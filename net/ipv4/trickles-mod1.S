
trickles-mod.o:     file format elf32-i386

Disassembly of section .text:

00000000 <htonl>:
       0:	8b 44 24 04          	mov    0x4(%esp,1),%eax
       4:	66 c1 c8 08          	ror    $0x8,%ax
       8:	c1 c8 10             	ror    $0x10,%eax
       b:	66 c1 c8 08          	ror    $0x8,%ax
       f:	c3                   	ret    

00000010 <htons>:
      10:	8b 44 24 04          	mov    0x4(%esp,1),%eax
      14:	25 ff ff 00 00       	and    $0xffff,%eax
      19:	66 c1 c8 08          	ror    $0x8,%ax
      1d:	c3                   	ret    
      1e:	90                   	nop    
      1f:	90                   	nop    

00000020 <free_trickles_msk>:
/* Two phase free: first phase disconnects socket from event list,
   sets to ALLOC_PROCESSING; second phase adds the socket to free
   list, sets to ALLOC_FREE and ready for reuse */
#ifndef USERTEST
static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk) {
      20:	55                   	push   %ebp
      21:	89 e5                	mov    %esp,%ebp
      23:	83 ec 0c             	sub    $0xc,%esp
      26:	89 5d fc             	mov    %ebx,0xfffffffc(%ebp)
	if(!SIMULATION_MODE(sk)) {
      29:	8b 45 08             	mov    0x8(%ebp),%eax
      2c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
      2f:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
      35:	a9 01 00 00 00       	test   $0x1,%eax
      3a:	74 05                	je     41 <free_trickles_msk+0x21>
      3c:	83 e0 08             	and    $0x8,%eax
      3f:	74 16                	je     57 <free_trickles_msk+0x37>
		if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) {
      41:	8b 43 0c             	mov    0xc(%ebx),%eax
      44:	85 c0                	test   %eax,%eax
      46:	74 48                	je     90 <free_trickles_msk+0x70>
      48:	83 f8 03             	cmp    $0x3,%eax
      4b:	74 43                	je     90 <free_trickles_msk+0x70>
			printk("double free\n");
			BUG();
		}
		if(msk->ctl == ALLOC_READY && msk->prev != NULL) {
      4d:	48                   	dec    %eax
      4e:	74 10                	je     60 <free_trickles_msk+0x40>
			unlink((struct alloc_head *)msk);
		}
		msk->ctl = ALLOC_PROCESSING;
      50:	c7 43 0c 03 00 00 00 	movl   $0x3,0xc(%ebx)
	}
}
      57:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
      5a:	89 ec                	mov    %ebp,%esp
      5c:	5d                   	pop    %ebp
      5d:	c3                   	ret    
      5e:	89 f6                	mov    %esi,%esi
      60:	8b 03                	mov    (%ebx),%eax
      62:	85 c0                	test   %eax,%eax
      64:	74 ea                	je     50 <free_trickles_msk+0x30>
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
      66:	8b 53 04             	mov    0x4(%ebx),%edx
      69:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
      6b:	8b 03                	mov    (%ebx),%eax
	elem->prev = elem->next = NULL;
      6d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      73:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
      76:	8b 43 08             	mov    0x8(%ebx),%eax
      79:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
      80:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
      83:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
      8a:	eb c4                	jmp    50 <free_trickles_msk+0x30>
      8c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
#ifndef USERTEST
static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk) {
	if(!SIMULATION_MODE(sk)) {
		if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) {
			printk("double free\n");
      90:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
      97:	e8 fc ff ff ff       	call   98 <free_trickles_msk+0x78>
			BUG();
      9c:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
      a3:	00 
      a4:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
      ab:	e8 fc ff ff ff       	call   ac <free_trickles_msk+0x8c>
      b0:	e8 fc ff ff ff       	call   b1 <free_trickles_msk+0x91>
      b5:	8b 43 0c             	mov    0xc(%ebx),%eax
      b8:	eb 93                	jmp    4d <free_trickles_msk+0x2d>
      ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

000000c0 <free_trickles_msk_finish>:
		}
		if(msk->ctl == ALLOC_READY && msk->prev != NULL) {
			unlink((struct alloc_head *)msk);
		}
		msk->ctl = ALLOC_PROCESSING;
	}
}

static inline void free_trickles_msk_finish(struct sock *sk, struct cminisock *msk) {
      c0:	55                   	push   %ebp
      c1:	89 e5                	mov    %esp,%ebp
      c3:	57                   	push   %edi
      c4:	56                   	push   %esi
      c5:	31 f6                	xor    %esi,%esi
      c7:	53                   	push   %ebx
      c8:	83 ec 10             	sub    $0x10,%esp
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
      cb:	8b 45 08             	mov    0x8(%ebp),%eax
	struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
      ce:	8b 55 08             	mov    0x8(%ebp),%edx
      d1:	8b 7d 0c             	mov    0xc(%ebp),%edi
      d4:	05 bc 00 00 00       	add    $0xbc,%eax
      d9:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
      dc:	81 c2 90 02 00 00    	add    $0x290,%edx
      e2:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
      e5:	8b 97 dc 00 00 00    	mov    0xdc(%edi),%edx
      eb:	39 d6                	cmp    %edx,%esi
      ed:	7d 2b                	jge    11a <free_trickles_msk_finish+0x5a>
      ef:	31 db                	xor    %ebx,%ebx
      f1:	eb 0d                	jmp    100 <free_trickles_msk_finish+0x40>
      f3:	90                   	nop    
      f4:	90                   	nop    
      f5:	90                   	nop    
      f6:	90                   	nop    
      f7:	90                   	nop    
      f8:	90                   	nop    
      f9:	90                   	nop    
      fa:	90                   	nop    
      fb:	90                   	nop    
      fc:	90                   	nop    
      fd:	90                   	nop    
      fe:	90                   	nop    
      ff:	90                   	nop    
     100:	8b 87 e0 00 00 00    	mov    0xe0(%edi),%eax
     106:	8b 44 18 18          	mov    0x18(%eax,%ebx,1),%eax
     10a:	85 c0                	test   %eax,%eax
     10c:	0f 85 6e 01 00 00    	jne    280 <free_trickles_msk_finish+0x1c0>
     112:	46                   	inc    %esi
     113:	83 c3 28             	add    $0x28,%ebx
     116:	39 d6                	cmp    %edx,%esi
     118:	7c e6                	jl     100 <free_trickles_msk_finish+0x40>
     11a:	8b 55 08             	mov    0x8(%ebp),%edx
     11d:	8b 82 a8 02 00 00    	mov    0x2a8(%edx),%eax
     123:	a9 01 00 00 00       	test   $0x1,%eax
     128:	74 05                	je     12f <free_trickles_msk_finish+0x6f>
     12a:	83 e0 08             	and    $0x8,%eax
     12d:	74 0e                	je     13d <free_trickles_msk_finish+0x7d>
     12f:	8b 87 e0 00 00 00    	mov    0xe0(%edi),%eax
     135:	85 c0                	test   %eax,%eax
     137:	0f 85 2d 01 00 00    	jne    26a <free_trickles_msk_finish+0x1aa>
     13d:	8b 87 80 00 00 00    	mov    0x80(%edi),%eax
     143:	85 c0                	test   %eax,%eax
     145:	0f 85 0b 01 00 00    	jne    256 <free_trickles_msk_finish+0x196>
     14b:	8b 87 88 00 00 00    	mov    0x88(%edi),%eax
     151:	85 c0                	test   %eax,%eax
     153:	0f 85 e9 00 00 00    	jne    242 <free_trickles_msk_finish+0x182>

	free_minisock(sk,msk);
	if(!SIMULATION_MODE(sk)) {
     159:	8b 55 08             	mov    0x8(%ebp),%edx
     15c:	8b 82 a8 02 00 00    	mov    0x2a8(%edx),%eax
     162:	a9 01 00 00 00       	test   $0x1,%eax
     167:	74 09                	je     172 <free_trickles_msk_finish+0xb2>
     169:	83 e0 08             	and    $0x8,%eax
     16c:	0f 84 89 00 00 00    	je     1fb <free_trickles_msk_finish+0x13b>
		if(msk->ctl != ALLOC_PROCESSING && msk->ctl != ALLOC_HALFFREE) {
     172:	8b 47 0c             	mov    0xc(%edi),%eax
     175:	83 e8 03             	sub    $0x3,%eax
     178:	83 f8 01             	cmp    $0x1,%eax
     17b:	77 57                	ja     1d4 <free_trickles_msk_finish+0x114>
	if(elem->list) {
		BUG();
	}
#endif
	if(head->next == elem /* || elem->prev != NULL || elem->next != NULL */) {
     17d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
     180:	39 78 04             	cmp    %edi,0x4(%eax)
     183:	74 28                	je     1ad <free_trickles_msk_finish+0xed>
		BUG();
		show_stack(NULL);	
	}
	elem->next = head->next;
     185:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
     188:	8b 42 04             	mov    0x4(%edx),%eax
     18b:	89 47 04             	mov    %eax,0x4(%edi)
	head->next->prev = elem;
     18e:	8b 42 04             	mov    0x4(%edx),%eax
     191:	89 38                	mov    %edi,(%eax)

	elem->prev = (struct alloc_head*)head;
     193:	89 17                	mov    %edx,(%edi)
	head->next = elem;
     195:	89 7a 04             	mov    %edi,0x4(%edx)

	elem->list = head;
     198:	89 57 08             	mov    %edx,0x8(%edi)
	head->len++;
     19b:	ff 42 10             	incl   0x10(%edx)
			printk("free_rstcp_msk_finish without corresponding free_rstcp_msk\n");
			BUG();
		}
		insert_head(head, (struct alloc_head *)msk);
		msk->ctl = ALLOC_FREE;
     19e:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
	} else {
		if(msk == tp->t.responseMSK) {
		} else {
			// overflow
			unlink((struct alloc_head*)msk);
			kfree(msk);
		}
		tp->t.responseCount--;
	}
	
}
     1a5:	83 c4 10             	add    $0x10,%esp
     1a8:	5b                   	pop    %ebx
     1a9:	5e                   	pop    %esi
     1aa:	5f                   	pop    %edi
     1ab:	5d                   	pop    %ebp
     1ac:	c3                   	ret    
		BUG();
	}
#endif
	if(head->next == elem /* || elem->prev != NULL || elem->next != NULL */) {
		BUG();
     1ad:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
     1b4:	00 
     1b5:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
     1bc:	e8 fc ff ff ff       	call   1bd <free_trickles_msk_finish+0xfd>
     1c1:	e8 fc ff ff ff       	call   1c2 <free_trickles_msk_finish+0x102>
		show_stack(NULL);	
     1c6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
     1cd:	e8 fc ff ff ff       	call   1ce <free_trickles_msk_finish+0x10e>
     1d2:	eb b1                	jmp    185 <free_trickles_msk_finish+0xc5>

	free_minisock(sk,msk);
	if(!SIMULATION_MODE(sk)) {
		if(msk->ctl != ALLOC_PROCESSING && msk->ctl != ALLOC_HALFFREE) {
			printk("free_rstcp_msk_finish without corresponding free_rstcp_msk\n");
     1d4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
     1db:	e8 fc ff ff ff       	call   1dc <free_trickles_msk_finish+0x11c>
			BUG();
     1e0:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
     1e7:	00 
     1e8:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
     1ef:	e8 fc ff ff ff       	call   1f0 <free_trickles_msk_finish+0x130>
     1f4:	e8 fc ff ff ff       	call   1f5 <free_trickles_msk_finish+0x135>
     1f9:	eb 82                	jmp    17d <free_trickles_msk_finish+0xbd>
		}
		insert_head(head, (struct alloc_head *)msk);
		msk->ctl = ALLOC_FREE;
	} else {
		if(msk == tp->t.responseMSK) {
     1fb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
     1fe:	3b b8 3c 0b 00 00    	cmp    0xb3c(%eax),%edi
     204:	74 2e                	je     234 <free_trickles_msk_finish+0x174>
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
     206:	8b 57 04             	mov    0x4(%edi),%edx
     209:	8b 07                	mov    (%edi),%eax
     20b:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
     20d:	8b 07                	mov    (%edi),%eax
	elem->prev = elem->next = NULL;
     20f:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
     215:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
     218:	8b 47 08             	mov    0x8(%edi),%eax
     21b:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
     222:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
     225:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
		if(msk == tp->t.responseMSK) {
		} else {
			// overflow
			unlink((struct alloc_head*)msk);
			kfree(msk);
     22c:	89 3c 24             	mov    %edi,(%esp,1)
     22f:	e8 fc ff ff ff       	call   230 <free_trickles_msk_finish+0x170>
		}
		tp->t.responseCount--;
     234:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
     237:	ff 8a 54 0b 00 00    	decl   0xb54(%edx)
     23d:	e9 63 ff ff ff       	jmp    1a5 <free_trickles_msk_finish+0xe5>
     242:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     246:	8b 45 08             	mov    0x8(%ebp),%eax
     249:	89 04 24             	mov    %eax,(%esp,1)
     24c:	e8 fc ff ff ff       	call   24d <free_trickles_msk_finish+0x18d>
     251:	e9 03 ff ff ff       	jmp    159 <free_trickles_msk_finish+0x99>
     256:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     25a:	8b 55 08             	mov    0x8(%ebp),%edx
     25d:	89 14 24             	mov    %edx,(%esp,1)
     260:	e8 fc ff ff ff       	call   261 <free_trickles_msk_finish+0x1a1>
     265:	e9 e1 fe ff ff       	jmp    14b <free_trickles_msk_finish+0x8b>
     26a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     26e:	8b 45 08             	mov    0x8(%ebp),%eax
     271:	89 04 24             	mov    %eax,(%esp,1)
     274:	e8 fc ff ff ff       	call   275 <free_trickles_msk_finish+0x1b5>
     279:	e9 bf fe ff ff       	jmp    13d <free_trickles_msk_finish+0x7d>
     27e:	89 f6                	mov    %esi,%esi
     280:	89 04 24             	mov    %eax,(%esp,1)
     283:	e8 fc ff ff ff       	call   284 <free_trickles_msk_finish+0x1c4>
     288:	8b 97 dc 00 00 00    	mov    0xdc(%edi),%edx
     28e:	e9 7f fe ff ff       	jmp    112 <free_trickles_msk_finish+0x52>
     293:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     299:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

000002a0 <unmarshallContinuationServer>:
  do{					\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
     2a0:	55                   	push   %ebp
     2a1:	89 e5                	mov    %esp,%ebp
     2a3:	31 d2                	xor    %edx,%edx
     2a5:	57                   	push   %edi
     2a6:	56                   	push   %esi
     2a7:	53                   	push   %ebx
     2a8:	83 ec 40             	sub    $0x40,%esp
     2ab:	8b 45 08             	mov    0x8(%ebp),%eax
     2ae:	8b 58 0c             	mov    0xc(%eax),%ebx
     2b1:	8b 83 a8 02 00 00    	mov    0x2a8(%ebx),%eax
     2b7:	a9 01 00 00 00       	test   $0x1,%eax
     2bc:	74 05                	je     2c3 <unmarshallContinuationServer+0x23>
     2be:	83 e0 08             	and    $0x8,%eax
     2c1:	74 05                	je     2c8 <unmarshallContinuationServer+0x28>
     2c3:	ba 01 00 00 00       	mov    $0x1,%edx
     2c8:	85 d2                	test   %edx,%edx
     2ca:	0f 85 03 01 00 00    	jne    3d3 <unmarshallContinuationServer+0x133>
     2d0:	8b 55 10             	mov    0x10(%ebp),%edx
     2d3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
     2d6:	0f b6 02             	movzbl (%edx),%eax
     2d9:	89 41 38             	mov    %eax,0x38(%ecx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     2dc:	8b 42 01             	mov    0x1(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
     2df:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     2e1:	89 41 34             	mov    %eax,0x34(%ecx)
  do{					\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
     2e4:	8b 42 09             	mov    0x9(%edx),%eax
     2e7:	89 41 3c             	mov    %eax,0x3c(%ecx)
     2ea:	8b 42 0d             	mov    0xd(%edx),%eax
     2ed:	89 41 40             	mov    %eax,0x40(%ecx)
     2f0:	8b 42 25             	mov    0x25(%edx),%eax
     2f3:	89 41 44             	mov    %eax,0x44(%ecx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     2f6:	8b 42 25             	mov    0x25(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
     2f9:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     2fb:	89 41 4c             	mov    %eax,0x4c(%ecx)
  do{					\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
     2fe:	8b 42 11             	mov    0x11(%edx),%eax
     301:	89 41 50             	mov    %eax,0x50(%ecx)
     304:	8b 42 29             	mov    0x29(%edx),%eax
     307:	89 41 48             	mov    %eax,0x48(%ecx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     30a:	8b 42 29             	mov    0x29(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
     30d:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     30f:	89 41 54             	mov    %eax,0x54(%ecx)
  do{					\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
     312:	0f b6 42 2d          	movzbl 0x2d(%edx),%eax
     316:	89 41 58             	mov    %eax,0x58(%ecx)
     319:	0f b6 42 05          	movzbl 0x5(%edx),%eax
     31d:	89 41 5c             	mov    %eax,0x5c(%ecx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     320:	8b 42 2e             	mov    0x2e(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
     323:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     325:	89 41 60             	mov    %eax,0x60(%ecx)
     328:	8b 42 32             	mov    0x32(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
     32b:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     32d:	89 41 64             	mov    %eax,0x64(%ecx)
     330:	8b 42 36             	mov    0x36(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
     333:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     335:	89 41 68             	mov    %eax,0x68(%ecx)
     338:	8b 42 3a             	mov    0x3a(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
     33b:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     33d:	89 41 6c             	mov    %eax,0x6c(%ecx)
     340:	8b 42 3e             	mov    0x3e(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
     343:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     345:	89 41 70             	mov    %eax,0x70(%ecx)
  do{					\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
     348:	31 d2                	xor    %edx,%edx
     34a:	8b 75 08             	mov    0x8(%ebp),%esi
     34d:	8b 46 0c             	mov    0xc(%esi),%eax
     350:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
     356:	a9 01 00 00 00       	test   $0x1,%eax
     35b:	74 05                	je     362 <unmarshallContinuationServer+0xc2>
     35d:	83 e0 08             	and    $0x8,%eax
     360:	74 05                	je     367 <unmarshallContinuationServer+0xc7>
     362:	ba 01 00 00 00       	mov    $0x1,%edx
     367:	85 d2                	test   %edx,%edx
     369:	75 39                	jne    3a4 <unmarshallContinuationServer+0x104>
     36b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
     36e:	31 db                	xor    %ebx,%ebx
     370:	89 99 dc 00 00 00    	mov    %ebx,0xdc(%ecx)
     376:	8b 75 10             	mov    0x10(%ebp),%esi
     379:	8b 46 42             	mov    0x42(%esi),%eax
     37c:	8b 56 46             	mov    0x46(%esi),%edx
     37f:	89 41 74             	mov    %eax,0x74(%ecx)
     382:	31 c0                	xor    %eax,%eax
     384:	89 51 78             	mov    %edx,0x78(%ecx)
     387:	31 d2                	xor    %edx,%edx
     389:	89 91 c0 00 00 00    	mov    %edx,0xc0(%ecx)
     38f:	89 81 c4 00 00 00    	mov    %eax,0xc4(%ecx)
     395:	b9 01 00 00 00       	mov    $0x1,%ecx
     39a:	83 c4 40             	add    $0x40,%esp
     39d:	89 c8                	mov    %ecx,%eax
     39f:	5b                   	pop    %ebx
     3a0:	5e                   	pop    %esi
     3a1:	5f                   	pop    %edi
     3a2:	5d                   	pop    %ebp
     3a3:	c3                   	ret    
     3a4:	8b 7d 08             	mov    0x8(%ebp),%edi
     3a7:	8b 55 0c             	mov    0xc(%ebp),%edx
     3aa:	8b 47 24             	mov    0x24(%edi),%eax
     3ad:	8b 40 10             	mov    0x10(%eax),%eax
     3b0:	89 42 14             	mov    %eax,0x14(%edx)
     3b3:	8b 47 24             	mov    0x24(%edi),%eax
     3b6:	8b 40 0c             	mov    0xc(%eax),%eax
     3b9:	89 42 18             	mov    %eax,0x18(%edx)
     3bc:	8b 47 20             	mov    0x20(%edi),%eax
     3bf:	0f b7 40 02          	movzwl 0x2(%eax),%eax
     3c3:	66 89 42 1c          	mov    %ax,0x1c(%edx)
     3c7:	8b 47 20             	mov    0x20(%edi),%eax
     3ca:	0f b7 00             	movzwl (%eax),%eax
     3cd:	66 89 42 1e          	mov    %ax,0x1e(%edx)
     3d1:	eb 98                	jmp    36b <unmarshallContinuationServer+0xcb>
     3d3:	8b 55 10             	mov    0x10(%ebp),%edx
     3d6:	8d 7d e4             	lea    0xffffffe4(%ebp),%edi
     3d9:	8b 75 08             	mov    0x8(%ebp),%esi
     3dc:	8b 42 01             	mov    0x1(%edx),%eax
     3df:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
     3e2:	0f b6 02             	movzbl (%edx),%eax
     3e5:	88 45 c8             	mov    %al,0xffffffc8(%ebp)
     3e8:	0f b6 42 05          	movzbl 0x5(%edx),%eax
     3ec:	88 45 c9             	mov    %al,0xffffffc9(%ebp)
     3ef:	8b 4e 24             	mov    0x24(%esi),%ecx
     3f2:	8b 41 10             	mov    0x10(%ecx),%eax
     3f5:	89 45 ca             	mov    %eax,0xffffffca(%ebp)
     3f8:	8b 56 20             	mov    0x20(%esi),%edx
     3fb:	89 fe                	mov    %edi,%esi
     3fd:	0f b7 42 02          	movzwl 0x2(%edx),%eax
     401:	66 89 45 ce          	mov    %ax,0xffffffce(%ebp)
     405:	8b 41 0c             	mov    0xc(%ecx),%eax
     408:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
     40b:	0f b7 02             	movzwl (%edx),%eax
     40e:	8d 55 c4             	lea    0xffffffc4(%ebp),%edx
     411:	89 7c 24 0c          	mov    %edi,0xc(%esp,1)
     415:	89 54 24 04          	mov    %edx,0x4(%esp,1)
     419:	89 1c 24             	mov    %ebx,(%esp,1)
     41c:	66 89 45 d4          	mov    %ax,0xffffffd4(%ebp)
     420:	8b 45 10             	mov    0x10(%ebp),%eax
     423:	89 44 24 08          	mov    %eax,0x8(%esp,1)
     427:	e8 fc ff ff ff       	call   428 <unmarshallContinuationServer+0x188>
     42c:	8b 45 10             	mov    0x10(%ebp),%eax
     42f:	b9 10 00 00 00       	mov    $0x10,%ecx
     434:	fc                   	cld    
     435:	83 c0 15             	add    $0x15,%eax
     438:	89 c7                	mov    %eax,%edi
     43a:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
     43c:	0f 97 c2             	seta   %dl
     43f:	0f 92 c0             	setb   %al
     442:	31 c9                	xor    %ecx,%ecx
     444:	38 c2                	cmp    %al,%dl
     446:	0f 85 4e ff ff ff    	jne    39a <unmarshallContinuationServer+0xfa>
     44c:	e9 7f fe ff ff       	jmp    2d0 <unmarshallContinuationServer+0x30>
     451:	eb 0d                	jmp    460 <unmarshallContinuationClient>
     453:	90                   	nop    
     454:	90                   	nop    
     455:	90                   	nop    
     456:	90                   	nop    
     457:	90                   	nop    
     458:	90                   	nop    
     459:	90                   	nop    
     45a:	90                   	nop    
     45b:	90                   	nop    
     45c:	90                   	nop    
     45d:	90                   	nop    
     45e:	90                   	nop    
     45f:	90                   	nop    

00000460 <unmarshallContinuationClient>:
UNMARSHALL_CONTINUATION(Client, CLIENT_COMPUTE_MAC);
     460:	55                   	push   %ebp
     461:	89 e5                	mov    %esp,%ebp
     463:	57                   	push   %edi
     464:	56                   	push   %esi
     465:	53                   	push   %ebx
     466:	83 ec 0c             	sub    $0xc,%esp
     469:	8b 75 10             	mov    0x10(%ebp),%esi
     46c:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp,1)
     473:	00 
     474:	8b 5d 0c             	mov    0xc(%ebp),%ebx
     477:	8b 7d 08             	mov    0x8(%ebp),%edi
     47a:	8d 46 15             	lea    0x15(%esi),%eax
     47d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     481:	8d 83 8c 00 00 00    	lea    0x8c(%ebx),%eax
     487:	89 04 24             	mov    %eax,(%esp,1)
     48a:	e8 e1 7d 00 00       	call   8270 <__constant_memcpy>
     48f:	0f b6 06             	movzbl (%esi),%eax
     492:	31 d2                	xor    %edx,%edx
     494:	89 43 38             	mov    %eax,0x38(%ebx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     497:	8b 46 01             	mov    0x1(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
     49a:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     49c:	89 43 34             	mov    %eax,0x34(%ebx)
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
UNMARSHALL_CONTINUATION(Client, CLIENT_COMPUTE_MAC);
     49f:	8b 46 09             	mov    0x9(%esi),%eax
     4a2:	89 43 3c             	mov    %eax,0x3c(%ebx)
     4a5:	8b 46 0d             	mov    0xd(%esi),%eax
     4a8:	89 43 40             	mov    %eax,0x40(%ebx)
     4ab:	8b 46 25             	mov    0x25(%esi),%eax
     4ae:	89 43 44             	mov    %eax,0x44(%ebx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     4b1:	8b 46 25             	mov    0x25(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
     4b4:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     4b6:	89 43 4c             	mov    %eax,0x4c(%ebx)
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
UNMARSHALL_CONTINUATION(Client, CLIENT_COMPUTE_MAC);
     4b9:	8b 46 11             	mov    0x11(%esi),%eax
     4bc:	89 43 50             	mov    %eax,0x50(%ebx)
     4bf:	8b 46 29             	mov    0x29(%esi),%eax
     4c2:	89 43 48             	mov    %eax,0x48(%ebx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     4c5:	8b 46 29             	mov    0x29(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
     4c8:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     4ca:	89 43 54             	mov    %eax,0x54(%ebx)
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
UNMARSHALL_CONTINUATION(Client, CLIENT_COMPUTE_MAC);
     4cd:	0f b6 46 2d          	movzbl 0x2d(%esi),%eax
     4d1:	89 43 58             	mov    %eax,0x58(%ebx)
     4d4:	0f b6 46 05          	movzbl 0x5(%esi),%eax
     4d8:	89 43 5c             	mov    %eax,0x5c(%ebx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     4db:	8b 46 2e             	mov    0x2e(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
     4de:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     4e0:	89 43 60             	mov    %eax,0x60(%ebx)
     4e3:	8b 46 32             	mov    0x32(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
     4e6:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     4e8:	89 43 64             	mov    %eax,0x64(%ebx)
     4eb:	8b 46 36             	mov    0x36(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
     4ee:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     4f0:	89 43 68             	mov    %eax,0x68(%ebx)
     4f3:	8b 46 3a             	mov    0x3a(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
     4f6:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     4f8:	89 43 6c             	mov    %eax,0x6c(%ebx)
     4fb:	8b 46 3e             	mov    0x3e(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
     4fe:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
     500:	89 43 70             	mov    %eax,0x70(%ebx)
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
UNMARSHALL_CONTINUATION(Client, CLIENT_COMPUTE_MAC);
     503:	8b 47 0c             	mov    0xc(%edi),%eax
     506:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
     50c:	a9 01 00 00 00       	test   $0x1,%eax
     511:	74 05                	je     518 <unmarshallContinuationClient+0xb8>
     513:	83 e0 08             	and    $0x8,%eax
     516:	74 05                	je     51d <unmarshallContinuationClient+0xbd>
     518:	ba 01 00 00 00       	mov    $0x1,%edx
     51d:	85 d2                	test   %edx,%edx
     51f:	75 31                	jne    552 <unmarshallContinuationClient+0xf2>
     521:	31 c0                	xor    %eax,%eax
     523:	31 ff                	xor    %edi,%edi
     525:	89 83 dc 00 00 00    	mov    %eax,0xdc(%ebx)
     52b:	8b 46 42             	mov    0x42(%esi),%eax
     52e:	8b 56 46             	mov    0x46(%esi),%edx
     531:	31 f6                	xor    %esi,%esi
     533:	89 bb c0 00 00 00    	mov    %edi,0xc0(%ebx)
     539:	89 b3 c4 00 00 00    	mov    %esi,0xc4(%ebx)
     53f:	89 43 74             	mov    %eax,0x74(%ebx)
     542:	b8 01 00 00 00       	mov    $0x1,%eax
     547:	89 53 78             	mov    %edx,0x78(%ebx)
     54a:	83 c4 0c             	add    $0xc,%esp
     54d:	5b                   	pop    %ebx
     54e:	5e                   	pop    %esi
     54f:	5f                   	pop    %edi
     550:	5d                   	pop    %ebp
     551:	c3                   	ret    
     552:	8b 47 24             	mov    0x24(%edi),%eax
     555:	8b 40 10             	mov    0x10(%eax),%eax
     558:	89 43 14             	mov    %eax,0x14(%ebx)
     55b:	8b 47 24             	mov    0x24(%edi),%eax
     55e:	8b 40 0c             	mov    0xc(%eax),%eax
     561:	89 43 18             	mov    %eax,0x18(%ebx)
     564:	8b 47 20             	mov    0x20(%edi),%eax
     567:	0f b7 40 02          	movzwl 0x2(%eax),%eax
     56b:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
     56f:	8b 47 20             	mov    0x20(%edi),%eax
     572:	0f b7 00             	movzwl (%eax),%eax
     575:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
     579:	eb a6                	jmp    521 <unmarshallContinuationClient+0xc1>
     57b:	90                   	nop    
     57c:	8d 74 26 00          	lea    0x0(%esi,1),%esi

00000580 <kmalloc_ConversionRequest>:
static int numConversionRequests = 0;

static int sendAckHelper(struct sock *sk, CONTINUATION_TYPE *cont, enum TrickleRequestType type);

struct ConversionRequest *kmalloc_ConversionRequest(int gfp) {
     580:	55                   	push   %ebp
     581:	89 e5                	mov    %esp,%ebp
     583:	83 ec 08             	sub    $0x8,%esp
	numConversionRequests++;
	return kmalloc(sizeof(struct ConversionRequest), gfp);
     586:	c7 04 24 68 00 00 00 	movl   $0x68,(%esp,1)
     58d:	8b 45 08             	mov    0x8(%ebp),%eax
     590:	ff 05 48 00 00 00    	incl   0x48
     596:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     59a:	e8 fc ff ff ff       	call   59b <kmalloc_ConversionRequest+0x1b>
}
     59f:	89 ec                	mov    %ebp,%esp
     5a1:	5d                   	pop    %ebp
     5a2:	c3                   	ret    
     5a3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     5a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

000005b0 <kmalloc_ContinuationRequest>:

int numContinuationRequests = 0;

struct ContinuationRequest *kmalloc_ContinuationRequest(int gfp) {
     5b0:	55                   	push   %ebp
     5b1:	89 e5                	mov    %esp,%ebp
     5b3:	83 ec 08             	sub    $0x8,%esp
	numContinuationRequests++;
	return kmalloc(sizeof(struct ContinuationRequest), gfp);
     5b6:	c7 04 24 5c 00 00 00 	movl   $0x5c,(%esp,1)
     5bd:	8b 45 08             	mov    0x8(%ebp),%eax
     5c0:	ff 05 00 00 00 00    	incl   0x0
     5c6:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     5ca:	e8 fc ff ff ff       	call   5cb <kmalloc_ContinuationRequest+0x1b>
}
     5cf:	89 ec                	mov    %ebp,%esp
     5d1:	5d                   	pop    %ebp
     5d2:	c3                   	ret    
     5d3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     5d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

000005e0 <trickles_add_clientsock>:

#ifdef USE_FLOATINGPOINT
// FSAVE/FRESTORE areas to support use of FPU in bottom half
static char fpu_user_save[NR_CPUS][512];
static char fpu_kernel_save[NR_CPUS][512];

// Based on code from asm-i386/xor.h
#define FPU_SAVE(X)							\
  do {									\
	if (!(current->flags & PF_USEDFPU)) {				\
		__asm__ __volatile__ (" clts;\n");			\
	} else 								\
  		__asm__ __volatile__ ("fsave %0; fwait": "=m"((X)[0]));	\
  } while (0)

#define FPU_RESTORE(X)							\
  do {									\
	if (!(current->flags & PF_USEDFPU)) {				\
		stts();							\
	} else 								\
		__asm__ __volatile__ ("frstor %0": : "m"((X)[0]));	\
  } while (0)
#endif // USE_FLOATINGPOINT

#ifndef USERTEST
struct proto trickles_client_prot;

spinlock_t trickles_sockets_head_lock = SPIN_LOCK_UNLOCKED;
struct sock trickles_sockets_head;

void trickles_add_clientsock(struct sock *sk) {
     5e0:	55                   	push   %ebp
     5e1:	89 e5                	mov    %esp,%ebp
     5e3:	8b 4d 08             	mov    0x8(%ebp),%ecx
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	struct tcp_opt *htp = &trickles_sockets_head.tp_pinfo.af_tcp;
	spin_lock(&trickles_sockets_head_lock);
	tp->t.dnext = htp->t.dnext;
     5e6:	a1 d0 0a 00 00       	mov    0xad0,%eax
     5eb:	8d 91 bc 00 00 00    	lea    0xbc(%ecx),%edx
     5f1:	89 82 14 0a 00 00    	mov    %eax,0xa14(%edx)
	htp->t.dnext = sk;
	tp->t.dprev = &trickles_sockets_head;
     5f7:	b8 00 00 00 00       	mov    $0x0,%eax
     5fc:	89 0d d0 0a 00 00    	mov    %ecx,0xad0
     602:	89 82 10 0a 00 00    	mov    %eax,0xa10(%edx)
	tp->t.dnext->tp_pinfo.af_tcp.t.dprev = sk;
     608:	8b 82 14 0a 00 00    	mov    0xa14(%edx),%eax
     60e:	89 88 cc 0a 00 00    	mov    %ecx,0xacc(%eax)
	spin_unlock(&trickles_sockets_head_lock);
}
     614:	5d                   	pop    %ebp
     615:	c3                   	ret    
     616:	8d 76 00             	lea    0x0(%esi),%esi
     619:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00000620 <trickles_del_clientsock>:

void trickles_del_clientsock(struct sock *sk) {
     620:	55                   	push   %ebp
     621:	89 e5                	mov    %esp,%ebp
     623:	83 ec 10             	sub    $0x10,%esp
     626:	89 75 fc             	mov    %esi,0xfffffffc(%ebp)
     629:	8b 75 08             	mov    0x8(%ebp),%esi
     62c:	89 5d f8             	mov    %ebx,0xfffffff8(%ebp)
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
     62f:	8d 9e bc 00 00 00    	lea    0xbc(%esi),%ebx
	if(tp->t.dprev == NULL) {
     635:	8b 83 10 0a 00 00    	mov    0xa10(%ebx),%eax
     63b:	85 c0                	test   %eax,%eax
     63d:	75 37                	jne    676 <trickles_del_clientsock+0x56>
		BUG_TRAP(tp->t.dnext != NULL);
     63f:	8b 83 14 0a 00 00    	mov    0xa14(%ebx),%eax
     645:	85 c0                	test   %eax,%eax
     647:	74 17                	je     660 <trickles_del_clientsock+0x40>
		printk("Socket not on clientsock list\n");
     649:	c7 45 08 40 00 00 00 	movl   $0x40,0x8(%ebp)
     650:	8b 5d f8             	mov    0xfffffff8(%ebp),%ebx
     653:	8b 75 fc             	mov    0xfffffffc(%ebp),%esi
     656:	89 ec                	mov    %ebp,%esp
     658:	5d                   	pop    %ebp
     659:	e9 fc ff ff ff       	jmp    65a <trickles_del_clientsock+0x3a>
     65e:	89 f6                	mov    %esi,%esi
     660:	c7 44 24 04 d6 00 00 	movl   $0xd6,0x4(%esp,1)
     667:	00 
     668:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp,1)
     66f:	e8 fc ff ff ff       	call   670 <trickles_del_clientsock+0x50>
     674:	eb d3                	jmp    649 <trickles_del_clientsock+0x29>
		return;
	}
	spin_lock(&trickles_sockets_head_lock);
	BUG_TRAP(tp->t.dprev->tp_pinfo.af_tcp.t.dnext == sk);
     676:	39 b0 d0 0a 00 00    	cmp    %esi,0xad0(%eax)
     67c:	74 14                	je     692 <trickles_del_clientsock+0x72>
     67e:	c7 44 24 04 db 00 00 	movl   $0xdb,0x4(%esp,1)
     685:	00 
     686:	c7 04 24 c0 00 00 00 	movl   $0xc0,(%esp,1)
     68d:	e8 fc ff ff ff       	call   68e <trickles_del_clientsock+0x6e>
	BUG_TRAP(tp->t.dnext->tp_pinfo.af_tcp.t.dprev == sk);
     692:	8b 83 14 0a 00 00    	mov    0xa14(%ebx),%eax
     698:	39 b0 cc 0a 00 00    	cmp    %esi,0xacc(%eax)
     69e:	74 1a                	je     6ba <trickles_del_clientsock+0x9a>
     6a0:	c7 44 24 04 dc 00 00 	movl   $0xdc,0x4(%esp,1)
     6a7:	00 
     6a8:	c7 04 24 20 01 00 00 	movl   $0x120,(%esp,1)
     6af:	e8 fc ff ff ff       	call   6b0 <trickles_del_clientsock+0x90>
     6b4:	8b 83 14 0a 00 00    	mov    0xa14(%ebx),%eax
	tp->t.dprev->tp_pinfo.af_tcp.t.dnext = tp->t.dnext;
     6ba:	8b 93 10 0a 00 00    	mov    0xa10(%ebx),%edx
     6c0:	89 82 d0 0a 00 00    	mov    %eax,0xad0(%edx)
	tp->t.dnext->tp_pinfo.af_tcp.t.dprev = tp->t.dprev;
     6c6:	8b 83 14 0a 00 00    	mov    0xa14(%ebx),%eax
     6cc:	89 90 cc 0a 00 00    	mov    %edx,0xacc(%eax)

	tp->t.dprev = tp->t.dnext = NULL;
     6d2:	31 c0                	xor    %eax,%eax
     6d4:	89 83 14 0a 00 00    	mov    %eax,0xa14(%ebx)
     6da:	31 c0                	xor    %eax,%eax
     6dc:	89 83 10 0a 00 00    	mov    %eax,0xa10(%ebx)
	spin_unlock(&trickles_sockets_head_lock);
}
     6e2:	8b 5d f8             	mov    0xfffffff8(%ebp),%ebx
     6e5:	8b 75 fc             	mov    0xfffffffc(%ebp),%esi
     6e8:	89 ec                	mov    %ebp,%esp
     6ea:	5d                   	pop    %ebp
     6eb:	c3                   	ret    
     6ec:	8d 74 26 00          	lea    0x0(%esi,1),%esi

000006f0 <hmac_setup>:
#endif

#define SKB_CONTAINS(SKB, SEQ) \
	((TCP_SKB_CB(SKB)->seq <= (SEQ)) && (TCP_SKB_CB(SKB)->end_seq > (SEQ)))

static inline void *kmalloc_dup(void *src, int len, unsigned gfp) {
	char *ptr = kmalloc(len, gfp);
	if(ptr == NULL) {
		printk("out of memory in kmalloc_dup\n");
		return NULL;
	}
	memcpy(ptr, src, len);
	return ptr;
}

#define requestReleasedData(X) // XXX Deprecated!

/* Simple random number generator */

static unsigned long rand;

static inline unsigned char random(void) {
  /* See "Numerical Recipes in C", second edition, p. 284 */
  rand = rand * 1664525L + 1013904223L;
  return (unsigned char) (rand >> 24);
}

/*
 * Crypto support
 */

const int generateHMAC = 1;
const int generateNonces = 1;

// hack to give gcc more information about constants
#define generateHMAC (1)
#define generateNonces (1)


// Debugging control 
int enableDataRecovery = 1;
int serverDebugLevel = 0;
int debugDrops = 0;
int debugTransitions = 0;

#define PRINT_TRANSITION(SK, S)						\
({ struct sock *_sk = (SK);						\
   struct tcp_opt *_tp = &_sk->tp_pinfo.af_tcp;				\
   printk("%p: %s data rcv_nxt = %d t.rcv_nxt = %d\n", _sk, (S), _tp->rcv_nxt, _tp->t.rcv_nxt); })

int debugProofDrops = 1;
int clientDebugLevel = 0;
//#define SPEW_PARTIAL
int disableSevereErrors = 1;
int printOverlap = 0;
int disableTimeout = 0;

#ifdef OPENSSL_HMAC

void hmac_setup(HMAC_CTX *ctx, char *key, int len) {
     6f0:	55                   	push   %ebp
     6f1:	89 e5                	mov    %esp,%ebp
     6f3:	57                   	push   %edi
     6f4:	56                   	push   %esi
     6f5:	53                   	push   %ebx
     6f6:	83 ec 50             	sub    $0x50,%esp
     6f9:	8b 5d 10             	mov    0x10(%ebp),%ebx
     6fc:	8b 75 0c             	mov    0xc(%ebp),%esi
  BUG_TRAP(len <= HMAC_BLOCKSIZE);
     6ff:	83 fb 40             	cmp    $0x40,%ebx
     702:	0f 8f b7 00 00 00    	jg     7bf <hmac_setup+0xcf>
  memset(ctx->key, 0, HMAC_BLOCKSIZE);
     708:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp,1)
     70f:	00 
     710:	8b 45 08             	mov    0x8(%ebp),%eax
     713:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
     71a:	00 
     71b:	89 04 24             	mov    %eax,(%esp,1)
     71e:	e8 5d 7c 00 00       	call   8380 <__constant_c_and_count_memset>

static inline void * __memcpy(void * to, const void * from, size_t n)
{
int d0, d1, d2;
__asm__ __volatile__(
     723:	89 d9                	mov    %ebx,%ecx
     725:	8b 7d 08             	mov    0x8(%ebp),%edi
     728:	c1 e9 02             	shr    $0x2,%ecx
     72b:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
     72d:	f6 c3 02             	test   $0x2,%bl
     730:	74 02                	je     734 <hmac_setup+0x44>
     732:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
     734:	f6 c3 01             	test   $0x1,%bl
     737:	74 01                	je     73a <hmac_setup+0x4a>
     739:	a4                   	movsb  %ds:(%esi),%es:(%edi)
  memcpy(ctx->key, key, len);

  int i;
  char pad[HMAC_BLOCKSIZE];

  for (i=0; i<HMAC_BLOCKSIZE; i++)
     73a:	31 d2                	xor    %edx,%edx
     73c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    pad[i]=0x36^ctx->key[i];
     740:	8b 4d 08             	mov    0x8(%ebp),%ecx
     743:	0f b6 04 0a          	movzbl (%edx,%ecx,1),%eax
     747:	34 36                	xor    $0x36,%al
     749:	88 44 2a b4          	mov    %al,0xffffffb4(%edx,%ebp,1)
     74d:	42                   	inc    %edx
     74e:	83 fa 3f             	cmp    $0x3f,%edx
     751:	7e ed                	jle    740 <hmac_setup+0x50>
  DIGEST_Init(&ctx->in_ctx);
     753:	89 cb                	mov    %ecx,%ebx
     755:	83 c3 40             	add    $0x40,%ebx
  DIGEST_Update(&ctx->in_ctx, pad, HMAC_BLOCKSIZE);
     758:	8d 75 b4             	lea    0xffffffb4(%ebp),%esi
     75b:	89 1c 24             	mov    %ebx,(%esp,1)
     75e:	e8 fc ff ff ff       	call   75f <hmac_setup+0x6f>
     763:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp,1)
     76a:	00 
     76b:	89 74 24 04          	mov    %esi,0x4(%esp,1)
     76f:	89 1c 24             	mov    %ebx,(%esp,1)
     772:	e8 fc ff ff ff       	call   773 <hmac_setup+0x83>

  for (i=0; i<HMAC_BLOCKSIZE; i++)
     777:	31 d2                	xor    %edx,%edx
     779:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    pad[i]=0x5c^ctx->key[i];
     780:	8b 7d 08             	mov    0x8(%ebp),%edi
     783:	0f b6 04 3a          	movzbl (%edx,%edi,1),%eax
     787:	34 5c                	xor    $0x5c,%al
     789:	88 44 2a b4          	mov    %al,0xffffffb4(%edx,%ebp,1)
     78d:	42                   	inc    %edx
     78e:	83 fa 3f             	cmp    $0x3f,%edx
     791:	7e ed                	jle    780 <hmac_setup+0x90>
  DIGEST_Init(&ctx->out_ctx);
     793:	89 fb                	mov    %edi,%ebx
     795:	81 c3 9c 00 00 00    	add    $0x9c,%ebx
     79b:	89 1c 24             	mov    %ebx,(%esp,1)
     79e:	e8 fc ff ff ff       	call   79f <hmac_setup+0xaf>
  DIGEST_Update(&ctx->out_ctx, pad, HMAC_BLOCKSIZE);
     7a3:	89 74 24 04          	mov    %esi,0x4(%esp,1)
     7a7:	89 1c 24             	mov    %ebx,(%esp,1)
     7aa:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp,1)
     7b1:	00 
     7b2:	e8 fc ff ff ff       	call   7b3 <hmac_setup+0xc3>
}
     7b7:	83 c4 50             	add    $0x50,%esp
     7ba:	5b                   	pop    %ebx
     7bb:	5e                   	pop    %esi
     7bc:	5f                   	pop    %edi
     7bd:	5d                   	pop    %ebp
     7be:	c3                   	ret    
     7bf:	c7 44 24 04 1f 01 00 	movl   $0x11f,0x4(%esp,1)
     7c6:	00 
     7c7:	c7 04 24 80 01 00 00 	movl   $0x180,(%esp,1)
     7ce:	e8 fc ff ff ff       	call   7cf <hmac_setup+0xdf>
     7d3:	e9 30 ff ff ff       	jmp    708 <hmac_setup+0x18>
     7d8:	90                   	nop    
     7d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi

000007e0 <hmac_init>:

void hmac_init(HMAC_CTX *ctx) {
     7e0:	55                   	push   %ebp
  ctx->digest_ctx = ctx->in_ctx;
     7e1:	fc                   	cld    
     7e2:	89 e5                	mov    %esp,%ebp
     7e4:	83 ec 08             	sub    $0x8,%esp
     7e7:	89 34 24             	mov    %esi,(%esp,1)
     7ea:	8b 75 08             	mov    0x8(%ebp),%esi
     7ed:	b9 17 00 00 00       	mov    $0x17,%ecx
     7f2:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
     7f6:	8d be f8 00 00 00    	lea    0xf8(%esi),%edi
     7fc:	83 c6 40             	add    $0x40,%esi
     7ff:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
}
     801:	8b 34 24             	mov    (%esp,1),%esi
     804:	8b 7c 24 04          	mov    0x4(%esp,1),%edi
     808:	89 ec                	mov    %ebp,%esp
     80a:	5d                   	pop    %ebp
     80b:	c3                   	ret    
     80c:	8d 74 26 00          	lea    0x0(%esi,1),%esi

00000810 <hmac_update>:

void hmac_update(HMAC_CTX *ctx, char *data, int len) {
     810:	55                   	push   %ebp
     811:	89 e5                	mov    %esp,%ebp
  DIGEST_Update(&ctx->digest_ctx, data, len);
     813:	8b 45 08             	mov    0x8(%ebp),%eax
     816:	05 f8 00 00 00       	add    $0xf8,%eax
     81b:	89 45 08             	mov    %eax,0x8(%ebp)
     81e:	5d                   	pop    %ebp
     81f:	e9 fc ff ff ff       	jmp    820 <hmac_update+0x10>
     824:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     82a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00000830 <hmac_final>:
}

void hmac_final(HMAC_CTX *ctx, char *output) {
     830:	55                   	push   %ebp
     831:	89 e5                	mov    %esp,%ebp
     833:	83 ec 5c             	sub    $0x5c,%esp
     836:	89 75 f8             	mov    %esi,0xfffffff8(%ebp)
     839:	8b 75 08             	mov    0x8(%ebp),%esi
     83c:	89 5d f4             	mov    %ebx,0xfffffff4(%ebp)
  char buf[HMAC_BLOCKSIZE];
  DIGEST_Final(buf, &ctx->digest_ctx);
     83f:	8d 5d b4             	lea    0xffffffb4(%ebp),%ebx
     842:	8d 86 f8 00 00 00    	lea    0xf8(%esi),%eax
     848:	89 7d fc             	mov    %edi,0xfffffffc(%ebp)
  ctx->digest_ctx = ctx->out_ctx;
     84b:	81 c6 9c 00 00 00    	add    $0x9c,%esi
     851:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
     854:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     858:	89 1c 24             	mov    %ebx,(%esp,1)
     85b:	e8 fc ff ff ff       	call   85c <hmac_final+0x2c>
     860:	fc                   	cld    
     861:	8b 7d b0             	mov    0xffffffb0(%ebp),%edi
     864:	b9 17 00 00 00       	mov    $0x17,%ecx
     869:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
  DIGEST_Update(&ctx->digest_ctx, buf, HMACLEN);
     86b:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
     86f:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp,1)
     876:	00 
     877:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
     87a:	89 04 24             	mov    %eax,(%esp,1)
     87d:	e8 fc ff ff ff       	call   87e <hmac_final+0x4e>
  DIGEST_Final(output, &ctx->digest_ctx);
     882:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
     885:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     889:	8b 45 0c             	mov    0xc(%ebp),%eax
     88c:	89 04 24             	mov    %eax,(%esp,1)
     88f:	e8 fc ff ff ff       	call   890 <hmac_final+0x60>
}
     894:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
     897:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
     89a:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
     89d:	89 ec                	mov    %ebp,%esp
     89f:	5d                   	pop    %ebp
     8a0:	c3                   	ret    
     8a1:	eb 0d                	jmp    8b0 <computeMAC>
     8a3:	90                   	nop    
     8a4:	90                   	nop    
     8a5:	90                   	nop    
     8a6:	90                   	nop    
     8a7:	90                   	nop    
     8a8:	90                   	nop    
     8a9:	90                   	nop    
     8aa:	90                   	nop    
     8ab:	90                   	nop    
     8ac:	90                   	nop    
     8ad:	90                   	nop    
     8ae:	90                   	nop    
     8af:	90                   	nop    

000008b0 <computeMAC>:

#endif // OPENSSL_HMAC

/* NONCE uses AES */

void computeMAC(struct sock *sk, PseudoHeader *phdr, const WireContinuation *cont, char *dest) {
     8b0:	55                   	push   %ebp
     8b1:	89 e5                	mov    %esp,%ebp
     8b3:	83 ec 14             	sub    $0x14,%esp
     8b6:	89 75 fc             	mov    %esi,0xfffffffc(%ebp)
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
     8b9:	8b 45 08             	mov    0x8(%ebp),%eax
     8bc:	8b 75 0c             	mov    0xc(%ebp),%esi
     8bf:	89 5d f8             	mov    %ebx,0xfffffff8(%ebp)
     8c2:	05 bc 00 00 00       	add    $0xbc,%eax
	if(generateHMAC) {
#ifdef OPENSSL_HMAC
		HMAC_CTX *ctx = tp->t.hmacCTX;
     8c7:	8b 98 0c 0b 00 00    	mov    0xb0c(%eax),%ebx
#ifdef DISABLE_SADDR_HMAC
		phdr->serverAddr = 0;
     8cd:	c7 46 06 00 00 00 00 	movl   $0x0,0x6(%esi)
#endif
		hmac_init(ctx);
     8d4:	89 1c 24             	mov    %ebx,(%esp,1)
     8d7:	e8 fc ff ff ff       	call   8d8 <computeMAC+0x28>
		hmac_update(ctx, (char*)phdr, HMAC_PHEADER_LEN);
     8dc:	89 74 24 04          	mov    %esi,0x4(%esp,1)
     8e0:	89 1c 24             	mov    %ebx,(%esp,1)
     8e3:	c7 44 24 08 12 00 00 	movl   $0x12,0x8(%esp,1)
     8ea:	00 
     8eb:	e8 fc ff ff ff       	call   8ec <computeMAC+0x3c>
		hmac_update(ctx, (char*)cont->hmac_start, WIRECONT_MAC_LEN);
     8f0:	8b 45 10             	mov    0x10(%ebp),%eax
     8f3:	89 1c 24             	mov    %ebx,(%esp,1)
     8f6:	c7 44 24 08 25 00 00 	movl   $0x25,0x8(%esp,1)
     8fd:	00 
     8fe:	83 c0 25             	add    $0x25,%eax
     901:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     905:	e8 fc ff ff ff       	call   906 <computeMAC+0x56>
		hmac_final(ctx, dest);
     90a:	8b 45 14             	mov    0x14(%ebp),%eax
     90d:	89 1c 24             	mov    %ebx,(%esp,1)
     910:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     914:	e8 fc ff ff ff       	call   915 <computeMAC+0x65>
#if 0
		printk("Hmac input\n");
		int position = hexdump((char*)phdr, HMAC_PHEADER_LEN);
		hexdump_helper((char*)cont->hmac_start, 
			       WIRECONT_MAC_LEN, position);
		printk("\n");
		printk("Hmac output\n");
		hexdump((char*)dest, HMACLEN);
		printk("\n");
#endif
#else
#error "not implemented"
		// improve parallelism by making local copy
		hmac_sha(tp->t.hmacKey, HMACLEN, 
			 (char*)cont->hmac_start - HMAC_PHEADER_LEN, WIRECONT_MAC_LEN,
			 dest, HMACLEN);
#endif
	} else {
		memset(dest, 0, HMACLEN);
	}
}
     919:	8b 5d f8             	mov    0xfffffff8(%ebp),%ebx
     91c:	8b 75 fc             	mov    0xfffffffc(%ebp),%esi
     91f:	89 ec                	mov    %ebp,%esp
     921:	5d                   	pop    %ebp
     922:	c3                   	ret    
     923:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     929:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00000930 <generateRangeNonce>:
#define NUM_NONCES_PER_BLOCK (NONCE_BLOCKSIZE / sizeof(__u32))

static inline 
__u32 generateCryptoRangeNonceHelper(aes_encrypt_ctx *ctx, __u64 seqNumLeft, __u64 seqNumRight) {
	int i;
	__u64 nums[2] = {seqNumLeft, seqNumRight+1};
	__u64 oldNum = -1;
	__u32 nonce = 0;
	char nonce_out[NONCE_BLOCKSIZE];

	for(i=0; i < 2; i++) {
		__u64 number = nums[i] / NUM_NONCES_PER_BLOCK;
		int offset = nums[i] % NUM_NONCES_PER_BLOCK;
		char nonce_in[NONCE_BLOCKSIZE];
		if(i > 0 && oldNum == number) {
			goto skip_generation;
		}
		memset(nonce_in, 0, NONCE_BLOCKSIZE);
		*((__u64*)nonce_in) = number;
		aes_encrypt(nonce_in, nonce_out, ctx);
	skip_generation:
		nonce ^= ((__u32*)nonce_out)[offset];
		oldNum = number;
	}
	return nonce;
}

__u32 generateRangeNonce(struct sock *sk, __u64 seqNumLeft, __u64 seqNumRight) {
     930:	55                   	push   %ebp
     931:	89 e5                	mov    %esp,%ebp
     933:	57                   	push   %edi
     934:	56                   	push   %esi
     935:	53                   	push   %ebx
     936:	83 ec 58             	sub    $0x58,%esp
     939:	8b 45 0c             	mov    0xc(%ebp),%eax
     93c:	8b 55 10             	mov    0x10(%ebp),%edx
     93f:	8b 5d 08             	mov    0x8(%ebp),%ebx
     942:	8b 75 14             	mov    0x14(%ebp),%esi
     945:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
     948:	8b 7d 18             	mov    0x18(%ebp),%edi
     94b:	89 55 c0             	mov    %edx,0xffffffc0(%ebp)
	if(SIMULATION_MODE(sk)) {
     94e:	8b 83 a8 02 00 00    	mov    0x2a8(%ebx),%eax
     954:	a9 01 00 00 00       	test   $0x1,%eax
     959:	74 0b                	je     966 <generateRangeNonce+0x36>
     95b:	a9 08 00 00 00       	test   $0x8,%eax
     960:	0f 84 11 01 00 00    	je     a77 <generateRangeNonce+0x147>
		BUG_TRAP(!SIMULATION_MODE(sk));
	}
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
	int myGenerateNonces = generateNonces && !SIMULATION_MODE(sk);
     966:	31 d2                	xor    %edx,%edx
     968:	a9 01 00 00 00       	test   $0x1,%eax
     96d:	8d 8b bc 00 00 00    	lea    0xbc(%ebx),%ecx
     973:	74 05                	je     97a <generateRangeNonce+0x4a>
     975:	83 e0 08             	and    $0x8,%eax
     978:	74 05                	je     97f <generateRangeNonce+0x4f>
     97a:	ba 01 00 00 00       	mov    $0x1,%edx
	if(myGenerateNonces) {
     97f:	85 d2                	test   %edx,%edx
     981:	0f 84 ce 00 00 00    	je     a55 <generateRangeNonce+0x125>
     987:	8b 89 20 0b 00 00    	mov    0xb20(%ecx),%ecx
     98d:	83 c6 01             	add    $0x1,%esi
     990:	c7 45 ac ff ff ff ff 	movl   $0xffffffff,0xffffffac(%ebp)
     997:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
     99a:	83 d7 00             	adc    $0x0,%edi
     99d:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
     9a0:	89 4d b8             	mov    %ecx,0xffffffb8(%ebp)
     9a3:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
     9a6:	89 55 e8             	mov    %edx,0xffffffe8(%ebp)
     9a9:	89 75 ec             	mov    %esi,0xffffffec(%ebp)
     9ac:	89 7d f0             	mov    %edi,0xfffffff0(%ebp)
     9af:	c7 45 b0 ff ff ff ff 	movl   $0xffffffff,0xffffffb0(%ebp)
     9b6:	c7 45 a8 00 00 00 00 	movl   $0x0,0xffffffa8(%ebp)
     9bd:	c7 45 b4 00 00 00 00 	movl   $0x0,0xffffffb4(%ebp)
     9c4:	8b 55 b4             	mov    0xffffffb4(%ebp),%edx
     9c7:	8b 4c d5 e4          	mov    0xffffffe4(%ebp,%edx,8),%ecx
     9cb:	8b 5c d5 e8          	mov    0xffffffe8(%ebp,%edx,8),%ebx
     9cf:	89 ce                	mov    %ecx,%esi
     9d1:	89 c8                	mov    %ecx,%eax
     9d3:	8b 4d b4             	mov    0xffffffb4(%ebp),%ecx
     9d6:	0f ac de 02          	shrd   $0x2,%ebx,%esi
     9da:	89 df                	mov    %ebx,%edi
     9dc:	83 e0 03             	and    $0x3,%eax
     9df:	c1 ef 02             	shr    $0x2,%edi
     9e2:	85 c9                	test   %ecx,%ecx
     9e4:	89 c3                	mov    %eax,%ebx
     9e6:	7e 0e                	jle    9f6 <generateRangeNonce+0xc6>
     9e8:	8b 55 b0             	mov    0xffffffb0(%ebp),%edx
     9eb:	8b 45 ac             	mov    0xffffffac(%ebp),%eax
     9ee:	31 fa                	xor    %edi,%edx
     9f0:	31 f0                	xor    %esi,%eax
     9f2:	09 c2                	or     %eax,%edx
     9f4:	74 3a                	je     a30 <generateRangeNonce+0x100>
     9f6:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp,1)
     9fd:	00 
     9fe:	8d 45 c4             	lea    0xffffffc4(%ebp),%eax
     a01:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
     a08:	00 
     a09:	89 04 24             	mov    %eax,(%esp,1)
     a0c:	e8 6f 79 00 00       	call   8380 <__constant_c_and_count_memset>
     a11:	8b 55 b8             	mov    0xffffffb8(%ebp),%edx
     a14:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
     a17:	89 75 c4             	mov    %esi,0xffffffc4(%ebp)
     a1a:	89 7d c8             	mov    %edi,0xffffffc8(%ebp)
     a1d:	89 54 24 08          	mov    %edx,0x8(%esp,1)
     a21:	8d 55 c4             	lea    0xffffffc4(%ebp),%edx
     a24:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     a28:	89 14 24             	mov    %edx,(%esp,1)
     a2b:	e8 fc ff ff ff       	call   a2c <generateRangeNonce+0xfc>
     a30:	8b 44 9d d4          	mov    0xffffffd4(%ebp,%ebx,4),%eax
     a34:	89 75 ac             	mov    %esi,0xffffffac(%ebp)
     a37:	ff 45 b4             	incl   0xffffffb4(%ebp)
     a3a:	31 45 a8             	xor    %eax,0xffffffa8(%ebp)
     a3d:	89 7d b0             	mov    %edi,0xffffffb0(%ebp)
     a40:	83 7d b4 01          	cmpl   $0x1,0xffffffb4(%ebp)
     a44:	8b 45 a8             	mov    0xffffffa8(%ebp),%eax
     a47:	0f 8e 77 ff ff ff    	jle    9c4 <generateRangeNonce+0x94>
		return generateCryptoRangeNonceHelper(tp->t.nonceCTX, seqNumLeft, seqNumRight);
	} else {
		int i;
		__u64 nums[2] = {seqNumLeft, seqNumRight+1};
		__u32 nonce = 0;
		for(i=0; i < 2; i++) {
			nonce ^= nums[i];
		}
		return nonce;
	}
}
     a4d:	83 c4 58             	add    $0x58,%esp
     a50:	5b                   	pop    %ebx
     a51:	5e                   	pop    %esi
     a52:	5f                   	pop    %edi
     a53:	5d                   	pop    %ebp
     a54:	c3                   	ret    
     a55:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
     a58:	83 c6 01             	add    $0x1,%esi
     a5b:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
     a5e:	89 75 cc             	mov    %esi,0xffffffcc(%ebp)
     a61:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
     a64:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
     a67:	89 55 c8             	mov    %edx,0xffffffc8(%ebp)
     a6a:	8b 55 c4             	mov    0xffffffc4(%ebp),%edx
     a6d:	83 d7 00             	adc    $0x0,%edi
     a70:	89 7d d0             	mov    %edi,0xffffffd0(%ebp)
     a73:	31 d0                	xor    %edx,%eax
     a75:	eb d6                	jmp    a4d <generateRangeNonce+0x11d>
     a77:	c7 44 24 04 83 01 00 	movl   $0x183,0x4(%esp,1)
     a7e:	00 
     a7f:	c7 04 24 e0 01 00 00 	movl   $0x1e0,(%esp,1)
     a86:	e8 fc ff ff ff       	call   a87 <generateRangeNonce+0x157>
     a8b:	8b 83 a8 02 00 00    	mov    0x2a8(%ebx),%eax
     a91:	e9 d0 fe ff ff       	jmp    966 <generateRangeNonce+0x36>
     a96:	8d 76 00             	lea    0x0(%esi),%esi
     a99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00000aa0 <generateSingleNonce>:

static inline
__u32 generateCryptoSingleNonceHelper(aes_encrypt_ctx *ctx, __u64 seqNum, struct NonceCtx *prevCtx) {
	__u64 number = seqNum / NUM_NONCES_PER_BLOCK;
	int offset = seqNum % NUM_NONCES_PER_BLOCK;
	char nonce_in[NONCE_BLOCKSIZE];
	char nonce_out_data[NONCE_BLOCKSIZE], *nonce_out = nonce_out_data;
	memset(nonce_in, 0, NONCE_BLOCKSIZE);
	__u32 nonce;

	if(prevCtx) {
		nonce_out = prevCtx->prevBlock;
		if(prevCtx->new) {
			prevCtx->prevNumber = number;
			prevCtx->new = 0;
		} else if(prevCtx->prevNumber == number) {
			goto skipGeneration;
		} else {
			prevCtx->prevNumber = number;
		}
	}
	*((__u64*)nonce_in) = number;

	aes_encrypt(nonce_in, nonce_out, ctx);
 skipGeneration:
	nonce = ((__u32*)nonce_out)[offset];
	if(offset == NUM_NONCES_PER_BLOCK-1) {
		number += 1;
		*((__u64*)nonce_in) = number;
		aes_encrypt(nonce_in, nonce_out, ctx);
		nonce ^= ((__u32*)nonce_out)[0];
		if(prevCtx) {
			prevCtx->prevNumber = number;
		}
	} else {
		nonce ^= ((__u32*)nonce_out)[offset + 1];
	}
	return nonce;
}

__u32 generateSingleNonce(struct sock *sk, __u64 seqNum, struct NonceCtx *prevCtx) {
     aa0:	55                   	push   %ebp
     aa1:	89 e5                	mov    %esp,%ebp
     aa3:	83 ec 20             	sub    $0x20,%esp
     aa6:	89 5d f4             	mov    %ebx,0xfffffff4(%ebp)
     aa9:	8b 45 14             	mov    0x14(%ebp),%eax
     aac:	8b 5d 08             	mov    0x8(%ebp),%ebx
     aaf:	89 75 f8             	mov    %esi,0xfffffff8(%ebp)
     ab2:	8b 75 0c             	mov    0xc(%ebp),%esi
     ab5:	89 7d fc             	mov    %edi,0xfffffffc(%ebp)
     ab8:	8b 7d 10             	mov    0x10(%ebp),%edi
     abb:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	BUG_TRAP(!SIMULATION_MODE(sk));
     abe:	8b 83 a8 02 00 00    	mov    0x2a8(%ebx),%eax
     ac4:	a9 01 00 00 00       	test   $0x1,%eax
     ac9:	74 07                	je     ad2 <generateSingleNonce+0x32>
     acb:	a9 08 00 00 00       	test   $0x8,%eax
     ad0:	74 55                	je     b27 <generateSingleNonce+0x87>
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
	int myGenerateNonces = generateNonces && !SIMULATION_MODE(sk);
     ad2:	31 d2                	xor    %edx,%edx
     ad4:	a9 01 00 00 00       	test   $0x1,%eax
     ad9:	8d 8b bc 00 00 00    	lea    0xbc(%ebx),%ecx
     adf:	74 05                	je     ae6 <generateSingleNonce+0x46>
     ae1:	83 e0 08             	and    $0x8,%eax
     ae4:	74 05                	je     aeb <generateSingleNonce+0x4b>
     ae6:	ba 01 00 00 00       	mov    $0x1,%edx

	if(myGenerateNonces) {
     aeb:	85 d2                	test   %edx,%edx
     aed:	75 12                	jne    b01 <generateSingleNonce+0x61>
		return generateCryptoSingleNonceHelper(tp->t.nonceCTX, seqNum, prevCtx);
	} else {
		return seqNum ^ (seqNum+1);
     aef:	8d 46 01             	lea    0x1(%esi),%eax
	}
}
     af2:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
     af5:	31 f0                	xor    %esi,%eax
     af7:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
     afa:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
     afd:	89 ec                	mov    %ebp,%esp
     aff:	5d                   	pop    %ebp
     b00:	c3                   	ret    
     b01:	89 75 0c             	mov    %esi,0xc(%ebp)
     b04:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
     b07:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
     b0a:	89 7d 10             	mov    %edi,0x10(%ebp)
     b0d:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
     b10:	89 45 14             	mov    %eax,0x14(%ebp)
     b13:	8b 81 20 0b 00 00    	mov    0xb20(%ecx),%eax
     b19:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
     b1c:	89 45 08             	mov    %eax,0x8(%ebp)
     b1f:	89 ec                	mov    %ebp,%esp
     b21:	5d                   	pop    %ebp
     b22:	e9 99 7a 00 00       	jmp    85c0 <generateCryptoSingleNonceHelper>
     b27:	c7 44 24 04 bc 01 00 	movl   $0x1bc,0x4(%esp,1)
     b2e:	00 
     b2f:	c7 04 24 e0 01 00 00 	movl   $0x1e0,(%esp,1)
     b36:	e8 fc ff ff ff       	call   b37 <generateSingleNonce+0x97>
     b3b:	8b 83 a8 02 00 00    	mov    0x2a8(%ebx),%eax
     b41:	eb 8f                	jmp    ad2 <generateSingleNonce+0x32>
     b43:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     b49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00000b50 <__tcp_checksum_complete_user>:

#ifndef USERTEST

/* begin functions copied from tcp_input.c */
static int __tcp_checksum_complete_user(struct sock *sk, struct sk_buff *skb)
{
     b50:	55                   	push   %ebp
     b51:	89 e5                	mov    %esp,%ebp
     b53:	83 ec 14             	sub    $0x14,%esp
     b56:	89 5d fc             	mov    %ebx,0xfffffffc(%ebp)
     b59:	8b 5d 0c             	mov    0xc(%ebp),%ebx
        int result;

	if(skb->ip_summed == CHECKSUM_HW) {
     b5c:	80 7b 7f 01          	cmpb   $0x1,0x7f(%ebx)
     b60:	0f 84 aa 00 00 00    	je     c10 <__tcp_checksum_complete_user+0xc0>
		skb->ip_summed = CHECKSUM_UNNECESSARY;
		if(!tcp_v4_check(skb->h.th, skb->len, skb->nh.iph->saddr, skb->nh.iph->daddr,
				 skb->csum))
			return 0;
		printk("hw tcp checksum failed\n");
		return -1;
	}
        if (sk->lock.users) {
     b66:	8b 45 08             	mov    0x8(%ebp),%eax
     b69:	8b 40 2c             	mov    0x2c(%eax),%eax
     b6c:	85 c0                	test   %eax,%eax
     b6e:	74 63                	je     bd3 <__tcp_checksum_complete_user+0x83>
                local_bh_enable();
     b70:	ba 08 00 00 00       	mov    $0x8,%edx
     b75:	a1 08 00 00 00       	mov    0x8,%eax
     b7a:	48                   	dec    %eax
     b7b:	85 c0                	test   %eax,%eax
     b7d:	a3 08 00 00 00       	mov    %eax,0x8
     b82:	75 0a                	jne    b8e <__tcp_checksum_complete_user+0x3e>
     b84:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
     b88:	0f 85 37 8b 00 00    	jne    96c5 <.text.lock.tmalloc>
 *	Fold a partial checksum
 */

static inline unsigned int csum_fold(unsigned int sum)
{
     b8e:	8b 43 78             	mov    0x78(%ebx),%eax
     b91:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
     b95:	8b 43 70             	mov    0x70(%ebx),%eax
     b98:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
     b9f:	00 
     ba0:	89 1c 24             	mov    %ebx,(%esp,1)
     ba3:	89 44 24 08          	mov    %eax,0x8(%esp,1)
     ba7:	e8 fc ff ff ff       	call   ba8 <__tcp_checksum_complete_user+0x58>
                result = __tcp_checksum_complete(skb);
                local_bh_disable();
     bac:	ff 05 08 00 00 00    	incl   0x8
 */

static inline unsigned int csum_fold(unsigned int sum)
{
	__asm__(
     bb2:	89 c2                	mov    %eax,%edx
     bb4:	c1 e0 10             	shl    $0x10,%eax
     bb7:	81 e2 00 00 ff ff    	and    $0xffff0000,%edx
     bbd:	01 c2                	add    %eax,%edx
     bbf:	81 d2 ff ff 00 00    	adc    $0xffff,%edx
     bc5:	f7 d2                	not    %edx
     bc7:	c1 ea 10             	shr    $0x10,%edx
        } else {
                result = __tcp_checksum_complete(skb);
        }
        return result;
}
     bca:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
     bcd:	89 ec                	mov    %ebp,%esp
     bcf:	89 d0                	mov    %edx,%eax
     bd1:	5d                   	pop    %ebp
     bd2:	c3                   	ret    
 *	Fold a partial checksum
 */

static inline unsigned int csum_fold(unsigned int sum)
{
     bd3:	8b 43 78             	mov    0x78(%ebx),%eax
     bd6:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
     bda:	8b 43 70             	mov    0x70(%ebx),%eax
     bdd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
     be4:	00 
     be5:	89 1c 24             	mov    %ebx,(%esp,1)
     be8:	89 44 24 08          	mov    %eax,0x8(%esp,1)
     bec:	e8 fc ff ff ff       	call   bed <__tcp_checksum_complete_user+0x9d>
	__asm__(
     bf1:	89 c2                	mov    %eax,%edx
     bf3:	c1 e0 10             	shl    $0x10,%eax
     bf6:	81 e2 00 00 ff ff    	and    $0xffff0000,%edx
     bfc:	01 c2                	add    %eax,%edx
     bfe:	81 d2 ff ff 00 00    	adc    $0xffff,%edx
     c04:	f7 d2                	not    %edx
     c06:	c1 ea 10             	shr    $0x10,%edx
     c09:	eb bf                	jmp    bca <__tcp_checksum_complete_user+0x7a>
     c0b:	90                   	nop    
     c0c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
						   unsigned long daddr,
						   unsigned short len,
						   unsigned short proto,
						   unsigned int sum)
{
     c10:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
/* gcc should generate this for open coded C now too. May be worth switching to 
   it because inline assembly cannot be scheduled. -AK */
static __inline__ __const__ __u16 ___arch__swab16(__u16 x)
{
	__asm__("xchgb %b0,%h0"		/* swap bytes		*/
     c14:	86 c4                	xchg   %al,%ah
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
     c16:	c1 e0 10             	shl    $0x10,%eax
     c19:	05 00 06 00 00       	add    $0x600,%eax
     c1e:	c6 43 7f 02          	movb   $0x2,0x7f(%ebx)
 */
static __inline__ u16 tcp_v4_check(struct tcphdr *th, int len,
				   unsigned long saddr, unsigned long daddr, 
				   unsigned long base)
{
     c22:	8b 4b 24             	mov    0x24(%ebx),%ecx
     c25:	8b 53 78             	mov    0x78(%ebx),%edx
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
     c28:	03 51 10             	add    0x10(%ecx),%edx
     c2b:	13 51 0c             	adc    0xc(%ecx),%edx
     c2e:	11 c2                	adc    %eax,%edx
     c30:	83 d2 00             	adc    $0x0,%edx
 */

static inline unsigned int csum_fold(unsigned int sum)
{
	__asm__(
     c33:	89 d0                	mov    %edx,%eax
     c35:	c1 e2 10             	shl    $0x10,%edx
     c38:	25 00 00 ff ff       	and    $0xffff0000,%eax
     c3d:	01 d0                	add    %edx,%eax
     c3f:	15 ff ff 00 00       	adc    $0xffff,%eax
     c44:	f7 d0                	not    %eax
		"addl %1, %0		;\n"
		"adcl $0xffff, %0	;\n"
		: "=r" (sum)
		: "r" (sum << 16), "0" (sum & 0xffff0000)
	);
	return (~sum) >> 16;
}

static inline unsigned long csum_tcpudp_nofold(unsigned long saddr,
						   unsigned long daddr,
						   unsigned short len,
						   unsigned short proto,
						   unsigned int sum)
{
    __asm__(
	"addl %1, %0	;\n"
	"adcl %2, %0	;\n"
	"adcl %3, %0	;\n"
	"adcl $0, %0	;\n"
	: "=r" (sum)
	: "g" (daddr), "g"(saddr), "g"((ntohs(len)<<16)+proto*256), "0"(sum));
    return sum;
}

/*
 * computes the checksum of the TCP/UDP pseudo-header
 * returns a 16-bit checksum, already complemented
 */
static inline unsigned short int csum_tcpudp_magic(unsigned long saddr,
						   unsigned long daddr,
						   unsigned short len,
						   unsigned short proto,
						   unsigned int sum)
{
     c46:	c1 e8 10             	shr    $0x10,%eax
 */
static __inline__ u16 tcp_v4_check(struct tcphdr *th, int len,
				   unsigned long saddr, unsigned long daddr, 
				   unsigned long base)
{
     c49:	31 d2                	xor    %edx,%edx
     c4b:	66 85 c0             	test   %ax,%ax
     c4e:	0f 84 76 ff ff ff    	je     bca <__tcp_checksum_complete_user+0x7a>
     c54:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp,1)
     c5b:	e8 fc ff ff ff       	call   c5c <__tcp_checksum_complete_user+0x10c>
     c60:	ba ff ff ff ff       	mov    $0xffffffff,%edx
     c65:	e9 60 ff ff ff       	jmp    bca <__tcp_checksum_complete_user+0x7a>
     c6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00000c70 <update_rx_stats>:

static __inline__ int
tcp_checksum_complete_user(struct sock *sk, struct sk_buff *skb)
{
	csum_complete_user_count++;
        return skb->ip_summed != CHECKSUM_UNNECESSARY &&
                __tcp_checksum_complete_user(sk, skb);
}

/* end functions copied from tcp_input.c */

static void update_rx_stats(struct sk_buff *in_skb) {
	numRxPackets++;
     c70:	83 05 00 00 00 00 01 	addl   $0x1,0x0
     c77:	55                   	push   %ebp
     c78:	89 e5                	mov    %esp,%ebp
     c7a:	8b 55 08             	mov    0x8(%ebp),%edx
     c7d:	83 15 04 00 00 00 00 	adcl   $0x0,0x4
	numRxBytes += in_skb->h.th->doff * 4 + in_skb->len;
}
     c84:	5d                   	pop    %ebp
     c85:	8b 42 20             	mov    0x20(%edx),%eax
     c88:	8b 52 70             	mov    0x70(%edx),%edx
     c8b:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
     c8f:	c0 e8 04             	shr    $0x4,%al
     c92:	83 e0 0f             	and    $0xf,%eax
     c95:	8d 04 82             	lea    (%edx,%eax,4),%eax
     c98:	31 d2                	xor    %edx,%edx
     c9a:	01 05 00 00 00 00    	add    %eax,0x0
     ca0:	11 15 04 00 00 00    	adc    %edx,0x4
     ca6:	c3                   	ret    
     ca7:	89 f6                	mov    %esi,%esi
     ca9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00000cb0 <trickles_rcv_impl>:

static int trickles_rcv_impl(struct sock *sk, struct sk_buff *in_skb) {
     cb0:	55                   	push   %ebp
     cb1:	89 e5                	mov    %esp,%ebp
     cb3:	57                   	push   %edi
     cb4:	56                   	push   %esi
     cb5:	53                   	push   %ebx
     cb6:	31 db                	xor    %ebx,%ebx
     cb8:	83 ec 0c             	sub    $0xc,%esp
     cbb:	ff 05 10 00 00 00    	incl   0x10
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
     cc1:	8b 45 08             	mov    0x8(%ebp),%eax
     cc4:	8b 55 0c             	mov    0xc(%ebp),%edx
     cc7:	05 bc 00 00 00       	add    $0xbc,%eax
     ccc:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
     ccf:	80 7a 7f 02          	cmpb   $0x2,0x7f(%edx)
     cd3:	74 19                	je     cee <trickles_rcv_impl+0x3e>
     cd5:	89 54 24 04          	mov    %edx,0x4(%esp,1)
     cd9:	8b 4d 08             	mov    0x8(%ebp),%ecx
     cdc:	89 0c 24             	mov    %ecx,(%esp,1)
     cdf:	e8 6c fe ff ff       	call   b50 <__tcp_checksum_complete_user>
     ce4:	85 c0                	test   %eax,%eax
     ce6:	b8 01 00 00 00       	mov    $0x1,%eax
     ceb:	0f 45 d8             	cmovne %eax,%ebx
     cee:	85 db                	test   %ebx,%ebx
     cf0:	0f 85 a5 02 00 00    	jne    f9b <trickles_rcv_impl+0x2eb>
	return skb->data;
}

static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
     cf6:	8b 55 0c             	mov    0xc(%ebp),%edx
	skb->len-=len;
     cf9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
     cfc:	8b 42 20             	mov    0x20(%edx),%eax
     cff:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
     d03:	c0 e8 04             	shr    $0x4,%al
     d06:	83 e0 0f             	and    $0xf,%eax
     d09:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
     d10:	8b 41 70             	mov    0x70(%ecx),%eax
     d13:	29 d0                	sub    %edx,%eax
	if (skb->len < skb->data_len)
     d15:	3b 41 74             	cmp    0x74(%ecx),%eax
     d18:	89 41 70             	mov    %eax,0x70(%ecx)
     d1b:	0f 82 8b 02 00 00    	jb     fac <trickles_rcv_impl+0x2fc>
     d21:	8b 45 0c             	mov    0xc(%ebp),%eax
     d24:	01 90 94 00 00 00    	add    %edx,0x94(%eax)

	if (tcp_checksum_complete_user(sk, in_skb))
		goto csum_error;
	__skb_pull(in_skb, in_skb->h.th->doff * 4);

	in_skb->ip_summed = CHECKSUM_UNNECESSARY;
     d2a:	c6 40 7f 02          	movb   $0x2,0x7f(%eax)
	in_skb->sk = sk;
     d2e:	8b 55 08             	mov    0x8(%ebp),%edx
     d31:	89 50 0c             	mov    %edx,0xc(%eax)

	//local_irq_save(flags); // 0502 - see if disabling/enabling interrupts resolves race condition

	if(sk->tp_pinfo.af_tcp.trickles_opt & TCP_TRICKLES_RSERVER) {
     d34:	f6 82 a8 02 00 00 08 	testb  $0x8,0x2a8(%edx)
     d3b:	0f 84 25 02 00 00    	je     f66 <trickles_rcv_impl+0x2b6>
		int result;
		// First process prequeue overflow
		struct sk_buff *pre_skb;
		while (can_alloc_trickles_msk(sk) && 
     d41:	8d ba 90 02 00 00    	lea    0x290(%edx),%edi
static inline 
int can_alloc_trickles_msk(struct sock *sk) {
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
	struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
	struct cminisock *curr = 
     d47:	8b 47 04             	mov    0x4(%edi),%eax
		(struct cminisock *)head->next;
	while((struct alloc_head_list*)curr != head && curr->ctl == ALLOC_PROCESSING) {
     d4a:	39 f8                	cmp    %edi,%eax
     d4c:	74 0a                	je     d58 <trickles_rcv_impl+0xa8>
     d4e:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
     d52:	0f 84 f8 01 00 00    	je     f50 <trickles_rcv_impl+0x2a0>
     d58:	39 f8                	cmp    %edi,%eax
     d5a:	0f 84 cd 00 00 00    	je     e2d <trickles_rcv_impl+0x17d>
{
	struct sk_buff *next, *prev, *result;

	prev = (struct sk_buff *) list;
	next = prev->next;
     d60:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
	result = NULL;
     d63:	31 db                	xor    %ebx,%ebx
     d65:	8b 75 f0             	mov    0xfffffff0(%ebp),%esi
     d68:	8b 81 24 0b 00 00    	mov    0xb24(%ecx),%eax
     d6e:	81 c6 24 0b 00 00    	add    $0xb24,%esi
	if (next != prev) {
     d74:	39 f0                	cmp    %esi,%eax
     d76:	74 24                	je     d9c <trickles_rcv_impl+0xec>
		result = next;
     d78:	89 c3                	mov    %eax,%ebx
		next = next->next;
     d7a:	8b 00                	mov    (%eax),%eax
		list->qlen--;
     d7c:	ff 4e 08             	decl   0x8(%esi)
		next->prev = prev;
		prev->next = next;
		result->next = NULL;
		result->prev = NULL;
		result->list = NULL;
     d7f:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
     d86:	89 70 04             	mov    %esi,0x4(%eax)
     d89:	89 81 24 0b 00 00    	mov    %eax,0xb24(%ecx)
     d8f:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
     d96:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
     d9c:	85 db                	test   %ebx,%ebx
     d9e:	0f 84 89 00 00 00    	je     e2d <trickles_rcv_impl+0x17d>
		       ((pre_skb = __skb_dequeue(&tp->t.prequeueOverflow))
			!= NULL)) {
			update_rx_stats(pre_skb);
     da4:	89 1c 24             	mov    %ebx,(%esp,1)
     da7:	e8 c4 fe ff ff       	call   c70 <update_rx_stats>
			result = server_rcv_impl(sk, pre_skb);
     dac:	8b 45 08             	mov    0x8(%ebp),%eax
     daf:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
     db3:	89 04 24             	mov    %eax,(%esp,1)
     db6:	e8 fc ff ff ff       	call   db7 <trickles_rcv_impl+0x107>
			if(result == 0 || result == -EINVAL) {
     dbb:	85 c0                	test   %eax,%eax
     dbd:	74 05                	je     dc4 <trickles_rcv_impl+0x114>
     dbf:	83 f8 ea             	cmp    $0xffffffea,%eax
     dc2:	75 0d                	jne    dd1 <trickles_rcv_impl+0x121>
				__kfree_skb(pre_skb);
     dc4:	89 1c 24             	mov    %ebx,(%esp,1)
     dc7:	e8 fc ff ff ff       	call   dc8 <trickles_rcv_impl+0x118>
     dcc:	e9 76 ff ff ff       	jmp    d47 <trickles_rcv_impl+0x97>
			} else {
				BUG_TRAP(result == -ENOMEM);
     dd1:	83 f8 f4             	cmp    $0xfffffff4,%eax
     dd4:	74 14                	je     dea <trickles_rcv_impl+0x13a>
     dd6:	c7 44 24 04 07 02 00 	movl   $0x207,0x4(%esp,1)
     ddd:	00 
     dde:	c7 04 24 40 02 00 00 	movl   $0x240,(%esp,1)
     de5:	e8 fc ff ff ff       	call   de6 <trickles_rcv_impl+0x136>
				RECORD_NOMEM();
     dea:	ff 05 14 00 00 00    	incl   0x14
static inline void __skb_queue_head(struct sk_buff_head *list, struct sk_buff *newsk)
{
	struct sk_buff *prev, *next;

	newsk->list = list;
     df0:	89 73 08             	mov    %esi,0x8(%ebx)
	list->qlen++;
     df3:	ff 46 08             	incl   0x8(%esi)
	prev = (struct sk_buff *)list;
	next = prev->next;
     df6:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
	newsk->next = next;
	newsk->prev = prev;
     df9:	89 73 04             	mov    %esi,0x4(%ebx)
     dfc:	8b 82 24 0b 00 00    	mov    0xb24(%edx),%eax
     e02:	89 03                	mov    %eax,(%ebx)
	next->prev = newsk;
     e04:	89 58 04             	mov    %ebx,0x4(%eax)
	prev->next = newsk;
}


/**
 *	skb_queue_head - queue a buffer at the list head
 *	@list: list to use
 *	@newsk: buffer to queue
 *
 *	Queue a buffer at the start of the list. This function takes the
 *	list lock and can be used safely with other locking &sk_buff functions
 *	safely.
 *
 *	A buffer cannot be placed on two lists at the same time.
 */	

static inline void skb_queue_head(struct sk_buff_head *list, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&list->lock, flags);
	__skb_queue_head(list, newsk);
	spin_unlock_irqrestore(&list->lock, flags);
}

/**
 *	__skb_queue_tail - queue a buffer at the list tail
 *	@list: list to use
 *	@newsk: buffer to queue
 *
 *	Queue a buffer at the end of a list. This function takes no locks
 *	and you must therefore hold required locks before calling it.
 *
 *	A buffer cannot be placed on two lists at the same time.
 */	
 

static inline void __skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
	struct sk_buff *prev, *next;

	newsk->list = list;
	list->qlen++;
	next = (struct sk_buff *)list;
	prev = next->prev;
     e07:	8b 46 04             	mov    0x4(%esi),%eax
     e0a:	89 9a 24 0b 00 00    	mov    %ebx,0xb24(%edx)
     e10:	8b 4d 0c             	mov    0xc(%ebp),%ecx
     e13:	89 71 08             	mov    %esi,0x8(%ecx)
     e16:	ff 46 08             	incl   0x8(%esi)
	newsk->next = next;
     e19:	89 31                	mov    %esi,(%ecx)
	newsk->prev = prev;
     e1b:	89 41 04             	mov    %eax,0x4(%ecx)
	next->prev = newsk;
	prev->next = newsk;
     e1e:	89 08                	mov    %ecx,(%eax)
     e20:	89 4e 04             	mov    %ecx,0x4(%esi)
				__skb_queue_head(&tp->t.prequeueOverflow, pre_skb);
				__skb_queue_tail(&tp->t.prequeueOverflow, in_skb);
				return 0;
			}
		}
		if(can_alloc_trickles_msk(sk)) {
			goto process_first;
		} else {
			// XXX should defer until later
			if(tp->t.prequeueOverflow.qlen < 20000) {
				__skb_queue_tail(&tp->t.prequeueOverflow, in_skb);
				return 0;
			} else {
				return -1;
			}
		}
		// optimization: process the rest of the prequeue before restoring FPU context
#ifndef USERTEST
		while (can_alloc_trickles_msk(sk) && 
		       ((in_skb = __skb_dequeue(&tp->ucopy.prequeue))
			!= NULL)) {
#endif
		process_first:
			update_rx_stats(in_skb);
			result = server_rcv_impl(sk, in_skb);
			if(result == 0 || result == -EINVAL) {
				__kfree_skb(in_skb);
			} else {
				BUG_TRAP(result == -ENOMEM);
				RECORD_NOMEM();
				__skb_queue_tail(&tp->ucopy.prequeue, in_skb);
				break;
			}
#ifndef USERTEST
		}
#endif
		//local_irq_restore(flags);
		return 0;
	} else {
		int result;

		update_rx_stats(in_skb);
		result = client_rcv_impl(sk, in_skb);
		if(result) {
			__kfree_skb(in_skb);
		}
		//local_irq_restore(flags);
		return 0;
     e23:	31 c0                	xor    %eax,%eax
	}
 csum_error:
	printk("CSUM error!\n");
	// irq not disabled 
	return -1;
}
     e25:	83 c4 0c             	add    $0xc,%esp
     e28:	5b                   	pop    %ebx
     e29:	5e                   	pop    %esi
     e2a:	5f                   	pop    %edi
     e2b:	5d                   	pop    %ebp
     e2c:	c3                   	ret    
static inline 
int can_alloc_trickles_msk(struct sock *sk) {
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
	struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
	struct cminisock *curr = 
     e2d:	8b 47 04             	mov    0x4(%edi),%eax
		(struct cminisock *)head->next;
	while((struct alloc_head_list*)curr != head && curr->ctl == ALLOC_PROCESSING) {
     e30:	39 f8                	cmp    %edi,%eax
     e32:	74 0a                	je     e3e <trickles_rcv_impl+0x18e>
     e34:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
     e38:	0f 84 f9 00 00 00    	je     f37 <trickles_rcv_impl+0x287>
     e3e:	39 f8                	cmp    %edi,%eax
     e40:	75 36                	jne    e78 <trickles_rcv_impl+0x1c8>
     e42:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
     e45:	81 b8 2c 0b 00 00 1f 	cmpl   $0x4e1f,0xb2c(%eax)
     e4c:	4e 00 00 
     e4f:	77 20                	ja     e71 <trickles_rcv_impl+0x1c1>
 */	
 

static inline void __skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
     e51:	05 24 0b 00 00       	add    $0xb24,%eax
	struct sk_buff *prev, *next;

	newsk->list = list;
     e56:	8b 55 0c             	mov    0xc(%ebp),%edx
     e59:	89 42 08             	mov    %eax,0x8(%edx)
	list->qlen++;
	next = (struct sk_buff *)list;
	prev = next->prev;
     e5c:	8b 50 04             	mov    0x4(%eax),%edx
     e5f:	ff 40 08             	incl   0x8(%eax)
	newsk->next = next;
     e62:	8b 4d 0c             	mov    0xc(%ebp),%ecx
     e65:	89 01                	mov    %eax,(%ecx)
	newsk->prev = prev;
     e67:	89 51 04             	mov    %edx,0x4(%ecx)
	next->prev = newsk;
	prev->next = newsk;
     e6a:	89 0a                	mov    %ecx,(%edx)
     e6c:	89 48 04             	mov    %ecx,0x4(%eax)
     e6f:	eb b2                	jmp    e23 <trickles_rcv_impl+0x173>
     e71:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     e76:	eb ad                	jmp    e25 <trickles_rcv_impl+0x175>
     e78:	8b 4d 0c             	mov    0xc(%ebp),%ecx
     e7b:	89 0c 24             	mov    %ecx,(%esp,1)
     e7e:	e8 ed fd ff ff       	call   c70 <update_rx_stats>
     e83:	8b 45 0c             	mov    0xc(%ebp),%eax
     e86:	8b 55 08             	mov    0x8(%ebp),%edx
     e89:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     e8d:	89 14 24             	mov    %edx,(%esp,1)
     e90:	e8 fc ff ff ff       	call   e91 <trickles_rcv_impl+0x1e1>
     e95:	85 c0                	test   %eax,%eax
     e97:	74 05                	je     e9e <trickles_rcv_impl+0x1ee>
     e99:	83 f8 ea             	cmp    $0xffffffea,%eax
     e9c:	75 6f                	jne    f0d <trickles_rcv_impl+0x25d>
     e9e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
     ea1:	89 0c 24             	mov    %ecx,(%esp,1)
     ea4:	e8 fc ff ff ff       	call   ea5 <trickles_rcv_impl+0x1f5>
static inline 
int can_alloc_trickles_msk(struct sock *sk) {
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
	struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
	struct cminisock *curr = 
     ea9:	8b 47 04             	mov    0x4(%edi),%eax
     eac:	8d 74 26 00          	lea    0x0(%esi,1),%esi
     eb0:	39 f8                	cmp    %edi,%eax
     eb2:	74 0b                	je     ebf <trickles_rcv_impl+0x20f>
     eb4:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
     eb8:	75 05                	jne    ebf <trickles_rcv_impl+0x20f>
		(struct cminisock *)head->next;
	while((struct alloc_head_list*)curr != head && curr->ctl == ALLOC_PROCESSING) {
		//printk("alloc_head loop\n");
		curr = curr->next;
     eba:	8b 40 04             	mov    0x4(%eax),%eax
     ebd:	eb f1                	jmp    eb0 <trickles_rcv_impl+0x200>
     ebf:	39 f8                	cmp    %edi,%eax
     ec1:	0f 84 5c ff ff ff    	je     e23 <trickles_rcv_impl+0x173>
{
	struct sk_buff *next, *prev, *result;

	prev = (struct sk_buff *) list;
	next = prev->next;
     ec7:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
     eca:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
     ecd:	8b 41 34             	mov    0x34(%ecx),%eax
	result = NULL;
     ed0:	31 c9                	xor    %ecx,%ecx
     ed2:	83 c2 34             	add    $0x34,%edx
	if (next != prev) {
     ed5:	39 d0                	cmp    %edx,%eax
     ed7:	74 24                	je     efd <trickles_rcv_impl+0x24d>
		result = next;
     ed9:	89 c1                	mov    %eax,%ecx
		next = next->next;
     edb:	8b 00                	mov    (%eax),%eax
		list->qlen--;
     edd:	ff 4a 08             	decl   0x8(%edx)
		next->prev = prev;
     ee0:	89 50 04             	mov    %edx,0x4(%eax)
		prev->next = next;
     ee3:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
		result->next = NULL;
		result->prev = NULL;
     ee6:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
		result->list = NULL;
     eed:	c7 41 08 00 00 00 00 	movl   $0x0,0x8(%ecx)
     ef4:	89 42 34             	mov    %eax,0x34(%edx)
     ef7:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
     efd:	89 4d 0c             	mov    %ecx,0xc(%ebp)
     f00:	85 c9                	test   %ecx,%ecx
     f02:	0f 85 70 ff ff ff    	jne    e78 <trickles_rcv_impl+0x1c8>
     f08:	e9 16 ff ff ff       	jmp    e23 <trickles_rcv_impl+0x173>
     f0d:	83 f8 f4             	cmp    $0xfffffff4,%eax
     f10:	74 14                	je     f26 <trickles_rcv_impl+0x276>
     f12:	c7 44 24 04 25 02 00 	movl   $0x225,0x4(%esp,1)
     f19:	00 
     f1a:	c7 04 24 40 02 00 00 	movl   $0x240,(%esp,1)
     f21:	e8 fc ff ff ff       	call   f22 <trickles_rcv_impl+0x272>
     f26:	ff 05 14 00 00 00    	incl   0x14
 */	
 

static inline void __skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
     f2c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
     f2f:	83 c0 34             	add    $0x34,%eax
     f32:	e9 1f ff ff ff       	jmp    e56 <trickles_rcv_impl+0x1a6>
	struct cminisock *curr = 
		(struct cminisock *)head->next;
	while((struct alloc_head_list*)curr != head && curr->ctl == ALLOC_PROCESSING) {
		//printk("alloc_head loop\n");
		curr = curr->next;
     f37:	8b 40 04             	mov    0x4(%eax),%eax
     f3a:	39 f8                	cmp    %edi,%eax
     f3c:	0f 84 fc fe ff ff    	je     e3e <trickles_rcv_impl+0x18e>
     f42:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
     f46:	74 ef                	je     f37 <trickles_rcv_impl+0x287>
     f48:	e9 f1 fe ff ff       	jmp    e3e <trickles_rcv_impl+0x18e>
     f4d:	8d 76 00             	lea    0x0(%esi),%esi
     f50:	8b 40 04             	mov    0x4(%eax),%eax
     f53:	39 f8                	cmp    %edi,%eax
     f55:	0f 84 fd fd ff ff    	je     d58 <trickles_rcv_impl+0xa8>
     f5b:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
     f5f:	74 ef                	je     f50 <trickles_rcv_impl+0x2a0>
     f61:	e9 f2 fd ff ff       	jmp    d58 <trickles_rcv_impl+0xa8>
     f66:	8b 45 0c             	mov    0xc(%ebp),%eax
     f69:	89 04 24             	mov    %eax,(%esp,1)
     f6c:	e8 ff fc ff ff       	call   c70 <update_rx_stats>
     f71:	8b 55 0c             	mov    0xc(%ebp),%edx
     f74:	8b 4d 08             	mov    0x8(%ebp),%ecx
     f77:	89 54 24 04          	mov    %edx,0x4(%esp,1)
     f7b:	89 0c 24             	mov    %ecx,(%esp,1)
     f7e:	e8 fc ff ff ff       	call   f7f <trickles_rcv_impl+0x2cf>
     f83:	85 c0                	test   %eax,%eax
     f85:	0f 84 98 fe ff ff    	je     e23 <trickles_rcv_impl+0x173>
     f8b:	8b 45 0c             	mov    0xc(%ebp),%eax
     f8e:	89 04 24             	mov    %eax,(%esp,1)
     f91:	e8 fc ff ff ff       	call   f92 <trickles_rcv_impl+0x2e2>
     f96:	e9 88 fe ff ff       	jmp    e23 <trickles_rcv_impl+0x173>
     f9b:	c7 04 24 44 00 00 00 	movl   $0x44,(%esp,1)
     fa2:	e8 fc ff ff ff       	call   fa3 <trickles_rcv_impl+0x2f3>
     fa7:	e9 c5 fe ff ff       	jmp    e71 <trickles_rcv_impl+0x1c1>
static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
	skb->len-=len;
	if (skb->len < skb->data_len)
		out_of_line_bug();
     fac:	c7 04 24 4c 03 00 00 	movl   $0x34c,(%esp,1)
     fb3:	e8 fc ff ff ff       	call   fb4 <trickles_rcv_impl+0x304>
     fb8:	90                   	nop    
     fb9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi

00000fc0 <resetClientTimer>:

#endif // USERTEST

/* 
 * 
 * Client handling 
 *
 */

static int findAckables(struct sock *sk, int skip, struct sk_buff **skip_skb);
static void requestSlowStart(struct sock *sk);
static inline void client_inseq(struct sock *sk, struct sk_buff *in_skb, int noCont);

#define MIN_SS_TIMEOUT (HZ/20)
//#define MIN_SS_TIMEOUT (HZ)
//#define MAX_SS_TIMEOUT (HZ/2)
#define MAX_SS_TIMEOUT (2*HZ)

/* slow start moderation */
void resetClientTimer(struct sock *sk) {
     fc0:	55                   	push   %ebp
     fc1:	89 e5                	mov    %esp,%ebp
     fc3:	83 ec 14             	sub    $0x14,%esp
     fc6:	89 7d fc             	mov    %edi,0xfffffffc(%ebp)
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
     fc9:	8b 7d 08             	mov    0x8(%ebp),%edi
     fcc:	89 75 f8             	mov    %esi,0xfffffff8(%ebp)
	unsigned long expiration = jiffies;
     fcf:	8b 35 00 00 00 00    	mov    0x0,%esi
     fd5:	81 c7 bc 00 00 00    	add    $0xbc,%edi
     fdb:	89 5d f4             	mov    %ebx,0xfffffff4(%ebp)

	if(tp->t.state == TRICKLES_CLIENT_SYNACK) {
     fde:	83 bf cc 02 00 00 04 	cmpl   $0x4,0x2cc(%edi)
     fe5:	74 79                	je     1060 <resetClientTimer+0xa0>
		expiration += 2 * HZ;
	} else {
		int timeout = MAX(tp->t.delay, MIN_SS_TIMEOUT);
     fe7:	8b 87 d4 02 00 00    	mov    0x2d4(%edi),%eax
     fed:	bb 05 00 00 00       	mov    $0x5,%ebx
     ff2:	39 c3                	cmp    %eax,%ebx
     ff4:	0f 4c d8             	cmovl  %eax,%ebx
     ff7:	a1 0c f0 04 00       	mov    0x4f00c,%eax
     ffc:	69 c0 0d 66 19 00    	imul   $0x19660d,%eax,%eax
    1002:	05 5f f3 6e 3c       	add    $0x3c6ef35f,%eax
    1007:	89 c1                	mov    %eax,%ecx
    1009:	c1 e9 18             	shr    $0x18,%ecx
    100c:	a3 0c f0 04 00       	mov    %eax,0x4f00c
    1011:	66 0f b6 d1          	movzbw %cl,%dx
    1015:	8d 04 d2             	lea    (%edx,%edx,8),%eax
    1018:	8d 04 42             	lea    (%edx,%eax,2),%eax
    101b:	8d 04 c0             	lea    (%eax,%eax,8),%eax
    101e:	c1 e8 08             	shr    $0x8,%eax
    1021:	d0 e8                	shr    %al
    1023:	88 c2                	mov    %al,%dl
    1025:	00 d2                	add    %dl,%dl
    1027:	00 c2                	add    %al,%dl
    1029:	28 d1                	sub    %dl,%cl
    102b:	0f b6 c1             	movzbl %cl,%eax
    102e:	01 c3                	add    %eax,%ebx
#ifdef RANDOMIZE_SLOWSTART_TIMER
		timeout += random() % ((HZ * 30) / 1000);
#endif
		expiration += timeout;
    1030:	01 de                	add    %ebx,%esi
	}
	// todo: change timeout to measured connection rtt
	if(!mod_timer(&tp->t.slowstart_timer, expiration)) {
    1032:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    1036:	8d 87 34 0a 00 00    	lea    0xa34(%edi),%eax
    103c:	89 04 24             	mov    %eax,(%esp,1)
    103f:	e8 fc ff ff ff       	call   1040 <resetClientTimer+0x80>
    1044:	85 c0                	test   %eax,%eax
    1046:	75 06                	jne    104e <resetClientTimer+0x8e>
 * useful range of an atomic_t is only 24 bits.
 */ 
static __inline__ void atomic_inc(atomic_t *v)
{
	__asm__ __volatile__(
    1048:	8b 45 08             	mov    0x8(%ebp),%eax
    104b:	ff 40 28             	incl   0x28(%eax)
		sock_hold(sk);
	}
}
    104e:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
    1051:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
    1054:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
    1057:	89 ec                	mov    %ebp,%esp
    1059:	5d                   	pop    %ebp
    105a:	c3                   	ret    
    105b:	90                   	nop    
    105c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    1060:	81 c6 c8 00 00 00    	add    $0xc8,%esi
    1066:	eb ca                	jmp    1032 <resetClientTimer+0x72>
    1068:	90                   	nop    
    1069:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi

00001070 <slow_start_timer>:

static void enterRecoveryState(struct sock *sk, int isSlowStart);
struct UC_Continuation *
findUCContinuation(struct sock *sk, unsigned start, unsigned end);

void slow_start_timer(unsigned long data) {
    1070:	55                   	push   %ebp
    1071:	89 e5                	mov    %esp,%ebp
    1073:	57                   	push   %edi
	static int totalNum;
	struct sock *sk = (struct sock *)data;
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	int numAcks = 0;
	int backedOff = 0;

#ifdef JAM_NORMAL
	if(tp->t.state == TRICKLES_CLIENT_NORMAL) {
		GEN_JAM("NORMAL");
		return;
	}
#endif

#ifdef JAM_SLOWSTART
	if(tp->t.state == TRICKLES_CLIENT_SLOWSTART) {
		if(trickles_ratelimit()) printk("slow_start_timer: Jammed on slow start\n");
		return;
	}
#endif

	totalNum ++;
	if(0 && (clientDebugLevel >= 1 || ( 1 && totalNum % 10000 == 0) || usertest)) {
		printk("Slow start timer @ %lu, rtt = %u, total = %d, numDataRequestMappings = %d, numContinuations = %d, numConversionRequests = %d, numContinuationRequests = %d, tp->rcv_nxt = %u, tp->t.rcv_nxt = %u, sk = %p\n", jiffies, tp->t.rtt, totalNum, numDataRequestMappings, numContinuations, numConversionRequests, numContinuationRequests, tp->rcv_nxt, tp->t.rcv_nxt, sk);
	}
	tp->t.in_flight = 0;
    1074:	31 ff                	xor    %edi,%edi
    1076:	56                   	push   %esi
    1077:	53                   	push   %ebx
    1078:	83 ec 34             	sub    $0x34,%esp
    107b:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
    1082:	8b 5d 08             	mov    0x8(%ebp),%ebx
    1085:	ff 05 30 e2 04 00    	incl   0x4e230
    108b:	8d b3 bc 00 00 00    	lea    0xbc(%ebx),%esi
    1091:	89 be fc 02 00 00    	mov    %edi,0x2fc(%esi)
#ifndef USERTEST
	bh_lock_sock(sk);
#if 0 // 0419 - no interaction between user and kernel except on copied_seq. 
	// XXX Removing this check MAY cause a race condition on tp->copied_seq!!!
	if (sk->lock.users) {
		/* Try again later */
		// 0419 trying to fix slow start's interaction with userspace
		tp->t.timerState |= TRICKLES_NEED_SLOWSTART;
		printk("need slowstart 1\n");
		if (!mod_timer(&tp->t.slowstart_timer, jiffies + (HZ/20)))
			sock_hold(sk);
		goto out_unlock;
	}
#endif
	if (sk->state == TCP_CLOSE)
    1097:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
    109b:	3c 07                	cmp    $0x7,%al
    109d:	0f 84 bd 00 00 00    	je     1160 <slow_start_timer+0xf0>
		goto out_unlock;
#endif // USERTEST

	int haveRequests = !empty(&tp->t.sentRequests) || !empty(&tp->t.queuedRequests);
    10a3:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
#ifdef __KERNEL__
#define VALID_MSK_CTL(X) ((X)->ctl == ALLOC_READY || \
                          (X)->ctl == ALLOC_HALFFREE)

static inline int empty(struct alloc_head_list *head) {
    10aa:	8d 83 24 0b 00 00    	lea    0xb24(%ebx),%eax
    10b0:	39 40 04             	cmp    %eax,0x4(%eax)
    10b3:	75 0b                	jne    10c0 <slow_start_timer+0x50>
    10b5:	8d 83 38 0b 00 00    	lea    0xb38(%ebx),%eax
    10bb:	39 40 04             	cmp    %eax,0x4(%eax)
    10be:	74 07                	je     10c7 <slow_start_timer+0x57>
    10c0:	c7 45 ec 01 00 00 00 	movl   $0x1,0xffffffec(%ebp)
	//printk("Slow start timer(%p), snd_una = %d, write_seq = %d\n", sk, tp->t.snd_una, tp->t.write_seq);


	// First, try to send out any pending acks
	if((numAcks = trickles_send_ack_impl(sk, 0)) == 0) {
    10c7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    10ce:	00 
    10cf:	89 1c 24             	mov    %ebx,(%esp,1)
    10d2:	e8 fc ff ff ff       	call   10d3 <slow_start_timer+0x63>
    10d7:	85 c0                	test   %eax,%eax
    10d9:	89 c7                	mov    %eax,%edi
    10db:	75 4d                	jne    112a <slow_start_timer+0xba>
		if(tp->t.timerState & TRICKLES_ENABLE_DATA_TIMEOUT 
    10dd:	f6 86 d8 02 00 00 01 	testb  $0x1,0x2d8(%esi)
    10e4:	0f 84 c8 01 00 00    	je     12b2 <slow_start_timer+0x242>
		   || findUCContinuation(sk, tp->t.byteReqNext, tp->t.byteReqNext)
		   || haveRequests) {
			//#define STRICT_BUFFER_CHECK
#ifdef STRICT_BUFFER_CHECK // 0419 - fixing extraneous slowstarts with blocked client
			// NOTE!!! POSSIBLE RACE CONDITION WITH USERSPACE SINCE WE DON'T CHECK USER LOCK
			int haveRcvBuf = tp->rcv_nxt < tp->copied_seq + sk->rcvbuf;
			if(!IS_SEND_UCONTREQ_STATE(tp) ||  
			   !empty(&tp->t.sentRequests) ||   // requests we can use
			   !empty(&tp->t.queuedRequests) || //  "" "" 
			   (haveRcvBuf && // have space in buffer, and usable continuation
			    findUCContinuation(sk, tp->rcv_nxt, tp->rcv_nxt))) {
#else
			if(!IS_SEND_UCONTREQ_STATE(tp) || haveRequests ||
    10ea:	8b 86 cc 02 00 00    	mov    0x2cc(%esi),%eax
    10f0:	48                   	dec    %eax
    10f1:	83 f8 02             	cmp    $0x2,%eax
    10f4:	77 0b                	ja     1101 <slow_start_timer+0x91>
    10f6:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    10f9:	85 d2                	test   %edx,%edx
    10fb:	0f 84 c8 00 00 00    	je     11c9 <slow_start_timer+0x159>
			   findUCContinuation(sk, tp->rcv_nxt, tp->rcv_nxt)) {
#endif
				static int totalNum = 0;
				if((totalNum++ % 100 == 0) || clientDebugLevel >= 1) {
#if 0
					printk("Timing out @ %lu (%d times) sk = %p tp->rcv_nxt = %d, rtt = %d, delay = %d\n", jiffies, totalNum, sk, tp->rcv_nxt, tp->t.rtt, tp->t.delay);
					printk("rtt = %u, total = %d, numDataRequestMappings = %d, numContinuations = %d, numConversionRequests = %d, numContinuationRequests = %d, tp->rcv_nxt = %u, tp->t.rcv_nxt = %u, sk = %p\n", tp->t.rtt, totalNum, numDataRequestMappings, numContinuations, numConversionRequests, numContinuationRequests, tp->rcv_nxt, tp->t.rcv_nxt, sk);
					printk("ContList Length = %d  Cont OFO queue length %d Data OFO queue length %d\n", tp->t.cont_list.len, tp->t.ofo_queue.qlen, tp->t.data_ofo_queue.qlen);
#endif
				}
				/* 1) Enter recovery mode
				   2) Initiate slow start
				*/
				backedOff = 1;
    1101:	c7 45 f0 01 00 00 00 	movl   $0x1,0xfffffff0(%ebp)
    1108:	ff 05 74 00 00 00    	incl   0x74
				enterRecoveryState(sk, 1);
    110e:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
    1115:	00 
    1116:	89 1c 24             	mov    %ebx,(%esp,1)
    1119:	e8 02 02 00 00       	call   1320 <enterRecoveryState>
#ifdef JAM_SLOWSTART1
				if(trickles_ratelimit()) printk("slow_start_timer: Jam Slowstart 1\n");
				return;
#endif
				requestSlowStart(sk);
    111e:	89 1c 24             	mov    %ebx,(%esp,1)
    1121:	e8 8a 5a 00 00       	call   6bb0 <requestSlowStart>
			} else {
				if(tp->t.conversionState == CONVERSION_IDLE) {
#ifdef STRICT_BUFFER_CHECK
					BUG_TRAP(haveRcvBuf);
#endif
					tp->t.timerState |= TRICKLES_NEED_SLOWSTART;
					//printk("need slowstart 2\n");
					tp->t.timerState &= ~TRICKLES_ENABLE_DATA_TIMEOUT;
				} else {
					if(trickles_ratelimit()) printk("no requests available for timeout ??? \n");
				}
			}
		}
	}
	if(numAcks) {
    1126:	85 ff                	test   %edi,%edi
    1128:	74 10                	je     113a <slow_start_timer+0xca>
		printk("slow start num acks = %d\n", numAcks);
    112a:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
    112e:	c7 04 24 51 00 00 00 	movl   $0x51,(%esp,1)
    1135:	e8 fc ff ff ff       	call   1136 <slow_start_timer+0xc6>
	}
	
	if(!disableTimeout) {
    113a:	a1 00 00 00 00       	mov    0x0,%eax
    113f:	85 c0                	test   %eax,%eax
    1141:	75 1d                	jne    1160 <slow_start_timer+0xf0>
		if(haveRequests || ((tp->t.timerState & TRICKLES_ENABLE_DATA_TIMEOUT) && 
    1143:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    1146:	85 c0                	test   %eax,%eax
    1148:	75 56                	jne    11a0 <slow_start_timer+0x130>
    114a:	f6 86 d8 02 00 00 01 	testb  $0x1,0x2d8(%esi)
    1151:	75 2e                	jne    1181 <slow_start_timer+0x111>
    1153:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    1159:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
	unsigned char c;

	__asm__ __volatile__(
    1160:	ff 4b 28             	decl   0x28(%ebx)
    1163:	0f 94 c0             	sete   %al
    1166:	84 c0                	test   %al,%al
    1168:	75 08                	jne    1172 <slow_start_timer+0x102>
				    findUCContinuation(sk, tp->t.byteReqNext, tp->t.byteReqNext))) {
			if(!backedOff) {
				int newDelay = tp->t.delay;
				newDelay = MIN(newDelay * 2, MAX_SS_TIMEOUT);
				tp->t.delay = newDelay;
			}
			resetClientTimer(sk); // 0504 - back off timer if no progress made
		}
		// TRICKY: If !enable_data_timeout, or no continuation findUCContinuation(), we MUST reset the timer 
		// when those states become true
	}
#ifndef USERTEST
out_unlock:
	bh_unlock_sock(sk);
	sock_put(sk);
#endif // USERTEST
}
    116a:	83 c4 34             	add    $0x34,%esp
    116d:	5b                   	pop    %ebx
    116e:	5e                   	pop    %esi
    116f:	5f                   	pop    %edi
    1170:	5d                   	pop    %ebp
    1171:	c3                   	ret    
/* Ungrab socket and destroy it, if it was the last reference. */
static inline void sock_put(struct sock *sk)
{
	if (atomic_dec_and_test(&sk->refcnt))
		sk_free(sk);
    1172:	89 5d 08             	mov    %ebx,0x8(%ebp)
    1175:	83 c4 34             	add    $0x34,%esp
    1178:	5b                   	pop    %ebx
    1179:	5e                   	pop    %esi
    117a:	5f                   	pop    %edi
    117b:	5d                   	pop    %ebp
    117c:	e9 fc ff ff ff       	jmp    117d <slow_start_timer+0x10d>
    1181:	8b 86 b8 0a 00 00    	mov    0xab8(%esi),%eax
    1187:	89 1c 24             	mov    %ebx,(%esp,1)
    118a:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    118e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    1192:	e8 fc ff ff ff       	call   1193 <slow_start_timer+0x123>
    1197:	85 c0                	test   %eax,%eax
    1199:	74 c5                	je     1160 <slow_start_timer+0xf0>
    119b:	90                   	nop    
    119c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    11a0:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    11a3:	85 c0                	test   %eax,%eax
    11a5:	75 18                	jne    11bf <slow_start_timer+0x14f>
    11a7:	8b 96 d4 02 00 00    	mov    0x2d4(%esi),%edx
    11ad:	b8 c8 00 00 00       	mov    $0xc8,%eax
    11b2:	01 d2                	add    %edx,%edx
    11b4:	39 d0                	cmp    %edx,%eax
    11b6:	0f 4f c2             	cmovg  %edx,%eax
    11b9:	89 86 d4 02 00 00    	mov    %eax,0x2d4(%esi)
    11bf:	89 1c 24             	mov    %ebx,(%esp,1)
    11c2:	e8 fc ff ff ff       	call   11c3 <slow_start_timer+0x153>
    11c7:	eb 97                	jmp    1160 <slow_start_timer+0xf0>
    11c9:	8b 46 08             	mov    0x8(%esi),%eax
    11cc:	89 1c 24             	mov    %ebx,(%esp,1)
    11cf:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    11d3:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    11d7:	e8 fc ff ff ff       	call   11d8 <slow_start_timer+0x168>
    11dc:	85 c0                	test   %eax,%eax
    11de:	0f 85 1d ff ff ff    	jne    1101 <slow_start_timer+0x91>
    11e4:	8b 86 c0 0a 00 00    	mov    0xac0(%esi),%eax
    11ea:	85 c0                	test   %eax,%eax
    11ec:	75 17                	jne    1205 <slow_start_timer+0x195>
    11ee:	8b 86 d8 02 00 00    	mov    0x2d8(%esi),%eax
    11f4:	83 c8 02             	or     $0x2,%eax
    11f7:	83 e0 fe             	and    $0xfffffffe,%eax
    11fa:	89 86 d8 02 00 00    	mov    %eax,0x2d8(%esi)
    1200:	e9 21 ff ff ff       	jmp    1126 <slow_start_timer+0xb6>
    1205:	a1 00 00 00 00       	mov    0x0,%eax
    120a:	9c                   	pushf  
    120b:	59                   	pop    %ecx
    120c:	fa                   	cli    
    120d:	89 c2                	mov    %eax,%edx
    120f:	2b 15 34 e2 04 00    	sub    0x4e234,%edx
    1215:	a3 34 e2 04 00       	mov    %eax,0x4e234
    121a:	03 15 78 00 00 00    	add    0x78,%edx
    1220:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    1226:	89 15 78 00 00 00    	mov    %edx,0x78
    122c:	76 0f                	jbe    123d <slow_start_timer+0x1cd>
    122e:	b8 88 13 00 00       	mov    $0x1388,%eax
    1233:	ba 88 13 00 00       	mov    $0x1388,%edx
    1238:	a3 78 00 00 00       	mov    %eax,0x78
    123d:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    1243:	76 61                	jbe    12a6 <slow_start_timer+0x236>
    1245:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    124b:	a1 38 e2 04 00       	mov    0x4e238,%eax
    1250:	89 15 78 00 00 00    	mov    %edx,0x78
    1256:	c7 05 38 e2 04 00 00 	movl   $0x0,0x4e238
    125d:	00 00 00 
    1260:	51                   	push   %ecx
    1261:	9d                   	popf   
    1262:	85 c0                	test   %eax,%eax
    1264:	75 1e                	jne    1284 <slow_start_timer+0x214>
    1266:	b8 01 00 00 00       	mov    $0x1,%eax
    126b:	85 c0                	test   %eax,%eax
    126d:	0f 84 b3 fe ff ff    	je     1126 <slow_start_timer+0xb6>
    1273:	c7 04 24 80 02 00 00 	movl   $0x280,(%esp,1)
    127a:	e8 fc ff ff ff       	call   127b <slow_start_timer+0x20b>
    127f:	e9 a2 fe ff ff       	jmp    1126 <slow_start_timer+0xb6>
    1284:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    1288:	c7 44 24 08 c6 02 00 	movl   $0x2c6,0x8(%esp,1)
    128f:	00 
    1290:	c7 44 24 04 6b 00 00 	movl   $0x6b,0x4(%esp,1)
    1297:	00 
    1298:	c7 04 24 c0 02 00 00 	movl   $0x2c0,(%esp,1)
    129f:	e8 fc ff ff ff       	call   12a0 <slow_start_timer+0x230>
    12a4:	eb c0                	jmp    1266 <slow_start_timer+0x1f6>
    12a6:	ff 05 38 e2 04 00    	incl   0x4e238
    12ac:	51                   	push   %ecx
    12ad:	9d                   	popf   
    12ae:	31 c0                	xor    %eax,%eax
    12b0:	eb b9                	jmp    126b <slow_start_timer+0x1fb>
    12b2:	8b 86 b8 0a 00 00    	mov    0xab8(%esi),%eax
    12b8:	89 1c 24             	mov    %ebx,(%esp,1)
    12bb:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    12bf:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    12c3:	e8 fc ff ff ff       	call   12c4 <slow_start_timer+0x254>
    12c8:	85 c0                	test   %eax,%eax
    12ca:	0f 85 1a fe ff ff    	jne    10ea <slow_start_timer+0x7a>
    12d0:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    12d3:	85 c9                	test   %ecx,%ecx
    12d5:	0f 84 4b fe ff ff    	je     1126 <slow_start_timer+0xb6>
    12db:	e9 0a fe ff ff       	jmp    10ea <slow_start_timer+0x7a>

000012e0 <trickles_client_connected_impl>:

static void trickles_client_connected_impl(struct sock *sk) {
    12e0:	55                   	push   %ebp
    12e1:	89 e5                	mov    %esp,%ebp
    12e3:	83 ec 0c             	sub    $0xc,%esp
    12e6:	89 5d f8             	mov    %ebx,0xfffffff8(%ebp)
    12e9:	8b 5d 08             	mov    0x8(%ebp),%ebx
    12ec:	89 75 fc             	mov    %esi,0xfffffffc(%ebp)
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    12ef:	8d b3 bc 00 00 00    	lea    0xbc(%ebx),%esi
	/* Called once client establishes connection */
	/* 1) Clear all timers
	   2) Initialize trickles timeout timer 
	*/
#ifndef USERTEST
	tcp_clear_xmit_timers(sk);
    12f5:	89 1c 24             	mov    %ebx,(%esp,1)
    12f8:	e8 fc ff ff ff       	call   12f9 <trickles_client_connected_impl+0x19>
	tp->t.slowstart_timer.function = &slow_start_timer;
    12fd:	b8 00 00 00 00       	mov    $0x0,%eax
	tp->t.slowstart_timer.data = (long)sk;
    1302:	89 9e 40 0a 00 00    	mov    %ebx,0xa40(%esi)
    1308:	89 86 44 0a 00 00    	mov    %eax,0xa44(%esi)
	resetClientTimer(sk);
    130e:	8b 75 fc             	mov    0xfffffffc(%ebp),%esi
    1311:	89 5d 08             	mov    %ebx,0x8(%ebp)
    1314:	8b 5d f8             	mov    0xfffffff8(%ebp),%ebx
    1317:	89 ec                	mov    %ebp,%esp
    1319:	5d                   	pop    %ebp
    131a:	e9 fc ff ff ff       	jmp    131b <trickles_client_connected_impl+0x3b>
    131f:	90                   	nop    

00001320 <enterRecoveryState>:
#endif // USERTEST
}

inline int Sack_contains(Sack *sack, int seq);

#if 0
// replaced with rebuildAckProof (cleaner design)
static void advanceAckProof(AckProof *proof, __u32 seq) {
	int i, j;
	for(i=0; i < proof->numSacks; i++) {
		if(Sack_contains(&proof->sacks[i], seq)) {
			break;
		}
	}
	if(i == proof->numSacks) {
		printk("advanceAckProof Error: Could not find target seqnum\n");
		proof->numSacks = 0;
		return;
	}
	for(j=0; j < proof->numSacks - i; j++) {
		proof->sacks[j] = proof->sacks[i + j];
	}
	proof->numSacks = proof->numSacks - i;
}
#endif

//#define CURR_CONT(X) ((CONTINUATION_TYPE *)((X)->tp_pinfo.af_tcp.t.ack_curr ? (X)->tp_pinfo.af_tcp.t.ack_curr : (X)->tp_pinfo.af_tcp.t.ack_prev))

void AckProof_dump(AckProof *proof);
static void enterRecoveryState(struct sock *sk, int reqSlowStart) {
    1320:	55                   	push   %ebp
    1321:	89 e5                	mov    %esp,%ebp
    1323:	83 ec 14             	sub    $0x14,%esp
    1326:	89 7d fc             	mov    %edi,0xfffffffc(%ebp)
    1329:	8b 7d 08             	mov    0x8(%ebp),%edi
    132c:	8b 55 0c             	mov    0xc(%ebp),%edx
    132f:	89 5d f4             	mov    %ebx,0xfffffff4(%ebp)
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    1332:	8d 9f bc 00 00 00    	lea    0xbc(%edi),%ebx
    1338:	89 75 f8             	mov    %esi,0xfffffff8(%ebp)
	int newDelay = tp->t.delay;

#ifdef SLOWSTART_ONLY
	reqSlowStart = 1;
#endif
	// enterRecoveryState may be called multiple times 
	// during the same Fast Recovery, but only once per SlowStart attempt
#ifdef JAM_SLOWSTART
	if(trickles_ratelimit()) printk("Jam slowstart - enterRecoverystate\n");
	return;
#endif
	switch(tp->t.state) {
    133b:	8b 83 cc 02 00 00    	mov    0x2cc(%ebx),%eax
    1341:	8b b3 d4 02 00 00    	mov    0x2d4(%ebx),%esi
    1347:	83 f8 02             	cmp    $0x2,%eax
    134a:	0f 84 45 01 00 00    	je     1495 <enterRecoveryState+0x175>
    1350:	83 f8 02             	cmp    $0x2,%eax
    1353:	0f 8f dd 00 00 00    	jg     1436 <enterRecoveryState+0x116>
    1359:	48                   	dec    %eax
    135a:	74 24                	je     1380 <enterRecoveryState+0x60>
	case TRICKLES_CLIENT_NORMAL:
		if(reqSlowStart) {
			if(clientDebugLevel >= 1 || debugTransitions)
				printk("%p: Normal=>SlowStart\n", sk);
			tp->t.state = TRICKLES_CLIENT_SLOWSTART;
			newDelay = MIN(newDelay * 6, MAX_SS_TIMEOUT);
			tp->t.clientStateCounter++;
			tp->t.request_snd_nxt++;
			tp->t.request_rcv_nxt = tp->t.request_snd_nxt;
		} else {
			if(clientDebugLevel >= 1 || debugTransitions) {
				printk("%p: Normal=>Recovery\n", sk);
				AckProof_dump(&tp->t.altProof);
			}
			tp->t.state = TRICKLES_CLIENT_RECOVERY;
			newDelay = MIN(newDelay * 2, MAX_SS_TIMEOUT);
			tp->t.clientStateCounter++;
		}
		break;
	case TRICKLES_CLIENT_RECOVERY:
		if(reqSlowStart) {
			tp->t.state = TRICKLES_CLIENT_SLOWSTART;
			newDelay = MIN(newDelay * 3, MAX_SS_TIMEOUT); // 2 * 3 = 6
			if(clientDebugLevel >= 1 || debugTransitions)
				printk("%p: Recovery=>SlowStart\n", sk);
			tp->t.clientStateCounter++;
			tp->t.request_snd_nxt++;
			tp->t.request_rcv_nxt = tp->t.request_snd_nxt;
		} else {
			// already in recovery state; take no action
			if(clientDebugLevel >= 1 || debugTransitions) {
				printk("%p: Recovery=>Recovery\n", sk);
				AckProof_dump(&tp->t.altProof);
			}
			// DO NOT UPDATE CLIENTSTATE COUNTER (or any other state)
			return;
		}
		break;
	case TRICKLES_CLIENT_SLOWSTART:
		BUG_TRAP(reqSlowStart);
		newDelay = MIN(newDelay * 2, MAX_SS_TIMEOUT);
		if(clientDebugLevel >= 1 || debugTransitions)
			printk("%p: SlowStart=>SlowStart\n", sk);
		// Unlike client_recovery=>client_recovery transition,
		// take action: send another slow start request
		tp->t.clientStateCounter++;
		tp->t.request_snd_nxt++;
		tp->t.request_rcv_nxt = tp->t.request_snd_nxt;
		break;
	}

	tp->t.delay = MAX(newDelay, MIN_SS_TIMEOUT);
    135c:	b8 05 00 00 00       	mov    $0x5,%eax
    1361:	39 f0                	cmp    %esi,%eax
    1363:	0f 4c c6             	cmovl  %esi,%eax
    1366:	89 83 d4 02 00 00    	mov    %eax,0x2d4(%ebx)
}
    136c:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
    136f:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
    1372:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
    1375:	89 ec                	mov    %ebp,%esp
    1377:	5d                   	pop    %ebp
    1378:	c3                   	ret    
    1379:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    1380:	85 d2                	test   %edx,%edx
    1382:	74 5b                	je     13df <enterRecoveryState+0xbf>
    1384:	a1 00 00 00 00       	mov    0x0,%eax
    1389:	85 c0                	test   %eax,%eax
    138b:	7e 47                	jle    13d4 <enterRecoveryState+0xb4>
    138d:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
    1391:	c7 04 24 76 00 00 00 	movl   $0x76,(%esp,1)
    1398:	e8 fc ff ff ff       	call   1399 <enterRecoveryState+0x79>
    139d:	b8 03 00 00 00       	mov    $0x3,%eax
    13a2:	ba c8 00 00 00       	mov    $0xc8,%edx
    13a7:	89 83 cc 02 00 00    	mov    %eax,0x2cc(%ebx)
    13ad:	8d 04 76             	lea    (%esi,%esi,2),%eax
    13b0:	01 c0                	add    %eax,%eax
    13b2:	39 c2                	cmp    %eax,%edx
    13b4:	89 c6                	mov    %eax,%esi
    13b6:	0f 4e f2             	cmovle %edx,%esi
    13b9:	ff 83 c8 02 00 00    	incl   0x2c8(%ebx)
    13bf:	8b 83 4c 0a 00 00    	mov    0xa4c(%ebx),%eax
    13c5:	40                   	inc    %eax
    13c6:	89 83 4c 0a 00 00    	mov    %eax,0xa4c(%ebx)
    13cc:	89 83 48 0a 00 00    	mov    %eax,0xa48(%ebx)
    13d2:	eb 88                	jmp    135c <enterRecoveryState+0x3c>
    13d4:	a1 00 00 00 00       	mov    0x0,%eax
    13d9:	85 c0                	test   %eax,%eax
    13db:	74 c0                	je     139d <enterRecoveryState+0x7d>
    13dd:	eb ae                	jmp    138d <enterRecoveryState+0x6d>
    13df:	a1 00 00 00 00       	mov    0x0,%eax
    13e4:	85 c0                	test   %eax,%eax
    13e6:	7e 43                	jle    142b <enterRecoveryState+0x10b>
    13e8:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
    13ec:	c7 04 24 8d 00 00 00 	movl   $0x8d,(%esp,1)
    13f3:	e8 fc ff ff ff       	call   13f4 <enterRecoveryState+0xd4>
    13f8:	8d 87 c4 06 00 00    	lea    0x6c4(%edi),%eax
    13fe:	89 04 24             	mov    %eax,(%esp,1)
    1401:	e8 fc ff ff ff       	call   1402 <enterRecoveryState+0xe2>
    1406:	8d 04 36             	lea    (%esi,%esi,1),%eax
    1409:	ba c8 00 00 00       	mov    $0xc8,%edx
    140e:	39 c2                	cmp    %eax,%edx
    1410:	bf 02 00 00 00       	mov    $0x2,%edi
    1415:	89 c6                	mov    %eax,%esi
    1417:	0f 4e f2             	cmovle %edx,%esi
    141a:	89 bb cc 02 00 00    	mov    %edi,0x2cc(%ebx)
    1420:	ff 83 c8 02 00 00    	incl   0x2c8(%ebx)
    1426:	e9 31 ff ff ff       	jmp    135c <enterRecoveryState+0x3c>
    142b:	a1 00 00 00 00       	mov    0x0,%eax
    1430:	85 c0                	test   %eax,%eax
    1432:	74 d2                	je     1406 <enterRecoveryState+0xe6>
    1434:	eb b2                	jmp    13e8 <enterRecoveryState+0xc8>
    1436:	83 f8 03             	cmp    $0x3,%eax
    1439:	0f 85 1d ff ff ff    	jne    135c <enterRecoveryState+0x3c>
    143f:	85 d2                	test   %edx,%edx
    1441:	74 3c                	je     147f <enterRecoveryState+0x15f>
    1443:	8d 04 36             	lea    (%esi,%esi,1),%eax
    1446:	ba c8 00 00 00       	mov    $0xc8,%edx
    144b:	39 c2                	cmp    %eax,%edx
    144d:	89 c6                	mov    %eax,%esi
    144f:	a1 00 00 00 00       	mov    0x0,%eax
    1454:	0f 4e f2             	cmovle %edx,%esi
    1457:	85 c0                	test   %eax,%eax
    1459:	7e 15                	jle    1470 <enterRecoveryState+0x150>
    145b:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
    145f:	c7 04 24 a3 00 00 00 	movl   $0xa3,(%esp,1)
    1466:	e8 fc ff ff ff       	call   1467 <enterRecoveryState+0x147>
    146b:	e9 49 ff ff ff       	jmp    13b9 <enterRecoveryState+0x99>
    1470:	a1 00 00 00 00       	mov    0x0,%eax
    1475:	85 c0                	test   %eax,%eax
    1477:	0f 84 3c ff ff ff    	je     13b9 <enterRecoveryState+0x99>
    147d:	eb dc                	jmp    145b <enterRecoveryState+0x13b>
    147f:	c7 44 24 04 40 03 00 	movl   $0x340,0x4(%esp,1)
    1486:	00 
    1487:	c7 04 24 00 03 00 00 	movl   $0x300,(%esp,1)
    148e:	e8 fc ff ff ff       	call   148f <enterRecoveryState+0x16f>
    1493:	eb ae                	jmp    1443 <enterRecoveryState+0x123>
    1495:	85 d2                	test   %edx,%edx
    1497:	74 47                	je     14e0 <enterRecoveryState+0x1c0>
    1499:	b9 03 00 00 00       	mov    $0x3,%ecx
    149e:	8d 14 76             	lea    (%esi,%esi,2),%edx
    14a1:	b8 c8 00 00 00       	mov    $0xc8,%eax
    14a6:	89 8b cc 02 00 00    	mov    %ecx,0x2cc(%ebx)
    14ac:	39 d0                	cmp    %edx,%eax
    14ae:	89 d6                	mov    %edx,%esi
    14b0:	8b 15 00 00 00 00    	mov    0x0,%edx
    14b6:	0f 4e f0             	cmovle %eax,%esi
    14b9:	85 d2                	test   %edx,%edx
    14bb:	7e 0d                	jle    14ca <enterRecoveryState+0x1aa>
    14bd:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
    14c1:	c7 04 24 bd 00 00 00 	movl   $0xbd,(%esp,1)
    14c8:	eb 9c                	jmp    1466 <enterRecoveryState+0x146>
    14ca:	a1 00 00 00 00       	mov    0x0,%eax
    14cf:	85 c0                	test   %eax,%eax
    14d1:	0f 84 e2 fe ff ff    	je     13b9 <enterRecoveryState+0x99>
    14d7:	eb e4                	jmp    14bd <enterRecoveryState+0x19d>
    14d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    14e0:	a1 00 00 00 00       	mov    0x0,%eax
    14e5:	85 c0                	test   %eax,%eax
    14e7:	7e 2a                	jle    1513 <enterRecoveryState+0x1f3>
    14e9:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
    14ed:	c7 04 24 d6 00 00 00 	movl   $0xd6,(%esp,1)
    14f4:	e8 fc ff ff ff       	call   14f5 <enterRecoveryState+0x1d5>
    14f9:	8d 87 c4 06 00 00    	lea    0x6c4(%edi),%eax
    14ff:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
    1502:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
    1505:	89 45 08             	mov    %eax,0x8(%ebp)
    1508:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
    150b:	89 ec                	mov    %ebp,%esp
    150d:	5d                   	pop    %ebp
    150e:	e9 fc ff ff ff       	jmp    150f <enterRecoveryState+0x1ef>
    1513:	a1 00 00 00 00       	mov    0x0,%eax
    1518:	85 c0                	test   %eax,%eax
    151a:	0f 84 4c fe ff ff    	je     136c <enterRecoveryState+0x4c>
    1520:	eb c7                	jmp    14e9 <enterRecoveryState+0x1c9>
    1522:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    1529:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00001530 <ContList_insert>:

#if 0
static void AckProof_rebuild(struct sock *sk, AckProof *proof) {
	struct sk_buff *skb;
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	CONTINUATION_TYPE *cont	=
		(CONTINUATION_TYPE *)tp->t.cont_list.next;

	proof->numSacks = 0;
	/* Todo: check if faster algorithm would help */
	if(cont != &tp->t.cont_list) {
		BUG_TRAP(cont->seq >= CURR_CONT(sk)->TCPBase);
	}
	while(cont != &tp->t.cont_list) {
		AckProof_update(sk, proof, cont);
		cont = cont->next;
	}
	/* TODO: add poison detection */
	skb_queue_walk(&tp->t.ofo_queue, skb) {
		AckProof_update(sk, proof, TCP_SKB_CB(skb)->cont);
	}
}
#endif

#define NEWER(S0,S1) ((S0)>(S1))
static void ContList_insert(struct sock *sk, CONTINUATION_TYPE *cont) {
    1530:	55                   	push   %ebp
    1531:	89 e5                	mov    %esp,%ebp
    1533:	57                   	push   %edi
    1534:	56                   	push   %esi
    1535:	53                   	push   %ebx
    1536:	83 ec 20             	sub    $0x20,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	CONTINUATION_TYPE *cont_curs, *currentVal = cont, *newCont;
	/* sorted insert into cont list */
	int replaced = 0;
	int replaceAckPrev = 0;
    1539:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
    1540:	8b 5d 08             	mov    0x8(%ebp),%ebx
    1543:	8b 45 0c             	mov    0xc(%ebp),%eax
    1546:	8d 93 bc 00 00 00    	lea    0xbc(%ebx),%edx
	if(tp->t.previous_base > cont->TCPBase) {
    154c:	89 c1                	mov    %eax,%ecx
    154e:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    1551:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
    1554:	8b 40 70             	mov    0x70(%eax),%eax
    1557:	39 82 e0 02 00 00    	cmp    %eax,0x2e0(%edx)
    155d:	0f 87 9c 03 00 00    	ja     18ff <ContList_insert+0x3cf>
		printk("previous base > cont->TCPBase. clientstate %d clientstatecounter %d\n", cont->clientState, tp->t.clientStateCounter);
	}
	for(cont_curs = (CONTINUATION_TYPE*)tp->t.cont_list.prev;
    1563:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    1566:	8b b0 20 0a 00 00    	mov    0xa20(%eax),%esi
    156c:	8d 83 dc 0a 00 00    	lea    0xadc(%ebx),%eax
    1572:	39 c6                	cmp    %eax,%esi
    1574:	0f 84 77 03 00 00    	je     18f1 <ContList_insert+0x3c1>
    157a:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    157d:	8b 51 34             	mov    0x34(%ecx),%edx
	    cont_curs != (CONTINUATION_TYPE*)&tp->t.cont_list;
	    cont_curs=cont_curs->prev) {
		if(cont_curs->seq < cont->seq) 
    1580:	39 56 34             	cmp    %edx,0x34(%esi)
    1583:	72 06                	jb     158b <ContList_insert+0x5b>
    1585:	8b 36                	mov    (%esi),%esi
    1587:	39 c6                	cmp    %eax,%esi
    1589:	75 f5                	jne    1580 <ContList_insert+0x50>
			break;
	}
	if(cont_curs->next != (CONTINUATION_TYPE*)&tp->t.cont_list &&
    158b:	8b 7e 04             	mov    0x4(%esi),%edi
    158e:	39 c7                	cmp    %eax,%edi
    1590:	74 0f                	je     15a1 <ContList_insert+0x71>
    1592:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    1595:	8b 41 34             	mov    0x34(%ecx),%eax
    1598:	39 47 34             	cmp    %eax,0x34(%edi)
    159b:	0f 84 85 01 00 00    	je     1726 <ContList_insert+0x1f6>
#else  //0426 - change kernel to slab cache
#ifndef USESLAB
  CONTINUATION_TYPE *rval = kmalloc(2 * sizeof(CONTINUATION_TYPE), flags);  // 0502 maybe slab cache usage is buggy
#else
  CONTINUATION_TYPE *rval = kmem_cache_alloc(clientSideContinuation_cache, GFP_ATOMIC);
    15a1:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    15a8:	00 
    15a9:	a1 00 00 00 00       	mov    0x0,%eax
    15ae:	89 04 24             	mov    %eax,(%esp,1)
    15b1:	e8 fc ff ff ff       	call   15b2 <ContList_insert+0x82>
#endif
#endif

#ifdef DEBUG_TRICKLES_ALLOCATION // 0418
  numContinuations++;
#endif

  // 0501 - attempting to track down corruption bug
#ifdef DEBUG_ALLOC
#ifndef USERTEST
  if(((int)rval) & 0xfff) {
	  printk("incorrect alignment\n");
	  BUG();
  }
#endif // USERTEST
#endif // DEBUG_ALLOC

  if(rval == NULL) {
    15b6:	85 c0                	test   %eax,%eax
    15b8:	89 c3                	mov    %eax,%ebx
    15ba:	0f 84 53 01 00 00    	je     1713 <ContList_insert+0x1e3>
    printk("out of memory while allocating continuation to copy\n");
    return NULL;
  }
  rval->prev = rval->next = NULL;
    15c0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    15c7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  rval->list = NULL;
    15cd:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  memcpy(rval, cont, (int)((CONTINUATION_TYPE *)0)->clientside_copy_end);
    15d4:	c7 44 24 08 dc 00 00 	movl   $0xdc,0x8(%esp,1)
    15db:	00 
    15dc:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    15df:	89 04 24             	mov    %eax,(%esp,1)
    15e2:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    15e6:	e8 85 6c 00 00       	call   8270 <__constant_memcpy>
  for(i=0; i < 2; i++) {
    15eb:	ba 01 00 00 00       	mov    $0x1,%edx
    15f0:	8d 83 d4 00 00 00    	lea    0xd4(%ebx),%eax
	  (rval+i)->ucont_len = 0;
    15f6:	c7 40 a8 00 00 00 00 	movl   $0x0,0xffffffa8(%eax)
	  (rval+i)->ucont_data = NULL;
    15fd:	c7 40 ac 00 00 00 00 	movl   $0x0,0xffffffac(%eax)
	  (rval+i)->input_len = 0;
    1604:	c7 40 b0 00 00 00 00 	movl   $0x0,0xffffffb0(%eax)
	  (rval+i)->input = NULL;
    160b:	c7 40 b4 00 00 00 00 	movl   $0x0,0xffffffb4(%eax)
	  // 0429 null mark
	  (rval+i)->mark = 0;
    1612:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	  (rval+i)->simulated = 0;
    1619:	c7 40 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%eax)
	  (rval+i)->num_packets = 0;
    1620:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	  (rval+i)->actualCwnd = 0;
    1627:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    162d:	05 e4 00 00 00       	add    $0xe4,%eax
    1632:	4a                   	dec    %edx
    1633:	79 c1                	jns    15f6 <ContList_insert+0xc6>
  }
    1635:	89 d8                	mov    %ebx,%eax
	   cont_curs->next->seq == cont->seq) {
		CONTINUATION_TYPE *dup = cont_curs->next;
		if(NEWER(cont->clientState, dup->clientState)) {
			newCont = copyClientSide_Continuation(cont, GFP_ATOMIC);
			if(newCont == NULL) {
				printk("ContList_Insert(1); out of memory\n");
				goto skip_insert;
			}

			replaced = 1;
			// get rid of old one
			if(tp->t.ack_prev == dup)
				replaceAckPrev = 1;
			if(clientDebugLevel >= 2)
				printk("Got rid of old cont %u\n", dup->seq);
			unlinkCont(dup);
			MARK_PC(dup);
			freeClientSide_Continuation(dup);
			goto skip_alloc;
		} else {
			// dont use new one
			if(tp->t.ack_prev == cont)
				printk("ContList_insert: invalid condition\n");
			if(clientDebugLevel >= 2)
				printk("Got rid of new cont %u\n", cont->seq);
			currentVal = dup;
			goto skip_insert;
		}
	}
	/* create copy for transport-level acking and processing */
	newCont = copyClientSide_Continuation(cont, GFP_ATOMIC);
	if(newCont == NULL) {
    1637:	85 c0                	test   %eax,%eax
  }
  return rval;
}

static inline CONTINUATION_TYPE *copyClientSide_Continuation(CONTINUATION_TYPE *cont, int flags) {
    1639:	89 c3                	mov    %eax,%ebx
    163b:	0f 84 bf 00 00 00    	je     1700 <ContList_insert+0x1d0>
		printk("ContList_Insert: Out of memory\n");
		goto skip_insert;
	}
	skip_alloc:
	newCont->mark |= 0x2;
    1641:	83 8b d8 00 00 00 02 	orl    $0x2,0xd8(%ebx)

	// don't need user-level data while performing transport-level processing
	newCont->ucont_data = NULL;
    1648:	31 c0                	xor    %eax,%eax
	elem->list->len--;
	elem->list = NULL;
}

static inline void insert(struct alloc_head *elem, struct alloc_head *prev, struct alloc_head *next) {
    164a:	8b 7e 04             	mov    0x4(%esi),%edi
    164d:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	newCont->input = NULL;
    1653:	31 c0                	xor    %eax,%eax
    1655:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
		BUG();
	}
#endif

	if(!(elem->next == NULL && elem->prev == NULL)) BUG();
    165b:	8b 43 04             	mov    0x4(%ebx),%eax
    165e:	85 c0                	test   %eax,%eax
    1660:	75 06                	jne    1668 <ContList_insert+0x138>
    1662:	8b 0b                	mov    (%ebx),%ecx
    1664:	85 c9                	test   %ecx,%ecx
    1666:	74 19                	je     1681 <ContList_insert+0x151>
    1668:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    166f:	00 
    1670:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    1677:	e8 fc ff ff ff       	call   1678 <ContList_insert+0x148>
    167c:	e8 fc ff ff ff       	call   167d <ContList_insert+0x14d>
	elem->next = prev->next;
	prev->next = elem;

	elem->prev = prev;
    1681:	89 33                	mov    %esi,(%ebx)
    1683:	8b 46 04             	mov    0x4(%esi),%eax
	next->prev = elem;
    1686:	89 1f                	mov    %ebx,(%edi)
    1688:	89 43 04             	mov    %eax,0x4(%ebx)

	elem->list = prev->list;
    168b:	8b 46 08             	mov    0x8(%esi),%eax
    168e:	89 5e 04             	mov    %ebx,0x4(%esi)
    1691:	89 43 08             	mov    %eax,0x8(%ebx)
	elem->list->len++;
    1694:	ff 40 10             	incl   0x10(%eax)
	insert((struct alloc_head*)newCont, (struct alloc_head*)cont_curs, (struct alloc_head*)cont_curs->next);
	if(replaceAckPrev || tp->t.ack_prev == cont) {
    1697:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    169a:	85 d2                	test   %edx,%edx
    169c:	75 55                	jne    16f3 <ContList_insert+0x1c3>
    169e:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    16a1:	8b 82 f0 02 00 00    	mov    0x2f0(%edx),%eax
    16a7:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
    16aa:	74 47                	je     16f3 <ContList_insert+0x1c3>
		tp->t.ack_prev = newCont;
		INTEGRITY_CHECK(sk, tp->t.ack_prev);
		SAVE_ACK_PREV(tp);
	}
	if(!(!tp->t.ack_prev || tp->t.ack_prev->next)) {
    16ac:	85 c0                	test   %eax,%eax
    16ae:	74 07                	je     16b7 <ContList_insert+0x187>
    16b0:	8b 40 04             	mov    0x4(%eax),%eax
    16b3:	85 c0                	test   %eax,%eax
    16b5:	74 08                	je     16bf <ContList_insert+0x18f>
		// 0429
		BUG_TRAP((!tp->t.ack_prev || tp->t.ack_prev->next));
		BUG();
	}
 skip_insert:
	;
}
    16b7:	83 c4 20             	add    $0x20,%esp
    16ba:	5b                   	pop    %ebx
    16bb:	5e                   	pop    %esi
    16bc:	5f                   	pop    %edi
    16bd:	5d                   	pop    %ebp
    16be:	c3                   	ret    
    16bf:	c7 44 24 04 a8 03 00 	movl   $0x3a8,0x4(%esp,1)
    16c6:	00 
    16c7:	c7 04 24 40 03 00 00 	movl   $0x340,(%esp,1)
    16ce:	e8 fc ff ff ff       	call   16cf <ContList_insert+0x19f>
    16d3:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    16da:	00 
    16db:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    16e2:	e8 fc ff ff ff       	call   16e3 <ContList_insert+0x1b3>
    16e7:	83 c4 20             	add    $0x20,%esp
    16ea:	5b                   	pop    %ebx
    16eb:	5e                   	pop    %esi
    16ec:	5f                   	pop    %edi
    16ed:	5d                   	pop    %ebp
    16ee:	e9 fc ff ff ff       	jmp    16ef <ContList_insert+0x1bf>
    16f3:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    16f6:	89 d8                	mov    %ebx,%eax
    16f8:	89 99 f0 02 00 00    	mov    %ebx,0x2f0(%ecx)
    16fe:	eb ac                	jmp    16ac <ContList_insert+0x17c>
    1700:	c7 45 08 a0 03 00 00 	movl   $0x3a0,0x8(%ebp)
    1707:	83 c4 20             	add    $0x20,%esp
    170a:	5b                   	pop    %ebx
    170b:	5e                   	pop    %esi
    170c:	5f                   	pop    %edi
    170d:	5d                   	pop    %ebp
    170e:	e9 fc ff ff ff       	jmp    170f <ContList_insert+0x1df>
#endif // USERTEST
#endif // DEBUG_ALLOC

  if(rval == NULL) {
    printk("out of memory while allocating continuation to copy\n");
    1713:	c7 04 24 c0 03 00 00 	movl   $0x3c0,(%esp,1)
    171a:	e8 fc ff ff ff       	call   171b <ContList_insert+0x1eb>
    171f:	31 c0                	xor    %eax,%eax
    1721:	e9 11 ff ff ff       	jmp    1637 <ContList_insert+0x107>
    1726:	8b 47 3c             	mov    0x3c(%edi),%eax
    1729:	39 41 3c             	cmp    %eax,0x3c(%ecx)
    172c:	77 44                	ja     1772 <ContList_insert+0x242>
    172e:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    1731:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    1734:	39 81 f0 02 00 00    	cmp    %eax,0x2f0(%ecx)
    173a:	74 28                	je     1764 <ContList_insert+0x234>
    173c:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    1743:	0f 8e 6e ff ff ff    	jle    16b7 <ContList_insert+0x187>
    1749:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    174c:	8b 42 34             	mov    0x34(%edx),%eax
    174f:	c7 04 24 ee 00 00 00 	movl   $0xee,(%esp,1)
    1756:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    175a:	e8 fc ff ff ff       	call   175b <ContList_insert+0x22b>
    175f:	e9 53 ff ff ff       	jmp    16b7 <ContList_insert+0x187>
    1764:	c7 04 24 00 04 00 00 	movl   $0x400,(%esp,1)
    176b:	e8 fc ff ff ff       	call   176c <ContList_insert+0x23c>
    1770:	eb ca                	jmp    173c <ContList_insert+0x20c>
#else  //0426 - change kernel to slab cache
#ifndef USESLAB
  CONTINUATION_TYPE *rval = kmalloc(2 * sizeof(CONTINUATION_TYPE), flags);  // 0502 maybe slab cache usage is buggy
#else
  CONTINUATION_TYPE *rval = kmem_cache_alloc(clientSideContinuation_cache, GFP_ATOMIC);
    1772:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    1779:	00 
    177a:	a1 00 00 00 00       	mov    0x0,%eax
    177f:	89 04 24             	mov    %eax,(%esp,1)
    1782:	e8 fc ff ff ff       	call   1783 <ContList_insert+0x253>
#endif
#endif

#ifdef DEBUG_TRICKLES_ALLOCATION // 0418
  numContinuations++;
#endif

  // 0501 - attempting to track down corruption bug
#ifdef DEBUG_ALLOC
#ifndef USERTEST
  if(((int)rval) & 0xfff) {
	  printk("incorrect alignment\n");
	  BUG();
  }
#endif // USERTEST
#endif // DEBUG_ALLOC

  if(rval == NULL) {
    1787:	85 c0                	test   %eax,%eax
    1789:	89 c3                	mov    %eax,%ebx
    178b:	0f 84 4d 01 00 00    	je     18de <ContList_insert+0x3ae>
    printk("out of memory while allocating continuation to copy\n");
    return NULL;
  }
  rval->prev = rval->next = NULL;
    1791:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    1798:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  rval->list = NULL;
    179e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  memcpy(rval, cont, (int)((CONTINUATION_TYPE *)0)->clientside_copy_end);
    17a5:	c7 44 24 08 dc 00 00 	movl   $0xdc,0x8(%esp,1)
    17ac:	00 
    17ad:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    17b0:	89 1c 24             	mov    %ebx,(%esp,1)
    17b3:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    17b7:	e8 b4 6a 00 00       	call   8270 <__constant_memcpy>
  for(i=0; i < 2; i++) {
    17bc:	ba 01 00 00 00       	mov    $0x1,%edx
    17c1:	8d 83 d4 00 00 00    	lea    0xd4(%ebx),%eax
	  (rval+i)->ucont_len = 0;
    17c7:	c7 40 a8 00 00 00 00 	movl   $0x0,0xffffffa8(%eax)
	  (rval+i)->ucont_data = NULL;
    17ce:	c7 40 ac 00 00 00 00 	movl   $0x0,0xffffffac(%eax)
	  (rval+i)->input_len = 0;
    17d5:	c7 40 b0 00 00 00 00 	movl   $0x0,0xffffffb0(%eax)
	  (rval+i)->input = NULL;
    17dc:	c7 40 b4 00 00 00 00 	movl   $0x0,0xffffffb4(%eax)
	  // 0429 null mark
	  (rval+i)->mark = 0;
    17e3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	  (rval+i)->simulated = 0;
    17ea:	c7 40 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%eax)
	  (rval+i)->num_packets = 0;
    17f1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	  (rval+i)->actualCwnd = 0;
    17f8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    17fe:	05 e4 00 00 00       	add    $0xe4,%eax
    1803:	4a                   	dec    %edx
    1804:	79 c1                	jns    17c7 <ContList_insert+0x297>
  }
    1806:	89 d8                	mov    %ebx,%eax
    1808:	85 c0                	test   %eax,%eax
  }
  return rval;
}

static inline CONTINUATION_TYPE *copyClientSide_Continuation(CONTINUATION_TYPE *cont, int flags) {
    180a:	89 c3                	mov    %eax,%ebx
    180c:	0f 84 c0 00 00 00    	je     18d2 <ContList_insert+0x3a2>
    1812:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    1815:	b8 01 00 00 00       	mov    $0x1,%eax
    181a:	39 ba f0 02 00 00    	cmp    %edi,0x2f0(%edx)
    1820:	0f 45 45 e8          	cmovne 0xffffffe8(%ebp),%eax
    1824:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    182b:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    182e:	0f 8f 86 00 00 00    	jg     18ba <ContList_insert+0x38a>
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    1834:	8b 57 04             	mov    0x4(%edi),%edx
    1837:	8b 07                	mov    (%edi),%eax
    1839:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    183b:	8b 07                	mov    (%edi),%eax
	elem->prev = elem->next = NULL;
    183d:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    1843:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
    1846:	8b 47 08             	mov    0x8(%edi),%eax
    1849:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
    1850:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    1853:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
  if(cont->list) {
	  BUG();
  }

  for(i=0; i < 2; i++) {
    185a:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
    1861:	c7 45 e4 01 00 00 00 	movl   $0x1,0xffffffe4(%ebp)
    if((cont+i)->ucont_data)
    1868:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
    186b:	8b 84 0f 80 00 00 00 	mov    0x80(%edi,%ecx,1),%eax
    1872:	85 c0                	test   %eax,%eax
    1874:	75 3a                	jne    18b0 <ContList_insert+0x380>
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
    1876:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    1879:	8b 84 17 88 00 00 00 	mov    0x88(%edi,%edx,1),%eax
    1880:	85 c0                	test   %eax,%eax
    1882:	75 22                	jne    18a6 <ContList_insert+0x376>
    1884:	81 45 e0 e4 00 00 00 	addl   $0xe4,0xffffffe0(%ebp)
    188b:	ff 4d e4             	decl   0xffffffe4(%ebp)
    188e:	79 d8                	jns    1868 <ContList_insert+0x338>
      kfree((cont+i)->input);
  }

#ifdef USERTEST
  kfree(cont);
#else  //0426 - change kernel to slab cache
#ifdef DEBUG_ALLOC
  zap_virt(cont);
  //memset(cont, 0x3e, sizeof(*cont));
#else
#ifndef USESLAB
  kfree(cont);  // 0502 maybe slab cache usage is buggy
#else
  kmem_cache_free(clientSideContinuation_cache, cont);
    1890:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
    1894:	a1 00 00 00 00       	mov    0x0,%eax
    1899:	89 04 24             	mov    %eax,(%esp,1)
    189c:	e8 fc ff ff ff       	call   189d <ContList_insert+0x36d>
    18a1:	e9 9b fd ff ff       	jmp    1641 <ContList_insert+0x111>
  for(i=0; i < 2; i++) {
    if((cont+i)->ucont_data)
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
      kfree((cont+i)->input);
    18a6:	89 04 24             	mov    %eax,(%esp,1)
    18a9:	e8 fc ff ff ff       	call   18aa <ContList_insert+0x37a>
    18ae:	eb d4                	jmp    1884 <ContList_insert+0x354>
    18b0:	89 04 24             	mov    %eax,(%esp,1)
    18b3:	e8 fc ff ff ff       	call   18b4 <ContList_insert+0x384>
    18b8:	eb bc                	jmp    1876 <ContList_insert+0x346>
    18ba:	8b 47 34             	mov    0x34(%edi),%eax
    18bd:	c7 04 24 06 01 00 00 	movl   $0x106,(%esp,1)
    18c4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    18c8:	e8 fc ff ff ff       	call   18c9 <ContList_insert+0x399>
    18cd:	e9 62 ff ff ff       	jmp    1834 <ContList_insert+0x304>
    18d2:	c7 45 08 40 04 00 00 	movl   $0x440,0x8(%ebp)
    18d9:	e9 29 fe ff ff       	jmp    1707 <ContList_insert+0x1d7>
#endif // USERTEST
#endif // DEBUG_ALLOC

  if(rval == NULL) {
    printk("out of memory while allocating continuation to copy\n");
    18de:	c7 04 24 c0 03 00 00 	movl   $0x3c0,(%esp,1)
    18e5:	e8 fc ff ff ff       	call   18e6 <ContList_insert+0x3b6>
    18ea:	31 c0                	xor    %eax,%eax
    18ec:	e9 17 ff ff ff       	jmp    1808 <ContList_insert+0x2d8>
    18f1:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    18f4:	8d 82 20 0a 00 00    	lea    0xa20(%edx),%eax
    18fa:	e9 8c fc ff ff       	jmp    158b <ContList_insert+0x5b>
    18ff:	8b 82 c8 02 00 00    	mov    0x2c8(%edx),%eax
    1905:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    1909:	8b 41 3c             	mov    0x3c(%ecx),%eax
    190c:	c7 04 24 80 04 00 00 	movl   $0x480,(%esp,1)
    1913:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    1917:	e8 fc ff ff ff       	call   1918 <ContList_insert+0x3e8>
    191c:	e9 42 fc ff ff       	jmp    1563 <ContList_insert+0x33>
    1921:	eb 0d                	jmp    1930 <freeRequest>
    1923:	90                   	nop    
    1924:	90                   	nop    
    1925:	90                   	nop    
    1926:	90                   	nop    
    1927:	90                   	nop    
    1928:	90                   	nop    
    1929:	90                   	nop    
    192a:	90                   	nop    
    192b:	90                   	nop    
    192c:	90                   	nop    
    192d:	90                   	nop    
    192e:	90                   	nop    
    192f:	90                   	nop    

00001930 <freeRequest>:

int breakpoint_seq = -1;
int paranoia = 0;

#if 0
struct Request *copyRequest(struct Request *req) {
	struct Request *rval;
	switch(req->type) {
	case MREQ_CONTINUATION: {
		struct ContinuationRequest *contReq = (struct ContinuationRequest *)req, *newContReq;
		newContReq = kmalloc_ContinuationRequest(GFP_ATOMIC);
		if(newContReq == NULL) {
			printk("Out of memory while copying request\n");
			return NULL;
		}
		*newContReq = *contReq;
		newContReq->conts = kmalloc(sizeof(newContReq->conts[0]) * newContReq->numConts, GFP_ATOMIC);
		if(newContReq->conts == NULL) {
			printk("Out of memory while copying request\n");
			kfree(newContReq);
			return NULL;
		}
		memcpy(newContReq->conts, contReq->conts, sizeof(contReq->conts[0]) * contReq->numConts);
		rval = (struct Request *)newContReq;
		break;
	}
	case MREQ_CONVERSION: {
		struct ConversionRequest *convReq = (struct ConversionRequest *)req, *newConvReq;
		newConvReq = kmalloc_ConversionRequest(GFP_ATOMIC);
		if(newConvReq == NULL) {
			printk("Out of memory while copying request\n");
			return NULL;
		}
		*newConvReq = *convReq;
		rval = (struct Request*)newConvReq;
		break;
	}
	default:
		rval = NULL;
		BUG();
	}
	rval->prev = rval->next = NULL;
	rval->list = NULL;
	return rval;
}
#endif

void freeRequest(struct Request *req) {
    1930:	55                   	push   %ebp
    1931:	89 e5                	mov    %esp,%ebp
    1933:	83 ec 0c             	sub    $0xc,%esp
    1936:	89 5d fc             	mov    %ebx,0xfffffffc(%ebp)
    1939:	8b 5d 08             	mov    0x8(%ebp),%ebx
	BUG_TRAP(req->allocated);
    193c:	0f b6 43 48          	movzbl 0x48(%ebx),%eax
    1940:	a8 02                	test   $0x2,%al
    1942:	0f 84 98 00 00 00    	je     19e0 <freeRequest+0xb0>
	req->allocated = 0;
    1948:	24 fd                	and    $0xfd,%al
    194a:	88 43 48             	mov    %al,0x48(%ebx)

	switch(req->type) {
    194d:	8b 43 0c             	mov    0xc(%ebx),%eax
    1950:	85 c0                	test   %eax,%eax
    1952:	74 5f                	je     19b3 <freeRequest+0x83>
    1954:	48                   	dec    %eax
    1955:	74 49                	je     19a0 <freeRequest+0x70>
	case MREQ_CONTINUATION: {
		struct ContinuationRequest *contReq = (struct ContinuationRequest *)req;
		/* need to deallocate continuation array */
		kfree(contReq->conts);
		numContinuationRequests--;
		break;
	}
	case MREQ_CONVERSION: {
		struct ConversionRequest *convReq = (struct ConversionRequest *)req;
		/* skb references are dropped when snd_una is advanced, so don't perform that deallocation here */
		if(convReq->incomplete) {
			kfree(convReq->incompletePred);
		} else {
			UC_CONTINUATION_TRYFREE(convReq->completePred);
		}
		numConversionRequests--;
		break;
	}
	default:
		BUG();
    1957:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    195e:	00 
    195f:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    1966:	e8 fc ff ff ff       	call   1967 <freeRequest+0x37>
    196b:	e8 fc ff ff ff       	call   196c <freeRequest+0x3c>
	}
	BUG_TRAP(!req->list);
    1970:	8b 43 08             	mov    0x8(%ebx),%eax
    1973:	85 c0                	test   %eax,%eax
    1975:	75 0e                	jne    1985 <freeRequest+0x55>
	kfree(req);
    1977:	89 5d 08             	mov    %ebx,0x8(%ebp)
    197a:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
    197d:	89 ec                	mov    %ebp,%esp
    197f:	5d                   	pop    %ebp
    1980:	e9 fc ff ff ff       	jmp    1981 <freeRequest+0x51>
    1985:	c7 44 24 04 f7 03 00 	movl   $0x3f7,0x4(%esp,1)
    198c:	00 
    198d:	c7 04 24 e0 04 00 00 	movl   $0x4e0,(%esp,1)
    1994:	e8 fc ff ff ff       	call   1995 <freeRequest+0x65>
    1999:	eb dc                	jmp    1977 <freeRequest+0x47>
    199b:	90                   	nop    
    199c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    19a0:	8b 43 58             	mov    0x58(%ebx),%eax
    19a3:	89 04 24             	mov    %eax,(%esp,1)
    19a6:	e8 fc ff ff ff       	call   19a7 <freeRequest+0x77>
    19ab:	ff 0d 00 00 00 00    	decl   0x0
    19b1:	eb bd                	jmp    1970 <freeRequest+0x40>
    19b3:	8b 43 54             	mov    0x54(%ebx),%eax
    19b6:	85 c0                	test   %eax,%eax
    19b8:	75 16                	jne    19d0 <freeRequest+0xa0>
 * cases.  Note that the guaranteed
 * useful range of an atomic_t is only 24 bits.
 */ 
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
    19ba:	8b 43 64             	mov    0x64(%ebx),%eax
	unsigned char c;

	__asm__ __volatile__(
    19bd:	ff 48 24             	decl   0x24(%eax)
    19c0:	0f 94 c2             	sete   %dl
    19c3:	84 d2                	test   %dl,%dl
    19c5:	75 09                	jne    19d0 <freeRequest+0xa0>
    19c7:	ff 0d 48 00 00 00    	decl   0x48
    19cd:	eb a1                	jmp    1970 <freeRequest+0x40>
    19cf:	90                   	nop    
    19d0:	8b 43 64             	mov    0x64(%ebx),%eax
    19d3:	89 04 24             	mov    %eax,(%esp,1)
    19d6:	e8 fc ff ff ff       	call   19d7 <freeRequest+0xa7>
    19db:	eb ea                	jmp    19c7 <freeRequest+0x97>
    19dd:	8d 76 00             	lea    0x0(%esi),%esi
    19e0:	c7 44 24 04 de 03 00 	movl   $0x3de,0x4(%esp,1)
    19e7:	00 
    19e8:	c7 04 24 20 05 00 00 	movl   $0x520,(%esp,1)
    19ef:	e8 fc ff ff ff       	call   19f0 <freeRequest+0xc0>
    19f4:	0f b6 43 48          	movzbl 0x48(%ebx),%eax
    19f8:	e9 4b ff ff ff       	jmp    1948 <freeRequest+0x18>
    19fd:	8d 76 00             	lea    0x0(%esi),%esi

00001a00 <queueConversionRequests>:
}

inline void pushRequests(struct sock *sk) {
	/* Try to send an ack */
	trickles_send_ack_impl(sk, 0);
}

static inline void cleanTxQueue(struct sock *sk) {
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	struct sk_buff *skb = NULL;
	for(skb = tp->t.requestBytes.next; skb != (struct sk_buff*)&tp->t.requestBytes; skb = skb->next) {
		if(TCP_SKB_CB(skb)->end_seq <= tp->t.snd_una) {
			struct sk_buff *clean = skb;
			skb = skb->prev;
			__skb_unlink(clean, &tp->t.requestBytes);
			kfree_skb(clean);
		}
	}
}

void queueConversionRequests(struct sock *sk) {
    1a00:	55                   	push   %ebp
    1a01:	89 e5                	mov    %esp,%ebp
    1a03:	57                   	push   %edi
    1a04:	56                   	push   %esi
    1a05:	53                   	push   %ebx
    1a06:	83 ec 14             	sub    $0x14,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	struct ConversionRequest *req;
	struct sk_buff *skb = NULL;
	int found = 0;
    1a09:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
    1a10:	8b 45 08             	mov    0x8(%ebp),%eax
    1a13:	89 c7                	mov    %eax,%edi
    1a15:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    1a18:	81 c7 bc 00 00 00    	add    $0xbc,%edi
	BUG_TRAP(tp->t.write_seq - tp->t.snd_una > 0);
    1a1e:	8b 87 c4 0a 00 00    	mov    0xac4(%edi),%eax
    1a24:	39 87 cc 0a 00 00    	cmp    %eax,0xacc(%edi)
    1a2a:	0f 84 2a 02 00 00    	je     1c5a <queueConversionRequests+0x25a>
	req = kmalloc_ConversionRequest(GFP_ATOMIC);
    1a30:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp,1)
    1a37:	e8 fc ff ff ff       	call   1a38 <queueConversionRequests+0x38>
    1a3c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	if(req == NULL) {
    1a3f:	85 c0                	test   %eax,%eax
    1a41:	0f 84 e9 01 00 00    	je     1c30 <queueConversionRequests+0x230>
		printk("queueConversionRequests: Out of memory!\n");
		BUG();
	}
	for(skb = tp->t.requestBytes.next; skb != (struct sk_buff*)&tp->t.requestBytes; skb = skb->next) {
    1a47:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    1a4a:	8b 9f d0 0a 00 00    	mov    0xad0(%edi),%ebx
    1a50:	05 8c 0b 00 00       	add    $0xb8c,%eax
    1a55:	39 c3                	cmp    %eax,%ebx
    1a57:	74 66                	je     1abf <queueConversionRequests+0xbf>
    1a59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
		if(TCP_SKB_CB(skb)->end_seq <= tp->t.snd_una) {
    1a60:	8b 87 c4 0a 00 00    	mov    0xac4(%edi),%eax
    1a66:	39 43 44             	cmp    %eax,0x44(%ebx)
    1a69:	0f 87 a5 01 00 00    	ja     1c14 <queueConversionRequests+0x214>
 * the list known..
 */
 
static inline void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
{
    1a6f:	8d b7 d0 0a 00 00    	lea    0xad0(%edi),%esi
			struct sk_buff *clean = skb;
    1a75:	89 d9                	mov    %ebx,%ecx
			skb = skb->prev;
    1a77:	8b 5b 04             	mov    0x4(%ebx),%ebx
static inline void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
{
	struct sk_buff * next, * prev;

	list->qlen--;
    1a7a:	ff 4e 08             	decl   0x8(%esi)
	next = skb->next;
	prev = skb->prev;
	skb->next = NULL;
	skb->prev = NULL;
	skb->list = NULL;
    1a7d:	c7 41 08 00 00 00 00 	movl   $0x0,0x8(%ecx)
    1a84:	8b 41 04             	mov    0x4(%ecx),%eax
    1a87:	8b 11                	mov    (%ecx),%edx
    1a89:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
    1a90:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	next->prev = prev;
    1a96:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    1a99:	89 10                	mov    %edx,(%eax)
    1a9b:	8b 81 84 00 00 00    	mov    0x84(%ecx),%eax
    1aa1:	48                   	dec    %eax
    1aa2:	74 0d                	je     1ab1 <queueConversionRequests+0xb1>
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
	unsigned char c;

	__asm__ __volatile__(
    1aa4:	ff 89 84 00 00 00    	decl   0x84(%ecx)
    1aaa:	0f 94 c0             	sete   %al
    1aad:	84 c0                	test   %al,%al
    1aaf:	74 08                	je     1ab9 <queueConversionRequests+0xb9>
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
		__kfree_skb(skb);
    1ab1:	89 0c 24             	mov    %ecx,(%esp,1)
    1ab4:	e8 fc ff ff ff       	call   1ab5 <queueConversionRequests+0xb5>
    1ab9:	8b 1b                	mov    (%ebx),%ebx
    1abb:	39 f3                	cmp    %esi,%ebx
    1abd:	75 a1                	jne    1a60 <queueConversionRequests+0x60>
			__skb_unlink(clean, &tp->t.requestBytes);
			kfree_skb(clean);
		} else if(SKB_CONTAINS(skb, tp->t.snd_una)) {
			found = 1;
			break;
		}
	}
	if(!found) {
    1abf:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    1ac2:	85 d2                	test   %edx,%edx
    1ac4:	0f 84 13 01 00 00    	je     1bdd <queueConversionRequests+0x1dd>
		struct UC_Continuation *completePred;
	};
};

static inline void initCompleteConversionRequest(struct ConversionRequest *req, struct UC_Continuation *pred, struct sk_buff *data, unsigned offset) {
    1aca:	8b 43 40             	mov    0x40(%ebx),%eax
    1acd:	8b b7 c4 0a 00 00    	mov    0xac4(%edi),%esi
    1ad3:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    1ad6:	8b 97 e0 0a 00 00    	mov    0xae0(%edi),%edx
    1adc:	29 c6                	sub    %eax,%esi
    1ade:	0f b6 41 48          	movzbl 0x48(%ecx),%eax
    1ae2:	c7 41 0c 00 00 00 00 	movl   $0x0,0xc(%ecx)
    1ae9:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
    1af0:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
    1af6:	0c 03                	or     $0x3,%al
    1af8:	c7 41 08 00 00 00 00 	movl   $0x0,0x8(%ecx)
    1aff:	c7 41 10 00 00 00 00 	movl   $0x0,0x10(%ecx)
    1b06:	80 61 14 f0          	andb   $0xf0,0x14(%ecx)
    1b0a:	c7 41 38 ff ff ff ff 	movl   $0xffffffff,0x38(%ecx)
    1b11:	c7 41 3c ff ff ff ff 	movl   $0xffffffff,0x3c(%ecx)
    1b18:	c7 41 44 ff ff ff ff 	movl   $0xffffffff,0x44(%ecx)
    1b1f:	c7 41 40 ff ff ff ff 	movl   $0xffffffff,0x40(%ecx)
    1b26:	88 41 48             	mov    %al,0x48(%ecx)
	initRequest((struct Request *)req, MREQ_CONVERSION);
	req->incomplete = 0;
    1b29:	c7 41 54 00 00 00 00 	movl   $0x0,0x54(%ecx)
	req->completePred = pred;
    1b30:	89 51 64             	mov    %edx,0x64(%ecx)
 * useful range of an atomic_t is only 24 bits.
 */ 
static __inline__ void atomic_inc(atomic_t *v)
{
	__asm__ __volatile__(
    1b33:	ff 42 24             	incl   0x24(%edx)
	req->incomplete = 0;
	req->completePred = pred;
	atomic_inc(&req->completePred->refcnt);
#if 1 // 0707
	if(atomic_read(&req->completePred->refcnt) < 2) {
    1b36:	8b 41 64             	mov    0x64(%ecx),%eax
    1b39:	8b 40 24             	mov    0x24(%eax),%eax
    1b3c:	48                   	dec    %eax
    1b3d:	0f 8e 89 00 00 00    	jle    1bcc <queueConversionRequests+0x1cc>
		printk("refcnt should be > 1!\n");
	}
#endif
	req->data = data;
    1b43:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    1b46:	89 58 58             	mov    %ebx,0x58(%eax)
	req->offset = offset;
    1b49:	89 70 5c             	mov    %esi,0x5c(%eax)
    1b4c:	8b 75 f0             	mov    0xfffffff0(%ebp),%esi
	elem->list = head;
	head->len++;
}

static inline void insert_tail(struct alloc_head_list *head, struct alloc_head *elem) {
    1b4f:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
    1b52:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx

void resetClientTimer(struct sock *sk);

static inline void queueNewRequest(struct sock *sk, struct Request *req) {
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    1b55:	81 c6 bc 00 00 00    	add    $0xbc,%esi
	elem->list = head;
	head->len++;
}

static inline void insert_tail(struct alloc_head_list *head, struct alloc_head *elem) {
    1b5b:	81 c3 38 0b 00 00    	add    $0xb38,%ebx
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
    1b61:	39 82 38 0b 00 00    	cmp    %eax,0xb38(%edx)
    1b67:	74 3c                	je     1ba5 <queueConversionRequests+0x1a5>
		BUG();
		show_stack(NULL);
	}
	elem->prev = head->prev;
    1b69:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    1b6c:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    1b6f:	8b 81 38 0b 00 00    	mov    0xb38(%ecx),%eax
    1b75:	89 02                	mov    %eax,(%edx)
	head->prev->next = elem;
    1b77:	8b 81 38 0b 00 00    	mov    0xb38(%ecx),%eax

	elem->next = (struct alloc_head*)head;

	elem->list = head;
    1b7d:	89 5a 08             	mov    %ebx,0x8(%edx)
    1b80:	89 50 04             	mov    %edx,0x4(%eax)
    1b83:	89 5a 04             	mov    %ebx,0x4(%edx)
	head->prev = elem;
	head->len++;
    1b86:	ff 43 10             	incl   0x10(%ebx)
    1b89:	89 91 38 0b 00 00    	mov    %edx,0xb38(%ecx)

static inline void queueNewRequest(struct sock *sk, struct Request *req) {
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	insert_tail(&tp->t.queuedRequests, (struct alloc_head*)req);
	tp->t.timerState |= TRICKLES_ENABLE_DATA_TIMEOUT;
    1b8f:	83 8e d8 02 00 00 01 	orl    $0x1,0x2d8(%esi)
	resetClientTimer(sk);
    1b96:	89 4d 08             	mov    %ecx,0x8(%ebp)
    1b99:	83 c4 14             	add    $0x14,%esp
    1b9c:	5b                   	pop    %ebx
    1b9d:	5e                   	pop    %esi
    1b9e:	5f                   	pop    %edi
    1b9f:	5d                   	pop    %ebp
    1ba0:	e9 fc ff ff ff       	jmp    1ba1 <queueConversionRequests+0x1a1>
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
		BUG();
    1ba5:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    1bac:	00 
    1bad:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    1bb4:	e8 fc ff ff ff       	call   1bb5 <queueConversionRequests+0x1b5>
    1bb9:	e8 fc ff ff ff       	call   1bba <queueConversionRequests+0x1ba>
		show_stack(NULL);
    1bbe:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    1bc5:	e8 fc ff ff ff       	call   1bc6 <queueConversionRequests+0x1c6>
    1bca:	eb 9d                	jmp    1b69 <queueConversionRequests+0x169>
	req->completePred = pred;
	atomic_inc(&req->completePred->refcnt);
#if 1 // 0707
	if(atomic_read(&req->completePred->refcnt) < 2) {
		printk("refcnt should be > 1!\n");
    1bcc:	c7 04 24 1e 01 00 00 	movl   $0x11e,(%esp,1)
    1bd3:	e8 fc ff ff ff       	call   1bd4 <queueConversionRequests+0x1d4>
    1bd8:	e9 66 ff ff ff       	jmp    1b43 <queueConversionRequests+0x143>
		printk("Could not find matching bytes to convert\n");
    1bdd:	c7 04 24 60 05 00 00 	movl   $0x560,(%esp,1)
    1be4:	e8 fc ff ff ff       	call   1be5 <queueConversionRequests+0x1e5>
		kfree(req);
    1be9:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    1bec:	89 14 24             	mov    %edx,(%esp,1)
    1bef:	e8 fc ff ff ff       	call   1bf0 <queueConversionRequests+0x1f0>
		BUG();
    1bf4:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    1bfb:	00 
    1bfc:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    1c03:	e8 fc ff ff ff       	call   1c04 <queueConversionRequests+0x204>
    1c08:	83 c4 14             	add    $0x14,%esp
    1c0b:	5b                   	pop    %ebx
    1c0c:	5e                   	pop    %esi
    1c0d:	5f                   	pop    %edi
    1c0e:	5d                   	pop    %ebp
    1c0f:	e9 fc ff ff ff       	jmp    1c10 <queueConversionRequests+0x210>
    1c14:	39 43 40             	cmp    %eax,0x40(%ebx)
    1c17:	76 0b                	jbe    1c24 <queueConversionRequests+0x224>
    1c19:	8d b7 d0 0a 00 00    	lea    0xad0(%edi),%esi
    1c1f:	e9 95 fe ff ff       	jmp    1ab9 <queueConversionRequests+0xb9>
    1c24:	c7 45 e8 01 00 00 00 	movl   $0x1,0xffffffe8(%ebp)
    1c2b:	e9 8f fe ff ff       	jmp    1abf <queueConversionRequests+0xbf>
    1c30:	c7 04 24 a0 05 00 00 	movl   $0x5a0,(%esp,1)
    1c37:	e8 fc ff ff ff       	call   1c38 <queueConversionRequests+0x238>
    1c3c:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    1c43:	00 
    1c44:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    1c4b:	e8 fc ff ff ff       	call   1c4c <queueConversionRequests+0x24c>
    1c50:	e8 fc ff ff ff       	call   1c51 <queueConversionRequests+0x251>
    1c55:	e9 ed fd ff ff       	jmp    1a47 <queueConversionRequests+0x47>
    1c5a:	c7 44 24 04 12 04 00 	movl   $0x412,0x4(%esp,1)
    1c61:	00 
    1c62:	c7 04 24 e0 05 00 00 	movl   $0x5e0,(%esp,1)
    1c69:	e8 fc ff ff ff       	call   1c6a <queueConversionRequests+0x26a>
    1c6e:	e9 bd fd ff ff       	jmp    1a30 <queueConversionRequests+0x30>
    1c73:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    1c79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00001c80 <finishIncompleteRequest>:
		return;
	}
	initCompleteConversionRequest(req,
				      tp->t.prevConvCont,
				      /* Data */
				      skb, 
				      tp->t.snd_una - TCP_SKB_CB(skb)->seq);
	//printk("%p: init complete conversion request: %d-%d\n", sk, tp->t.snd_una, TCP_SKB_CB(skb)->end_seq);
	queueNewRequest(sk, (struct Request *)req);
#if 0 // 0426 - do not push out requests in interrupt context, since the requests will be sent automatically
	/* Push out any possible acks */
	pushRequests(sk);
#endif
}

inline void finishIncompleteRequest(struct sock *sk) {
    1c80:	55                   	push   %ebp
    1c81:	89 e5                	mov    %esp,%ebp
    1c83:	57                   	push   %edi
    1c84:	56                   	push   %esi
    1c85:	53                   	push   %ebx
    1c86:	83 ec 14             	sub    $0x14,%esp
    1c89:	8b 45 08             	mov    0x8(%ebp),%eax
    1c8c:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    1c8f:	89 c7                	mov    %eax,%edi
    1c91:	81 c7 bc 00 00 00    	add    $0xbc,%edi
	struct ConversionRequest *req = tp->t.newIncompleteRequest;
    1c97:	8b 97 dc 0a 00 00    	mov    0xadc(%edi),%edx
	struct sk_buff *skb;
	int found = 0;
    1c9d:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
	if(req == NULL) {
    1ca4:	85 d2                	test   %edx,%edx
    1ca6:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
    1ca9:	0f 84 9c 01 00 00    	je     1e4b <finishIncompleteRequest+0x1cb>
		printk("finishIncompleteRequest, but no pending incomplete request\n");
		BUG();
	}
	BUG_TRAP(req->incomplete);
    1caf:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    1cb2:	8b 40 54             	mov    0x54(%eax),%eax
    1cb5:	85 c0                	test   %eax,%eax
    1cb7:	0f 84 75 01 00 00    	je     1e32 <finishIncompleteRequest+0x1b2>

	for(skb = tp->t.requestBytes.next; skb != (struct sk_buff*)&tp->t.requestBytes; skb = skb->next) {
    1cbd:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    1cc0:	8b 9f d0 0a 00 00    	mov    0xad0(%edi),%ebx
    1cc6:	05 8c 0b 00 00       	add    $0xb8c,%eax
    1ccb:	39 c3                	cmp    %eax,%ebx
    1ccd:	74 60                	je     1d2f <finishIncompleteRequest+0xaf>
    1ccf:	90                   	nop    
		if(TCP_SKB_CB(skb)->end_seq <= tp->t.snd_una) {
    1cd0:	8b 87 c4 0a 00 00    	mov    0xac4(%edi),%eax
    1cd6:	39 43 44             	cmp    %eax,0x44(%ebx)
    1cd9:	0f 87 37 01 00 00    	ja     1e16 <finishIncompleteRequest+0x196>
 * the list known..
 */
 
static inline void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
{
    1cdf:	8d b7 d0 0a 00 00    	lea    0xad0(%edi),%esi
			struct sk_buff *clean = skb;
    1ce5:	89 d9                	mov    %ebx,%ecx
			skb = skb->prev;
    1ce7:	8b 5b 04             	mov    0x4(%ebx),%ebx
static inline void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
{
	struct sk_buff * next, * prev;

	list->qlen--;
    1cea:	ff 4e 08             	decl   0x8(%esi)
	next = skb->next;
	prev = skb->prev;
	skb->next = NULL;
	skb->prev = NULL;
	skb->list = NULL;
    1ced:	c7 41 08 00 00 00 00 	movl   $0x0,0x8(%ecx)
    1cf4:	8b 41 04             	mov    0x4(%ecx),%eax
    1cf7:	8b 11                	mov    (%ecx),%edx
    1cf9:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
    1d00:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	next->prev = prev;
    1d06:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    1d09:	89 10                	mov    %edx,(%eax)
    1d0b:	8b 81 84 00 00 00    	mov    0x84(%ecx),%eax
    1d11:	48                   	dec    %eax
    1d12:	74 0d                	je     1d21 <finishIncompleteRequest+0xa1>
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
	unsigned char c;

	__asm__ __volatile__(
    1d14:	ff 89 84 00 00 00    	decl   0x84(%ecx)
    1d1a:	0f 94 c0             	sete   %al
    1d1d:	84 c0                	test   %al,%al
    1d1f:	74 08                	je     1d29 <finishIncompleteRequest+0xa9>
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
		__kfree_skb(skb);
    1d21:	89 0c 24             	mov    %ecx,(%esp,1)
    1d24:	e8 fc ff ff ff       	call   1d25 <finishIncompleteRequest+0xa5>
    1d29:	8b 1b                	mov    (%ebx),%ebx
    1d2b:	39 f3                	cmp    %esi,%ebx
    1d2d:	75 a1                	jne    1cd0 <finishIncompleteRequest+0x50>
			__skb_unlink(clean, &tp->t.requestBytes);
			kfree_skb(clean);
		} else if(SKB_CONTAINS(skb, tp->t.snd_una)) {
			found = 1;
			break;
		}
	}
	if(!found) {
    1d2f:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    1d32:	85 c0                	test   %eax,%eax
    1d34:	0f 84 b0 00 00 00    	je     1dea <finishIncompleteRequest+0x16a>
		printk("Could not find matching bytes to convert\n");
		BUG();
		return;
	}
	tp->t.newIncompleteRequest = NULL;
    1d3a:	31 c0                	xor    %eax,%eax
    1d3c:	89 87 dc 0a 00 00    	mov    %eax,0xadc(%edi)

	req->data = skb;
    1d42:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    1d45:	89 5a 58             	mov    %ebx,0x58(%edx)
	req->offset = tp->t.snd_una - TCP_SKB_CB(skb)->seq;
    1d48:	8b 73 40             	mov    0x40(%ebx),%esi
    1d4b:	8b 87 c4 0a 00 00    	mov    0xac4(%edi),%eax
    1d51:	29 f0                	sub    %esi,%eax
    1d53:	89 42 5c             	mov    %eax,0x5c(%edx)
	req->start = TCP_SKB_CB(skb)->seq + req->offset;
    1d56:	8b 4b 40             	mov    0x40(%ebx),%ecx
    1d59:	01 c8                	add    %ecx,%eax
    1d5b:	89 42 40             	mov    %eax,0x40(%edx)
	req->end = req->start;
    1d5e:	89 42 44             	mov    %eax,0x44(%edx)

void resetClientTimer(struct sock *sk);

static inline void queueNewRequest(struct sock *sk, struct Request *req) {
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    1d61:	8b 75 f0             	mov    0xfffffff0(%ebp),%esi
	elem->list = head;
	head->len++;
}

static inline void insert_tail(struct alloc_head_list *head, struct alloc_head *elem) {
    1d64:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
    1d67:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax

void resetClientTimer(struct sock *sk);

static inline void queueNewRequest(struct sock *sk, struct Request *req) {
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    1d6a:	81 c6 bc 00 00 00    	add    $0xbc,%esi
	elem->list = head;
	head->len++;
}

static inline void insert_tail(struct alloc_head_list *head, struct alloc_head *elem) {
    1d70:	81 c3 38 0b 00 00    	add    $0xb38,%ebx
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
    1d76:	39 90 38 0b 00 00    	cmp    %edx,0xb38(%eax)
    1d7c:	74 45                	je     1dc3 <finishIncompleteRequest+0x143>
		BUG();
		show_stack(NULL);
	}
	elem->prev = head->prev;
    1d7e:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    1d81:	8b 82 38 0b 00 00    	mov    0xb38(%edx),%eax
    1d87:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    1d8a:	89 02                	mov    %eax,(%edx)
	head->prev->next = elem;
    1d8c:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    1d8f:	8b 82 38 0b 00 00    	mov    0xb38(%edx),%eax
    1d95:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    1d98:	89 50 04             	mov    %edx,0x4(%eax)

	elem->next = (struct alloc_head*)head;

	elem->list = head;
    1d9b:	89 5a 08             	mov    %ebx,0x8(%edx)
    1d9e:	89 5a 04             	mov    %ebx,0x4(%edx)
	head->prev = elem;
    1da1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
	head->len++;
    1da4:	ff 43 10             	incl   0x10(%ebx)
    1da7:	89 90 38 0b 00 00    	mov    %edx,0xb38(%eax)

static inline void queueNewRequest(struct sock *sk, struct Request *req) {
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	insert_tail(&tp->t.queuedRequests, (struct alloc_head*)req);
	tp->t.timerState |= TRICKLES_ENABLE_DATA_TIMEOUT;
    1dad:	83 8e d8 02 00 00 01 	orl    $0x1,0x2d8(%esi)
	resetClientTimer(sk);
    1db4:	89 45 08             	mov    %eax,0x8(%ebp)
    1db7:	83 c4 14             	add    $0x14,%esp
    1dba:	5b                   	pop    %ebx
    1dbb:	5e                   	pop    %esi
    1dbc:	5f                   	pop    %edi
    1dbd:	5d                   	pop    %ebp
    1dbe:	e9 fc ff ff ff       	jmp    1dbf <finishIncompleteRequest+0x13f>
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
		BUG();
    1dc3:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    1dca:	00 
    1dcb:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    1dd2:	e8 fc ff ff ff       	call   1dd3 <finishIncompleteRequest+0x153>
    1dd7:	e8 fc ff ff ff       	call   1dd8 <finishIncompleteRequest+0x158>
		show_stack(NULL);
    1ddc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    1de3:	e8 fc ff ff ff       	call   1de4 <finishIncompleteRequest+0x164>
    1de8:	eb 94                	jmp    1d7e <finishIncompleteRequest+0xfe>
    1dea:	c7 04 24 60 05 00 00 	movl   $0x560,(%esp,1)
    1df1:	e8 fc ff ff ff       	call   1df2 <finishIncompleteRequest+0x172>
    1df6:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    1dfd:	00 
    1dfe:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    1e05:	e8 fc ff ff ff       	call   1e06 <finishIncompleteRequest+0x186>
    1e0a:	83 c4 14             	add    $0x14,%esp
    1e0d:	5b                   	pop    %ebx
    1e0e:	5e                   	pop    %esi
    1e0f:	5f                   	pop    %edi
    1e10:	5d                   	pop    %ebp
    1e11:	e9 fc ff ff ff       	jmp    1e12 <finishIncompleteRequest+0x192>
    1e16:	39 43 40             	cmp    %eax,0x40(%ebx)
    1e19:	76 0b                	jbe    1e26 <finishIncompleteRequest+0x1a6>
    1e1b:	8d b7 d0 0a 00 00    	lea    0xad0(%edi),%esi
    1e21:	e9 03 ff ff ff       	jmp    1d29 <finishIncompleteRequest+0xa9>
    1e26:	c7 45 e8 01 00 00 00 	movl   $0x1,0xffffffe8(%ebp)
    1e2d:	e9 fd fe ff ff       	jmp    1d2f <finishIncompleteRequest+0xaf>
    1e32:	c7 44 24 04 3f 04 00 	movl   $0x43f,0x4(%esp,1)
    1e39:	00 
    1e3a:	c7 04 24 40 06 00 00 	movl   $0x640,(%esp,1)
    1e41:	e8 fc ff ff ff       	call   1e42 <finishIncompleteRequest+0x1c2>
    1e46:	e9 72 fe ff ff       	jmp    1cbd <finishIncompleteRequest+0x3d>
    1e4b:	c7 04 24 80 06 00 00 	movl   $0x680,(%esp,1)
    1e52:	e8 fc ff ff ff       	call   1e53 <finishIncompleteRequest+0x1d3>
    1e57:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    1e5e:	00 
    1e5f:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    1e66:	e8 fc ff ff ff       	call   1e67 <finishIncompleteRequest+0x1e7>
    1e6b:	e8 fc ff ff ff       	call   1e6c <finishIncompleteRequest+0x1ec>
    1e70:	e9 3a fe ff ff       	jmp    1caf <finishIncompleteRequest+0x2f>
    1e75:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    1e79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00001e80 <updateParent>:
	queueNewRequest(sk, (struct Request*)req);
#if 0 // 0426 - do not push out requests in interrupt context, since the requests will be sent automatically
	pushRequests(sk);
#endif
}

static inline int processIncompleteResponse(struct sock *sk, struct WireUC_CVT_IncompleteResponse *incompleteResp, int responseLen) {
	/* Update conversion state, and use the incomplete
	   continuationn to generate and enqueue the request for the
	   next step in the parse */
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	struct ConversionRequest *newConvReq;
	struct sk_buff *skb;
	int foundNextData = 0;
	struct WireUC_CVT_IncompleteContinuation *pred;
	unsigned predLength;
	unsigned ackSeq = ntohl(incompleteResp->ack_seq);
	int bytesConsumed = tp->t.snd_una;

	/* Need to finish this conversion. So find
	   next bytestream data to send, enqueue new
	   request in request queue */

	/* XXX This code does not gracefully handle
	   parallel parse requests */
	if(ackSeq > tp->t.snd_una) {
		tp->t.snd_una = ackSeq;
		if(tp->t.snd_una > tp->t.write_seq) {
			printk("BUG! after byte position update, snd_una %d > write_seq %d !\n", tp->t.snd_una, tp->t.write_seq);
			tp->t.snd_una = tp->t.write_seq;
			return -1;
		}
	}
	bytesConsumed = tp->t.snd_una - bytesConsumed;
	if(bytesConsumed == 0 &&
	   tp->t.snd_end - tp->t.snd_una >= MTU) {
		printk("Error: bytesConsumed == 0, but full MTU was sent! Forward progress cannot be made\n");
		return -1;
	}
	/* Deallocate any elements in send queue that we no longer need, and find next skb to use */
	for(skb = tp->t.requestBytes.next; skb != (struct sk_buff*)&tp->t.requestBytes; skb = skb->next) {
		if(TCP_SKB_CB(skb)->end_seq <= tp->t.snd_una) {
			struct sk_buff *clean = skb;
			skb = skb->prev;
			__skb_unlink(clean, &tp->t.requestBytes);
			kfree_skb(clean);
		}
		if(SKB_CONTAINS(skb, tp->t.snd_una)) {
			foundNextData = 1;
			break;
		}
	}
	newConvReq = kmalloc_ConversionRequest(GFP_ATOMIC);
	if(newConvReq == NULL) {
		printk("Out of memory while allocating Request to continue incomplete conversion!\n");
		return -1;
	}
	predLength = responseLen - ((char*)&incompleteResp->newCont - (char*)incompleteResp);
	pred = kmalloc_dup(&incompleteResp->newCont, predLength, GFP_ATOMIC);
	if(pred == NULL) {
		kfree(newConvReq);
		printk("kmalloc_dup() returned error\n");
		return -1;
	}
	if(!foundNextData) {
		// Defer installation of new request until data arrives from userlevel
		BUG_TRAP(tp->t.newIncompleteRequest == NULL);
		tp->t.conversionState = CONVERSION_WAITFORUSER;
		tp->t.newIncompleteRequest = newConvReq;
		initIncompleteConversionRequest(newConvReq, 
						pred, predLength,
						/* no data yet */
						NULL, -1);
		//printk("process_incomplete_request set conversion state to waitforuser\n");
	} else {
		BUG_TRAP(tp->t.newIncompleteRequest == NULL);
		tp->t.conversionState = CONVERSION_WAITFORSERVER;
		tp->t.newIncompleteRequest = NULL;
		initIncompleteConversionRequest(newConvReq, 
						pred, predLength, 
						/* data */
						skb,
						tp->t.snd_una - TCP_SKB_CB(skb)->seq);
		queueNewRequest(sk, (struct Request*)newConvReq);
#if 0 // 0426 - do not push out requests in interrupt context, since the requests will be sent automatically
		pushRequests(sk);
#endif
		//printk("process_incomplete_request set conversion state to waitforserver\n");
	}
	return 0;
}

#define LEFT 0
#define RIGHT 1

/* insertNewDep is used to insert a dependency into a blank range where no previous dependency ever existed */
static inline int insertNewDep(struct UC_DependencyNode *left, struct UC_DependencyNode *right, struct UC_DependencyNode *newDep, int side) {
	unsigned newStart, newEnd;
	struct UC_DependencyNode *clone;
	struct alloc_head *prev, *next;

	if(left == NULL) {
		newStart = newDep->start;
	} else {
		newStart = MAX(left->end, newDep->start);
		prev = (struct alloc_head*)left;
		next = left->next;
	}
	if(right == NULL) {
		newEnd = newDep->end;
	} else {
		newEnd = MIN(newDep->end, right->start);
		prev = right->prev;
		next = (struct alloc_head*)right;
	}
	switch(side) {
	case LEFT:
		if(right) {
			if(newDep->start >= right->start) {
				printk("insertNewDep: supposed to insert on left, but newDep is not at the left\n");
				return -1;
			}
		} else {
			printk("insertNewDep: supposed to insert on left, but nothing to the right\n");
			return -1;
		}
		break;
	case RIGHT:
		if(left) {
			if(newDep->end <= left->end) {
				printk("insertNewDep: supposed to insert on right, but newDep is not at the right\n");
				return -1;
			}
		} else {
			printk("insertNewDep: supposed to insert on right, but nothing to the left\n");
			return -1;
		}
		break;
	default:
		printk("insertNewDep: unknown side\n");
		return -1;
	}
	clone = copyUC_DependencyNode(newDep);
	if(clone == NULL) {
		printk("Out of memory while creating dependency at %d side\n", side);
		return -1;
	}
	insert((struct alloc_head*)clone, prev, next);
	return 0;
}

static inline int addNewUC_Continuation(struct sock *sk, struct UC_Continuation *newCont) {
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	struct UC_Continuation *insertPos;

	// find place to insert new continuation
	alloc_head_reverse_walk(&tp->t.ucontList, insertPos) {
		/* insert the new continuation in the proper location */
		if(insertPos->clientValidStart < newCont->validStart) break;
	}
	newCont->clientValidStart = newCont->validStart;
	newCont->clientValidEnd = newCont->validEnd;
	
	// find intersections
	// Real validStart and validEnd should NOT be touched in this block
	struct alloc_head_list *insertionList = &tp->t.ucontList;
	insert((struct alloc_head*)newCont, 
	       (struct alloc_head*)insertPos, (struct alloc_head*)insertPos->next);

	// Now, resolve overlaps
	struct UC_Continuation *finger = (struct UC_Continuation *)insertPos, *nextCont;

	if((struct alloc_head_list*)finger == insertionList) {
		finger = (struct UC_Continuation*) finger->next;
	}
	unsigned lastByte = newCont->clientValidEnd;
	for(; (struct alloc_head_list*)finger->next != insertionList; finger = nextCont) {
		nextCont = (struct UC_Continuation *)finger->next;
		unsigned start = MAX(finger->clientValidStart, nextCont->clientValidStart),
			end = MIN(finger->clientValidEnd, nextCont->clientValidEnd);
		if(start < end) {
			struct UC_Continuation *left = NULL, *middle = NULL, *right = NULL,
				*older = NULL, *newer = NULL;
			struct alloc_head *iPrev = finger->prev;
			struct alloc_head *iPrev0 = iPrev;
			struct alloc_head *iNext = nextCont->next;

			// let newest continuation take intersection
			if(finger->seq > nextCont->seq) {
				older = nextCont;
				newer = finger;
			} else {
				older = finger;
				newer = nextCont;
			}
			if(older->clientValidStart < start) {
				left = older;
			}
			middle = newer;
			if(older->clientValidEnd > end) {
				if(left == older) {
					struct UC_Continuation *older1 = copyUC_Continuation(older);
					if(older1 == NULL) {
						printk("Out of memory while splitting continuation\n");
						return -1;
					}
#if 0 // 0707 -- unclear ???
					right->prev = right->next = NULL;
					right->list = NULL;
#endif
					right = older1;
				} else {
					right = older;
				}
			} else {
				if(!left) {
					BUG_TRAP(older != NULL);
					// older completely overlapped
					unlink((struct alloc_head*)older);
					kfree(older);
				}
			}
			if(left) {
				if(left->list)
					unlink((struct alloc_head*)left);
				left->clientValidEnd = start;
			}
			if(middle) {
				if(middle->list)
					unlink((struct alloc_head*)middle);
				// no clientValid* adjustment necessary, since middle is preserved
			}
			if(right) {
				if(right->list)
					unlink((struct alloc_head*)right);
				right->clientValidStart = end;
			}
			if(left) {
				insert((struct alloc_head*)left, iPrev, iNext);
				iPrev = (struct alloc_head *)left;
			}
			if(middle) {
				insert((struct alloc_head*)middle, iPrev, iNext);
				iPrev = (struct alloc_head*)middle;
			}
			if(right) {
				insert((struct alloc_head*)right, iPrev, iNext);
				iPrev = (struct alloc_head*)right;
			}
			/* Sanity checks */
			{
				struct UC_Continuation *finger = (struct UC_Continuation*)iPrev0;
				while((struct alloc_head*)finger->next != iNext) {
					if((struct alloc_head_list*)finger != insertionList &&
					   (struct alloc_head_list*)finger->next != insertionList) {
						BUG_TRAP(finger->clientValidEnd <= 
							 ((struct UC_Continuation*)finger->next)->clientValidStart);
					}
					finger = (struct UC_Continuation*)finger->next;
				}
			}
			nextCont = (struct UC_Continuation*)iPrev0; // XXX iNext->prev is a more efficient resumption point
		}
		if(end >= lastByte) {
			// no more overlaps possible
			break;
		}
	}
	// it's possible for client timer to block because we dont have continuations
	// XXX we may wish to guard this with more stringent checks to avoid unnecessary timeouts?
	resetClientTimer(sk);
	return 0;
}

void updateParent(struct sock *sk, enum UserRequestType matchType, unsigned matchID, 
		 unsigned numSiblings, unsigned position, 
		 unsigned start, unsigned end) {
    1e80:	55                   	push   %ebp
    1e81:	89 e5                	mov    %esp,%ebp
    1e83:	57                   	push   %edi
    1e84:	56                   	push   %esi
    1e85:	53                   	push   %ebx
    1e86:	83 ec 2c             	sub    $0x2c,%esp
	/* Additional POSTCONDITION: 	
	   tp->t.request_rcv_nxt updated
	*/
	int k;
	int foundCleanable = 0;
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	struct alloc_head_list *list_heads[] = {&tp->t.sentRequests, 
						&tp->t.queuedRequests};
	struct Request *parent_req;
	for(k=0; k < sizeof(list_heads)/sizeof(list_heads[0]); k++) {
    1e89:	c7 45 d4 01 00 00 00 	movl   $0x1,0xffffffd4(%ebp)
    1e90:	8b 55 08             	mov    0x8(%ebp),%edx
    1e93:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
    1e97:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
    1e9e:	8d 82 bc 00 00 00    	lea    0xbc(%edx),%eax
    1ea4:	d3 65 d4             	shll   %cl,0xffffffd4(%ebp)
    1ea7:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    1eaa:	8d 82 24 0b 00 00    	lea    0xb24(%edx),%eax
    1eb0:	81 c2 38 0b 00 00    	add    $0xb38,%edx
    1eb6:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    1eb9:	89 55 f0             	mov    %edx,0xfffffff0(%ebp)
    1ebc:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
		struct alloc_head_list *head = list_heads[k];
    1ec3:	8b 75 e8             	mov    0xffffffe8(%ebp),%esi
    1ec6:	8b 7c b5 ec          	mov    0xffffffec(%ebp,%esi,4),%edi
		alloc_head_walk(head, parent_req) {
    1eca:	8b 5f 04             	mov    0x4(%edi),%ebx
    1ecd:	39 fb                	cmp    %edi,%ebx
    1ecf:	74 2e                	je     1eff <updateParent+0x7f>
    1ed1:	0f b6 4d 18          	movzbl 0x18(%ebp),%ecx
    1ed5:	c7 45 dc 01 00 00 00 	movl   $0x1,0xffffffdc(%ebp)
    1edc:	8b 75 d4             	mov    0xffffffd4(%ebp),%esi
    1edf:	d3 65 dc             	shll   %cl,0xffffffdc(%ebp)
    1ee2:	4e                   	dec    %esi
    1ee3:	89 75 d8             	mov    %esi,0xffffffd8(%ebp)
    1ee6:	8d 76 00             	lea    0x0(%esi),%esi
    1ee9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
			unsigned positionMask = 1 << position;
			unsigned allMask;
			if(matchID != parent_req->seq) {
    1ef0:	8b 4b 3c             	mov    0x3c(%ebx),%ecx
    1ef3:	39 4d 10             	cmp    %ecx,0x10(%ebp)
    1ef6:	74 2b                	je     1f23 <updateParent+0xa3>
    1ef8:	8b 5b 04             	mov    0x4(%ebx),%ebx
    1efb:	39 fb                	cmp    %edi,%ebx
    1efd:	75 f1                	jne    1ef0 <updateParent+0x70>
				continue;
			}
			if(parent_req->type != matchType) {
				printk("updateParent: type does not match\n");
				return;
			}
			foundCleanable = 1;

			if(numSiblings > MAX_MREQ_CHILDREN) {
				printk("Too many siblings!\n");
				return;
			}
			if(position >= numSiblings) {
				printk("position >= numSiblings!\n");
				return;
			}
			if(!(parent_req->numChildren == 0 || 
			     numSiblings == parent_req->numChildren)) {
				printk("Inconsistent number of siblings!\n");
				return;
			}
			if(parent_req->childrenMask & positionMask) {
				printk("Already received this child\n");
				return;
			}
			parent_req->numChildren = numSiblings;
			if(parent_req->numChildren == 0) {
				printk("numChildren == 0 (not possible, because we just received a child\n");
				return;
			}
			parent_req->childrenMask |= positionMask;
			allMask = (unsigned)(1 << parent_req->numChildren) - 1;

			if((parent_req->childrenMask & allMask) == allMask) {
				/* Server may not have generated an update covering the entire continuation. If not, resubmit request */
				switch(parent_req->type) {
				case MREQ_CONTINUATION:
				case MREQ_CONVERSION: {
					// Deallocate parent
					// avoid stale pointer dereference when doing next step of alloc_head_walk
					struct Request *clean = parent_req;
					BUG_TRAP(parent_req->seq == tp->t.request_rcv_nxt);
					tp->t.request_rcv_nxt++;

					parent_req = (struct Request *)clean->prev;
					//printk("removed %u-%u\n", clean->start, clean->end);
					unlink((struct alloc_head*)clean);
					freeRequest(clean);
					break;
				}
				default:
					printk("updateParent: unsupported parent type\n");
					BUG();
				}
			}
		}
		/* back in outer loop */
		if(foundCleanable) {
    1eff:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    1f02:	85 c0                	test   %eax,%eax
    1f04:	75 15                	jne    1f1b <updateParent+0x9b>
    1f06:	ff 45 e8             	incl   0xffffffe8(%ebp)
    1f09:	83 7d e8 01          	cmpl   $0x1,0xffffffe8(%ebp)
    1f0d:	76 b4                	jbe    1ec3 <updateParent+0x43>
			break;
		}
	}
	if(!foundCleanable) {
		printk("Error: could not find matching request in reliable request queue!\n");
    1f0f:	c7 04 24 c0 06 00 00 	movl   $0x6c0,(%esp,1)
    1f16:	e8 fc ff ff ff       	call   1f17 <updateParent+0x97>
	}
}
    1f1b:	83 c4 2c             	add    $0x2c,%esp
    1f1e:	5b                   	pop    %ebx
    1f1f:	5e                   	pop    %esi
    1f20:	5f                   	pop    %edi
    1f21:	5d                   	pop    %ebp
    1f22:	c3                   	ret    
    1f23:	8b 43 0c             	mov    0xc(%ebx),%eax
    1f26:	8b 55 0c             	mov    0xc(%ebp),%edx
    1f29:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    1f2c:	39 d0                	cmp    %edx,%eax
    1f2e:	0f 85 46 01 00 00    	jne    207a <updateParent+0x1fa>
    1f34:	83 7d 14 04          	cmpl   $0x4,0x14(%ebp)
    1f38:	c7 45 e4 01 00 00 00 	movl   $0x1,0xffffffe4(%ebp)
    1f3f:	0f 87 29 01 00 00    	ja     206e <updateParent+0x1ee>
    1f45:	8b 75 14             	mov    0x14(%ebp),%esi
    1f48:	39 75 18             	cmp    %esi,0x18(%ebp)
    1f4b:	0f 83 11 01 00 00    	jae    2062 <updateParent+0x1e2>
    1f51:	8b 43 10             	mov    0x10(%ebx),%eax
    1f54:	85 c0                	test   %eax,%eax
    1f56:	74 09                	je     1f61 <updateParent+0xe1>
    1f58:	39 45 14             	cmp    %eax,0x14(%ebp)
    1f5b:	0f 85 f5 00 00 00    	jne    2056 <updateParent+0x1d6>
    1f61:	0f b6 53 14          	movzbl 0x14(%ebx),%edx
    1f65:	89 d0                	mov    %edx,%eax
    1f67:	83 e0 0f             	and    $0xf,%eax
    1f6a:	85 45 dc             	test   %eax,0xffffffdc(%ebp)
    1f6d:	0f 85 d7 00 00 00    	jne    204a <updateParent+0x1ca>
    1f73:	8b 75 14             	mov    0x14(%ebp),%esi
    1f76:	85 f6                	test   %esi,%esi
    1f78:	89 73 10             	mov    %esi,0x10(%ebx)
    1f7b:	0f 84 bd 00 00 00    	je     203e <updateParent+0x1be>
    1f81:	8b 75 dc             	mov    0xffffffdc(%ebp),%esi
    1f84:	80 e2 f0             	and    $0xf0,%dl
    1f87:	09 f0                	or     %esi,%eax
    1f89:	24 0f                	and    $0xf,%al
    1f8b:	08 c2                	or     %al,%dl
    1f8d:	89 d0                	mov    %edx,%eax
    1f8f:	88 53 14             	mov    %dl,0x14(%ebx)
    1f92:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    1f95:	83 e0 0f             	and    $0xf,%eax
    1f98:	21 d0                	and    %edx,%eax
    1f9a:	3b 45 d8             	cmp    0xffffffd8(%ebp),%eax
    1f9d:	0f 85 55 ff ff ff    	jne    1ef8 <updateParent+0x78>
    1fa3:	83 7d d0 01          	cmpl   $0x1,0xffffffd0(%ebp)
    1fa7:	77 6b                	ja     2014 <updateParent+0x194>
    1fa9:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    1fac:	89 de                	mov    %ebx,%esi
    1fae:	8b 82 48 0a 00 00    	mov    0xa48(%edx),%eax
    1fb4:	39 c1                	cmp    %eax,%ecx
    1fb6:	74 1d                	je     1fd5 <updateParent+0x155>
    1fb8:	c7 44 24 04 a4 05 00 	movl   $0x5a4,0x4(%esp,1)
    1fbf:	00 
    1fc0:	c7 04 24 20 07 00 00 	movl   $0x720,(%esp,1)
    1fc7:	e8 fc ff ff ff       	call   1fc8 <updateParent+0x148>
    1fcc:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
    1fcf:	8b 81 48 0a 00 00    	mov    0xa48(%ecx),%eax
    1fd5:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    1fd8:	40                   	inc    %eax
    1fd9:	89 82 48 0a 00 00    	mov    %eax,0xa48(%edx)
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    1fdf:	8b 56 04             	mov    0x4(%esi),%edx
    1fe2:	8b 06                	mov    (%esi),%eax
    1fe4:	8b 1b                	mov    (%ebx),%ebx
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    1fe6:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    1fe8:	8b 06                	mov    (%esi),%eax
	elem->prev = elem->next = NULL;
    1fea:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    1ff0:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
    1ff3:	8b 46 08             	mov    0x8(%esi),%eax
    1ff6:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
    1ffd:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    2000:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    2007:	89 34 24             	mov    %esi,(%esp,1)
    200a:	e8 fc ff ff ff       	call   200b <updateParent+0x18b>
    200f:	e9 e4 fe ff ff       	jmp    1ef8 <updateParent+0x78>
    2014:	c7 04 24 80 07 00 00 	movl   $0x780,(%esp,1)
    201b:	e8 fc ff ff ff       	call   201c <updateParent+0x19c>
    2020:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    2027:	00 
    2028:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    202f:	e8 fc ff ff ff       	call   2030 <updateParent+0x1b0>
    2034:	e8 fc ff ff ff       	call   2035 <updateParent+0x1b5>
    2039:	e9 ba fe ff ff       	jmp    1ef8 <updateParent+0x78>
    203e:	c7 04 24 c0 07 00 00 	movl   $0x7c0,(%esp,1)
    2045:	e9 cc fe ff ff       	jmp    1f16 <updateParent+0x96>
    204a:	c7 04 24 35 01 00 00 	movl   $0x135,(%esp,1)
    2051:	e9 c0 fe ff ff       	jmp    1f16 <updateParent+0x96>
    2056:	c7 04 24 20 08 00 00 	movl   $0x820,(%esp,1)
    205d:	e9 b4 fe ff ff       	jmp    1f16 <updateParent+0x96>
    2062:	c7 04 24 52 01 00 00 	movl   $0x152,(%esp,1)
    2069:	e9 a8 fe ff ff       	jmp    1f16 <updateParent+0x96>
    206e:	c7 04 24 6c 01 00 00 	movl   $0x16c,(%esp,1)
    2075:	e9 9c fe ff ff       	jmp    1f16 <updateParent+0x96>
    207a:	c7 04 24 60 08 00 00 	movl   $0x860,(%esp,1)
    2081:	e9 90 fe ff ff       	jmp    1f16 <updateParent+0x96>
    2086:	8d 76 00             	lea    0x0(%esi),%esi
    2089:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00002090 <removeObsoleteContinuations>:

void removeObsoleteContinuations(struct sock *sk) {
    2090:	55                   	push   %ebp
    2091:	89 e5                	mov    %esp,%ebp
    2093:	57                   	push   %edi
    2094:	56                   	push   %esi
    2095:	53                   	push   %ebx
    2096:	83 ec 04             	sub    $0x4,%esp
    2099:	8b 45 08             	mov    0x8(%ebp),%eax
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    209c:	8d b8 bc 00 00 00    	lea    0xbc(%eax),%edi
	struct UC_Continuation *ucont;
	int count = 0;
	alloc_head_walk(&tp->t.ucontList, ucont) {
    20a2:	05 a0 0b 00 00       	add    $0xba0,%eax
    20a7:	8b 9f e8 0a 00 00    	mov    0xae8(%edi),%ebx
    20ad:	39 c3                	cmp    %eax,%ebx
    20af:	74 1e                	je     20cf <removeObsoleteContinuations+0x3f>
    20b1:	89 c6                	mov    %eax,%esi
    20b3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    20b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
		if(ucont->kernel.obsoleteAt <= tp->rcv_nxt) {
    20c0:	8b 47 08             	mov    0x8(%edi),%eax
    20c3:	39 43 2c             	cmp    %eax,0x2c(%ebx)
    20c6:	76 0d                	jbe    20d5 <removeObsoleteContinuations+0x45>
    20c8:	8b 5b 04             	mov    0x4(%ebx),%ebx
    20cb:	39 f3                	cmp    %esi,%ebx
    20cd:	75 f1                	jne    20c0 <removeObsoleteContinuations+0x30>
			struct UC_Continuation *clean = ucont;
#ifdef FINDUC_DBG
			printk("Removed continuation c=%d o=%d [%d-%d] [%d-%d]\n", 
			       count, clean->kernel.obsoleteAt,
			       clean->validStart, clean->validEnd,
			       clean->clientValidStart, clean->clientValidEnd);
#endif
			ucont = (struct UC_Continuation*)ucont->prev;
			unlink((struct alloc_head*)clean);
			count++;
			kfree(clean);
		}
	}
}
    20cf:	5f                   	pop    %edi
    20d0:	5b                   	pop    %ebx
    20d1:	5e                   	pop    %esi
    20d2:	5f                   	pop    %edi
    20d3:	5d                   	pop    %ebp
    20d4:	c3                   	ret    
    20d5:	89 da                	mov    %ebx,%edx
    20d7:	8b 1b                	mov    (%ebx),%ebx
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    20d9:	8b 4a 04             	mov    0x4(%edx),%ecx
    20dc:	89 19                	mov    %ebx,(%ecx)
	elem->prev->next = elem->next;
    20de:	8b 02                	mov    (%edx),%eax
	elem->prev = elem->next = NULL;
    20e0:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
    20e6:	89 48 04             	mov    %ecx,0x4(%eax)

	elem->list->len--;
    20e9:	8b 42 08             	mov    0x8(%edx),%eax
    20ec:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
    20f3:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    20f6:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
    20fd:	89 14 24             	mov    %edx,(%esp,1)
    2100:	e8 fc ff ff ff       	call   2101 <removeObsoleteContinuations+0x71>
    2105:	eb c1                	jmp    20c8 <removeObsoleteContinuations+0x38>
    2107:	89 f6                	mov    %esi,%esi
    2109:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00002110 <removeObsoleteDependencies>:

void removeObsoleteDependencies(struct sock *sk) {
    2110:	55                   	push   %ebp
    2111:	89 e5                	mov    %esp,%ebp
    2113:	56                   	push   %esi
    2114:	53                   	push   %ebx
    2115:	83 ec 08             	sub    $0x8,%esp
    2118:	8b 45 08             	mov    0x8(%ebp),%eax
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	struct UC_DependencyNode *depNode;
	/* Drop reference count for dependency nodes that we no longer need for requesting new data */
	alloc_head_walk(&tp->t.depNodeList, depNode) {
    211b:	8b 98 b8 0b 00 00    	mov    0xbb8(%eax),%ebx
    2121:	05 b4 0b 00 00       	add    $0xbb4,%eax
    2126:	39 c3                	cmp    %eax,%ebx
    2128:	74 32                	je     215c <removeObsoleteDependencies+0x4c>
    212a:	89 c6                	mov    %eax,%esi
    212c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    return 0;
  }
  return dep->refCnt;
#else
  printk("Dependency management doesn't work yet\n");
    2130:	c7 04 24 a0 08 00 00 	movl   $0x8a0,(%esp,1)
    2137:	e8 fc ff ff ff       	call   2138 <removeObsoleteDependencies+0x28>
  BUG();
    213c:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    2143:	00 
    2144:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    214b:	e8 fc ff ff ff       	call   214c <removeObsoleteDependencies+0x3c>
    2150:	e8 fc ff ff ff       	call   2151 <removeObsoleteDependencies+0x41>
    2155:	8b 5b 04             	mov    0x4(%ebx),%ebx
    2158:	39 f3                	cmp    %esi,%ebx
    215a:	75 d4                	jne    2130 <removeObsoleteDependencies+0x20>
		struct UC_DependencyNode *prev = (struct UC_DependencyNode*)depNode->prev;
		if(freeDependencyNode(sk,depNode) == 0) {
			/* dependency was freed and unlinked, so avoid dereferencing a dangling pointer */
			depNode = prev;
		}
	}
}
    215c:	83 c4 08             	add    $0x8,%esp
    215f:	5b                   	pop    %ebx
    2160:	5e                   	pop    %esi
    2161:	5d                   	pop    %ebp
    2162:	c3                   	ret    
    2163:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    2169:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00002170 <UpdateClientTransportState>:

static inline void removeObsoleteDataRequestMaps(struct sock *sk, unsigned transportSeq) {
	/* Side effect: updates rtt estimate */
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	int i;
	struct DataRequestMapping *dataReqMap, *nextDataReqMap;
	struct alloc_head_list* dataRequestLists[] = {
		&tp->t.dataRequestMap,
		&tp->t.missingDataMap};

	TIMING_CTX_DEF0("removeObsoleteDataRequestMaps", "requestMap", "missingMap");
	TIMING_CTX_DEF1(1,1);
	reinitTimingCtx(&ctx);
	for(i=0; i < 2; i++) {
		struct alloc_head_list *currList = dataRequestLists[i];
		recordSample(&ctx, i);
		for(dataReqMap = (struct DataRequestMapping *)currList->next;
		    dataReqMap != (struct DataRequestMapping *)currList;
		    dataReqMap = nextDataReqMap) {
			int freed = 0;
			nextDataReqMap = dataReqMap->next;

			if(dataReqMap->end <= tp->rcv_nxt) {
				unlink((struct alloc_head*)dataReqMap);
				/* update rtt estimate if obsolete request matches current packet */
				// XXX - with this algorithm, reordering inflates rtt (timing is updated when the packet can be delivered in-order, not when it is first received)
				// XXX should we test the sequence number?
				if(1 /* || dataReqMap->transportResponseSeqStart <= transportSeq && 
					transportSeq < dataReqMap->transportResponseSeqEnd */) {
#ifdef FIXEDRTT
					tp->t.rtt = (FIXEDRTT);
#else
#if 0
					if(tp->t.rtt == 0) {
						tp->t.rtt = (jiffies - dataReqMap->timestamp) << 3;
					} else {
						tp->t.rtt = (tp->t.rtt - (tp->t.rtt >> 3)) +
							(jiffies - dataReqMap->timestamp);
					}
#else
					// 0425: change to use timestamp option
					// code moved to trickles_client_rcv
#endif
#endif
					{
						static int rttCounter = 0;
						rttCounter++;
						if(clientDebugLevel >= 2) {
							if(rttCounter % 1000 == 0)
								printk("HZ=%d delta %lu, new rtt %d %d/8\n", HZ, jiffies - dataReqMap->timestamp, tp->t.rtt >> 3, tp->t.rtt & 0x7);
						}
					}
				}
				freeDataRequestMapping(dataReqMap);
				freed = 1;
#if 0
				// use new value of rtt for timeout
				tp->t.delay = 2 * (tp->t.rtt >> 3);
#else
				// moved to trickles_client_rcv
#endif
				resetClientTimer(sk);
			}
			if(!freed && dataReqMap->sent && 
			   !dataReqMap->completed && // hint
			   tp->t.rcv_nxt >= dataReqMap->transportResponseSeqEnd) {
				// dataReqMap is still valid
				// If tp->t.rcv_nxt >= transportSeqEnd, then the server may not have sent us the full request.
				// Find missing parts of the request, and resubmit

				// save old head
				struct alloc_head *prevMap = (struct alloc_head*) dataReqMap->prev, 
					*nextMap = (struct alloc_head*)dataReqMap->next;
				int inserted = 0;
				int lastEnd = MAX(dataReqMap->start, tp->rcv_nxt);
				struct sk_buff *finger = tp->t.ofo_queue.next;
				unlink((struct alloc_head*)dataReqMap);

				// XXX 0505 OPTIMIZE - Pick optimal walking direction? Would probably result in 2x speedup if we
				// check whether we're closer to the left or the right
				skb_queue_walk(&tp->t.data_ofo_queue, finger) {
					// detect overlap
					int minSeq = MAX(TCP_SKB_CB(finger)->seq, dataReqMap->start);
					int maxSeq = MIN(TCP_SKB_CB(finger)->end_seq, dataReqMap->end);
					if(maxSeq >= dataReqMap->end) {
						break;
					}
					if(minSeq < maxSeq) {
						// overlap
						if(lastEnd < minSeq) {
							// void between last skb and this skb; ask server to fill it in
							submitDerivedDataRequestMapping(sk, dataReqMap, lastEnd, minSeq);
							inserted = 1;
#ifdef SPEW_PARTIAL
							printk("Inserted %d-%d\n", lastEnd, minSeq);
#endif
						}
						lastEnd = maxSeq;
					}
				}

				if(lastEnd < dataReqMap->end) {
					int myStart = lastEnd,
						myEnd = dataReqMap->end;
					if(!inserted) {
						// common case: server omitted data at the end of the request. 
						// Reuse existing mapping
						submitDataRequestMapping(sk, dataReqMap, myStart, myEnd);
#ifdef SPEW_PARTIAL
						printk("Inserted %d-%d\n", myStart, myEnd);
#endif
					} else {
						submitDerivedDataRequestMapping(sk, dataReqMap, myStart, myEnd);
#ifdef SPEW_PARTIAL
						printk("Inserted %d-%d\n", myStart, myEnd);
#endif
					}
				} else {
					if(!inserted) {
						// request is completely covered; put it back
						dataReqMap->completed = 1;
						insert((struct alloc_head*)dataReqMap, prevMap, nextMap);
					}
				}
			}
		}
		recordSample(&ctx, i);
	}
	printTimings(&ctx);
}

void UpdateClientTransportState(struct sock *sk, struct sk_buff *skb, CONTINUATION_TYPE *cont) {
    2170:	55                   	push   %ebp
    2171:	89 e5                	mov    %esp,%ebp
    2173:	83 ec 34             	sub    $0x34,%esp
    2176:	89 5d f4             	mov    %ebx,0xfffffff4(%ebp)
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    2179:	8b 5d 08             	mov    0x8(%ebp),%ebx
	// if noCont, then no available information for updating state machine
	BUG_TRAP(cont->seq <= tp->t.rcv_nxt);
    217c:	8b 55 10             	mov    0x10(%ebp),%edx
    217f:	89 75 f8             	mov    %esi,0xfffffff8(%ebp)
    2182:	81 c3 bc 00 00 00    	add    $0xbc,%ebx
    2188:	89 7d fc             	mov    %edi,0xfffffffc(%ebp)
    218b:	8b 83 dc 02 00 00    	mov    0x2dc(%ebx),%eax
    2191:	39 42 34             	cmp    %eax,0x34(%edx)
    2194:	0f 87 18 04 00 00    	ja     25b2 <UpdateClientTransportState+0x442>
#define UPTODATE(CONT) ((CONT)->clientState == tp->t.clientStateCounter)
	/* Transport level updates */
	if(cont->continuationType == CONTTYPE_MINIMAL) {
    219a:	8b 75 10             	mov    0x10(%ebp),%esi
    219d:	8b 46 38             	mov    0x38(%esi),%eax
    21a0:	85 c0                	test   %eax,%eax
    21a2:	74 1c                	je     21c0 <UpdateClientTransportState+0x50>
		// minimal continuation type cannot update transport state
		return;
	}
	switch(tp->t.state) {
    21a4:	8b 83 cc 02 00 00    	mov    0x2cc(%ebx),%eax
    21aa:	83 f8 02             	cmp    $0x2,%eax
    21ad:	0f 84 bd 03 00 00    	je     2570 <UpdateClientTransportState+0x400>
    21b3:	83 f8 02             	cmp    $0x2,%eax
    21b6:	7f 38                	jg     21f0 <UpdateClientTransportState+0x80>
    21b8:	48                   	dec    %eax
    21b9:	74 12                	je     21cd <UpdateClientTransportState+0x5d>
    21bb:	90                   	nop    
    21bc:	8d 74 26 00          	lea    0x0(%esi,1),%esi
	case TRICKLES_CLIENT_NORMAL:
		if(cont->firstChild)
			tp->t.in_flight = MAX(0, tp->t.in_flight - 1);
		break;
	case TRICKLES_CLIENT_RECOVERY:
		if(cont->state == CONT_BOOTSTRAP &&
		   UPTODATE(cont)) {
			if(clientDebugLevel >= 2)
				printk("received bootstrap continuation\n");
			/* during recovery, need to switch to bootstrap continuation */
			/* If bootstrap state, fall through to check if we should exit from recovery */
			goto exit_recovery;
		} else {
			break;
		}
	case TRICKLES_CLIENT_SLOWSTART:
	exit_recovery:
		if(UPTODATE(cont) && cont->seq == cont->TCPBase) {
			/* exit recovery */
			CONTINUATION_TYPE *cont_curs, *next;
			__u32 prev_seq = tp->t.ack_prev->TCPBase; // 0501 cleanup
			if(clientDebugLevel >= 1)
				printk("client_rcv: exit recovery or slow start : seq = %u oldBase = %u newBase = %u startCwnd = %u\n", cont->seq, 
				       prev_seq, cont->TCPBase, cont->startCwnd);

			tp->t.standardProof.numSacks = 0;
			AckProof_update(sk, &tp->t.standardProof, cont);
			for(cont_curs = (CONTINUATION_TYPE*)tp->t.cont_list.next;
			    cont_curs != (CONTINUATION_TYPE*)&tp->t.cont_list;
			    cont_curs = next) {
				next = (CONTINUATION_TYPE*)cont_curs->next;

				// 0424 - tighten up conditions to detect inconsistent states
				/*
				if(((tp->t.state == TRICKLES_CLIENT_SLOWSTART && UPTODATE(cont_curs)) ||
				    ((tp->t.state == TRICKLES_CLIENT_RECOVERY) && cont_curs->seq >= cont->TCPBase))) {
				*/
				if(UPTODATE(cont_curs) && cont_curs->TCPBase >= cont->TCPBase) {
					BUG_TRAP(cont_curs->TCPBase >= cont->TCPBase);
					AckProof_update(sk, &tp->t.standardProof, cont_curs);
				} else {
					/* there should not be any older continuations in list */
					// XXX 0426 - Additional violation situations are possible if requestSlowStart fails because it cannot find a continuation that can be used for the slow start request
					if(!(cont_curs->clientState == tp->t.clientStateCounter-2 /* recovery followed by slow start */ || 
					     cont_curs->clientState == tp->t.clientStateCounter-1 /* recovery */||
					     cont_curs->clientState == tp->t.clientStateCounter)) {
						if(!disableSevereErrors)
							printk("%p: cleaning violation: cursor state %d current client state %d\n",
							       sk, cont_curs->clientState, tp->t.clientStateCounter);
					}
					BUG_TRAP(cont_curs != cont);
					unlinkCont(cont_curs);
					MARK_PC(cont_curs);
#if 1 // 0430 disabled to isolate bug (yes this reveals a bunch of memory errors)
					freeClientSide_Continuation(cont_curs);
#else
					if((int)cont_curs & 0xfff) {
						BUG();
					}
					BUG_TRAP(((int)cont_curs & 0xfff) == 0);
					zap_virt(cont_curs);
#endif
				}
			}
			/* only up-to-date continuations in cont_list now */
			tp->t.altProof = tp->t.standardProof;
#if 0
			printk("standard ");
			AckProof_dump(&tp->t.standardProof);
			printk("alt ");
			AckProof_dump(&tp->t.altProof);
#endif
			BUG_TRAP(tp->t.standardProof.sacks[0].left <= cont->TCPBase);
			BUG_TRAP(tp->t.altProof.sacks[0].left <= cont->TCPBase);
				
			tp->t.previous_base = cont->TCPBase;
			if(clientDebugLevel >= 1)
				printk("new cwnd: %d ssthresh: %d seq: %d base: %d\n", cont->startCwnd, cont->ssthresh, cont->seq, cont->TCPBase);
			if(clientDebugLevel >= 1 ||  debugTransitions) {
				char *oldState;
				switch(tp->t.state) {
				case TRICKLES_CLIENT_SLOWSTART:
					oldState = "SlowStart";
					break;
				case TRICKLES_CLIENT_RECOVERY:
					oldState = "Recovery";
					break;
				case TRICKLES_CLIENT_NORMAL:
					oldState = "NORMAL!!";
					BUG();
					break;
				default:
					oldState = "UNKNOWN!!";
					BUG();
					break;
				}
				printk("%p: %s=>Normal\n", sk, oldState); // 0419
			}
			appendTricklesLossEvent(sk, MIN(cont->startCwnd, EVENT_CWND_MAX),
						EVENT_EXTRA_RECV, tp->t.state);

			tp->t.state = TRICKLES_CLIENT_NORMAL;
			tp->t.oo_count = 0;
			tp->t.in_flight = 0;

			tp->t.timerState = TRICKLES_ENABLE_DATA_TIMEOUT;
			resetClientTimer(sk);

			//SAVE_ACK_PREV(tp);
			tp->t.ack_prev = NULL;
			tp->t.ack_last = cont->seq;
			//0501 - called twice when recovering
			//findAckables(sk, 0, NULL);
			break;
		}
	}
}
    21c0:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
    21c3:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
    21c6:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
    21c9:	89 ec                	mov    %ebp,%esp
    21cb:	5d                   	pop    %ebp
    21cc:	c3                   	ret    
    21cd:	8b 7d 10             	mov    0x10(%ebp),%edi
    21d0:	8b 47 5c             	mov    0x5c(%edi),%eax
    21d3:	85 c0                	test   %eax,%eax
    21d5:	74 e9                	je     21c0 <UpdateClientTransportState+0x50>
    21d7:	8b 83 fc 02 00 00    	mov    0x2fc(%ebx),%eax
    21dd:	31 d2                	xor    %edx,%edx
    21df:	48                   	dec    %eax
    21e0:	0f 49 d0             	cmovns %eax,%edx
    21e3:	89 93 fc 02 00 00    	mov    %edx,0x2fc(%ebx)
    21e9:	eb d5                	jmp    21c0 <UpdateClientTransportState+0x50>
    21eb:	90                   	nop    
    21ec:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    21f0:	83 f8 03             	cmp    $0x3,%eax
    21f3:	75 cb                	jne    21c0 <UpdateClientTransportState+0x50>
    21f5:	8b 7d 10             	mov    0x10(%ebp),%edi
    21f8:	8b 57 3c             	mov    0x3c(%edi),%edx
    21fb:	8b 83 c8 02 00 00    	mov    0x2c8(%ebx),%eax
    2201:	39 c2                	cmp    %eax,%edx
    2203:	75 bb                	jne    21c0 <UpdateClientTransportState+0x50>
    2205:	8b 45 10             	mov    0x10(%ebp),%eax
    2208:	8b 50 34             	mov    0x34(%eax),%edx
    220b:	3b 50 70             	cmp    0x70(%eax),%edx
    220e:	75 b0                	jne    21c0 <UpdateClientTransportState+0x50>
    2210:	8b 83 f0 02 00 00    	mov    0x2f0(%ebx),%eax
    2216:	8b 48 70             	mov    0x70(%eax),%ecx
    2219:	a1 00 00 00 00       	mov    0x0,%eax
    221e:	85 c0                	test   %eax,%eax
    2220:	7e 22                	jle    2244 <UpdateClientTransportState+0xd4>
    2222:	8b 75 10             	mov    0x10(%ebp),%esi
    2225:	8b 46 68             	mov    0x68(%esi),%eax
    2228:	89 54 24 0c          	mov    %edx,0xc(%esp,1)
    222c:	89 4c 24 08          	mov    %ecx,0x8(%esp,1)
    2230:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    2234:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    2238:	c7 04 24 e0 08 00 00 	movl   $0x8e0,(%esp,1)
    223f:	e8 fc ff ff ff       	call   2240 <UpdateClientTransportState+0xd0>
    2244:	31 c0                	xor    %eax,%eax
    2246:	89 83 00 03 00 00    	mov    %eax,0x300(%ebx)
    224c:	8d 83 00 03 00 00    	lea    0x300(%ebx),%eax
    2252:	8b 7d 10             	mov    0x10(%ebp),%edi
    2255:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    2258:	8b 55 08             	mov    0x8(%ebp),%edx
    225b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    225f:	89 7c 24 08          	mov    %edi,0x8(%esp,1)
    2263:	8d bb 20 0a 00 00    	lea    0xa20(%ebx),%edi
    2269:	89 14 24             	mov    %edx,(%esp,1)
    226c:	e8 fc ff ff ff       	call   226d <UpdateClientTransportState+0xfd>
    2271:	8b b3 24 0a 00 00    	mov    0xa24(%ebx),%esi
    2277:	89 7d e4             	mov    %edi,0xffffffe4(%ebp)
    227a:	39 fe                	cmp    %edi,%esi
    227c:	0f 84 c1 00 00 00    	je     2343 <UpdateClientTransportState+0x1d3>
    2282:	8b 46 04             	mov    0x4(%esi),%eax
    2285:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    2288:	8b 56 3c             	mov    0x3c(%esi),%edx
    228b:	8b 8b c8 02 00 00    	mov    0x2c8(%ebx),%ecx
    2291:	39 ca                	cmp    %ecx,%edx
    2293:	0f 84 ad 02 00 00    	je     2546 <UpdateClientTransportState+0x3d6>
    2299:	8d 41 fe             	lea    0xfffffffe(%ecx),%eax
    229c:	39 c2                	cmp    %eax,%edx
    229e:	74 19                	je     22b9 <UpdateClientTransportState+0x149>
    22a0:	8d 41 ff             	lea    0xffffffff(%ecx),%eax
    22a3:	39 c2                	cmp    %eax,%edx
    22a5:	74 12                	je     22b9 <UpdateClientTransportState+0x149>
    22a7:	39 ca                	cmp    %ecx,%edx
    22a9:	74 0e                	je     22b9 <UpdateClientTransportState+0x149>
    22ab:	8b 3d 00 00 00 00    	mov    0x0,%edi
    22b1:	85 ff                	test   %edi,%edi
    22b3:	0f 84 6a 02 00 00    	je     2523 <UpdateClientTransportState+0x3b3>
    22b9:	3b 75 10             	cmp    0x10(%ebp),%esi
    22bc:	0f 84 48 02 00 00    	je     250a <UpdateClientTransportState+0x39a>
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    22c2:	8b 56 04             	mov    0x4(%esi),%edx
    22c5:	8b 06                	mov    (%esi),%eax
    22c7:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    22c9:	8b 06                	mov    (%esi),%eax
	elem->prev = elem->next = NULL;
    22cb:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    22d1:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
    22d4:	8b 46 08             	mov    0x8(%esi),%eax
    22d7:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
    22de:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    22e1:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
  if(cont->list) {
	  BUG();
  }

  for(i=0; i < 2; i++) {
    22e8:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
    22ef:	c7 45 e8 01 00 00 00 	movl   $0x1,0xffffffe8(%ebp)
    if((cont+i)->ucont_data)
    22f6:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    22f9:	8b 84 16 80 00 00 00 	mov    0x80(%esi,%edx,1),%eax
    2300:	85 c0                	test   %eax,%eax
    2302:	0f 85 f5 01 00 00    	jne    24fd <UpdateClientTransportState+0x38d>
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
    2308:	8b 7d e0             	mov    0xffffffe0(%ebp),%edi
    230b:	8b 84 3e 88 00 00 00 	mov    0x88(%esi,%edi,1),%eax
    2312:	85 c0                	test   %eax,%eax
    2314:	0f 85 d6 01 00 00    	jne    24f0 <UpdateClientTransportState+0x380>
    231a:	81 45 e0 e4 00 00 00 	addl   $0xe4,0xffffffe0(%ebp)
    2321:	ff 4d e8             	decl   0xffffffe8(%ebp)
    2324:	79 d0                	jns    22f6 <UpdateClientTransportState+0x186>
      kfree((cont+i)->input);
  }

#ifdef USERTEST
  kfree(cont);
#else  //0426 - change kernel to slab cache
#ifdef DEBUG_ALLOC
  zap_virt(cont);
  //memset(cont, 0x3e, sizeof(*cont));
#else
#ifndef USESLAB
  kfree(cont);  // 0502 maybe slab cache usage is buggy
#else
  kmem_cache_free(clientSideContinuation_cache, cont);
    2326:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    232a:	a1 00 00 00 00       	mov    0x0,%eax
    232f:	89 04 24             	mov    %eax,(%esp,1)
    2332:	e8 fc ff ff ff       	call   2333 <UpdateClientTransportState+0x1c3>
    2337:	8b 75 f0             	mov    0xfffffff0(%ebp),%esi
    233a:	3b 75 e4             	cmp    0xffffffe4(%ebp),%esi
    233d:	0f 85 3f ff ff ff    	jne    2282 <UpdateClientTransportState+0x112>
    2343:	8d 83 08 06 00 00    	lea    0x608(%ebx),%eax
    2349:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    234c:	a9 04 00 00 00       	test   $0x4,%eax
    2351:	ba 08 03 00 00       	mov    $0x308,%edx
    2356:	74 1d                	je     2375 <UpdateClientTransportState+0x205>
    2358:	8b 83 00 03 00 00    	mov    0x300(%ebx),%eax
    235e:	8d b3 04 03 00 00    	lea    0x304(%ebx),%esi
    2364:	ba 04 03 00 00       	mov    $0x304,%edx
    2369:	89 83 08 06 00 00    	mov    %eax,0x608(%ebx)
    236f:	8d 83 0c 06 00 00    	lea    0x60c(%ebx),%eax
    2375:	fc                   	cld    
    2376:	89 d1                	mov    %edx,%ecx
    2378:	c1 e9 02             	shr    $0x2,%ecx
    237b:	89 c7                	mov    %eax,%edi
    237d:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    237f:	8b 55 10             	mov    0x10(%ebp),%edx
    2382:	8b 42 70             	mov    0x70(%edx),%eax
    2385:	39 83 08 03 00 00    	cmp    %eax,0x308(%ebx)
    238b:	0f 87 3a 01 00 00    	ja     24cb <UpdateClientTransportState+0x35b>
    2391:	39 83 10 06 00 00    	cmp    %eax,0x610(%ebx)
    2397:	0f 87 0f 01 00 00    	ja     24ac <UpdateClientTransportState+0x33c>
    239d:	89 83 e0 02 00 00    	mov    %eax,0x2e0(%ebx)
    23a3:	8b 0d 00 00 00 00    	mov    0x0,%ecx
    23a9:	85 c9                	test   %ecx,%ecx
    23ab:	0f 8e ed 00 00 00    	jle    249e <UpdateClientTransportState+0x32e>
    23b1:	8b 55 10             	mov    0x10(%ebp),%edx
    23b4:	8b 42 70             	mov    0x70(%edx),%eax
    23b7:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    23bb:	8b 42 34             	mov    0x34(%edx),%eax
    23be:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    23c2:	8b 42 6c             	mov    0x6c(%edx),%eax
    23c5:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    23c9:	8b 42 68             	mov    0x68(%edx),%eax
    23cc:	c7 04 24 40 09 00 00 	movl   $0x940,(%esp,1)
    23d3:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    23d7:	e8 fc ff ff ff       	call   23d8 <UpdateClientTransportState+0x268>
    23dc:	8b 15 00 00 00 00    	mov    0x0,%edx
    23e2:	85 d2                	test   %edx,%edx
    23e4:	0f 8e b4 00 00 00    	jle    249e <UpdateClientTransportState+0x32e>
    23ea:	8b 83 cc 02 00 00    	mov    0x2cc(%ebx),%eax
    23f0:	be 80 01 00 00       	mov    $0x180,%esi
    23f5:	83 f8 02             	cmp    $0x2,%eax
    23f8:	74 2a                	je     2424 <UpdateClientTransportState+0x2b4>
    23fa:	83 f8 02             	cmp    $0x2,%eax
    23fd:	0f 8f 8c 00 00 00    	jg     248f <UpdateClientTransportState+0x31f>
    2403:	48                   	dec    %eax
    2404:	74 7f                	je     2485 <UpdateClientTransportState+0x315>
    2406:	be 89 01 00 00       	mov    $0x189,%esi
    240b:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    2412:	00 
    2413:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    241a:	e8 fc ff ff ff       	call   241b <UpdateClientTransportState+0x2ab>
    241f:	e8 fc ff ff ff       	call   2420 <UpdateClientTransportState+0x2b0>
    2424:	89 74 24 08          	mov    %esi,0x8(%esp,1)
    2428:	8b 75 08             	mov    0x8(%ebp),%esi
    242b:	c7 04 24 93 01 00 00 	movl   $0x193,(%esp,1)
    2432:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    2436:	e8 fc ff ff ff       	call   2437 <UpdateClientTransportState+0x2c7>
    243b:	b8 01 00 00 00       	mov    $0x1,%eax
    2440:	89 83 cc 02 00 00    	mov    %eax,0x2cc(%ebx)
    2446:	31 c0                	xor    %eax,%eax
    2448:	89 83 f8 02 00 00    	mov    %eax,0x2f8(%ebx)
    244e:	31 c0                	xor    %eax,%eax
    2450:	89 83 fc 02 00 00    	mov    %eax,0x2fc(%ebx)
    2456:	b8 01 00 00 00       	mov    $0x1,%eax
    245b:	89 83 d8 02 00 00    	mov    %eax,0x2d8(%ebx)
    2461:	8b 7d 08             	mov    0x8(%ebp),%edi
    2464:	89 3c 24             	mov    %edi,(%esp,1)
    2467:	e8 fc ff ff ff       	call   2468 <UpdateClientTransportState+0x2f8>
    246c:	31 c0                	xor    %eax,%eax
    246e:	89 83 f0 02 00 00    	mov    %eax,0x2f0(%ebx)
    2474:	8b 55 10             	mov    0x10(%ebp),%edx
    2477:	8b 42 34             	mov    0x34(%edx),%eax
    247a:	89 83 f4 02 00 00    	mov    %eax,0x2f4(%ebx)
    2480:	e9 3b fd ff ff       	jmp    21c0 <UpdateClientTransportState+0x50>
    2485:	be a3 01 00 00       	mov    $0x1a3,%esi
    248a:	e9 7c ff ff ff       	jmp    240b <UpdateClientTransportState+0x29b>
    248f:	83 f8 03             	cmp    $0x3,%eax
    2492:	be ac 01 00 00       	mov    $0x1ac,%esi
    2497:	74 8b                	je     2424 <UpdateClientTransportState+0x2b4>
    2499:	e9 68 ff ff ff       	jmp    2406 <UpdateClientTransportState+0x296>
    249e:	a1 00 00 00 00       	mov    0x0,%eax
    24a3:	85 c0                	test   %eax,%eax
    24a5:	74 94                	je     243b <UpdateClientTransportState+0x2cb>
    24a7:	e9 3e ff ff ff       	jmp    23ea <UpdateClientTransportState+0x27a>
    24ac:	c7 44 24 04 b5 06 00 	movl   $0x6b5,0x4(%esp,1)
    24b3:	00 
    24b4:	c7 04 24 80 09 00 00 	movl   $0x980,(%esp,1)
    24bb:	e8 fc ff ff ff       	call   24bc <UpdateClientTransportState+0x34c>
    24c0:	8b 7d 10             	mov    0x10(%ebp),%edi
    24c3:	8b 47 70             	mov    0x70(%edi),%eax
    24c6:	e9 d2 fe ff ff       	jmp    239d <UpdateClientTransportState+0x22d>
    24cb:	c7 44 24 04 b4 06 00 	movl   $0x6b4,0x4(%esp,1)
    24d2:	00 
    24d3:	c7 04 24 e0 09 00 00 	movl   $0x9e0,(%esp,1)
    24da:	e8 fc ff ff ff       	call   24db <UpdateClientTransportState+0x36b>
    24df:	8b 75 10             	mov    0x10(%ebp),%esi
    24e2:	8b 46 70             	mov    0x70(%esi),%eax
    24e5:	e9 a7 fe ff ff       	jmp    2391 <UpdateClientTransportState+0x221>
    24ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  for(i=0; i < 2; i++) {
    if((cont+i)->ucont_data)
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
      kfree((cont+i)->input);
    24f0:	89 04 24             	mov    %eax,(%esp,1)
    24f3:	e8 fc ff ff ff       	call   24f4 <UpdateClientTransportState+0x384>
    24f8:	e9 1d fe ff ff       	jmp    231a <UpdateClientTransportState+0x1aa>
    24fd:	89 04 24             	mov    %eax,(%esp,1)
    2500:	e8 fc ff ff ff       	call   2501 <UpdateClientTransportState+0x391>
    2505:	e9 fe fd ff ff       	jmp    2308 <UpdateClientTransportState+0x198>
    250a:	c7 44 24 04 9e 06 00 	movl   $0x69e,0x4(%esp,1)
    2511:	00 
    2512:	c7 04 24 60 0a 00 00 	movl   $0xa60,(%esp,1)
    2519:	e8 fc ff ff ff       	call   251a <UpdateClientTransportState+0x3aa>
    251e:	e9 9f fd ff ff       	jmp    22c2 <UpdateClientTransportState+0x152>
    2523:	89 4c 24 0c          	mov    %ecx,0xc(%esp,1)
    2527:	8b 46 3c             	mov    0x3c(%esi),%eax
    252a:	8b 7d 08             	mov    0x8(%ebp),%edi
    252d:	c7 04 24 a0 0a 00 00 	movl   $0xaa0,(%esp,1)
    2534:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    2538:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
    253c:	e8 fc ff ff ff       	call   253d <UpdateClientTransportState+0x3cd>
    2541:	e9 73 fd ff ff       	jmp    22b9 <UpdateClientTransportState+0x149>
    2546:	8b 7d 10             	mov    0x10(%ebp),%edi
    2549:	8b 47 70             	mov    0x70(%edi),%eax
    254c:	39 46 70             	cmp    %eax,0x70(%esi)
    254f:	0f 82 44 fd ff ff    	jb     2299 <UpdateClientTransportState+0x129>
    2555:	89 74 24 08          	mov    %esi,0x8(%esp,1)
    2559:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    255c:	8b 55 08             	mov    0x8(%ebp),%edx
    255f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    2563:	89 14 24             	mov    %edx,(%esp,1)
    2566:	e8 fc ff ff ff       	call   2567 <UpdateClientTransportState+0x3f7>
    256b:	e9 c7 fd ff ff       	jmp    2337 <UpdateClientTransportState+0x1c7>
    2570:	8b 45 10             	mov    0x10(%ebp),%eax
    2573:	83 78 58 02          	cmpl   $0x2,0x58(%eax)
    2577:	0f 85 43 fc ff ff    	jne    21c0 <UpdateClientTransportState+0x50>
    257d:	8b 50 3c             	mov    0x3c(%eax),%edx
    2580:	8b 83 c8 02 00 00    	mov    0x2c8(%ebx),%eax
    2586:	39 c2                	cmp    %eax,%edx
    2588:	0f 85 32 fc ff ff    	jne    21c0 <UpdateClientTransportState+0x50>
    258e:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    2595:	0f 8e 66 fc ff ff    	jle    2201 <UpdateClientTransportState+0x91>
    259b:	c7 04 24 00 0b 00 00 	movl   $0xb00,(%esp,1)
    25a2:	e8 fc ff ff ff       	call   25a3 <UpdateClientTransportState+0x433>
    25a7:	8b 75 10             	mov    0x10(%ebp),%esi
    25aa:	8b 56 3c             	mov    0x3c(%esi),%edx
    25ad:	e9 49 fc ff ff       	jmp    21fb <UpdateClientTransportState+0x8b>
    25b2:	c7 44 24 04 64 06 00 	movl   $0x664,0x4(%esp,1)
    25b9:	00 
    25ba:	c7 04 24 40 0b 00 00 	movl   $0xb40,(%esp,1)
    25c1:	e8 fc ff ff ff       	call   25c2 <UpdateClientTransportState+0x452>
    25c6:	e9 cf fb ff ff       	jmp    219a <UpdateClientTransportState+0x2a>
    25cb:	90                   	nop    
    25cc:	8d 74 26 00          	lea    0x0(%esi,1),%esi

000025d0 <UpdateClientUCState>:

static void UpdateClientUCState(struct sock *sk, struct sk_buff *skb, CONTINUATION_TYPE *cont) {
    25d0:	55                   	push   %ebp
    25d1:	89 e5                	mov    %esp,%ebp
    25d3:	57                   	push   %edi
    25d4:	56                   	push   %esi
    25d5:	53                   	push   %ebx
    25d6:	83 ec 44             	sub    $0x44,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	struct WireUC_RespHeader *hdr;
	struct UC_Continuation *addedUCont = NULL;
    25d9:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
    25e0:	8b 45 08             	mov    0x8(%ebp),%eax
    25e3:	8b 55 0c             	mov    0xc(%ebp),%edx
    25e6:	8b 4d 10             	mov    0x10(%ebp),%ecx
    25e9:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    25ec:	05 bc 00 00 00       	add    $0xbc,%eax
    25f1:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
    25f4:	89 4d e8             	mov    %ecx,0xffffffe8(%ebp)
    25f7:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
	int isSynack = skb->h.th->syn && skb->h.th->ack;
    25fa:	8b 42 20             	mov    0x20(%edx),%eax
    25fd:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
	int ucont_position;
	int ucontNum = 0;
    2601:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)

	/* 
	 * 
	 * 
	 * UC-level updates 
	 *
	 *
	 */

	// Examine user continuation
	// 0505 - allow multiple continuations per packet
	for(ucont_position = 0; 
    2608:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
    260f:	24 12                	and    $0x12,%al
    2611:	3c 12                	cmp    $0x12,%al
    2613:	0f 94 c0             	sete   %al
    2616:	0f b6 c0             	movzbl %al,%eax
    2619:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    261c:	31 c0                	xor    %eax,%eax
    261e:	3b 41 7c             	cmp    0x7c(%ecx),%eax
    2621:	0f 8d d9 00 00 00    	jge    2700 <UpdateClientUCState+0x130>
    2627:	89 f6                	mov    %esi,%esi
    2629:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
	    ucont_position < cont->ucont_len; 
	    ucont_position += ntohs(hdr->len)) {
		void *ucont_start = cont->ucont_data + ucont_position;
    2630:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    2633:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
    2636:	8b 82 80 00 00 00    	mov    0x80(%edx),%eax
    263c:	01 c1                	add    %eax,%ecx
    263e:	89 4d d0             	mov    %ecx,0xffffffd0(%ebp)
		hdr = (struct WireUC_RespHeader *)ucont_start;
		int ucont_len = ntohs(hdr->len);
    2641:	0f b7 41 02          	movzwl 0x2(%ecx),%eax
/* gcc should generate this for open coded C now too. May be worth switching to 
   it because inline assembly cannot be scheduled. -AK */
static __inline__ __const__ __u16 ___arch__swab16(__u16 x)
{
	__asm__("xchgb %b0,%h0"		/* swap bytes		*/
    2645:	86 c4                	xchg   %al,%ah
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
    2647:	0f b7 c0             	movzwl %ax,%eax

		if(ucont_len < sizeof(struct WireUC_RespHeader)) {
    264a:	83 f8 03             	cmp    $0x3,%eax
    264d:	0f 86 59 05 00 00    	jbe    2bac <UpdateClientUCState+0x5dc>
			printk("User continuation %d @ %d too short\n", ucontNum, ucont_position);
			return;
		}
		ucontNum++;
    2653:	ff 45 d4             	incl   0xffffffd4(%ebp)

		switch((enum UC_Type)hdr->type) {
    2656:	8b 4d d0             	mov    0xffffffd0(%ebp),%ecx
    2659:	0f b6 11             	movzbl (%ecx),%edx
    265c:	83 fa 01             	cmp    $0x1,%edx
    265f:	0f 84 6b 02 00 00    	je     28d0 <UpdateClientUCState+0x300>
    2665:	83 fa 01             	cmp    $0x1,%edx
    2668:	0f 82 d2 01 00 00    	jb     2840 <UpdateClientUCState+0x270>
    266e:	83 fa 02             	cmp    $0x2,%edx
    2671:	0f 84 71 01 00 00    	je     27e8 <UpdateClientUCState+0x218>
    2677:	83 fa 04             	cmp    $0x4,%edx
    267a:	0f 85 5f 01 00 00    	jne    27df <UpdateClientUCState+0x20f>
		case UC_INCOMPLETE: {
			struct WireUC_CVT_IncompleteResponse *incompleteResp = 
				(struct WireUC_CVT_IncompleteResponse *) hdr;
			int res;
			if(ucont_len < sizeof(*incompleteResp)) {
				printk("User continuation too short for incomplete response\n");
				return;
			}
			switch(tp->t.conversionState) {
			case CONVERSION_WAITFORSERVER:
				res = processIncompleteResponse(sk,incompleteResp,ucont_len);
				if(res) {
					printk("Error while processing incompleteResponse\n");
					return;
				}
				break;
			case CONVERSION_IDLE:
			case CONVERSION_WAITFORUSER:
				printk("Invalid conversion state (supposed to be WAITFORSERVER) hwhile processing incompleteResponse\n");
				return;
			default:
				printk("Invalid state!\n");
				BUG();
				return;
			}
			break;
		}
		case UC_COMPLETE: {
			struct WireUC_CVT_CompleteResponse *completeResp = 
				(struct WireUC_CVT_CompleteResponse *) hdr;
			struct UC_Continuation *ucont;
			if(ucont_len < sizeof(*completeResp)) {
				printk("User continuation too short for complete response\n");
				return;
			}
			switch(tp->t.conversionState) {
				struct UC_Continuation *newConvCont;
				unsigned ackSeq;
			case CONVERSION_WAITFORSERVER:
				ucont = unmarshallUC_Continuation(&completeResp->newCont, 
								  ucont_len - ((char*)&completeResp->newCont - (char*)ucont_start));
				if(ucont == NULL) {
					printk("Error while unmarshalling UC Continuation for UC_Complete packet\n");
					return;
				}
				/* Save continuation for use in subsequent conversion request */
				newConvCont = copyUC_Continuation(ucont);
				atomic_set(&newConvCont->refcnt, 1);
				if(newConvCont == NULL) {
					printk("Error while saving convCont in prevConvCont\n");
					kfree(ucont);
					return;
				}
				if(tp->t.prevConvCont) {
					// XXX Leave these FINDING_LEAK defines in here to find the lurking memory leak
#ifdef FINDING_LEAK
					printk("prevConvCont: \n");
					UC_Continuation_dump(tp->t.prevConvCont);
#endif
					UC_CONTINUATION_TRYFREE(tp->t.prevConvCont);
#ifdef FINDING_LEAK
					printk("newConvCont0: \n");
					UC_Continuation_dump(ucont);
					printk("newConvCont1: \n");
					UC_Continuation_dump(newConvCont);
#endif
				}
				tp->t.prevConvCont = newConvCont;

				ackSeq = ntohl(completeResp->ack_seq);
				if(ackSeq > tp->t.snd_una) {
					tp->t.snd_una = ackSeq;
					if(tp->t.snd_una > tp->t.write_seq) {
						printk("Error! snd_una %d > tp->t.write_seq %d while processing CompleteConversion\n", tp->t.snd_una, tp->t.write_seq);
						tp->t.snd_una = tp->t.write_seq;
					}
				}
#if FINDING_LEAK
				printk("ackseq = %d snd_una = %d\n", ackSeq, tp->t.snd_una);
#endif
				if(addNewUC_Continuation(sk, ucont)) {
					printk("UC_COMPLETE: error while adding new continuation\n");
					kfree(ucont);
					// xxx don't need to check refcnt on prevConvCont, since we 
					// know that there's only  one reference
					kfree(tp->t.prevConvCont);
					tp->t.prevConvCont = NULL;
					return;
				}
				requestReleasedData(sk);
				if(tp->t.write_seq - tp->t.snd_una > 0) {
					queueConversionRequests(sk);
					tp->t.conversionState = CONVERSION_WAITFORSERVER;
#if 0 // 0426 - do not push out requests in interrupt context, since the requests will be sent automatically
					pushRequests(sk);
#endif
					//printk("update client state set conversion state to waitforserver\n");
				} else {
					cleanTxQueue(sk);
					tp->t.conversionState = CONVERSION_IDLE;
					//printk("update client state set conversion state to IDLE: %d\n", tp->t.conversionState);
				}
				break;
			case CONVERSION_IDLE:
				printk("Invalid state: CONVERSION_IDLE while processing completeResponse\n");
				return;
			case CONVERSION_WAITFORUSER:
				printk("Invalid state: CONVERSION_WAITFORUSER while processing completeResponse\n");
				return;
			default:
				printk("Invalid state!\n");
				BUG();
				return;
			}
			break;
		}
		case UC_UPDATE: {
			/* This code was written 3/25, but never
			   used. See UC_NCONT code path below for New
			   CONTinuation Update technique */
			struct WireUC_MGMT_UpdateResponse *updateResp = 
				(struct WireUC_MGMT_UpdateResponse *) hdr;
			struct UC_Continuation *ucont;
			if(ucont_len < sizeof(*updateResp)) {
				printk("User continuation too short for update response\n");
				return;
			}
			ucont =	unmarshallUC_Continuation(&updateResp->newCont, 
							  ucont_len - ((char*)&updateResp->newCont - (char*)ucont_start));
			if(ucont == NULL) {
				printk("UC_Update: out of memory while unmarshalling new continuation\n");
				return;
			}
			addedUCont = ucont;
			if(addNewUC_Continuation(sk, addedUCont)) {
				printk("UC_Update: error while adding new continuation\n");
				return;
			}
			requestReleasedData(sk);
			break;
		}
		case UC_NEWCONT: {
			struct WireUC_NewContinuationResponse *newContResp = 
				(struct WireUC_NewContinuationResponse *) hdr;
			struct UC_Continuation *ucont;
			if(ucont_len < sizeof(*newContResp)) {
    2680:	83 f8 11             	cmp    $0x11,%eax
    2683:	0f 86 43 01 00 00    	jbe    27cc <UpdateClientUCState+0x1fc>
				printk("User continuation too short for UC_NEWCONT\n");
				return;
			}
			ucont = unmarshallUC_Continuation(&newContResp->newCont, 
    2689:	83 e8 04             	sub    $0x4,%eax
    268c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    2690:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    2693:	83 c0 04             	add    $0x4,%eax
    2696:	89 04 24             	mov    %eax,(%esp,1)
    2699:	e8 82 5e 00 00       	call   8520 <unmarshallUC_Continuation>
							  ucont_len - ((char*)&newContResp->newCont - (char*)ucont_start));
			if(ucont == NULL) {
    269e:	85 c0                	test   %eax,%eax
    26a0:	89 c3                	mov    %eax,%ebx
    26a2:	0f 84 13 01 00 00    	je     27bb <UpdateClientUCState+0x1eb>
				printk("Error while unmarshalling UC Continuation for UC_NEWCONT packet\n");
			}
			addedUCont = ucont;
    26a8:	89 5d e0             	mov    %ebx,0xffffffe0(%ebp)
			if(addNewUC_Continuation(sk, ucont)) {
    26ab:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    26af:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    26b2:	89 0c 24             	mov    %ecx,(%esp,1)
    26b5:	e8 e6 63 00 00       	call   8aa0 <addNewUC_Continuation>
    26ba:	85 c0                	test   %eax,%eax
    26bc:	0f 85 db 00 00 00    	jne    279d <UpdateClientUCState+0x1cd>
				printk("UC_NEWCONT: error while adding new continuation\n");
				kfree(ucont);
				return;
			}
			requestReleasedData(sk);
			break;
		}
		default:
			printk("Invalid UC response \n");
			return;
		}
		/* 
		 * Update parent, removing from reliable queues if necessary
		 */
		if(isSynack) {
    26c2:	8b 5d dc             	mov    0xffffffdc(%ebp),%ebx
    26c5:	85 db                	test   %ebx,%ebx
    26c7:	74 3f                	je     2708 <UpdateClientUCState+0x138>
			// synack does not have a parent
			tp->t.request_rcv_nxt = 1;
    26c9:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    26cc:	b9 01 00 00 00       	mov    $0x1,%ecx
			tp->t.request_snd_nxt = 1;
    26d1:	b8 01 00 00 00       	mov    $0x1,%eax
    26d6:	89 8a 48 0a 00 00    	mov    %ecx,0xa48(%edx)
    26dc:	89 82 4c 0a 00 00    	mov    %eax,0xa4c(%edx)
    26e2:	8b 55 d0             	mov    0xffffffd0(%ebp),%edx
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
    26e5:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
    26e8:	0f b7 42 02          	movzwl 0x2(%edx),%eax
/* gcc should generate this for open coded C now too. May be worth switching to 
   it because inline assembly cannot be scheduled. -AK */
static __inline__ __const__ __u16 ___arch__swab16(__u16 x)
{
	__asm__("xchgb %b0,%h0"		/* swap bytes		*/
    26ec:	86 c4                	xchg   %al,%ah
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
    26ee:	0f b7 c0             	movzwl %ax,%eax
    26f1:	01 45 d8             	add    %eax,0xffffffd8(%ebp)
    26f4:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    26f7:	3b 41 7c             	cmp    0x7c(%ecx),%eax
    26fa:	0f 8c 30 ff ff ff    	jl     2630 <UpdateClientUCState+0x60>
		} else {
			enum UserRequestType type;
			unsigned start, end;
			switch(hdr->type) {
			case UC_INCOMPLETE:
			case UC_COMPLETE:
				type = MREQ_CONVERSION;
				start = -1;
				end = -1;
				goto update_parent;
			case UC_UPDATE:
				BUG_TRAP(addedUCont);
				type = MREQ_CONTINUATION;
				start = addedUCont->validStart;
				end = addedUCont->validEnd;
			update_parent:
				updateParent(sk, type, TCP_SKB_CB(skb)->parent, 
					     TCP_SKB_CB(skb)->numSiblings, TCP_SKB_CB(skb)->position,
					     start, end);
				break;
			case UC_NEWCONT:
				/// do nothing
				break;
			default:
				printk("Invalid Uc response \n");
			}
		}
	}
}
    2700:	83 c4 44             	add    $0x44,%esp
    2703:	5b                   	pop    %ebx
    2704:	5e                   	pop    %esi
    2705:	5f                   	pop    %edi
    2706:	5d                   	pop    %ebp
    2707:	c3                   	ret    
    2708:	8b 4d d0             	mov    0xffffffd0(%ebp),%ecx
    270b:	0f b6 01             	movzbl (%ecx),%eax
    270e:	83 f8 02             	cmp    $0x2,%eax
    2711:	74 5d                	je     2770 <UpdateClientUCState+0x1a0>
    2713:	31 db                	xor    %ebx,%ebx
    2715:	83 f8 02             	cmp    $0x2,%eax
    2718:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
    271d:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    2722:	7e 13                	jle    2737 <UpdateClientUCState+0x167>
    2724:	83 f8 04             	cmp    $0x4,%eax
    2727:	74 b9                	je     26e2 <UpdateClientUCState+0x112>
    2729:	c7 04 24 b6 01 00 00 	movl   $0x1b6,(%esp,1)
    2730:	e8 fc ff ff ff       	call   2731 <UpdateClientUCState+0x161>
    2735:	eb ab                	jmp    26e2 <UpdateClientUCState+0x112>
    2737:	89 54 24 18          	mov    %edx,0x18(%esp,1)
    273b:	89 4c 24 14          	mov    %ecx,0x14(%esp,1)
    273f:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    2742:	0f b6 42 69          	movzbl 0x69(%edx),%eax
    2746:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    274a:	0f b6 42 68          	movzbl 0x68(%edx),%eax
    274e:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    2752:	8b 42 64             	mov    0x64(%edx),%eax
    2755:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    2759:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    275d:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    2760:	89 0c 24             	mov    %ecx,(%esp,1)
    2763:	e8 fc ff ff ff       	call   2764 <UpdateClientUCState+0x194>
    2768:	e9 75 ff ff ff       	jmp    26e2 <UpdateClientUCState+0x112>
    276d:	8d 76 00             	lea    0x0(%esi),%esi
    2770:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    2773:	85 c0                	test   %eax,%eax
    2775:	74 10                	je     2787 <UpdateClientUCState+0x1b7>
    2777:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    277a:	bb 01 00 00 00       	mov    $0x1,%ebx
    277f:	8b 48 10             	mov    0x10(%eax),%ecx
    2782:	8b 50 14             	mov    0x14(%eax),%edx
    2785:	eb b0                	jmp    2737 <UpdateClientUCState+0x167>
    2787:	c7 44 24 04 bb 07 00 	movl   $0x7bb,0x4(%esp,1)
    278e:	00 
    278f:	c7 04 24 a0 0b 00 00 	movl   $0xba0,(%esp,1)
    2796:	e8 fc ff ff ff       	call   2797 <UpdateClientUCState+0x1c7>
    279b:	eb da                	jmp    2777 <UpdateClientUCState+0x1a7>
    279d:	c7 04 24 e0 0b 00 00 	movl   $0xbe0,(%esp,1)
    27a4:	e8 fc ff ff ff       	call   27a5 <UpdateClientUCState+0x1d5>
    27a9:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    27ac:	89 45 08             	mov    %eax,0x8(%ebp)
    27af:	83 c4 44             	add    $0x44,%esp
    27b2:	5b                   	pop    %ebx
    27b3:	5e                   	pop    %esi
    27b4:	5f                   	pop    %edi
    27b5:	5d                   	pop    %ebp
    27b6:	e9 fc ff ff ff       	jmp    27b7 <UpdateClientUCState+0x1e7>
    27bb:	c7 04 24 20 0c 00 00 	movl   $0xc20,(%esp,1)
    27c2:	e8 fc ff ff ff       	call   27c3 <UpdateClientUCState+0x1f3>
    27c7:	e9 dc fe ff ff       	jmp    26a8 <UpdateClientUCState+0xd8>
    27cc:	c7 45 08 80 0c 00 00 	movl   $0xc80,0x8(%ebp)
    27d3:	83 c4 44             	add    $0x44,%esp
    27d6:	5b                   	pop    %ebx
    27d7:	5e                   	pop    %esi
    27d8:	5f                   	pop    %edi
    27d9:	5d                   	pop    %ebp
    27da:	e9 fc ff ff ff       	jmp    27db <UpdateClientUCState+0x20b>
    27df:	c7 45 08 cc 01 00 00 	movl   $0x1cc,0x8(%ebp)
    27e6:	eb eb                	jmp    27d3 <UpdateClientUCState+0x203>
    27e8:	83 f8 10             	cmp    $0x10,%eax
    27eb:	76 45                	jbe    2832 <UpdateClientUCState+0x262>
    27ed:	83 e8 04             	sub    $0x4,%eax
    27f0:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    27f4:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    27f7:	83 c0 04             	add    $0x4,%eax
    27fa:	89 04 24             	mov    %eax,(%esp,1)
    27fd:	e8 1e 5d 00 00       	call   8520 <unmarshallUC_Continuation>
    2802:	85 c0                	test   %eax,%eax
    2804:	74 23                	je     2829 <UpdateClientUCState+0x259>
    2806:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    2809:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    280d:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    2810:	89 14 24             	mov    %edx,(%esp,1)
    2813:	e8 88 62 00 00       	call   8aa0 <addNewUC_Continuation>
    2818:	85 c0                	test   %eax,%eax
    281a:	0f 84 a2 fe ff ff    	je     26c2 <UpdateClientUCState+0xf2>
    2820:	c7 45 08 c0 0c 00 00 	movl   $0xcc0,0x8(%ebp)
    2827:	eb aa                	jmp    27d3 <UpdateClientUCState+0x203>
    2829:	c7 45 08 00 0d 00 00 	movl   $0xd00,0x8(%ebp)
    2830:	eb a1                	jmp    27d3 <UpdateClientUCState+0x203>
    2832:	c7 45 08 40 0d 00 00 	movl   $0xd40,0x8(%ebp)
    2839:	eb 98                	jmp    27d3 <UpdateClientUCState+0x203>
    283b:	90                   	nop    
    283c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    2840:	83 f8 0b             	cmp    $0xb,%eax
    2843:	76 7e                	jbe    28c3 <UpdateClientUCState+0x2f3>
    2845:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
    2848:	8b 91 c0 0a 00 00    	mov    0xac0(%ecx),%edx
    284e:	83 fa 01             	cmp    $0x1,%edx
    2851:	75 2a                	jne    287d <UpdateClientUCState+0x2ad>
    2853:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    2857:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    285a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    285e:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    2861:	89 14 24             	mov    %edx,(%esp,1)
    2864:	e8 77 5e 00 00       	call   86e0 <processIncompleteResponse>
    2869:	85 c0                	test   %eax,%eax
    286b:	0f 84 51 fe ff ff    	je     26c2 <UpdateClientUCState+0xf2>
    2871:	c7 45 08 80 0d 00 00 	movl   $0xd80,0x8(%ebp)
    2878:	e9 56 ff ff ff       	jmp    27d3 <UpdateClientUCState+0x203>
    287d:	83 fa 01             	cmp    $0x1,%edx
    2880:	7e 3d                	jle    28bf <UpdateClientUCState+0x2ef>
    2882:	83 fa 02             	cmp    $0x2,%edx
    2885:	74 2c                	je     28b3 <UpdateClientUCState+0x2e3>
    2887:	c7 04 24 e2 01 00 00 	movl   $0x1e2,(%esp,1)
    288e:	e8 fc ff ff ff       	call   288f <UpdateClientUCState+0x2bf>
    2893:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    289a:	00 
    289b:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    28a2:	e8 fc ff ff ff       	call   28a3 <UpdateClientUCState+0x2d3>
    28a7:	83 c4 44             	add    $0x44,%esp
    28aa:	5b                   	pop    %ebx
    28ab:	5e                   	pop    %esi
    28ac:	5f                   	pop    %edi
    28ad:	5d                   	pop    %ebp
    28ae:	e9 fc ff ff ff       	jmp    28af <UpdateClientUCState+0x2df>
    28b3:	c7 45 08 c0 0d 00 00 	movl   $0xdc0,0x8(%ebp)
    28ba:	e9 14 ff ff ff       	jmp    27d3 <UpdateClientUCState+0x203>
    28bf:	85 d2                	test   %edx,%edx
    28c1:	eb c2                	jmp    2885 <UpdateClientUCState+0x2b5>
    28c3:	c7 45 08 20 0e 00 00 	movl   $0xe20,0x8(%ebp)
    28ca:	e9 04 ff ff ff       	jmp    27d3 <UpdateClientUCState+0x203>
    28cf:	90                   	nop    
    28d0:	83 f8 14             	cmp    $0x14,%eax
    28d3:	0f 86 c7 02 00 00    	jbe    2ba0 <UpdateClientUCState+0x5d0>
    28d9:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
    28dc:	8b 91 c0 0a 00 00    	mov    0xac0(%ecx),%edx
    28e2:	83 fa 01             	cmp    $0x1,%edx
    28e5:	0f 85 84 02 00 00    	jne    2b6f <UpdateClientUCState+0x59f>
    28eb:	83 e8 08             	sub    $0x8,%eax
    28ee:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    28f2:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    28f5:	83 c0 08             	add    $0x8,%eax
    28f8:	89 04 24             	mov    %eax,(%esp,1)
    28fb:	e8 20 5c 00 00       	call   8520 <unmarshallUC_Continuation>
    2900:	85 c0                	test   %eax,%eax
    2902:	89 c3                	mov    %eax,%ebx
    2904:	0f 84 59 02 00 00    	je     2b63 <UpdateClientUCState+0x593>
}

static inline struct UC_Continuation *copyUC_Continuation(struct UC_Continuation *scont) {
  /* create a separate copy */
  int dataLen = scont->dataLen;
    290a:	8b 40 28             	mov    0x28(%eax),%eax
    290d:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
  struct UC_Continuation *rval = kmalloc(sizeof(*rval) + dataLen, GFP_ATOMIC);
    2910:	83 c0 30             	add    $0x30,%eax
    2913:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    291a:	00 
    291b:	89 04 24             	mov    %eax,(%esp,1)
    291e:	e8 fc ff ff ff       	call   291f <UpdateClientUCState+0x34f>
  if(rval == NULL) {
    2923:	85 c0                	test   %eax,%eax
    2925:	89 c2                	mov    %eax,%edx
    2927:	0f 84 23 02 00 00    	je     2b50 <UpdateClientUCState+0x580>
    printk("Out of memory while copying UC_Continuation\n");
    return NULL;
  }
  *rval = *scont;
    292d:	8b 03                	mov    (%ebx),%eax
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
    292f:	8d 7a 30             	lea    0x30(%edx),%edi
    2932:	8d 73 30             	lea    0x30(%ebx),%esi
  if(rval == NULL) {
    printk("Out of memory while copying UC_Continuation\n");
    return NULL;
  }
  *rval = *scont;
    2935:	89 02                	mov    %eax,(%edx)
    2937:	8b 43 04             	mov    0x4(%ebx),%eax
    293a:	89 42 04             	mov    %eax,0x4(%edx)
    293d:	8b 43 08             	mov    0x8(%ebx),%eax
    2940:	89 42 08             	mov    %eax,0x8(%edx)
    2943:	8b 43 0c             	mov    0xc(%ebx),%eax
    2946:	89 42 0c             	mov    %eax,0xc(%edx)
    2949:	8b 43 10             	mov    0x10(%ebx),%eax
    294c:	89 42 10             	mov    %eax,0x10(%edx)
    294f:	8b 43 14             	mov    0x14(%ebx),%eax
    2952:	89 42 14             	mov    %eax,0x14(%edx)
    2955:	8b 43 18             	mov    0x18(%ebx),%eax
    2958:	89 42 18             	mov    %eax,0x18(%edx)
    295b:	8b 43 1c             	mov    0x1c(%ebx),%eax
    295e:	89 42 1c             	mov    %eax,0x1c(%edx)
    2961:	8b 43 20             	mov    0x20(%ebx),%eax
    2964:	89 42 20             	mov    %eax,0x20(%edx)
    2967:	8b 43 24             	mov    0x24(%ebx),%eax
    296a:	89 42 24             	mov    %eax,0x24(%edx)
    296d:	8b 43 28             	mov    0x28(%ebx),%eax
    2970:	89 42 28             	mov    %eax,0x28(%edx)
    2973:	8b 43 2c             	mov    0x2c(%ebx),%eax
  rval->prev = rval->next = NULL;
    2976:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
    297d:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  rval->list = NULL;
    2983:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
    298a:	89 42 2c             	mov    %eax,0x2c(%edx)

static inline void * __memcpy(void * to, const void * from, size_t n)
{
int d0, d1, d2;
__asm__ __volatile__(
    298d:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
    2990:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    2993:	c1 e9 02             	shr    $0x2,%ecx
    2996:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    2998:	a8 02                	test   $0x2,%al
    299a:	74 02                	je     299e <UpdateClientUCState+0x3ce>
    299c:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    299e:	a8 01                	test   $0x1,%al
    29a0:	74 01                	je     29a3 <UpdateClientUCState+0x3d3>
    29a2:	a4                   	movsb  %ds:(%esi),%es:(%edi)
  *rval = *scont;
  rval->prev = rval->next = NULL;
  rval->list = NULL;

  memcpy(rval->kernel.data, scont->kernel.data, dataLen);
    29a3:	89 d6                	mov    %edx,%esi
    29a5:	c7 46 24 01 00 00 00 	movl   $0x1,0x24(%esi)
    29ac:	85 f6                	test   %esi,%esi
    29ae:	0f 84 87 01 00 00    	je     2b3b <UpdateClientUCState+0x56b>
    29b4:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
    29b7:	8b 91 e0 0a 00 00    	mov    0xae0(%ecx),%edx
    29bd:	85 d2                	test   %edx,%edx
    29bf:	74 0e                	je     29cf <UpdateClientUCState+0x3ff>
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
	unsigned char c;

	__asm__ __volatile__(
    29c1:	ff 4a 24             	decl   0x24(%edx)
    29c4:	0f 94 c0             	sete   %al
    29c7:	84 c0                	test   %al,%al
    29c9:	0f 85 59 01 00 00    	jne    2b28 <UpdateClientUCState+0x558>
    29cf:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    29d2:	89 b0 e0 0a 00 00    	mov    %esi,0xae0(%eax)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    29d8:	8b 55 d0             	mov    0xffffffd0(%ebp),%edx
    29db:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    29de:	8b 42 04             	mov    0x4(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    29e1:	0f c8                	bswap  %eax
    29e3:	3b 81 c4 0a 00 00    	cmp    0xac4(%ecx),%eax
    29e9:	76 14                	jbe    29ff <UpdateClientUCState+0x42f>
    29eb:	89 81 c4 0a 00 00    	mov    %eax,0xac4(%ecx)
    29f1:	8b 91 cc 0a 00 00    	mov    0xacc(%ecx),%edx
    29f7:	39 d0                	cmp    %edx,%eax
    29f9:	0f 87 01 01 00 00    	ja     2b00 <UpdateClientUCState+0x530>
    29ff:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    2a03:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    2a06:	89 0c 24             	mov    %ecx,(%esp,1)
    2a09:	e8 92 60 00 00       	call   8aa0 <addNewUC_Continuation>
    2a0e:	85 c0                	test   %eax,%eax
    2a10:	0f 85 b2 00 00 00    	jne    2ac8 <UpdateClientUCState+0x4f8>
    2a16:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    2a19:	8b 82 c4 0a 00 00    	mov    0xac4(%edx),%eax
    2a1f:	39 82 cc 0a 00 00    	cmp    %eax,0xacc(%edx)
    2a25:	74 1e                	je     2a45 <UpdateClientUCState+0x475>
    2a27:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    2a2a:	bf 01 00 00 00       	mov    $0x1,%edi
    2a2f:	89 0c 24             	mov    %ecx,(%esp,1)
    2a32:	e8 fc ff ff ff       	call   2a33 <UpdateClientUCState+0x463>
    2a37:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    2a3a:	89 b8 c0 0a 00 00    	mov    %edi,0xac0(%eax)
    2a40:	e9 7d fc ff ff       	jmp    26c2 <UpdateClientUCState+0xf2>
    2a45:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    2a48:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    2a4b:	8b b2 d0 0a 00 00    	mov    0xad0(%edx),%esi
    2a51:	05 8c 0b 00 00       	add    $0xb8c,%eax
    2a56:	39 c6                	cmp    %eax,%esi
    2a58:	74 5e                	je     2ab8 <UpdateClientUCState+0x4e8>
    2a5a:	8d 9a d0 0a 00 00    	lea    0xad0(%edx),%ebx
    2a60:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
    2a63:	8b 81 c4 0a 00 00    	mov    0xac4(%ecx),%eax
    2a69:	39 46 44             	cmp    %eax,0x44(%esi)
    2a6c:	77 44                	ja     2ab2 <UpdateClientUCState+0x4e2>
    2a6e:	89 f1                	mov    %esi,%ecx
    2a70:	8b 76 04             	mov    0x4(%esi),%esi
static inline void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
{
	struct sk_buff * next, * prev;

	list->qlen--;
    2a73:	ff 4b 08             	decl   0x8(%ebx)
	next = skb->next;
	prev = skb->prev;
	skb->next = NULL;
	skb->prev = NULL;
	skb->list = NULL;
    2a76:	c7 41 08 00 00 00 00 	movl   $0x0,0x8(%ecx)
    2a7d:	8b 41 04             	mov    0x4(%ecx),%eax
    2a80:	8b 11                	mov    (%ecx),%edx
    2a82:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
    2a89:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	next->prev = prev;
    2a8f:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    2a92:	89 10                	mov    %edx,(%eax)
    2a94:	8b 81 84 00 00 00    	mov    0x84(%ecx),%eax
    2a9a:	48                   	dec    %eax
    2a9b:	74 0d                	je     2aaa <UpdateClientUCState+0x4da>
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
	unsigned char c;

	__asm__ __volatile__(
    2a9d:	ff 89 84 00 00 00    	decl   0x84(%ecx)
    2aa3:	0f 94 c0             	sete   %al
    2aa6:	84 c0                	test   %al,%al
    2aa8:	74 08                	je     2ab2 <UpdateClientUCState+0x4e2>
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
		__kfree_skb(skb);
    2aaa:	89 0c 24             	mov    %ecx,(%esp,1)
    2aad:	e8 fc ff ff ff       	call   2aae <UpdateClientUCState+0x4de>
    2ab2:	8b 36                	mov    (%esi),%esi
    2ab4:	39 de                	cmp    %ebx,%esi
    2ab6:	75 a8                	jne    2a60 <UpdateClientUCState+0x490>
    2ab8:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    2abb:	31 f6                	xor    %esi,%esi
    2abd:	89 b0 c0 0a 00 00    	mov    %esi,0xac0(%eax)
    2ac3:	e9 fa fb ff ff       	jmp    26c2 <UpdateClientUCState+0xf2>
    2ac8:	c7 04 24 60 0e 00 00 	movl   $0xe60,(%esp,1)
    2acf:	e8 fc ff ff ff       	call   2ad0 <UpdateClientUCState+0x500>
    2ad4:	89 1c 24             	mov    %ebx,(%esp,1)
    2ad7:	e8 fc ff ff ff       	call   2ad8 <UpdateClientUCState+0x508>
    2adc:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    2adf:	8b 82 e0 0a 00 00    	mov    0xae0(%edx),%eax
    2ae5:	89 04 24             	mov    %eax,(%esp,1)
    2ae8:	e8 fc ff ff ff       	call   2ae9 <UpdateClientUCState+0x519>
    2aed:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
    2af0:	31 c0                	xor    %eax,%eax
    2af2:	89 81 e0 0a 00 00    	mov    %eax,0xae0(%ecx)
    2af8:	e9 03 fc ff ff       	jmp    2700 <UpdateClientUCState+0x130>
    2afd:	8d 76 00             	lea    0x0(%esi),%esi
    2b00:	89 54 24 08          	mov    %edx,0x8(%esp,1)
    2b04:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    2b08:	c7 04 24 a0 0e 00 00 	movl   $0xea0,(%esp,1)
    2b0f:	e8 fc ff ff ff       	call   2b10 <UpdateClientUCState+0x540>
    2b14:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    2b17:	8b 82 cc 0a 00 00    	mov    0xacc(%edx),%eax
    2b1d:	89 82 c4 0a 00 00    	mov    %eax,0xac4(%edx)
    2b23:	e9 d7 fe ff ff       	jmp    29ff <UpdateClientUCState+0x42f>
    2b28:	8b 81 e0 0a 00 00    	mov    0xae0(%ecx),%eax
    2b2e:	89 04 24             	mov    %eax,(%esp,1)
    2b31:	e8 fc ff ff ff       	call   2b32 <UpdateClientUCState+0x562>
    2b36:	e9 94 fe ff ff       	jmp    29cf <UpdateClientUCState+0x3ff>
    2b3b:	c7 04 24 00 0f 00 00 	movl   $0xf00,(%esp,1)
    2b42:	e8 fc ff ff ff       	call   2b43 <UpdateClientUCState+0x573>
    2b47:	89 5d 08             	mov    %ebx,0x8(%ebp)
    2b4a:	e9 60 fc ff ff       	jmp    27af <UpdateClientUCState+0x1df>
    2b4f:	90                   	nop    
  /* create a separate copy */
  int dataLen = scont->dataLen;
  struct UC_Continuation *rval = kmalloc(sizeof(*rval) + dataLen, GFP_ATOMIC);
  if(rval == NULL) {
    printk("Out of memory while copying UC_Continuation\n");
    2b50:	c7 04 24 40 0f 00 00 	movl   $0xf40,(%esp,1)
    2b57:	31 f6                	xor    %esi,%esi
    2b59:	e8 fc ff ff ff       	call   2b5a <UpdateClientUCState+0x58a>
    2b5e:	e9 42 fe ff ff       	jmp    29a5 <UpdateClientUCState+0x3d5>
    2b63:	c7 45 08 80 0f 00 00 	movl   $0xf80,0x8(%ebp)
    2b6a:	e9 64 fc ff ff       	jmp    27d3 <UpdateClientUCState+0x203>
    2b6f:	83 fa 01             	cmp    $0x1,%edx
    2b72:	7e 15                	jle    2b89 <UpdateClientUCState+0x5b9>
    2b74:	83 fa 02             	cmp    $0x2,%edx
    2b77:	0f 85 0a fd ff ff    	jne    2887 <UpdateClientUCState+0x2b7>
    2b7d:	c7 45 08 e0 0f 00 00 	movl   $0xfe0,0x8(%ebp)
    2b84:	e9 4a fc ff ff       	jmp    27d3 <UpdateClientUCState+0x203>
    2b89:	85 d2                	test   %edx,%edx
    2b8b:	0f 85 f6 fc ff ff    	jne    2887 <UpdateClientUCState+0x2b7>
    2b91:	c7 45 08 40 10 00 00 	movl   $0x1040,0x8(%ebp)
    2b98:	e9 36 fc ff ff       	jmp    27d3 <UpdateClientUCState+0x203>
    2b9d:	8d 76 00             	lea    0x0(%esi),%esi
    2ba0:	c7 45 08 a0 10 00 00 	movl   $0x10a0,0x8(%ebp)
    2ba7:	e9 27 fc ff ff       	jmp    27d3 <UpdateClientUCState+0x203>
    2bac:	c7 45 08 e0 10 00 00 	movl   $0x10e0,0x8(%ebp)
    2bb3:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    2bb6:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
    2bb9:	89 45 10             	mov    %eax,0x10(%ebp)
    2bbc:	89 55 0c             	mov    %edx,0xc(%ebp)
    2bbf:	83 c4 44             	add    $0x44,%esp
    2bc2:	5b                   	pop    %ebx
    2bc3:	5e                   	pop    %esi
    2bc4:	5f                   	pop    %edi
    2bc5:	5d                   	pop    %ebp
    2bc6:	e9 fc ff ff ff       	jmp    2bc7 <UpdateClientUCState+0x5f7>
    2bcb:	90                   	nop    
    2bcc:	8d 74 26 00          	lea    0x0(%esi,1),%esi

00002bd0 <client_rcv_impl>:


#define SYNACK_TIMEOUT (HZ)

int client_rcv_impl(struct sock *sk, struct sk_buff *in_skb) {
    2bd0:	55                   	push   %ebp
    2bd1:	89 e5                	mov    %esp,%ebp
    2bd3:	57                   	push   %edi
    2bd4:	56                   	push   %esi
    2bd5:	53                   	push   %ebx
    2bd6:	83 ec 50             	sub    $0x50,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    2bd9:	8b 45 08             	mov    0x8(%ebp),%eax

#ifndef USESLAB
  CONTINUATION_TYPE *rval = kmalloc(2 * sizeof(CONTINUATION_TYPE), flags); // 0502 maybe slab cache usage is buggy
#else
  CONTINUATION_TYPE *rval = kmem_cache_alloc(clientSideContinuation_cache, GFP_ATOMIC);
    2bdc:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    2be3:	00 
    2be4:	05 bc 00 00 00       	add    $0xbc,%eax
    2be9:	89 45 ec             	mov    %eax,0xffffffec(%ebp)

#ifndef USESLAB
  CONTINUATION_TYPE *rval = kmalloc(2 * sizeof(CONTINUATION_TYPE), flags); // 0502 maybe slab cache usage is buggy
#else
  CONTINUATION_TYPE *rval = kmem_cache_alloc(clientSideContinuation_cache, GFP_ATOMIC);
    2bec:	a1 00 00 00 00       	mov    0x0,%eax
    2bf1:	89 04 24             	mov    %eax,(%esp,1)
    2bf4:	e8 fc ff ff ff       	call   2bf5 <client_rcv_impl+0x25>
#endif
#endif

#ifdef DEBUG_TRICKLES_ALLOCATION // 0418
  numContinuations++;
#endif

  if(rval == NULL) {
    2bf9:	85 c0                	test   %eax,%eax
    2bfb:	0f 84 e0 13 00 00    	je     3fe1 <client_rcv_impl+0x1411>
    printk("out of memory while allocating continuation\n");
    return NULL;
  }

  rval->prev = rval->next = NULL;
    2c01:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  rval->list = NULL;
#ifdef INIT2 // 0502 - initialize only the first one (simulation is off)
  for(i=0; i < 2; i++) {
    2c08:	b9 01 00 00 00       	mov    $0x1,%ecx
    2c0d:	8d 90 cc 00 00 00    	lea    0xcc(%eax),%edx
    2c13:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    2c19:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
#else
  for(i=0; i < 1; i++) {
#endif
	  (rval+i)->ucont_len = 0;
    2c20:	c7 42 b0 00 00 00 00 	movl   $0x0,0xffffffb0(%edx)
	  (rval+i)->ucont_data = NULL;
    2c27:	c7 42 b4 00 00 00 00 	movl   $0x0,0xffffffb4(%edx)
	  (rval+i)->input_len = 0;
    2c2e:	c7 42 b8 00 00 00 00 	movl   $0x0,0xffffffb8(%edx)
	  (rval+i)->input = NULL;
    2c35:	c7 42 bc 00 00 00 00 	movl   $0x0,0xffffffbc(%edx)
	  // 0429 null mark
	  (rval+i)->mark = 0;
    2c3c:	c7 42 0c 00 00 00 00 	movl   $0x0,0xc(%edx)
	  (rval+i)->simulated = 0;
    2c43:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
    2c49:	81 c2 e4 00 00 00    	add    $0xe4,%edx
    2c4f:	49                   	dec    %ecx
    2c50:	79 ce                	jns    2c20 <client_rcv_impl+0x50>
  }
    2c52:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
	WireTrickleResponse *tresp_hdr;
	CONTINUATION_TYPE *cont = newClientSide_Continuation(GFP_ATOMIC);
	short ucont_len;
	char *ucont_in;
	int progress;
	unsigned cur_seq;
	int noCont = 0;
    2c55:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
	int synack = 0;

	TIMING_CTX_DEF0("client_rcv_impl", "top", "int0", "int1");
	TIMING_CTX_DEF1(8,7,4);
	reinitTimingCtx(&ctx);
	recordSample(&ctx,0);

#ifdef JAM_SLOWSTART
	if(tp->t.state == TRICKLES_CLIENT_SLOWSTART) {
		if(trickles_ratelimit()) printk("Rcv: Jammed on slow start\n");
		goto drop;
	}
#endif
	//0502 search start
#ifdef JAM_NORMAL
	if(tp->t.state == TRICKLES_CLIENT_NORMAL) {
		GEN_JAM("normal");
		goto drop;
	}
#endif // JAM_NORMAL

	if(cont == NULL) {
    2c5c:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    2c5f:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
    2c66:	85 c0                	test   %eax,%eax
    2c68:	0f 84 67 13 00 00    	je     3fd5 <client_rcv_impl+0x1405>
		printk("client_rcv: Could not allocate continuation\n");
		goto drop;
	}
	cont->mark |= 0x1;
    2c6e:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    2c71:	83 8a d8 00 00 00 01 	orl    $0x1,0xd8(%edx)

#ifdef RCV_COPY_TO_SMALLER_SKB
	// in_skb is too big (in 4K slab for device). So copy it into a smaller skb (order 2048
	// disable for performance, enable for scalability
	{
		struct sk_buff *copy;
		int copyLen = in_skb->tail - in_skb->head;
    2c78:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    2c7b:	8b 99 98 00 00 00    	mov    0x98(%ecx),%ebx
    2c81:	8b b9 90 00 00 00    	mov    0x90(%ecx),%edi
		copy = alloc_skb(copyLen, GFP_ATOMIC);
    2c87:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    2c8e:	00 
    2c8f:	29 fb                	sub    %edi,%ebx
    2c91:	89 1c 24             	mov    %ebx,(%esp,1)
    2c94:	e8 fc ff ff ff       	call   2c95 <client_rcv_impl+0xc5>
    2c99:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
		if(copy == NULL) {
    2c9c:	85 c0                	test   %eax,%eax
    2c9e:	0f 84 5a 01 00 00    	je     2dfe <client_rcv_impl+0x22e>
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
    2ca4:	8b b8 90 00 00 00    	mov    0x90(%eax),%edi
    2caa:	8b 45 0c             	mov    0xc(%ebp),%eax
int d0, d1, d2;
__asm__ __volatile__(
    2cad:	89 d9                	mov    %ebx,%ecx
    2caf:	c1 e9 02             	shr    $0x2,%ecx
    2cb2:	8b b0 90 00 00 00    	mov    0x90(%eax),%esi
    2cb8:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    2cba:	f6 c3 02             	test   $0x2,%bl
    2cbd:	74 02                	je     2cc1 <client_rcv_impl+0xf1>
    2cbf:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    2cc1:	f6 c3 01             	test   $0x1,%bl
    2cc4:	74 01                	je     2cc7 <client_rcv_impl+0xf7>
    2cc6:	a4                   	movsb  %ds:(%esi),%es:(%edi)
 *	room. This is only allowed for an empty buffer.
 */

static inline void skb_reserve(struct sk_buff *skb, unsigned int len)
{
    2cc7:	8b 55 0c             	mov    0xc(%ebp),%edx
	skb->data+=len;
    2cca:	8b 5d d4             	mov    0xffffffd4(%ebp),%ebx
    2ccd:	8b 8a 90 00 00 00    	mov    0x90(%edx),%ecx
    2cd3:	8b 82 94 00 00 00    	mov    0x94(%edx),%eax
    2cd9:	29 c8                	sub    %ecx,%eax
    2cdb:	01 83 94 00 00 00    	add    %eax,0x94(%ebx)
	skb->tail+=len;
    2ce1:	8b 75 d4             	mov    0xffffffd4(%ebp),%esi
    2ce4:	8b 9e 98 00 00 00    	mov    0x98(%esi),%ebx
    2cea:	01 c3                	add    %eax,%ebx
			goto drop;
		}
		memcpy(copy->head, in_skb->head, copyLen);
		skb_reserve(copy, in_skb->data - in_skb->head);
		copy->h.th = (struct tcphdr*)(copy->head + ((char*)in_skb->h.th - (char*)in_skb->head));
    2cec:	8b 42 20             	mov    0x20(%edx),%eax
    2cef:	8b 96 90 00 00 00    	mov    0x90(%esi),%edx

static inline void skb_reserve(struct sk_buff *skb, unsigned int len)
{
	skb->data+=len;
	skb->tail+=len;
    2cf5:	89 9e 98 00 00 00    	mov    %ebx,0x98(%esi)
    2cfb:	29 c8                	sub    %ecx,%eax
    2cfd:	8d 04 10             	lea    (%eax,%edx,1),%eax
    2d00:	89 46 20             	mov    %eax,0x20(%esi)
		copy->nh.iph = (struct iphdr*)(copy->head + ((char*)in_skb->nh.iph - (char*)in_skb->head));
    2d03:	8b 7d 0c             	mov    0xc(%ebp),%edi
    2d06:	8b 47 24             	mov    0x24(%edi),%eax
    2d09:	29 c8                	sub    %ecx,%eax
    2d0b:	01 c2                	add    %eax,%edx
    2d0d:	89 56 24             	mov    %edx,0x24(%esi)
	return result;
}

static inline int skb_is_nonlinear(const struct sk_buff *skb)
{
    2d10:	8b 76 74             	mov    0x74(%esi),%esi
	return skb->data_len;
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
	return skb->len - skb->data_len;
}

#define SKB_PAGE_ASSERT(skb) do { if (skb_shinfo(skb)->nr_frags) out_of_line_bug(); } while (0)
#define SKB_FRAG_ASSERT(skb) do { if (skb_shinfo(skb)->frag_list) out_of_line_bug(); } while (0)
#define SKB_LINEAR_ASSERT(skb) do { if (skb_is_nonlinear(skb)) out_of_line_bug(); } while (0)

/*
 *	Add data to an sk_buff
 */
 
static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	return tmp;
}

/**
 *	skb_put - add data to a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer. If this would
 *	exceed the total buffer size the kernel will panic. A pointer to the
 *	first byte of the extra data is returned.
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
    2d13:	8b 57 70             	mov    0x70(%edi),%edx
    2d16:	85 f6                	test   %esi,%esi
    2d18:	0f 85 ab 12 00 00    	jne    3fc9 <client_rcv_impl+0x13f9>
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
    2d1e:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
    2d21:	8d 04 1a             	lea    (%edx,%ebx,1),%eax
	skb->len+=len;
    2d24:	01 51 70             	add    %edx,0x70(%ecx)
	if(skb->tail>skb->end) {
    2d27:	3b 81 9c 00 00 00    	cmp    0x9c(%ecx),%eax
    2d2d:	89 81 98 00 00 00    	mov    %eax,0x98(%ecx)
    2d33:	0f 87 77 12 00 00    	ja     3fb0 <client_rcv_impl+0x13e0>
		skb_put(copy, in_skb->len);
		BUG_TRAP(copy->len == in_skb->len);
    2d39:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    2d3c:	8b 75 d4             	mov    0xffffffd4(%ebp),%esi
    2d3f:	8b 43 70             	mov    0x70(%ebx),%eax
    2d42:	39 46 70             	cmp    %eax,0x70(%esi)
    2d45:	74 14                	je     2d5b <client_rcv_impl+0x18b>
    2d47:	c7 44 24 04 04 08 00 	movl   $0x804,0x4(%esp,1)
    2d4e:	00 
    2d4f:	c7 04 24 20 11 00 00 	movl   $0x1120,(%esp,1)
    2d56:	e8 fc ff ff ff       	call   2d57 <client_rcv_impl+0x187>
		copy->sk = in_skb->sk;
    2d5b:	8b 7d 0c             	mov    0xc(%ebp),%edi
    2d5e:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
    2d61:	8b 47 0c             	mov    0xc(%edi),%eax
    2d64:	89 42 0c             	mov    %eax,0xc(%edx)

		__kfree_skb(in_skb);
    2d67:	89 3c 24             	mov    %edi,(%esp,1)
    2d6a:	e8 fc ff ff ff       	call   2d6b <client_rcv_impl+0x19b>
		in_skb = copy;
    2d6f:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
    2d72:	89 4d 0c             	mov    %ecx,0xc(%ebp)
	}
#endif

#ifdef DEBUG_RECOVERY_MICROTEST
	{
		static int dropCount = 0;
		dropCount++;
		if(dropCount > 1000 && dropCount % 1000 <= 3) {
			goto drop;
		}
	}
#endif
	
	tresp_hdr = (WireTrickleResponse *)in_skb->data;
    2d75:	8b b1 94 00 00 00    	mov    0x94(%ecx),%esi
	/* 0429 - hash compression support */
	/* XXX HASHCOMPRESSED does not work for retransmitted packets */
	if(tresp_hdr->cont.continuationType & CONTTYPE_HASHCOMPRESSED) {
    2d7b:	80 7e 0c 00          	cmpb   $0x0,0xc(%esi)
    2d7f:	0f 89 8b 01 00 00    	jns    2f10 <client_rcv_impl+0x340>
#ifdef ENABLE_HASHCOMPRESS
		if(!pskb_may_pull(in_skb, RESPONSELEN_HASHCOMPRESS)) {
			printk("client_rcv: could not pull hash compress continuation\n");
			goto drop;
		}

		CONTINUATION_TYPE *finger, *simulationOutput;
		static struct WireContinuation scratch[NR_CPUS]; // avoid stack allocation (which risks stack overflow), and kmalloc, which is inefficient
		struct WireContinuation *wc_scratch = &scratch[smp_processor_id()];
		struct WireContinuation *wcont = &tresp_hdr->cont;
		int fullType;
		tresp_hdr->cont.continuationType &= ~CONTTYPE_HASHCOMPRESSED;
		fullType = tresp_hdr->cont.continuationType == CONTTYPE_FULL1 || 
			tresp_hdr->cont.continuationType == CONTTYPE_FULL2;
		BUG_TRAP(fullType ||
			 tresp_hdr->cont.continuationType == CONTTYPE_MINIMAL);
		
		/* find matching continuation */
		alloc_head_reverse_walk(&tp->t.cont_list, finger) {
			if(wcont->hash.parentSeq  == (typeof(wcont->hash.parentSeq)) finger->seq &&
			   wcont->hash.clientState == (typeof(wcont->hash.clientState)) finger->clientState) {
				break;
			}
		}
		if(finger == (CONTINUATION_TYPE *)&tp->t.cont_list) {
			if(clientDebugLevel >= 2)
				printk("could not find matching parent continuation\n");
			goto drop;
		}
		simulationOutput = finger + 1;
		// 0430 - numSiblings is from UC level; there is no similar field for Transport level
		//BUG_TRAP(tresp_hdr->numSiblings == simulationOutput->num_packets);

		BUG_TRAP(finger->simulated);
		BUG_TRAP(wcont->hash.position < simulationOutput->num_packets);

		// XXX replace this roundabout construction of new continuation with direct transformation
		marshallContinuationServerCopyMAC(sk, wc_scratch, simulationOutput, wcont->hash.position);
		unmarshallContinuationClient(in_skb, cont, wc_scratch);

		/* set up fields that client could not predict */
		cont->timestamp = ntohl(wcont->hash.timestamp);
		cont->mrtt = cont->rawMrtt = ntohs(wcont->hash.mrtt);
		cont->parentMSK = finger;

		if(fullType) {
			memcpy(cont->mac, wcont->hash.mac, HMACLEN);
		} else {
			noCont = 1;
		}

		__skb_pull(in_skb, RESPONSELEN_HASHCOMPRESS);
#else
		if(trickles_ratelimit()) 
    2d85:	a1 00 00 00 00       	mov    0x0,%eax
    2d8a:	9c                   	pushf  
    2d8b:	59                   	pop    %ecx
    2d8c:	fa                   	cli    
    2d8d:	89 c2                	mov    %eax,%edx
    2d8f:	8b 1d 3c e2 04 00    	mov    0x4e23c,%ebx
    2d95:	8b 3d 88 00 00 00    	mov    0x88,%edi
    2d9b:	a3 3c e2 04 00       	mov    %eax,0x4e23c
    2da0:	29 da                	sub    %ebx,%edx
    2da2:	01 fa                	add    %edi,%edx
    2da4:	89 15 88 00 00 00    	mov    %edx,0x88
    2daa:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    2db0:	76 10                	jbe    2dc2 <client_rcv_impl+0x1f2>
    2db2:	be 88 13 00 00       	mov    $0x1388,%esi
    2db7:	ba 88 13 00 00       	mov    $0x1388,%edx
    2dbc:	89 35 88 00 00 00    	mov    %esi,0x88
    2dc2:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    2dc8:	0f 86 31 01 00 00    	jbe    2eff <client_rcv_impl+0x32f>
    2dce:	31 db                	xor    %ebx,%ebx
    2dd0:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    2dd6:	a1 40 e2 04 00       	mov    0x4e240,%eax
    2ddb:	89 15 88 00 00 00    	mov    %edx,0x88
    2de1:	89 1d 40 e2 04 00    	mov    %ebx,0x4e240
    2de7:	51                   	push   %ecx
    2de8:	9d                   	popf   
    2de9:	85 c0                	test   %eax,%eax
    2deb:	0f 85 e9 00 00 00    	jne    2eda <client_rcv_impl+0x30a>
    2df1:	b8 01 00 00 00       	mov    $0x1,%eax
    2df6:	85 c0                	test   %eax,%eax
    2df8:	0f 85 cb 00 00 00    	jne    2ec9 <client_rcv_impl+0x2f9>
			printk("Hash compressed continuation received, but support not compiled in\n");
		goto drop;
#endif
	} else {
		if(!pskb_may_pull(in_skb, RESPONSELEN_MINIMAL)) {
			//printk("client_rcv: could not pull WireTrickleResponse\n");
			goto drop;
		}

		switch(tresp_hdr->cont.continuationType) {
		case CONTTYPE_MINIMAL:
			__skb_pull(in_skb, RESPONSELEN_MINIMAL);
			noCont = 1;
			break;
		case CONTTYPE_FULL1:
		case CONTTYPE_FULL2:
			if(!pskb_may_pull(in_skb, sizeof(WireTrickleResponse))) {
				printk("client_rcv: could not pull full WireTrickleResponse\n");
				goto drop;
			}
			__skb_pull(in_skb, sizeof(WireTrickleResponse));
			break;
		default:
			BUG();
		}
		if(noCont) {
			cont->continuationType = tresp_hdr->cont.continuationType;
			cont->seq = ntohl(tresp_hdr->cont.seq);
			cont->clientState = tresp_hdr->cont.clientState;
			cont->clientTimestamp = tresp_hdr->cont.clientTimestamp;
			cont->parent = tresp_hdr->cont.parent;
		} else {
			unmarshallContinuationClient(in_skb, cont, &tresp_hdr->cont);
		}
	}
	if(!noCont && (cont->seq > tp->t.rcv_nxt + 1000000 ||
		       cont->TCPBase > tp->t.rcv_nxt + 1000000)) {
		if(trickles_ratelimit()) 
			printk("Warning: client received bogus sequence number (%u) or TCPBase (%u)\n", cont->seq, cont->TCPBase);
	}
	TCP_SKB_CB(in_skb)->cont = cont;
	TCP_SKB_CB(in_skb)->byteNum = ntohl(tresp_hdr->byteNum);
	TCP_SKB_CB(in_skb)->numSiblings = tresp_hdr->numSiblings;
	TCP_SKB_CB(in_skb)->position = tresp_hdr->position;

	ucont_len = ntohs(tresp_hdr->ucont_len);
	ucont_in = in_skb->data;

	cont->mark = SKBLIST;

	recordSample(&ctx,0);

	cont->ucont_len = ucont_len;
	
	cont->cum_nonce = tresp_hdr->nonce;
	cont->next = cont->prev = NULL;

	/* debugger hook */
	if(cont->seq == breakpoint_seq) {
		static int x;
		x++;
	}

	if(!pskb_may_pull(in_skb, ucont_len)) {
		printk("client_rcv: could not pull ucont (ucont_len = %d, skb_len = %d)\n", (int)ucont_len, in_skb->len);
		goto drop;
	}
	if(ucont_len) {
		cont->ucont_data = kmalloc(ucont_len, GFP_ATOMIC);
		if(cont->ucont_data == NULL) {
			printk("client_rcv: out of memory while copying user continuation\n");
			goto drop;
		}
		memcpy(cont->ucont_data, ucont_in, ucont_len);
		__skb_pull(in_skb, ucont_len);
	}

	TCP_SKB_CB(in_skb)->trickle_seq = cont->seq;
	TCP_SKB_CB(in_skb)->clientState = cont->clientState;
	if(cont->seq < tp->t.rcv_nxt) {
		if(clientDebugLevel >= 2 || debugDrops)
			printk("Client_rcv: Useless old packet cont.seq = %u < rcv_nxt = %u; dropping\n", cont->seq, tp->t.rcv_nxt);
		goto drop;
	}
	recordSample(&ctx,0);
	if(sk->state != TCP_ESTABLISHED) {
		if(!(in_skb->h.th->syn && in_skb->h.th->ack) )
			goto drop;
		synack = 1;
		BUG_TRAP(!noCont);
		sk->state = TCP_ESTABLISHED;
		tp->rcv_nxt = 0;
		tp->rcv_wup = 0;
		tp->copied_seq = 0;
		trickles_client_connected_impl(sk);
		tp->t.rcv_nxt = cont->seq;
		tp->t.previous_base = cont->TCPBase;
		tp->t.state = TRICKLES_CLIENT_NORMAL;

		//SAVE_ACK_PREV(tp);
		tp->t.ack_prev = NULL;
		tp->t.ack_last = cont->seq + 1;
		tp->t.rtt = 0;
		tp->t.delay = 0;

		tp->t.timerState = TRICKLES_ENABLE_DATA_TIMEOUT;
		resetClientTimer(sk);
		/* copied from tcp_synsent_state_process; copy more if necessary */
		mb();
		tcp_set_state(sk, TCP_ESTABLISHED);
		if(!sk->dead) {
			sk->state_change(sk);
			sk_wake_async(sk, 0, POLL_OUT);
		} 
		cont->clientState = tp->t.clientStateCounter;
		cont->parent = tp->t.request_rcv_nxt;
	} else if(tp->t.state == TRICKLES_CLIENT_SYNACK && 
		  !in_skb->h.th->syn && in_skb->h.th->ack) {
		tp->t.state = TRICKLES_CLIENT_NORMAL;
	}
#ifdef JAM_NORMAL
	if(tp->t.state == TRICKLES_CLIENT_NORMAL) {
		GEN_JAM("normal");
		goto drop;
	}
#endif // JAM_NORMAL
	// 0502 search end

	// Must initialize in_skb->parent here, since 
	// cont->parent is initialized in SYN/ACK processing
	TCP_SKB_CB(in_skb)->parent = cont->parent;

	recordSample(&ctx,0);
	/*
	printk("Client received %u, rcv_nxt = %u, ack_seq = %u, ack_last = %u\n", 
	       cont.seq, tp->t.rcv_nxt, tp->t.ack_seq, tp->t.ack_last);
	*/

	recordSample(&ctx,0);

	/* 
	 *
	 *
	 * DATA STRUCTURE INVARIANTS
	 * ofo_queue - inserted during initial packet receipt, removed when dequeued, handed off to userspace, freed when duplicate arrives
	 * cont_list - inserted during initial packet receipt (not reordering), and freed during acking. NEVER freed during ofo_queue walk!!!
	 * In other words, continuations are treated separately from data
	 *
	 */

	recordSample(&ctx,0);
	if(!(((tp->t.state == TRICKLES_CLIENT_NORMAL || tp->t.state == TRICKLES_CLIENT_SLOWSTART) && 
	      cont->clientState == tp->t.clientStateCounter) || 
	     (tp->t.state == TRICKLES_CLIENT_RECOVERY && 
	      (cont->clientState == tp->t.clientStateCounter || cont->clientState == tp->t.clientStateCounter-1)))) {
		if(clientDebugLevel >= 2 || debugDrops) 
			printk("client state did not match, packet seq = %u state = %u, clientstate = %u\n", cont->seq, cont->clientState, tp->t.clientStateCounter);
		goto drop;
	}
	/* always add to alt sacks */
	if(!AckProof_update(sk, &tp->t.altProof, cont)) {
		if(clientDebugLevel >= 2 || debugDrops || debugProofDrops) {
			if(trickles_ratelimit())
				printk("altproof not updated, dropping\n");
		}
		goto drop;
	}
	if(tp->t.ack_prev == NULL || cont->seq > tp->t.ack_prev->seq) {
		//printk("  client: updating standardProof\n");
		/* have not acked yet, so add to standard sack */
		if(!AckProof_update(sk, &tp->t.standardProof, cont) && 
		   // 0419: need this test since tp->t.standardProof can be in bad states during recovery and slowstart
		   tp->t.state == TRICKLES_CLIENT_NORMAL) {
			if(clientDebugLevel >= 2 || debugDrops || debugProofDrops){
				if(trickles_ratelimit())
					printk("standardProof not updated, dropping\n");
			}
			goto drop;
		}
	}

	if(!noCont) {
		/* receiving packets, so we're making progress */
		if(!disableTimeout) {
			resetClientTimer(sk);
		}
	}
	cur_seq = cont->seq; // save value since cont might be deallocated soon
	
#ifdef FIXEDRTT
	tp->t.rtt = FIXEDRTT;
#else
	if(!synack) {
		int delta = jiffies - cont->clientTimestamp;
		if(delta > 0) {
			// protect against wraparound
			if(delta > 1000) {
				printk("warning: delta = %d\n", delta);
			}
			if(tp->t.rtt == 0) {
				tp->t.rtt = (delta) << 3;
			} else {
				tp->t.rtt = (tp->t.rtt - (tp->t.rtt >> 3)) +
					delta;
			}
		}
	}
#endif
	tp->t.delay = (tp->t.rtt >> 3) * TIMEOUT_MULTIPLIER;

#ifdef JAM_NORMAL
	if(tp->t.state == TRICKLES_CLIENT_NORMAL) {
		GEN_JAM("normal");
		goto drop;
	}
#endif // JAM_NORMAL

	if(cont->seq == tp->t.rcv_nxt) {
		int closedGap = 0;
		struct sk_buff *skb = in_skb;
		unsigned seq = cont->seq;
		int first = 1;
		recordSample(&ctx,1);

		if(!noCont) {
			ContList_insert(sk,cont);
		}
		recordSample(&ctx,1);
		while(1) {
			/* do NOT reinsert continuations from ofo queue; they're already in the ContList */
			client_inseq(sk, skb, noCont);
			if(first) recordSample(&ctx,1);
			if(paranoia >= 1 &&
			   AckProof_checkRange(&tp->t.altProof, tp->t.rcv_nxt, tp->t.rcv_nxt) == BADRANGE) {
				printk("Could not find rcv_nxt in altProof\n");
			}
			tp->t.rcv_nxt++;
			skb = skb_peek(&tp->t.ofo_queue);
			if(first) recordSample(&ctx,1);
			if(!skb || TCP_SKB_CB(skb)->trickle_seq != tp->t.rcv_nxt) {
				if(first) recordSample(&ctx,1);
				break;
			}
			closedGap++;
			__skb_dequeue(&tp->t.ofo_queue);
			delOfoSkb(skb);
			if(first) recordSample(&ctx,1);
			first = 0;
		}
		recordSample(&ctx,1);
		if(closedGap) {
			if(clientDebugLevel >= 2) 
				printk("%u closed gap of %d, ack_last = %u\n", seq, closedGap, tp->t.ack_last);
		} else {
			if(clientDebugLevel >= 2)
				printk("%u in order, ack_last = %u\n", seq, tp->t.ack_last);
		}
		recordSample(&ctx,1);
	} else {
		/* enqueue in ofo_queue */
		if(skb_peek(&tp->t.ofo_queue) == NULL) {
			if(clientDebugLevel >= 2)
				printk("  client: %u inserted at ofo head\n", TCP_SKB_CB(in_skb)->trickle_seq);
			if(!addOfoSkb(in_skb)) {
				goto drop;
			}
			__skb_queue_head(&tp->t.ofo_queue, in_skb);
			if(!noCont) {
				ContList_insert(sk,cont);
			}
		} else {
			struct sk_buff *skb = tp->t.ofo_queue.prev;
			do {
				if(TCP_SKB_CB(skb)->trickle_seq < TCP_SKB_CB(in_skb)->trickle_seq) 
					break;
			} while((struct sk_buff_head*)(skb=skb->prev) != &tp->t.ofo_queue);

			if((struct sk_buff_head*)skb->next != &tp->t.ofo_queue &&
			   TCP_SKB_CB(skb->next)->trickle_seq == TCP_SKB_CB(in_skb)->trickle_seq) {
				// overlap
				struct sk_buff *next = skb->next;
				if(NEWER(TCP_SKB_CB(in_skb)->clientState, TCP_SKB_CB(next)->clientState)) {

					if(clientDebugLevel >= 2)
						printk("Got rid of old skb %u\n", TCP_SKB_CB(next)->trickle_seq);
					__skb_unlink(next, &tp->t.ofo_queue);
					kfree_skb(next);
				} else {
					if(clientDebugLevel >= 2)
						printk("Got rid of new skb %u\n", TCP_SKB_CB(in_skb)->trickle_seq);
					kfree_skb(in_skb);
					goto skip_insert;
				}
			}
			if(clientDebugLevel >= 2) {
				printk("  client: inserted %u after %u, before %u\n", TCP_SKB_CB(in_skb)->trickle_seq, TCP_SKB_CB(skb)->trickle_seq, TCP_SKB_CB(skb->next)->trickle_seq);
			}
			if(!addOfoSkb(in_skb)) {
				goto drop;
			}
			__skb_insert(in_skb, skb, skb->next, &tp->t.ofo_queue);

			/* sorted insert into cont list */	
			if(!noCont)
				ContList_insert(sk, cont);
		skip_insert: ;
		}
	}
	recordSample(&ctx,0);
	cont = NULL;
	in_skb = NULL;
	// After this point, never reference cont or in_skb

	switch(tp->t.state) {
	case TRICKLES_CLIENT_SYNACK:
	case TRICKLES_CLIENT_NORMAL:
	case TRICKLES_CLIENT_RECOVERY:
		/* Check whether we want to send an ack */
		recordSample(&ctx,2);
		progress = findAckables(sk,0,NULL);
		recordSample(&ctx,2);
		if(!progress) {
			if(clientDebugLevel >= 2)
				printk("  client: no ackable found, rcv_nxt = %u\n", tp->t.rcv_nxt);
#ifndef DISABLE_FASTRECOVERY
			if(cur_seq > tp->t.ack_last) {
				tp->t.oo_count++;
#if 1 // 0714 - try different out of order thresholds
				if(tp->t.oo_count >= OO_THRESHOLD) {
#else
				if(tp->t.oo_count >= min(OO_THRESHOLD, max(tp->t.sentRequests.len / 4, 3))) {
				}
#endif
					int old_last = tp->t.ack_last;
					unsigned first_seq, seq;
					struct sk_buff *skip_skb;
					struct Request *req;
					struct DataRequestMapping *dataReqMap;

					if(clientDebugLevel >= 2)
						printk("oo threshold exceeded\n");
					tp->t.oo_count = 0;
					enterRecoveryState(sk, 0);
					findAckables(sk, 1,&skip_skb);

					BUG_TRAP(tp->t.ack_last >= old_last);
					BUG_TRAP(skip_skb != NULL);
					if(skip_skb->prev != (struct sk_buff*)&tp->t.ofo_queue) {
						first_seq = TCP_SKB_CB(skip_skb->prev)->trickle_seq + 1;
					} else {
						first_seq = tp->t.rcv_nxt;
					}
					BUG_TRAP(first_seq < TCP_SKB_CB(skip_skb)->trickle_seq);
#if 1 // 0418 [AA
					for(seq = first_seq,
						    dataReqMap = (struct DataRequestMapping*)tp->t.dataRequestMap.next,
						    req = (struct Request *)tp->t.sentRequests.next;
					    seq < TCP_SKB_CB(skip_skb)->trickle_seq; 
					    seq++) {
						int foundMapping = 0, foundRequest = 0;
						while(dataReqMap != (struct DataRequestMapping*) &tp->t.dataRequestMap &&
						      dataReqMap->transportResponseSeqEnd <= seq) {
							dataReqMap = dataReqMap->next;
						}
						if(dataReqMap != (struct DataRequestMapping*)&tp->t.dataRequestMap &&
						   dataReqMap->transportResponseSeqStart <= seq && 
						   seq < dataReqMap->transportResponseSeqEnd) {
							struct DataRequestMapping *next = dataReqMap->next;
							// Missing packet overlaps a data mapping
							if(enableDataRecovery) {
								unlink((struct alloc_head*)dataReqMap);
								insert_tail(&tp->t.missingDataMap, 
									    (struct alloc_head*)dataReqMap);
								foundMapping = 1;
							}
							dataReqMap = next;
						}

						while(req != (struct Request *)&tp->t.sentRequests &&
						      req->transportResponseSeqEnd <= seq) {
							req = (struct Request*)req->next;
						}
						if(req != (struct Request *)&tp->t.sentRequests &&
						   req->transportResponseSeqStart <= seq && 
						   seq < req->transportResponseSeqEnd) {
							struct Request *next = (struct Request*)req->next;

#if 1 // 0418
							unlink((struct alloc_head*)req);
							resetRequest(req);
							insert_head(&tp->t.queuedRequests, (struct alloc_head*)req);
							foundRequest = 1;
#endif
							req = next;
						}
						if(!(foundRequest ^ foundMapping)) {
#if 0 // 0418 trickles should be able to recover from these conditions
							if(foundRequest && foundMapping) {
								printk("weird, found both a request and a mapping\n");
							} else {
								printk("found neither request nor mapping\n");
							}
#endif
						}
					}
#endif // 0418 AA]
				}
			}
#endif // DISABLE_FASTRECOVERY
		} else {
			//printk("  client: after findackables: ack_seq = %d ack_last = %d\n", tp->t.ack_seq, tp->t.ack_last);
		}
		recordSample(&ctx,2);
		trickles_send_ack_impl(sk, 0);
		recordSample(&ctx,2);
		break;
	case TRICKLES_CLIENT_SLOWSTART:
		// do nothing
		break;
	default:
		BUG();
	}
	recordSample(&ctx,0);
	printTimings(&ctx);
	return 0;
 drop:
	__kfree_skb(in_skb);
    2dfe:	8b 75 0c             	mov    0xc(%ebp),%esi
    2e01:	89 34 24             	mov    %esi,(%esp,1)
    2e04:	e8 fc ff ff ff       	call   2e05 <client_rcv_impl+0x235>
	if(cont != NULL && (tp->t.ack_prev == cont)) {
    2e09:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    2e0c:	85 c0                	test   %eax,%eax
    2e0e:	74 5c                	je     2e6c <client_rcv_impl+0x29c>
    2e10:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
    2e13:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    2e16:	39 87 f0 02 00 00    	cmp    %eax,0x2f0(%edi)
    2e1c:	0f 84 89 00 00 00    	je     2eab <client_rcv_impl+0x2db>
  }
#endif // USERTEST
#endif // DEBUG_ALLOC

  if(cont->list) {
    2e22:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    2e25:	8b 42 08             	mov    0x8(%edx),%eax
    2e28:	85 c0                	test   %eax,%eax
    2e2a:	75 64                	jne    2e90 <client_rcv_impl+0x2c0>
	  BUG();
  }

  for(i=0; i < 2; i++) {
    2e2c:	31 db                	xor    %ebx,%ebx
    2e2e:	be 01 00 00 00       	mov    $0x1,%esi
    if((cont+i)->ucont_data)
    2e33:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
    2e36:	8b 84 19 80 00 00 00 	mov    0x80(%ecx,%ebx,1),%eax
    2e3d:	85 c0                	test   %eax,%eax
    2e3f:	75 3f                	jne    2e80 <client_rcv_impl+0x2b0>
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
    2e41:	8b 7d e8             	mov    0xffffffe8(%ebp),%edi
    2e44:	8b 84 1f 88 00 00 00 	mov    0x88(%edi,%ebx,1),%eax
    2e4b:	85 c0                	test   %eax,%eax
    2e4d:	75 27                	jne    2e76 <client_rcv_impl+0x2a6>
    2e4f:	81 c3 e4 00 00 00    	add    $0xe4,%ebx
    2e55:	4e                   	dec    %esi
    2e56:	79 db                	jns    2e33 <client_rcv_impl+0x263>
      kfree((cont+i)->input);
  }

#ifdef USERTEST
  kfree(cont);
#else  //0426 - change kernel to slab cache
#ifdef DEBUG_ALLOC
  zap_virt(cont);
  //memset(cont, 0x3e, sizeof(*cont));
#else
#ifndef USESLAB
  kfree(cont);  // 0502 maybe slab cache usage is buggy
#else
  kmem_cache_free(clientSideContinuation_cache, cont);
    2e58:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    2e5b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    2e5f:	a1 00 00 00 00       	mov    0x0,%eax
    2e64:	89 04 24             	mov    %eax,(%esp,1)
    2e67:	e8 fc ff ff ff       	call   2e68 <client_rcv_impl+0x298>
		BUG();
	}
	if(cont) {
		MARK_PC(cont);
		freeClientSide_Continuation(cont);
	}
	return 0;
}
    2e6c:	83 c4 50             	add    $0x50,%esp
    2e6f:	31 c0                	xor    %eax,%eax
    2e71:	5b                   	pop    %ebx
    2e72:	5e                   	pop    %esi
    2e73:	5f                   	pop    %edi
    2e74:	5d                   	pop    %ebp
    2e75:	c3                   	ret    
  for(i=0; i < 2; i++) {
    if((cont+i)->ucont_data)
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
      kfree((cont+i)->input);
    2e76:	89 04 24             	mov    %eax,(%esp,1)
    2e79:	e8 fc ff ff ff       	call   2e7a <client_rcv_impl+0x2aa>
    2e7e:	eb cf                	jmp    2e4f <client_rcv_impl+0x27f>
    2e80:	89 04 24             	mov    %eax,(%esp,1)
    2e83:	e8 fc ff ff ff       	call   2e84 <client_rcv_impl+0x2b4>
    2e88:	eb b7                	jmp    2e41 <client_rcv_impl+0x271>
    2e8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    2e90:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    2e97:	00 
    2e98:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    2e9f:	e8 fc ff ff ff       	call   2ea0 <client_rcv_impl+0x2d0>
    2ea4:	e8 fc ff ff ff       	call   2ea5 <client_rcv_impl+0x2d5>
    2ea9:	eb 81                	jmp    2e2c <client_rcv_impl+0x25c>
    2eab:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    2eb2:	00 
    2eb3:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    2eba:	e8 fc ff ff ff       	call   2ebb <client_rcv_impl+0x2eb>
    2ebf:	e8 fc ff ff ff       	call   2ec0 <client_rcv_impl+0x2f0>
    2ec4:	e9 59 ff ff ff       	jmp    2e22 <client_rcv_impl+0x252>
    2ec9:	c7 04 24 80 11 00 00 	movl   $0x1180,(%esp,1)
    2ed0:	e8 fc ff ff ff       	call   2ed1 <client_rcv_impl+0x301>
    2ed5:	e9 24 ff ff ff       	jmp    2dfe <client_rcv_impl+0x22e>
    2eda:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    2ede:	c7 44 24 08 4f 08 00 	movl   $0x84f,0x8(%esp,1)
    2ee5:	00 
    2ee6:	c7 44 24 04 6b 00 00 	movl   $0x6b,0x4(%esp,1)
    2eed:	00 
    2eee:	c7 04 24 c0 02 00 00 	movl   $0x2c0,(%esp,1)
    2ef5:	e8 fc ff ff ff       	call   2ef6 <client_rcv_impl+0x326>
    2efa:	e9 f2 fe ff ff       	jmp    2df1 <client_rcv_impl+0x221>
    2eff:	ff 05 40 e2 04 00    	incl   0x4e240
    2f05:	51                   	push   %ecx
    2f06:	9d                   	popf   
    2f07:	31 c0                	xor    %eax,%eax
    2f09:	e9 e8 fe ff ff       	jmp    2df6 <client_rcv_impl+0x226>
    2f0e:	89 f6                	mov    %esi,%esi
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
	return skb->len - skb->data_len;
    2f10:	8b 5d 0c             	mov    0xc(%ebp),%ebx
}

#define SKB_PAGE_ASSERT(skb) do { if (skb_shinfo(skb)->nr_frags) out_of_line_bug(); } while (0)
#define SKB_FRAG_ASSERT(skb) do { if (skb_shinfo(skb)->frag_list) out_of_line_bug(); } while (0)
#define SKB_LINEAR_ASSERT(skb) do { if (skb_is_nonlinear(skb)) out_of_line_bug(); } while (0)

/*
 *	Add data to an sk_buff
 */
 
static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	return tmp;
}

/**
 *	skb_put - add data to a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer. If this would
 *	exceed the total buffer size the kernel will panic. A pointer to the
 *	first byte of the extra data is returned.
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	if(skb->tail>skb->end) {
		skb_over_panic(skb, len, current_text_addr());
	}
	return tmp;
}

static inline unsigned char *__skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
	skb->len+=len;
	return skb->data;
}

/**
 *	skb_push - add data to the start of a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer at the buffer
 *	start. If this would exceed the total buffer headroom the kernel will
 *	panic. A pointer to the first byte of the extra data is returned.
 */

static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
	skb->len+=len;
	if(skb->data<skb->head) {
		skb_under_panic(skb, len, current_text_addr());
	}
	return skb->data;
}

static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
	skb->len-=len;
	if (skb->len < skb->data_len)
		out_of_line_bug();
	return 	skb->data+=len;
}

/**
 *	skb_pull - remove data from the start of a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to remove
 *
 *	This function removes data from the start of a buffer, returning
 *	the memory to the headroom. A pointer to the next data in the buffer
 *	is returned. Once the data has been pulled future pushes will overwrite
 *	the old data.
 */

static inline unsigned char * skb_pull(struct sk_buff *skb, unsigned int len)
{	
	if (len > skb->len)
		return NULL;
	return __skb_pull(skb,len);
}

extern unsigned char * __pskb_pull_tail(struct sk_buff *skb, int delta);

static inline char *__pskb_pull(struct sk_buff *skb, unsigned int len)
{
	if (len > skb_headlen(skb) &&
	    __pskb_pull_tail(skb, len-skb_headlen(skb)) == NULL)
		return NULL;
	skb->len -= len;
	return 	skb->data += len;
}

static inline unsigned char * pskb_pull(struct sk_buff *skb, unsigned int len)
{	
	if (len > skb->len)
		return NULL;
	return __pskb_pull(skb,len);
}

static inline int pskb_may_pull(struct sk_buff *skb, unsigned int len)
{
    2f13:	b9 21 00 00 00       	mov    $0x21,%ecx
    2f18:	8b 7d 0c             	mov    0xc(%ebp),%edi
    2f1b:	8b 53 70             	mov    0x70(%ebx),%edx
    2f1e:	8b 47 74             	mov    0x74(%edi),%eax
    2f21:	89 d3                	mov    %edx,%ebx
    2f23:	29 c3                	sub    %eax,%ebx
    2f25:	b8 01 00 00 00       	mov    $0x1,%eax
    2f2a:	39 d9                	cmp    %ebx,%ecx
    2f2c:	76 0a                	jbe    2f38 <client_rcv_impl+0x368>
	if (len <= skb_headlen(skb))
		return 1;
	if (len > skb->len)
    2f2e:	31 c0                	xor    %eax,%eax
    2f30:	39 d1                	cmp    %edx,%ecx
    2f32:	0f 86 52 10 00 00    	jbe    3f8a <client_rcv_impl+0x13ba>
    2f38:	85 c0                	test   %eax,%eax
    2f3a:	0f 84 be fe ff ff    	je     2dfe <client_rcv_impl+0x22e>
    2f40:	0f b6 46 0c          	movzbl 0xc(%esi),%eax
    2f44:	85 c0                	test   %eax,%eax
    2f46:	0f 84 13 10 00 00    	je     3f5f <client_rcv_impl+0x138f>
    2f4c:	83 f8 02             	cmp    $0x2,%eax
    2f4f:	0f 8f ec 0f 00 00    	jg     3f41 <client_rcv_impl+0x1371>
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
	return skb->len - skb->data_len;
    2f55:	8b 5d d4             	mov    0xffffffd4(%ebp),%ebx
}

#define SKB_PAGE_ASSERT(skb) do { if (skb_shinfo(skb)->nr_frags) out_of_line_bug(); } while (0)
#define SKB_FRAG_ASSERT(skb) do { if (skb_shinfo(skb)->frag_list) out_of_line_bug(); } while (0)
#define SKB_LINEAR_ASSERT(skb) do { if (skb_is_nonlinear(skb)) out_of_line_bug(); } while (0)

/*
 *	Add data to an sk_buff
 */
 
static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	return tmp;
}

/**
 *	skb_put - add data to a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer. If this would
 *	exceed the total buffer size the kernel will panic. A pointer to the
 *	first byte of the extra data is returned.
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	if(skb->tail>skb->end) {
		skb_over_panic(skb, len, current_text_addr());
	}
	return tmp;
}

static inline unsigned char *__skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
	skb->len+=len;
	return skb->data;
}

/**
 *	skb_push - add data to the start of a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer at the buffer
 *	start. If this would exceed the total buffer headroom the kernel will
 *	panic. A pointer to the first byte of the extra data is returned.
 */

static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
	skb->len+=len;
	if(skb->data<skb->head) {
		skb_under_panic(skb, len, current_text_addr());
	}
	return skb->data;
}

static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
	skb->len-=len;
	if (skb->len < skb->data_len)
		out_of_line_bug();
	return 	skb->data+=len;
}

/**
 *	skb_pull - remove data from the start of a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to remove
 *
 *	This function removes data from the start of a buffer, returning
 *	the memory to the headroom. A pointer to the next data in the buffer
 *	is returned. Once the data has been pulled future pushes will overwrite
 *	the old data.
 */

static inline unsigned char * skb_pull(struct sk_buff *skb, unsigned int len)
{	
	if (len > skb->len)
		return NULL;
	return __skb_pull(skb,len);
}

extern unsigned char * __pskb_pull_tail(struct sk_buff *skb, int delta);

static inline char *__pskb_pull(struct sk_buff *skb, unsigned int len)
{
	if (len > skb_headlen(skb) &&
	    __pskb_pull_tail(skb, len-skb_headlen(skb)) == NULL)
		return NULL;
	skb->len -= len;
	return 	skb->data += len;
}

static inline unsigned char * pskb_pull(struct sk_buff *skb, unsigned int len)
{	
	if (len > skb->len)
		return NULL;
	return __pskb_pull(skb,len);
}

static inline int pskb_may_pull(struct sk_buff *skb, unsigned int len)
{
    2f58:	b9 56 00 00 00       	mov    $0x56,%ecx
    2f5d:	8b 7d d4             	mov    0xffffffd4(%ebp),%edi
    2f60:	8b 53 70             	mov    0x70(%ebx),%edx
    2f63:	8b 47 74             	mov    0x74(%edi),%eax
    2f66:	89 d3                	mov    %edx,%ebx
    2f68:	29 c3                	sub    %eax,%ebx
    2f6a:	b8 01 00 00 00       	mov    $0x1,%eax
    2f6f:	39 d9                	cmp    %ebx,%ecx
    2f71:	76 0a                	jbe    2f7d <client_rcv_impl+0x3ad>
	if (len <= skb_headlen(skb))
		return 1;
	if (len > skb->len)
    2f73:	31 c0                	xor    %eax,%eax
    2f75:	39 d1                	cmp    %edx,%ecx
    2f77:	0f 86 a4 0f 00 00    	jbe    3f21 <client_rcv_impl+0x1351>
    2f7d:	85 c0                	test   %eax,%eax
    2f7f:	0f 84 90 0f 00 00    	je     3f15 <client_rcv_impl+0x1345>
    2f85:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
    2f88:	8b 42 70             	mov    0x70(%edx),%eax
    2f8b:	83 e8 56             	sub    $0x56,%eax
    2f8e:	3b 42 74             	cmp    0x74(%edx),%eax
    2f91:	89 42 70             	mov    %eax,0x70(%edx)
    2f94:	0f 82 aa 0e 00 00    	jb     3e44 <client_rcv_impl+0x1274>
    2f9a:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
    2f9d:	83 81 94 00 00 00 56 	addl   $0x56,0x94(%ecx)
    2fa4:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    2fa7:	85 c0                	test   %eax,%eax
    2fa9:	0f 84 48 0f 00 00    	je     3ef7 <client_rcv_impl+0x1327>
    2faf:	0f b6 46 0c          	movzbl 0xc(%esi),%eax
    2fb3:	8b 5d e8             	mov    0xffffffe8(%ebp),%ebx
    2fb6:	89 43 38             	mov    %eax,0x38(%ebx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    2fb9:	8b 46 0d             	mov    0xd(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    2fbc:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    2fbe:	89 43 34             	mov    %eax,0x34(%ebx)
    2fc1:	8b 46 15             	mov    0x15(%esi),%eax
    2fc4:	89 43 3c             	mov    %eax,0x3c(%ebx)
    2fc7:	8b 46 1d             	mov    0x1d(%esi),%eax
    2fca:	89 43 50             	mov    %eax,0x50(%ebx)
    2fcd:	8b 46 19             	mov    0x19(%esi),%eax
    2fd0:	89 43 40             	mov    %eax,0x40(%ebx)
    2fd3:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    2fd6:	85 c0                	test   %eax,%eax
    2fd8:	0f 85 94 00 00 00    	jne    3072 <client_rcv_impl+0x4a2>
    2fde:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    2fe1:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
    2fe4:	8b 82 dc 02 00 00    	mov    0x2dc(%edx),%eax
    2fea:	05 40 42 0f 00       	add    $0xf4240,%eax
    2fef:	39 41 34             	cmp    %eax,0x34(%ecx)
    2ff2:	77 05                	ja     2ff9 <client_rcv_impl+0x429>
    2ff4:	39 41 70             	cmp    %eax,0x70(%ecx)
    2ff7:	76 79                	jbe    3072 <client_rcv_impl+0x4a2>
    2ff9:	a1 00 00 00 00       	mov    0x0,%eax
    2ffe:	9c                   	pushf  
    2fff:	59                   	pop    %ecx
    3000:	fa                   	cli    
    3001:	89 c2                	mov    %eax,%edx
    3003:	8b 3d 44 e2 04 00    	mov    0x4e244,%edi
    3009:	8b 1d 8c 00 00 00    	mov    0x8c,%ebx
    300f:	a3 44 e2 04 00       	mov    %eax,0x4e244
    3014:	29 fa                	sub    %edi,%edx
    3016:	01 da                	add    %ebx,%edx
    3018:	89 15 8c 00 00 00    	mov    %edx,0x8c
    301e:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    3024:	76 10                	jbe    3036 <client_rcv_impl+0x466>
    3026:	bf 88 13 00 00       	mov    $0x1388,%edi
    302b:	ba 88 13 00 00       	mov    $0x1388,%edx
    3030:	89 3d 8c 00 00 00    	mov    %edi,0x8c
    3036:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    303c:	0f 86 a6 0e 00 00    	jbe    3ee8 <client_rcv_impl+0x1318>
    3042:	31 db                	xor    %ebx,%ebx
    3044:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    304a:	a1 48 e2 04 00       	mov    0x4e248,%eax
    304f:	89 15 8c 00 00 00    	mov    %edx,0x8c
    3055:	89 1d 48 e2 04 00    	mov    %ebx,0x4e248
    305b:	51                   	push   %ecx
    305c:	9d                   	popf   
    305d:	85 c0                	test   %eax,%eax
    305f:	0f 85 5e 0e 00 00    	jne    3ec3 <client_rcv_impl+0x12f3>
    3065:	b8 01 00 00 00       	mov    $0x1,%eax
    306a:	85 c0                	test   %eax,%eax
    306c:	0f 85 2f 0e 00 00    	jne    3ea1 <client_rcv_impl+0x12d1>
    3072:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3075:	8b 7d d4             	mov    0xffffffd4(%ebp),%edi
    3078:	8b 97 94 00 00 00    	mov    0x94(%edi),%edx
    307e:	89 47 5c             	mov    %eax,0x5c(%edi)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    3081:	8b 46 04             	mov    0x4(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    3084:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    3086:	89 47 60             	mov    %eax,0x60(%edi)
    3089:	0f b6 46 08          	movzbl 0x8(%esi),%eax
    308d:	88 47 68             	mov    %al,0x68(%edi)
    3090:	0f b6 46 09          	movzbl 0x9(%esi),%eax
    3094:	88 47 69             	mov    %al,0x69(%edi)
    3097:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
    309a:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
/* gcc should generate this for open coded C now too. May be worth switching to 
   it because inline assembly cannot be scheduled. -AK */
static __inline__ __const__ __u16 ___arch__swab16(__u16 x)
{
	__asm__("xchgb %b0,%h0"		/* swap bytes		*/
    309e:	86 c4                	xchg   %al,%ah
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
    30a0:	0f bf d8             	movswl %ax,%ebx
    30a3:	89 55 e4             	mov    %edx,0xffffffe4(%ebp)
    30a6:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    30ab:	89 81 d8 00 00 00    	mov    %eax,0xd8(%ecx)
    30b1:	89 59 7c             	mov    %ebx,0x7c(%ecx)
    30b4:	8b 06                	mov    (%esi),%eax
    30b6:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
    30bc:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
    30c3:	89 41 2c             	mov    %eax,0x2c(%ecx)
    30c6:	a1 00 00 00 00       	mov    0x0,%eax
    30cb:	39 41 34             	cmp    %eax,0x34(%ecx)
    30ce:	0f 84 c2 0d 00 00    	je     3e96 <client_rcv_impl+0x12c6>
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
	return skb->len - skb->data_len;
    30d4:	8b 75 d4             	mov    0xffffffd4(%ebp),%esi
    30d7:	b8 01 00 00 00       	mov    $0x1,%eax
    30dc:	8b 56 70             	mov    0x70(%esi),%edx
    30df:	8b 7e 74             	mov    0x74(%esi),%edi
    30e2:	89 d1                	mov    %edx,%ecx
    30e4:	29 f9                	sub    %edi,%ecx
    30e6:	39 cb                	cmp    %ecx,%ebx
    30e8:	76 0a                	jbe    30f4 <client_rcv_impl+0x524>
}

#define SKB_PAGE_ASSERT(skb) do { if (skb_shinfo(skb)->nr_frags) out_of_line_bug(); } while (0)
#define SKB_FRAG_ASSERT(skb) do { if (skb_shinfo(skb)->frag_list) out_of_line_bug(); } while (0)
#define SKB_LINEAR_ASSERT(skb) do { if (skb_is_nonlinear(skb)) out_of_line_bug(); } while (0)

/*
 *	Add data to an sk_buff
 */
 
static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	return tmp;
}

/**
 *	skb_put - add data to a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer. If this would
 *	exceed the total buffer size the kernel will panic. A pointer to the
 *	first byte of the extra data is returned.
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	if(skb->tail>skb->end) {
		skb_over_panic(skb, len, current_text_addr());
	}
	return tmp;
}

static inline unsigned char *__skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
	skb->len+=len;
	return skb->data;
}

/**
 *	skb_push - add data to the start of a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer at the buffer
 *	start. If this would exceed the total buffer headroom the kernel will
 *	panic. A pointer to the first byte of the extra data is returned.
 */

static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
	skb->len+=len;
	if(skb->data<skb->head) {
		skb_under_panic(skb, len, current_text_addr());
	}
	return skb->data;
}

static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
	skb->len-=len;
	if (skb->len < skb->data_len)
		out_of_line_bug();
	return 	skb->data+=len;
}

/**
 *	skb_pull - remove data from the start of a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to remove
 *
 *	This function removes data from the start of a buffer, returning
 *	the memory to the headroom. A pointer to the next data in the buffer
 *	is returned. Once the data has been pulled future pushes will overwrite
 *	the old data.
 */

static inline unsigned char * skb_pull(struct sk_buff *skb, unsigned int len)
{	
	if (len > skb->len)
		return NULL;
	return __skb_pull(skb,len);
}

extern unsigned char * __pskb_pull_tail(struct sk_buff *skb, int delta);

static inline char *__pskb_pull(struct sk_buff *skb, unsigned int len)
{
	if (len > skb_headlen(skb) &&
	    __pskb_pull_tail(skb, len-skb_headlen(skb)) == NULL)
		return NULL;
	skb->len -= len;
	return 	skb->data += len;
}

static inline unsigned char * pskb_pull(struct sk_buff *skb, unsigned int len)
{	
	if (len > skb->len)
		return NULL;
	return __pskb_pull(skb,len);
}

static inline int pskb_may_pull(struct sk_buff *skb, unsigned int len)
{
	if (len <= skb_headlen(skb))
		return 1;
	if (len > skb->len)
    30ea:	31 c0                	xor    %eax,%eax
    30ec:	39 d3                	cmp    %edx,%ebx
    30ee:	0f 86 82 0d 00 00    	jbe    3e76 <client_rcv_impl+0x12a6>
    30f4:	85 c0                	test   %eax,%eax
    30f6:	0f 84 60 0d 00 00    	je     3e5c <client_rcv_impl+0x128c>
    30fc:	66 85 db             	test   %bx,%bx
    30ff:	0f 85 eb 0c 00 00    	jne    3df0 <client_rcv_impl+0x1220>
    3105:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    3108:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
    310b:	8b 42 34             	mov    0x34(%edx),%eax
    310e:	89 41 54             	mov    %eax,0x54(%ecx)
    3111:	8b 42 3c             	mov    0x3c(%edx),%eax
    3114:	89 41 58             	mov    %eax,0x58(%ecx)
    3117:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
    311a:	8b 83 dc 02 00 00    	mov    0x2dc(%ebx),%eax
    3120:	39 42 34             	cmp    %eax,0x34(%edx)
    3123:	73 38                	jae    315d <client_rcv_impl+0x58d>
    3125:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    312c:	7e 1f                	jle    314d <client_rcv_impl+0x57d>
    312e:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    3132:	8b 75 e8             	mov    0xffffffe8(%ebp),%esi
    3135:	8b 46 34             	mov    0x34(%esi),%eax
    3138:	c7 04 24 e0 11 00 00 	movl   $0x11e0,(%esp,1)
    313f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3143:	e8 fc ff ff ff       	call   3144 <client_rcv_impl+0x574>
    3148:	e9 b1 fc ff ff       	jmp    2dfe <client_rcv_impl+0x22e>
    314d:	8b 15 00 00 00 00    	mov    0x0,%edx
    3153:	85 d2                	test   %edx,%edx
    3155:	0f 84 a3 fc ff ff    	je     2dfe <client_rcv_impl+0x22e>
    315b:	eb d1                	jmp    312e <client_rcv_impl+0x55e>
    315d:	8b 7d 08             	mov    0x8(%ebp),%edi
    3160:	0f b6 47 20          	movzbl 0x20(%edi),%eax
    3164:	fe c8                	dec    %al
    3166:	0f 84 4b 0c 00 00    	je     3db7 <client_rcv_impl+0x11e7>
    316c:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
    316f:	8b 42 20             	mov    0x20(%edx),%eax
    3172:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    3176:	24 12                	and    $0x12,%al
    3178:	3c 12                	cmp    $0x12,%al
    317a:	0f 85 7e fc ff ff    	jne    2dfe <client_rcv_impl+0x22e>
    3180:	c7 45 d8 01 00 00 00 	movl   $0x1,0xffffffd8(%ebp)
    3187:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    318a:	85 c0                	test   %eax,%eax
    318c:	0f 85 0c 0c 00 00    	jne    3d9e <client_rcv_impl+0x11ce>
    3192:	8b 4d 08             	mov    0x8(%ebp),%ecx
    3195:	31 c0                	xor    %eax,%eax
    3197:	31 ff                	xor    %edi,%edi
    3199:	c6 41 20 01          	movb   $0x1,0x20(%ecx)
    319d:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
    31a0:	89 83 f0 00 00 00    	mov    %eax,0xf0(%ebx)
    31a6:	31 c0                	xor    %eax,%eax
    31a8:	89 83 fc 00 00 00    	mov    %eax,0xfc(%ebx)
    31ae:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    31b5:	89 0c 24             	mov    %ecx,(%esp,1)
    31b8:	e8 23 e1 ff ff       	call   12e0 <trickles_client_connected_impl>
    31bd:	8b 75 e8             	mov    0xffffffe8(%ebp),%esi
    31c0:	8b 46 34             	mov    0x34(%esi),%eax
    31c3:	89 83 dc 02 00 00    	mov    %eax,0x2dc(%ebx)
    31c9:	8b 46 70             	mov    0x70(%esi),%eax
    31cc:	89 83 e0 02 00 00    	mov    %eax,0x2e0(%ebx)
    31d2:	b8 01 00 00 00       	mov    $0x1,%eax
    31d7:	89 83 cc 02 00 00    	mov    %eax,0x2cc(%ebx)
    31dd:	31 c0                	xor    %eax,%eax
    31df:	89 83 f0 02 00 00    	mov    %eax,0x2f0(%ebx)
    31e5:	8b 46 34             	mov    0x34(%esi),%eax
    31e8:	be 01 00 00 00       	mov    $0x1,%esi
    31ed:	89 bb d4 02 00 00    	mov    %edi,0x2d4(%ebx)
    31f3:	89 b3 d8 02 00 00    	mov    %esi,0x2d8(%ebx)
    31f9:	40                   	inc    %eax
    31fa:	89 83 f4 02 00 00    	mov    %eax,0x2f4(%ebx)
    3200:	31 c0                	xor    %eax,%eax
    3202:	89 83 d0 02 00 00    	mov    %eax,0x2d0(%ebx)
    3208:	8b 7d 08             	mov    0x8(%ebp),%edi
    320b:	89 3c 24             	mov    %edi,(%esp,1)
    320e:	e8 fc ff ff ff       	call   320f <client_rcv_impl+0x63f>
    3213:	f0 83 44 24 00 00    	lock addl $0x0,0x0(%esp,1)
#endif

static __inline__ void tcp_set_state(struct sock *sk, int state)
{
	int oldstate = sk->state;
    3219:	0f b6 47 20          	movzbl 0x20(%edi),%eax

	switch (state) {
	case TCP_ESTABLISHED:
		if (oldstate != TCP_ESTABLISHED)
    321d:	fe c8                	dec    %al
    321f:	74 1b                	je     323c <client_rcv_impl+0x66c>
			TCP_INC_STATS(TcpCurrEstab);
    3221:	8b 0d 08 00 00 00    	mov    0x8,%ecx
    3227:	ba 60 00 00 00       	mov    $0x60,%edx
    322c:	b8 20 00 00 00       	mov    $0x20,%eax
    3231:	85 c9                	test   %ecx,%ecx
    3233:	0f 45 d0             	cmovne %eax,%edx
    3236:	ff 82 00 00 00 00    	incl   0x0(%edx)
		break;

	case TCP_CLOSE:
		if (oldstate == TCP_CLOSE_WAIT || oldstate == TCP_ESTABLISHED)
			TCP_INC_STATS(TcpEstabResets);

		sk->prot->unhash(sk);
		if (sk->prev && !(sk->userlocks&SOCK_BINDPORT_LOCK))
			tcp_put_port(sk);
		/* fall through */
	default:
		if (oldstate==TCP_ESTABLISHED)
			tcp_statistics[smp_processor_id()*2+!in_softirq()].TcpCurrEstab--;
	}

	/* Change state AFTER socket is unhashed to avoid closed
	 * socket sitting in hash tables.
	 */
	sk->state = state;
    323c:	8b 45 08             	mov    0x8(%ebp),%eax
    323f:	c6 40 20 01          	movb   $0x1,0x20(%eax)
    3243:	8b 55 08             	mov    0x8(%ebp),%edx
    3246:	0f b6 82 80 00 00 00 	movzbl 0x80(%edx),%eax
    324d:	84 c0                	test   %al,%al
    324f:	0f 84 07 0b 00 00    	je     3d5c <client_rcv_impl+0x118c>
    3255:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
    3258:	8b 75 e8             	mov    0xffffffe8(%ebp),%esi
    325b:	8b 83 c8 02 00 00    	mov    0x2c8(%ebx),%eax
    3261:	89 46 3c             	mov    %eax,0x3c(%esi)
    3264:	8b 83 48 0a 00 00    	mov    0xa48(%ebx),%eax
    326a:	89 46 40             	mov    %eax,0x40(%esi)
    326d:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
    3270:	8b 5d d4             	mov    0xffffffd4(%ebp),%ebx
    3273:	8b 41 40             	mov    0x40(%ecx),%eax
    3276:	89 43 64             	mov    %eax,0x64(%ebx)
    3279:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    327c:	8b 96 cc 02 00 00    	mov    0x2cc(%esi),%edx
    3282:	83 fa 01             	cmp    $0x1,%edx
    3285:	0f 84 b7 0a 00 00    	je     3d42 <client_rcv_impl+0x1172>
    328b:	83 fa 03             	cmp    $0x3,%edx
    328e:	0f 84 ae 0a 00 00    	je     3d42 <client_rcv_impl+0x1172>
    3294:	83 fa 02             	cmp    $0x2,%edx
    3297:	74 47                	je     32e0 <client_rcv_impl+0x710>
    3299:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    32a0:	7e 2f                	jle    32d1 <client_rcv_impl+0x701>
    32a2:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
    32a5:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    32a8:	8b 87 c8 02 00 00    	mov    0x2c8(%edi),%eax
    32ae:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    32b2:	8b 42 3c             	mov    0x3c(%edx),%eax
    32b5:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    32b9:	8b 42 34             	mov    0x34(%edx),%eax
    32bc:	c7 04 24 40 12 00 00 	movl   $0x1240,(%esp,1)
    32c3:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    32c7:	e8 fc ff ff ff       	call   32c8 <client_rcv_impl+0x6f8>
    32cc:	e9 2d fb ff ff       	jmp    2dfe <client_rcv_impl+0x22e>
    32d1:	a1 00 00 00 00       	mov    0x0,%eax
    32d6:	85 c0                	test   %eax,%eax
    32d8:	0f 84 20 fb ff ff    	je     2dfe <client_rcv_impl+0x22e>
    32de:	eb c2                	jmp    32a2 <client_rcv_impl+0x6d2>
    32e0:	8b 5d e8             	mov    0xffffffe8(%ebp),%ebx
    32e3:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    32e6:	8b 53 3c             	mov    0x3c(%ebx),%edx
    32e9:	8b 86 c8 02 00 00    	mov    0x2c8(%esi),%eax
    32ef:	39 c2                	cmp    %eax,%edx
    32f1:	74 05                	je     32f8 <client_rcv_impl+0x728>
    32f3:	48                   	dec    %eax
    32f4:	39 c2                	cmp    %eax,%edx
    32f6:	75 a1                	jne    3299 <client_rcv_impl+0x6c9>
    32f8:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
    32fb:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
    32fe:	8b 75 08             	mov    0x8(%ebp),%esi
    3301:	81 c3 08 06 00 00    	add    $0x608,%ebx
    3307:	89 4c 24 08          	mov    %ecx,0x8(%esp,1)
    330b:	89 5d d0             	mov    %ebx,0xffffffd0(%ebp)
    330e:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    3312:	89 34 24             	mov    %esi,(%esp,1)
    3315:	e8 fc ff ff ff       	call   3316 <client_rcv_impl+0x746>
    331a:	85 c0                	test   %eax,%eax
    331c:	0f 85 de 00 00 00    	jne    3400 <client_rcv_impl+0x830>
    3322:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    3329:	0f 8e ab 00 00 00    	jle    33da <client_rcv_impl+0x80a>
    332f:	a1 00 00 00 00       	mov    0x0,%eax
    3334:	9c                   	pushf  
    3335:	59                   	pop    %ecx
    3336:	fa                   	cli    
    3337:	89 c2                	mov    %eax,%edx
    3339:	8b 1d 50 e2 04 00    	mov    0x4e250,%ebx
    333f:	8b 3d 90 00 00 00    	mov    0x90,%edi
    3345:	a3 50 e2 04 00       	mov    %eax,0x4e250
    334a:	29 da                	sub    %ebx,%edx
    334c:	01 fa                	add    %edi,%edx
    334e:	89 15 90 00 00 00    	mov    %edx,0x90
    3354:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    335a:	76 10                	jbe    336c <client_rcv_impl+0x79c>
    335c:	be 88 13 00 00       	mov    $0x1388,%esi
    3361:	ba 88 13 00 00       	mov    $0x1388,%edx
    3366:	89 35 90 00 00 00    	mov    %esi,0x90
    336c:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    3372:	76 5a                	jbe    33ce <client_rcv_impl+0x7fe>
    3374:	31 db                	xor    %ebx,%ebx
    3376:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    337c:	a1 54 e2 04 00       	mov    0x4e254,%eax
    3381:	89 15 90 00 00 00    	mov    %edx,0x90
    3387:	89 1d 54 e2 04 00    	mov    %ebx,0x4e254
    338d:	51                   	push   %ecx
    338e:	9d                   	popf   
    338f:	85 c0                	test   %eax,%eax
    3391:	75 19                	jne    33ac <client_rcv_impl+0x7dc>
    3393:	b8 01 00 00 00       	mov    $0x1,%eax
    3398:	85 c0                	test   %eax,%eax
    339a:	0f 84 5e fa ff ff    	je     2dfe <client_rcv_impl+0x22e>
    33a0:	c7 04 24 a0 12 00 00 	movl   $0x12a0,(%esp,1)
    33a7:	e9 24 fb ff ff       	jmp    2ed0 <client_rcv_impl+0x300>
    33ac:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    33b0:	c7 44 24 08 f2 08 00 	movl   $0x8f2,0x8(%esp,1)
    33b7:	00 
    33b8:	c7 44 24 04 6b 00 00 	movl   $0x6b,0x4(%esp,1)
    33bf:	00 
    33c0:	c7 04 24 c0 02 00 00 	movl   $0x2c0,(%esp,1)
    33c7:	e8 fc ff ff ff       	call   33c8 <client_rcv_impl+0x7f8>
    33cc:	eb c5                	jmp    3393 <client_rcv_impl+0x7c3>
    33ce:	ff 05 54 e2 04 00    	incl   0x4e254
    33d4:	51                   	push   %ecx
    33d5:	9d                   	popf   
    33d6:	31 c0                	xor    %eax,%eax
    33d8:	eb be                	jmp    3398 <client_rcv_impl+0x7c8>
    33da:	8b 3d 00 00 00 00    	mov    0x0,%edi
    33e0:	85 ff                	test   %edi,%edi
    33e2:	0f 85 47 ff ff ff    	jne    332f <client_rcv_impl+0x75f>
    33e8:	8b 35 00 00 00 00    	mov    0x0,%esi
    33ee:	85 f6                	test   %esi,%esi
    33f0:	0f 84 08 fa ff ff    	je     2dfe <client_rcv_impl+0x22e>
    33f6:	e9 34 ff ff ff       	jmp    332f <client_rcv_impl+0x75f>
    33fb:	90                   	nop    
    33fc:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    3400:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
    3403:	8b 87 f0 02 00 00    	mov    0x2f0(%edi),%eax
    3409:	85 c0                	test   %eax,%eax
    340b:	74 0b                	je     3418 <client_rcv_impl+0x848>
    340d:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    3410:	8b 40 34             	mov    0x34(%eax),%eax
    3413:	39 42 34             	cmp    %eax,0x34(%edx)
    3416:	76 32                	jbe    344a <client_rcv_impl+0x87a>
    3418:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    341b:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
    341e:	8b 5d 08             	mov    0x8(%ebp),%ebx
    3421:	05 00 03 00 00       	add    $0x300,%eax
    3426:	89 4c 24 08          	mov    %ecx,0x8(%esp,1)
    342a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    342e:	89 1c 24             	mov    %ebx,(%esp,1)
    3431:	e8 fc ff ff ff       	call   3432 <client_rcv_impl+0x862>
    3436:	85 c0                	test   %eax,%eax
    3438:	75 10                	jne    344a <client_rcv_impl+0x87a>
    343a:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    343d:	83 be cc 02 00 00 01 	cmpl   $0x1,0x2cc(%esi)
    3444:	0f 84 1f 08 00 00    	je     3c69 <client_rcv_impl+0x1099>
    344a:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    344d:	85 c0                	test   %eax,%eax
    344f:	75 0d                	jne    345e <client_rcv_impl+0x88e>
    3451:	a1 00 00 00 00       	mov    0x0,%eax
    3456:	85 c0                	test   %eax,%eax
    3458:	0f 84 fb 07 00 00    	je     3c59 <client_rcv_impl+0x1089>
    345e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3461:	8b 40 34             	mov    0x34(%eax),%eax
    3464:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    3467:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    346a:	85 c0                	test   %eax,%eax
    346c:	75 3c                	jne    34aa <client_rcv_impl+0x8da>
    346e:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    3471:	8b 1d 00 00 00 00    	mov    0x0,%ebx
    3477:	8b 42 50             	mov    0x50(%edx),%eax
    347a:	29 c3                	sub    %eax,%ebx
    347c:	85 db                	test   %ebx,%ebx
    347e:	7e 2a                	jle    34aa <client_rcv_impl+0x8da>
    3480:	81 fb e8 03 00 00    	cmp    $0x3e8,%ebx
    3486:	0f 8f b8 07 00 00    	jg     3c44 <client_rcv_impl+0x1074>
    348c:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    348f:	8b 91 d0 02 00 00    	mov    0x2d0(%ecx),%edx
    3495:	85 d2                	test   %edx,%edx
    3497:	0f 85 8f 07 00 00    	jne    3c2c <client_rcv_impl+0x105c>
    349d:	8d 04 dd 00 00 00 00 	lea    0x0(,%ebx,8),%eax
    34a4:	89 81 d0 02 00 00    	mov    %eax,0x2d0(%ecx)
    34aa:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    34ad:	8b 86 d0 02 00 00    	mov    0x2d0(%esi),%eax
    34b3:	c1 f8 03             	sar    $0x3,%eax
    34b6:	01 c0                	add    %eax,%eax
    34b8:	89 86 d4 02 00 00    	mov    %eax,0x2d4(%esi)
    34be:	8b 7d e8             	mov    0xffffffe8(%ebp),%edi
    34c1:	8b 7f 34             	mov    0x34(%edi),%edi
    34c4:	89 7d b4             	mov    %edi,0xffffffb4(%ebp)
    34c7:	3b be dc 02 00 00    	cmp    0x2dc(%esi),%edi
    34cd:	0f 84 f0 05 00 00    	je     3ac3 <client_rcv_impl+0xef3>
 *	volatile. Use with caution.
 */
 
static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
{
    34d3:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
	struct sk_buff *list = ((struct sk_buff *)list_)->next;
    34d6:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    34d9:	81 c7 e4 02 00 00    	add    $0x2e4,%edi
    34df:	89 7d b8             	mov    %edi,0xffffffb8(%ebp)
    34e2:	8b 82 e4 02 00 00    	mov    0x2e4(%edx),%eax
	if (list == (struct sk_buff *)list_)
    34e8:	ba 00 00 00 00       	mov    $0x0,%edx
    34ed:	39 f8                	cmp    %edi,%eax
    34ef:	0f 44 c2             	cmove  %edx,%eax
    34f2:	85 c0                	test   %eax,%eax
    34f4:	0f 84 36 05 00 00    	je     3a30 <client_rcv_impl+0xe60>
    34fa:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    34fd:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
    3500:	8b b0 e8 02 00 00    	mov    0x2e8(%eax),%esi
    3506:	8b 42 54             	mov    0x54(%edx),%eax
    3509:	39 46 54             	cmp    %eax,0x54(%esi)
    350c:	72 07                	jb     3515 <client_rcv_impl+0x945>
    350e:	8b 76 04             	mov    0x4(%esi),%esi
    3511:	39 fe                	cmp    %edi,%esi
    3513:	75 f4                	jne    3509 <client_rcv_impl+0x939>
    3515:	8b 1e                	mov    (%esi),%ebx
    3517:	39 fb                	cmp    %edi,%ebx
    3519:	74 0b                	je     3526 <client_rcv_impl+0x956>
    351b:	8b 53 54             	mov    0x54(%ebx),%edx
    351e:	39 c2                	cmp    %eax,%edx
    3520:	0f 84 52 04 00 00    	je     3978 <client_rcv_impl+0xda8>
    3526:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    352d:	0f 8f 1a 04 00 00    	jg     394d <client_rcv_impl+0xd7d>
    3533:	a1 00 00 00 00       	mov    0x0,%eax
    3538:	31 d2                	xor    %edx,%edx
    353a:	3d 00 00 00 10       	cmp    $0x10000000,%eax
    353f:	7f 1c                	jg     355d <client_rcv_impl+0x98d>
 * Atomically adds @i to @v.  Note that the guaranteed useful range
 * of an atomic_t is only 24 bits.
 */
static __inline__ void atomic_add(int i, atomic_t *v)
{
    3541:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
    3544:	8b 81 9c 00 00 00    	mov    0x9c(%ecx),%eax
    354a:	8b 99 90 00 00 00    	mov    0x90(%ecx),%ebx
    3550:	29 d8                	sub    %ebx,%eax
	__asm__ __volatile__(
    3552:	01 05 00 00 00 00    	add    %eax,0x0
    3558:	ba 01 00 00 00       	mov    $0x1,%edx
    355d:	85 d2                	test   %edx,%edx
    355f:	0f 84 99 f8 ff ff    	je     2dfe <client_rcv_impl+0x22e>
static inline void __skb_insert(struct sk_buff *newsk,
	struct sk_buff * prev, struct sk_buff *next,
	struct sk_buff_head * list)
{
	newsk->next = next;
    3565:	8b 5d d4             	mov    0xffffffd4(%ebp),%ebx
    3568:	8b 06                	mov    (%esi),%eax
	newsk->prev = prev;
    356a:	89 73 04             	mov    %esi,0x4(%ebx)
    356d:	89 03                	mov    %eax,(%ebx)
	next->prev = newsk;
    356f:	89 58 04             	mov    %ebx,0x4(%eax)
	prev->next = newsk;
    3572:	89 1e                	mov    %ebx,(%esi)
	newsk->list = list;
    3574:	89 7b 08             	mov    %edi,0x8(%ebx)
	list->qlen++;
    3577:	ff 47 08             	incl   0x8(%edi)
    357a:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    357d:	85 d2                	test   %edx,%edx
    357f:	0f 84 b1 03 00 00    	je     3936 <client_rcv_impl+0xd66>
    3585:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    3588:	8b 82 cc 02 00 00    	mov    0x2cc(%edx),%eax
    358e:	83 f8 03             	cmp    $0x3,%eax
    3591:	0f 84 d5 f8 ff ff    	je     2e6c <client_rcv_impl+0x29c>
    3597:	83 f8 03             	cmp    $0x3,%eax
    359a:	0f 8f 8c 03 00 00    	jg     392c <client_rcv_impl+0xd5c>
    35a0:	48                   	dec    %eax
    35a1:	0f 8c 67 03 00 00    	jl     390e <client_rcv_impl+0xd3e>
    35a7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    35ae:	00 
    35af:	8b 4d 08             	mov    0x8(%ebp),%ecx
    35b2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    35b9:	00 
    35ba:	89 0c 24             	mov    %ecx,(%esp,1)
    35bd:	e8 de 19 00 00       	call   4fa0 <findAckables>
    35c2:	85 c0                	test   %eax,%eax
    35c4:	0f 85 3a 02 00 00    	jne    3804 <client_rcv_impl+0xc34>
    35ca:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    35d1:	0f 8f 19 03 00 00    	jg     38f0 <client_rcv_impl+0xd20>
    35d7:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    35da:	8b 9e f4 02 00 00    	mov    0x2f4(%esi),%ebx
    35e0:	39 5d e0             	cmp    %ebx,0xffffffe0(%ebp)
    35e3:	0f 86 1b 02 00 00    	jbe    3804 <client_rcv_impl+0xc34>
    35e9:	8b 86 f8 02 00 00    	mov    0x2f8(%esi),%eax
    35ef:	40                   	inc    %eax
    35f0:	89 86 f8 02 00 00    	mov    %eax,0x2f8(%esi)
    35f6:	3b 05 00 00 00 00    	cmp    0x0,%eax
    35fc:	0f 8c 02 02 00 00    	jl     3804 <client_rcv_impl+0xc34>
    3602:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    3609:	0f 8f c9 02 00 00    	jg     38d8 <client_rcv_impl+0xd08>
    360f:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
    3612:	31 c0                	xor    %eax,%eax
    3614:	89 87 f8 02 00 00    	mov    %eax,0x2f8(%edi)
    361a:	8b 45 08             	mov    0x8(%ebp),%eax
    361d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    3624:	00 
    3625:	89 04 24             	mov    %eax,(%esp,1)
    3628:	e8 f3 dc ff ff       	call   1320 <enterRecoveryState>
    362d:	8b 55 08             	mov    0x8(%ebp),%edx
    3630:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
    3633:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    3637:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
    363e:	00 
    363f:	89 14 24             	mov    %edx,(%esp,1)
    3642:	e8 59 19 00 00       	call   4fa0 <findAckables>
    3647:	39 9f f4 02 00 00    	cmp    %ebx,0x2f4(%edi)
    364d:	0f 8c 6c 02 00 00    	jl     38bf <client_rcv_impl+0xcef>
    3653:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    3656:	85 c0                	test   %eax,%eax
    3658:	0f 84 45 02 00 00    	je     38a3 <client_rcv_impl+0xcd3>
    365e:	8b 50 04             	mov    0x4(%eax),%edx
    3661:	3b 55 b8             	cmp    0xffffffb8(%ebp),%edx
    3664:	0f 84 2b 02 00 00    	je     3895 <client_rcv_impl+0xcc5>
    366a:	8b 5a 54             	mov    0x54(%edx),%ebx
    366d:	43                   	inc    %ebx
    366e:	3b 58 54             	cmp    0x54(%eax),%ebx
    3671:	0f 83 02 02 00 00    	jae    3879 <client_rcv_impl+0xca9>
    3677:	89 5d cc             	mov    %ebx,0xffffffcc(%ebp)
    367a:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
    367d:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
    3680:	3b 50 54             	cmp    0x54(%eax),%edx
    3683:	8b bb 94 0a 00 00    	mov    0xa94(%ebx),%edi
    3689:	89 de                	mov    %ebx,%esi
    368b:	8b 9b 6c 0a 00 00    	mov    0xa6c(%ebx),%ebx
    3691:	0f 83 6d 01 00 00    	jae    3804 <client_rcv_impl+0xc34>
    3697:	8d 8e 90 0a 00 00    	lea    0xa90(%esi),%ecx
    369d:	81 c6 68 0a 00 00    	add    $0xa68,%esi
    36a3:	89 4d bc             	mov    %ecx,0xffffffbc(%ebp)
    36a6:	89 75 c0             	mov    %esi,0xffffffc0(%ebp)
    36a9:	3b 7d bc             	cmp    0xffffffbc(%ebp),%edi
    36ac:	0f 84 9a 00 00 00    	je     374c <client_rcv_impl+0xb7c>
    36b2:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    36b5:	39 47 1c             	cmp    %eax,0x1c(%edi)
    36b8:	77 14                	ja     36ce <client_rcv_impl+0xafe>
    36ba:	8b 7f 04             	mov    0x4(%edi),%edi
    36bd:	3b 7d bc             	cmp    0xffffffbc(%ebp),%edi
    36c0:	0f 84 86 00 00 00    	je     374c <client_rcv_impl+0xb7c>
    36c6:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
    36c9:	39 57 1c             	cmp    %edx,0x1c(%edi)
    36cc:	76 ec                	jbe    36ba <client_rcv_impl+0xaea>
    36ce:	3b 7d bc             	cmp    0xffffffbc(%ebp),%edi
    36d1:	74 79                	je     374c <client_rcv_impl+0xb7c>
    36d3:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
    36d6:	39 4f 18             	cmp    %ecx,0x18(%edi)
    36d9:	77 71                	ja     374c <client_rcv_impl+0xb7c>
    36db:	3b 4f 1c             	cmp    0x1c(%edi),%ecx
    36de:	73 6c                	jae    374c <client_rcv_impl+0xb7c>
    36e0:	a1 00 00 00 00       	mov    0x0,%eax
    36e5:	8b 77 04             	mov    0x4(%edi),%esi
    36e8:	85 c0                	test   %eax,%eax
    36ea:	89 75 c8             	mov    %esi,0xffffffc8(%ebp)
    36ed:	74 5a                	je     3749 <client_rcv_impl+0xb79>
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    36ef:	8b 07                	mov    (%edi),%eax
    36f1:	89 06                	mov    %eax,(%esi)
	elem->prev->next = elem->next;
    36f3:	8b 07                	mov    (%edi),%eax
	elem->prev = elem->next = NULL;
    36f5:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    36fb:	89 70 04             	mov    %esi,0x4(%eax)

	elem->list->len--;
    36fe:	8b 47 08             	mov    0x8(%edi),%eax
    3701:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
    3708:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    370b:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
    3712:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    3715:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    3718:	8b 82 a4 0a 00 00    	mov    0xaa4(%edx),%eax
    371e:	81 c6 a4 0a 00 00    	add    $0xaa4,%esi
    3724:	39 f8                	cmp    %edi,%eax
    3726:	0f 84 1a 01 00 00    	je     3846 <client_rcv_impl+0xc76>
    372c:	89 07                	mov    %eax,(%edi)
    372e:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    3731:	8b 82 a4 0a 00 00    	mov    0xaa4(%edx),%eax
    3737:	89 77 08             	mov    %esi,0x8(%edi)
    373a:	89 78 04             	mov    %edi,0x4(%eax)
    373d:	89 77 04             	mov    %esi,0x4(%edi)
    3740:	ff 46 10             	incl   0x10(%esi)
    3743:	89 ba a4 0a 00 00    	mov    %edi,0xaa4(%edx)
    3749:	8b 7d c8             	mov    0xffffffc8(%ebp),%edi
    374c:	3b 5d c0             	cmp    0xffffffc0(%ebp),%ebx
    374f:	0f 84 9d 00 00 00    	je     37f2 <client_rcv_impl+0xc22>
    3755:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
    3758:	39 4b 50             	cmp    %ecx,0x50(%ebx)
    375b:	77 14                	ja     3771 <client_rcv_impl+0xba1>
    375d:	8b 5b 04             	mov    0x4(%ebx),%ebx
    3760:	3b 5d c0             	cmp    0xffffffc0(%ebp),%ebx
    3763:	0f 84 89 00 00 00    	je     37f2 <client_rcv_impl+0xc22>
    3769:	8b 75 cc             	mov    0xffffffcc(%ebp),%esi
    376c:	39 73 50             	cmp    %esi,0x50(%ebx)
    376f:	76 ec                	jbe    375d <client_rcv_impl+0xb8d>
    3771:	3b 5d c0             	cmp    0xffffffc0(%ebp),%ebx
    3774:	74 7c                	je     37f2 <client_rcv_impl+0xc22>
    3776:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    3779:	39 43 4c             	cmp    %eax,0x4c(%ebx)
    377c:	77 74                	ja     37f2 <client_rcv_impl+0xc22>
    377e:	3b 43 50             	cmp    0x50(%ebx),%eax
    3781:	73 6f                	jae    37f2 <client_rcv_impl+0xc22>
    3783:	8b 53 04             	mov    0x4(%ebx),%edx
    3786:	89 55 c4             	mov    %edx,0xffffffc4(%ebp)
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    3789:	8b 03                	mov    (%ebx),%eax
    378b:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    378d:	8b 43 04             	mov    0x4(%ebx),%eax
    3790:	8b 13                	mov    (%ebx),%edx
	elem->prev = elem->next = NULL;
    3792:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    3798:	89 42 04             	mov    %eax,0x4(%edx)

	elem->list->len--;
    379b:	8b 43 08             	mov    0x8(%ebx),%eax
    379e:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    37a5:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    37a8:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	REQUEST_FIELDS
};

static inline void resetRequest(struct Request *req) {
	req->numChildren = 0;
    37af:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
	req->childrenMask = 0;
    37b6:	80 63 14 f0          	andb   $0xf0,0x14(%ebx)
	req->transport_seq = -1;
	req->seq = -1;
	req->isNew = 1;
    37ba:	80 4b 48 01          	orb    $0x1,0x48(%ebx)
    37be:	c7 43 38 ff ff ff ff 	movl   $0xffffffff,0x38(%ebx)
    37c5:	c7 43 3c ff ff ff ff 	movl   $0xffffffff,0x3c(%ebx)
#endif

//#define DEBUG_LIST

static inline void insert_head(struct alloc_head_list *head, struct alloc_head *elem) {
    37cc:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    37cf:	81 c6 7c 0a 00 00    	add    $0xa7c,%esi
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
#endif
	if(head->next == elem /* || elem->prev != NULL || elem->next != NULL */) {
    37d5:	8b 46 04             	mov    0x4(%esi),%eax
    37d8:	39 d8                	cmp    %ebx,%eax
    37da:	74 40                	je     381c <client_rcv_impl+0xc4c>
		BUG();
		show_stack(NULL);	
	}
	elem->next = head->next;
    37dc:	89 43 04             	mov    %eax,0x4(%ebx)
	head->next->prev = elem;
    37df:	8b 46 04             	mov    0x4(%esi),%eax
    37e2:	89 18                	mov    %ebx,(%eax)

	elem->prev = (struct alloc_head*)head;
    37e4:	89 33                	mov    %esi,(%ebx)
	head->next = elem;
    37e6:	89 5e 04             	mov    %ebx,0x4(%esi)

	elem->list = head;
    37e9:	89 73 08             	mov    %esi,0x8(%ebx)
	head->len++;
    37ec:	ff 46 10             	incl   0x10(%esi)
    37ef:	8b 5d c4             	mov    0xffffffc4(%ebp),%ebx
    37f2:	ff 45 cc             	incl   0xffffffcc(%ebp)
    37f5:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    37f8:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
    37fb:	3b 48 54             	cmp    0x54(%eax),%ecx
    37fe:	0f 82 a5 fe ff ff    	jb     36a9 <client_rcv_impl+0xad9>
    3804:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    380b:	00 
    380c:	8b 5d 08             	mov    0x8(%ebp),%ebx
    380f:	89 1c 24             	mov    %ebx,(%esp,1)
    3812:	e8 fc ff ff ff       	call   3813 <client_rcv_impl+0xc43>
    3817:	e9 50 f6 ff ff       	jmp    2e6c <client_rcv_impl+0x29c>
		BUG();
	}
#endif
	if(head->next == elem /* || elem->prev != NULL || elem->next != NULL */) {
		BUG();
    381c:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    3823:	00 
    3824:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    382b:	e8 fc ff ff ff       	call   382c <client_rcv_impl+0xc5c>
    3830:	e8 fc ff ff ff       	call   3831 <client_rcv_impl+0xc61>
		show_stack(NULL);	
    3835:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    383c:	e8 fc ff ff ff       	call   383d <client_rcv_impl+0xc6d>
    3841:	8b 46 04             	mov    0x4(%esi),%eax
    3844:	eb 96                	jmp    37dc <client_rcv_impl+0xc0c>
	}
	elem->next = head->next;
	head->next->prev = elem;

	elem->prev = (struct alloc_head*)head;
	head->next = elem;

	elem->list = head;
	head->len++;
}

static inline void insert_tail(struct alloc_head_list *head, struct alloc_head *elem) {
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
		BUG();
    3846:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    384d:	00 
    384e:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    3855:	e8 fc ff ff ff       	call   3856 <client_rcv_impl+0xc86>
    385a:	e8 fc ff ff ff       	call   385b <client_rcv_impl+0xc8b>
		show_stack(NULL);
    385f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    3866:	e8 fc ff ff ff       	call   3867 <client_rcv_impl+0xc97>
    386b:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    386e:	8b 81 a4 0a 00 00    	mov    0xaa4(%ecx),%eax
    3874:	e9 b3 fe ff ff       	jmp    372c <client_rcv_impl+0xb5c>
    3879:	c7 44 24 04 b0 09 00 	movl   $0x9b0,0x4(%esp,1)
    3880:	00 
    3881:	c7 04 24 c0 12 00 00 	movl   $0x12c0,(%esp,1)
    3888:	e8 fc ff ff ff       	call   3889 <client_rcv_impl+0xcb9>
    388d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    3890:	e9 e2 fd ff ff       	jmp    3677 <client_rcv_impl+0xaa7>
    3895:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    3898:	8b 99 dc 02 00 00    	mov    0x2dc(%ecx),%ebx
    389e:	e9 cb fd ff ff       	jmp    366e <client_rcv_impl+0xa9e>
    38a3:	c7 44 24 04 aa 09 00 	movl   $0x9aa,0x4(%esp,1)
    38aa:	00 
    38ab:	c7 04 24 20 13 00 00 	movl   $0x1320,(%esp,1)
    38b2:	e8 fc ff ff ff       	call   38b3 <client_rcv_impl+0xce3>
    38b7:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    38ba:	e9 9f fd ff ff       	jmp    365e <client_rcv_impl+0xa8e>
    38bf:	c7 44 24 04 a9 09 00 	movl   $0x9a9,0x4(%esp,1)
    38c6:	00 
    38c7:	c7 04 24 60 13 00 00 	movl   $0x1360,(%esp,1)
    38ce:	e8 fc ff ff ff       	call   38cf <client_rcv_impl+0xcff>
    38d3:	e9 7b fd ff ff       	jmp    3653 <client_rcv_impl+0xa83>
    38d8:	c7 04 24 f2 01 00 00 	movl   $0x1f2,(%esp,1)
    38df:	e8 fc ff ff ff       	call   38e0 <client_rcv_impl+0xd10>
    38e4:	e9 26 fd ff ff       	jmp    360f <client_rcv_impl+0xa3f>
    38e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    38f0:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
    38f3:	8b 83 dc 02 00 00    	mov    0x2dc(%ebx),%eax
    38f9:	c7 04 24 c0 13 00 00 	movl   $0x13c0,(%esp,1)
    3900:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3904:	e8 fc ff ff ff       	call   3905 <client_rcv_impl+0xd35>
    3909:	e9 c9 fc ff ff       	jmp    35d7 <client_rcv_impl+0xa07>
    390e:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    3915:	00 
    3916:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    391d:	e8 fc ff ff ff       	call   391e <client_rcv_impl+0xd4e>
    3922:	e8 fc ff ff ff       	call   3923 <client_rcv_impl+0xd53>
    3927:	e9 40 f5 ff ff       	jmp    2e6c <client_rcv_impl+0x29c>
    392c:	83 f8 04             	cmp    $0x4,%eax
    392f:	75 dd                	jne    390e <client_rcv_impl+0xd3e>
    3931:	e9 71 fc ff ff       	jmp    35a7 <client_rcv_impl+0x9d7>
    3936:	8b 75 e8             	mov    0xffffffe8(%ebp),%esi
    3939:	8b 7d 08             	mov    0x8(%ebp),%edi
    393c:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    3940:	89 3c 24             	mov    %edi,(%esp,1)
    3943:	e8 e8 db ff ff       	call   1530 <ContList_insert>
    3948:	e9 38 fc ff ff       	jmp    3585 <client_rcv_impl+0x9b5>
    394d:	8b 06                	mov    (%esi),%eax
    394f:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
    3952:	8b 40 54             	mov    0x54(%eax),%eax
    3955:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    3959:	8b 46 54             	mov    0x54(%esi),%eax
    395c:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    3960:	8b 42 54             	mov    0x54(%edx),%eax
    3963:	c7 04 24 00 14 00 00 	movl   $0x1400,(%esp,1)
    396a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    396e:	e8 fc ff ff ff       	call   396f <client_rcv_impl+0xd9f>
    3973:	e9 bb fb ff ff       	jmp    3533 <client_rcv_impl+0x963>
    3978:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
    397b:	8b 43 58             	mov    0x58(%ebx),%eax
    397e:	39 41 58             	cmp    %eax,0x58(%ecx)
    3981:	76 63                	jbe    39e6 <client_rcv_impl+0xe16>
    3983:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    398a:	7f 48                	jg     39d4 <client_rcv_impl+0xe04>
static inline void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
{
	struct sk_buff * next, * prev;

	list->qlen--;
    398c:	ff 4f 08             	decl   0x8(%edi)
	next = skb->next;
	prev = skb->prev;
	skb->next = NULL;
	skb->prev = NULL;
	skb->list = NULL;
    398f:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    3996:	8b 43 04             	mov    0x4(%ebx),%eax
    3999:	8b 13                	mov    (%ebx),%edx
    399b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    39a2:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	next->prev = prev;
    39a8:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    39ab:	89 10                	mov    %edx,(%eax)
    39ad:	8b 83 84 00 00 00    	mov    0x84(%ebx),%eax
    39b3:	48                   	dec    %eax
    39b4:	74 11                	je     39c7 <client_rcv_impl+0xdf7>
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
	unsigned char c;

	__asm__ __volatile__(
    39b6:	ff 8b 84 00 00 00    	decl   0x84(%ebx)
    39bc:	0f 94 c0             	sete   %al
    39bf:	84 c0                	test   %al,%al
    39c1:	0f 84 5f fb ff ff    	je     3526 <client_rcv_impl+0x956>
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
		__kfree_skb(skb);
    39c7:	89 1c 24             	mov    %ebx,(%esp,1)
    39ca:	e8 fc ff ff ff       	call   39cb <client_rcv_impl+0xdfb>
    39cf:	e9 52 fb ff ff       	jmp    3526 <client_rcv_impl+0x956>
    39d4:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    39d8:	c7 04 24 09 02 00 00 	movl   $0x209,(%esp,1)
    39df:	e8 fc ff ff ff       	call   39e0 <client_rcv_impl+0xe10>
    39e4:	eb a6                	jmp    398c <client_rcv_impl+0xdbc>
    39e6:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    39ed:	7f 2d                	jg     3a1c <client_rcv_impl+0xe4c>
 */
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
    39ef:	8b 5d d4             	mov    0xffffffd4(%ebp),%ebx
    39f2:	8b 83 84 00 00 00    	mov    0x84(%ebx),%eax
    39f8:	48                   	dec    %eax
    39f9:	74 11                	je     3a0c <client_rcv_impl+0xe3c>
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
	unsigned char c;

	__asm__ __volatile__(
    39fb:	ff 8b 84 00 00 00    	decl   0x84(%ebx)
    3a01:	0f 94 c0             	sete   %al
    3a04:	84 c0                	test   %al,%al
    3a06:	0f 84 79 fb ff ff    	je     3585 <client_rcv_impl+0x9b5>
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
		__kfree_skb(skb);
    3a0c:	8b 75 d4             	mov    0xffffffd4(%ebp),%esi
    3a0f:	89 34 24             	mov    %esi,(%esp,1)
    3a12:	e8 fc ff ff ff       	call   3a13 <client_rcv_impl+0xe43>
    3a17:	e9 69 fb ff ff       	jmp    3585 <client_rcv_impl+0x9b5>
    3a1c:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    3a20:	c7 04 24 20 02 00 00 	movl   $0x220,(%esp,1)
    3a27:	e8 fc ff ff ff       	call   3a28 <client_rcv_impl+0xe58>
    3a2c:	eb c1                	jmp    39ef <client_rcv_impl+0xe1f>
    3a2e:	89 f6                	mov    %esi,%esi
    3a30:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    3a37:	7f 6f                	jg     3aa8 <client_rcv_impl+0xed8>
    3a39:	a1 00 00 00 00       	mov    0x0,%eax
    3a3e:	31 d2                	xor    %edx,%edx
    3a40:	3d 00 00 00 10       	cmp    $0x10000000,%eax
    3a45:	7f 1c                	jg     3a63 <client_rcv_impl+0xe93>
 * Atomically adds @i to @v.  Note that the guaranteed useful range
 * of an atomic_t is only 24 bits.
 */
static __inline__ void atomic_add(int i, atomic_t *v)
{
    3a47:	8b 5d d4             	mov    0xffffffd4(%ebp),%ebx
    3a4a:	8b 83 9c 00 00 00    	mov    0x9c(%ebx),%eax
    3a50:	8b 93 90 00 00 00    	mov    0x90(%ebx),%edx
    3a56:	29 d0                	sub    %edx,%eax
	__asm__ __volatile__(
    3a58:	01 05 00 00 00 00    	add    %eax,0x0
    3a5e:	ba 01 00 00 00       	mov    $0x1,%edx
    3a63:	85 d2                	test   %edx,%edx
    3a65:	0f 84 93 f3 ff ff    	je     2dfe <client_rcv_impl+0x22e>
static inline void __skb_queue_head(struct sk_buff_head *list, struct sk_buff *newsk)
{
	struct sk_buff *prev, *next;

	newsk->list = list;
    3a6b:	8b 75 d4             	mov    0xffffffd4(%ebp),%esi
    3a6e:	89 7e 08             	mov    %edi,0x8(%esi)
	list->qlen++;
    3a71:	ff 47 08             	incl   0x8(%edi)
	prev = (struct sk_buff *)list;
	next = prev->next;
    3a74:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
	newsk->next = next;
	newsk->prev = prev;
    3a77:	89 7e 04             	mov    %edi,0x4(%esi)
    3a7a:	8b 82 e4 02 00 00    	mov    0x2e4(%edx),%eax
    3a80:	89 06                	mov    %eax,(%esi)
	next->prev = newsk;
    3a82:	89 70 04             	mov    %esi,0x4(%eax)
	prev->next = newsk;
    3a85:	89 b2 e4 02 00 00    	mov    %esi,0x2e4(%edx)
    3a8b:	8b 75 dc             	mov    0xffffffdc(%ebp),%esi
    3a8e:	85 f6                	test   %esi,%esi
    3a90:	0f 85 ef fa ff ff    	jne    3585 <client_rcv_impl+0x9b5>
    3a96:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
    3a99:	8b 5d 08             	mov    0x8(%ebp),%ebx
    3a9c:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    3aa0:	89 1c 24             	mov    %ebx,(%esp,1)
    3aa3:	e9 9b fe ff ff       	jmp    3943 <client_rcv_impl+0xd73>
    3aa8:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
    3aab:	8b 41 54             	mov    0x54(%ecx),%eax
    3aae:	c7 04 24 40 14 00 00 	movl   $0x1440,(%esp,1)
    3ab5:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3ab9:	e8 fc ff ff ff       	call   3aba <client_rcv_impl+0xeea>
    3abe:	e9 76 ff ff ff       	jmp    3a39 <client_rcv_impl+0xe69>
    3ac3:	8b 7d dc             	mov    0xffffffdc(%ebp),%edi
    3ac6:	31 f6                	xor    %esi,%esi
    3ac8:	8b 5d d4             	mov    0xffffffd4(%ebp),%ebx
    3acb:	85 ff                	test   %edi,%edi
    3acd:	0f 84 42 01 00 00    	je     3c15 <client_rcv_impl+0x1045>
    3ad3:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    3ad6:	81 c1 e4 02 00 00    	add    $0x2e4,%ecx
    3adc:	89 4d b8             	mov    %ecx,0xffffffb8(%ebp)
    3adf:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    3ae3:	8b 7d dc             	mov    0xffffffdc(%ebp),%edi
    3ae6:	8b 45 08             	mov    0x8(%ebp),%eax
    3ae9:	89 7c 24 08          	mov    %edi,0x8(%esp,1)
    3aed:	89 04 24             	mov    %eax,(%esp,1)
    3af0:	e8 7b 0a 00 00       	call   4570 <client_inseq>
    3af5:	8b 1d 00 00 00 00    	mov    0x0,%ebx
    3afb:	85 db                	test   %ebx,%ebx
    3afd:	7e 24                	jle    3b23 <client_rcv_impl+0xf53>
    3aff:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    3b02:	8b 4d d0             	mov    0xffffffd0(%ebp),%ecx
    3b05:	8b 82 dc 02 00 00    	mov    0x2dc(%edx),%eax
    3b0b:	89 0c 24             	mov    %ecx,(%esp,1)
    3b0e:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    3b12:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3b16:	e8 fc ff ff ff       	call   3b17 <client_rcv_impl+0xf47>
    3b1b:	85 c0                	test   %eax,%eax
    3b1d:	0f 84 e1 00 00 00    	je     3c04 <client_rcv_impl+0x1034>
    3b23:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
 
static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
{
	struct sk_buff *list = ((struct sk_buff *)list_)->next;
	if (list == (struct sk_buff *)list_)
    3b26:	bf 00 00 00 00       	mov    $0x0,%edi
    3b2b:	8b 83 dc 02 00 00    	mov    0x2dc(%ebx),%eax
 */
 
static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
{
	struct sk_buff *list = ((struct sk_buff *)list_)->next;
    3b31:	8b 93 e4 02 00 00    	mov    0x2e4(%ebx),%edx
    3b37:	40                   	inc    %eax
 */
 
static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
{
	struct sk_buff *list = ((struct sk_buff *)list_)->next;
    3b38:	89 d1                	mov    %edx,%ecx
    3b3a:	89 83 dc 02 00 00    	mov    %eax,0x2dc(%ebx)
 
static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
{
	struct sk_buff *list = ((struct sk_buff *)list_)->next;
	if (list == (struct sk_buff *)list_)
    3b40:	3b 55 b8             	cmp    0xffffffb8(%ebp),%edx
    3b43:	0f 44 d7             	cmove  %edi,%edx
    3b46:	85 d2                	test   %edx,%edx
 *	volatile. Use with caution.
 */
 
static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
{
    3b48:	89 d3                	mov    %edx,%ebx
    3b4a:	74 4c                	je     3b98 <client_rcv_impl+0xfc8>
    3b4c:	39 42 54             	cmp    %eax,0x54(%edx)
    3b4f:	75 47                	jne    3b98 <client_rcv_impl+0xfc8>
    3b51:	46                   	inc    %esi

	prev = (struct sk_buff *) list;
	next = prev->next;
	result = NULL;
	if (next != prev) {
    3b52:	3b 4d b8             	cmp    0xffffffb8(%ebp),%ecx
    3b55:	74 28                	je     3b7f <client_rcv_impl+0xfaf>
		result = next;
		next = next->next;
		list->qlen--;
    3b57:	8b 7d b8             	mov    0xffffffb8(%ebp),%edi
    3b5a:	8b 01                	mov    (%ecx),%eax
    3b5c:	ff 4f 08             	decl   0x8(%edi)
		next->prev = prev;
    3b5f:	89 78 04             	mov    %edi,0x4(%eax)
		prev->next = next;
    3b62:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
		result->next = NULL;
		result->prev = NULL;
    3b65:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
		result->list = NULL;
    3b6c:	c7 41 08 00 00 00 00 	movl   $0x0,0x8(%ecx)
    3b73:	89 87 e4 02 00 00    	mov    %eax,0x2e4(%edi)
    3b79:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
 * Atomically subtracts @i from @v.  Note that the guaranteed
 * useful range of an atomic_t is only 24 bits.
 */
static __inline__ void atomic_sub(int i, atomic_t *v)
{
    3b7f:	8b 82 9c 00 00 00    	mov    0x9c(%edx),%eax
    3b85:	8b 8a 90 00 00 00    	mov    0x90(%edx),%ecx
    3b8b:	29 c8                	sub    %ecx,%eax
	__asm__ __volatile__(
    3b8d:	29 05 00 00 00 00    	sub    %eax,0x0
    3b93:	e9 47 ff ff ff       	jmp    3adf <client_rcv_impl+0xf0f>
    3b98:	85 f6                	test   %esi,%esi
    3b9a:	74 36                	je     3bd2 <client_rcv_impl+0x1002>
    3b9c:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    3ba3:	0f 8e dc f9 ff ff    	jle    3585 <client_rcv_impl+0x9b5>
    3ba9:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    3bac:	8b 4d b4             	mov    0xffffffb4(%ebp),%ecx
    3baf:	8b 82 f4 02 00 00    	mov    0x2f4(%edx),%eax
    3bb5:	89 74 24 08          	mov    %esi,0x8(%esp,1)
    3bb9:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    3bbd:	c7 04 24 80 14 00 00 	movl   $0x1480,(%esp,1)
    3bc4:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    3bc8:	e8 fc ff ff ff       	call   3bc9 <client_rcv_impl+0xff9>
    3bcd:	e9 b3 f9 ff ff       	jmp    3585 <client_rcv_impl+0x9b5>
    3bd2:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    3bd9:	0f 8e a6 f9 ff ff    	jle    3585 <client_rcv_impl+0x9b5>
    3bdf:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
    3be2:	8b 75 b4             	mov    0xffffffb4(%ebp),%esi
    3be5:	8b 83 f4 02 00 00    	mov    0x2f4(%ebx),%eax
    3beb:	c7 04 24 37 02 00 00 	movl   $0x237,(%esp,1)
    3bf2:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    3bf6:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    3bfa:	e8 fc ff ff ff       	call   3bfb <client_rcv_impl+0x102b>
    3bff:	e9 81 f9 ff ff       	jmp    3585 <client_rcv_impl+0x9b5>
    3c04:	c7 04 24 c0 14 00 00 	movl   $0x14c0,(%esp,1)
    3c0b:	e8 fc ff ff ff       	call   3c0c <client_rcv_impl+0x103c>
    3c10:	e9 0e ff ff ff       	jmp    3b23 <client_rcv_impl+0xf53>
    3c15:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3c18:	8b 55 08             	mov    0x8(%ebp),%edx
    3c1b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3c1f:	89 14 24             	mov    %edx,(%esp,1)
    3c22:	e8 09 d9 ff ff       	call   1530 <ContList_insert>
    3c27:	e9 a7 fe ff ff       	jmp    3ad3 <client_rcv_impl+0xf03>
    3c2c:	89 d0                	mov    %edx,%eax
    3c2e:	c1 f8 03             	sar    $0x3,%eax
    3c31:	29 c2                	sub    %eax,%edx
    3c33:	8d 04 13             	lea    (%ebx,%edx,1),%eax
    3c36:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
    3c39:	89 83 d0 02 00 00    	mov    %eax,0x2d0(%ebx)
    3c3f:	e9 66 f8 ff ff       	jmp    34aa <client_rcv_impl+0x8da>
    3c44:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    3c48:	c7 04 24 53 02 00 00 	movl   $0x253,(%esp,1)
    3c4f:	e8 fc ff ff ff       	call   3c50 <client_rcv_impl+0x1080>
    3c54:	e9 33 f8 ff ff       	jmp    348c <client_rcv_impl+0x8bc>
    3c59:	8b 7d 08             	mov    0x8(%ebp),%edi
    3c5c:	89 3c 24             	mov    %edi,(%esp,1)
    3c5f:	e8 fc ff ff ff       	call   3c60 <client_rcv_impl+0x1090>
    3c64:	e9 f5 f7 ff ff       	jmp    345e <client_rcv_impl+0x88e>
    3c69:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    3c70:	0f 8e ab 00 00 00    	jle    3d21 <client_rcv_impl+0x1151>
    3c76:	a1 00 00 00 00       	mov    0x0,%eax
    3c7b:	9c                   	pushf  
    3c7c:	59                   	pop    %ecx
    3c7d:	fa                   	cli    
    3c7e:	89 c2                	mov    %eax,%edx
    3c80:	8b 1d 58 e2 04 00    	mov    0x4e258,%ebx
    3c86:	8b 3d 94 00 00 00    	mov    0x94,%edi
    3c8c:	a3 58 e2 04 00       	mov    %eax,0x4e258
    3c91:	29 da                	sub    %ebx,%edx
    3c93:	01 fa                	add    %edi,%edx
    3c95:	89 15 94 00 00 00    	mov    %edx,0x94
    3c9b:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    3ca1:	76 10                	jbe    3cb3 <client_rcv_impl+0x10e3>
    3ca3:	be 88 13 00 00       	mov    $0x1388,%esi
    3ca8:	ba 88 13 00 00       	mov    $0x1388,%edx
    3cad:	89 35 94 00 00 00    	mov    %esi,0x94
    3cb3:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    3cb9:	76 5a                	jbe    3d15 <client_rcv_impl+0x1145>
    3cbb:	31 db                	xor    %ebx,%ebx
    3cbd:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    3cc3:	a1 5c e2 04 00       	mov    0x4e25c,%eax
    3cc8:	89 15 94 00 00 00    	mov    %edx,0x94
    3cce:	89 1d 5c e2 04 00    	mov    %ebx,0x4e25c
    3cd4:	51                   	push   %ecx
    3cd5:	9d                   	popf   
    3cd6:	85 c0                	test   %eax,%eax
    3cd8:	75 19                	jne    3cf3 <client_rcv_impl+0x1123>
    3cda:	b8 01 00 00 00       	mov    $0x1,%eax
    3cdf:	85 c0                	test   %eax,%eax
    3ce1:	0f 84 17 f1 ff ff    	je     2dfe <client_rcv_impl+0x22e>
    3ce7:	c7 04 24 00 15 00 00 	movl   $0x1500,(%esp,1)
    3cee:	e9 dd f1 ff ff       	jmp    2ed0 <client_rcv_impl+0x300>
    3cf3:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    3cf7:	c7 44 24 08 fe 08 00 	movl   $0x8fe,0x8(%esp,1)
    3cfe:	00 
    3cff:	c7 44 24 04 6b 00 00 	movl   $0x6b,0x4(%esp,1)
    3d06:	00 
    3d07:	c7 04 24 c0 02 00 00 	movl   $0x2c0,(%esp,1)
    3d0e:	e8 fc ff ff ff       	call   3d0f <client_rcv_impl+0x113f>
    3d13:	eb c5                	jmp    3cda <client_rcv_impl+0x110a>
    3d15:	ff 05 5c e2 04 00    	incl   0x4e25c
    3d1b:	51                   	push   %ecx
    3d1c:	9d                   	popf   
    3d1d:	31 c0                	xor    %eax,%eax
    3d1f:	eb be                	jmp    3cdf <client_rcv_impl+0x110f>
    3d21:	8b 3d 00 00 00 00    	mov    0x0,%edi
    3d27:	85 ff                	test   %edi,%edi
    3d29:	0f 85 47 ff ff ff    	jne    3c76 <client_rcv_impl+0x10a6>
    3d2f:	8b 35 00 00 00 00    	mov    0x0,%esi
    3d35:	85 f6                	test   %esi,%esi
    3d37:	0f 84 c1 f0 ff ff    	je     2dfe <client_rcv_impl+0x22e>
    3d3d:	e9 34 ff ff ff       	jmp    3c76 <client_rcv_impl+0x10a6>
    3d42:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
    3d45:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
    3d48:	8b 87 c8 02 00 00    	mov    0x2c8(%edi),%eax
    3d4e:	39 41 3c             	cmp    %eax,0x3c(%ecx)
    3d51:	0f 85 3d f5 ff ff    	jne    3294 <client_rcv_impl+0x6c4>
    3d57:	e9 9c f5 ff ff       	jmp    32f8 <client_rcv_impl+0x728>
    3d5c:	89 14 24             	mov    %edx,(%esp,1)
    3d5f:	ff 92 a8 0c 00 00    	call   *0xca8(%edx)
}

static inline void sk_wake_async(struct sock *sk, int how, int band)
{
	if (sk->socket && sk->socket->fasync_list)
    3d65:	8b 4d 08             	mov    0x8(%ebp),%ecx
    3d68:	8b 81 a0 0c 00 00    	mov    0xca0(%ecx),%eax
    3d6e:	85 c0                	test   %eax,%eax
    3d70:	0f 84 df f4 ff ff    	je     3255 <client_rcv_impl+0x685>
    3d76:	8b 50 10             	mov    0x10(%eax),%edx
    3d79:	85 d2                	test   %edx,%edx
    3d7b:	0f 84 d4 f4 ff ff    	je     3255 <client_rcv_impl+0x685>
		sock_wake_async(sk->socket, how, band);
    3d81:	c7 44 24 08 02 00 02 	movl   $0x20002,0x8(%esp,1)
    3d88:	00 
    3d89:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    3d90:	00 
    3d91:	89 04 24             	mov    %eax,(%esp,1)
    3d94:	e8 fc ff ff ff       	call   3d95 <client_rcv_impl+0x11c5>
    3d99:	e9 b7 f4 ff ff       	jmp    3255 <client_rcv_impl+0x685>
    3d9e:	c7 44 24 04 a9 08 00 	movl   $0x8a9,0x4(%esp,1)
    3da5:	00 
    3da6:	c7 04 24 40 15 00 00 	movl   $0x1540,(%esp,1)
    3dad:	e8 fc ff ff ff       	call   3dae <client_rcv_impl+0x11de>
    3db2:	e9 db f3 ff ff       	jmp    3192 <client_rcv_impl+0x5c2>
    3db7:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
    3dba:	83 bf cc 02 00 00 04 	cmpl   $0x4,0x2cc(%edi)
    3dc1:	0f 85 a6 f4 ff ff    	jne    326d <client_rcv_impl+0x69d>
    3dc7:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
    3dca:	8b 42 20             	mov    0x20(%edx),%eax
    3dcd:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    3dd1:	24 12                	and    $0x12,%al
    3dd3:	3c 10                	cmp    $0x10,%al
    3dd5:	0f 85 92 f4 ff ff    	jne    326d <client_rcv_impl+0x69d>
    3ddb:	b8 01 00 00 00       	mov    $0x1,%eax
    3de0:	89 87 cc 02 00 00    	mov    %eax,0x2cc(%edi)
    3de6:	e9 82 f4 ff ff       	jmp    326d <client_rcv_impl+0x69d>
    3deb:	90                   	nop    
    3dec:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    3df0:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    3df7:	00 
    3df8:	89 1c 24             	mov    %ebx,(%esp,1)
    3dfb:	e8 fc ff ff ff       	call   3dfc <client_rcv_impl+0x122c>
    3e00:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
    3e03:	85 c0                	test   %eax,%eax
    3e05:	89 c7                	mov    %eax,%edi
    3e07:	89 81 80 00 00 00    	mov    %eax,0x80(%ecx)
    3e0d:	74 41                	je     3e50 <client_rcv_impl+0x1280>

static inline void * __memcpy(void * to, const void * from, size_t n)
{
int d0, d1, d2;
__asm__ __volatile__(
    3e0f:	89 d9                	mov    %ebx,%ecx
    3e11:	c1 e9 02             	shr    $0x2,%ecx
    3e14:	8b 75 e4             	mov    0xffffffe4(%ebp),%esi
    3e17:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    3e19:	f6 c3 02             	test   $0x2,%bl
    3e1c:	74 02                	je     3e20 <client_rcv_impl+0x1250>
    3e1e:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    3e20:	f6 c3 01             	test   $0x1,%bl
    3e23:	74 01                	je     3e26 <client_rcv_impl+0x1256>
    3e25:	a4                   	movsb  %ds:(%esi),%es:(%edi)
}

static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
	skb->len-=len;
    3e26:	8b 75 d4             	mov    0xffffffd4(%ebp),%esi
    3e29:	8b 46 70             	mov    0x70(%esi),%eax
    3e2c:	29 d8                	sub    %ebx,%eax
	if (skb->len < skb->data_len)
    3e2e:	3b 46 74             	cmp    0x74(%esi),%eax
    3e31:	89 46 70             	mov    %eax,0x70(%esi)
    3e34:	72 0e                	jb     3e44 <client_rcv_impl+0x1274>
    3e36:	8b 7d d4             	mov    0xffffffd4(%ebp),%edi
    3e39:	01 9f 94 00 00 00    	add    %ebx,0x94(%edi)
    3e3f:	e9 c1 f2 ff ff       	jmp    3105 <client_rcv_impl+0x535>
		out_of_line_bug();
    3e44:	c7 04 24 4c 03 00 00 	movl   $0x34c,(%esp,1)
    3e4b:	e8 fc ff ff ff       	call   3e4c <client_rcv_impl+0x127c>
    3e50:	c7 04 24 80 15 00 00 	movl   $0x1580,(%esp,1)
    3e57:	e9 74 f0 ff ff       	jmp    2ed0 <client_rcv_impl+0x300>
    3e5c:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
    3e5f:	8b 42 70             	mov    0x70(%edx),%eax
    3e62:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    3e66:	c7 04 24 c0 15 00 00 	movl   $0x15c0,(%esp,1)
    3e6d:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    3e71:	e9 cd f2 ff ff       	jmp    3143 <client_rcv_impl+0x573>
	return skb->data_len;
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
    3e76:	8b 7d d4             	mov    0xffffffd4(%ebp),%edi
    3e79:	89 d8                	mov    %ebx,%eax
    3e7b:	29 c8                	sub    %ecx,%eax
    3e7d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3e81:	89 3c 24             	mov    %edi,(%esp,1)
    3e84:	e8 fc ff ff ff       	call   3e85 <client_rcv_impl+0x12b5>
    3e89:	85 c0                	test   %eax,%eax
    3e8b:	0f 95 c0             	setne  %al
    3e8e:	0f b6 c0             	movzbl %al,%eax
    3e91:	e9 5e f2 ff ff       	jmp    30f4 <client_rcv_impl+0x524>
    3e96:	ff 05 4c e2 04 00    	incl   0x4e24c
    3e9c:	e9 33 f2 ff ff       	jmp    30d4 <client_rcv_impl+0x504>
    3ea1:	8b 5d e8             	mov    0xffffffe8(%ebp),%ebx
    3ea4:	8b 43 70             	mov    0x70(%ebx),%eax
    3ea7:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    3eab:	8b 43 34             	mov    0x34(%ebx),%eax
    3eae:	c7 04 24 20 16 00 00 	movl   $0x1620,(%esp,1)
    3eb5:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3eb9:	e8 fc ff ff ff       	call   3eba <client_rcv_impl+0x12ea>
    3ebe:	e9 af f1 ff ff       	jmp    3072 <client_rcv_impl+0x4a2>
    3ec3:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    3ec7:	c7 44 24 08 75 08 00 	movl   $0x875,0x8(%esp,1)
    3ece:	00 
    3ecf:	c7 44 24 04 6b 00 00 	movl   $0x6b,0x4(%esp,1)
    3ed6:	00 
    3ed7:	c7 04 24 c0 02 00 00 	movl   $0x2c0,(%esp,1)
    3ede:	e8 fc ff ff ff       	call   3edf <client_rcv_impl+0x130f>
    3ee3:	e9 7d f1 ff ff       	jmp    3065 <client_rcv_impl+0x495>
    3ee8:	ff 05 48 e2 04 00    	incl   0x4e248
    3eee:	51                   	push   %ecx
    3eef:	9d                   	popf   
    3ef0:	31 c0                	xor    %eax,%eax
    3ef2:	e9 73 f1 ff ff       	jmp    306a <client_rcv_impl+0x49a>
    3ef7:	8d 46 0c             	lea    0xc(%esi),%eax
    3efa:	8b 7d e8             	mov    0xffffffe8(%ebp),%edi
    3efd:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    3f01:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    3f04:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
    3f08:	89 04 24             	mov    %eax,(%esp,1)
    3f0b:	e8 50 c5 ff ff       	call   460 <unmarshallContinuationClient>
    3f10:	e9 be f0 ff ff       	jmp    2fd3 <client_rcv_impl+0x403>
    3f15:	c7 04 24 80 16 00 00 	movl   $0x1680,(%esp,1)
    3f1c:	e9 af ef ff ff       	jmp    2ed0 <client_rcv_impl+0x300>
	return skb->data_len;
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
    3f21:	89 c8                	mov    %ecx,%eax
    3f23:	29 d8                	sub    %ebx,%eax
    3f25:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3f29:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    3f2c:	89 04 24             	mov    %eax,(%esp,1)
    3f2f:	e8 fc ff ff ff       	call   3f30 <client_rcv_impl+0x1360>
    3f34:	85 c0                	test   %eax,%eax
    3f36:	0f 95 c0             	setne  %al
    3f39:	0f b6 c0             	movzbl %al,%eax
    3f3c:	e9 3c f0 ff ff       	jmp    2f7d <client_rcv_impl+0x3ad>
    3f41:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    3f48:	00 
    3f49:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    3f50:	e8 fc ff ff ff       	call   3f51 <client_rcv_impl+0x1381>
    3f55:	e8 fc ff ff ff       	call   3f56 <client_rcv_impl+0x1386>
    3f5a:	e9 45 f0 ff ff       	jmp    2fa4 <client_rcv_impl+0x3d4>
}

static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
	skb->len-=len;
    3f5f:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
    3f62:	8b 42 70             	mov    0x70(%edx),%eax
    3f65:	83 e8 21             	sub    $0x21,%eax
	if (skb->len < skb->data_len)
    3f68:	3b 42 74             	cmp    0x74(%edx),%eax
    3f6b:	89 42 70             	mov    %eax,0x70(%edx)
    3f6e:	0f 82 d0 fe ff ff    	jb     3e44 <client_rcv_impl+0x1274>
		out_of_line_bug();
    3f74:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
    3f77:	83 81 94 00 00 00 21 	addl   $0x21,0x94(%ecx)
    3f7e:	c7 45 dc 01 00 00 00 	movl   $0x1,0xffffffdc(%ebp)
    3f85:	e9 1a f0 ff ff       	jmp    2fa4 <client_rcv_impl+0x3d4>
	return skb->data_len;
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
    3f8a:	89 c8                	mov    %ecx,%eax
    3f8c:	29 d8                	sub    %ebx,%eax
    3f8e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3f92:	8b 45 0c             	mov    0xc(%ebp),%eax
    3f95:	89 04 24             	mov    %eax,(%esp,1)
    3f98:	e8 fc ff ff ff       	call   3f99 <client_rcv_impl+0x13c9>
    3f9d:	85 c0                	test   %eax,%eax
    3f9f:	0f 95 c0             	setne  %al
    3fa2:	0f b6 c0             	movzbl %al,%eax
    3fa5:	e9 8e ef ff ff       	jmp    2f38 <client_rcv_impl+0x368>
    3faa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	return skb->len - skb->data_len;
}

#define SKB_PAGE_ASSERT(skb) do { if (skb_shinfo(skb)->nr_frags) out_of_line_bug(); } while (0)
#define SKB_FRAG_ASSERT(skb) do { if (skb_shinfo(skb)->frag_list) out_of_line_bug(); } while (0)
#define SKB_LINEAR_ASSERT(skb) do { if (skb_is_nonlinear(skb)) out_of_line_bug(); } while (0)

/*
 *	Add data to an sk_buff
 */
 
static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	return tmp;
}

/**
 *	skb_put - add data to a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer. If this would
 *	exceed the total buffer size the kernel will panic. A pointer to the
 *	first byte of the extra data is returned.
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	if(skb->tail>skb->end) {
		skb_over_panic(skb, len, current_text_addr());
    3fb0:	c7 44 24 08 b8 3f 00 	movl   $0x3fb8,0x8(%esp,1)
    3fb7:	00 
    3fb8:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    3fbc:	89 0c 24             	mov    %ecx,(%esp,1)
    3fbf:	e8 fc ff ff ff       	call   3fc0 <client_rcv_impl+0x13f0>
    3fc4:	e9 70 ed ff ff       	jmp    2d39 <client_rcv_impl+0x169>
    3fc9:	c7 04 24 24 03 00 00 	movl   $0x324,(%esp,1)
    3fd0:	e9 76 fe ff ff       	jmp    3e4b <client_rcv_impl+0x127b>
    3fd5:	c7 04 24 c0 16 00 00 	movl   $0x16c0,(%esp,1)
    3fdc:	e9 ef ee ff ff       	jmp    2ed0 <client_rcv_impl+0x300>
  numContinuations++;
#endif

  if(rval == NULL) {
    printk("out of memory while allocating continuation\n");
    3fe1:	c7 04 24 00 17 00 00 	movl   $0x1700,(%esp,1)
    3fe8:	e8 fc ff ff ff       	call   3fe9 <client_rcv_impl+0x1419>
    3fed:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
    3ff4:	e9 5c ec ff ff       	jmp    2c55 <client_rcv_impl+0x85>
    3ff9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi

00004000 <trickles_send_ack_impl>:

int trickles_send_ack_impl(struct sock *sk, int user_ctx) {
    4000:	55                   	push   %ebp
    4001:	89 e5                	mov    %esp,%ebp
    4003:	57                   	push   %edi
    4004:	56                   	push   %esi
    4005:	53                   	push   %ebx
    4006:	83 ec 24             	sub    $0x24,%esp
	int num_iterations = 0;
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    4009:	8b 45 08             	mov    0x8(%ebp),%eax
    400c:	05 bc 00 00 00       	add    $0xbc,%eax
    4011:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	CONTINUATION_TYPE *cont = tp->t.ack_prev;
    4014:	8b 90 f0 02 00 00    	mov    0x2f0(%eax),%edx
	int contSource = 1;
	int caller = user_ctx ? 1 : 0; // DON'T REMOVE! Used when timing is enabled 
	int numAcksSent = 0;
    401a:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)

	TIMING_CTX_DEF0("trickles_send_ack_impl", "kernel", "user");
	TIMING_CTX_DEF1(5,5);
	reinitTimingCtx(&ctx);
	recordSample(&ctx,caller);
	if(caller)  ; // force reference to caller in all compilation environments

	if(cont == NULL) {
    4021:	8b 45 08             	mov    0x8(%ebp),%eax
    4024:	05 dc 0a 00 00       	add    $0xadc,%eax
    4029:	85 d2                	test   %edx,%edx
    402b:	0f 45 c2             	cmovne %edx,%eax
    402e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    4031:	eb 0d                	jmp    4040 <trickles_send_ack_impl+0x40>
    4033:	90                   	nop    
    4034:	90                   	nop    
    4035:	90                   	nop    
    4036:	90                   	nop    
    4037:	90                   	nop    
    4038:	90                   	nop    
    4039:	90                   	nop    
    403a:	90                   	nop    
    403b:	90                   	nop    
    403c:	90                   	nop    
    403d:	90                   	nop    
    403e:	90                   	nop    
    403f:	90                   	nop    
		contSource = 0;
		cont = (CONTINUATION_TYPE *)&tp->t.cont_list;
	}
	while(1) {
		int is_curr = 0;
		num_iterations++;
		
		recordSample(&ctx,caller);
		cont = cont->next;
    4040:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    4043:	8b 49 04             	mov    0x4(%ecx),%ecx
		/* Send ack */
		if(cont == NULL) {
    4046:	85 c9                	test   %ecx,%ecx
    4048:	89 4d ec             	mov    %ecx,0xffffffec(%ebp)
    404b:	0f 84 83 02 00 00    	je     42d4 <trickles_send_ack_impl+0x2d4>
			printk("trickles_send_ack_impl: cont == NULL\n");
			BUG();
			goto out;
		}

		if(cont == (CONTINUATION_TYPE*)&tp->t.cont_list ||
    4051:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    4054:	05 20 0a 00 00       	add    $0xa20,%eax
    4059:	39 45 ec             	cmp    %eax,0xffffffec(%ebp)
    405c:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    405f:	0f 84 64 02 00 00    	je     42c9 <trickles_send_ack_impl+0x2c9>
    4065:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    4068:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    406b:	8b 82 f4 02 00 00    	mov    0x2f4(%edx),%eax
    4071:	39 41 34             	cmp    %eax,0x34(%ecx)
    4074:	0f 83 4f 02 00 00    	jae    42c9 <trickles_send_ack_impl+0x2c9>
		   cont->seq >= tp->t.ack_last) {
			/* advanced too far; don't update */
			if(is_curr) BUG();
			goto out;
		}

		recordSample(&ctx,caller);

		if(!sendAckHelper(sk,cont,TREQ_NORMAL)) {
    407a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    4081:	00 
    4082:	8b 45 08             	mov    0x8(%ebp),%eax
    4085:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    4089:	89 04 24             	mov    %eax,(%esp,1)
    408c:	e8 2f 16 00 00       	call   56c0 <sendAckHelper>
    4091:	85 c0                	test   %eax,%eax
    4093:	0f 84 30 02 00 00    	je     42c9 <trickles_send_ack_impl+0x2c9>
			/* some error while transmitting ack */
			goto out;
		}
		numAcksSent++;
    4099:	ff 45 e8             	incl   0xffffffe8(%ebp)

		if(clientDebugLevel >= 2) {
    409c:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    40a3:	7e 0d                	jle    40b2 <trickles_send_ack_impl+0xb2>
			if(cont->state == CONT_BOOTSTRAP) {
    40a5:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    40a8:	83 7a 58 02          	cmpl   $0x2,0x58(%edx)
    40ac:	0f 84 ff 01 00 00    	je     42b1 <trickles_send_ack_impl+0x2b1>
				printk("bootstrap ack: %u\n", cont->seq);
			}
		}

		recordSample(&ctx,caller);
		tp->t.ack_prev = cont;
    40b2:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    40b5:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
		INTEGRITY_CHECK(sk, tp->t.ack_prev);
		SAVE_ACK_PREV(tp);
		if(!(!tp->t.ack_prev || tp->t.ack_prev->next)) {
    40b8:	85 c0                	test   %eax,%eax
    40ba:	89 81 f0 02 00 00    	mov    %eax,0x2f0(%ecx)
    40c0:	74 0b                	je     40cd <trickles_send_ack_impl+0xcd>
    40c2:	8b 40 04             	mov    0x4(%eax),%eax
    40c5:	85 c0                	test   %eax,%eax
    40c7:	0f 84 b2 01 00 00    	je     427f <trickles_send_ack_impl+0x27f>
			// 0429
			BUG_TRAP(!tp->t.ack_prev || tp->t.ack_prev->next);
			BUG();
		}

		if(tp->t.state == TRICKLES_CLIENT_NORMAL) {
    40cd:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    40d0:	83 ba cc 02 00 00 01 	cmpl   $0x1,0x2cc(%edx)
    40d7:	74 0e                	je     40e7 <trickles_send_ack_impl+0xe7>
			CONTINUATION_TYPE *clean = (CONTINUATION_TYPE*)tp->t.cont_list.next;
			while(clean != (CONTINUATION_TYPE*)&tp->t.cont_list) {
				CONTINUATION_TYPE *prev = clean;
				clean = clean->next;
				// XXX  0429 hash compress changes needed
				if(
#ifdef ENABLE_HASHCOMPRESS
				   prev->numChildrenReceived < prev->numTransportChildren || 
#endif
				   prev->seq >= tp->t.ack_prev->seq ||
				   prev->seq >= tp->t.rcv_nxt /* ||
								 prev->seq >= tp->t.previous_base */) {
#if 0
					printk("skipped continued deallocation (list len = %d): prev->seq (%d) >= tp->t.ack_prev->seq (%d), prev->seq (%d) >= tp->t.rcv_nxt (%d)\n", 
					       tp->t.cont_list.len,
					       prev->seq, tp->t.ack_prev->seq,
					       prev->seq, tp->t.rcv_nxt);
#endif
					break;
				}
				BUG_TRAP(prev != tp->t.ack_prev);
				BUG_TRAP(prev != cont);
				unlinkCont(prev);
				MARK_PC(prev);
				if(tp->t.ack_prev == prev) {
					BUG();
				}
				if(clientDebugLevel >= 2) {
					printk("freeing %d, rcv_nxt=%d, previous_base = %d\n", prev->seq, tp->t.rcv_nxt, tp->t.previous_base);
				}
				freeClientSide_Continuation(prev);
			}
		}
		tp->t.in_flight++;
    40d9:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    40dc:	ff 80 fc 02 00 00    	incl   0x2fc(%eax)
    40e2:	e9 59 ff ff ff       	jmp    4040 <trickles_send_ack_impl+0x40>
    40e7:	8b 8a 24 0a 00 00    	mov    0xa24(%edx),%ecx
    40ed:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    40f0:	89 4d e0             	mov    %ecx,0xffffffe0(%ebp)
    40f3:	39 c1                	cmp    %eax,%ecx
    40f5:	74 e2                	je     40d9 <trickles_send_ack_impl+0xd9>
    40f7:	8b 5d e0             	mov    0xffffffe0(%ebp),%ebx
    40fa:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    40fd:	8b 53 04             	mov    0x4(%ebx),%edx
    4100:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
    4103:	8b 91 f0 02 00 00    	mov    0x2f0(%ecx),%edx
    4109:	8b 43 34             	mov    0x34(%ebx),%eax
    410c:	3b 42 34             	cmp    0x34(%edx),%eax
    410f:	73 c8                	jae    40d9 <trickles_send_ack_impl+0xd9>
    4111:	3b 81 dc 02 00 00    	cmp    0x2dc(%ecx),%eax
    4117:	73 c0                	jae    40d9 <trickles_send_ack_impl+0xd9>
    4119:	39 d3                	cmp    %edx,%ebx
    411b:	0f 84 45 01 00 00    	je     4266 <trickles_send_ack_impl+0x266>
    4121:	3b 5d ec             	cmp    0xffffffec(%ebp),%ebx
    4124:	0f 84 23 01 00 00    	je     424d <trickles_send_ack_impl+0x24d>
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    412a:	8b 53 04             	mov    0x4(%ebx),%edx
    412d:	8b 03                	mov    (%ebx),%eax
    412f:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    4131:	8b 03                	mov    (%ebx),%eax
	elem->prev = elem->next = NULL;
    4133:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    4139:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
    413c:	8b 43 08             	mov    0x8(%ebx),%eax
    413f:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    4146:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    4149:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    4150:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    4153:	39 98 f0 02 00 00    	cmp    %ebx,0x2f0(%eax)
    4159:	0f 84 d0 00 00 00    	je     422f <trickles_send_ack_impl+0x22f>
    415f:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    4166:	0f 8f 94 00 00 00    	jg     4200 <trickles_send_ack_impl+0x200>
  }
#endif // USERTEST
#endif // DEBUG_ALLOC

  if(cont->list) {
    416c:	8b 43 08             	mov    0x8(%ebx),%eax
    416f:	85 c0                	test   %eax,%eax
    4171:	75 6d                	jne    41e0 <trickles_send_ack_impl+0x1e0>
	  BUG();
  }

  for(i=0; i < 2; i++) {
    4173:	31 f6                	xor    %esi,%esi
    4175:	bf 01 00 00 00       	mov    $0x1,%edi
    if((cont+i)->ucont_data)
    417a:	8b 84 33 80 00 00 00 	mov    0x80(%ebx,%esi,1),%eax
    4181:	85 c0                	test   %eax,%eax
    4183:	75 4b                	jne    41d0 <trickles_send_ack_impl+0x1d0>
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
    4185:	8b 84 33 88 00 00 00 	mov    0x88(%ebx,%esi,1),%eax
    418c:	85 c0                	test   %eax,%eax
    418e:	75 30                	jne    41c0 <trickles_send_ack_impl+0x1c0>
    4190:	81 c6 e4 00 00 00    	add    $0xe4,%esi
    4196:	4f                   	dec    %edi
    4197:	79 e1                	jns    417a <trickles_send_ack_impl+0x17a>
      kfree((cont+i)->input);
  }

#ifdef USERTEST
  kfree(cont);
#else  //0426 - change kernel to slab cache
#ifdef DEBUG_ALLOC
  zap_virt(cont);
  //memset(cont, 0x3e, sizeof(*cont));
#else
#ifndef USESLAB
  kfree(cont);  // 0502 maybe slab cache usage is buggy
#else
  kmem_cache_free(clientSideContinuation_cache, cont);
    4199:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    419d:	a1 00 00 00 00       	mov    0x0,%eax
    41a2:	89 04 24             	mov    %eax,(%esp,1)
    41a5:	e8 fc ff ff ff       	call   41a6 <trickles_send_ack_impl+0x1a6>
    41aa:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
    41ad:	39 4d e0             	cmp    %ecx,0xffffffe0(%ebp)
    41b0:	0f 85 41 ff ff ff    	jne    40f7 <trickles_send_ack_impl+0xf7>
    41b6:	e9 1e ff ff ff       	jmp    40d9 <trickles_send_ack_impl+0xd9>
    41bb:	90                   	nop    
    41bc:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    41c0:	89 04 24             	mov    %eax,(%esp,1)
    41c3:	e8 fc ff ff ff       	call   41c4 <trickles_send_ack_impl+0x1c4>
    41c8:	eb c6                	jmp    4190 <trickles_send_ack_impl+0x190>
    41ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    41d0:	89 04 24             	mov    %eax,(%esp,1)
    41d3:	e8 fc ff ff ff       	call   41d4 <trickles_send_ack_impl+0x1d4>
    41d8:	eb ab                	jmp    4185 <trickles_send_ack_impl+0x185>
    41da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    41e0:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    41e7:	00 
    41e8:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    41ef:	e8 fc ff ff ff       	call   41f0 <trickles_send_ack_impl+0x1f0>
    41f4:	e8 fc ff ff ff       	call   41f5 <trickles_send_ack_impl+0x1f5>
    41f9:	e9 75 ff ff ff       	jmp    4173 <trickles_send_ack_impl+0x173>
    41fe:	89 f6                	mov    %esi,%esi
    4200:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    4203:	8b 82 e0 02 00 00    	mov    0x2e0(%edx),%eax
    4209:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    420d:	8b 82 dc 02 00 00    	mov    0x2dc(%edx),%eax
    4213:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    4217:	8b 43 34             	mov    0x34(%ebx),%eax
    421a:	c7 04 24 40 17 00 00 	movl   $0x1740,(%esp,1)
    4221:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    4225:	e8 fc ff ff ff       	call   4226 <trickles_send_ack_impl+0x226>
    422a:	e9 3d ff ff ff       	jmp    416c <trickles_send_ack_impl+0x16c>
    422f:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    4236:	00 
    4237:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    423e:	e8 fc ff ff ff       	call   423f <trickles_send_ack_impl+0x23f>
    4243:	e8 fc ff ff ff       	call   4244 <trickles_send_ack_impl+0x244>
    4248:	e9 12 ff ff ff       	jmp    415f <trickles_send_ack_impl+0x15f>
    424d:	c7 44 24 04 59 0a 00 	movl   $0xa59,0x4(%esp,1)
    4254:	00 
    4255:	c7 04 24 80 17 00 00 	movl   $0x1780,(%esp,1)
    425c:	e8 fc ff ff ff       	call   425d <trickles_send_ack_impl+0x25d>
    4261:	e9 c4 fe ff ff       	jmp    412a <trickles_send_ack_impl+0x12a>
    4266:	c7 44 24 04 58 0a 00 	movl   $0xa58,0x4(%esp,1)
    426d:	00 
    426e:	c7 04 24 c0 17 00 00 	movl   $0x17c0,(%esp,1)
    4275:	e8 fc ff ff ff       	call   4276 <trickles_send_ack_impl+0x276>
    427a:	e9 a2 fe ff ff       	jmp    4121 <trickles_send_ack_impl+0x121>
    427f:	c7 44 24 04 3f 0a 00 	movl   $0xa3f,0x4(%esp,1)
    4286:	00 
    4287:	c7 04 24 20 18 00 00 	movl   $0x1820,(%esp,1)
    428e:	e8 fc ff ff ff       	call   428f <trickles_send_ack_impl+0x28f>
    4293:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    429a:	00 
    429b:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    42a2:	e8 fc ff ff ff       	call   42a3 <trickles_send_ack_impl+0x2a3>
    42a7:	e8 fc ff ff ff       	call   42a8 <trickles_send_ack_impl+0x2a8>
    42ac:	e9 1c fe ff ff       	jmp    40cd <trickles_send_ack_impl+0xcd>
    42b1:	8b 42 34             	mov    0x34(%edx),%eax
    42b4:	c7 04 24 68 02 00 00 	movl   $0x268,(%esp,1)
    42bb:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    42bf:	e8 fc ff ff ff       	call   42c0 <trickles_send_ack_impl+0x2c0>
    42c4:	e9 e9 fd ff ff       	jmp    40b2 <trickles_send_ack_impl+0xb2>
		recordSample(&ctx,caller);
		//printTimings(&ctx);
	}
 out:
	return numAcksSent;
	//printTimings(&ctx);
}
    42c9:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    42cc:	83 c4 24             	add    $0x24,%esp
    42cf:	5b                   	pop    %ebx
    42d0:	5e                   	pop    %esi
    42d1:	5f                   	pop    %edi
    42d2:	5d                   	pop    %ebp
    42d3:	c3                   	ret    
    42d4:	c7 04 24 80 18 00 00 	movl   $0x1880,(%esp,1)
    42db:	e8 fc ff ff ff       	call   42dc <trickles_send_ack_impl+0x2dc>
    42e0:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    42e7:	00 
    42e8:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    42ef:	e8 fc ff ff ff       	call   42f0 <trickles_send_ack_impl+0x2f0>
    42f4:	e8 fc ff ff ff       	call   42f5 <trickles_send_ack_impl+0x2f5>
    42f9:	eb ce                	jmp    42c9 <trickles_send_ack_impl+0x2c9>
    42fb:	90                   	nop    
    42fc:	8d 74 26 00          	lea    0x0(%esi,1),%esi

00004300 <user_ack_impl>:

void user_ack_impl(struct sock *sk) {
    4300:	55                   	push   %ebp
    4301:	89 e5                	mov    %esp,%ebp
    4303:	83 ec 14             	sub    $0x14,%esp
    4306:	89 5d f8             	mov    %ebx,0xfffffff8(%ebp)
    4309:	89 75 fc             	mov    %esi,0xfffffffc(%ebp)
    430c:	8b 75 08             	mov    0x8(%ebp),%esi
	/* Wrapper for trickles_send_ack_impl */
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;

	BUG_TRAP(in_softirq());
    430f:	a1 08 00 00 00       	mov    0x8,%eax
    4314:	8d 9e bc 00 00 00    	lea    0xbc(%esi),%ebx
    431a:	85 c0                	test   %eax,%eax
    431c:	74 74                	je     4392 <user_ack_impl+0x92>
#ifdef JAM_NORMAL
	if(tp->t.state == TRICKLES_CLIENT_NORMAL) {
		if(trickles_ratelimit()) printk("user_ack_impl: Jammed on normal\n");
		return;
	}
#endif // JAM_NORMAL


	tp->t.timerState |= TRICKLES_ENABLE_DATA_TIMEOUT;
    431e:	8b 83 d8 02 00 00    	mov    0x2d8(%ebx),%eax
    4324:	83 c8 01             	or     $0x1,%eax
    4327:	89 83 d8 02 00 00    	mov    %eax,0x2d8(%ebx)
	if((tp->t.timerState & TRICKLES_NEED_SLOWSTART)) {
    432d:	83 e0 02             	and    $0x2,%eax
    4330:	74 4e                	je     4380 <user_ack_impl+0x80>
		// slow start blocked by user
#ifdef JAM_SLOWSTART
		if(tp->t.state == TRICKLES_CLIENT_SLOWSTART) {
			if(trickles_ratelimit()) printk("user_ack_impl: Jam Slowstart\n");
			return;
		}
#endif
		enterRecoveryState(sk, 1);
    4332:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
    4339:	00 
    433a:	89 34 24             	mov    %esi,(%esp,1)
    433d:	e8 de cf ff ff       	call   1320 <enterRecoveryState>
#ifdef JAM_SLOWSTART1
		if(tp->t.state == TRICKLES_CLIENT_SLOWSTART) {
			if(trickles_ratelimit()) printk("user_ack_impl: Jam Slowstart 1\n");
			return;
		}
#endif

		if(clientDebugLevel >= 2)
    4342:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    4349:	7f 19                	jg     4364 <user_ack_impl+0x64>
			printk("user_ack_impl requestslowstart %p state = %d\n", sk, tp->t.timerState);
		requestSlowStart(sk);
    434b:	89 34 24             	mov    %esi,(%esp,1)
    434e:	e8 5d 28 00 00       	call   6bb0 <requestSlowStart>
	} else {
		trickles_send_ack_impl(sk, 1);
	}
	resetClientTimer(sk);
    4353:	89 75 08             	mov    %esi,0x8(%ebp)
    4356:	8b 5d f8             	mov    0xfffffff8(%ebp),%ebx
    4359:	8b 75 fc             	mov    0xfffffffc(%ebp),%esi
    435c:	89 ec                	mov    %ebp,%esp
    435e:	5d                   	pop    %ebp
    435f:	e9 fc ff ff ff       	jmp    4360 <user_ack_impl+0x60>
    4364:	8b 83 d8 02 00 00    	mov    0x2d8(%ebx),%eax
    436a:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    436e:	c7 04 24 c0 18 00 00 	movl   $0x18c0,(%esp,1)
    4375:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    4379:	e8 fc ff ff ff       	call   437a <user_ack_impl+0x7a>
    437e:	eb cb                	jmp    434b <user_ack_impl+0x4b>
    4380:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
    4387:	00 
    4388:	89 34 24             	mov    %esi,(%esp,1)
    438b:	e8 fc ff ff ff       	call   438c <user_ack_impl+0x8c>
    4390:	eb c1                	jmp    4353 <user_ack_impl+0x53>
    4392:	c7 44 24 04 72 0a 00 	movl   $0xa72,0x4(%esp,1)
    4399:	00 
    439a:	c7 04 24 00 19 00 00 	movl   $0x1900,(%esp,1)
    43a1:	e8 fc ff ff ff       	call   43a2 <user_ack_impl+0xa2>
    43a6:	e9 73 ff ff ff       	jmp    431e <user_ack_impl+0x1e>
    43ab:	90                   	nop    
    43ac:	8d 74 26 00          	lea    0x0(%esi,1),%esi

000043b0 <trickles_fin>:
}

void tcp_data_queue(struct sock *sk, struct sk_buff *skb);
#ifndef USERTEST
void trickles_fin(struct sock *sk) {
    43b0:	55                   	push   %ebp
    43b1:	89 e5                	mov    %esp,%ebp
	// based on tcp_fin()
	sk->shutdown |= RCV_SHUTDOWN;
	sk->done = 0;
	sk->err = EPIPE;
    43b3:	b8 20 00 00 00       	mov    $0x20,%eax
    43b8:	56                   	push   %esi
    43b9:	53                   	push   %ebx
    43ba:	83 ec 0c             	sub    $0xc,%esp
    43bd:	8b 5d 08             	mov    0x8(%ebp),%ebx
    43c0:	c6 83 81 00 00 00 00 	movb   $0x0,0x81(%ebx)
    43c7:	89 83 20 0c 00 00    	mov    %eax,0xc20(%ebx)
#endif

static __inline__ void tcp_set_state(struct sock *sk, int state)
{
	int oldstate = sk->state;
    43cd:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
    43d1:	80 4b 27 01          	orb    $0x1,0x27(%ebx)
#endif

static __inline__ void tcp_set_state(struct sock *sk, int state)
{
	int oldstate = sk->state;
    43d5:	0f b6 f0             	movzbl %al,%esi

	switch (state) {
	case TCP_ESTABLISHED:
		if (oldstate != TCP_ESTABLISHED)
			TCP_INC_STATS(TcpCurrEstab);
		break;

	case TCP_CLOSE:
		if (oldstate == TCP_CLOSE_WAIT || oldstate == TCP_ESTABLISHED)
    43d8:	83 fe 08             	cmp    $0x8,%esi
    43db:	0f 84 cf 00 00 00    	je     44b0 <trickles_fin+0x100>
    43e1:	83 fe 01             	cmp    $0x1,%esi
    43e4:	0f 84 c6 00 00 00    	je     44b0 <trickles_fin+0x100>
			TCP_INC_STATS(TcpEstabResets);

		sk->prot->unhash(sk);
    43ea:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax
    43f0:	89 1c 24             	mov    %ebx,(%esp,1)
    43f3:	ff 50 3c             	call   *0x3c(%eax)
		if (sk->prev && !(sk->userlocks&SOCK_BINDPORT_LOCK))
    43f6:	8b 43 7c             	mov    0x7c(%ebx),%eax
    43f9:	85 c0                	test   %eax,%eax
    43fb:	74 11                	je     440e <trickles_fin+0x5e>
    43fd:	0f b6 83 8c 00 00 00 	movzbl 0x8c(%ebx),%eax
    4404:	24 08                	and    $0x8,%al
    4406:	84 c0                	test   %al,%al
    4408:	0f 84 92 00 00 00    	je     44a0 <trickles_fin+0xf0>
			tcp_put_port(sk);
		/* fall through */
	default:
		if (oldstate==TCP_ESTABLISHED)
    440e:	4e                   	dec    %esi
    440f:	74 6f                	je     4480 <trickles_fin+0xd0>
			tcp_statistics[smp_processor_id()*2+!in_softirq()].TcpCurrEstab--;
	}

	/* Change state AFTER socket is unhashed to avoid closed
	 * socket sitting in hash tables.
	 */
	sk->state = state;
    4411:	c6 43 20 07          	movb   $0x7,0x20(%ebx)
	tcp_set_state(sk, TCP_CLOSE);

	sk->state_change(sk);
    4415:	89 1c 24             	mov    %ebx,(%esp,1)
    4418:	ff 93 a8 0c 00 00    	call   *0xca8(%ebx)
	/* Do not send POLL_HUP for half duplex close. */
	if (sk->shutdown == SHUTDOWN_MASK || sk->state == TCP_CLOSE)
    441e:	80 7b 27 03          	cmpb   $0x3,0x27(%ebx)
    4422:	74 3c                	je     4460 <trickles_fin+0xb0>
    4424:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
    4428:	3c 07                	cmp    $0x7,%al
    442a:	74 34                	je     4460 <trickles_fin+0xb0>
}

static inline void sk_wake_async(struct sock *sk, int how, int band)
{
	if (sk->socket && sk->socket->fasync_list)
    442c:	8b 83 a0 0c 00 00    	mov    0xca0(%ebx),%eax
    4432:	85 c0                	test   %eax,%eax
    4434:	74 07                	je     443d <trickles_fin+0x8d>
    4436:	8b 50 10             	mov    0x10(%eax),%edx
    4439:	85 d2                	test   %edx,%edx
    443b:	75 07                	jne    4444 <trickles_fin+0x94>
		sk_wake_async(sk, 1, POLL_HUP);
	else
		sk_wake_async(sk, 1, POLL_IN);
}
    443d:	83 c4 0c             	add    $0xc,%esp
    4440:	5b                   	pop    %ebx
    4441:	5e                   	pop    %esi
    4442:	5d                   	pop    %ebp
    4443:	c3                   	ret    

static inline void sk_wake_async(struct sock *sk, int how, int band)
{
	if (sk->socket && sk->socket->fasync_list)
		sock_wake_async(sk->socket, how, band);
    4444:	c7 44 24 08 01 00 02 	movl   $0x20001,0x8(%esp,1)
    444b:	00 
    444c:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
    4453:	00 
    4454:	89 04 24             	mov    %eax,(%esp,1)
    4457:	e8 fc ff ff ff       	call   4458 <trickles_fin+0xa8>
    445c:	eb df                	jmp    443d <trickles_fin+0x8d>
    445e:	89 f6                	mov    %esi,%esi
    4460:	8b 83 a0 0c 00 00    	mov    0xca0(%ebx),%eax
    4466:	85 c0                	test   %eax,%eax
    4468:	74 d3                	je     443d <trickles_fin+0x8d>
    446a:	8b 48 10             	mov    0x10(%eax),%ecx
    446d:	85 c9                	test   %ecx,%ecx
    446f:	74 cc                	je     443d <trickles_fin+0x8d>
    4471:	c7 44 24 08 06 00 02 	movl   $0x20006,0x8(%esp,1)
    4478:	00 
    4479:	eb d1                	jmp    444c <trickles_fin+0x9c>
    447b:	90                   	nop    
    447c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
			tcp_put_port(sk);
		/* fall through */
	default:
		if (oldstate==TCP_ESTABLISHED)
			tcp_statistics[smp_processor_id()*2+!in_softirq()].TcpCurrEstab--;
    4480:	8b 35 08 00 00 00    	mov    0x8,%esi
    4486:	ba 60 00 00 00       	mov    $0x60,%edx
    448b:	b8 20 00 00 00       	mov    $0x20,%eax
    4490:	85 f6                	test   %esi,%esi
    4492:	0f 45 d0             	cmovne %eax,%edx
    4495:	ff 8a 00 00 00 00    	decl   0x0(%edx)
    449b:	e9 71 ff ff ff       	jmp    4411 <trickles_fin+0x61>
    44a0:	89 1c 24             	mov    %ebx,(%esp,1)
    44a3:	e8 fc ff ff ff       	call   44a4 <trickles_fin+0xf4>
    44a8:	e9 61 ff ff ff       	jmp    440e <trickles_fin+0x5e>
    44ad:	8d 76 00             	lea    0x0(%esi),%esi
    44b0:	a1 08 00 00 00       	mov    0x8,%eax
    44b5:	ba 40 00 00 00       	mov    $0x40,%edx
    44ba:	85 c0                	test   %eax,%eax
    44bc:	b8 00 00 00 00       	mov    $0x0,%eax
    44c1:	0f 45 d0             	cmovne %eax,%edx
    44c4:	ff 82 1c 00 00 00    	incl   0x1c(%edx)
    44ca:	e9 1b ff ff ff       	jmp    43ea <trickles_fin+0x3a>
    44cf:	90                   	nop    

000044d0 <tcp_copy_to_iovec>:

/* begin functions copied from tcp_input.c */
static int tcp_copy_to_iovec(struct sock *sk, struct sk_buff *skb, int hlen)
{
    44d0:	55                   	push   %ebp
    44d1:	89 e5                	mov    %esp,%ebp
    44d3:	83 ec 1c             	sub    $0x1c,%esp
    44d6:	89 5d f4             	mov    %ebx,0xfffffff4(%ebp)
    44d9:	8b 55 0c             	mov    0xc(%ebp),%edx
    44dc:	8b 4d 10             	mov    0x10(%ebp),%ecx
    44df:	89 7d fc             	mov    %edi,0xfffffffc(%ebp)
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
    44e2:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int chunk = skb->len - hlen;
	int err;

	local_bh_enable();
    44e5:	bf 08 00 00 00       	mov    $0x8,%edi
    44ea:	89 75 f8             	mov    %esi,0xfffffff8(%ebp)
    44ed:	8b 72 70             	mov    0x70(%edx),%esi
    44f0:	81 c3 bc 00 00 00    	add    $0xbc,%ebx
    44f6:	29 ce                	sub    %ecx,%esi
    44f8:	a1 08 00 00 00       	mov    0x8,%eax
    44fd:	48                   	dec    %eax
    44fe:	85 c0                	test   %eax,%eax
    4500:	a3 08 00 00 00       	mov    %eax,0x8
    4505:	75 0a                	jne    4511 <tcp_copy_to_iovec+0x41>
    4507:	83 7f f8 00          	cmpl   $0x0,0xfffffff8(%edi)
    450b:	0f 85 c4 51 00 00    	jne    96d5 <.text.lock.tmalloc+0x10>
	if (skb->ip_summed==CHECKSUM_UNNECESSARY)
    4511:	80 7a 7f 02          	cmpb   $0x2,0x7f(%edx)
    4515:	74 39                	je     4550 <tcp_copy_to_iovec+0x80>
		err = skb_copy_datagram_iovec(skb, hlen, tp->ucopy.iov, chunk);
	else
		err = skb_copy_and_csum_datagram_iovec(skb, hlen, tp->ucopy.iov);
    4517:	8b 43 44             	mov    0x44(%ebx),%eax
    451a:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    451e:	89 14 24             	mov    %edx,(%esp,1)
    4521:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    4525:	e8 fc ff ff ff       	call   4526 <tcp_copy_to_iovec+0x56>

	if (!err) {
    452a:	85 c0                	test   %eax,%eax
    452c:	75 09                	jne    4537 <tcp_copy_to_iovec+0x67>
		tp->ucopy.len -= chunk;
    452e:	29 73 4c             	sub    %esi,0x4c(%ebx)
		tp->copied_seq += chunk;
    4531:	01 b3 fc 00 00 00    	add    %esi,0xfc(%ebx)
	}

	local_bh_disable();
    4537:	ff 05 08 00 00 00    	incl   0x8
	return err;
}
    453d:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
    4540:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
    4543:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
    4546:	89 ec                	mov    %ebp,%esp
    4548:	5d                   	pop    %ebp
    4549:	c3                   	ret    
    454a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    4550:	89 74 24 0c          	mov    %esi,0xc(%esp,1)
    4554:	8b 43 44             	mov    0x44(%ebx),%eax
    4557:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    455b:	89 14 24             	mov    %edx,(%esp,1)
    455e:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    4562:	e8 fc ff ff ff       	call   4563 <tcp_copy_to_iovec+0x93>
    4567:	eb c1                	jmp    452a <tcp_copy_to_iovec+0x5a>
    4569:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi

00004570 <client_inseq>:

static inline void tcp_fast_path_queue(struct sock *sk, struct sk_buff *skb) {
	// derived from fast path code in tcp_input.c
	int eaten = 0;
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	int len = skb->len;
	int direct_copy = tp->ucopy.task == current &&
	    tp->copied_seq == tp->rcv_nxt &&
	    len <= tp->ucopy.len &&
	    sk->lock.users;

	TIMING_CTX_DEF0("fast_path_queue", "not direct copy", "direct copy");
	TIMING_CTX_DEF1(3,3);
	reinitTimingCtx(&ctx);
	direct_copy = direct_copy ? 1 : 0;
	recordSample(&ctx,direct_copy);

	if(len == 0) goto skip;

	if(!(tp->trickles_opt & TCP_TRICKLES_BUFFERDISCARD)) {
		if (direct_copy) {
			__set_current_state(TASK_RUNNING);

			if (!tcp_copy_to_iovec(sk, skb, 0)) {
				tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq;
				NET_INC_STATS_BH(TCPHPHitsToUser);
				eaten = 1;
			}
		}
		recordSample(&ctx,direct_copy);
		if (!eaten) {
			NET_INC_STATS_BH(TCPHPHits);

			/* Bulk data transfer: receiver */
			// 0418
			if(atomic_read(&skb_shinfo(skb)->dataref) != 1) {
				printk("refcnt != 1 when queuing for user delivery\n");
			}

			__skb_queue_tail(&sk->receive_queue, skb);
			tcp_set_owner_r(skb, sk);
			tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq;
			// print out error if we exceed by more than 12.5%
			if(tp->rcv_nxt > (sk->rcvbuf + tp->copied_seq + (sk->rcvbuf >> 2))) {
				if(!disableSevereErrors) 
					printk("exceeded constraint on rcvbuf by %d\n", tp->rcv_nxt - (sk->rcvbuf + tp->copied_seq));
			}
		}
	} else { 
		// TCP_TRICKLES_BUFFERDISCARD
		tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq;
		kfree_skb(skb);
	}
	recordSample(&ctx,direct_copy);
	sk_wake_async(sk, 0, POLL_IN);
	if(skb->h.th->fin) {
		trickles_fin(sk);
	}
	printTimings(&ctx);
 skip:
	if (eaten)
		__kfree_skb(skb);
	else
		sk->data_ready(sk, 0);
	return;
}
#endif // USERTEST

// TODO: use cleaner test
#define SKB_CONTAINS_DATA(SKB) (((SKB)->len > 0 || TCP_SKB_CB(SKB)->cont->ucont_len == 0) && TCP_SKB_CB(SKB)->position != INVALID_POSITION)
//#define SKB_CONTAINS_DATA(SKB) ((SKB)->len > 0)

static inline void client_inseq(struct sock *sk, struct sk_buff *skb, int noCont) {
    4570:	55                   	push   %ebp
    4571:	89 e5                	mov    %esp,%ebp
    4573:	57                   	push   %edi
    4574:	56                   	push   %esi
    4575:	53                   	push   %ebx
    4576:	83 ec 34             	sub    $0x34,%esp
    4579:	8b 45 08             	mov    0x8(%ebp),%eax
    457c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    457f:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    4582:	05 bc 00 00 00       	add    $0xbc,%eax
    4587:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	CONTINUATION_TYPE *cont = TCP_SKB_CB(skb)->cont;
    458a:	8b 73 5c             	mov    0x5c(%ebx),%esi
	unsigned transportSeq = cont->seq;
    458d:	8b 56 34             	mov    0x34(%esi),%edx
    4590:	89 55 e8             	mov    %edx,0xffffffe8(%ebp)

	// Perform state updates before queuing packet, for otherwise skb might disappear
	/* find matching continuation in ContList */
	if(!noCont) {
    4593:	8b 55 10             	mov    0x10(%ebp),%edx
    4596:	85 d2                	test   %edx,%edx
    4598:	75 46                	jne    45e0 <client_inseq+0x70>
		CONTINUATION_TYPE *cont;
		int found = 0;
		alloc_head_reverse_walk(&tp->t.cont_list, cont) {
    459a:	8b 90 20 0a 00 00    	mov    0xa20(%eax),%edx
    45a0:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    45a3:	31 ff                	xor    %edi,%edi
    45a5:	05 dc 0a 00 00       	add    $0xadc,%eax
    45aa:	39 c2                	cmp    %eax,%edx
    45ac:	74 21                	je     45cf <client_inseq+0x5f>
    45ae:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    45b1:	8b 88 dc 02 00 00    	mov    0x2dc(%eax),%ecx
    45b7:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    45ba:	05 dc 0a 00 00       	add    $0xadc,%eax
    45bf:	90                   	nop    
			if(cont->seq == tp->t.rcv_nxt) {
    45c0:	39 4a 34             	cmp    %ecx,0x34(%edx)
    45c3:	0f 84 2c 07 00 00    	je     4cf5 <client_inseq+0x785>
    45c9:	8b 12                	mov    (%edx),%edx
    45cb:	39 c2                	cmp    %eax,%edx
    45cd:	75 f1                	jne    45c0 <client_inseq+0x50>
				found = 1;
				UpdateClientTransportState(sk, skb, cont);
#ifdef ENABLE_HASHCOMPRESS
				if(cont->parentMSK) {
					cont->parentMSK->numChildrenReceived++;
				}
#endif
				// cannot continue looping after performing update, since list may have changed
				break;
			}
		}
		if(!found) {
    45cf:	85 ff                	test   %edi,%edi
    45d1:	75 0d                	jne    45e0 <client_inseq+0x70>
			if(clientDebugLevel >= 2) {
    45d3:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    45da:	0f 8f 04 07 00 00    	jg     4ce4 <client_inseq+0x774>
				printk("client_inseq: could not find transport level continuation to use for state update\n");
			}
		}
	}

	/* During retransmission, the association between transport
	   level sequence numbers and UC-level request numbers is
	   scrambled. Hence, client needs to perform a reordering on
	   UC requests */

	if(SKB_CONTAINS_DATA(skb)) {
    45e0:	8b 53 70             	mov    0x70(%ebx),%edx
    45e3:	85 d2                	test   %edx,%edx
    45e5:	75 0e                	jne    45f5 <client_inseq+0x85>
    45e7:	8b 43 5c             	mov    0x5c(%ebx),%eax
    45ea:	8b 40 7c             	mov    0x7c(%eax),%eax
    45ed:	85 c0                	test   %eax,%eax
    45ef:	0f 85 3f 04 00 00    	jne    4a34 <client_inseq+0x4c4>
    45f5:	80 7b 69 ff          	cmpb   $0xff,0x69(%ebx)
    45f9:	0f 84 35 04 00 00    	je     4a34 <client_inseq+0x4c4>
		if(cont->ucont_len > 0) {
    45ff:	8b 46 7c             	mov    0x7c(%esi),%eax
    4602:	85 c0                	test   %eax,%eax
    4604:	7e 13                	jle    4619 <client_inseq+0xa9>
			UpdateClientUCState(sk, skb, cont);
    4606:	89 74 24 08          	mov    %esi,0x8(%esp,1)
    460a:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    460e:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    4611:	89 14 24             	mov    %edx,(%esp,1)
    4614:	e8 b7 df ff ff       	call   25d0 <UpdateClientUCState>
		}

		BUG_TRAP(tp->t.ack_prev != cont); // 0429 track down corruption error
    4619:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    461c:	39 b1 f0 02 00 00    	cmp    %esi,0x2f0(%ecx)
    4622:	0f 84 f3 03 00 00    	je     4a1b <client_inseq+0x4ab>
  }
#endif // USERTEST
#endif // DEBUG_ALLOC

  if(cont->list) {
    4628:	8b 46 08             	mov    0x8(%esi),%eax
    462b:	85 c0                	test   %eax,%eax
    462d:	0f 85 ca 03 00 00    	jne    49fd <client_inseq+0x48d>
	  BUG();
  }

  for(i=0; i < 2; i++) {
    4633:	c7 45 e4 01 00 00 00 	movl   $0x1,0xffffffe4(%ebp)
    463a:	31 ff                	xor    %edi,%edi
    if((cont+i)->ucont_data)
    463c:	8b 84 3e 80 00 00 00 	mov    0x80(%esi,%edi,1),%eax
    4643:	85 c0                	test   %eax,%eax
    4645:	0f 85 a5 03 00 00    	jne    49f0 <client_inseq+0x480>
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
    464b:	8b 84 3e 88 00 00 00 	mov    0x88(%esi,%edi,1),%eax
    4652:	85 c0                	test   %eax,%eax
    4654:	0f 85 86 03 00 00    	jne    49e0 <client_inseq+0x470>
    465a:	81 c7 e4 00 00 00    	add    $0xe4,%edi
    4660:	ff 4d e4             	decl   0xffffffe4(%ebp)
    4663:	79 d7                	jns    463c <client_inseq+0xcc>
      kfree((cont+i)->input);
  }

#ifdef USERTEST
  kfree(cont);
#else  //0426 - change kernel to slab cache
#ifdef DEBUG_ALLOC
  zap_virt(cont);
  //memset(cont, 0x3e, sizeof(*cont));
#else
#ifndef USESLAB
  kfree(cont);  // 0502 maybe slab cache usage is buggy
#else
  kmem_cache_free(clientSideContinuation_cache, cont);
    4665:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    4669:	a1 00 00 00 00       	mov    0x0,%eax
    466e:	89 04 24             	mov    %eax,(%esp,1)
    4671:	e8 fc ff ff ff       	call   4672 <client_inseq+0x102>
		MARK_PC(cont);
		freeClientSide_Continuation(cont);
		TCP_SKB_CB(skb)->cont = NULL;

		if(skb->len == 0) goto drop;
    4676:	8b 53 70             	mov    0x70(%ebx),%edx
    4679:	c7 43 5c 00 00 00 00 	movl   $0x0,0x5c(%ebx)
    4680:	85 d2                	test   %edx,%edx
    4682:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
    4685:	0f 84 35 03 00 00    	je     49c0 <client_inseq+0x450>

		if(TCP_SKB_CB(skb)->byteNum > tp->rcv_nxt) {
    468b:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    468e:	8b 4b 60             	mov    0x60(%ebx),%ecx
    4691:	8b 46 08             	mov    0x8(%esi),%eax
    4694:	39 c1                	cmp    %eax,%ecx
    4696:	0f 86 45 01 00 00    	jbe    47e1 <client_inseq+0x271>
			struct sk_buff *finger, *next;
			/*
			  Enqueue in ofo queue
			 */
			TCP_SKB_CB(skb)->seq = TCP_SKB_CB(skb)->byteNum;
    469c:	89 4b 40             	mov    %ecx,0x40(%ebx)
			TCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(skb)->seq + skb->len;
    469f:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
 *	volatile. Use with caution.
 */
 
static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
{
    46a2:	89 f7                	mov    %esi,%edi
    46a4:	89 43 44             	mov    %eax,0x44(%ebx)
 *	volatile. Use with caution.
 */
 
static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
{
    46a7:	81 c7 5c 0a 00 00    	add    $0xa5c,%edi
	struct sk_buff *list = ((struct sk_buff *)list_)->next;
    46ad:	8b 86 5c 0a 00 00    	mov    0xa5c(%esi),%eax
	if (list == (struct sk_buff *)list_)
    46b3:	ba 00 00 00 00       	mov    $0x0,%edx
    46b8:	39 f8                	cmp    %edi,%eax
    46ba:	0f 44 c2             	cmove  %edx,%eax
    46bd:	85 c0                	test   %eax,%eax
    46bf:	0f 84 15 01 00 00    	je     47da <client_inseq+0x26a>
			if(skb_peek(&tp->t.data_ofo_queue)) {
				finger = tp->t.data_ofo_queue.prev;
    46c5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    46c8:	8b b0 60 0a 00 00    	mov    0xa60(%eax),%esi
    46ce:	89 c8                	mov    %ecx,%eax
				/* eliminate overlap later, when using elements from ofo queue */
				do {
				
					if(TCP_SKB_CB(finger)->seq < TCP_SKB_CB(skb)->seq) 
    46d0:	39 46 40             	cmp    %eax,0x40(%esi)
    46d3:	72 07                	jb     46dc <client_inseq+0x16c>
						break;
				} while((struct sk_buff_head*)(finger=finger->prev) != &tp->t.data_ofo_queue);
    46d5:	8b 76 04             	mov    0x4(%esi),%esi
    46d8:	39 fe                	cmp    %edi,%esi
    46da:	75 f4                	jne    46d0 <client_inseq+0x160>
			} else {
				finger = (struct sk_buff *)&tp->t.data_ofo_queue;
			}
			next = finger->next;
			if(finger != (struct sk_buff*)&tp->t.data_ofo_queue) {
    46dc:	39 fe                	cmp    %edi,%esi
    46de:	8b 0e                	mov    (%esi),%ecx
    46e0:	74 37                	je     4719 <client_inseq+0x1a9>
				int slack = TCP_SKB_CB(finger)->end_seq - TCP_SKB_CB(skb)->seq;
    46e2:	8b 56 44             	mov    0x44(%esi),%edx
    46e5:	8b 43 40             	mov    0x40(%ebx),%eax
    46e8:	29 c2                	sub    %eax,%edx
    46ea:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
				if(slack > 0) {
    46ed:	85 d2                	test   %edx,%edx
    46ef:	7e 28                	jle    4719 <client_inseq+0x1a9>
					if(slack >= skb->len) {
    46f1:	3b 55 e0             	cmp    0xffffffe0(%ebp),%edx
    46f4:	0f 83 d6 00 00 00    	jae    47d0 <client_inseq+0x260>
}

static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
	skb->len-=len;
    46fa:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    46fd:	29 d0                	sub    %edx,%eax
	if (skb->len < skb->data_len)
    46ff:	3b 43 74             	cmp    0x74(%ebx),%eax
    4702:	89 43 70             	mov    %eax,0x70(%ebx)
    4705:	0f 82 07 06 00 00    	jb     4d12 <client_inseq+0x7a2>
		out_of_line_bug();
    470b:	01 93 94 00 00 00    	add    %edx,0x94(%ebx)
						// completely covered by old packet
						__kfree_skb(skb);
						// 0717 Trying to increase efficiency
						if(0 && trickles_ratelimit()) {
							printk("New packet completely covered by old packet\n");
						}
						goto skip_ofo_insert;
					} else {
						skb_pull(skb, slack);
						TCP_SKB_CB(skb)->seq += slack;
    4711:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    4714:	01 d0                	add    %edx,%eax
    4716:	89 43 40             	mov    %eax,0x40(%ebx)
						// 0717 Trying to increase efficiency
						if(0 && trickles_ratelimit()) {
							printk("New packet overlapped old packet by %d\n", slack);
						}
					}
				}
			}
			if(next != (struct sk_buff*)&tp->t.data_ofo_queue) {
    4719:	39 f9                	cmp    %edi,%ecx
    471b:	74 4a                	je     4767 <client_inseq+0x1f7>
				int slack = TCP_SKB_CB(skb)->end_seq - TCP_SKB_CB(next)->seq;
    471d:	8b 53 44             	mov    0x44(%ebx),%edx
    4720:	8b 41 40             	mov    0x40(%ecx),%eax
    4723:	29 c2                	sub    %eax,%edx
    4725:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
				if(slack > 0) {
    4728:	85 d2                	test   %edx,%edx
    472a:	7e 3b                	jle    4767 <client_inseq+0x1f7>
					if(slack >= next->len) {
    472c:	8b 41 70             	mov    0x70(%ecx),%eax
    472f:	39 c2                	cmp    %eax,%edx
    4731:	72 79                	jb     47ac <client_inseq+0x23c>
static inline void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
{
	struct sk_buff * next, * prev;

	list->qlen--;
    4733:	ff 4f 08             	decl   0x8(%edi)
	next = skb->next;
	prev = skb->prev;
	skb->next = NULL;
	skb->prev = NULL;
	skb->list = NULL;
    4736:	c7 41 08 00 00 00 00 	movl   $0x0,0x8(%ecx)
    473d:	8b 11                	mov    (%ecx),%edx
    473f:	8b 41 04             	mov    0x4(%ecx),%eax
    4742:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
    4748:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
	next->prev = prev;
	prev->next = next;
    474f:	89 10                	mov    %edx,(%eax)
    4751:	89 42 04             	mov    %eax,0x4(%edx)
						// completely covered by new packet
						__skb_unlink(next, &tp->t.data_ofo_queue);
						if(tp->t.byteReqHint == next)
    4754:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    4757:	39 8a bc 0a 00 00    	cmp    %ecx,0xabc(%edx)
    475d:	74 43                	je     47a2 <client_inseq+0x232>
							tp->t.byteReqHint = NULL;
						// 0717 Trying to increase efficiency
						if(0 && trickles_ratelimit()) {
							printk("Old packet completely covered by old packet\n");
						}
						__kfree_skb(next);
    475f:	89 0c 24             	mov    %ecx,(%esp,1)
    4762:	e8 fc ff ff ff       	call   4763 <client_inseq+0x1f3>
	struct sk_buff * prev, struct sk_buff *next,
	struct sk_buff_head * list)
{
	newsk->next = next;
	newsk->prev = prev;
    4767:	89 73 04             	mov    %esi,0x4(%ebx)
    476a:	8b 06                	mov    (%esi),%eax
    476c:	89 03                	mov    %eax,(%ebx)
	next->prev = newsk;
    476e:	89 58 04             	mov    %ebx,0x4(%eax)
	prev->next = newsk;
    4771:	89 1e                	mov    %ebx,(%esi)
	newsk->list = list;
    4773:	89 7b 08             	mov    %edi,0x8(%ebx)
	list->qlen++;
    4776:	ff 47 08             	incl   0x8(%edi)
					} else {
						skb_pull(next, slack);
						TCP_SKB_CB(next)->seq += slack;
						// 0717 Trying to increase efficiency
						if(0 && trickles_ratelimit()) {
							printk("Old packet overlapped new packet by %d\n", slack);
						}
					}
				}
			}
			__skb_insert(skb, finger, finger->next, &tp->t.data_ofo_queue);
		skip_ofo_insert:
			goto done_processing;
		}
		if(TCP_SKB_CB(skb)->byteNum < tp->rcv_nxt) {
			int slack = tp->rcv_nxt - TCP_SKB_CB(skb)->byteNum;
			if(slack >= skb->len) {
				if(clientDebugLevel >= 2)
					printk("ByteNum < tp->rcv_nxt and no overlap; discarding\n");
				__kfree_skb(skb);
				goto done_processing;
			} else {
				__skb_pull(skb, slack);
				TCP_SKB_CB(skb)->byteNum += slack;
			}
		}
		if(skb->len == 0) {
			__kfree_skb(skb);
			goto done_processing;
		}
		BUG_TRAP(TCP_SKB_CB(skb)->byteNum == tp->rcv_nxt);
		TCP_SKB_CB(skb)->seq = tp->rcv_nxt;
		TCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(skb)->seq + skb->len;
		while(1) {
		queue_next_packet:
			/* TODO: This code trusts that only client actions generate
			   packets. Add windowsize check to prevent attackers from
			   overflowing window */

			BUG_TRAP(skb->len > 0);

#ifndef USERTEST
			tcp_fast_path_queue(sk, skb);
#else
			tcp_data_queue(sk, skb);
#endif // USERTEST
			if(tp->t.byteReqHint == skb)
				tp->t.byteReqHint = NULL;

			while((skb = skb_peek(&tp->t.data_ofo_queue))) {
				if(TCP_SKB_CB(skb)->seq > tp->rcv_nxt) {
					goto data_done;
				}
				__skb_unlink(skb, &tp->t.data_ofo_queue);
				if(tp->t.byteReqHint == skb)
					tp->t.byteReqHint = NULL;

				if(TCP_SKB_CB(skb)->end_seq <= tp->rcv_nxt) {
					if(printOverlap)
						printk("IN SEQUENCE WHOLE PACKET REMOVED: %d\n", skb->len);
					__kfree_skb(skb);
				} else {
					int slack = tp->rcv_nxt - TCP_SKB_CB(skb)->seq;
					__skb_pull(skb, slack);
					TCP_SKB_CB(skb)->seq += slack;
					BUG_TRAP(TCP_SKB_CB(skb)->seq == tp->rcv_nxt &&
						 skb->len > 0);
					if(slack) {
						// 0426 - overlap should rarely occur since they are eliminated when inserting in the ofo data queue
						if(printOverlap)
							printk("IN SEQUENCE SLACK REMOVED: %d\n", slack);
					}
					goto queue_next_packet;
				}
			}
			// only reach this point if no suitable packet found
			break;
		}
	data_done: // jump to data_done if rcv_nxt was updated
		/* Remove obsolete missingDataMap and dataRequestMap entries */
		// 0505 - moved to common code path
		;
	} else {
		if((cont->ucont_len == 0 && skb->len == 0) ||
		   TCP_SKB_CB(skb)->parent < tp->t.request_rcv_nxt) {
			if(TCP_SKB_CB(skb)->parent < tp->t.request_rcv_nxt) {
				//printk("UC-obsolete packet\n");
			}
			BUG_TRAP(tp->t.ack_prev != cont); // 0429 track down corruption error
			MARK_PC(cont);
			freeClientSide_Continuation(cont);
			__kfree_skb(skb);
			goto done_processing;
		}
		if(TCP_SKB_CB(skb)->parent == INVALID_REQNUM) {
			goto drop;
		}
		BUG_TRAP(TCP_SKB_CB(skb)->parent != INVALID_REQNUM);

		if(TCP_SKB_CB(skb)->parent == tp->t.request_rcv_nxt) {
			for(;;) {
				cont = TCP_SKB_CB(skb)->cont;
#ifndef TEST_TRANSPORT_ONLY
				UpdateClientUCState(sk, skb, cont);
#endif
				// deallocation of skb->cont must occur after references in the above block
				BUG_TRAP(tp->t.ack_prev != cont); // 0429 track down corruption error
				MARK_PC(cont);
				freeClientSide_Continuation(cont);
				// request_rcv_nxt is updated in updateParent
				skb = skb_peek(&tp->t.request_ofo_queue);
				if(skb == NULL || TCP_SKB_CB(skb)->parent != tp->t.request_rcv_nxt) {
					break;
				}
				__skb_dequeue(&tp->t.request_ofo_queue);
			}
		} else {
			/* enqueue in request_ofo_queue */
			struct sk_buff *finger;
			BUG_TRAP(TCP_SKB_CB(skb)->parent > tp->t.request_rcv_nxt);
			if(skb_queue_empty(&tp->t.request_ofo_queue)) {
				__skb_queue_head(&tp->t.request_ofo_queue, skb);
				goto done_queuing;
			} else { // 0418  changed from else if(TCP_SKB_CB(finger)->parent) to else
				finger = tp->t.request_ofo_queue.prev;
				do {
					if(TCP_SKB_CB(finger)->parent < TCP_SKB_CB(skb)->parent) 
						break;
				} while((struct sk_buff_head*)(finger=finger->prev) != &tp->t.request_ofo_queue);
				if(finger->next != (struct sk_buff*)&tp->t.request_ofo_queue) {
					if(TCP_SKB_CB(finger->next)->parent == TCP_SKB_CB(skb)->parent) {
						__kfree_skb(skb);
						goto done_queuing;
					}
					BUG_TRAP(TCP_SKB_CB(finger->next)->parent > 
						 TCP_SKB_CB(skb)->parent);
				}
				__skb_insert(skb, finger, finger->next, &tp->t.request_ofo_queue);
			}
		done_queuing:
			;
		}
	}
 done_processing:
	/* Clean out stuff just rendered obsolete */
	removeObsoleteDataRequestMaps(sk, transportSeq);  // moved out of data-only path, so that it executes unconditionally
    4779:	8b 75 e8             	mov    0xffffffe8(%ebp),%esi
    477c:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    4780:	8b 7d f0             	mov    0xfffffff0(%ebp),%edi
    4783:	89 3c 24             	mov    %edi,(%esp,1)
    4786:	e8 c5 47 00 00       	call   8f50 <removeObsoleteDataRequestMaps>
	removeObsoleteContinuations(sk);
    478b:	89 3c 24             	mov    %edi,(%esp,1)
    478e:	e8 fc ff ff ff       	call   478f <client_inseq+0x21f>
	removeObsoleteDependencies(sk);
    4793:	89 7d 08             	mov    %edi,0x8(%ebp)
    4796:	83 c4 34             	add    $0x34,%esp
    4799:	5b                   	pop    %ebx
    479a:	5e                   	pop    %esi
    479b:	5f                   	pop    %edi
    479c:	5d                   	pop    %ebp
    479d:	e9 fc ff ff ff       	jmp    479e <client_inseq+0x22e>
    47a2:	31 c0                	xor    %eax,%eax
    47a4:	89 82 bc 0a 00 00    	mov    %eax,0xabc(%edx)
    47aa:	eb b3                	jmp    475f <client_inseq+0x1ef>
}

static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
	skb->len-=len;
    47ac:	29 d0                	sub    %edx,%eax
	if (skb->len < skb->data_len)
    47ae:	3b 41 74             	cmp    0x74(%ecx),%eax
    47b1:	89 41 70             	mov    %eax,0x70(%ecx)
    47b4:	0f 82 58 05 00 00    	jb     4d12 <client_inseq+0x7a2>
		out_of_line_bug();
    47ba:	01 91 94 00 00 00    	add    %edx,0x94(%ecx)
    47c0:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    47c3:	01 d0                	add    %edx,%eax
    47c5:	89 41 40             	mov    %eax,0x40(%ecx)
    47c8:	eb 9d                	jmp    4767 <client_inseq+0x1f7>
    47ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    47d0:	89 1c 24             	mov    %ebx,(%esp,1)
    47d3:	e8 fc ff ff ff       	call   47d4 <client_inseq+0x264>
    47d8:	eb 9f                	jmp    4779 <client_inseq+0x209>
    47da:	89 fe                	mov    %edi,%esi
    47dc:	e9 fb fe ff ff       	jmp    46dc <client_inseq+0x16c>
    47e1:	39 c1                	cmp    %eax,%ecx
    47e3:	73 37                	jae    481c <client_inseq+0x2ac>
    47e5:	29 c8                	sub    %ecx,%eax
    47e7:	39 d0                	cmp    %edx,%eax
    47e9:	72 17                	jb     4802 <client_inseq+0x292>
    47eb:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    47f2:	7e dc                	jle    47d0 <client_inseq+0x260>
    47f4:	c7 04 24 40 19 00 00 	movl   $0x1940,(%esp,1)
    47fb:	e8 fc ff ff ff       	call   47fc <client_inseq+0x28c>
    4800:	eb ce                	jmp    47d0 <client_inseq+0x260>
}

static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
	skb->len-=len;
    4802:	29 c2                	sub    %eax,%edx
	if (skb->len < skb->data_len)
    4804:	3b 53 74             	cmp    0x74(%ebx),%edx
    4807:	89 53 70             	mov    %edx,0x70(%ebx)
    480a:	0f 82 02 05 00 00    	jb     4d12 <client_inseq+0x7a2>
		out_of_line_bug();
    4810:	01 83 94 00 00 00    	add    %eax,0x94(%ebx)
    4816:	8d 04 08             	lea    (%eax,%ecx,1),%eax
    4819:	89 43 60             	mov    %eax,0x60(%ebx)
    481c:	85 d2                	test   %edx,%edx
    481e:	74 b0                	je     47d0 <client_inseq+0x260>
    4820:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    4823:	8b 41 08             	mov    0x8(%ecx),%eax
    4826:	39 43 60             	cmp    %eax,0x60(%ebx)
    4829:	74 1d                	je     4848 <client_inseq+0x2d8>
    482b:	c7 44 24 04 85 0b 00 	movl   $0xb85,0x4(%esp,1)
    4832:	00 
    4833:	c7 04 24 80 19 00 00 	movl   $0x1980,(%esp,1)
    483a:	e8 fc ff ff ff       	call   483b <client_inseq+0x2cb>
    483f:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    4842:	8b 53 70             	mov    0x70(%ebx),%edx
    4845:	8b 46 08             	mov    0x8(%esi),%eax
    4848:	89 43 40             	mov    %eax,0x40(%ebx)
    484b:	01 d0                	add    %edx,%eax
    484d:	89 43 44             	mov    %eax,0x44(%ebx)
    4850:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    4853:	8d b8 5c 0a 00 00    	lea    0xa5c(%eax),%edi
    4859:	85 d2                	test   %edx,%edx
    485b:	0f 84 40 01 00 00    	je     49a1 <client_inseq+0x431>
    4861:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    4865:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    4868:	89 14 24             	mov    %edx,(%esp,1)
    486b:	e8 40 4c 00 00       	call   94b0 <tcp_fast_path_queue>
    4870:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    4873:	39 99 bc 0a 00 00    	cmp    %ebx,0xabc(%ecx)
    4879:	0f 84 15 01 00 00    	je     4994 <client_inseq+0x424>
    487f:	90                   	nop    
 */
 
static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
{
	struct sk_buff *list = ((struct sk_buff *)list_)->next;
    4880:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
	if (list == (struct sk_buff *)list_)
    4883:	31 db                	xor    %ebx,%ebx
    4885:	8b b2 5c 0a 00 00    	mov    0xa5c(%edx),%esi
    488b:	39 fe                	cmp    %edi,%esi
    488d:	0f 45 de             	cmovne %esi,%ebx
    4890:	85 db                	test   %ebx,%ebx
    4892:	89 de                	mov    %ebx,%esi
    4894:	0f 84 df fe ff ff    	je     4779 <client_inseq+0x209>
    489a:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    489d:	8b 42 08             	mov    0x8(%edx),%eax
    48a0:	39 43 40             	cmp    %eax,0x40(%ebx)
    48a3:	0f 87 d0 fe ff ff    	ja     4779 <client_inseq+0x209>
static inline void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
{
	struct sk_buff * next, * prev;

	list->qlen--;
    48a9:	ff 4f 08             	decl   0x8(%edi)
	next = skb->next;
	prev = skb->prev;
	skb->next = NULL;
	skb->prev = NULL;
	skb->list = NULL;
    48ac:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    48b3:	8b 13                	mov    (%ebx),%edx
    48b5:	8b 43 04             	mov    0x4(%ebx),%eax
    48b8:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    48be:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	next->prev = prev;
	prev->next = next;
    48c5:	89 10                	mov    %edx,(%eax)
    48c7:	89 42 04             	mov    %eax,0x4(%edx)
    48ca:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    48cd:	39 99 bc 0a 00 00    	cmp    %ebx,0xabc(%ecx)
    48d3:	0f 84 ae 00 00 00    	je     4987 <client_inseq+0x417>
    48d9:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    48dc:	8b 50 08             	mov    0x8(%eax),%edx
    48df:	39 53 44             	cmp    %edx,0x44(%ebx)
    48e2:	77 29                	ja     490d <client_inseq+0x39d>
    48e4:	8b 35 00 00 00 00    	mov    0x0,%esi
    48ea:	85 f6                	test   %esi,%esi
    48ec:	75 0a                	jne    48f8 <client_inseq+0x388>
    48ee:	89 1c 24             	mov    %ebx,(%esp,1)
    48f1:	e8 fc ff ff ff       	call   48f2 <client_inseq+0x382>
    48f6:	eb 88                	jmp    4880 <client_inseq+0x310>
    48f8:	8b 43 70             	mov    0x70(%ebx),%eax
    48fb:	c7 04 24 e0 19 00 00 	movl   $0x19e0,(%esp,1)
    4902:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    4906:	e8 fc ff ff ff       	call   4907 <client_inseq+0x397>
    490b:	eb e1                	jmp    48ee <client_inseq+0x37e>
    490d:	8b 43 40             	mov    0x40(%ebx),%eax
    4910:	29 c2                	sub    %eax,%edx
    4912:	89 55 d4             	mov    %edx,0xffffffd4(%ebp)
}

static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
	skb->len-=len;
    4915:	8b 53 70             	mov    0x70(%ebx),%edx
    4918:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
    491b:	29 ca                	sub    %ecx,%edx
	if (skb->len < skb->data_len)
    491d:	3b 53 74             	cmp    0x74(%ebx),%edx
    4920:	89 53 70             	mov    %edx,0x70(%ebx)
    4923:	0f 82 e9 03 00 00    	jb     4d12 <client_inseq+0x7a2>
    4929:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
    492c:	01 8b 94 00 00 00    	add    %ecx,0x94(%ebx)
    4932:	01 c8                	add    %ecx,%eax
    4934:	89 43 40             	mov    %eax,0x40(%ebx)
    4937:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    493a:	3b 41 08             	cmp    0x8(%ecx),%eax
    493d:	74 42                	je     4981 <client_inseq+0x411>
    493f:	c7 44 24 04 a9 0b 00 	movl   $0xba9,0x4(%esp,1)
    4946:	00 
    4947:	c7 04 24 20 1a 00 00 	movl   $0x1a20,(%esp,1)
    494e:	e8 fc ff ff ff       	call   494f <client_inseq+0x3df>
    4953:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
    4956:	85 c9                	test   %ecx,%ecx
    4958:	75 08                	jne    4962 <client_inseq+0x3f2>
    495a:	8b 56 70             	mov    0x70(%esi),%edx
    495d:	e9 f7 fe ff ff       	jmp    4859 <client_inseq+0x2e9>
    4962:	8b 15 00 00 00 00    	mov    0x0,%edx
    4968:	85 d2                	test   %edx,%edx
    496a:	74 ee                	je     495a <client_inseq+0x3ea>
    496c:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    496f:	c7 04 24 a0 1a 00 00 	movl   $0x1aa0,(%esp,1)
    4976:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    497a:	e8 fc ff ff ff       	call   497b <client_inseq+0x40b>
    497f:	eb d9                	jmp    495a <client_inseq+0x3ea>
    4981:	85 d2                	test   %edx,%edx
    4983:	75 ce                	jne    4953 <client_inseq+0x3e3>
    4985:	eb b8                	jmp    493f <client_inseq+0x3cf>
    4987:	31 c0                	xor    %eax,%eax
    4989:	89 81 bc 0a 00 00    	mov    %eax,0xabc(%ecx)
    498f:	e9 45 ff ff ff       	jmp    48d9 <client_inseq+0x369>
    4994:	31 c0                	xor    %eax,%eax
    4996:	89 81 bc 0a 00 00    	mov    %eax,0xabc(%ecx)
    499c:	e9 df fe ff ff       	jmp    4880 <client_inseq+0x310>
    49a1:	c7 44 24 04 8e 0b 00 	movl   $0xb8e,0x4(%esp,1)
    49a8:	00 
    49a9:	c7 04 24 c0 1a 00 00 	movl   $0x1ac0,(%esp,1)
    49b0:	e8 fc ff ff ff       	call   49b1 <client_inseq+0x441>
    49b5:	e9 a7 fe ff ff       	jmp    4861 <client_inseq+0x2f1>
    49ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	return;
 drop:
	if(TCP_SKB_CB(skb)->cont) {
    49c0:	8b 43 5c             	mov    0x5c(%ebx),%eax
    49c3:	85 c0                	test   %eax,%eax
    49c5:	75 0f                	jne    49d6 <client_inseq+0x466>
		kfree(TCP_SKB_CB(skb)->cont);
	}
	__kfree_skb(skb);
    49c7:	89 5d 08             	mov    %ebx,0x8(%ebp)
    49ca:	83 c4 34             	add    $0x34,%esp
    49cd:	5b                   	pop    %ebx
    49ce:	5e                   	pop    %esi
    49cf:	5f                   	pop    %edi
    49d0:	5d                   	pop    %ebp
    49d1:	e9 fc ff ff ff       	jmp    49d2 <client_inseq+0x462>
    49d6:	89 04 24             	mov    %eax,(%esp,1)
    49d9:	e8 fc ff ff ff       	call   49da <client_inseq+0x46a>
    49de:	eb e7                	jmp    49c7 <client_inseq+0x457>
  for(i=0; i < 2; i++) {
    if((cont+i)->ucont_data)
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
      kfree((cont+i)->input);
    49e0:	89 04 24             	mov    %eax,(%esp,1)
    49e3:	e8 fc ff ff ff       	call   49e4 <client_inseq+0x474>
    49e8:	e9 6d fc ff ff       	jmp    465a <client_inseq+0xea>
    49ed:	8d 76 00             	lea    0x0(%esi),%esi
    49f0:	89 04 24             	mov    %eax,(%esp,1)
    49f3:	e8 fc ff ff ff       	call   49f4 <client_inseq+0x484>
    49f8:	e9 4e fc ff ff       	jmp    464b <client_inseq+0xdb>
    49fd:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    4a04:	00 
    4a05:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    4a0c:	e8 fc ff ff ff       	call   4a0d <client_inseq+0x49d>
    4a11:	e8 fc ff ff ff       	call   4a12 <client_inseq+0x4a2>
    4a16:	e9 18 fc ff ff       	jmp    4633 <client_inseq+0xc3>
    4a1b:	c7 44 24 04 2b 0b 00 	movl   $0xb2b,0x4(%esp,1)
    4a22:	00 
    4a23:	c7 04 24 00 1b 00 00 	movl   $0x1b00,(%esp,1)
    4a2a:	e8 fc ff ff ff       	call   4a2b <client_inseq+0x4bb>
    4a2f:	e9 f4 fb ff ff       	jmp    4628 <client_inseq+0xb8>
    4a34:	8b 46 7c             	mov    0x7c(%esi),%eax
    4a37:	85 c0                	test   %eax,%eax
    4a39:	75 04                	jne    4a3f <client_inseq+0x4cf>
    4a3b:	85 d2                	test   %edx,%edx
    4a3d:	74 14                	je     4a53 <client_inseq+0x4e3>
    4a3f:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
    4a42:	8b 43 64             	mov    0x64(%ebx),%eax
    4a45:	8b 97 48 0a 00 00    	mov    0xa48(%edi),%edx
    4a4b:	39 d0                	cmp    %edx,%eax
    4a4d:	0f 83 9a 00 00 00    	jae    4aed <client_inseq+0x57d>
    4a53:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    4a56:	39 b0 f0 02 00 00    	cmp    %esi,0x2f0(%eax)
    4a5c:	74 76                	je     4ad4 <client_inseq+0x564>
  }
#endif // USERTEST
#endif // DEBUG_ALLOC

  if(cont->list) {
    4a5e:	8b 46 08             	mov    0x8(%esi),%eax
    4a61:	85 c0                	test   %eax,%eax
    4a63:	75 54                	jne    4ab9 <client_inseq+0x549>
	  BUG();
  }

  for(i=0; i < 2; i++) {
    4a65:	c7 45 d0 01 00 00 00 	movl   $0x1,0xffffffd0(%ebp)
    4a6c:	31 ff                	xor    %edi,%edi
    if((cont+i)->ucont_data)
    4a6e:	8b 84 3e 80 00 00 00 	mov    0x80(%esi,%edi,1),%eax
    4a75:	85 c0                	test   %eax,%eax
    4a77:	75 36                	jne    4aaf <client_inseq+0x53f>
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
    4a79:	8b 84 3e 88 00 00 00 	mov    0x88(%esi,%edi,1),%eax
    4a80:	85 c0                	test   %eax,%eax
    4a82:	75 21                	jne    4aa5 <client_inseq+0x535>
    4a84:	81 c7 e4 00 00 00    	add    $0xe4,%edi
    4a8a:	ff 4d d0             	decl   0xffffffd0(%ebp)
    4a8d:	79 df                	jns    4a6e <client_inseq+0x4fe>
      kfree((cont+i)->input);
  }

#ifdef USERTEST
  kfree(cont);
#else  //0426 - change kernel to slab cache
#ifdef DEBUG_ALLOC
  zap_virt(cont);
  //memset(cont, 0x3e, sizeof(*cont));
#else
#ifndef USESLAB
  kfree(cont);  // 0502 maybe slab cache usage is buggy
#else
  kmem_cache_free(clientSideContinuation_cache, cont);
    4a8f:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    4a93:	a1 00 00 00 00       	mov    0x0,%eax
    4a98:	89 04 24             	mov    %eax,(%esp,1)
    4a9b:	e8 fc ff ff ff       	call   4a9c <client_inseq+0x52c>
    4aa0:	e9 2b fd ff ff       	jmp    47d0 <client_inseq+0x260>
  for(i=0; i < 2; i++) {
    if((cont+i)->ucont_data)
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
      kfree((cont+i)->input);
    4aa5:	89 04 24             	mov    %eax,(%esp,1)
    4aa8:	e8 fc ff ff ff       	call   4aa9 <client_inseq+0x539>
    4aad:	eb d5                	jmp    4a84 <client_inseq+0x514>
    4aaf:	89 04 24             	mov    %eax,(%esp,1)
    4ab2:	e8 fc ff ff ff       	call   4ab3 <client_inseq+0x543>
    4ab7:	eb c0                	jmp    4a79 <client_inseq+0x509>
    4ab9:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    4ac0:	00 
    4ac1:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    4ac8:	e8 fc ff ff ff       	call   4ac9 <client_inseq+0x559>
    4acd:	e8 fc ff ff ff       	call   4ace <client_inseq+0x55e>
    4ad2:	eb 91                	jmp    4a65 <client_inseq+0x4f5>
    4ad4:	c7 44 24 04 bf 0b 00 	movl   $0xbbf,0x4(%esp,1)
    4adb:	00 
    4adc:	c7 04 24 00 1b 00 00 	movl   $0x1b00,(%esp,1)
    4ae3:	e8 fc ff ff ff       	call   4ae4 <client_inseq+0x574>
    4ae8:	e9 71 ff ff ff       	jmp    4a5e <client_inseq+0x4ee>
    4aed:	83 f8 ff             	cmp    $0xffffffff,%eax
    4af0:	0f 84 ca fe ff ff    	je     49c0 <client_inseq+0x450>
    4af6:	39 d0                	cmp    %edx,%eax
    4af8:	0f 84 b1 00 00 00    	je     4baf <client_inseq+0x63f>
    4afe:	39 d0                	cmp    %edx,%eax
    4b00:	0f 86 90 00 00 00    	jbe    4b96 <client_inseq+0x626>
 *	Returns true if the queue is empty, false otherwise.
 */
 
static inline int skb_queue_empty(struct sk_buff_head *list)
{
    4b06:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
    4b09:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    4b0c:	81 c7 50 0a 00 00    	add    $0xa50,%edi
    4b12:	39 b8 50 0a 00 00    	cmp    %edi,0xa50(%eax)
    4b18:	75 22                	jne    4b3c <client_inseq+0x5cc>
	return (list->next == (struct sk_buff *) list);
}

/**
 *	skb_get - reference buffer
 *	@skb: buffer to reference
 *
 *	Makes another reference to a socket buffer and returns a pointer
 *	to the buffer.
 */
 
static inline struct sk_buff *skb_get(struct sk_buff *skb)
{
	atomic_inc(&skb->users);
	return skb;
}

/*
 * If users==1, we are the only owner and are can avoid redundant
 * atomic change.
 */
 
/**
 *	kfree_skb - free an sk_buff
 *	@skb: buffer to free
 *
 *	Drop a reference to the buffer and free it if the usage count has
 *	hit zero.
 */
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
		__kfree_skb(skb);
}

/* Use this if you didn't touch the skb state [for fast switching] */
static inline void kfree_skb_fast(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
		kfree_skbmem(skb);	
}

/**
 *	skb_cloned - is the buffer a clone
 *	@skb: buffer to check
 *
 *	Returns true if the buffer was generated with skb_clone() and is
 *	one of multiple shared copies of the buffer. Cloned buffers are
 *	shared data so must not be written to under normal circumstances.
 */

static inline int skb_cloned(struct sk_buff *skb)
{
	return skb->cloned && atomic_read(&skb_shinfo(skb)->dataref) != 1;
}

/**
 *	skb_shared - is the buffer shared
 *	@skb: buffer to check
 *
 *	Returns true if more than one person has a reference to this
 *	buffer.
 */
 
static inline int skb_shared(struct sk_buff *skb)
{
	return (atomic_read(&skb->users) != 1);
}

/** 
 *	skb_share_check - check if buffer is shared and if so clone it
 *	@skb: buffer to check
 *	@pri: priority for memory allocation
 *	
 *	If the buffer is shared the buffer is cloned and the old copy
 *	drops a reference. A new clone with a single reference is returned.
 *	If the buffer is not shared the original buffer is returned. When
 *	being called from interrupt status or with spinlocks held pri must
 *	be GFP_ATOMIC.
 *
 *	NULL is returned on a memory allocation failure.
 */
 
static inline struct sk_buff *skb_share_check(struct sk_buff *skb, int pri)
{
	if (skb_shared(skb)) {
		struct sk_buff *nskb;
		nskb = skb_clone(skb, pri);
		kfree_skb(skb);
		return nskb;
	}
	return skb;
}


/*
 *	Copy shared buffers into a new sk_buff. We effectively do COW on
 *	packets to handle cases where we have a local reader and forward
 *	and a couple of other messy ones. The normal one is tcpdumping
 *	a packet thats being forwarded.
 */
 
/**
 *	skb_unshare - make a copy of a shared buffer
 *	@skb: buffer to check
 *	@pri: priority for memory allocation
 *
 *	If the socket buffer is a clone then this function creates a new
 *	copy of the data, drops a reference count on the old copy and returns
 *	the new copy with the reference count at 1. If the buffer is not a clone
 *	the original buffer is returned. When called with a spinlock held or
 *	from interrupt state @pri must be %GFP_ATOMIC
 *
 *	%NULL is returned on a memory allocation failure.
 */
 
static inline struct sk_buff *skb_unshare(struct sk_buff *skb, int pri)
{
	struct sk_buff *nskb;
	if(!skb_cloned(skb))
		return skb;
	nskb=skb_copy(skb, pri);
	kfree_skb(skb);		/* Free our shared copy */
	return nskb;
}

/**
 *	skb_peek
 *	@list_: list to peek at
 *
 *	Peek an &sk_buff. Unlike most other operations you _MUST_
 *	be careful with this one. A peek leaves the buffer on the
 *	list and someone else may run off with it. You must hold
 *	the appropriate locks or have a private queue to do this.
 *
 *	Returns %NULL for an empty list or a pointer to the head element.
 *	The reference count is not incremented and the reference is therefore
 *	volatile. Use with caution.
 */
 
static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
{
	struct sk_buff *list = ((struct sk_buff *)list_)->next;
	if (list == (struct sk_buff *)list_)
		list = NULL;
	return list;
}

/**
 *	skb_peek_tail
 *	@list_: list to peek at
 *
 *	Peek an &sk_buff. Unlike most other operations you _MUST_
 *	be careful with this one. A peek leaves the buffer on the
 *	list and someone else may run off with it. You must hold
 *	the appropriate locks or have a private queue to do this.
 *
 *	Returns %NULL for an empty list or a pointer to the tail element.
 *	The reference count is not incremented and the reference is therefore
 *	volatile. Use with caution.
 */

static inline struct sk_buff *skb_peek_tail(struct sk_buff_head *list_)
{
	struct sk_buff *list = ((struct sk_buff *)list_)->prev;
	if (list == (struct sk_buff *)list_)
		list = NULL;
	return list;
}

/**
 *	skb_queue_len	- get queue length
 *	@list_: list to measure
 *
 *	Return the length of an &sk_buff queue. 
 */
 
static inline __u32 skb_queue_len(struct sk_buff_head *list_)
{
	return(list_->qlen);
}

static inline void skb_queue_head_init(struct sk_buff_head *list)
{
	spin_lock_init(&list->lock);
	list->prev = (struct sk_buff *)list;
	list->next = (struct sk_buff *)list;
	list->qlen = 0;
}

/*
 *	Insert an sk_buff at the start of a list.
 *
 *	The "__skb_xxxx()" functions are the non-atomic ones that
 *	can only be called with interrupts disabled.
 */

/**
 *	__skb_queue_head - queue a buffer at the list head
 *	@list: list to use
 *	@newsk: buffer to queue
 *
 *	Queue a buffer at the start of a list. This function takes no locks
 *	and you must therefore hold required locks before calling it.
 *
 *	A buffer cannot be placed on two lists at the same time.
 */	
 
static inline void __skb_queue_head(struct sk_buff_head *list, struct sk_buff *newsk)
{
	struct sk_buff *prev, *next;

	newsk->list = list;
    4b1a:	89 7b 08             	mov    %edi,0x8(%ebx)
	list->qlen++;
    4b1d:	ff 47 08             	incl   0x8(%edi)
	prev = (struct sk_buff *)list;
	next = prev->next;
    4b20:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
	newsk->next = next;
	newsk->prev = prev;
    4b23:	89 7b 04             	mov    %edi,0x4(%ebx)
    4b26:	8b 82 50 0a 00 00    	mov    0xa50(%edx),%eax
    4b2c:	89 03                	mov    %eax,(%ebx)
	next->prev = newsk;
    4b2e:	89 58 04             	mov    %ebx,0x4(%eax)
	prev->next = newsk;
    4b31:	89 9a 50 0a 00 00    	mov    %ebx,0xa50(%edx)
    4b37:	e9 3d fc ff ff       	jmp    4779 <client_inseq+0x209>
    4b3c:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    4b3f:	8b 43 64             	mov    0x64(%ebx),%eax
    4b42:	8b b1 54 0a 00 00    	mov    0xa54(%ecx),%esi
    4b48:	90                   	nop    
    4b49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    4b50:	39 46 64             	cmp    %eax,0x64(%esi)
    4b53:	72 07                	jb     4b5c <client_inseq+0x5ec>
    4b55:	8b 76 04             	mov    0x4(%esi),%esi
    4b58:	39 fe                	cmp    %edi,%esi
    4b5a:	75 f4                	jne    4b50 <client_inseq+0x5e0>
    4b5c:	8b 16                	mov    (%esi),%edx
    4b5e:	39 fa                	cmp    %edi,%edx
    4b60:	74 0f                	je     4b71 <client_inseq+0x601>
    4b62:	8b 4a 64             	mov    0x64(%edx),%ecx
    4b65:	39 c1                	cmp    %eax,%ecx
    4b67:	0f 84 63 fc ff ff    	je     47d0 <client_inseq+0x260>
    4b6d:	39 c1                	cmp    %eax,%ecx
    4b6f:	76 0d                	jbe    4b7e <client_inseq+0x60e>
	struct sk_buff * prev, struct sk_buff *next,
	struct sk_buff_head * list)
{
	newsk->next = next;
	newsk->prev = prev;
    4b71:	89 73 04             	mov    %esi,0x4(%ebx)
    4b74:	89 13                	mov    %edx,(%ebx)
	next->prev = newsk;
    4b76:	89 5a 04             	mov    %ebx,0x4(%edx)
    4b79:	e9 f3 fb ff ff       	jmp    4771 <client_inseq+0x201>
    4b7e:	c7 44 24 04 ee 0b 00 	movl   $0xbee,0x4(%esp,1)
    4b85:	00 
    4b86:	c7 04 24 60 1b 00 00 	movl   $0x1b60,(%esp,1)
    4b8d:	e8 fc ff ff ff       	call   4b8e <client_inseq+0x61e>
    4b92:	8b 16                	mov    (%esi),%edx
    4b94:	eb db                	jmp    4b71 <client_inseq+0x601>
    4b96:	c7 44 24 04 de 0b 00 	movl   $0xbde,0x4(%esp,1)
    4b9d:	00 
    4b9e:	c7 04 24 e0 1b 00 00 	movl   $0x1be0,(%esp,1)
    4ba5:	e8 fc ff ff ff       	call   4ba6 <client_inseq+0x636>
    4baa:	e9 57 ff ff ff       	jmp    4b06 <client_inseq+0x596>
    4baf:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    4bb2:	81 c2 50 0a 00 00    	add    $0xa50,%edx
    4bb8:	89 55 cc             	mov    %edx,0xffffffcc(%ebp)
    4bbb:	90                   	nop    
    4bbc:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    4bc0:	8b 73 5c             	mov    0x5c(%ebx),%esi
    4bc3:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    4bc7:	89 74 24 08          	mov    %esi,0x8(%esp,1)
    4bcb:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    4bce:	89 0c 24             	mov    %ecx,(%esp,1)
    4bd1:	e8 fa d9 ff ff       	call   25d0 <UpdateClientUCState>
    4bd6:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
    4bd9:	39 b7 f0 02 00 00    	cmp    %esi,0x2f0(%edi)
    4bdf:	0f 84 e6 00 00 00    	je     4ccb <client_inseq+0x75b>
  }
#endif // USERTEST
#endif // DEBUG_ALLOC

  if(cont->list) {
    4be5:	8b 46 08             	mov    0x8(%esi),%eax
    4be8:	85 c0                	test   %eax,%eax
    4bea:	0f 85 bd 00 00 00    	jne    4cad <client_inseq+0x73d>
	  BUG();
  }

  for(i=0; i < 2; i++) {
    4bf0:	31 db                	xor    %ebx,%ebx
    4bf2:	bf 01 00 00 00       	mov    $0x1,%edi
    if((cont+i)->ucont_data)
    4bf7:	8b 84 1e 80 00 00 00 	mov    0x80(%esi,%ebx,1),%eax
    4bfe:	85 c0                	test   %eax,%eax
    4c00:	0f 85 9a 00 00 00    	jne    4ca0 <client_inseq+0x730>
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
    4c06:	8b 84 1e 88 00 00 00 	mov    0x88(%esi,%ebx,1),%eax
    4c0d:	85 c0                	test   %eax,%eax
    4c0f:	75 7f                	jne    4c90 <client_inseq+0x720>
    4c11:	81 c3 e4 00 00 00    	add    $0xe4,%ebx
    4c17:	4f                   	dec    %edi
    4c18:	79 dd                	jns    4bf7 <client_inseq+0x687>
      kfree((cont+i)->input);
  }

#ifdef USERTEST
  kfree(cont);
#else  //0426 - change kernel to slab cache
#ifdef DEBUG_ALLOC
  zap_virt(cont);
  //memset(cont, 0x3e, sizeof(*cont));
#else
#ifndef USESLAB
  kfree(cont);  // 0502 maybe slab cache usage is buggy
#else
  kmem_cache_free(clientSideContinuation_cache, cont);
    4c1a:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    4c1e:	a1 00 00 00 00       	mov    0x0,%eax
 
static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
{
	struct sk_buff *list = ((struct sk_buff *)list_)->next;
	if (list == (struct sk_buff *)list_)
    4c23:	31 db                	xor    %ebx,%ebx
#else
#ifndef USESLAB
  kfree(cont);  // 0502 maybe slab cache usage is buggy
#else
  kmem_cache_free(clientSideContinuation_cache, cont);
    4c25:	89 04 24             	mov    %eax,(%esp,1)
    4c28:	e8 fc ff ff ff       	call   4c29 <client_inseq+0x6b9>
 */
 
static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
{
	struct sk_buff *list = ((struct sk_buff *)list_)->next;
    4c2d:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    4c30:	8b 82 50 0a 00 00    	mov    0xa50(%edx),%eax
	if (list == (struct sk_buff *)list_)
    4c36:	3b 45 cc             	cmp    0xffffffcc(%ebp),%eax
    4c39:	89 c2                	mov    %eax,%edx
    4c3b:	0f 45 d8             	cmovne %eax,%ebx
    4c3e:	85 db                	test   %ebx,%ebx
    4c40:	0f 84 33 fb ff ff    	je     4779 <client_inseq+0x209>
    4c46:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    4c49:	8b 81 48 0a 00 00    	mov    0xa48(%ecx),%eax
    4c4f:	39 43 64             	cmp    %eax,0x64(%ebx)
    4c52:	0f 85 21 fb ff ff    	jne    4779 <client_inseq+0x209>

	prev = (struct sk_buff *) list;
	next = prev->next;
	result = NULL;
	if (next != prev) {
    4c58:	3b 55 cc             	cmp    0xffffffcc(%ebp),%edx
    4c5b:	0f 84 5f ff ff ff    	je     4bc0 <client_inseq+0x650>
		result = next;
		next = next->next;
		list->qlen--;
    4c61:	8b 75 cc             	mov    0xffffffcc(%ebp),%esi
    4c64:	8b 02                	mov    (%edx),%eax
    4c66:	ff 4e 08             	decl   0x8(%esi)
		next->prev = prev;
    4c69:	89 70 04             	mov    %esi,0x4(%eax)
		prev->next = next;
    4c6c:	89 81 50 0a 00 00    	mov    %eax,0xa50(%ecx)
		result->next = NULL;
		result->prev = NULL;
    4c72:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
    4c79:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
		result->list = NULL;
    4c7f:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
    4c86:	e9 35 ff ff ff       	jmp    4bc0 <client_inseq+0x650>
    4c8b:	90                   	nop    
    4c8c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
  for(i=0; i < 2; i++) {
    if((cont+i)->ucont_data)
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
      kfree((cont+i)->input);
    4c90:	89 04 24             	mov    %eax,(%esp,1)
    4c93:	e8 fc ff ff ff       	call   4c94 <client_inseq+0x724>
    4c98:	e9 74 ff ff ff       	jmp    4c11 <client_inseq+0x6a1>
    4c9d:	8d 76 00             	lea    0x0(%esi),%esi
    4ca0:	89 04 24             	mov    %eax,(%esp,1)
    4ca3:	e8 fc ff ff ff       	call   4ca4 <client_inseq+0x734>
    4ca8:	e9 59 ff ff ff       	jmp    4c06 <client_inseq+0x696>
    4cad:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    4cb4:	00 
    4cb5:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    4cbc:	e8 fc ff ff ff       	call   4cbd <client_inseq+0x74d>
    4cc1:	e8 fc ff ff ff       	call   4cc2 <client_inseq+0x752>
    4cc6:	e9 25 ff ff ff       	jmp    4bf0 <client_inseq+0x680>
    4ccb:	c7 44 24 04 d1 0b 00 	movl   $0xbd1,0x4(%esp,1)
    4cd2:	00 
    4cd3:	c7 04 24 00 1b 00 00 	movl   $0x1b00,(%esp,1)
    4cda:	e8 fc ff ff ff       	call   4cdb <client_inseq+0x76b>
    4cdf:	e9 01 ff ff ff       	jmp    4be5 <client_inseq+0x675>
    4ce4:	c7 04 24 40 1c 00 00 	movl   $0x1c40,(%esp,1)
    4ceb:	e8 fc ff ff ff       	call   4cec <client_inseq+0x77c>
    4cf0:	e9 eb f8 ff ff       	jmp    45e0 <client_inseq+0x70>
    4cf5:	89 54 24 08          	mov    %edx,0x8(%esp,1)
    4cf9:	bf 01 00 00 00       	mov    $0x1,%edi
    4cfe:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    4d02:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    4d05:	89 14 24             	mov    %edx,(%esp,1)
    4d08:	e8 fc ff ff ff       	call   4d09 <client_inseq+0x799>
    4d0d:	e9 bd f8 ff ff       	jmp    45cf <client_inseq+0x5f>
static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
	skb->len-=len;
	if (skb->len < skb->data_len)
		out_of_line_bug();
    4d12:	c7 04 24 4c 03 00 00 	movl   $0x34c,(%esp,1)
    4d19:	e8 fc ff ff ff       	call   4d1a <client_inseq+0x7aa>
    4d1e:	89 f6                	mov    %esi,%esi

00004d20 <AckProof_update>:
}

/* TODO: Strip out sk argument */
int AckProof_update(struct sock *sk, AckProof *ackProof, CONTINUATION_TYPE *cont) {
    4d20:	55                   	push   %ebp
    4d21:	89 e5                	mov    %esp,%ebp
	int i, j;
	__u32 seq = cont->seq;
	int *numSacks = &ackProof->numSacks;
	Sack *sacks = ackProof->sacks;
	for(i=0; i < *numSacks && (seq >= sacks[i].left || seq == sacks[i].left - 1); i++) {
    4d23:	31 c9                	xor    %ecx,%ecx
    4d25:	57                   	push   %edi
    4d26:	56                   	push   %esi
    4d27:	53                   	push   %ebx
    4d28:	83 ec 10             	sub    $0x10,%esp
    4d2b:	8b 55 0c             	mov    0xc(%ebp),%edx
    4d2e:	8b 45 10             	mov    0x10(%ebp),%eax
    4d31:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    4d34:	83 c2 08             	add    $0x8,%edx
    4d37:	8b 78 34             	mov    0x34(%eax),%edi
    4d3a:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
    4d3d:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
    4d44:	3b 0b                	cmp    (%ebx),%ecx
    4d46:	7d 68                	jge    4db0 <AckProof_update+0x90>
    4d48:	8b 43 08             	mov    0x8(%ebx),%eax
    4d4b:	39 c7                	cmp    %eax,%edi
    4d4d:	0f 82 3d 02 00 00    	jb     4f90 <AckProof_update+0x270>
    4d53:	8b 45 0c             	mov    0xc(%ebp),%eax
    4d56:	8d 70 08             	lea    0x8(%eax),%esi
    4d59:	89 f3                	mov    %esi,%ebx
    4d5b:	90                   	nop    
    4d5c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
	  /* condition not expressed as > because of overflow/underflow */
		if(seq == sacks[i].left - 1) {
    4d60:	8b 13                	mov    (%ebx),%edx
    4d62:	8d 42 ff             	lea    0xffffffff(%edx),%eax
    4d65:	39 c7                	cmp    %eax,%edi
    4d67:	0f 84 b0 01 00 00    	je     4f1d <AckProof_update+0x1fd>
			sacks[i].left = seq;
			sacks[i].nonceSummary ^= cont->cum_nonce;
			if(i > 0 && sacks[i-1].right == sacks[i].left - 1) {
				printk("Not supposed to reach this point\n");
			  /* actually, this case should never be reached */
				/* coalesce */
				sacks[i-1].right = sacks[i].right;
				sacks[i-1].nonceSummary ^= sacks[i].nonceSummary;
				for(j=i + 1; j < *numSacks; j++) {
					sacks[j - 1] = sacks[j];
				}
				(*numSacks)--;
			}
			return 1;
		} else if(seq == sacks[i].right + 1) {
    4d6d:	8b 43 04             	mov    0x4(%ebx),%eax
    4d70:	40                   	inc    %eax
    4d71:	39 c7                	cmp    %eax,%edi
    4d73:	0f 84 34 01 00 00    	je     4ead <AckProof_update+0x18d>
			sacks[i].right = seq;
			sacks[i].nonceSummary ^= cont->cum_nonce;
			if(i + 1 < *numSacks && sacks[i].right == sacks[i+1].left - 1) {
				/* coalesce */
				sacks[i].right = sacks[i+1].right;
				sacks[i].nonceSummary ^= sacks[i+1].nonceSummary;
				for(j=i + 2; j < *numSacks; j++) {
					sacks[j - 1] = sacks[j];
				}
				(*numSacks)--;
			}
			return 1;
		} else if(Sack_contains(&sacks[i], seq)) {
    4d79:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
    4d7d:	89 34 24             	mov    %esi,(%esp,1)
    4d80:	e8 fc ff ff ff       	call   4d81 <AckProof_update+0x61>
    4d85:	85 c0                	test   %eax,%eax
    4d87:	0f 85 13 01 00 00    	jne    4ea0 <AckProof_update+0x180>
    4d8d:	ff 45 f0             	incl   0xfffffff0(%ebp)
    4d90:	83 c6 0c             	add    $0xc,%esi
    4d93:	8b 55 0c             	mov    0xc(%ebp),%edx
    4d96:	83 c3 0c             	add    $0xc,%ebx
    4d99:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    4d9c:	3b 02                	cmp    (%edx),%eax
    4d9e:	7d 10                	jge    4db0 <AckProof_update+0x90>
    4da0:	8b 03                	mov    (%ebx),%eax
    4da2:	39 c7                	cmp    %eax,%edi
    4da4:	73 ba                	jae    4d60 <AckProof_update+0x40>
    4da6:	48                   	dec    %eax
    4da7:	39 c7                	cmp    %eax,%edi
    4da9:	74 b5                	je     4d60 <AckProof_update+0x40>
    4dab:	90                   	nop    
    4dac:	8d 74 26 00          	lea    0x0(%esi,1),%esi
			/* In the middle of an existing sack */
			return 1;
		}
	}
	if(i >= MAX_KERNEL_SACKS) {
    4db0:	31 c0                	xor    %eax,%eax
    4db2:	83 7d f0 3f          	cmpl   $0x3f,0xfffffff0(%ebp)
    4db6:	0f 8f e9 00 00 00    	jg     4ea5 <AckProof_update+0x185>
		//printk("exceeded # of sacks while updating sack\n");
		return 0;
	}
	/* Cannot extend any sack ; create new one */
	/* seq is between i-1 and i; shift upwards all sacks i and up */
	for(j=MIN(*numSacks, MAX_KERNEL_SACKS-1); j > i; j--) {
    4dbc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    4dbf:	b8 3f 00 00 00       	mov    $0x3f,%eax
    4dc4:	8b 11                	mov    (%ecx),%edx
    4dc6:	39 d0                	cmp    %edx,%eax
    4dc8:	89 d1                	mov    %edx,%ecx
    4dca:	0f 4e c8             	cmovle %eax,%ecx
    4dcd:	3b 4d f0             	cmp    0xfffffff0(%ebp),%ecx
    4dd0:	7e 28                	jle    4dfa <AckProof_update+0xda>
    4dd2:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
    4dd5:	8d 04 49             	lea    (%ecx,%ecx,2),%eax
    4dd8:	8d 14 83             	lea    (%ebx,%eax,4),%edx
    4ddb:	90                   	nop    
    4ddc:	8d 74 26 00          	lea    0x0(%esi,1),%esi
		sacks[j] = sacks[j-1];
    4de0:	8b 42 f4             	mov    0xfffffff4(%edx),%eax
    4de3:	49                   	dec    %ecx
    4de4:	89 02                	mov    %eax,(%edx)
    4de6:	8b 42 f8             	mov    0xfffffff8(%edx),%eax
    4de9:	89 42 04             	mov    %eax,0x4(%edx)
    4dec:	8b 42 fc             	mov    0xfffffffc(%edx),%eax
    4def:	89 42 08             	mov    %eax,0x8(%edx)
    4df2:	83 ea 0c             	sub    $0xc,%edx
    4df5:	3b 4d f0             	cmp    0xfffffff0(%ebp),%ecx
    4df8:	7f e6                	jg     4de0 <AckProof_update+0xc0>
	}
	sacks[i].left = sacks[i].right = seq;
    4dfa:	8b 75 f0             	mov    0xfffffff0(%ebp),%esi
    4dfd:	8d 04 76             	lea    (%esi,%esi,2),%eax
    4e00:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    4e07:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    4e0a:	8d 1c 08             	lea    (%eax,%ecx,1),%ebx
    4e0d:	89 7c 08 04          	mov    %edi,0x4(%eax,%ecx,1)
    4e11:	89 3b                	mov    %edi,(%ebx)
	sacks[i].nonceSummary = cont->cum_nonce;
    4e13:	8b 55 10             	mov    0x10(%ebp),%edx
    4e16:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    4e19:	8b 42 2c             	mov    0x2c(%edx),%eax
    4e1c:	89 44 0e 08          	mov    %eax,0x8(%esi,%ecx,1)
	*numSacks = MIN(*numSacks+1, MAX_KERNEL_SACKS);
    4e20:	8b 45 0c             	mov    0xc(%ebp),%eax
    4e23:	8b 10                	mov    (%eax),%edx
    4e25:	b8 40 00 00 00       	mov    $0x40,%eax
    4e2a:	42                   	inc    %edx
    4e2b:	39 d0                	cmp    %edx,%eax
    4e2d:	0f 4f c2             	cmovg  %edx,%eax
    4e30:	8b 55 0c             	mov    0xc(%ebp),%edx
    4e33:	89 02                	mov    %eax,(%edx)
	/* Sanity checks */
	BUG_TRAP(i == *numSacks-1 || (sacks[i].right != sacks[i+1].left - 1 &&
				      sacks[i].right < sacks[i+1].left));
    4e35:	48                   	dec    %eax
    4e36:	39 45 f0             	cmp    %eax,0xfffffff0(%ebp)
    4e39:	74 26                	je     4e61 <AckProof_update+0x141>
    4e3b:	8b 5b 0c             	mov    0xc(%ebx),%ebx
    4e3e:	8b 54 0e 04          	mov    0x4(%esi,%ecx,1),%edx
    4e42:	8d 43 ff             	lea    0xffffffff(%ebx),%eax
    4e45:	39 c2                	cmp    %eax,%edx
    4e47:	74 04                	je     4e4d <AckProof_update+0x12d>
    4e49:	39 da                	cmp    %ebx,%edx
    4e4b:	72 14                	jb     4e61 <AckProof_update+0x141>
    4e4d:	c7 44 24 04 3a 0c 00 	movl   $0xc3a,0x4(%esp,1)
    4e54:	00 
    4e55:	c7 04 24 a0 1c 00 00 	movl   $0x1ca0,(%esp,1)
    4e5c:	e8 fc ff ff ff       	call   4e5d <AckProof_update+0x13d>
	BUG_TRAP(i == 0 || (sacks[i-1].right != sacks[i].left - 1 &&
			    sacks[i-1].right < sacks[i].left));
    4e61:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    4e64:	85 c9                	test   %ecx,%ecx
    4e66:	74 38                	je     4ea0 <AckProof_update+0x180>
    4e68:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    4e6b:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
    4e6e:	8d 04 49             	lea    (%ecx,%ecx,2),%eax
    4e71:	8d 04 83             	lea    (%ebx,%eax,4),%eax
    4e74:	8b 08                	mov    (%eax),%ecx
    4e76:	8b 40 f8             	mov    0xfffffff8(%eax),%eax
    4e79:	8d 51 ff             	lea    0xffffffff(%ecx),%edx
    4e7c:	39 d0                	cmp    %edx,%eax
    4e7e:	74 04                	je     4e84 <AckProof_update+0x164>
    4e80:	39 c8                	cmp    %ecx,%eax
    4e82:	72 1c                	jb     4ea0 <AckProof_update+0x180>
    4e84:	c7 44 24 04 3c 0c 00 	movl   $0xc3c,0x4(%esp,1)
    4e8b:	00 
    4e8c:	c7 04 24 40 1d 00 00 	movl   $0x1d40,(%esp,1)
    4e93:	e8 fc ff ff ff       	call   4e94 <AckProof_update+0x174>
    4e98:	90                   	nop    
    4e99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi

	return 1;
    4ea0:	b8 01 00 00 00       	mov    $0x1,%eax
}
    4ea5:	83 c4 10             	add    $0x10,%esp
    4ea8:	5b                   	pop    %ebx
    4ea9:	5e                   	pop    %esi
    4eaa:	5f                   	pop    %edi
    4eab:	5d                   	pop    %ebp
    4eac:	c3                   	ret    
    4ead:	89 7b 04             	mov    %edi,0x4(%ebx)
    4eb0:	8b 45 10             	mov    0x10(%ebp),%eax
    4eb3:	8b 50 2c             	mov    0x2c(%eax),%edx
    4eb6:	8b 43 08             	mov    0x8(%ebx),%eax
    4eb9:	31 c2                	xor    %eax,%edx
    4ebb:	89 53 08             	mov    %edx,0x8(%ebx)
    4ebe:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    4ec1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    4ec4:	40                   	inc    %eax
    4ec5:	3b 01                	cmp    (%ecx),%eax
    4ec7:	7d d7                	jge    4ea0 <AckProof_update+0x180>
    4ec9:	8b 43 0c             	mov    0xc(%ebx),%eax
    4ecc:	48                   	dec    %eax
    4ecd:	39 c7                	cmp    %eax,%edi
    4ecf:	75 cf                	jne    4ea0 <AckProof_update+0x180>
    4ed1:	8b 73 14             	mov    0x14(%ebx),%esi
    4ed4:	8b 43 10             	mov    0x10(%ebx),%eax
    4ed7:	31 f2                	xor    %esi,%edx
    4ed9:	89 43 04             	mov    %eax,0x4(%ebx)
    4edc:	89 53 08             	mov    %edx,0x8(%ebx)
    4edf:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    4ee2:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    4ee5:	8b 03                	mov    (%ebx),%eax
    4ee7:	83 c1 02             	add    $0x2,%ecx
    4eea:	39 c1                	cmp    %eax,%ecx
    4eec:	7d 27                	jge    4f15 <AckProof_update+0x1f5>
    4eee:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    4ef1:	8d 04 49             	lea    (%ecx,%ecx,2),%eax
    4ef4:	8d 14 86             	lea    (%esi,%eax,4),%edx
    4ef7:	8b 02                	mov    (%edx),%eax
    4ef9:	41                   	inc    %ecx
    4efa:	89 42 f4             	mov    %eax,0xfffffff4(%edx)
    4efd:	8b 42 04             	mov    0x4(%edx),%eax
    4f00:	89 42 f8             	mov    %eax,0xfffffff8(%edx)
    4f03:	8b 42 08             	mov    0x8(%edx),%eax
    4f06:	89 42 fc             	mov    %eax,0xfffffffc(%edx)
    4f09:	83 c2 0c             	add    $0xc,%edx
    4f0c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    4f0f:	8b 03                	mov    (%ebx),%eax
    4f11:	39 c1                	cmp    %eax,%ecx
    4f13:	7c e2                	jl     4ef7 <AckProof_update+0x1d7>
    4f15:	8b 75 0c             	mov    0xc(%ebp),%esi
    4f18:	48                   	dec    %eax
    4f19:	89 06                	mov    %eax,(%esi)
    4f1b:	eb 83                	jmp    4ea0 <AckProof_update+0x180>
    4f1d:	89 3b                	mov    %edi,(%ebx)
    4f1f:	8b 4d 10             	mov    0x10(%ebp),%ecx
    4f22:	8b 41 2c             	mov    0x2c(%ecx),%eax
    4f25:	31 43 08             	xor    %eax,0x8(%ebx)
    4f28:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    4f2b:	85 c0                	test   %eax,%eax
    4f2d:	0f 8e 6d ff ff ff    	jle    4ea0 <AckProof_update+0x180>
    4f33:	8d 42 fe             	lea    0xfffffffe(%edx),%eax
    4f36:	39 43 f8             	cmp    %eax,0xfffffff8(%ebx)
    4f39:	0f 85 61 ff ff ff    	jne    4ea0 <AckProof_update+0x180>
    4f3f:	c7 04 24 e0 1d 00 00 	movl   $0x1de0,(%esp,1)
    4f46:	e8 fc ff ff ff       	call   4f47 <AckProof_update+0x227>
    4f4b:	8b 43 04             	mov    0x4(%ebx),%eax
    4f4e:	89 43 f8             	mov    %eax,0xfffffff8(%ebx)
    4f51:	8b 43 08             	mov    0x8(%ebx),%eax
    4f54:	31 43 fc             	xor    %eax,0xfffffffc(%ebx)
    4f57:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    4f5a:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    4f5d:	8b 03                	mov    (%ebx),%eax
    4f5f:	41                   	inc    %ecx
    4f60:	39 c1                	cmp    %eax,%ecx
    4f62:	7d b1                	jge    4f15 <AckProof_update+0x1f5>
    4f64:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    4f67:	8d 04 49             	lea    (%ecx,%ecx,2),%eax
    4f6a:	8d 14 86             	lea    (%esi,%eax,4),%edx
    4f6d:	8b 02                	mov    (%edx),%eax
    4f6f:	41                   	inc    %ecx
    4f70:	89 42 f4             	mov    %eax,0xfffffff4(%edx)
    4f73:	8b 42 04             	mov    0x4(%edx),%eax
    4f76:	89 42 f8             	mov    %eax,0xfffffff8(%edx)
    4f79:	8b 42 08             	mov    0x8(%edx),%eax
    4f7c:	89 42 fc             	mov    %eax,0xfffffffc(%edx)
    4f7f:	83 c2 0c             	add    $0xc,%edx
    4f82:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    4f85:	8b 03                	mov    (%ebx),%eax
    4f87:	39 c1                	cmp    %eax,%ecx
    4f89:	7c e2                	jl     4f6d <AckProof_update+0x24d>
    4f8b:	eb 88                	jmp    4f15 <AckProof_update+0x1f5>
    4f8d:	8d 76 00             	lea    0x0(%esi),%esi
    4f90:	48                   	dec    %eax
    4f91:	39 c7                	cmp    %eax,%edi
    4f93:	0f 85 17 fe ff ff    	jne    4db0 <AckProof_update+0x90>
    4f99:	e9 b5 fd ff ff       	jmp    4d53 <AckProof_update+0x33>
    4f9e:	89 f6                	mov    %esi,%esi

00004fa0 <findAckables>:


static int findAckables(struct sock *sk, int skip, struct sk_buff **skip_skb) {
    4fa0:	55                   	push   %ebp
    4fa1:	89 e5                	mov    %esp,%ebp
	// skip == 1 if we are to ignore leading missing packets (loss assumed)
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	int progress = 0;
    4fa3:	31 c9                	xor    %ecx,%ecx
    4fa5:	57                   	push   %edi
    4fa6:	56                   	push   %esi
    4fa7:	53                   	push   %ebx
 
static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
{
	struct sk_buff *list = ((struct sk_buff *)list_)->next;
	if (list == (struct sk_buff *)list_)
    4fa8:	89 cb                	mov    %ecx,%ebx
    4faa:	83 ec 14             	sub    $0x14,%esp
    4fad:	8b 55 08             	mov    0x8(%ebp),%edx
 *	volatile. Use with caution.
 */
 
static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
{
    4fb0:	8d 82 a0 03 00 00    	lea    0x3a0(%edx),%eax
    4fb6:	8d b2 bc 00 00 00    	lea    0xbc(%edx),%esi
 *	volatile. Use with caution.
 */
 
static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
{
    4fbc:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	struct sk_buff *list = ((struct sk_buff *)list_)->next;
    4fbf:	8b 82 a0 03 00 00    	mov    0x3a0(%edx),%eax
	if (list == (struct sk_buff *)list_)
    4fc5:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
    4fc8:	0f 45 d8             	cmovne %eax,%ebx
	struct sk_buff *skb = skb_peek(&tp->t.ofo_queue);
	if(skip_skb) *skip_skb = NULL;
    4fcb:	8b 45 10             	mov    0x10(%ebp),%eax
    4fce:	85 c0                	test   %eax,%eax
    4fd0:	74 09                	je     4fdb <findAckables+0x3b>
    4fd2:	8b 45 10             	mov    0x10(%ebp),%eax
    4fd5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	// 0419 special case - if ack_curr is set (due to recovery), we've already made progress in finding an ackable continuation
#if 0
	// 0501 - don't call findAckable when exiting recovery
	if(tp->t.ack_prev == NULL && tp->t.cont_list.len >= 1) {
		progress = 1;
		goto done;
	}
#endif

	if(tp->t.ack_last < tp->t.rcv_nxt) {
    4fdb:	8b 86 dc 02 00 00    	mov    0x2dc(%esi),%eax
    4fe1:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    4fe4:	39 86 f4 02 00 00    	cmp    %eax,0x2f4(%esi)
    4fea:	7d 0b                	jge    4ff7 <findAckables+0x57>
		tp->t.ack_last = tp->t.rcv_nxt;
    4fec:	89 86 f4 02 00 00    	mov    %eax,0x2f4(%esi)
		progress = 1;
    4ff2:	b9 01 00 00 00       	mov    $0x1,%ecx
	}
	if(skb) {
    4ff7:	85 db                	test   %ebx,%ebx
    4ff9:	0f 84 b8 00 00 00    	je     50b7 <findAckables+0x117>
		if(!progress && skip) {
    4fff:	85 c9                	test   %ecx,%ecx
    5001:	8d ba a0 03 00 00    	lea    0x3a0(%edx),%edi
    5007:	75 7c                	jne    5085 <findAckables+0xe5>
    5009:	8b 45 0c             	mov    0xc(%ebp),%eax
    500c:	85 c0                	test   %eax,%eax
    500e:	74 75                	je     5085 <findAckables+0xe5>
			while((struct sk_buff_head*)skb != &tp->t.ofo_queue &&
    5010:	3b 5d f0             	cmp    0xfffffff0(%ebp),%ebx
    5013:	0f 84 cb 00 00 00    	je     50e4 <findAckables+0x144>
    5019:	8b 86 f4 02 00 00    	mov    0x2f4(%esi),%eax
    501f:	39 43 54             	cmp    %eax,0x54(%ebx)
    5022:	0f 83 b1 00 00 00    	jae    50d9 <findAckables+0x139>
    5028:	90                   	nop    
    5029:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
			      TCP_SKB_CB(skb)->trickle_seq < tp->t.ack_last) {
				skb = skb->next;
    5030:	8b 1b                	mov    (%ebx),%ebx
    5032:	39 fb                	cmp    %edi,%ebx
    5034:	0f 84 9b 00 00 00    	je     50d5 <findAckables+0x135>
    503a:	39 43 54             	cmp    %eax,0x54(%ebx)
    503d:	72 f1                	jb     5030 <findAckables+0x90>
			}
			if((struct sk_buff_head*)skb == &tp->t.ofo_queue) return 0 /* no progress*/;
    503f:	39 fb                	cmp    %edi,%ebx
    5041:	0f 84 8e 00 00 00    	je     50d5 <findAckables+0x135>
			if(clientDebugLevel >= 2)
    5047:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    504e:	7e 21                	jle    5071 <findAckables+0xd1>
				printk("ack_last skipped over gap: %u - %u\n", 
    5050:	8b 43 54             	mov    0x54(%ebx),%eax
    5053:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    5057:	8b 43 04             	mov    0x4(%ebx),%eax
    505a:	39 f8                	cmp    %edi,%eax
    505c:	74 71                	je     50cf <findAckables+0x12f>
    505e:	8b 40 54             	mov    0x54(%eax),%eax
    5061:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    5065:	c7 04 24 20 1e 00 00 	movl   $0x1e20,(%esp,1)
    506c:	e8 fc ff ff ff       	call   506d <findAckables+0xcd>
				       (struct sk_buff_head*)skb->prev != &tp->t.ofo_queue ? 
				       TCP_SKB_CB(skb->prev)->trickle_seq :
				       tp->t.rcv_nxt - 1, TCP_SKB_CB(skb)->trickle_seq);
			tp->t.ack_last = TCP_SKB_CB(skb)->trickle_seq + 1;
    5071:	8b 43 54             	mov    0x54(%ebx),%eax
			*skip_skb = skb;
			progress = 1;
    5074:	b9 01 00 00 00       	mov    $0x1,%ecx
    5079:	40                   	inc    %eax
    507a:	89 86 f4 02 00 00    	mov    %eax,0x2f4(%esi)
    5080:	8b 45 10             	mov    0x10(%ebp),%eax
    5083:	89 18                	mov    %ebx,(%eax)
		}
		while((struct sk_buff_head*)skb != &tp->t.ofo_queue &&
    5085:	39 fb                	cmp    %edi,%ebx
    5087:	74 2e                	je     50b7 <findAckables+0x117>
    5089:	8b 53 54             	mov    0x54(%ebx),%edx
    508c:	8b 86 f4 02 00 00    	mov    0x2f4(%esi),%eax
    5092:	39 c2                	cmp    %eax,%edx
    5094:	77 21                	ja     50b7 <findAckables+0x117>
    5096:	8d 76 00             	lea    0x0(%esi),%esi
    5099:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
		      TCP_SKB_CB(skb)->trickle_seq <= tp->t.ack_last) {
			if(tp->t.ack_last == TCP_SKB_CB(skb)->trickle_seq) {
    50a0:	39 d0                	cmp    %edx,%eax
    50a2:	74 1d                	je     50c1 <findAckables+0x121>
				tp->t.ack_last++;
				progress = 1;
			}
			skb = skb->next;
    50a4:	8b 1b                	mov    (%ebx),%ebx
    50a6:	39 fb                	cmp    %edi,%ebx
    50a8:	74 0d                	je     50b7 <findAckables+0x117>
    50aa:	8b 53 54             	mov    0x54(%ebx),%edx
    50ad:	8b 86 f4 02 00 00    	mov    0x2f4(%esi),%eax
    50b3:	39 c2                	cmp    %eax,%edx
    50b5:	76 e9                	jbe    50a0 <findAckables+0x100>
		}
	}
#if 0
 done:
#endif
	return progress;
    50b7:	89 c8                	mov    %ecx,%eax
}
    50b9:	83 c4 14             	add    $0x14,%esp
    50bc:	5b                   	pop    %ebx
    50bd:	5e                   	pop    %esi
    50be:	5f                   	pop    %edi
    50bf:	5d                   	pop    %ebp
    50c0:	c3                   	ret    
    50c1:	40                   	inc    %eax
    50c2:	b9 01 00 00 00       	mov    $0x1,%ecx
    50c7:	89 86 f4 02 00 00    	mov    %eax,0x2f4(%esi)
    50cd:	eb d5                	jmp    50a4 <findAckables+0x104>
    50cf:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    50d2:	48                   	dec    %eax
    50d3:	eb 8c                	jmp    5061 <findAckables+0xc1>
    50d5:	31 c0                	xor    %eax,%eax
    50d7:	eb e0                	jmp    50b9 <findAckables+0x119>
    50d9:	8d ba a0 03 00 00    	lea    0x3a0(%edx),%edi
    50df:	e9 5b ff ff ff       	jmp    503f <findAckables+0x9f>
    50e4:	8d be e4 02 00 00    	lea    0x2e4(%esi),%edi
    50ea:	e9 50 ff ff ff       	jmp    503f <findAckables+0x9f>
    50ef:	90                   	nop    

000050f0 <findUCContinuation>:

 struct UC_Continuation *findUCContinuation(struct sock *sk, unsigned start, unsigned end) {
    50f0:	55                   	push   %ebp
    50f1:	89 e5                	mov    %esp,%ebp
    50f3:	57                   	push   %edi
    50f4:	56                   	push   %esi
    50f5:	53                   	push   %ebx
    50f6:	83 ec 10             	sub    $0x10,%esp
    50f9:	8b 55 08             	mov    0x8(%ebp),%edx
    50fc:	8b 75 0c             	mov    0xc(%ebp),%esi
	 /* XXX use faster datastructure/algorithms? */

	 struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	 struct UC_Continuation *ucont = (struct UC_Continuation*)tp->t.ucontList.next, 
    50ff:	8b 9a a4 0b 00 00    	mov    0xba4(%edx),%ebx
		 *candidate = NULL;
	 int found = 0;

#if 0
	 while(ucont != (struct UC_Continuation *)&tp->t.ucontList) {
		 if(ucont->validStart <= start) {
			 if(end <= ucont->validEnd) {
				 // perfect fit
				 found = 1;
				 candidate = ucont;
				 break;
			 }
			 if(candidate == NULL) {
				 candidate = ucont;
			 } else if(ucont->validEnd > candidate->validEnd) {
				 // better fit than previous candidate
				 candidate = ucont;
			 }
		 }
		 ucont = (struct UC_Continuation*)ucont->next;
	 }
#else
	 // return continuation with maximum overlap
	 int overlapSize = 0;
	 while(ucont != (struct UC_Continuation *)&tp->t.ucontList) {
    5105:	8d 82 a0 0b 00 00    	lea    0xba0(%edx),%eax
    510b:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
    5112:	39 c3                	cmp    %eax,%ebx
    5114:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
    511b:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
    5122:	74 74                	je     5198 <findUCContinuation+0xa8>
    5124:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    5127:	89 f6                	mov    %esi,%esi
    5129:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
#ifdef FINDUC_DBG
		 printk("Considering %p: [%d-%d]\n", ucont, 
			ucont->validStart, ucont->validEnd);
#endif
		 int overlapStart = MAX(ucont->validStart, start);
    5130:	8b 43 10             	mov    0x10(%ebx),%eax
		 int overlapEnd = MIN(ucont->validEnd, end);
    5133:	8b 4d 10             	mov    0x10(%ebp),%ecx
    5136:	39 c6                	cmp    %eax,%esi
    5138:	89 c2                	mov    %eax,%edx
    513a:	8b 43 14             	mov    0x14(%ebx),%eax
    513d:	0f 43 d6             	cmovae %esi,%edx
    5140:	39 45 10             	cmp    %eax,0x10(%ebp)
    5143:	0f 47 c8             	cmova  %eax,%ecx
		 int zerolenOK = start == end;
    5146:	3b 75 10             	cmp    0x10(%ebp),%esi
    5149:	0f 94 c0             	sete   %al
    514c:	0f b6 f8             	movzbl %al,%edi
		 int curr_overlapSize = overlapEnd - overlapStart;
    514f:	89 c8                	mov    %ecx,%eax
    5151:	29 d0                	sub    %edx,%eax
		 if(overlapStart > start || overlapStart > overlapEnd || 
    5153:	39 f2                	cmp    %esi,%edx
    5155:	77 39                	ja     5190 <findUCContinuation+0xa0>
    5157:	39 ca                	cmp    %ecx,%edx
    5159:	7f 35                	jg     5190 <findUCContinuation+0xa0>
    515b:	85 ff                	test   %edi,%edi
    515d:	75 04                	jne    5163 <findUCContinuation+0x73>
    515f:	85 c0                	test   %eax,%eax
    5161:	74 2d                	je     5190 <findUCContinuation+0xa0>
		    (!zerolenOK && curr_overlapSize == 0)) {
#ifdef FINDUC_DBG
			 printk("skipped overlap = [%d=%d]\n", 
				overlapStart, overlapEnd);
#endif
			 goto next;
		 }

		 if(overlapEnd == end) {
    5163:	3b 4d 10             	cmp    0x10(%ebp),%ecx
    5166:	74 49                	je     51b1 <findUCContinuation+0xc1>
			 // done, found perfect fit
			 found = 1;
#ifdef FINDUC_DBG
			 printk("perfect fit, set to %p\n", ucont);
#endif
			 candidate = ucont;
			 break;
		 }
		 if((curr_overlapSize > 0 || zerolenOK) && 
    5168:	85 c0                	test   %eax,%eax
    516a:	7e 3f                	jle    51ab <findUCContinuation+0xbb>
    516c:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    516f:	85 c9                	test   %ecx,%ecx
    5171:	74 05                	je     5178 <findUCContinuation+0x88>
    5173:	39 45 e8             	cmp    %eax,0xffffffe8(%ebp)
    5176:	7d 18                	jge    5190 <findUCContinuation+0xa0>
		    (candidate == NULL || overlapSize < curr_overlapSize)) {
#ifdef FINDUC_DBG
			 printk("%d %d candidate set to %p\n", overlapSize, 
				curr_overlapSize, ucont);
#endif
			 found = 1;
    5178:	c7 45 ec 01 00 00 00 	movl   $0x1,0xffffffec(%ebp)
			 overlapSize = curr_overlapSize;
    517f:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
			 candidate = ucont;
    5182:	89 5d f0             	mov    %ebx,0xfffffff0(%ebp)
    5185:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    5189:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
		 }
	 next:
#ifdef FINDUC_DBG
		 printk("next\n");
#endif
		 ucont = (struct UC_Continuation*)ucont->next;
    5190:	8b 5b 04             	mov    0x4(%ebx),%ebx
    5193:	3b 5d e4             	cmp    0xffffffe4(%ebp),%ebx
    5196:	75 98                	jne    5130 <findUCContinuation+0x40>
	 }
#endif
#ifdef FINDUC_DBG
	 printk("uc_continuation: [%d-%d] ", start, end);
#endif
	 if(!found) {
    5198:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    519b:	31 c0                	xor    %eax,%eax
    519d:	85 d2                	test   %edx,%edx
    519f:	0f 45 45 f0          	cmovne 0xfffffff0(%ebp),%eax
#ifdef FINDUC_DBG
		 printk("not found\n");
#endif
		 return NULL;
	 }
#ifdef FINDUC_DBG
	 printk("%p [%d-%d]\n", candidate, candidate->validStart, 
		candidate->validEnd);
#endif

	 return candidate;
 }
    51a3:	83 c4 10             	add    $0x10,%esp
    51a6:	5b                   	pop    %ebx
    51a7:	5e                   	pop    %esi
    51a8:	5f                   	pop    %edi
    51a9:	5d                   	pop    %ebp
    51aa:	c3                   	ret    
    51ab:	85 ff                	test   %edi,%edi
    51ad:	74 e1                	je     5190 <findUCContinuation+0xa0>
    51af:	eb bb                	jmp    516c <findUCContinuation+0x7c>
    51b1:	c7 45 ec 01 00 00 00 	movl   $0x1,0xffffffec(%ebp)
    51b8:	89 5d f0             	mov    %ebx,0xfffffff0(%ebp)
    51bb:	eb db                	jmp    5198 <findUCContinuation+0xa8>
    51bd:	8d 76 00             	lea    0x0(%esi),%esi

000051c0 <startSimulation>:

struct sk_buff *startSimulation(struct sock *sk, CONTINUATION_TYPE *cont, struct sk_buff *skb) {
    51c0:	55                   	push   %ebp
    51c1:	89 e5                	mov    %esp,%ebp
    51c3:	83 ec 14             	sub    $0x14,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	struct sk_buff *result = skb_copy(skb, GFP_ATOMIC);
    51c6:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    51cd:	00 
    51ce:	8b 45 10             	mov    0x10(%ebp),%eax
    51d1:	89 5d f4             	mov    %ebx,0xfffffff4(%ebp)
    51d4:	89 75 f8             	mov    %esi,0xfffffff8(%ebp)
    51d7:	89 7d fc             	mov    %edi,0xfffffffc(%ebp)
    51da:	8b 7d 08             	mov    0x8(%ebp),%edi
    51dd:	89 04 24             	mov    %eax,(%esp,1)
    51e0:	e8 fc ff ff ff       	call   51e1 <startSimulation+0x21>
    51e5:	89 c6                	mov    %eax,%esi
	if(result == NULL) {
    51e7:	31 c0                	xor    %eax,%eax
    51e9:	85 f6                	test   %esi,%esi
    51eb:	8d 9f bc 00 00 00    	lea    0xbc(%edi),%ebx
    51f1:	74 44                	je     5237 <startSimulation+0x77>
		return NULL;
	}
	tp->t.responseMSK = cont;
    51f3:	8b 45 0c             	mov    0xc(%ebp),%eax
    51f6:	89 83 3c 0b 00 00    	mov    %eax,0xb3c(%ebx)
	tp->t.responseCount = 0;
    51fc:	31 c0                	xor    %eax,%eax
    51fe:	89 83 54 0b 00 00    	mov    %eax,0xb54(%ebx)

	BUG_TRAP(tp->t.responseList.len == 0);
    5204:	8b 9b 50 0b 00 00    	mov    0xb50(%ebx),%ebx
    520a:	85 db                	test   %ebx,%ebx
    520c:	75 36                	jne    5244 <startSimulation+0x84>
static inline int empty(struct alloc_head_list *head) {
	return head->next == (struct alloc_head*)head;
}

static inline void init_head(struct alloc_head_list *head) {
    520e:	8d 87 fc 0b 00 00    	lea    0xbfc(%edi),%eax
	head->next = head->prev = (struct alloc_head*)head;
    5214:	89 87 fc 0b 00 00    	mov    %eax,0xbfc(%edi)
    521a:	89 40 04             	mov    %eax,0x4(%eax)
	head->list = head;
    521d:	89 40 08             	mov    %eax,0x8(%eax)
	head->len = 0;
    5220:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	init_head(&tp->t.responseList);

	result->h.th = NULL;
	result->nh.iph = NULL;
	return result;	
    5227:	89 f0                	mov    %esi,%eax
    5229:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
    5230:	c7 46 24 00 00 00 00 	movl   $0x0,0x24(%esi)
}
    5237:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
    523a:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
    523d:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
    5240:	89 ec                	mov    %ebp,%esp
    5242:	5d                   	pop    %ebp
    5243:	c3                   	ret    
    5244:	c7 44 24 04 d7 0c 00 	movl   $0xcd7,0x4(%esp,1)
    524b:	00 
    524c:	c7 04 24 60 1e 00 00 	movl   $0x1e60,(%esp,1)
    5253:	e8 fc ff ff ff       	call   5254 <startSimulation+0x94>
    5258:	eb b4                	jmp    520e <startSimulation+0x4e>
    525a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00005260 <finishSimulation>:

void finishSimulation(struct sock *sk, CONTINUATION_TYPE *destCont, CONTINUATION_TYPE *simCont) {
    5260:	55                   	push   %ebp
    5261:	89 e5                	mov    %esp,%ebp
    5263:	57                   	push   %edi
    5264:	56                   	push   %esi
    5265:	53                   	push   %ebx
    5266:	83 ec 1c             	sub    $0x1c,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    5269:	8b 45 08             	mov    0x8(%ebp),%eax
    526c:	8b 7d 10             	mov    0x10(%ebp),%edi
    526f:	05 bc 00 00 00       	add    $0xbc,%eax
    5274:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	CONTINUATION_TYPE *finger;
	if(tp->t.responseCount >= 1) {
    5277:	8b 88 54 0b 00 00    	mov    0xb54(%eax),%ecx
    527d:	85 c9                	test   %ecx,%ecx
    527f:	0f 8e de 01 00 00    	jle    5463 <finishSimulation+0x203>
		int totalDataLen = 0;
    5285:	31 f6                	xor    %esi,%esi
		int i;
		BUG_TRAP(simCont == tp->t.responseMSK);
    5287:	3b b8 3c 0b 00 00    	cmp    0xb3c(%eax),%edi
    528d:	74 14                	je     52a3 <finishSimulation+0x43>
    528f:	c7 44 24 04 e5 0c 00 	movl   $0xce5,0x4(%esp,1)
    5296:	00 
    5297:	c7 04 24 c0 1e 00 00 	movl   $0x1ec0,(%esp,1)
    529e:	e8 fc ff ff ff       	call   529f <finishSimulation+0x3f>
		for(i=0; i < simCont->num_packets; i++) {
    52a3:	8b 97 dc 00 00 00    	mov    0xdc(%edi),%edx
    52a9:	31 db                	xor    %ebx,%ebx
    52ab:	39 d6                	cmp    %edx,%esi
    52ad:	7d 2b                	jge    52da <finishSimulation+0x7a>
    52af:	31 c9                	xor    %ecx,%ecx
    52b1:	eb 0d                	jmp    52c0 <finishSimulation+0x60>
    52b3:	90                   	nop    
    52b4:	90                   	nop    
    52b5:	90                   	nop    
    52b6:	90                   	nop    
    52b7:	90                   	nop    
    52b8:	90                   	nop    
    52b9:	90                   	nop    
    52ba:	90                   	nop    
    52bb:	90                   	nop    
    52bc:	90                   	nop    
    52bd:	90                   	nop    
    52be:	90                   	nop    
    52bf:	90                   	nop    
			totalDataLen += simCont->packets[i].len;
    52c0:	8b 87 e0 00 00 00    	mov    0xe0(%edi),%eax
    52c6:	43                   	inc    %ebx
    52c7:	8b 54 08 08          	mov    0x8(%eax,%ecx,1),%edx
    52cb:	83 c1 28             	add    $0x28,%ecx
    52ce:	01 d6                	add    %edx,%esi
    52d0:	8b 97 dc 00 00 00    	mov    0xdc(%edi),%edx
    52d6:	39 d3                	cmp    %edx,%ebx
    52d8:	7c e6                	jl     52c0 <finishSimulation+0x60>
			simCont->packets[i].contType &= ~CONTTYPE_HASHCOMPRESSED;
		}

		destCont->minResponseLen = totalDataLen;
    52da:	8b 4d 0c             	mov    0xc(%ebp),%ecx
		destCont->firstTransportChild = simCont->packets[0].seq;
    52dd:	8b 87 e0 00 00 00    	mov    0xe0(%edi),%eax
    52e3:	89 b1 b4 00 00 00    	mov    %esi,0xb4(%ecx)
    52e9:	8b 40 04             	mov    0x4(%eax),%eax
		destCont->numTransportChildren = simCont->num_packets;
    52ec:	89 91 bc 00 00 00    	mov    %edx,0xbc(%ecx)
    52f2:	89 81 b8 00 00 00    	mov    %eax,0xb8(%ecx)
	} else {
		//printk("No simulation output (could be harmless, e.g. during fast recovery!!\n");
		destCont->minResponseLen = 0;
		destCont->firstTransportChild = 0;
		destCont->numTransportChildren = 0;
		destCont->mark = -1;
	}
	finger = (CONTINUATION_TYPE*)tp->t.responseList.next;
    52f8:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
	while(finger != (CONTINUATION_TYPE*)&tp->t.responseList) {
    52fb:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    52fe:	8b 92 44 0b 00 00    	mov    0xb44(%edx),%edx
    5304:	81 c1 40 0b 00 00    	add    $0xb40,%ecx
    530a:	89 4d e8             	mov    %ecx,0xffffffe8(%ebp)
    530d:	39 ca                	cmp    %ecx,%edx
    530f:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
    5312:	0f 84 e9 00 00 00    	je     5401 <finishSimulation+0x1a1>
    5318:	90                   	nop    
    5319:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
		printk("responseListlen = %d\n", tp->t.responseList.len);
    5320:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx

#ifdef CAN_USE_TFREE
static inline void free_minisock(struct sock *sk, struct cminisock *msk) {
	int i;
	for(i=0; i < msk->num_packets; i++) {
    5323:	31 ff                	xor    %edi,%edi
    5325:	8b 82 50 0b 00 00    	mov    0xb50(%edx),%eax
    532b:	c7 04 24 7b 02 00 00 	movl   $0x27b,(%esp,1)
    5332:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    5336:	e8 fc ff ff ff       	call   5337 <finishSimulation+0xd7>
		printk("finger=%p (%p  %p)\n", finger, finger->prev, finger->next);
    533b:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    533e:	8b 41 04             	mov    0x4(%ecx),%eax
    5341:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    5345:	8b 01                	mov    (%ecx),%eax
    5347:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    534b:	c7 04 24 91 02 00 00 	movl   $0x291,(%esp,1)
    5352:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    5356:	e8 fc ff ff ff       	call   5357 <finishSimulation+0xf7>
		struct cminisock *clean = finger;
    535b:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
		finger = finger->next;
    535e:	8b 46 04             	mov    0x4(%esi),%eax
    5361:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    5364:	8b 56 04             	mov    0x4(%esi),%edx
    5367:	8b 06                	mov    (%esi),%eax
    5369:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    536b:	8b 06                	mov    (%esi),%eax
	elem->prev = elem->next = NULL;
    536d:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    5373:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
    5376:	8b 46 08             	mov    0x8(%esi),%eax
    5379:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
    5380:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    5383:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)

#ifdef CAN_USE_TFREE
static inline void free_minisock(struct sock *sk, struct cminisock *msk) {
	int i;
	for(i=0; i < msk->num_packets; i++) {
    538a:	8b 96 dc 00 00 00    	mov    0xdc(%esi),%edx
    5390:	39 d7                	cmp    %edx,%edi
    5392:	7d 26                	jge    53ba <finishSimulation+0x15a>
    5394:	31 db                	xor    %ebx,%ebx
    5396:	8d 76 00             	lea    0x0(%esi),%esi
    5399:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
		if(msk->packets[i].ucontData != NULL) {
    53a0:	8b 86 e0 00 00 00    	mov    0xe0(%esi),%eax
    53a6:	8b 44 18 18          	mov    0x18(%eax,%ebx,1),%eax
    53aa:	85 c0                	test   %eax,%eax
    53ac:	0f 85 9e 00 00 00    	jne    5450 <finishSimulation+0x1f0>
    53b2:	47                   	inc    %edi
    53b3:	83 c3 28             	add    $0x28,%ebx
    53b6:	39 d7                	cmp    %edx,%edi
    53b8:	7c e6                	jl     53a0 <finishSimulation+0x140>
			kfree(msk->packets[i].ucontData);
		}
	}
	if(!SIMULATION_MODE(sk) && msk->packets) {
    53ba:	8b 55 08             	mov    0x8(%ebp),%edx
    53bd:	8b 82 a8 02 00 00    	mov    0x2a8(%edx),%eax
    53c3:	a9 01 00 00 00       	test   $0x1,%eax
    53c8:	74 05                	je     53cf <finishSimulation+0x16f>
    53ca:	83 e0 08             	and    $0x8,%eax
    53cd:	74 0a                	je     53d9 <finishSimulation+0x179>
    53cf:	8b 86 e0 00 00 00    	mov    0xe0(%esi),%eax
    53d5:	85 c0                	test   %eax,%eax
    53d7:	75 60                	jne    5439 <finishSimulation+0x1d9>
		tfree(sk,msk->packets);
	}

	if(msk->ucont_data != NULL)
    53d9:	8b 86 80 00 00 00    	mov    0x80(%esi),%eax
    53df:	85 c0                	test   %eax,%eax
    53e1:	75 45                	jne    5428 <finishSimulation+0x1c8>
		tfree(sk,msk->ucont_data);
	if(msk->input != NULL)
    53e3:	8b 86 88 00 00 00    	mov    0x88(%esi),%eax
    53e9:	85 c0                	test   %eax,%eax
    53eb:	75 2a                	jne    5417 <finishSimulation+0x1b7>
		unlinkCont(clean);
		MARK_PC(clean);
		free_minisock(sk, clean);
		kfree(clean); // not a bug! alloc_trickles_msk creates the msk w/ kmalloc()
    53ed:	89 34 24             	mov    %esi,(%esp,1)
    53f0:	e8 fc ff ff ff       	call   53f1 <finishSimulation+0x191>
    53f5:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
    53f8:	39 4d ec             	cmp    %ecx,0xffffffec(%ebp)
    53fb:	0f 85 1f ff ff ff    	jne    5320 <finishSimulation+0xc0>
	}
	destCont->simulated = 1;
    5401:	8b 45 0c             	mov    0xc(%ebp),%eax
    5404:	ba 01 00 00 00       	mov    $0x1,%edx
    5409:	89 90 cc 00 00 00    	mov    %edx,0xcc(%eax)
}
    540f:	83 c4 1c             	add    $0x1c,%esp
    5412:	5b                   	pop    %ebx
    5413:	5e                   	pop    %esi
    5414:	5f                   	pop    %edi
    5415:	5d                   	pop    %ebp
    5416:	c3                   	ret    

	if(msk->ucont_data != NULL)
		tfree(sk,msk->ucont_data);
	if(msk->input != NULL)
		tfree(sk,msk->input);
    5417:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    541b:	8b 55 08             	mov    0x8(%ebp),%edx
    541e:	89 14 24             	mov    %edx,(%esp,1)
    5421:	e8 fc ff ff ff       	call   5422 <finishSimulation+0x1c2>
    5426:	eb c5                	jmp    53ed <finishSimulation+0x18d>
    5428:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    542c:	8b 45 08             	mov    0x8(%ebp),%eax
    542f:	89 04 24             	mov    %eax,(%esp,1)
    5432:	e8 fc ff ff ff       	call   5433 <finishSimulation+0x1d3>
    5437:	eb aa                	jmp    53e3 <finishSimulation+0x183>
    5439:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    543d:	8b 4d 08             	mov    0x8(%ebp),%ecx
    5440:	89 0c 24             	mov    %ecx,(%esp,1)
    5443:	e8 fc ff ff ff       	call   5444 <finishSimulation+0x1e4>
    5448:	eb 8f                	jmp    53d9 <finishSimulation+0x179>
    544a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    5450:	89 04 24             	mov    %eax,(%esp,1)
    5453:	e8 fc ff ff ff       	call   5454 <finishSimulation+0x1f4>
    5458:	8b 96 dc 00 00 00    	mov    0xdc(%esi),%edx
    545e:	e9 4f ff ff ff       	jmp    53b2 <finishSimulation+0x152>
    5463:	8b 45 0c             	mov    0xc(%ebp),%eax
    5466:	31 ff                	xor    %edi,%edi
    5468:	31 f6                	xor    %esi,%esi
    546a:	31 db                	xor    %ebx,%ebx
    546c:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
    5471:	89 b8 b4 00 00 00    	mov    %edi,0xb4(%eax)
    5477:	89 b0 b8 00 00 00    	mov    %esi,0xb8(%eax)
    547d:	89 98 bc 00 00 00    	mov    %ebx,0xbc(%eax)
    5483:	89 88 d8 00 00 00    	mov    %ecx,0xd8(%eax)
    5489:	e9 6a fe ff ff       	jmp    52f8 <finishSimulation+0x98>
    548e:	89 f6                	mov    %esi,%esi

00005490 <runSimulation>:

static int runSimulation(struct sock *sk, CONTINUATION_TYPE *cont, struct sk_buff *skb) {
    5490:	55                   	push   %ebp
    5491:	89 e5                	mov    %esp,%ebp
    5493:	57                   	push   %edi
    5494:	56                   	push   %esi
    5495:	53                   	push   %ebx
    5496:	83 ec 10             	sub    $0x10,%esp
	struct sk_buff *scratchSkb = startSimulation(sk, cont + 1, skb);
    5499:	8b 45 10             	mov    0x10(%ebp),%eax
    549c:	8b 7d 0c             	mov    0xc(%ebp),%edi
    549f:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    54a3:	8b 45 08             	mov    0x8(%ebp),%eax
    54a6:	81 c7 e4 00 00 00    	add    $0xe4,%edi
    54ac:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
    54b0:	89 04 24             	mov    %eax,(%esp,1)
    54b3:	e8 fc ff ff ff       	call   54b4 <runSimulation+0x24>
	if(scratchSkb == NULL) {
    54b8:	85 c0                	test   %eax,%eax
    54ba:	89 c3                	mov    %eax,%ebx
    54bc:	0f 84 ee 01 00 00    	je     56b0 <runSimulation+0x220>
		printk("Out of memory during simulation\n");
		return 0;
	}

	int rval = server_rcv_impl(sk, scratchSkb);
    54c2:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    54c6:	8b 4d 08             	mov    0x8(%ebp),%ecx
    54c9:	89 0c 24             	mov    %ecx,(%esp,1)
    54cc:	e8 fc ff ff ff       	call   54cd <runSimulation+0x3d>
	// server_rcv_impl never deallocates skb
	__kfree_skb(scratchSkb);
    54d1:	89 1c 24             	mov    %ebx,(%esp,1)
    54d4:	89 c6                	mov    %eax,%esi
    54d6:	e8 fc ff ff ff       	call   54d7 <runSimulation+0x47>
	if(rval == -EINVAL) {
    54db:	83 fe ea             	cmp    $0xffffffea,%esi
    54de:	0f 84 fc 00 00 00    	je     55e0 <runSimulation+0x150>
		if(!disableSevereErrors) {
			if(trickles_ratelimit()) {
				printk("simulation failure\n");
			}
		}
		finishSimulation(sk, cont, cont + 1);
		return 0;
	} else {
		if(rval != 0) {
    54e4:	85 f6                	test   %esi,%esi
    54e6:	74 70                	je     5558 <runSimulation+0xc8>
			if(trickles_ratelimit()) {
    54e8:	a1 00 00 00 00       	mov    0x0,%eax
    54ed:	9c                   	pushf  
    54ee:	59                   	pop    %ecx
    54ef:	fa                   	cli    
    54f0:	89 c2                	mov    %eax,%edx
    54f2:	8b 1d 68 e2 04 00    	mov    0x4e268,%ebx
    54f8:	a3 68 e2 04 00       	mov    %eax,0x4e268
    54fd:	29 da                	sub    %ebx,%edx
    54ff:	8b 1d 9c 00 00 00    	mov    0x9c,%ebx
    5505:	01 da                	add    %ebx,%edx
    5507:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    550d:	89 15 9c 00 00 00    	mov    %edx,0x9c
    5513:	76 0f                	jbe    5524 <runSimulation+0x94>
    5515:	b8 88 13 00 00       	mov    $0x1388,%eax
    551a:	ba 88 13 00 00       	mov    $0x1388,%edx
    551f:	a3 9c 00 00 00       	mov    %eax,0x9c
    5524:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    552a:	0f 86 a0 00 00 00    	jbe    55d0 <runSimulation+0x140>
    5530:	31 db                	xor    %ebx,%ebx
    5532:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    5538:	a1 6c e2 04 00       	mov    0x4e26c,%eax
    553d:	89 15 9c 00 00 00    	mov    %edx,0x9c
    5543:	89 1d 6c e2 04 00    	mov    %ebx,0x4e26c
    5549:	51                   	push   %ecx
    554a:	9d                   	popf   
    554b:	85 c0                	test   %eax,%eax
    554d:	75 5b                	jne    55aa <runSimulation+0x11a>
    554f:	b8 01 00 00 00       	mov    $0x1,%eax
    5554:	85 c0                	test   %eax,%eax
    5556:	75 40                	jne    5598 <runSimulation+0x108>
				printk("simulation rval == %d\n", rval);
			}
		}
		// debugging 
		struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
		tp->snd_cwnd = cont->actualCwnd;
    5558:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    555b:	8b 45 08             	mov    0x8(%ebp),%eax
    555e:	8b 91 d4 00 00 00    	mov    0xd4(%ecx),%edx
    5564:	05 bc 00 00 00       	add    $0xbc,%eax
    5569:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
		tp->snd_ssthresh = cont->ssthresh;
    556f:	8b 51 6c             	mov    0x6c(%ecx),%edx
    5572:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)
	}
	finishSimulation(sk, cont, cont + 1);
    5578:	8b 45 08             	mov    0x8(%ebp),%eax
    557b:	89 7c 24 08          	mov    %edi,0x8(%esp,1)
    557f:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    5583:	89 04 24             	mov    %eax,(%esp,1)
    5586:	e8 fc ff ff ff       	call   5587 <runSimulation+0xf7>
	return 1;
    558b:	b8 01 00 00 00       	mov    $0x1,%eax
}
    5590:	83 c4 10             	add    $0x10,%esp
    5593:	5b                   	pop    %ebx
    5594:	5e                   	pop    %esi
    5595:	5f                   	pop    %edi
    5596:	5d                   	pop    %ebp
    5597:	c3                   	ret    
    5598:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    559c:	c7 04 24 a5 02 00 00 	movl   $0x2a5,(%esp,1)
    55a3:	e8 fc ff ff ff       	call   55a4 <runSimulation+0x114>
    55a8:	eb ae                	jmp    5558 <runSimulation+0xc8>
    55aa:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    55ae:	c7 44 24 08 17 0d 00 	movl   $0xd17,0x8(%esp,1)
    55b5:	00 
    55b6:	c7 44 24 04 6b 00 00 	movl   $0x6b,0x4(%esp,1)
    55bd:	00 
    55be:	c7 04 24 c0 02 00 00 	movl   $0x2c0,(%esp,1)
    55c5:	e8 fc ff ff ff       	call   55c6 <runSimulation+0x136>
    55ca:	eb 83                	jmp    554f <runSimulation+0xbf>
    55cc:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    55d0:	ff 05 6c e2 04 00    	incl   0x4e26c
    55d6:	51                   	push   %ecx
    55d7:	9d                   	popf   
    55d8:	31 c0                	xor    %eax,%eax
    55da:	e9 75 ff ff ff       	jmp    5554 <runSimulation+0xc4>
    55df:	90                   	nop    
    55e0:	a1 00 00 00 00       	mov    0x0,%eax
    55e5:	85 c0                	test   %eax,%eax
    55e7:	75 6c                	jne    5655 <runSimulation+0x1c5>
    55e9:	a1 00 00 00 00       	mov    0x0,%eax
    55ee:	9c                   	pushf  
    55ef:	59                   	pop    %ecx
    55f0:	fa                   	cli    
    55f1:	89 c2                	mov    %eax,%edx
    55f3:	8b 35 60 e2 04 00    	mov    0x4e260,%esi
    55f9:	8b 1d 98 00 00 00    	mov    0x98,%ebx
    55ff:	a3 60 e2 04 00       	mov    %eax,0x4e260
    5604:	29 f2                	sub    %esi,%edx
    5606:	01 da                	add    %ebx,%edx
    5608:	89 15 98 00 00 00    	mov    %edx,0x98
    560e:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    5614:	76 0f                	jbe    5625 <runSimulation+0x195>
    5616:	b8 88 13 00 00       	mov    $0x1388,%eax
    561b:	ba 88 13 00 00       	mov    $0x1388,%edx
    5620:	a3 98 00 00 00       	mov    %eax,0x98
    5625:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    562b:	76 75                	jbe    56a2 <runSimulation+0x212>
    562d:	31 f6                	xor    %esi,%esi
    562f:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    5635:	a1 64 e2 04 00       	mov    0x4e264,%eax
    563a:	89 15 98 00 00 00    	mov    %edx,0x98
    5640:	89 35 64 e2 04 00    	mov    %esi,0x4e264
    5646:	51                   	push   %ecx
    5647:	9d                   	popf   
    5648:	85 c0                	test   %eax,%eax
    564a:	75 34                	jne    5680 <runSimulation+0x1f0>
    564c:	b8 01 00 00 00       	mov    $0x1,%eax
    5651:	85 c0                	test   %eax,%eax
    5653:	75 1d                	jne    5672 <runSimulation+0x1e2>
    5655:	89 7c 24 08          	mov    %edi,0x8(%esp,1)
    5659:	8b 45 0c             	mov    0xc(%ebp),%eax
    565c:	8b 4d 08             	mov    0x8(%ebp),%ecx
    565f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    5663:	89 0c 24             	mov    %ecx,(%esp,1)
    5666:	e8 fc ff ff ff       	call   5667 <runSimulation+0x1d7>
    566b:	31 c0                	xor    %eax,%eax
    566d:	e9 1e ff ff ff       	jmp    5590 <runSimulation+0x100>
    5672:	c7 04 24 bc 02 00 00 	movl   $0x2bc,(%esp,1)
    5679:	e8 fc ff ff ff       	call   567a <runSimulation+0x1ea>
    567e:	eb d5                	jmp    5655 <runSimulation+0x1c5>
    5680:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    5684:	c7 44 24 08 0f 0d 00 	movl   $0xd0f,0x8(%esp,1)
    568b:	00 
    568c:	c7 44 24 04 6b 00 00 	movl   $0x6b,0x4(%esp,1)
    5693:	00 
    5694:	c7 04 24 c0 02 00 00 	movl   $0x2c0,(%esp,1)
    569b:	e8 fc ff ff ff       	call   569c <runSimulation+0x20c>
    56a0:	eb aa                	jmp    564c <runSimulation+0x1bc>
    56a2:	ff 05 64 e2 04 00    	incl   0x4e264
    56a8:	51                   	push   %ecx
    56a9:	9d                   	popf   
    56aa:	31 c0                	xor    %eax,%eax
    56ac:	eb a3                	jmp    5651 <runSimulation+0x1c1>
    56ae:	89 f6                	mov    %esi,%esi
    56b0:	c7 04 24 20 1f 00 00 	movl   $0x1f20,(%esp,1)
    56b7:	e8 fc ff ff ff       	call   56b8 <runSimulation+0x228>
    56bc:	eb ad                	jmp    566b <runSimulation+0x1db>
    56be:	89 f6                	mov    %esi,%esi

000056c0 <sendAckHelper>:

#define USEFULNESS_THRESHOLD (1000) // don't use continuation unless we can receive at least this many bytes

static int sendAckHelper(struct sock *sk, CONTINUATION_TYPE *cont, enum TrickleRequestType type) {
    56c0:	55                   	push   %ebp
    56c1:	89 e5                	mov    %esp,%ebp
    56c3:	57                   	push   %edi
    56c4:	56                   	push   %esi
    56c5:	53                   	push   %ebx
    56c6:	83 ec 70             	sub    $0x70,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    56c9:	8b 45 08             	mov    0x8(%ebp),%eax
	struct sk_buff *skb;
	int res;
	while((skb=__skb_dequeue(&tp->t.sendAckOverflow))) {
    56cc:	8b 55 08             	mov    0x8(%ebp),%edx
    56cf:	05 bc 00 00 00       	add    $0xbc,%eax
    56d4:	8d 9a ec 0b 00 00    	lea    0xbec(%edx),%ebx
    56da:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    56dd:	8d 76 00             	lea    0x0(%esi),%esi
{
	struct sk_buff *next, *prev, *result;

	prev = (struct sk_buff *) list;
	next = prev->next;
    56e0:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
	result = NULL;
    56e3:	31 f6                	xor    %esi,%esi
    56e5:	8b 81 30 0b 00 00    	mov    0xb30(%ecx),%eax
	if (next != prev) {
    56eb:	39 d8                	cmp    %ebx,%eax
    56ed:	74 24                	je     5713 <sendAckHelper+0x53>
		result = next;
    56ef:	89 c6                	mov    %eax,%esi
		next = next->next;
    56f1:	8b 00                	mov    (%eax),%eax
		list->qlen--;
    56f3:	ff 4b 08             	decl   0x8(%ebx)
		next->prev = prev;
		prev->next = next;
		result->next = NULL;
		result->prev = NULL;
		result->list = NULL;
    56f6:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    56fd:	89 58 04             	mov    %ebx,0x4(%eax)
    5700:	89 81 30 0b 00 00    	mov    %eax,0xb30(%ecx)
    5706:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
    570d:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    5713:	89 75 ec             	mov    %esi,0xffffffec(%ebp)
    5716:	85 f6                	test   %esi,%esi
    5718:	0f 84 17 01 00 00    	je     5835 <sendAckHelper+0x175>
		BUG_TRAP(skb->sk == sk);
    571e:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    5721:	8b 45 08             	mov    0x8(%ebp),%eax
    5724:	39 41 0c             	cmp    %eax,0xc(%ecx)
    5727:	74 14                	je     573d <sendAckHelper+0x7d>
    5729:	c7 44 24 04 2b 0d 00 	movl   $0xd2b,0x4(%esp,1)
    5730:	00 
    5731:	c7 04 24 60 1f 00 00 	movl   $0x1f60,(%esp,1)
    5738:	e8 fc ff ff ff       	call   5739 <sendAckHelper+0x79>
		skb->sk = sk;
    573d:	8b 4d 08             	mov    0x8(%ebp),%ecx
    5740:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    5743:	89 4a 0c             	mov    %ecx,0xc(%edx)
		if((res = tp->af_specific->queue_xmit(skb, 0)) != 0) {
    5746:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5749:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    574c:	8b 82 dc 00 00 00    	mov    0xdc(%edx),%eax
    5752:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    5759:	00 
    575a:	89 0c 24             	mov    %ecx,(%esp,1)
    575d:	ff 10                	call   *(%eax)
    575f:	85 c0                	test   %eax,%eax
    5761:	0f 84 79 ff ff ff    	je     56e0 <sendAckHelper+0x20>
			if(trickles_ratelimit()) {
    5767:	8b 15 00 00 00 00    	mov    0x0,%edx
    576d:	9c                   	pushf  
    576e:	59                   	pop    %ecx
    576f:	fa                   	cli    
    5770:	89 d0                	mov    %edx,%eax
    5772:	8b 3d 70 e2 04 00    	mov    0x4e270,%edi
    5778:	89 15 70 e2 04 00    	mov    %edx,0x4e270
    577e:	29 f8                	sub    %edi,%eax
    5780:	8b 3d a0 00 00 00    	mov    0xa0,%edi
    5786:	01 f8                	add    %edi,%eax
    5788:	3d 88 13 00 00       	cmp    $0x1388,%eax
    578d:	a3 a0 00 00 00       	mov    %eax,0xa0
    5792:	76 10                	jbe    57a4 <sendAckHelper+0xe4>
    5794:	ba 88 13 00 00       	mov    $0x1388,%edx
    5799:	b8 88 13 00 00       	mov    $0x1388,%eax
    579e:	89 15 a0 00 00 00    	mov    %edx,0xa0
    57a4:	3d f3 01 00 00       	cmp    $0x1f3,%eax
    57a9:	76 7e                	jbe    5829 <sendAckHelper+0x169>
    57ab:	31 ff                	xor    %edi,%edi
    57ad:	2d f4 01 00 00       	sub    $0x1f4,%eax
    57b2:	8b 15 74 e2 04 00    	mov    0x4e274,%edx
    57b8:	a3 a0 00 00 00       	mov    %eax,0xa0
    57bd:	89 3d 74 e2 04 00    	mov    %edi,0x4e274
    57c3:	51                   	push   %ecx
    57c4:	9d                   	popf   
    57c5:	85 d2                	test   %edx,%edx
    57c7:	75 3e                	jne    5807 <sendAckHelper+0x147>
    57c9:	b8 01 00 00 00       	mov    $0x1,%eax
    57ce:	85 c0                	test   %eax,%eax
    57d0:	75 27                	jne    57f9 <sendAckHelper+0x139>
static inline void __skb_queue_head(struct sk_buff_head *list, struct sk_buff *newsk)
{
	struct sk_buff *prev, *next;

	newsk->list = list;
    57d2:	89 5e 08             	mov    %ebx,0x8(%esi)
	list->qlen++;
    57d5:	ff 43 08             	incl   0x8(%ebx)
	prev = (struct sk_buff *)list;
	next = prev->next;
    57d8:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
	newsk->next = next;
	newsk->prev = prev;
    57db:	89 5e 04             	mov    %ebx,0x4(%esi)
    57de:	8b 82 30 0b 00 00    	mov    0xb30(%edx),%eax
    57e4:	89 06                	mov    %eax,(%esi)
	next->prev = newsk;
    57e6:	89 70 04             	mov    %esi,0x4(%eax)
	prev->next = newsk;
    57e9:	89 b2 30 0b 00 00    	mov    %esi,0xb30(%edx)
				printk("dropped while sending ack from overflow\n");
			}
			// push back
			__skb_queue_head(&tp->t.sendAckOverflow, skb);
			return 0;
		}
	}

#if 0 // 0420, tracking down source of order 4096 objects
	skb = alloc_skb(MTU, GFP_ATOMIC);
#else 
	skb = alloc_skb(MAX_TCP_HEADER + MAX_TRICKLES_HDR_LEN + MTU, GFP_ATOMIC);
#endif
	WireTrickleRequest *wreq;
	int tcp_header_size;
	struct tcphdr *th;
	AckProof *proof;
	short windowValue = 0;
	
	TIMING_CTX_DEF0("sendAckHelper", "sent", "didn't send", "inner0", "inner10", "inner11");
	TIMING_CTX_DEF1(6, 4, 2, 3, 3);
	reinitTimingCtx(&ctx);
	recordSample(&ctx,0);
	recordSample(&ctx,1);

	if(skb == NULL) {
		printk("sendAckHelper: out of memory\n");
		return 0;
	}

	if(cont->state == CONT_BOOTSTRAP || 
	   type == TREQ_SLOWSTART) {
		proof = &tp->t.altProof;
		if(clientDebugLevel >= 2) {
			printk("sending alt proof\n");
			AckProof_dump(proof);
		}
	} else {
		proof = &tp->t.standardProof;
	}

	skb_reserve(skb, MAX_TCP_HEADER);
	wreq = (WireTrickleRequest *)skb_put(skb, sizeof(WireTrickleRequest) + proof->numSacks * sizeof(WireSack));
	//printk("sendackhelper - req: %p\n", &req->cont);

	wreq->type = type;
	recordSample(&ctx,0);
	recordSample(&ctx,1);

	__u32 oldClientTimestamp = cont->clientTimestamp ;
	__u32 oldClientState = cont->clientState;
	cont->clientTimestamp = jiffies;
	cont->clientState = tp->t.clientStateCounter;
	marshallContinuationClient(sk,&wreq->cont,cont, -1);
#ifdef ENABLE_HASHCOMPRESS
	// reset number of children that we have received
	cont->numChildrenReceived = 0;
	// dont restore the timestamp and client state; we need them when reconstructing the packet
#else
	cont->clientTimestamp = oldClientTimestamp;
	cont->clientState = oldClientState;
#endif

	marshallAckProof(&wreq->ackProof, proof);
	recordSample(&ctx,0);
	recordSample(&ctx,1);

	if(IS_SEND_UCONTREQ_STATE(tp)) {
		// Only send requests in normal state
		// Manage reliable request queue here
		if(HAS_PENDING_REQUESTS(sk)) {
			recordSample(&ctx,2);
			wreq->ucont_len = 0; // hack to make input to simulation well-formed
			/* Execute simulation to initialize 
			   minResponseLen
			   firstTransportChild
			   numTransportChildren 
			   
			   MUST occur after skb is initialized with transport-level fields!
			*/
			if(!runSimulation(sk,cont,skb)) goto out_free_error;
			if(cont->minResponseLen < USEFULNESS_THRESHOLD) goto out_free_ignore_this_cont;

			struct Request *mreq = (struct Request*)tp->t.queuedRequests.next;

			unlink((struct alloc_head*)mreq);
			insert_tail(&tp->t.sentRequests, (struct alloc_head*)mreq);
			mreq->transport_seq = cont->seq;
			if(mreq->isNew) {
				mreq->seq = tp->t.request_snd_nxt;
				tp->t.request_snd_nxt = tp->t.request_snd_nxt + 1; // sequence number is the identifier to match during scoreboard management
				mreq->isNew = 0;
			}
			// Now that we have UC sequence number, marshall continuation
			wreq->cont.parent = mreq->seq;

			/* All MTU handling is performed at this level */
			switch(mreq->type) {
			case MREQ_CONVERSION: {
				struct ConversionRequest *convReq = 
					(struct ConversionRequest *)mreq;
				struct sk_buff *input_skb;
				unsigned outContLen, copyLen, copyOffset;
				__u16 wlen;

				input_skb = convReq->data;
				copyOffset = convReq->offset;
				if(convReq->incomplete) {
					struct WireUC_CVT_IncompleteRequest *wInConvReq;
					unsigned contLen;

					/* get current position */
					wInConvReq = (struct WireUC_CVT_IncompleteRequest *)
						skb_put(skb, sizeof(*wInConvReq));
					contLen = convReq->predLength;
					skb_put(skb, contLen - sizeof(wInConvReq->predCont));
					memcpy(&wInConvReq->predCont, convReq->incompletePred, contLen);
					wInConvReq->type = UC_INCOMPLETE;
					outContLen = (char*)skb_put(skb, 0) - (char*)wInConvReq;
					wlen = htons((short)outContLen);
					wInConvReq->len = wlen;
					wInConvReq->seq = 
						htonl(TCP_SKB_CB(input_skb)->seq + copyOffset);
				} else {
					struct WireUC_CVT_CompleteRequest *wConvReq;
					unsigned contLen;

					wConvReq = (struct WireUC_CVT_CompleteRequest*)
						skb_put(skb, sizeof(*wConvReq));
					contLen = marshallUC_Continuation(&wConvReq->predCont, 
									  convReq->completePred);

					skb_put(skb, contLen - sizeof(wConvReq->predCont));
					wConvReq->type = UC_COMPLETE;
					outContLen = (char*)skb_put(skb, 0) - (char*)wConvReq;
					wlen = htons((short)outContLen);
					wConvReq->len = wlen;
					wConvReq->seq = 
						htonl(TCP_SKB_CB(input_skb)->seq + copyOffset);
				}
				if(outContLen > MTU) {
					printk("outContLen > MTU\n");
					recordSample(&ctx,1);
					goto out_free_error;
				}
				wreq->ucont_len = wlen;

				convReq->start = TCP_SKB_CB(input_skb)->seq + copyOffset;
				copyLen = MIN(MTU - outContLen, tp->t.write_seq - tp->t.snd_una);
				convReq->end = convReq->start + copyLen;

				/* Update snd_end to allow for progress check */
				tp->t.snd_end = convReq->end;

				/* Copy bytestream to request */
				BUG_TRAP(copyLen + outContLen <= MTU);
				while(copyLen > 0) {
					unsigned pieceLen = MIN(input_skb->len - copyOffset, copyLen);
					memcpy(skb_put(skb, pieceLen), input_skb->data + copyOffset, pieceLen);
					copyOffset = 0;
					copyLen -= pieceLen;
					input_skb = input_skb->next;
				}
#ifdef PRINT_CLIENT_CONVERSIONCOUNT
				static int conversionCount = 0;
				conversionCount++;
				if(trickles_ratelimit()) {
					printk("conversionCount = %d\n", conversionCount);
				}
#endif
				break;
			}
			case MREQ_CONTINUATION: {
				struct ContinuationRequest *updateReq = (struct ContinuationRequest *)mreq;
				struct WireUC_MGMT_UpdateRequest *wUpdateReq;
				int i;
				unsigned numContinuations = updateReq->numConts;
				unsigned totalLen = 0;

				wUpdateReq = (struct WireUC_MGMT_UpdateRequest*)skb_put(skb, sizeof(*wUpdateReq));
				wUpdateReq->newStart = htonl(updateReq->start);
				wUpdateReq->newEnd = htonl(updateReq->end);
				wUpdateReq->numContinuations = (__u8)numContinuations;
				for(i=0; i < numContinuations; i++) {
					// length
					__u16 *lenPtr = (__u16*)skb_put(skb, sizeof(__u16));
					unsigned contLen;
					contLen = marshallUC_Continuation((struct WireUC_Continuation*)skb_put(skb, 0), updateReq->conts[i]);
					skb_put(skb, contLen);
					*lenPtr = htons((short)contLen);
					totalLen += sizeof(__u16) + contLen;
				}
				BUG_TRAP(totalLen <= MTU);
				wUpdateReq->type = UC_UPDATE;
				wUpdateReq->len = htons((short)(sizeof(*wUpdateReq) + totalLen));
				wreq->ucont_len = wUpdateReq->len;
				break;
			}
			default:
				printk("sendackhelper: Unknown request type!\n");
				recordSample(&ctx,1);
				goto out_free_error;
			}
			mreq->transportResponseSeqStart = cont->firstTransportChild;
			mreq->transportResponseSeqEnd = 
				mreq->transportResponseSeqStart + cont->numTransportChildren;

			recordSample(&ctx,2);
		} else if((/* (tp->trickles_opt & TCP_TRICKLES_RCV_START) && */ (tp->t.byteReqNext < tp->copied_seq + sk->rcvbuf)) || !empty(&tp->t.missingDataMap)) {
			struct WireUC_DataRequest *wDataReq = (struct WireUC_DataRequest*)
				skb_put(skb, sizeof(struct WireUC_DataRequest));
			unsigned outContLen;
			void *ptr;
			struct DataRequestMapping *dataReqMap = NULL, *finger;
			struct UC_Continuation *ucont;

			wreq->ucont_len = 0; // hack to make input to simulation well-formed

			/* Execute simulation to initialize 
			   minResponseLen
			   firstTransportChild
			   numTransportChildren 

			   MUST occur after skb is initialized with transport-level fields!

			   xxx There should not be any simulation
			   dependencies on the header fields that are
			   initialized after start of simulation
			*/
			if(!runSimulation(sk,cont,skb)) goto out_free_error;
			if(cont->minResponseLen < USEFULNESS_THRESHOLD) goto out_free_ignore_this_cont;


			int maxLen = cont->minResponseLen;
			unsigned tseq_start = cont->firstTransportChild,
				tseq_end = tseq_start + cont->numTransportChildren;
			BUG_TRAP(tseq_start != -1 && tseq_end != -1);
			if(cont->minResponseLen <= 0) {
				printk("simulation responseLen: %d\n", cont->minResponseLen);
			}

			if(!empty(&tp->t.missingDataMap)) {
				recordSample(&ctx,3);
				BUG_TRAP(enableDataRecovery);

				dataReqMap = (struct DataRequestMapping*)tp->t.missingDataMap.next;
				ucont = dataReqMap->ucont;

				if(dataReqMap->end - dataReqMap->start > maxLen) {
					unsigned newStart = dataReqMap->start + maxLen;
					struct DataRequestMapping *rest = 
						newDataRequestMapping(ucont, -1, -1, newStart, dataReqMap->end);
					if(rest == NULL) {
						printk("out of memory while splitting missing data mapping\n");
						recordSample(&ctx,1);
						goto out_free_error;
					}
					dataReqMap->end = newStart;
					insert_tail(&tp->t.missingDataMap, 
								(struct alloc_head*)rest);
				}
				unlink((struct alloc_head*)dataReqMap);
				dataReqMap->transportResponseSeqStart = tseq_start;
				dataReqMap->transportResponseSeqEnd = tseq_end;
				recordSample(&ctx,3);
			} else {
				recordSample(&ctx,4);
				struct sk_buff *finger;
				unsigned start,
					end;
				unsigned gapLen = maxLen;
				// XXX: needs more performance tuning, e.g. hint pointing at next element to process
				if(tp->t.byteReqHint) {
					finger = tp->t.byteReqHint;
				} else {
					finger = tp->t.data_ofo_queue.next;
				}
				// SACK: Find a gap to fill in
				while(finger != (struct sk_buff*)&tp->t.data_ofo_queue) {
					if(SKB_CONTAINS(finger, tp->t.byteReqNext)) {
						tp->t.byteReqNext = TCP_SKB_CB(finger)->end_seq;
						if(finger->next != (struct sk_buff*)&tp->t.data_ofo_queue) {
							gapLen = TCP_SKB_CB(finger->next)->seq - tp->t.byteReqNext;
						}
					} else if(TCP_SKB_CB(finger)->seq > tp->t.byteReqNext) {
						break;
					}
					finger = finger->next;
				}
				if(finger != (struct sk_buff *)&tp->t.data_ofo_queue) {
					tp->t.byteReqHint = finger;
				} else {
					tp->t.byteReqHint = NULL;
				}

				start = tp->t.byteReqNext;
				ucont = findUCContinuation(sk, start, start + gapLen);
				if(ucont == NULL) {
					recordSample(&ctx,1);
					goto out_free_error;
				}

				tp->t.byteReqNext = end = 
					MIN(start + gapLen, ucont->validEnd);
				tp->t.byteReqHint = NULL;
				dataReqMap = newDataRequestMapping(ucont, tseq_start, tseq_end, start, end);
				if(dataReqMap == NULL) {
					printk("Out of memory while allocating new data request mapping\n");
					recordSample(&ctx,1);
					goto out_free_error;
				}
				recordSample(&ctx,4);
			}
			finger = (struct DataRequestMapping*)tp->t.dataRequestMap.prev;
#ifndef DISABLE_DATAREQUEST
			insert_tail(&tp->t.dataRequestMap, (struct alloc_head*)dataReqMap);
#endif
			dataReqMap->sent = 1;

			if(finger != (struct DataRequestMapping *)&tp->t.dataRequestMap) {
				if(finger->transportResponseSeqEnd > tseq_start) {
					if(!disableSevereErrors) {
						printk("WARNING: Out of order continuation transportResponseSeqEnd received (%u %u). Either server or client is buggy\n", finger->transportResponseSeqEnd, tseq_start);
					}
				}
			}

			// update parent with latest sequence number
			wreq->cont.parent = -1;
			wDataReq->type = UC_DATA;
			wDataReq->len = htons(sizeof(struct WireUC_DataRequest));
			wDataReq->start = htonl(dataReqMap->start);
			wDataReq->end = htonl(dataReqMap->end);
#ifdef PRINT_CLIENT_ZEROCOUNT
			if(wDataReq->start == wDataReq->end) {
				static int zeroCount = 0;
				zeroCount++;
				if(trickles_ratelimit()) {
					printk("client ZeroCount %d\n", zeroCount);
				}
			}
#endif

			// 0419
			if(!disableSevereErrors && ntohl(wDataReq->end) - ntohl(wDataReq->start) > MTU * 10) {
				printk("maxLen = %d > MTU * 10\n", ntohl(wDataReq->end) - ntohl(wDataReq->start));
			}

			windowValue = (dataReqMap->end - tp->copied_seq) >> 5;
#ifndef TEST_TRANSPORT_ONLY
			outContLen = sizeof(struct WireUC_DataRequest) +
				marshallUC_Continuation((struct WireUC_Continuation *)skb_put(skb,0), dataReqMap->ucont);
#else
#error "not kept up to date"
			outContLen = sizeof(struct WireUC_DataRequest);
#endif
			ptr = skb_put(skb, outContLen);
			wreq->ucont_len = htons(outContLen);
#ifdef DISABLE_DATAREQUEST // 0418 added in attempt to isolate mapping lists from rest of system
			freeDataRequestMapping(dataReqMap);
#endif
			recordSample(&ctx,3);
			recordSample(&ctx,4);
		} else {
			/* couldn't send out a request */
			if(tp->rcv_nxt > tp->copied_seq) // only safe if user_ack will reset this bit later
				tp->t.timerState &= ~TRICKLES_ENABLE_DATA_TIMEOUT;
			recordSample(&ctx,1);
			goto out_free_error;
		}
		/* Todo: Add support for direct interface */
	} else {
		/* In all other states, do only transport layer */
		wreq->ucont_len = htons(0);
		wreq->cont.parent = -1;

		if(!runSimulation(sk,cont,skb)) goto out_free_error;
		if(cont->minResponseLen < USEFULNESS_THRESHOLD) goto out_free_ignore_this_cont;

		static int transportCount = 0;
		transportCount++;
		if(trickles_ratelimit()) {
			printk("transportCount = %d\n", transportCount);
		}
	}

	if(tp->t.eventsPos == 0) {
		goto sample;
	} else {
		struct TricklesLossEvent *lastEvent = &tp->t.events[tp->t.eventsPos - 1];
		if(tp->t.state != lastEvent->state) {
		// state change
			appendTricklesLossEvent(sk, MIN((cont+1)->mark, EVENT_CWND_MAX), 
						EVENT_EXTRA_SEND, tp->t.state);
		}  else if(jiffies - lastEvent->time >= HZ) {
		sample:
			appendTricklesLossEvent(sk, MIN(tp->t.cont_list.len, EVENT_CWND_MAX), 
						EVENT_EXTRA_SAMPLE0, tp->t.state);
			appendTricklesLossEvent(sk, MIN((cont+1)->mark, EVENT_CWND_MAX), 
						EVENT_EXTRA_SAMPLE1, tp->t.state);
		}
	}

	skb->csum = 0;
	skb->ip_summed = CHECKSUM_HW;
	skb->sk = sk;
	tcp_header_size = sizeof(struct tcphdr) + TCPOLEN_TRICKLES;
	th = (struct tcphdr *) skb_push(skb, tcp_header_size);
	skb->h.th = th;
	th->source = sk->sport;
	th->dest = sk->dport;
	th->seq = -1; // todo: set useful values here
	// set tcp header size and zero out flags 

	th->doff = tcp_header_size >> 2;
	th->ack = htonl(cont->seq);

	// TODO: Find uses for window, urg_ptr fields
	th->window = htons(windowValue);
	th->check = 0;
	th->urg_ptr = 0;
	*(__u32*)(th+1) = htonl((TCPOPT_TRICKLES << 24)  | 
				(TCPOLEN_TRICKLES << 16) |
				0);
	th->ack = 1;
	th->syn = 0;
	th->fin = 0;
	th->rst = 0;

#ifndef USERTEST
	recordSample(&ctx,0);
	trickles_checksum(skb, skb->len);
	recordSample(&ctx,0);
	if((res = tp->af_specific->queue_xmit(skb, 0)) != 0) {
		if(trickles_ratelimit()) {
			printk("sendAckHelper wants to spill to overflow due to send failure (tx res = %d)\n", res);
#ifndef DISABLE_SENDACKOVERFLOW
			printk("However, it's disabled!!! All you need is an skb_copy() above in the queue_xmit, but I haven't tested it\n", res);
#endif
		}
#ifndef DISABLE_SENDACKOVERFLOW
		__skb_queue_tail(&tp->t.sendAckOverflow, skb);
#else
		//__kfree_skb(skb);
#endif
	}
	recordSample(&ctx,0);
#else
	skb->nh.iph = (struct iphdr*)skb_push(skb, sizeof(struct iphdr));
	skb->nh.iph->daddr = sk->daddr;
	skb->nh.iph->saddr = sk->saddr;
	sendtoserver(skb);
#endif

	printTimings(&ctx);
	return 1;
 out_free_error:
	__kfree_skb(skb);
	return 0;
    57ef:	31 c0                	xor    %eax,%eax
 out_free_ignore_this_cont:
	__kfree_skb(skb);
	return 1;
}
    57f1:	83 c4 70             	add    $0x70,%esp
    57f4:	5b                   	pop    %ebx
    57f5:	5e                   	pop    %esi
    57f6:	5f                   	pop    %edi
    57f7:	5d                   	pop    %ebp
    57f8:	c3                   	ret    
    57f9:	c7 04 24 a0 1f 00 00 	movl   $0x1fa0,(%esp,1)
    5800:	e8 fc ff ff ff       	call   5801 <sendAckHelper+0x141>
    5805:	eb cb                	jmp    57d2 <sendAckHelper+0x112>
    5807:	89 54 24 0c          	mov    %edx,0xc(%esp,1)
    580b:	c7 44 24 08 2e 0d 00 	movl   $0xd2e,0x8(%esp,1)
    5812:	00 
    5813:	c7 44 24 04 6b 00 00 	movl   $0x6b,0x4(%esp,1)
    581a:	00 
    581b:	c7 04 24 c0 02 00 00 	movl   $0x2c0,(%esp,1)
    5822:	e8 fc ff ff ff       	call   5823 <sendAckHelper+0x163>
    5827:	eb a0                	jmp    57c9 <sendAckHelper+0x109>
    5829:	ff 05 74 e2 04 00    	incl   0x4e274
    582f:	51                   	push   %ecx
    5830:	9d                   	popf   
    5831:	31 c0                	xor    %eax,%eax
    5833:	eb 99                	jmp    57ce <sendAckHelper+0x10e>
    5835:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    583c:	00 
    583d:	c7 04 24 40 09 00 00 	movl   $0x940,(%esp,1)
    5844:	e8 fc ff ff ff       	call   5845 <sendAckHelper+0x185>
    5849:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    584c:	85 c0                	test   %eax,%eax
    584e:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
    5855:	0f 84 d8 12 00 00    	je     6b33 <sendAckHelper+0x1473>
    585b:	8b 75 0c             	mov    0xc(%ebp),%esi
    585e:	83 7e 58 02          	cmpl   $0x2,0x58(%esi)
    5862:	0f 84 97 12 00 00    	je     6aff <sendAckHelper+0x143f>
    5868:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    586c:	0f 84 8d 12 00 00    	je     6aff <sendAckHelper+0x143f>
    5872:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    5875:	81 c1 00 03 00 00    	add    $0x300,%ecx
    587b:	89 4d e8             	mov    %ecx,0xffffffe8(%ebp)
 */

static inline void skb_reserve(struct sk_buff *skb, unsigned int len)
{
	skb->data+=len;
    587e:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
	skb->tail+=len;
    5881:	8b be 98 00 00 00    	mov    0x98(%esi),%edi
    5887:	81 86 94 00 00 00 a0 	addl   $0xa0,0x94(%esi)
    588e:	00 00 00 
    5891:	8d 87 a0 00 00 00    	lea    0xa0(%edi),%eax
    5897:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    589a:	89 86 98 00 00 00    	mov    %eax,0x98(%esi)
    58a0:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    58a3:	8b 02                	mov    (%edx),%eax
    58a5:	8d 04 40             	lea    (%eax,%eax,2),%eax
    58a8:	8d 14 85 4e 00 00 00 	lea    0x4e(,%eax,4),%edx
    58af:	8b 46 74             	mov    0x74(%esi),%eax
    58b2:	85 c0                	test   %eax,%eax
    58b4:	0f 85 8a 12 00 00    	jne    6b44 <sendAckHelper+0x1484>
    58ba:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    58bd:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    58c0:	01 d0                	add    %edx,%eax
    58c2:	01 51 70             	add    %edx,0x70(%ecx)
    58c5:	3b 81 9c 00 00 00    	cmp    0x9c(%ecx),%eax
    58cb:	89 81 98 00 00 00    	mov    %eax,0x98(%ecx)
    58d1:	0f 87 0f 12 00 00    	ja     6ae6 <sendAckHelper+0x1426>
    58d7:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
    58db:	88 87 a0 00 00 00    	mov    %al,0xa0(%edi)
    58e1:	8b 55 0c             	mov    0xc(%ebp),%edx
    58e4:	a1 00 00 00 00       	mov    0x0,%eax
    58e9:	8b 5a 50             	mov    0x50(%edx),%ebx
    58ec:	8b 72 3c             	mov    0x3c(%edx),%esi
    58ef:	89 42 50             	mov    %eax,0x50(%edx)
    58f2:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    58f5:	8b 81 c8 02 00 00    	mov    0x2c8(%ecx),%eax
    58fb:	89 42 3c             	mov    %eax,0x3c(%edx)
    58fe:	8d 87 a1 00 00 00    	lea    0xa1(%edi),%eax
    5904:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    5908:	8b 45 08             	mov    0x8(%ebp),%eax
    590b:	89 54 24 08          	mov    %edx,0x8(%esp,1)
    590f:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp,1)
    5916:	ff 
    5917:	89 04 24             	mov    %eax,(%esp,1)
    591a:	e8 01 2b 00 00       	call   8420 <marshallContinuationClient>
    591f:	8b 55 0c             	mov    0xc(%ebp),%edx
    5922:	8d 87 ed 00 00 00    	lea    0xed(%edi),%eax
    5928:	89 72 3c             	mov    %esi,0x3c(%edx)
    592b:	89 5a 50             	mov    %ebx,0x50(%edx)
    592e:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
    5931:	89 04 24             	mov    %eax,(%esp,1)
    5934:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    5938:	e8 83 2b 00 00       	call   84c0 <marshallAckProof>
    593d:	8b 75 f0             	mov    0xfffffff0(%ebp),%esi
    5940:	8b 86 cc 02 00 00    	mov    0x2cc(%esi),%eax
    5946:	48                   	dec    %eax
    5947:	83 f8 02             	cmp    $0x2,%eax
    594a:	0f 87 96 10 00 00    	ja     69e6 <sendAckHelper+0x1326>
#ifdef __KERNEL__
#define VALID_MSK_CTL(X) ((X)->ctl == ALLOC_READY || \
                          (X)->ctl == ALLOC_HALFFREE)

static inline int empty(struct alloc_head_list *head) {
    5950:	8b 45 08             	mov    0x8(%ebp),%eax
    5953:	05 38 0b 00 00       	add    $0xb38,%eax
    5958:	39 40 04             	cmp    %eax,0x4(%eax)
    595b:	0f 85 a1 08 00 00    	jne    6202 <sendAckHelper+0xb42>
    5961:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    5964:	8b 75 08             	mov    0x8(%ebp),%esi
    5967:	8b 91 fc 00 00 00    	mov    0xfc(%ecx),%edx
    596d:	8b 7e 38             	mov    0x38(%esi),%edi
    5970:	89 d0                	mov    %edx,%eax
    5972:	01 f8                	add    %edi,%eax
    5974:	39 81 b8 0a 00 00    	cmp    %eax,0xab8(%ecx)
    597a:	72 10                	jb     598c <sendAckHelper+0x2cc>
#ifdef __KERNEL__
#define VALID_MSK_CTL(X) ((X)->ctl == ALLOC_READY || \
                          (X)->ctl == ALLOC_HALFFREE)

static inline int empty(struct alloc_head_list *head) {
    597c:	89 c8                	mov    %ecx,%eax
    597e:	05 a4 0a 00 00       	add    $0xaa4,%eax
    5983:	39 40 04             	cmp    %eax,0x4(%eax)
    5986:	0f 84 5e 08 00 00    	je     61ea <sendAckHelper+0xb2a>
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
    598c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    598f:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    5992:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
    5998:	89 45 ac             	mov    %eax,0xffffffac(%ebp)
    599b:	8b 5a 74             	mov    0x74(%edx),%ebx
    599e:	85 db                	test   %ebx,%ebx
    59a0:	0f 85 9e 11 00 00    	jne    6b44 <sendAckHelper+0x1484>
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
    59a6:	8b 45 ac             	mov    0xffffffac(%ebp),%eax
    59a9:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    59ac:	83 c0 0c             	add    $0xc,%eax
	skb->len+=len;
    59af:	83 41 70 0c          	addl   $0xc,0x70(%ecx)
	if(skb->tail>skb->end) {
    59b3:	3b 81 9c 00 00 00    	cmp    0x9c(%ecx),%eax
    59b9:	89 81 98 00 00 00    	mov    %eax,0x98(%ecx)
    59bf:	0f 87 08 08 00 00    	ja     61cd <sendAckHelper+0xb0d>
    59c5:	8b 75 e0             	mov    0xffffffe0(%ebp),%esi
    59c8:	66 c7 46 4b 00 00    	movw   $0x0,0x4b(%esi)
    59ce:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    59d1:	8b 55 0c             	mov    0xc(%ebp),%edx
    59d4:	8b 4d 08             	mov    0x8(%ebp),%ecx
    59d7:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    59db:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    59df:	89 0c 24             	mov    %ecx,(%esp,1)
    59e2:	e8 a9 fa ff ff       	call   5490 <runSimulation>
    59e7:	85 c0                	test   %eax,%eax
    59e9:	0f 84 25 06 00 00    	je     6014 <sendAckHelper+0x954>
    59ef:	8b 75 0c             	mov    0xc(%ebp),%esi
    59f2:	8b 9e b4 00 00 00    	mov    0xb4(%esi),%ebx
    59f8:	81 fb e7 03 00 00    	cmp    $0x3e7,%ebx
    59fe:	89 d8                	mov    %ebx,%eax
    5a00:	0f 86 b7 07 00 00    	jbe    61bd <sendAckHelper+0xafd>
    5a06:	8b 96 b8 00 00 00    	mov    0xb8(%esi),%edx
    5a0c:	89 55 a4             	mov    %edx,0xffffffa4(%ebp)
    5a0f:	8b 8e bc 00 00 00    	mov    0xbc(%esi),%ecx
    5a15:	01 ca                	add    %ecx,%edx
    5a17:	83 7d a4 ff          	cmpl   $0xffffffff,0xffffffa4(%ebp)
    5a1b:	89 55 a0             	mov    %edx,0xffffffa0(%ebp)
    5a1e:	0f 84 77 07 00 00    	je     619b <sendAckHelper+0xadb>
    5a24:	42                   	inc    %edx
    5a25:	0f 84 70 07 00 00    	je     619b <sendAckHelper+0xadb>
    5a2b:	85 c0                	test   %eax,%eax
    5a2d:	0f 84 4f 07 00 00    	je     6182 <sendAckHelper+0xac2>
#ifdef __KERNEL__
#define VALID_MSK_CTL(X) ((X)->ctl == ALLOC_READY || \
                          (X)->ctl == ALLOC_HALFFREE)

static inline int empty(struct alloc_head_list *head) {
    5a33:	8b 7d f0             	mov    0xfffffff0(%ebp),%edi
    5a36:	81 c7 a4 0a 00 00    	add    $0xaa4,%edi
    5a3c:	39 7f 04             	cmp    %edi,0x4(%edi)
    5a3f:	0f 84 f8 05 00 00    	je     603d <sendAckHelper+0x97d>
    5a45:	a1 00 00 00 00       	mov    0x0,%eax
    5a4a:	85 c0                	test   %eax,%eax
    5a4c:	0f 84 d2 05 00 00    	je     6024 <sendAckHelper+0x964>
    5a52:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    5a55:	8b b0 a8 0a 00 00    	mov    0xaa8(%eax),%esi
    5a5b:	8b 56 0c             	mov    0xc(%esi),%edx
    5a5e:	89 55 a8             	mov    %edx,0xffffffa8(%ebp)
    5a61:	8b 4e 24             	mov    0x24(%esi),%ecx
    5a64:	89 c8                	mov    %ecx,%eax
    5a66:	89 4d 9c             	mov    %ecx,0xffffff9c(%ebp)
    5a69:	8b 56 20             	mov    0x20(%esi),%edx
    5a6c:	29 d0                	sub    %edx,%eax
    5a6e:	39 d8                	cmp    %ebx,%eax
    5a70:	0f 87 b6 04 00 00    	ja     5f2c <sendAckHelper+0x86c>
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    5a76:	8b 56 04             	mov    0x4(%esi),%edx
    5a79:	8b 06                	mov    (%esi),%eax
    5a7b:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    5a7d:	8b 06                	mov    (%esi),%eax
	elem->prev = elem->next = NULL;
    5a7f:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    5a85:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
    5a88:	8b 46 08             	mov    0x8(%esi),%eax
    5a8b:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
    5a92:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    5a95:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    5a9c:	8b 45 a4             	mov    0xffffffa4(%ebp),%eax
    5a9f:	89 46 18             	mov    %eax,0x18(%esi)
    5aa2:	8b 55 a0             	mov    0xffffffa0(%ebp),%edx
    5aa5:	89 56 1c             	mov    %edx,0x1c(%esi)
    5aa8:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5aab:	8b ba 90 0a 00 00    	mov    0xa90(%edx),%edi
	elem->list = head;
	head->len++;
}

static inline void insert_tail(struct alloc_head_list *head, struct alloc_head *elem) {
    5ab1:	89 d3                	mov    %edx,%ebx
    5ab3:	81 c3 90 0a 00 00    	add    $0xa90,%ebx
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
    5ab9:	39 f7                	cmp    %esi,%edi
    5abb:	89 f8                	mov    %edi,%eax
	if(elem->list) {
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
    5abd:	0f 84 36 04 00 00    	je     5ef9 <sendAckHelper+0x839>
		BUG();
		show_stack(NULL);
	}
	elem->prev = head->prev;
    5ac3:	89 06                	mov    %eax,(%esi)
	head->prev->next = elem;
    5ac5:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5ac8:	8b 82 90 0a 00 00    	mov    0xa90(%edx),%eax

	elem->next = (struct alloc_head*)head;

	elem->list = head;
    5ace:	89 5e 08             	mov    %ebx,0x8(%esi)
    5ad1:	89 70 04             	mov    %esi,0x4(%eax)
    5ad4:	89 5e 04             	mov    %ebx,0x4(%esi)
	head->prev = elem;
	head->len++;
    5ad7:	ff 43 10             	incl   0x10(%ebx)
    5ada:	39 df                	cmp    %ebx,%edi

	elem->next = (struct alloc_head*)head;

	elem->list = head;
	head->prev = elem;
    5adc:	89 b2 90 0a 00 00    	mov    %esi,0xa90(%edx)
    5ae2:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
    5ae9:	74 15                	je     5b00 <sendAckHelper+0x440>
    5aeb:	8b 4d a4             	mov    0xffffffa4(%ebp),%ecx
    5aee:	39 4f 1c             	cmp    %ecx,0x1c(%edi)
    5af1:	76 0d                	jbe    5b00 <sendAckHelper+0x440>
    5af3:	a1 00 00 00 00       	mov    0x0,%eax
    5af8:	85 c0                	test   %eax,%eax
    5afa:	0f 84 dd 03 00 00    	je     5edd <sendAckHelper+0x81d>
    5b00:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    5b03:	c7 40 0e ff ff ff ff 	movl   $0xffffffff,0xe(%eax)
    5b0a:	8b 55 ac             	mov    0xffffffac(%ebp),%edx
    5b0d:	c6 02 03             	movb   $0x3,(%edx)
    5b10:	66 c7 42 02 00 0c    	movw   $0xc00,0x2(%edx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    5b16:	8b 4d ac             	mov    0xffffffac(%ebp),%ecx
    5b19:	8b 56 20             	mov    0x20(%esi),%edx

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    5b1c:	0f ca                	bswap  %edx
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    5b1e:	89 51 04             	mov    %edx,0x4(%ecx)
    5b21:	8b 46 24             	mov    0x24(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    5b24:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    5b26:	89 41 08             	mov    %eax,0x8(%ecx)
    5b29:	8b 1d 00 00 00 00    	mov    0x0,%ebx
    5b2f:	85 db                	test   %ebx,%ebx
    5b31:	75 11                	jne    5b44 <sendAckHelper+0x484>

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    5b33:	0f c8                	bswap  %eax
    5b35:	0f ca                	bswap  %edx
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    5b37:	29 d0                	sub    %edx,%eax
    5b39:	3d 34 35 00 00       	cmp    $0x3534,%eax
    5b3e:	0f 87 84 03 00 00    	ja     5ec8 <sendAckHelper+0x808>
    5b44:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5b47:	8b 46 24             	mov    0x24(%esi),%eax
    5b4a:	8b 8a fc 00 00 00    	mov    0xfc(%edx),%ecx
    5b50:	29 c8                	sub    %ecx,%eax
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
    5b52:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    5b55:	c1 e8 05             	shr    $0x5,%eax
    5b58:	98                   	cwtl   
    5b59:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
	return result;
}

static inline int skb_is_nonlinear(const struct sk_buff *skb)
{
    5b5c:	8b 79 74             	mov    0x74(%ecx),%edi
	return skb->data_len;
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
	return skb->len - skb->data_len;
}

#define SKB_PAGE_ASSERT(skb) do { if (skb_shinfo(skb)->nr_frags) out_of_line_bug(); } while (0)
#define SKB_FRAG_ASSERT(skb) do { if (skb_shinfo(skb)->frag_list) out_of_line_bug(); } while (0)
#define SKB_LINEAR_ASSERT(skb) do { if (skb_is_nonlinear(skb)) out_of_line_bug(); } while (0)

/*
 *	Add data to an sk_buff
 */
 
static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	return tmp;
}

/**
 *	skb_put - add data to a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer. If this would
 *	exceed the total buffer size the kernel will panic. A pointer to the
 *	first byte of the extra data is returned.
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
    5b5f:	8b 99 98 00 00 00    	mov    0x98(%ecx),%ebx
    5b65:	85 ff                	test   %edi,%edi
    5b67:	0f 85 d7 0f 00 00    	jne    6b44 <sendAckHelper+0x1484>
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
    5b6d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
	skb->len+=len;
	if(skb->tail>skb->end) {
    5b70:	3b 98 9c 00 00 00    	cmp    0x9c(%eax),%ebx
    5b76:	89 98 98 00 00 00    	mov    %ebx,0x98(%eax)
    5b7c:	0f 87 29 03 00 00    	ja     5eab <sendAckHelper+0x7eb>
  memcpy(rval->kernel.data, scont->data, dataLen);
  return rval;
}

static inline unsigned marshallUC_Continuation(struct WireUC_Continuation *dcont, struct UC_Continuation *scont) {
    5b82:	8b 76 0c             	mov    0xc(%esi),%esi
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
    5b85:	8d 7b 0d             	lea    0xd(%ebx),%edi
  return rval;
}

static inline unsigned marshallUC_Continuation(struct WireUC_Continuation *dcont, struct UC_Continuation *scont) {
  int dataLen = scont->dataLen;
    5b88:	8b 56 28             	mov    0x28(%esi),%edx
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    5b8b:	8b 46 0c             	mov    0xc(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    5b8e:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    5b90:	89 03                	mov    %eax,(%ebx)
    5b92:	8b 46 10             	mov    0x10(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    5b95:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    5b97:	89 43 04             	mov    %eax,0x4(%ebx)
    5b9a:	8b 46 14             	mov    0x14(%esi),%eax

static inline void * __memcpy(void * to, const void * from, size_t n)
{
int d0, d1, d2;
__asm__ __volatile__(
    5b9d:	89 d1                	mov    %edx,%ecx

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    5b9f:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    5ba1:	89 43 08             	mov    %eax,0x8(%ebx)

static inline void * __memcpy(void * to, const void * from, size_t n)
{
int d0, d1, d2;
__asm__ __volatile__(
    5ba4:	c1 e9 02             	shr    $0x2,%ecx
  int dataLen = scont->dataLen;
  dcont->seq = htonl(scont->seq);
  dcont->validStart = htonl(scont->validStart);
  dcont->validEnd = htonl(scont->validEnd);
  dcont->fields = scont->fields;
    5ba7:	0f b6 46 20          	movzbl 0x20(%esi),%eax
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
    5bab:	83 c6 30             	add    $0x30,%esi
  int dataLen = scont->dataLen;
  dcont->seq = htonl(scont->seq);
  dcont->validStart = htonl(scont->validStart);
  dcont->validEnd = htonl(scont->validEnd);
  dcont->fields = scont->fields;
    5bae:	88 43 0c             	mov    %al,0xc(%ebx)

static inline void * __memcpy(void * to, const void * from, size_t n)
{
int d0, d1, d2;
__asm__ __volatile__(
    5bb1:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    5bb3:	f6 c2 02             	test   $0x2,%dl
    5bb6:	74 02                	je     5bba <sendAckHelper+0x4fa>
    5bb8:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    5bba:	f6 c2 01             	test   $0x1,%dl
    5bbd:	74 01                	je     5bc0 <sendAckHelper+0x500>
    5bbf:	a4                   	movsb  %ds:(%esi),%es:(%edi)
  memcpy(rval->kernel.data, scont->data, dataLen);
  return rval;
}

static inline unsigned marshallUC_Continuation(struct WireUC_Continuation *dcont, struct UC_Continuation *scont) {
    5bc0:	8d 5a 19             	lea    0x19(%edx),%ebx
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
    5bc3:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    5bc6:	8b 72 74             	mov    0x74(%edx),%esi
    5bc9:	8b 82 98 00 00 00    	mov    0x98(%edx),%eax
    5bcf:	85 f6                	test   %esi,%esi
    5bd1:	0f 85 6d 0f 00 00    	jne    6b44 <sendAckHelper+0x1484>
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
    5bd7:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    5bda:	01 d8                	add    %ebx,%eax
	skb->len+=len;
    5bdc:	01 59 70             	add    %ebx,0x70(%ecx)
	if(skb->tail>skb->end) {
    5bdf:	3b 81 9c 00 00 00    	cmp    0x9c(%ecx),%eax
    5be5:	89 81 98 00 00 00    	mov    %eax,0x98(%ecx)
    5beb:	0f 87 a1 02 00 00    	ja     5e92 <sendAckHelper+0x7d2>
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
    5bf1:	8b 75 e0             	mov    0xffffffe0(%ebp),%esi
    5bf4:	0f b7 c3             	movzwl %bx,%eax
/* gcc should generate this for open coded C now too. May be worth switching to 
   it because inline assembly cannot be scheduled. -AK */
static __inline__ __const__ __u16 ___arch__swab16(__u16 x)
{
	__asm__("xchgb %b0,%h0"		/* swap bytes		*/
    5bf7:	86 c4                	xchg   %al,%ah
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
    5bf9:	66 89 46 4b          	mov    %ax,0x4b(%esi)
    5bfd:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5c00:	8b 82 5c 0b 00 00    	mov    0xb5c(%edx),%eax
    5c06:	85 c0                	test   %eax,%eax
    5c08:	74 21                	je     5c2b <sendAckHelper+0x56b>
    5c0a:	8b ba 58 0b 00 00    	mov    0xb58(%edx),%edi
    5c10:	8d 04 80             	lea    (%eax,%eax,4),%eax
    5c13:	01 f8                	add    %edi,%eax
    5c15:	0f b6 40 fc          	movzbl 0xfffffffc(%eax),%eax
    5c19:	c0 e8 05             	shr    $0x5,%al
    5c1c:	0f b6 c0             	movzbl %al,%eax
    5c1f:	39 82 cc 02 00 00    	cmp    %eax,0x2cc(%edx)
    5c25:	0f 84 5d 02 00 00    	je     5e88 <sendAckHelper+0x7c8>
    5c2b:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
 */

static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
    5c2e:	8b 81 94 00 00 00    	mov    0x94(%ecx),%eax
    5c34:	c7 41 78 00 00 00 00 	movl   $0x0,0x78(%ecx)
    5c3b:	c6 41 7f 01          	movb   $0x1,0x7f(%ecx)
 */

static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
    5c3f:	83 e8 18             	sub    $0x18,%eax
    5c42:	8b 75 08             	mov    0x8(%ebp),%esi
 */

static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
    5c45:	89 81 94 00 00 00    	mov    %eax,0x94(%ecx)
	skb->len+=len;
    5c4b:	83 41 70 18          	addl   $0x18,0x70(%ecx)
	if(skb->data<skb->head) {
    5c4f:	3b 81 90 00 00 00    	cmp    0x90(%ecx),%eax
    5c55:	89 71 0c             	mov    %esi,0xc(%ecx)
static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
	skb->len+=len;
	if(skb->data<skb->head) {
    5c58:	0f 82 0d 02 00 00    	jb     5e6b <sendAckHelper+0x7ab>
		skb_under_panic(skb, len, current_text_addr());
	}
    5c5e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    5c61:	8b 88 94 00 00 00    	mov    0x94(%eax),%ecx
    5c67:	89 48 20             	mov    %ecx,0x20(%eax)
    5c6a:	8b 55 08             	mov    0x8(%ebp),%edx
    5c6d:	0f b7 42 22          	movzwl 0x22(%edx),%eax
    5c71:	66 89 01             	mov    %ax,(%ecx)
    5c74:	0f b7 42 08          	movzwl 0x8(%edx),%eax
    5c78:	c7 41 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ecx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    5c7f:	0f b6 51 0d          	movzbl 0xd(%ecx),%edx
    5c83:	66 89 41 02          	mov    %ax,0x2(%ecx)
    5c87:	0f b6 41 0c          	movzbl 0xc(%ecx),%eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    5c8b:	80 e2 ef             	and    $0xef,%dl
    5c8e:	24 0f                	and    $0xf,%al
    5c90:	0c 60                	or     $0x60,%al
    5c92:	88 41 0c             	mov    %al,0xc(%ecx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    5c95:	8b 75 0c             	mov    0xc(%ebp),%esi
    5c98:	8b 46 34             	mov    0x34(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    5c9b:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    5c9d:	24 01                	and    $0x1,%al
    5c9f:	c0 e0 04             	shl    $0x4,%al
    5ca2:	08 c2                	or     %al,%dl
    5ca4:	88 51 0d             	mov    %dl,0xd(%ecx)
    5ca7:	80 ca 10             	or     $0x10,%dl
    5caa:	80 e2 f8             	and    $0xf8,%dl
    5cad:	0f b7 45 e4          	movzwl 0xffffffe4(%ebp),%eax
    5cb1:	66 c7 41 10 00 00    	movw   $0x0,0x10(%ecx)
/* gcc should generate this for open coded C now too. May be worth switching to 
   it because inline assembly cannot be scheduled. -AK */
static __inline__ __const__ __u16 ___arch__swab16(__u16 x)
{
	__asm__("xchgb %b0,%h0"		/* swap bytes		*/
    5cb7:	86 c4                	xchg   %al,%ah
    5cb9:	66 c7 41 12 00 00    	movw   $0x0,0x12(%ecx)
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
    5cbf:	66 89 41 0e          	mov    %ax,0xe(%ecx)
    5cc3:	c7 41 14 0b 04 00 00 	movl   $0x40b,0x14(%ecx)
    5cca:	88 51 0d             	mov    %dl,0xd(%ecx)

#define MINISOCK_LEN(RO_LEN) ((RO_LEN) / 2)

#ifndef USERTEST
static inline void trickles_checksum(struct sk_buff *skb, int headerLen) {
    5ccd:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    5cd0:	8b 50 70             	mov    0x70(%eax),%edx
	struct sock *sk = skb->sk;
	if(skb->ip_summed == CHECKSUM_HW) {
    5cd3:	80 78 7f 01          	cmpb   $0x1,0x7f(%eax)
    5cd7:	8b 70 0c             	mov    0xc(%eax),%esi
    5cda:	0f 84 3c 01 00 00    	je     5e1c <sendAckHelper+0x75c>
		skb->h.th->check = 0;
		skb->h.th->check = ~tcp_v4_check(skb->h.th, skb->len, sk->saddr, sk->daddr,
					 0);
		skb->csum = offsetof(struct tcphdr, check);
	} else {
		skb->h.th->check = 0;
    5ce0:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    5ce3:	8b 41 20             	mov    0x20(%ecx),%eax
    5ce6:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
		skb->h.th->check = tcp_v4_check(skb->h.th, skb->len, sk->saddr, sk->daddr, 
    5cec:	8b 41 20             	mov    0x20(%ecx),%eax
    5cef:	89 45 94             	mov    %eax,0xffffff94(%ebp)
 */
static __inline__ u16 tcp_v4_check(struct tcphdr *th, int len,
				   unsigned long saddr, unsigned long daddr, 
				   unsigned long base)
{
    5cf2:	8b 41 78             	mov    0x78(%ecx),%eax
    5cf5:	8b 59 70             	mov    0x70(%ecx),%ebx
    5cf8:	8b 7e 70             	mov    0x70(%esi),%edi
    5cfb:	8b 36                	mov    (%esi),%esi
    5cfd:	89 54 24 04          	mov    %edx,0x4(%esp,1)
						   unsigned long daddr,
						   unsigned short len,
						   unsigned short proto,
						   unsigned int sum)
{
    5d01:	0f b7 db             	movzwl %bx,%ebx
 */
static __inline__ u16 tcp_v4_check(struct tcphdr *th, int len,
				   unsigned long saddr, unsigned long daddr, 
				   unsigned long base)
{
    5d04:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    5d08:	8b 41 20             	mov    0x20(%ecx),%eax
/* gcc should generate this for open coded C now too. May be worth switching to 
   it because inline assembly cannot be scheduled. -AK */
static __inline__ __const__ __u16 ___arch__swab16(__u16 x)
{
	__asm__("xchgb %b0,%h0"		/* swap bytes		*/
    5d0b:	86 df                	xchg   %bl,%bh
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
    5d0d:	c1 e3 10             	shl    $0x10,%ebx
    5d10:	81 c3 00 06 00 00    	add    $0x600,%ebx
 */
static __inline__ u16 tcp_v4_check(struct tcphdr *th, int len,
				   unsigned long saddr, unsigned long daddr, 
				   unsigned long base)
{
    5d16:	89 04 24             	mov    %eax,(%esp,1)
    5d19:	e8 fc ff ff ff       	call   5d1a <sendAckHelper+0x65a>
    5d1e:	8b 4d 94             	mov    0xffffff94(%ebp),%ecx
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
    5d21:	01 f0                	add    %esi,%eax
    5d23:	11 f8                	adc    %edi,%eax
    5d25:	11 d8                	adc    %ebx,%eax
    5d27:	83 d0 00             	adc    $0x0,%eax
 */

static inline unsigned int csum_fold(unsigned int sum)
{
	__asm__(
    5d2a:	89 c2                	mov    %eax,%edx
    5d2c:	81 e2 00 00 ff ff    	and    $0xffff0000,%edx
    5d32:	c1 e0 10             	shl    $0x10,%eax
    5d35:	01 c2                	add    %eax,%edx
    5d37:	81 d2 ff ff 00 00    	adc    $0xffff,%edx
    5d3d:	f7 d2                	not    %edx
		"addl %1, %0		;\n"
		"adcl $0xffff, %0	;\n"
		: "=r" (sum)
		: "r" (sum << 16), "0" (sum & 0xffff0000)
	);
	return (~sum) >> 16;
}

static inline unsigned long csum_tcpudp_nofold(unsigned long saddr,
						   unsigned long daddr,
						   unsigned short len,
						   unsigned short proto,
						   unsigned int sum)
{
    __asm__(
	"addl %1, %0	;\n"
	"adcl %2, %0	;\n"
	"adcl %3, %0	;\n"
	"adcl $0, %0	;\n"
	: "=r" (sum)
	: "g" (daddr), "g"(saddr), "g"((ntohs(len)<<16)+proto*256), "0"(sum));
    return sum;
}

/*
 * computes the checksum of the TCP/UDP pseudo-header
 * returns a 16-bit checksum, already complemented
 */
static inline unsigned short int csum_tcpudp_magic(unsigned long saddr,
						   unsigned long daddr,
						   unsigned short len,
						   unsigned short proto,
						   unsigned int sum)
{
    5d3f:	c1 ea 10             	shr    $0x10,%edx
 */
static __inline__ u16 tcp_v4_check(struct tcphdr *th, int len,
				   unsigned long saddr, unsigned long daddr, 
				   unsigned long base)
{
    5d42:	66 89 51 10          	mov    %dx,0x10(%ecx)
    5d46:	8b 75 f0             	mov    0xfffffff0(%ebp),%esi
    5d49:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    5d4c:	8b 86 dc 00 00 00    	mov    0xdc(%esi),%eax
    5d52:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    5d59:	00 
    5d5a:	89 14 24             	mov    %edx,(%esp,1)
    5d5d:	ff 10                	call   *(%eax)
    5d5f:	85 c0                	test   %eax,%eax
    5d61:	89 c7                	mov    %eax,%edi
    5d63:	74 6d                	je     5dd2 <sendAckHelper+0x712>
    5d65:	a1 00 00 00 00       	mov    0x0,%eax
    5d6a:	9c                   	pushf  
    5d6b:	59                   	pop    %ecx
    5d6c:	fa                   	cli    
    5d6d:	89 c2                	mov    %eax,%edx
    5d6f:	8b 35 88 e2 04 00    	mov    0x4e288,%esi
    5d75:	8b 1d b4 00 00 00    	mov    0xb4,%ebx
    5d7b:	a3 88 e2 04 00       	mov    %eax,0x4e288
    5d80:	29 f2                	sub    %esi,%edx
    5d82:	01 da                	add    %ebx,%edx
    5d84:	89 15 b4 00 00 00    	mov    %edx,0xb4
    5d8a:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    5d90:	76 10                	jbe    5da2 <sendAckHelper+0x6e2>
    5d92:	be 88 13 00 00       	mov    $0x1388,%esi
    5d97:	ba 88 13 00 00       	mov    $0x1388,%edx
    5d9c:	89 35 b4 00 00 00    	mov    %esi,0xb4
    5da2:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    5da8:	76 66                	jbe    5e10 <sendAckHelper+0x750>
    5daa:	31 db                	xor    %ebx,%ebx
    5dac:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    5db2:	a1 8c e2 04 00       	mov    0x4e28c,%eax
    5db7:	89 15 b4 00 00 00    	mov    %edx,0xb4
    5dbd:	89 1d 8c e2 04 00    	mov    %ebx,0x4e28c
    5dc3:	51                   	push   %ecx
    5dc4:	9d                   	popf   
    5dc5:	85 c0                	test   %eax,%eax
    5dc7:	75 25                	jne    5dee <sendAckHelper+0x72e>
    5dc9:	b8 01 00 00 00       	mov    $0x1,%eax
    5dce:	85 c0                	test   %eax,%eax
    5dd0:	75 0a                	jne    5ddc <sendAckHelper+0x71c>
    5dd2:	b8 01 00 00 00       	mov    $0x1,%eax
    5dd7:	e9 15 fa ff ff       	jmp    57f1 <sendAckHelper+0x131>
    5ddc:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
    5de0:	c7 04 24 e0 1f 00 00 	movl   $0x1fe0,(%esp,1)
    5de7:	e8 fc ff ff ff       	call   5de8 <sendAckHelper+0x728>
    5dec:	eb e4                	jmp    5dd2 <sendAckHelper+0x712>
    5dee:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    5df2:	c7 44 24 08 e1 0e 00 	movl   $0xee1,0x8(%esp,1)
    5df9:	00 
    5dfa:	c7 44 24 04 6b 00 00 	movl   $0x6b,0x4(%esp,1)
    5e01:	00 
    5e02:	c7 04 24 c0 02 00 00 	movl   $0x2c0,(%esp,1)
    5e09:	e8 fc ff ff ff       	call   5e0a <sendAckHelper+0x74a>
    5e0e:	eb b9                	jmp    5dc9 <sendAckHelper+0x709>
    5e10:	ff 05 8c e2 04 00    	incl   0x4e28c
    5e16:	51                   	push   %ecx
    5e17:	9d                   	popf   
    5e18:	31 c0                	xor    %eax,%eax
    5e1a:	eb b2                	jmp    5dce <sendAckHelper+0x70e>
#ifndef USERTEST
static inline void trickles_checksum(struct sk_buff *skb, int headerLen) {
	struct sock *sk = skb->sk;
	if(skb->ip_summed == CHECKSUM_HW) {
		skb->h.th->check = 0;
    5e1c:	89 c2                	mov    %eax,%edx
    5e1e:	8b 40 20             	mov    0x20(%eax),%eax
    5e21:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
		skb->h.th->check = ~tcp_v4_check(skb->h.th, skb->len, sk->saddr, sk->daddr,
    5e27:	8b 4a 20             	mov    0x20(%edx),%ecx
						   unsigned long daddr,
						   unsigned short len,
						   unsigned short proto,
						   unsigned int sum)
{
    5e2a:	0f b7 42 70          	movzwl 0x70(%edx),%eax
/* gcc should generate this for open coded C now too. May be worth switching to 
   it because inline assembly cannot be scheduled. -AK */
static __inline__ __const__ __u16 ___arch__swab16(__u16 x)
{
	__asm__("xchgb %b0,%h0"		/* swap bytes		*/
    5e2e:	86 c4                	xchg   %al,%ah
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
    5e30:	c1 e0 10             	shl    $0x10,%eax
    5e33:	05 00 06 00 00       	add    $0x600,%eax
    5e38:	31 d2                	xor    %edx,%edx
    5e3a:	03 16                	add    (%esi),%edx
    5e3c:	13 56 70             	adc    0x70(%esi),%edx
    5e3f:	11 c2                	adc    %eax,%edx
    5e41:	83 d2 00             	adc    $0x0,%edx
 */

static inline unsigned int csum_fold(unsigned int sum)
{
	__asm__(
    5e44:	89 d0                	mov    %edx,%eax
    5e46:	25 00 00 ff ff       	and    $0xffff0000,%eax
    5e4b:	c1 e2 10             	shl    $0x10,%edx
    5e4e:	01 d0                	add    %edx,%eax
    5e50:	15 ff ff 00 00       	adc    $0xffff,%eax
		"addl %1, %0		;\n"
		"adcl $0xffff, %0	;\n"
		: "=r" (sum)
		: "r" (sum << 16), "0" (sum & 0xffff0000)
	);
	return (~sum) >> 16;
}

static inline unsigned long csum_tcpudp_nofold(unsigned long saddr,
						   unsigned long daddr,
						   unsigned short len,
						   unsigned short proto,
						   unsigned int sum)
{
    __asm__(
	"addl %1, %0	;\n"
	"adcl %2, %0	;\n"
	"adcl %3, %0	;\n"
	"adcl $0, %0	;\n"
	: "=r" (sum)
	: "g" (daddr), "g"(saddr), "g"((ntohs(len)<<16)+proto*256), "0"(sum));
    return sum;
}

/*
 * computes the checksum of the TCP/UDP pseudo-header
 * returns a 16-bit checksum, already complemented
 */
static inline unsigned short int csum_tcpudp_magic(unsigned long saddr,
						   unsigned long daddr,
						   unsigned short len,
						   unsigned short proto,
						   unsigned int sum)
{
    5e55:	c1 e8 10             	shr    $0x10,%eax
 */
static __inline__ u16 tcp_v4_check(struct tcphdr *th, int len,
				   unsigned long saddr, unsigned long daddr, 
				   unsigned long base)
{
    5e58:	66 89 41 10          	mov    %ax,0x10(%ecx)
	if(skb->ip_summed == CHECKSUM_HW) {
		skb->h.th->check = 0;
		skb->h.th->check = ~tcp_v4_check(skb->h.th, skb->len, sk->saddr, sk->daddr,
					 0);
		skb->csum = offsetof(struct tcphdr, check);
    5e5c:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    5e5f:	c7 41 78 10 00 00 00 	movl   $0x10,0x78(%ecx)
    5e66:	e9 db fe ff ff       	jmp    5d46 <sendAckHelper+0x686>
{
	skb->data-=len;
	skb->len+=len;
	if(skb->data<skb->head) {
		skb_under_panic(skb, len, current_text_addr());
    5e6b:	c7 44 24 08 73 5e 00 	movl   $0x5e73,0x8(%esp,1)
    5e72:	00 
    5e73:	c7 44 24 04 18 00 00 	movl   $0x18,0x4(%esp,1)
    5e7a:	00 
    5e7b:	89 0c 24             	mov    %ecx,(%esp,1)
    5e7e:	e8 fc ff ff ff       	call   5e7f <sendAckHelper+0x7bf>
    5e83:	e9 d6 fd ff ff       	jmp    5c5e <sendAckHelper+0x59e>
    5e88:	a1 00 00 00 00       	mov    0x0,%eax
    5e8d:	e9 99 fd ff ff       	jmp    5c2b <sendAckHelper+0x56b>
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	if(skb->tail>skb->end) {
		skb_over_panic(skb, len, current_text_addr());
    5e92:	c7 44 24 08 9a 5e 00 	movl   $0x5e9a,0x8(%esp,1)
    5e99:	00 
    5e9a:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    5e9e:	89 0c 24             	mov    %ecx,(%esp,1)
    5ea1:	e8 fc ff ff ff       	call   5ea2 <sendAckHelper+0x7e2>
    5ea6:	e9 46 fd ff ff       	jmp    5bf1 <sendAckHelper+0x531>
    5eab:	c7 44 24 08 b3 5e 00 	movl   $0x5eb3,0x8(%esp,1)
    5eb2:	00 
    5eb3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    5eba:	00 
    5ebb:	89 04 24             	mov    %eax,(%esp,1)
    5ebe:	e8 fc ff ff ff       	call   5ebf <sendAckHelper+0x7ff>
    5ec3:	e9 ba fc ff ff       	jmp    5b82 <sendAckHelper+0x4c2>
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    5ec8:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    5ecc:	c7 04 24 d0 02 00 00 	movl   $0x2d0,(%esp,1)
    5ed3:	e8 fc ff ff ff       	call   5ed4 <sendAckHelper+0x814>
    5ed8:	e9 67 fc ff ff       	jmp    5b44 <sendAckHelper+0x484>
    5edd:	89 4c 24 08          	mov    %ecx,0x8(%esp,1)
    5ee1:	8b 47 1c             	mov    0x1c(%edi),%eax
    5ee4:	c7 04 24 40 20 00 00 	movl   $0x2040,(%esp,1)
    5eeb:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    5eef:	e8 fc ff ff ff       	call   5ef0 <sendAckHelper+0x830>
    5ef4:	e9 07 fc ff ff       	jmp    5b00 <sendAckHelper+0x440>
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
		BUG();
    5ef9:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    5f00:	00 
    5f01:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    5f08:	e8 fc ff ff ff       	call   5f09 <sendAckHelper+0x849>
    5f0d:	e8 fc ff ff ff       	call   5f0e <sendAckHelper+0x84e>
		show_stack(NULL);
    5f12:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    5f19:	e8 fc ff ff ff       	call   5f1a <sendAckHelper+0x85a>
    5f1e:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    5f21:	8b 81 90 0a 00 00    	mov    0xa90(%ecx),%eax
    5f27:	e9 97 fb ff ff       	jmp    5ac3 <sendAckHelper+0x403>

static inline 
struct DataRequestMapping *newDataRequestMapping(struct UC_Continuation *ucont, unsigned tseq_start, unsigned tseq_end, 
						 unsigned start, unsigned end) {
	struct DataRequestMapping *newMapping = kmalloc(sizeof(struct DataRequestMapping), GFP_ATOMIC);
    5f2c:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    5f33:	00 
    5f34:	01 da                	add    %ebx,%edx
static inline 
struct DataRequestMapping *newDataRequestMapping(struct UC_Continuation *ucont, unsigned tseq_start, unsigned tseq_end, 
						 unsigned start, unsigned end) {
	struct DataRequestMapping *newMapping = kmalloc(sizeof(struct DataRequestMapping), GFP_ATOMIC);
	if(newMapping == NULL) return NULL;
    5f36:	31 db                	xor    %ebx,%ebx
    5f38:	89 55 98             	mov    %edx,0xffffff98(%ebp)

static inline 
struct DataRequestMapping *newDataRequestMapping(struct UC_Continuation *ucont, unsigned tseq_start, unsigned tseq_end, 
						 unsigned start, unsigned end) {
	struct DataRequestMapping *newMapping = kmalloc(sizeof(struct DataRequestMapping), GFP_ATOMIC);
    5f3b:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp,1)
    5f42:	e8 fc ff ff ff       	call   5f43 <sendAckHelper+0x883>
	if(newMapping == NULL) return NULL;
    5f47:	85 c0                	test   %eax,%eax
    5f49:	89 c2                	mov    %eax,%edx
    5f4b:	74 52                	je     5f9f <sendAckHelper+0x8df>
	newMapping->next = newMapping->prev = NULL;
    5f4d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	newMapping->list = NULL;

	newMapping->completed = 0;
	newMapping->ucont = ucont;
	newMapping->transportResponseSeqStart = tseq_start;
	newMapping->transportResponseSeqEnd = tseq_end;
	newMapping->sent = 0;
	newMapping->start = start;
	newMapping->end = end;
#ifndef USERTEST
	newMapping->timestamp = jiffies;
#endif

	numDataRequestMappings++;
    5f53:	89 d3                	mov    %edx,%ebx
    5f55:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    5f5c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    5f63:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
    5f6a:	8b 45 a8             	mov    0xffffffa8(%ebp),%eax
    5f6d:	c7 42 18 ff ff ff ff 	movl   $0xffffffff,0x18(%edx)
    5f74:	c7 42 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%edx)
    5f7b:	c7 42 10 00 00 00 00 	movl   $0x0,0x10(%edx)
    5f82:	89 42 0c             	mov    %eax,0xc(%edx)
    5f85:	8b 4d 98             	mov    0xffffff98(%ebp),%ecx
    5f88:	89 4a 20             	mov    %ecx,0x20(%edx)
    5f8b:	8b 45 9c             	mov    0xffffff9c(%ebp),%eax
    5f8e:	89 42 24             	mov    %eax,0x24(%edx)
    5f91:	a1 00 00 00 00       	mov    0x0,%eax
    5f96:	89 42 28             	mov    %eax,0x28(%edx)
    5f99:	ff 05 00 00 00 00    	incl   0x0
    5f9f:	85 db                	test   %ebx,%ebx
    5fa1:	74 65                	je     6008 <sendAckHelper+0x948>
    5fa3:	8b 55 98             	mov    0xffffff98(%ebp),%edx
    5fa6:	89 56 24             	mov    %edx,0x24(%esi)
	if(elem->list) {
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
    5fa9:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    5fac:	8b 81 a4 0a 00 00    	mov    0xaa4(%ecx),%eax
    5fb2:	39 d8                	cmp    %ebx,%eax
    5fb4:	74 22                	je     5fd8 <sendAckHelper+0x918>
		BUG();
		show_stack(NULL);
	}
	elem->prev = head->prev;
    5fb6:	89 03                	mov    %eax,(%ebx)
	head->prev->next = elem;
    5fb8:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    5fbb:	8b 81 a4 0a 00 00    	mov    0xaa4(%ecx),%eax

	elem->next = (struct alloc_head*)head;

	elem->list = head;
    5fc1:	89 7b 08             	mov    %edi,0x8(%ebx)
    5fc4:	89 58 04             	mov    %ebx,0x4(%eax)
    5fc7:	89 7b 04             	mov    %edi,0x4(%ebx)
	head->prev = elem;
	head->len++;
    5fca:	ff 47 10             	incl   0x10(%edi)
    5fcd:	89 99 a4 0a 00 00    	mov    %ebx,0xaa4(%ecx)
    5fd3:	e9 9e fa ff ff       	jmp    5a76 <sendAckHelper+0x3b6>
    5fd8:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    5fdf:	00 
    5fe0:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    5fe7:	e8 fc ff ff ff       	call   5fe8 <sendAckHelper+0x928>
    5fec:	e8 fc ff ff ff       	call   5fed <sendAckHelper+0x92d>
    5ff1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    5ff8:	e8 fc ff ff ff       	call   5ff9 <sendAckHelper+0x939>
    5ffd:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    6000:	8b 82 a4 0a 00 00    	mov    0xaa4(%edx),%eax
    6006:	eb ae                	jmp    5fb6 <sendAckHelper+0x8f6>
    6008:	c7 04 24 c0 20 00 00 	movl   $0x20c0,(%esp,1)
    600f:	e8 fc ff ff ff       	call   6010 <sendAckHelper+0x950>
    6014:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    6017:	89 0c 24             	mov    %ecx,(%esp,1)
    601a:	e8 fc ff ff ff       	call   601b <sendAckHelper+0x95b>
    601f:	e9 cb f7 ff ff       	jmp    57ef <sendAckHelper+0x12f>
    6024:	c7 44 24 04 22 0e 00 	movl   $0xe22,0x4(%esp,1)
    602b:	00 
    602c:	c7 04 24 00 21 00 00 	movl   $0x2100,(%esp,1)
    6033:	e8 fc ff ff ff       	call   6034 <sendAckHelper+0x974>
    6038:	e9 15 fa ff ff       	jmp    5a52 <sendAckHelper+0x392>
    603d:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    6040:	89 df                	mov    %ebx,%edi
    6042:	8b 81 bc 0a 00 00    	mov    0xabc(%ecx),%eax
    6048:	85 c0                	test   %eax,%eax
    604a:	89 c2                	mov    %eax,%edx
    604c:	75 09                	jne    6057 <sendAckHelper+0x997>
    604e:	8b 75 f0             	mov    0xfffffff0(%ebp),%esi
    6051:	8b 96 5c 0a 00 00    	mov    0xa5c(%esi),%edx
    6057:	8b 75 f0             	mov    0xfffffff0(%ebp),%esi
    605a:	81 c6 5c 0a 00 00    	add    $0xa5c,%esi
    6060:	39 f2                	cmp    %esi,%edx
    6062:	0f 84 0c 01 00 00    	je     6174 <sendAckHelper+0xab4>
    6068:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    606b:	8b 98 b8 0a 00 00    	mov    0xab8(%eax),%ebx
    6071:	8b 42 40             	mov    0x40(%edx),%eax
    6074:	39 d8                	cmp    %ebx,%eax
    6076:	77 27                	ja     609f <sendAckHelper+0x9df>
    6078:	8b 4a 44             	mov    0x44(%edx),%ecx
    607b:	39 d9                	cmp    %ebx,%ecx
    607d:	0f 86 e2 00 00 00    	jbe    6165 <sendAckHelper+0xaa5>
    6083:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    6086:	89 88 b8 0a 00 00    	mov    %ecx,0xab8(%eax)
    608c:	8b 02                	mov    (%edx),%eax
    608e:	39 f0                	cmp    %esi,%eax
    6090:	74 05                	je     6097 <sendAckHelper+0x9d7>
    6092:	8b 78 40             	mov    0x40(%eax),%edi
    6095:	29 cf                	sub    %ecx,%edi
    6097:	89 cb                	mov    %ecx,%ebx
    6099:	39 f0                	cmp    %esi,%eax
    609b:	89 c2                	mov    %eax,%edx
    609d:	75 d2                	jne    6071 <sendAckHelper+0x9b1>
    609f:	31 c0                	xor    %eax,%eax
    60a1:	39 f2                	cmp    %esi,%edx
    60a3:	8b 75 f0             	mov    0xfffffff0(%ebp),%esi
    60a6:	0f 45 c2             	cmovne %edx,%eax
    60a9:	89 86 bc 0a 00 00    	mov    %eax,0xabc(%esi)
    60af:	8d 34 1f             	lea    (%edi,%ebx,1),%esi
    60b2:	8b 45 08             	mov    0x8(%ebp),%eax
    60b5:	89 74 24 08          	mov    %esi,0x8(%esp,1)
    60b9:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    60bd:	89 04 24             	mov    %eax,(%esp,1)
    60c0:	e8 fc ff ff ff       	call   60c1 <sendAckHelper+0xa01>
    60c5:	89 45 a8             	mov    %eax,0xffffffa8(%ebp)
    60c8:	85 c0                	test   %eax,%eax
    60ca:	0f 84 44 ff ff ff    	je     6014 <sendAckHelper+0x954>
    60d0:	8b 78 14             	mov    0x14(%eax),%edi
    60d3:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    60d6:	39 f7                	cmp    %esi,%edi
    60d8:	0f 47 fe             	cmova  %esi,%edi
    60db:	31 c0                	xor    %eax,%eax
    60dd:	89 ba b8 0a 00 00    	mov    %edi,0xab8(%edx)
    60e3:	89 82 bc 0a 00 00    	mov    %eax,0xabc(%edx)

static inline 
struct DataRequestMapping *newDataRequestMapping(struct UC_Continuation *ucont, unsigned tseq_start, unsigned tseq_end, 
						 unsigned start, unsigned end) {
	struct DataRequestMapping *newMapping = kmalloc(sizeof(struct DataRequestMapping), GFP_ATOMIC);
    60e9:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    60f0:	00 
    60f1:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp,1)
    60f8:	e8 fc ff ff ff       	call   60f9 <sendAckHelper+0xa39>
    60fd:	89 c2                	mov    %eax,%edx
	if(newMapping == NULL) return NULL;
    60ff:	31 c0                	xor    %eax,%eax
    6101:	85 d2                	test   %edx,%edx
    6103:	74 4a                	je     614f <sendAckHelper+0xa8f>
	newMapping->next = newMapping->prev = NULL;
    6105:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
    610b:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
	newMapping->list = NULL;
    6112:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)

	newMapping->completed = 0;
    6119:	c7 42 14 00 00 00 00 	movl   $0x0,0x14(%edx)
	newMapping->ucont = ucont;
    6120:	8b 4d a8             	mov    0xffffffa8(%ebp),%ecx
    6123:	89 4a 0c             	mov    %ecx,0xc(%edx)
	newMapping->transportResponseSeqStart = tseq_start;
    6126:	8b 75 a4             	mov    0xffffffa4(%ebp),%esi
    6129:	89 72 18             	mov    %esi,0x18(%edx)
	newMapping->transportResponseSeqEnd = tseq_end;
    612c:	8b 45 a0             	mov    0xffffffa0(%ebp),%eax
	newMapping->sent = 0;
    612f:	c7 42 10 00 00 00 00 	movl   $0x0,0x10(%edx)
	newMapping->start = start;
    6136:	89 5a 20             	mov    %ebx,0x20(%edx)
	newMapping->end = end;
    6139:	89 7a 24             	mov    %edi,0x24(%edx)
    613c:	89 42 1c             	mov    %eax,0x1c(%edx)
#ifndef USERTEST
	newMapping->timestamp = jiffies;
    613f:	a1 00 00 00 00       	mov    0x0,%eax
    6144:	89 42 28             	mov    %eax,0x28(%edx)
#endif

	numDataRequestMappings++;
    6147:	89 d0                	mov    %edx,%eax
    6149:	ff 05 00 00 00 00    	incl   0x0
    614f:	85 c0                	test   %eax,%eax
extern int numDataRequestMappings;

static inline 
struct DataRequestMapping *newDataRequestMapping(struct UC_Continuation *ucont, unsigned tseq_start, unsigned tseq_end, 
						 unsigned start, unsigned end) {
    6151:	89 c6                	mov    %eax,%esi
    6153:	0f 85 4f f9 ff ff    	jne    5aa8 <sendAckHelper+0x3e8>
    6159:	c7 04 24 60 21 00 00 	movl   $0x2160,(%esp,1)
    6160:	e9 aa fe ff ff       	jmp    600f <sendAckHelper+0x94f>
    6165:	39 d8                	cmp    %ebx,%eax
    6167:	0f 87 32 ff ff ff    	ja     609f <sendAckHelper+0x9df>
    616d:	8b 02                	mov    (%edx),%eax
    616f:	e9 25 ff ff ff       	jmp    6099 <sendAckHelper+0x9d9>
    6174:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    6177:	8b 99 b8 0a 00 00    	mov    0xab8(%ecx),%ebx
    617d:	e9 1d ff ff ff       	jmp    609f <sendAckHelper+0x9df>
    6182:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    6189:	00 
    618a:	c7 04 24 e8 02 00 00 	movl   $0x2e8,(%esp,1)
    6191:	e8 fc ff ff ff       	call   6192 <sendAckHelper+0xad2>
    6196:	e9 98 f8 ff ff       	jmp    5a33 <sendAckHelper+0x373>
    619b:	c7 44 24 04 1b 0e 00 	movl   $0xe1b,0x4(%esp,1)
    61a2:	00 
    61a3:	c7 04 24 a0 21 00 00 	movl   $0x21a0,(%esp,1)
    61aa:	e8 fc ff ff ff       	call   61ab <sendAckHelper+0xaeb>
    61af:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    61b2:	8b 81 b4 00 00 00    	mov    0xb4(%ecx),%eax
    61b8:	e9 6e f8 ff ff       	jmp    5a2b <sendAckHelper+0x36b>
    61bd:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    61c0:	89 34 24             	mov    %esi,(%esp,1)
    61c3:	e8 fc ff ff ff       	call   61c4 <sendAckHelper+0xb04>
    61c8:	e9 05 fc ff ff       	jmp    5dd2 <sendAckHelper+0x712>
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	if(skb->tail>skb->end) {
		skb_over_panic(skb, len, current_text_addr());
    61cd:	c7 44 24 08 d5 61 00 	movl   $0x61d5,0x8(%esp,1)
    61d4:	00 
    61d5:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp,1)
    61dc:	00 
    61dd:	89 0c 24             	mov    %ecx,(%esp,1)
    61e0:	e8 fc ff ff ff       	call   61e1 <sendAckHelper+0xb21>
    61e5:	e9 db f7 ff ff       	jmp    59c5 <sendAckHelper+0x305>
    61ea:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    61ed:	39 50 08             	cmp    %edx,0x8(%eax)
    61f0:	0f 86 1e fe ff ff    	jbe    6014 <sendAckHelper+0x954>
    61f6:	83 a0 d8 02 00 00 fe 	andl   $0xfffffffe,0x2d8(%eax)
    61fd:	e9 12 fe ff ff       	jmp    6014 <sendAckHelper+0x954>
    6202:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    6205:	66 c7 40 4b 00 00    	movw   $0x0,0x4b(%eax)
    620b:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    620e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    6211:	8b 75 08             	mov    0x8(%ebp),%esi
    6214:	89 54 24 08          	mov    %edx,0x8(%esp,1)
    6218:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    621c:	89 34 24             	mov    %esi,(%esp,1)
    621f:	e8 6c f2 ff ff       	call   5490 <runSimulation>
    6224:	85 c0                	test   %eax,%eax
    6226:	0f 84 e8 fd ff ff    	je     6014 <sendAckHelper+0x954>
    622c:	8b 45 0c             	mov    0xc(%ebp),%eax
    622f:	81 b8 b4 00 00 00 e7 	cmpl   $0x3e7,0xb4(%eax)
    6236:	03 00 00 
    6239:	76 82                	jbe    61bd <sendAckHelper+0xafd>
    623b:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    623e:	8b 92 80 0a 00 00    	mov    0xa80(%edx),%edx
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    6244:	89 d1                	mov    %edx,%ecx
    6246:	89 55 dc             	mov    %edx,0xffffffdc(%ebp)
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    6249:	8b 52 04             	mov    0x4(%edx),%edx
    624c:	8b 01                	mov    (%ecx),%eax
    624e:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    6250:	8b 01                	mov    (%ecx),%eax
	elem->prev = elem->next = NULL;
    6252:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
    6258:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
    625b:	8b 41 08             	mov    0x8(%ecx),%eax
    625e:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
    6265:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    6268:	c7 41 08 00 00 00 00 	movl   $0x0,0x8(%ecx)
    626f:	8b 75 f0             	mov    0xfffffff0(%ebp),%esi
    6272:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    6275:	8b 86 68 0a 00 00    	mov    0xa68(%esi),%eax
    627b:	81 c3 68 0a 00 00    	add    $0xa68,%ebx
    6281:	39 c8                	cmp    %ecx,%eax
    6283:	0f 84 2d 07 00 00    	je     69b6 <sendAckHelper+0x12f6>
    6289:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    628c:	89 02                	mov    %eax,(%edx)
    628e:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    6291:	8b 81 68 0a 00 00    	mov    0xa68(%ecx),%eax
    6297:	89 5a 08             	mov    %ebx,0x8(%edx)
    629a:	89 50 04             	mov    %edx,0x4(%eax)
    629d:	89 5a 04             	mov    %ebx,0x4(%edx)
    62a0:	ff 43 10             	incl   0x10(%ebx)
    62a3:	89 91 68 0a 00 00    	mov    %edx,0xa68(%ecx)
    62a9:	8b 75 0c             	mov    0xc(%ebp),%esi
    62ac:	f6 42 48 01          	testb  $0x1,0x48(%edx)
    62b0:	8b 46 34             	mov    0x34(%esi),%eax
    62b3:	89 42 38             	mov    %eax,0x38(%edx)
    62b6:	74 13                	je     62cb <sendAckHelper+0xc0b>
    62b8:	8b 81 4c 0a 00 00    	mov    0xa4c(%ecx),%eax
    62be:	89 42 3c             	mov    %eax,0x3c(%edx)
    62c1:	ff 81 4c 0a 00 00    	incl   0xa4c(%ecx)
    62c7:	80 62 48 fe          	andb   $0xfe,0x48(%edx)
    62cb:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    62ce:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
    62d1:	8b 42 3c             	mov    0x3c(%edx),%eax
    62d4:	89 41 0e             	mov    %eax,0xe(%ecx)
    62d7:	8b 42 0c             	mov    0xc(%edx),%eax
    62da:	85 c0                	test   %eax,%eax
    62dc:	0f 84 56 02 00 00    	je     6538 <sendAckHelper+0xe78>
    62e2:	48                   	dec    %eax
    62e3:	74 0c                	je     62f1 <sendAckHelper+0xc31>
    62e5:	c7 04 24 00 22 00 00 	movl   $0x2200,(%esp,1)
    62ec:	e9 1e fd ff ff       	jmp    600f <sendAckHelper+0x94f>
    62f1:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
    62f4:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    62f7:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    62fa:	8b 40 54             	mov    0x54(%eax),%eax
    62fd:	c7 45 b8 00 00 00 00 	movl   $0x0,0xffffffb8(%ebp)
    6304:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
    6307:	8b 92 98 00 00 00    	mov    0x98(%edx),%edx
    630d:	89 55 b4             	mov    %edx,0xffffffb4(%ebp)
    6310:	8b 79 74             	mov    0x74(%ecx),%edi
    6313:	85 ff                	test   %edi,%edi
    6315:	0f 85 29 08 00 00    	jne    6b44 <sendAckHelper+0x1484>
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
    631b:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
    631e:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    6321:	83 c0 0c             	add    $0xc,%eax
	skb->len+=len;
    6324:	83 46 70 0c          	addl   $0xc,0x70(%esi)
	if(skb->tail>skb->end) {
    6328:	3b 86 9c 00 00 00    	cmp    0x9c(%esi),%eax
    632e:	89 86 98 00 00 00    	mov    %eax,0x98(%esi)
    6334:	0f 87 e1 01 00 00    	ja     651b <sendAckHelper+0xe5b>
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    633a:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    633d:	8b 4d b4             	mov    0xffffffb4(%ebp),%ecx
    6340:	8b 42 40             	mov    0x40(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    6343:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    6345:	89 41 03             	mov    %eax,0x3(%ecx)
    6348:	8b 42 44             	mov    0x44(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    634b:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    634d:	89 41 07             	mov    %eax,0x7(%ecx)
    6350:	0f b6 45 bc          	movzbl 0xffffffbc(%ebp),%eax
    6354:	88 41 0b             	mov    %al,0xb(%ecx)
    6357:	8b 55 bc             	mov    0xffffffbc(%ebp),%edx
    635a:	39 55 b8             	cmp    %edx,0xffffffb8(%ebp)
    635d:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
    6364:	0f 83 fb 00 00 00    	jae    6465 <sendAckHelper+0xda5>
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
    636a:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    636d:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    6370:	8b 89 98 00 00 00    	mov    0x98(%ecx),%ecx
    6376:	89 4d b0             	mov    %ecx,0xffffffb0(%ebp)
    6379:	8b 56 74             	mov    0x74(%esi),%edx
    637c:	85 d2                	test   %edx,%edx
    637e:	0f 85 c0 07 00 00    	jne    6b44 <sendAckHelper+0x1484>
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
    6384:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
    6387:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    638a:	83 c0 02             	add    $0x2,%eax
	skb->len+=len;
    638d:	83 41 70 02          	addl   $0x2,0x70(%ecx)
	if(skb->tail>skb->end) {
    6391:	3b 81 9c 00 00 00    	cmp    0x9c(%ecx),%eax
    6397:	89 81 98 00 00 00    	mov    %eax,0x98(%ecx)
    639d:	0f 87 55 01 00 00    	ja     64f8 <sendAckHelper+0xe38>
    63a3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    63a6:	85 d2                	test   %edx,%edx
    63a8:	8b 98 98 00 00 00    	mov    0x98(%eax),%ebx
    63ae:	0f 85 90 07 00 00    	jne    6b44 <sendAckHelper+0x1484>
    63b4:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    63b7:	3b 9a 9c 00 00 00    	cmp    0x9c(%edx),%ebx
    63bd:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
    63c3:	0f 87 12 01 00 00    	ja     64db <sendAckHelper+0xe1b>
  memcpy(rval->kernel.data, scont->data, dataLen);
  return rval;
}

static inline unsigned marshallUC_Continuation(struct WireUC_Continuation *dcont, struct UC_Continuation *scont) {
    63c9:	8b 4d dc             	mov    0xffffffdc(%ebp),%ecx
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
    63cc:	8d 7b 0d             	lea    0xd(%ebx),%edi
  memcpy(rval->kernel.data, scont->data, dataLen);
  return rval;
}

static inline unsigned marshallUC_Continuation(struct WireUC_Continuation *dcont, struct UC_Continuation *scont) {
    63cf:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
    63d2:	8b 41 58             	mov    0x58(%ecx),%eax
    63d5:	8b 34 90             	mov    (%eax,%edx,4),%esi
  int dataLen = scont->dataLen;
    63d8:	8b 56 28             	mov    0x28(%esi),%edx
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    63db:	8b 46 0c             	mov    0xc(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    63de:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    63e0:	89 03                	mov    %eax,(%ebx)
    63e2:	8b 46 10             	mov    0x10(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    63e5:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    63e7:	89 43 04             	mov    %eax,0x4(%ebx)
    63ea:	8b 46 14             	mov    0x14(%esi),%eax

static inline void * __memcpy(void * to, const void * from, size_t n)
{
int d0, d1, d2;
__asm__ __volatile__(
    63ed:	89 d1                	mov    %edx,%ecx

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    63ef:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    63f1:	89 43 08             	mov    %eax,0x8(%ebx)

static inline void * __memcpy(void * to, const void * from, size_t n)
{
int d0, d1, d2;
__asm__ __volatile__(
    63f4:	c1 e9 02             	shr    $0x2,%ecx
  int dataLen = scont->dataLen;
  dcont->seq = htonl(scont->seq);
  dcont->validStart = htonl(scont->validStart);
  dcont->validEnd = htonl(scont->validEnd);
  dcont->fields = scont->fields;
    63f7:	0f b6 46 20          	movzbl 0x20(%esi),%eax
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
    63fb:	83 c6 30             	add    $0x30,%esi
  int dataLen = scont->dataLen;
  dcont->seq = htonl(scont->seq);
  dcont->validStart = htonl(scont->validStart);
  dcont->validEnd = htonl(scont->validEnd);
  dcont->fields = scont->fields;
    63fe:	88 43 0c             	mov    %al,0xc(%ebx)

static inline void * __memcpy(void * to, const void * from, size_t n)
{
int d0, d1, d2;
__asm__ __volatile__(
    6401:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    6403:	f6 c2 02             	test   $0x2,%dl
    6406:	74 02                	je     640a <sendAckHelper+0xd4a>
    6408:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    640a:	f6 c2 01             	test   $0x1,%dl
    640d:	74 01                	je     6410 <sendAckHelper+0xd50>
    640f:	a4                   	movsb  %ds:(%esi),%es:(%edi)
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
    6410:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
  dcont->seq = htonl(scont->seq);
  dcont->validStart = htonl(scont->validStart);
  dcont->validEnd = htonl(scont->validEnd);
  dcont->fields = scont->fields;
  memcpy(dcont->data, scont->kernel.data, dataLen);
    6413:	8d 5a 0d             	lea    0xd(%edx),%ebx
	return result;
}

static inline int skb_is_nonlinear(const struct sk_buff *skb)
{
    6416:	8b 71 74             	mov    0x74(%ecx),%esi
	return skb->data_len;
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
	return skb->len - skb->data_len;
}

#define SKB_PAGE_ASSERT(skb) do { if (skb_shinfo(skb)->nr_frags) out_of_line_bug(); } while (0)
#define SKB_FRAG_ASSERT(skb) do { if (skb_shinfo(skb)->frag_list) out_of_line_bug(); } while (0)
#define SKB_LINEAR_ASSERT(skb) do { if (skb_is_nonlinear(skb)) out_of_line_bug(); } while (0)

/*
 *	Add data to an sk_buff
 */
 
static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	return tmp;
}

/**
 *	skb_put - add data to a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer. If this would
 *	exceed the total buffer size the kernel will panic. A pointer to the
 *	first byte of the extra data is returned.
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
    6419:	8b 81 98 00 00 00    	mov    0x98(%ecx),%eax
    641f:	85 f6                	test   %esi,%esi
    6421:	0f 85 1d 07 00 00    	jne    6b44 <sendAckHelper+0x1484>
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
    6427:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    642a:	01 d8                	add    %ebx,%eax
	skb->len+=len;
    642c:	01 5e 70             	add    %ebx,0x70(%esi)
	if(skb->tail>skb->end) {
    642f:	3b 86 9c 00 00 00    	cmp    0x9c(%esi),%eax
    6435:	89 86 98 00 00 00    	mov    %eax,0x98(%esi)
    643b:	0f 87 81 00 00 00    	ja     64c2 <sendAckHelper+0xe02>
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
    6441:	8b 55 b0             	mov    0xffffffb0(%ebp),%edx
    6444:	0f b7 c3             	movzwl %bx,%eax
/* gcc should generate this for open coded C now too. May be worth switching to 
   it because inline assembly cannot be scheduled. -AK */
static __inline__ __const__ __u16 ___arch__swab16(__u16 x)
{
	__asm__("xchgb %b0,%h0"		/* swap bytes		*/
    6447:	86 c4                	xchg   %al,%ah
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
    6449:	66 89 02             	mov    %ax,(%edx)
    644c:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    644f:	8b 4d b8             	mov    0xffffffb8(%ebp),%ecx
    6452:	ff 45 c0             	incl   0xffffffc0(%ebp)
    6455:	8d 4c 0b 02          	lea    0x2(%ebx,%ecx,1),%ecx
    6459:	39 45 c0             	cmp    %eax,0xffffffc0(%ebp)
    645c:	89 4d b8             	mov    %ecx,0xffffffb8(%ebp)
    645f:	0f 82 05 ff ff ff    	jb     636a <sendAckHelper+0xcaa>
    6465:	81 7d b8 52 05 00 00 	cmpl   $0x552,0xffffffb8(%ebp)
    646c:	77 3e                	ja     64ac <sendAckHelper+0xdec>
    646e:	8b 55 b4             	mov    0xffffffb4(%ebp),%edx
    6471:	c6 02 02             	movb   $0x2,(%edx)
    6474:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
    6477:	83 c0 0c             	add    $0xc,%eax
    647a:	0f b7 c0             	movzwl %ax,%eax
/* gcc should generate this for open coded C now too. May be worth switching to 
   it because inline assembly cannot be scheduled. -AK */
static __inline__ __const__ __u16 ___arch__swab16(__u16 x)
{
	__asm__("xchgb %b0,%h0"		/* swap bytes		*/
    647d:	86 c4                	xchg   %al,%ah
    647f:	0f b7 c0             	movzwl %ax,%eax
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
    6482:	66 89 42 01          	mov    %ax,0x1(%edx)
    6486:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
    6489:	66 89 41 4b          	mov    %ax,0x4b(%ecx)
    648d:	8b 75 0c             	mov    0xc(%ebp),%esi
    6490:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    6493:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
    6499:	89 42 4c             	mov    %eax,0x4c(%edx)
    649c:	8b 8e bc 00 00 00    	mov    0xbc(%esi),%ecx
    64a2:	01 c8                	add    %ecx,%eax
    64a4:	89 42 50             	mov    %eax,0x50(%edx)
    64a7:	e9 51 f7 ff ff       	jmp    5bfd <sendAckHelper+0x53d>
    64ac:	c7 44 24 04 ef 0d 00 	movl   $0xdef,0x4(%esp,1)
    64b3:	00 
    64b4:	c7 04 24 40 22 00 00 	movl   $0x2240,(%esp,1)
    64bb:	e8 fc ff ff ff       	call   64bc <sendAckHelper+0xdfc>
    64c0:	eb ac                	jmp    646e <sendAckHelper+0xdae>
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	if(skb->tail>skb->end) {
		skb_over_panic(skb, len, current_text_addr());
    64c2:	c7 44 24 08 ca 64 00 	movl   $0x64ca,0x8(%esp,1)
    64c9:	00 
    64ca:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    64ce:	89 34 24             	mov    %esi,(%esp,1)
    64d1:	e8 fc ff ff ff       	call   64d2 <sendAckHelper+0xe12>
    64d6:	e9 66 ff ff ff       	jmp    6441 <sendAckHelper+0xd81>
    64db:	c7 44 24 08 e3 64 00 	movl   $0x64e3,0x8(%esp,1)
    64e2:	00 
    64e3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    64ea:	00 
    64eb:	89 14 24             	mov    %edx,(%esp,1)
    64ee:	e8 fc ff ff ff       	call   64ef <sendAckHelper+0xe2f>
    64f3:	e9 d1 fe ff ff       	jmp    63c9 <sendAckHelper+0xd09>
    64f8:	c7 44 24 08 00 65 00 	movl   $0x6500,0x8(%esp,1)
    64ff:	00 
    6500:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp,1)
    6507:	00 
    6508:	89 0c 24             	mov    %ecx,(%esp,1)
    650b:	e8 fc ff ff ff       	call   650c <sendAckHelper+0xe4c>
    6510:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    6513:	8b 56 74             	mov    0x74(%esi),%edx
    6516:	e9 88 fe ff ff       	jmp    63a3 <sendAckHelper+0xce3>
    651b:	c7 44 24 08 23 65 00 	movl   $0x6523,0x8(%esp,1)
    6522:	00 
    6523:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp,1)
    652a:	00 
    652b:	89 34 24             	mov    %esi,(%esp,1)
    652e:	e8 fc ff ff ff       	call   652f <sendAckHelper+0xe6f>
    6533:	e9 02 fe ff ff       	jmp    633a <sendAckHelper+0xc7a>
    6538:	8b 75 dc             	mov    0xffffffdc(%ebp),%esi
    653b:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    653e:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    6541:	8b 76 58             	mov    0x58(%esi),%esi
    6544:	89 75 d8             	mov    %esi,0xffffffd8(%ebp)
    6547:	8b 40 5c             	mov    0x5c(%eax),%eax
    654a:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    654d:	8b 42 54             	mov    0x54(%edx),%eax
    6550:	85 c0                	test   %eax,%eax
    6552:	0f 84 26 03 00 00    	je     687e <sendAckHelper+0x11be>
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
    6558:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    655b:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    655e:	8b 89 98 00 00 00    	mov    0x98(%ecx),%ecx
    6564:	89 4d cc             	mov    %ecx,0xffffffcc(%ebp)
    6567:	8b 56 74             	mov    0x74(%esi),%edx
    656a:	85 d2                	test   %edx,%edx
    656c:	0f 85 d2 05 00 00    	jne    6b44 <sendAckHelper+0x1484>
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
    6572:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    6575:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    6578:	83 c0 0b             	add    $0xb,%eax
	skb->len+=len;
    657b:	83 41 70 0b          	addl   $0xb,0x70(%ecx)
	if(skb->tail>skb->end) {
    657f:	3b 81 9c 00 00 00    	cmp    0x9c(%ecx),%eax
    6585:	89 81 98 00 00 00    	mov    %eax,0x98(%ecx)
    658b:	0f 87 ca 02 00 00    	ja     685b <sendAckHelper+0x119b>
    6591:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
	return result;
}

static inline int skb_is_nonlinear(const struct sk_buff *skb)
{
    6594:	85 d2                	test   %edx,%edx
	return skb->data_len;
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
	return skb->len - skb->data_len;
}

#define SKB_PAGE_ASSERT(skb) do { if (skb_shinfo(skb)->nr_frags) out_of_line_bug(); } while (0)
#define SKB_FRAG_ASSERT(skb) do { if (skb_shinfo(skb)->frag_list) out_of_line_bug(); } while (0)
#define SKB_LINEAR_ASSERT(skb) do { if (skb_is_nonlinear(skb)) out_of_line_bug(); } while (0)

/*
 *	Add data to an sk_buff
 */
 
static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	return tmp;
}

/**
 *	skb_put - add data to a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer. If this would
 *	exceed the total buffer size the kernel will panic. A pointer to the
 *	first byte of the extra data is returned.
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
    6596:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    6599:	8b 58 60             	mov    0x60(%eax),%ebx
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
    659c:	8b 86 98 00 00 00    	mov    0x98(%esi),%eax
    65a2:	8d 4b fc             	lea    0xfffffffc(%ebx),%ecx
    65a5:	0f 85 99 05 00 00    	jne    6b44 <sendAckHelper+0x1484>
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
    65ab:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    65ae:	01 c8                	add    %ecx,%eax
	skb->len+=len;
    65b0:	01 4a 70             	add    %ecx,0x70(%edx)
	if(skb->tail>skb->end) {
    65b3:	3b 82 9c 00 00 00    	cmp    0x9c(%edx),%eax
    65b9:	89 82 98 00 00 00    	mov    %eax,0x98(%edx)
    65bf:	0f 87 7d 02 00 00    	ja     6842 <sendAckHelper+0x1182>
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
    65c5:	8b 4d dc             	mov    0xffffffdc(%ebp),%ecx
    65c8:	8b 7d cc             	mov    0xffffffcc(%ebp),%edi
    65cb:	8b 71 64             	mov    0x64(%ecx),%esi
int d0, d1, d2;
__asm__ __volatile__(
    65ce:	89 d9                	mov    %ebx,%ecx
    65d0:	83 c7 07             	add    $0x7,%edi
    65d3:	c1 e9 02             	shr    $0x2,%ecx
    65d6:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    65d8:	f6 c3 02             	test   $0x2,%bl
    65db:	74 02                	je     65df <sendAckHelper+0xf1f>
    65dd:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    65df:	f6 c3 01             	test   $0x1,%bl
    65e2:	74 01                	je     65e5 <sendAckHelper+0xf25>
    65e4:	a4                   	movsb  %ds:(%esi),%es:(%edi)
    65e5:	8b 75 cc             	mov    0xffffffcc(%ebp),%esi
    65e8:	c6 06 00             	movb   $0x0,(%esi)
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
    65eb:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    65ee:	8b 78 74             	mov    0x74(%eax),%edi
    65f1:	8b 98 98 00 00 00    	mov    0x98(%eax),%ebx
    65f7:	85 ff                	test   %edi,%edi
    65f9:	0f 85 45 05 00 00    	jne    6b44 <sendAckHelper+0x1484>
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
    65ff:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
	skb->len+=len;
	if(skb->tail>skb->end) {
    6602:	3b 9a 9c 00 00 00    	cmp    0x9c(%edx),%ebx
    6608:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
    660e:	0f 87 11 02 00 00    	ja     6825 <sendAckHelper+0x1165>
    6614:	8b 75 cc             	mov    0xffffffcc(%ebp),%esi
    6617:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
 *	first byte of the extra data is returned.
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
    661a:	29 f3                	sub    %esi,%ebx
    661c:	0f b7 c3             	movzwl %bx,%eax
/* gcc should generate this for open coded C now too. May be worth switching to 
   it because inline assembly cannot be scheduled. -AK */
static __inline__ __const__ __u16 ___arch__swab16(__u16 x)
{
	__asm__("xchgb %b0,%h0"		/* swap bytes		*/
    661f:	86 c4                	xchg   %al,%ah
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
    6621:	0f b7 d0             	movzwl %ax,%edx
    6624:	66 89 51 01          	mov    %dx,0x1(%ecx)
    6628:	8b 75 d8             	mov    0xffffffd8(%ebp),%esi
    662b:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    662e:	8b 7e 40             	mov    0x40(%esi),%edi
    6631:	01 f8                	add    %edi,%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    6633:	0f c8                	bswap  %eax
    6635:	81 fb 52 05 00 00    	cmp    $0x552,%ebx
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    663b:	89 41 03             	mov    %eax,0x3(%ecx)
    663e:	0f 87 d5 01 00 00    	ja     6819 <sendAckHelper+0x1159>
    6644:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    6647:	66 89 50 4b          	mov    %dx,0x4b(%eax)
    664b:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    664e:	8b 4d d0             	mov    0xffffffd0(%ebp),%ecx
    6651:	8b 75 dc             	mov    0xffffffdc(%ebp),%esi
    6654:	8b 42 40             	mov    0x40(%edx),%eax
    6657:	01 c1                	add    %eax,%ecx
    6659:	89 4e 40             	mov    %ecx,0x40(%esi)
    665c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    665f:	8b 75 f0             	mov    0xfffffff0(%ebp),%esi
    6662:	8b 90 cc 0a 00 00    	mov    0xacc(%eax),%edx
    6668:	b8 52 05 00 00       	mov    $0x552,%eax
    666d:	8b be c4 0a 00 00    	mov    0xac4(%esi),%edi
    6673:	29 d8                	sub    %ebx,%eax
    6675:	29 fa                	sub    %edi,%edx
    6677:	39 c2                	cmp    %eax,%edx
    6679:	0f 46 c2             	cmovbe %edx,%eax
    667c:	01 c1                	add    %eax,%ecx
    667e:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
    6681:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    6684:	89 48 44             	mov    %ecx,0x44(%eax)
    6687:	89 8e c8 0a 00 00    	mov    %ecx,0xac8(%esi)
    668d:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    6690:	01 d8                	add    %ebx,%eax
    6692:	3d 52 05 00 00       	cmp    $0x552,%eax
    6697:	0f 87 63 01 00 00    	ja     6800 <sendAckHelper+0x1140>
    669d:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    66a0:	85 c0                	test   %eax,%eax
    66a2:	0f 84 81 00 00 00    	je     6729 <sendAckHelper+0x1069>
    66a8:	c7 45 c4 af 66 00 00 	movl   $0x66af,0xffffffc4(%ebp)
    66af:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    66b2:	8b 7d d0             	mov    0xffffffd0(%ebp),%edi
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
    66b5:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    66b8:	8b 42 70             	mov    0x70(%edx),%eax
    66bb:	8b 5d d4             	mov    0xffffffd4(%ebp),%ebx
	return result;
}

static inline int skb_is_nonlinear(const struct sk_buff *skb)
{
    66be:	8b 71 74             	mov    0x74(%ecx),%esi
    66c1:	29 f8                	sub    %edi,%eax
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
    66c3:	8b b9 98 00 00 00    	mov    0x98(%ecx),%edi
    66c9:	39 45 d4             	cmp    %eax,0xffffffd4(%ebp)
    66cc:	0f 47 d8             	cmova  %eax,%ebx
	return result;
}

static inline int skb_is_nonlinear(const struct sk_buff *skb)
{
    66cf:	85 f6                	test   %esi,%esi
    66d1:	0f 85 6d 04 00 00    	jne    6b44 <sendAckHelper+0x1484>
	return skb->data_len;
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
	return skb->len - skb->data_len;
}

#define SKB_PAGE_ASSERT(skb) do { if (skb_shinfo(skb)->nr_frags) out_of_line_bug(); } while (0)
#define SKB_FRAG_ASSERT(skb) do { if (skb_shinfo(skb)->frag_list) out_of_line_bug(); } while (0)
#define SKB_LINEAR_ASSERT(skb) do { if (skb_is_nonlinear(skb)) out_of_line_bug(); } while (0)

/*
 *	Add data to an sk_buff
 */
 
static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	return tmp;
}

/**
 *	skb_put - add data to a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer. If this would
 *	exceed the total buffer size the kernel will panic. A pointer to the
 *	first byte of the extra data is returned.
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
    66d7:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    66da:	8d 04 3b             	lea    (%ebx,%edi,1),%eax
	skb->len+=len;
    66dd:	01 5e 70             	add    %ebx,0x70(%esi)
	if(skb->tail>skb->end) {
    66e0:	3b 86 9c 00 00 00    	cmp    0x9c(%esi),%eax
    66e6:	89 86 98 00 00 00    	mov    %eax,0x98(%esi)
    66ec:	0f 87 f6 00 00 00    	ja     67e8 <sendAckHelper+0x1128>
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
    66f2:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
int d0, d1, d2;
__asm__ __volatile__(
    66f5:	89 d9                	mov    %ebx,%ecx
    66f7:	c1 e9 02             	shr    $0x2,%ecx
    66fa:	8b 92 94 00 00 00    	mov    0x94(%edx),%edx
    6700:	01 55 d0             	add    %edx,0xffffffd0(%ebp)
    6703:	8b 75 d0             	mov    0xffffffd0(%ebp),%esi
    6706:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    6708:	f6 c3 02             	test   $0x2,%bl
    670b:	74 02                	je     670f <sendAckHelper+0x104f>
    670d:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    670f:	f6 c3 01             	test   $0x1,%bl
    6712:	74 01                	je     6715 <sendAckHelper+0x1055>
    6714:	a4                   	movsb  %ds:(%esi),%es:(%edi)
    6715:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
    671c:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
    671f:	8b 09                	mov    (%ecx),%ecx
    6721:	29 5d d4             	sub    %ebx,0xffffffd4(%ebp)
    6724:	89 4d d8             	mov    %ecx,0xffffffd8(%ebp)
    6727:	75 86                	jne    66af <sendAckHelper+0xfef>
    6729:	ff 05 a4 00 00 00    	incl   0xa4
    672f:	a1 00 00 00 00       	mov    0x0,%eax
    6734:	9c                   	pushf  
    6735:	59                   	pop    %ecx
    6736:	fa                   	cli    
    6737:	89 c2                	mov    %eax,%edx
    6739:	8b 1d 78 e2 04 00    	mov    0x4e278,%ebx
    673f:	8b 3d a8 00 00 00    	mov    0xa8,%edi
    6745:	a3 78 e2 04 00       	mov    %eax,0x4e278
    674a:	29 da                	sub    %ebx,%edx
    674c:	01 fa                	add    %edi,%edx
    674e:	89 15 a8 00 00 00    	mov    %edx,0xa8
    6754:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    675a:	76 10                	jbe    676c <sendAckHelper+0x10ac>
    675c:	be 88 13 00 00       	mov    $0x1388,%esi
    6761:	ba 88 13 00 00       	mov    $0x1388,%edx
    6766:	89 35 a8 00 00 00    	mov    %esi,0xa8
    676c:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    6772:	76 68                	jbe    67dc <sendAckHelper+0x111c>
    6774:	31 db                	xor    %ebx,%ebx
    6776:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    677c:	a1 7c e2 04 00       	mov    0x4e27c,%eax
    6781:	89 15 a8 00 00 00    	mov    %edx,0xa8
    6787:	89 1d 7c e2 04 00    	mov    %ebx,0x4e27c
    678d:	51                   	push   %ecx
    678e:	9d                   	popf   
    678f:	85 c0                	test   %eax,%eax
    6791:	75 27                	jne    67ba <sendAckHelper+0x10fa>
    6793:	b8 01 00 00 00       	mov    $0x1,%eax
    6798:	85 c0                	test   %eax,%eax
    679a:	0f 84 ed fc ff ff    	je     648d <sendAckHelper+0xdcd>
    67a0:	c7 04 24 04 03 00 00 	movl   $0x304,(%esp,1)
    67a7:	a1 a4 00 00 00       	mov    0xa4,%eax
    67ac:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    67b0:	e8 fc ff ff ff       	call   67b1 <sendAckHelper+0x10f1>
    67b5:	e9 d3 fc ff ff       	jmp    648d <sendAckHelper+0xdcd>
    67ba:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    67be:	c7 44 24 08 d5 0d 00 	movl   $0xdd5,0x8(%esp,1)
    67c5:	00 
    67c6:	c7 44 24 04 6b 00 00 	movl   $0x6b,0x4(%esp,1)
    67cd:	00 
    67ce:	c7 04 24 c0 02 00 00 	movl   $0x2c0,(%esp,1)
    67d5:	e8 fc ff ff ff       	call   67d6 <sendAckHelper+0x1116>
    67da:	eb b7                	jmp    6793 <sendAckHelper+0x10d3>
    67dc:	ff 05 7c e2 04 00    	incl   0x4e27c
    67e2:	51                   	push   %ecx
    67e3:	9d                   	popf   
    67e4:	31 c0                	xor    %eax,%eax
    67e6:	eb b0                	jmp    6798 <sendAckHelper+0x10d8>
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	if(skb->tail>skb->end) {
		skb_over_panic(skb, len, current_text_addr());
    67e8:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    67ec:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    67ef:	89 34 24             	mov    %esi,(%esp,1)
    67f2:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    67f6:	e8 fc ff ff ff       	call   67f7 <sendAckHelper+0x1137>
    67fb:	e9 f2 fe ff ff       	jmp    66f2 <sendAckHelper+0x1032>
    6800:	c7 44 24 04 ca 0d 00 	movl   $0xdca,0x4(%esp,1)
    6807:	00 
    6808:	c7 04 24 80 22 00 00 	movl   $0x2280,(%esp,1)
    680f:	e8 fc ff ff ff       	call   6810 <sendAckHelper+0x1150>
    6814:	e9 84 fe ff ff       	jmp    669d <sendAckHelper+0xfdd>
    6819:	c7 04 24 1a 03 00 00 	movl   $0x31a,(%esp,1)
    6820:	e9 ea f7 ff ff       	jmp    600f <sendAckHelper+0x94f>
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	if(skb->tail>skb->end) {
		skb_over_panic(skb, len, current_text_addr());
    6825:	c7 44 24 08 2d 68 00 	movl   $0x682d,0x8(%esp,1)
    682c:	00 
    682d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    6834:	00 
    6835:	89 14 24             	mov    %edx,(%esp,1)
    6838:	e8 fc ff ff ff       	call   6839 <sendAckHelper+0x1179>
    683d:	e9 d2 fd ff ff       	jmp    6614 <sendAckHelper+0xf54>
    6842:	c7 44 24 08 4a 68 00 	movl   $0x684a,0x8(%esp,1)
    6849:	00 
    684a:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    684e:	89 14 24             	mov    %edx,(%esp,1)
    6851:	e8 fc ff ff ff       	call   6852 <sendAckHelper+0x1192>
    6856:	e9 6a fd ff ff       	jmp    65c5 <sendAckHelper+0xf05>
    685b:	c7 44 24 08 63 68 00 	movl   $0x6863,0x8(%esp,1)
    6862:	00 
    6863:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp,1)
    686a:	00 
    686b:	89 0c 24             	mov    %ecx,(%esp,1)
    686e:	e8 fc ff ff ff       	call   686f <sendAckHelper+0x11af>
    6873:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    6876:	8b 56 74             	mov    0x74(%esi),%edx
    6879:	e9 13 fd ff ff       	jmp    6591 <sendAckHelper+0xed1>
    687e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    6881:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    6884:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
    688a:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
    688d:	8b 4a 74             	mov    0x74(%edx),%ecx
    6890:	85 c9                	test   %ecx,%ecx
    6892:	0f 85 ac 02 00 00    	jne    6b44 <sendAckHelper+0x1484>
    6898:	8b 7d c8             	mov    0xffffffc8(%ebp),%edi
    689b:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    689e:	83 c7 14             	add    $0x14,%edi
    68a1:	83 41 70 14          	addl   $0x14,0x70(%ecx)
    68a5:	3b b9 9c 00 00 00    	cmp    0x9c(%ecx),%edi
    68ab:	89 b9 98 00 00 00    	mov    %edi,0x98(%ecx)
    68b1:	0f 87 e2 00 00 00    	ja     6999 <sendAckHelper+0x12d9>
  memcpy(rval->kernel.data, scont->data, dataLen);
  return rval;
}

static inline unsigned marshallUC_Continuation(struct WireUC_Continuation *dcont, struct UC_Continuation *scont) {
    68b7:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    68ba:	8b 55 c8             	mov    0xffffffc8(%ebp),%edx
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    68bd:	8b 4d c8             	mov    0xffffffc8(%ebp),%ecx
  memcpy(rval->kernel.data, scont->data, dataLen);
  return rval;
}

static inline unsigned marshallUC_Continuation(struct WireUC_Continuation *dcont, struct UC_Continuation *scont) {
    68c0:	8b 70 64             	mov    0x64(%eax),%esi
    68c3:	83 c2 07             	add    $0x7,%edx
  int dataLen = scont->dataLen;
    68c6:	8b 5e 28             	mov    0x28(%esi),%ebx
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    68c9:	8b 46 0c             	mov    0xc(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    68cc:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    68ce:	89 41 07             	mov    %eax,0x7(%ecx)
    68d1:	8b 46 10             	mov    0x10(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    68d4:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    68d6:	89 42 04             	mov    %eax,0x4(%edx)
    68d9:	8b 46 14             	mov    0x14(%esi),%eax

static inline void * __memcpy(void * to, const void * from, size_t n)
{
int d0, d1, d2;
__asm__ __volatile__(
    68dc:	89 d9                	mov    %ebx,%ecx

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    68de:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    68e0:	89 42 08             	mov    %eax,0x8(%edx)

static inline void * __memcpy(void * to, const void * from, size_t n)
{
int d0, d1, d2;
__asm__ __volatile__(
    68e3:	c1 e9 02             	shr    $0x2,%ecx
  int dataLen = scont->dataLen;
  dcont->seq = htonl(scont->seq);
  dcont->validStart = htonl(scont->validStart);
  dcont->validEnd = htonl(scont->validEnd);
  dcont->fields = scont->fields;
    68e6:	0f b6 46 20          	movzbl 0x20(%esi),%eax
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
    68ea:	83 c6 30             	add    $0x30,%esi
  int dataLen = scont->dataLen;
  dcont->seq = htonl(scont->seq);
  dcont->validStart = htonl(scont->validStart);
  dcont->validEnd = htonl(scont->validEnd);
  dcont->fields = scont->fields;
    68ed:	88 42 0c             	mov    %al,0xc(%edx)

static inline void * __memcpy(void * to, const void * from, size_t n)
{
int d0, d1, d2;
__asm__ __volatile__(
    68f0:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    68f2:	f6 c3 02             	test   $0x2,%bl
    68f5:	74 02                	je     68f9 <sendAckHelper+0x1239>
    68f7:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    68f9:	f6 c3 01             	test   $0x1,%bl
    68fc:	74 01                	je     68ff <sendAckHelper+0x123f>
    68fe:	a4                   	movsb  %ds:(%esi),%es:(%edi)
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
    68ff:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    6902:	8b 56 74             	mov    0x74(%esi),%edx
    6905:	8b 86 98 00 00 00    	mov    0x98(%esi),%eax
    690b:	85 d2                	test   %edx,%edx
    690d:	0f 85 31 02 00 00    	jne    6b44 <sendAckHelper+0x1484>
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
    6913:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    6916:	01 d8                	add    %ebx,%eax
	skb->len+=len;
    6918:	01 5a 70             	add    %ebx,0x70(%edx)
	if(skb->tail>skb->end) {
    691b:	3b 82 9c 00 00 00    	cmp    0x9c(%edx),%eax
    6921:	89 82 98 00 00 00    	mov    %eax,0x98(%edx)
    6927:	77 5a                	ja     6983 <sendAckHelper+0x12c3>
    6929:	8b 4d c8             	mov    0xffffffc8(%ebp),%ecx
    692c:	c6 01 01             	movb   $0x1,(%ecx)
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
    692f:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    6932:	8b 46 74             	mov    0x74(%esi),%eax
    6935:	8b 9e 98 00 00 00    	mov    0x98(%esi),%ebx
    693b:	85 c0                	test   %eax,%eax
    693d:	0f 85 01 02 00 00    	jne    6b44 <sendAckHelper+0x1484>
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
    6943:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
	skb->len+=len;
	if(skb->tail>skb->end) {
    6946:	3b 98 9c 00 00 00    	cmp    0x9c(%eax),%ebx
    694c:	89 98 98 00 00 00    	mov    %ebx,0x98(%eax)
    6952:	77 15                	ja     6969 <sendAckHelper+0x12a9>
    6954:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    6957:	8b 4d c8             	mov    0xffffffc8(%ebp),%ecx
 *	first byte of the extra data is returned.
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
    695a:	29 c3                	sub    %eax,%ebx
    695c:	0f b7 c3             	movzwl %bx,%eax
/* gcc should generate this for open coded C now too. May be worth switching to 
   it because inline assembly cannot be scheduled. -AK */
static __inline__ __const__ __u16 ___arch__swab16(__u16 x)
{
	__asm__("xchgb %b0,%h0"		/* swap bytes		*/
    695f:	86 c4                	xchg   %al,%ah
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
    6961:	0f b7 d0             	movzwl %ax,%edx
    6964:	e9 bb fc ff ff       	jmp    6624 <sendAckHelper+0xf64>
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	if(skb->tail>skb->end) {
		skb_over_panic(skb, len, current_text_addr());
    6969:	c7 44 24 08 71 69 00 	movl   $0x6971,0x8(%esp,1)
    6970:	00 
    6971:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    6978:	00 
    6979:	89 04 24             	mov    %eax,(%esp,1)
    697c:	e8 fc ff ff ff       	call   697d <sendAckHelper+0x12bd>
    6981:	eb d1                	jmp    6954 <sendAckHelper+0x1294>
    6983:	c7 44 24 08 8b 69 00 	movl   $0x698b,0x8(%esp,1)
    698a:	00 
    698b:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    698f:	89 14 24             	mov    %edx,(%esp,1)
    6992:	e8 fc ff ff ff       	call   6993 <sendAckHelper+0x12d3>
    6997:	eb 90                	jmp    6929 <sendAckHelper+0x1269>
    6999:	c7 44 24 08 a1 69 00 	movl   $0x69a1,0x8(%esp,1)
    69a0:	00 
    69a1:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp,1)
    69a8:	00 
    69a9:	89 0c 24             	mov    %ecx,(%esp,1)
    69ac:	e8 fc ff ff ff       	call   69ad <sendAckHelper+0x12ed>
    69b1:	e9 01 ff ff ff       	jmp    68b7 <sendAckHelper+0x11f7>
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
		BUG();
    69b6:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    69bd:	00 
    69be:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    69c5:	e8 fc ff ff ff       	call   69c6 <sendAckHelper+0x1306>
    69ca:	e8 fc ff ff ff       	call   69cb <sendAckHelper+0x130b>
		show_stack(NULL);
    69cf:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    69d6:	e8 fc ff ff ff       	call   69d7 <sendAckHelper+0x1317>
    69db:	8b 86 68 0a 00 00    	mov    0xa68(%esi),%eax
    69e1:	e9 a3 f8 ff ff       	jmp    6289 <sendAckHelper+0xbc9>
    69e6:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    69e9:	66 c7 42 4b 00 00    	movw   $0x0,0x4b(%edx)
    69ef:	c7 42 0e ff ff ff ff 	movl   $0xffffffff,0xe(%edx)
    69f6:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    69f9:	8b 75 0c             	mov    0xc(%ebp),%esi
    69fc:	8b 45 08             	mov    0x8(%ebp),%eax
    69ff:	89 4c 24 08          	mov    %ecx,0x8(%esp,1)
    6a03:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    6a07:	89 04 24             	mov    %eax,(%esp,1)
    6a0a:	e8 81 ea ff ff       	call   5490 <runSimulation>
    6a0f:	85 c0                	test   %eax,%eax
    6a11:	0f 84 fd f5 ff ff    	je     6014 <sendAckHelper+0x954>
    6a17:	81 be b4 00 00 00 e7 	cmpl   $0x3e7,0xb4(%esi)
    6a1e:	03 00 00 
    6a21:	0f 86 96 f7 ff ff    	jbe    61bd <sendAckHelper+0xafd>
    6a27:	ff 05 ac 00 00 00    	incl   0xac
    6a2d:	a1 00 00 00 00       	mov    0x0,%eax
    6a32:	9c                   	pushf  
    6a33:	59                   	pop    %ecx
    6a34:	fa                   	cli    
    6a35:	89 c2                	mov    %eax,%edx
    6a37:	8b 1d 80 e2 04 00    	mov    0x4e280,%ebx
    6a3d:	8b 3d b0 00 00 00    	mov    0xb0,%edi
    6a43:	a3 80 e2 04 00       	mov    %eax,0x4e280
    6a48:	29 da                	sub    %ebx,%edx
    6a4a:	01 fa                	add    %edi,%edx
    6a4c:	89 15 b0 00 00 00    	mov    %edx,0xb0
    6a52:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    6a58:	76 10                	jbe    6a6a <sendAckHelper+0x13aa>
    6a5a:	be 88 13 00 00       	mov    $0x1388,%esi
    6a5f:	ba 88 13 00 00       	mov    $0x1388,%edx
    6a64:	89 35 b0 00 00 00    	mov    %esi,0xb0
    6a6a:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    6a70:	76 68                	jbe    6ada <sendAckHelper+0x141a>
    6a72:	31 db                	xor    %ebx,%ebx
    6a74:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    6a7a:	a1 84 e2 04 00       	mov    0x4e284,%eax
    6a7f:	89 15 b0 00 00 00    	mov    %edx,0xb0
    6a85:	89 1d 84 e2 04 00    	mov    %ebx,0x4e284
    6a8b:	51                   	push   %ecx
    6a8c:	9d                   	popf   
    6a8d:	85 c0                	test   %eax,%eax
    6a8f:	75 27                	jne    6ab8 <sendAckHelper+0x13f8>
    6a91:	b8 01 00 00 00       	mov    $0x1,%eax
    6a96:	85 c0                	test   %eax,%eax
    6a98:	0f 84 5f f1 ff ff    	je     5bfd <sendAckHelper+0x53d>
    6a9e:	c7 04 24 2c 03 00 00 	movl   $0x32c,(%esp,1)
    6aa5:	a1 ac 00 00 00       	mov    0xac,%eax
    6aaa:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6aae:	e8 fc ff ff ff       	call   6aaf <sendAckHelper+0x13ef>
    6ab3:	e9 45 f1 ff ff       	jmp    5bfd <sendAckHelper+0x53d>
    6ab8:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    6abc:	c7 44 24 08 ac 0e 00 	movl   $0xeac,0x8(%esp,1)
    6ac3:	00 
    6ac4:	c7 44 24 04 6b 00 00 	movl   $0x6b,0x4(%esp,1)
    6acb:	00 
    6acc:	c7 04 24 c0 02 00 00 	movl   $0x2c0,(%esp,1)
    6ad3:	e8 fc ff ff ff       	call   6ad4 <sendAckHelper+0x1414>
    6ad8:	eb b7                	jmp    6a91 <sendAckHelper+0x13d1>
    6ada:	ff 05 84 e2 04 00    	incl   0x4e284
    6ae0:	51                   	push   %ecx
    6ae1:	9d                   	popf   
    6ae2:	31 c0                	xor    %eax,%eax
    6ae4:	eb b0                	jmp    6a96 <sendAckHelper+0x13d6>
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	if(skb->tail>skb->end) {
		skb_over_panic(skb, len, current_text_addr());
    6ae6:	c7 44 24 08 ee 6a 00 	movl   $0x6aee,0x8(%esp,1)
    6aed:	00 
    6aee:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    6af2:	89 0c 24             	mov    %ecx,(%esp,1)
    6af5:	e8 fc ff ff ff       	call   6af6 <sendAckHelper+0x1436>
    6afa:	e9 d8 ed ff ff       	jmp    58d7 <sendAckHelper+0x217>
    6aff:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    6b02:	05 08 06 00 00       	add    $0x608,%eax
    6b07:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    6b0e:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    6b11:	0f 8e 67 ed ff ff    	jle    587e <sendAckHelper+0x1be>
    6b17:	c7 04 24 41 03 00 00 	movl   $0x341,(%esp,1)
    6b1e:	e8 fc ff ff ff       	call   6b1f <sendAckHelper+0x145f>
    6b23:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    6b26:	89 14 24             	mov    %edx,(%esp,1)
    6b29:	e8 fc ff ff ff       	call   6b2a <sendAckHelper+0x146a>
    6b2e:	e9 4b ed ff ff       	jmp    587e <sendAckHelper+0x1be>
    6b33:	c7 04 24 54 03 00 00 	movl   $0x354,(%esp,1)
    6b3a:	e8 fc ff ff ff       	call   6b3b <sendAckHelper+0x147b>
    6b3f:	e9 ab ec ff ff       	jmp    57ef <sendAckHelper+0x12f>
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
    6b44:	c7 04 24 24 03 00 00 	movl   $0x324,(%esp,1)
    6b4b:	e8 fc ff ff ff       	call   6b4c <sendAckHelper+0x148c>

00006b50 <ContList_dump>:

#if 0 // 0426 removed static to allow call from gdb
static 
#endif
void ContList_dump(struct sock *sk) {
    6b50:	55                   	push   %ebp
    6b51:	89 e5                	mov    %esp,%ebp
    6b53:	56                   	push   %esi
    6b54:	53                   	push   %ebx
    6b55:	83 ec 08             	sub    $0x8,%esp
    6b58:	8b 75 08             	mov    0x8(%ebp),%esi
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	CONTINUATION_TYPE *msk = (CONTINUATION_TYPE *)tp->t.cont_list.next;
	printk("  ContList: ");
    6b5b:	c7 04 24 72 03 00 00 	movl   $0x372,(%esp,1)
    6b62:	e8 fc ff ff ff       	call   6b63 <ContList_dump+0x13>
    6b67:	8d 9e bc 00 00 00    	lea    0xbc(%esi),%ebx

#if 0 // 0426 more extensive dump
	if(msk != (CONTINUATION_TYPE*)&tp->t.cont_list) {
		printk("%d-%d", ((CONTINUATION_TYPE *)tp->t.cont_list.next)->seq, 
		       ((CONTINUATION_TYPE *)tp->t.cont_list.prev)->seq);
	}
#else
	alloc_head_walk(&tp->t.cont_list, msk) {
    6b6d:	8b 9b 24 0a 00 00    	mov    0xa24(%ebx),%ebx
    6b73:	8d 86 dc 0a 00 00    	lea    0xadc(%esi),%eax
    6b79:	39 c3                	cmp    %eax,%ebx
    6b7b:	74 1d                	je     6b9a <ContList_dump+0x4a>
    6b7d:	89 c6                	mov    %eax,%esi
    6b7f:	90                   	nop    
		printk("%d, ", msk->seq);
    6b80:	8b 43 34             	mov    0x34(%ebx),%eax
    6b83:	c7 04 24 7f 03 00 00 	movl   $0x37f,(%esp,1)
    6b8a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6b8e:	e8 fc ff ff ff       	call   6b8f <ContList_dump+0x3f>
    6b93:	8b 5b 04             	mov    0x4(%ebx),%ebx
    6b96:	39 f3                	cmp    %esi,%ebx
    6b98:	75 e6                	jne    6b80 <ContList_dump+0x30>
	}
#endif
	printk("\n");
    6b9a:	c7 45 08 84 03 00 00 	movl   $0x384,0x8(%ebp)
    6ba1:	83 c4 08             	add    $0x8,%esp
    6ba4:	5b                   	pop    %ebx
    6ba5:	5e                   	pop    %esi
    6ba6:	5d                   	pop    %ebp
    6ba7:	e9 fc ff ff ff       	jmp    6ba8 <ContList_dump+0x58>
    6bac:	8d 74 26 00          	lea    0x0(%esi,1),%esi

00006bb0 <requestSlowStart>:
}

static void requestSlowStart(struct sock *sk) {
    6bb0:	55                   	push   %ebp
    6bb1:	89 e5                	mov    %esp,%ebp
    6bb3:	57                   	push   %edi
    6bb4:	56                   	push   %esi
    6bb5:	53                   	push   %ebx
    6bb6:	83 ec 4c             	sub    $0x4c,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	CONTINUATION_TYPE *msk = NULL, *curr_cont, *clean;
    6bb9:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
    6bc0:	8b 45 08             	mov    0x8(%ebp),%eax
    6bc3:	05 bc 00 00 00       	add    $0xbc,%eax
    6bc8:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
	struct sk_buff *skb;
	struct Request *mreq, *prev;
	struct DataRequestMapping *dataReq, *nextDataReq;
	__u32 left, right, lastRcv = tp->t.rcv_nxt - 1;
    6bcb:	8b 90 dc 02 00 00    	mov    0x2dc(%eax),%edx
	int leftViolation = 0, rightViolation = 0;
    6bd1:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
    6bd8:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
    6bdf:	4a                   	dec    %edx
    6be0:	89 55 d8             	mov    %edx,0xffffffd8(%ebp)

	tp->t.timerState &= ~TRICKLES_NEED_SLOWSTART;
    6be3:	83 a0 d8 02 00 00 fd 	andl   $0xfffffffd,0x2d8(%eax)
	if(clientDebugLevel >= 1) {
    6bea:	a1 00 00 00 00       	mov    0x0,%eax
    6bef:	85 c0                	test   %eax,%eax
    6bf1:	7e 30                	jle    6c23 <requestSlowStart+0x73>
		printk("  client: slow start acking %u, tp->rcv_nxt = %u, tp->copied_seq = %u\n", tp->t.rcv_nxt - 1, tp->rcv_nxt, tp->copied_seq);
    6bf3:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
    6bf6:	8b 81 fc 00 00 00    	mov    0xfc(%ecx),%eax
    6bfc:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    6c00:	8b 41 08             	mov    0x8(%ecx),%eax
    6c03:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    6c07:	c7 04 24 e0 22 00 00 	movl   $0x22e0,(%esp,1)
    6c0e:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    6c12:	e8 fc ff ff ff       	call   6c13 <requestSlowStart+0x63>
		printk("Slow start dump\n");
    6c17:	c7 04 24 86 03 00 00 	movl   $0x386,(%esp,1)
    6c1e:	e8 fc ff ff ff       	call   6c1f <requestSlowStart+0x6f>
	}
	right = AckProof_findRight(&tp->t.altProof, lastRcv);
    6c23:	8b 5d 08             	mov    0x8(%ebp),%ebx
    6c26:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    6c29:	81 c3 c4 06 00 00    	add    $0x6c4,%ebx
    6c2f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6c33:	89 1c 24             	mov    %ebx,(%esp,1)
    6c36:	e8 fc ff ff ff       	call   6c37 <requestSlowStart+0x87>
	left = AckProof_findLeft(&tp->t.altProof, lastRcv);
    6c3b:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    6c3e:	89 c7                	mov    %eax,%edi
    6c40:	89 1c 24             	mov    %ebx,(%esp,1)
    6c43:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    6c47:	e8 fc ff ff ff       	call   6c48 <requestSlowStart+0x98>
	if(right != lastRcv) {
#if 0
		BUG_TRAP(right != tp->t.rcv_nxt - 1);
		printk("right (%u) != tp->t.rcv_nxt - 1 (%u)\n", right, tp->t.rcv_nxt - 1);
		AckProof_dump(&tp->t.altProof;
#endif
	}
	if(right >= lastRcv) {
    6c4c:	3b 7d d8             	cmp    0xffffffd8(%ebp),%edi
    6c4f:	89 c6                	mov    %eax,%esi
    6c51:	72 0d                	jb     6c60 <requestSlowStart+0xb0>
		if(clientDebugLevel >= 2) {
    6c53:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    6c5a:	0f 8f f9 05 00 00    	jg     7259 <requestSlowStart+0x6a9>
			printk("right >= lastRcv ");
			AckProof_dump(&tp->t.altProof);
		}
	}
	alloc_head_reverse_walk(&tp->t.cont_list, curr_cont) {
    6c60:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
    6c63:	8b 99 20 0a 00 00    	mov    0xa20(%ecx),%ebx
    6c69:	81 c1 20 0a 00 00    	add    $0xa20,%ecx
    6c6f:	89 4d c8             	mov    %ecx,0xffffffc8(%ebp)
    6c72:	39 cb                	cmp    %ecx,%ebx
    6c74:	74 52                	je     6cc8 <requestSlowStart+0x118>
    6c76:	8d 76 00             	lea    0x0(%esi),%esi
    6c79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
		if(left <= curr_cont->TCPBase && curr_cont->TCPBase <= right) {
    6c80:	8b 53 70             	mov    0x70(%ebx),%edx
    6c83:	39 d6                	cmp    %edx,%esi
    6c85:	77 08                	ja     6c8f <requestSlowStart+0xdf>
    6c87:	39 fa                	cmp    %edi,%edx
    6c89:	0f 86 c2 05 00 00    	jbe    7251 <requestSlowStart+0x6a1>
			msk = curr_cont;
			break;
			//BUG_TRAP();
		}
		if(left > curr_cont->TCPBase) leftViolation++;
    6c8f:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    6c92:	40                   	inc    %eax
    6c93:	39 d6                	cmp    %edx,%esi
    6c95:	0f 46 45 d4          	cmovbe 0xffffffd4(%ebp),%eax
    6c99:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
		if(right < curr_cont->TCPBase) rightViolation++;
    6c9c:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    6c9f:	40                   	inc    %eax
    6ca0:	39 d7                	cmp    %edx,%edi
    6ca2:	0f 43 45 d0          	cmovae 0xffffffd0(%ebp),%eax
    6ca6:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
		if(curr_cont->TCPBase > tp->t.previous_base) {
    6ca9:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    6cac:	3b 90 e0 02 00 00    	cmp    0x2e0(%eax),%edx
    6cb2:	76 0d                	jbe    6cc1 <requestSlowStart+0x111>
			if(clientDebugLevel >= 2) {
    6cb4:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    6cbb:	0f 8f 7f 05 00 00    	jg     7240 <requestSlowStart+0x690>
    6cc1:	8b 1b                	mov    (%ebx),%ebx
    6cc3:	3b 5d c8             	cmp    0xffffffc8(%ebp),%ebx
    6cc6:	75 b8                	jne    6c80 <requestSlowStart+0xd0>
				printk("requestslowstart tcpbase > previousbase\n");
			}
		}
	}
#ifdef JAM_SLOWSTART2
	if(trickles_ratelimit()) printk("requestslowstart: jam slowstart 2\n");
	return;
#endif

	if(msk == NULL) {
    6cc8:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    6ccb:	85 c0                	test   %eax,%eax
    6ccd:	0f 84 82 04 00 00    	je     7155 <requestSlowStart+0x5a5>
		if(0 || !disableSevereErrors)
			if(trickles_ratelimit())
				printk("%p: Could not find acceptable msk in requestSlowStart, contlist len = %d, left violations %d, right violations %d\n", sk, tp->t.cont_list.len, leftViolation, rightViolation);
		return;
	}
	if(clientDebugLevel >= 1)
    6cd3:	8b 0d 00 00 00 00    	mov    0x0,%ecx
    6cd9:	85 c9                	test   %ecx,%ecx
    6cdb:	7e 25                	jle    6d02 <requestSlowStart+0x152>
	  printk("using cont %u, base = %u, left = %u right = %u\n", msk->seq, msk->TCPBase, left, right);
    6cdd:	89 7c 24 10          	mov    %edi,0x10(%esp,1)
    6ce1:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    6ce4:	89 74 24 0c          	mov    %esi,0xc(%esp,1)
    6ce8:	8b 42 70             	mov    0x70(%edx),%eax
    6ceb:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    6cef:	8b 42 34             	mov    0x34(%edx),%eax
    6cf2:	c7 04 24 40 23 00 00 	movl   $0x2340,(%esp,1)
    6cf9:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6cfd:	e8 fc ff ff ff       	call   6cfe <requestSlowStart+0x14e>
	BUG_TRAP(msk != (CONTINUATION_TYPE*)&tp->t.cont_list);
    6d02:	8b 4d c8             	mov    0xffffffc8(%ebp),%ecx
    6d05:	39 4d e4             	cmp    %ecx,0xffffffe4(%ebp)
    6d08:	0f 84 2e 04 00 00    	je     713c <requestSlowStart+0x58c>
	skb = tp->t.ofo_queue.next;
    6d0e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax

	/* Clean up state to avoid interference from other packets */
	while(skb != (struct sk_buff*)&tp->t.ofo_queue) {
    6d11:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    6d14:	8b 80 e4 02 00 00    	mov    0x2e4(%eax),%eax
    6d1a:	81 c2 e4 02 00 00    	add    $0x2e4,%edx
    6d20:	89 55 c4             	mov    %edx,0xffffffc4(%ebp)
    6d23:	39 d0                	cmp    %edx,%eax
    6d25:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    6d28:	0f 84 b2 00 00 00    	je     6de0 <requestSlowStart+0x230>
    6d2e:	89 f6                	mov    %esi,%esi
		struct sk_buff *prev = skb;
    6d30:	8b 5d dc             	mov    0xffffffdc(%ebp),%ebx
static inline void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
{
	struct sk_buff * next, * prev;

	list->qlen--;
    6d33:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
		skb = skb->next;
    6d36:	8b 0b                	mov    (%ebx),%ecx
    6d38:	89 4d dc             	mov    %ecx,0xffffffdc(%ebp)
static inline void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
{
	struct sk_buff * next, * prev;

	list->qlen--;
    6d3b:	ff 48 08             	decl   0x8(%eax)
	next = skb->next;
	prev = skb->prev;
	skb->next = NULL;
	skb->prev = NULL;
	skb->list = NULL;
    6d3e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    6d45:	8b 13                	mov    (%ebx),%edx
    6d47:	8b 43 04             	mov    0x4(%ebx),%eax
    6d4a:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    6d50:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	next->prev = prev;
	prev->next = next;
    6d57:	89 10                	mov    %edx,(%eax)
    6d59:	89 42 04             	mov    %eax,0x4(%edx)
 * Atomically subtracts @i from @v.  Note that the guaranteed
 * useful range of an atomic_t is only 24 bits.
 */
static __inline__ void atomic_sub(int i, atomic_t *v)
{
    6d5c:	8b 83 9c 00 00 00    	mov    0x9c(%ebx),%eax
    6d62:	8b 93 90 00 00 00    	mov    0x90(%ebx),%edx
    6d68:	29 d0                	sub    %edx,%eax
	__asm__ __volatile__(
    6d6a:	29 05 00 00 00 00    	sub    %eax,0x0
		__skb_unlink(prev, &tp->t.ofo_queue);
		delOfoSkb(prev);
		BUG_TRAP(TCP_SKB_CB(prev)->cont->list == NULL); // 0430 tracking down corruption bug
    6d70:	8b 73 5c             	mov    0x5c(%ebx),%esi
    6d73:	8b 46 08             	mov    0x8(%esi),%eax
    6d76:	85 c0                	test   %eax,%eax
    6d78:	0f 85 a2 03 00 00    	jne    7120 <requestSlowStart+0x570>
  }
#endif // USERTEST
#endif // DEBUG_ALLOC

  if(cont->list) {
    6d7e:	8b 46 08             	mov    0x8(%esi),%eax
    6d81:	85 c0                	test   %eax,%eax
    6d83:	0f 85 77 03 00 00    	jne    7100 <requestSlowStart+0x550>
	  BUG();
  }

  for(i=0; i < 2; i++) {
    6d89:	c7 45 cc 01 00 00 00 	movl   $0x1,0xffffffcc(%ebp)
    6d90:	31 ff                	xor    %edi,%edi
    if((cont+i)->ucont_data)
    6d92:	8b 84 3e 80 00 00 00 	mov    0x80(%esi,%edi,1),%eax
    6d99:	85 c0                	test   %eax,%eax
    6d9b:	0f 85 4f 03 00 00    	jne    70f0 <requestSlowStart+0x540>
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
    6da1:	8b 84 3e 88 00 00 00 	mov    0x88(%esi,%edi,1),%eax
    6da8:	85 c0                	test   %eax,%eax
    6daa:	0f 85 30 03 00 00    	jne    70e0 <requestSlowStart+0x530>
    6db0:	81 c7 e4 00 00 00    	add    $0xe4,%edi
    6db6:	ff 4d cc             	decl   0xffffffcc(%ebp)
    6db9:	79 d7                	jns    6d92 <requestSlowStart+0x1e2>
      kfree((cont+i)->input);
  }

#ifdef USERTEST
  kfree(cont);
#else  //0426 - change kernel to slab cache
#ifdef DEBUG_ALLOC
  zap_virt(cont);
  //memset(cont, 0x3e, sizeof(*cont));
#else
#ifndef USESLAB
  kfree(cont);  // 0502 maybe slab cache usage is buggy
#else
  kmem_cache_free(clientSideContinuation_cache, cont);
    6dbb:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    6dbf:	a1 00 00 00 00       	mov    0x0,%eax
    6dc4:	89 04 24             	mov    %eax,(%esp,1)
    6dc7:	e8 fc ff ff ff       	call   6dc8 <requestSlowStart+0x218>
		MARK_PC(TCP_SKB_CB(prev)->cont);
		freeClientSide_Continuation(TCP_SKB_CB(prev)->cont);
		__kfree_skb(prev);
    6dcc:	89 1c 24             	mov    %ebx,(%esp,1)
    6dcf:	e8 fc ff ff ff       	call   6dd0 <requestSlowStart+0x220>
    6dd4:	8b 55 c4             	mov    0xffffffc4(%ebp),%edx
    6dd7:	39 55 dc             	cmp    %edx,0xffffffdc(%ebp)
    6dda:	0f 85 50 ff ff ff    	jne    6d30 <requestSlowStart+0x180>
	}
#ifdef JAM_SLOWSTART3
	if(trickles_ratelimit()) printk("requestslowstart: jam slowstart 3\n");
	return;
#endif

	clean = (CONTINUATION_TYPE*)tp->t.cont_list.next;
    6de0:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
	while(clean != (CONTINUATION_TYPE*)&tp->t.cont_list) {
    6de3:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    6de6:	8b 89 24 0a 00 00    	mov    0xa24(%ecx),%ecx
    6dec:	89 4d e0             	mov    %ecx,0xffffffe0(%ebp)
    6def:	39 c1                	cmp    %eax,%ecx
    6df1:	0f 84 84 00 00 00    	je     6e7b <requestSlowStart+0x2cb>
    6df7:	89 f6                	mov    %esi,%esi
    6df9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
		CONTINUATION_TYPE *prev = clean;
    6e00:	8b 5d e0             	mov    0xffffffe0(%ebp),%ebx
		clean = clean->next;
		// 0424: clean out all continuations other than the one we are using for slowstart
		if(prev != msk) {
    6e03:	3b 5d e4             	cmp    0xffffffe4(%ebp),%ebx
    6e06:	8b 53 04             	mov    0x4(%ebx),%edx
    6e09:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
    6e0c:	74 65                	je     6e73 <requestSlowStart+0x2c3>
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    6e0e:	8b 53 04             	mov    0x4(%ebx),%edx
  if(cont->list) {
	  BUG();
  }

  for(i=0; i < 2; i++) {
    6e11:	31 f6                	xor    %esi,%esi
    6e13:	bf 01 00 00 00       	mov    $0x1,%edi
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    6e18:	8b 03                	mov    (%ebx),%eax
    6e1a:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    6e1c:	8b 03                	mov    (%ebx),%eax
	elem->prev = elem->next = NULL;
    6e1e:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    6e24:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
    6e27:	8b 43 08             	mov    0x8(%ebx),%eax
    6e2a:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    6e31:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    6e34:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	  BUG();
  }

  for(i=0; i < 2; i++) {
    if((cont+i)->ucont_data)
    6e3b:	8b 84 33 80 00 00 00 	mov    0x80(%ebx,%esi,1),%eax
    6e42:	85 c0                	test   %eax,%eax
    6e44:	0f 85 86 02 00 00    	jne    70d0 <requestSlowStart+0x520>
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
    6e4a:	8b 84 33 88 00 00 00 	mov    0x88(%ebx,%esi,1),%eax
    6e51:	85 c0                	test   %eax,%eax
    6e53:	0f 85 67 02 00 00    	jne    70c0 <requestSlowStart+0x510>
    6e59:	81 c6 e4 00 00 00    	add    $0xe4,%esi
    6e5f:	4f                   	dec    %edi
    6e60:	79 d9                	jns    6e3b <requestSlowStart+0x28b>
      kfree((cont+i)->input);
  }

#ifdef USERTEST
  kfree(cont);
#else  //0426 - change kernel to slab cache
#ifdef DEBUG_ALLOC
  zap_virt(cont);
  //memset(cont, 0x3e, sizeof(*cont));
#else
#ifndef USESLAB
  kfree(cont);  // 0502 maybe slab cache usage is buggy
#else
  kmem_cache_free(clientSideContinuation_cache, cont);
    6e62:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    6e66:	a1 00 00 00 00       	mov    0x0,%eax
    6e6b:	89 04 24             	mov    %eax,(%esp,1)
    6e6e:	e8 fc ff ff ff       	call   6e6f <requestSlowStart+0x2bf>
    6e73:	8b 4d c8             	mov    0xffffffc8(%ebp),%ecx
    6e76:	39 4d e0             	cmp    %ecx,0xffffffe0(%ebp)
    6e79:	75 85                	jne    6e00 <requestSlowStart+0x250>
			unlinkCont(prev);
			MARK_PC(prev);
			freeClientSide_Continuation(prev);
		}
	}

#ifdef JAM_SLOWSTART4
	if(trickles_ratelimit()) printk("requestslowstart: jam slowstart 4\n");
	return;
#endif

	/* Retransmit all UC requests: 
	   move sentRequests back to queuedRequests
	*/
	for(mreq = (struct Request*)tp->t.sentRequests.prev;
    6e7b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    6e7e:	8b 98 68 0a 00 00    	mov    0xa68(%eax),%ebx
    6e84:	05 68 0a 00 00       	add    $0xa68,%eax
    6e89:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
    6e8c:	39 c3                	cmp    %eax,%ebx
    6e8e:	0f 84 80 00 00 00    	je     6f14 <requestSlowStart+0x364>
    6e94:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    6e97:	8d b2 7c 0a 00 00    	lea    0xa7c(%edx),%esi
    6e9d:	8d 76 00             	lea    0x0(%esi),%esi
	    mreq != (struct Request*)&tp->t.sentRequests;
	    mreq = (struct Request*)prev) {
		prev = (struct Request*)mreq->prev;

		/* note: can't just splice the ends, since each list
		   node contains a pointer to the containing list */
		// Shift to front of queuedRequests, in order
		BUG_TRAP(!mreq->isNew);
    6ea0:	f6 43 48 01          	testb  $0x1,0x48(%ebx)
    6ea4:	8b 3b                	mov    (%ebx),%edi
    6ea6:	89 f8                	mov    %edi,%eax
    6ea8:	0f 85 f2 01 00 00    	jne    70a0 <requestSlowStart+0x4f0>
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    6eae:	8b 53 04             	mov    0x4(%ebx),%edx
    6eb1:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    6eb3:	8b 03                	mov    (%ebx),%eax
	elem->prev = elem->next = NULL;
    6eb5:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    6ebb:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
    6ebe:	8b 43 08             	mov    0x8(%ebx),%eax
    6ec1:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    6ec8:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    6ecb:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	REQUEST_FIELDS
};

static inline void resetRequest(struct Request *req) {
	req->numChildren = 0;
    6ed2:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
	req->childrenMask = 0;
    6ed9:	80 63 14 f0          	andb   $0xf0,0x14(%ebx)
	req->transport_seq = -1;
	req->seq = -1;
	req->isNew = 1;
    6edd:	80 4b 48 01          	orb    $0x1,0x48(%ebx)
    6ee1:	c7 43 38 ff ff ff ff 	movl   $0xffffffff,0x38(%ebx)
    6ee8:	c7 43 3c ff ff ff ff 	movl   $0xffffffff,0x3c(%ebx)
	if(elem->list) {
		BUG();
	}
#endif
	if(head->next == elem /* || elem->prev != NULL || elem->next != NULL */) {
    6eef:	8b 46 04             	mov    0x4(%esi),%eax
    6ef2:	39 d8                	cmp    %ebx,%eax
    6ef4:	0f 84 77 01 00 00    	je     7071 <requestSlowStart+0x4c1>
		BUG();
		show_stack(NULL);	
	}
	elem->next = head->next;
    6efa:	89 43 04             	mov    %eax,0x4(%ebx)
	head->next->prev = elem;
    6efd:	8b 46 04             	mov    0x4(%esi),%eax
    6f00:	89 18                	mov    %ebx,(%eax)

	elem->prev = (struct alloc_head*)head;
    6f02:	89 33                	mov    %esi,(%ebx)
	head->next = elem;
    6f04:	89 5e 04             	mov    %ebx,0x4(%esi)

	elem->list = head;
    6f07:	89 73 08             	mov    %esi,0x8(%ebx)
    6f0a:	89 fb                	mov    %edi,%ebx
	elem->prev = (struct alloc_head*)head;
	head->next = elem;

	elem->list = head;
	head->len++;
    6f0c:	ff 46 10             	incl   0x10(%esi)
    6f0f:	3b 7d c0             	cmp    0xffffffc0(%ebp),%edi
    6f12:	75 8c                	jne    6ea0 <requestSlowStart+0x2f0>
		unlink((struct alloc_head*)mreq);
		resetRequest(mreq);
		insert_head(&tp->t.queuedRequests, (struct alloc_head*)mreq);
	}
	/* clear data requests */
#ifdef JAM_SLOWSTART5
	if(trickles_ratelimit()) printk("requestslowstart: jam slowstart 5\n");
	return;
#endif
	{
		int i;
		struct alloc_head_list* dataRequestLists[] = {
    6f14:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
			&tp->t.dataRequestMap,
			&tp->t.missingDataMap};
		for(i=0; i < 2; i++) {
    6f17:	8d 4d ec             	lea    0xffffffec(%ebp),%ecx
    6f1a:	bf 01 00 00 00       	mov    $0x1,%edi
    6f1f:	89 4d bc             	mov    %ecx,0xffffffbc(%ebp)
    6f22:	05 90 0a 00 00       	add    $0xa90,%eax
    6f27:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    6f2a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    6f2d:	05 a4 0a 00 00       	add    $0xaa4,%eax
    6f32:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
			struct alloc_head_list *currList = dataRequestLists[i];
    6f35:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    6f38:	8b 30                	mov    (%eax),%esi
			for(dataReq = (struct DataRequestMapping *)currList->next; 
    6f3a:	8b 4e 04             	mov    0x4(%esi),%ecx
    6f3d:	39 f1                	cmp    %esi,%ecx
    6f3f:	74 4c                	je     6f8d <requestSlowStart+0x3dd>
    6f41:	eb 0d                	jmp    6f50 <requestSlowStart+0x3a0>
    6f43:	90                   	nop    
    6f44:	90                   	nop    
    6f45:	90                   	nop    
    6f46:	90                   	nop    
    6f47:	90                   	nop    
    6f48:	90                   	nop    
    6f49:	90                   	nop    
    6f4a:	90                   	nop    
    6f4b:	90                   	nop    
    6f4c:	90                   	nop    
    6f4d:	90                   	nop    
    6f4e:	90                   	nop    
    6f4f:	90                   	nop    
			    dataReq != (struct DataRequestMapping *)currList;
			    dataReq = nextDataReq) {
				nextDataReq = dataReq->next;
    6f50:	8b 59 04             	mov    0x4(%ecx),%ebx
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    6f53:	8b 01                	mov    (%ecx),%eax
    6f55:	89 03                	mov    %eax,(%ebx)
	elem->prev->next = elem->next;
    6f57:	8b 41 04             	mov    0x4(%ecx),%eax
    6f5a:	8b 11                	mov    (%ecx),%edx
	elem->prev = elem->next = NULL;
    6f5c:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
    6f62:	89 42 04             	mov    %eax,0x4(%edx)

	elem->list->len--;
    6f65:	8b 41 08             	mov    0x8(%ecx),%eax
    6f68:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
    6f6f:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    6f72:	c7 41 08 00 00 00 00 	movl   $0x0,0x8(%ecx)
}

static inline void freeDataRequestMapping(struct DataRequestMapping *dataReq) {
	numDataRequestMappings--;
	kfree(dataReq);
    6f79:	89 0c 24             	mov    %ecx,(%esp,1)
    6f7c:	ff 0d 00 00 00 00    	decl   0x0
    6f82:	e8 fc ff ff ff       	call   6f83 <requestSlowStart+0x3d3>
    6f87:	39 f3                	cmp    %esi,%ebx
    6f89:	89 d9                	mov    %ebx,%ecx
    6f8b:	75 c3                	jne    6f50 <requestSlowStart+0x3a0>
    6f8d:	83 45 bc 04          	addl   $0x4,0xffffffbc(%ebp)
    6f91:	4f                   	dec    %edi
    6f92:	79 a1                	jns    6f35 <requestSlowStart+0x385>
				unlink((struct alloc_head*)dataReq);
				freeDataRequestMapping(dataReq);
			}
		}

		tp->t.byteReqNext = tp->rcv_nxt;
    6f94:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    6f97:	8b 42 08             	mov    0x8(%edx),%eax
    6f9a:	89 82 b8 0a 00 00    	mov    %eax,0xab8(%edx)
		tp->t.byteReqHint = NULL;
    6fa0:	31 c0                	xor    %eax,%eax
    6fa2:	89 82 bc 0a 00 00    	mov    %eax,0xabc(%edx)
	}

	tp->t.ack_prev = msk;
    6fa8:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
    6fab:	89 8a f0 02 00 00    	mov    %ecx,0x2f0(%edx)
	INTEGRITY_CHECK(sk, tp->t.ack_prev);
#ifdef JAM_SLOWSTART6
	if(trickles_ratelimit()) printk("requestslowstart: jam slowstart 6\n");
	return;
#endif

	SAVE_ACK_PREV(tp);
	tp->t.ack_last = tp->t.ack_prev->seq + 1;
    6fb1:	8b 41 34             	mov    0x34(%ecx),%eax
    6fb4:	40                   	inc    %eax
	if(!(!tp->t.ack_prev || tp->t.ack_prev->next)) {
    6fb5:	85 c9                	test   %ecx,%ecx
    6fb7:	89 82 f4 02 00 00    	mov    %eax,0x2f4(%edx)
    6fbd:	74 07                	je     6fc6 <requestSlowStart+0x416>
    6fbf:	8b 41 04             	mov    0x4(%ecx),%eax
    6fc2:	85 c0                	test   %eax,%eax
    6fc4:	74 79                	je     703f <requestSlowStart+0x48f>
		// 0429
		BUG_TRAP(!tp->t.ack_prev || tp->t.ack_prev->next);
		BUG();
	}
	
	// free sendAckOverflow list
	while((skb = __skb_dequeue(&tp->t.sendAckOverflow))) {
    6fc6:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    6fc9:	8d 98 30 0b 00 00    	lea    0xb30(%eax),%ebx
    6fcf:	90                   	nop    
{
	struct sk_buff *next, *prev, *result;

	prev = (struct sk_buff *) list;
	next = prev->next;
    6fd0:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
	result = NULL;
    6fd3:	31 d2                	xor    %edx,%edx
    6fd5:	8b 81 30 0b 00 00    	mov    0xb30(%ecx),%eax
	if (next != prev) {
    6fdb:	39 d8                	cmp    %ebx,%eax
    6fdd:	74 24                	je     7003 <requestSlowStart+0x453>
		result = next;
    6fdf:	89 c2                	mov    %eax,%edx
		next = next->next;
    6fe1:	8b 00                	mov    (%eax),%eax
		list->qlen--;
    6fe3:	ff 4b 08             	decl   0x8(%ebx)
		next->prev = prev;
		prev->next = next;
		result->next = NULL;
		result->prev = NULL;
		result->list = NULL;
    6fe6:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
    6fed:	89 58 04             	mov    %ebx,0x4(%eax)
    6ff0:	89 81 30 0b 00 00    	mov    %eax,0xb30(%ecx)
    6ff6:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
    6ffd:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
    7003:	89 55 dc             	mov    %edx,0xffffffdc(%ebp)
    7006:	85 d2                	test   %edx,%edx
    7008:	74 0d                	je     7017 <requestSlowStart+0x467>
		__kfree_skb(skb);
    700a:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    700d:	89 14 24             	mov    %edx,(%esp,1)
    7010:	e8 fc ff ff ff       	call   7011 <requestSlowStart+0x461>
    7015:	eb b9                	jmp    6fd0 <requestSlowStart+0x420>
	}
#if 0
	// recorded in SendAckHelper()
	appendTricklesLossEvent(sk, MIN(tp->t.ack_prev->startCwnd, EVENT_CWND_MAX),
				-3, tp->t.state);
#endif
	sendAckHelper(sk,tp->t.ack_prev,TREQ_SLOWSTART);
    7017:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp,1)
    701e:	00 
    701f:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    7022:	8b 4d 08             	mov    0x8(%ebp),%ecx
    7025:	8b 82 f0 02 00 00    	mov    0x2f0(%edx),%eax
    702b:	89 0c 24             	mov    %ecx,(%esp,1)
    702e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    7032:	e8 89 e6 ff ff       	call   56c0 <sendAckHelper>
}
    7037:	83 c4 4c             	add    $0x4c,%esp
    703a:	5b                   	pop    %ebx
    703b:	5e                   	pop    %esi
    703c:	5f                   	pop    %edi
    703d:	5d                   	pop    %ebp
    703e:	c3                   	ret    
    703f:	c7 44 24 04 a4 0f 00 	movl   $0xfa4,0x4(%esp,1)
    7046:	00 
    7047:	c7 04 24 20 18 00 00 	movl   $0x1820,(%esp,1)
    704e:	e8 fc ff ff ff       	call   704f <requestSlowStart+0x49f>
    7053:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    705a:	00 
    705b:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    7062:	e8 fc ff ff ff       	call   7063 <requestSlowStart+0x4b3>
    7067:	e8 fc ff ff ff       	call   7068 <requestSlowStart+0x4b8>
    706c:	e9 55 ff ff ff       	jmp    6fc6 <requestSlowStart+0x416>
		BUG();
	}
#endif
	if(head->next == elem /* || elem->prev != NULL || elem->next != NULL */) {
		BUG();
    7071:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    7078:	00 
    7079:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    7080:	e8 fc ff ff ff       	call   7081 <requestSlowStart+0x4d1>
    7085:	e8 fc ff ff ff       	call   7086 <requestSlowStart+0x4d6>
		show_stack(NULL);	
    708a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    7091:	e8 fc ff ff ff       	call   7092 <requestSlowStart+0x4e2>
    7096:	8b 46 04             	mov    0x4(%esi),%eax
    7099:	e9 5c fe ff ff       	jmp    6efa <requestSlowStart+0x34a>
    709e:	89 f6                	mov    %esi,%esi
    70a0:	c7 44 24 04 7b 0f 00 	movl   $0xf7b,0x4(%esp,1)
    70a7:	00 
    70a8:	c7 04 24 80 23 00 00 	movl   $0x2380,(%esp,1)
    70af:	e8 fc ff ff ff       	call   70b0 <requestSlowStart+0x500>
    70b4:	8b 03                	mov    (%ebx),%eax
    70b6:	e9 f3 fd ff ff       	jmp    6eae <requestSlowStart+0x2fe>
    70bb:	90                   	nop    
    70bc:	8d 74 26 00          	lea    0x0(%esi,1),%esi
  for(i=0; i < 2; i++) {
    if((cont+i)->ucont_data)
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
      kfree((cont+i)->input);
    70c0:	89 04 24             	mov    %eax,(%esp,1)
    70c3:	e8 fc ff ff ff       	call   70c4 <requestSlowStart+0x514>
    70c8:	e9 8c fd ff ff       	jmp    6e59 <requestSlowStart+0x2a9>
    70cd:	8d 76 00             	lea    0x0(%esi),%esi
    70d0:	89 04 24             	mov    %eax,(%esp,1)
    70d3:	e8 fc ff ff ff       	call   70d4 <requestSlowStart+0x524>
    70d8:	e9 6d fd ff ff       	jmp    6e4a <requestSlowStart+0x29a>
    70dd:	8d 76 00             	lea    0x0(%esi),%esi
    70e0:	89 04 24             	mov    %eax,(%esp,1)
    70e3:	e8 fc ff ff ff       	call   70e4 <requestSlowStart+0x534>
    70e8:	e9 c3 fc ff ff       	jmp    6db0 <requestSlowStart+0x200>
    70ed:	8d 76 00             	lea    0x0(%esi),%esi
    70f0:	89 04 24             	mov    %eax,(%esp,1)
    70f3:	e8 fc ff ff ff       	call   70f4 <requestSlowStart+0x544>
    70f8:	e9 a4 fc ff ff       	jmp    6da1 <requestSlowStart+0x1f1>
    70fd:	8d 76 00             	lea    0x0(%esi),%esi
    7100:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    7107:	00 
    7108:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    710f:	e8 fc ff ff ff       	call   7110 <requestSlowStart+0x560>
    7114:	e8 fc ff ff ff       	call   7115 <requestSlowStart+0x565>
    7119:	e9 6b fc ff ff       	jmp    6d89 <requestSlowStart+0x1d9>
    711e:	89 f6                	mov    %esi,%esi
    7120:	c7 44 24 04 55 0f 00 	movl   $0xf55,0x4(%esp,1)
    7127:	00 
    7128:	c7 04 24 c0 23 00 00 	movl   $0x23c0,(%esp,1)
    712f:	e8 fc ff ff ff       	call   7130 <requestSlowStart+0x580>
    7134:	8b 73 5c             	mov    0x5c(%ebx),%esi
    7137:	e9 42 fc ff ff       	jmp    6d7e <requestSlowStart+0x1ce>
    713c:	c7 44 24 04 4c 0f 00 	movl   $0xf4c,0x4(%esp,1)
    7143:	00 
    7144:	c7 04 24 20 24 00 00 	movl   $0x2420,(%esp,1)
    714b:	e8 fc ff ff ff       	call   714c <requestSlowStart+0x59c>
    7150:	e9 b9 fb ff ff       	jmp    6d0e <requestSlowStart+0x15e>
    7155:	8b 35 00 00 00 00    	mov    0x0,%esi
    715b:	85 f6                	test   %esi,%esi
    715d:	0f 85 d4 fe ff ff    	jne    7037 <requestSlowStart+0x487>
    7163:	a1 00 00 00 00       	mov    0x0,%eax
    7168:	9c                   	pushf  
    7169:	59                   	pop    %ecx
    716a:	fa                   	cli    
    716b:	89 c2                	mov    %eax,%edx
    716d:	8b 1d 90 e2 04 00    	mov    0x4e290,%ebx
    7173:	8b 3d b8 00 00 00    	mov    0xb8,%edi
    7179:	a3 90 e2 04 00       	mov    %eax,0x4e290
    717e:	29 da                	sub    %ebx,%edx
    7180:	01 fa                	add    %edi,%edx
    7182:	89 15 b8 00 00 00    	mov    %edx,0xb8
    7188:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    718e:	76 10                	jbe    71a0 <requestSlowStart+0x5f0>
    7190:	be 88 13 00 00       	mov    $0x1388,%esi
    7195:	ba 88 13 00 00       	mov    $0x1388,%edx
    719a:	89 35 b8 00 00 00    	mov    %esi,0xb8
    71a0:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    71a6:	0f 86 81 00 00 00    	jbe    722d <requestSlowStart+0x67d>
    71ac:	31 db                	xor    %ebx,%ebx
    71ae:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    71b4:	a1 94 e2 04 00       	mov    0x4e294,%eax
    71b9:	89 15 b8 00 00 00    	mov    %edx,0xb8
    71bf:	89 1d 94 e2 04 00    	mov    %ebx,0x4e294
    71c5:	51                   	push   %ecx
    71c6:	9d                   	popf   
    71c7:	85 c0                	test   %eax,%eax
    71c9:	75 40                	jne    720b <requestSlowStart+0x65b>
    71cb:	b8 01 00 00 00       	mov    $0x1,%eax
    71d0:	85 c0                	test   %eax,%eax
    71d2:	0f 84 5f fe ff ff    	je     7037 <requestSlowStart+0x487>
    71d8:	8b 55 d0             	mov    0xffffffd0(%ebp),%edx
    71db:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
    71de:	89 54 24 10          	mov    %edx,0x10(%esp,1)
    71e2:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    71e5:	89 4c 24 0c          	mov    %ecx,0xc(%esp,1)
    71e9:	8b 4d 08             	mov    0x8(%ebp),%ecx
    71ec:	8b 82 30 0a 00 00    	mov    0xa30(%edx),%eax
    71f2:	c7 04 24 80 24 00 00 	movl   $0x2480,(%esp,1)
    71f9:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    71fd:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    7201:	e8 fc ff ff ff       	call   7202 <requestSlowStart+0x652>
    7206:	e9 2c fe ff ff       	jmp    7037 <requestSlowStart+0x487>
    720b:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    720f:	c7 44 24 08 46 0f 00 	movl   $0xf46,0x8(%esp,1)
    7216:	00 
    7217:	c7 44 24 04 6b 00 00 	movl   $0x6b,0x4(%esp,1)
    721e:	00 
    721f:	c7 04 24 c0 02 00 00 	movl   $0x2c0,(%esp,1)
    7226:	e8 fc ff ff ff       	call   7227 <requestSlowStart+0x677>
    722b:	eb 9e                	jmp    71cb <requestSlowStart+0x61b>
    722d:	ff 05 94 e2 04 00    	incl   0x4e294
    7233:	51                   	push   %ecx
    7234:	9d                   	popf   
    7235:	31 c0                	xor    %eax,%eax
    7237:	eb 97                	jmp    71d0 <requestSlowStart+0x620>
    7239:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    7240:	c7 04 24 00 25 00 00 	movl   $0x2500,(%esp,1)
    7247:	e8 fc ff ff ff       	call   7248 <requestSlowStart+0x698>
    724c:	e9 70 fa ff ff       	jmp    6cc1 <requestSlowStart+0x111>
    7251:	89 5d e4             	mov    %ebx,0xffffffe4(%ebp)
    7254:	e9 6f fa ff ff       	jmp    6cc8 <requestSlowStart+0x118>
    7259:	c7 04 24 97 03 00 00 	movl   $0x397,(%esp,1)
    7260:	e8 fc ff ff ff       	call   7261 <requestSlowStart+0x6b1>
    7265:	89 1c 24             	mov    %ebx,(%esp,1)
    7268:	e8 fc ff ff ff       	call   7269 <requestSlowStart+0x6b9>
    726d:	e9 ee f9 ff ff       	jmp    6c60 <requestSlowStart+0xb0>
    7272:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    7279:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00007280 <trickles_clear_timers>:


#ifndef USERTEST
/* 
 *
 * Destructors
 *
 *
 */
static void trickles_clear_timers(struct sock *sk) {
    7280:	55                   	push   %ebp
    7281:	89 e5                	mov    %esp,%ebp
    7283:	83 ec 08             	sub    $0x8,%esp
    7286:	89 5d fc             	mov    %ebx,0xfffffffc(%ebp)
    7289:	8b 5d 08             	mov    0x8(%ebp),%ebx
	timer->list.next = timer->list.prev = NULL;
}

static inline int timer_pending (const struct timer_list * timer)
{
    728c:	8b 93 f0 0a 00 00    	mov    0xaf0(%ebx),%edx
    7292:	8d 83 f0 0a 00 00    	lea    0xaf0(%ebx),%eax
    7298:	85 d2                	test   %edx,%edx
    729a:	75 07                	jne    72a3 <trickles_clear_timers+0x23>
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
	if(timer_pending(&tp->t.slowstart_timer)) {
		static int numCleared = 0;
		if(del_timer(&tp->t.slowstart_timer)) {
			__sock_put(sk);
		}
		numCleared++;
		//printk("%d timers cleared\n", numCleared);
	}
	return;
}
    729c:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
    729f:	89 ec                	mov    %ebp,%esp
    72a1:	5d                   	pop    %ebp
    72a2:	c3                   	ret    
    72a3:	89 04 24             	mov    %eax,(%esp,1)
    72a6:	e8 fc ff ff ff       	call   72a7 <trickles_clear_timers+0x27>
    72ab:	85 c0                	test   %eax,%eax
    72ad:	74 03                	je     72b2 <trickles_clear_timers+0x32>
 * useful range of an atomic_t is only 24 bits.
 */ 
static __inline__ void atomic_dec(atomic_t *v)
{
	__asm__ __volatile__(
    72af:	ff 4b 28             	decl   0x28(%ebx)
    72b2:	ff 05 bc 00 00 00    	incl   0xbc
    72b8:	eb e2                	jmp    729c <trickles_clear_timers+0x1c>
    72ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

000072c0 <trickles_destroy>:

#endif //USERTEST

static void trickles_destroy(struct sock *sk) {
    72c0:	55                   	push   %ebp
    72c1:	89 e5                	mov    %esp,%ebp
    72c3:	57                   	push   %edi
    72c4:	56                   	push   %esi
    72c5:	53                   	push   %ebx
    72c6:	83 ec 64             	sub    $0x64,%esp
	int i;
	struct sk_buff *skb;
	CONTINUATION_TYPE *cont;
	struct UC_Continuation *ucont;
	struct UC_DependencyNode *depNode;
	struct Request *req;
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
    72c9:	8b 45 08             	mov    0x8(%ebp),%eax
    72cc:	05 bc 00 00 00       	add    $0xbc,%eax
    72d1:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
	struct alloc_head_list *lists[] = {&tp->t.sentRequests, &tp->t.queuedRequests};
    72d4:	8b 45 08             	mov    0x8(%ebp),%eax
	struct alloc_head_list *dataRequestLists[] = {&tp->t.dataRequestMap, &tp->t.missingDataMap};

#ifndef USERTEST
	if(!(tp->trickles_opt & TCP_TRICKLES_ENABLE)) {
    72d7:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    72da:	05 24 0b 00 00       	add    $0xb24,%eax
    72df:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    72e2:	8b 45 08             	mov    0x8(%ebp),%eax
    72e5:	05 38 0b 00 00       	add    $0xb38,%eax
    72ea:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    72ed:	8b 45 08             	mov    0x8(%ebp),%eax
    72f0:	05 4c 0b 00 00       	add    $0xb4c,%eax
    72f5:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    72f8:	8b 45 08             	mov    0x8(%ebp),%eax
    72fb:	05 60 0b 00 00       	add    $0xb60,%eax
    7300:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    7303:	f6 82 ec 01 00 00 01 	testb  $0x1,0x1ec(%edx)
    730a:	0f 84 5b 05 00 00    	je     786b <trickles_destroy+0x5ab>
		return;
	}

	//KGDB_ASSERT("BREAK", 0);
	/* Schedule vfree() for later */
	if(TRICKLES_USERAPI_CONFIGURED_TP(tp)) {
    7310:	8b ba d0 01 00 00    	mov    0x1d0(%edx),%edi
    7316:	85 ff                	test   %edi,%edi
    7318:	0f 85 ff 06 00 00    	jne    7a1d <trickles_destroy+0x75d>
		schedule_work((struct work_struct *)(tp->cminisock_api_config.cfg.ctl + 1));
	}

	trickles_clear_timers(sk);
    731e:	8b 4d 08             	mov    0x8(%ebp),%ecx
    7321:	89 0c 24             	mov    %ecx,(%esp,1)
    7324:	e8 57 ff ff ff       	call   7280 <trickles_clear_timers>
#endif //USERTEST

	/* drain ofo queues */
	while((skb=__skb_dequeue(&tp->t.ofo_queue))!=NULL) {
    7329:	8b 45 08             	mov    0x8(%ebp),%eax
    732c:	05 a0 03 00 00       	add    $0x3a0,%eax
    7331:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
    7334:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    733a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
{
	struct sk_buff *next, *prev, *result;

	prev = (struct sk_buff *) list;
	next = prev->next;
    7340:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
    7343:	8b 81 e4 02 00 00    	mov    0x2e4(%ecx),%eax
	result = NULL;
    7349:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
	if (next != prev) {
    7350:	3b 45 bc             	cmp    0xffffffbc(%ebp),%eax
    7353:	74 2e                	je     7383 <trickles_destroy+0xc3>
		result = next;
    7355:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
		next = next->next;
		list->qlen--;
    7358:	8b 4d bc             	mov    0xffffffbc(%ebp),%ecx
    735b:	8b 00                	mov    (%eax),%eax
    735d:	ff 49 08             	decl   0x8(%ecx)
		next->prev = prev;
    7360:	89 48 04             	mov    %ecx,0x4(%eax)
		prev->next = next;
    7363:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    7366:	89 82 e4 02 00 00    	mov    %eax,0x2e4(%edx)
		result->next = NULL;
    736c:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
    736f:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
		result->prev = NULL;
    7375:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
		result->list = NULL;
    737c:	c7 41 08 00 00 00 00 	movl   $0x0,0x8(%ecx)
    7383:	8b 5d d4             	mov    0xffffffd4(%ebp),%ebx
    7386:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    7389:	05 50 0a 00 00       	add    $0xa50,%eax
    738e:	85 db                	test   %ebx,%ebx
    7390:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
    7393:	0f 84 a7 00 00 00    	je     7440 <trickles_destroy+0x180>
  }
  return rval;
}

static inline void freeClientSide_Continuation(CONTINUATION_TYPE *cont) {
    7399:	8b 5b 5c             	mov    0x5c(%ebx),%ebx
  int i;
#ifdef DEBUG_TRICKLES_ALLOCATION // 0418
  numContinuations--;
#endif
#ifdef DEBUG_ALLOC
#ifndef USERTEST
  if((int)cont & 0xfff) {
	  BUG();
  }
#endif // USERTEST
#endif // DEBUG_ALLOC

  if(cont->list) {
    739c:	8b 73 08             	mov    0x8(%ebx),%esi
    739f:	85 f6                	test   %esi,%esi
    73a1:	75 7d                	jne    7420 <trickles_destroy+0x160>
	  BUG();
  }

  for(i=0; i < 2; i++) {
    73a3:	31 f6                	xor    %esi,%esi
    73a5:	bf 01 00 00 00       	mov    $0x1,%edi
    if((cont+i)->ucont_data)
    73aa:	8b 84 33 80 00 00 00 	mov    0x80(%ebx,%esi,1),%eax
    73b1:	85 c0                	test   %eax,%eax
    73b3:	75 5b                	jne    7410 <trickles_destroy+0x150>
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
    73b5:	8b 84 33 88 00 00 00 	mov    0x88(%ebx,%esi,1),%eax
    73bc:	85 c0                	test   %eax,%eax
    73be:	75 40                	jne    7400 <trickles_destroy+0x140>
    73c0:	81 c6 e4 00 00 00    	add    $0xe4,%esi
    73c6:	4f                   	dec    %edi
    73c7:	79 e1                	jns    73aa <trickles_destroy+0xea>
      kfree((cont+i)->input);
  }

#ifdef USERTEST
  kfree(cont);
#else  //0426 - change kernel to slab cache
#ifdef DEBUG_ALLOC
  zap_virt(cont);
  //memset(cont, 0x3e, sizeof(*cont));
#else
#ifndef USESLAB
  kfree(cont);  // 0502 maybe slab cache usage is buggy
#else
  kmem_cache_free(clientSideContinuation_cache, cont);
    73c9:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    73cd:	a1 00 00 00 00       	mov    0x0,%eax
    73d2:	89 04 24             	mov    %eax,(%esp,1)
    73d5:	e8 fc ff ff ff       	call   73d6 <trickles_destroy+0x116>
 * Atomically subtracts @i from @v.  Note that the guaranteed
 * useful range of an atomic_t is only 24 bits.
 */
static __inline__ void atomic_sub(int i, atomic_t *v)
{
    73da:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
    73dd:	8b 82 9c 00 00 00    	mov    0x9c(%edx),%eax
    73e3:	8b 8a 90 00 00 00    	mov    0x90(%edx),%ecx
    73e9:	29 c8                	sub    %ecx,%eax
	__asm__ __volatile__(
    73eb:	29 05 00 00 00 00    	sub    %eax,0x0
		MARK_PC(TCP_SKB_CB(skb)->cont);
		freeClientSide_Continuation(TCP_SKB_CB(skb)->cont);
		delOfoSkb(skb);
		__kfree_skb(skb);
    73f1:	89 14 24             	mov    %edx,(%esp,1)
    73f4:	e8 fc ff ff ff       	call   73f5 <trickles_destroy+0x135>
    73f9:	e9 42 ff ff ff       	jmp    7340 <trickles_destroy+0x80>
    73fe:	89 f6                	mov    %esi,%esi
  for(i=0; i < 2; i++) {
    if((cont+i)->ucont_data)
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
      kfree((cont+i)->input);
    7400:	89 04 24             	mov    %eax,(%esp,1)
    7403:	e8 fc ff ff ff       	call   7404 <trickles_destroy+0x144>
    7408:	eb b6                	jmp    73c0 <trickles_destroy+0x100>
    740a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    7410:	89 04 24             	mov    %eax,(%esp,1)
    7413:	e8 fc ff ff ff       	call   7414 <trickles_destroy+0x154>
    7418:	eb 9b                	jmp    73b5 <trickles_destroy+0xf5>
    741a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    7420:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    7427:	00 
    7428:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    742f:	e8 fc ff ff ff       	call   7430 <trickles_destroy+0x170>
    7434:	e8 fc ff ff ff       	call   7435 <trickles_destroy+0x175>
    7439:	e9 65 ff ff ff       	jmp    73a3 <trickles_destroy+0xe3>
    743e:	89 f6                	mov    %esi,%esi
{
	struct sk_buff *next, *prev, *result;

	prev = (struct sk_buff *) list;
	next = prev->next;
    7440:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
    7443:	8b 81 50 0a 00 00    	mov    0xa50(%ecx),%eax
	result = NULL;
    7449:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
	if (next != prev) {
    7450:	3b 45 c0             	cmp    0xffffffc0(%ebp),%eax
    7453:	74 2e                	je     7483 <trickles_destroy+0x1c3>
		result = next;
    7455:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
		next = next->next;
		list->qlen--;
    7458:	8b 4d c0             	mov    0xffffffc0(%ebp),%ecx
    745b:	8b 00                	mov    (%eax),%eax
    745d:	ff 49 08             	decl   0x8(%ecx)
		next->prev = prev;
    7460:	89 48 04             	mov    %ecx,0x4(%eax)
		prev->next = next;
    7463:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    7466:	89 82 50 0a 00 00    	mov    %eax,0xa50(%edx)
		result->next = NULL;
    746c:	8b 4d d0             	mov    0xffffffd0(%ebp),%ecx
    746f:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
		result->prev = NULL;
    7475:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
		result->list = NULL;
    747c:	c7 41 08 00 00 00 00 	movl   $0x0,0x8(%ecx)
    7483:	8b 5d d0             	mov    0xffffffd0(%ebp),%ebx
    7486:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    7489:	85 db                	test   %ebx,%ebx
    748b:	8d b0 5c 0a 00 00    	lea    0xa5c(%eax),%esi
    7491:	0f 84 89 00 00 00    	je     7520 <trickles_destroy+0x260>
  }
  return rval;
}

static inline void freeClientSide_Continuation(CONTINUATION_TYPE *cont) {
    7497:	8b 5b 5c             	mov    0x5c(%ebx),%ebx
  int i;
#ifdef DEBUG_TRICKLES_ALLOCATION // 0418
  numContinuations--;
#endif
#ifdef DEBUG_ALLOC
#ifndef USERTEST
  if((int)cont & 0xfff) {
	  BUG();
  }
#endif // USERTEST
#endif // DEBUG_ALLOC

  if(cont->list) {
    749a:	8b 43 08             	mov    0x8(%ebx),%eax
    749d:	85 c0                	test   %eax,%eax
    749f:	75 5f                	jne    7500 <trickles_destroy+0x240>
	  BUG();
  }

  for(i=0; i < 2; i++) {
    74a1:	31 f6                	xor    %esi,%esi
    74a3:	bf 01 00 00 00       	mov    $0x1,%edi
    if((cont+i)->ucont_data)
    74a8:	8b 84 33 80 00 00 00 	mov    0x80(%ebx,%esi,1),%eax
    74af:	85 c0                	test   %eax,%eax
    74b1:	75 3f                	jne    74f2 <trickles_destroy+0x232>
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
    74b3:	8b 84 33 88 00 00 00 	mov    0x88(%ebx,%esi,1),%eax
    74ba:	85 c0                	test   %eax,%eax
    74bc:	75 2a                	jne    74e8 <trickles_destroy+0x228>
    74be:	81 c6 e4 00 00 00    	add    $0xe4,%esi
    74c4:	4f                   	dec    %edi
    74c5:	79 e1                	jns    74a8 <trickles_destroy+0x1e8>
      kfree((cont+i)->input);
  }

#ifdef USERTEST
  kfree(cont);
#else  //0426 - change kernel to slab cache
#ifdef DEBUG_ALLOC
  zap_virt(cont);
  //memset(cont, 0x3e, sizeof(*cont));
#else
#ifndef USESLAB
  kfree(cont);  // 0502 maybe slab cache usage is buggy
#else
  kmem_cache_free(clientSideContinuation_cache, cont);
    74c7:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    74cb:	a1 00 00 00 00       	mov    0x0,%eax
    74d0:	89 04 24             	mov    %eax,(%esp,1)
    74d3:	e8 fc ff ff ff       	call   74d4 <trickles_destroy+0x214>
	}
	while((skb=__skb_dequeue(&tp->t.request_ofo_queue))!=NULL) {
		MARK_PC(TCP_SKB_CB(skb)->cont);
		freeClientSide_Continuation(TCP_SKB_CB(skb)->cont);
		__kfree_skb(skb);
    74d8:	8b 55 d0             	mov    0xffffffd0(%ebp),%edx
    74db:	89 14 24             	mov    %edx,(%esp,1)
    74de:	e8 fc ff ff ff       	call   74df <trickles_destroy+0x21f>
    74e3:	e9 58 ff ff ff       	jmp    7440 <trickles_destroy+0x180>
  for(i=0; i < 2; i++) {
    if((cont+i)->ucont_data)
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
      kfree((cont+i)->input);
    74e8:	89 04 24             	mov    %eax,(%esp,1)
    74eb:	e8 fc ff ff ff       	call   74ec <trickles_destroy+0x22c>
    74f0:	eb cc                	jmp    74be <trickles_destroy+0x1fe>
    74f2:	89 04 24             	mov    %eax,(%esp,1)
    74f5:	e8 fc ff ff ff       	call   74f6 <trickles_destroy+0x236>
    74fa:	eb b7                	jmp    74b3 <trickles_destroy+0x1f3>
    74fc:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    7500:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    7507:	00 
    7508:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    750f:	e8 fc ff ff ff       	call   7510 <trickles_destroy+0x250>
    7514:	e8 fc ff ff ff       	call   7515 <trickles_destroy+0x255>
    7519:	eb 86                	jmp    74a1 <trickles_destroy+0x1e1>
    751b:	90                   	nop    
    751c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
{
	struct sk_buff *next, *prev, *result;

	prev = (struct sk_buff *) list;
	next = prev->next;
    7520:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    7523:	8b 82 5c 0a 00 00    	mov    0xa5c(%edx),%eax
	result = NULL;
    7529:	31 d2                	xor    %edx,%edx
	if (next != prev) {
    752b:	39 f0                	cmp    %esi,%eax
    752d:	74 27                	je     7556 <trickles_destroy+0x296>
		result = next;
    752f:	89 c2                	mov    %eax,%edx
		next = next->next;
    7531:	8b 00                	mov    (%eax),%eax
		list->qlen--;
    7533:	ff 4e 08             	decl   0x8(%esi)
		next->prev = prev;
    7536:	89 70 04             	mov    %esi,0x4(%eax)
		prev->next = next;
    7539:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
		result->next = NULL;
		result->prev = NULL;
    753c:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
		result->list = NULL;
    7543:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
    754a:	89 81 5c 0a 00 00    	mov    %eax,0xa5c(%ecx)
    7550:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
    7556:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    7559:	85 d2                	test   %edx,%edx
    755b:	89 d3                	mov    %edx,%ebx
    755d:	8d b8 24 0b 00 00    	lea    0xb24(%eax),%edi
    7563:	74 21                	je     7586 <trickles_destroy+0x2c6>
	}
	while((skb=__skb_dequeue(&tp->t.data_ofo_queue))!=NULL) {
		// data ofo queue continuations were already deallocated
		// 0418 check skb reference count
#ifndef USERTEST
		if(atomic_read(&skb_shinfo(skb)->dataref) != 1) {
    7565:	8b 83 9c 00 00 00    	mov    0x9c(%ebx),%eax
    756b:	8b 00                	mov    (%eax),%eax
    756d:	48                   	dec    %eax
    756e:	74 0c                	je     757c <trickles_destroy+0x2bc>
			printk("skb on data_ofo_queue had refcnt != 1\n");
    7570:	c7 04 24 40 25 00 00 	movl   $0x2540,(%esp,1)
    7577:	e8 fc ff ff ff       	call   7578 <trickles_destroy+0x2b8>
		}
#endif // USERTEST
		__kfree_skb(skb);
    757c:	89 1c 24             	mov    %ebx,(%esp,1)
    757f:	e8 fc ff ff ff       	call   7580 <trickles_destroy+0x2c0>
    7584:	eb 9a                	jmp    7520 <trickles_destroy+0x260>
{
	struct sk_buff *next, *prev, *result;

	prev = (struct sk_buff *) list;
	next = prev->next;
    7586:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    7589:	8b 82 24 0b 00 00    	mov    0xb24(%edx),%eax
	result = NULL;
    758f:	31 d2                	xor    %edx,%edx
	if (next != prev) {
    7591:	39 f8                	cmp    %edi,%eax
    7593:	74 27                	je     75bc <trickles_destroy+0x2fc>
		result = next;
    7595:	89 c2                	mov    %eax,%edx
		next = next->next;
    7597:	8b 00                	mov    (%eax),%eax
		list->qlen--;
    7599:	ff 4f 08             	decl   0x8(%edi)
		next->prev = prev;
    759c:	89 78 04             	mov    %edi,0x4(%eax)
		prev->next = next;
    759f:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
		result->next = NULL;
		result->prev = NULL;
    75a2:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
		result->list = NULL;
    75a9:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
    75b0:	89 81 24 0b 00 00    	mov    %eax,0xb24(%ecx)
    75b6:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
    75bc:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    75bf:	85 d2                	test   %edx,%edx
    75c1:	89 d3                	mov    %edx,%ebx
    75c3:	8d b0 30 0b 00 00    	lea    0xb30(%eax),%esi
    75c9:	74 0a                	je     75d5 <trickles_destroy+0x315>
	}

	// Drain overflow queues
	while((skb=__skb_dequeue(&tp->t.prequeueOverflow))) {
		__kfree_skb(skb);
    75cb:	89 1c 24             	mov    %ebx,(%esp,1)
    75ce:	e8 fc ff ff ff       	call   75cf <trickles_destroy+0x30f>
    75d3:	eb b1                	jmp    7586 <trickles_destroy+0x2c6>
{
	struct sk_buff *next, *prev, *result;

	prev = (struct sk_buff *) list;
	next = prev->next;
    75d5:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    75d8:	8b 82 30 0b 00 00    	mov    0xb30(%edx),%eax
	result = NULL;
    75de:	31 d2                	xor    %edx,%edx
	if (next != prev) {
    75e0:	39 f0                	cmp    %esi,%eax
    75e2:	74 27                	je     760b <trickles_destroy+0x34b>
		result = next;
    75e4:	89 c2                	mov    %eax,%edx
		next = next->next;
    75e6:	8b 00                	mov    (%eax),%eax
		list->qlen--;
    75e8:	ff 4e 08             	decl   0x8(%esi)
		next->prev = prev;
    75eb:	89 70 04             	mov    %esi,0x4(%eax)
		prev->next = next;
    75ee:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
		result->next = NULL;
		result->prev = NULL;
    75f1:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
		result->list = NULL;
    75f8:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
    75ff:	89 81 30 0b 00 00    	mov    %eax,0xb30(%ecx)
    7605:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
    760b:	85 d2                	test   %edx,%edx
    760d:	89 d3                	mov    %edx,%ebx
    760f:	74 0a                	je     761b <trickles_destroy+0x35b>
	}
	while((skb=__skb_dequeue(&tp->t.sendAckOverflow))) {
		__kfree_skb(skb);
    7611:	89 1c 24             	mov    %ebx,(%esp,1)
    7614:	e8 fc ff ff ff       	call   7615 <trickles_destroy+0x355>
    7619:	eb ba                	jmp    75d5 <trickles_destroy+0x315>
	}

	/* Clean protocol continuation list */
	cont = (CONTINUATION_TYPE *)tp->t.cont_list.next;
    761b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
#if 0 // 0426 used to debug continuation memory leaks 
	{
		static int cleanNum = 0;
		printk("conts cleaned: %d\n", cleanNum += tp->t.cont_list.len);
	}
#endif

	while(cont != (CONTINUATION_TYPE*)&tp->t.cont_list) {
    761e:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    7621:	8b 80 24 0a 00 00    	mov    0xa24(%eax),%eax
    7627:	81 c2 20 0a 00 00    	add    $0xa20,%edx
    762d:	89 55 c8             	mov    %edx,0xffffffc8(%ebp)
    7630:	39 d0                	cmp    %edx,%eax
    7632:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    7635:	74 7f                	je     76b6 <trickles_destroy+0x3f6>
    7637:	89 f6                	mov    %esi,%esi
    7639:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
		CONTINUATION_TYPE *prev = cont;
    7640:	8b 5d dc             	mov    0xffffffdc(%ebp),%ebx
  if(cont->list) {
	  BUG();
  }

  for(i=0; i < 2; i++) {
    7643:	31 f6                	xor    %esi,%esi
    7645:	bf 01 00 00 00       	mov    $0x1,%edi
		cont = cont->next;
    764a:	8b 4b 04             	mov    0x4(%ebx),%ecx
    764d:	89 4d dc             	mov    %ecx,0xffffffdc(%ebp)
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    7650:	8b 53 04             	mov    0x4(%ebx),%edx
    7653:	8b 03                	mov    (%ebx),%eax
    7655:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    7657:	8b 03                	mov    (%ebx),%eax
	elem->prev = elem->next = NULL;
    7659:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    765f:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
    7662:	8b 43 08             	mov    0x8(%ebx),%eax
    7665:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    766c:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    766f:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	  BUG();
  }

  for(i=0; i < 2; i++) {
    if((cont+i)->ucont_data)
    7676:	8b 84 33 80 00 00 00 	mov    0x80(%ebx,%esi,1),%eax
    767d:	85 c0                	test   %eax,%eax
    767f:	0f 85 8b 03 00 00    	jne    7a10 <trickles_destroy+0x750>
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
    7685:	8b 84 33 88 00 00 00 	mov    0x88(%ebx,%esi,1),%eax
    768c:	85 c0                	test   %eax,%eax
    768e:	0f 85 6c 03 00 00    	jne    7a00 <trickles_destroy+0x740>
    7694:	81 c6 e4 00 00 00    	add    $0xe4,%esi
    769a:	4f                   	dec    %edi
    769b:	79 d9                	jns    7676 <trickles_destroy+0x3b6>
      kfree((cont+i)->input);
  }

#ifdef USERTEST
  kfree(cont);
#else  //0426 - change kernel to slab cache
#ifdef DEBUG_ALLOC
  zap_virt(cont);
  //memset(cont, 0x3e, sizeof(*cont));
#else
#ifndef USESLAB
  kfree(cont);  // 0502 maybe slab cache usage is buggy
#else
  kmem_cache_free(clientSideContinuation_cache, cont);
    769d:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    76a1:	a1 00 00 00 00       	mov    0x0,%eax
    76a6:	89 04 24             	mov    %eax,(%esp,1)
    76a9:	e8 fc ff ff ff       	call   76aa <trickles_destroy+0x3ea>
    76ae:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    76b1:	39 45 dc             	cmp    %eax,0xffffffdc(%ebp)
    76b4:	75 8a                	jne    7640 <trickles_destroy+0x380>
		unlinkCont(prev);
		MARK_PC(prev);
		freeClientSide_Continuation(prev);
	}

	/* Clean sent and pending requests */
	for(i=0; i < sizeof(lists)/sizeof(lists[0]); i++) {
    76b6:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
    76bd:	8d 7d ec             	lea    0xffffffec(%ebp),%edi
		struct alloc_head_list *list = lists[i];
    76c0:	8b 37                	mov    (%edi),%esi
		for(req = (struct Request*)list->next; req != (struct Request*)list;) {
    76c2:	8b 5e 04             	mov    0x4(%esi),%ebx
    76c5:	39 f3                	cmp    %esi,%ebx
    76c7:	74 3b                	je     7704 <trickles_destroy+0x444>
    76c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
			struct Request *clean = req;
    76d0:	89 da                	mov    %ebx,%edx
			req = (struct Request*)req->next;
    76d2:	8b 5b 04             	mov    0x4(%ebx),%ebx
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    76d5:	8b 02                	mov    (%edx),%eax
    76d7:	89 03                	mov    %eax,(%ebx)
	elem->prev->next = elem->next;
    76d9:	8b 02                	mov    (%edx),%eax
	elem->prev = elem->next = NULL;
    76db:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
    76e1:	89 58 04             	mov    %ebx,0x4(%eax)

	elem->list->len--;
    76e4:	8b 42 08             	mov    0x8(%edx),%eax
    76e7:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
    76ee:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    76f1:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
			unlink((struct alloc_head*)clean);
			freeRequest(clean);
    76f8:	89 14 24             	mov    %edx,(%esp,1)
    76fb:	e8 fc ff ff ff       	call   76fc <trickles_destroy+0x43c>
    7700:	39 f3                	cmp    %esi,%ebx
    7702:	75 cc                	jne    76d0 <trickles_destroy+0x410>
    7704:	ff 45 e0             	incl   0xffffffe0(%ebp)
    7707:	83 c7 04             	add    $0x4,%edi
    770a:	83 7d e0 01          	cmpl   $0x1,0xffffffe0(%ebp)
    770e:	76 b0                	jbe    76c0 <trickles_destroy+0x400>
		}
	}

	for(i=0; i < sizeof(dataRequestLists)/sizeof(dataRequestLists[0]); i++) {
    7710:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
    7717:	8d 7d e4             	lea    0xffffffe4(%ebp),%edi
		struct DataRequestMapping *mapping;
		struct alloc_head_list *list = dataRequestLists[i];
    771a:	8b 37                	mov    (%edi),%esi
		for(mapping  = (struct DataRequestMapping*)list->next; 
    771c:	8b 5e 04             	mov    0x4(%esi),%ebx
    771f:	39 f3                	cmp    %esi,%ebx
    7721:	74 47                	je     776a <trickles_destroy+0x4aa>
    7723:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    7729:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
		    mapping != (struct DataRequestMapping*)list;) {
			struct DataRequestMapping *clean = mapping;
    7730:	89 da                	mov    %ebx,%edx
			mapping = mapping->next;
    7732:	8b 5b 04             	mov    0x4(%ebx),%ebx
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    7735:	8b 02                	mov    (%edx),%eax
    7737:	89 03                	mov    %eax,(%ebx)
	elem->prev->next = elem->next;
    7739:	8b 02                	mov    (%edx),%eax
	elem->prev = elem->next = NULL;
    773b:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
    7741:	89 58 04             	mov    %ebx,0x4(%eax)

	elem->list->len--;
    7744:	8b 42 08             	mov    0x8(%edx),%eax
    7747:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
    774e:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    7751:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
}

static inline void freeDataRequestMapping(struct DataRequestMapping *dataReq) {
	numDataRequestMappings--;
	kfree(dataReq);
    7758:	89 14 24             	mov    %edx,(%esp,1)
    775b:	ff 0d 00 00 00 00    	decl   0x0
    7761:	e8 fc ff ff ff       	call   7762 <trickles_destroy+0x4a2>
    7766:	39 f3                	cmp    %esi,%ebx
    7768:	75 c6                	jne    7730 <trickles_destroy+0x470>
    776a:	ff 45 e0             	incl   0xffffffe0(%ebp)
    776d:	83 c7 04             	add    $0x4,%edi
    7770:	83 7d e0 01          	cmpl   $0x1,0xffffffe0(%ebp)
    7774:	76 a4                	jbe    771a <trickles_destroy+0x45a>
			unlink((struct alloc_head*)clean);
			freeDataRequestMapping(clean);
		}
	}

	if(tp->t.newIncompleteRequest) {
    7776:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    7779:	8b 82 dc 0a 00 00    	mov    0xadc(%edx),%eax
    777f:	85 c0                	test   %eax,%eax
    7781:	0f 85 60 02 00 00    	jne    79e7 <trickles_destroy+0x727>
		freeRequest((struct Request*)tp->t.newIncompleteRequest);
		tp->t.newIncompleteRequest = NULL;
	}
	if(tp->t.prevConvCont) {
    7787:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    778a:	8b 82 e0 0a 00 00    	mov    0xae0(%edx),%eax
    7790:	85 c0                	test   %eax,%eax
    7792:	0f 85 37 02 00 00    	jne    79cf <trickles_destroy+0x70f>
		// don't bother with refcnt, since we're cleaning up
		kfree(tp->t.prevConvCont);
		tp->t.prevConvCont = NULL;
	}
	/* Clean user continuations and dependencies */
	for(ucont = (struct UC_Continuation*)tp->t.ucontList.next; 
    7798:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    779b:	8b 98 e8 0a 00 00    	mov    0xae8(%eax),%ebx
    77a1:	89 c6                	mov    %eax,%esi
    77a3:	81 c6 e4 0a 00 00    	add    $0xae4,%esi
    77a9:	39 f3                	cmp    %esi,%ebx
    77ab:	74 14                	je     77c1 <trickles_destroy+0x501>
    77ad:	8d 76 00             	lea    0x0(%esi),%esi
	    ucont != (struct UC_Continuation*)&tp->t.ucontList;) {
		struct UC_Continuation *clean = (struct UC_Continuation*) ucont;
    77b0:	89 d8                	mov    %ebx,%eax
		ucont = (struct UC_Continuation*)ucont->next;
    77b2:	8b 5b 04             	mov    0x4(%ebx),%ebx
		kfree(clean);
    77b5:	89 04 24             	mov    %eax,(%esp,1)
    77b8:	e8 fc ff ff ff       	call   77b9 <trickles_destroy+0x4f9>
    77bd:	39 f3                	cmp    %esi,%ebx
    77bf:	75 ef                	jne    77b0 <trickles_destroy+0x4f0>
	}
	for(depNode = (struct UC_DependencyNode*)tp->t.depNodeList.next; 
    77c1:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    77c4:	8b ba fc 0a 00 00    	mov    0xafc(%edx),%edi
    77ca:	81 c2 f8 0a 00 00    	add    $0xaf8,%edx
    77d0:	89 55 c4             	mov    %edx,0xffffffc4(%ebp)
    77d3:	39 d7                	cmp    %edx,%edi
    77d5:	74 31                	je     7808 <trickles_destroy+0x548>
    77d7:	89 f6                	mov    %esi,%esi
    77d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
	    depNode != (struct UC_DependencyNode*)&tp->t.depNodeList;) {
		struct UC_DependencyNode *clean = depNode;
    77e0:	89 fe                	mov    %edi,%esi
		depNode = (struct UC_DependencyNode*)depNode->next;
    77e2:	8b 7f 04             	mov    0x4(%edi),%edi
	}
	return;
}

static inline void vector_free(struct vector *vec) {
    77e5:	8d 5f 24             	lea    0x24(%edi),%ebx
	kfree(vec->elems);
    77e8:	8b 43 08             	mov    0x8(%ebx),%eax
    77eb:	89 04 24             	mov    %eax,(%esp,1)
    77ee:	e8 fc ff ff ff       	call   77ef <trickles_destroy+0x52f>
	kfree(vec);
    77f3:	89 1c 24             	mov    %ebx,(%esp,1)
    77f6:	e8 fc ff ff ff       	call   77f7 <trickles_destroy+0x537>
		vector_free(&depNode->depLinks);
		kfree(clean);
    77fb:	89 34 24             	mov    %esi,(%esp,1)
    77fe:	e8 fc ff ff ff       	call   77ff <trickles_destroy+0x53f>
    7803:	3b 7d c4             	cmp    0xffffffc4(%ebp),%edi
    7806:	75 d8                	jne    77e0 <trickles_destroy+0x520>
	}

#ifndef USERTEST
	/* deallocate minisockets */

	if((tp->trickles_opt & TCP_TRICKLES_ENABLE) &&
    7808:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
    780b:	8b 81 ec 01 00 00    	mov    0x1ec(%ecx),%eax
    7811:	83 e0 09             	and    $0x9,%eax
    7814:	83 f8 09             	cmp    $0x9,%eax
    7817:	0f 84 c5 00 00 00    	je     78e2 <trickles_destroy+0x622>
	   (tp->trickles_opt & TCP_TRICKLES_RSERVER) &&
	   TRICKLES_USERAPI_CONFIGURED_TP(tp)) {
		struct trickles_mmap_ctl *ctl = (struct trickles_mmap_ctl *)&tp->cminisock_api_config.cfg.ctl;
		struct cminisock *msk = (struct cminisock *)ctl->minisock_base;
		while((char*)msk <= (char*)ctl->ro_base + MINISOCK_LEN(ctl->ro_len)) {
			free_minisock(sk,msk);
			msk++;
		}
	}
#endif // USERTEST

#ifdef OPENSSL_HMAC
	// for OpenSSL HMAC
	if(tp->t.hmacCTX) {
    781d:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    7820:	8b 82 0c 0b 00 00    	mov    0xb0c(%edx),%eax
    7826:	85 c0                	test   %eax,%eax
    7828:	0f 85 9c 00 00 00    	jne    78ca <trickles_destroy+0x60a>
		kfree(tp->t.hmacCTX);
		tp->t.hmacCTX = NULL;
	}
#endif
	if(tp->t.nonceCTX) {
    782e:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    7831:	8b 82 20 0b 00 00    	mov    0xb20(%edx),%eax
    7837:	85 c0                	test   %eax,%eax
    7839:	75 77                	jne    78b2 <trickles_destroy+0x5f2>
		kfree(tp->t.nonceCTX);
		tp->t.nonceCTX = NULL;
	}
	if(0 && trickles_ratelimit() && (numRxPackets != 0 || numTxPackets != 0)) {
		printk("numRxPackets = %llu, numRxBytes = %llu, avgRxPacketSize = %d, numTxPackets = %llu, numTxBytes = %llu, avgTxPacketSize = %d\n", 
		       numRxPackets, numRxBytes, (__u32)(numRxPackets >> 4) ? (__u32)(numRxBytes >> 4) / (__u32)(numRxPackets >> 4) : 0,
		       numTxPackets, numTxBytes, (__u32)(numTxPackets >> 4) ? (__u32)(numTxBytes >> 4) / (__u32)(numTxPackets >> 4) : 0);
		numRxPackets = numRxBytes = numTxPackets = numTxBytes = 0;
	}

#ifndef USERTEST
	/* Unlink from global client socket list */
	if((tp->trickles_opt & TCP_TRICKLES_ENABLE) && !(tp->trickles_opt & TCP_TRICKLES_RSERVER)) {
    783b:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    783e:	8b 82 ec 01 00 00    	mov    0x1ec(%edx),%eax
    7844:	83 e0 09             	and    $0x9,%eax
    7847:	48                   	dec    %eax
    7848:	74 5b                	je     78a5 <trickles_destroy+0x5e5>
		trickles_del_clientsock(sk);
	} else {
		BUG_TRAP(tp->t.dnext == NULL);
    784a:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    784d:	8b b0 14 0a 00 00    	mov    0xa14(%eax),%esi
    7853:	85 f6                	test   %esi,%esi
    7855:	75 38                	jne    788f <trickles_destroy+0x5cf>
	}
#endif // USERTEST

#ifdef RECORD_LOSS_EVENTS
	if(tp->t.events != NULL) {
		struct TricklesProcLogEntry *newEntry = 
			kmalloc(sizeof(struct TricklesProcLogEntry), GFP_ATOMIC);
		newEntry->next = newEntry->prev = NULL;
		newEntry->list = NULL;
		newEntry->addr = sk->daddr;
		newEntry->port = sk->dport;
		newEntry->rcv_nxt = tp->rcv_nxt;
		newEntry->t_rcv_nxt = tp->t.rcv_nxt;

		newEntry->events = tp->t.events;
		newEntry->size = tp->t.eventsSize;
		newEntry->returnedEvents = 0;
		newEntry->sentAmount = 0;
		insert_tail(&tricklesProcLogHead, (struct alloc_head *)newEntry);
	}
#endif
	if(sk->prev) {
    7857:	8b 55 08             	mov    0x8(%ebp),%edx
    785a:	8b 5a 7c             	mov    0x7c(%edx),%ebx
    785d:	85 db                	test   %ebx,%ebx
    785f:	75 20                	jne    7881 <trickles_destroy+0x5c1>
		printk("Trickles prev != NULL\n");
	}
	if(sk->bind_next) {
    7861:	8b 4d 08             	mov    0x8(%ebp),%ecx
    7864:	8b 49 18             	mov    0x18(%ecx),%ecx
    7867:	85 c9                	test   %ecx,%ecx
    7869:	75 08                	jne    7873 <trickles_destroy+0x5b3>
		printk("Trickles bind_next != NULL\n");
	}
}
    786b:	83 c4 64             	add    $0x64,%esp
    786e:	5b                   	pop    %ebx
    786f:	5e                   	pop    %esi
    7870:	5f                   	pop    %edi
    7871:	5d                   	pop    %ebp
    7872:	c3                   	ret    
    7873:	c7 04 24 a9 03 00 00 	movl   $0x3a9,(%esp,1)
    787a:	e8 fc ff ff ff       	call   787b <trickles_destroy+0x5bb>
    787f:	eb ea                	jmp    786b <trickles_destroy+0x5ab>
    7881:	c7 04 24 c5 03 00 00 	movl   $0x3c5,(%esp,1)
    7888:	e8 fc ff ff ff       	call   7889 <trickles_destroy+0x5c9>
    788d:	eb d2                	jmp    7861 <trickles_destroy+0x5a1>
    788f:	c7 44 24 04 69 10 00 	movl   $0x1069,0x4(%esp,1)
    7896:	00 
    7897:	c7 04 24 80 25 00 00 	movl   $0x2580,(%esp,1)
    789e:	e8 fc ff ff ff       	call   789f <trickles_destroy+0x5df>
    78a3:	eb b2                	jmp    7857 <trickles_destroy+0x597>
    78a5:	8b 4d 08             	mov    0x8(%ebp),%ecx
    78a8:	89 0c 24             	mov    %ecx,(%esp,1)
    78ab:	e8 fc ff ff ff       	call   78ac <trickles_destroy+0x5ec>
    78b0:	eb a5                	jmp    7857 <trickles_destroy+0x597>
    78b2:	89 04 24             	mov    %eax,(%esp,1)
    78b5:	31 ff                	xor    %edi,%edi
    78b7:	e8 fc ff ff ff       	call   78b8 <trickles_destroy+0x5f8>
    78bc:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
    78bf:	89 b9 20 0b 00 00    	mov    %edi,0xb20(%ecx)
    78c5:	e9 71 ff ff ff       	jmp    783b <trickles_destroy+0x57b>
    78ca:	89 04 24             	mov    %eax,(%esp,1)
    78cd:	e8 fc ff ff ff       	call   78ce <trickles_destroy+0x60e>
    78d2:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
    78d5:	31 c0                	xor    %eax,%eax
    78d7:	89 81 0c 0b 00 00    	mov    %eax,0xb0c(%ecx)
    78dd:	e9 4c ff ff ff       	jmp    782e <trickles_destroy+0x56e>
    78e2:	8b b1 d0 01 00 00    	mov    0x1d0(%ecx),%esi
    78e8:	85 f6                	test   %esi,%esi
    78ea:	0f 84 2d ff ff ff    	je     781d <trickles_destroy+0x55d>
    78f0:	81 c1 cc 01 00 00    	add    $0x1cc,%ecx
    78f6:	89 4d cc             	mov    %ecx,0xffffffcc(%ebp)
    78f9:	8b 41 20             	mov    0x20(%ecx),%eax
    78fc:	8b 59 14             	mov    0x14(%ecx),%ebx
    78ff:	8b 79 0c             	mov    0xc(%ecx),%edi
    7902:	d1 e8                	shr    %eax
    7904:	01 d8                	add    %ebx,%eax
    7906:	39 c7                	cmp    %eax,%edi
    7908:	0f 87 0f ff ff ff    	ja     781d <trickles_destroy+0x55d>

#ifdef CAN_USE_TFREE
static inline void free_minisock(struct sock *sk, struct cminisock *msk) {
	int i;
	for(i=0; i < msk->num_packets; i++) {
    790e:	8b 97 dc 00 00 00    	mov    0xdc(%edi),%edx
    7914:	31 f6                	xor    %esi,%esi
    7916:	39 d6                	cmp    %edx,%esi
    7918:	7d 20                	jge    793a <trickles_destroy+0x67a>
    791a:	31 db                	xor    %ebx,%ebx
    791c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
		if(msk->packets[i].ucontData != NULL) {
    7920:	8b 87 e0 00 00 00    	mov    0xe0(%edi),%eax
    7926:	8b 44 18 18          	mov    0x18(%eax,%ebx,1),%eax
    792a:	85 c0                	test   %eax,%eax
    792c:	0f 85 8a 00 00 00    	jne    79bc <trickles_destroy+0x6fc>
    7932:	46                   	inc    %esi
    7933:	83 c3 28             	add    $0x28,%ebx
    7936:	39 d6                	cmp    %edx,%esi
    7938:	7c e6                	jl     7920 <trickles_destroy+0x660>
			kfree(msk->packets[i].ucontData);
		}
	}
	if(!SIMULATION_MODE(sk) && msk->packets) {
    793a:	8b 55 08             	mov    0x8(%ebp),%edx
    793d:	8b 82 a8 02 00 00    	mov    0x2a8(%edx),%eax
    7943:	a9 01 00 00 00       	test   $0x1,%eax
    7948:	74 05                	je     794f <trickles_destroy+0x68f>
    794a:	83 e0 08             	and    $0x8,%eax
    794d:	74 0a                	je     7959 <trickles_destroy+0x699>
    794f:	8b 87 e0 00 00 00    	mov    0xe0(%edi),%eax
    7955:	85 c0                	test   %eax,%eax
    7957:	75 52                	jne    79ab <trickles_destroy+0x6eb>
		tfree(sk,msk->packets);
	}

	if(msk->ucont_data != NULL)
    7959:	8b 87 80 00 00 00    	mov    0x80(%edi),%eax
    795f:	85 c0                	test   %eax,%eax
    7961:	75 37                	jne    799a <trickles_destroy+0x6da>
		tfree(sk,msk->ucont_data);
	if(msk->input != NULL)
    7963:	8b 87 88 00 00 00    	mov    0x88(%edi),%eax
    7969:	85 c0                	test   %eax,%eax
    796b:	75 1c                	jne    7989 <trickles_destroy+0x6c9>
    796d:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
    7970:	81 c7 e4 00 00 00    	add    $0xe4,%edi
    7976:	8b 41 20             	mov    0x20(%ecx),%eax
    7979:	8b 51 14             	mov    0x14(%ecx),%edx
    797c:	d1 e8                	shr    %eax
    797e:	01 d0                	add    %edx,%eax
    7980:	39 c7                	cmp    %eax,%edi
    7982:	76 8a                	jbe    790e <trickles_destroy+0x64e>
    7984:	e9 94 fe ff ff       	jmp    781d <trickles_destroy+0x55d>

	if(msk->ucont_data != NULL)
		tfree(sk,msk->ucont_data);
	if(msk->input != NULL)
		tfree(sk,msk->input);
    7989:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    798d:	8b 55 08             	mov    0x8(%ebp),%edx
    7990:	89 14 24             	mov    %edx,(%esp,1)
    7993:	e8 fc ff ff ff       	call   7994 <trickles_destroy+0x6d4>
    7998:	eb d3                	jmp    796d <trickles_destroy+0x6ad>
    799a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    799e:	8b 45 08             	mov    0x8(%ebp),%eax
    79a1:	89 04 24             	mov    %eax,(%esp,1)
    79a4:	e8 fc ff ff ff       	call   79a5 <trickles_destroy+0x6e5>
    79a9:	eb b8                	jmp    7963 <trickles_destroy+0x6a3>
    79ab:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    79af:	8b 4d 08             	mov    0x8(%ebp),%ecx
    79b2:	89 0c 24             	mov    %ecx,(%esp,1)
    79b5:	e8 fc ff ff ff       	call   79b6 <trickles_destroy+0x6f6>
    79ba:	eb 9d                	jmp    7959 <trickles_destroy+0x699>
    79bc:	89 04 24             	mov    %eax,(%esp,1)
    79bf:	e8 fc ff ff ff       	call   79c0 <trickles_destroy+0x700>
    79c4:	8b 97 dc 00 00 00    	mov    0xdc(%edi),%edx
    79ca:	e9 63 ff ff ff       	jmp    7932 <trickles_destroy+0x672>
    79cf:	89 04 24             	mov    %eax,(%esp,1)
    79d2:	31 ff                	xor    %edi,%edi
    79d4:	e8 fc ff ff ff       	call   79d5 <trickles_destroy+0x715>
    79d9:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
    79dc:	89 b9 e0 0a 00 00    	mov    %edi,0xae0(%ecx)
    79e2:	e9 b1 fd ff ff       	jmp    7798 <trickles_destroy+0x4d8>
    79e7:	89 04 24             	mov    %eax,(%esp,1)
    79ea:	e8 fc ff ff ff       	call   79eb <trickles_destroy+0x72b>
    79ef:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
    79f2:	31 c0                	xor    %eax,%eax
    79f4:	89 81 dc 0a 00 00    	mov    %eax,0xadc(%ecx)
    79fa:	e9 88 fd ff ff       	jmp    7787 <trickles_destroy+0x4c7>
    79ff:	90                   	nop    
  for(i=0; i < 2; i++) {
    if((cont+i)->ucont_data)
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
      kfree((cont+i)->input);
    7a00:	89 04 24             	mov    %eax,(%esp,1)
    7a03:	e8 fc ff ff ff       	call   7a04 <trickles_destroy+0x744>
    7a08:	e9 87 fc ff ff       	jmp    7694 <trickles_destroy+0x3d4>
    7a0d:	8d 76 00             	lea    0x0(%esi),%esi
    7a10:	89 04 24             	mov    %eax,(%esp,1)
    7a13:	e8 fc ff ff ff       	call   7a14 <trickles_destroy+0x754>
    7a18:	e9 68 fc ff ff       	jmp    7685 <trickles_destroy+0x3c5>
    7a1d:	8b 82 cc 01 00 00    	mov    0x1cc(%edx),%eax
    7a23:	83 c0 3c             	add    $0x3c,%eax
    7a26:	89 04 24             	mov    %eax,(%esp,1)
    7a29:	e8 fc ff ff ff       	call   7a2a <trickles_destroy+0x76a>
    7a2e:	e9 eb f8 ff ff       	jmp    731e <trickles_destroy+0x5e>
    7a33:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    7a39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00007a40 <init_module>:

#ifndef USERTEST

kmem_cache_t *clientSideContinuation_cache;

static inline void clientSideContinuation_init(void *p, kmem_cache_t *cache, 
					       unsigned long flags) {
	return;
}

static char *contCacheName;

int trickles_init(void) {
    7a40:	55                   	push   %ebp
	BUG_TRAP(HMAC_PHEADER_LEN == sizeof(PseudoHeader));

	trickles_prot = tcp_prot;
    7a41:	fc                   	cld    
    7a42:	89 e5                	mov    %esp,%ebp
    7a44:	57                   	push   %edi
	trickles_prot.sendmsg = trickles_sendmsg;
    7a45:	b8 00 00 00 00       	mov    $0x0,%eax
    7a4a:	56                   	push   %esi
    7a4b:	83 ec 18             	sub    $0x18,%esp
    7a4e:	bf 00 00 00 00       	mov    $0x0,%edi
    7a53:	be 00 00 00 00       	mov    $0x0,%esi
    7a58:	b9 21 00 00 00       	mov    $0x21,%ecx
	trickles_prot.close = trickles_close;
	trickles_client_prot = trickles_prot;

	trickles_client_prot.sendmsg = trickles_client_sendmsg;
	trickles_client_prot.recvmsg = trickles_client_recvmsg;

	trickles_rcv_hook = trickles_rcv_impl;
	trickles_destroy_hook = trickles_destroy;
    7a5d:	ba c0 72 00 00       	mov    $0x72c0,%edx
    7a62:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    7a64:	a3 28 00 00 00       	mov    %eax,0x28
    7a69:	b8 00 00 00 00       	mov    $0x0,%eax
    7a6e:	be 00 00 00 00       	mov    $0x0,%esi
    7a73:	a3 00 00 00 00       	mov    %eax,0x0

	cminisock_config_pipe_hook = cminisock_config_pipe_impl;
    7a78:	b8 00 00 00 00       	mov    $0x0,%eax
    7a7d:	bf 00 00 00 00       	mov    $0x0,%edi
    7a82:	a3 00 00 00 00       	mov    %eax,0x0
	trickles_sendv_hook = trickles_sendv_impl;
    7a87:	b8 00 00 00 00       	mov    $0x0,%eax
    7a8c:	b9 21 00 00 00       	mov    $0x21,%ecx
    7a91:	a3 00 00 00 00       	mov    %eax,0x0
	trickles_send_hook = trickles_send_impl;
    7a96:	b8 00 00 00 00       	mov    $0x0,%eax
    7a9b:	a3 00 00 00 00       	mov    %eax,0x0
	trickles_sendfilev_hook = trickles_sendfilev_impl;
    7aa0:	b8 00 00 00 00       	mov    $0x0,%eax
    7aa5:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    7aa7:	a3 00 00 00 00       	mov    %eax,0x0
	trickles_mmap_hook = trickles_mmap_impl;
    7aac:	b8 00 00 00 00       	mov    $0x0,%eax
    7ab1:	bf 00 00 00 00       	mov    $0x0,%edi
    7ab6:	a3 00 00 00 00       	mov    %eax,0x0
	trickles_setucont_hook = trickles_setucont_impl;
    7abb:	b8 00 00 00 00       	mov    $0x0,%eax
    7ac0:	be 00 00 00 00       	mov    $0x0,%esi
    7ac5:	a3 00 00 00 00       	mov    %eax,0x0
    7aca:	b9 b0 0c 00 00       	mov    $0xcb0,%ecx

	trickles_sock_poll_hook = trickles_sock_poll_impl;
	trickles_init_sock_hook = trickles_init_sock_impl;

	trickles_send_ack_hook = user_ack_impl;

	trickles_sockets_head.tp_pinfo.af_tcp.t.dnext = &trickles_sockets_head;
	trickles_sockets_head.tp_pinfo.af_tcp.t.dprev = &trickles_sockets_head;
    7acf:	b8 00 00 00 00       	mov    $0x0,%eax
    7ad4:	89 3d 28 00 00 00    	mov    %edi,0x28
    7ada:	bf 00 00 00 00       	mov    $0x0,%edi
    7adf:	89 35 2c 00 00 00    	mov    %esi,0x2c
    7ae5:	be 00 00 00 00       	mov    $0x0,%esi
    7aea:	89 0d 00 00 00 00    	mov    %ecx,0x0
    7af0:	b9 00 00 00 00       	mov    $0x0,%ecx
    7af5:	89 15 00 00 00 00    	mov    %edx,0x0
    7afb:	ba 00 00 00 00       	mov    $0x0,%edx
    7b00:	a3 cc 0a 00 00       	mov    %eax,0xacc

	trickles_getsockopt_hook = trickles_getsockopt_impl;
    7b05:	b8 00 00 00 00       	mov    $0x0,%eax
    7b0a:	89 0d 00 00 00 00    	mov    %ecx,0x0
    7b10:	89 15 d0 0a 00 00    	mov    %edx,0xad0
    7b16:	89 3d 00 00 00 00    	mov    %edi,0x0
    7b1c:	89 35 00 00 00 00    	mov    %esi,0x0
    7b22:	a3 00 00 00 00       	mov    %eax,0x0

	printk("Warning: Low level Trickles client interface not implemented\n");
    7b27:	c7 04 24 e0 25 00 00 	movl   $0x25e0,(%esp,1)
    7b2e:	e8 fc ff ff ff       	call   7b2f <init_module+0xef>
	trickles_sendmsg_hook = NULL;
    7b33:	31 c0                	xor    %eax,%eax
    7b35:	a3 00 00 00 00       	mov    %eax,0x0

	trickles_sendbulk_hook = trickles_sendbulk_impl;
    7b3a:	b8 00 00 00 00       	mov    $0x0,%eax
    7b3f:	a3 00 00 00 00       	mov    %eax,0x0

	/* initialize crappy RNG */
	rand = jiffies;
    7b44:	a1 00 00 00 00       	mov    0x0,%eax

	//trickles_client_connected_hook = trickles_client_connected_impl;

#ifdef USE_FLOATINGPOINT
	{
		int i;
		kernel_fpu_begin();
		barrier();
		init_fpu();
		barrier();
		for(i=0; i < NR_CPUS; i++) {
#ifdef FAST_CONTEXT
			asm __volatile__ ("fninit\n fnstcw %0": "=m"(fpu_kernel_save[i][0]));
			*((short*)fpu_kernel_save[i]) |= 0x1f; // mask all exceptions
#else
			asm __volatile__ ("fninit\n");
			barrier();
			FPU_SAVE(fpu_kernel_save[i]);
			barrier();
#endif
		}
		barrier();
		kernel_fpu_end();
	}
#else
		/*
		  for(i=0; i < 1000; i++) {
		  printk("mborg_isqrt(%d) = %d\n", i, mborg_isqrt4(i));
		  }
		*/
#endif // USE_FLOATINGPOINT

	printk("trickles loaded (hmac = %d nonce = %d): %s %s\n", generateHMAC, generateNonces, UTS_VERSION, LINUX_COMPILE_HOST);
    7b49:	c7 44 24 10 dc 03 00 	movl   $0x3dc,0x10(%esp,1)
    7b50:	00 
    7b51:	c7 44 24 0c 20 26 00 	movl   $0x2620,0xc(%esp,1)
    7b58:	00 
    7b59:	a3 0c f0 04 00       	mov    %eax,0x4f00c
    7b5e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp,1)
    7b65:	00 
    7b66:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
    7b6d:	00 
    7b6e:	c7 04 24 60 26 00 00 	movl   $0x2660,(%esp,1)
    7b75:	e8 fc ff ff ff       	call   7b76 <init_module+0x136>


#ifdef DEBUG_LIST
	printk("***** Warning: DebugList\n");
#endif

#ifdef CONFIG_DEBUG_SLAB
	printk("***** Warning: Compiled with SLAB debug on, will be absolutely extremely slow. You won't believe how slow this is.\n");
#endif

#ifdef FIXEDRTT
	printk("***** Warning :FIXEDRTT\n");
#endif

	if(disableSevereErrors) {
    7b7a:	a1 00 00 00 00       	mov    0x0,%eax
    7b7f:	85 c0                	test   %eax,%eax
    7b81:	0f 85 3a 02 00 00    	jne    7dc1 <init_module+0x381>
		printk("***** Warning: Printk of severe errors & warnings suppressed\n");
	}

#ifdef DEBUG_TRICKLES_ALLOCATION
	printk("***** Warning: debugging trickles allocation\n");
#endif

	if(!enableDataRecovery) {
    7b87:	a1 00 00 00 00       	mov    0x0,%eax
    7b8c:	85 c0                	test   %eax,%eax
    7b8e:	0f 84 1c 02 00 00    	je     7db0 <init_module+0x370>
		printk("**** Warning: enableDataRecovery == 0\n");
	}
	contCacheName = kmalloc(128, GFP_ATOMIC);
    7b94:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    7b9b:	00 
	// We leak about 30 objects from this slab every run. For now, change the name of the run on each bootup to avoid BUG() assertion on kmem_cache_create
	sprintf(contCacheName, "cont#%lu", jiffies);

	//0501 hack to find memory leak
	if(2 * sizeof(CONTINUATION_TYPE) > 4096) {
		BUG();
	}
#ifdef DEBUG_ALLOC
	printk("Warning: 4K allocation for clientsidecontinuation_cache: compiling in 386 mode to disable PSE, PGE. pse = %d, pge = %d; ack_prev integrity check\n", cpu_has_pse, cpu_has_pge);
	clientSideContinuation_cache = 
		kmem_cache_create(contCacheName,
				  4096,
				  0,
				  SLAB_PAGE_ALIGN | SLAB_DEBUG_INITIAL | SLAB_POISON | SLAB_RED_ZONE,
				  clientSideContinuation_init, NULL);
#else
	clientSideContinuation_cache = 
		kmem_cache_create(contCacheName,
				  2 * sizeof(CONTINUATION_TYPE),
				  0,
				  SLAB_HWCACHE_ALIGN /* | SLAB_DEBUG_INITIAL | SLAB_POISON | SLAB_RED_ZONE */,
				  clientSideContinuation_init, NULL);
#endif
#ifndef INIT2
	printk("Warning: not initializing both elements in continuation arrays\n");
#endif
#ifdef SAVE_APHIST
	printk("Warning: APHist array being allocated and wasting space\n");
#endif

	printk("Warning: Stuck client state detection (slow start left/right violation) disabled\n");
	printk("Warning: Disabled server-side recovery mode's out of memory errors\n");

#ifdef DISABLE_DATAREQUEST
	printk("Warning: Disabling DataRequest\n");
#endif
#ifdef RECORD_LOSS_EVENTS
	printk("Warning: Recording loss events\n");
#endif

#ifdef SLOWSTART_ONLY
	printk("Warning: Slow start only; no fast recovery\n");
#endif

#ifdef RANDOMIZE_SLOWSTART_TIMER
	printk("Randomizing slow start timer\n");
#endif

#ifdef STOMP_CONNECTIONS
	printk("Stomping connections every %d\n", STOMP_CONNECTIONS);
#endif

	sysctl_dbg_cwnd = 0;
    7b9c:	31 ff                	xor    %edi,%edi
	return head->next == (struct alloc_head*)head;
}

static inline void init_head(struct alloc_head_list *head) {
	head->next = head->prev = (struct alloc_head*)head;
    7b9e:	be 00 00 00 00       	mov    $0x0,%esi
    7ba3:	c7 04 24 80 00 00 00 	movl   $0x80,(%esp,1)
    7baa:	e8 fc ff ff ff       	call   7bab <init_module+0x16b>
    7baf:	8b 15 00 00 00 00    	mov    0x0,%edx
    7bb5:	a3 10 f0 04 00       	mov    %eax,0x4f010
    7bba:	c7 44 24 04 f3 03 00 	movl   $0x3f3,0x4(%esp,1)
    7bc1:	00 
    7bc2:	89 54 24 08          	mov    %edx,0x8(%esp,1)
    7bc6:	89 04 24             	mov    %eax,(%esp,1)
    7bc9:	e8 fc ff ff ff       	call   7bca <init_module+0x18a>
    7bce:	a1 10 f0 04 00       	mov    0x4f010,%eax
    7bd3:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp,1)
    7bda:	00 
    7bdb:	c7 44 24 10 c0 96 00 	movl   $0x96c0,0x10(%esp,1)
    7be2:	00 
    7be3:	c7 44 24 0c 00 20 00 	movl   $0x2000,0xc(%esp,1)
    7bea:	00 
    7beb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    7bf2:	00 
    7bf3:	c7 44 24 04 c8 01 00 	movl   $0x1c8,0x4(%esp,1)
    7bfa:	00 
    7bfb:	89 04 24             	mov    %eax,(%esp,1)
    7bfe:	e8 fc ff ff ff       	call   7bff <init_module+0x1bf>
    7c03:	a3 00 00 00 00       	mov    %eax,0x0
    7c08:	c7 04 24 a0 26 00 00 	movl   $0x26a0,(%esp,1)
    7c0f:	e8 fc ff ff ff       	call   7c10 <init_module+0x1d0>
    7c14:	c7 04 24 00 27 00 00 	movl   $0x2700,(%esp,1)
    7c1b:	e8 fc ff ff ff       	call   7c1c <init_module+0x1dc>
    7c20:	c7 04 24 fc 03 00 00 	movl   $0x3fc,(%esp,1)
    7c27:	e8 fc ff ff ff       	call   7c28 <init_module+0x1e8>

static inline void init_head(struct alloc_head_list *head) {
	head->next = head->prev = (struct alloc_head*)head;
	head->list = head;
	head->len = 0;
    7c2c:	31 c0                	xor    %eax,%eax
    7c2e:	b9 00 00 00 00       	mov    $0x0,%ecx
    7c33:	ba 00 00 00 00       	mov    $0x0,%edx
    7c38:	89 3d 00 00 00 00    	mov    %edi,0x0
	return head->next == (struct alloc_head*)head;
}

static inline void init_head(struct alloc_head_list *head) {
	head->next = head->prev = (struct alloc_head*)head;
    7c3e:	89 35 00 00 00 00    	mov    %esi,0x0
    7c44:	89 0d 04 00 00 00    	mov    %ecx,0x4
	head->list = head;
    7c4a:	89 15 08 00 00 00    	mov    %edx,0x8
	head->len = 0;
    7c50:	a3 10 00 00 00       	mov    %eax,0x10
static inline struct proc_dir_entry *create_proc_read_entry(const char *name,
	mode_t mode, struct proc_dir_entry *base, 
	read_proc_t *read_proc, void * data)
{
	struct proc_dir_entry *res=create_proc_entry(name,mode,base);
    7c55:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    7c5c:	00 
    7c5d:	c7 44 24 04 a4 01 00 	movl   $0x1a4,0x4(%esp,1)
    7c64:	00 
    7c65:	c7 04 24 1a 04 00 00 	movl   $0x41a,(%esp,1)
    7c6c:	e8 fc ff ff ff       	call   7c6d <init_module+0x22d>
	if (res) {
    7c71:	85 c0                	test   %eax,%eax
    7c73:	74 0e                	je     7c83 <init_module+0x243>
		res->read_proc=read_proc;
    7c75:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
		res->data=data;
    7c7c:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
    7c83:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    7c8a:	00 
	return head->next == (struct alloc_head*)head;
}

static inline void init_head(struct alloc_head_list *head) {
	head->next = head->prev = (struct alloc_head*)head;
    7c8b:	b8 00 00 00 00       	mov    $0x0,%eax
    7c90:	a3 00 00 00 00       	mov    %eax,0x0
    7c95:	b8 00 00 00 00       	mov    $0x0,%eax
    7c9a:	a3 04 00 00 00       	mov    %eax,0x4
	head->list = head;
    7c9f:	b8 00 00 00 00       	mov    $0x0,%eax
    7ca4:	a3 08 00 00 00       	mov    %eax,0x8
	head->len = 0;
    7ca9:	31 c0                	xor    %eax,%eax
    7cab:	a3 10 00 00 00       	mov    %eax,0x10
static inline struct proc_dir_entry *create_proc_read_entry(const char *name,
	mode_t mode, struct proc_dir_entry *base, 
	read_proc_t *read_proc, void * data)
{
	struct proc_dir_entry *res=create_proc_entry(name,mode,base);
    7cb0:	c7 44 24 04 a4 01 00 	movl   $0x1a4,0x4(%esp,1)
    7cb7:	00 
    7cb8:	c7 04 24 23 04 00 00 	movl   $0x423,(%esp,1)
    7cbf:	e8 fc ff ff ff       	call   7cc0 <init_module+0x280>
	if (res) {
    7cc4:	85 c0                	test   %eax,%eax
    7cc6:	74 0e                	je     7cd6 <init_module+0x296>
		res->read_proc=read_proc;
    7cc8:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
		res->data=data;
    7ccf:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
	if(sysctl_dbg_cwnd) {
		printk("Dumping cwnd to log\n");
	}

	init_head(&tricklesProcLogHead);
	create_proc_read_entry("trickles", S_IRUGO | S_IWUSR,
			       NULL, trickles_read_proc, NULL); 

	init_head(&tricklesCwndProcLogHead);
	create_proc_read_entry("trickles_cwnd", S_IRUGO | S_IWUSR,
			       NULL, trickles_cwnd_read_proc, NULL); 

#ifdef LOG_CWND_ENABLE
	trickles_logCwnd_hook = trickles_logCwnd_impl;
	printk("Log cwnd enabled!!!\n");
#else
	trickles_logCwnd_hook = trickles_logCwnd_default;
#endif

	printk("Multiplicative factor = %d\n", MULT_FACTOR);
    7cd6:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp,1)
    7cdd:	00 
    7cde:	b8 00 00 00 00       	mov    $0x0,%eax
    7ce3:	c7 04 24 31 04 00 00 	movl   $0x431,(%esp,1)
    7cea:	a3 00 00 00 00       	mov    %eax,0x0
    7cef:	e8 fc ff ff ff       	call   7cf0 <init_module+0x2b0>

#ifdef ACKTCP_CWND_SPEED_HACK
#define STRINGIFY(X) #X
	printk("Using AckTCPCwnd speed hack " STRINGIFY(ACKTCP_CWND_SPEED_HACK) "\n");
    7cf4:	c7 04 24 60 27 00 00 	movl   $0x2760,(%esp,1)
    7cfb:	e8 fc ff ff ff       	call   7cfc <init_module+0x2bc>
#undef STRINGIFY
#endif
	printk("Timeout multiplier: %d\n", TIMEOUT_MULTIPLIER);
    7d00:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp,1)
    7d07:	00 
    7d08:	c7 04 24 4d 04 00 00 	movl   $0x44d,(%esp,1)
    7d0f:	e8 fc ff ff ff       	call   7d10 <init_module+0x2d0>

#ifdef ZERO_SSTHRESH_PROTECTION_HACK
	printk("Zero ssthresh protection hack\n");
    7d14:	c7 04 24 a0 27 00 00 	movl   $0x27a0,(%esp,1)
    7d1b:	e8 fc ff ff ff       	call   7d1c <init_module+0x2dc>
#endif
#ifdef DISABLE_ACKTCPCWND_WARNINGS
	printk("AckTCPCwnd warnings disabled\n");
    7d20:	c7 04 24 65 04 00 00 	movl   $0x465,(%esp,1)
    7d27:	e8 fc ff ff ff       	call   7d28 <init_module+0x2e8>
#endif
#ifdef DISABLE_SENDACKOVERFLOW
	printk("SendAckOverflow disabled\n");
    7d2c:	c7 04 24 83 04 00 00 	movl   $0x483,(%esp,1)
    7d33:	e8 fc ff ff ff       	call   7d34 <init_module+0x2f4>
#endif

#ifdef FIXED_CRYPTO_KEYS
	printk("Fixed crypto keys\n");
    7d38:	c7 04 24 9d 04 00 00 	movl   $0x49d,(%esp,1)
    7d3f:	e8 fc ff ff ff       	call   7d40 <init_module+0x300>
#endif
	if(DISABLE_NONCE_CHECK) {
		printk("Nonce check disabled\n");
	}

#ifdef DISABLE_SADDR_HMAC
	printk("Server source address not included in HMAC\n");
    7d44:	c7 04 24 c0 27 00 00 	movl   $0x27c0,(%esp,1)
    7d4b:	e8 fc ff ff ff       	call   7d4c <init_module+0x30c>
#endif

#ifdef DISABLE_NONCE_FAIL
	printk("!!!Disabled nonce mismatch check!!!\n");
#endif

#ifdef PRINT_NONCE_DIAG
	{
		int i;
		struct aes_encrypt_ctx ctx;
		char nonce_key[NONCE_KEYLEN];
		char block[NONCE_BLOCKSIZE];
		memset(nonce_key, 0, NONCE_KEYLEN);
		memset(block, 0, NONCE_BLOCKSIZE);
		strcpy(nonce_key, "hello w");
		aes_encrypt_key(nonce_key, NONCE_KEYLEN, &ctx);
		for(i=0; i < 10; i++) {	
			char output[NONCE_BLOCKSIZE];
			*(__u64*)block = i * i;
			aes_encrypt(block, output, &ctx);
			printk(" Input: ");
			hexdump(block, NONCE_BLOCKSIZE);
			printk("\n");
			printk("Output: ");
			hexdump(output, NONCE_BLOCKSIZE);
			printk("\n");
		}
#define TAR_MAX (10)
		__u32 testArray[TAR_MAX];
		for(i=1; i <= TAR_MAX; i++) {
			printk("Range nonce 1-%d 0x%0X\n", i, 
			       testArray[i] = 
			       generateCryptoRangeNonceHelper(&ctx, 1, i));
		}
		printk("Nonces 1-%d: ", TAR_MAX);
		struct NonceCtx nctx;
		nctx.new = 1;
		__u32 accum = 0;
		for(i=1; i <= TAR_MAX; i++) {
			__u32 curr = generateCryptoSingleNonceHelper(&ctx, i, &nctx);
			accum ^= curr;
			printk("0x%0X%c ", accum, (accum == testArray[i]) ? 'g' : '!');
		}
#undef TAR_MAX
	}
#endif
	printk("WIRECONT_MAC_LEN: %d\n", WIRECONT_MAC_LEN);
    7d50:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp,1)
    7d57:	00 
    7d58:	c7 04 24 b0 04 00 00 	movl   $0x4b0,(%esp,1)
    7d5f:	e8 fc ff ff ff       	call   7d60 <init_module+0x320>

#ifdef RCV_COPY_TO_SMALLER_SKB
	printk("Client is copying dev skbs to minimal size skbs\n");
    7d64:	c7 04 24 00 28 00 00 	movl   $0x2800,(%esp,1)
    7d6b:	e8 fc ff ff ff       	call   7d6c <init_module+0x32c>
#endif
	printk("FullMTU = %d, MinimalMTU = %d, "
    7d70:	c7 44 24 14 1f 00 00 	movl   $0x1f,0x14(%esp,1)
    7d77:	00 
    7d78:	c7 44 24 10 15 00 00 	movl   $0x15,0x10(%esp,1)
    7d7f:	00 
    7d80:	c7 44 24 0c 4a 00 00 	movl   $0x4a,0xc(%esp,1)
    7d87:	00 
    7d88:	c7 44 24 08 87 05 00 	movl   $0x587,0x8(%esp,1)
    7d8f:	00 
    7d90:	c7 44 24 04 52 05 00 	movl   $0x552,0x4(%esp,1)
    7d97:	00 
    7d98:	c7 04 24 40 28 00 00 	movl   $0x2840,(%esp,1)
    7d9f:	e8 fc ff ff ff       	call   7da0 <init_module+0x360>
	       "CONTTYPELEN_FULL = %d, CONTTYPELEN_MINIMAL = %d, HASHCOMPRESS = %d\n",
	       CONTTYPE_FULL_MTU, CONTTYPE_MINIMAL_MTU, 
	       CONTTYPELEN_FULL, CONTTYPELEN_MINIMAL, 
	       CONTTYPELEN_HASHCOMPRESS);

	return 0;
}
    7da4:	83 c4 18             	add    $0x18,%esp
    7da7:	31 c0                	xor    %eax,%eax
    7da9:	5e                   	pop    %esi
    7daa:	5f                   	pop    %edi
    7dab:	5d                   	pop    %ebp
    7dac:	c3                   	ret    
    7dad:	8d 76 00             	lea    0x0(%esi),%esi
    7db0:	c7 04 24 c0 28 00 00 	movl   $0x28c0,(%esp,1)
    7db7:	e8 fc ff ff ff       	call   7db8 <init_module+0x378>
    7dbc:	e9 d3 fd ff ff       	jmp    7b94 <init_module+0x154>
    7dc1:	c7 04 24 00 29 00 00 	movl   $0x2900,(%esp,1)
    7dc8:	e8 fc ff ff ff       	call   7dc9 <init_module+0x389>
    7dcd:	e9 b5 fd ff ff       	jmp    7b87 <init_module+0x147>
    7dd2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    7dd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00007de0 <cleanup_module>:

static void trickles_exit(void) {
    7de0:	55                   	push   %ebp
	struct sock *sk = trickles_sockets_head.next;
	trickles_rcv_hook = trickles_rcv_default;
    7de1:	b8 00 00 00 00       	mov    $0x0,%eax
    7de6:	89 e5                	mov    %esp,%ebp
    7de8:	57                   	push   %edi
	trickles_destroy_hook = trickles_destroy_default;
	cminisock_config_pipe_hook = cminisock_config_pipe_default;
	trickles_sendv_hook = trickles_sendv_default;
	trickles_send_hook = trickles_send_default;
    7de9:	bf 00 00 00 00       	mov    $0x0,%edi
	trickles_sendfilev_hook = trickles_sendfilev_default;
	trickles_mmap_hook = trickles_mmap_default;
    7dee:	b9 00 00 00 00       	mov    $0x0,%ecx
    7df3:	56                   	push   %esi
	trickles_sock_poll_hook = trickles_sock_poll_default;
    7df4:	ba 00 00 00 00       	mov    $0x0,%edx
    7df9:	53                   	push   %ebx
    7dfa:	83 ec 3c             	sub    $0x3c,%esp
    7dfd:	be 00 00 00 00       	mov    $0x0,%esi
    7e02:	a3 00 00 00 00       	mov    %eax,0x0
    7e07:	b8 00 00 00 00       	mov    $0x0,%eax
    7e0c:	8b 1d 10 00 00 00    	mov    0x10,%ebx
    7e12:	a3 00 00 00 00       	mov    %eax,0x0
    7e17:	b8 00 00 00 00       	mov    $0x0,%eax
    7e1c:	a3 00 00 00 00       	mov    %eax,0x0
    7e21:	b8 00 00 00 00       	mov    $0x0,%eax
    7e26:	a3 00 00 00 00       	mov    %eax,0x0
	trickles_init_sock_hook = trickles_init_sock_default;
    7e2b:	b8 00 00 00 00       	mov    $0x0,%eax
    7e30:	a3 00 00 00 00       	mov    %eax,0x0
	trickles_send_ack_hook = trickles_send_ack_default;
    7e35:	b8 00 00 00 00       	mov    $0x0,%eax
    7e3a:	a3 00 00 00 00       	mov    %eax,0x0
	trickles_setucont_hook = trickles_setucont_default;
    7e3f:	b8 00 00 00 00       	mov    $0x0,%eax
    7e44:	a3 00 00 00 00       	mov    %eax,0x0
	trickles_getsockopt_hook = trickles_getsockopt_default;
    7e49:	b8 00 00 00 00       	mov    $0x0,%eax
    7e4e:	a3 00 00 00 00       	mov    %eax,0x0

	trickles_sendmsg_hook = trickles_sendmsg_default;
    7e53:	b8 00 00 00 00       	mov    $0x0,%eax
    7e58:	89 3d 00 00 00 00    	mov    %edi,0x0
	trickles_logCwnd_hook = trickles_logCwnd_default;

	trickles_sendbulk_hook = trickles_sendbulk_default;
    7e5e:	bf 00 00 00 00       	mov    $0x0,%edi
    7e63:	a3 00 00 00 00       	mov    %eax,0x0
    7e68:	b8 00 00 00 00       	mov    $0x0,%eax
    7e6d:	89 35 00 00 00 00    	mov    %esi,0x0

	spin_lock(&trickles_sockets_head_lock);
	int i = 0;
    7e73:	31 f6                	xor    %esi,%esi
    7e75:	89 0d 00 00 00 00    	mov    %ecx,0x0
    7e7b:	89 15 00 00 00 00    	mov    %edx,0x0
    7e81:	a3 00 00 00 00       	mov    %eax,0x0
    7e86:	89 3d 00 00 00 00    	mov    %edi,0x0
	local_bh_disable();
    7e8c:	ff 05 08 00 00 00    	incl   0x8
	while(sk && sk != &trickles_sockets_head) {
    7e92:	85 db                	test   %ebx,%ebx
    7e94:	74 25                	je     7ebb <cleanup_module+0xdb>
    7e96:	81 fb 00 00 00 00    	cmp    $0x0,%ebx
    7e9c:	74 1d                	je     7ebb <cleanup_module+0xdb>
    7e9e:	89 f6                	mov    %esi,%esi
		trickles_clear_timers(sk);
    7ea0:	89 1c 24             	mov    %ebx,(%esp,1)
		sk = sk->tp_pinfo.af_tcp.t.dnext;
		i++;
    7ea3:	46                   	inc    %esi
    7ea4:	e8 d7 f3 ff ff       	call   7280 <trickles_clear_timers>
    7ea9:	8b 9b d0 0a 00 00    	mov    0xad0(%ebx),%ebx
    7eaf:	85 db                	test   %ebx,%ebx
    7eb1:	74 08                	je     7ebb <cleanup_module+0xdb>
    7eb3:	81 fb 00 00 00 00    	cmp    $0x0,%ebx
    7eb9:	75 e5                	jne    7ea0 <cleanup_module+0xc0>
	}
	printk("%d timers cleared\n", i);
    7ebb:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    7ebf:	c7 04 24 c6 04 00 00 	movl   $0x4c6,(%esp,1)
    7ec6:	e8 fc ff ff ff       	call   7ec7 <cleanup_module+0xe7>
	local_bh_enable();
    7ecb:	ba 08 00 00 00       	mov    $0x8,%edx
    7ed0:	a1 08 00 00 00       	mov    0x8,%eax
    7ed5:	48                   	dec    %eax
    7ed6:	85 c0                	test   %eax,%eax
    7ed8:	a3 08 00 00 00       	mov    %eax,0x8
    7edd:	75 0a                	jne    7ee9 <cleanup_module+0x109>
    7edf:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
    7ee3:	0f 85 fc 17 00 00    	jne    96e5 <.text.lock.tmalloc+0x20>
	spin_unlock(&trickles_sockets_head_lock);
	//trickles_client_connected_hook = trickles_client_connected_default;
	printk("trickles unloaded\n");
    7ee9:	c7 04 24 d9 04 00 00 	movl   $0x4d9,(%esp,1)
    7ef0:	e8 fc ff ff ff       	call   7ef1 <cleanup_module+0x111>
	printk("numConversionRequests = %d, numContinuationRequests = %d, numDataRequestMappings = %d\n", 
    7ef5:	a1 00 00 00 00       	mov    0x0,%eax
    7efa:	c7 04 24 40 29 00 00 	movl   $0x2940,(%esp,1)
    7f01:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    7f05:	a1 00 00 00 00       	mov    0x0,%eax
    7f0a:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    7f0e:	a1 48 00 00 00       	mov    0x48,%eax
    7f13:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    7f17:	e8 fc ff ff ff       	call   7f18 <cleanup_module+0x138>
	       numConversionRequests, numContinuationRequests, numDataRequestMappings);

	printk("numRxPackets = %llu, numRxBytes = %llu, numTxPackets = %llu, numTxBytes = %llu\n", 
    7f1c:	a1 00 00 00 00       	mov    0x0,%eax
    7f21:	8b 15 04 00 00 00    	mov    0x4,%edx
    7f27:	c7 04 24 a0 29 00 00 	movl   $0x29a0,(%esp,1)
    7f2e:	89 44 24 1c          	mov    %eax,0x1c(%esp,1)
    7f32:	a1 00 00 00 00       	mov    0x0,%eax
    7f37:	89 54 24 20          	mov    %edx,0x20(%esp,1)
    7f3b:	8b 15 04 00 00 00    	mov    0x4,%edx
    7f41:	89 44 24 14          	mov    %eax,0x14(%esp,1)
    7f45:	a1 00 00 00 00       	mov    0x0,%eax
    7f4a:	89 54 24 18          	mov    %edx,0x18(%esp,1)
    7f4e:	8b 15 04 00 00 00    	mov    0x4,%edx
    7f54:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    7f58:	a1 00 00 00 00       	mov    0x0,%eax
    7f5d:	89 54 24 10          	mov    %edx,0x10(%esp,1)
    7f61:	8b 15 04 00 00 00    	mov    0x4,%edx
    7f67:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    7f6b:	89 54 24 08          	mov    %edx,0x8(%esp,1)
    7f6f:	e8 fc ff ff ff       	call   7f70 <cleanup_module+0x190>
	       numRxPackets, numRxBytes, numTxPackets, numTxBytes);

	kmem_cache_destroy(clientSideContinuation_cache);
    7f74:	a1 00 00 00 00       	mov    0x0,%eax
    7f79:	89 04 24             	mov    %eax,(%esp,1)
    7f7c:	e8 fc ff ff ff       	call   7f7d <cleanup_module+0x19d>

	struct TricklesProcLogEntry *logEntry;
	struct TricklesCwndProcLogEntry *cwndLogEntry;
	local_bh_disable();
    7f81:	ff 05 08 00 00 00    	incl   0x8
	alloc_head_walk(&tricklesProcLogHead, logEntry) {
    7f87:	8b 35 04 00 00 00    	mov    0x4,%esi
    7f8d:	81 fe 00 00 00 00    	cmp    $0x0,%esi
    7f93:	74 51                	je     7fe6 <cleanup_module+0x206>
    7f95:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    7f99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
		struct TricklesProcLogEntry *clean = logEntry;
    7fa0:	89 f3                	mov    %esi,%ebx
		logEntry = (struct TricklesProcLogEntry*)logEntry->prev;
    7fa2:	8b 36                	mov    (%esi),%esi
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    7fa4:	8b 53 04             	mov    0x4(%ebx),%edx
    7fa7:	89 32                	mov    %esi,(%edx)
	elem->prev->next = elem->next;
    7fa9:	8b 03                	mov    (%ebx),%eax
	elem->prev = elem->next = NULL;
    7fab:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    7fb1:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
    7fb4:	8b 43 08             	mov    0x8(%ebx),%eax
    7fb7:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    7fbe:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    7fc1:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		unlink((struct alloc_head*)clean);
		kfree(clean->events);
    7fc8:	8b 43 1c             	mov    0x1c(%ebx),%eax
    7fcb:	89 04 24             	mov    %eax,(%esp,1)
    7fce:	e8 fc ff ff ff       	call   7fcf <cleanup_module+0x1ef>
		kfree(clean);
    7fd3:	89 1c 24             	mov    %ebx,(%esp,1)
    7fd6:	e8 fc ff ff ff       	call   7fd7 <cleanup_module+0x1f7>
    7fdb:	8b 76 04             	mov    0x4(%esi),%esi
    7fde:	81 fe 00 00 00 00    	cmp    $0x0,%esi
    7fe4:	75 ba                	jne    7fa0 <cleanup_module+0x1c0>
	}
	// should not need to take locks if bh is disabled
	alloc_head_walk(&tricklesCwndProcLogHead, cwndLogEntry) {
    7fe6:	8b 1d 04 00 00 00    	mov    0x4,%ebx
    7fec:	81 fb 00 00 00 00    	cmp    $0x0,%ebx
    7ff2:	74 47                	je     803b <cleanup_module+0x25b>
    7ff4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    7ffa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
		struct TricklesCwndProcLogEntry *clean = cwndLogEntry;
    8000:	89 da                	mov    %ebx,%edx
		cwndLogEntry = (struct TricklesCwndProcLogEntry*)cwndLogEntry->prev;
    8002:	8b 1b                	mov    (%ebx),%ebx
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    8004:	8b 4a 04             	mov    0x4(%edx),%ecx
    8007:	89 19                	mov    %ebx,(%ecx)
	elem->prev->next = elem->next;
    8009:	8b 02                	mov    (%edx),%eax
	elem->prev = elem->next = NULL;
    800b:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
    8011:	89 48 04             	mov    %ecx,0x4(%eax)

	elem->list->len--;
    8014:	8b 42 08             	mov    0x8(%edx),%eax
    8017:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
    801e:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    8021:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
		unlink((struct alloc_head*)clean);
		kfree(clean);
    8028:	89 14 24             	mov    %edx,(%esp,1)
    802b:	e8 fc ff ff ff       	call   802c <cleanup_module+0x24c>
    8030:	8b 5b 04             	mov    0x4(%ebx),%ebx
    8033:	81 fb 00 00 00 00    	cmp    $0x0,%ebx
    8039:	75 c5                	jne    8000 <cleanup_module+0x220>
	}
	local_bh_enable();
    803b:	ba 08 00 00 00       	mov    $0x8,%edx
    8040:	a1 08 00 00 00       	mov    0x8,%eax
    8045:	48                   	dec    %eax
    8046:	85 c0                	test   %eax,%eax
    8048:	a3 08 00 00 00       	mov    %eax,0x8
    804d:	75 0a                	jne    8059 <cleanup_module+0x279>
    804f:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
    8053:	0f 85 9c 16 00 00    	jne    96f5 <.text.lock.tmalloc+0x30>
	remove_proc_entry("trickles", NULL);
    8059:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    8060:	00 
    8061:	c7 04 24 1a 04 00 00 	movl   $0x41a,(%esp,1)
    8068:	e8 fc ff ff ff       	call   8069 <cleanup_module+0x289>
	remove_proc_entry("trickles_cwnd", NULL);
    806d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    8074:	00 
    8075:	c7 04 24 23 04 00 00 	movl   $0x423,(%esp,1)
    807c:	e8 fc ff ff ff       	call   807d <cleanup_module+0x29d>


	printk("numRxPackets = %llu, numRxBytes = %llu, avgRxPacketSize = %d, numTxPackets = %llu, numTxBytes = %llu, avgTxPacketSize = %d\n", 
    8081:	a1 00 00 00 00       	mov    0x0,%eax
    8086:	8b 15 04 00 00 00    	mov    0x4,%edx
    808c:	89 c1                	mov    %eax,%ecx
    808e:	0f ac d1 04          	shrd   $0x4,%edx,%ecx
    8092:	85 c9                	test   %ecx,%ecx
    8094:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    8097:	89 55 f0             	mov    %edx,0xfffffff0(%ebp)
    809a:	0f 84 91 01 00 00    	je     8231 <cleanup_module+0x451>
    80a0:	8b 35 00 00 00 00    	mov    0x0,%esi
    80a6:	31 d2                	xor    %edx,%edx
    80a8:	8b 3d 04 00 00 00    	mov    0x4,%edi
    80ae:	89 f0                	mov    %esi,%eax
    80b0:	0f ac f8 04          	shrd   $0x4,%edi,%eax
    80b4:	f7 f1                	div    %ecx
    80b6:	89 44 24 28          	mov    %eax,0x28(%esp,1)
    80ba:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    80bd:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    80c0:	89 74 24 20          	mov    %esi,0x20(%esp,1)
    80c4:	89 44 24 18          	mov    %eax,0x18(%esp,1)
    80c8:	a1 00 00 00 00       	mov    0x0,%eax
    80cd:	89 54 24 1c          	mov    %edx,0x1c(%esp,1)
    80d1:	8b 15 04 00 00 00    	mov    0x4,%edx
    80d7:	89 c1                	mov    %eax,%ecx
    80d9:	89 7c 24 24          	mov    %edi,0x24(%esp,1)
    80dd:	0f ac d1 04          	shrd   $0x4,%edx,%ecx
    80e1:	85 c9                	test   %ecx,%ecx
    80e3:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    80e6:	89 55 e8             	mov    %edx,0xffffffe8(%ebp)
    80e9:	0f 84 2f 01 00 00    	je     821e <cleanup_module+0x43e>
    80ef:	8b 35 00 00 00 00    	mov    0x0,%esi
    80f5:	31 d2                	xor    %edx,%edx
    80f7:	8b 3d 04 00 00 00    	mov    0x4,%edi
    80fd:	89 f0                	mov    %esi,%eax
    80ff:	0f ac f8 04          	shrd   $0x4,%edi,%eax
    8103:	f7 f1                	div    %ecx
    8105:	89 44 24 14          	mov    %eax,0x14(%esp,1)
    8109:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
	       numRxPackets, numRxBytes, (__u32)(numRxPackets >> 4) ? (__u32)(numRxBytes >> 4) / (__u32)(numRxPackets >> 4) : 0,
	       numTxPackets, numTxBytes, (__u32)(numTxPackets >> 4) ? (__u32)(numTxBytes >> 4) / (__u32)(numTxPackets >> 4) : 0);
	numRxPackets = numRxBytes = numTxPackets = numTxBytes = 0;
    810c:	31 db                	xor    %ebx,%ebx
    810e:	89 74 24 0c          	mov    %esi,0xc(%esp,1)
    8112:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    8115:	31 f6                	xor    %esi,%esi
    8117:	89 54 24 08          	mov    %edx,0x8(%esp,1)
    811b:	89 7c 24 10          	mov    %edi,0x10(%esp,1)
    811f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    8123:	c7 04 24 00 2a 00 00 	movl   $0x2a00,(%esp,1)
    812a:	e8 fc ff ff ff       	call   812b <cleanup_module+0x34b>
    812f:	31 c0                	xor    %eax,%eax
    8131:	31 c9                	xor    %ecx,%ecx
    8133:	a3 00 00 00 00       	mov    %eax,0x0
    8138:	31 c0                	xor    %eax,%eax
    813a:	31 d2                	xor    %edx,%edx
    813c:	a3 04 00 00 00       	mov    %eax,0x4
    8141:	31 c0                	xor    %eax,%eax
    8143:	a3 00 00 00 00       	mov    %eax,0x0
    8148:	31 c0                	xor    %eax,%eax
    814a:	a3 04 00 00 00       	mov    %eax,0x4

	printk("Number of no memory events: %d\n", gNumNomemEvents);
    814f:	a1 14 00 00 00       	mov    0x14,%eax
    8154:	89 0d 00 00 00 00    	mov    %ecx,0x0
    815a:	89 15 04 00 00 00    	mov    %edx,0x4
    8160:	89 1d 04 00 00 00    	mov    %ebx,0x4
    8166:	89 35 00 00 00 00    	mov    %esi,0x0
    816c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    8170:	c7 04 24 80 2a 00 00 	movl   $0x2a80,(%esp,1)
    8177:	e8 fc ff ff ff       	call   8178 <cleanup_module+0x398>
	printk("Number of csum bytes %d, ", total_csum_bytes);
    817c:	a1 00 00 00 00       	mov    0x0,%eax
    8181:	c7 04 24 ec 04 00 00 	movl   $0x4ec,(%esp,1)
    8188:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    818c:	e8 fc ff ff ff       	call   818d <cleanup_module+0x3ad>
	printk("TCP Complete count %d, ", csum_complete_user_count);
    8191:	a1 10 00 00 00       	mov    0x10,%eax
    8196:	c7 04 24 06 05 00 00 	movl   $0x506,(%esp,1)
    819d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    81a1:	e8 fc ff ff ff       	call   81a2 <cleanup_module+0x3c2>
	printk("setucont %d, sendv %d\n", gNumSetUCont, gNumSendv);
    81a6:	a1 00 00 00 00       	mov    0x0,%eax
    81ab:	c7 04 24 1e 05 00 00 	movl   $0x51e,(%esp,1)
    81b2:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    81b6:	a1 00 00 00 00       	mov    0x0,%eax
    81bb:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    81bf:	e8 fc ff ff ff       	call   81c0 <cleanup_module+0x3e0>
	printk("Num of sendbulk: %d, descs: %d\n", gNumSendbulk, gNumSendbulkDesc);
    81c4:	a1 00 00 00 00       	mov    0x0,%eax
    81c9:	c7 04 24 a0 2a 00 00 	movl   $0x2aa0,(%esp,1)
    81d0:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    81d4:	a1 00 00 00 00       	mov    0x0,%eax
    81d9:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    81dd:	e8 fc ff ff ff       	call   81de <cleanup_module+0x3fe>
	printk("Average updates per poll %d (%d/%d)\n",
    81e2:	8b 1d 00 00 00 00    	mov    0x0,%ebx
    81e8:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
    81ed:	8b 15 00 00 00 00    	mov    0x0,%edx
    81f3:	89 5c 24 0c          	mov    %ebx,0xc(%esp,1)
    81f7:	85 db                	test   %ebx,%ebx
    81f9:	89 54 24 08          	mov    %edx,0x8(%esp,1)
    81fd:	74 07                	je     8206 <cleanup_module+0x426>
    81ff:	89 d0                	mov    %edx,%eax
    8201:	99                   	cltd   
    8202:	f7 fb                	idiv   %ebx
    8204:	89 c1                	mov    %eax,%ecx
    8206:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    820a:	c7 04 24 c0 2a 00 00 	movl   $0x2ac0,(%esp,1)
    8211:	e8 fc ff ff ff       	call   8212 <cleanup_module+0x432>
	       gUpdateSincePollCount ? 
	       gUpdateSincePollTotal / gUpdateSincePollCount : -1,
	       gUpdateSincePollTotal, gUpdateSincePollCount);
}
    8216:	83 c4 3c             	add    $0x3c,%esp
    8219:	5b                   	pop    %ebx
    821a:	5e                   	pop    %esi
    821b:	5f                   	pop    %edi
    821c:	5d                   	pop    %ebp
    821d:	c3                   	ret    
    821e:	8b 35 00 00 00 00    	mov    0x0,%esi
    8224:	31 c0                	xor    %eax,%eax
    8226:	8b 3d 04 00 00 00    	mov    0x4,%edi
    822c:	e9 d4 fe ff ff       	jmp    8105 <cleanup_module+0x325>
    8231:	8b 35 00 00 00 00    	mov    0x0,%esi
    8237:	31 c0                	xor    %eax,%eax
    8239:	8b 3d 04 00 00 00    	mov    0x4,%edi
    823f:	e9 72 fe ff ff       	jmp    80b6 <cleanup_module+0x2d6>
    8244:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    824a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00008250 <pushRequests>:
    8250:	55                   	push   %ebp
    8251:	89 e5                	mov    %esp,%ebp
    8253:	83 ec 08             	sub    $0x8,%esp
    8256:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    825d:	00 
    825e:	8b 45 08             	mov    0x8(%ebp),%eax
    8261:	89 04 24             	mov    %eax,(%esp,1)
    8264:	e8 fc ff ff ff       	call   8265 <pushRequests+0x15>
    8269:	89 ec                	mov    %ebp,%esp
    826b:	5d                   	pop    %ebp
    826c:	c3                   	ret    
    826d:	8d 76 00             	lea    0x0(%esi),%esi

00008270 <__constant_memcpy>:
 * This looks horribly ugly, but the compiler can optimize it totally,
 * as the count is constant.
 */
static inline void * __constant_memcpy(void * to, const void * from, size_t n)
{
    8270:	55                   	push   %ebp
    8271:	89 e5                	mov    %esp,%ebp
    8273:	83 ec 0c             	sub    $0xc,%esp
    8276:	89 75 f8             	mov    %esi,0xfffffff8(%ebp)
    8279:	8b 4d 10             	mov    0x10(%ebp),%ecx
    827c:	8b 55 08             	mov    0x8(%ebp),%edx
    827f:	89 7d fc             	mov    %edi,0xfffffffc(%ebp)
	switch (n) {
    8282:	83 f9 14             	cmp    $0x14,%ecx
    8285:	8b 75 0c             	mov    0xc(%ebp),%esi
    8288:	0f 87 82 00 00 00    	ja     8310 <__constant_memcpy+0xa0>
    828e:	ff 24 8d 34 00 00 00 	jmp    *0x34(,%ecx,4)
		case 0:
			return to;
		case 1:
			*(unsigned char *)to = *(const unsigned char *)from;
    8295:	0f b6 06             	movzbl (%esi),%eax
    8298:	88 02                	mov    %al,(%edx)
    829a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			return to;
		case 2:
			*(unsigned short *)to = *(const unsigned short *)from;
			return to;
		case 3:
			*(unsigned short *)to = *(const unsigned short *)from;
			*(2+(unsigned char *)to) = *(2+(const unsigned char *)from);
			return to;
		case 4:
			*(unsigned long *)to = *(const unsigned long *)from;
			return to;
		case 6:	/* for Ethernet addresses */
			*(unsigned long *)to = *(const unsigned long *)from;
			*(2+(unsigned short *)to) = *(2+(const unsigned short *)from);
			return to;
		case 8:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			return to;
		case 12:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
			return to;
		case 16:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
			*(3+(unsigned long *)to) = *(3+(const unsigned long *)from);
			return to;
		case 20:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
			*(3+(unsigned long *)to) = *(3+(const unsigned long *)from);
			*(4+(unsigned long *)to) = *(4+(const unsigned long *)from);
			return to;
	}
#define COMMON(x) \
__asm__ __volatile__( \
	"rep ; movsl" \
	x \
	: "=&c" (d0), "=&D" (d1), "=&S" (d2) \
	: "0" (n/4),"1" ((long) to),"2" ((long) from) \
	: "memory");
{
	int d0, d1, d2;
	switch (n % 4) {
		case 0: COMMON(""); return to;
		case 1: COMMON("\n\tmovsb"); return to;
		case 2: COMMON("\n\tmovsw"); return to;
		default: COMMON("\n\tmovsw\n\tmovsb"); return to;
	}
}
  
#undef COMMON
}
    82a0:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
    82a3:	89 d0                	mov    %edx,%eax
    82a5:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
    82a8:	89 ec                	mov    %ebp,%esp
    82aa:	5d                   	pop    %ebp
    82ab:	c3                   	ret    
    82ac:	0f b7 06             	movzwl (%esi),%eax
    82af:	66 89 02             	mov    %ax,(%edx)
    82b2:	eb ec                	jmp    82a0 <__constant_memcpy+0x30>
    82b4:	0f b7 06             	movzwl (%esi),%eax
    82b7:	66 89 02             	mov    %ax,(%edx)
    82ba:	0f b6 46 02          	movzbl 0x2(%esi),%eax
    82be:	88 42 02             	mov    %al,0x2(%edx)
    82c1:	eb dd                	jmp    82a0 <__constant_memcpy+0x30>
    82c3:	8b 06                	mov    (%esi),%eax
    82c5:	89 02                	mov    %eax,(%edx)
    82c7:	eb d7                	jmp    82a0 <__constant_memcpy+0x30>
    82c9:	8b 06                	mov    (%esi),%eax
    82cb:	89 02                	mov    %eax,(%edx)
    82cd:	0f b7 46 04          	movzwl 0x4(%esi),%eax
    82d1:	66 89 42 04          	mov    %ax,0x4(%edx)
    82d5:	eb c9                	jmp    82a0 <__constant_memcpy+0x30>
    82d7:	8b 06                	mov    (%esi),%eax
    82d9:	89 02                	mov    %eax,(%edx)
    82db:	8b 46 04             	mov    0x4(%esi),%eax
    82de:	89 42 04             	mov    %eax,0x4(%edx)
    82e1:	eb bd                	jmp    82a0 <__constant_memcpy+0x30>
    82e3:	8b 06                	mov    (%esi),%eax
    82e5:	89 02                	mov    %eax,(%edx)
    82e7:	8b 46 04             	mov    0x4(%esi),%eax
    82ea:	89 42 04             	mov    %eax,0x4(%edx)
    82ed:	8b 46 08             	mov    0x8(%esi),%eax
    82f0:	89 42 08             	mov    %eax,0x8(%edx)
    82f3:	eb ab                	jmp    82a0 <__constant_memcpy+0x30>
    82f5:	8b 06                	mov    (%esi),%eax
    82f7:	89 02                	mov    %eax,(%edx)
    82f9:	8b 46 04             	mov    0x4(%esi),%eax
    82fc:	89 42 04             	mov    %eax,0x4(%edx)
    82ff:	8b 46 08             	mov    0x8(%esi),%eax
    8302:	89 42 08             	mov    %eax,0x8(%edx)
    8305:	8b 46 0c             	mov    0xc(%esi),%eax
    8308:	89 42 0c             	mov    %eax,0xc(%edx)
    830b:	eb 93                	jmp    82a0 <__constant_memcpy+0x30>
    830d:	8d 76 00             	lea    0x0(%esi),%esi
    8310:	89 c8                	mov    %ecx,%eax
    8312:	83 e0 03             	and    $0x3,%eax
    8315:	83 f8 01             	cmp    $0x1,%eax
    8318:	74 36                	je     8350 <__constant_memcpy+0xe0>
    831a:	83 f8 01             	cmp    $0x1,%eax
    831d:	72 22                	jb     8341 <__constant_memcpy+0xd1>
    831f:	83 f8 02             	cmp    $0x2,%eax
    8322:	74 0f                	je     8333 <__constant_memcpy+0xc3>
    8324:	c1 e9 02             	shr    $0x2,%ecx
    8327:	89 d7                	mov    %edx,%edi
    8329:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    832b:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    832d:	a4                   	movsb  %ds:(%esi),%es:(%edi)
    832e:	e9 6d ff ff ff       	jmp    82a0 <__constant_memcpy+0x30>
    8333:	c1 e9 02             	shr    $0x2,%ecx
    8336:	89 d7                	mov    %edx,%edi
    8338:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    833a:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    833c:	e9 5f ff ff ff       	jmp    82a0 <__constant_memcpy+0x30>
    8341:	c1 e9 02             	shr    $0x2,%ecx
    8344:	89 d7                	mov    %edx,%edi
    8346:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    8348:	e9 53 ff ff ff       	jmp    82a0 <__constant_memcpy+0x30>
    834d:	8d 76 00             	lea    0x0(%esi),%esi
    8350:	c1 e9 02             	shr    $0x2,%ecx
    8353:	89 d7                	mov    %edx,%edi
    8355:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    8357:	a4                   	movsb  %ds:(%esi),%es:(%edi)
    8358:	e9 43 ff ff ff       	jmp    82a0 <__constant_memcpy+0x30>
    835d:	8b 06                	mov    (%esi),%eax
    835f:	89 02                	mov    %eax,(%edx)
    8361:	8b 46 04             	mov    0x4(%esi),%eax
    8364:	89 42 04             	mov    %eax,0x4(%edx)
    8367:	8b 46 08             	mov    0x8(%esi),%eax
    836a:	89 42 08             	mov    %eax,0x8(%edx)
    836d:	8b 46 0c             	mov    0xc(%esi),%eax
    8370:	89 42 0c             	mov    %eax,0xc(%edx)
    8373:	8b 46 10             	mov    0x10(%esi),%eax
    8376:	89 42 10             	mov    %eax,0x10(%edx)
    8379:	e9 22 ff ff ff       	jmp    82a0 <__constant_memcpy+0x30>
    837e:	89 f6                	mov    %esi,%esi

00008380 <__constant_c_and_count_memset>:

#define __HAVE_ARCH_MEMCPY

#ifdef CONFIG_X86_USE_3DNOW

#include <asm/mmx.h>

/*
 *	This CPU favours 3DNow strongly (eg AMD Athlon)
 */

static inline void * __constant_memcpy3d(void * to, const void * from, size_t len)
{
	if (len < 512)
		return __constant_memcpy(to, from, len);
	return _mmx_memcpy(to, from, len);
}

static __inline__ void *__memcpy3d(void *to, const void *from, size_t len)
{
	if (len < 512)
		return __memcpy(to, from, len);
	return _mmx_memcpy(to, from, len);
}

#define memcpy(t, f, n) \
(__builtin_constant_p(n) ? \
 __constant_memcpy3d((t),(f),(n)) : \
 __memcpy3d((t),(f),(n)))

#else

/*
 *	No 3D Now!
 */
 
#define memcpy(t, f, n) \
(__builtin_constant_p(n) ? \
 __constant_memcpy((t),(f),(n)) : \
 __memcpy((t),(f),(n)))

#endif

/*
 * struct_cpy(x,y), copy structure *x into (matching structure) *y.
 *
 * We get link-time errors if the structure sizes do not match.
 * There is no runtime overhead, it's all optimized away at
 * compile time.
 */
extern void __struct_cpy_bug (void);

#define struct_cpy(x,y) 			\
({						\
	if (sizeof(*(x)) != sizeof(*(y))) 	\
		__struct_cpy_bug;		\
	memcpy(x, y, sizeof(*(x)));		\
})

#define __HAVE_ARCH_MEMMOVE
static inline void * memmove(void * dest,const void * src, size_t n)
{
int d0, d1, d2;
if (dest<src)
__asm__ __volatile__(
	"rep\n\t"
	"movsb"
	: "=&c" (d0), "=&S" (d1), "=&D" (d2)
	:"0" (n),"1" (src),"2" (dest)
	: "memory");
else
__asm__ __volatile__(
	"std\n\t"
	"rep\n\t"
	"movsb\n\t"
	"cld"
	: "=&c" (d0), "=&S" (d1), "=&D" (d2)
	:"0" (n),
	 "1" (n-1+(const char *)src),
	 "2" (n-1+(char *)dest)
	:"memory");
return dest;
}

#define memcmp __builtin_memcmp

#define __HAVE_ARCH_MEMCHR
static inline void * memchr(const void * cs,int c,size_t count)
{
int d0;
register void * __res;
if (!count)
	return NULL;
__asm__ __volatile__(
	"repne\n\t"
	"scasb\n\t"
	"je 1f\n\t"
	"movl $1,%0\n"
	"1:\tdecl %0"
	:"=D" (__res), "=&c" (d0) : "a" (c),"0" (cs),"1" (count));
return __res;
}

static inline void * __memset_generic(void * s, char c,size_t count)
{
int d0, d1;
__asm__ __volatile__(
	"rep\n\t"
	"stosb"
	: "=&c" (d0), "=&D" (d1)
	:"a" (c),"1" (s),"0" (count)
	:"memory");
return s;
}

/* we might want to write optimized versions of these later */
#define __constant_count_memset(s,c,count) __memset_generic((s),(c),(count))

/*
 * memset(x,0,y) is a reasonably common thing to do, so we want to fill
 * things 32 bits at a time even when we don't know the size of the
 * area at compile-time..
 */
static inline void * __constant_c_memset(void * s, unsigned long c, size_t count)
{
int d0, d1;
__asm__ __volatile__(
	"rep ; stosl\n\t"
	"testb $2,%b3\n\t"
	"je 1f\n\t"
	"stosw\n"
	"1:\ttestb $1,%b3\n\t"
	"je 2f\n\t"
	"stosb\n"
	"2:"
	: "=&c" (d0), "=&D" (d1)
	:"a" (c), "q" (count), "0" (count/4), "1" ((long) s)
	:"memory");
return (s);	
}

/* Added by Gertjan van Wingerde to make minix and sysv module work */
#define __HAVE_ARCH_STRNLEN
static inline size_t strnlen(const char * s, size_t count)
{
int d0;
register int __res;
__asm__ __volatile__(
	"movl %2,%0\n\t"
	"jmp 2f\n"
	"1:\tcmpb $0,(%0)\n\t"
	"je 3f\n\t"
	"incl %0\n"
	"2:\tdecl %1\n\t"
	"cmpl $-1,%1\n\t"
	"jne 1b\n"
	"3:\tsubl %2,%0"
	:"=a" (__res), "=&d" (d0)
	:"c" (s),"1" (count));
return __res;
}
/* end of additional stuff */

#define __HAVE_ARCH_STRSTR

extern char *strstr(const char *cs, const char *ct);

/*
 * This looks horribly ugly, but the compiler can optimize it totally,
 * as we by now know that both pattern and count is constant..
 */
static inline void * __constant_c_and_count_memset(void * s, unsigned long pattern, size_t count)
{
    8380:	55                   	push   %ebp
    8381:	89 e5                	mov    %esp,%ebp
    8383:	83 ec 08             	sub    $0x8,%esp
    8386:	89 1c 24             	mov    %ebx,(%esp,1)
    8389:	8b 4d 10             	mov    0x10(%ebp),%ecx
    838c:	8b 55 08             	mov    0x8(%ebp),%edx
    838f:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
	switch (count) {
    8393:	83 f9 04             	cmp    $0x4,%ecx
    8396:	8b 45 0c             	mov    0xc(%ebp),%eax
    8399:	77 35                	ja     83d0 <__constant_c_and_count_memset+0x50>
    839b:	ff 24 8d 88 00 00 00 	jmp    *0x88(,%ecx,4)
		case 0:
			return s;
		case 1:
			*(unsigned char *)s = pattern;
    83a2:	88 02                	mov    %al,(%edx)
    83a4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    83aa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
			return s;
		case 2:
			*(unsigned short *)s = pattern;
			return s;
		case 3:
			*(unsigned short *)s = pattern;
			*(2+(unsigned char *)s) = pattern;
			return s;
		case 4:
			*(unsigned long *)s = pattern;
			return s;
	}
#define COMMON(x) \
__asm__  __volatile__( \
	"rep ; stosl" \
	x \
	: "=&c" (d0), "=&D" (d1) \
	: "a" (pattern),"0" (count/4),"1" ((long) s) \
	: "memory")
{
	int d0, d1;
	switch (count % 4) {
		case 0: COMMON(""); return s;
		case 1: COMMON("\n\tstosb"); return s;
		case 2: COMMON("\n\tstosw"); return s;
		default: COMMON("\n\tstosw\n\tstosb"); return s;
	}
}
  
#undef COMMON
}
    83b0:	8b 1c 24             	mov    (%esp,1),%ebx
    83b3:	89 d0                	mov    %edx,%eax
    83b5:	8b 7c 24 04          	mov    0x4(%esp,1),%edi
    83b9:	89 ec                	mov    %ebp,%esp
    83bb:	5d                   	pop    %ebp
    83bc:	c3                   	ret    
    83bd:	66 89 02             	mov    %ax,(%edx)
    83c0:	eb ee                	jmp    83b0 <__constant_c_and_count_memset+0x30>
    83c2:	66 89 02             	mov    %ax,(%edx)
    83c5:	88 42 02             	mov    %al,0x2(%edx)
    83c8:	eb e6                	jmp    83b0 <__constant_c_and_count_memset+0x30>
    83ca:	89 02                	mov    %eax,(%edx)
    83cc:	eb e2                	jmp    83b0 <__constant_c_and_count_memset+0x30>
    83ce:	89 f6                	mov    %esi,%esi
    83d0:	89 cb                	mov    %ecx,%ebx
    83d2:	83 e3 03             	and    $0x3,%ebx
    83d5:	83 fb 01             	cmp    $0x1,%ebx
    83d8:	74 36                	je     8410 <__constant_c_and_count_memset+0x90>
    83da:	83 fb 01             	cmp    $0x1,%ebx
    83dd:	72 21                	jb     8400 <__constant_c_and_count_memset+0x80>
    83df:	83 fb 02             	cmp    $0x2,%ebx
    83e2:	74 0c                	je     83f0 <__constant_c_and_count_memset+0x70>
    83e4:	c1 e9 02             	shr    $0x2,%ecx
    83e7:	89 d7                	mov    %edx,%edi
    83e9:	f3 ab                	repz stos %eax,%es:(%edi)
    83eb:	66 ab                	stos   %ax,%es:(%edi)
    83ed:	aa                   	stos   %al,%es:(%edi)
    83ee:	eb c0                	jmp    83b0 <__constant_c_and_count_memset+0x30>
    83f0:	c1 e9 02             	shr    $0x2,%ecx
    83f3:	89 d7                	mov    %edx,%edi
    83f5:	f3 ab                	repz stos %eax,%es:(%edi)
    83f7:	66 ab                	stos   %ax,%es:(%edi)
    83f9:	eb b5                	jmp    83b0 <__constant_c_and_count_memset+0x30>
    83fb:	90                   	nop    
    83fc:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    8400:	c1 e9 02             	shr    $0x2,%ecx
    8403:	89 d7                	mov    %edx,%edi
    8405:	f3 ab                	repz stos %eax,%es:(%edi)
    8407:	eb a7                	jmp    83b0 <__constant_c_and_count_memset+0x30>
    8409:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    8410:	c1 e9 02             	shr    $0x2,%ecx
    8413:	89 d7                	mov    %edx,%edi
    8415:	f3 ab                	repz stos %eax,%es:(%edi)
    8417:	aa                   	stos   %al,%es:(%edi)
    8418:	eb 96                	jmp    83b0 <__constant_c_and_count_memset+0x30>
    841a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00008420 <marshallContinuationClient>:
  } while(0)

MARSHALL_CONTINUATION(Server, 1, SERVER_COMPUTE_MAC)
MARSHALL_CONTINUATION(ServerCopyMAC, 1, CLIENT_COMPUTE_MAC)
MARSHALL_CONTINUATION(Client, 0, CLIENT_COMPUTE_MAC)
    8420:	55                   	push   %ebp
    8421:	89 e5                	mov    %esp,%ebp
    8423:	53                   	push   %ebx
    8424:	8b 4d 10             	mov    0x10(%ebp),%ecx
    8427:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    842a:	8b 41 3c             	mov    0x3c(%ecx),%eax
    842d:	89 43 09             	mov    %eax,0x9(%ebx)
    8430:	8b 41 40             	mov    0x40(%ecx),%eax
    8433:	89 43 0d             	mov    %eax,0xd(%ebx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    8436:	8b 41 34             	mov    0x34(%ecx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    8439:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    843b:	89 43 01             	mov    %eax,0x1(%ebx)
  } while(0)

MARSHALL_CONTINUATION(Server, 1, SERVER_COMPUTE_MAC)
MARSHALL_CONTINUATION(ServerCopyMAC, 1, CLIENT_COMPUTE_MAC)
MARSHALL_CONTINUATION(Client, 0, CLIENT_COMPUTE_MAC)
    843e:	0f b6 41 38          	movzbl 0x38(%ecx),%eax
    8442:	88 03                	mov    %al,(%ebx)
    8444:	0f b6 41 5c          	movzbl 0x5c(%ecx),%eax
    8448:	88 43 05             	mov    %al,0x5(%ebx)
    844b:	0f b6 41 58          	movzbl 0x58(%ecx),%eax
    844f:	88 43 2d             	mov    %al,0x2d(%ebx)
    8452:	8b 41 44             	mov    0x44(%ecx),%eax
    8455:	89 43 25             	mov    %eax,0x25(%ebx)
    8458:	8b 41 50             	mov    0x50(%ecx),%eax
    845b:	89 43 11             	mov    %eax,0x11(%ebx)
    845e:	8b 41 48             	mov    0x48(%ecx),%eax
    8461:	89 43 29             	mov    %eax,0x29(%ebx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    8464:	8b 41 60             	mov    0x60(%ecx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    8467:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    8469:	89 43 2e             	mov    %eax,0x2e(%ebx)
    846c:	8b 41 64             	mov    0x64(%ecx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    846f:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    8471:	89 43 32             	mov    %eax,0x32(%ebx)
    8474:	8b 41 68             	mov    0x68(%ecx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    8477:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    8479:	89 43 36             	mov    %eax,0x36(%ebx)
    847c:	8b 41 6c             	mov    0x6c(%ecx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    847f:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    8481:	89 43 3a             	mov    %eax,0x3a(%ebx)
    8484:	8b 41 70             	mov    0x70(%ecx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    8487:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    8489:	89 43 3e             	mov    %eax,0x3e(%ebx)
  } while(0)

MARSHALL_CONTINUATION(Server, 1, SERVER_COMPUTE_MAC)
MARSHALL_CONTINUATION(ServerCopyMAC, 1, CLIENT_COMPUTE_MAC)
MARSHALL_CONTINUATION(Client, 0, CLIENT_COMPUTE_MAC)
    848c:	8b 51 78             	mov    0x78(%ecx),%edx
    848f:	8b 41 74             	mov    0x74(%ecx),%eax
    8492:	81 c1 8c 00 00 00    	add    $0x8c,%ecx
    8498:	89 43 42             	mov    %eax,0x42(%ebx)
    849b:	89 53 46             	mov    %edx,0x46(%ebx)
    849e:	83 c3 15             	add    $0x15,%ebx
    84a1:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
    84a8:	89 4d 0c             	mov    %ecx,0xc(%ebp)
    84ab:	89 5d 08             	mov    %ebx,0x8(%ebp)
    84ae:	5b                   	pop    %ebx
    84af:	5d                   	pop    %ebp
    84b0:	e9 bb fd ff ff       	jmp    8270 <__constant_memcpy>
    84b5:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    84b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

000084c0 <marshallAckProof>:
#undef SERVER_COMPUTE_MAC
#undef CLIENT_COMPUTE_MAC
#undef HNCONVERTLONG

static inline void marshallAckProof(WireAckProof *dproof, const AckProof *sproof) {
    84c0:	55                   	push   %ebp
    84c1:	89 e5                	mov    %esp,%ebp
#define HNCONVERTLONG(X) dproof->X = htonl(sproof->X);
#define COPYLONG(X) dproof->X = sproof->X
  int i;
  dproof->numSacks = MIN(sproof->numSacks, MAXSACKS);
    84c3:	ba 40 00 00 00       	mov    $0x40,%edx
    84c8:	56                   	push   %esi
    84c9:	8b 75 0c             	mov    0xc(%ebp),%esi
    84cc:	53                   	push   %ebx
    84cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
    84d0:	8b 06                	mov    (%esi),%eax
    84d2:	39 c2                	cmp    %eax,%edx
    84d4:	0f 4f d0             	cmovg  %eax,%edx
  for(i=0; i < dproof->numSacks; i++) {
    84d7:	31 c9                	xor    %ecx,%ecx
    84d9:	84 d2                	test   %dl,%dl
    84db:	88 13                	mov    %dl,(%ebx)
    84dd:	74 38                	je     8517 <marshallAckProof+0x57>
    84df:	31 d2                	xor    %edx,%edx
    84e1:	eb 0d                	jmp    84f0 <marshallAckProof+0x30>
    84e3:	90                   	nop    
    84e4:	90                   	nop    
    84e5:	90                   	nop    
    84e6:	90                   	nop    
    84e7:	90                   	nop    
    84e8:	90                   	nop    
    84e9:	90                   	nop    
    84ea:	90                   	nop    
    84eb:	90                   	nop    
    84ec:	90                   	nop    
    84ed:	90                   	nop    
    84ee:	90                   	nop    
    84ef:	90                   	nop    
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    84f0:	8b 44 16 08          	mov    0x8(%esi,%edx,1),%eax
#define HNCONVERTLONG(X) dproof->X = htonl(sproof->X);
#define COPYLONG(X) dproof->X = sproof->X
  int i;
  dproof->numSacks = MIN(sproof->numSacks, MAXSACKS);
  for(i=0; i < dproof->numSacks; i++) {
    84f4:	41                   	inc    %ecx

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    84f5:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    84f7:	89 44 13 01          	mov    %eax,0x1(%ebx,%edx,1)
    84fb:	8b 44 16 0c          	mov    0xc(%esi,%edx,1),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    84ff:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    8501:	89 44 13 05          	mov    %eax,0x5(%ebx,%edx,1)
  dproof->numSacks = MIN(sproof->numSacks, MAXSACKS);
  for(i=0; i < dproof->numSacks; i++) {
    HNCONVERTLONG(sacks[i].left);
    HNCONVERTLONG(sacks[i].right);
    COPYLONG(sacks[i].nonceSummary);
    8505:	8b 44 16 10          	mov    0x10(%esi,%edx,1),%eax
    8509:	89 44 13 09          	mov    %eax,0x9(%ebx,%edx,1)
    850d:	83 c2 0c             	add    $0xc,%edx
    8510:	0f b6 03             	movzbl (%ebx),%eax
    8513:	39 c1                	cmp    %eax,%ecx
    8515:	7c d9                	jl     84f0 <marshallAckProof+0x30>
  }
#undef HNCONVERTLONG
#undef COPYLONG
}
    8517:	5b                   	pop    %ebx
    8518:	5e                   	pop    %esi
    8519:	5d                   	pop    %ebp
    851a:	c3                   	ret    
    851b:	90                   	nop    
    851c:	8d 74 26 00          	lea    0x0(%esi,1),%esi

00008520 <unmarshallUC_Continuation>:

#define NHCONVERTLONG(X) dcont->X = ntohl(scont->X);
#define COPYLONG(X) dcont->X = scont->X

struct sk_buff;
/* skb is used to initialize connection endpoint variables */

#define UNMARSHALL_CONTINUATION(SUFFIX, COMPUTE_MAC)			\
  static __attribute__((always_inline)) int unmarshallContinuation ## SUFFIX(struct sk_buff *skb, CONTINUATION_TYPE *dcont, const WireContinuation *scont) { \
    COMPUTE_MAC();							\
  dcont->continuationType = scont->continuationType;			\
  NHCONVERTLONG(seq);							\
									\
  dcont->clientState = scont->clientState;				\
  dcont->parent = scont->parent;					\
									\
  dcont->rawTimestamp = scont->timestamp;				\
  dcont->timestamp = ntohl(scont->timestamp);				\
  dcont->clientTimestamp = scont->clientTimestamp;			\
  dcont->rawMrtt = scont->mrtt;						\
									\
  dcont->mrtt = ntohl(scont->mrtt);					\
  dcont->state = scont->state;						\
  dcont->firstChild = scont->firstChild;				\
									\
  /* printk("unmarshall - firstLoss: %p\n", &dcont->firstLoss); */	\
  NHCONVERTLONG(firstLoss);						\
  NHCONVERTLONG(firstBootstrapSeq);					\
  NHCONVERTLONG(startCwnd);						\
  NHCONVERTLONG(ssthresh);						\
  NHCONVERTLONG(TCPBase);						\
									\
  if(unlikely(!SIMULATION_MODE(skb->sk))) {				\
	  dcont->saddr = skb->nh.iph->daddr;				\
	  dcont->daddr = skb->nh.iph->saddr;				\
	  dcont->source = skb->h.th->dest;				\
	  dcont->dest = skb->h.th->source;				\
  }									\
  dcont->num_packets = 0;						\
									\
  dcont->tokenCounterBase = scont->tokenCounterBase;			\
									\
  dcont->numChildrenReceived = 0;					\
  dcont->parentMSK = NULL;						\
									\
  return 1;								\
}

#define SERVER_COMPUTE_MAC()			\
do {						\
    if(unlikely(!SIMULATION_MODE(skb->sk))) {	\
      char mac[HMACLEN];			\
      PseudoHeader hdr, *phdr = &hdr;		\
      phdr->seq = scont->seq;			\
      phdr->type = scont->continuationType;	\
      phdr->first = scont->firstChild;		\
      phdr->serverAddr = skb->nh.iph->daddr;	\
      phdr->serverPort = skb->h.th->dest;	\
      phdr->clientAddr = skb->nh.iph->saddr;	\
      phdr->clientPort = skb->h.th->source;	\
						\
      computeMAC(skb->sk, phdr, scont, mac);	\
      if(memcmp(mac, scont->mac, HMACLEN)) {	\
	return 0;				\
      }						\
    }						\
} while(0);

#define CLIENT_COMPUTE_MAC()			\
  do{					\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
UNMARSHALL_CONTINUATION(Client, CLIENT_COMPUTE_MAC);

#undef SERVER_COMPUTE_MAC
#undef CLIENT_COMPUTE_MAC
#undef NHCONVERTLONG
#undef COPYLONG

extern int numContinuations;

#ifndef USERTEST
extern kmem_cache_t *clientSideContinuation_cache;
#endif

#define USESLAB
#define INIT2

static inline CONTINUATION_TYPE *newClientSide_Continuation(int flags) {
  int i;
#ifdef USERTEST
  CONTINUATION_TYPE *rval = kmalloc(2 * sizeof(CONTINUATION_TYPE), flags);
#else  //0426 - change kernel to slab cache

#ifndef USESLAB
  CONTINUATION_TYPE *rval = kmalloc(2 * sizeof(CONTINUATION_TYPE), flags); // 0502 maybe slab cache usage is buggy
#else
  CONTINUATION_TYPE *rval = kmem_cache_alloc(clientSideContinuation_cache, GFP_ATOMIC);
#endif
#endif

#ifdef DEBUG_TRICKLES_ALLOCATION // 0418
  numContinuations++;
#endif

  if(rval == NULL) {
    printk("out of memory while allocating continuation\n");
    return NULL;
  }

  rval->prev = rval->next = NULL;
  rval->list = NULL;
#ifdef INIT2 // 0502 - initialize only the first one (simulation is off)
  for(i=0; i < 2; i++) {
#else
  for(i=0; i < 1; i++) {
#endif
	  (rval+i)->ucont_len = 0;
	  (rval+i)->ucont_data = NULL;
	  (rval+i)->input_len = 0;
	  (rval+i)->input = NULL;
	  // 0429 null mark
	  (rval+i)->mark = 0;
	  (rval+i)->simulated = 0;
  }
  return rval;
}

static inline CONTINUATION_TYPE *copyClientSide_Continuation(CONTINUATION_TYPE *cont, int flags) {
  int i;
#ifdef USERTEST
  CONTINUATION_TYPE *rval = kmalloc(2 * sizeof(CONTINUATION_TYPE), flags);
#else  //0426 - change kernel to slab cache
#ifndef USESLAB
  CONTINUATION_TYPE *rval = kmalloc(2 * sizeof(CONTINUATION_TYPE), flags);  // 0502 maybe slab cache usage is buggy
#else
  CONTINUATION_TYPE *rval = kmem_cache_alloc(clientSideContinuation_cache, GFP_ATOMIC);
#endif
#endif

#ifdef DEBUG_TRICKLES_ALLOCATION // 0418
  numContinuations++;
#endif

  // 0501 - attempting to track down corruption bug
#ifdef DEBUG_ALLOC
#ifndef USERTEST
  if(((int)rval) & 0xfff) {
	  printk("incorrect alignment\n");
	  BUG();
  }
#endif // USERTEST
#endif // DEBUG_ALLOC

  if(rval == NULL) {
    printk("out of memory while allocating continuation to copy\n");
    return NULL;
  }
  rval->prev = rval->next = NULL;
  rval->list = NULL;

  memcpy(rval, cont, (int)((CONTINUATION_TYPE *)0)->clientside_copy_end);
  for(i=0; i < 2; i++) {
	  (rval+i)->ucont_len = 0;
	  (rval+i)->ucont_data = NULL;
	  (rval+i)->input_len = 0;
	  (rval+i)->input = NULL;
	  // 0429 null mark
	  (rval+i)->mark = 0;
	  (rval+i)->simulated = 0;
	  (rval+i)->num_packets = 0;
	  (rval+i)->actualCwnd = 0;
  }
  return rval;
}

static inline void freeClientSide_Continuation(CONTINUATION_TYPE *cont) {
  int i;
#ifdef DEBUG_TRICKLES_ALLOCATION // 0418
  numContinuations--;
#endif
#ifdef DEBUG_ALLOC
#ifndef USERTEST
  if((int)cont & 0xfff) {
	  BUG();
  }
#endif // USERTEST
#endif // DEBUG_ALLOC

  if(cont->list) {
	  BUG();
  }

  for(i=0; i < 2; i++) {
    if((cont+i)->ucont_data)
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
      kfree((cont+i)->input);
  }

#ifdef USERTEST
  kfree(cont);
#else  //0426 - change kernel to slab cache
#ifdef DEBUG_ALLOC
  zap_virt(cont);
  //memset(cont, 0x3e, sizeof(*cont));
#else
#ifndef USESLAB
  kfree(cont);  // 0502 maybe slab cache usage is buggy
#else
  kmem_cache_free(clientSideContinuation_cache, cont);
#endif
#endif
#endif
}

static inline void unmarshallAckProof(AckProof *dproof, const WireAckProof *sproof) {
#define NHCONVERTLONG(X) dproof->X = ntohl(sproof->X);
#define COPYLONG(X) dproof->X = sproof->X
  int i;
  dproof->numSacks = sproof->numSacks;
  for(i=0; i < sproof->numSacks; i++) {
    NHCONVERTLONG(sacks[i].left);
    NHCONVERTLONG(sacks[i].right);
    COPYLONG(sacks[i].nonceSummary);
  }
#undef NHCONVERTLONG
#undef COPYLONG
}

static inline struct UC_Continuation *unmarshallUC_Continuation(struct WireUC_Continuation *scont, unsigned length) {
    8520:	55                   	push   %ebp
    8521:	89 e5                	mov    %esp,%ebp
    8523:	57                   	push   %edi
    8524:	56                   	push   %esi
    8525:	53                   	push   %ebx
    8526:	83 ec 10             	sub    $0x10,%esp
    8529:	8b 45 0c             	mov    0xc(%ebp),%eax
  unsigned dataLen = length - sizeof(struct WireUC_Continuation);
  struct UC_Continuation *rval = kmalloc(sizeof(struct UC_Continuation) + dataLen, GFP_ATOMIC);
    852c:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    8533:	00 
    8534:	8b 75 08             	mov    0x8(%ebp),%esi
    8537:	8d 50 f3             	lea    0xfffffff3(%eax),%edx
    853a:	83 c0 23             	add    $0x23,%eax
    853d:	89 55 f0             	mov    %edx,0xfffffff0(%ebp)
    8540:	89 04 24             	mov    %eax,(%esp,1)
    8543:	e8 fc ff ff ff       	call   8544 <unmarshallUC_Continuation+0x24>

  if(rval == NULL) {
    8548:	85 c0                	test   %eax,%eax
    854a:	89 c3                	mov    %eax,%ebx
    854c:	74 5d                	je     85ab <unmarshallUC_Continuation+0x8b>
    printk("Out of memory while unmarshalling UC_Continuation\n");
    return NULL;
  }
  rval->prev = rval->next = NULL;
    854e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
    8555:	8d 7b 30             	lea    0x30(%ebx),%edi
  if(rval == NULL) {
    printk("Out of memory while unmarshalling UC_Continuation\n");
    return NULL;
  }
  rval->prev = rval->next = NULL;
    8558:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  rval->list = NULL;
    855e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    8565:	8b 06                	mov    (%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    8567:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    8569:	89 43 0c             	mov    %eax,0xc(%ebx)
    856c:	8b 46 04             	mov    0x4(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    856f:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    8571:	89 43 10             	mov    %eax,0x10(%ebx)
    8574:	8b 56 08             	mov    0x8(%esi),%edx

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    8577:	0f ca                	bswap  %edx
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    8579:	89 53 14             	mov    %edx,0x14(%ebx)

  rval->seq = ntohl(scont->seq);
  rval->validStart = ntohl(scont->validStart);
  rval->validEnd = ntohl(scont->validEnd);
  rval->fields = scont->fields;
    857c:	0f b6 46 0c          	movzbl 0xc(%esi),%eax
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
    8580:	83 c6 0d             	add    $0xd,%esi

  rval->seq = ntohl(scont->seq);
  rval->validStart = ntohl(scont->validStart);
  rval->validEnd = ntohl(scont->validEnd);
  rval->fields = scont->fields;
    8583:	88 43 20             	mov    %al,0x20(%ebx)
  rval->dataLen = dataLen;
    8586:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  rval->kernel.obsoleteAt = rval->validEnd;
    8589:	89 53 2c             	mov    %edx,0x2c(%ebx)

static inline void * __memcpy(void * to, const void * from, size_t n)
{
int d0, d1, d2;
__asm__ __volatile__(
    858c:	89 c1                	mov    %eax,%ecx
    858e:	c1 e9 02             	shr    $0x2,%ecx
  rval->seq = ntohl(scont->seq);
  rval->validStart = ntohl(scont->validStart);
  rval->validEnd = ntohl(scont->validEnd);
  rval->fields = scont->fields;
  rval->dataLen = dataLen;
    8591:	89 43 28             	mov    %eax,0x28(%ebx)

static inline void * __memcpy(void * to, const void * from, size_t n)
{
int d0, d1, d2;
__asm__ __volatile__(
    8594:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    8596:	a8 02                	test   $0x2,%al
    8598:	74 02                	je     859c <unmarshallUC_Continuation+0x7c>
    859a:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    859c:	a8 01                	test   $0x1,%al
    859e:	74 01                	je     85a1 <unmarshallUC_Continuation+0x81>
    85a0:	a4                   	movsb  %ds:(%esi),%es:(%edi)
  rval->fields = scont->fields;
  rval->dataLen = dataLen;
  rval->kernel.obsoleteAt = rval->validEnd;
  memcpy(rval->kernel.data, scont->data, dataLen);
  return rval;
    85a1:	89 d8                	mov    %ebx,%eax
}
    85a3:	83 c4 10             	add    $0x10,%esp
    85a6:	5b                   	pop    %ebx
    85a7:	5e                   	pop    %esi
    85a8:	5f                   	pop    %edi
    85a9:	5d                   	pop    %ebp
    85aa:	c3                   	ret    
    85ab:	c7 04 24 00 2b 00 00 	movl   $0x2b00,(%esp,1)
    85b2:	e8 fc ff ff ff       	call   85b3 <unmarshallUC_Continuation+0x93>
    85b7:	31 c0                	xor    %eax,%eax
    85b9:	eb e8                	jmp    85a3 <unmarshallUC_Continuation+0x83>
    85bb:	90                   	nop    
    85bc:	8d 74 26 00          	lea    0x0(%esi,1),%esi

000085c0 <generateCryptoSingleNonceHelper>:
    85c0:	55                   	push   %ebp
    85c1:	89 e5                	mov    %esp,%ebp
    85c3:	57                   	push   %edi
    85c4:	56                   	push   %esi
    85c5:	53                   	push   %ebx
    85c6:	83 ec 34             	sub    $0x34,%esp
    85c9:	8b 45 0c             	mov    0xc(%ebp),%eax
    85cc:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp,1)
    85d3:	00 
    85d4:	8b 55 10             	mov    0x10(%ebp),%edx
    85d7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    85de:	00 
    85df:	89 c3                	mov    %eax,%ebx
    85e1:	83 e0 03             	and    $0x3,%eax
    85e4:	0f ac d3 02          	shrd   $0x2,%edx,%ebx
    85e8:	89 d6                	mov    %edx,%esi
    85ea:	8d 55 e4             	lea    0xffffffe4(%ebp),%edx
    85ed:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    85f0:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
    85f3:	c1 ee 02             	shr    $0x2,%esi
    85f6:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    85f9:	89 14 24             	mov    %edx,(%esp,1)
    85fc:	e8 7f fd ff ff       	call   8380 <__constant_c_and_count_memset>
    8601:	8b 7d 14             	mov    0x14(%ebp),%edi
    8604:	85 ff                	test   %edi,%edi
    8606:	74 22                	je     862a <generateCryptoSingleNonceHelper+0x6a>
    8608:	8b 4d 14             	mov    0x14(%ebp),%ecx
    860b:	8b 45 14             	mov    0x14(%ebp),%eax
    860e:	83 c1 0c             	add    $0xc,%ecx
    8611:	89 4d cc             	mov    %ecx,0xffffffcc(%ebp)
    8614:	8b 08                	mov    (%eax),%ecx
    8616:	85 c9                	test   %ecx,%ecx
    8618:	0f 84 92 00 00 00    	je     86b0 <generateCryptoSingleNonceHelper+0xf0>
    861e:	89 58 04             	mov    %ebx,0x4(%eax)
    8621:	89 70 08             	mov    %esi,0x8(%eax)
    8624:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    862a:	89 5d e4             	mov    %ebx,0xffffffe4(%ebp)
    862d:	8b 55 08             	mov    0x8(%ebp),%edx
    8630:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
    8633:	89 75 e8             	mov    %esi,0xffffffe8(%ebp)
    8636:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
    8639:	89 04 24             	mov    %eax,(%esp,1)
    863c:	89 54 24 08          	mov    %edx,0x8(%esp,1)
    8640:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    8644:	e8 fc ff ff ff       	call   8645 <generateCryptoSingleNonceHelper+0x85>
    8649:	8b 55 d0             	mov    0xffffffd0(%ebp),%edx
    864c:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
    864f:	83 fa 03             	cmp    $0x3,%edx
    8652:	8b 3c 91             	mov    (%ecx,%edx,4),%edi
    8655:	74 19                	je     8670 <generateCryptoSingleNonceHelper+0xb0>
    8657:	8b 55 d0             	mov    0xffffffd0(%ebp),%edx
    865a:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
    865d:	8b 44 91 04          	mov    0x4(%ecx,%edx,4),%eax
    8661:	31 c7                	xor    %eax,%edi
    8663:	83 c4 34             	add    $0x34,%esp
    8666:	89 f8                	mov    %edi,%eax
    8668:	5b                   	pop    %ebx
    8669:	5e                   	pop    %esi
    866a:	5f                   	pop    %edi
    866b:	5d                   	pop    %ebp
    866c:	c3                   	ret    
    866d:	8d 76 00             	lea    0x0(%esi),%esi
    8670:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    8674:	8b 45 08             	mov    0x8(%ebp),%eax
    8677:	83 c3 01             	add    $0x1,%ebx
    867a:	83 d6 00             	adc    $0x0,%esi
    867d:	8d 55 e4             	lea    0xffffffe4(%ebp),%edx
    8680:	89 14 24             	mov    %edx,(%esp,1)
    8683:	89 5d e4             	mov    %ebx,0xffffffe4(%ebp)
    8686:	89 75 e8             	mov    %esi,0xffffffe8(%ebp)
    8689:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    868d:	e8 fc ff ff ff       	call   868e <generateCryptoSingleNonceHelper+0xce>
    8692:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
    8695:	8b 45 14             	mov    0x14(%ebp),%eax
    8698:	8b 11                	mov    (%ecx),%edx
    869a:	31 d7                	xor    %edx,%edi
    869c:	85 c0                	test   %eax,%eax
    869e:	74 c3                	je     8663 <generateCryptoSingleNonceHelper+0xa3>
    86a0:	8b 45 14             	mov    0x14(%ebp),%eax
    86a3:	89 58 04             	mov    %ebx,0x4(%eax)
    86a6:	89 70 08             	mov    %esi,0x8(%eax)
    86a9:	eb b8                	jmp    8663 <generateCryptoSingleNonceHelper+0xa3>
    86ab:	90                   	nop    
    86ac:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    86b0:	8b 4d 14             	mov    0x14(%ebp),%ecx
    86b3:	8b 51 08             	mov    0x8(%ecx),%edx
    86b6:	8b 41 04             	mov    0x4(%ecx),%eax
    86b9:	89 d1                	mov    %edx,%ecx
    86bb:	31 f1                	xor    %esi,%ecx
    86bd:	31 d8                	xor    %ebx,%eax
    86bf:	09 c1                	or     %eax,%ecx
    86c1:	74 86                	je     8649 <generateCryptoSingleNonceHelper+0x89>
    86c3:	8b 45 14             	mov    0x14(%ebp),%eax
    86c6:	89 58 04             	mov    %ebx,0x4(%eax)
    86c9:	89 70 08             	mov    %esi,0x8(%eax)
    86cc:	e9 59 ff ff ff       	jmp    862a <generateCryptoSingleNonceHelper+0x6a>
    86d1:	eb 0d                	jmp    86e0 <processIncompleteResponse>
    86d3:	90                   	nop    
    86d4:	90                   	nop    
    86d5:	90                   	nop    
    86d6:	90                   	nop    
    86d7:	90                   	nop    
    86d8:	90                   	nop    
    86d9:	90                   	nop    
    86da:	90                   	nop    
    86db:	90                   	nop    
    86dc:	90                   	nop    
    86dd:	90                   	nop    
    86de:	90                   	nop    
    86df:	90                   	nop    

000086e0 <processIncompleteResponse>:
    86e0:	55                   	push   %ebp
    86e1:	89 e5                	mov    %esp,%ebp
    86e3:	57                   	push   %edi
    86e4:	56                   	push   %esi
    86e5:	53                   	push   %ebx
    86e6:	83 ec 20             	sub    $0x20,%esp
    86e9:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
    86f0:	8b 45 08             	mov    0x8(%ebp),%eax
    86f3:	8b 7d 0c             	mov    0xc(%ebp),%edi
    86f6:	05 bc 00 00 00       	add    $0xbc,%eax
    86fb:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    86fe:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    8701:	8b 47 04             	mov    0x4(%edi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    8704:	0f c8                	bswap  %eax
    8706:	8b 91 c4 0a 00 00    	mov    0xac4(%ecx),%edx
    870c:	39 d0                	cmp    %edx,%eax
    870e:	89 d1                	mov    %edx,%ecx
    8710:	76 19                	jbe    872b <processIncompleteResponse+0x4b>
    8712:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    8715:	8b 93 cc 0a 00 00    	mov    0xacc(%ebx),%edx
    871b:	89 83 c4 0a 00 00    	mov    %eax,0xac4(%ebx)
    8721:	39 d0                	cmp    %edx,%eax
    8723:	0f 87 55 03 00 00    	ja     8a7e <processIncompleteResponse+0x39e>
    8729:	89 c2                	mov    %eax,%edx
    872b:	39 ca                	cmp    %ecx,%edx
    872d:	75 16                	jne    8745 <processIncompleteResponse+0x65>
    872f:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    8732:	8b 81 c8 0a 00 00    	mov    0xac8(%ecx),%eax
    8738:	29 d0                	sub    %edx,%eax
    873a:	3d 51 05 00 00       	cmp    $0x551,%eax
    873f:	0f 87 30 03 00 00    	ja     8a75 <processIncompleteResponse+0x395>
    8745:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    8748:	8b 98 d0 0a 00 00    	mov    0xad0(%eax),%ebx
    874e:	89 c6                	mov    %eax,%esi
    8750:	81 c6 d0 0a 00 00    	add    $0xad0,%esi
    8756:	39 f3                	cmp    %esi,%ebx
    8758:	74 70                	je     87ca <processIncompleteResponse+0xea>
    875a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    8760:	39 53 44             	cmp    %edx,0x44(%ebx)
    8763:	77 51                	ja     87b6 <processIncompleteResponse+0xd6>
    8765:	89 d9                	mov    %ebx,%ecx
    8767:	8b 5b 04             	mov    0x4(%ebx),%ebx
static inline void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
{
	struct sk_buff * next, * prev;

	list->qlen--;
    876a:	ff 4e 08             	decl   0x8(%esi)
	next = skb->next;
	prev = skb->prev;
	skb->next = NULL;
	skb->prev = NULL;
	skb->list = NULL;
    876d:	c7 41 08 00 00 00 00 	movl   $0x0,0x8(%ecx)
    8774:	8b 41 04             	mov    0x4(%ecx),%eax
    8777:	8b 11                	mov    (%ecx),%edx
    8779:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
    8780:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	next->prev = prev;
    8786:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    8789:	89 10                	mov    %edx,(%eax)
    878b:	8b 81 84 00 00 00    	mov    0x84(%ecx),%eax
    8791:	48                   	dec    %eax
    8792:	74 11                	je     87a5 <processIncompleteResponse+0xc5>
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
	unsigned char c;

	__asm__ __volatile__(
    8794:	ff 89 84 00 00 00    	decl   0x84(%ecx)
    879a:	0f 94 c0             	sete   %al
    879d:	84 c0                	test   %al,%al
    879f:	0f 84 c2 02 00 00    	je     8a67 <processIncompleteResponse+0x387>
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
		__kfree_skb(skb);
    87a5:	89 0c 24             	mov    %ecx,(%esp,1)
    87a8:	e8 fc ff ff ff       	call   87a9 <processIncompleteResponse+0xc9>
    87ad:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    87b0:	8b 91 c4 0a 00 00    	mov    0xac4(%ecx),%edx
    87b6:	39 53 40             	cmp    %edx,0x40(%ebx)
    87b9:	77 09                	ja     87c4 <processIncompleteResponse+0xe4>
    87bb:	39 53 44             	cmp    %edx,0x44(%ebx)
    87be:	0f 87 97 02 00 00    	ja     8a5b <processIncompleteResponse+0x37b>
    87c4:	8b 1b                	mov    (%ebx),%ebx
    87c6:	39 f3                	cmp    %esi,%ebx
    87c8:	75 96                	jne    8760 <processIncompleteResponse+0x80>
    87ca:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp,1)
    87d1:	e8 fc ff ff ff       	call   87d2 <processIncompleteResponse+0xf2>
    87d6:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    87d9:	85 c0                	test   %eax,%eax
    87db:	0f 84 71 02 00 00    	je     8a52 <processIncompleteResponse+0x372>
    87e1:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    87e8:	00 
    87e9:	8b 55 10             	mov    0x10(%ebp),%edx
    87ec:	8d 77 08             	lea    0x8(%edi),%esi
    87ef:	83 ea 08             	sub    $0x8,%edx
    87f2:	89 55 e4             	mov    %edx,0xffffffe4(%ebp)
    87f5:	89 14 24             	mov    %edx,(%esp,1)
    87f8:	e8 fc ff ff ff       	call   87f9 <processIncompleteResponse+0x119>
    87fd:	85 c0                	test   %eax,%eax
    87ff:	89 c2                	mov    %eax,%edx
    8801:	0f 84 38 02 00 00    	je     8a3f <processIncompleteResponse+0x35f>

static inline void * __memcpy(void * to, const void * from, size_t n)
{
int d0, d1, d2;
__asm__ __volatile__(
    8807:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
    880a:	89 c7                	mov    %eax,%edi
    880c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    880f:	c1 e9 02             	shr    $0x2,%ecx
    8812:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    8814:	a8 02                	test   $0x2,%al
    8816:	74 02                	je     881a <processIncompleteResponse+0x13a>
    8818:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    881a:	a8 01                	test   $0x1,%al
    881c:	74 01                	je     881f <processIncompleteResponse+0x13f>
    881e:	a4                   	movsb  %ds:(%esi),%es:(%edi)
    881f:	89 d7                	mov    %edx,%edi
    8821:	85 ff                	test   %edi,%edi
    8823:	0f 84 f5 01 00 00    	je     8a1e <processIncompleteResponse+0x33e>
    8829:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    882c:	85 d2                	test   %edx,%edx
    882e:	0f 85 b7 00 00 00    	jne    88eb <processIncompleteResponse+0x20b>
    8834:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    8837:	8b 81 dc 0a 00 00    	mov    0xadc(%ecx),%eax
    883d:	85 c0                	test   %eax,%eax
    883f:	0f 85 8d 00 00 00    	jne    88d2 <processIncompleteResponse+0x1f2>
    8845:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    8848:	b8 02 00 00 00       	mov    $0x2,%eax
    884d:	89 83 c0 0a 00 00    	mov    %eax,0xac0(%ebx)
    8853:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    8856:	89 83 dc 0a 00 00    	mov    %eax,0xadc(%ebx)
};

static inline void resetRequest(struct Request *req) {
	req->numChildren = 0;
	req->childrenMask = 0;
    885c:	80 60 14 f0          	andb   $0xf0,0x14(%eax)
	req->transport_seq = -1;
	req->seq = -1;
	req->isNew = 1;
}

static inline void initRequest(struct Request *req, enum UserRequestType type) {
	/* Initialize generic fields */
	req->type = type;
    8860:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	req->prev = req->next = NULL;
    8867:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    886e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	req->list = NULL;
    8874:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    887b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    8882:	c7 40 38 ff ff ff ff 	movl   $0xffffffff,0x38(%eax)
    8889:	c7 40 3c ff ff ff ff 	movl   $0xffffffff,0x3c(%eax)
    8890:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    8893:	0f b6 42 48          	movzbl 0x48(%edx),%eax
	resetRequest(req);
	req->start = req->end = -1;
    8897:	c7 42 44 ff ff ff ff 	movl   $0xffffffff,0x44(%edx)
    889e:	c7 42 40 ff ff ff ff 	movl   $0xffffffff,0x40(%edx)
	req->allocated = 1;
}

void resetClientTimer(struct sock *sk);

static inline void queueNewRequest(struct sock *sk, struct Request *req) {
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	insert_tail(&tp->t.queuedRequests, (struct alloc_head*)req);
	tp->t.timerState |= TRICKLES_ENABLE_DATA_TIMEOUT;
	resetClientTimer(sk);
}

struct ConversionRequest {
	REQUEST_FIELDS

	bool incomplete; //  0 = complete, 1 = incomplete
	// First skb that contains data to convert
	struct sk_buff *data;
	// Offset within sk_buff
	unsigned offset;
#if 0
	// Length to send. If necessary, consult successors to 'data'
	unsigned length;
	// if length == 0, length is undefined and should be set in sendAck (possibly performing fragmentation)
#endif

	unsigned predLength;
	union {
		struct WireUC_CVT_IncompleteContinuation *incompletePred;
		struct UC_Continuation *completePred;
	};
};

static inline void initCompleteConversionRequest(struct ConversionRequest *req, struct UC_Continuation *pred, struct sk_buff *data, unsigned offset) {
	initRequest((struct Request *)req, MREQ_CONVERSION);
	req->incomplete = 0;
	req->completePred = pred;
	atomic_inc(&req->completePred->refcnt);
#if 1 // 0707
	if(atomic_read(&req->completePred->refcnt) < 2) {
		printk("refcnt should be > 1!\n");
	}
#endif
	req->data = data;
	req->offset = offset;
}

static inline void initIncompleteConversionRequest(struct ConversionRequest *req, struct WireUC_CVT_IncompleteContinuation *pred, unsigned predLength, struct sk_buff *data, unsigned offset) {
	initRequest((struct Request *)req, MREQ_CONVERSION);
	req->incomplete = 1;
    88a5:	c7 42 54 01 00 00 00 	movl   $0x1,0x54(%edx)
    88ac:	0c 03                	or     $0x3,%al
    88ae:	88 42 48             	mov    %al,0x48(%edx)
	req->incompletePred = pred;
    88b1:	89 7a 64             	mov    %edi,0x64(%edx)
	req->predLength = predLength;
    88b4:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
	req->data = data;
    88b7:	c7 42 58 00 00 00 00 	movl   $0x0,0x58(%edx)
	req->offset = offset;
    88be:	c7 42 5c ff ff ff ff 	movl   $0xffffffff,0x5c(%edx)
    88c5:	89 4a 60             	mov    %ecx,0x60(%edx)
    88c8:	31 c0                	xor    %eax,%eax
    88ca:	83 c4 20             	add    $0x20,%esp
    88cd:	5b                   	pop    %ebx
    88ce:	5e                   	pop    %esi
    88cf:	5f                   	pop    %edi
    88d0:	5d                   	pop    %ebp
    88d1:	c3                   	ret    
    88d2:	c7 44 24 04 99 04 00 	movl   $0x499,0x4(%esp,1)
    88d9:	00 
    88da:	c7 04 24 40 2b 00 00 	movl   $0x2b40,(%esp,1)
    88e1:	e8 fc ff ff ff       	call   88e2 <processIncompleteResponse+0x202>
    88e6:	e9 5a ff ff ff       	jmp    8845 <processIncompleteResponse+0x165>
    88eb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    88ee:	8b 80 dc 0a 00 00    	mov    0xadc(%eax),%eax
    88f4:	85 c0                	test   %eax,%eax
    88f6:	0f 85 09 01 00 00    	jne    8a05 <processIncompleteResponse+0x325>
    88fc:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    88ff:	b8 01 00 00 00       	mov    $0x1,%eax
    8904:	89 82 c0 0a 00 00    	mov    %eax,0xac0(%edx)
    890a:	31 c0                	xor    %eax,%eax
    890c:	89 82 dc 0a 00 00    	mov    %eax,0xadc(%edx)
	req->data = data;
	req->offset = offset;
}

static inline void initIncompleteConversionRequest(struct ConversionRequest *req, struct WireUC_CVT_IncompleteContinuation *pred, unsigned predLength, struct sk_buff *data, unsigned offset) {
    8912:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    8915:	8b 43 40             	mov    0x40(%ebx),%eax
    8918:	8b 91 c4 0a 00 00    	mov    0xac4(%ecx),%edx
    891e:	29 c2                	sub    %eax,%edx
    8920:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    8923:	80 60 14 f0          	andb   $0xf0,0x14(%eax)
    8927:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    892e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    8935:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    893b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    8942:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    8949:	c7 40 38 ff ff ff ff 	movl   $0xffffffff,0x38(%eax)
    8950:	c7 40 3c ff ff ff ff 	movl   $0xffffffff,0x3c(%eax)
    8957:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    895a:	0f b6 41 48          	movzbl 0x48(%ecx),%eax
    895e:	c7 41 44 ff ff ff ff 	movl   $0xffffffff,0x44(%ecx)
    8965:	c7 41 40 ff ff ff ff 	movl   $0xffffffff,0x40(%ecx)
	initRequest((struct Request *)req, MREQ_CONVERSION);
	req->incomplete = 1;
    896c:	c7 41 54 01 00 00 00 	movl   $0x1,0x54(%ecx)
    8973:	0c 03                	or     $0x3,%al
    8975:	88 41 48             	mov    %al,0x48(%ecx)
	req->incompletePred = pred;
    8978:	89 79 64             	mov    %edi,0x64(%ecx)
	req->predLength = predLength;
    897b:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
	req->data = data;
    897e:	89 59 58             	mov    %ebx,0x58(%ecx)
	req->offset = offset;
    8981:	89 51 5c             	mov    %edx,0x5c(%ecx)
    8984:	89 41 60             	mov    %eax,0x60(%ecx)
    8987:	8b 75 08             	mov    0x8(%ebp),%esi
	elem->list = head;
	head->len++;
}

static inline void insert_tail(struct alloc_head_list *head, struct alloc_head *elem) {
    898a:	8b 5d 08             	mov    0x8(%ebp),%ebx
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
    898d:	8b 55 08             	mov    0x8(%ebp),%edx

void resetClientTimer(struct sock *sk);

static inline void queueNewRequest(struct sock *sk, struct Request *req) {
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    8990:	81 c6 bc 00 00 00    	add    $0xbc,%esi
	elem->list = head;
	head->len++;
}

static inline void insert_tail(struct alloc_head_list *head, struct alloc_head *elem) {
    8996:	81 c3 38 0b 00 00    	add    $0xb38,%ebx
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
    899c:	39 8a 38 0b 00 00    	cmp    %ecx,0xb38(%edx)
    89a2:	74 3a                	je     89de <processIncompleteResponse+0x2fe>
		BUG();
		show_stack(NULL);
	}
	elem->prev = head->prev;
    89a4:	8b 4d 08             	mov    0x8(%ebp),%ecx
    89a7:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
    89aa:	8b 81 38 0b 00 00    	mov    0xb38(%ecx),%eax
    89b0:	89 07                	mov    %eax,(%edi)
	head->prev->next = elem;
    89b2:	8b 81 38 0b 00 00    	mov    0xb38(%ecx),%eax

	elem->next = (struct alloc_head*)head;

	elem->list = head;
    89b8:	89 5f 08             	mov    %ebx,0x8(%edi)
    89bb:	89 78 04             	mov    %edi,0x4(%eax)
    89be:	89 5f 04             	mov    %ebx,0x4(%edi)
	head->prev = elem;
	head->len++;
    89c1:	ff 43 10             	incl   0x10(%ebx)
    89c4:	89 b9 38 0b 00 00    	mov    %edi,0xb38(%ecx)

static inline void queueNewRequest(struct sock *sk, struct Request *req) {
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	insert_tail(&tp->t.queuedRequests, (struct alloc_head*)req);
	tp->t.timerState |= TRICKLES_ENABLE_DATA_TIMEOUT;
    89ca:	83 8e d8 02 00 00 01 	orl    $0x1,0x2d8(%esi)
	resetClientTimer(sk);
    89d1:	89 0c 24             	mov    %ecx,(%esp,1)
    89d4:	e8 fc ff ff ff       	call   89d5 <processIncompleteResponse+0x2f5>
    89d9:	e9 ea fe ff ff       	jmp    88c8 <processIncompleteResponse+0x1e8>
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
		BUG();
    89de:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    89e5:	00 
    89e6:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    89ed:	e8 fc ff ff ff       	call   89ee <processIncompleteResponse+0x30e>
    89f2:	e8 fc ff ff ff       	call   89f3 <processIncompleteResponse+0x313>
		show_stack(NULL);
    89f7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    89fe:	e8 fc ff ff ff       	call   89ff <processIncompleteResponse+0x31f>
    8a03:	eb 9f                	jmp    89a4 <processIncompleteResponse+0x2c4>
    8a05:	c7 44 24 04 a2 04 00 	movl   $0x4a2,0x4(%esp,1)
    8a0c:	00 
    8a0d:	c7 04 24 40 2b 00 00 	movl   $0x2b40,(%esp,1)
    8a14:	e8 fc ff ff ff       	call   8a15 <processIncompleteResponse+0x335>
    8a19:	e9 de fe ff ff       	jmp    88fc <processIncompleteResponse+0x21c>
    8a1e:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    8a21:	89 14 24             	mov    %edx,(%esp,1)
    8a24:	e8 fc ff ff ff       	call   8a25 <processIncompleteResponse+0x345>
    8a29:	c7 04 24 35 05 00 00 	movl   $0x535,(%esp,1)
    8a30:	e8 fc ff ff ff       	call   8a31 <processIncompleteResponse+0x351>
    8a35:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    8a3a:	e9 8b fe ff ff       	jmp    88ca <processIncompleteResponse+0x1ea>
    8a3f:	c7 04 24 53 05 00 00 	movl   $0x553,(%esp,1)
    8a46:	31 ff                	xor    %edi,%edi
    8a48:	e8 fc ff ff ff       	call   8a49 <processIncompleteResponse+0x369>
    8a4d:	e9 cf fd ff ff       	jmp    8821 <processIncompleteResponse+0x141>
    8a52:	c7 04 24 a0 2b 00 00 	movl   $0x2ba0,(%esp,1)
    8a59:	eb d5                	jmp    8a30 <processIncompleteResponse+0x350>
    8a5b:	c7 45 e8 01 00 00 00 	movl   $0x1,0xffffffe8(%ebp)
    8a62:	e9 63 fd ff ff       	jmp    87ca <processIncompleteResponse+0xea>
    8a67:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    8a6a:	8b 90 c4 0a 00 00    	mov    0xac4(%eax),%edx
    8a70:	e9 41 fd ff ff       	jmp    87b6 <processIncompleteResponse+0xd6>
    8a75:	c7 04 24 00 2c 00 00 	movl   $0x2c00,(%esp,1)
    8a7c:	eb b2                	jmp    8a30 <processIncompleteResponse+0x350>
    8a7e:	89 54 24 08          	mov    %edx,0x8(%esp,1)
    8a82:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    8a86:	c7 04 24 60 2c 00 00 	movl   $0x2c60,(%esp,1)
    8a8d:	e8 fc ff ff ff       	call   8a8e <processIncompleteResponse+0x3ae>
    8a92:	8b 83 cc 0a 00 00    	mov    0xacc(%ebx),%eax
    8a98:	89 83 c4 0a 00 00    	mov    %eax,0xac4(%ebx)
    8a9e:	eb 95                	jmp    8a35 <processIncompleteResponse+0x355>

00008aa0 <addNewUC_Continuation>:
    8aa0:	55                   	push   %ebp
    8aa1:	89 e5                	mov    %esp,%ebp
    8aa3:	57                   	push   %edi
    8aa4:	56                   	push   %esi
    8aa5:	53                   	push   %ebx
    8aa6:	83 ec 40             	sub    $0x40,%esp
    8aa9:	8b 4d 08             	mov    0x8(%ebp),%ecx
    8aac:	8b 55 08             	mov    0x8(%ebp),%edx
    8aaf:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    8ab2:	81 c1 bc 00 00 00    	add    $0xbc,%ecx
    8ab8:	8b b1 e4 0a 00 00    	mov    0xae4(%ecx),%esi
    8abe:	81 c2 a0 0b 00 00    	add    $0xba0,%edx
    8ac4:	39 d6                	cmp    %edx,%esi
    8ac6:	0f 84 68 04 00 00    	je     8f34 <addNewUC_Continuation+0x494>
    8acc:	8b 43 10             	mov    0x10(%ebx),%eax
    8acf:	89 55 c0             	mov    %edx,0xffffffc0(%ebp)
    8ad2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    8ad9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
    8ae0:	39 46 18             	cmp    %eax,0x18(%esi)
    8ae3:	72 07                	jb     8aec <addNewUC_Continuation+0x4c>
    8ae5:	8b 36                	mov    (%esi),%esi
    8ae7:	3b 75 c0             	cmp    0xffffffc0(%ebp),%esi
    8aea:	75 f4                	jne    8ae0 <addNewUC_Continuation+0x40>
    8aec:	89 43 18             	mov    %eax,0x18(%ebx)
    8aef:	8b 43 14             	mov    0x14(%ebx),%eax
    8af2:	89 43 1c             	mov    %eax,0x1c(%ebx)
	elem->list->len--;
	elem->list = NULL;
}

static inline void insert(struct alloc_head *elem, struct alloc_head *prev, struct alloc_head *next) {
    8af5:	8b 46 04             	mov    0x4(%esi),%eax
    8af8:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
	if(prev->next != next || next->prev != prev) {
		BUG();
	}
#endif

	if(!(elem->next == NULL && elem->prev == NULL)) BUG();
    8afb:	8b 53 04             	mov    0x4(%ebx),%edx
    8afe:	85 d2                	test   %edx,%edx
    8b00:	75 06                	jne    8b08 <addNewUC_Continuation+0x68>
    8b02:	8b 3b                	mov    (%ebx),%edi
    8b04:	85 ff                	test   %edi,%edi
    8b06:	74 1c                	je     8b24 <addNewUC_Continuation+0x84>
    8b08:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    8b0f:	00 
    8b10:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    8b17:	e8 fc ff ff ff       	call   8b18 <addNewUC_Continuation+0x78>
    8b1c:	e8 fc ff ff ff       	call   8b1d <addNewUC_Continuation+0x7d>
    8b21:	8b 46 04             	mov    0x4(%esi),%eax
	elem->next = prev->next;
    8b24:	89 43 04             	mov    %eax,0x4(%ebx)
	prev->next = elem;

	elem->prev = prev;
	next->prev = elem;

	elem->list = prev->list;
    8b27:	8b 46 08             	mov    0x8(%esi),%eax
    8b2a:	89 f1                	mov    %esi,%ecx
	if(!(elem->next == NULL && elem->prev == NULL)) BUG();
	elem->next = prev->next;
	prev->next = elem;

	elem->prev = prev;
    8b2c:	89 33                	mov    %esi,(%ebx)
    8b2e:	89 5e 04             	mov    %ebx,0x4(%esi)
	next->prev = elem;
    8b31:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx

	elem->list = prev->list;
    8b34:	89 43 08             	mov    %eax,0x8(%ebx)
    8b37:	89 1a                	mov    %ebx,(%edx)
	elem->list->len++;
    8b39:	ff 40 10             	incl   0x10(%eax)
    8b3c:	3b 75 c0             	cmp    0xffffffc0(%ebp),%esi
    8b3f:	0f 84 e4 03 00 00    	je     8f29 <addNewUC_Continuation+0x489>
    8b45:	8b 5b 1c             	mov    0x1c(%ebx),%ebx
    8b48:	89 5d ec             	mov    %ebx,0xffffffec(%ebp)
    8b4b:	8b 51 04             	mov    0x4(%ecx),%edx
    8b4e:	3b 55 c0             	cmp    0xffffffc0(%ebp),%edx
    8b51:	0f 84 62 02 00 00    	je     8db9 <addNewUC_Continuation+0x319>
    8b57:	89 f6                	mov    %esi,%esi
    8b59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
    8b60:	8b 41 18             	mov    0x18(%ecx),%eax
    8b63:	89 d6                	mov    %edx,%esi
    8b65:	8b 7a 18             	mov    0x18(%edx),%edi
    8b68:	39 c7                	cmp    %eax,%edi
    8b6a:	0f 43 c7             	cmovae %edi,%eax
    8b6d:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    8b70:	8b 41 1c             	mov    0x1c(%ecx),%eax
    8b73:	8b 5a 1c             	mov    0x1c(%edx),%ebx
    8b76:	39 c3                	cmp    %eax,%ebx
    8b78:	0f 46 c3             	cmovbe %ebx,%eax
    8b7b:	39 45 e8             	cmp    %eax,0xffffffe8(%ebp)
    8b7e:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    8b81:	0f 83 1a 02 00 00    	jae    8da1 <addNewUC_Continuation+0x301>
    8b87:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
    8b8e:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
    8b95:	8b 31                	mov    (%ecx),%esi
    8b97:	89 75 d4             	mov    %esi,0xffffffd4(%ebp)
    8b9a:	89 75 d8             	mov    %esi,0xffffffd8(%ebp)
    8b9d:	8b 7a 04             	mov    0x4(%edx),%edi
    8ba0:	89 7d d0             	mov    %edi,0xffffffd0(%ebp)
    8ba3:	8b 42 0c             	mov    0xc(%edx),%eax
    8ba6:	39 41 0c             	cmp    %eax,0xc(%ecx)
    8ba9:	0f 86 71 03 00 00    	jbe    8f20 <addNewUC_Continuation+0x480>
    8baf:	89 d6                	mov    %edx,%esi
    8bb1:	89 cb                	mov    %ecx,%ebx
    8bb3:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    8bb6:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    8bb9:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
    8bbc:	39 46 18             	cmp    %eax,0x18(%esi)
    8bbf:	0f 42 d6             	cmovb  %esi,%edx
    8bc2:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
    8bc5:	39 4e 1c             	cmp    %ecx,0x1c(%esi)
    8bc8:	0f 86 f3 02 00 00    	jbe    8ec1 <addNewUC_Continuation+0x421>
    8bce:	39 f2                	cmp    %esi,%edx
    8bd0:	0f 84 13 02 00 00    	je     8de9 <addNewUC_Continuation+0x349>
    8bd6:	89 75 dc             	mov    %esi,0xffffffdc(%ebp)
    8bd9:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    8bdc:	85 d2                	test   %edx,%edx
    8bde:	74 38                	je     8c18 <addNewUC_Continuation+0x178>
    8be0:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    8be3:	8b 4a 08             	mov    0x8(%edx),%ecx
    8be6:	85 c9                	test   %ecx,%ecx
    8be8:	74 25                	je     8c0f <addNewUC_Continuation+0x16f>
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    8bea:	8b 42 04             	mov    0x4(%edx),%eax
    8bed:	89 d6                	mov    %edx,%esi
    8bef:	8b 12                	mov    (%edx),%edx
    8bf1:	89 10                	mov    %edx,(%eax)
	elem->prev->next = elem->next;
    8bf3:	8b 16                	mov    (%esi),%edx
	elem->prev = elem->next = NULL;
    8bf5:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    8bfb:	89 42 04             	mov    %eax,0x4(%edx)
    8bfe:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)

	elem->list->len--;
    8c05:	ff 49 10             	decl   0x10(%ecx)
	elem->list = NULL;
    8c08:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    8c0f:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    8c12:	8b 7d e0             	mov    0xffffffe0(%ebp),%edi
    8c15:	89 47 1c             	mov    %eax,0x1c(%edi)
    8c18:	85 db                	test   %ebx,%ebx
    8c1a:	74 2a                	je     8c46 <addNewUC_Continuation+0x1a6>
    8c1c:	8b 4b 08             	mov    0x8(%ebx),%ecx
    8c1f:	85 c9                	test   %ecx,%ecx
    8c21:	74 23                	je     8c46 <addNewUC_Continuation+0x1a6>
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    8c23:	8b 43 04             	mov    0x4(%ebx),%eax
    8c26:	8b 13                	mov    (%ebx),%edx
    8c28:	89 10                	mov    %edx,(%eax)
	elem->prev->next = elem->next;
    8c2a:	8b 13                	mov    (%ebx),%edx
	elem->prev = elem->next = NULL;
    8c2c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    8c32:	89 42 04             	mov    %eax,0x4(%edx)
    8c35:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)

	elem->list->len--;
    8c3c:	ff 49 10             	decl   0x10(%ecx)
	elem->list = NULL;
    8c3f:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    8c46:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    8c49:	85 c0                	test   %eax,%eax
    8c4b:	74 38                	je     8c85 <addNewUC_Continuation+0x1e5>
    8c4d:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    8c50:	8b 4a 08             	mov    0x8(%edx),%ecx
    8c53:	85 c9                	test   %ecx,%ecx
    8c55:	74 25                	je     8c7c <addNewUC_Continuation+0x1dc>
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    8c57:	8b 42 04             	mov    0x4(%edx),%eax
    8c5a:	89 d6                	mov    %edx,%esi
    8c5c:	8b 12                	mov    (%edx),%edx
    8c5e:	89 10                	mov    %edx,(%eax)
	elem->prev->next = elem->next;
    8c60:	8b 16                	mov    (%esi),%edx
	elem->prev = elem->next = NULL;
    8c62:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    8c68:	89 42 04             	mov    %eax,0x4(%edx)
    8c6b:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)

	elem->list->len--;
    8c72:	ff 49 10             	decl   0x10(%ecx)
	elem->list = NULL;
    8c75:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    8c7c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    8c7f:	8b 7d dc             	mov    0xffffffdc(%ebp),%edi
    8c82:	89 47 18             	mov    %eax,0x18(%edi)
    8c85:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    8c88:	85 c0                	test   %eax,%eax
    8c8a:	74 4b                	je     8cd7 <addNewUC_Continuation+0x237>
		BUG();
	}
#endif

	if(!(elem->next == NULL && elem->prev == NULL)) BUG();
    8c8c:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    8c8f:	8b 42 04             	mov    0x4(%edx),%eax
    8c92:	85 c0                	test   %eax,%eax
    8c94:	75 06                	jne    8c9c <addNewUC_Continuation+0x1fc>
    8c96:	8b 02                	mov    (%edx),%eax
    8c98:	85 c0                	test   %eax,%eax
    8c9a:	74 19                	je     8cb5 <addNewUC_Continuation+0x215>
    8c9c:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    8ca3:	00 
    8ca4:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    8cab:	e8 fc ff ff ff       	call   8cac <addNewUC_Continuation+0x20c>
    8cb0:	e8 fc ff ff ff       	call   8cb1 <addNewUC_Continuation+0x211>
	elem->next = prev->next;
    8cb5:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
    8cb8:	8b 75 e0             	mov    0xffffffe0(%ebp),%esi
    8cbb:	8b 41 04             	mov    0x4(%ecx),%eax
	prev->next = elem;

	elem->prev = prev;
    8cbe:	89 0e                	mov    %ecx,(%esi)
    8cc0:	89 46 04             	mov    %eax,0x4(%esi)
	next->prev = elem;

	elem->list = prev->list;
    8cc3:	8b 41 08             	mov    0x8(%ecx),%eax
    8cc6:	89 71 04             	mov    %esi,0x4(%ecx)
    8cc9:	8b 7d d0             	mov    0xffffffd0(%ebp),%edi
    8ccc:	89 46 08             	mov    %eax,0x8(%esi)
    8ccf:	89 37                	mov    %esi,(%edi)
	elem->list->len++;
    8cd1:	ff 40 10             	incl   0x10(%eax)
    8cd4:	89 75 d8             	mov    %esi,0xffffffd8(%ebp)
    8cd7:	85 db                	test   %ebx,%ebx
    8cd9:	74 45                	je     8d20 <addNewUC_Continuation+0x280>
		BUG();
	}
#endif

	if(!(elem->next == NULL && elem->prev == NULL)) BUG();
    8cdb:	8b 43 04             	mov    0x4(%ebx),%eax
    8cde:	85 c0                	test   %eax,%eax
    8ce0:	75 06                	jne    8ce8 <addNewUC_Continuation+0x248>
    8ce2:	8b 03                	mov    (%ebx),%eax
    8ce4:	85 c0                	test   %eax,%eax
    8ce6:	74 19                	je     8d01 <addNewUC_Continuation+0x261>
    8ce8:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    8cef:	00 
    8cf0:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    8cf7:	e8 fc ff ff ff       	call   8cf8 <addNewUC_Continuation+0x258>
    8cfc:	e8 fc ff ff ff       	call   8cfd <addNewUC_Continuation+0x25d>
	elem->next = prev->next;
    8d01:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    8d04:	8b 42 04             	mov    0x4(%edx),%eax
	prev->next = elem;

	elem->prev = prev;
    8d07:	89 13                	mov    %edx,(%ebx)
    8d09:	89 43 04             	mov    %eax,0x4(%ebx)
	next->prev = elem;

	elem->list = prev->list;
    8d0c:	8b 42 08             	mov    0x8(%edx),%eax
    8d0f:	89 5a 04             	mov    %ebx,0x4(%edx)
    8d12:	8b 4d d0             	mov    0xffffffd0(%ebp),%ecx
    8d15:	89 43 08             	mov    %eax,0x8(%ebx)
    8d18:	89 19                	mov    %ebx,(%ecx)
	elem->list->len++;
    8d1a:	ff 40 10             	incl   0x10(%eax)
    8d1d:	89 5d d8             	mov    %ebx,0xffffffd8(%ebp)
    8d20:	8b 7d dc             	mov    0xffffffdc(%ebp),%edi
    8d23:	85 ff                	test   %edi,%edi
    8d25:	74 48                	je     8d6f <addNewUC_Continuation+0x2cf>
		BUG();
	}
#endif

	if(!(elem->next == NULL && elem->prev == NULL)) BUG();
    8d27:	8b 5d dc             	mov    0xffffffdc(%ebp),%ebx
    8d2a:	8b 73 04             	mov    0x4(%ebx),%esi
    8d2d:	85 f6                	test   %esi,%esi
    8d2f:	75 06                	jne    8d37 <addNewUC_Continuation+0x297>
    8d31:	8b 0b                	mov    (%ebx),%ecx
    8d33:	85 c9                	test   %ecx,%ecx
    8d35:	74 19                	je     8d50 <addNewUC_Continuation+0x2b0>
    8d37:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    8d3e:	00 
    8d3f:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    8d46:	e8 fc ff ff ff       	call   8d47 <addNewUC_Continuation+0x2a7>
    8d4b:	e8 fc ff ff ff       	call   8d4c <addNewUC_Continuation+0x2ac>
	elem->next = prev->next;
    8d50:	8b 75 d8             	mov    0xffffffd8(%ebp),%esi
    8d53:	8b 7d dc             	mov    0xffffffdc(%ebp),%edi
    8d56:	8b 46 04             	mov    0x4(%esi),%eax
	prev->next = elem;

	elem->prev = prev;
    8d59:	89 37                	mov    %esi,(%edi)
    8d5b:	89 47 04             	mov    %eax,0x4(%edi)
    8d5e:	89 7e 04             	mov    %edi,0x4(%esi)
	next->prev = elem;
    8d61:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    8d64:	89 38                	mov    %edi,(%eax)

	elem->list = prev->list;
    8d66:	8b 46 08             	mov    0x8(%esi),%eax
    8d69:	89 47 08             	mov    %eax,0x8(%edi)
	elem->list->len++;
    8d6c:	ff 40 10             	incl   0x10(%eax)
    8d6f:	8b 75 d4             	mov    0xffffffd4(%ebp),%esi
    8d72:	8b 46 04             	mov    0x4(%esi),%eax
    8d75:	3b 45 d0             	cmp    0xffffffd0(%ebp),%eax
    8d78:	74 24                	je     8d9e <addNewUC_Continuation+0x2fe>
    8d7a:	89 c2                	mov    %eax,%edx
    8d7c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    8d80:	3b 75 c0             	cmp    0xffffffc0(%ebp),%esi
    8d83:	74 0d                	je     8d92 <addNewUC_Continuation+0x2f2>
    8d85:	3b 55 c0             	cmp    0xffffffc0(%ebp),%edx
    8d88:	74 08                	je     8d92 <addNewUC_Continuation+0x2f2>
    8d8a:	8b 42 18             	mov    0x18(%edx),%eax
    8d8d:	39 46 1c             	cmp    %eax,0x1c(%esi)
    8d90:	77 3e                	ja     8dd0 <addNewUC_Continuation+0x330>
    8d92:	8b 42 04             	mov    0x4(%edx),%eax
    8d95:	89 d6                	mov    %edx,%esi
    8d97:	3b 45 d0             	cmp    0xffffffd0(%ebp),%eax
    8d9a:	89 c2                	mov    %eax,%edx
    8d9c:	75 e2                	jne    8d80 <addNewUC_Continuation+0x2e0>
    8d9e:	8b 75 d4             	mov    0xffffffd4(%ebp),%esi
    8da1:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    8da4:	39 55 e4             	cmp    %edx,0xffffffe4(%ebp)
    8da7:	73 10                	jae    8db9 <addNewUC_Continuation+0x319>
    8da9:	8b 46 04             	mov    0x4(%esi),%eax
    8dac:	89 f1                	mov    %esi,%ecx
    8dae:	3b 45 c0             	cmp    0xffffffc0(%ebp),%eax
    8db1:	89 c2                	mov    %eax,%edx
    8db3:	0f 85 a7 fd ff ff    	jne    8b60 <addNewUC_Continuation+0xc0>
    8db9:	8b 4d 08             	mov    0x8(%ebp),%ecx
    8dbc:	89 0c 24             	mov    %ecx,(%esp,1)
    8dbf:	e8 fc ff ff ff       	call   8dc0 <addNewUC_Continuation+0x320>
    8dc4:	31 c0                	xor    %eax,%eax
    8dc6:	83 c4 40             	add    $0x40,%esp
    8dc9:	5b                   	pop    %ebx
    8dca:	5e                   	pop    %esi
    8dcb:	5f                   	pop    %edi
    8dcc:	5d                   	pop    %ebp
    8dcd:	c3                   	ret    
    8dce:	89 f6                	mov    %esi,%esi
    8dd0:	c7 44 24 04 57 05 00 	movl   $0x557,0x4(%esp,1)
    8dd7:	00 
    8dd8:	c7 04 24 a0 2c 00 00 	movl   $0x2ca0,(%esp,1)
    8ddf:	e8 fc ff ff ff       	call   8de0 <addNewUC_Continuation+0x340>
    8de4:	8b 56 04             	mov    0x4(%esi),%edx
    8de7:	eb a9                	jmp    8d92 <addNewUC_Continuation+0x2f2>
}

static inline struct UC_Continuation *copyUC_Continuation(struct UC_Continuation *scont) {
  /* create a separate copy */
  int dataLen = scont->dataLen;
    8de9:	8b 42 28             	mov    0x28(%edx),%eax
  struct UC_Continuation *rval = kmalloc(sizeof(*rval) + dataLen, GFP_ATOMIC);
    8dec:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    8df3:	00 
    8df4:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    8df7:	83 c0 30             	add    $0x30,%eax
    8dfa:	89 04 24             	mov    %eax,(%esp,1)
    8dfd:	e8 fc ff ff ff       	call   8dfe <addNewUC_Continuation+0x35e>
  if(rval == NULL) {
    8e02:	85 c0                	test   %eax,%eax
    8e04:	89 c2                	mov    %eax,%edx
    8e06:	0f 84 a5 00 00 00    	je     8eb1 <addNewUC_Continuation+0x411>
    printk("Out of memory while copying UC_Continuation\n");
    return NULL;
  }
  *rval = *scont;
    8e0c:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
    8e0f:	8d 72 30             	lea    0x30(%edx),%esi
  if(rval == NULL) {
    printk("Out of memory while copying UC_Continuation\n");
    return NULL;
  }
  *rval = *scont;
    8e12:	8b 01                	mov    (%ecx),%eax
    8e14:	89 02                	mov    %eax,(%edx)
    8e16:	8b 41 04             	mov    0x4(%ecx),%eax
    8e19:	89 42 04             	mov    %eax,0x4(%edx)
    8e1c:	8b 41 08             	mov    0x8(%ecx),%eax
    8e1f:	89 42 08             	mov    %eax,0x8(%edx)
    8e22:	8b 41 0c             	mov    0xc(%ecx),%eax
    8e25:	89 42 0c             	mov    %eax,0xc(%edx)
    8e28:	8b 41 10             	mov    0x10(%ecx),%eax
    8e2b:	89 42 10             	mov    %eax,0x10(%edx)
    8e2e:	8b 41 14             	mov    0x14(%ecx),%eax
    8e31:	89 42 14             	mov    %eax,0x14(%edx)
    8e34:	8b 41 18             	mov    0x18(%ecx),%eax
    8e37:	89 42 18             	mov    %eax,0x18(%edx)
    8e3a:	8b 41 1c             	mov    0x1c(%ecx),%eax
    8e3d:	89 42 1c             	mov    %eax,0x1c(%edx)
    8e40:	8b 41 20             	mov    0x20(%ecx),%eax
    8e43:	89 42 20             	mov    %eax,0x20(%edx)
    8e46:	8b 41 24             	mov    0x24(%ecx),%eax
    8e49:	89 42 24             	mov    %eax,0x24(%edx)
    8e4c:	8b 41 28             	mov    0x28(%ecx),%eax
    8e4f:	89 42 28             	mov    %eax,0x28(%edx)
    8e52:	8b 41 2c             	mov    0x2c(%ecx),%eax
  rval->prev = rval->next = NULL;
    8e55:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
    8e5c:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  rval->list = NULL;
    8e62:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
    8e69:	89 42 2c             	mov    %eax,0x2c(%edx)

static inline void * __memcpy(void * to, const void * from, size_t n)
{
int d0, d1, d2;
__asm__ __volatile__(
    8e6c:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    8e6f:	89 75 c4             	mov    %esi,0xffffffc4(%ebp)
    8e72:	89 ce                	mov    %ecx,%esi
    8e74:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
    8e77:	83 c6 30             	add    $0x30,%esi
    8e7a:	8b 7d c4             	mov    0xffffffc4(%ebp),%edi
    8e7d:	c1 e9 02             	shr    $0x2,%ecx
    8e80:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    8e82:	a8 02                	test   $0x2,%al
    8e84:	74 02                	je     8e88 <addNewUC_Continuation+0x3e8>
    8e86:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    8e88:	a8 01                	test   $0x1,%al
    8e8a:	74 01                	je     8e8d <addNewUC_Continuation+0x3ed>
    8e8c:	a4                   	movsb  %ds:(%esi),%es:(%edi)
  *rval = *scont;
  rval->prev = rval->next = NULL;
  rval->list = NULL;

  memcpy(rval->kernel.data, scont->kernel.data, dataLen);
    8e8d:	89 d0                	mov    %edx,%eax
    8e8f:	85 c0                	test   %eax,%eax
    8e91:	74 08                	je     8e9b <addNewUC_Continuation+0x3fb>
    8e93:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    8e96:	e9 3e fd ff ff       	jmp    8bd9 <addNewUC_Continuation+0x139>
    8e9b:	c7 04 24 40 2d 00 00 	movl   $0x2d40,(%esp,1)
    8ea2:	e8 fc ff ff ff       	call   8ea3 <addNewUC_Continuation+0x403>
    8ea7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    8eac:	e9 15 ff ff ff       	jmp    8dc6 <addNewUC_Continuation+0x326>
  /* create a separate copy */
  int dataLen = scont->dataLen;
  struct UC_Continuation *rval = kmalloc(sizeof(*rval) + dataLen, GFP_ATOMIC);
  if(rval == NULL) {
    printk("Out of memory while copying UC_Continuation\n");
    8eb1:	c7 04 24 40 0f 00 00 	movl   $0xf40,(%esp,1)
    8eb8:	e8 fc ff ff ff       	call   8eb9 <addNewUC_Continuation+0x419>
    8ebd:	31 c0                	xor    %eax,%eax
    8ebf:	eb ce                	jmp    8e8f <addNewUC_Continuation+0x3ef>
    8ec1:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
    8ec4:	85 c9                	test   %ecx,%ecx
    8ec6:	0f 85 14 fd ff ff    	jne    8be0 <addNewUC_Continuation+0x140>
    8ecc:	85 f6                	test   %esi,%esi
    8ece:	74 33                	je     8f03 <addNewUC_Continuation+0x463>
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    8ed0:	8b 56 04             	mov    0x4(%esi),%edx
    8ed3:	8b 06                	mov    (%esi),%eax
    8ed5:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    8ed7:	8b 06                	mov    (%esi),%eax
	elem->prev = elem->next = NULL;
    8ed9:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    8edf:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
    8ee2:	8b 46 08             	mov    0x8(%esi),%eax
    8ee5:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
    8eec:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    8eef:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    8ef6:	89 34 24             	mov    %esi,(%esp,1)
    8ef9:	e8 fc ff ff ff       	call   8efa <addNewUC_Continuation+0x45a>
    8efe:	e9 d6 fc ff ff       	jmp    8bd9 <addNewUC_Continuation+0x139>
    8f03:	c7 44 24 04 2f 05 00 	movl   $0x52f,0x4(%esp,1)
    8f0a:	00 
    8f0b:	c7 04 24 80 2d 00 00 	movl   $0x2d80,(%esp,1)
    8f12:	e8 fc ff ff ff       	call   8f13 <addNewUC_Continuation+0x473>
    8f17:	eb b7                	jmp    8ed0 <addNewUC_Continuation+0x430>
    8f19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    8f20:	89 ce                	mov    %ecx,%esi
    8f22:	89 d3                	mov    %edx,%ebx
    8f24:	e9 8a fc ff ff       	jmp    8bb3 <addNewUC_Continuation+0x113>
    8f29:	8b 75 c0             	mov    0xffffffc0(%ebp),%esi
    8f2c:	8b 4e 04             	mov    0x4(%esi),%ecx
    8f2f:	e9 11 fc ff ff       	jmp    8b45 <addNewUC_Continuation+0xa5>
    8f34:	81 c1 e4 0a 00 00    	add    $0xae4,%ecx
    8f3a:	8b 43 10             	mov    0x10(%ebx),%eax
    8f3d:	89 4d c0             	mov    %ecx,0xffffffc0(%ebp)
    8f40:	e9 a7 fb ff ff       	jmp    8aec <addNewUC_Continuation+0x4c>
    8f45:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    8f49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00008f50 <removeObsoleteDataRequestMaps>:
    8f50:	55                   	push   %ebp
    8f51:	89 e5                	mov    %esp,%ebp
    8f53:	57                   	push   %edi
    8f54:	56                   	push   %esi
    8f55:	53                   	push   %ebx
    8f56:	83 ec 48             	sub    $0x48,%esp
    8f59:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
    8f60:	8b 45 08             	mov    0x8(%ebp),%eax
    8f63:	8b 55 08             	mov    0x8(%ebp),%edx
    8f66:	05 bc 00 00 00       	add    $0xbc,%eax
    8f6b:	81 c2 60 0b 00 00    	add    $0xb60,%edx
    8f71:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    8f74:	8b 45 08             	mov    0x8(%ebp),%eax
    8f77:	89 55 dc             	mov    %edx,0xffffffdc(%ebp)
    8f7a:	89 55 f0             	mov    %edx,0xfffffff0(%ebp)
    8f7d:	05 4c 0b 00 00       	add    $0xb4c,%eax
    8f82:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    8f85:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    8f88:	8b 44 85 ec          	mov    0xffffffec(%ebp,%eax,4),%eax
    8f8c:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    8f8f:	8b 58 04             	mov    0x4(%eax),%ebx
    8f92:	39 c3                	cmp    %eax,%ebx
    8f94:	0f 84 02 02 00 00    	je     919c <removeObsoleteDataRequestMaps+0x24c>
    8f9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    8fa0:	8b 53 04             	mov    0x4(%ebx),%edx
    8fa3:	31 f6                	xor    %esi,%esi
    8fa5:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
    8fa8:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    8fab:	8b 42 08             	mov    0x8(%edx),%eax
    8fae:	39 43 24             	cmp    %eax,0x24(%ebx)
    8fb1:	77 79                	ja     902c <removeObsoleteDataRequestMaps+0xdc>
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    8fb3:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    8fb6:	8b 03                	mov    (%ebx),%eax
    8fb8:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    8fba:	8b 03                	mov    (%ebx),%eax
	elem->prev = elem->next = NULL;
    8fbc:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    8fc2:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
    8fc5:	8b 43 08             	mov    0x8(%ebx),%eax
    8fc8:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    8fcf:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    8fd2:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    8fd9:	8b 0d 84 00 00 00    	mov    0x84,%ecx
    8fdf:	41                   	inc    %ecx
    8fe0:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    8fe7:	89 0d 84 00 00 00    	mov    %ecx,0x84
    8fed:	7e 1f                	jle    900e <removeObsoleteDataRequestMaps+0xbe>
    8fef:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
    8ff4:	f7 e9                	imul   %ecx
    8ff6:	89 c8                	mov    %ecx,%eax
    8ff8:	89 d6                	mov    %edx,%esi
    8ffa:	99                   	cltd   
    8ffb:	c1 fe 06             	sar    $0x6,%esi
    8ffe:	29 d6                	sub    %edx,%esi
    9000:	69 f6 e8 03 00 00    	imul   $0x3e8,%esi,%esi
    9006:	39 f1                	cmp    %esi,%ecx
    9008:	0f 84 5a 04 00 00    	je     9468 <removeObsoleteDataRequestMaps+0x518>
	return newMapping;
}

static inline void freeDataRequestMapping(struct DataRequestMapping *dataReq) {
	numDataRequestMappings--;
    900e:	ff 0d 00 00 00 00    	decl   0x0
    9014:	be 01 00 00 00       	mov    $0x1,%esi
}

static inline void freeDataRequestMapping(struct DataRequestMapping *dataReq) {
	numDataRequestMappings--;
	kfree(dataReq);
    9019:	89 1c 24             	mov    %ebx,(%esp,1)
    901c:	e8 fc ff ff ff       	call   901d <removeObsoleteDataRequestMaps+0xcd>
    9021:	8b 45 08             	mov    0x8(%ebp),%eax
    9024:	89 04 24             	mov    %eax,(%esp,1)
    9027:	e8 fc ff ff ff       	call   9028 <removeObsoleteDataRequestMaps+0xd8>
    902c:	85 f6                	test   %esi,%esi
    902e:	0f 85 5c 01 00 00    	jne    9190 <removeObsoleteDataRequestMaps+0x240>
    9034:	8b 43 10             	mov    0x10(%ebx),%eax
    9037:	85 c0                	test   %eax,%eax
    9039:	0f 84 51 01 00 00    	je     9190 <removeObsoleteDataRequestMaps+0x240>
    903f:	8b 43 14             	mov    0x14(%ebx),%eax
    9042:	85 c0                	test   %eax,%eax
    9044:	0f 85 46 01 00 00    	jne    9190 <removeObsoleteDataRequestMaps+0x240>
    904a:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    904d:	8b 43 1c             	mov    0x1c(%ebx),%eax
    9050:	39 82 dc 02 00 00    	cmp    %eax,0x2dc(%edx)
    9056:	0f 82 34 01 00 00    	jb     9190 <removeObsoleteDataRequestMaps+0x240>
    905c:	8b 03                	mov    (%ebx),%eax
    905e:	31 c9                	xor    %ecx,%ecx
    9060:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
    9063:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    9066:	8b 53 04             	mov    0x4(%ebx),%edx
    9069:	89 55 d0             	mov    %edx,0xffffffd0(%ebp)
    906c:	8b 50 08             	mov    0x8(%eax),%edx
    906f:	8b 43 20             	mov    0x20(%ebx),%eax
    9072:	39 c2                	cmp    %eax,%edx
    9074:	0f 43 c2             	cmovae %edx,%eax
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    9077:	8b 55 d0             	mov    0xffffffd0(%ebp),%edx
    907a:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    907d:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    9080:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    9082:	8b 03                	mov    (%ebx),%eax
	elem->prev = elem->next = NULL;
    9084:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    908a:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
    908d:	8b 43 08             	mov    0x8(%ebx),%eax
    9090:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    9097:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    909a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    90a1:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    90a4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    90a7:	8b 92 5c 0a 00 00    	mov    0xa5c(%edx),%edx
    90ad:	05 5c 0a 00 00       	add    $0xa5c,%eax
    90b2:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
    90b5:	39 c2                	cmp    %eax,%edx
    90b7:	89 55 c8             	mov    %edx,0xffffffc8(%ebp)
    90ba:	0f 84 a0 03 00 00    	je     9460 <removeObsoleteDataRequestMaps+0x510>
    90c0:	8b 73 24             	mov    0x24(%ebx),%esi
    90c3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    90c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
    90d0:	8b 55 c8             	mov    0xffffffc8(%ebp),%edx
    90d3:	8b 7b 20             	mov    0x20(%ebx),%edi
    90d6:	8b 42 40             	mov    0x40(%edx),%eax
    90d9:	39 c7                	cmp    %eax,%edi
    90db:	0f 42 f8             	cmovb  %eax,%edi
    90de:	8b 42 44             	mov    0x44(%edx),%eax
    90e1:	39 c6                	cmp    %eax,%esi
    90e3:	0f 46 c6             	cmovbe %esi,%eax
    90e6:	39 f0                	cmp    %esi,%eax
    90e8:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
    90eb:	73 22                	jae    910f <removeObsoleteDataRequestMaps+0x1bf>
    90ed:	39 c7                	cmp    %eax,%edi
    90ef:	7d 0f                	jge    9100 <removeObsoleteDataRequestMaps+0x1b0>
    90f1:	39 7d cc             	cmp    %edi,0xffffffcc(%ebp)
    90f4:	0f 8c 59 02 00 00    	jl     9353 <removeObsoleteDataRequestMaps+0x403>
    90fa:	8b 55 c4             	mov    0xffffffc4(%ebp),%edx
    90fd:	89 55 cc             	mov    %edx,0xffffffcc(%ebp)
    9100:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    9103:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
    9106:	8b 00                	mov    (%eax),%eax
    9108:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
    910b:	39 d0                	cmp    %edx,%eax
    910d:	75 c1                	jne    90d0 <removeObsoleteDataRequestMaps+0x180>
    910f:	39 75 cc             	cmp    %esi,0xffffffcc(%ebp)
    9112:	0f 83 e8 01 00 00    	jae    9300 <removeObsoleteDataRequestMaps+0x3b0>
    9118:	85 c9                	test   %ecx,%ecx
    911a:	0f 85 da 00 00 00    	jne    91fa <removeObsoleteDataRequestMaps+0x2aa>
static inline
void submitDataRequestMapping(struct sock *sk, struct DataRequestMapping *dataReq, 
					      unsigned newStart, unsigned newEnd) {
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	BUG_TRAP(dataReq->list == NULL);
    9120:	8b 7b 08             	mov    0x8(%ebx),%edi
    9123:	85 ff                	test   %edi,%edi
    9125:	0f 85 b6 00 00 00    	jne    91e1 <removeObsoleteDataRequestMaps+0x291>
	dataReq->completed = 0;
    912b:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
	dataReq->sent = 0;
    9132:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
	// poison values
	dataReq->transportResponseSeqStart = UINT_MAX;
    9139:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
	dataReq->transportResponseSeqEnd = UINT_MAX;
    9140:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
	dataReq->timestamp = UINT_MAX;
    9147:	c7 43 28 ff ff ff ff 	movl   $0xffffffff,0x28(%ebx)
	dataReq->start = newStart;
    914e:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
	dataReq->end = newEnd;
    9151:	89 73 24             	mov    %esi,0x24(%ebx)
    9154:	89 43 20             	mov    %eax,0x20(%ebx)
	if(elem->list) {
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
    9157:	8b 55 08             	mov    0x8(%ebp),%edx
    915a:	8b 82 60 0b 00 00    	mov    0xb60(%edx),%eax
    9160:	39 d8                	cmp    %ebx,%eax
    9162:	74 4d                	je     91b1 <removeObsoleteDataRequestMaps+0x261>
		BUG();
		show_stack(NULL);
	}
	elem->prev = head->prev;
    9164:	89 03                	mov    %eax,(%ebx)
	head->prev->next = elem;
    9166:	8b 55 08             	mov    0x8(%ebp),%edx
    9169:	8b 82 60 0b 00 00    	mov    0xb60(%edx),%eax
    916f:	89 58 04             	mov    %ebx,0x4(%eax)

	elem->next = (struct alloc_head*)head;
    9172:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    9175:	89 43 04             	mov    %eax,0x4(%ebx)

	elem->list = head;
    9178:	89 43 08             	mov    %eax,0x8(%ebx)
	head->prev = elem;
    917b:	89 9a 60 0b 00 00    	mov    %ebx,0xb60(%edx)
	head->len++;
}

static inline void unlink(struct alloc_head *elem) {
#ifdef DEBUG_LIST
	if(elem->list == (struct alloc_head_list*) elem) {
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
	elem->prev->next = elem->next;
	elem->prev = elem->next = NULL;

	elem->list->len--;
	elem->list = NULL;
}

static inline void insert(struct alloc_head *elem, struct alloc_head *prev, struct alloc_head *next) {
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
	if(prev->next != next || next->prev != prev) {
		BUG();
	}
#endif

	if(!(elem->next == NULL && elem->prev == NULL)) BUG();
	elem->next = prev->next;
	prev->next = elem;

	elem->prev = prev;
	next->prev = elem;

	elem->list = prev->list;
	elem->list->len++;
    9181:	ff 40 10             	incl   0x10(%eax)
    9184:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    918a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
    9190:	8b 5d e0             	mov    0xffffffe0(%ebp),%ebx
    9193:	3b 5d d8             	cmp    0xffffffd8(%ebp),%ebx
    9196:	0f 85 04 fe ff ff    	jne    8fa0 <removeObsoleteDataRequestMaps+0x50>
    919c:	ff 45 e4             	incl   0xffffffe4(%ebp)
    919f:	83 7d e4 01          	cmpl   $0x1,0xffffffe4(%ebp)
    91a3:	0f 8e dc fd ff ff    	jle    8f85 <removeObsoleteDataRequestMaps+0x35>
    91a9:	83 c4 48             	add    $0x48,%esp
    91ac:	5b                   	pop    %ebx
    91ad:	5e                   	pop    %esi
    91ae:	5f                   	pop    %edi
    91af:	5d                   	pop    %ebp
    91b0:	c3                   	ret    
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
		BUG();
    91b1:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    91b8:	00 
    91b9:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    91c0:	e8 fc ff ff ff       	call   91c1 <removeObsoleteDataRequestMaps+0x271>
    91c5:	e8 fc ff ff ff       	call   91c6 <removeObsoleteDataRequestMaps+0x276>
		show_stack(NULL);
    91ca:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    91d1:	e8 fc ff ff ff       	call   91d2 <removeObsoleteDataRequestMaps+0x282>
    91d6:	8b 55 08             	mov    0x8(%ebp),%edx
    91d9:	8b 82 60 0b 00 00    	mov    0xb60(%edx),%eax
    91df:	eb 83                	jmp    9164 <removeObsoleteDataRequestMaps+0x214>
    91e1:	c7 44 24 04 0e 02 00 	movl   $0x20e,0x4(%esp,1)
    91e8:	00 
    91e9:	c7 04 24 c0 2d 00 00 	movl   $0x2dc0,(%esp,1)
    91f0:	e8 fc ff ff ff       	call   91f1 <removeObsoleteDataRequestMaps+0x2a1>
    91f5:	e9 31 ff ff ff       	jmp    912b <removeObsoleteDataRequestMaps+0x1db>

static inline 
void submitDerivedDataRequestMapping(struct sock *sk, struct DataRequestMapping *oldReqMap, 
					    unsigned start, unsigned end) {
	struct DataRequestMapping *newMap = 
    91fa:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    9201:	00 
    9202:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp,1)
    9209:	e8 fc ff ff ff       	call   920a <removeObsoleteDataRequestMaps+0x2ba>
    920e:	89 c7                	mov    %eax,%edi
		kmalloc(sizeof(struct DataRequestMapping), GFP_ATOMIC);
	*newMap = *oldReqMap;
    9210:	8b 03                	mov    (%ebx),%eax
    9212:	89 07                	mov    %eax,(%edi)
    9214:	8b 43 04             	mov    0x4(%ebx),%eax
    9217:	89 47 04             	mov    %eax,0x4(%edi)
    921a:	8b 53 08             	mov    0x8(%ebx),%edx
    921d:	85 d2                	test   %edx,%edx
    921f:	89 57 08             	mov    %edx,0x8(%edi)
    9222:	8b 43 0c             	mov    0xc(%ebx),%eax
    9225:	89 47 0c             	mov    %eax,0xc(%edi)
    9228:	8b 43 10             	mov    0x10(%ebx),%eax
    922b:	89 47 10             	mov    %eax,0x10(%edi)
    922e:	8b 43 14             	mov    0x14(%ebx),%eax
    9231:	89 47 14             	mov    %eax,0x14(%edi)
    9234:	8b 43 18             	mov    0x18(%ebx),%eax
    9237:	89 47 18             	mov    %eax,0x18(%edi)
    923a:	8b 43 1c             	mov    0x1c(%ebx),%eax
    923d:	89 47 1c             	mov    %eax,0x1c(%edi)
    9240:	8b 43 20             	mov    0x20(%ebx),%eax
    9243:	89 47 20             	mov    %eax,0x20(%edi)
    9246:	8b 43 24             	mov    0x24(%ebx),%eax
    9249:	89 47 24             	mov    %eax,0x24(%edi)
    924c:	8b 43 28             	mov    0x28(%ebx),%eax
    924f:	89 47 28             	mov    %eax,0x28(%edi)
    9252:	0f 85 8b 00 00 00    	jne    92e3 <removeObsoleteDataRequestMaps+0x393>
    9258:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%edi)
    925f:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
    9266:	c7 47 18 ff ff ff ff 	movl   $0xffffffff,0x18(%edi)
    926d:	c7 47 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%edi)
    9274:	c7 47 28 ff ff ff ff 	movl   $0xffffffff,0x28(%edi)
    927b:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
    927e:	89 77 24             	mov    %esi,0x24(%edi)
    9281:	89 57 20             	mov    %edx,0x20(%edi)
	if(elem->list) {
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
    9284:	8b 55 08             	mov    0x8(%ebp),%edx
    9287:	8b 82 60 0b 00 00    	mov    0xb60(%edx),%eax
    928d:	39 f8                	cmp    %edi,%eax
    928f:	74 22                	je     92b3 <removeObsoleteDataRequestMaps+0x363>
		BUG();
		show_stack(NULL);
	}
	elem->prev = head->prev;
    9291:	89 07                	mov    %eax,(%edi)
	head->prev->next = elem;
    9293:	8b 55 08             	mov    0x8(%ebp),%edx
    9296:	8b 82 60 0b 00 00    	mov    0xb60(%edx),%eax
    929c:	89 78 04             	mov    %edi,0x4(%eax)

	elem->next = (struct alloc_head*)head;
    929f:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    92a2:	89 47 04             	mov    %eax,0x4(%edi)

	elem->list = head;
    92a5:	89 47 08             	mov    %eax,0x8(%edi)
	head->prev = elem;
    92a8:	89 ba 60 0b 00 00    	mov    %edi,0xb60(%edx)
	head->len++;
    92ae:	e9 ce fe ff ff       	jmp    9181 <removeObsoleteDataRequestMaps+0x231>
    92b3:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    92ba:	00 
    92bb:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    92c2:	e8 fc ff ff ff       	call   92c3 <removeObsoleteDataRequestMaps+0x373>
    92c7:	e8 fc ff ff ff       	call   92c8 <removeObsoleteDataRequestMaps+0x378>
    92cc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    92d3:	e8 fc ff ff ff       	call   92d4 <removeObsoleteDataRequestMaps+0x384>
    92d8:	8b 55 08             	mov    0x8(%ebp),%edx
    92db:	8b 82 60 0b 00 00    	mov    0xb60(%edx),%eax
    92e1:	eb ae                	jmp    9291 <removeObsoleteDataRequestMaps+0x341>
    92e3:	c7 44 24 04 0e 02 00 	movl   $0x20e,0x4(%esp,1)
    92ea:	00 
    92eb:	c7 04 24 c0 2d 00 00 	movl   $0x2dc0,(%esp,1)
    92f2:	e8 fc ff ff ff       	call   92f3 <removeObsoleteDataRequestMaps+0x3a3>
    92f7:	e9 5c ff ff ff       	jmp    9258 <removeObsoleteDataRequestMaps+0x308>
    92fc:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    9300:	85 c9                	test   %ecx,%ecx
    9302:	0f 85 88 fe ff ff    	jne    9190 <removeObsoleteDataRequestMaps+0x240>
    9308:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
		BUG();
	}
#endif

	if(!(elem->next == NULL && elem->prev == NULL)) BUG();
    930f:	8b 73 04             	mov    0x4(%ebx),%esi
    9312:	85 f6                	test   %esi,%esi
    9314:	75 06                	jne    931c <removeObsoleteDataRequestMaps+0x3cc>
    9316:	8b 0b                	mov    (%ebx),%ecx
    9318:	85 c9                	test   %ecx,%ecx
    931a:	74 19                	je     9335 <removeObsoleteDataRequestMaps+0x3e5>
    931c:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    9323:	00 
    9324:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    932b:	e8 fc ff ff ff       	call   932c <removeObsoleteDataRequestMaps+0x3dc>
    9330:	e8 fc ff ff ff       	call   9331 <removeObsoleteDataRequestMaps+0x3e1>
	elem->next = prev->next;
    9335:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
    9338:	8b 42 04             	mov    0x4(%edx),%eax
	prev->next = elem;

	elem->prev = prev;
    933b:	89 13                	mov    %edx,(%ebx)
    933d:	89 43 04             	mov    %eax,0x4(%ebx)
    9340:	89 5a 04             	mov    %ebx,0x4(%edx)
	next->prev = elem;
    9343:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    9346:	89 18                	mov    %ebx,(%eax)

	elem->list = prev->list;
    9348:	8b 42 08             	mov    0x8(%edx),%eax
    934b:	89 43 08             	mov    %eax,0x8(%ebx)
    934e:	e9 2e fe ff ff       	jmp    9181 <removeObsoleteDataRequestMaps+0x231>

static inline 
void submitDerivedDataRequestMapping(struct sock *sk, struct DataRequestMapping *oldReqMap, 
					    unsigned start, unsigned end) {
	struct DataRequestMapping *newMap = 
    9353:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    935a:	00 
    935b:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp,1)
    9362:	e8 fc ff ff ff       	call   9363 <removeObsoleteDataRequestMaps+0x413>
    9367:	89 c6                	mov    %eax,%esi
		kmalloc(sizeof(struct DataRequestMapping), GFP_ATOMIC);
	*newMap = *oldReqMap;
    9369:	8b 03                	mov    (%ebx),%eax
    936b:	89 06                	mov    %eax,(%esi)
    936d:	8b 43 04             	mov    0x4(%ebx),%eax
    9370:	89 46 04             	mov    %eax,0x4(%esi)
    9373:	8b 53 08             	mov    0x8(%ebx),%edx
    9376:	85 d2                	test   %edx,%edx
    9378:	89 56 08             	mov    %edx,0x8(%esi)
    937b:	8b 43 0c             	mov    0xc(%ebx),%eax
    937e:	89 46 0c             	mov    %eax,0xc(%esi)
    9381:	8b 43 10             	mov    0x10(%ebx),%eax
    9384:	89 46 10             	mov    %eax,0x10(%esi)
    9387:	8b 43 14             	mov    0x14(%ebx),%eax
    938a:	89 46 14             	mov    %eax,0x14(%esi)
    938d:	8b 43 18             	mov    0x18(%ebx),%eax
    9390:	89 46 18             	mov    %eax,0x18(%esi)
    9393:	8b 43 1c             	mov    0x1c(%ebx),%eax
    9396:	89 46 1c             	mov    %eax,0x1c(%esi)
    9399:	8b 43 20             	mov    0x20(%ebx),%eax
    939c:	89 46 20             	mov    %eax,0x20(%esi)
    939f:	8b 43 24             	mov    0x24(%ebx),%eax
    93a2:	89 46 24             	mov    %eax,0x24(%esi)
    93a5:	8b 43 28             	mov    0x28(%ebx),%eax
    93a8:	89 46 28             	mov    %eax,0x28(%esi)
    93ab:	0f 85 96 00 00 00    	jne    9447 <removeObsoleteDataRequestMaps+0x4f7>
    93b1:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
    93b8:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
    93bf:	c7 46 18 ff ff ff ff 	movl   $0xffffffff,0x18(%esi)
    93c6:	c7 46 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%esi)
    93cd:	c7 46 28 ff ff ff ff 	movl   $0xffffffff,0x28(%esi)
    93d4:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    93d7:	89 7e 24             	mov    %edi,0x24(%esi)
    93da:	89 46 20             	mov    %eax,0x20(%esi)
	if(elem->list) {
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
    93dd:	8b 55 08             	mov    0x8(%ebp),%edx
    93e0:	8b 82 60 0b 00 00    	mov    0xb60(%edx),%eax
    93e6:	39 f0                	cmp    %esi,%eax
    93e8:	74 2d                	je     9417 <removeObsoleteDataRequestMaps+0x4c7>
		BUG();
		show_stack(NULL);
	}
	elem->prev = head->prev;
    93ea:	89 06                	mov    %eax,(%esi)
	head->prev->next = elem;
    93ec:	8b 55 08             	mov    0x8(%ebp),%edx
    93ef:	b9 01 00 00 00       	mov    $0x1,%ecx
		BUG();
		show_stack(NULL);
	}
	elem->prev = head->prev;
	head->prev->next = elem;
    93f4:	8b 82 60 0b 00 00    	mov    0xb60(%edx),%eax
    93fa:	89 70 04             	mov    %esi,0x4(%eax)

	elem->next = (struct alloc_head*)head;
    93fd:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    9400:	89 46 04             	mov    %eax,0x4(%esi)

	elem->list = head;
    9403:	89 46 08             	mov    %eax,0x8(%esi)
	head->prev = elem;
	head->len++;
    9406:	ff 40 10             	incl   0x10(%eax)
    9409:	89 b2 60 0b 00 00    	mov    %esi,0xb60(%edx)
    940f:	8b 73 24             	mov    0x24(%ebx),%esi
    9412:	e9 e3 fc ff ff       	jmp    90fa <removeObsoleteDataRequestMaps+0x1aa>
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
		BUG();
    9417:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp,1)
    941e:	00 
    941f:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp,1)
    9426:	e8 fc ff ff ff       	call   9427 <removeObsoleteDataRequestMaps+0x4d7>
    942b:	e8 fc ff ff ff       	call   942c <removeObsoleteDataRequestMaps+0x4dc>
		show_stack(NULL);
    9430:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    9437:	e8 fc ff ff ff       	call   9438 <removeObsoleteDataRequestMaps+0x4e8>
    943c:	8b 55 08             	mov    0x8(%ebp),%edx
    943f:	8b 82 60 0b 00 00    	mov    0xb60(%edx),%eax
    9445:	eb a3                	jmp    93ea <removeObsoleteDataRequestMaps+0x49a>
    9447:	c7 44 24 04 0e 02 00 	movl   $0x20e,0x4(%esp,1)
    944e:	00 
    944f:	c7 04 24 c0 2d 00 00 	movl   $0x2dc0,(%esp,1)
    9456:	e8 fc ff ff ff       	call   9457 <removeObsoleteDataRequestMaps+0x507>
    945b:	e9 51 ff ff ff       	jmp    93b1 <removeObsoleteDataRequestMaps+0x461>
    9460:	8b 73 24             	mov    0x24(%ebx),%esi
    9463:	e9 a7 fc ff ff       	jmp    910f <removeObsoleteDataRequestMaps+0x1bf>
    9468:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    946b:	8b 82 d0 02 00 00    	mov    0x2d0(%edx),%eax
    9471:	89 c2                	mov    %eax,%edx
    9473:	c1 f8 03             	sar    $0x3,%eax
    9476:	83 e2 07             	and    $0x7,%edx
    9479:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    947d:	a1 00 00 00 00       	mov    0x0,%eax
    9482:	89 54 24 10          	mov    %edx,0x10(%esp,1)
    9486:	8b 53 28             	mov    0x28(%ebx),%edx
    9489:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp,1)
    9490:	00 
    9491:	c7 04 24 40 2e 00 00 	movl   $0x2e40,(%esp,1)
    9498:	29 d0                	sub    %edx,%eax
    949a:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    949e:	e8 fc ff ff ff       	call   949f <removeObsoleteDataRequestMaps+0x54f>
    94a3:	e9 66 fb ff ff       	jmp    900e <removeObsoleteDataRequestMaps+0xbe>
    94a8:	90                   	nop    
    94a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi

000094b0 <tcp_fast_path_queue>:
    94b0:	55                   	push   %ebp
    94b1:	31 d2                	xor    %edx,%edx
    94b3:	89 e5                	mov    %esp,%ebp
    94b5:	57                   	push   %edi

static inline struct task_struct * get_current(void)
{
	struct task_struct *current;
	__asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
    94b6:	b8 00 e0 ff ff       	mov    $0xffffe000,%eax
    94bb:	56                   	push   %esi
    94bc:	53                   	push   %ebx
    94bd:	83 ec 10             	sub    $0x10,%esp
    94c0:	8b 75 08             	mov    0x8(%ebp),%esi
    94c3:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)

static inline struct task_struct * get_current(void)
{
	struct task_struct *current;
	__asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
    94ca:	21 e0                	and    %esp,%eax
    94cc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    94cf:	8d be bc 00 00 00    	lea    0xbc(%esi),%edi

struct task_struct;

static inline struct task_struct * get_current(void)
{
    94d5:	39 47 40             	cmp    %eax,0x40(%edi)
    94d8:	8b 4b 70             	mov    0x70(%ebx),%ecx

struct task_struct;

static inline struct task_struct * get_current(void)
{
    94db:	0f 84 af 01 00 00    	je     9690 <tcp_fast_path_queue+0x1e0>
    94e1:	31 c0                	xor    %eax,%eax
    94e3:	85 d2                	test   %edx,%edx
    94e5:	0f 95 c0             	setne  %al
    94e8:	85 c9                	test   %ecx,%ecx
    94ea:	0f 84 be 00 00 00    	je     95ae <tcp_fast_path_queue+0xfe>
    94f0:	f6 87 ec 01 00 00 40 	testb  $0x40,0x1ec(%edi)
    94f7:	0f 85 63 01 00 00    	jne    9660 <tcp_fast_path_queue+0x1b0>
    94fd:	85 c0                	test   %eax,%eax
    94ff:	0f 85 16 01 00 00    	jne    961b <tcp_fast_path_queue+0x16b>
    9505:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    9508:	85 c0                	test   %eax,%eax
    950a:	0f 85 80 00 00 00    	jne    9590 <tcp_fast_path_queue+0xe0>
    9510:	ff 05 64 00 00 00    	incl   0x64
    9516:	8b 83 9c 00 00 00    	mov    0x9c(%ebx),%eax
    951c:	8b 00                	mov    (%eax),%eax
    951e:	48                   	dec    %eax
    951f:	74 0c                	je     952d <tcp_fast_path_queue+0x7d>
    9521:	c7 04 24 80 2e 00 00 	movl   $0x2e80,(%esp,1)
    9528:	e8 fc ff ff ff       	call   9529 <tcp_fast_path_queue+0x79>
 */	
 

static inline void __skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
    952d:	8d 46 48             	lea    0x48(%esi),%eax
	struct sk_buff *prev, *next;

	newsk->list = list;
	list->qlen++;
	next = (struct sk_buff *)list;
	prev = next->prev;
    9530:	8b 50 04             	mov    0x4(%eax),%edx
    9533:	89 43 08             	mov    %eax,0x8(%ebx)

static inline void tcp_set_owner_r(struct sk_buff *skb, struct sock *sk)
{
	skb->sk = sk;
	skb->destructor = tcp_rfree;
    9536:	b9 00 00 00 00       	mov    $0x0,%ecx
{
	struct sk_buff *prev, *next;

	newsk->list = list;
	list->qlen++;
    953b:	ff 40 08             	incl   0x8(%eax)
	next = (struct sk_buff *)list;
	prev = next->prev;
	newsk->next = next;
    953e:	89 03                	mov    %eax,(%ebx)
	newsk->prev = prev;
    9540:	89 53 04             	mov    %edx,0x4(%ebx)
	next->prev = newsk;
	prev->next = newsk;
    9543:	89 1a                	mov    %ebx,(%edx)
    9545:	89 58 04             	mov    %ebx,0x4(%eax)
 * Atomically adds @i to @v.  Note that the guaranteed useful range
 * of an atomic_t is only 24 bits.
 */
static __inline__ void atomic_add(int i, atomic_t *v)
{
    9548:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
extern void tcp_rfree(struct sk_buff *skb);

static inline void tcp_set_owner_r(struct sk_buff *skb, struct sock *sk)
{
	skb->sk = sk;
    954e:	89 73 0c             	mov    %esi,0xc(%ebx)
	skb->destructor = tcp_rfree;
    9551:	89 8b a0 00 00 00    	mov    %ecx,0xa0(%ebx)
 * of an atomic_t is only 24 bits.
 */
static __inline__ void atomic_add(int i, atomic_t *v)
{
	__asm__ __volatile__(
    9557:	01 46 44             	add    %eax,0x44(%esi)
{
	skb->sk = sk;
	skb->destructor = tcp_rfree;
	atomic_add(skb->truesize, &sk->rmem_alloc);
	sk->forward_alloc -= skb->truesize;
    955a:	8b 93 8c 00 00 00    	mov    0x8c(%ebx),%edx
    9560:	8b 46 6c             	mov    0x6c(%esi),%eax
    9563:	29 d0                	sub    %edx,%eax
    9565:	89 46 6c             	mov    %eax,0x6c(%esi)
    9568:	8b 53 44             	mov    0x44(%ebx),%edx
    956b:	89 57 08             	mov    %edx,0x8(%edi)
    956e:	8b 46 38             	mov    0x38(%esi),%eax
    9571:	89 c1                	mov    %eax,%ecx
    9573:	c1 f8 02             	sar    $0x2,%eax
    9576:	03 8f fc 00 00 00    	add    0xfc(%edi),%ecx
    957c:	8d 04 08             	lea    (%eax,%ecx,1),%eax
    957f:	39 c2                	cmp    %eax,%edx
    9581:	76 0d                	jbe    9590 <tcp_fast_path_queue+0xe0>
    9583:	a1 00 00 00 00       	mov    0x0,%eax
    9588:	85 c0                	test   %eax,%eax
    958a:	74 78                	je     9604 <tcp_fast_path_queue+0x154>
    958c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
}

static inline void sk_wake_async(struct sock *sk, int how, int band)
{
	if (sk->socket && sk->socket->fasync_list)
    9590:	8b 86 a0 0c 00 00    	mov    0xca0(%esi),%eax
    9596:	85 c0                	test   %eax,%eax
    9598:	74 07                	je     95a1 <tcp_fast_path_queue+0xf1>
    959a:	8b 78 10             	mov    0x10(%eax),%edi
    959d:	85 ff                	test   %edi,%edi
    959f:	75 49                	jne    95ea <tcp_fast_path_queue+0x13a>
    95a1:	8b 43 20             	mov    0x20(%ebx),%eax
    95a4:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    95a8:	24 01                	and    $0x1,%al
    95aa:	84 c0                	test   %al,%al
    95ac:	75 32                	jne    95e0 <tcp_fast_path_queue+0x130>
    95ae:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    95b1:	85 c9                	test   %ecx,%ecx
    95b3:	74 0f                	je     95c4 <tcp_fast_path_queue+0x114>
    95b5:	89 5d 08             	mov    %ebx,0x8(%ebp)
    95b8:	83 c4 10             	add    $0x10,%esp
    95bb:	5b                   	pop    %ebx
    95bc:	5e                   	pop    %esi
    95bd:	5f                   	pop    %edi
    95be:	5d                   	pop    %ebp
    95bf:	e9 fc ff ff ff       	jmp    95c0 <tcp_fast_path_queue+0x110>
    95c4:	89 34 24             	mov    %esi,(%esp,1)
    95c7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    95ce:	00 
    95cf:	ff 96 ac 0c 00 00    	call   *0xcac(%esi)
    95d5:	83 c4 10             	add    $0x10,%esp
    95d8:	5b                   	pop    %ebx
    95d9:	5e                   	pop    %esi
    95da:	5f                   	pop    %edi
    95db:	5d                   	pop    %ebp
    95dc:	c3                   	ret    
    95dd:	8d 76 00             	lea    0x0(%esi),%esi
    95e0:	89 34 24             	mov    %esi,(%esp,1)
    95e3:	e8 fc ff ff ff       	call   95e4 <tcp_fast_path_queue+0x134>
    95e8:	eb c4                	jmp    95ae <tcp_fast_path_queue+0xfe>

static inline void sk_wake_async(struct sock *sk, int how, int band)
{
	if (sk->socket && sk->socket->fasync_list)
		sock_wake_async(sk->socket, how, band);
    95ea:	c7 44 24 08 01 00 02 	movl   $0x20001,0x8(%esp,1)
    95f1:	00 
    95f2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    95f9:	00 
    95fa:	89 04 24             	mov    %eax,(%esp,1)
    95fd:	e8 fc ff ff ff       	call   95fe <tcp_fast_path_queue+0x14e>
    9602:	eb 9d                	jmp    95a1 <tcp_fast_path_queue+0xf1>
    9604:	c7 04 24 c0 2e 00 00 	movl   $0x2ec0,(%esp,1)
    960b:	29 ca                	sub    %ecx,%edx
    960d:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    9611:	e8 fc ff ff ff       	call   9612 <tcp_fast_path_queue+0x162>
    9616:	e9 75 ff ff ff       	jmp    9590 <tcp_fast_path_queue+0xe0>

static inline struct task_struct * get_current(void)
{
	struct task_struct *current;
	__asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
    961b:	b8 00 e0 ff ff       	mov    $0xffffe000,%eax
    9620:	21 e0                	and    %esp,%eax
    9622:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    9628:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    962f:	00 
    9630:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    9634:	89 34 24             	mov    %esi,(%esp,1)
    9637:	e8 94 ae ff ff       	call   44d0 <tcp_copy_to_iovec>
    963c:	85 c0                	test   %eax,%eax
    963e:	0f 85 c1 fe ff ff    	jne    9505 <tcp_fast_path_queue+0x55>
    9644:	8b 43 44             	mov    0x44(%ebx),%eax
    9647:	89 47 08             	mov    %eax,0x8(%edi)
    964a:	ff 05 68 00 00 00    	incl   0x68
    9650:	c7 45 f0 01 00 00 00 	movl   $0x1,0xfffffff0(%ebp)
    9657:	e9 a9 fe ff ff       	jmp    9505 <tcp_fast_path_queue+0x55>
    965c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    9660:	8b 43 44             	mov    0x44(%ebx),%eax
    9663:	89 47 08             	mov    %eax,0x8(%edi)
 */
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
    9666:	8b 83 84 00 00 00    	mov    0x84(%ebx),%eax
    966c:	48                   	dec    %eax
    966d:	74 11                	je     9680 <tcp_fast_path_queue+0x1d0>
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
	unsigned char c;

	__asm__ __volatile__(
    966f:	ff 8b 84 00 00 00    	decl   0x84(%ebx)
    9675:	0f 94 c0             	sete   %al
    9678:	84 c0                	test   %al,%al
    967a:	0f 84 10 ff ff ff    	je     9590 <tcp_fast_path_queue+0xe0>
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
		__kfree_skb(skb);
    9680:	89 1c 24             	mov    %ebx,(%esp,1)
    9683:	e8 fc ff ff ff       	call   9684 <tcp_fast_path_queue+0x1d4>
    9688:	e9 03 ff ff ff       	jmp    9590 <tcp_fast_path_queue+0xe0>
    968d:	8d 76 00             	lea    0x0(%esi),%esi
    9690:	8b 47 08             	mov    0x8(%edi),%eax
    9693:	39 87 fc 00 00 00    	cmp    %eax,0xfc(%edi)
    9699:	0f 85 42 fe ff ff    	jne    94e1 <tcp_fast_path_queue+0x31>
    969f:	3b 4f 4c             	cmp    0x4c(%edi),%ecx
    96a2:	0f 8f 39 fe ff ff    	jg     94e1 <tcp_fast_path_queue+0x31>
    96a8:	8b 46 2c             	mov    0x2c(%esi),%eax
    96ab:	ba 01 00 00 00       	mov    $0x1,%edx
    96b0:	85 c0                	test   %eax,%eax
    96b2:	0f 44 55 f0          	cmove  0xfffffff0(%ebp),%edx
    96b6:	e9 26 fe ff ff       	jmp    94e1 <tcp_fast_path_queue+0x31>
    96bb:	90                   	nop    
    96bc:	8d 74 26 00          	lea    0x0(%esi,1),%esi

000096c0 <clientSideContinuation_init>:
    96c0:	55                   	push   %ebp
    96c1:	89 e5                	mov    %esp,%ebp
    96c3:	5d                   	pop    %ebp
    96c4:	c3                   	ret    

000096c5 <.text.lock.tmalloc>:
    96c5:	50                   	push   %eax
    96c6:	51                   	push   %ecx
    96c7:	52                   	push   %edx
    96c8:	e8 fc ff ff ff       	call   96c9 <.text.lock.tmalloc+0x4>
    96cd:	5a                   	pop    %edx
    96ce:	59                   	pop    %ecx
    96cf:	58                   	pop    %eax
    96d0:	e9 b9 74 ff ff       	jmp    b8e <__tcp_checksum_complete_user+0x3e>
    96d5:	50                   	push   %eax
    96d6:	51                   	push   %ecx
    96d7:	52                   	push   %edx
    96d8:	e8 fc ff ff ff       	call   96d9 <.text.lock.tmalloc+0x14>
    96dd:	5a                   	pop    %edx
    96de:	59                   	pop    %ecx
    96df:	58                   	pop    %eax
    96e0:	e9 2c ae ff ff       	jmp    4511 <tcp_copy_to_iovec+0x41>
    96e5:	50                   	push   %eax
    96e6:	51                   	push   %ecx
    96e7:	52                   	push   %edx
    96e8:	e8 fc ff ff ff       	call   96e9 <.text.lock.tmalloc+0x24>
    96ed:	5a                   	pop    %edx
    96ee:	59                   	pop    %ecx
    96ef:	58                   	pop    %eax
    96f0:	e9 f4 e7 ff ff       	jmp    7ee9 <cleanup_module+0x109>
    96f5:	50                   	push   %eax
    96f6:	51                   	push   %ecx
    96f7:	52                   	push   %edx
    96f8:	e8 fc ff ff ff       	call   96f9 <.text.lock.tmalloc+0x34>
    96fd:	5a                   	pop    %edx
    96fe:	59                   	pop    %ecx
    96ff:	58                   	pop    %eax
    9700:	e9 54 e9 ff ff       	jmp    8059 <cleanup_module+0x279>
    9705:	90                   	nop    
    9706:	90                   	nop    
    9707:	90                   	nop    
    9708:	90                   	nop    
    9709:	90                   	nop    
    970a:	90                   	nop    
    970b:	90                   	nop    
    970c:	90                   	nop    
    970d:	90                   	nop    
    970e:	90                   	nop    
    970f:	90                   	nop    

00009710 <free_trickles_msk>:
/* Two phase free: first phase disconnects socket from event list,
   sets to ALLOC_PROCESSING; second phase adds the socket to free
   list, sets to ALLOC_FREE and ready for reuse */
#ifndef USERTEST
static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk) {
    9710:	55                   	push   %ebp
    9711:	89 e5                	mov    %esp,%ebp
    9713:	83 ec 0c             	sub    $0xc,%esp
    9716:	89 5d fc             	mov    %ebx,0xfffffffc(%ebp)
	if(!SIMULATION_MODE(sk)) {
    9719:	8b 45 08             	mov    0x8(%ebp),%eax
    971c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    971f:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    9725:	a9 01 00 00 00       	test   $0x1,%eax
    972a:	74 05                	je     9731 <free_trickles_msk+0x21>
    972c:	83 e0 08             	and    $0x8,%eax
    972f:	74 16                	je     9747 <free_trickles_msk+0x37>
		if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) {
    9731:	8b 43 0c             	mov    0xc(%ebx),%eax
    9734:	85 c0                	test   %eax,%eax
    9736:	74 48                	je     9780 <free_trickles_msk+0x70>
    9738:	83 f8 03             	cmp    $0x3,%eax
    973b:	74 43                	je     9780 <free_trickles_msk+0x70>
			printk("double free\n");
			BUG();
		}
		if(msk->ctl == ALLOC_READY && msk->prev != NULL) {
    973d:	48                   	dec    %eax
    973e:	74 10                	je     9750 <free_trickles_msk+0x40>
			unlink((struct alloc_head *)msk);
		}
		msk->ctl = ALLOC_PROCESSING;
    9740:	c7 43 0c 03 00 00 00 	movl   $0x3,0xc(%ebx)
	}
}
    9747:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
    974a:	89 ec                	mov    %ebp,%esp
    974c:	5d                   	pop    %ebp
    974d:	c3                   	ret    
    974e:	89 f6                	mov    %esi,%esi
    9750:	8b 03                	mov    (%ebx),%eax
    9752:	85 c0                	test   %eax,%eax
    9754:	74 ea                	je     9740 <free_trickles_msk+0x30>
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    9756:	8b 53 04             	mov    0x4(%ebx),%edx
    9759:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    975b:	8b 03                	mov    (%ebx),%eax
	elem->prev = elem->next = NULL;
    975d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    9763:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
    9766:	8b 43 08             	mov    0x8(%ebx),%eax
    9769:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    9770:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    9773:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    977a:	eb c4                	jmp    9740 <free_trickles_msk+0x30>
    977c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
#ifndef USERTEST
static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk) {
	if(!SIMULATION_MODE(sk)) {
		if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) {
			printk("double free\n");
    9780:	c7 04 24 71 05 00 00 	movl   $0x571,(%esp,1)
    9787:	e8 fc ff ff ff       	call   9788 <free_trickles_msk+0x78>
			BUG();
    978c:	c7 44 24 04 7e 05 00 	movl   $0x57e,0x4(%esp,1)
    9793:	00 
    9794:	c7 04 24 82 05 00 00 	movl   $0x582,(%esp,1)
    979b:	e8 fc ff ff ff       	call   979c <free_trickles_msk+0x8c>
    97a0:	e8 fc ff ff ff       	call   97a1 <free_trickles_msk+0x91>
    97a5:	8b 43 0c             	mov    0xc(%ebx),%eax
    97a8:	eb 93                	jmp    973d <free_trickles_msk+0x2d>
    97aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

000097b0 <free_trickles_msk_finish>:
		}
		if(msk->ctl == ALLOC_READY && msk->prev != NULL) {
			unlink((struct alloc_head *)msk);
		}
		msk->ctl = ALLOC_PROCESSING;
	}
}

static inline void free_trickles_msk_finish(struct sock *sk, struct cminisock *msk) {
    97b0:	55                   	push   %ebp
    97b1:	89 e5                	mov    %esp,%ebp
    97b3:	57                   	push   %edi
    97b4:	56                   	push   %esi
    97b5:	31 f6                	xor    %esi,%esi
    97b7:	53                   	push   %ebx
    97b8:	83 ec 10             	sub    $0x10,%esp
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
    97bb:	8b 45 08             	mov    0x8(%ebp),%eax
	struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
    97be:	8b 55 08             	mov    0x8(%ebp),%edx
    97c1:	8b 7d 0c             	mov    0xc(%ebp),%edi
    97c4:	05 bc 00 00 00       	add    $0xbc,%eax
    97c9:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    97cc:	81 c2 90 02 00 00    	add    $0x290,%edx
    97d2:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
    97d5:	8b 97 dc 00 00 00    	mov    0xdc(%edi),%edx
    97db:	39 d6                	cmp    %edx,%esi
    97dd:	7d 2b                	jge    980a <free_trickles_msk_finish+0x5a>
    97df:	31 db                	xor    %ebx,%ebx
    97e1:	eb 0d                	jmp    97f0 <free_trickles_msk_finish+0x40>
    97e3:	90                   	nop    
    97e4:	90                   	nop    
    97e5:	90                   	nop    
    97e6:	90                   	nop    
    97e7:	90                   	nop    
    97e8:	90                   	nop    
    97e9:	90                   	nop    
    97ea:	90                   	nop    
    97eb:	90                   	nop    
    97ec:	90                   	nop    
    97ed:	90                   	nop    
    97ee:	90                   	nop    
    97ef:	90                   	nop    
    97f0:	8b 87 e0 00 00 00    	mov    0xe0(%edi),%eax
    97f6:	8b 44 18 18          	mov    0x18(%eax,%ebx,1),%eax
    97fa:	85 c0                	test   %eax,%eax
    97fc:	0f 85 6e 01 00 00    	jne    9970 <free_trickles_msk_finish+0x1c0>
    9802:	46                   	inc    %esi
    9803:	83 c3 28             	add    $0x28,%ebx
    9806:	39 d6                	cmp    %edx,%esi
    9808:	7c e6                	jl     97f0 <free_trickles_msk_finish+0x40>
    980a:	8b 55 08             	mov    0x8(%ebp),%edx
    980d:	8b 82 a8 02 00 00    	mov    0x2a8(%edx),%eax
    9813:	a9 01 00 00 00       	test   $0x1,%eax
    9818:	74 05                	je     981f <free_trickles_msk_finish+0x6f>
    981a:	83 e0 08             	and    $0x8,%eax
    981d:	74 0e                	je     982d <free_trickles_msk_finish+0x7d>
    981f:	8b 87 e0 00 00 00    	mov    0xe0(%edi),%eax
    9825:	85 c0                	test   %eax,%eax
    9827:	0f 85 2d 01 00 00    	jne    995a <free_trickles_msk_finish+0x1aa>
    982d:	8b 87 80 00 00 00    	mov    0x80(%edi),%eax
    9833:	85 c0                	test   %eax,%eax
    9835:	0f 85 0b 01 00 00    	jne    9946 <free_trickles_msk_finish+0x196>
    983b:	8b 87 88 00 00 00    	mov    0x88(%edi),%eax
    9841:	85 c0                	test   %eax,%eax
    9843:	0f 85 e9 00 00 00    	jne    9932 <free_trickles_msk_finish+0x182>

	free_minisock(sk,msk);
	if(!SIMULATION_MODE(sk)) {
    9849:	8b 55 08             	mov    0x8(%ebp),%edx
    984c:	8b 82 a8 02 00 00    	mov    0x2a8(%edx),%eax
    9852:	a9 01 00 00 00       	test   $0x1,%eax
    9857:	74 09                	je     9862 <free_trickles_msk_finish+0xb2>
    9859:	83 e0 08             	and    $0x8,%eax
    985c:	0f 84 89 00 00 00    	je     98eb <free_trickles_msk_finish+0x13b>
		if(msk->ctl != ALLOC_PROCESSING && msk->ctl != ALLOC_HALFFREE) {
    9862:	8b 47 0c             	mov    0xc(%edi),%eax
    9865:	83 e8 03             	sub    $0x3,%eax
    9868:	83 f8 01             	cmp    $0x1,%eax
    986b:	77 57                	ja     98c4 <free_trickles_msk_finish+0x114>
	if(elem->list) {
		BUG();
	}
#endif
	if(head->next == elem /* || elem->prev != NULL || elem->next != NULL */) {
    986d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    9870:	39 78 04             	cmp    %edi,0x4(%eax)
    9873:	74 28                	je     989d <free_trickles_msk_finish+0xed>
		BUG();
		show_stack(NULL);	
	}
	elem->next = head->next;
    9875:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    9878:	8b 42 04             	mov    0x4(%edx),%eax
    987b:	89 47 04             	mov    %eax,0x4(%edi)
	head->next->prev = elem;
    987e:	8b 42 04             	mov    0x4(%edx),%eax
    9881:	89 38                	mov    %edi,(%eax)

	elem->prev = (struct alloc_head*)head;
    9883:	89 17                	mov    %edx,(%edi)
	head->next = elem;
    9885:	89 7a 04             	mov    %edi,0x4(%edx)

	elem->list = head;
    9888:	89 57 08             	mov    %edx,0x8(%edi)
	head->len++;
    988b:	ff 42 10             	incl   0x10(%edx)
			printk("free_rstcp_msk_finish without corresponding free_rstcp_msk\n");
			BUG();
		}
		insert_head(head, (struct alloc_head *)msk);
		msk->ctl = ALLOC_FREE;
    988e:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
	} else {
		if(msk == tp->t.responseMSK) {
		} else {
			// overflow
			unlink((struct alloc_head*)msk);
			kfree(msk);
		}
		tp->t.responseCount--;
	}
	
}
    9895:	83 c4 10             	add    $0x10,%esp
    9898:	5b                   	pop    %ebx
    9899:	5e                   	pop    %esi
    989a:	5f                   	pop    %edi
    989b:	5d                   	pop    %ebp
    989c:	c3                   	ret    
		BUG();
	}
#endif
	if(head->next == elem /* || elem->prev != NULL || elem->next != NULL */) {
		BUG();
    989d:	c7 44 24 04 7e 05 00 	movl   $0x57e,0x4(%esp,1)
    98a4:	00 
    98a5:	c7 04 24 82 05 00 00 	movl   $0x582,(%esp,1)
    98ac:	e8 fc ff ff ff       	call   98ad <free_trickles_msk_finish+0xfd>
    98b1:	e8 fc ff ff ff       	call   98b2 <free_trickles_msk_finish+0x102>
		show_stack(NULL);	
    98b6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    98bd:	e8 fc ff ff ff       	call   98be <free_trickles_msk_finish+0x10e>
    98c2:	eb b1                	jmp    9875 <free_trickles_msk_finish+0xc5>

	free_minisock(sk,msk);
	if(!SIMULATION_MODE(sk)) {
		if(msk->ctl != ALLOC_PROCESSING && msk->ctl != ALLOC_HALFFREE) {
			printk("free_rstcp_msk_finish without corresponding free_rstcp_msk\n");
    98c4:	c7 04 24 00 2f 00 00 	movl   $0x2f00,(%esp,1)
    98cb:	e8 fc ff ff ff       	call   98cc <free_trickles_msk_finish+0x11c>
			BUG();
    98d0:	c7 44 24 04 7e 05 00 	movl   $0x57e,0x4(%esp,1)
    98d7:	00 
    98d8:	c7 04 24 82 05 00 00 	movl   $0x582,(%esp,1)
    98df:	e8 fc ff ff ff       	call   98e0 <free_trickles_msk_finish+0x130>
    98e4:	e8 fc ff ff ff       	call   98e5 <free_trickles_msk_finish+0x135>
    98e9:	eb 82                	jmp    986d <free_trickles_msk_finish+0xbd>
		}
		insert_head(head, (struct alloc_head *)msk);
		msk->ctl = ALLOC_FREE;
	} else {
		if(msk == tp->t.responseMSK) {
    98eb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    98ee:	3b b8 3c 0b 00 00    	cmp    0xb3c(%eax),%edi
    98f4:	74 2e                	je     9924 <free_trickles_msk_finish+0x174>
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    98f6:	8b 57 04             	mov    0x4(%edi),%edx
    98f9:	8b 07                	mov    (%edi),%eax
    98fb:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    98fd:	8b 07                	mov    (%edi),%eax
	elem->prev = elem->next = NULL;
    98ff:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    9905:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
    9908:	8b 47 08             	mov    0x8(%edi),%eax
    990b:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
    9912:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    9915:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
		if(msk == tp->t.responseMSK) {
		} else {
			// overflow
			unlink((struct alloc_head*)msk);
			kfree(msk);
    991c:	89 3c 24             	mov    %edi,(%esp,1)
    991f:	e8 fc ff ff ff       	call   9920 <free_trickles_msk_finish+0x170>
		}
		tp->t.responseCount--;
    9924:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    9927:	ff 8a 54 0b 00 00    	decl   0xb54(%edx)
    992d:	e9 63 ff ff ff       	jmp    9895 <free_trickles_msk_finish+0xe5>
    9932:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    9936:	8b 45 08             	mov    0x8(%ebp),%eax
    9939:	89 04 24             	mov    %eax,(%esp,1)
    993c:	e8 fc ff ff ff       	call   993d <free_trickles_msk_finish+0x18d>
    9941:	e9 03 ff ff ff       	jmp    9849 <free_trickles_msk_finish+0x99>
    9946:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    994a:	8b 55 08             	mov    0x8(%ebp),%edx
    994d:	89 14 24             	mov    %edx,(%esp,1)
    9950:	e8 fc ff ff ff       	call   9951 <free_trickles_msk_finish+0x1a1>
    9955:	e9 e1 fe ff ff       	jmp    983b <free_trickles_msk_finish+0x8b>
    995a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    995e:	8b 45 08             	mov    0x8(%ebp),%eax
    9961:	89 04 24             	mov    %eax,(%esp,1)
    9964:	e8 fc ff ff ff       	call   9965 <free_trickles_msk_finish+0x1b5>
    9969:	e9 bf fe ff ff       	jmp    982d <free_trickles_msk_finish+0x7d>
    996e:	89 f6                	mov    %esi,%esi
    9970:	89 04 24             	mov    %eax,(%esp,1)
    9973:	e8 fc ff ff ff       	call   9974 <free_trickles_msk_finish+0x1c4>
    9978:	8b 97 dc 00 00 00    	mov    0xdc(%edi),%edx
    997e:	e9 7f fe ff ff       	jmp    9802 <free_trickles_msk_finish+0x52>
    9983:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    9989:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00009990 <trickles_morecore>:
#include "compat.h"
#include "skbuff.h"
#endif

void *trickles_morecore(struct sock *sk, long size) {
    9990:	55                   	push   %ebp
    9991:	89 e5                	mov    %esp,%ebp
    9993:	83 ec 14             	sub    $0x14,%esp
    9996:	89 5d fc             	mov    %ebx,0xfffffffc(%ebp)
    void *result;
    struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    9999:	8b 55 08             	mov    0x8(%ebp),%edx
    if(tp->t.heapbytesallocated + size > tp->t.heapbytesize) {
    999c:	8b 45 0c             	mov    0xc(%ebp),%eax
    999f:	81 c2 bc 00 00 00    	add    $0xbc,%edx
    99a5:	8b 8a 20 02 00 00    	mov    0x220(%edx),%ecx
    99ab:	89 cb                	mov    %ecx,%ebx
    99ad:	01 c3                	add    %eax,%ebx
    99af:	3b 9a 1c 02 00 00    	cmp    0x21c(%edx),%ebx
    99b5:	0f 8e b5 00 00 00    	jle    9a70 <trickles_morecore+0xe0>
      if(trickles_ratelimit()) {
    99bb:	a1 00 00 00 00       	mov    0x0,%eax
    99c0:	9c                   	pushf  
    99c1:	59                   	pop    %ecx
    99c2:	fa                   	cli    
    99c3:	89 c2                	mov    %eax,%edx
    99c5:	8b 1d 50 d2 09 00    	mov    0x9d250,%ebx
    99cb:	a3 50 d2 09 00       	mov    %eax,0x9d250
    99d0:	29 da                	sub    %ebx,%edx
    99d2:	8b 1d cc 00 00 00    	mov    0xcc,%ebx
    99d8:	01 da                	add    %ebx,%edx
    99da:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    99e0:	89 15 cc 00 00 00    	mov    %edx,0xcc
    99e6:	76 0f                	jbe    99f7 <trickles_morecore+0x67>
    99e8:	b8 88 13 00 00       	mov    $0x1388,%eax
    99ed:	ba 88 13 00 00       	mov    $0x1388,%edx
    99f2:	a3 cc 00 00 00       	mov    %eax,0xcc
    99f7:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    99fd:	76 61                	jbe    9a60 <trickles_morecore+0xd0>
    99ff:	31 db                	xor    %ebx,%ebx
    9a01:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    9a07:	a1 54 d2 09 00       	mov    0x9d254,%eax
    9a0c:	89 15 cc 00 00 00    	mov    %edx,0xcc
    9a12:	89 1d 54 d2 09 00    	mov    %ebx,0x9d254
    9a18:	51                   	push   %ecx
    9a19:	9d                   	popf   
    9a1a:	85 c0                	test   %eax,%eax
    9a1c:	75 20                	jne    9a3e <trickles_morecore+0xae>
    9a1e:	b8 01 00 00 00       	mov    $0x1,%eax
    9a23:	85 c0                	test   %eax,%eax
    9a25:	75 09                	jne    9a30 <trickles_morecore+0xa0>
	printk("tmalloc: out of memory\n");
      }
      return NULL;
    9a27:	31 c0                	xor    %eax,%eax
    }
#ifndef USERTEST
    result = (char*)tp->cminisock_api_config.cfg.ctl->heap_base;
#else 
    result = (char*)tp->t.heap_absolute_base;
#endif
    result = (char*)result + tp->t.heapbytesallocated;
    tp->t.heapbytesallocated += size;
    return result;
}
    9a29:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
    9a2c:	89 ec                	mov    %ebp,%esp
    9a2e:	5d                   	pop    %ebp
    9a2f:	c3                   	ret    
    9a30:	c7 04 24 9d 05 00 00 	movl   $0x59d,(%esp,1)
    9a37:	e8 fc ff ff ff       	call   9a38 <trickles_morecore+0xa8>
    9a3c:	eb e9                	jmp    9a27 <trickles_morecore+0x97>
    9a3e:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    9a42:	c7 44 24 08 1e 00 00 	movl   $0x1e,0x8(%esp,1)
    9a49:	00 
    9a4a:	c7 44 24 04 b5 05 00 	movl   $0x5b5,0x4(%esp,1)
    9a51:	00 
    9a52:	c7 04 24 40 2f 00 00 	movl   $0x2f40,(%esp,1)
    9a59:	e8 fc ff ff ff       	call   9a5a <trickles_morecore+0xca>
    9a5e:	eb be                	jmp    9a1e <trickles_morecore+0x8e>
    9a60:	ff 05 54 d2 09 00    	incl   0x9d254
    9a66:	51                   	push   %ecx
    9a67:	9d                   	popf   
    9a68:	31 c0                	xor    %eax,%eax
    9a6a:	eb b7                	jmp    9a23 <trickles_morecore+0x93>
    9a6c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    9a70:	8b 82 cc 01 00 00    	mov    0x1cc(%edx),%eax
    9a76:	03 48 10             	add    0x10(%eax),%ecx
    9a79:	89 9a 20 02 00 00    	mov    %ebx,0x220(%edx)
    9a7f:	89 c8                	mov    %ecx,%eax
    9a81:	eb a6                	jmp    9a29 <trickles_morecore+0x99>
    9a83:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    9a89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00009a90 <align>:

void *(*_morecore)(struct sock *, long) = trickles_morecore;

void tfree(struct sock *sk, void *ptr);

/* Aligned allocation. */
static void *
align(struct sock *sk, size_t size)
{
    9a90:	55                   	push   %ebp
    9a91:	89 e5                	mov    %esp,%ebp
    9a93:	83 ec 14             	sub    $0x14,%esp
    9a96:	89 7d fc             	mov    %edi,0xfffffffc(%ebp)
    void *result;
    unsigned int adj;

    result = (*_morecore)(sk, size);
    9a99:	8b 45 0c             	mov    0xc(%ebp),%eax
    9a9c:	8b 7d 08             	mov    0x8(%ebp),%edi
    9a9f:	89 75 f8             	mov    %esi,0xfffffff8(%ebp)
    9aa2:	89 5d f4             	mov    %ebx,0xfffffff4(%ebp)
    9aa5:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    9aa9:	89 3c 24             	mov    %edi,(%esp,1)
    9aac:	ff 15 00 00 00 00    	call   *0x0
    9ab2:	89 c6                	mov    %eax,%esi
    adj = (unsigned int) ((char *) result - (char *) NULL) % BLOCKSIZE;
    if (adj != 0) {
    9ab4:	25 ff 0f 00 00       	and    $0xfff,%eax
    9ab9:	75 15                	jne    9ad0 <align+0x40>
	(*_morecore)(sk,adj = BLOCKSIZE - adj);
	result = (char *) result + adj;
    }
    return result;
}
    9abb:	89 f0                	mov    %esi,%eax
    9abd:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
    9ac0:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
    9ac3:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
    9ac6:	89 ec                	mov    %ebp,%esp
    9ac8:	5d                   	pop    %ebp
    9ac9:	c3                   	ret    
    9aca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    9ad0:	89 3c 24             	mov    %edi,(%esp,1)
    9ad3:	bb 00 10 00 00       	mov    $0x1000,%ebx
    9ad8:	29 c3                	sub    %eax,%ebx
    9ada:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    9ade:	01 de                	add    %ebx,%esi
    9ae0:	ff 15 00 00 00 00    	call   *0x0
    9ae6:	eb d3                	jmp    9abb <align+0x2b>
    9ae8:	90                   	nop    
    9ae9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi

00009af0 <initialize_malloc>:

/* Set everything up and remember that we have. */
static int
initialize_malloc(struct sock *sk)
{
    9af0:	55                   	push   %ebp
    9af1:	89 e5                	mov    %esp,%ebp
    9af3:	83 ec 18             	sub    $0x18,%esp
    9af6:	89 5d f4             	mov    %ebx,0xfffffff4(%ebp)
    9af9:	8b 4d 08             	mov    0x8(%ebp),%ecx
    9afc:	89 7d fc             	mov    %edi,0xfffffffc(%ebp)
    9aff:	89 75 f8             	mov    %esi,0xfffffff8(%ebp)
    struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    9b02:	8d 99 bc 00 00 00    	lea    0xbc(%ecx),%ebx
    tp->t.heapsize = tp->t.heapbytesize / BLOCKSIZE;
    9b08:	8b 93 1c 02 00 00    	mov    0x21c(%ebx),%edx
    9b0e:	83 fa ff             	cmp    $0xffffffff,%edx
    9b11:	8d 82 ff 0f 00 00    	lea    0xfff(%edx),%eax
    9b17:	0f 4f c2             	cmovg  %edx,%eax
    9b1a:	c1 f8 0c             	sar    $0xc,%eax
    9b1d:	89 83 24 02 00 00    	mov    %eax,0x224(%ebx)
    tp->t.heapinfo = align(sk, tp->t.heapsize * sizeof (union heap_info));
    9b23:	8d 04 40             	lea    (%eax,%eax,2),%eax
    9b26:	c1 e0 02             	shl    $0x2,%eax
    9b29:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    9b2d:	89 0c 24             	mov    %ecx,(%esp,1)
    9b30:	e8 5b ff ff ff       	call   9a90 <align>
    9b35:	89 83 2c 02 00 00    	mov    %eax,0x22c(%ebx)
    9b3b:	89 c7                	mov    %eax,%edi
    if (!tp->t.heapinfo)
    9b3d:	31 c0                	xor    %eax,%eax
    9b3f:	85 ff                	test   %edi,%edi
    9b41:	74 6c                	je     9baf <initialize_malloc+0xbf>
	return 0;
    memset(tp->t.heapinfo, 0, tp->t.heapsize * sizeof (union heap_info));
    9b43:	8b 83 24 02 00 00    	mov    0x224(%ebx),%eax
    9b49:	8d 04 40             	lea    (%eax,%eax,2),%eax
    9b4c:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
 */
static inline void * __constant_c_memset(void * s, unsigned long c, size_t count)
{
int d0, d1;
__asm__ __volatile__(
    9b53:	31 c0                	xor    %eax,%eax
    9b55:	89 f1                	mov    %esi,%ecx
    9b57:	c1 e9 02             	shr    $0x2,%ecx
    9b5a:	89 f2                	mov    %esi,%edx
    9b5c:	f3 ab                	repz stos %eax,%es:(%edi)
    9b5e:	f6 c2 02             	test   $0x2,%dl
    9b61:	74 02                	je     9b65 <initialize_malloc+0x75>
    9b63:	66 ab                	stos   %ax,%es:(%edi)
    9b65:	f6 c2 01             	test   $0x1,%dl
    9b68:	74 01                	je     9b6b <initialize_malloc+0x7b>
    9b6a:	aa                   	stos   %al,%es:(%edi)
    tp->t.heapinfo[0].free.size = 0;
    9b6b:	8b 83 2c 02 00 00    	mov    0x22c(%ebx),%eax
    9b71:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    tp->t.heapinfo[0].free.next = tp->t.heapinfo[0].free.prev = 0;
    9b77:	8b 83 2c 02 00 00    	mov    0x22c(%ebx),%eax
    9b7d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    9b84:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    tp->t.heapindex = 0;
    9b8b:	31 c0                	xor    %eax,%eax
    9b8d:	89 83 30 02 00 00    	mov    %eax,0x230(%ebx)
    tp->t.heapbase = (char *) tp->t.heapinfo;
    9b93:	8b 83 2c 02 00 00    	mov    0x22c(%ebx),%eax
    9b99:	89 83 28 02 00 00    	mov    %eax,0x228(%ebx)
    tp->t.malloc_initialized = 1;
    9b9f:	b8 01 00 00 00       	mov    $0x1,%eax
    9ba4:	89 83 18 02 00 00    	mov    %eax,0x218(%ebx)
    return 1;
    9baa:	b8 01 00 00 00       	mov    $0x1,%eax
}
    9baf:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
    9bb2:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
    9bb5:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
    9bb8:	89 ec                	mov    %ebp,%esp
    9bba:	5d                   	pop    %ebp
    9bbb:	c3                   	ret    
    9bbc:	8d 74 26 00          	lea    0x0(%esi,1),%esi

00009bc0 <morecore>:

/* Get neatly aligned memory, initializing or growing the
   heap info table as necessary. */
static void *
morecore(struct sock *sk, size_t size)
{
    9bc0:	55                   	push   %ebp
    9bc1:	89 e5                	mov    %esp,%ebp
    9bc3:	57                   	push   %edi
    9bc4:	56                   	push   %esi
    9bc5:	53                   	push   %ebx
    9bc6:	83 ec 24             	sub    $0x24,%esp
    struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    9bc9:	8b 45 08             	mov    0x8(%ebp),%eax
    void *result;
    union heap_info *newinfo, *oldinfo;
    int newsize;

    result = align(sk,size);
    9bcc:	8b 55 08             	mov    0x8(%ebp),%edx
    9bcf:	8b 7d 0c             	mov    0xc(%ebp),%edi
    9bd2:	05 bc 00 00 00       	add    $0xbc,%eax
    9bd7:	89 14 24             	mov    %edx,(%esp,1)
    9bda:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    9bdd:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
    9be1:	e8 aa fe ff ff       	call   9a90 <align>
    9be6:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    if (!result)
    9be9:	31 c0                	xor    %eax,%eax
    9beb:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    9bee:	85 d2                	test   %edx,%edx
    9bf0:	0f 84 82 01 00 00    	je     9d78 <morecore+0x1b8>
	return NULL;

    /* Check if we need to grow the info table. */
    if (BLOCK(sk,(char *) result + size) > tp->t.heapsize) {
    9bf6:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
    9bf9:	8b 45 08             	mov    0x8(%ebp),%eax
    9bfc:	01 fb                	add    %edi,%ebx
    9bfe:	89 5d e0             	mov    %ebx,0xffffffe0(%ebp)
    9c01:	8b 98 e4 02 00 00    	mov    0x2e4(%eax),%ebx
    9c07:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    9c0a:	29 da                	sub    %ebx,%edx
    9c0c:	83 fa ff             	cmp    $0xffffffff,%edx
    9c0f:	8d b2 ff 0f 00 00    	lea    0xfff(%edx),%esi
    9c15:	89 d0                	mov    %edx,%eax
    9c17:	0f 4e c6             	cmovle %esi,%eax
    9c1a:	c1 f8 0c             	sar    $0xc,%eax
    9c1d:	40                   	inc    %eax
    9c1e:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    9c21:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    9c24:	8b 88 24 02 00 00    	mov    0x224(%eax),%ecx
    9c2a:	39 4d dc             	cmp    %ecx,0xffffffdc(%ebp)
    9c2d:	0f 8e 24 01 00 00    	jle    9d57 <morecore+0x197>
	newsize = tp->t.heapsize;
    9c33:	89 4d e4             	mov    %ecx,0xffffffe4(%ebp)
	while (BLOCK(sk,(char *) result + size) > newsize)
    9c36:	89 f1                	mov    %esi,%ecx
    9c38:	90                   	nop    
    9c39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    9c40:	83 fa ff             	cmp    $0xffffffff,%edx
    9c43:	89 d0                	mov    %edx,%eax
    9c45:	0f 4e c1             	cmovle %ecx,%eax
    9c48:	c1 f8 0c             	sar    $0xc,%eax
    9c4b:	40                   	inc    %eax
    9c4c:	3b 45 e4             	cmp    0xffffffe4(%ebp),%eax
    9c4f:	7e 05                	jle    9c56 <morecore+0x96>
	    newsize *= 2;
    9c51:	d1 65 e4             	shll   0xffffffe4(%ebp)
    9c54:	eb ea                	jmp    9c40 <morecore+0x80>
	newinfo = align(sk,newsize * sizeof (union heap_info));
    9c56:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    9c59:	8d 04 52             	lea    (%edx,%edx,2),%eax
    9c5c:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    9c63:	8b 45 08             	mov    0x8(%ebp),%eax
    9c66:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    9c6a:	89 04 24             	mov    %eax,(%esp,1)
    9c6d:	e8 1e fe ff ff       	call   9a90 <align>
    9c72:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
	if (!newinfo) {
    9c75:	85 c0                	test   %eax,%eax
    9c77:	0f 84 03 01 00 00    	je     9d80 <morecore+0x1c0>
 */
static inline void * __constant_c_memset(void * s, unsigned long c, size_t count)
{
int d0, d1;
__asm__ __volatile__(
    9c7d:	89 d9                	mov    %ebx,%ecx
	    (*_morecore)(sk,-size);
	    return NULL;
	}
	memset(newinfo, 0, newsize * sizeof (union heap_info));
    9c7f:	31 c0                	xor    %eax,%eax
 */
static inline void * __constant_c_memset(void * s, unsigned long c, size_t count)
{
int d0, d1;
__asm__ __volatile__(
    9c81:	c1 e9 02             	shr    $0x2,%ecx
    9c84:	8b 7d e8             	mov    0xffffffe8(%ebp),%edi
    9c87:	f3 ab                	repz stos %eax,%es:(%edi)
    9c89:	f6 c3 02             	test   $0x2,%bl
    9c8c:	74 02                	je     9c90 <morecore+0xd0>
    9c8e:	66 ab                	stos   %ax,%es:(%edi)
    9c90:	f6 c3 01             	test   $0x1,%bl
    9c93:	74 01                	je     9c96 <morecore+0xd6>
    9c95:	aa                   	stos   %al,%es:(%edi)
	memcpy(newinfo, tp->t.heapinfo, tp->t.heapsize * sizeof (union heap_info));
    9c96:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx

static inline void * __memcpy(void * to, const void * from, size_t n)
{
int d0, d1, d2;
__asm__ __volatile__(
    9c99:	8b 7d e8             	mov    0xffffffe8(%ebp),%edi
    9c9c:	8b 83 24 02 00 00    	mov    0x224(%ebx),%eax
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
    9ca2:	8b b3 2c 02 00 00    	mov    0x22c(%ebx),%esi
    9ca8:	8d 04 40             	lea    (%eax,%eax,2),%eax
    9cab:	c1 e0 02             	shl    $0x2,%eax

static inline void * __memcpy(void * to, const void * from, size_t n)
{
int d0, d1, d2;
__asm__ __volatile__(
    9cae:	89 c1                	mov    %eax,%ecx
    9cb0:	c1 e9 02             	shr    $0x2,%ecx
    9cb3:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    9cb5:	a8 02                	test   $0x2,%al
    9cb7:	74 02                	je     9cbb <morecore+0xfb>
    9cb9:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    9cbb:	a8 01                	test   $0x1,%al
    9cbd:	74 01                	je     9cc0 <morecore+0x100>
    9cbf:	a4                   	movsb  %ds:(%esi),%es:(%edi)
	oldinfo = tp->t.heapinfo;
	newinfo[BLOCK(sk,oldinfo)].busy.type = 0;
    9cc0:	8b 55 08             	mov    0x8(%ebp),%edx
    9cc3:	8b 8b 2c 02 00 00    	mov    0x22c(%ebx),%ecx
    9cc9:	8b 5d e8             	mov    0xffffffe8(%ebp),%ebx
    9ccc:	8b ba e4 02 00 00    	mov    0x2e4(%edx),%edi
    9cd2:	89 c8                	mov    %ecx,%eax
    9cd4:	29 f8                	sub    %edi,%eax
    9cd6:	83 f8 ff             	cmp    $0xffffffff,%eax
    9cd9:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
    9cdf:	0f 4e c2             	cmovle %edx,%eax
    9ce2:	31 f6                	xor    %esi,%esi
    9ce4:	c1 f8 0c             	sar    $0xc,%eax
    9ce7:	8d 04 40             	lea    (%eax,%eax,2),%eax
	newinfo[BLOCK(sk,oldinfo)].busy.info.size
    9cea:	89 ca                	mov    %ecx,%edx
    9cec:	89 74 83 0c          	mov    %esi,0xc(%ebx,%eax,4)
    9cf0:	8b 45 08             	mov    0x8(%ebp),%eax
    9cf3:	8b 98 e4 02 00 00    	mov    0x2e4(%eax),%ebx
    9cf9:	29 da                	sub    %ebx,%edx
    9cfb:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    9cfe:	83 fa ff             	cmp    $0xffffffff,%edx
    9d01:	8d 82 ff 0f 00 00    	lea    0xfff(%edx),%eax
    9d07:	0f 4e d0             	cmovle %eax,%edx
    9d0a:	8b 83 24 02 00 00    	mov    0x224(%ebx),%eax
    9d10:	8b 5d e8             	mov    0xffffffe8(%ebp),%ebx
    9d13:	c1 fa 0c             	sar    $0xc,%edx
    9d16:	8d 04 40             	lea    (%eax,%eax,2),%eax
    9d19:	8d 04 85 ff 0f 00 00 	lea    0xfff(,%eax,4),%eax
    9d20:	8d 14 52             	lea    (%edx,%edx,2),%edx
    9d23:	c1 e8 0c             	shr    $0xc,%eax
    9d26:	89 44 93 10          	mov    %eax,0x10(%ebx,%edx,4)
	    = BLOCKIFY(tp->t.heapsize * sizeof (union heap_info));
	tp->t.heapinfo = newinfo;
    9d2a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    9d2d:	89 98 2c 02 00 00    	mov    %ebx,0x22c(%eax)
	tfree(sk,oldinfo);
    9d33:	8b 55 08             	mov    0x8(%ebp),%edx
    9d36:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    9d3a:	89 14 24             	mov    %edx,(%esp,1)
    9d3d:	e8 fc ff ff ff       	call   9d3e <morecore+0x17e>
	tp->t.heapsize = newsize;
    9d42:	8b 5d e4             	mov    0xffffffe4(%ebp),%ebx
    9d45:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    9d48:	89 98 24 02 00 00    	mov    %ebx,0x224(%eax)
    9d4e:	8b 55 08             	mov    0x8(%ebp),%edx
    9d51:	8b 9a e4 02 00 00    	mov    0x2e4(%edx),%ebx
    }
    tp->t.heaplimit = BLOCK(sk,(char *) result + size);
    9d57:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    9d5a:	29 d8                	sub    %ebx,%eax
    9d5c:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    9d5f:	83 f8 ff             	cmp    $0xffffffff,%eax
    9d62:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
    9d68:	0f 4e c2             	cmovle %edx,%eax
    9d6b:	c1 f8 0c             	sar    $0xc,%eax
    9d6e:	40                   	inc    %eax
    9d6f:	89 83 34 02 00 00    	mov    %eax,0x234(%ebx)
    return result;
    9d75:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
    9d78:	83 c4 24             	add    $0x24,%esp
    9d7b:	5b                   	pop    %ebx
    9d7c:	5e                   	pop    %esi
    9d7d:	5f                   	pop    %edi
    9d7e:	5d                   	pop    %ebp
    9d7f:	c3                   	ret    
    9d80:	8b 55 08             	mov    0x8(%ebp),%edx
    9d83:	f7 df                	neg    %edi
    9d85:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
    9d89:	89 14 24             	mov    %edx,(%esp,1)
    9d8c:	ff 15 00 00 00 00    	call   *0x0
    9d92:	31 c0                	xor    %eax,%eax
    9d94:	eb e2                	jmp    9d78 <morecore+0x1b8>
    9d96:	8d 76 00             	lea    0x0(%esi),%esi
    9d99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00009da0 <tmalloc>:

/* Allocate memory from the heap. */
void *
tmalloc(struct sock *sk, size_t size)
{
    9da0:	55                   	push   %ebp
    9da1:	89 e5                	mov    %esp,%ebp
    9da3:	57                   	push   %edi
    9da4:	56                   	push   %esi
    9da5:	53                   	push   %ebx
    9da6:	83 ec 28             	sub    $0x28,%esp
    9da9:	8b 45 08             	mov    0x8(%ebp),%eax
    9dac:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9daf:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    9db2:	05 bc 00 00 00       	add    $0xbc,%eax
    void *result;
    int log, block, blocks, i, lastblocks, start;
    struct heap_list *next;

    if(SIMULATION_MODE(sk)) {
    9db7:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    9dba:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    9dbd:	8b 82 a8 02 00 00    	mov    0x2a8(%edx),%eax
    9dc3:	a9 01 00 00 00       	test   $0x1,%eax
    9dc8:	74 09                	je     9dd3 <tmalloc+0x33>
    9dca:	83 e0 08             	and    $0x8,%eax
    9dcd:	0f 84 ed 03 00 00    	je     a1c0 <tmalloc+0x420>
	    return kmalloc(size, GFP_ATOMIC);
    }

    if (!tp->t.malloc_initialized && !initialize_malloc(sk))
    9dd3:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    9dd6:	8b 89 18 02 00 00    	mov    0x218(%ecx),%ecx
    9ddc:	85 c9                	test   %ecx,%ecx
    9dde:	0f 84 bc 03 00 00    	je     a1a0 <tmalloc+0x400>
	return NULL;

    if (size == 0)
    9de4:	31 d2                	xor    %edx,%edx
    9de6:	85 db                	test   %ebx,%ebx
    9de8:	0f 84 a6 00 00 00    	je     9e94 <tmalloc+0xf4>
	return NULL;

    if (size < sizeof (struct heap_list))
    9dee:	83 fb 07             	cmp    $0x7,%ebx
    9df1:	b8 08 00 00 00       	mov    $0x8,%eax
    9df6:	0f 46 d8             	cmovbe %eax,%ebx
	size = sizeof (struct heap_list);

    /* Determine the allocation policy based on the request size. */
    if (size <= BLOCKSIZE / 2) {
    9df9:	81 fb 00 08 00 00    	cmp    $0x800,%ebx
    9dff:	0f 87 6b 01 00 00    	ja     9f70 <tmalloc+0x1d0>
	/* Small allocation to receive a fragment of a block. Determine
	   the logarithm to base two of the fragment size. */
	--size;
    9e05:	4b                   	dec    %ebx
	for (log = 1; (size >>= 1) != 0; ++log)
    9e06:	d1 eb                	shr    %ebx
    9e08:	be 01 00 00 00       	mov    $0x1,%esi
    9e0d:	74 06                	je     9e15 <tmalloc+0x75>
    9e0f:	90                   	nop    
    9e10:	46                   	inc    %esi
    9e11:	d1 eb                	shr    %ebx
    9e13:	75 fb                	jne    9e10 <tmalloc+0x70>
	    ;

	/* Look in the fragment lists for a free fragment of the
	   desired size. */
	if ((next = tp->t.fraghead[log].next) != 0) {
    9e15:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    9e18:	8b 94 f0 68 02 00 00 	mov    0x268(%eax,%esi,8),%edx
    9e1f:	85 d2                	test   %edx,%edx
    9e21:	74 7b                	je     9e9e <tmalloc+0xfe>
	    /* There are free fragments of this size.  Pop a fragment
	       out of the fragment list and return it.  Update the block's
	       nfree and first counters. */
	    result = next;
    9e23:	89 55 e8             	mov    %edx,0xffffffe8(%ebp)
	    next->prev->next = next->next;
    9e26:	89 d1                	mov    %edx,%ecx
    9e28:	8b 52 04             	mov    0x4(%edx),%edx
    9e2b:	8b 01                	mov    (%ecx),%eax
    9e2d:	89 02                	mov    %eax,(%edx)
	    if (next->next)
    9e2f:	8b 01                	mov    (%ecx),%eax
    9e31:	85 c0                	test   %eax,%eax
    9e33:	74 03                	je     9e38 <tmalloc+0x98>
		next->next->prev = next->prev;
    9e35:	89 50 04             	mov    %edx,0x4(%eax)
	    block = BLOCK(sk,result);
    9e38:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    9e3b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
	    if (--tp->t.heapinfo[block].busy.info.frag.nfree)
    9e3e:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
    9e41:	8b 93 e4 02 00 00    	mov    0x2e4(%ebx),%edx
    9e47:	29 d0                	sub    %edx,%eax
    9e49:	83 f8 ff             	cmp    $0xffffffff,%eax
    9e4c:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
    9e52:	0f 4e c2             	cmovle %edx,%eax
    9e55:	8b 97 2c 02 00 00    	mov    0x22c(%edi),%edx
    9e5b:	c1 f8 0c             	sar    $0xc,%eax
    9e5e:	8d 44 40 03          	lea    0x3(%eax,%eax,2),%eax
    9e62:	8d 3c 85 00 00 00 00 	lea    0x0(,%eax,4),%edi
    9e69:	8b 44 3a 04          	mov    0x4(%edx,%edi,1),%eax
    9e6d:	48                   	dec    %eax
    9e6e:	85 c0                	test   %eax,%eax
    9e70:	89 44 3a 04          	mov    %eax,0x4(%edx,%edi,1)
    9e74:	74 1b                	je     9e91 <tmalloc+0xf1>
		tp->t.heapinfo[block].busy.info.frag.first
    9e76:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    9e79:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
    9e7c:	8b 90 2c 02 00 00    	mov    0x22c(%eax),%edx
    9e82:	8b 01                	mov    (%ecx),%eax
    9e84:	89 f1                	mov    %esi,%ecx
    9e86:	25 ff 0f 00 00       	and    $0xfff,%eax
    9e8b:	d3 e8                	shr    %cl,%eax
    9e8d:	89 44 3a 08          	mov    %eax,0x8(%edx,%edi,1)
		    = (unsigned int) ((char *) next->next - (char *) NULL)
		      % BLOCKSIZE >> log;
	} else {
	    /* No free fragments of the desired size, so get a new block
	       and break it into fragments, returning the first. */
	    result = tmalloc(sk,BLOCKSIZE);
	    if (!result)
		return NULL;
	    ++tp->t.fragblocks[log];

	    /* Link all fragments but the first into the free list. */
	    for (i = 1; i < BLOCKSIZE >> log; ++i) {
		next = (struct heap_list *) ((char *) result + (i << log));
		next->next = tp->t.fraghead[log].next;
		next->prev = &tp->t.fraghead[log];
		next->prev->next = next;
		if (next->next)
		    next->next->prev = next;
	    }

	    /* Initialize the nfree and first counters for this block. */
	    block = BLOCK(sk,result);
	    tp->t.heapinfo[block].busy.type = log;
	    tp->t.heapinfo[block].busy.info.frag.nfree = i - 1;
	    tp->t.heapinfo[block].busy.info.frag.first = i - 1;
	}
    } else {
	/* Large allocation to receive one or more blocks.  Search
	   the free list in a circle starting at the last place visited.
	   If we loop completely around without finding a large enough
	   space we will have to get more memory from the system. */
	blocks = BLOCKIFY(size);
	start = block = tp->t.heapindex;
	while (tp->t.heapinfo[block].free.size < blocks) {
	    block = tp->t.heapinfo[block].free.next;
	    if (block == start) {
		/* Need to get more from the system.  Check to see if
		   the new core will be contiguous with the final free
		   block; if so we don't need to get as much. */
		block = tp->t.heapinfo[0].free.prev;
		lastblocks = tp->t.heapinfo[block].free.size;
		if (tp->t.heaplimit && block + lastblocks == tp->t.heaplimit
		    && (*_morecore)(sk,0) == ADDRESS(sk,block + lastblocks)
		    && morecore(sk,(blocks - lastblocks) * BLOCKSIZE)) {
		    /* Note that morecore() can change the location of
		       the final block if it moves the info table and the
		       old one gets coalesced into the final block. */
		    block = tp->t.heapinfo[0].free.prev;
		    tp->t.heapinfo[block].free.size += blocks - lastblocks;
		    continue;
		}
		result = morecore(sk,blocks * BLOCKSIZE);
		if (!result)
		    return NULL;
		block = BLOCK(sk,result);
		tp->t.heapinfo[block].busy.type = 0;
		tp->t.heapinfo[block].busy.info.size = blocks;
		return result;
	    }
	}

	/* At this point we have found a suitable free list entry.
	   Figure out how to remove what we need from the list. */
	result = ADDRESS(sk,block);
	if (tp->t.heapinfo[block].free.size > blocks) {
	    /* The block we found has a bit left over, so relink the
	       tail end back into the free list. */
	    tp->t.heapinfo[block + blocks].free.size
		= tp->t.heapinfo[block].free.size - blocks;
	    tp->t.heapinfo[block + blocks].free.next
		= tp->t.heapinfo[block].free.next;
	    tp->t.heapinfo[block + blocks].free.prev
		= tp->t.heapinfo[block].free.prev;
	    tp->t.heapinfo[tp->t.heapinfo[block].free.prev].free.next
		= tp->t.heapinfo[tp->t.heapinfo[block].free.next].free.prev
		    = tp->t.heapindex = block + blocks;
	} else {
	    /* The block exactly matches our requirements, so
	       just remove it from the list. */
	    tp->t.heapinfo[tp->t.heapinfo[block].free.next].free.prev
		= tp->t.heapinfo[block].free.prev;
	    tp->t.heapinfo[tp->t.heapinfo[block].free.prev].free.next
		= tp->t.heapindex = tp->t.heapinfo[block].free.next;
	}

	tp->t.heapinfo[block].busy.type = 0;
	tp->t.heapinfo[block].busy.info.size = blocks;
    }

    return result;
    9e91:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
}
    9e94:	83 c4 28             	add    $0x28,%esp
    9e97:	89 d0                	mov    %edx,%eax
    9e99:	5b                   	pop    %ebx
    9e9a:	5e                   	pop    %esi
    9e9b:	5f                   	pop    %edi
    9e9c:	5d                   	pop    %ebp
    9e9d:	c3                   	ret    
    9e9e:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp,1)
    9ea5:	00 
    9ea6:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    9ea9:	89 1c 24             	mov    %ebx,(%esp,1)
    9eac:	e8 fc ff ff ff       	call   9ead <tmalloc+0x10d>
    9eb1:	31 d2                	xor    %edx,%edx
    9eb3:	85 c0                	test   %eax,%eax
    9eb5:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    9eb8:	74 da                	je     9e94 <tmalloc+0xf4>
    9eba:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
    9ebd:	b8 00 10 00 00       	mov    $0x1000,%eax
    9ec2:	89 f1                	mov    %esi,%ecx
    9ec4:	d3 f8                	sar    %cl,%eax
    9ec6:	ff 84 b7 38 02 00 00 	incl   0x238(%edi,%esi,4)
    9ecd:	c7 45 d4 01 00 00 00 	movl   $0x1,0xffffffd4(%ebp)
    9ed4:	39 45 d4             	cmp    %eax,0xffffffd4(%ebp)
    9ed7:	7d 46                	jge    9f1f <tmalloc+0x17f>
    9ed9:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
    9edc:	8d 3c f3             	lea    (%ebx,%esi,8),%edi
    9edf:	89 c3                	mov    %eax,%ebx
    9ee1:	8d 97 68 02 00 00    	lea    0x268(%edi),%edx
    9ee7:	89 55 dc             	mov    %edx,0xffffffdc(%ebp)
    9eea:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    9eed:	89 f1                	mov    %esi,%ecx
    9eef:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    9ef2:	d3 e0                	shl    %cl,%eax
    9ef4:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    9ef7:	01 c2                	add    %eax,%edx
    9ef9:	8b 84 f1 68 02 00 00 	mov    0x268(%ecx,%esi,8),%eax
    9f00:	89 02                	mov    %eax,(%edx)
    9f02:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    9f05:	89 97 68 02 00 00    	mov    %edx,0x268(%edi)
    9f0b:	89 42 04             	mov    %eax,0x4(%edx)
    9f0e:	8b 02                	mov    (%edx),%eax
    9f10:	85 c0                	test   %eax,%eax
    9f12:	74 03                	je     9f17 <tmalloc+0x177>
    9f14:	89 50 04             	mov    %edx,0x4(%eax)
    9f17:	ff 45 d4             	incl   0xffffffd4(%ebp)
    9f1a:	39 5d d4             	cmp    %ebx,0xffffffd4(%ebp)
    9f1d:	7c cb                	jl     9eea <tmalloc+0x14a>
    9f1f:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    9f22:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    9f25:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    9f28:	8b ba e4 02 00 00    	mov    0x2e4(%edx),%edi
    9f2e:	29 f8                	sub    %edi,%eax
    9f30:	83 f8 ff             	cmp    $0xffffffff,%eax
    9f33:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
    9f39:	0f 4e c2             	cmovle %edx,%eax
    9f3c:	8b 91 2c 02 00 00    	mov    0x22c(%ecx),%edx
    9f42:	c1 f8 0c             	sar    $0xc,%eax
    9f45:	8d 44 40 03          	lea    0x3(%eax,%eax,2),%eax
    9f49:	c1 e0 02             	shl    $0x2,%eax
    9f4c:	89 34 02             	mov    %esi,(%edx,%eax,1)
    9f4f:	8b 91 2c 02 00 00    	mov    0x22c(%ecx),%edx
    9f55:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
    9f58:	49                   	dec    %ecx
    9f59:	89 4c 02 04          	mov    %ecx,0x4(%edx,%eax,1)
    9f5d:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
    9f60:	8b 93 2c 02 00 00    	mov    0x22c(%ebx),%edx
    9f66:	89 4c 02 08          	mov    %ecx,0x8(%edx,%eax,1)
    9f6a:	e9 22 ff ff ff       	jmp    9e91 <tmalloc+0xf1>
    9f6f:	90                   	nop    
    9f70:	81 c3 ff 0f 00 00    	add    $0xfff,%ebx
    9f76:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
    9f79:	c1 eb 0c             	shr    $0xc,%ebx
    9f7c:	89 5d e4             	mov    %ebx,0xffffffe4(%ebp)
    9f7f:	8b b7 30 02 00 00    	mov    0x230(%edi),%esi
    9f85:	8d 04 76             	lea    (%esi,%esi,2),%eax
    9f88:	89 75 e0             	mov    %esi,0xffffffe0(%ebp)
    9f8b:	8b bf 2c 02 00 00    	mov    0x22c(%edi),%edi
    9f91:	c1 e0 02             	shl    $0x2,%eax
    9f94:	39 1c 07             	cmp    %ebx,(%edi,%eax,1)
    9f97:	89 fa                	mov    %edi,%edx
    9f99:	7d 22                	jge    9fbd <tmalloc+0x21d>
    9f9b:	90                   	nop    
    9f9c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    9fa0:	8b 74 02 04          	mov    0x4(%edx,%eax,1),%esi
    9fa4:	3b 75 e0             	cmp    0xffffffe0(%ebp),%esi
    9fa7:	0f 84 03 01 00 00    	je     a0b0 <tmalloc+0x310>
    9fad:	8d 04 76             	lea    (%esi,%esi,2),%eax
    9fb0:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
    9fb3:	c1 e0 02             	shl    $0x2,%eax
    9fb6:	39 0c 07             	cmp    %ecx,(%edi,%eax,1)
    9fb9:	89 fa                	mov    %edi,%edx
    9fbb:	7c e3                	jl     9fa0 <tmalloc+0x200>
    9fbd:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    9fc0:	89 f0                	mov    %esi,%eax
    9fc2:	c1 e0 0c             	shl    $0xc,%eax
    9fc5:	8b 8b e4 02 00 00    	mov    0x2e4(%ebx),%ecx
    9fcb:	01 c8                	add    %ecx,%eax
    9fcd:	2d 00 10 00 00       	sub    $0x1000,%eax
    9fd2:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    9fd5:	8d 04 76             	lea    (%esi,%esi,2),%eax
    9fd8:	c1 e0 02             	shl    $0x2,%eax
    9fdb:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    9fde:	8b 04 07             	mov    (%edi,%eax,1),%eax
    9fe1:	3b 45 e4             	cmp    0xffffffe4(%ebp),%eax
    9fe4:	0f 8e 8c 00 00 00    	jle    a076 <tmalloc+0x2d6>
    9fea:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
    9fed:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    9ff0:	8d 1c 31             	lea    (%ecx,%esi,1),%ebx
    9ff3:	8d 0c 5b             	lea    (%ebx,%ebx,2),%ecx
    9ff6:	c1 e1 02             	shl    $0x2,%ecx
    9ff9:	29 d0                	sub    %edx,%eax
    9ffb:	89 04 0f             	mov    %eax,(%edi,%ecx,1)
    9ffe:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
    a001:	8b 97 2c 02 00 00    	mov    0x22c(%edi),%edx
    a007:	8b 7d d8             	mov    0xffffffd8(%ebp),%edi
    a00a:	8b 44 3a 04          	mov    0x4(%edx,%edi,1),%eax
    a00e:	89 44 0a 04          	mov    %eax,0x4(%edx,%ecx,1)
    a012:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    a015:	8b 90 2c 02 00 00    	mov    0x22c(%eax),%edx
    a01b:	8b 44 3a 08          	mov    0x8(%edx,%edi,1),%eax
    a01f:	89 44 0a 08          	mov    %eax,0x8(%edx,%ecx,1)
    a023:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    a026:	8b 8a 2c 02 00 00    	mov    0x22c(%edx),%ecx
    a02c:	8b 54 39 08          	mov    0x8(%ecx,%edi,1),%edx
    a030:	8b 44 39 04          	mov    0x4(%ecx,%edi,1),%eax
    a034:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
    a037:	8d 14 52             	lea    (%edx,%edx,2),%edx
    a03a:	8d 04 40             	lea    (%eax,%eax,2),%eax
    a03d:	89 9f 30 02 00 00    	mov    %ebx,0x230(%edi)
    a043:	89 5c 81 08          	mov    %ebx,0x8(%ecx,%eax,4)
    a047:	89 5c 91 04          	mov    %ebx,0x4(%ecx,%edx,4)
    a04b:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    a04e:	8b 82 2c 02 00 00    	mov    0x22c(%edx),%eax
    a054:	8d 14 76             	lea    (%esi,%esi,2),%edx
    a057:	c1 e2 02             	shl    $0x2,%edx
    a05a:	c7 04 10 00 00 00 00 	movl   $0x0,(%eax,%edx,1)
    a061:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    a064:	8b 5d e4             	mov    0xffffffe4(%ebp),%ebx
    a067:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    a06d:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
    a071:	e9 1b fe ff ff       	jmp    9e91 <tmalloc+0xf1>
    a076:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    a079:	8b 44 17 04          	mov    0x4(%edi,%edx,1),%eax
    a07d:	89 d1                	mov    %edx,%ecx
    a07f:	8b 54 17 08          	mov    0x8(%edi,%edx,1),%edx
    a083:	8d 04 40             	lea    (%eax,%eax,2),%eax
    a086:	89 54 87 08          	mov    %edx,0x8(%edi,%eax,4)
    a08a:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
    a08d:	8b 7d d8             	mov    0xffffffd8(%ebp),%edi
    a090:	8b 93 2c 02 00 00    	mov    0x22c(%ebx),%edx
    a096:	8b 44 0a 08          	mov    0x8(%edx,%ecx,1),%eax
    a09a:	8b 4c 3a 04          	mov    0x4(%edx,%edi,1),%ecx
    a09e:	8d 04 40             	lea    (%eax,%eax,2),%eax
    a0a1:	89 8b 30 02 00 00    	mov    %ecx,0x230(%ebx)
    a0a7:	89 4c 82 04          	mov    %ecx,0x4(%edx,%eax,4)
    a0ab:	eb 9e                	jmp    a04b <tmalloc+0x2ab>
    a0ad:	8d 76 00             	lea    0x0(%esi),%esi
    a0b0:	8b 72 08             	mov    0x8(%edx),%esi
    a0b3:	8d 04 76             	lea    (%esi,%esi,2),%eax
    a0b6:	8b 3c 82             	mov    (%edx,%eax,4),%edi
    a0b9:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    a0bc:	8b 82 34 02 00 00    	mov    0x234(%edx),%eax
    a0c2:	85 c0                	test   %eax,%eax
    a0c4:	74 70                	je     a136 <tmalloc+0x396>
    a0c6:	8d 1c 37             	lea    (%edi,%esi,1),%ebx
    a0c9:	39 c3                	cmp    %eax,%ebx
    a0cb:	75 69                	jne    a136 <tmalloc+0x396>
    a0cd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    a0d4:	00 
    a0d5:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    a0d8:	c1 e3 0c             	shl    $0xc,%ebx
    a0db:	89 0c 24             	mov    %ecx,(%esp,1)
    a0de:	ff 15 00 00 00 00    	call   *0x0
    a0e4:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    a0e7:	8b b2 e4 02 00 00    	mov    0x2e4(%edx),%esi
    a0ed:	01 f3                	add    %esi,%ebx
    a0ef:	8d 93 00 f0 ff ff    	lea    0xfffff000(%ebx),%edx
    a0f5:	39 d0                	cmp    %edx,%eax
    a0f7:	75 3d                	jne    a136 <tmalloc+0x396>
    a0f9:	8b 5d e4             	mov    0xffffffe4(%ebp),%ebx
    a0fc:	29 fb                	sub    %edi,%ebx
    a0fe:	89 d8                	mov    %ebx,%eax
    a100:	c1 e0 0c             	shl    $0xc,%eax
    a103:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    a107:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    a10a:	89 0c 24             	mov    %ecx,(%esp,1)
    a10d:	e8 ae fa ff ff       	call   9bc0 <morecore>
    a112:	85 c0                	test   %eax,%eax
    a114:	74 20                	je     a136 <tmalloc+0x396>
    a116:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
    a119:	8b 87 2c 02 00 00    	mov    0x22c(%edi),%eax
    a11f:	8b 70 08             	mov    0x8(%eax),%esi
    a122:	8d 14 76             	lea    (%esi,%esi,2),%edx
    a125:	01 1c 90             	add    %ebx,(%eax,%edx,4)
    a128:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    a12b:	8b b8 2c 02 00 00    	mov    0x22c(%eax),%edi
    a131:	e9 77 fe ff ff       	jmp    9fad <tmalloc+0x20d>
    a136:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    a139:	c1 e0 0c             	shl    $0xc,%eax
    a13c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    a140:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    a143:	89 14 24             	mov    %edx,(%esp,1)
    a146:	e8 75 fa ff ff       	call   9bc0 <morecore>
    a14b:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    a14e:	85 c0                	test   %eax,%eax
    a150:	74 43                	je     a195 <tmalloc+0x3f5>
    a152:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    a155:	8b 99 e4 02 00 00    	mov    0x2e4(%ecx),%ebx
    a15b:	29 d8                	sub    %ebx,%eax
    a15d:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
    a160:	83 f8 ff             	cmp    $0xffffffff,%eax
    a163:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
    a169:	0f 4e c2             	cmovle %edx,%eax
    a16c:	8b 93 2c 02 00 00    	mov    0x22c(%ebx),%edx
    a172:	c1 f8 0c             	sar    $0xc,%eax
    a175:	8d 44 40 03          	lea    0x3(%eax,%eax,2),%eax
    a179:	c1 e0 02             	shl    $0x2,%eax
    a17c:	c7 04 02 00 00 00 00 	movl   $0x0,(%edx,%eax,1)
    a183:	8b 93 2c 02 00 00    	mov    0x22c(%ebx),%edx
    a189:	8b 7d e4             	mov    0xffffffe4(%ebp),%edi
    a18c:	89 7c 02 04          	mov    %edi,0x4(%edx,%eax,1)
    a190:	e9 fc fc ff ff       	jmp    9e91 <tmalloc+0xf1>
    a195:	31 d2                	xor    %edx,%edx
    a197:	e9 f8 fc ff ff       	jmp    9e94 <tmalloc+0xf4>
    a19c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    a1a0:	8b 7d f0             	mov    0xfffffff0(%ebp),%edi
    a1a3:	89 3c 24             	mov    %edi,(%esp,1)
    a1a6:	e8 45 f9 ff ff       	call   9af0 <initialize_malloc>
    a1ab:	31 d2                	xor    %edx,%edx
    a1ad:	85 c0                	test   %eax,%eax
    a1af:	0f 84 df fc ff ff    	je     9e94 <tmalloc+0xf4>
    a1b5:	e9 2a fc ff ff       	jmp    9de4 <tmalloc+0x44>
    a1ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    a1c0:	c7 45 0c 20 00 00 00 	movl   $0x20,0xc(%ebp)
    a1c7:	89 5d 08             	mov    %ebx,0x8(%ebp)
    a1ca:	83 c4 28             	add    $0x28,%esp
    a1cd:	5b                   	pop    %ebx
    a1ce:	5e                   	pop    %esi
    a1cf:	5f                   	pop    %edi
    a1d0:	5d                   	pop    %ebp
    a1d1:	e9 fc ff ff ff       	jmp    a1d2 <tmalloc+0x432>
    a1d6:	8d 76 00             	lea    0x0(%esi),%esi
    a1d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

0000a1e0 <tfree>:

/* Return memory to the heap. */
void
tfree(struct sock *sk, void *ptr)
{
    a1e0:	55                   	push   %ebp
    a1e1:	89 e5                	mov    %esp,%ebp
    a1e3:	57                   	push   %edi
    a1e4:	56                   	push   %esi
    a1e5:	53                   	push   %ebx
    a1e6:	83 ec 28             	sub    $0x28,%esp
    a1e9:	8b 45 08             	mov    0x8(%ebp),%eax
    a1ec:	8b 55 0c             	mov    0xc(%ebp),%edx
    a1ef:	8d 88 bc 00 00 00    	lea    0xbc(%eax),%ecx
    a1f5:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    a1f8:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
    a1fb:	89 4d dc             	mov    %ecx,0xffffffdc(%ebp)
    a1fe:	89 f6                	mov    %esi,%esi
    struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    int block, blocks, i, type;
    struct heap_list *prev, *next;

    if (!ptr)
    a200:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
    a203:	85 ff                	test   %edi,%edi
    a205:	0f 84 44 01 00 00    	je     a34f <tfree+0x16f>
	return;

    if(SIMULATION_MODE(sk)) {
    a20b:	8b 7d f0             	mov    0xfffffff0(%ebp),%edi
    a20e:	8b 87 a8 02 00 00    	mov    0x2a8(%edi),%eax
    a214:	a9 01 00 00 00       	test   $0x1,%eax
    a219:	74 09                	je     a224 <tfree+0x44>
    a21b:	83 e0 08             	and    $0x8,%eax
    a21e:	0f 84 5d 03 00 00    	je     a581 <tfree+0x3a1>
	    kfree(ptr);
	    return;
    }

    block = BLOCK(sk,ptr);
    a224:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    a227:	8b 45 ec             	mov    0xffffffec(%ebp),%eax

    switch (type = tp->t.heapinfo[block].busy.type) {
    a22a:	8b 4d dc             	mov    0xffffffdc(%ebp),%ecx
    a22d:	8b ba e4 02 00 00    	mov    0x2e4(%edx),%edi
    a233:	8b 89 2c 02 00 00    	mov    0x22c(%ecx),%ecx
    a239:	29 f8                	sub    %edi,%eax
    a23b:	83 f8 ff             	cmp    $0xffffffff,%eax
    a23e:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
    a244:	0f 4e c2             	cmovle %edx,%eax
    a247:	c1 f8 0c             	sar    $0xc,%eax
    a24a:	8d 70 01             	lea    0x1(%eax),%esi
    a24d:	89 4d e0             	mov    %ecx,0xffffffe0(%ebp)
    a250:	8d 04 76             	lea    (%esi,%esi,2),%eax
    a253:	c1 e0 02             	shl    $0x2,%eax
    a256:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    a259:	8b 1c 01             	mov    (%ecx,%eax,1),%ebx
    a25c:	85 db                	test   %ebx,%ebx
    a25e:	0f 84 44 01 00 00    	je     a3a8 <tfree+0x1c8>
    case 0:
	/* Find the free cluster previous to this one in the free list.
	   Start searching at the last block referenced; this may benefit
	   programs with locality of allocation. */
	i = tp->t.heapindex;
	if (i > block)
	    while (i > block)
		i = tp->t.heapinfo[i].free.prev;
	else {
	    do
		i = tp->t.heapinfo[i].free.next;
	    while (i > 0 && i < block);
	    i = tp->t.heapinfo[i].free.prev;
	}

	/* Determine how to link this block into the free list. */
	if (block == i + tp->t.heapinfo[i].free.size) {
	    /* Coalesce this block with its predecessor. */
	    tp->t.heapinfo[i].free.size += tp->t.heapinfo[block].busy.info.size;
	    block = i;
	} else {
	    /* Really link this block back into the free list. */
	    tp->t.heapinfo[block].free.size = tp->t.heapinfo[block].busy.info.size;
	    tp->t.heapinfo[block].free.next = tp->t.heapinfo[i].free.next;
	    tp->t.heapinfo[block].free.prev = i;
	    tp->t.heapinfo[i].free.next = block;
	    tp->t.heapinfo[tp->t.heapinfo[block].free.next].free.prev = block;
	}

	/* Now that the block is linked in, see if we can coalesce it
	   with its successor (by deleting its successor from the list
	   and adding in its size). */
	if (block + tp->t.heapinfo[block].free.size == tp->t.heapinfo[block].free.next) {
	    tp->t.heapinfo[block].free.size
		+= tp->t.heapinfo[tp->t.heapinfo[block].free.next].free.size;
	    tp->t.heapinfo[block].free.next
		= tp->t.heapinfo[tp->t.heapinfo[block].free.next].free.next;
	    tp->t.heapinfo[tp->t.heapinfo[block].free.next].free.prev = block;
	}

	/* Now see if we can return stuff to the system. */
	blocks = tp->t.heapinfo[block].free.size;
	if (blocks >= FINAL_FREE_BLOCKS && block + blocks == tp->t.heaplimit
	    && (*_morecore)(sk,0) == ADDRESS(sk,block + blocks)) {
	    tp->t.heaplimit -= blocks;
	    (*_morecore)(sk,-blocks * BLOCKSIZE);
	    tp->t.heapinfo[tp->t.heapinfo[block].free.prev].free.next
		= tp->t.heapinfo[block].free.next;
	    tp->t.heapinfo[tp->t.heapinfo[block].free.next].free.prev
		= tp->t.heapinfo[block].free.prev;
	    block = tp->t.heapinfo[block].free.prev;
	}

	/* Set the next search to begin at this block. */
	tp->t.heapindex = block;
	break;

    default:
	/* Get the address of the first free fragment in this block. */
	prev = (struct heap_list *) ((char *) ADDRESS(sk,block)
    a264:	89 f0                	mov    %esi,%eax
    a266:	c1 e0 0c             	shl    $0xc,%eax
    a269:	8d 04 38             	lea    (%eax,%edi,1),%eax
    a26c:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
    a26f:	8b 7d d8             	mov    0xffffffd8(%ebp),%edi
    a272:	8b 54 39 08          	mov    0x8(%ecx,%edi,1),%edx
    a276:	88 d9                	mov    %bl,%cl
				+ (tp->t.heapinfo[block].busy.info.frag.first
				   << type));

	if (tp->t.heapinfo[block].busy.info.frag.nfree == (BLOCKSIZE >> type) - 1
    a278:	bf 00 10 00 00       	mov    $0x1000,%edi
    a27d:	d3 ff                	sar    %cl,%edi
    a27f:	d3 e2                	shl    %cl,%edx
    a281:	8d 94 02 00 f0 ff ff 	lea    0xfffff000(%edx,%eax,1),%edx
    a288:	8d 47 ff             	lea    0xffffffff(%edi),%eax
    a28b:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
    a28e:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    a291:	89 55 e8             	mov    %edx,0xffffffe8(%ebp)
    a294:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    a297:	8b 4c 10 04          	mov    0x4(%eax,%edx,1),%ecx
    a29b:	3b 4d d4             	cmp    0xffffffd4(%ebp),%ecx
    a29e:	75 75                	jne    a315 <tfree+0x135>
    a2a0:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    a2a3:	8b 84 9a 38 02 00 00 	mov    0x238(%edx,%ebx,4),%eax
    a2aa:	83 f8 01             	cmp    $0x1,%eax
    a2ad:	7e 66                	jle    a315 <tfree+0x135>
	&& tp->t.fragblocks[type] > 1) {
	    /* If all fragments of this block are free, remove them
	       from the fragment list and free the whole block. */
	    --tp->t.fragblocks[type];
    a2af:	48                   	dec    %eax
	    for (next = prev, i = 1; i < BLOCKSIZE >> type; ++i)
    a2b0:	4f                   	dec    %edi
    a2b1:	89 84 9a 38 02 00 00 	mov    %eax,0x238(%edx,%ebx,4)
    a2b8:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    a2bb:	7e 08                	jle    a2c5 <tfree+0xe5>
    a2bd:	89 cb                	mov    %ecx,%ebx
    a2bf:	90                   	nop    
    a2c0:	4b                   	dec    %ebx
		next = next->next;
    a2c1:	8b 12                	mov    (%edx),%edx
    a2c3:	75 fb                	jne    a2c0 <tfree+0xe0>
	    prev->prev->next = next;
    a2c5:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
	    if (next)
    a2c8:	85 d2                	test   %edx,%edx
    a2ca:	8b 41 04             	mov    0x4(%ecx),%eax
    a2cd:	89 10                	mov    %edx,(%eax)
    a2cf:	74 03                	je     a2d4 <tfree+0xf4>
		next->prev = prev->prev;
    a2d1:	89 42 04             	mov    %eax,0x4(%edx)
	    tp->t.heapinfo[block].busy.type = 0;
    a2d4:	8b 7d dc             	mov    0xffffffdc(%ebp),%edi
    a2d7:	8d 14 76             	lea    (%esi,%esi,2),%edx
    a2da:	c1 e2 02             	shl    $0x2,%edx
	    tp->t.heapinfo[block].busy.info.size = 1;
    a2dd:	b9 01 00 00 00       	mov    $0x1,%ecx
    a2e2:	8b 87 2c 02 00 00    	mov    0x22c(%edi),%eax
	    tfree(sk,ADDRESS(sk,block));
    a2e8:	c1 e6 0c             	shl    $0xc,%esi
    a2eb:	c7 04 10 00 00 00 00 	movl   $0x0,(%eax,%edx,1)
    a2f2:	8b 87 2c 02 00 00    	mov    0x22c(%edi),%eax
    a2f8:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
    a2fc:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    a2ff:	8b 90 e4 02 00 00    	mov    0x2e4(%eax),%edx
    a305:	01 d6                	add    %edx,%esi
    a307:	81 ee 00 10 00 00    	sub    $0x1000,%esi
    a30d:	89 75 ec             	mov    %esi,0xffffffec(%ebp)
    a310:	e9 eb fe ff ff       	jmp    a200 <tfree+0x20>
	} else if (tp->t.heapinfo[block].busy.info.frag.nfree) {
    a315:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    a318:	8d 04 76             	lea    (%esi,%esi,2),%eax
    a31b:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
    a322:	8b 44 32 04          	mov    0x4(%edx,%esi,1),%eax
    a326:	85 c0                	test   %eax,%eax
    a328:	74 2d                	je     a357 <tfree+0x177>
	    /* If some fragments of this block are free, link this fragment
	       into the fragment list after the first free fragment of
	       this block. */
	    next = ptr;
	    next->next = prev->next;
    a32a:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
    a32d:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
    a330:	8b 01                	mov    (%ecx),%eax
	    next->prev = prev;
    a332:	89 4f 04             	mov    %ecx,0x4(%edi)
    a335:	89 07                	mov    %eax,(%edi)
	    prev->next = next;
    a337:	89 39                	mov    %edi,(%ecx)
	    if (next->next)
    a339:	8b 07                	mov    (%edi),%eax
    a33b:	85 c0                	test   %eax,%eax
    a33d:	74 03                	je     a342 <tfree+0x162>
		next->next->prev = next;
    a33f:	89 78 04             	mov    %edi,0x4(%eax)
	    ++tp->t.heapinfo[block].busy.info.frag.nfree;
    a342:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    a345:	8b 82 2c 02 00 00    	mov    0x22c(%edx),%eax
    a34b:	ff 44 30 04          	incl   0x4(%eax,%esi,1)
	} else {
	    /* No fragments of this block are free, so link this fragment
	       into the fragment list and announce that it is the first
	       free fragment of this block. */
	    prev = (struct heap_list *) ptr;
	    tp->t.heapinfo[block].busy.info.frag.nfree = 1;
	    tp->t.heapinfo[block].busy.info.frag.first
		= (unsigned int) ((char *) ptr - (char *) NULL) % BLOCKSIZE
		  >> type;
	    prev->next = tp->t.fraghead[type].next;
	    prev->prev = &tp->t.fraghead[type];
	    prev->prev->next = prev;
	    if (prev->next)
		prev->next->prev = prev;
	}
	break;
    }
}
    a34f:	83 c4 28             	add    $0x28,%esp
    a352:	5b                   	pop    %ebx
    a353:	5e                   	pop    %esi
    a354:	5f                   	pop    %edi
    a355:	5d                   	pop    %ebp
    a356:	c3                   	ret    
    a357:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
    a35a:	bf 01 00 00 00       	mov    $0x1,%edi
    a35f:	89 7c 31 04          	mov    %edi,0x4(%ecx,%esi,1)
    a363:	88 d9                	mov    %bl,%cl
    a365:	8b 7d dc             	mov    0xffffffdc(%ebp),%edi
    a368:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    a36b:	8b 97 2c 02 00 00    	mov    0x22c(%edi),%edx
    a371:	25 ff 0f 00 00       	and    $0xfff,%eax
    a376:	d3 e8                	shr    %cl,%eax
    a378:	89 44 32 08          	mov    %eax,0x8(%edx,%esi,1)
    a37c:	8b 84 df 68 02 00 00 	mov    0x268(%edi,%ebx,8),%eax
    a383:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
    a386:	89 07                	mov    %eax,(%edi)
    a388:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    a38b:	8d 14 d8             	lea    (%eax,%ebx,8),%edx
    a38e:	89 ba 68 02 00 00    	mov    %edi,0x268(%edx)
    a394:	8d 82 68 02 00 00    	lea    0x268(%edx),%eax
    a39a:	89 47 04             	mov    %eax,0x4(%edi)
    a39d:	8b 07                	mov    (%edi),%eax
    a39f:	85 c0                	test   %eax,%eax
    a3a1:	74 ac                	je     a34f <tfree+0x16f>
    a3a3:	89 78 04             	mov    %edi,0x4(%eax)
    a3a6:	eb a7                	jmp    a34f <tfree+0x16f>
    a3a8:	8b 7d dc             	mov    0xffffffdc(%ebp),%edi
    a3ab:	8b 9f 30 02 00 00    	mov    0x230(%edi),%ebx
    a3b1:	39 f3                	cmp    %esi,%ebx
    a3b3:	0f 8e a7 01 00 00    	jle    a560 <tfree+0x380>
    a3b9:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    a3bc:	8d 04 5b             	lea    (%ebx,%ebx,2),%eax
    a3bf:	8b 5c 82 08          	mov    0x8(%edx,%eax,4),%ebx
    a3c3:	39 f3                	cmp    %esi,%ebx
    a3c5:	7f f2                	jg     a3b9 <tfree+0x1d9>
    a3c7:	8d 04 5b             	lea    (%ebx,%ebx,2),%eax
    a3ca:	8d 3c 85 00 00 00 00 	lea    0x0(,%eax,4),%edi
    a3d1:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    a3d4:	8b 14 38             	mov    (%eax,%edi,1),%edx
    a3d7:	8d 04 1a             	lea    (%edx,%ebx,1),%eax
    a3da:	39 c6                	cmp    %eax,%esi
    a3dc:	0f 84 66 01 00 00    	je     a548 <tfree+0x368>
    a3e2:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
    a3e5:	8d 04 76             	lea    (%esi,%esi,2),%eax
    a3e8:	c1 e0 02             	shl    $0x2,%eax
    a3eb:	8b 54 01 04          	mov    0x4(%ecx,%eax,1),%edx
    a3ef:	89 14 01             	mov    %edx,(%ecx,%eax,1)
    a3f2:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    a3f5:	8b 8a 2c 02 00 00    	mov    0x22c(%edx),%ecx
    a3fb:	8b 54 39 04          	mov    0x4(%ecx,%edi,1),%edx
    a3ff:	89 54 01 04          	mov    %edx,0x4(%ecx,%eax,1)
    a403:	8b 4d dc             	mov    0xffffffdc(%ebp),%ecx
    a406:	8b 91 2c 02 00 00    	mov    0x22c(%ecx),%edx
    a40c:	89 5c 02 08          	mov    %ebx,0x8(%edx,%eax,1)
    a410:	8b 91 2c 02 00 00    	mov    0x22c(%ecx),%edx
    a416:	89 74 3a 04          	mov    %esi,0x4(%edx,%edi,1)
    a41a:	8b 91 2c 02 00 00    	mov    0x22c(%ecx),%edx
    a420:	8b 44 02 04          	mov    0x4(%edx,%eax,1),%eax
    a424:	8d 04 40             	lea    (%eax,%eax,2),%eax
    a427:	89 74 82 08          	mov    %esi,0x8(%edx,%eax,4)
    a42b:	8b 7d dc             	mov    0xffffffdc(%ebp),%edi
    a42e:	8d 04 76             	lea    (%esi,%esi,2),%eax
    a431:	8b 97 2c 02 00 00    	mov    0x22c(%edi),%edx
    a437:	8d 3c 85 00 00 00 00 	lea    0x0(,%eax,4),%edi
    a43e:	8b 0c 3a             	mov    (%edx,%edi,1),%ecx
    a441:	8d 04 31             	lea    (%ecx,%esi,1),%eax
    a444:	3b 44 3a 04          	cmp    0x4(%edx,%edi,1),%eax
    a448:	0f 84 b8 00 00 00    	je     a506 <tfree+0x326>
    a44e:	8b 1c 3a             	mov    (%edx,%edi,1),%ebx
    a451:	83 fb 07             	cmp    $0x7,%ebx
    a454:	7e 11                	jle    a467 <tfree+0x287>
    a456:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    a459:	8d 04 33             	lea    (%ebx,%esi,1),%eax
    a45c:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    a45f:	3b 82 34 02 00 00    	cmp    0x234(%edx),%eax
    a465:	74 0e                	je     a475 <tfree+0x295>
    a467:	8b 4d dc             	mov    0xffffffdc(%ebp),%ecx
    a46a:	89 b1 30 02 00 00    	mov    %esi,0x230(%ecx)
    a470:	e9 da fe ff ff       	jmp    a34f <tfree+0x16f>
    a475:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    a47c:	00 
    a47d:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    a480:	89 0c 24             	mov    %ecx,(%esp,1)
    a483:	ff 15 00 00 00 00    	call   *0x0
    a489:	c1 65 e4 0c          	shll   $0xc,0xffffffe4(%ebp)
    a48d:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    a490:	8b 92 e4 02 00 00    	mov    0x2e4(%edx),%edx
    a496:	01 55 e4             	add    %edx,0xffffffe4(%ebp)
    a499:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    a49c:	81 ea 00 10 00 00    	sub    $0x1000,%edx
    a4a2:	39 d0                	cmp    %edx,%eax
    a4a4:	75 c1                	jne    a467 <tfree+0x287>
    a4a6:	8b 4d dc             	mov    0xffffffdc(%ebp),%ecx
    a4a9:	29 99 34 02 00 00    	sub    %ebx,0x234(%ecx)
    a4af:	f7 db                	neg    %ebx
    a4b1:	c1 e3 0c             	shl    $0xc,%ebx
    a4b4:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    a4b8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    a4bb:	89 04 24             	mov    %eax,(%esp,1)
    a4be:	ff 15 00 00 00 00    	call   *0x0
    a4c4:	8b 4d dc             	mov    0xffffffdc(%ebp),%ecx
    a4c7:	8b 91 2c 02 00 00    	mov    0x22c(%ecx),%edx
    a4cd:	8b 44 3a 08          	mov    0x8(%edx,%edi,1),%eax
    a4d1:	8b 4c 3a 04          	mov    0x4(%edx,%edi,1),%ecx
    a4d5:	8d 04 40             	lea    (%eax,%eax,2),%eax
    a4d8:	89 4c 82 04          	mov    %ecx,0x4(%edx,%eax,4)
    a4dc:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    a4df:	8b 90 2c 02 00 00    	mov    0x22c(%eax),%edx
    a4e5:	8b 44 3a 04          	mov    0x4(%edx,%edi,1),%eax
    a4e9:	8b 4c 3a 08          	mov    0x8(%edx,%edi,1),%ecx
    a4ed:	8d 04 40             	lea    (%eax,%eax,2),%eax
    a4f0:	89 4c 82 08          	mov    %ecx,0x8(%edx,%eax,4)
    a4f4:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    a4f7:	8b 82 2c 02 00 00    	mov    0x22c(%edx),%eax
    a4fd:	8b 74 38 08          	mov    0x8(%eax,%edi,1),%esi
    a501:	e9 61 ff ff ff       	jmp    a467 <tfree+0x287>
    a506:	8d 04 40             	lea    (%eax,%eax,2),%eax
    a509:	8b 1c 82             	mov    (%edx,%eax,4),%ebx
    a50c:	01 d9                	add    %ebx,%ecx
    a50e:	89 0c 3a             	mov    %ecx,(%edx,%edi,1)
    a511:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    a514:	8b 90 2c 02 00 00    	mov    0x22c(%eax),%edx
    a51a:	8b 44 3a 04          	mov    0x4(%edx,%edi,1),%eax
    a51e:	8d 04 40             	lea    (%eax,%eax,2),%eax
    a521:	8b 44 82 04          	mov    0x4(%edx,%eax,4),%eax
    a525:	89 44 3a 04          	mov    %eax,0x4(%edx,%edi,1)
    a529:	8b 4d dc             	mov    0xffffffdc(%ebp),%ecx
    a52c:	8b 91 2c 02 00 00    	mov    0x22c(%ecx),%edx
    a532:	8b 44 3a 04          	mov    0x4(%edx,%edi,1),%eax
    a536:	8d 04 40             	lea    (%eax,%eax,2),%eax
    a539:	89 74 82 08          	mov    %esi,0x8(%edx,%eax,4)
    a53d:	8b 91 2c 02 00 00    	mov    0x22c(%ecx),%edx
    a543:	e9 06 ff ff ff       	jmp    a44e <tfree+0x26e>
    a548:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
    a54b:	8d 04 76             	lea    (%esi,%esi,2),%eax
    a54e:	8b 74 81 04          	mov    0x4(%ecx,%eax,4),%esi
    a552:	01 f2                	add    %esi,%edx
    a554:	89 de                	mov    %ebx,%esi
    a556:	89 14 39             	mov    %edx,(%ecx,%edi,1)
    a559:	e9 cd fe ff ff       	jmp    a42b <tfree+0x24b>
    a55e:	89 f6                	mov    %esi,%esi
    a560:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
    a563:	8d 04 5b             	lea    (%ebx,%ebx,2),%eax
    a566:	8b 5c 81 04          	mov    0x4(%ecx,%eax,4),%ebx
    a56a:	85 db                	test   %ebx,%ebx
    a56c:	7e 04                	jle    a572 <tfree+0x392>
    a56e:	39 f3                	cmp    %esi,%ebx
    a570:	7c ee                	jl     a560 <tfree+0x380>
    a572:	8b 7d e0             	mov    0xffffffe0(%ebp),%edi
    a575:	8d 04 5b             	lea    (%ebx,%ebx,2),%eax
    a578:	8b 5c 87 08          	mov    0x8(%edi,%eax,4),%ebx
    a57c:	e9 46 fe ff ff       	jmp    a3c7 <tfree+0x1e7>
    a581:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    a584:	89 45 08             	mov    %eax,0x8(%ebp)
    a587:	83 c4 28             	add    $0x28,%esp
    a58a:	5b                   	pop    %ebx
    a58b:	5e                   	pop    %esi
    a58c:	5f                   	pop    %edi
    a58d:	5d                   	pop    %ebp
    a58e:	e9 fc ff ff ff       	jmp    a58f <tfree+0x3af>
    a593:	90                   	nop    
    a594:	90                   	nop    
    a595:	90                   	nop    
    a596:	90                   	nop    
    a597:	90                   	nop    
    a598:	90                   	nop    
    a599:	90                   	nop    
    a59a:	90                   	nop    
    a59b:	90                   	nop    
    a59c:	90                   	nop    
    a59d:	90                   	nop    
    a59e:	90                   	nop    
    a59f:	90                   	nop    

0000a5a0 <free_trickles_msk>:
/* Two phase free: first phase disconnects socket from event list,
   sets to ALLOC_PROCESSING; second phase adds the socket to free
   list, sets to ALLOC_FREE and ready for reuse */
#ifndef USERTEST
static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk) {
    a5a0:	55                   	push   %ebp
    a5a1:	89 e5                	mov    %esp,%ebp
    a5a3:	83 ec 0c             	sub    $0xc,%esp
    a5a6:	89 5d fc             	mov    %ebx,0xfffffffc(%ebp)
	if(!SIMULATION_MODE(sk)) {
    a5a9:	8b 45 08             	mov    0x8(%ebp),%eax
    a5ac:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a5af:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    a5b5:	a9 01 00 00 00       	test   $0x1,%eax
    a5ba:	74 05                	je     a5c1 <free_trickles_msk+0x21>
    a5bc:	83 e0 08             	and    $0x8,%eax
    a5bf:	74 16                	je     a5d7 <free_trickles_msk+0x37>
		if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) {
    a5c1:	8b 43 0c             	mov    0xc(%ebx),%eax
    a5c4:	85 c0                	test   %eax,%eax
    a5c6:	74 48                	je     a610 <free_trickles_msk+0x70>
    a5c8:	83 f8 03             	cmp    $0x3,%eax
    a5cb:	74 43                	je     a610 <free_trickles_msk+0x70>
			printk("double free\n");
			BUG();
		}
		if(msk->ctl == ALLOC_READY && msk->prev != NULL) {
    a5cd:	48                   	dec    %eax
    a5ce:	74 10                	je     a5e0 <free_trickles_msk+0x40>
			unlink((struct alloc_head *)msk);
		}
		msk->ctl = ALLOC_PROCESSING;
    a5d0:	c7 43 0c 03 00 00 00 	movl   $0x3,0xc(%ebx)
	}
}
    a5d7:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
    a5da:	89 ec                	mov    %ebp,%esp
    a5dc:	5d                   	pop    %ebp
    a5dd:	c3                   	ret    
    a5de:	89 f6                	mov    %esi,%esi
    a5e0:	8b 03                	mov    (%ebx),%eax
    a5e2:	85 c0                	test   %eax,%eax
    a5e4:	74 ea                	je     a5d0 <free_trickles_msk+0x30>
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    a5e6:	8b 53 04             	mov    0x4(%ebx),%edx
    a5e9:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    a5eb:	8b 03                	mov    (%ebx),%eax
	elem->prev = elem->next = NULL;
    a5ed:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    a5f3:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
    a5f6:	8b 43 08             	mov    0x8(%ebx),%eax
    a5f9:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    a600:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    a603:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    a60a:	eb c4                	jmp    a5d0 <free_trickles_msk+0x30>
    a60c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
#ifndef USERTEST
static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk) {
	if(!SIMULATION_MODE(sk)) {
		if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) {
			printk("double free\n");
    a610:	c7 04 24 bf 05 00 00 	movl   $0x5bf,(%esp,1)
    a617:	e8 fc ff ff ff       	call   a618 <free_trickles_msk+0x78>
			BUG();
    a61c:	c7 44 24 04 cc 05 00 	movl   $0x5cc,0x4(%esp,1)
    a623:	00 
    a624:	c7 04 24 d0 05 00 00 	movl   $0x5d0,(%esp,1)
    a62b:	e8 fc ff ff ff       	call   a62c <free_trickles_msk+0x8c>
    a630:	e8 fc ff ff ff       	call   a631 <free_trickles_msk+0x91>
    a635:	8b 43 0c             	mov    0xc(%ebx),%eax
    a638:	eb 93                	jmp    a5cd <free_trickles_msk+0x2d>
    a63a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000a640 <free_trickles_msk_finish>:
		}
		if(msk->ctl == ALLOC_READY && msk->prev != NULL) {
			unlink((struct alloc_head *)msk);
		}
		msk->ctl = ALLOC_PROCESSING;
	}
}

static inline void free_trickles_msk_finish(struct sock *sk, struct cminisock *msk) {
    a640:	55                   	push   %ebp
    a641:	89 e5                	mov    %esp,%ebp
    a643:	57                   	push   %edi
    a644:	56                   	push   %esi
    a645:	31 f6                	xor    %esi,%esi
    a647:	53                   	push   %ebx
    a648:	83 ec 10             	sub    $0x10,%esp
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
    a64b:	8b 45 08             	mov    0x8(%ebp),%eax
	struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
    a64e:	8b 55 08             	mov    0x8(%ebp),%edx
    a651:	8b 7d 0c             	mov    0xc(%ebp),%edi
    a654:	05 bc 00 00 00       	add    $0xbc,%eax
    a659:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    a65c:	81 c2 90 02 00 00    	add    $0x290,%edx
    a662:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
    a665:	8b 97 dc 00 00 00    	mov    0xdc(%edi),%edx
    a66b:	39 d6                	cmp    %edx,%esi
    a66d:	7d 2b                	jge    a69a <free_trickles_msk_finish+0x5a>
    a66f:	31 db                	xor    %ebx,%ebx
    a671:	eb 0d                	jmp    a680 <free_trickles_msk_finish+0x40>
    a673:	90                   	nop    
    a674:	90                   	nop    
    a675:	90                   	nop    
    a676:	90                   	nop    
    a677:	90                   	nop    
    a678:	90                   	nop    
    a679:	90                   	nop    
    a67a:	90                   	nop    
    a67b:	90                   	nop    
    a67c:	90                   	nop    
    a67d:	90                   	nop    
    a67e:	90                   	nop    
    a67f:	90                   	nop    
    a680:	8b 87 e0 00 00 00    	mov    0xe0(%edi),%eax
    a686:	8b 44 18 18          	mov    0x18(%eax,%ebx,1),%eax
    a68a:	85 c0                	test   %eax,%eax
    a68c:	0f 85 6e 01 00 00    	jne    a800 <free_trickles_msk_finish+0x1c0>
    a692:	46                   	inc    %esi
    a693:	83 c3 28             	add    $0x28,%ebx
    a696:	39 d6                	cmp    %edx,%esi
    a698:	7c e6                	jl     a680 <free_trickles_msk_finish+0x40>
    a69a:	8b 55 08             	mov    0x8(%ebp),%edx
    a69d:	8b 82 a8 02 00 00    	mov    0x2a8(%edx),%eax
    a6a3:	a9 01 00 00 00       	test   $0x1,%eax
    a6a8:	74 05                	je     a6af <free_trickles_msk_finish+0x6f>
    a6aa:	83 e0 08             	and    $0x8,%eax
    a6ad:	74 0e                	je     a6bd <free_trickles_msk_finish+0x7d>
    a6af:	8b 87 e0 00 00 00    	mov    0xe0(%edi),%eax
    a6b5:	85 c0                	test   %eax,%eax
    a6b7:	0f 85 2d 01 00 00    	jne    a7ea <free_trickles_msk_finish+0x1aa>
    a6bd:	8b 87 80 00 00 00    	mov    0x80(%edi),%eax
    a6c3:	85 c0                	test   %eax,%eax
    a6c5:	0f 85 0b 01 00 00    	jne    a7d6 <free_trickles_msk_finish+0x196>
    a6cb:	8b 87 88 00 00 00    	mov    0x88(%edi),%eax
    a6d1:	85 c0                	test   %eax,%eax
    a6d3:	0f 85 e9 00 00 00    	jne    a7c2 <free_trickles_msk_finish+0x182>

	free_minisock(sk,msk);
	if(!SIMULATION_MODE(sk)) {
    a6d9:	8b 55 08             	mov    0x8(%ebp),%edx
    a6dc:	8b 82 a8 02 00 00    	mov    0x2a8(%edx),%eax
    a6e2:	a9 01 00 00 00       	test   $0x1,%eax
    a6e7:	74 09                	je     a6f2 <free_trickles_msk_finish+0xb2>
    a6e9:	83 e0 08             	and    $0x8,%eax
    a6ec:	0f 84 89 00 00 00    	je     a77b <free_trickles_msk_finish+0x13b>
		if(msk->ctl != ALLOC_PROCESSING && msk->ctl != ALLOC_HALFFREE) {
    a6f2:	8b 47 0c             	mov    0xc(%edi),%eax
    a6f5:	83 e8 03             	sub    $0x3,%eax
    a6f8:	83 f8 01             	cmp    $0x1,%eax
    a6fb:	77 57                	ja     a754 <free_trickles_msk_finish+0x114>
	if(elem->list) {
		BUG();
	}
#endif
	if(head->next == elem /* || elem->prev != NULL || elem->next != NULL */) {
    a6fd:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    a700:	39 78 04             	cmp    %edi,0x4(%eax)
    a703:	74 28                	je     a72d <free_trickles_msk_finish+0xed>
		BUG();
		show_stack(NULL);	
	}
	elem->next = head->next;
    a705:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    a708:	8b 42 04             	mov    0x4(%edx),%eax
    a70b:	89 47 04             	mov    %eax,0x4(%edi)
	head->next->prev = elem;
    a70e:	8b 42 04             	mov    0x4(%edx),%eax
    a711:	89 38                	mov    %edi,(%eax)

	elem->prev = (struct alloc_head*)head;
    a713:	89 17                	mov    %edx,(%edi)
	head->next = elem;
    a715:	89 7a 04             	mov    %edi,0x4(%edx)

	elem->list = head;
    a718:	89 57 08             	mov    %edx,0x8(%edi)
	head->len++;
    a71b:	ff 42 10             	incl   0x10(%edx)
			printk("free_rstcp_msk_finish without corresponding free_rstcp_msk\n");
			BUG();
		}
		insert_head(head, (struct alloc_head *)msk);
		msk->ctl = ALLOC_FREE;
    a71e:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
	} else {
		if(msk == tp->t.responseMSK) {
		} else {
			// overflow
			unlink((struct alloc_head*)msk);
			kfree(msk);
		}
		tp->t.responseCount--;
	}
	
}
    a725:	83 c4 10             	add    $0x10,%esp
    a728:	5b                   	pop    %ebx
    a729:	5e                   	pop    %esi
    a72a:	5f                   	pop    %edi
    a72b:	5d                   	pop    %ebp
    a72c:	c3                   	ret    
		BUG();
	}
#endif
	if(head->next == elem /* || elem->prev != NULL || elem->next != NULL */) {
		BUG();
    a72d:	c7 44 24 04 cc 05 00 	movl   $0x5cc,0x4(%esp,1)
    a734:	00 
    a735:	c7 04 24 d0 05 00 00 	movl   $0x5d0,(%esp,1)
    a73c:	e8 fc ff ff ff       	call   a73d <free_trickles_msk_finish+0xfd>
    a741:	e8 fc ff ff ff       	call   a742 <free_trickles_msk_finish+0x102>
		show_stack(NULL);	
    a746:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    a74d:	e8 fc ff ff ff       	call   a74e <free_trickles_msk_finish+0x10e>
    a752:	eb b1                	jmp    a705 <free_trickles_msk_finish+0xc5>

	free_minisock(sk,msk);
	if(!SIMULATION_MODE(sk)) {
		if(msk->ctl != ALLOC_PROCESSING && msk->ctl != ALLOC_HALFFREE) {
			printk("free_rstcp_msk_finish without corresponding free_rstcp_msk\n");
    a754:	c7 04 24 80 2f 00 00 	movl   $0x2f80,(%esp,1)
    a75b:	e8 fc ff ff ff       	call   a75c <free_trickles_msk_finish+0x11c>
			BUG();
    a760:	c7 44 24 04 cc 05 00 	movl   $0x5cc,0x4(%esp,1)
    a767:	00 
    a768:	c7 04 24 d0 05 00 00 	movl   $0x5d0,(%esp,1)
    a76f:	e8 fc ff ff ff       	call   a770 <free_trickles_msk_finish+0x130>
    a774:	e8 fc ff ff ff       	call   a775 <free_trickles_msk_finish+0x135>
    a779:	eb 82                	jmp    a6fd <free_trickles_msk_finish+0xbd>
		}
		insert_head(head, (struct alloc_head *)msk);
		msk->ctl = ALLOC_FREE;
	} else {
		if(msk == tp->t.responseMSK) {
    a77b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    a77e:	3b b8 3c 0b 00 00    	cmp    0xb3c(%eax),%edi
    a784:	74 2e                	je     a7b4 <free_trickles_msk_finish+0x174>
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    a786:	8b 57 04             	mov    0x4(%edi),%edx
    a789:	8b 07                	mov    (%edi),%eax
    a78b:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    a78d:	8b 07                	mov    (%edi),%eax
	elem->prev = elem->next = NULL;
    a78f:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    a795:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
    a798:	8b 47 08             	mov    0x8(%edi),%eax
    a79b:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
    a7a2:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    a7a5:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
		if(msk == tp->t.responseMSK) {
		} else {
			// overflow
			unlink((struct alloc_head*)msk);
			kfree(msk);
    a7ac:	89 3c 24             	mov    %edi,(%esp,1)
    a7af:	e8 fc ff ff ff       	call   a7b0 <free_trickles_msk_finish+0x170>
		}
		tp->t.responseCount--;
    a7b4:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    a7b7:	ff 8a 54 0b 00 00    	decl   0xb54(%edx)
    a7bd:	e9 63 ff ff ff       	jmp    a725 <free_trickles_msk_finish+0xe5>
    a7c2:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    a7c6:	8b 45 08             	mov    0x8(%ebp),%eax
    a7c9:	89 04 24             	mov    %eax,(%esp,1)
    a7cc:	e8 fc ff ff ff       	call   a7cd <free_trickles_msk_finish+0x18d>
    a7d1:	e9 03 ff ff ff       	jmp    a6d9 <free_trickles_msk_finish+0x99>
    a7d6:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    a7da:	8b 55 08             	mov    0x8(%ebp),%edx
    a7dd:	89 14 24             	mov    %edx,(%esp,1)
    a7e0:	e8 fc ff ff ff       	call   a7e1 <free_trickles_msk_finish+0x1a1>
    a7e5:	e9 e1 fe ff ff       	jmp    a6cb <free_trickles_msk_finish+0x8b>
    a7ea:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    a7ee:	8b 45 08             	mov    0x8(%ebp),%eax
    a7f1:	89 04 24             	mov    %eax,(%esp,1)
    a7f4:	e8 fc ff ff ff       	call   a7f5 <free_trickles_msk_finish+0x1b5>
    a7f9:	e9 bf fe ff ff       	jmp    a6bd <free_trickles_msk_finish+0x7d>
    a7fe:	89 f6                	mov    %esi,%esi
    a800:	89 04 24             	mov    %eax,(%esp,1)
    a803:	e8 fc ff ff ff       	call   a804 <free_trickles_msk_finish+0x1c4>
    a808:	8b 97 dc 00 00 00    	mov    0xdc(%edi),%edx
    a80e:	e9 7f fe ff ff       	jmp    a692 <free_trickles_msk_finish+0x52>
    a813:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    a819:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

0000a820 <unmarshallContinuationServer>:
  do{					\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
    a820:	55                   	push   %ebp
    a821:	89 e5                	mov    %esp,%ebp
    a823:	31 d2                	xor    %edx,%edx
    a825:	57                   	push   %edi
    a826:	56                   	push   %esi
    a827:	53                   	push   %ebx
    a828:	83 ec 40             	sub    $0x40,%esp
    a82b:	8b 45 08             	mov    0x8(%ebp),%eax
    a82e:	8b 58 0c             	mov    0xc(%eax),%ebx
    a831:	8b 83 a8 02 00 00    	mov    0x2a8(%ebx),%eax
    a837:	a9 01 00 00 00       	test   $0x1,%eax
    a83c:	74 05                	je     a843 <unmarshallContinuationServer+0x23>
    a83e:	83 e0 08             	and    $0x8,%eax
    a841:	74 05                	je     a848 <unmarshallContinuationServer+0x28>
    a843:	ba 01 00 00 00       	mov    $0x1,%edx
    a848:	85 d2                	test   %edx,%edx
    a84a:	0f 85 03 01 00 00    	jne    a953 <unmarshallContinuationServer+0x133>
    a850:	8b 55 10             	mov    0x10(%ebp),%edx
    a853:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    a856:	0f b6 02             	movzbl (%edx),%eax
    a859:	89 41 38             	mov    %eax,0x38(%ecx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    a85c:	8b 42 01             	mov    0x1(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    a85f:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    a861:	89 41 34             	mov    %eax,0x34(%ecx)
  do{					\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
    a864:	8b 42 09             	mov    0x9(%edx),%eax
    a867:	89 41 3c             	mov    %eax,0x3c(%ecx)
    a86a:	8b 42 0d             	mov    0xd(%edx),%eax
    a86d:	89 41 40             	mov    %eax,0x40(%ecx)
    a870:	8b 42 25             	mov    0x25(%edx),%eax
    a873:	89 41 44             	mov    %eax,0x44(%ecx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    a876:	8b 42 25             	mov    0x25(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    a879:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    a87b:	89 41 4c             	mov    %eax,0x4c(%ecx)
  do{					\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
    a87e:	8b 42 11             	mov    0x11(%edx),%eax
    a881:	89 41 50             	mov    %eax,0x50(%ecx)
    a884:	8b 42 29             	mov    0x29(%edx),%eax
    a887:	89 41 48             	mov    %eax,0x48(%ecx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    a88a:	8b 42 29             	mov    0x29(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    a88d:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    a88f:	89 41 54             	mov    %eax,0x54(%ecx)
  do{					\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
    a892:	0f b6 42 2d          	movzbl 0x2d(%edx),%eax
    a896:	89 41 58             	mov    %eax,0x58(%ecx)
    a899:	0f b6 42 05          	movzbl 0x5(%edx),%eax
    a89d:	89 41 5c             	mov    %eax,0x5c(%ecx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    a8a0:	8b 42 2e             	mov    0x2e(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    a8a3:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    a8a5:	89 41 60             	mov    %eax,0x60(%ecx)
    a8a8:	8b 42 32             	mov    0x32(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    a8ab:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    a8ad:	89 41 64             	mov    %eax,0x64(%ecx)
    a8b0:	8b 42 36             	mov    0x36(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    a8b3:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    a8b5:	89 41 68             	mov    %eax,0x68(%ecx)
    a8b8:	8b 42 3a             	mov    0x3a(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    a8bb:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    a8bd:	89 41 6c             	mov    %eax,0x6c(%ecx)
    a8c0:	8b 42 3e             	mov    0x3e(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    a8c3:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    a8c5:	89 41 70             	mov    %eax,0x70(%ecx)
  do{					\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
    a8c8:	31 d2                	xor    %edx,%edx
    a8ca:	8b 75 08             	mov    0x8(%ebp),%esi
    a8cd:	8b 46 0c             	mov    0xc(%esi),%eax
    a8d0:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    a8d6:	a9 01 00 00 00       	test   $0x1,%eax
    a8db:	74 05                	je     a8e2 <unmarshallContinuationServer+0xc2>
    a8dd:	83 e0 08             	and    $0x8,%eax
    a8e0:	74 05                	je     a8e7 <unmarshallContinuationServer+0xc7>
    a8e2:	ba 01 00 00 00       	mov    $0x1,%edx
    a8e7:	85 d2                	test   %edx,%edx
    a8e9:	75 39                	jne    a924 <unmarshallContinuationServer+0x104>
    a8eb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    a8ee:	31 db                	xor    %ebx,%ebx
    a8f0:	89 99 dc 00 00 00    	mov    %ebx,0xdc(%ecx)
    a8f6:	8b 75 10             	mov    0x10(%ebp),%esi
    a8f9:	8b 46 42             	mov    0x42(%esi),%eax
    a8fc:	8b 56 46             	mov    0x46(%esi),%edx
    a8ff:	89 41 74             	mov    %eax,0x74(%ecx)
    a902:	31 c0                	xor    %eax,%eax
    a904:	89 51 78             	mov    %edx,0x78(%ecx)
    a907:	31 d2                	xor    %edx,%edx
    a909:	89 91 c0 00 00 00    	mov    %edx,0xc0(%ecx)
    a90f:	89 81 c4 00 00 00    	mov    %eax,0xc4(%ecx)
    a915:	b9 01 00 00 00       	mov    $0x1,%ecx
    a91a:	83 c4 40             	add    $0x40,%esp
    a91d:	89 c8                	mov    %ecx,%eax
    a91f:	5b                   	pop    %ebx
    a920:	5e                   	pop    %esi
    a921:	5f                   	pop    %edi
    a922:	5d                   	pop    %ebp
    a923:	c3                   	ret    
    a924:	8b 7d 08             	mov    0x8(%ebp),%edi
    a927:	8b 55 0c             	mov    0xc(%ebp),%edx
    a92a:	8b 47 24             	mov    0x24(%edi),%eax
    a92d:	8b 40 10             	mov    0x10(%eax),%eax
    a930:	89 42 14             	mov    %eax,0x14(%edx)
    a933:	8b 47 24             	mov    0x24(%edi),%eax
    a936:	8b 40 0c             	mov    0xc(%eax),%eax
    a939:	89 42 18             	mov    %eax,0x18(%edx)
    a93c:	8b 47 20             	mov    0x20(%edi),%eax
    a93f:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    a943:	66 89 42 1c          	mov    %ax,0x1c(%edx)
    a947:	8b 47 20             	mov    0x20(%edi),%eax
    a94a:	0f b7 00             	movzwl (%eax),%eax
    a94d:	66 89 42 1e          	mov    %ax,0x1e(%edx)
    a951:	eb 98                	jmp    a8eb <unmarshallContinuationServer+0xcb>
    a953:	8b 55 10             	mov    0x10(%ebp),%edx
    a956:	8d 7d e4             	lea    0xffffffe4(%ebp),%edi
    a959:	8b 75 08             	mov    0x8(%ebp),%esi
    a95c:	8b 42 01             	mov    0x1(%edx),%eax
    a95f:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
    a962:	0f b6 02             	movzbl (%edx),%eax
    a965:	88 45 c8             	mov    %al,0xffffffc8(%ebp)
    a968:	0f b6 42 05          	movzbl 0x5(%edx),%eax
    a96c:	88 45 c9             	mov    %al,0xffffffc9(%ebp)
    a96f:	8b 4e 24             	mov    0x24(%esi),%ecx
    a972:	8b 41 10             	mov    0x10(%ecx),%eax
    a975:	89 45 ca             	mov    %eax,0xffffffca(%ebp)
    a978:	8b 56 20             	mov    0x20(%esi),%edx
    a97b:	89 fe                	mov    %edi,%esi
    a97d:	0f b7 42 02          	movzwl 0x2(%edx),%eax
    a981:	66 89 45 ce          	mov    %ax,0xffffffce(%ebp)
    a985:	8b 41 0c             	mov    0xc(%ecx),%eax
    a988:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    a98b:	0f b7 02             	movzwl (%edx),%eax
    a98e:	8d 55 c4             	lea    0xffffffc4(%ebp),%edx
    a991:	89 7c 24 0c          	mov    %edi,0xc(%esp,1)
    a995:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    a999:	89 1c 24             	mov    %ebx,(%esp,1)
    a99c:	66 89 45 d4          	mov    %ax,0xffffffd4(%ebp)
    a9a0:	8b 45 10             	mov    0x10(%ebp),%eax
    a9a3:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    a9a7:	e8 fc ff ff ff       	call   a9a8 <unmarshallContinuationServer+0x188>
    a9ac:	8b 45 10             	mov    0x10(%ebp),%eax
    a9af:	b9 10 00 00 00       	mov    $0x10,%ecx
    a9b4:	fc                   	cld    
    a9b5:	83 c0 15             	add    $0x15,%eax
    a9b8:	89 c7                	mov    %eax,%edi
    a9ba:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
    a9bc:	0f 97 c2             	seta   %dl
    a9bf:	0f 92 c0             	setb   %al
    a9c2:	31 c9                	xor    %ecx,%ecx
    a9c4:	38 c2                	cmp    %al,%dl
    a9c6:	0f 85 4e ff ff ff    	jne    a91a <unmarshallContinuationServer+0xfa>
    a9cc:	e9 7f fe ff ff       	jmp    a850 <unmarshallContinuationServer+0x30>
    a9d1:	eb 0d                	jmp    a9e0 <unmarshallContinuationClient>
    a9d3:	90                   	nop    
    a9d4:	90                   	nop    
    a9d5:	90                   	nop    
    a9d6:	90                   	nop    
    a9d7:	90                   	nop    
    a9d8:	90                   	nop    
    a9d9:	90                   	nop    
    a9da:	90                   	nop    
    a9db:	90                   	nop    
    a9dc:	90                   	nop    
    a9dd:	90                   	nop    
    a9de:	90                   	nop    
    a9df:	90                   	nop    

0000a9e0 <unmarshallContinuationClient>:
UNMARSHALL_CONTINUATION(Client, CLIENT_COMPUTE_MAC);
    a9e0:	55                   	push   %ebp
    a9e1:	89 e5                	mov    %esp,%ebp
    a9e3:	57                   	push   %edi
    a9e4:	56                   	push   %esi
    a9e5:	53                   	push   %ebx
    a9e6:	83 ec 0c             	sub    $0xc,%esp
    a9e9:	8b 75 10             	mov    0x10(%ebp),%esi
    a9ec:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp,1)
    a9f3:	00 
    a9f4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a9f7:	8b 7d 08             	mov    0x8(%ebp),%edi
    a9fa:	8d 46 15             	lea    0x15(%esi),%eax
    a9fd:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    aa01:	8d 83 8c 00 00 00    	lea    0x8c(%ebx),%eax
    aa07:	89 04 24             	mov    %eax,(%esp,1)
    aa0a:	e8 d1 29 00 00       	call   d3e0 <__constant_memcpy>
    aa0f:	0f b6 06             	movzbl (%esi),%eax
    aa12:	31 d2                	xor    %edx,%edx
    aa14:	89 43 38             	mov    %eax,0x38(%ebx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    aa17:	8b 46 01             	mov    0x1(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    aa1a:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    aa1c:	89 43 34             	mov    %eax,0x34(%ebx)
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
UNMARSHALL_CONTINUATION(Client, CLIENT_COMPUTE_MAC);
    aa1f:	8b 46 09             	mov    0x9(%esi),%eax
    aa22:	89 43 3c             	mov    %eax,0x3c(%ebx)
    aa25:	8b 46 0d             	mov    0xd(%esi),%eax
    aa28:	89 43 40             	mov    %eax,0x40(%ebx)
    aa2b:	8b 46 25             	mov    0x25(%esi),%eax
    aa2e:	89 43 44             	mov    %eax,0x44(%ebx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    aa31:	8b 46 25             	mov    0x25(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    aa34:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    aa36:	89 43 4c             	mov    %eax,0x4c(%ebx)
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
UNMARSHALL_CONTINUATION(Client, CLIENT_COMPUTE_MAC);
    aa39:	8b 46 11             	mov    0x11(%esi),%eax
    aa3c:	89 43 50             	mov    %eax,0x50(%ebx)
    aa3f:	8b 46 29             	mov    0x29(%esi),%eax
    aa42:	89 43 48             	mov    %eax,0x48(%ebx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    aa45:	8b 46 29             	mov    0x29(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    aa48:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    aa4a:	89 43 54             	mov    %eax,0x54(%ebx)
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
UNMARSHALL_CONTINUATION(Client, CLIENT_COMPUTE_MAC);
    aa4d:	0f b6 46 2d          	movzbl 0x2d(%esi),%eax
    aa51:	89 43 58             	mov    %eax,0x58(%ebx)
    aa54:	0f b6 46 05          	movzbl 0x5(%esi),%eax
    aa58:	89 43 5c             	mov    %eax,0x5c(%ebx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    aa5b:	8b 46 2e             	mov    0x2e(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    aa5e:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    aa60:	89 43 60             	mov    %eax,0x60(%ebx)
    aa63:	8b 46 32             	mov    0x32(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    aa66:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    aa68:	89 43 64             	mov    %eax,0x64(%ebx)
    aa6b:	8b 46 36             	mov    0x36(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    aa6e:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    aa70:	89 43 68             	mov    %eax,0x68(%ebx)
    aa73:	8b 46 3a             	mov    0x3a(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    aa76:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    aa78:	89 43 6c             	mov    %eax,0x6c(%ebx)
    aa7b:	8b 46 3e             	mov    0x3e(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    aa7e:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    aa80:	89 43 70             	mov    %eax,0x70(%ebx)
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
UNMARSHALL_CONTINUATION(Client, CLIENT_COMPUTE_MAC);
    aa83:	8b 47 0c             	mov    0xc(%edi),%eax
    aa86:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    aa8c:	a9 01 00 00 00       	test   $0x1,%eax
    aa91:	74 05                	je     aa98 <unmarshallContinuationClient+0xb8>
    aa93:	83 e0 08             	and    $0x8,%eax
    aa96:	74 05                	je     aa9d <unmarshallContinuationClient+0xbd>
    aa98:	ba 01 00 00 00       	mov    $0x1,%edx
    aa9d:	85 d2                	test   %edx,%edx
    aa9f:	75 31                	jne    aad2 <unmarshallContinuationClient+0xf2>
    aaa1:	31 c0                	xor    %eax,%eax
    aaa3:	31 ff                	xor    %edi,%edi
    aaa5:	89 83 dc 00 00 00    	mov    %eax,0xdc(%ebx)
    aaab:	8b 46 42             	mov    0x42(%esi),%eax
    aaae:	8b 56 46             	mov    0x46(%esi),%edx
    aab1:	31 f6                	xor    %esi,%esi
    aab3:	89 bb c0 00 00 00    	mov    %edi,0xc0(%ebx)
    aab9:	89 b3 c4 00 00 00    	mov    %esi,0xc4(%ebx)
    aabf:	89 43 74             	mov    %eax,0x74(%ebx)
    aac2:	b8 01 00 00 00       	mov    $0x1,%eax
    aac7:	89 53 78             	mov    %edx,0x78(%ebx)
    aaca:	83 c4 0c             	add    $0xc,%esp
    aacd:	5b                   	pop    %ebx
    aace:	5e                   	pop    %esi
    aacf:	5f                   	pop    %edi
    aad0:	5d                   	pop    %ebp
    aad1:	c3                   	ret    
    aad2:	8b 47 24             	mov    0x24(%edi),%eax
    aad5:	8b 40 10             	mov    0x10(%eax),%eax
    aad8:	89 43 14             	mov    %eax,0x14(%ebx)
    aadb:	8b 47 24             	mov    0x24(%edi),%eax
    aade:	8b 40 0c             	mov    0xc(%eax),%eax
    aae1:	89 43 18             	mov    %eax,0x18(%ebx)
    aae4:	8b 47 20             	mov    0x20(%edi),%eax
    aae7:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    aaeb:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
    aaef:	8b 47 20             	mov    0x20(%edi),%eax
    aaf2:	0f b7 00             	movzwl (%eax),%eax
    aaf5:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
    aaf9:	eb a6                	jmp    aaa1 <unmarshallContinuationClient+0xc1>
    aafb:	90                   	nop    
    aafc:	8d 74 26 00          	lea    0x0(%esi,1),%esi

0000ab00 <mborg_isqrt4>:
#define QUAD(SIGN,a,b,c) (-(b) SIGN sqrtf((b) * (b) - 4*(a)*(c))) / (2 * a)
#define COMPUTE_CWND(SSTHRESH, TCPBASE, SEQ) \
   QUAD(+, 1.0/2.0, 1.0/2.0, -((int)(SSTHRESH) * ((int)(SSTHRESH) + 1)) / 2.0 - (SEQ) + (TCPBASE));
#else
static unsigned int mborg_isqrt4(unsigned long val) {
    ab00:	55                   	push   %ebp
    ab01:	89 e5                	mov    %esp,%ebp
    ab03:	53                   	push   %ebx
    ab04:	8b 4d 08             	mov    0x8(%ebp),%ecx
  unsigned int temp, g=0;
    ab07:	31 db                	xor    %ebx,%ebx

  if (val >= 0x40000000) {
    ab09:	81 f9 ff ff ff 3f    	cmp    $0x3fffffff,%ecx
    ab0f:	76 0b                	jbe    ab1c <mborg_isqrt4+0x1c>
    g = 0x8000; 
    ab11:	bb 00 80 00 00       	mov    $0x8000,%ebx
    val -= 0x40000000;
    ab16:	81 e9 00 00 00 40    	sub    $0x40000000,%ecx
  }

#define INNER_MBGSQRT(s)                      \
  temp = (g << (s)) + (1 << ((s) * 2 - 2));   \
  if (val >= temp) {                          \
    g += 1 << ((s)-1);                        \
    val -= temp;                              \
  }

  INNER_MBGSQRT (15)
    ab1c:	89 d8                	mov    %ebx,%eax
    ab1e:	c1 e0 0f             	shl    $0xf,%eax
    ab21:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
    ab27:	39 d1                	cmp    %edx,%ecx
    ab29:	72 08                	jb     ab33 <mborg_isqrt4+0x33>
    ab2b:	81 c3 00 40 00 00    	add    $0x4000,%ebx
    ab31:	29 d1                	sub    %edx,%ecx
  INNER_MBGSQRT (14)
    ab33:	89 d8                	mov    %ebx,%eax
    ab35:	c1 e0 0e             	shl    $0xe,%eax
    ab38:	8d 90 00 00 00 04    	lea    0x4000000(%eax),%edx
    ab3e:	39 d1                	cmp    %edx,%ecx
    ab40:	72 08                	jb     ab4a <mborg_isqrt4+0x4a>
    ab42:	81 c3 00 20 00 00    	add    $0x2000,%ebx
    ab48:	29 d1                	sub    %edx,%ecx
  INNER_MBGSQRT (13)
    ab4a:	89 d8                	mov    %ebx,%eax
    ab4c:	c1 e0 0d             	shl    $0xd,%eax
    ab4f:	8d 90 00 00 00 01    	lea    0x1000000(%eax),%edx
    ab55:	39 d1                	cmp    %edx,%ecx
    ab57:	72 08                	jb     ab61 <mborg_isqrt4+0x61>
    ab59:	81 c3 00 10 00 00    	add    $0x1000,%ebx
    ab5f:	29 d1                	sub    %edx,%ecx
  INNER_MBGSQRT (12)
    ab61:	89 d8                	mov    %ebx,%eax
    ab63:	c1 e0 0c             	shl    $0xc,%eax
    ab66:	8d 90 00 00 40 00    	lea    0x400000(%eax),%edx
    ab6c:	39 d1                	cmp    %edx,%ecx
    ab6e:	72 08                	jb     ab78 <mborg_isqrt4+0x78>
    ab70:	81 c3 00 08 00 00    	add    $0x800,%ebx
    ab76:	29 d1                	sub    %edx,%ecx
  INNER_MBGSQRT (11)
    ab78:	89 d8                	mov    %ebx,%eax
    ab7a:	c1 e0 0b             	shl    $0xb,%eax
    ab7d:	8d 90 00 00 10 00    	lea    0x100000(%eax),%edx
    ab83:	39 d1                	cmp    %edx,%ecx
    ab85:	72 08                	jb     ab8f <mborg_isqrt4+0x8f>
    ab87:	81 c3 00 04 00 00    	add    $0x400,%ebx
    ab8d:	29 d1                	sub    %edx,%ecx
  INNER_MBGSQRT (10)
    ab8f:	89 d8                	mov    %ebx,%eax
    ab91:	c1 e0 0a             	shl    $0xa,%eax
    ab94:	8d 90 00 00 04 00    	lea    0x40000(%eax),%edx
    ab9a:	39 d1                	cmp    %edx,%ecx
    ab9c:	72 08                	jb     aba6 <mborg_isqrt4+0xa6>
    ab9e:	81 c3 00 02 00 00    	add    $0x200,%ebx
    aba4:	29 d1                	sub    %edx,%ecx
  INNER_MBGSQRT ( 9)
    aba6:	89 d8                	mov    %ebx,%eax
    aba8:	c1 e0 09             	shl    $0x9,%eax
    abab:	8d 90 00 00 01 00    	lea    0x10000(%eax),%edx
    abb1:	39 d1                	cmp    %edx,%ecx
    abb3:	72 08                	jb     abbd <mborg_isqrt4+0xbd>
    abb5:	81 c3 00 01 00 00    	add    $0x100,%ebx
    abbb:	29 d1                	sub    %edx,%ecx
  INNER_MBGSQRT ( 8)
    abbd:	89 d8                	mov    %ebx,%eax
    abbf:	c1 e0 08             	shl    $0x8,%eax
    abc2:	8d 90 00 40 00 00    	lea    0x4000(%eax),%edx
    abc8:	39 d1                	cmp    %edx,%ecx
    abca:	72 05                	jb     abd1 <mborg_isqrt4+0xd1>
    abcc:	83 eb 80             	sub    $0xffffff80,%ebx
    abcf:	29 d1                	sub    %edx,%ecx
  INNER_MBGSQRT ( 7)
    abd1:	89 d8                	mov    %ebx,%eax
    abd3:	c1 e0 07             	shl    $0x7,%eax
    abd6:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
    abdc:	39 d1                	cmp    %edx,%ecx
    abde:	72 05                	jb     abe5 <mborg_isqrt4+0xe5>
    abe0:	83 c3 40             	add    $0x40,%ebx
    abe3:	29 d1                	sub    %edx,%ecx
  INNER_MBGSQRT ( 6)
    abe5:	89 d8                	mov    %ebx,%eax
    abe7:	c1 e0 06             	shl    $0x6,%eax
    abea:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
    abf0:	39 d1                	cmp    %edx,%ecx
    abf2:	72 05                	jb     abf9 <mborg_isqrt4+0xf9>
    abf4:	83 c3 20             	add    $0x20,%ebx
    abf7:	29 d1                	sub    %edx,%ecx
  INNER_MBGSQRT ( 5)
    abf9:	89 d8                	mov    %ebx,%eax
    abfb:	c1 e0 05             	shl    $0x5,%eax
    abfe:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    ac04:	39 d1                	cmp    %edx,%ecx
    ac06:	72 05                	jb     ac0d <mborg_isqrt4+0x10d>
    ac08:	83 c3 10             	add    $0x10,%ebx
    ac0b:	29 d1                	sub    %edx,%ecx
  INNER_MBGSQRT ( 4)
    ac0d:	89 d8                	mov    %ebx,%eax
    ac0f:	c1 e0 04             	shl    $0x4,%eax
    ac12:	8d 50 40             	lea    0x40(%eax),%edx
    ac15:	39 d1                	cmp    %edx,%ecx
    ac17:	72 05                	jb     ac1e <mborg_isqrt4+0x11e>
    ac19:	83 c3 08             	add    $0x8,%ebx
    ac1c:	29 d1                	sub    %edx,%ecx
  INNER_MBGSQRT ( 3)
    ac1e:	8d 14 dd 10 00 00 00 	lea    0x10(,%ebx,8),%edx
    ac25:	39 d1                	cmp    %edx,%ecx
    ac27:	72 05                	jb     ac2e <mborg_isqrt4+0x12e>
    ac29:	83 c3 04             	add    $0x4,%ebx
    ac2c:	29 d1                	sub    %edx,%ecx
  INNER_MBGSQRT ( 2)
    ac2e:	8d 14 9d 04 00 00 00 	lea    0x4(,%ebx,4),%edx
    ac35:	39 d1                	cmp    %edx,%ecx
    ac37:	72 05                	jb     ac3e <mborg_isqrt4+0x13e>
    ac39:	83 c3 02             	add    $0x2,%ebx
    ac3c:	29 d1                	sub    %edx,%ecx

#undef INNER_MBGSQRT

  temp = g+g+1;
    ac3e:	8d 54 1b 01          	lea    0x1(%ebx,%ebx,1),%edx
  if (val >= temp) g++;
    ac42:	8d 43 01             	lea    0x1(%ebx),%eax
    ac45:	39 d1                	cmp    %edx,%ecx
    ac47:	0f 43 d8             	cmovae %eax,%ebx
  return g;
}
    ac4a:	89 d8                	mov    %ebx,%eax
    ac4c:	5b                   	pop    %ebx
    ac4d:	5d                   	pop    %ebp
    ac4e:	c3                   	ret    
    ac4f:	90                   	nop    

0000ac50 <AckTCPCwnd>:

#define QUAD(SIGN,a,b,c) (-(b) SIGN mborg_isqrt4((b) * (b) - 4*(a)*(c))) / (2 * a)

// TODO: Improve precision?
/*
 * Fixed point computation with a fast square root is a bit tricky. 
 * We perform the square root at .(2*PREC) precision, after which the datatype becomes
 * .(PREC) (since the scaling factor is taken to ^-0.5)

     In floating point, the expression is 
      - (1/2) + sqrt((1/2)^2 - 4*1/2*(-(ssthresh*(ssthresh+1)/2 - *(seq - TCPBase))))
*/

#define PREC (1)
#define COMPUTE_CWND(SSTHRESH, TCPBASE, SEQ) \
	(((-1 << (PREC - 1)) + mborg_isqrt4((1 << (2*PREC - 2)) - ((-((int)(ssthresh) * ((int)(ssthresh) + 1)) - 2 * (((int)seq) - (TCPBase))) << (2*PREC)))) >> PREC)
#endif // USE_FLOATINGPOINT

#define MAX_CWND ((1<<13)-1)
#define CLAMP(X) (MIN((X),MAX_CWND))

// TODO: Investigate using -msoftfloat, or saving/restoring FPU state
// while processing interrupts

int AckTCPCwnd(unsigned seq, const CONTINUATION_TYPE *cont, int *hintResult) {
    ac50:	55                   	push   %ebp
    ac51:	89 e5                	mov    %esp,%ebp
    ac53:	57                   	push   %edi
  int res, hint = -1;
  // hint is processed as a relative offset in the body, then converted to an absolute offset just before returning
  unsigned startCwnd = cont->startCwnd;
  unsigned ssthresh = MIN(MAX(cont->ssthresh, startCwnd), MAX_CWND);
    ac54:	bf ff 1f 00 00       	mov    $0x1fff,%edi
    ac59:	56                   	push   %esi
    ac5a:	53                   	push   %ebx
    ac5b:	83 ec 18             	sub    $0x18,%esp
    ac5e:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,0xfffffff0(%ebp)
    ac65:	8b 55 0c             	mov    0xc(%ebp),%edx
    ac68:	8b 45 08             	mov    0x8(%ebp),%eax
    ac6b:	8b 5a 68             	mov    0x68(%edx),%ebx
    ac6e:	89 d1                	mov    %edx,%ecx
    ac70:	8b 52 6c             	mov    0x6c(%edx),%edx
  unsigned TCPBase = cont->TCPBase;
    ac73:	8b 49 70             	mov    0x70(%ecx),%ecx
    ac76:	39 d3                	cmp    %edx,%ebx
    ac78:	0f 43 d3             	cmovae %ebx,%edx
    ac7b:	81 fa 00 20 00 00    	cmp    $0x2000,%edx
    ac81:	0f 42 fa             	cmovb  %edx,%edi
  unsigned additiveStart = (ssthresh - startCwnd + TCPBase) + ssthresh;

#ifdef ACKTCP_CWND_SPEED_HACK
  seq = TCPBase + (seq - TCPBase) * ACKTCP_CWND_SPEED_HACK;
    ac84:	29 c8                	sub    %ecx,%eax
    ac86:	89 fa                	mov    %edi,%edx
    ac88:	29 da                	sub    %ebx,%edx
    ac8a:	01 ca                	add    %ecx,%edx
    ac8c:	8d 34 17             	lea    (%edi,%edx,1),%esi
    ac8f:	89 75 ec             	mov    %esi,0xffffffec(%ebp)
    ac92:	d1 e8                	shr    %eax
    ac94:	8d 34 08             	lea    (%eax,%ecx,1),%esi
#endif

  if(seq < TCPBase) {
    ac97:	39 ce                	cmp    %ecx,%esi
    ac99:	73 65                	jae    ad00 <AckTCPCwnd+0xb0>
    if(!disableSevereErrors) 
    ac9b:	8b 1d 00 00 00 00    	mov    0x0,%ebx
    aca1:	85 db                	test   %ebx,%ebx
    aca3:	74 3f                	je     ace4 <AckTCPCwnd+0x94>
      ERROR("Seq (%u) < TCPBase (%u)\n", seq, TCPBase);
    res = -1;
    aca5:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    goto done;
  }

#if 0
  // obsolete test
  if(seq - TCPBase > MAX_CWND * MAX_CWND) {
	  printk("Exceeded max limit without renormalizing\n");
	  res = -1;
	  goto done;
  }
#endif
  if(seq < ssthresh - startCwnd + TCPBase) {
    res = startCwnd + (seq - TCPBase);
  } else if(ssthresh - startCwnd + TCPBase <= seq &&
	    seq < additiveStart) {
    res = ssthresh;
  } else {
	  /* result is solution to x(x+1)-ssthresh(ssthresh+1)
                                   --------------------------- - N
                                                2                  */
	  //int offset = seq - TCPBase;
	  int offset = seq - additiveStart;
#ifdef USE_SQRT
	  int position, cwnd;
	  //double a = 1.0/2.0, b = 1.0/2.0, c = -((int)ssthresh * ((int)ssthresh + 1)) / 2.0 - seq + TCPBase;
	  cwnd = COMPUTE_CWND(ssthresh, TCPBase, seq);
	  
	  //val = 1/4 - (-((int)(ssthresh) * ((int)(ssthresh) + 1)) - 2 * (((int)seq) - (TCPBase)))
	  //printk("sqrt(%d) = %d\n", val, mborg_isqrt4(val));

	  cwnd = CLAMP(cwnd);
	  position = (cwnd*(cwnd+1)-ssthresh*(ssthresh+1)) / 2;
	  if(cwnd == MAX_CWND) {
		  res = cwnd;
		  hint = - 1;
	  } else {
		  if(offset >= position) {
			  int cwnd_1 = CLAMP(cwnd + 1),
				  cwnd_2 = CLAMP(cwnd + 2);
			  if(offset < position + cwnd_1) {
				  res = cwnd_1;
				  hint = additiveStart + position + cwnd_1;
			  } else {
				  if(!(offset < position + cwnd_1 + cwnd_2)) {
#ifndef DISABLE_ACKTCPCWND_WARNINGS
					  BUG_TRAP(0);
#endif
				  }
				  res = cwnd_2;
				  hint = additiveStart + position + cwnd_1 + cwnd_2;
			  }
		  } else if(offset < position) {
			  if(offset > position - cwnd) {
				  res = cwnd;
				  hint = additiveStart + position;
			  } else {
				  if(!(offset > position - cwnd - (cwnd - 1))) {
#ifndef DISABLE_ACKTCPCWND_WARNINGS
					  BUG_TRAP(0);
#endif
				  }
				  if((cwnd - 1) < ssthresh) {
#ifndef DISABLE_ACKTCPCWND_WARNINGS

					  BUG_TRAP(0);
#endif
				  }
#ifndef DISABLE_ACKTCPCWND_WARNINGS
				  BUG_TRAP(cwnd - 1 >= 1);
#endif
				  res = cwnd - 1;
				  hint = additiveStart + position - cwnd;
			  }		  
		  }
	  }
#else
	  // Fixed point Newton's method to solve (cwnd*(cwnd+1) - ssthresh*(ssthresh+)) / 2 = 
#define FRAC (2)
	  int i;
	  static int numIterations, count = 0;
	  //long long x;
	  typedef int FIXEDPT_TYPE;
	  FIXEDPT_TYPE x, oldX[32];;
	  // Special case: offset > max clamp
	  if(offset >= (MAX_CWND * (MAX_CWND + 1) - ssthresh*(ssthresh+1)) / 2) {
		  res = MAX_CWND;
		  goto done;
	  }

	  /* Newton iteration:
	     x_{k+1} = x_k - f(x_k)/f'(x_k) */
	  // set initial guess to maximum possible value to avoid converging to wrong root	  
	  x = (MAX_CWND) << FRAC;
#define MAX_NEWTON_ITERATIONS (sizeof(FIXEDPT_TYPE) * 8)
	  for(i=0; i < MAX_NEWTON_ITERATIONS; i++) {
		  FIXEDPT_TYPE cwnd, xupdate;
		  unsigned position;
		  cwnd = x >> FRAC;

#if 0
		  printk("offset = %d ssthresh = %d x_%d: %d ", offset, ssthresh, i, x >> FRAC);
		  printk("f(x_%d) * 2 = %d (%d %d %d) ", i, (x * (x + (1 << FRAC)) - (((int)ssthresh * ((int)ssthresh + 1) + 2 * offset) << (2 * FRAC))) >> (2 * FRAC), x * (x + (1 << FRAC)), (((int)ssthresh * ((int)ssthresh + 1) + 2 * offset)) << (2 * FRAC), (x * (x + (1 << FRAC)) - (((int)ssthresh * ((int)ssthresh + 1) + 2 * offset) << (2 * FRAC))));
		  printk("f'(x_%d) * 2 = %d ", i, (2 * x + (1 << FRAC)) >> FRAC);
		  printk("f/f' = %d ", ((x * (x + (1 << FRAC)) - (((int)ssthresh * ((int)ssthresh + 1) + 2 * offset) << (2 * FRAC))) /
					 (2 * x + (1 << FRAC))));
		  printk("\n");
#endif
		  position = (cwnd*(cwnd+1)-ssthresh*(ssthresh+1)) / 2;
		  if(offset - position >= 0 && 
		     offset - position < cwnd + 1) {
			  res = CLAMP(cwnd + 1);
			  hint = additiveStart + position + res;

			  if(i > numIterations || count == 100000) {
			    numIterations = i;
			    printk("%d iterations - result = %d\n", i, cwnd);
			    if(count == 100000) count = 0;
			  }
			  count++;
			  goto done;
		  } else if(position - offset > 0 &&
			    position - offset < cwnd) {
			  res = CLAMP(cwnd);
			  hint = additiveStart + position;

			  if(i > numIterations || count == 100000) {
			    numIterations = i;
			    printk("%d iterations - result = %d\n", i, cwnd);
			    if(count == 100000) count = 0;
			  }
			  count++;
			  goto done;
		  }
		  xupdate = (x - 
		       ((x * (x + (1 << FRAC)) - (((int)ssthresh * ((int)ssthresh + 1) + 2 * offset) << (2 * FRAC))) /
			(2 * x + (1 << FRAC))));
		  oldX[i] = x;
		  if(xupdate == x) {
			  int sign0 = ((int)ssthresh * ((int)ssthresh + 1) + 2 * offset) > 0 ? 1 : -1,
				  sign1 = (2 * x + (1 << FRAC)) > 0 ? 1 : -1;
			  x -= (sign0 * sign1) << FRAC;
		  } else {
			  x = xupdate;
		  }
	  }
	  printk("AckTCPCwnd SQRT: Too many iterations: x = %d f(x) = %d f'(x) = %d offset = %d ssthresh * (ssthresh+1) = %d, %d \n", 
		 x >> FRAC, 
		 (x * (x + (1 << FRAC)) - (((int)ssthresh * ((int)ssthresh + 1) + 2 * offset) << (2 * FRAC))) >> (2 * FRAC), 
		 ((2 * x) >> FRAC) + 1,
		 offset, 
		 ssthresh*(ssthresh+1), 
		 (((int)ssthresh * ((int)ssthresh + 1) + 2 * offset))/2);
	  for(i = 0; i < MAX_NEWTON_ITERATIONS; i++) {
		  printk("X_%d = %d\n", i, oldX[i]);
	  }
	  res = (-(1 << (FRAC-1)) + x) >> FRAC;

#endif
#undef FRAC
  }
  done:
	  ;
  if(res > MAX_CWND)
    acaa:	81 fa 00 20 00 00    	cmp    $0x2000,%edx
    acb0:	b8 ff 1f 00 00       	mov    $0x1fff,%eax
    acb5:	0f 4d d0             	cmovge %eax,%edx
	  res = MAX_CWND;
  if(hintResult != NULL)
    acb8:	8b 45 10             	mov    0x10(%ebp),%eax
    acbb:	85 c0                	test   %eax,%eax
    acbd:	74 12                	je     acd1 <AckTCPCwnd+0x81>
    *hintResult = (hint >= 0) ? hint : -1;
    acbf:	83 7d f0 fe          	cmpl   $0xfffffffe,0xfffffff0(%ebp)
    acc3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    acc8:	8b 4d 10             	mov    0x10(%ebp),%ecx
    accb:	0f 4f 45 f0          	cmovg  0xfffffff0(%ebp),%eax
    accf:	89 01                	mov    %eax,(%ecx)
  ((CONTINUATION_TYPE*)cont)->mark = res; // tricklesLossEvent gets cwnd size from here
    acd1:	8b 75 0c             	mov    0xc(%ebp),%esi
  return res;
}
    acd4:	89 d0                	mov    %edx,%eax
    acd6:	89 96 d8 00 00 00    	mov    %edx,0xd8(%esi)
    acdc:	83 c4 18             	add    $0x18,%esp
    acdf:	5b                   	pop    %ebx
    ace0:	5e                   	pop    %esi
    ace1:	5f                   	pop    %edi
    ace2:	5d                   	pop    %ebp
    ace3:	c3                   	ret    
    ace4:	89 4c 24 08          	mov    %ecx,0x8(%esp,1)
    ace8:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    acec:	c7 04 24 eb 05 00 00 	movl   $0x5eb,(%esp,1)
    acf3:	e8 fc ff ff ff       	call   acf4 <AckTCPCwnd+0xa4>
    acf8:	eb ab                	jmp    aca5 <AckTCPCwnd+0x55>
    acfa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    ad00:	39 d6                	cmp    %edx,%esi
    ad02:	73 0c                	jae    ad10 <AckTCPCwnd+0xc0>
    ad04:	29 ce                	sub    %ecx,%esi
    ad06:	8d 14 1e             	lea    (%esi,%ebx,1),%edx
    ad09:	eb 9f                	jmp    acaa <AckTCPCwnd+0x5a>
    ad0b:	90                   	nop    
    ad0c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    ad10:	39 f2                	cmp    %esi,%edx
    ad12:	77 07                	ja     ad1b <AckTCPCwnd+0xcb>
    ad14:	3b 75 ec             	cmp    0xffffffec(%ebp),%esi
    ad17:	89 fa                	mov    %edi,%edx
    ad19:	72 8f                	jb     acaa <AckTCPCwnd+0x5a>
    ad1b:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    ad1e:	89 f0                	mov    %esi,%eax
    ad20:	89 fb                	mov    %edi,%ebx
    ad22:	29 ce                	sub    %ecx,%esi
    ad24:	29 d0                	sub    %edx,%eax
    ad26:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    ad29:	8d 47 01             	lea    0x1(%edi),%eax
    ad2c:	0f af d8             	imul   %eax,%ebx
    ad2f:	8d 04 36             	lea    (%esi,%esi,1),%eax
    ad32:	89 da                	mov    %ebx,%edx
    ad34:	f7 da                	neg    %edx
    ad36:	29 c2                	sub    %eax,%edx
    ad38:	b8 01 00 00 00       	mov    $0x1,%eax
    ad3d:	c1 e2 02             	shl    $0x2,%edx
    ad40:	29 d0                	sub    %edx,%eax
    ad42:	89 04 24             	mov    %eax,(%esp,1)
    ad45:	e8 b6 fd ff ff       	call   ab00 <mborg_isqrt4>
    ad4a:	b9 ff 1f 00 00       	mov    $0x1fff,%ecx
    ad4f:	48                   	dec    %eax
    ad50:	d1 e8                	shr    %eax
    ad52:	39 c1                	cmp    %eax,%ecx
    ad54:	0f 4f c8             	cmovg  %eax,%ecx
    ad57:	8d 41 01             	lea    0x1(%ecx),%eax
    ad5a:	89 ce                	mov    %ecx,%esi
    ad5c:	0f af f0             	imul   %eax,%esi
    ad5f:	29 de                	sub    %ebx,%esi
    ad61:	d1 ee                	shr    %esi
    ad63:	81 f9 ff 1f 00 00    	cmp    $0x1fff,%ecx
    ad69:	74 62                	je     adcd <AckTCPCwnd+0x17d>
    ad6b:	39 75 e8             	cmp    %esi,0xffffffe8(%ebp)
    ad6e:	7c 39                	jl     ada9 <AckTCPCwnd+0x159>
    ad70:	bb ff 1f 00 00       	mov    $0x1fff,%ebx
    ad75:	39 c3                	cmp    %eax,%ebx
    ad77:	ba ff 1f 00 00       	mov    $0x1fff,%edx
    ad7c:	0f 4f d8             	cmovg  %eax,%ebx
    ad7f:	8d 41 02             	lea    0x2(%ecx),%eax
    ad82:	39 c2                	cmp    %eax,%edx
    ad84:	0f 4f d0             	cmovg  %eax,%edx
    ad87:	8d 04 33             	lea    (%ebx,%esi,1),%eax
    ad8a:	39 45 e8             	cmp    %eax,0xffffffe8(%ebp)
    ad8d:	7d 11                	jge    ada0 <AckTCPCwnd+0x150>
    ad8f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    ad92:	89 da                	mov    %ebx,%edx
    ad94:	01 f0                	add    %esi,%eax
    ad96:	01 d0                	add    %edx,%eax
    ad98:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    ad9b:	e9 0a ff ff ff       	jmp    acaa <AckTCPCwnd+0x5a>
    ada0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    ada3:	01 f0                	add    %esi,%eax
    ada5:	01 d8                	add    %ebx,%eax
    ada7:	eb ed                	jmp    ad96 <AckTCPCwnd+0x146>
    ada9:	89 f0                	mov    %esi,%eax
    adab:	29 c8                	sub    %ecx,%eax
    adad:	39 45 e8             	cmp    %eax,0xffffffe8(%ebp)
    adb0:	7e 0f                	jle    adc1 <AckTCPCwnd+0x171>
    adb2:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    adb5:	89 ca                	mov    %ecx,%edx
    adb7:	01 c6                	add    %eax,%esi
    adb9:	89 75 f0             	mov    %esi,0xfffffff0(%ebp)
    adbc:	e9 e9 fe ff ff       	jmp    acaa <AckTCPCwnd+0x5a>
    adc1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    adc4:	8d 51 ff             	lea    0xffffffff(%ecx),%edx
    adc7:	01 c6                	add    %eax,%esi
    adc9:	29 ce                	sub    %ecx,%esi
    adcb:	eb ec                	jmp    adb9 <AckTCPCwnd+0x169>
    adcd:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,0xfffffff0(%ebp)
    add4:	ba ff 1f 00 00       	mov    $0x1fff,%edx
    add9:	e9 cc fe ff ff       	jmp    acaa <AckTCPCwnd+0x5a>
    adde:	89 f6                	mov    %esi,%esi

0000ade0 <Sack_validate>:

inline int AckTCPCwndScalar(unsigned seq, const CONTINUATION_TYPE *cont) {
	return AckTCPCwnd(seq, cont, NULL);
}

int Sack_validate(CONTINUATION_TYPE *cont, Sack *sack) {
    ade0:	55                   	push   %ebp
    ade1:	89 e5                	mov    %esp,%ebp
    ade3:	83 ec 1c             	sub    $0x1c,%esp
    ade6:	89 5d f8             	mov    %ebx,0xfffffff8(%ebp)
    ade9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    adec:	89 75 fc             	mov    %esi,0xfffffffc(%ebp)
  if(sack->left > sack->right) {
    adef:	8b 43 04             	mov    0x4(%ebx),%eax
    adf2:	39 03                	cmp    %eax,(%ebx)
    adf4:	76 0c                	jbe    ae02 <Sack_validate+0x22>
    return 0;
  }
  /* Verify that cumulative nonce matches sack range */
  if(!DISABLE_NONCE_CHECK) {
    __u32 genNonce = generateRangeNonce(cont->sk, sack->left, sack->right);
    if(genNonce != sack->nonceSummary) {
#ifdef DISABLE_NONCE_FAIL // 0715 - this was old code used force side effect from generateRangeNonce() without actually performing nonce check
      static volatile int w;
      w++;
#else
      if(trickles_ratelimit()) {
	printk("nonce check failed for [%d-%d] = 0x%0X != 0x%0X\n", 
	       sack->left, sack->right, genNonce, sack->nonceSummary);
      }
      return 0;
    adf6:	31 c0                	xor    %eax,%eax
#endif
    }
  }
#if 0
  if(trickles_ratelimit()) {
	  printk("nonce check succeeded\n");
  }
#endif
  return 1;
}
    adf8:	8b 5d f8             	mov    0xfffffff8(%ebp),%ebx
    adfb:	8b 75 fc             	mov    0xfffffffc(%ebp),%esi
    adfe:	89 ec                	mov    %ebp,%esp
    ae00:	5d                   	pop    %ebp
    ae01:	c3                   	ret    
    ae02:	8b 43 04             	mov    0x4(%ebx),%eax
    ae05:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp,1)
    ae0c:	00 
    ae0d:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    ae11:	8b 03                	mov    (%ebx),%eax
    ae13:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    ae1a:	00 
    ae1b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ae1f:	8b 45 08             	mov    0x8(%ebp),%eax
    ae22:	8b 40 20             	mov    0x20(%eax),%eax
    ae25:	89 04 24             	mov    %eax,(%esp,1)
    ae28:	e8 fc ff ff ff       	call   ae29 <Sack_validate+0x49>
    ae2d:	3b 43 08             	cmp    0x8(%ebx),%eax
    ae30:	89 c6                	mov    %eax,%esi
    ae32:	0f 84 c5 00 00 00    	je     aefd <Sack_validate+0x11d>
    ae38:	a1 00 00 00 00       	mov    0x0,%eax
    ae3d:	9c                   	pushf  
    ae3e:	59                   	pop    %ecx
    ae3f:	fa                   	cli    
    ae40:	89 c2                	mov    %eax,%edx
    ae42:	2b 15 90 b4 0e 00    	sub    0xeb490,%edx
    ae48:	a3 90 b4 0e 00       	mov    %eax,0xeb490
    ae4d:	03 15 04 01 00 00    	add    0x104,%edx
    ae53:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    ae59:	89 15 04 01 00 00    	mov    %edx,0x104
    ae5f:	76 0f                	jbe    ae70 <Sack_validate+0x90>
    ae61:	b8 88 13 00 00       	mov    $0x1388,%eax
    ae66:	ba 88 13 00 00       	mov    $0x1388,%edx
    ae6b:	a3 04 01 00 00       	mov    %eax,0x104
    ae70:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    ae76:	76 79                	jbe    aef1 <Sack_validate+0x111>
    ae78:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    ae7e:	a1 94 b4 0e 00       	mov    0xeb494,%eax
    ae83:	89 15 04 01 00 00    	mov    %edx,0x104
    ae89:	c7 05 94 b4 0e 00 00 	movl   $0x0,0xeb494
    ae90:	00 00 00 
    ae93:	51                   	push   %ecx
    ae94:	9d                   	popf   
    ae95:	85 c0                	test   %eax,%eax
    ae97:	75 36                	jne    aecf <Sack_validate+0xef>
    ae99:	b8 01 00 00 00       	mov    $0x1,%eax
    ae9e:	85 c0                	test   %eax,%eax
    aea0:	0f 84 50 ff ff ff    	je     adf6 <Sack_validate+0x16>
    aea6:	8b 43 08             	mov    0x8(%ebx),%eax
    aea9:	89 74 24 0c          	mov    %esi,0xc(%esp,1)
    aead:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    aeb1:	8b 43 04             	mov    0x4(%ebx),%eax
    aeb4:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    aeb8:	8b 03                	mov    (%ebx),%eax
    aeba:	c7 04 24 c0 2f 00 00 	movl   $0x2fc0,(%esp,1)
    aec1:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    aec5:	e8 fc ff ff ff       	call   aec6 <Sack_validate+0xe6>
    aeca:	e9 27 ff ff ff       	jmp    adf6 <Sack_validate+0x16>
    aecf:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    aed3:	c7 44 24 08 26 01 00 	movl   $0x126,0x8(%esp,1)
    aeda:	00 
    aedb:	c7 44 24 04 04 06 00 	movl   $0x604,0x4(%esp,1)
    aee2:	00 
    aee3:	c7 04 24 00 30 00 00 	movl   $0x3000,(%esp,1)
    aeea:	e8 fc ff ff ff       	call   aeeb <Sack_validate+0x10b>
    aeef:	eb a8                	jmp    ae99 <Sack_validate+0xb9>
    aef1:	ff 05 94 b4 0e 00    	incl   0xeb494
    aef7:	51                   	push   %ecx
    aef8:	9d                   	popf   
    aef9:	31 c0                	xor    %eax,%eax
    aefb:	eb a1                	jmp    ae9e <Sack_validate+0xbe>
    aefd:	b8 01 00 00 00       	mov    $0x1,%eax
    af02:	e9 f1 fe ff ff       	jmp    adf8 <Sack_validate+0x18>
    af07:	89 f6                	mov    %esi,%esi
    af09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

0000af10 <AckProof_isPoisoned>:

inline int Sack_contains(Sack *sack, int seq) {
  return sack->left <= seq && seq <= sack->right;
}

inline int Sack_gapLen(Sack *left, Sack *right) {
  return right->left - left->right - 1;
}

inline int Sack_adjacent(Sack *left, Sack *right) {
  return Sack_gapLen(left, right) == 0;
}

int AckProof_isPoisoned(AckProof *proof, Sack *sack) {
    af10:	55                   	push   %ebp
    af11:	89 e5                	mov    %esp,%ebp
  /* For now, always return 0 */
  return 0;
}
    af13:	31 c0                	xor    %eax,%eax
    af15:	5d                   	pop    %ebp
    af16:	c3                   	ret    
    af17:	89 f6                	mov    %esi,%esi
    af19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

0000af20 <AckProof_validate>:

int AckProof_validate(AckProof *proof) {
    af20:	55                   	push   %ebp
    af21:	89 e5                	mov    %esp,%ebp
    af23:	83 ec 24             	sub    $0x24,%esp
    af26:	89 5d f4             	mov    %ebx,0xfffffff4(%ebp)
    af29:	8b 55 08             	mov    0x8(%ebp),%edx
    af2c:	89 75 f8             	mov    %esi,0xfffffff8(%ebp)
    af2f:	89 7d fc             	mov    %edi,0xfffffffc(%ebp)
  int i;
  CONTINUATION_TYPE *cont = proof->cont;
  Sack *sacks = proof->sacks;
  int numSacks = proof->numSacks;
    af32:	8b 32                	mov    (%edx),%esi
    af34:	8d 4a 08             	lea    0x8(%edx),%ecx
    af37:	8b 7a 04             	mov    0x4(%edx),%edi
  // 0714 MAXSACKS is appropriate here (e.g., NOT MAX_KERNEL_SACKS) because 
  // this numSacks comes from the wire
  if(numSacks == 0 || numSacks > MAXSACKS || 
    af3a:	85 f6                	test   %esi,%esi
    af3c:	74 12                	je     af50 <AckProof_validate+0x30>
    af3e:	83 fe 40             	cmp    $0x40,%esi
    af41:	7f 0d                	jg     af50 <AckProof_validate+0x30>
    af43:	8b 47 70             	mov    0x70(%edi),%eax
    af46:	39 42 08             	cmp    %eax,0x8(%edx)
    af49:	76 4b                	jbe    af96 <AckProof_validate+0x76>
    af4b:	90                   	nop    
    af4c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
     sacks[0].left > cont->TCPBase) {
	  if(!disableSevereErrors)
    af50:	8b 15 00 00 00 00    	mov    0x0,%edx
    af56:	85 d2                	test   %edx,%edx
    af58:	74 16                	je     af70 <AckProof_validate+0x50>
		  printk("Zero sacks (%d), too many sacks, or start (%u) > TCPBase (%u) [seq = %u]\n", numSacks, sacks[0].left, cont->TCPBase, cont->seq);
    return 0;
  }
  for(i=0; i < numSacks; i++) {
    if(!Sack_validate(cont, &sacks[i])) {
      return 0;
    }
    if(i > 0 && sacks[i].left <= sacks[i-1].right) {
      return 0;
    af5a:	31 d2                	xor    %edx,%edx
    }
  }
  return 1;
}
    af5c:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
    af5f:	89 d0                	mov    %edx,%eax
    af61:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
    af64:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
    af67:	89 ec                	mov    %ebp,%esp
    af69:	5d                   	pop    %ebp
    af6a:	c3                   	ret    
    af6b:	90                   	nop    
    af6c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    af70:	8b 47 34             	mov    0x34(%edi),%eax
    af73:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    af77:	8b 47 70             	mov    0x70(%edi),%eax
    af7a:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    af7e:	8b 01                	mov    (%ecx),%eax
    af80:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    af84:	c7 04 24 40 30 00 00 	movl   $0x3040,(%esp,1)
    af8b:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    af8f:	e8 fc ff ff ff       	call   af90 <AckProof_validate+0x70>
    af94:	eb c4                	jmp    af5a <AckProof_validate+0x3a>
    af96:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
    af9d:	39 75 f0             	cmp    %esi,0xfffffff0(%ebp)
    afa0:	7d 39                	jge    afdb <AckProof_validate+0xbb>
    afa2:	89 cb                	mov    %ecx,%ebx
    afa4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    afaa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
    afb0:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    afb4:	89 3c 24             	mov    %edi,(%esp,1)
    afb7:	e8 fc ff ff ff       	call   afb8 <AckProof_validate+0x98>
    afbc:	31 d2                	xor    %edx,%edx
    afbe:	85 c0                	test   %eax,%eax
    afc0:	74 9a                	je     af5c <AckProof_validate+0x3c>
    afc2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    afc5:	85 c0                	test   %eax,%eax
    afc7:	7e 07                	jle    afd0 <AckProof_validate+0xb0>
    afc9:	8b 43 f8             	mov    0xfffffff8(%ebx),%eax
    afcc:	39 03                	cmp    %eax,(%ebx)
    afce:	76 8a                	jbe    af5a <AckProof_validate+0x3a>
    afd0:	ff 45 f0             	incl   0xfffffff0(%ebp)
    afd3:	83 c3 0c             	add    $0xc,%ebx
    afd6:	39 75 f0             	cmp    %esi,0xfffffff0(%ebp)
    afd9:	7c d5                	jl     afb0 <AckProof_validate+0x90>
    afdb:	ba 01 00 00 00       	mov    $0x1,%edx
    afe0:	e9 77 ff ff ff       	jmp    af5c <AckProof_validate+0x3c>
    afe5:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    afe9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

0000aff0 <AckProof_firstLoss>:

/* Note: FirstLoss considers poisoned nonces as present */
int AckProof_firstLoss(AckProof *proof) {
    aff0:	55                   	push   %ebp
    aff1:	89 e5                	mov    %esp,%ebp
    aff3:	56                   	push   %esi
    aff4:	53                   	push   %ebx
  int i, numSacks = proof->numSacks;
  Sack *sacks = proof->sacks;
  for(i=1; i < numSacks; i++) {
    aff5:	bb 01 00 00 00       	mov    $0x1,%ebx
    affa:	83 ec 04             	sub    $0x4,%esp
    affd:	8b 45 08             	mov    0x8(%ebp),%eax
    b000:	8b 30                	mov    (%eax),%esi
    b002:	39 f3                	cmp    %esi,%ebx
    b004:	7d 1f                	jge    b025 <AckProof_firstLoss+0x35>
    b006:	8d 50 14             	lea    0x14(%eax),%edx
    b009:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    b010:	8b 4a f8             	mov    0xfffffff8(%edx),%ecx
    b013:	89 c8                	mov    %ecx,%eax
    b015:	f7 d0                	not    %eax
    b017:	03 02                	add    (%edx),%eax
    b019:	85 c0                	test   %eax,%eax
    b01b:	75 1e                	jne    b03b <AckProof_firstLoss+0x4b>
    b01d:	43                   	inc    %ebx
    b01e:	83 c2 0c             	add    $0xc,%edx
    b021:	39 f3                	cmp    %esi,%ebx
    b023:	7c eb                	jl     b010 <AckProof_firstLoss+0x20>
    if(!Sack_adjacent(&sacks[i-1], &sacks[i])) {
      return sacks[i-1].right + 1;
    }
  }
  ERROR("No loss!\n");
    b025:	c7 04 24 16 06 00 00 	movl   $0x616,(%esp,1)
    b02c:	e8 fc ff ff ff       	call   b02d <AckProof_firstLoss+0x3d>
  return -1;
    b031:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    b036:	59                   	pop    %ecx
    b037:	5b                   	pop    %ebx
    b038:	5e                   	pop    %esi
    b039:	5d                   	pop    %ebp
    b03a:	c3                   	ret    
    b03b:	8d 41 01             	lea    0x1(%ecx),%eax
    b03e:	eb f6                	jmp    b036 <AckProof_firstLoss+0x46>

0000b040 <AckProof_checkRange>:

enum CheckRangeResult AckProof_checkRange(AckProof *proof, int left, int right) {
    b040:	55                   	push   %ebp
    b041:	89 e5                	mov    %esp,%ebp
    b043:	57                   	push   %edi
  int i;
  int cursor;
  int poisoned = 0;
  Sack *sacks = proof->sacks;
  /* Check if AckProof covers the desired range */
  cursor = left;
  for(i=0; i < proof->numSacks; i++) {
    b044:	31 ff                	xor    %edi,%edi
    b046:	56                   	push   %esi
    b047:	53                   	push   %ebx
    b048:	83 ec 14             	sub    $0x14,%esp
    b04b:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
    b052:	8b 45 08             	mov    0x8(%ebp),%eax
    b055:	8b 5d 08             	mov    0x8(%ebp),%ebx
    b058:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    b05b:	83 c0 08             	add    $0x8,%eax
    b05e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    b061:	8b 1b                	mov    (%ebx),%ebx
    b063:	39 df                	cmp    %ebx,%edi
    b065:	89 5d e8             	mov    %ebx,0xffffffe8(%ebp)
    b068:	7d 29                	jge    b093 <AckProof_checkRange+0x53>
    b06a:	31 f6                	xor    %esi,%esi
    b06c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    b070:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    b073:	31 d2                	xor    %edx,%edx
    b075:	01 f0                	add    %esi,%eax
    b077:	39 08                	cmp    %ecx,(%eax)
    b079:	77 0b                	ja     b086 <AckProof_checkRange+0x46>
    b07b:	3b 48 04             	cmp    0x4(%eax),%ecx
    b07e:	bb 01 00 00 00       	mov    $0x1,%ebx
    b083:	0f 46 d3             	cmovbe %ebx,%edx
    b086:	85 d2                	test   %edx,%edx
    b088:	75 26                	jne    b0b0 <AckProof_checkRange+0x70>
    b08a:	47                   	inc    %edi
    b08b:	83 c6 0c             	add    $0xc,%esi
    b08e:	3b 7d e8             	cmp    0xffffffe8(%ebp),%edi
    b091:	7c dd                	jl     b070 <AckProof_checkRange+0x30>
    if(Sack_contains(&sacks[i], cursor)) {
      if(AckProof_isPoisoned(proof, &sacks[i])) {
	poisoned = 1;
      }
      cursor = sacks[i].right + 1;
      if(cursor > right) break;
    }
  }
  if(i == proof->numSacks) {
    b093:	31 c0                	xor    %eax,%eax
    b095:	3b 7d e8             	cmp    0xffffffe8(%ebp),%edi
    b098:	74 0d                	je     b0a7 <AckProof_checkRange+0x67>
    return BADRANGE;
  }
  return poisoned ? POISONEDRANGE : NORMALRANGE;
    b09a:	31 c0                	xor    %eax,%eax
    b09c:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
    b0a0:	0f 94 c0             	sete   %al
    b0a3:	8d 44 00 ff          	lea    0xffffffff(%eax,%eax,1),%eax
}
    b0a7:	83 c4 14             	add    $0x14,%esp
    b0aa:	5b                   	pop    %ebx
    b0ab:	5e                   	pop    %esi
    b0ac:	5f                   	pop    %edi
    b0ad:	5d                   	pop    %ebp
    b0ae:	c3                   	ret    
    b0af:	90                   	nop    
    b0b0:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b0b4:	8b 45 08             	mov    0x8(%ebp),%eax
    b0b7:	bb 01 00 00 00       	mov    $0x1,%ebx
    b0bc:	89 04 24             	mov    %eax,(%esp,1)
    b0bf:	e8 fc ff ff ff       	call   b0c0 <AckProof_checkRange+0x80>
    b0c4:	85 c0                	test   %eax,%eax
    b0c6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    b0c9:	0f 44 5d f0          	cmove  0xfffffff0(%ebp),%ebx
    b0cd:	89 5d f0             	mov    %ebx,0xfffffff0(%ebp)
    b0d0:	8b 4c 30 04          	mov    0x4(%eax,%esi,1),%ecx
    b0d4:	41                   	inc    %ecx
    b0d5:	3b 4d 10             	cmp    0x10(%ebp),%ecx
    b0d8:	7f 0a                	jg     b0e4 <AckProof_checkRange+0xa4>
    b0da:	8b 5d 08             	mov    0x8(%ebp),%ebx
    b0dd:	8b 1b                	mov    (%ebx),%ebx
    b0df:	89 5d e8             	mov    %ebx,0xffffffe8(%ebp)
    b0e2:	eb a6                	jmp    b08a <AckProof_checkRange+0x4a>
    b0e4:	8b 45 08             	mov    0x8(%ebp),%eax
    b0e7:	8b 00                	mov    (%eax),%eax
    b0e9:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    b0ec:	eb a5                	jmp    b093 <AckProof_checkRange+0x53>
    b0ee:	89 f6                	mov    %esi,%esi

0000b0f0 <AckProof_findRight>:

__u32 AckProof_findRight(AckProof *proof, int start) {
    b0f0:	55                   	push   %ebp
    b0f1:	89 e5                	mov    %esp,%ebp
    b0f3:	57                   	push   %edi
    b0f4:	56                   	push   %esi
    b0f5:	53                   	push   %ebx
    b0f6:	83 ec 10             	sub    $0x10,%esp
  int i;
  int cursor;
  int poisoned = 0;
  Sack *sacks = proof->sacks;
  /* Check if AckProof covers the desired range */
  cursor = start;
  for(i=0; i < proof->numSacks; i++) {
    b0f9:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
    b100:	8b 45 08             	mov    0x8(%ebp),%eax
    b103:	8b 7d 08             	mov    0x8(%ebp),%edi
    b106:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    b109:	8b 00                	mov    (%eax),%eax
    b10b:	83 c7 08             	add    $0x8,%edi
    b10e:	39 45 f0             	cmp    %eax,0xfffffff0(%ebp)
    b111:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    b114:	7d 31                	jge    b147 <AckProof_findRight+0x57>
    b116:	31 db                	xor    %ebx,%ebx
    b118:	90                   	nop    
    b119:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    b120:	8d 14 3b             	lea    (%ebx,%edi,1),%edx
    b123:	31 c0                	xor    %eax,%eax
    b125:	39 0a                	cmp    %ecx,(%edx)
    b127:	77 0c                	ja     b135 <AckProof_findRight+0x45>
    b129:	3b 4c 1f 04          	cmp    0x4(%edi,%ebx,1),%ecx
    b12d:	be 01 00 00 00       	mov    $0x1,%esi
    b132:	0f 46 c6             	cmovbe %esi,%eax
    b135:	85 c0                	test   %eax,%eax
    b137:	75 27                	jne    b160 <AckProof_findRight+0x70>
    b139:	ff 45 f0             	incl   0xfffffff0(%ebp)
    b13c:	83 c3 0c             	add    $0xc,%ebx
    b13f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    b142:	39 45 f0             	cmp    %eax,0xfffffff0(%ebp)
    b145:	7c d9                	jl     b120 <AckProof_findRight+0x30>
    if(Sack_contains(&sacks[i], cursor)) {
      if(AckProof_isPoisoned(proof, &sacks[i])) {
	poisoned = 1;
      }
      cursor = sacks[i].right + 1;
    }
  }
  if(cursor > start) 
    b147:	8b 55 0c             	mov    0xc(%ebp),%edx
    b14a:	8d 41 ff             	lea    0xffffffff(%ecx),%eax
    b14d:	4a                   	dec    %edx
    b14e:	3b 4d 0c             	cmp    0xc(%ebp),%ecx
    b151:	0f 4e c2             	cmovle %edx,%eax
	  return cursor - 1;
  else
	  return start - 1; // error condition
}
    b154:	83 c4 10             	add    $0x10,%esp
    b157:	5b                   	pop    %ebx
    b158:	5e                   	pop    %esi
    b159:	5f                   	pop    %edi
    b15a:	5d                   	pop    %ebp
    b15b:	c3                   	ret    
    b15c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    b160:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    b164:	8b 45 08             	mov    0x8(%ebp),%eax
    b167:	89 04 24             	mov    %eax,(%esp,1)
    b16a:	e8 fc ff ff ff       	call   b16b <AckProof_findRight+0x7b>
    b16f:	8b 75 08             	mov    0x8(%ebp),%esi
    b172:	8b 4c 1f 04          	mov    0x4(%edi,%ebx,1),%ecx
    b176:	8b 36                	mov    (%esi),%esi
    b178:	41                   	inc    %ecx
    b179:	89 75 ec             	mov    %esi,0xffffffec(%ebp)
    b17c:	eb bb                	jmp    b139 <AckProof_findRight+0x49>
    b17e:	89 f6                	mov    %esi,%esi

0000b180 <AckProof_findLeft>:

__u32 AckProof_findLeft(AckProof *proof, int start) {
    b180:	55                   	push   %ebp
    b181:	89 e5                	mov    %esp,%ebp
    b183:	57                   	push   %edi
    b184:	56                   	push   %esi
    b185:	53                   	push   %ebx
    b186:	83 ec 08             	sub    $0x8,%esp
    b189:	8b 7d 08             	mov    0x8(%ebp),%edi
  int i;
  int cursor;
  int poisoned = 0;
  Sack *sacks = proof->sacks;
  /* Check if AckProof covers the desired range */
  cursor = start;
    b18c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  for(i=proof->numSacks - 1; i >= 0; i--) {
    b18f:	8b 37                	mov    (%edi),%esi
    b191:	8d 57 08             	lea    0x8(%edi),%edx
    b194:	4e                   	dec    %esi
    b195:	78 24                	js     b1bb <AckProof_findLeft+0x3b>
    b197:	8d 04 76             	lea    (%esi,%esi,2),%eax
    b19a:	8d 1c 82             	lea    (%edx,%eax,4),%ebx
    b19d:	8d 76 00             	lea    0x0(%esi),%esi
    b1a0:	31 c0                	xor    %eax,%eax
    b1a2:	39 0b                	cmp    %ecx,(%ebx)
    b1a4:	77 0b                	ja     b1b1 <AckProof_findLeft+0x31>
    b1a6:	3b 4b 04             	cmp    0x4(%ebx),%ecx
    b1a9:	ba 01 00 00 00       	mov    $0x1,%edx
    b1ae:	0f 46 c2             	cmovbe %edx,%eax
    b1b1:	85 c0                	test   %eax,%eax
    b1b3:	75 1b                	jne    b1d0 <AckProof_findLeft+0x50>
    b1b5:	83 eb 0c             	sub    $0xc,%ebx
    b1b8:	4e                   	dec    %esi
    b1b9:	79 e5                	jns    b1a0 <AckProof_findLeft+0x20>
    if(Sack_contains(&sacks[i], cursor)) {
      if(AckProof_isPoisoned(proof, &sacks[i])) {
	poisoned = 1;
      }
      cursor = sacks[i].left - 1;
    }
  }
  if(cursor < start) 
    b1bb:	8b 55 0c             	mov    0xc(%ebp),%edx
    b1be:	8d 41 01             	lea    0x1(%ecx),%eax
    b1c1:	42                   	inc    %edx
    b1c2:	3b 4d 0c             	cmp    0xc(%ebp),%ecx
    b1c5:	0f 4d c2             	cmovge %edx,%eax
	  return cursor + 1;
  else
	  return start + 1; // error condition
}
    b1c8:	83 c4 08             	add    $0x8,%esp
    b1cb:	5b                   	pop    %ebx
    b1cc:	5e                   	pop    %esi
    b1cd:	5f                   	pop    %edi
    b1ce:	5d                   	pop    %ebp
    b1cf:	c3                   	ret    
    b1d0:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    b1d4:	89 3c 24             	mov    %edi,(%esp,1)
    b1d7:	e8 fc ff ff ff       	call   b1d8 <AckProof_findLeft+0x58>
    b1dc:	8b 0b                	mov    (%ebx),%ecx
    b1de:	49                   	dec    %ecx
    b1df:	eb d4                	jmp    b1b5 <AckProof_findLeft+0x35>
    b1e1:	eb 0d                	jmp    b1f0 <AckProof_dump>
    b1e3:	90                   	nop    
    b1e4:	90                   	nop    
    b1e5:	90                   	nop    
    b1e6:	90                   	nop    
    b1e7:	90                   	nop    
    b1e8:	90                   	nop    
    b1e9:	90                   	nop    
    b1ea:	90                   	nop    
    b1eb:	90                   	nop    
    b1ec:	90                   	nop    
    b1ed:	90                   	nop    
    b1ee:	90                   	nop    
    b1ef:	90                   	nop    

0000b1f0 <AckProof_dump>:

static int DoNormalStep(CONTINUATION_TYPE **cont, AckProof *ackProof, enum cminisock_event_tag event);
static int DoRecoveryStep(CONTINUATION_TYPE **cont, AckProof *ackProof, enum cminisock_event_tag event);
static int DoSlowStartStep(CONTINUATION_TYPE **cont, AckProof *ackProof, __u32 newBase, enum cminisock_event_tag event);

void AckProof_dump(AckProof *proof) {
    b1f0:	55                   	push   %ebp
    b1f1:	89 e5                	mov    %esp,%ebp
    b1f3:	57                   	push   %edi
    b1f4:	56                   	push   %esi
	int i;
	printk("proof(%d) = ", proof->numSacks);
	for(i = 0; i < proof->numSacks; i++) {
    b1f5:	31 f6                	xor    %esi,%esi
    b1f7:	53                   	push   %ebx
    b1f8:	83 ec 0c             	sub    $0xc,%esp
    b1fb:	8b 7d 08             	mov    0x8(%ebp),%edi
    b1fe:	8b 07                	mov    (%edi),%eax
    b200:	c7 04 24 20 06 00 00 	movl   $0x620,(%esp,1)
    b207:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b20b:	e8 fc ff ff ff       	call   b20c <AckProof_dump+0x1c>
    b210:	3b 37                	cmp    (%edi),%esi
    b212:	7d 2e                	jge    b242 <AckProof_dump+0x52>
    b214:	89 fb                	mov    %edi,%ebx
    b216:	8d 76 00             	lea    0x0(%esi),%esi
    b219:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
		printk("[%d-%d]", proof->sacks[i].left, proof->sacks[i].right);
    b220:	8b 43 0c             	mov    0xc(%ebx),%eax
    b223:	46                   	inc    %esi
    b224:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    b228:	8b 43 08             	mov    0x8(%ebx),%eax
    b22b:	c7 04 24 2d 06 00 00 	movl   $0x62d,(%esp,1)
    b232:	83 c3 0c             	add    $0xc,%ebx
    b235:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b239:	e8 fc ff ff ff       	call   b23a <AckProof_dump+0x4a>
    b23e:	3b 37                	cmp    (%edi),%esi
    b240:	7c de                	jl     b220 <AckProof_dump+0x30>
	}
	printk("\n");
    b242:	c7 45 08 35 06 00 00 	movl   $0x635,0x8(%ebp)
    b249:	83 c4 0c             	add    $0xc,%esp
    b24c:	5b                   	pop    %ebx
    b24d:	5e                   	pop    %esi
    b24e:	5f                   	pop    %edi
    b24f:	5d                   	pop    %ebp
    b250:	e9 fc ff ff ff       	jmp    b251 <AckProof_dump+0x61>
    b255:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    b259:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

0000b260 <WireTrickleRequest_extract>:
}

WireTrickleRequest *WireTrickleRequest_extract(struct cminisock *msk, struct sk_buff *skb, int *error) {
    b260:	55                   	push   %ebp
    b261:	89 e5                	mov    %esp,%ebp
	return __pskb_pull(skb,len);
}

static inline int pskb_may_pull(struct sk_buff *skb, unsigned int len)
{
    b263:	b9 4e 00 00 00       	mov    $0x4e,%ecx
    b268:	57                   	push   %edi
    b269:	56                   	push   %esi
    b26a:	53                   	push   %ebx
    b26b:	83 ec 14             	sub    $0x14,%esp
    b26e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int sacks_len;
	WireTrickleRequest *req = (WireTrickleRequest*)skb->data;
	*error = EINVAL;
    b271:	8b 55 10             	mov    0x10(%ebp),%edx
    b274:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
    b27a:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    b27d:	c7 02 16 00 00 00    	movl   $0x16,(%edx)
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
	return skb->len - skb->data_len;
    b283:	8b 53 70             	mov    0x70(%ebx),%edx
    b286:	8b 43 74             	mov    0x74(%ebx),%eax
    b289:	89 d6                	mov    %edx,%esi
    b28b:	29 c6                	sub    %eax,%esi
    b28d:	b8 01 00 00 00       	mov    $0x1,%eax
    b292:	39 f1                	cmp    %esi,%ecx
    b294:	76 0a                	jbe    b2a0 <WireTrickleRequest_extract+0x40>
}

#define SKB_PAGE_ASSERT(skb) do { if (skb_shinfo(skb)->nr_frags) out_of_line_bug(); } while (0)
#define SKB_FRAG_ASSERT(skb) do { if (skb_shinfo(skb)->frag_list) out_of_line_bug(); } while (0)
#define SKB_LINEAR_ASSERT(skb) do { if (skb_is_nonlinear(skb)) out_of_line_bug(); } while (0)

/*
 *	Add data to an sk_buff
 */
 
static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	return tmp;
}

/**
 *	skb_put - add data to a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer. If this would
 *	exceed the total buffer size the kernel will panic. A pointer to the
 *	first byte of the extra data is returned.
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	if(skb->tail>skb->end) {
		skb_over_panic(skb, len, current_text_addr());
	}
	return tmp;
}

static inline unsigned char *__skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
	skb->len+=len;
	return skb->data;
}

/**
 *	skb_push - add data to the start of a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer at the buffer
 *	start. If this would exceed the total buffer headroom the kernel will
 *	panic. A pointer to the first byte of the extra data is returned.
 */

static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
	skb->len+=len;
	if(skb->data<skb->head) {
		skb_under_panic(skb, len, current_text_addr());
	}
	return skb->data;
}

static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
	skb->len-=len;
	if (skb->len < skb->data_len)
		out_of_line_bug();
	return 	skb->data+=len;
}

/**
 *	skb_pull - remove data from the start of a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to remove
 *
 *	This function removes data from the start of a buffer, returning
 *	the memory to the headroom. A pointer to the next data in the buffer
 *	is returned. Once the data has been pulled future pushes will overwrite
 *	the old data.
 */

static inline unsigned char * skb_pull(struct sk_buff *skb, unsigned int len)
{	
	if (len > skb->len)
		return NULL;
	return __skb_pull(skb,len);
}

extern unsigned char * __pskb_pull_tail(struct sk_buff *skb, int delta);

static inline char *__pskb_pull(struct sk_buff *skb, unsigned int len)
{
	if (len > skb_headlen(skb) &&
	    __pskb_pull_tail(skb, len-skb_headlen(skb)) == NULL)
		return NULL;
	skb->len -= len;
	return 	skb->data += len;
}

static inline unsigned char * pskb_pull(struct sk_buff *skb, unsigned int len)
{	
	if (len > skb->len)
		return NULL;
	return __pskb_pull(skb,len);
}

static inline int pskb_may_pull(struct sk_buff *skb, unsigned int len)
{
	if (len <= skb_headlen(skb))
		return 1;
	if (len > skb->len)
    b296:	31 c0                	xor    %eax,%eax
    b298:	39 d1                	cmp    %edx,%ecx
    b29a:	0f 86 16 03 00 00    	jbe    b5b6 <WireTrickleRequest_extract+0x356>
    b2a0:	85 c0                	test   %eax,%eax
    b2a2:	0f 85 bb 00 00 00    	jne    b363 <WireTrickleRequest_extract+0x103>

	if(!pskb_may_pull(skb, sizeof(*req))) {
		if(trickles_ratelimit()) {
    b2a8:	a1 00 00 00 00       	mov    0x0,%eax
    b2ad:	9c                   	pushf  
    b2ae:	59                   	pop    %ecx
    b2af:	fa                   	cli    
    b2b0:	89 c2                	mov    %eax,%edx
    b2b2:	8b 3d 98 b4 0e 00    	mov    0xeb498,%edi
    b2b8:	8b 35 08 01 00 00    	mov    0x108,%esi
    b2be:	a3 98 b4 0e 00       	mov    %eax,0xeb498
    b2c3:	29 fa                	sub    %edi,%edx
    b2c5:	01 f2                	add    %esi,%edx
    b2c7:	89 15 08 01 00 00    	mov    %edx,0x108
    b2cd:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    b2d3:	76 10                	jbe    b2e5 <WireTrickleRequest_extract+0x85>
    b2d5:	bf 88 13 00 00       	mov    $0x1388,%edi
    b2da:	ba 88 13 00 00       	mov    $0x1388,%edx
    b2df:	89 3d 08 01 00 00    	mov    %edi,0x108
    b2e5:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    b2eb:	76 6a                	jbe    b357 <WireTrickleRequest_extract+0xf7>
    b2ed:	31 f6                	xor    %esi,%esi
    b2ef:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    b2f5:	a1 9c b4 0e 00       	mov    0xeb49c,%eax
    b2fa:	89 15 08 01 00 00    	mov    %edx,0x108
    b300:	89 35 9c b4 0e 00    	mov    %esi,0xeb49c
    b306:	51                   	push   %ecx
    b307:	9d                   	popf   
    b308:	85 c0                	test   %eax,%eax
    b30a:	75 29                	jne    b335 <WireTrickleRequest_extract+0xd5>
    b30c:	b8 01 00 00 00       	mov    $0x1,%eax
    b311:	85 c0                	test   %eax,%eax
    b313:	75 0b                	jne    b320 <WireTrickleRequest_extract+0xc0>
			printk("SKB too short for WireTrickleRequest, len = %d\n", skb->len);
		}
		return NULL;
	}
	__skb_pull(skb, sizeof(*req));
	/* Handle variable length fields */
	sacks_len = req->ackProof.numSacks * sizeof(WireSack);

	// 0714 MAXSACKS is appropriate here (e.g., NOT MAX_KERNEL_SACKS) because 
	// value comes from wire
	if(!(req->ackProof.numSacks <= MAXSACKS &&
	     pskb_may_pull(skb, sacks_len))) {
		printk("SKB too short for WireTrickleRequest (either too many sacks, or not enough space in packet header for sacks\n");
		return NULL;
	}
	__skb_pull(skb, sacks_len);

	msk->ucont_len = ntohs(req->ucont_len);
	if(!pskb_may_pull(skb, msk->ucont_len)) {
		printk("WireTrickleRequest_extract: skb too short for ucont\n");
		return NULL;
	}
	if(!SIMULATION_MODE(msk->sk)) {
		if(msk->ucont_len > 0) {
			msk->ucont_data = tmalloc(skb->sk, msk->ucont_len);
			if(msk->ucont_data == NULL) {
#if 0
				if(trickles_ratelimit()) {
					printk("WireTrickleRequest_extract: Out of memory while copying ucont\n");
				}
#endif
				*error = ENOMEM;
				return NULL;
			}
			memcpy(msk->ucont_data, (char*)skb->data, msk->ucont_len);
			__skb_pull(skb, msk->ucont_len);
		} else {
			msk->ucont_data = NULL;
		}
	} else {
		msk->ucont_len = 0;
		msk->ucont_data = NULL;
	}

	BUG_TRAP(skb->len >= 0);
	if(!SIMULATION_MODE(msk->sk)) {
		msk->input_len = skb->len;
		if(msk->input_len > 0) {
			msk->input = tmalloc(skb->sk, msk->input_len);
			if(msk->input == NULL) {
#if 0
				if(trickles_ratelimit()) {
					printk("WireTrickleRequest_extract: Out of memory while copying Conversion data\n");
				}
#endif
				*error = ENOMEM;
				return NULL;
    b315:	31 c0                	xor    %eax,%eax
			}
			memcpy(msk->input, (char*)skb->data, msk->input_len);
		} else {
			msk->input = NULL;
		}
	} else {
		msk->input_len = 0;
		msk->input = NULL;
	}
	*error = 0;
	return req;
}
    b317:	83 c4 14             	add    $0x14,%esp
    b31a:	5b                   	pop    %ebx
    b31b:	5e                   	pop    %esi
    b31c:	5f                   	pop    %edi
    b31d:	5d                   	pop    %ebp
    b31e:	c3                   	ret    
    b31f:	90                   	nop    
    b320:	8b 43 70             	mov    0x70(%ebx),%eax
    b323:	c7 04 24 a0 30 00 00 	movl   $0x30a0,(%esp,1)
    b32a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b32e:	e8 fc ff ff ff       	call   b32f <WireTrickleRequest_extract+0xcf>
    b333:	eb e0                	jmp    b315 <WireTrickleRequest_extract+0xb5>
    b335:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    b339:	c7 44 24 08 bf 01 00 	movl   $0x1bf,0x8(%esp,1)
    b340:	00 
    b341:	c7 44 24 04 04 06 00 	movl   $0x604,0x4(%esp,1)
    b348:	00 
    b349:	c7 04 24 00 30 00 00 	movl   $0x3000,(%esp,1)
    b350:	e8 fc ff ff ff       	call   b351 <WireTrickleRequest_extract+0xf1>
    b355:	eb b5                	jmp    b30c <WireTrickleRequest_extract+0xac>
    b357:	ff 05 9c b4 0e 00    	incl   0xeb49c
    b35d:	51                   	push   %ecx
    b35e:	9d                   	popf   
    b35f:	31 c0                	xor    %eax,%eax
    b361:	eb ae                	jmp    b311 <WireTrickleRequest_extract+0xb1>
}

static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
	skb->len-=len;
    b363:	8b 4b 70             	mov    0x70(%ebx),%ecx
	if (skb->len < skb->data_len)
    b366:	8b 73 74             	mov    0x74(%ebx),%esi
    b369:	83 e9 4e             	sub    $0x4e,%ecx
    b36c:	89 4b 70             	mov    %ecx,0x70(%ebx)
    b36f:	39 f1                	cmp    %esi,%ecx
    b371:	0f 82 5c 02 00 00    	jb     b5d3 <WireTrickleRequest_extract+0x373>
		out_of_line_bug();
    b377:	83 83 94 00 00 00 4e 	addl   $0x4e,0x94(%ebx)
    b37e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b381:	0f b6 50 4d          	movzbl 0x4d(%eax),%edx
    b385:	0f b6 c2             	movzbl %dl,%eax
    b388:	8d 04 40             	lea    (%eax,%eax,2),%eax
    b38b:	80 fa 40             	cmp    $0x40,%dl
    b38e:	8d 3c 85 00 00 00 00 	lea    0x0(,%eax,4),%edi
    b395:	77 1b                	ja     b3b2 <WireTrickleRequest_extract+0x152>
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
	return skb->len - skb->data_len;
    b397:	89 ca                	mov    %ecx,%edx
    b399:	29 f2                	sub    %esi,%edx
    b39b:	39 d7                	cmp    %edx,%edi
    b39d:	b8 01 00 00 00       	mov    $0x1,%eax
    b3a2:	76 0a                	jbe    b3ae <WireTrickleRequest_extract+0x14e>
}

#define SKB_PAGE_ASSERT(skb) do { if (skb_shinfo(skb)->nr_frags) out_of_line_bug(); } while (0)
#define SKB_FRAG_ASSERT(skb) do { if (skb_shinfo(skb)->frag_list) out_of_line_bug(); } while (0)
#define SKB_LINEAR_ASSERT(skb) do { if (skb_is_nonlinear(skb)) out_of_line_bug(); } while (0)

/*
 *	Add data to an sk_buff
 */
 
static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	return tmp;
}

/**
 *	skb_put - add data to a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer. If this would
 *	exceed the total buffer size the kernel will panic. A pointer to the
 *	first byte of the extra data is returned.
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	if(skb->tail>skb->end) {
		skb_over_panic(skb, len, current_text_addr());
	}
	return tmp;
}

static inline unsigned char *__skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
	skb->len+=len;
	return skb->data;
}

/**
 *	skb_push - add data to the start of a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer at the buffer
 *	start. If this would exceed the total buffer headroom the kernel will
 *	panic. A pointer to the first byte of the extra data is returned.
 */

static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
	skb->len+=len;
	if(skb->data<skb->head) {
		skb_under_panic(skb, len, current_text_addr());
	}
	return skb->data;
}

static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
	skb->len-=len;
	if (skb->len < skb->data_len)
		out_of_line_bug();
	return 	skb->data+=len;
}

/**
 *	skb_pull - remove data from the start of a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to remove
 *
 *	This function removes data from the start of a buffer, returning
 *	the memory to the headroom. A pointer to the next data in the buffer
 *	is returned. Once the data has been pulled future pushes will overwrite
 *	the old data.
 */

static inline unsigned char * skb_pull(struct sk_buff *skb, unsigned int len)
{	
	if (len > skb->len)
		return NULL;
	return __skb_pull(skb,len);
}

extern unsigned char * __pskb_pull_tail(struct sk_buff *skb, int delta);

static inline char *__pskb_pull(struct sk_buff *skb, unsigned int len)
{
	if (len > skb_headlen(skb) &&
	    __pskb_pull_tail(skb, len-skb_headlen(skb)) == NULL)
		return NULL;
	skb->len -= len;
	return 	skb->data += len;
}

static inline unsigned char * pskb_pull(struct sk_buff *skb, unsigned int len)
{	
	if (len > skb->len)
		return NULL;
	return __pskb_pull(skb,len);
}

static inline int pskb_may_pull(struct sk_buff *skb, unsigned int len)
{
	if (len <= skb_headlen(skb))
		return 1;
	if (len > skb->len)
    b3a4:	31 c0                	xor    %eax,%eax
    b3a6:	39 cf                	cmp    %ecx,%edi
    b3a8:	0f 86 eb 01 00 00    	jbe    b599 <WireTrickleRequest_extract+0x339>
    b3ae:	85 c0                	test   %eax,%eax
    b3b0:	75 11                	jne    b3c3 <WireTrickleRequest_extract+0x163>
    b3b2:	c7 04 24 e0 30 00 00 	movl   $0x30e0,(%esp,1)
    b3b9:	e8 fc ff ff ff       	call   b3ba <WireTrickleRequest_extract+0x15a>
    b3be:	e9 52 ff ff ff       	jmp    b315 <WireTrickleRequest_extract+0xb5>
}

static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
	skb->len-=len;
    b3c3:	8b 43 70             	mov    0x70(%ebx),%eax
    b3c6:	29 f8                	sub    %edi,%eax
	if (skb->len < skb->data_len)
    b3c8:	3b 43 74             	cmp    0x74(%ebx),%eax
    b3cb:	89 43 70             	mov    %eax,0x70(%ebx)
    b3ce:	0f 82 ff 01 00 00    	jb     b5d3 <WireTrickleRequest_extract+0x373>
		out_of_line_bug();
    b3d4:	01 bb 94 00 00 00    	add    %edi,0x94(%ebx)
    b3da:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
    b3dd:	8b 4d 08             	mov    0x8(%ebp),%ecx
    b3e0:	0f b7 42 4b          	movzwl 0x4b(%edx),%eax
/* gcc should generate this for open coded C now too. May be worth switching to 
   it because inline assembly cannot be scheduled. -AK */
static __inline__ __const__ __u16 ___arch__swab16(__u16 x)
{
	__asm__("xchgb %b0,%h0"		/* swap bytes		*/
    b3e4:	86 c4                	xchg   %al,%ah
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
    b3e6:	0f b7 c0             	movzwl %ax,%eax
    b3e9:	89 41 7c             	mov    %eax,0x7c(%ecx)
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
	return skb->len - skb->data_len;
    b3ec:	8b 53 70             	mov    0x70(%ebx),%edx
    b3ef:	8b 4b 74             	mov    0x74(%ebx),%ecx
    b3f2:	89 d6                	mov    %edx,%esi
    b3f4:	29 ce                	sub    %ecx,%esi
    b3f6:	b9 01 00 00 00       	mov    $0x1,%ecx
    b3fb:	39 f0                	cmp    %esi,%eax
    b3fd:	76 0a                	jbe    b409 <WireTrickleRequest_extract+0x1a9>
}

#define SKB_PAGE_ASSERT(skb) do { if (skb_shinfo(skb)->nr_frags) out_of_line_bug(); } while (0)
#define SKB_FRAG_ASSERT(skb) do { if (skb_shinfo(skb)->frag_list) out_of_line_bug(); } while (0)
#define SKB_LINEAR_ASSERT(skb) do { if (skb_is_nonlinear(skb)) out_of_line_bug(); } while (0)

/*
 *	Add data to an sk_buff
 */
 
static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	return tmp;
}

/**
 *	skb_put - add data to a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer. If this would
 *	exceed the total buffer size the kernel will panic. A pointer to the
 *	first byte of the extra data is returned.
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	if(skb->tail>skb->end) {
		skb_over_panic(skb, len, current_text_addr());
	}
	return tmp;
}

static inline unsigned char *__skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
	skb->len+=len;
	return skb->data;
}

/**
 *	skb_push - add data to the start of a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer at the buffer
 *	start. If this would exceed the total buffer headroom the kernel will
 *	panic. A pointer to the first byte of the extra data is returned.
 */

static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
	skb->len+=len;
	if(skb->data<skb->head) {
		skb_under_panic(skb, len, current_text_addr());
	}
	return skb->data;
}

static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
	skb->len-=len;
	if (skb->len < skb->data_len)
		out_of_line_bug();
	return 	skb->data+=len;
}

/**
 *	skb_pull - remove data from the start of a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to remove
 *
 *	This function removes data from the start of a buffer, returning
 *	the memory to the headroom. A pointer to the next data in the buffer
 *	is returned. Once the data has been pulled future pushes will overwrite
 *	the old data.
 */

static inline unsigned char * skb_pull(struct sk_buff *skb, unsigned int len)
{	
	if (len > skb->len)
		return NULL;
	return __skb_pull(skb,len);
}

extern unsigned char * __pskb_pull_tail(struct sk_buff *skb, int delta);

static inline char *__pskb_pull(struct sk_buff *skb, unsigned int len)
{
	if (len > skb_headlen(skb) &&
	    __pskb_pull_tail(skb, len-skb_headlen(skb)) == NULL)
		return NULL;
	skb->len -= len;
	return 	skb->data += len;
}

static inline unsigned char * pskb_pull(struct sk_buff *skb, unsigned int len)
{	
	if (len > skb->len)
		return NULL;
	return __pskb_pull(skb,len);
}

static inline int pskb_may_pull(struct sk_buff *skb, unsigned int len)
{
	if (len <= skb_headlen(skb))
		return 1;
	if (len > skb->len)
    b3ff:	31 c9                	xor    %ecx,%ecx
    b401:	39 d0                	cmp    %edx,%eax
    b403:	0f 86 76 01 00 00    	jbe    b57f <WireTrickleRequest_extract+0x31f>
    b409:	85 c9                	test   %ecx,%ecx
    b40b:	0f 84 62 01 00 00    	je     b573 <WireTrickleRequest_extract+0x313>
    b411:	8b 45 08             	mov    0x8(%ebp),%eax
    b414:	8b 50 20             	mov    0x20(%eax),%edx
    b417:	8b 82 a8 02 00 00    	mov    0x2a8(%edx),%eax
    b41d:	a9 01 00 00 00       	test   $0x1,%eax
    b422:	74 09                	je     b42d <WireTrickleRequest_extract+0x1cd>
    b424:	83 e0 08             	and    $0x8,%eax
    b427:	0f 84 2f 01 00 00    	je     b55c <WireTrickleRequest_extract+0x2fc>
    b42d:	8b 4d 08             	mov    0x8(%ebp),%ecx
    b430:	8b 41 7c             	mov    0x7c(%ecx),%eax
    b433:	85 c0                	test   %eax,%eax
    b435:	0f 8e 11 01 00 00    	jle    b54c <WireTrickleRequest_extract+0x2ec>
    b43b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b43f:	8b 43 0c             	mov    0xc(%ebx),%eax
    b442:	89 04 24             	mov    %eax,(%esp,1)
    b445:	e8 fc ff ff ff       	call   b446 <WireTrickleRequest_extract+0x1e6>
    b44a:	89 c2                	mov    %eax,%edx
    b44c:	8b 45 08             	mov    0x8(%ebp),%eax
    b44f:	85 d2                	test   %edx,%edx
    b451:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
    b457:	75 0e                	jne    b467 <WireTrickleRequest_extract+0x207>
    b459:	8b 55 10             	mov    0x10(%ebp),%edx
    b45c:	c7 02 0c 00 00 00    	movl   $0xc,(%edx)
    b462:	e9 ae fe ff ff       	jmp    b315 <WireTrickleRequest_extract+0xb5>
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
    b467:	8b 4d 08             	mov    0x8(%ebp),%ecx
int d0, d1, d2;
__asm__ __volatile__(
    b46a:	89 d7                	mov    %edx,%edi
    b46c:	8b b3 94 00 00 00    	mov    0x94(%ebx),%esi
    b472:	8b 41 7c             	mov    0x7c(%ecx),%eax
    b475:	89 c1                	mov    %eax,%ecx
    b477:	c1 e9 02             	shr    $0x2,%ecx
    b47a:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    b47c:	a8 02                	test   $0x2,%al
    b47e:	74 02                	je     b482 <WireTrickleRequest_extract+0x222>
    b480:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    b482:	a8 01                	test   $0x1,%al
    b484:	74 01                	je     b487 <WireTrickleRequest_extract+0x227>
    b486:	a4                   	movsb  %ds:(%esi),%es:(%edi)
	return skb->data;
}

static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
    b487:	8b 45 08             	mov    0x8(%ebp),%eax
    b48a:	8b 50 7c             	mov    0x7c(%eax),%edx
	skb->len-=len;
    b48d:	8b 43 70             	mov    0x70(%ebx),%eax
    b490:	29 d0                	sub    %edx,%eax
	if (skb->len < skb->data_len)
    b492:	3b 43 74             	cmp    0x74(%ebx),%eax
    b495:	89 43 70             	mov    %eax,0x70(%ebx)
    b498:	0f 82 35 01 00 00    	jb     b5d3 <WireTrickleRequest_extract+0x373>
    b49e:	01 93 94 00 00 00    	add    %edx,0x94(%ebx)
    b4a4:	8b 4d 08             	mov    0x8(%ebp),%ecx
    b4a7:	8b 51 20             	mov    0x20(%ecx),%edx
    b4aa:	8b 82 a8 02 00 00    	mov    0x2a8(%edx),%eax
    b4b0:	a9 01 00 00 00       	test   $0x1,%eax
    b4b5:	74 05                	je     b4bc <WireTrickleRequest_extract+0x25c>
    b4b7:	83 e0 08             	and    $0x8,%eax
    b4ba:	74 7b                	je     b537 <WireTrickleRequest_extract+0x2d7>
    b4bc:	8b 43 70             	mov    0x70(%ebx),%eax
    b4bf:	8b 55 08             	mov    0x8(%ebp),%edx
    b4c2:	85 c0                	test   %eax,%eax
    b4c4:	89 82 84 00 00 00    	mov    %eax,0x84(%edx)
    b4ca:	7e 5e                	jle    b52a <WireTrickleRequest_extract+0x2ca>
    b4cc:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b4d0:	8b 43 0c             	mov    0xc(%ebx),%eax
    b4d3:	89 04 24             	mov    %eax,(%esp,1)
    b4d6:	e8 fc ff ff ff       	call   b4d7 <WireTrickleRequest_extract+0x277>
    b4db:	8b 4d 08             	mov    0x8(%ebp),%ecx
    b4de:	85 c0                	test   %eax,%eax
    b4e0:	89 c7                	mov    %eax,%edi
    b4e2:	89 81 88 00 00 00    	mov    %eax,0x88(%ecx)
    b4e8:	75 0e                	jne    b4f8 <WireTrickleRequest_extract+0x298>
    b4ea:	8b 45 10             	mov    0x10(%ebp),%eax
    b4ed:	c7 00 0c 00 00 00    	movl   $0xc,(%eax)
    b4f3:	e9 1d fe ff ff       	jmp    b315 <WireTrickleRequest_extract+0xb5>
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
    b4f8:	8b 55 08             	mov    0x8(%ebp),%edx
    b4fb:	8b b3 94 00 00 00    	mov    0x94(%ebx),%esi
    b501:	8b 82 84 00 00 00    	mov    0x84(%edx),%eax
int d0, d1, d2;
__asm__ __volatile__(
    b507:	89 c1                	mov    %eax,%ecx
    b509:	c1 e9 02             	shr    $0x2,%ecx
    b50c:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    b50e:	a8 02                	test   $0x2,%al
    b510:	74 02                	je     b514 <WireTrickleRequest_extract+0x2b4>
    b512:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    b514:	a8 01                	test   $0x1,%al
    b516:	74 01                	je     b519 <WireTrickleRequest_extract+0x2b9>
    b518:	a4                   	movsb  %ds:(%esi),%es:(%edi)
    b519:	8b 55 10             	mov    0x10(%ebp),%edx
    b51c:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
    b522:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b525:	e9 ed fd ff ff       	jmp    b317 <WireTrickleRequest_extract+0xb7>
    b52a:	8b 4d 08             	mov    0x8(%ebp),%ecx
    b52d:	31 db                	xor    %ebx,%ebx
    b52f:	89 99 88 00 00 00    	mov    %ebx,0x88(%ecx)
    b535:	eb e2                	jmp    b519 <WireTrickleRequest_extract+0x2b9>
    b537:	8b 45 08             	mov    0x8(%ebp),%eax
    b53a:	31 c9                	xor    %ecx,%ecx
    b53c:	31 d2                	xor    %edx,%edx
    b53e:	89 88 84 00 00 00    	mov    %ecx,0x84(%eax)
    b544:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
    b54a:	eb cd                	jmp    b519 <WireTrickleRequest_extract+0x2b9>
    b54c:	8b 45 08             	mov    0x8(%ebp),%eax
    b54f:	31 ff                	xor    %edi,%edi
    b551:	89 b8 80 00 00 00    	mov    %edi,0x80(%eax)
    b557:	e9 4e ff ff ff       	jmp    b4aa <WireTrickleRequest_extract+0x24a>
    b55c:	8b 4d 08             	mov    0x8(%ebp),%ecx
    b55f:	31 f6                	xor    %esi,%esi
    b561:	c7 41 7c 00 00 00 00 	movl   $0x0,0x7c(%ecx)
    b568:	89 b1 80 00 00 00    	mov    %esi,0x80(%ecx)
    b56e:	e9 37 ff ff ff       	jmp    b4aa <WireTrickleRequest_extract+0x24a>
    b573:	c7 04 24 60 31 00 00 	movl   $0x3160,(%esp,1)
    b57a:	e9 3a fe ff ff       	jmp    b3b9 <WireTrickleRequest_extract+0x159>
	return skb->data_len;
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
    b57f:	89 1c 24             	mov    %ebx,(%esp,1)
    b582:	29 f0                	sub    %esi,%eax
    b584:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b588:	e8 fc ff ff ff       	call   b589 <WireTrickleRequest_extract+0x329>
    b58d:	31 c9                	xor    %ecx,%ecx
    b58f:	85 c0                	test   %eax,%eax
    b591:	0f 95 c1             	setne  %cl
    b594:	e9 70 fe ff ff       	jmp    b409 <WireTrickleRequest_extract+0x1a9>
    b599:	89 1c 24             	mov    %ebx,(%esp,1)
    b59c:	89 f8                	mov    %edi,%eax
    b59e:	29 d0                	sub    %edx,%eax
    b5a0:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b5a4:	e8 fc ff ff ff       	call   b5a5 <WireTrickleRequest_extract+0x345>
    b5a9:	85 c0                	test   %eax,%eax
    b5ab:	0f 95 c0             	setne  %al
    b5ae:	0f b6 c0             	movzbl %al,%eax
    b5b1:	e9 f8 fd ff ff       	jmp    b3ae <WireTrickleRequest_extract+0x14e>
    b5b6:	89 1c 24             	mov    %ebx,(%esp,1)
    b5b9:	89 c8                	mov    %ecx,%eax
    b5bb:	29 f0                	sub    %esi,%eax
    b5bd:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b5c1:	e8 fc ff ff ff       	call   b5c2 <WireTrickleRequest_extract+0x362>
    b5c6:	85 c0                	test   %eax,%eax
    b5c8:	0f 95 c0             	setne  %al
    b5cb:	0f b6 c0             	movzbl %al,%eax
    b5ce:	e9 cd fc ff ff       	jmp    b2a0 <WireTrickleRequest_extract+0x40>
	return skb->len - skb->data_len;
}

#define SKB_PAGE_ASSERT(skb) do { if (skb_shinfo(skb)->nr_frags) out_of_line_bug(); } while (0)
#define SKB_FRAG_ASSERT(skb) do { if (skb_shinfo(skb)->frag_list) out_of_line_bug(); } while (0)
#define SKB_LINEAR_ASSERT(skb) do { if (skb_is_nonlinear(skb)) out_of_line_bug(); } while (0)

/*
 *	Add data to an sk_buff
 */
 
static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	return tmp;
}

/**
 *	skb_put - add data to a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer. If this would
 *	exceed the total buffer size the kernel will panic. A pointer to the
 *	first byte of the extra data is returned.
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	if(skb->tail>skb->end) {
		skb_over_panic(skb, len, current_text_addr());
	}
	return tmp;
}

static inline unsigned char *__skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
	skb->len+=len;
	return skb->data;
}

/**
 *	skb_push - add data to the start of a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer at the buffer
 *	start. If this would exceed the total buffer headroom the kernel will
 *	panic. A pointer to the first byte of the extra data is returned.
 */

static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
	skb->len+=len;
	if(skb->data<skb->head) {
		skb_under_panic(skb, len, current_text_addr());
	}
	return skb->data;
}

static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
	skb->len-=len;
	if (skb->len < skb->data_len)
		out_of_line_bug();
    b5d3:	c7 04 24 4c 03 00 00 	movl   $0x34c,(%esp,1)
    b5da:	e8 fc ff ff ff       	call   b5db <WireTrickleRequest_extract+0x37b>
    b5df:	90                   	nop    

0000b5e0 <DoUpcall>:

static inline void pre_init_sock(struct cminisock *msk, struct sk_buff *skb) {
	/* save the fields necessary for a later init_sock */
	if(!SIMULATION_MODE(msk->sk)) {
		msk->saddr = skb->nh.iph->daddr;
		msk->source = skb->h.th->dest;

		msk->daddr = skb->nh.iph->saddr;
		msk->dest = skb->h.th->source;
	}
}

#ifndef USERTEST
void DoUpcall(struct cminisock *msk, enum cminisock_event_tag event) {
    b5e0:	55                   	push   %ebp
    b5e1:	89 e5                	mov    %esp,%ebp
    b5e3:	57                   	push   %edi
    b5e4:	56                   	push   %esi
    b5e5:	53                   	push   %ebx
    b5e6:	83 ec 30             	sub    $0x30,%esp
	int i;
	struct NonceCtx ctx;
	if(!SIMULATION_MODE(msk->sk)) {
    b5e9:	8b 55 08             	mov    0x8(%ebp),%edx
    b5ec:	8b 42 20             	mov    0x20(%edx),%eax
    b5ef:	8b 90 a8 02 00 00    	mov    0x2a8(%eax),%edx
    b5f5:	f7 c2 01 00 00 00    	test   $0x1,%edx
    b5fb:	74 09                	je     b606 <DoUpcall+0x26>
    b5fd:	83 e2 08             	and    $0x8,%edx
    b600:	0f 84 b4 00 00 00    	je     b6ba <DoUpcall+0xda>
		ctx.new = 1;
    b606:	c7 45 d4 01 00 00 00 	movl   $0x1,0xffffffd4(%ebp)
		for(i=0; i < msk->num_packets; i++) {
    b60d:	8b 55 08             	mov    0x8(%ebp),%edx
    b610:	31 ff                	xor    %edi,%edi
    b612:	3b ba dc 00 00 00    	cmp    0xdc(%edx),%edi
    b618:	7d 66                	jge    b680 <DoUpcall+0xa0>
    b61a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			msk->packets[i].nonce = generateSingleNonce(msk->sk, msk->packets[i].seq, &ctx);
    b620:	8b 55 08             	mov    0x8(%ebp),%edx
    b623:	8d 1c bf             	lea    (%edi,%edi,4),%ebx
    b626:	47                   	inc    %edi
    b627:	c1 e3 03             	shl    $0x3,%ebx
    b62a:	8b b2 e0 00 00 00    	mov    0xe0(%edx),%esi
    b630:	8d 55 d4             	lea    0xffffffd4(%ebp),%edx
    b633:	89 54 24 0c          	mov    %edx,0xc(%esp,1)
    b637:	8b 54 1e 04          	mov    0x4(%esi,%ebx,1),%edx
    b63b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    b642:	00 
    b643:	89 04 24             	mov    %eax,(%esp,1)
    b646:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    b64a:	e8 fc ff ff ff       	call   b64b <DoUpcall+0x6b>
			msk->packets[i].ucontLen = 0;
			msk->packets[i].ucontData = NULL;
    b64f:	31 c9                	xor    %ecx,%ecx
    b651:	89 04 1e             	mov    %eax,(%esi,%ebx,1)
    b654:	31 f6                	xor    %esi,%esi
    b656:	8b 55 08             	mov    0x8(%ebp),%edx
    b659:	8b 82 e0 00 00 00    	mov    0xe0(%edx),%eax
    b65f:	89 74 18 14          	mov    %esi,0x14(%eax,%ebx,1)
    b663:	8b 82 e0 00 00 00    	mov    0xe0(%edx),%eax
    b669:	89 4c 18 18          	mov    %ecx,0x18(%eax,%ebx,1)
    b66d:	3b ba dc 00 00 00    	cmp    0xdc(%edx),%edi
    b673:	7d 08                	jge    b67d <DoUpcall+0x9d>
    b675:	8b 55 08             	mov    0x8(%ebp),%edx
    b678:	8b 42 20             	mov    0x20(%edx),%eax
    b67b:	eb a3                	jmp    b620 <DoUpcall+0x40>
    b67d:	8b 42 20             	mov    0x20(%edx),%eax
		}
		queue_upcall_prealloc(msk->sk,event,msk);
    b680:	89 04 24             	mov    %eax,(%esp,1)
    b683:	8b 55 08             	mov    0x8(%ebp),%edx
    b686:	89 54 24 08          	mov    %edx,0x8(%esp,1)
    b68a:	8b 55 0c             	mov    0xc(%ebp),%edx
    b68d:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    b691:	e8 fc ff ff ff       	call   b692 <DoUpcall+0xb2>
		queue_upcall(event,msk);
    b696:	8b 45 08             	mov    0x8(%ebp),%eax
    b699:	8b 55 0c             	mov    0xc(%ebp),%edx
    b69c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b6a0:	89 14 24             	mov    %edx,(%esp,1)
    b6a3:	e8 fc ff ff ff       	call   b6a4 <DoUpcall+0xc4>
		queue_upcall_deliver(msk->sk,msk);
    b6a8:	8b 45 08             	mov    0x8(%ebp),%eax
    b6ab:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b6af:	8b 40 20             	mov    0x20(%eax),%eax
    b6b2:	89 04 24             	mov    %eax,(%esp,1)
    b6b5:	e8 fc ff ff ff       	call   b6b6 <DoUpcall+0xd6>
	}
 }
    b6ba:	83 c4 30             	add    $0x30,%esp
    b6bd:	5b                   	pop    %ebx
    b6be:	5e                   	pop    %esi
    b6bf:	5f                   	pop    %edi
    b6c0:	5d                   	pop    %ebp
    b6c1:	c3                   	ret    
    b6c2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    b6c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

0000b6d0 <server_rcv_impl>:
#endif

int server_rcv_impl(struct sock *sk, struct sk_buff *in_skb) {
    b6d0:	55                   	push   %ebp
    b6d1:	89 e5                	mov    %esp,%ebp
    b6d3:	57                   	push   %edi
    b6d4:	56                   	push   %esi
    b6d5:	53                   	push   %ebx
    b6d6:	83 ec 1c             	sub    $0x1c,%esp
	int rval = -EINVAL;
    b6d9:	c7 45 ec ea ff ff ff 	movl   $0xffffffea,0xffffffec(%ebp)
    b6e0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    b6e3:	8b 75 08             	mov    0x8(%ebp),%esi
	struct tcphdr *ith = in_skb->h.th;
    b6e6:	8b 43 20             	mov    0x20(%ebx),%eax
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
    b6e9:	8d be bc 00 00 00    	lea    0xbc(%esi),%edi
    b6ef:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
	struct cminisock *msk;

	TIMING_CTX_DEF0("server_rcv_impl", "");
	TIMING_CTX_DEF1(4);
	reinitTimingCtx(&ctx);
	recordSample(&ctx,0);

	if(!SIMULATION_MODE(sk) && !TRICKLES_USERAPI_CONFIGURED_TP(tp)) {
    b6f2:	8b 86 a8 02 00 00    	mov    0x2a8(%esi),%eax
    b6f8:	a9 01 00 00 00       	test   $0x1,%eax
    b6fd:	74 05                	je     b704 <server_rcv_impl+0x34>
    b6ff:	83 e0 08             	and    $0x8,%eax
    b702:	74 0e                	je     b712 <server_rcv_impl+0x42>
    b704:	8b 87 d0 01 00 00    	mov    0x1d0(%edi),%eax
    b70a:	85 c0                	test   %eax,%eax
    b70c:	0f 84 c2 02 00 00    	je     b9d4 <server_rcv_impl+0x304>
		printk("Not configured\n");
		goto out;
	}

	msk = alloc_trickles_msk(sk);
    b712:	89 34 24             	mov    %esi,(%esp,1)
    b715:	e8 f6 1f 00 00       	call   d710 <alloc_trickles_msk>
    b71a:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

        if(msk == NULL) {
    b71d:	85 c0                	test   %eax,%eax
    b71f:	0f 85 bb 00 00 00    	jne    b7e0 <server_rcv_impl+0x110>
		if(trickles_ratelimit())
    b725:	a1 00 00 00 00       	mov    0x0,%eax
    b72a:	9c                   	pushf  
    b72b:	59                   	pop    %ecx
    b72c:	fa                   	cli    
    b72d:	89 c2                	mov    %eax,%edx
    b72f:	8b 35 a0 b4 0e 00    	mov    0xeb4a0,%esi
    b735:	8b 1d 0c 01 00 00    	mov    0x10c,%ebx
    b73b:	a3 a0 b4 0e 00       	mov    %eax,0xeb4a0
    b740:	29 f2                	sub    %esi,%edx
    b742:	01 da                	add    %ebx,%edx
    b744:	89 15 0c 01 00 00    	mov    %edx,0x10c
    b74a:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    b750:	76 0f                	jbe    b761 <server_rcv_impl+0x91>
    b752:	b8 88 13 00 00       	mov    $0x1388,%eax
    b757:	ba 88 13 00 00       	mov    $0x1388,%edx
    b75c:	a3 0c 01 00 00       	mov    %eax,0x10c
    b761:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    b767:	76 67                	jbe    b7d0 <server_rcv_impl+0x100>
    b769:	31 ff                	xor    %edi,%edi
    b76b:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    b771:	a1 a4 b4 0e 00       	mov    0xeb4a4,%eax
    b776:	89 15 0c 01 00 00    	mov    %edx,0x10c
    b77c:	89 3d a4 b4 0e 00    	mov    %edi,0xeb4a4
    b782:	51                   	push   %ecx
    b783:	9d                   	popf   
    b784:	85 c0                	test   %eax,%eax
    b786:	75 26                	jne    b7ae <server_rcv_impl+0xde>
    b788:	b8 01 00 00 00       	mov    $0x1,%eax
    b78d:	85 c0                	test   %eax,%eax
    b78f:	75 0f                	jne    b7a0 <server_rcv_impl+0xd0>
			printk("could not allocate minisock\n");
		goto out;
        }

	msk->sk = sk;
	in_skb->sk = sk;
	pre_init_sock(msk,in_skb);

	recordSample(&ctx,0);
	if(SIMULATION_MODE(sk)) {
		goto normal;
	}
	if(ith->syn) {
		__u32 firstSeq;
		/* SYN packet format:
		 * Initial request continuation immediately follows TCP
		 * header
		 */
		if(ith->ack) {
			printk("warning: trickles server cannot handle syn/ack\n");
		}
		firstSeq = 1; // XXX Should be randomized
		if(!alloc_msk_packets(msk, 1)) {
			goto out;
		}
		makePacket(&msk->packets[0], firstSeq, 1, MTU, 
			   -1, PTYPE_FIRST | PACKET_NORMAL, CONTTYPE_FULL1,
			   1 * MTU,  firstSeq + 1, 1);
		/* xxx Should Trickles allow data on SYN packets */
		msk->ucont_len = 0;

		msk->clientState = -1;
		msk->mrtt = 0;

		// these values (firstLoss, firstBootstrapSeq) are not used in normal state ( syn/ack )
		msk->firstLoss = 0x1055;
		msk->firstBootstrapSeq = 0xb007;
		msk->startCwnd = 1;
		msk->ssthresh = 0x3fff; // small enough to prevent overflow when squaring
		//msk->ssthresh = 0x100;
		msk->TCPBase = msk->packets[0].seq;
		msk->tokenCounterBase = tp->bigTokenCounter;
		tp->bigTokenCounter += ((__u64) 1)  << 32;

		DoUpcall(msk, SYN);

#if 0
		// Automatic packet generation
		tp->t.dbg_skb = skb_copy(in_skb, GFP_ATOMIC);
		tp->t.slowstart_timer.function = &testTimer;
		tp->t.slowstart_timer.data = (long)sk;
		resetClientTimer(sk);
#endif
	} else if(ith->fin) {
		/* FIN packet format:
		   WireTrickleRequest */
		/* Sequence number generation */
		recordSample(&ctx,0);
		if((rval = ExecuteTrickle(&msk, in_skb, FIN))) {
			goto out_dealloc_msk;
		}
	} else if(ith->rst) {
		/* TODO: Implement reset handling */
		goto out_dealloc_msk;	
	} else {
	normal:
		/* normal operation */
		recordSample(&ctx,0);
		if((rval = ExecuteTrickle(&msk, in_skb, ACK))) {
			goto out_dealloc_msk;
		}
	}
	recordSample(&ctx,0);
	//printTimings(&ctx);
	return 0;
 out_dealloc_msk:
	if(rval != -ENOMEM) {
		// ENOMEM deallocates msk in callees. This is a hostorical artifact
		free_trickles_msk(sk,msk);
		free_trickles_msk_finish(sk,msk);
	}
 out:
	return rval;
    b791:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
    b794:	83 c4 1c             	add    $0x1c,%esp
    b797:	5b                   	pop    %ebx
    b798:	5e                   	pop    %esi
    b799:	5f                   	pop    %edi
    b79a:	5d                   	pop    %ebp
    b79b:	c3                   	ret    
    b79c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    b7a0:	c7 04 24 37 06 00 00 	movl   $0x637,(%esp,1)
    b7a7:	e8 fc ff ff ff       	call   b7a8 <server_rcv_impl+0xd8>
    b7ac:	eb e3                	jmp    b791 <server_rcv_impl+0xc1>
    b7ae:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    b7b2:	c7 44 24 08 36 02 00 	movl   $0x236,0x8(%esp,1)
    b7b9:	00 
    b7ba:	c7 44 24 04 04 06 00 	movl   $0x604,0x4(%esp,1)
    b7c1:	00 
    b7c2:	c7 04 24 00 30 00 00 	movl   $0x3000,(%esp,1)
    b7c9:	e8 fc ff ff ff       	call   b7ca <server_rcv_impl+0xfa>
    b7ce:	eb b8                	jmp    b788 <server_rcv_impl+0xb8>
    b7d0:	ff 05 a4 b4 0e 00    	incl   0xeb4a4
    b7d6:	51                   	push   %ecx
    b7d7:	9d                   	popf   
    b7d8:	31 c0                	xor    %eax,%eax
    b7da:	eb b1                	jmp    b78d <server_rcv_impl+0xbd>
    b7dc:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    b7e0:	89 70 20             	mov    %esi,0x20(%eax)
    b7e3:	89 73 0c             	mov    %esi,0xc(%ebx)
    b7e6:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    b7e9:	8b 42 20             	mov    0x20(%edx),%eax
    b7ec:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    b7f2:	a9 01 00 00 00       	test   $0x1,%eax
    b7f7:	74 05                	je     b7fe <server_rcv_impl+0x12e>
    b7f9:	83 e0 08             	and    $0x8,%eax
    b7fc:	74 27                	je     b825 <server_rcv_impl+0x155>
    b7fe:	8b 43 24             	mov    0x24(%ebx),%eax
    b801:	8b 40 10             	mov    0x10(%eax),%eax
    b804:	89 42 14             	mov    %eax,0x14(%edx)
    b807:	8b 43 20             	mov    0x20(%ebx),%eax
    b80a:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    b80e:	66 89 42 1c          	mov    %ax,0x1c(%edx)
    b812:	8b 43 24             	mov    0x24(%ebx),%eax
    b815:	8b 40 0c             	mov    0xc(%eax),%eax
    b818:	89 42 18             	mov    %eax,0x18(%edx)
    b81b:	8b 43 20             	mov    0x20(%ebx),%eax
    b81e:	0f b7 00             	movzwl (%eax),%eax
    b821:	66 89 42 1e          	mov    %ax,0x1e(%edx)
    b825:	8b 86 a8 02 00 00    	mov    0x2a8(%esi),%eax
    b82b:	a9 01 00 00 00       	test   $0x1,%eax
    b830:	74 09                	je     b83b <server_rcv_impl+0x16b>
    b832:	83 e0 08             	and    $0x8,%eax
    b835:	0f 84 44 01 00 00    	je     b97f <server_rcv_impl+0x2af>
    b83b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    b83e:	0f b6 50 0d          	movzbl 0xd(%eax),%edx
    b842:	88 d0                	mov    %dl,%al
    b844:	24 02                	and    $0x2,%al
    b846:	84 c0                	test   %al,%al
    b848:	0f 84 22 01 00 00    	je     b970 <server_rcv_impl+0x2a0>
    b84e:	80 e2 10             	and    $0x10,%dl
    b851:	84 d2                	test   %dl,%dl
    b853:	0f 85 03 01 00 00    	jne    b95c <server_rcv_impl+0x28c>
    b859:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
    b860:	00 
    b861:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b864:	89 04 24             	mov    %eax,(%esp,1)
    b867:	e8 84 1c 00 00       	call   d4f0 <alloc_msk_packets>
    b86c:	85 c0                	test   %eax,%eax
    b86e:	0f 84 1d ff ff ff    	je     b791 <server_rcv_impl+0xc1>
			      __u8 type, 
			      __u8 contType, 
			      __u16 minResponseLen,
			      __u32 firstTransportChild, 
			      __u8 numTransportChildren) {
    b874:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b877:	8b 90 e0 00 00 00    	mov    0xe0(%eax),%edx
  pkt->nonce = -1;
  pkt->seq = seq;
  //pkt->ack_seq = ack_seq;
  pkt->len = len;
  pkt->byteNum = byteNum;
  pkt->type = type;
  pkt->contType = contType;
    b87d:	0f b6 42 10          	movzbl 0x10(%edx),%eax
    b881:	c7 42 04 01 00 00 00 	movl   $0x1,0x4(%edx)
    b888:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
    b88e:	c7 42 08 52 05 00 00 	movl   $0x552,0x8(%edx)
    b895:	24 c0                	and    $0xc0,%al
    b897:	0c 08                	or     $0x8,%al
    b899:	88 42 10             	mov    %al,0x10(%edx)
    b89c:	c7 42 0c ff ff ff ff 	movl   $0xffffffff,0xc(%edx)
  pkt->minResponseLen = minResponseLen;
    b8a3:	66 c7 42 1c 52 05    	movw   $0x552,0x1c(%edx)
  pkt->firstTransportChild = firstTransportChild;
    b8a9:	c7 42 20 02 00 00 00 	movl   $0x2,0x20(%edx)
  pkt->numTransportChildren = numTransportChildren;
    b8b0:	c6 42 24 01          	movb   $0x1,0x24(%edx)
  pkt->ucontLen = 0;
    b8b4:	c7 42 14 00 00 00 00 	movl   $0x0,0x14(%edx)
  pkt->ucontData = NULL;
    b8bb:	c7 42 18 00 00 00 00 	movl   $0x0,0x18(%edx)
  pkt->numSiblings = -1;
    b8c2:	c6 42 11 ff          	movb   $0xff,0x11(%edx)
  pkt->position = INVALID_POSITION;
    b8c6:	c6 42 12 ff          	movb   $0xff,0x12(%edx)
    b8ca:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b8cd:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
    b8d4:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b8d7:	c7 40 3c ff ff ff ff 	movl   $0xffffffff,0x3c(%eax)
    b8de:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b8e1:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
    b8e8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b8eb:	c7 40 60 55 10 00 00 	movl   $0x1055,0x60(%eax)
    b8f2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b8f5:	c7 40 64 07 b0 00 00 	movl   $0xb007,0x64(%eax)
    b8fc:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b8ff:	c7 40 68 01 00 00 00 	movl   $0x1,0x68(%eax)
    b906:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b909:	c7 40 6c ff 3f 00 00 	movl   $0x3fff,0x6c(%eax)
    b910:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    b913:	8b 82 e0 00 00 00    	mov    0xe0(%edx),%eax
    b919:	8b 40 04             	mov    0x4(%eax),%eax
    b91c:	89 42 70             	mov    %eax,0x70(%edx)
    b91f:	8b 87 f0 01 00 00    	mov    0x1f0(%edi),%eax
    b925:	8b 97 f4 01 00 00    	mov    0x1f4(%edi),%edx
    b92b:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    b92e:	89 41 74             	mov    %eax,0x74(%ecx)
    b931:	89 51 78             	mov    %edx,0x78(%ecx)
    b934:	83 87 f0 01 00 00 00 	addl   $0x0,0x1f0(%edi)
    b93b:	83 97 f4 01 00 00 01 	adcl   $0x1,0x1f4(%edi)
    b942:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    b949:	00 
    b94a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b94d:	89 04 24             	mov    %eax,(%esp,1)
    b950:	e8 fc ff ff ff       	call   b951 <server_rcv_impl+0x281>
    b955:	31 c0                	xor    %eax,%eax
    b957:	e9 38 fe ff ff       	jmp    b794 <server_rcv_impl+0xc4>
    b95c:	c7 04 24 a0 31 00 00 	movl   $0x31a0,(%esp,1)
    b963:	e8 fc ff ff ff       	call   b964 <server_rcv_impl+0x294>
    b968:	e9 ec fe ff ff       	jmp    b859 <server_rcv_impl+0x189>
    b96d:	8d 76 00             	lea    0x0(%esi),%esi
    b970:	88 d0                	mov    %dl,%al
    b972:	24 01                	and    $0x1,%al
    b974:	84 c0                	test   %al,%al
    b976:	75 52                	jne    b9ca <server_rcv_impl+0x2fa>
    b978:	80 e2 04             	and    $0x4,%dl
    b97b:	84 d2                	test   %dl,%dl
    b97d:	75 1e                	jne    b99d <server_rcv_impl+0x2cd>
    b97f:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp,1)
    b986:	00 
    b987:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    b98b:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
    b98e:	89 04 24             	mov    %eax,(%esp,1)
    b991:	e8 4a 00 00 00       	call   b9e0 <ExecuteTrickle>
    b996:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    b999:	85 c0                	test   %eax,%eax
    b99b:	74 b8                	je     b955 <server_rcv_impl+0x285>
    b99d:	83 7d ec f4          	cmpl   $0xfffffff4,0xffffffec(%ebp)
    b9a1:	0f 84 ea fd ff ff    	je     b791 <server_rcv_impl+0xc1>
    b9a7:	89 34 24             	mov    %esi,(%esp,1)
    b9aa:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b9ad:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b9b1:	e8 ea eb ff ff       	call   a5a0 <free_trickles_msk>
    b9b6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b9b9:	89 34 24             	mov    %esi,(%esp,1)
    b9bc:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b9c0:	e8 7b ec ff ff       	call   a640 <free_trickles_msk_finish>
    b9c5:	e9 c7 fd ff ff       	jmp    b791 <server_rcv_impl+0xc1>
    b9ca:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp,1)
    b9d1:	00 
    b9d2:	eb b3                	jmp    b987 <server_rcv_impl+0x2b7>
    b9d4:	c7 04 24 54 06 00 00 	movl   $0x654,(%esp,1)
    b9db:	e9 c7 fd ff ff       	jmp    b7a7 <server_rcv_impl+0xd7>

0000b9e0 <ExecuteTrickle>:

#if 0
#define SIMULATIONMODE_INIT() int simPrintCount = 0
#define SIMULATIONMODE_PRINT() if(SIMULATION_MODE(skb->sk)) /*printk("simulation mode : %d\n", simPrintCount++)*/ 
#else
#define SIMULATIONMODE_INIT()
#define SIMULATIONMODE_PRINT()
#endif

static int ExecuteTrickle(struct cminisock **cont, struct sk_buff *skb, enum cminisock_event_tag event) {
    b9e0:	55                   	push   %ebp
    b9e1:	89 e5                	mov    %esp,%ebp
  int rval = -EINVAL;
    b9e3:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    b9e8:	57                   	push   %edi

  int error;
  AckProof ackProof;
  WireTrickleRequest *treq_hdr = WireTrickleRequest_extract(*cont, skb, &error);
  enum CheckRangeResult rangeCheck;

  SIMULATIONMODE_INIT();

  TIMING_CTX_DEF0("ExecuteTrickle", "");
  TIMING_CTX_DEF1(7);
  reinitTimingCtx(&ctx);
  recordSample(&ctx,0);
  (*cont)->executionTrace = 0;
    b9e9:	31 ff                	xor    %edi,%edi
    b9eb:	56                   	push   %esi
    b9ec:	53                   	push   %ebx
    b9ed:	81 ec 28 03 00 00    	sub    $0x328,%esp
    b9f3:	89 85 dc fc ff ff    	mov    %eax,0xfffffcdc(%ebp)
    b9f9:	8d 85 e0 fc ff ff    	lea    0xfffffce0(%ebp),%eax
    b9ff:	8b 55 08             	mov    0x8(%ebp),%edx
    ba02:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    ba06:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba09:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ba0d:	8b 02                	mov    (%edx),%eax
    ba0f:	89 04 24             	mov    %eax,(%esp,1)
    ba12:	e8 fc ff ff ff       	call   ba13 <ExecuteTrickle+0x33>
    ba17:	8b 4d 08             	mov    0x8(%ebp),%ecx
    ba1a:	89 c6                	mov    %eax,%esi

  if(treq_hdr == NULL) {
    ba1c:	85 f6                	test   %esi,%esi
    ba1e:	8b 01                	mov    (%ecx),%eax
    ba20:	89 b8 d0 00 00 00    	mov    %edi,0xd0(%eax)
    ba26:	0f 84 c4 04 00 00    	je     bef0 <ExecuteTrickle+0x510>
    if(error == EINVAL) {
      if(trickles_ratelimit()) {
	printk("ExecuteTrickle: Could not find request header\n");
      }
      return -EINVAL;
    } else {
      BUG_TRAP(error == ENOMEM);
      return -ENOMEM;
    }
  }
  
  if(!unmarshallContinuationServer(skb, *cont, &treq_hdr->cont)) {
    ba2c:	8b 55 08             	mov    0x8(%ebp),%edx
    ba2f:	8d 46 01             	lea    0x1(%esi),%eax
    ba32:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    ba35:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    ba39:	8b 02                	mov    (%edx),%eax
    ba3b:	89 0c 24             	mov    %ecx,(%esp,1)
    ba3e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ba42:	e8 d9 ed ff ff       	call   a820 <unmarshallContinuationServer>
    ba47:	85 c0                	test   %eax,%eax
    ba49:	0f 85 b9 00 00 00    	jne    bb08 <ExecuteTrickle+0x128>
    /* MAC error */
	  if(trickles_ratelimit())
    ba4f:	a1 00 00 00 00       	mov    0x0,%eax
    ba54:	9c                   	pushf  
    ba55:	59                   	pop    %ecx
    ba56:	fa                   	cli    
    ba57:	89 c2                	mov    %eax,%edx
    ba59:	8b 1d b0 b4 0e 00    	mov    0xeb4b0,%ebx
    ba5f:	8b 3d 14 01 00 00    	mov    0x114,%edi
    ba65:	a3 b0 b4 0e 00       	mov    %eax,0xeb4b0
    ba6a:	29 da                	sub    %ebx,%edx
    ba6c:	01 fa                	add    %edi,%edx
    ba6e:	89 15 14 01 00 00    	mov    %edx,0x114
    ba74:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    ba7a:	76 10                	jbe    ba8c <ExecuteTrickle+0xac>
    ba7c:	be 88 13 00 00       	mov    $0x1388,%esi
    ba81:	ba 88 13 00 00       	mov    $0x1388,%edx
    ba86:	89 35 14 01 00 00    	mov    %esi,0x114
    ba8c:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    ba92:	76 68                	jbe    bafc <ExecuteTrickle+0x11c>
    ba94:	31 db                	xor    %ebx,%ebx
    ba96:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    ba9c:	a1 b4 b4 0e 00       	mov    0xeb4b4,%eax
    baa1:	89 15 14 01 00 00    	mov    %edx,0x114
    baa7:	89 1d b4 b4 0e 00    	mov    %ebx,0xeb4b4
    baad:	51                   	push   %ecx
    baae:	9d                   	popf   
    baaf:	85 c0                	test   %eax,%eax
    bab1:	75 27                	jne    bada <ExecuteTrickle+0xfa>
    bab3:	b8 01 00 00 00       	mov    $0x1,%eax
    bab8:	85 c0                	test   %eax,%eax
    baba:	75 10                	jne    bacc <ExecuteTrickle+0xec>
		  printk("Mac error\n");
    return -EINVAL;
  }
  recordSample(&ctx,0);
  SIMULATIONMODE_PRINT();
  unmarshallAckProof(&ackProof, &treq_hdr->ackProof);
  ackProof.cont = *cont;
  recordSample(&ctx,0);
  if(!SIMULATION_MODE((*cont)->sk) && !AckProof_validate(&ackProof)) {
    /* Bad nonce, or doesn't start at TCPBase */
    if(SIMULATION_MODE(skb->sk)  && debugSimulation)
      printk("ackproof validation failed\n");
    return -EINVAL;
  }

  SIMULATIONMODE_PRINT();
  recordSample(&ctx,0);
  if(serverDebugLevel >= 2) {
    printk("Server processing: %u\n", (*cont)->seq);
    AckProof_dump(&ackProof);
  }

  /* Determine continuation mode */
  SIMULATIONMODE_PRINT();
  rangeCheck = AckProof_checkRange(&ackProof, (*cont)->TCPBase, (*cont)->seq);
  recordSample(&ctx,0);

  switch((enum TrickleRequestType)treq_hdr->type) {
  case TREQ_NORMAL: {
    // mrtt_1 = mrtt_0 * 7/8 + delta * 1/8
    (*cont)->mrtt -= (*cont)->mrtt >> 3;
    (*cont)->mrtt += jiffies - (*cont)->timestamp;
    switch((*cont)->state) {
    case CONT_NORMAL:
      if(serverDebugLevel >= 2)
        printk("Normal request => Normal state\n");
      switch(rangeCheck) {
      case NORMALRANGE:
	if(serverDebugLevel >= 2)
	  printk("  Normal Range\n");
	SIMULATIONMODE_PRINT();
#ifdef STOMP_CONNECTIONS
#define STOMP()								\
	if(!SIMULATION_MODE(skb->sk) &&					\
           (*cont)->seq - (*cont)->TCPBase >= STOMP_CONNECTIONS) {	\
	/* if(trickles_ratelimit()) {				\
		  printk("Stomping connection from %X:%d\n", (*cont)->daddr, (*cont)->dest); \
	  } */							\
	  return -EINVAL;							\
	}
#else
#define STOMP()
#endif
        STOMP();
	rval = DoNormalStep(cont, &ackProof, event);
	recordSample(&ctx,0);
	break;
      case POISONEDRANGE:
      case BADRANGE:
	if(serverDebugLevel >= 2) {
	  printk("  Bad or poisoned Range (ack # %u)\n", (*cont)->seq);
	  AckProof_dump(&ackProof);
	}
	rval = DoRecoveryStep(cont, &ackProof, event);
	break;
      }
      break;
    case CONT_RECOVERY:
      if(serverDebugLevel >= 1)
	printk("Normal request => Recovery state\n");
      switch(rangeCheck) {
      default:
	// no action
	break;
      }
      break;
    case CONT_BOOTSTRAP:
      if(serverDebugLevel >= 1)
	printk("Normal request => Bootstrap state\n");
      switch(rangeCheck) {
      case POISONEDRANGE:
	if(serverDebugLevel >= 1)
	  printk("  Poisoned Range\n");
	// check that poison is only during recovery interval
	if(!(AckProof_checkRange(&ackProof, (*cont)->TCPBase, (*cont)->firstLoss-1) == NORMALRANGE
	     && AckProof_checkRange(&ackProof, (*cont)->firstBootstrapSeq, (*cont)->seq) == NORMALRANGE)) {
	  ERROR("poisoned packets where normal packets should be\n");
	  goto slow_start;
	}
      case NORMALRANGE:
	if(serverDebugLevel >= 1)
	  printk("  Normal Range\n");
	(*cont)->TCPBase = (*cont)->firstBootstrapSeq;
	if(serverDebugLevel >= 1)
	  printk("Bootstrap: TCPBase = %u CWND = %u SSTHRESH = %u\n", (*cont)->TCPBase, (*cont)->startCwnd, (*cont)->ssthresh);
	STOMP();
	rval = DoNormalStep(cont, &ackProof, event);
	break;
      case BADRANGE:
	if(serverDebugLevel >= 1)
	  printk("  Bad Range\n");
      slow_start:
	if(serverDebugLevel >= 1) {
		printk("slow start bad range: ");
		AckProof_dump(&ackProof);
	}
	rval = DoRecoveryStep(cont, &ackProof, event);
	break;
      default:
	printk("  unknown state\n");
	return -EINVAL;
      }
      break;
    }
    break;
  }
  case TREQ_SLOWSTART: {
    __u32 seq;
    (*cont)->mrtt = (jiffies - (*cont)->timestamp) << 3;
    if(serverDebugLevel >= 1) {
      printk("Slow Start request => \n");
      AckProof_dump(&ackProof);
    }
    seq = AckProof_findRight(&ackProof, (*cont)->TCPBase);
    if(seq < (*cont)->TCPBase) {
	    printk("  SlowStart: seq < (*cont)->TCPBase\n");
	    return -EINVAL;
    babc:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    }
    rval = DoSlowStartStep(cont, &ackProof, seq + 1, event);
    break;
  }
  default:
    printk("  unknown request type\n");
  }

  recordSample(&ctx,0);
  //printTimings(&ctx);
  return rval;
}
    bac1:	81 c4 28 03 00 00    	add    $0x328,%esp
    bac7:	5b                   	pop    %ebx
    bac8:	5e                   	pop    %esi
    bac9:	5f                   	pop    %edi
    baca:	5d                   	pop    %ebp
    bacb:	c3                   	ret    
    bacc:	c7 04 24 64 06 00 00 	movl   $0x664,(%esp,1)
    bad3:	e8 fc ff ff ff       	call   bad4 <ExecuteTrickle+0xf4>
    bad8:	eb e2                	jmp    babc <ExecuteTrickle+0xdc>
    bada:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    bade:	c7 44 24 08 b2 02 00 	movl   $0x2b2,0x8(%esp,1)
    bae5:	00 
    bae6:	c7 44 24 04 04 06 00 	movl   $0x604,0x4(%esp,1)
    baed:	00 
    baee:	c7 04 24 00 30 00 00 	movl   $0x3000,(%esp,1)
    baf5:	e8 fc ff ff ff       	call   baf6 <ExecuteTrickle+0x116>
    bafa:	eb b7                	jmp    bab3 <ExecuteTrickle+0xd3>
    bafc:	ff 05 b4 b4 0e 00    	incl   0xeb4b4
    bb02:	51                   	push   %ecx
    bb03:	9d                   	popf   
    bb04:	31 c0                	xor    %eax,%eax
    bb06:	eb b0                	jmp    bab8 <ExecuteTrickle+0xd8>
static inline void unmarshallAckProof(AckProof *dproof, const WireAckProof *sproof) {
#define NHCONVERTLONG(X) dproof->X = ntohl(sproof->X);
#define COPYLONG(X) dproof->X = sproof->X
  int i;
  dproof->numSacks = sproof->numSacks;
    bb08:	0f b6 46 4d          	movzbl 0x4d(%esi),%eax
  for(i=0; i < sproof->numSacks; i++) {
    bb0c:	31 db                	xor    %ebx,%ebx
    bb0e:	8d bd e4 fc ff ff    	lea    0xfffffce4(%ebp),%edi
    bb14:	8d 4e 4d             	lea    0x4d(%esi),%ecx
    bb17:	89 85 e4 fc ff ff    	mov    %eax,0xfffffce4(%ebp)
    bb1d:	80 7e 4d 00          	cmpb   $0x0,0x4d(%esi)
    bb21:	74 34                	je     bb57 <ExecuteTrickle+0x177>
    bb23:	31 d2                	xor    %edx,%edx
    bb25:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    bb29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    bb30:	8b 44 11 01          	mov    0x1(%ecx,%edx,1),%eax
#define NHCONVERTLONG(X) dproof->X = ntohl(sproof->X);
#define COPYLONG(X) dproof->X = sproof->X
  int i;
  dproof->numSacks = sproof->numSacks;
  for(i=0; i < sproof->numSacks; i++) {
    bb34:	43                   	inc    %ebx

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    bb35:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    bb37:	89 44 17 08          	mov    %eax,0x8(%edi,%edx,1)
    bb3b:	8b 44 11 05          	mov    0x5(%ecx,%edx,1),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    bb3f:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    bb41:	89 44 17 0c          	mov    %eax,0xc(%edi,%edx,1)
  dproof->numSacks = sproof->numSacks;
  for(i=0; i < sproof->numSacks; i++) {
    NHCONVERTLONG(sacks[i].left);
    NHCONVERTLONG(sacks[i].right);
    COPYLONG(sacks[i].nonceSummary);
    bb45:	8b 44 11 09          	mov    0x9(%ecx,%edx,1),%eax
    bb49:	89 44 17 10          	mov    %eax,0x10(%edi,%edx,1)
    bb4d:	83 c2 0c             	add    $0xc,%edx
    bb50:	0f b6 01             	movzbl (%ecx),%eax
    bb53:	39 c3                	cmp    %eax,%ebx
    bb55:	7c d9                	jl     bb30 <ExecuteTrickle+0x150>
    bb57:	8b 45 08             	mov    0x8(%ebp),%eax
    bb5a:	8b 10                	mov    (%eax),%edx
    bb5c:	89 95 e8 fc ff ff    	mov    %edx,0xfffffce8(%ebp)
    bb62:	8b 42 20             	mov    0x20(%edx),%eax
    bb65:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    bb6b:	a9 01 00 00 00       	test   $0x1,%eax
    bb70:	74 05                	je     bb77 <ExecuteTrickle+0x197>
    bb72:	83 e0 08             	and    $0x8,%eax
    bb75:	74 4e                	je     bbc5 <ExecuteTrickle+0x1e5>
    bb77:	89 3c 24             	mov    %edi,(%esp,1)
    bb7a:	e8 fc ff ff ff       	call   bb7b <ExecuteTrickle+0x19b>
    bb7f:	85 c0                	test   %eax,%eax
    bb81:	75 3d                	jne    bbc0 <ExecuteTrickle+0x1e0>
    bb83:	8b 55 0c             	mov    0xc(%ebp),%edx
    bb86:	8b 42 0c             	mov    0xc(%edx),%eax
    bb89:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    bb8f:	a9 01 00 00 00       	test   $0x1,%eax
    bb94:	0f 84 22 ff ff ff    	je     babc <ExecuteTrickle+0xdc>
    bb9a:	83 e0 08             	and    $0x8,%eax
    bb9d:	0f 85 19 ff ff ff    	jne    babc <ExecuteTrickle+0xdc>
    bba3:	8b 3d 00 00 00 00    	mov    0x0,%edi
    bba9:	85 ff                	test   %edi,%edi
    bbab:	0f 84 0b ff ff ff    	je     babc <ExecuteTrickle+0xdc>
    bbb1:	c7 04 24 6f 06 00 00 	movl   $0x66f,(%esp,1)
    bbb8:	e9 16 ff ff ff       	jmp    bad3 <ExecuteTrickle+0xf3>
    bbbd:	8d 76 00             	lea    0x0(%esi),%esi
    bbc0:	8b 4d 08             	mov    0x8(%ebp),%ecx
    bbc3:	8b 11                	mov    (%ecx),%edx
    bbc5:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    bbcc:	0f 8f f7 02 00 00    	jg     bec9 <ExecuteTrickle+0x4e9>
    bbd2:	8b 42 34             	mov    0x34(%edx),%eax
    bbd5:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    bbd9:	8b 42 70             	mov    0x70(%edx),%eax
    bbdc:	89 3c 24             	mov    %edi,(%esp,1)
    bbdf:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    bbe3:	e8 fc ff ff ff       	call   bbe4 <ExecuteTrickle+0x204>
    bbe8:	89 c3                	mov    %eax,%ebx
    bbea:	0f b6 06             	movzbl (%esi),%eax
    bbed:	85 c0                	test   %eax,%eax
    bbef:	0f 84 a0 00 00 00    	je     bc95 <ExecuteTrickle+0x2b5>
    bbf5:	48                   	dec    %eax
    bbf6:	74 17                	je     bc0f <ExecuteTrickle+0x22f>
    bbf8:	c7 04 24 8b 06 00 00 	movl   $0x68b,(%esp,1)
    bbff:	e8 fc ff ff ff       	call   bc00 <ExecuteTrickle+0x220>
    bc04:	8b 85 dc fc ff ff    	mov    0xfffffcdc(%ebp),%eax
    bc0a:	e9 b2 fe ff ff       	jmp    bac1 <ExecuteTrickle+0xe1>
    bc0f:	8b 4d 08             	mov    0x8(%ebp),%ecx
    bc12:	a1 00 00 00 00       	mov    0x0,%eax
    bc17:	8b 11                	mov    (%ecx),%edx
    bc19:	8b 4a 4c             	mov    0x4c(%edx),%ecx
    bc1c:	29 c8                	sub    %ecx,%eax
    bc1e:	c1 e0 03             	shl    $0x3,%eax
    bc21:	89 42 54             	mov    %eax,0x54(%edx)
    bc24:	a1 00 00 00 00       	mov    0x0,%eax
    bc29:	85 c0                	test   %eax,%eax
    bc2b:	7e 14                	jle    bc41 <ExecuteTrickle+0x261>
    bc2d:	c7 04 24 a3 06 00 00 	movl   $0x6a3,(%esp,1)
    bc34:	e8 fc ff ff ff       	call   bc35 <ExecuteTrickle+0x255>
    bc39:	89 3c 24             	mov    %edi,(%esp,1)
    bc3c:	e8 fc ff ff ff       	call   bc3d <ExecuteTrickle+0x25d>
    bc41:	8b 55 08             	mov    0x8(%ebp),%edx
    bc44:	8b 02                	mov    (%edx),%eax
    bc46:	8b 40 70             	mov    0x70(%eax),%eax
    bc49:	89 3c 24             	mov    %edi,(%esp,1)
    bc4c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    bc50:	e8 fc ff ff ff       	call   bc51 <ExecuteTrickle+0x271>
    bc55:	8b 4d 08             	mov    0x8(%ebp),%ecx
    bc58:	89 c2                	mov    %eax,%edx
    bc5a:	8b 01                	mov    (%ecx),%eax
    bc5c:	3b 50 70             	cmp    0x70(%eax),%edx
    bc5f:	73 0c                	jae    bc6d <ExecuteTrickle+0x28d>
    bc61:	c7 04 24 e0 31 00 00 	movl   $0x31e0,(%esp,1)
    bc68:	e9 66 fe ff ff       	jmp    bad3 <ExecuteTrickle+0xf3>
    bc6d:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
    bc71:	8b 45 10             	mov    0x10(%ebp),%eax
    bc74:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    bc78:	8d 42 01             	lea    0x1(%edx),%eax
    bc7b:	8b 55 08             	mov    0x8(%ebp),%edx
    bc7e:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    bc82:	89 14 24             	mov    %edx,(%esp,1)
    bc85:	e8 66 15 00 00       	call   d1f0 <DoSlowStartStep>
    bc8a:	89 85 dc fc ff ff    	mov    %eax,0xfffffcdc(%ebp)
    bc90:	e9 6f ff ff ff       	jmp    bc04 <ExecuteTrickle+0x224>
    bc95:	8b 55 08             	mov    0x8(%ebp),%edx
    bc98:	8b 0a                	mov    (%edx),%ecx
    bc9a:	8b 41 54             	mov    0x54(%ecx),%eax
    bc9d:	89 c2                	mov    %eax,%edx
    bc9f:	c1 ea 03             	shr    $0x3,%edx
    bca2:	29 d0                	sub    %edx,%eax
    bca4:	89 41 54             	mov    %eax,0x54(%ecx)
    bca7:	8b 4d 08             	mov    0x8(%ebp),%ecx
    bcaa:	a1 00 00 00 00       	mov    0x0,%eax
    bcaf:	8b 11                	mov    (%ecx),%edx
    bcb1:	8b 72 4c             	mov    0x4c(%edx),%esi
    bcb4:	29 f0                	sub    %esi,%eax
    bcb6:	01 42 54             	add    %eax,0x54(%edx)
    bcb9:	8b 01                	mov    (%ecx),%eax
    bcbb:	8b 40 58             	mov    0x58(%eax),%eax
    bcbe:	83 f8 01             	cmp    $0x1,%eax
    bcc1:	0f 84 e9 01 00 00    	je     beb0 <ExecuteTrickle+0x4d0>
    bcc7:	83 f8 01             	cmp    $0x1,%eax
    bcca:	0f 82 53 01 00 00    	jb     be23 <ExecuteTrickle+0x443>
    bcd0:	83 f8 02             	cmp    $0x2,%eax
    bcd3:	0f 85 2b ff ff ff    	jne    bc04 <ExecuteTrickle+0x224>
    bcd9:	a1 00 00 00 00       	mov    0x0,%eax
    bcde:	85 c0                	test   %eax,%eax
    bce0:	7e 0c                	jle    bcee <ExecuteTrickle+0x30e>
    bce2:	c7 04 24 20 32 00 00 	movl   $0x3220,(%esp,1)
    bce9:	e8 fc ff ff ff       	call   bcea <ExecuteTrickle+0x30a>
    bcee:	85 db                	test   %ebx,%ebx
    bcf0:	0f 84 1a 01 00 00    	je     be10 <ExecuteTrickle+0x430>
    bcf6:	85 db                	test   %ebx,%ebx
    bcf8:	7e 77                	jle    bd71 <ExecuteTrickle+0x391>
    bcfa:	4b                   	dec    %ebx
    bcfb:	74 0c                	je     bd09 <ExecuteTrickle+0x329>
    bcfd:	c7 04 24 bb 06 00 00 	movl   $0x6bb,(%esp,1)
    bd04:	e9 ca fd ff ff       	jmp    bad3 <ExecuteTrickle+0xf3>
    bd09:	a1 00 00 00 00       	mov    0x0,%eax
    bd0e:	85 c0                	test   %eax,%eax
    bd10:	7e 0c                	jle    bd1e <ExecuteTrickle+0x33e>
    bd12:	c7 04 24 cc 06 00 00 	movl   $0x6cc,(%esp,1)
    bd19:	e8 fc ff ff ff       	call   bd1a <ExecuteTrickle+0x33a>
    bd1e:	8b 4d 08             	mov    0x8(%ebp),%ecx
    bd21:	8b 11                	mov    (%ecx),%edx
    bd23:	8b 42 64             	mov    0x64(%edx),%eax
    bd26:	89 42 70             	mov    %eax,0x70(%edx)
    bd29:	8b 35 00 00 00 00    	mov    0x0,%esi
    bd2f:	85 f6                	test   %esi,%esi
    bd31:	7e 23                	jle    bd56 <ExecuteTrickle+0x376>
    bd33:	8b 11                	mov    (%ecx),%edx
    bd35:	8b 42 6c             	mov    0x6c(%edx),%eax
    bd38:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    bd3c:	8b 42 68             	mov    0x68(%edx),%eax
    bd3f:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    bd43:	8b 42 70             	mov    0x70(%edx),%eax
    bd46:	c7 04 24 60 32 00 00 	movl   $0x3260,(%esp,1)
    bd4d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    bd51:	e8 fc ff ff ff       	call   bd52 <ExecuteTrickle+0x372>
    bd56:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
    bd5a:	8b 45 10             	mov    0x10(%ebp),%eax
    bd5d:	8b 55 08             	mov    0x8(%ebp),%edx
    bd60:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    bd64:	89 14 24             	mov    %edx,(%esp,1)
    bd67:	e8 14 08 00 00       	call   c580 <DoNormalStep>
    bd6c:	e9 19 ff ff ff       	jmp    bc8a <ExecuteTrickle+0x2aa>
    bd71:	43                   	inc    %ebx
    bd72:	75 89                	jne    bcfd <ExecuteTrickle+0x31d>
    bd74:	a1 00 00 00 00       	mov    0x0,%eax
    bd79:	85 c0                	test   %eax,%eax
    bd7b:	7e 0c                	jle    bd89 <ExecuteTrickle+0x3a9>
    bd7d:	c7 04 24 dc 06 00 00 	movl   $0x6dc,(%esp,1)
    bd84:	e8 fc ff ff ff       	call   bd85 <ExecuteTrickle+0x3a5>
    bd89:	8b 4d 08             	mov    0x8(%ebp),%ecx
    bd8c:	8b 11                	mov    (%ecx),%edx
    bd8e:	8b 42 60             	mov    0x60(%edx),%eax
    bd91:	48                   	dec    %eax
    bd92:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    bd96:	8b 42 70             	mov    0x70(%edx),%eax
    bd99:	89 3c 24             	mov    %edi,(%esp,1)
    bd9c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    bda0:	e8 fc ff ff ff       	call   bda1 <ExecuteTrickle+0x3c1>
    bda5:	48                   	dec    %eax
    bda6:	74 44                	je     bdec <ExecuteTrickle+0x40c>
    bda8:	c7 04 24 a0 32 00 00 	movl   $0x32a0,(%esp,1)
    bdaf:	e8 fc ff ff ff       	call   bdb0 <ExecuteTrickle+0x3d0>
    bdb4:	a1 00 00 00 00       	mov    0x0,%eax
    bdb9:	85 c0                	test   %eax,%eax
    bdbb:	7e 14                	jle    bdd1 <ExecuteTrickle+0x3f1>
    bdbd:	c7 04 24 ee 06 00 00 	movl   $0x6ee,(%esp,1)
    bdc4:	e8 fc ff ff ff       	call   bdc5 <ExecuteTrickle+0x3e5>
    bdc9:	89 3c 24             	mov    %edi,(%esp,1)
    bdcc:	e8 fc ff ff ff       	call   bdcd <ExecuteTrickle+0x3ed>
    bdd1:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
    bdd5:	8b 4d 10             	mov    0x10(%ebp),%ecx
    bdd8:	8b 45 08             	mov    0x8(%ebp),%eax
    bddb:	89 4c 24 08          	mov    %ecx,0x8(%esp,1)
    bddf:	89 04 24             	mov    %eax,(%esp,1)
    bde2:	e8 d9 0b 00 00       	call   c9c0 <DoRecoveryStep>
    bde7:	e9 9e fe ff ff       	jmp    bc8a <ExecuteTrickle+0x2aa>
    bdec:	8b 45 08             	mov    0x8(%ebp),%eax
    bdef:	8b 10                	mov    (%eax),%edx
    bdf1:	8b 42 34             	mov    0x34(%edx),%eax
    bdf4:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    bdf8:	8b 42 64             	mov    0x64(%edx),%eax
    bdfb:	89 3c 24             	mov    %edi,(%esp,1)
    bdfe:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    be02:	e8 fc ff ff ff       	call   be03 <ExecuteTrickle+0x423>
    be07:	48                   	dec    %eax
    be08:	75 9e                	jne    bda8 <ExecuteTrickle+0x3c8>
    be0a:	e9 fa fe ff ff       	jmp    bd09 <ExecuteTrickle+0x329>
    be0f:	90                   	nop    
    be10:	8b 1d 00 00 00 00    	mov    0x0,%ebx
    be16:	85 db                	test   %ebx,%ebx
    be18:	7e b7                	jle    bdd1 <ExecuteTrickle+0x3f1>
    be1a:	c7 04 24 05 07 00 00 	movl   $0x705,(%esp,1)
    be21:	eb 8c                	jmp    bdaf <ExecuteTrickle+0x3cf>
    be23:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    be2a:	7f 73                	jg     be9f <ExecuteTrickle+0x4bf>
    be2c:	83 fb ff             	cmp    $0xffffffff,%ebx
    be2f:	0f 8c cf fd ff ff    	jl     bc04 <ExecuteTrickle+0x224>
    be35:	85 db                	test   %ebx,%ebx
    be37:	7e 25                	jle    be5e <ExecuteTrickle+0x47e>
    be39:	4b                   	dec    %ebx
    be3a:	0f 85 c4 fd ff ff    	jne    bc04 <ExecuteTrickle+0x224>
    be40:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    be47:	0f 8e 09 ff ff ff    	jle    bd56 <ExecuteTrickle+0x376>
    be4d:	c7 04 24 cc 06 00 00 	movl   $0x6cc,(%esp,1)
    be54:	e8 fc ff ff ff       	call   be55 <ExecuteTrickle+0x475>
    be59:	e9 f8 fe ff ff       	jmp    bd56 <ExecuteTrickle+0x376>
    be5e:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    be65:	7f 16                	jg     be7d <ExecuteTrickle+0x49d>
    be67:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
    be6b:	8b 45 10             	mov    0x10(%ebp),%eax
    be6e:	8b 55 08             	mov    0x8(%ebp),%edx
    be71:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    be75:	89 14 24             	mov    %edx,(%esp,1)
    be78:	e9 65 ff ff ff       	jmp    bde2 <ExecuteTrickle+0x402>
    be7d:	8b 4d 08             	mov    0x8(%ebp),%ecx
    be80:	8b 01                	mov    (%ecx),%eax
    be82:	8b 40 34             	mov    0x34(%eax),%eax
    be85:	c7 04 24 e0 32 00 00 	movl   $0x32e0,(%esp,1)
    be8c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    be90:	e8 fc ff ff ff       	call   be91 <ExecuteTrickle+0x4b1>
    be95:	89 3c 24             	mov    %edi,(%esp,1)
    be98:	e8 fc ff ff ff       	call   be99 <ExecuteTrickle+0x4b9>
    be9d:	eb c8                	jmp    be67 <ExecuteTrickle+0x487>
    be9f:	c7 04 24 20 33 00 00 	movl   $0x3320,(%esp,1)
    bea6:	e8 fc ff ff ff       	call   bea7 <ExecuteTrickle+0x4c7>
    beab:	e9 7c ff ff ff       	jmp    be2c <ExecuteTrickle+0x44c>
    beb0:	a1 00 00 00 00       	mov    0x0,%eax
    beb5:	85 c0                	test   %eax,%eax
    beb7:	0f 8e 47 fd ff ff    	jle    bc04 <ExecuteTrickle+0x224>
    bebd:	c7 04 24 40 33 00 00 	movl   $0x3340,(%esp,1)
    bec4:	e9 36 fd ff ff       	jmp    bbff <ExecuteTrickle+0x21f>
    bec9:	8b 42 34             	mov    0x34(%edx),%eax
    becc:	c7 04 24 12 07 00 00 	movl   $0x712,(%esp,1)
    bed3:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    bed7:	e8 fc ff ff ff       	call   bed8 <ExecuteTrickle+0x4f8>
    bedc:	89 3c 24             	mov    %edi,(%esp,1)
    bedf:	e8 fc ff ff ff       	call   bee0 <ExecuteTrickle+0x500>
    bee4:	8b 45 08             	mov    0x8(%ebp),%eax
    bee7:	8b 10                	mov    (%eax),%edx
    bee9:	e9 e4 fc ff ff       	jmp    bbd2 <ExecuteTrickle+0x1f2>
    beee:	89 f6                	mov    %esi,%esi
    bef0:	8b 85 e0 fc ff ff    	mov    0xfffffce0(%ebp),%eax
    bef6:	83 f8 16             	cmp    $0x16,%eax
    bef9:	74 23                	je     bf1e <ExecuteTrickle+0x53e>
    befb:	83 f8 0c             	cmp    $0xc,%eax
    befe:	74 14                	je     bf14 <ExecuteTrickle+0x534>
    bf00:	c7 44 24 04 ab 02 00 	movl   $0x2ab,0x4(%esp,1)
    bf07:	00 
    bf08:	c7 04 24 80 33 00 00 	movl   $0x3380,(%esp,1)
    bf0f:	e8 fc ff ff ff       	call   bf10 <ExecuteTrickle+0x530>
    bf14:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
    bf19:	e9 a3 fb ff ff       	jmp    bac1 <ExecuteTrickle+0xe1>
    bf1e:	a1 00 00 00 00       	mov    0x0,%eax
    bf23:	9c                   	pushf  
    bf24:	59                   	pop    %ecx
    bf25:	fa                   	cli    
    bf26:	89 c2                	mov    %eax,%edx
    bf28:	8b 35 a8 b4 0e 00    	mov    0xeb4a8,%esi
    bf2e:	8b 1d 10 01 00 00    	mov    0x110,%ebx
    bf34:	a3 a8 b4 0e 00       	mov    %eax,0xeb4a8
    bf39:	29 f2                	sub    %esi,%edx
    bf3b:	01 da                	add    %ebx,%edx
    bf3d:	89 15 10 01 00 00    	mov    %edx,0x110
    bf43:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    bf49:	76 10                	jbe    bf5b <ExecuteTrickle+0x57b>
    bf4b:	bf 88 13 00 00       	mov    $0x1388,%edi
    bf50:	ba 88 13 00 00       	mov    $0x1388,%edx
    bf55:	89 3d 10 01 00 00    	mov    %edi,0x110
    bf5b:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    bf61:	76 5a                	jbe    bfbd <ExecuteTrickle+0x5dd>
    bf63:	31 f6                	xor    %esi,%esi
    bf65:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    bf6b:	a1 ac b4 0e 00       	mov    0xeb4ac,%eax
    bf70:	89 15 10 01 00 00    	mov    %edx,0x110
    bf76:	89 35 ac b4 0e 00    	mov    %esi,0xeb4ac
    bf7c:	51                   	push   %ecx
    bf7d:	9d                   	popf   
    bf7e:	85 c0                	test   %eax,%eax
    bf80:	75 19                	jne    bf9b <ExecuteTrickle+0x5bb>
    bf82:	b8 01 00 00 00       	mov    $0x1,%eax
    bf87:	85 c0                	test   %eax,%eax
    bf89:	0f 84 2d fb ff ff    	je     babc <ExecuteTrickle+0xdc>
    bf8f:	c7 04 24 e0 33 00 00 	movl   $0x33e0,(%esp,1)
    bf96:	e9 38 fb ff ff       	jmp    bad3 <ExecuteTrickle+0xf3>
    bf9b:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    bf9f:	c7 44 24 08 a6 02 00 	movl   $0x2a6,0x8(%esp,1)
    bfa6:	00 
    bfa7:	c7 44 24 04 04 06 00 	movl   $0x604,0x4(%esp,1)
    bfae:	00 
    bfaf:	c7 04 24 00 30 00 00 	movl   $0x3000,(%esp,1)
    bfb6:	e8 fc ff ff ff       	call   bfb7 <ExecuteTrickle+0x5d7>
    bfbb:	eb c5                	jmp    bf82 <ExecuteTrickle+0x5a2>
    bfbd:	ff 05 ac b4 0e 00    	incl   0xeb4ac
    bfc3:	51                   	push   %ecx
    bfc4:	9d                   	popf   
    bfc5:	31 c0                	xor    %eax,%eax
    bfc7:	eb be                	jmp    bf87 <ExecuteTrickle+0x5a7>
    bfc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi

0000bfd0 <msk_transmit_skb>:

int msk_transmit_skb(struct cminisock *msk, struct sk_buff *skb, int packet_num) {
    bfd0:	55                   	push   %ebp
    bfd1:	89 e5                	mov    %esp,%ebp
    bfd3:	57                   	push   %edi
    bfd4:	56                   	push   %esi
    bfd5:	53                   	push   %ebx
    bfd6:	83 ec 34             	sub    $0x34,%esp
	int tcp_header_size;
	struct tcphdr *th;
	struct sock *sk;

#ifdef FORCE_MSK_TRANSMIT_REORDERING
	static struct sk_buff *reorder_skb = NULL;
#endif

#ifndef USERTEST
	struct tcp_func *af = &ipv4_specific;
#endif

	struct WireTrickleResponse *resp_hdr;
	int err;
	int ucontLen = msk->packets[packet_num].ucontLen;
    bfd9:	8b 45 08             	mov    0x8(%ebp),%eax
    bfdc:	8b 4d 10             	mov    0x10(%ebp),%ecx
    bfdf:	8b 90 e0 00 00 00    	mov    0xe0(%eax),%edx
    bfe5:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
	int origSkbLen = skb->len;

	sk = skb->sk = msk->sk;
    bfe8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    bfeb:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
    bff2:	8b 45 0c             	mov    0xc(%ebp),%eax
    bff5:	8b 54 1a 14          	mov    0x14(%edx,%ebx,1),%edx
    bff9:	89 55 f0             	mov    %edx,0xfffffff0(%ebp)
    bffc:	8b 55 08             	mov    0x8(%ebp),%edx
    bfff:	8b 40 70             	mov    0x70(%eax),%eax
    c002:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    c005:	8b 52 20             	mov    0x20(%edx),%edx
    c008:	89 55 e8             	mov    %edx,0xffffffe8(%ebp)
    c00b:	89 51 0c             	mov    %edx,0xc(%ecx)

	//printk("msk_transmit_skb: skb len(%d) stcp len(%d)\n", skb->len, tcb->stcp_len);
	if(userapi_time_spew)
    c00e:	a1 00 00 00 00       	mov    0x0,%eax
    c013:	85 c0                	test   %eax,%eax
    c015:	0f 85 35 05 00 00    	jne    c550 <msk_transmit_skb+0x580>
		printk("transmit time: %lu\n", jiffies);
	msk->timestamp = jiffies;
    c01b:	a1 00 00 00 00       	mov    0x0,%eax
    c020:	8b 55 08             	mov    0x8(%ebp),%edx
    c023:	89 42 4c             	mov    %eax,0x4c(%edx)

	/* UCONT handling */
	BUG_TRAP(ucontLen >= 0);
    c026:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    c029:	85 c0                	test   %eax,%eax
    c02b:	0f 88 ff 04 00 00    	js     c530 <msk_transmit_skb+0x560>
	if(ucontLen > 0) {
    c031:	8b 7d f0             	mov    0xfffffff0(%ebp),%edi
    c034:	85 ff                	test   %edi,%edi
    c036:	0f 8e e4 04 00 00    	jle    c520 <msk_transmit_skb+0x550>
		if(msk->packets[packet_num].ucontData != NULL) {
    c03c:	8b 4d 08             	mov    0x8(%ebp),%ecx
    c03f:	8b 91 e0 00 00 00    	mov    0xe0(%ecx),%edx
    c045:	8b 74 1a 18          	mov    0x18(%edx,%ebx,1),%esi
    c049:	85 f6                	test   %esi,%esi
    c04b:	74 5b                	je     c0a8 <msk_transmit_skb+0xd8>
 */

static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
    c04d:	8b 55 0c             	mov    0xc(%ebp),%edx
    c050:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    c053:	8b 82 94 00 00 00    	mov    0x94(%edx),%eax
    c059:	29 c8                	sub    %ecx,%eax
    c05b:	89 82 94 00 00 00    	mov    %eax,0x94(%edx)
	skb->len+=len;
    c061:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    c064:	01 4a 70             	add    %ecx,0x70(%edx)
	if(skb->data<skb->head) {
    c067:	3b 82 90 00 00 00    	cmp    0x90(%edx),%eax
    c06d:	0f 82 8d 04 00 00    	jb     c500 <msk_transmit_skb+0x530>
		skb_under_panic(skb, len, current_text_addr());
	}
    c073:	8b 45 0c             	mov    0xc(%ebp),%eax
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
    c076:	8b 55 08             	mov    0x8(%ebp),%edx
int d0, d1, d2;
__asm__ __volatile__(
    c079:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
	skb->data-=len;
	skb->len+=len;
	if(skb->data<skb->head) {
		skb_under_panic(skb, len, current_text_addr());
	}
    c07c:	8b b8 94 00 00 00    	mov    0x94(%eax),%edi
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
    c082:	8b 82 e0 00 00 00    	mov    0xe0(%edx),%eax
int d0, d1, d2;
__asm__ __volatile__(
    c088:	c1 e9 02             	shr    $0x2,%ecx
    c08b:	8b 74 18 18          	mov    0x18(%eax,%ebx,1),%esi
    c08f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    c092:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    c094:	a8 02                	test   $0x2,%al
    c096:	74 02                	je     c09a <msk_transmit_skb+0xca>
    c098:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    c09a:	a8 01                	test   $0x1,%al
    c09c:	74 01                	je     c09f <msk_transmit_skb+0xcf>
    c09e:	a4                   	movsb  %ds:(%esi),%es:(%edi)
    c09f:	8b 4d 08             	mov    0x8(%ebp),%ecx
    c0a2:	8b 91 e0 00 00 00    	mov    0xe0(%ecx),%edx
			memcpy(skb_push(skb, ucontLen),
			       msk->packets[packet_num].ucontData, ucontLen);
		} else {
			// Do nothing; already in the packet
		}
	}

	if(msk->packets[packet_num].contType & CONTTYPE_HASHCOMPRESSED) {
    c0a8:	8b 4d 10             	mov    0x10(%ebp),%ecx
    c0ab:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
    c0ae:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
    c0b5:	0f b6 44 32 10       	movzbl 0x10(%edx,%esi,1),%eax
    c0ba:	c0 e8 03             	shr    $0x3,%al
#ifdef ENABLE_HASHCOMPRESS
		int fullType;
		struct WireContinuation *wcont;
		static struct WireContinuation scratch[NR_CPUS]; // avoid stack allocation (which risks stack overflow), and kmalloc, which is inefficient
		struct WireContinuation *wc_scratch = &scratch[smp_processor_id()];

		resp_hdr = (WireTrickleResponse*)skb_push(skb, RESPONSELEN_HASHCOMPRESS);
		wcont = &resp_hdr->cont;
		
		/* mask off hashcompressed bit to verify type */
		msk->packets[packet_num].contType &= ~CONTTYPE_HASHCOMPRESSED;
		fullType = msk->packets[packet_num].contType == CONTTYPE_FULL1 ||
			msk->packets[packet_num].contType == CONTTYPE_FULL2;
		BUG_TRAP(fullType ||
			 msk->packets[packet_num].contType == CONTTYPE_MINIMAL);
		// restore hashcompressed bit
		msk->packets[packet_num].contType |= CONTTYPE_HASHCOMPRESSED;

		wcont->continuationType = msk->packets[packet_num].contType;
		wcont->hash.timestamp = htonl(msk->timestamp);
		wcont->hash.mrtt = htonl(msk->mrtt);
		wcont->hash.parentSeq = msk->seq;
		wcont->hash.clientState = msk->clientState;
		wcont->hash.position = packet_num;

		// marshall continuation to get mac value
		if(fullType) {
			// do this for all "FULL" continuation types
			msk->packets[packet_num].contType &= ~CONTTYPE_HASHCOMPRESSED;
			marshallContinuationServer(sk, wc_scratch, msk, packet_num);
			msk->packets[packet_num].contType |= CONTTYPE_HASHCOMPRESSED;

			memcpy(wcont->hash.mac, wc_scratch->mac, HMACLEN);
		}
#else
		printk("msk_transmit_skb: hash compress not enabled\n");
		BUG();
#endif
	} else {
		switch(msk->packets[packet_num].contType) {
    c0bd:	83 e0 07             	and    $0x7,%eax
    c0c0:	0f 84 cc 03 00 00    	je     c492 <msk_transmit_skb+0x4c2>
    c0c6:	83 f8 02             	cmp    $0x2,%eax
    c0c9:	0f 8f a3 03 00 00    	jg     c472 <msk_transmit_skb+0x4a2>
 */

static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
    c0cf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    c0d2:	8b 81 94 00 00 00    	mov    0x94(%ecx),%eax
	skb->len+=len;
    c0d8:	83 41 70 56          	addl   $0x56,0x70(%ecx)
    c0dc:	83 e8 56             	sub    $0x56,%eax
	if(skb->data<skb->head) {
    c0df:	3b 81 90 00 00 00    	cmp    0x90(%ecx),%eax
    c0e5:	89 81 94 00 00 00    	mov    %eax,0x94(%ecx)
    c0eb:	0f 82 64 03 00 00    	jb     c455 <msk_transmit_skb+0x485>
		skb_under_panic(skb, len, current_text_addr());
	}
    c0f1:	8b 45 0c             	mov    0xc(%ebp),%eax
		case CONTTYPE_MINIMAL:
			resp_hdr = (WireTrickleResponse*)skb_push(skb, RESPONSELEN_MINIMAL);
			resp_hdr->cont.seq = htonl(msk->packets[packet_num].seq);
			resp_hdr->cont.continuationType = CONTTYPE_MINIMAL;
			resp_hdr->cont.clientState = msk->clientState;
			resp_hdr->cont.parent = msk->parent;
			resp_hdr->cont.clientTimestamp = msk->clientTimestamp;
			break;
		case CONTTYPE_FULL1:
		case CONTTYPE_FULL2:
			/* Generate Trickle header */
			resp_hdr = (WireTrickleResponse*)skb_push(skb, sizeof(WireTrickleResponse));
			marshallContinuationServer(sk, &resp_hdr->cont, msk, packet_num);
    c0f4:	8b 55 10             	mov    0x10(%ebp),%edx
    c0f7:	8b 4d 08             	mov    0x8(%ebp),%ecx
	skb->data-=len;
	skb->len+=len;
	if(skb->data<skb->head) {
		skb_under_panic(skb, len, current_text_addr());
	}
    c0fa:	8b 98 94 00 00 00    	mov    0x94(%eax),%ebx
    c100:	89 54 24 0c          	mov    %edx,0xc(%esp,1)
    c104:	89 4c 24 08          	mov    %ecx,0x8(%esp,1)
    c108:	8d 43 0c             	lea    0xc(%ebx),%eax
    c10b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    c10f:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    c112:	89 04 24             	mov    %eax,(%esp,1)
    c115:	e8 96 17 00 00       	call   d8b0 <marshallContinuationServer>
			break;
		default:
			resp_hdr = NULL;
			BUG();
		}
	}
	resp_hdr->nonce = msk->packets[packet_num].nonce;
    c11a:	8b 4d 08             	mov    0x8(%ebp),%ecx
    c11d:	8b 91 e0 00 00 00    	mov    0xe0(%ecx),%edx
    c123:	8b 4d 10             	mov    0x10(%ebp),%ecx
    c126:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
    c129:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
    c130:	8b 04 32             	mov    (%edx,%esi,1),%eax
    c133:	89 03                	mov    %eax,(%ebx)

	resp_hdr->ucont_len = htons((short)ucontLen);
    c135:	0f b7 45 f0          	movzwl 0xfffffff0(%ebp),%eax
/* gcc should generate this for open coded C now too. May be worth switching to 
   it because inline assembly cannot be scheduled. -AK */
static __inline__ __const__ __u16 ___arch__swab16(__u16 x)
{
	__asm__("xchgb %b0,%h0"		/* swap bytes		*/
    c139:	86 c4                	xchg   %al,%ah
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
    c13b:	66 89 43 0a          	mov    %ax,0xa(%ebx)
	resp_hdr->byteNum = htonl(msk->packets[packet_num].byteNum);
    c13f:	8b 55 08             	mov    0x8(%ebp),%edx
    c142:	8b 82 e0 00 00 00    	mov    0xe0(%edx),%eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    c148:	8b 44 30 0c          	mov    0xc(%eax,%esi,1),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    c14c:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    c14e:	89 43 04             	mov    %eax,0x4(%ebx)
	resp_hdr->numSiblings = msk->packets[packet_num].numSiblings;
    c151:	8b 82 e0 00 00 00    	mov    0xe0(%edx),%eax
    c157:	0f b6 44 30 11       	movzbl 0x11(%eax,%esi,1),%eax
    c15c:	88 43 08             	mov    %al,0x8(%ebx)
	resp_hdr->position = msk->packets[packet_num].position;
    c15f:	8b 82 e0 00 00 00    	mov    0xe0(%edx),%eax
    c165:	0f b6 44 30 12       	movzbl 0x12(%eax,%esi,1),%eax
    c16a:	88 43 09             	mov    %al,0x9(%ebx)
 */

static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
    c16d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    c170:	8b 81 94 00 00 00    	mov    0x94(%ecx),%eax
	skb->len+=len;
    c176:	83 41 70 18          	addl   $0x18,0x70(%ecx)
    c17a:	83 e8 18             	sub    $0x18,%eax
	if(skb->data<skb->head) {
    c17d:	3b 81 90 00 00 00    	cmp    0x90(%ecx),%eax
    c183:	89 81 94 00 00 00    	mov    %eax,0x94(%ecx)
    c189:	0f 82 a9 02 00 00    	jb     c438 <msk_transmit_skb+0x468>
		skb_under_panic(skb, len, current_text_addr());
	}
    c18f:	8b 45 0c             	mov    0xc(%ebp),%eax
    c192:	8b 98 94 00 00 00    	mov    0x94(%eax),%ebx

	//printk("transmit_skb - resp_hdr: %p, ucont_len\n", &resp_hdr->cont, ntohs(resp_hdr->ucont_len));

	tcp_header_size = sizeof(struct tcphdr) + TCPOLEN_TRICKLES;
	th = (struct tcphdr *) skb_push(skb, tcp_header_size);
	skb->h.th = th;
    c198:	89 58 20             	mov    %ebx,0x20(%eax)
	th->source = sk->sport;
    c19b:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    c19e:	0f b7 42 22          	movzwl 0x22(%edx),%eax
    c1a2:	66 89 03             	mov    %ax,(%ebx)
	th->dest = msk->dest;
    c1a5:	8b 4d 08             	mov    0x8(%ebp),%ecx
    c1a8:	0f b7 41 1e          	movzwl 0x1e(%ecx),%eax
    c1ac:	66 89 43 02          	mov    %ax,0x2(%ebx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    c1b0:	8b 41 34             	mov    0x34(%ecx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    c1b3:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    c1b5:	89 43 04             	mov    %eax,0x4(%ebx)

	th->seq = htonl(msk->seq);

	// 0615 - mark each packet with a unique identifier so we know exactly how many packets were sent
	static int gSendPacketNumber = 0;
	// save debugging information
	if(sysctl_dbg_cwnd) {
    c1b8:	a1 00 00 00 00       	mov    0x0,%eax
    c1bd:	85 c0                	test   %eax,%eax
    c1bf:	0f 85 20 02 00 00    	jne    c3e5 <msk_transmit_skb+0x415>
		trickles_logCwnd_hook(msk->daddr, msk->dest, msk->packets[packet_num].seq,
				      gSendPacketNumber,
				      msk->startCwnd, msk->mark /* effCwnd */, msk->ssthresh,
				      msk->mrtt, msk->mrtt);
	}
#if 0
	th->ack_seq = htonl(gSendPacketNumber++);
#else
	th->ack_seq = htonl(msk->packets[packet_num].byteNum);
    c1c5:	8b 55 08             	mov    0x8(%ebp),%edx
    c1c8:	8b 82 e0 00 00 00    	mov    0xe0(%edx),%eax
#endif

	// set tcp header size and zero out flags 
	th->doff = tcp_header_size >> 2;
	th->res1= 0;
	th->cwr = 0;
	th->ece = 0;
	th->urg = 0;

	th->ack = 1;
	th->psh = 0;
	th->rst = 0;
	th->syn = 0;
	th->fin = 0;
    c1ce:	b2 10                	mov    $0x10,%dl
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    c1d0:	8b 44 30 0c          	mov    0xc(%eax,%esi,1),%eax
    c1d4:	c6 43 0c 60          	movb   $0x60,0xc(%ebx)

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    c1d8:	0f c8                	bswap  %eax
    c1da:	88 53 0d             	mov    %dl,0xd(%ebx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    c1dd:	89 43 08             	mov    %eax,0x8(%ebx)

	// TODO: Find uses for window, urg_ptr fields
	th->window = 0;
    c1e0:	66 c7 43 0e 00 00    	movw   $0x0,0xe(%ebx)
	th->check = 0;
    c1e6:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
	th->urg_ptr = 0;
    c1ec:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
	*(__u32*)(th+1) = htonl((TCPOPT_TRICKLES << 24)  | 
    c1f2:	8b 4d 08             	mov    0x8(%ebp),%ecx
    c1f5:	0f b7 41 7c          	movzwl 0x7c(%ecx),%eax
    c1f9:	83 c0 56             	add    $0x56,%eax
    c1fc:	0f b7 c0             	movzwl %ax,%eax
    c1ff:	0d 00 00 04 0b       	or     $0xb040000,%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    c204:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    c206:	89 43 14             	mov    %eax,0x14(%ebx)
				(TCPOLEN_TRICKLES << 16) |
				((__u16)(sizeof(WireTrickleResponse) + msk->ucont_len)));

	switch(msk->tag) {
    c209:	8b 41 10             	mov    0x10(%ecx),%eax
    c20c:	83 f8 01             	cmp    $0x1,%eax
    c20f:	74 1e                	je     c22f <msk_transmit_skb+0x25f>
    c211:	83 f8 01             	cmp    $0x1,%eax
    c214:	0f 82 c6 01 00 00    	jb     c3e0 <msk_transmit_skb+0x410>
    c21a:	83 f8 02             	cmp    $0x2,%eax
    c21d:	0f 84 ae 01 00 00    	je     c3d1 <msk_transmit_skb+0x401>
	case SYN:
		th->syn = 1; // send syn/ack
		th->ack = 1;
		break;
	case FIN:
		th->fin = 1;
		break;
	case ACK:
		break;
	default:
		printk("msk_transmit_skb: unsupported event tag\n");
    c223:	c7 04 24 20 34 00 00 	movl   $0x3420,(%esp,1)
    c22a:	e8 fc ff ff ff       	call   c22b <msk_transmit_skb+0x25b>
	}

	numTxPackets++;
    c22f:	83 05 00 00 00 00 01 	addl   $0x1,0x0
	numTxBytes += skb->len;
    c236:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    c239:	83 15 04 00 00 00 00 	adcl   $0x0,0x4
    c240:	31 d2                	xor    %edx,%edx
    c242:	8b 41 70             	mov    0x70(%ecx),%eax
    c245:	01 05 00 00 00 00    	add    %eax,0x0

#define MINISOCK_LEN(RO_LEN) ((RO_LEN) / 2)

#ifndef USERTEST
static inline void trickles_checksum(struct sk_buff *skb, int headerLen) {
    c24b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    c24e:	11 15 04 00 00 00    	adc    %edx,0x4

#define MINISOCK_LEN(RO_LEN) ((RO_LEN) / 2)

#ifndef USERTEST
static inline void trickles_checksum(struct sk_buff *skb, int headerLen) {
    c254:	8b 51 70             	mov    0x70(%ecx),%edx
	struct sock *sk = skb->sk;
    c257:	8b 71 0c             	mov    0xc(%ecx),%esi
    c25a:	29 c2                	sub    %eax,%edx
	if(skb->ip_summed == CHECKSUM_HW) {
    c25c:	80 79 7f 01          	cmpb   $0x1,0x7f(%ecx)
    c260:	0f 84 1b 01 00 00    	je     c381 <msk_transmit_skb+0x3b1>
		skb->h.th->check = 0;
		skb->h.th->check = ~tcp_v4_check(skb->h.th, skb->len, sk->saddr, sk->daddr,
					 0);
		skb->csum = offsetof(struct tcphdr, check);
	} else {
		skb->h.th->check = 0;
    c266:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    c269:	8b 41 20             	mov    0x20(%ecx),%eax
    c26c:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
		skb->h.th->check = tcp_v4_check(skb->h.th, skb->len, sk->saddr, sk->daddr, 
    c272:	8b 41 20             	mov    0x20(%ecx),%eax
    c275:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
 */
static __inline__ u16 tcp_v4_check(struct tcphdr *th, int len,
				   unsigned long saddr, unsigned long daddr, 
				   unsigned long base)
{
    c278:	8b 59 70             	mov    0x70(%ecx),%ebx
    c27b:	8b 7e 70             	mov    0x70(%esi),%edi
    c27e:	8b 41 78             	mov    0x78(%ecx),%eax
    c281:	8b 36                	mov    (%esi),%esi
						   unsigned long daddr,
						   unsigned short len,
						   unsigned short proto,
						   unsigned int sum)
{
    c283:	0f b7 db             	movzwl %bx,%ebx
 */
static __inline__ u16 tcp_v4_check(struct tcphdr *th, int len,
				   unsigned long saddr, unsigned long daddr, 
				   unsigned long base)
{
    c286:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    c28a:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
/* gcc should generate this for open coded C now too. May be worth switching to 
   it because inline assembly cannot be scheduled. -AK */
static __inline__ __const__ __u16 ___arch__swab16(__u16 x)
{
	__asm__("xchgb %b0,%h0"		/* swap bytes		*/
    c28d:	86 df                	xchg   %bl,%bh
 */
static __inline__ u16 tcp_v4_check(struct tcphdr *th, int len,
				   unsigned long saddr, unsigned long daddr, 
				   unsigned long base)
{
    c28f:	89 44 24 08          	mov    %eax,0x8(%esp,1)
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
    c293:	c1 e3 10             	shl    $0x10,%ebx
    c296:	81 c3 00 06 00 00    	add    $0x600,%ebx
 */
static __inline__ u16 tcp_v4_check(struct tcphdr *th, int len,
				   unsigned long saddr, unsigned long daddr, 
				   unsigned long base)
{
    c29c:	89 14 24             	mov    %edx,(%esp,1)
    c29f:	e8 fc ff ff ff       	call   c2a0 <msk_transmit_skb+0x2d0>
    c2a4:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
    c2a7:	01 f0                	add    %esi,%eax
    c2a9:	11 f8                	adc    %edi,%eax
    c2ab:	11 d8                	adc    %ebx,%eax
    c2ad:	83 d0 00             	adc    $0x0,%eax
 */

static inline unsigned int csum_fold(unsigned int sum)
{
	__asm__(
    c2b0:	89 c2                	mov    %eax,%edx
    c2b2:	81 e2 00 00 ff ff    	and    $0xffff0000,%edx
    c2b8:	c1 e0 10             	shl    $0x10,%eax
    c2bb:	01 c2                	add    %eax,%edx
    c2bd:	81 d2 ff ff 00 00    	adc    $0xffff,%edx
    c2c3:	f7 d2                	not    %edx
		"addl %1, %0		;\n"
		"adcl $0xffff, %0	;\n"
		: "=r" (sum)
		: "r" (sum << 16), "0" (sum & 0xffff0000)
	);
	return (~sum) >> 16;
}

static inline unsigned long csum_tcpudp_nofold(unsigned long saddr,
						   unsigned long daddr,
						   unsigned short len,
						   unsigned short proto,
						   unsigned int sum)
{
    __asm__(
	"addl %1, %0	;\n"
	"adcl %2, %0	;\n"
	"adcl %3, %0	;\n"
	"adcl $0, %0	;\n"
	: "=r" (sum)
	: "g" (daddr), "g"(saddr), "g"((ntohs(len)<<16)+proto*256), "0"(sum));
    return sum;
}

/*
 * computes the checksum of the TCP/UDP pseudo-header
 * returns a 16-bit checksum, already complemented
 */
static inline unsigned short int csum_tcpudp_magic(unsigned long saddr,
						   unsigned long daddr,
						   unsigned short len,
						   unsigned short proto,
						   unsigned int sum)
{
    c2c5:	c1 ea 10             	shr    $0x10,%edx
 */
static __inline__ u16 tcp_v4_check(struct tcphdr *th, int len,
				   unsigned long saddr, unsigned long daddr, 
				   unsigned long base)
{
    c2c8:	66 89 51 10          	mov    %dx,0x10(%ecx)

#ifndef USERTEST
	trickles_checksum(skb, skb->len - origSkbLen);
	if(sk->protocol == IPPROTO_TCP) {
    c2cc:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    c2cf:	0f b6 82 33 0c 00 00 	movzbl 0xc33(%edx),%eax
    c2d6:	3c 06                	cmp    $0x6,%al
    c2d8:	0f 84 93 00 00 00    	je     c371 <msk_transmit_skb+0x3a1>
#ifndef FORCE_MSK_TRANSMIT_REORDERING
		err = af->queue_xmit(skb, 0);
#else
		if(reorder_skb == NULL) {
			reorder_skb = skb;
			err = 0;
		} else {
			err = af->queue_xmit(skb, 0);
			err = af->queue_xmit(reorder_skb, 0) | err;
		}
#endif
	} else {
		struct udphdr *udp_hdr;
		BUG_TRAP(sk->protocol == IPPROTO_UDP);
    c2de:	3c 11                	cmp    $0x11,%al
    c2e0:	74 14                	je     c2f6 <msk_transmit_skb+0x326>
    c2e2:	c7 44 24 04 f5 03 00 	movl   $0x3f5,0x4(%esp,1)
    c2e9:	00 
    c2ea:	c7 04 24 60 34 00 00 	movl   $0x3460,(%esp,1)
    c2f1:	e8 fc ff ff ff       	call   c2f2 <msk_transmit_skb+0x322>
 */

static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
    c2f6:	8b 55 0c             	mov    0xc(%ebp),%edx
    c2f9:	8b 82 94 00 00 00    	mov    0x94(%edx),%eax
	skb->len+=len;
    c2ff:	83 42 70 08          	addl   $0x8,0x70(%edx)
    c303:	83 e8 08             	sub    $0x8,%eax
	if(skb->data<skb->head) {
    c306:	3b 82 90 00 00 00    	cmp    0x90(%edx),%eax
    c30c:	89 82 94 00 00 00    	mov    %eax,0x94(%edx)
    c312:	72 43                	jb     c357 <msk_transmit_skb+0x387>
		skb_under_panic(skb, len, current_text_addr());
	}
    c314:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    c317:	8b 81 94 00 00 00    	mov    0x94(%ecx),%eax
		udp_hdr = (struct udphdr*) 
			skb_push(skb, sizeof(struct udphdr));
		udp_hdr->source = sk->sport;
    c31d:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
    c320:	0f b7 51 22          	movzwl 0x22(%ecx),%edx
    c324:	66 89 10             	mov    %dx,(%eax)
		udp_hdr->dest = sk->dport;
    c327:	0f b7 51 08          	movzwl 0x8(%ecx),%edx
		udp_hdr->len = htons(sizeof(struct udphdr));
    c32b:	66 c7 40 04 00 08    	movw   $0x800,0x4(%eax)
		udp_hdr->check = 0;
    c331:	66 c7 40 06 00 00    	movw   $0x0,0x6(%eax)
    c337:	66 89 50 02          	mov    %dx,0x2(%eax)
		err = af->queue_xmit(skb, 0);
    c33b:	8b 45 0c             	mov    0xc(%ebp),%eax
    c33e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    c345:	00 
    c346:	89 04 24             	mov    %eax,(%esp,1)
    c349:	ff 15 00 00 00 00    	call   *0x0
	}
#else
	err = 0;
	skb->nh.iph = (struct iphdr*)skb_push(skb, sizeof(struct iphdr));
	skb->nh.iph->daddr = msk->daddr;
	skb->nh.iph->saddr = msk->saddr;
	sendtoclient(skb);
#endif // USERTEST
	return err;
}
    c34f:	83 c4 34             	add    $0x34,%esp
    c352:	5b                   	pop    %ebx
    c353:	5e                   	pop    %esi
    c354:	5f                   	pop    %edi
    c355:	5d                   	pop    %ebp
    c356:	c3                   	ret    
{
	skb->data-=len;
	skb->len+=len;
	if(skb->data<skb->head) {
		skb_under_panic(skb, len, current_text_addr());
    c357:	c7 44 24 08 5f c3 00 	movl   $0xc35f,0x8(%esp,1)
    c35e:	00 
    c35f:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp,1)
    c366:	00 
    c367:	89 14 24             	mov    %edx,(%esp,1)
    c36a:	e8 fc ff ff ff       	call   c36b <msk_transmit_skb+0x39b>
    c36f:	eb a3                	jmp    c314 <msk_transmit_skb+0x344>
    c371:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    c378:	00 
    c379:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    c37c:	89 0c 24             	mov    %ecx,(%esp,1)
    c37f:	eb c8                	jmp    c349 <msk_transmit_skb+0x379>
#ifndef USERTEST
static inline void trickles_checksum(struct sk_buff *skb, int headerLen) {
	struct sock *sk = skb->sk;
	if(skb->ip_summed == CHECKSUM_HW) {
		skb->h.th->check = 0;
    c381:	8b 41 20             	mov    0x20(%ecx),%eax
						   unsigned long daddr,
						   unsigned short len,
						   unsigned short proto,
						   unsigned int sum)
{
    c384:	31 d2                	xor    %edx,%edx
#ifndef USERTEST
static inline void trickles_checksum(struct sk_buff *skb, int headerLen) {
	struct sock *sk = skb->sk;
	if(skb->ip_summed == CHECKSUM_HW) {
		skb->h.th->check = 0;
    c386:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
		skb->h.th->check = ~tcp_v4_check(skb->h.th, skb->len, sk->saddr, sk->daddr,
    c38c:	8b 45 0c             	mov    0xc(%ebp),%eax
    c38f:	8b 48 20             	mov    0x20(%eax),%ecx
						   unsigned long daddr,
						   unsigned short len,
						   unsigned short proto,
						   unsigned int sum)
{
    c392:	0f b7 40 70          	movzwl 0x70(%eax),%eax
/* gcc should generate this for open coded C now too. May be worth switching to 
   it because inline assembly cannot be scheduled. -AK */
static __inline__ __const__ __u16 ___arch__swab16(__u16 x)
{
	__asm__("xchgb %b0,%h0"		/* swap bytes		*/
    c396:	86 c4                	xchg   %al,%ah
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
    c398:	c1 e0 10             	shl    $0x10,%eax
    c39b:	05 00 06 00 00       	add    $0x600,%eax
    c3a0:	03 16                	add    (%esi),%edx
    c3a2:	13 56 70             	adc    0x70(%esi),%edx
    c3a5:	11 c2                	adc    %eax,%edx
    c3a7:	83 d2 00             	adc    $0x0,%edx
 */

static inline unsigned int csum_fold(unsigned int sum)
{
	__asm__(
    c3aa:	89 d0                	mov    %edx,%eax
    c3ac:	25 00 00 ff ff       	and    $0xffff0000,%eax
    c3b1:	c1 e2 10             	shl    $0x10,%edx
    c3b4:	01 d0                	add    %edx,%eax
    c3b6:	15 ff ff 00 00       	adc    $0xffff,%eax
		"addl %1, %0		;\n"
		"adcl $0xffff, %0	;\n"
		: "=r" (sum)
		: "r" (sum << 16), "0" (sum & 0xffff0000)
	);
	return (~sum) >> 16;
}

static inline unsigned long csum_tcpudp_nofold(unsigned long saddr,
						   unsigned long daddr,
						   unsigned short len,
						   unsigned short proto,
						   unsigned int sum)
{
    __asm__(
	"addl %1, %0	;\n"
	"adcl %2, %0	;\n"
	"adcl %3, %0	;\n"
	"adcl $0, %0	;\n"
	: "=r" (sum)
	: "g" (daddr), "g"(saddr), "g"((ntohs(len)<<16)+proto*256), "0"(sum));
    return sum;
}

/*
 * computes the checksum of the TCP/UDP pseudo-header
 * returns a 16-bit checksum, already complemented
 */
static inline unsigned short int csum_tcpudp_magic(unsigned long saddr,
						   unsigned long daddr,
						   unsigned short len,
						   unsigned short proto,
						   unsigned int sum)
{
    c3bb:	c1 e8 10             	shr    $0x10,%eax
 */
static __inline__ u16 tcp_v4_check(struct tcphdr *th, int len,
				   unsigned long saddr, unsigned long daddr, 
				   unsigned long base)
{
    c3be:	66 89 41 10          	mov    %ax,0x10(%ecx)
	if(skb->ip_summed == CHECKSUM_HW) {
		skb->h.th->check = 0;
		skb->h.th->check = ~tcp_v4_check(skb->h.th, skb->len, sk->saddr, sk->daddr,
					 0);
		skb->csum = offsetof(struct tcphdr, check);
    c3c2:	8b 55 0c             	mov    0xc(%ebp),%edx
    c3c5:	c7 42 78 10 00 00 00 	movl   $0x10,0x78(%edx)
    c3cc:	e9 fb fe ff ff       	jmp    c2cc <msk_transmit_skb+0x2fc>
    c3d1:	80 ca 01             	or     $0x1,%dl
    c3d4:	88 53 0d             	mov    %dl,0xd(%ebx)
    c3d7:	e9 53 fe ff ff       	jmp    c22f <msk_transmit_skb+0x25f>
    c3dc:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    c3e0:	80 ca 12             	or     $0x12,%dl
    c3e3:	eb ef                	jmp    c3d4 <msk_transmit_skb+0x404>
    c3e5:	8b 41 54             	mov    0x54(%ecx),%eax
    c3e8:	89 44 24 20          	mov    %eax,0x20(%esp,1)
    c3ec:	89 44 24 1c          	mov    %eax,0x1c(%esp,1)
    c3f0:	8b 41 6c             	mov    0x6c(%ecx),%eax
    c3f3:	89 44 24 18          	mov    %eax,0x18(%esp,1)
    c3f7:	8b 81 d8 00 00 00    	mov    0xd8(%ecx),%eax
    c3fd:	89 44 24 14          	mov    %eax,0x14(%esp,1)
    c401:	8b 41 68             	mov    0x68(%ecx),%eax
    c404:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    c408:	a1 18 01 00 00       	mov    0x118,%eax
    c40d:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    c411:	8b 81 e0 00 00 00    	mov    0xe0(%ecx),%eax
    c417:	8b 44 30 04          	mov    0x4(%eax,%esi,1),%eax
    c41b:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    c41f:	0f bf 41 1e          	movswl 0x1e(%ecx),%eax
    c423:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    c427:	8b 41 18             	mov    0x18(%ecx),%eax
    c42a:	89 04 24             	mov    %eax,(%esp,1)
    c42d:	ff 15 00 00 00 00    	call   *0x0
    c433:	e9 8d fd ff ff       	jmp    c1c5 <msk_transmit_skb+0x1f5>
{
	skb->data-=len;
	skb->len+=len;
	if(skb->data<skb->head) {
		skb_under_panic(skb, len, current_text_addr());
    c438:	c7 44 24 08 40 c4 00 	movl   $0xc440,0x8(%esp,1)
    c43f:	00 
    c440:	c7 44 24 04 18 00 00 	movl   $0x18,0x4(%esp,1)
    c447:	00 
    c448:	89 0c 24             	mov    %ecx,(%esp,1)
    c44b:	e8 fc ff ff ff       	call   c44c <msk_transmit_skb+0x47c>
    c450:	e9 3a fd ff ff       	jmp    c18f <msk_transmit_skb+0x1bf>
    c455:	c7 44 24 08 5d c4 00 	movl   $0xc45d,0x8(%esp,1)
    c45c:	00 
    c45d:	c7 44 24 04 56 00 00 	movl   $0x56,0x4(%esp,1)
    c464:	00 
    c465:	89 0c 24             	mov    %ecx,(%esp,1)
    c468:	e8 fc ff ff ff       	call   c469 <msk_transmit_skb+0x499>
    c46d:	e9 7f fc ff ff       	jmp    c0f1 <msk_transmit_skb+0x121>
    c472:	c7 44 24 04 cc 05 00 	movl   $0x5cc,0x4(%esp,1)
    c479:	00 
    c47a:	31 db                	xor    %ebx,%ebx
    c47c:	c7 04 24 d0 05 00 00 	movl   $0x5d0,(%esp,1)
    c483:	e8 fc ff ff ff       	call   c484 <msk_transmit_skb+0x4b4>
    c488:	e8 fc ff ff ff       	call   c489 <msk_transmit_skb+0x4b9>
    c48d:	e9 88 fc ff ff       	jmp    c11a <msk_transmit_skb+0x14a>
 */

static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
    c492:	8b 55 0c             	mov    0xc(%ebp),%edx
    c495:	8b 82 94 00 00 00    	mov    0x94(%edx),%eax
	skb->len+=len;
    c49b:	83 42 70 21          	addl   $0x21,0x70(%edx)
    c49f:	83 e8 21             	sub    $0x21,%eax
	if(skb->data<skb->head) {
    c4a2:	3b 82 90 00 00 00    	cmp    0x90(%edx),%eax
    c4a8:	89 82 94 00 00 00    	mov    %eax,0x94(%edx)
    c4ae:	72 36                	jb     c4e6 <msk_transmit_skb+0x516>
    c4b0:	8b 55 08             	mov    0x8(%ebp),%edx
	skb->data-=len;
	skb->len+=len;
	if(skb->data<skb->head) {
		skb_under_panic(skb, len, current_text_addr());
	}
    c4b3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    c4b6:	8b 82 e0 00 00 00    	mov    0xe0(%edx),%eax
	skb->data-=len;
	skb->len+=len;
	if(skb->data<skb->head) {
		skb_under_panic(skb, len, current_text_addr());
	}
    c4bc:	8b 99 94 00 00 00    	mov    0x94(%ecx),%ebx
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    c4c2:	8b 44 30 04          	mov    0x4(%eax,%esi,1),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    c4c6:	0f c8                	bswap  %eax
    c4c8:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    c4cc:	89 43 0d             	mov    %eax,0xd(%ebx)
    c4cf:	8b 42 3c             	mov    0x3c(%edx),%eax
    c4d2:	89 43 15             	mov    %eax,0x15(%ebx)
    c4d5:	8b 42 40             	mov    0x40(%edx),%eax
    c4d8:	89 43 19             	mov    %eax,0x19(%ebx)
    c4db:	8b 42 50             	mov    0x50(%edx),%eax
    c4de:	89 43 1d             	mov    %eax,0x1d(%ebx)
    c4e1:	e9 34 fc ff ff       	jmp    c11a <msk_transmit_skb+0x14a>
{
	skb->data-=len;
	skb->len+=len;
	if(skb->data<skb->head) {
		skb_under_panic(skb, len, current_text_addr());
    c4e6:	c7 44 24 08 ee c4 00 	movl   $0xc4ee,0x8(%esp,1)
    c4ed:	00 
    c4ee:	c7 44 24 04 21 00 00 	movl   $0x21,0x4(%esp,1)
    c4f5:	00 
    c4f6:	89 14 24             	mov    %edx,(%esp,1)
    c4f9:	e8 fc ff ff ff       	call   c4fa <msk_transmit_skb+0x52a>
    c4fe:	eb b0                	jmp    c4b0 <msk_transmit_skb+0x4e0>
    c500:	c7 44 24 08 08 c5 00 	movl   $0xc508,0x8(%esp,1)
    c507:	00 
    c508:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    c50c:	89 14 24             	mov    %edx,(%esp,1)
    c50f:	e8 fc ff ff ff       	call   c510 <msk_transmit_skb+0x540>
    c514:	e9 5a fb ff ff       	jmp    c073 <msk_transmit_skb+0xa3>
    c519:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
    c520:	8b 45 08             	mov    0x8(%ebp),%eax
    c523:	8b 90 e0 00 00 00    	mov    0xe0(%eax),%edx
    c529:	e9 7a fb ff ff       	jmp    c0a8 <msk_transmit_skb+0xd8>
    c52e:	89 f6                	mov    %esi,%esi
    c530:	c7 44 24 04 59 03 00 	movl   $0x359,0x4(%esp,1)
    c537:	00 
    c538:	c7 04 24 c0 34 00 00 	movl   $0x34c0,(%esp,1)
    c53f:	e8 fc ff ff ff       	call   c540 <msk_transmit_skb+0x570>
    c544:	e9 e8 fa ff ff       	jmp    c031 <msk_transmit_skb+0x61>
    c549:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    c550:	c7 04 24 29 07 00 00 	movl   $0x729,(%esp,1)
    c557:	a1 00 00 00 00       	mov    0x0,%eax
    c55c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    c560:	e8 fc ff ff ff       	call   c561 <msk_transmit_skb+0x591>
    c565:	e9 b1 fa ff ff       	jmp    c01b <msk_transmit_skb+0x4b>
    c56a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000c570 <NormalizeContinuation>:



/*
  Sequence #
  State
  **Recovery:
  firstLoss
  firstBootstrapSeq

  **AckTCPCwnd
  startCwnd
  ssthresh
  TCPBase */

void NormalizeContinuation(CONTINUATION_TYPE *cont, AckProof *ackProof) {
    c570:	55                   	push   %ebp
    c571:	89 e5                	mov    %esp,%ebp
#if 0
  // TODO: Disabled normalization code for now because Normalization complicates TCP update calculation
	unsigned seq = cont->seq;
	if(seq - cont->TCPBase > MAX_CWND * MAX_CWND) {
		int cwnd;
		// make sure normalization of parallel threads results in the same new TCPBase
		__u32 right = AckProof_findRight(ackProof, cont->TCPBase),
			newSeq = cont->TCPBase + MAX_CWND * MAX_CWND;
		BUG_TRAP(right >= cont->TCPBase);
		BUG_TRAP(newSeq <= right);
		cwnd = AckTCPCwndScalar(newSeq, cont);
		if(cwnd < 0) {
			printk("Bad CWND in normalizeContinuation\n");
			return;
		}
		cont->startCwnd = cwnd;
		cont->TCPBase = newSeq;
		printk("Warning: Normalization is not correct yet!\n");
	}
#endif
}
    c573:	5d                   	pop    %ebp
    c574:	c3                   	ret    
    c575:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    c579:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

0000c580 <DoNormalStep>:

#ifdef USE_INCREMENTAL_CWND
 __u32 AckTCPHint(__u32 prevCwnd, __u32 *hint, __u32 seq, CONTINUATION_TYPE *cont) {
	__u32 currCwnd;
	// Updates result for next call to AckTCPHint
	if(*hint != -1) {
		/* Compute update starting from hint */
		currCwnd = prevCwnd;
		if(seq >= *hint) {
			int delta = seq  - *hint, ticks = 0;
			currCwnd = CLAMP(currCwnd + 1);
			if(currCwnd < cont->ssthresh) {
				currCwnd = CLAMP(MIN(cont->ssthresh, 
						     currCwnd + delta));
				delta -= currCwnd - prevCwnd;
			}
			while(delta >= currCwnd) {
				ticks++;
				BUG_TRAP(currCwnd >= cont->ssthresh);
				delta -= currCwnd;
				currCwnd = CLAMP(currCwnd + 1);
			}
			if(currCwnd < cont->ssthresh) {
				*hint = seq + 1;
			} else {
				*hint = seq + (-delta);
			}
		}
	} else {
		/* Compute from scratch */
		currCwnd = AckTCPCwndScalar(cont->seq, cont);
	}
	return currCwnd;
}
#endif // USE_INCREMENTAL_CWND

#define INITIAL_CWND (0)
#define FIRST_ACKSEQ(CONTTYPE, SEQ) \
    ((CONTTYPE) == CONTTYPE_FULL2 ? (SEQ) - 1 : (SEQ))
static int DoNormalStep(CONTINUATION_TYPE **cont, 
			 AckProof *ackProof, 
			 enum cminisock_event_tag event) {
    c580:	55                   	push   %ebp
    c581:	89 e5                	mov    %esp,%ebp
    c583:	57                   	push   %edi
	int i, numPackets = 0;
  __u32 first_ack_seq = 
    FIRST_ACKSEQ((*cont)->continuationType, 
		 (*cont)->seq), firstResponseSeq;
  int prevCwnd, currCwnd;
  int numOutput;
  int first = 1, thisResponseLen = 0, hint;
  __u32 offset;

  (*cont)->executionTrace = 1;
    c584:	bf 01 00 00 00       	mov    $0x1,%edi
    c589:	56                   	push   %esi
    c58a:	53                   	push   %ebx
    c58b:	83 ec 30             	sub    $0x30,%esp
    c58e:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
    c595:	8b 55 08             	mov    0x8(%ebp),%edx
    c598:	8b 02                	mov    (%edx),%eax
    c59a:	83 78 38 02          	cmpl   $0x2,0x38(%eax)
    c59e:	89 b8 d0 00 00 00    	mov    %edi,0xd0(%eax)
    c5a4:	8b 70 34             	mov    0x34(%eax),%esi

  TIMING_CTX_DEF0("DoNormalStep", "");
  TIMING_CTX_DEF1(7);
  reinitTimingCtx(&ctx);
  recordSample(&ctx,0);

  prevCwnd = (first_ack_seq == (*cont)->TCPBase) ? 
    c5a7:	8b 45 08             	mov    0x8(%ebp),%eax
    c5aa:	8d 56 ff             	lea    0xffffffff(%esi),%edx
    c5ad:	0f 44 f2             	cmove  %edx,%esi
    c5b0:	8b 10                	mov    (%eax),%edx
    c5b2:	3b 72 70             	cmp    0x70(%edx),%esi
    c5b5:	0f 84 cd 03 00 00    	je     c988 <DoNormalStep+0x408>
    c5bb:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    c5bf:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
    c5c2:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    c5c6:	8d 46 ff             	lea    0xffffffff(%esi),%eax
    c5c9:	89 04 24             	mov    %eax,(%esp,1)
    c5cc:	e8 fc ff ff ff       	call   c5cd <DoNormalStep+0x4d>
    c5d1:	89 c7                	mov    %eax,%edi
    c5d3:	8b 45 08             	mov    0x8(%ebp),%eax
    c5d6:	8b 10                	mov    (%eax),%edx
    c5d8:	8b 42 34             	mov    0x34(%edx),%eax
    c5db:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    c5df:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    c5e6:	00 
    c5e7:	89 04 24             	mov    %eax,(%esp,1)
    c5ea:	e8 fc ff ff ff       	call   c5eb <DoNormalStep+0x6b>
    (*cont)->startCwnd : 
    AckTCPCwnd(first_ack_seq - 1, (*cont), &hint);
  recordSample(&ctx,0);

#ifndef USE_INCREMENTAL_CWND
  currCwnd = AckTCPCwndScalar((*cont)->seq, (*cont));
#else
  currCwnd = AckTCPHint(prevCwnd, &hint, (*cont)->seq, (*cont));
#endif
  (*cont)->actualCwnd = currCwnd;
    c5ef:	8b 55 08             	mov    0x8(%ebp),%edx
    c5f2:	89 c3                	mov    %eax,%ebx
    c5f4:	8b 02                	mov    (%edx),%eax
    c5f6:	89 98 d4 00 00 00    	mov    %ebx,0xd4(%eax)

  //printk("prevCwnd: %u currCwnd: %u - ", prevCwnd, currCwnd);
  recordSample(&ctx,0);
  numOutput = MAX(0, currCwnd - (int)prevCwnd);
    c5fc:	89 d8                	mov    %ebx,%eax
    c5fe:	29 f8                	sub    %edi,%eax
    c600:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
    c607:	0f 48 45 e0          	cmovs  0xffffffe0(%ebp),%eax
    c60b:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)

  switch((*cont)->continuationType) {
    c60e:	8b 02                	mov    (%edx),%eax
    c610:	8b 40 38             	mov    0x38(%eax),%eax
    c613:	83 f8 01             	cmp    $0x1,%eax
    c616:	0f 84 64 03 00 00    	je     c980 <DoNormalStep+0x400>
    c61c:	83 f8 02             	cmp    $0x2,%eax
    c61f:	0f 84 4f 03 00 00    	je     c974 <DoNormalStep+0x3f4>
  case CONTTYPE_FULL1:
    numOutput += 1;
    break;
  case CONTTYPE_FULL2:
    numOutput += 2;
    break;
  default:
    BUG();
    c625:	c7 44 24 04 cc 05 00 	movl   $0x5cc,0x4(%esp,1)
    c62c:	00 
    c62d:	c7 04 24 d0 05 00 00 	movl   $0x5d0,(%esp,1)
    c634:	e8 fc ff ff ff       	call   c635 <DoNormalStep+0xb5>
    c639:	e8 fc ff ff ff       	call   c63a <DoNormalStep+0xba>
  }

  if(prevCwnd < 0 || currCwnd < 0) {
    c63e:	85 ff                	test   %edi,%edi
    c640:	0f 88 7e 02 00 00    	js     c8c4 <DoNormalStep+0x344>
    c646:	85 db                	test   %ebx,%ebx
    c648:	0f 88 76 02 00 00    	js     c8c4 <DoNormalStep+0x344>
    /* error in AckTCPCwnd; return without generating output */
    if(trickles_ratelimit()) {
      ERROR("Error in acktcpcwnd\n");
    }
    free_trickles_msk((*cont)->sk,*cont);
    free_trickles_msk_finish((*cont)->sk,*cont);
    return -EINVAL;
  }
  if(numOutput < 0) {
    c64e:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    c651:	85 c0                	test   %eax,%eax
    c653:	0f 88 53 02 00 00    	js     c8ac <DoNormalStep+0x32c>
    ERROR("Decrease in AckTCPCwnd\n");
    numOutput = 0;
  }
  if(numOutput > 5) {
    c659:	83 7d e0 05          	cmpl   $0x5,0xffffffe0(%ebp)
    c65d:	7e 66                	jle    c6c5 <DoNormalStep+0x145>
    printk("bug in cwnd generation: ack_seq = %u-%u, TCPBase = %u, "
    c65f:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    c662:	89 44 24 14          	mov    %eax,0x14(%esp,1)
    c666:	8b 45 08             	mov    0x8(%ebp),%eax
    c669:	8b 10                	mov    (%eax),%edx
    c66b:	8b 42 68             	mov    0x68(%edx),%eax
    c66e:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    c672:	8b 42 70             	mov    0x70(%edx),%eax
    c675:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    c679:	8b 42 34             	mov    0x34(%edx),%eax
    c67c:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    c680:	c7 04 24 20 35 00 00 	movl   $0x3520,(%esp,1)
    c687:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    c68b:	e8 fc ff ff ff       	call   c68c <DoNormalStep+0x10c>
	   "cwnd = %u, numOutput = %u, \n",
	   first_ack_seq, (*cont)->seq, (*cont)->TCPBase, 
	   (*cont)->startCwnd, numOutput);
    
    free_trickles_msk((*cont)->sk,(*cont));
    c690:	8b 55 08             	mov    0x8(%ebp),%edx
    c693:	8b 02                	mov    (%edx),%eax
    c695:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    c699:	8b 40 20             	mov    0x20(%eax),%eax
    c69c:	89 04 24             	mov    %eax,(%esp,1)
    c69f:	e8 fc de ff ff       	call   a5a0 <free_trickles_msk>
    free_trickles_msk_finish((*cont)->sk,(*cont));
    c6a4:	8b 55 08             	mov    0x8(%ebp),%edx
    c6a7:	8b 02                	mov    (%edx),%eax
    c6a9:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    c6ad:	8b 40 20             	mov    0x20(%eax),%eax
    c6b0:	89 04 24             	mov    %eax,(%esp,1)
    c6b3:	e8 88 df ff ff       	call   a640 <free_trickles_msk_finish>
    return -EINVAL;
    c6b8:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  }
  recordSample(&ctx,0);
  NormalizeContinuation(*cont,ackProof);
  recordSample(&ctx,0);
  firstResponseSeq = first_ack_seq + prevCwnd;

  // allocate space for packets
  if(!alloc_msk_packets((*cont), numOutput)) {
    free_trickles_msk((*cont)->sk,(*cont));
    free_trickles_msk_finish((*cont)->sk,(*cont));
    return -ENOMEM;
  }
  for(i=0; i < numOutput; i++) {
    __u32 seq = firstResponseSeq + i;
    int thisMTU, nextResponseLen = 0, firstChild = -1, 
      numChildren = -1, contType;
    if(serverDebugLevel >= 1) {
      if((*cont)->state == CONT_BOOTSTRAP) {
	printk("  %u\n", seq);
      }
    }
    // Algorithm choices here affect normalize continuation
    offset = seq - (*cont)->TCPBase;

#define CONTTYPE(OFFSET) (((OFFSET) <= 8) ? CONTTYPE_FULL1 :		\
			  (((OFFSET) % 2 == 0) ? CONTTYPE_FULL2 :	\
			   CONTTYPE_MINIMAL))

    /* calculate number of packets in successor*/
    contType = CONTTYPE(offset);

#ifdef ENABLE_HASHCOMPRESS
    switch(contType) {
    case CONTTYPE_FULL1:
    case CONTTYPE_FULL2:
	    thisMTU = CONTTYPE_HASHCOMPRESS_MTU;
	    break;
    case CONTTYPE_MINIMAL:
	    thisMTU = CONTTYPE_HASHCOMPRESS_MTU;
	    break;
    default:
	    thisMTU = -1;
	    BUG();
    }
    contType |= CONTTYPE_HASHCOMPRESSED;
#else
    switch(contType) {
    case CONTTYPE_FULL1:
    case CONTTYPE_FULL2:
	    thisMTU = CONTTYPE_FULL_MTU;
	    break;
    case CONTTYPE_MINIMAL:
	    thisMTU = CONTTYPE_MINIMAL_MTU;
	    break;
    default:
	    thisMTU = -1;
	    BUG();
    }
#endif
    thisResponseLen += thisMTU;
    makePacket(&(*cont)->packets[numPackets], seq, 0xdeadbeef, thisMTU, -1, (first ? PTYPE_FIRST : 0) | PACKET_NORMAL, contType, nextResponseLen,
	       firstChild, numChildren);


    first = 0;
    numPackets++;
  }
  (*cont)->num_packets = numPackets;
  BUG_TRAP(numPackets <= numOutput);
  recordSample(&ctx,0);

  DoUpcall((*cont), event);
  recordSample(&ctx,0);
  //printTimings(&ctx);
  return 0;
}
    c6bd:	83 c4 30             	add    $0x30,%esp
    c6c0:	5b                   	pop    %ebx
    c6c1:	5e                   	pop    %esi
    c6c2:	5f                   	pop    %edi
    c6c3:	5d                   	pop    %ebp
    c6c4:	c3                   	ret    
    c6c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    c6c8:	01 fe                	add    %edi,%esi
    c6ca:	8b 55 08             	mov    0x8(%ebp),%edx
    c6cd:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    c6d1:	8b 02                	mov    (%edx),%eax
    c6d3:	89 04 24             	mov    %eax,(%esp,1)
    c6d6:	e8 fc ff ff ff       	call   c6d7 <DoNormalStep+0x157>
    c6db:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    c6de:	8b 55 08             	mov    0x8(%ebp),%edx
    c6e1:	89 75 e4             	mov    %esi,0xffffffe4(%ebp)
    c6e4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    c6e8:	8b 02                	mov    (%edx),%eax
    c6ea:	89 04 24             	mov    %eax,(%esp,1)
    c6ed:	e8 fe 0d 00 00       	call   d4f0 <alloc_msk_packets>
    c6f2:	85 c0                	test   %eax,%eax
    c6f4:	0f 84 80 01 00 00    	je     c87a <DoNormalStep+0x2fa>
    c6fa:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
    c701:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    c704:	39 45 ec             	cmp    %eax,0xffffffec(%ebp)
    c707:	0f 8d f6 00 00 00    	jge    c803 <DoNormalStep+0x283>
    c70d:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    c710:	8d 04 92             	lea    (%edx,%edx,4),%eax
    c713:	c1 e0 03             	shl    $0x3,%eax
    c716:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    c719:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    c720:	8b 75 e4             	mov    0xffffffe4(%ebp),%esi
    c723:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    c726:	8b 3d 00 00 00 00    	mov    0x0,%edi
    c72c:	01 c6                	add    %eax,%esi
    c72e:	85 ff                	test   %edi,%edi
    c730:	0f 8e 3a 01 00 00    	jle    c870 <DoNormalStep+0x2f0>
    c736:	8b 45 08             	mov    0x8(%ebp),%eax
    c739:	8b 10                	mov    (%eax),%edx
    c73b:	83 7a 58 02          	cmpl   $0x2,0x58(%edx)
    c73f:	0f 84 1b 01 00 00    	je     c860 <DoNormalStep+0x2e0>
    c745:	8b 5a 70             	mov    0x70(%edx),%ebx
    c748:	89 f0                	mov    %esi,%eax
    c74a:	29 d8                	sub    %ebx,%eax
    c74c:	83 f8 08             	cmp    $0x8,%eax
    c74f:	0f 86 fb 00 00 00    	jbe    c850 <DoNormalStep+0x2d0>
    c755:	31 db                	xor    %ebx,%ebx
    c757:	a9 01 00 00 00       	test   $0x1,%eax
    c75c:	0f 94 c3             	sete   %bl
    c75f:	01 db                	add    %ebx,%ebx
    c761:	85 db                	test   %ebx,%ebx
    c763:	bf 87 05 00 00       	mov    $0x587,%edi
    c768:	74 2d                	je     c797 <DoNormalStep+0x217>
    c76a:	83 fb 02             	cmp    $0x2,%ebx
    c76d:	bf 52 05 00 00       	mov    $0x552,%edi
    c772:	7e 23                	jle    c797 <DoNormalStep+0x217>
    c774:	c7 44 24 04 cc 05 00 	movl   $0x5cc,0x4(%esp,1)
    c77b:	00 
    c77c:	bf ff ff ff ff       	mov    $0xffffffff,%edi
    c781:	c7 04 24 d0 05 00 00 	movl   $0x5d0,(%esp,1)
    c788:	e8 fc ff ff ff       	call   c789 <DoNormalStep+0x209>
    c78d:	e8 fc ff ff ff       	call   c78e <DoNormalStep+0x20e>
    c792:	8b 45 08             	mov    0x8(%ebp),%eax
    c795:	8b 10                	mov    (%eax),%edx
			      __u8 type, 
			      __u8 contType, 
			      __u16 minResponseLen,
			      __u32 firstTransportChild, 
			      __u8 numTransportChildren) {
    c797:	8b 8a e0 00 00 00    	mov    0xe0(%edx),%ecx
    c79d:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    c7a0:	01 c8                	add    %ecx,%eax
    c7a2:	88 d9                	mov    %bl,%cl
  pkt->nonce = -1;
  pkt->seq = seq;
  //pkt->ack_seq = ack_seq;
  pkt->len = len;
  pkt->byteNum = byteNum;
  pkt->type = type;
  pkt->contType = contType;
    c7a4:	c0 e1 03             	shl    $0x3,%cl
    c7a7:	0f b6 50 10          	movzbl 0x10(%eax),%edx
    c7ab:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    c7b1:	89 70 04             	mov    %esi,0x4(%eax)
    c7b4:	89 78 08             	mov    %edi,0x8(%eax)
    c7b7:	80 e2 c0             	and    $0xc0,%dl
    c7ba:	08 ca                	or     %cl,%dl
    c7bc:	c7 40 0c ff ff ff ff 	movl   $0xffffffff,0xc(%eax)
    c7c3:	88 50 10             	mov    %dl,0x10(%eax)
  pkt->minResponseLen = minResponseLen;
    c7c6:	66 c7 40 1c 00 00    	movw   $0x0,0x1c(%eax)
  pkt->firstTransportChild = firstTransportChild;
    c7cc:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)
  pkt->numTransportChildren = numTransportChildren;
    c7d3:	c6 40 24 ff          	movb   $0xff,0x24(%eax)
  pkt->ucontLen = 0;
    c7d7:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  pkt->ucontData = NULL;
    c7de:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  pkt->numSiblings = -1;
    c7e5:	c6 40 11 ff          	movb   $0xff,0x11(%eax)
  pkt->position = INVALID_POSITION;
    c7e9:	c6 40 12 ff          	movb   $0xff,0x12(%eax)
    c7ed:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    c7f0:	ff 45 ec             	incl   0xffffffec(%ebp)
    c7f3:	83 45 dc 28          	addl   $0x28,0xffffffdc(%ebp)
    c7f7:	ff 45 e8             	incl   0xffffffe8(%ebp)
    c7fa:	39 55 ec             	cmp    %edx,0xffffffec(%ebp)
    c7fd:	0f 8c 1d ff ff ff    	jl     c720 <DoNormalStep+0x1a0>
    c803:	8b 55 08             	mov    0x8(%ebp),%edx
    c806:	8b 02                	mov    (%edx),%eax
    c808:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    c80b:	89 90 dc 00 00 00    	mov    %edx,0xdc(%eax)
    c811:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    c814:	39 c2                	cmp    %eax,%edx
    c816:	7f 1b                	jg     c833 <DoNormalStep+0x2b3>
    c818:	8b 45 10             	mov    0x10(%ebp),%eax
    c81b:	8b 55 08             	mov    0x8(%ebp),%edx
    c81e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    c822:	8b 02                	mov    (%edx),%eax
    c824:	89 04 24             	mov    %eax,(%esp,1)
    c827:	e8 fc ff ff ff       	call   c828 <DoNormalStep+0x2a8>
    c82c:	31 c0                	xor    %eax,%eax
    c82e:	e9 8a fe ff ff       	jmp    c6bd <DoNormalStep+0x13d>
    c833:	c7 44 24 04 db 04 00 	movl   $0x4db,0x4(%esp,1)
    c83a:	00 
    c83b:	c7 04 24 80 35 00 00 	movl   $0x3580,(%esp,1)
    c842:	e8 fc ff ff ff       	call   c843 <DoNormalStep+0x2c3>
    c847:	eb cf                	jmp    c818 <DoNormalStep+0x298>
    c849:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    c850:	bb 01 00 00 00       	mov    $0x1,%ebx
    c855:	e9 07 ff ff ff       	jmp    c761 <DoNormalStep+0x1e1>
    c85a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    c860:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    c864:	c7 04 24 3d 07 00 00 	movl   $0x73d,(%esp,1)
    c86b:	e8 fc ff ff ff       	call   c86c <DoNormalStep+0x2ec>
    c870:	8b 45 08             	mov    0x8(%ebp),%eax
    c873:	8b 10                	mov    (%eax),%edx
    c875:	e9 cb fe ff ff       	jmp    c745 <DoNormalStep+0x1c5>
    c87a:	8b 55 08             	mov    0x8(%ebp),%edx
    c87d:	8b 02                	mov    (%edx),%eax
    c87f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    c883:	8b 40 20             	mov    0x20(%eax),%eax
    c886:	89 04 24             	mov    %eax,(%esp,1)
    c889:	e8 12 dd ff ff       	call   a5a0 <free_trickles_msk>
    c88e:	8b 55 08             	mov    0x8(%ebp),%edx
    c891:	8b 02                	mov    (%edx),%eax
    c893:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    c897:	8b 40 20             	mov    0x20(%eax),%eax
    c89a:	89 04 24             	mov    %eax,(%esp,1)
    c89d:	e8 9e dd ff ff       	call   a640 <free_trickles_msk_finish>
    c8a2:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
    c8a7:	e9 11 fe ff ff       	jmp    c6bd <DoNormalStep+0x13d>
    c8ac:	c7 04 24 43 07 00 00 	movl   $0x743,(%esp,1)
    c8b3:	e8 fc ff ff ff       	call   c8b4 <DoNormalStep+0x334>
    c8b8:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
    c8bf:	e9 95 fd ff ff       	jmp    c659 <DoNormalStep+0xd9>
    c8c4:	a1 00 00 00 00       	mov    0x0,%eax
    c8c9:	9c                   	pushf  
    c8ca:	59                   	pop    %ecx
    c8cb:	fa                   	cli    
    c8cc:	89 c2                	mov    %eax,%edx
    c8ce:	8b 1d b8 b4 0e 00    	mov    0xeb4b8,%ebx
    c8d4:	8b 3d 1c 01 00 00    	mov    0x11c,%edi
    c8da:	a3 b8 b4 0e 00       	mov    %eax,0xeb4b8
    c8df:	29 da                	sub    %ebx,%edx
    c8e1:	01 fa                	add    %edi,%edx
    c8e3:	89 15 1c 01 00 00    	mov    %edx,0x11c
    c8e9:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    c8ef:	76 10                	jbe    c901 <DoNormalStep+0x381>
    c8f1:	be 88 13 00 00       	mov    $0x1388,%esi
    c8f6:	ba 88 13 00 00       	mov    $0x1388,%edx
    c8fb:	89 35 1c 01 00 00    	mov    %esi,0x11c
    c901:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    c907:	76 5f                	jbe    c968 <DoNormalStep+0x3e8>
    c909:	31 db                	xor    %ebx,%ebx
    c90b:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    c911:	a1 bc b4 0e 00       	mov    0xeb4bc,%eax
    c916:	89 15 1c 01 00 00    	mov    %edx,0x11c
    c91c:	89 1d bc b4 0e 00    	mov    %ebx,0xeb4bc
    c922:	51                   	push   %ecx
    c923:	9d                   	popf   
    c924:	85 c0                	test   %eax,%eax
    c926:	75 1e                	jne    c946 <DoNormalStep+0x3c6>
    c928:	b8 01 00 00 00       	mov    $0x1,%eax
    c92d:	85 c0                	test   %eax,%eax
    c92f:	0f 84 5b fd ff ff    	je     c690 <DoNormalStep+0x110>
    c935:	c7 04 24 5b 07 00 00 	movl   $0x75b,(%esp,1)
    c93c:	e8 fc ff ff ff       	call   c93d <DoNormalStep+0x3bd>
    c941:	e9 4a fd ff ff       	jmp    c690 <DoNormalStep+0x110>
    c946:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    c94a:	c7 44 24 08 83 04 00 	movl   $0x483,0x8(%esp,1)
    c951:	00 
    c952:	c7 44 24 04 04 06 00 	movl   $0x604,0x4(%esp,1)
    c959:	00 
    c95a:	c7 04 24 00 30 00 00 	movl   $0x3000,(%esp,1)
    c961:	e8 fc ff ff ff       	call   c962 <DoNormalStep+0x3e2>
    c966:	eb c0                	jmp    c928 <DoNormalStep+0x3a8>
    c968:	ff 05 bc b4 0e 00    	incl   0xeb4bc
    c96e:	51                   	push   %ecx
    c96f:	9d                   	popf   
    c970:	31 c0                	xor    %eax,%eax
    c972:	eb b9                	jmp    c92d <DoNormalStep+0x3ad>
    c974:	83 45 e0 02          	addl   $0x2,0xffffffe0(%ebp)
    c978:	e9 c1 fc ff ff       	jmp    c63e <DoNormalStep+0xbe>
    c97d:	8d 76 00             	lea    0x0(%esi),%esi
    c980:	ff 45 e0             	incl   0xffffffe0(%ebp)
    c983:	e9 b6 fc ff ff       	jmp    c63e <DoNormalStep+0xbe>
    c988:	8b 7a 68             	mov    0x68(%edx),%edi
    c98b:	e9 48 fc ff ff       	jmp    c5d8 <DoNormalStep+0x58>

0000c990 <intersect>:


static int intersect(int start0, int end0, int start1, int end1) {
    c990:	55                   	push   %ebp
    c991:	89 e5                	mov    %esp,%ebp
    c993:	53                   	push   %ebx
    c994:	8b 45 10             	mov    0x10(%ebp),%eax
    c997:	8b 4d 08             	mov    0x8(%ebp),%ecx
    c99a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    c99d:	8b 55 14             	mov    0x14(%ebp),%edx
  int start = MAX(start0,start1),
    c9a0:	39 c8                	cmp    %ecx,%eax
    c9a2:	0f 4d c8             	cmovge %eax,%ecx
    end = MIN(end0,end1);
    c9a5:	89 d8                	mov    %ebx,%eax
    c9a7:	39 da                	cmp    %ebx,%edx
    c9a9:	0f 4e c2             	cmovle %edx,%eax
  if(start <= end) {
    c9ac:	39 c1                	cmp    %eax,%ecx
    c9ae:	7f 06                	jg     c9b6 <intersect+0x26>
    /* intersection */
    return end - start + 1;
    c9b0:	29 c8                	sub    %ecx,%eax
    c9b2:	40                   	inc    %eax
  } else {
    return 0;
  }
}
    c9b3:	5b                   	pop    %ebx
    c9b4:	5d                   	pop    %ebp
    c9b5:	c3                   	ret    
    c9b6:	31 c0                	xor    %eax,%eax
    c9b8:	eb f9                	jmp    c9b3 <intersect+0x23>
    c9ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000c9c0 <DoRecoveryStep>:

#ifdef USERTEST
#if 0
#define serverDebugLevel recoveryDebugLevel
static int recoveryDebugLevel = 99; // temporary use in userspace debugging to print only recovery handler debugging information
#endif
#endif

static int DoRecoveryStep(CONTINUATION_TYPE **cont, AckProof *ackProof, 
			  enum cminisock_event_tag event) {
    c9c0:	55                   	push   %ebp
    c9c1:	89 e5                	mov    %esp,%ebp
    c9c3:	57                   	push   %edi
  int i;
  Sack *sacks = ackProof->sacks;
  // XXX INTMAX suppresses "uninitialized variable" harmless warnings in gcc
  int numLosses = 0, numBootstrapLosses = 0, bootstrapStart, bootstrapEnd, 
	  afterGap = 0,gapLeft = INT_MAX, gapRight = INT_MAX;
  unsigned numPackets = 0;
  int origCwnd, origCwndPred = INT_MAX, newCwnd;
    c9c4:	bf ff ff ff 7f       	mov    $0x7fffffff,%edi
    c9c9:	56                   	push   %esi
  int gaplen = INT_MAX;
  int adj = INT_MAX;
  __u32 ack_seq;
  __u32 lastRegularPacket;

  int numPacketsSendable;
  int numPacketsAllocated;

  int bootstrapIntersectStart, 
    bootstrapIntersectLast;

  (*cont)->executionTrace = 2;
    c9ca:	be 02 00 00 00       	mov    $0x2,%esi
    c9cf:	53                   	push   %ebx
    c9d0:	83 ec 74             	sub    $0x74,%esp
    c9d3:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
    c9da:	8b 45 0c             	mov    0xc(%ebp),%eax
    c9dd:	c7 45 e0 ff ff ff 7f 	movl   $0x7fffffff,0xffffffe0(%ebp)
    c9e4:	8b 55 08             	mov    0x8(%ebp),%edx
    c9e7:	c7 45 dc ff ff ff 7f 	movl   $0x7fffffff,0xffffffdc(%ebp)
    c9ee:	83 c0 08             	add    $0x8,%eax
    c9f1:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    c9f4:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
    c9fb:	c7 45 d0 ff ff ff 7f 	movl   $0x7fffffff,0xffffffd0(%ebp)
    ca02:	c7 45 cc ff ff ff 7f 	movl   $0x7fffffff,0xffffffcc(%ebp)
    ca09:	8b 02                	mov    (%edx),%eax
    ca0b:	89 b0 d0 00 00 00    	mov    %esi,0xd0(%eax)
    ca11:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    ca14:	89 0c 24             	mov    %ecx,(%esp,1)
    ca17:	e8 fc ff ff ff       	call   ca18 <DoRecoveryStep+0x58>
    ca1c:	8b 75 08             	mov    0x8(%ebp),%esi
    ca1f:	8b 16                	mov    (%esi),%edx
    ca21:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    ca28:	00 
    ca29:	89 04 24             	mov    %eax,(%esp,1)
    ca2c:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    ca30:	e8 fc ff ff ff       	call   ca31 <DoRecoveryStep+0x71>

  origCwnd = AckTCPCwndScalar(AckProof_firstLoss(ackProof), (*cont));
  if(origCwnd < 0) {
    ca35:	85 c0                	test   %eax,%eax
    ca37:	89 c6                	mov    %eax,%esi
    ca39:	0f 88 71 07 00 00    	js     d1b0 <DoRecoveryStep+0x7f0>
	  if(!disableSevereErrors)
		  printk("recoveryStep: OrigCwnd undefined\n");
	  free_trickles_msk((*cont)->sk,(*cont));
	  free_trickles_msk_finish((*cont)->sk,(*cont));
	  return -EINVAL;
  }
  (*cont)->state = CONT_RECOVERY;
    ca3f:	8b 55 08             	mov    0x8(%ebp),%edx
    ca42:	8b 02                	mov    (%edx),%eax
    ca44:	c7 40 58 01 00 00 00 	movl   $0x1,0x58(%eax)
  (*cont)->firstLoss = AckProof_firstLoss(ackProof);
    ca4b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    ca4e:	8b 1a                	mov    (%edx),%ebx
    ca50:	89 0c 24             	mov    %ecx,(%esp,1)
    ca53:	e8 fc ff ff ff       	call   ca54 <DoRecoveryStep+0x94>
    ca58:	89 43 60             	mov    %eax,0x60(%ebx)
  switch(CONTTYPE((*cont)->firstLoss - (*cont)->TCPBase)) {
    ca5b:	8b 55 08             	mov    0x8(%ebp),%edx
    ca5e:	8b 02                	mov    (%edx),%eax
    ca60:	8b 50 60             	mov    0x60(%eax),%edx
    ca63:	8b 48 70             	mov    0x70(%eax),%ecx
    ca66:	29 ca                	sub    %ecx,%edx
    ca68:	83 fa 08             	cmp    $0x8,%edx
    ca6b:	0f 86 2f 07 00 00    	jbe    d1a0 <DoRecoveryStep+0x7e0>
    ca71:	31 c0                	xor    %eax,%eax
    ca73:	f7 c2 01 00 00 00    	test   $0x1,%edx
    ca79:	0f 94 c0             	sete   %al
    ca7c:	01 c0                	add    %eax,%eax
    ca7e:	83 f8 01             	cmp    $0x1,%eax
    ca81:	0f 8e df 06 00 00    	jle    d166 <DoRecoveryStep+0x7a6>
    ca87:	83 f8 02             	cmp    $0x2,%eax
    ca8a:	0f 84 a1 06 00 00    	je     d131 <DoRecoveryStep+0x771>
  case CONTTYPE_FULL1: // fall-through
  case CONTTYPE_MINIMAL:
    origCwndPred = AckTCPCwndScalar(AckProof_firstLoss(ackProof)-1, (*cont));
    adj = 0;
    break;
  case CONTTYPE_FULL2:
    origCwndPred = AckTCPCwndScalar(AckProof_firstLoss(ackProof)-2, (*cont));
    adj = -1;
    break;
  }
  if(origCwnd < origCwndPred) {
    ca90:	39 fe                	cmp    %edi,%esi
    ca92:	0f 8c 88 06 00 00    	jl     d120 <DoRecoveryStep+0x760>
    printk("recoveryStep: OrigCwnd < OrigCwndPred\n");
    free_trickles_msk((*cont)->sk,(*cont));
    free_trickles_msk_finish((*cont)->sk,(*cont));
    return -EINVAL;
  }
  lastRegularPacket =  ((*cont)->firstLoss - 1 + adj) + origCwndPred;
    ca98:	8b 55 08             	mov    0x8(%ebp),%edx
    ca9b:	8b 02                	mov    (%edx),%eax
    ca9d:	8b 48 60             	mov    0x60(%eax),%ecx
    caa0:	01 4d cc             	add    %ecx,0xffffffcc(%ebp)
    caa3:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
    caa6:	01 fa                	add    %edi,%edx
  (*cont)->num_packets = 0;
    caa8:	31 ff                	xor    %edi,%edi
    caaa:	8d 4a ff             	lea    0xffffffff(%edx),%ecx
    caad:	89 4d c4             	mov    %ecx,0xffffffc4(%ebp)
    cab0:	89 b8 dc 00 00 00    	mov    %edi,0xdc(%eax)

#if 0  // 0615
  printk("EffCwnd (recoverystep): %d\n", origCwnd);
#endif

  newCwnd = origCwnd / MULT_FACTOR;
    cab6:	89 f0                	mov    %esi,%eax
    cab8:	c1 e8 1f             	shr    $0x1f,%eax
    cabb:	01 c6                	add    %eax,%esi
    cabd:	d1 fe                	sar    %esi
    cabf:	89 75 d4             	mov    %esi,0xffffffd4(%ebp)

  (*cont)->actualCwnd = newCwnd;
    cac2:	8b 75 08             	mov    0x8(%ebp),%esi
    cac5:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
    cac8:	8b 06                	mov    (%esi),%eax

  // FIXME: should allow 2 different TCPBase in CMinisock, since
  // bootstrap and rtx ought to have different TCPBase
  (*cont)->TCPBase = (*cont)->firstBootstrapSeq = lastRegularPacket + 1;
  (*cont)->startCwnd = newCwnd;
#ifndef ZERO_SSTHRESH_PROTECTION_HACK
  (*cont)->ssthresh = newCwnd;
#else
  if(newCwnd == 0)
    caca:	85 c9                	test   %ecx,%ecx
    cacc:	89 88 d4 00 00 00    	mov    %ecx,0xd4(%eax)
    cad2:	8b 06                	mov    (%esi),%eax
    cad4:	89 50 64             	mov    %edx,0x64(%eax)
    cad7:	89 50 70             	mov    %edx,0x70(%eax)
    cada:	8b 06                	mov    (%esi),%eax
    cadc:	89 48 68             	mov    %ecx,0x68(%eax)
    cadf:	0f 85 2b 06 00 00    	jne    d110 <DoRecoveryStep+0x750>
    (*cont)->ssthresh /= MULT_FACTOR;
    cae5:	8b 06                	mov    (%esi),%eax
    cae7:	d1 68 6c             	shrl   0x6c(%eax)
  else
    (*cont)->ssthresh = newCwnd;
#endif

  bootstrapStart = lastRegularPacket - newCwnd;
    caea:	8b 4d c4             	mov    0xffffffc4(%ebp),%ecx
  bootstrapEnd = bootstrapStart + newCwnd - 1;

  // XXX 0427 TODO: Remove first transport child processing

  /* Find the number of gaps */
  for(i=0; i < ackProof->numSacks; i++) {
    caed:	31 ff                	xor    %edi,%edi
    caef:	8b 5d d4             	mov    0xffffffd4(%ebp),%ebx
    caf2:	8b 75 d4             	mov    0xffffffd4(%ebp),%esi
    caf5:	8b 45 0c             	mov    0xc(%ebp),%eax
    caf8:	29 d9                	sub    %ebx,%ecx
    cafa:	89 4d ec             	mov    %ecx,0xffffffec(%ebp)
    cafd:	8d 74 0e ff          	lea    0xffffffff(%esi,%ecx,1),%esi
    cb01:	89 75 e8             	mov    %esi,0xffffffe8(%ebp)
    cb04:	8b 00                	mov    (%eax),%eax
    cb06:	39 c7                	cmp    %eax,%edi
    cb08:	89 45 a4             	mov    %eax,0xffffffa4(%ebp)
    cb0b:	0f 8d 82 00 00 00    	jge    cb93 <DoRecoveryStep+0x1d3>
    cb11:	8b 55 08             	mov    0x8(%ebp),%edx
    cb14:	31 c9                	xor    %ecx,%ecx
    cb16:	8b 1a                	mov    (%edx),%ebx
    cb18:	90                   	nop    
    cb19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    int cursorgap = 0;
    cb20:	c7 45 bc 00 00 00 00 	movl   $0x0,0xffffffbc(%ebp)
    if(i > 0 && !Sack_adjacent(&sacks[i-1], &sacks[i])) {
    cb27:	85 ff                	test   %edi,%edi
    cb29:	7e 19                	jle    cb44 <DoRecoveryStep+0x184>
    cb2b:	8b 75 f0             	mov    0xfffffff0(%ebp),%esi
    cb2e:	8b 04 0e             	mov    (%esi,%ecx,1),%eax
    cb31:	8b 54 0e f8          	mov    0xfffffff8(%esi,%ecx,1),%edx
    cb35:	29 d0                	sub    %edx,%eax
    cb37:	48                   	dec    %eax
    cb38:	74 0a                	je     cb44 <DoRecoveryStep+0x184>
    cb3a:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
      gaplen = Sack_gapLen(&sacks[i-1], &sacks[i]);
      cursorgap = 1;
    cb3d:	c7 45 bc 01 00 00 00 	movl   $0x1,0xffffffbc(%ebp)
    cb44:	8b 45 0c             	mov    0xc(%ebp),%eax
    cb47:	31 d2                	xor    %edx,%edx
    cb49:	8b 75 0c             	mov    0xc(%ebp),%esi
    cb4c:	01 c8                	add    %ecx,%eax
    cb4e:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
    cb51:	8b 43 34             	mov    0x34(%ebx),%eax
    cb54:	8b 74 0e 08          	mov    0x8(%esi,%ecx,1),%esi
    cb58:	89 75 90             	mov    %esi,0xffffff90(%ebp)
    cb5b:	39 c6                	cmp    %eax,%esi
    cb5d:	77 0f                	ja     cb6e <DoRecoveryStep+0x1ae>
    cb5f:	8b 75 0c             	mov    0xc(%ebp),%esi
    cb62:	3b 44 0e 0c          	cmp    0xc(%esi,%ecx,1),%eax
    cb66:	be 01 00 00 00       	mov    $0x1,%esi
    cb6b:	0f 46 d6             	cmovbe %esi,%edx
    cb6e:	85 d2                	test   %edx,%edx
    cb70:	74 18                	je     cb8a <DoRecoveryStep+0x1ca>
      numLosses += gaplen;
      numBootstrapLosses += 
	intersect(bootstrapStart, sacks[i].left-1,
		  bootstrapEnd, sacks[i-1].right+1);
    }
    if(Sack_contains(&ackProof->sacks[i], (*cont)->seq)) {
      if(((*cont)->seq == sacks[i].left || 
    cb72:	8b 75 f0             	mov    0xfffffff0(%ebp),%esi
    cb75:	8b 14 0e             	mov    (%esi,%ecx,1),%edx
    cb78:	39 d0                	cmp    %edx,%eax
    cb7a:	0f 84 69 05 00 00    	je     d0e9 <DoRecoveryStep+0x729>
    cb80:	83 7b 38 02          	cmpl   $0x2,0x38(%ebx)
    cb84:	0f 84 56 05 00 00    	je     d0e0 <DoRecoveryStep+0x720>
    cb8a:	47                   	inc    %edi
    cb8b:	83 c1 0c             	add    $0xc,%ecx
    cb8e:	3b 7d a4             	cmp    0xffffffa4(%ebp),%edi
    cb91:	7c 8d                	jl     cb20 <DoRecoveryStep+0x160>
	  ((*cont)->continuationType == CONTTYPE_FULL2 && (*cont)->seq - 1 == sacks[i].left))
	  && cursorgap) {
	/* detected gap; measure size of gap */
	afterGap = 1;
	gapLeft = ackProof->sacks[i-1].right + 1,
	  gapRight = ackProof->sacks[i].left - 1;
      }
    }
  }

  if(serverDebugLevel >= 2) {
    cb93:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    cb9a:	0f 8f 21 05 00 00    	jg     d0c1 <DoRecoveryStep+0x701>
	  printk("RecoveryStep\n");
	  AckProof_dump(ackProof);
  }

  // Preallocate space for all packets that we are going to generate
  numPacketsSendable = 0;
  numPacketsAllocated = 0;
    cba0:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
  if(afterGap) {
    cba7:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
    cbaa:	85 c9                	test   %ecx,%ecx
    cbac:	74 32                	je     cbe0 <DoRecoveryStep+0x220>
    int start, end;
    numPacketsAllocated += (gapRight - gapLeft) + 1; // range is inclusive
    cbae:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    cbb1:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    /* intersect bootstrap range with gap */
    start = MAX(gapLeft, bootstrapStart);
    end = MIN(gapRight, bootstrapEnd);
    cbb4:	8b 4d dc             	mov    0xffffffdc(%ebp),%ecx
    cbb7:	29 d0                	sub    %edx,%eax
    cbb9:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    cbbc:	40                   	inc    %eax
    cbbd:	39 55 ec             	cmp    %edx,0xffffffec(%ebp)
    cbc0:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
    cbc3:	89 c8                	mov    %ecx,%eax
    cbc5:	0f 4d 55 ec          	cmovge 0xffffffec(%ebp),%edx
    cbc9:	39 4d e8             	cmp    %ecx,0xffffffe8(%ebp)
    cbcc:	0f 4e 45 e8          	cmovle 0xffffffe8(%ebp),%eax
    if(start <= end) {
    cbd0:	39 c2                	cmp    %eax,%edx
    cbd2:	7f 0c                	jg     cbe0 <DoRecoveryStep+0x220>
      numPacketsAllocated += (end - start) + 1; // range is inclusive
    cbd4:	8b 75 c0             	mov    0xffffffc0(%ebp),%esi
    cbd7:	29 d0                	sub    %edx,%eax
    cbd9:	8d 74 30 01          	lea    0x1(%eax,%esi,1),%esi
    cbdd:	89 75 c0             	mov    %esi,0xffffffc0(%ebp)
    }
  }
  {
    /* intersect ack ack range with bootstrap range */
    bootstrapIntersectStart = MAX(FIRST_ACKSEQ((*cont)->continuationType, (*cont)->seq),
				  bootstrapStart);
    cbe0:	8b 45 08             	mov    0x8(%ebp),%eax
    cbe3:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
    bootstrapIntersectLast = MIN((*cont)->seq,
				 bootstrapEnd);
    cbe6:	8b 75 e8             	mov    0xffffffe8(%ebp),%esi
    cbe9:	8b 08                	mov    (%eax),%ecx
    cbeb:	8b 51 34             	mov    0x34(%ecx),%edx
    cbee:	83 79 38 02          	cmpl   $0x2,0x38(%ecx)
    cbf2:	8d 42 ff             	lea    0xffffffff(%edx),%eax
    cbf5:	0f 45 c2             	cmovne %edx,%eax
    cbf8:	39 c7                	cmp    %eax,%edi
    cbfa:	0f 42 f8             	cmovb  %eax,%edi
    cbfd:	39 d6                	cmp    %edx,%esi
    cbff:	0f 46 d6             	cmovbe %esi,%edx
    if(bootstrapIntersectStart <= bootstrapIntersectLast) {
    cc02:	39 d7                	cmp    %edx,%edi
    cc04:	89 55 b4             	mov    %edx,0xffffffb4(%ebp)
    cc07:	7f 0e                	jg     cc17 <DoRecoveryStep+0x257>
      numPacketsAllocated += 
    cc09:	89 d0                	mov    %edx,%eax
    cc0b:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
    cc0e:	29 f8                	sub    %edi,%eax
    cc10:	8d 54 10 01          	lea    0x1(%eax,%edx,1),%edx
    cc14:	89 55 c0             	mov    %edx,0xffffffc0(%ebp)
	bootstrapIntersectLast - bootstrapIntersectStart + 1; // range is inclusive
    }
  }
  if(numPacketsAllocated == 0) {
    cc17:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
    cc1a:	85 c0                	test   %eax,%eax
    cc1c:	75 2d                	jne    cc4b <DoRecoveryStep+0x28b>
    free_trickles_msk((*cont)->sk,(*cont));
    cc1e:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    cc22:	8b 41 20             	mov    0x20(%ecx),%eax
    cc25:	89 04 24             	mov    %eax,(%esp,1)
    cc28:	e8 73 d9 ff ff       	call   a5a0 <free_trickles_msk>
    free_trickles_msk_finish((*cont)->sk,(*cont));
    cc2d:	8b 4d 08             	mov    0x8(%ebp),%ecx
    cc30:	8b 01                	mov    (%ecx),%eax
    cc32:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    cc36:	8b 40 20             	mov    0x20(%eax),%eax
    cc39:	89 04 24             	mov    %eax,(%esp,1)
    cc3c:	e8 ff d9 ff ff       	call   a640 <free_trickles_msk_finish>
    return 0;
  }
  if(!alloc_msk_packets((*cont), numPacketsAllocated)) {
    free_trickles_msk((*cont)->sk,(*cont));
    free_trickles_msk_finish((*cont)->sk,(*cont));
    return -ENOMEM;
  }

  if(afterGap) {
    __u32 seq;
    if(serverDebugLevel >= 1) {
      printk("  Bootstrap [%d - %d], newCwnd %d\n", bootstrapStart, bootstrapEnd, newCwnd);
      printk("  Gaplen = %d (after gap)\n", gaplen);
    }
    /* Generate retransmits */
    if(gapRight - gapLeft > MAX_GAPSIZE) {
          //printk("recoveryStep: gap too large (%u-%u)\n", gapLeft, gapRight);
	  free_trickles_msk((*cont)->sk,(*cont));
	  free_trickles_msk_finish((*cont)->sk,(*cont));
	  return -EINVAL;
    }
    for(seq = gapLeft; seq <= gapRight; seq++) {
      if(serverDebugLevel >= 1) {
	printk("  Gap rtx %u\n", seq);
      }
      makePacket(&(*cont)->packets[numPackets], seq, 0xdeadbeef, MTU, -1, PACKET_RETRANS, CONTTYPE_MINIMAL, MTU, 
			 -1, -1);
      numPackets++;
      /* retransmit bootstrap packets that should have been clocked out by missing packets */
      /* xxx: merge with identical code below */
      if(seq >= bootstrapStart && seq <= bootstrapEnd) {
	__u32 bootstrap_seq = lastRegularPacket + 1 + (seq - bootstrapStart);
	unsigned firstChild;
	int numChildren, prevCwnd, currCwnd;
	if(serverDebugLevel >= 1) {
		printk("  Gap bootstrap %u\n", bootstrap_seq);
	}
	if(bootstrap_seq == (*cont)->TCPBase) {
		// corner case
		firstChild = bootstrap_seq + (*cont)->startCwnd;
		numChildren = 1;
	} else {
		prevCwnd = AckTCPCwndScalar(bootstrap_seq - 1, *cont);
		currCwnd = AckTCPCwndScalar(bootstrap_seq, *cont);
		firstChild = bootstrap_seq + prevCwnd;
		numChildren = currCwnd - prevCwnd + 1;
	}

	makePacket(&(*cont)->packets[numPackets],
		   bootstrap_seq, 0xdeadbeef, MTU, -1, 
		   PACKET_BOOTSTRAP, CONTTYPE_FULL1, CONTTYPE_FULL_MTU,
		   firstChild, numChildren);
	numPackets++;
      }
    }
    if(serverDebugLevel >= 1) {
      printk("  After RTX: %u packets\n", numPackets);
    }
  } else {
    if(serverDebugLevel >= 2) {
      printk("  Not after gap\n");
    }
  }
  /* Transmit bootstrap packets in 2nd half of recovery interval */
  BUG_TRAP((*cont)->continuationType == CONTTYPE_FULL1 ||
	   (*cont)->continuationType == CONTTYPE_FULL2);
  for(ack_seq = bootstrapIntersectStart;
      ack_seq <= bootstrapIntersectLast;
      ack_seq++) {
    /* Eventually, clock out newCwnd bootstrap packets. Clock out one
       here */
    __u32 seq = lastRegularPacket + 1 + (ack_seq - bootstrapStart);
    unsigned firstChild;
    int numChildren, prevCwnd, currCwnd;

    if(serverDebugLevel >= 1)
      printk("  Bootstrap %u\n", seq);

    /* copied from above */
    if(seq == (*cont)->TCPBase) {
      // corner case
      firstChild = seq + (*cont)->startCwnd;
      numChildren = 1;
    } else {
      prevCwnd = AckTCPCwndScalar(seq - 1, *cont);
      currCwnd = AckTCPCwndScalar(seq, *cont);
      firstChild = seq + prevCwnd;
      numChildren = currCwnd - prevCwnd + 1;
    }

    makePacket(&(*cont)->packets[numPackets],
	       seq, 0xdeadbeef, MTU, -1, PACKET_BOOTSTRAP, 
	       CONTTYPE_FULL1, MTU, firstChild, numChildren);
    numPackets++;
    if(serverDebugLevel >= 1) {
      printk("  After bootstrap: %u packets\n", numPackets);
    }
  }
  numPacketsSendable = numPackets;
  (*cont)->num_packets = numPackets;
  if(numPacketsSendable > numPacketsAllocated) {
    printk("Sendable = %d, allocated = %d\n", numPacketsSendable, numPacketsAllocated);
    BUG_TRAP(numPacketsSendable <= numPacketsAllocated);
  }

  DoUpcall((*cont), event);
  return 0;
    cc41:	31 c0                	xor    %eax,%eax
}
    cc43:	83 c4 74             	add    $0x74,%esp
    cc46:	5b                   	pop    %ebx
    cc47:	5e                   	pop    %esi
    cc48:	5f                   	pop    %edi
    cc49:	5d                   	pop    %ebp
    cc4a:	c3                   	ret    
    cc4b:	89 0c 24             	mov    %ecx,(%esp,1)
    cc4e:	8b 75 c0             	mov    0xffffffc0(%ebp),%esi
    cc51:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    cc55:	e8 96 08 00 00       	call   d4f0 <alloc_msk_packets>
    cc5a:	85 c0                	test   %eax,%eax
    cc5c:	0f 84 2d 04 00 00    	je     d08f <DoRecoveryStep+0x6cf>
    cc62:	8b 75 e4             	mov    0xffffffe4(%ebp),%esi
    cc65:	85 f6                	test   %esi,%esi
    cc67:	0f 84 04 04 00 00    	je     d071 <DoRecoveryStep+0x6b1>
    cc6d:	8b 1d 00 00 00 00    	mov    0x0,%ebx
    cc73:	85 db                	test   %ebx,%ebx
    cc75:	7e 34                	jle    ccab <DoRecoveryStep+0x2eb>
    cc77:	c7 04 24 e0 35 00 00 	movl   $0x35e0,(%esp,1)
    cc7e:	8b 75 d4             	mov    0xffffffd4(%ebp),%esi
    cc81:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    cc84:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    cc87:	89 74 24 0c          	mov    %esi,0xc(%esp,1)
    cc8b:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    cc8f:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    cc93:	e8 fc ff ff ff       	call   cc94 <DoRecoveryStep+0x2d4>
    cc98:	8b 4d d0             	mov    0xffffffd0(%ebp),%ecx
    cc9b:	c7 04 24 70 07 00 00 	movl   $0x770,(%esp,1)
    cca2:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    cca6:	e8 fc ff ff ff       	call   cca7 <DoRecoveryStep+0x2e7>
    ccab:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    ccae:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
    ccb1:	29 c8                	sub    %ecx,%eax
    ccb3:	83 f8 0a             	cmp    $0xa,%eax
    ccb6:	0f 8f 86 03 00 00    	jg     d042 <DoRecoveryStep+0x682>
    ccbc:	8b 75 e0             	mov    0xffffffe0(%ebp),%esi
    ccbf:	3b 75 dc             	cmp    0xffffffdc(%ebp),%esi
    ccc2:	0f 87 9d 01 00 00    	ja     ce65 <DoRecoveryStep+0x4a5>
    ccc8:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    cccb:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    ccce:	29 d0                	sub    %edx,%eax
    ccd0:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    ccd3:	8d 04 30             	lea    (%eax,%esi,1),%eax
    ccd6:	89 45 9c             	mov    %eax,0xffffff9c(%ebp)
    ccd9:	8d 04 92             	lea    (%edx,%edx,4),%eax
    ccdc:	c1 e0 03             	shl    $0x3,%eax
    ccdf:	89 45 98             	mov    %eax,0xffffff98(%ebp)
    cce2:	89 45 94             	mov    %eax,0xffffff94(%ebp)
    cce5:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    cce9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
    ccf0:	8b 1d 00 00 00 00    	mov    0x0,%ebx
    ccf6:	85 db                	test   %ebx,%ebx
    ccf8:	7e 10                	jle    cd0a <DoRecoveryStep+0x34a>
    ccfa:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    ccfe:	c7 04 24 8b 07 00 00 	movl   $0x78b,(%esp,1)
    cd05:	e8 fc ff ff ff       	call   cd06 <DoRecoveryStep+0x346>
			      __u8 type, 
			      __u8 contType, 
			      __u16 minResponseLen,
			      __u32 firstTransportChild, 
			      __u8 numTransportChildren) {
    cd0a:	8b 4d 08             	mov    0x8(%ebp),%ecx
    cd0d:	8b 55 94             	mov    0xffffff94(%ebp),%edx
    cd10:	8b 01                	mov    (%ecx),%eax
    cd12:	8b 88 e0 00 00 00    	mov    0xe0(%eax),%ecx
    cd18:	01 ca                	add    %ecx,%edx
  pkt->nonce = -1;
  pkt->seq = seq;
  //pkt->ack_seq = ack_seq;
  pkt->len = len;
  pkt->byteNum = byteNum;
  pkt->type = type;
    cd1a:	0f b6 42 10          	movzbl 0x10(%edx),%eax
    cd1e:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
    cd24:	89 72 04             	mov    %esi,0x4(%edx)
    cd27:	c7 42 08 52 05 00 00 	movl   $0x552,0x8(%edx)
    cd2e:	0c 01                	or     $0x1,%al
  pkt->contType = contType;
    cd30:	24 c1                	and    $0xc1,%al
    cd32:	c7 42 0c ff ff ff ff 	movl   $0xffffffff,0xc(%edx)
    cd39:	88 42 10             	mov    %al,0x10(%edx)
  pkt->minResponseLen = minResponseLen;
    cd3c:	66 c7 42 1c 52 05    	movw   $0x552,0x1c(%edx)
  pkt->firstTransportChild = firstTransportChild;
    cd42:	c7 42 20 ff ff ff ff 	movl   $0xffffffff,0x20(%edx)
  pkt->numTransportChildren = numTransportChildren;
    cd49:	c6 42 24 ff          	movb   $0xff,0x24(%edx)
  pkt->ucontLen = 0;
    cd4d:	c7 42 14 00 00 00 00 	movl   $0x0,0x14(%edx)
  pkt->ucontData = NULL;
    cd54:	c7 42 18 00 00 00 00 	movl   $0x0,0x18(%edx)
  pkt->numSiblings = -1;
    cd5b:	c6 42 11 ff          	movb   $0xff,0x11(%edx)
  pkt->position = INVALID_POSITION;
    cd5f:	c6 42 12 ff          	movb   $0xff,0x12(%edx)
    cd63:	83 45 98 28          	addl   $0x28,0xffffff98(%ebp)
    cd67:	83 45 94 28          	addl   $0x28,0xffffff94(%ebp)
    cd6b:	ff 45 d8             	incl   0xffffffd8(%ebp)
    cd6e:	3b 75 ec             	cmp    0xffffffec(%ebp),%esi
    cd71:	0f 82 e1 00 00 00    	jb     ce58 <DoRecoveryStep+0x498>
    cd77:	3b 75 e8             	cmp    0xffffffe8(%ebp),%esi
    cd7a:	0f 87 d8 00 00 00    	ja     ce58 <DoRecoveryStep+0x498>
    cd80:	8b 45 9c             	mov    0xffffff9c(%ebp),%eax
    cd83:	8b 15 00 00 00 00    	mov    0x0,%edx
    cd89:	40                   	inc    %eax
    cd8a:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
    cd8d:	85 d2                	test   %edx,%edx
    cd8f:	7e 10                	jle    cda1 <DoRecoveryStep+0x3e1>
    cd91:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    cd95:	c7 04 24 99 07 00 00 	movl   $0x799,(%esp,1)
    cd9c:	e8 fc ff ff ff       	call   cd9d <DoRecoveryStep+0x3dd>
    cda1:	8b 55 08             	mov    0x8(%ebp),%edx
    cda4:	8b 4d b0             	mov    0xffffffb0(%ebp),%ecx
    cda7:	8b 1a                	mov    (%edx),%ebx
    cda9:	3b 4b 70             	cmp    0x70(%ebx),%ecx
    cdac:	0f 84 7f 02 00 00    	je     d031 <DoRecoveryStep+0x671>
    cdb2:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    cdb6:	8b 45 9c             	mov    0xffffff9c(%ebp),%eax
    cdb9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    cdc0:	00 
    cdc1:	89 04 24             	mov    %eax,(%esp,1)
    cdc4:	e8 fc ff ff ff       	call   cdc5 <DoRecoveryStep+0x405>
    cdc9:	8b 55 08             	mov    0x8(%ebp),%edx
    cdcc:	89 c3                	mov    %eax,%ebx
    cdce:	8b 4d b0             	mov    0xffffffb0(%ebp),%ecx
    cdd1:	8b 02                	mov    (%edx),%eax
    cdd3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    cdda:	00 
    cddb:	89 0c 24             	mov    %ecx,(%esp,1)
    cdde:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    cde2:	e8 fc ff ff ff       	call   cde3 <DoRecoveryStep+0x423>
    cde7:	8b 4d b0             	mov    0xffffffb0(%ebp),%ecx
    cdea:	29 d8                	sub    %ebx,%eax
    cdec:	40                   	inc    %eax
    cded:	89 45 ac             	mov    %eax,0xffffffac(%ebp)
    cdf0:	8b 45 08             	mov    0x8(%ebp),%eax
    cdf3:	01 d9                	add    %ebx,%ecx
    cdf5:	8b 18                	mov    (%eax),%ebx
			      __u8 type, 
			      __u8 contType, 
			      __u16 minResponseLen,
			      __u32 firstTransportChild, 
			      __u8 numTransportChildren) {
    cdf7:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
    cdfd:	8b 55 98             	mov    0xffffff98(%ebp),%edx
    ce00:	01 c2                	add    %eax,%edx
  pkt->nonce = -1;
    ce02:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
  pkt->seq = seq;
    ce08:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
  //pkt->ack_seq = ack_seq;
  pkt->len = len;
    ce0b:	c7 42 08 52 05 00 00 	movl   $0x552,0x8(%edx)
  pkt->byteNum = byteNum;
    ce12:	c7 42 0c ff ff ff ff 	movl   $0xffffffff,0xc(%edx)
  pkt->type = type;
  pkt->contType = contType;
  pkt->minResponseLen = minResponseLen;
    ce19:	66 c7 42 1c 52 05    	movw   $0x552,0x1c(%edx)
    ce1f:	89 42 04             	mov    %eax,0x4(%edx)
    ce22:	0f b6 42 10          	movzbl 0x10(%edx),%eax
  pkt->firstTransportChild = firstTransportChild;
    ce26:	89 4a 20             	mov    %ecx,0x20(%edx)
    ce29:	24 ca                	and    $0xca,%al
    ce2b:	0c 0a                	or     $0xa,%al
    ce2d:	88 42 10             	mov    %al,0x10(%edx)
  pkt->numTransportChildren = numTransportChildren;
    ce30:	0f b6 4d ac          	movzbl 0xffffffac(%ebp),%ecx
  pkt->ucontLen = 0;
    ce34:	c7 42 14 00 00 00 00 	movl   $0x0,0x14(%edx)
  pkt->ucontData = NULL;
    ce3b:	c7 42 18 00 00 00 00 	movl   $0x0,0x18(%edx)
  pkt->numSiblings = -1;
    ce42:	c6 42 11 ff          	movb   $0xff,0x11(%edx)
  pkt->position = INVALID_POSITION;
    ce46:	c6 42 12 ff          	movb   $0xff,0x12(%edx)
    ce4a:	88 4a 24             	mov    %cl,0x24(%edx)
    ce4d:	83 45 98 28          	addl   $0x28,0xffffff98(%ebp)
    ce51:	83 45 94 28          	addl   $0x28,0xffffff94(%ebp)
    ce55:	ff 45 d8             	incl   0xffffffd8(%ebp)
    ce58:	ff 45 9c             	incl   0xffffff9c(%ebp)
    ce5b:	46                   	inc    %esi
    ce5c:	3b 75 dc             	cmp    0xffffffdc(%ebp),%esi
    ce5f:	0f 86 8b fe ff ff    	jbe    ccf0 <DoRecoveryStep+0x330>
    ce65:	a1 00 00 00 00       	mov    0x0,%eax
    ce6a:	85 c0                	test   %eax,%eax
    ce6c:	7e 13                	jle    ce81 <DoRecoveryStep+0x4c1>
    ce6e:	c7 04 24 ad 07 00 00 	movl   $0x7ad,(%esp,1)
    ce75:	8b 75 d8             	mov    0xffffffd8(%ebp),%esi
    ce78:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    ce7c:	e8 fc ff ff ff       	call   ce7d <DoRecoveryStep+0x4bd>
    ce81:	8b 55 08             	mov    0x8(%ebp),%edx
    ce84:	8b 02                	mov    (%edx),%eax
    ce86:	8b 40 38             	mov    0x38(%eax),%eax
    ce89:	48                   	dec    %eax
    ce8a:	83 f8 01             	cmp    $0x1,%eax
    ce8d:	0f 87 85 01 00 00    	ja     d018 <DoRecoveryStep+0x658>
    ce93:	89 7d c8             	mov    %edi,0xffffffc8(%ebp)
    ce96:	8b 4d b4             	mov    0xffffffb4(%ebp),%ecx
    ce99:	39 cf                	cmp    %ecx,%edi
    ce9b:	0f 87 0c 01 00 00    	ja     cfad <DoRecoveryStep+0x5ed>
    cea1:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    cea4:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    cea7:	29 75 c4             	sub    %esi,0xffffffc4(%ebp)
    ceaa:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    cead:	01 c7                	add    %eax,%edi
    ceaf:	8d 04 92             	lea    (%edx,%edx,4),%eax
    ceb2:	c1 e0 03             	shl    $0x3,%eax
    ceb5:	89 45 a0             	mov    %eax,0xffffffa0(%ebp)
    ceb8:	90                   	nop    
    ceb9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    cec0:	a1 00 00 00 00       	mov    0x0,%eax
    cec5:	8d 77 01             	lea    0x1(%edi),%esi
    cec8:	85 c0                	test   %eax,%eax
    ceca:	7e 10                	jle    cedc <DoRecoveryStep+0x51c>
    cecc:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    ced0:	c7 04 24 c6 07 00 00 	movl   $0x7c6,(%esp,1)
    ced7:	e8 fc ff ff ff       	call   ced8 <DoRecoveryStep+0x518>
    cedc:	8b 4d 08             	mov    0x8(%ebp),%ecx
    cedf:	8b 19                	mov    (%ecx),%ebx
    cee1:	3b 73 70             	cmp    0x70(%ebx),%esi
    cee4:	0f 84 1b 01 00 00    	je     d005 <DoRecoveryStep+0x645>
    ceea:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    ceee:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    cef5:	00 
    cef6:	89 3c 24             	mov    %edi,(%esp,1)
    cef9:	e8 fc ff ff ff       	call   cefa <DoRecoveryStep+0x53a>
    cefe:	8b 55 08             	mov    0x8(%ebp),%edx
    cf01:	89 c3                	mov    %eax,%ebx
    cf03:	8b 02                	mov    (%edx),%eax
    cf05:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    cf0c:	00 
    cf0d:	89 34 24             	mov    %esi,(%esp,1)
    cf10:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    cf14:	e8 fc ff ff ff       	call   cf15 <DoRecoveryStep+0x555>
    cf19:	8d 0c 33             	lea    (%ebx,%esi,1),%ecx
    cf1c:	29 d8                	sub    %ebx,%eax
    cf1e:	40                   	inc    %eax
    cf1f:	89 45 a8             	mov    %eax,0xffffffa8(%ebp)
    cf22:	8b 45 08             	mov    0x8(%ebp),%eax
    cf25:	8b 18                	mov    (%eax),%ebx
			      __u8 type, 
			      __u8 contType, 
			      __u16 minResponseLen,
			      __u32 firstTransportChild, 
			      __u8 numTransportChildren) {
    cf27:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
    cf2d:	8b 55 a0             	mov    0xffffffa0(%ebp),%edx
    cf30:	01 c2                	add    %eax,%edx
  pkt->nonce = -1;
  pkt->seq = seq;
  //pkt->ack_seq = ack_seq;
  pkt->len = len;
  pkt->byteNum = byteNum;
  pkt->type = type;
  pkt->contType = contType;
    cf32:	0f b6 42 10          	movzbl 0x10(%edx),%eax
    cf36:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
    cf3c:	89 72 04             	mov    %esi,0x4(%edx)
    cf3f:	c7 42 08 52 05 00 00 	movl   $0x552,0x8(%edx)
    cf46:	24 ca                	and    $0xca,%al
    cf48:	0c 0a                	or     $0xa,%al
    cf4a:	c7 42 0c ff ff ff ff 	movl   $0xffffffff,0xc(%edx)
    cf51:	88 42 10             	mov    %al,0x10(%edx)
  pkt->minResponseLen = minResponseLen;
    cf54:	66 c7 42 1c 52 05    	movw   $0x552,0x1c(%edx)
  pkt->firstTransportChild = firstTransportChild;
    cf5a:	89 4a 20             	mov    %ecx,0x20(%edx)
  pkt->numTransportChildren = numTransportChildren;
    cf5d:	0f b6 4d a8          	movzbl 0xffffffa8(%ebp),%ecx
  pkt->ucontLen = 0;
    cf61:	c7 42 14 00 00 00 00 	movl   $0x0,0x14(%edx)
  pkt->ucontData = NULL;
    cf68:	c7 42 18 00 00 00 00 	movl   $0x0,0x18(%edx)
  pkt->numSiblings = -1;
    cf6f:	c6 42 11 ff          	movb   $0xff,0x11(%edx)
  pkt->position = INVALID_POSITION;
    cf73:	c6 42 12 ff          	movb   $0xff,0x12(%edx)
    cf77:	88 4a 24             	mov    %cl,0x24(%edx)
    cf7a:	a1 00 00 00 00       	mov    0x0,%eax
    cf7f:	83 45 a0 28          	addl   $0x28,0xffffffa0(%ebp)
    cf83:	ff 45 d8             	incl   0xffffffd8(%ebp)
    cf86:	85 c0                	test   %eax,%eax
    cf88:	7e 13                	jle    cf9d <DoRecoveryStep+0x5dd>
    cf8a:	c7 04 24 20 36 00 00 	movl   $0x3620,(%esp,1)
    cf91:	8b 75 d8             	mov    0xffffffd8(%ebp),%esi
    cf94:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    cf98:	e8 fc ff ff ff       	call   cf99 <DoRecoveryStep+0x5d9>
    cf9d:	ff 45 c8             	incl   0xffffffc8(%ebp)
    cfa0:	47                   	inc    %edi
    cfa1:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
    cfa4:	39 45 c8             	cmp    %eax,0xffffffc8(%ebp)
    cfa7:	0f 86 13 ff ff ff    	jbe    cec0 <DoRecoveryStep+0x500>
    cfad:	8b 55 08             	mov    0x8(%ebp),%edx
    cfb0:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
    cfb3:	8b 02                	mov    (%edx),%eax
    cfb5:	89 88 dc 00 00 00    	mov    %ecx,0xdc(%eax)
    cfbb:	8b 75 c0             	mov    0xffffffc0(%ebp),%esi
    cfbe:	39 f1                	cmp    %esi,%ecx
    cfc0:	7f 19                	jg     cfdb <DoRecoveryStep+0x61b>
    cfc2:	8b 45 10             	mov    0x10(%ebp),%eax
    cfc5:	8b 55 08             	mov    0x8(%ebp),%edx
    cfc8:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    cfcc:	8b 02                	mov    (%edx),%eax
    cfce:	89 04 24             	mov    %eax,(%esp,1)
    cfd1:	e8 fc ff ff ff       	call   cfd2 <DoRecoveryStep+0x612>
    cfd6:	e9 66 fc ff ff       	jmp    cc41 <DoRecoveryStep+0x281>
    cfdb:	89 74 24 08          	mov    %esi,0x8(%esp,1)
    cfdf:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    cfe3:	c7 04 24 40 36 00 00 	movl   $0x3640,(%esp,1)
    cfea:	e8 fc ff ff ff       	call   cfeb <DoRecoveryStep+0x62b>
    cfef:	c7 44 24 04 e2 05 00 	movl   $0x5e2,0x4(%esp,1)
    cff6:	00 
    cff7:	c7 04 24 60 36 00 00 	movl   $0x3660,(%esp,1)
    cffe:	e8 fc ff ff ff       	call   cfff <DoRecoveryStep+0x63f>
    d003:	eb bd                	jmp    cfc2 <DoRecoveryStep+0x602>
    d005:	8b 43 68             	mov    0x68(%ebx),%eax
    d008:	89 f1                	mov    %esi,%ecx
    d00a:	c7 45 a8 01 00 00 00 	movl   $0x1,0xffffffa8(%ebp)
    d011:	01 c1                	add    %eax,%ecx
    d013:	e9 0f ff ff ff       	jmp    cf27 <DoRecoveryStep+0x567>
    d018:	c7 44 24 04 bd 05 00 	movl   $0x5bd,0x4(%esp,1)
    d01f:	00 
    d020:	c7 04 24 c0 36 00 00 	movl   $0x36c0,(%esp,1)
    d027:	e8 fc ff ff ff       	call   d028 <DoRecoveryStep+0x668>
    d02c:	e9 62 fe ff ff       	jmp    ce93 <DoRecoveryStep+0x4d3>
    d031:	8b 43 68             	mov    0x68(%ebx),%eax
    d034:	c7 45 ac 01 00 00 00 	movl   $0x1,0xffffffac(%ebp)
    d03b:	01 c1                	add    %eax,%ecx
    d03d:	e9 b5 fd ff ff       	jmp    cdf7 <DoRecoveryStep+0x437>
    d042:	8b 75 08             	mov    0x8(%ebp),%esi
    d045:	8b 06                	mov    (%esi),%eax
    d047:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    d04b:	8b 40 20             	mov    0x20(%eax),%eax
    d04e:	89 04 24             	mov    %eax,(%esp,1)
    d051:	e8 4a d5 ff ff       	call   a5a0 <free_trickles_msk>
    d056:	8b 06                	mov    (%esi),%eax
    d058:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    d05c:	8b 40 20             	mov    0x20(%eax),%eax
    d05f:	89 04 24             	mov    %eax,(%esp,1)
    d062:	e8 d9 d5 ff ff       	call   a640 <free_trickles_msk_finish>
    d067:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    d06c:	e9 d2 fb ff ff       	jmp    cc43 <DoRecoveryStep+0x283>
    d071:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    d078:	0f 8e 03 fe ff ff    	jle    ce81 <DoRecoveryStep+0x4c1>
    d07e:	c7 04 24 d6 07 00 00 	movl   $0x7d6,(%esp,1)
    d085:	e8 fc ff ff ff       	call   d086 <DoRecoveryStep+0x6c6>
    d08a:	e9 f2 fd ff ff       	jmp    ce81 <DoRecoveryStep+0x4c1>
    d08f:	8b 55 08             	mov    0x8(%ebp),%edx
    d092:	8b 02                	mov    (%edx),%eax
    d094:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    d098:	8b 40 20             	mov    0x20(%eax),%eax
    d09b:	89 04 24             	mov    %eax,(%esp,1)
    d09e:	e8 fd d4 ff ff       	call   a5a0 <free_trickles_msk>
    d0a3:	8b 4d 08             	mov    0x8(%ebp),%ecx
    d0a6:	8b 01                	mov    (%ecx),%eax
    d0a8:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    d0ac:	8b 40 20             	mov    0x20(%eax),%eax
    d0af:	89 04 24             	mov    %eax,(%esp,1)
    d0b2:	e8 89 d5 ff ff       	call   a640 <free_trickles_msk_finish>
    d0b7:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
    d0bc:	e9 82 fb ff ff       	jmp    cc43 <DoRecoveryStep+0x283>
    d0c1:	c7 04 24 e7 07 00 00 	movl   $0x7e7,(%esp,1)
    d0c8:	e8 fc ff ff ff       	call   d0c9 <DoRecoveryStep+0x709>
    d0cd:	8b 45 0c             	mov    0xc(%ebp),%eax
    d0d0:	89 04 24             	mov    %eax,(%esp,1)
    d0d3:	e8 fc ff ff ff       	call   d0d4 <DoRecoveryStep+0x714>
    d0d8:	e9 c3 fa ff ff       	jmp    cba0 <DoRecoveryStep+0x1e0>
    d0dd:	8d 76 00             	lea    0x0(%esi),%esi
    d0e0:	48                   	dec    %eax
    d0e1:	39 d0                	cmp    %edx,%eax
    d0e3:	0f 85 a1 fa ff ff    	jne    cb8a <DoRecoveryStep+0x1ca>
    d0e9:	8b 75 bc             	mov    0xffffffbc(%ebp),%esi
    d0ec:	85 f6                	test   %esi,%esi
    d0ee:	0f 84 96 fa ff ff    	je     cb8a <DoRecoveryStep+0x1ca>
    d0f4:	c7 45 e4 01 00 00 00 	movl   $0x1,0xffffffe4(%ebp)
    d0fb:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
    d0fe:	8b 75 90             	mov    0xffffff90(%ebp),%esi
    d101:	8b 10                	mov    (%eax),%edx
    d103:	4e                   	dec    %esi
    d104:	89 75 dc             	mov    %esi,0xffffffdc(%ebp)
    d107:	42                   	inc    %edx
    d108:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
    d10b:	e9 7a fa ff ff       	jmp    cb8a <DoRecoveryStep+0x1ca>
    d110:	8b 75 08             	mov    0x8(%ebp),%esi
    d113:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
    d116:	8b 06                	mov    (%esi),%eax
    d118:	89 50 6c             	mov    %edx,0x6c(%eax)
    d11b:	e9 ca f9 ff ff       	jmp    caea <DoRecoveryStep+0x12a>
    d120:	c7 04 24 60 37 00 00 	movl   $0x3760,(%esp,1)
    d127:	e8 fc ff ff ff       	call   d128 <DoRecoveryStep+0x768>
    d12c:	e9 11 ff ff ff       	jmp    d042 <DoRecoveryStep+0x682>
    d131:	8b 45 0c             	mov    0xc(%ebp),%eax
    d134:	89 04 24             	mov    %eax,(%esp,1)
    d137:	e8 fc ff ff ff       	call   d138 <DoRecoveryStep+0x778>
    d13c:	8b 4d 08             	mov    0x8(%ebp),%ecx
    d13f:	83 e8 02             	sub    $0x2,%eax
    d142:	8b 11                	mov    (%ecx),%edx
    d144:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    d14b:	00 
    d14c:	89 04 24             	mov    %eax,(%esp,1)
    d14f:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    d153:	e8 fc ff ff ff       	call   d154 <DoRecoveryStep+0x794>
    d158:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,0xffffffcc(%ebp)
    d15f:	89 c7                	mov    %eax,%edi
    d161:	e9 2a f9 ff ff       	jmp    ca90 <DoRecoveryStep+0xd0>
    d166:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    d169:	89 0c 24             	mov    %ecx,(%esp,1)
    d16c:	e8 fc ff ff ff       	call   d16d <DoRecoveryStep+0x7ad>
    d171:	8b 4d 08             	mov    0x8(%ebp),%ecx
    d174:	48                   	dec    %eax
    d175:	8b 11                	mov    (%ecx),%edx
    d177:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    d17e:	00 
    d17f:	89 04 24             	mov    %eax,(%esp,1)
    d182:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    d186:	e8 fc ff ff ff       	call   d187 <DoRecoveryStep+0x7c7>
    d18b:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
    d192:	89 c7                	mov    %eax,%edi
    d194:	e9 f7 f8 ff ff       	jmp    ca90 <DoRecoveryStep+0xd0>
    d199:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    d1a0:	b8 01 00 00 00       	mov    $0x1,%eax
    d1a5:	e9 d4 f8 ff ff       	jmp    ca7e <DoRecoveryStep+0xbe>
    d1aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    d1b0:	8b 1d 00 00 00 00    	mov    0x0,%ebx
    d1b6:	85 db                	test   %ebx,%ebx
    d1b8:	74 1e                	je     d1d8 <DoRecoveryStep+0x818>
    d1ba:	8b 55 08             	mov    0x8(%ebp),%edx
    d1bd:	8b 02                	mov    (%edx),%eax
    d1bf:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    d1c3:	8b 40 20             	mov    0x20(%eax),%eax
    d1c6:	89 04 24             	mov    %eax,(%esp,1)
    d1c9:	e8 d2 d3 ff ff       	call   a5a0 <free_trickles_msk>
    d1ce:	8b 4d 08             	mov    0x8(%ebp),%ecx
    d1d1:	8b 01                	mov    (%ecx),%eax
    d1d3:	e9 80 fe ff ff       	jmp    d058 <DoRecoveryStep+0x698>
    d1d8:	c7 04 24 a0 37 00 00 	movl   $0x37a0,(%esp,1)
    d1df:	e8 fc ff ff ff       	call   d1e0 <DoRecoveryStep+0x820>
    d1e4:	eb d4                	jmp    d1ba <DoRecoveryStep+0x7fa>
    d1e6:	8d 76 00             	lea    0x0(%esi),%esi
    d1e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

0000d1f0 <DoSlowStartStep>:

static int DoSlowStartStep(CONTINUATION_TYPE **cont, AckProof *ackProof, __u32 newBase, enum cminisock_event_tag event) {
    d1f0:	55                   	push   %ebp
    d1f1:	89 e5                	mov    %esp,%ebp
  (*cont)->executionTrace = 3;
    d1f3:	ba 03 00 00 00       	mov    $0x3,%edx
    d1f8:	53                   	push   %ebx
    d1f9:	83 ec 0c             	sub    $0xc,%esp
    d1fc:	8b 5d 08             	mov    0x8(%ebp),%ebx
    d1ff:	8b 03                	mov    (%ebx),%eax
    d201:	89 90 d0 00 00 00    	mov    %edx,0xd0(%eax)

  int right = AckProof_findRight(ackProof, (*cont)->TCPBase);
    d207:	8b 03                	mov    (%ebx),%eax
    d209:	8b 40 70             	mov    0x70(%eax),%eax
    d20c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    d210:	8b 45 0c             	mov    0xc(%ebp),%eax
    d213:	89 04 24             	mov    %eax,(%esp,1)
    d216:	e8 fc ff ff ff       	call   d217 <DoSlowStartStep+0x27>
    d21b:	8b 13                	mov    (%ebx),%edx
    d21d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    d224:	00 
    d225:	89 04 24             	mov    %eax,(%esp,1)
    d228:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    d22c:	e8 fc ff ff ff       	call   d22d <DoSlowStartStep+0x3d>
  int effCwnd = AckTCPCwndScalar(right, (*cont));
#ifndef ZERO_SSTHRESH_PROTECTION_HACK
  (*cont)->ssthresh = effCwnd / MULT_FACTOR;
#else
  if(effCwnd >= MULT_FACTOR) {
    d231:	83 f8 01             	cmp    $0x1,%eax
    d234:	89 c1                	mov    %eax,%ecx
    d236:	0f 8e 04 01 00 00    	jle    d340 <DoSlowStartStep+0x150>
    (*cont)->ssthresh = effCwnd / MULT_FACTOR;
    d23c:	8b 13                	mov    (%ebx),%edx
    d23e:	c1 e8 1f             	shr    $0x1f,%eax
    d241:	8d 04 08             	lea    (%eax,%ecx,1),%eax
    d244:	d1 f8                	sar    %eax
    d246:	89 42 6c             	mov    %eax,0x6c(%edx)
  } else {
    (*cont)->ssthresh /= 2;
  }
#endif

  (*cont)->TCPBase = newBase;
    d249:	8b 13                	mov    (%ebx),%edx
    d24b:	8b 45 10             	mov    0x10(%ebp),%eax
    d24e:	89 42 70             	mov    %eax,0x70(%edx)
  (*cont)->startCwnd = 1;
    d251:	8b 03                	mov    (%ebx),%eax
    d253:	c7 40 68 01 00 00 00 	movl   $0x1,0x68(%eax)

  (*cont)->actualCwnd = (*cont)->startCwnd;
    d25a:	8b 13                	mov    (%ebx),%edx
    d25c:	8b 42 68             	mov    0x68(%edx),%eax
    d25f:	89 82 d4 00 00 00    	mov    %eax,0xd4(%edx)

#if 1
  if(!alloc_msk_packets((*cont), 1)) {
    d265:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
    d26c:	00 
    d26d:	8b 03                	mov    (%ebx),%eax
    d26f:	89 04 24             	mov    %eax,(%esp,1)
    d272:	e8 79 02 00 00       	call   d4f0 <alloc_msk_packets>
    d277:	85 c0                	test   %eax,%eax
    d279:	0f 84 97 00 00 00    	je     d316 <DoSlowStartStep+0x126>
			      __u8 type, 
			      __u8 contType, 
			      __u16 minResponseLen,
			      __u32 firstTransportChild, 
			      __u8 numTransportChildren) {
    d27f:	8b 03                	mov    (%ebx),%eax
    d281:	8b 90 e0 00 00 00    	mov    0xe0(%eax),%edx
    d287:	8b 40 70             	mov    0x70(%eax),%eax
  pkt->nonce = -1;
    d28a:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
    d290:	8d 48 01             	lea    0x1(%eax),%ecx
  pkt->seq = seq;
    d293:	89 42 04             	mov    %eax,0x4(%edx)
  //pkt->ack_seq = ack_seq;
  pkt->len = len;
  pkt->byteNum = byteNum;
  pkt->type = type;
  pkt->contType = contType;
    d296:	0f b6 42 10          	movzbl 0x10(%edx),%eax
    d29a:	c7 42 08 52 05 00 00 	movl   $0x552,0x8(%edx)
    d2a1:	c7 42 0c ff ff ff ff 	movl   $0xffffffff,0xc(%edx)
  pkt->minResponseLen = minResponseLen;
    d2a8:	66 c7 42 1c 52 05    	movw   $0x552,0x1c(%edx)
    d2ae:	24 c0                	and    $0xc0,%al
    d2b0:	0c 08                	or     $0x8,%al
    d2b2:	88 42 10             	mov    %al,0x10(%edx)
  pkt->firstTransportChild = firstTransportChild;
    d2b5:	89 4a 20             	mov    %ecx,0x20(%edx)
  pkt->numTransportChildren = numTransportChildren;
    d2b8:	c6 42 24 01          	movb   $0x1,0x24(%edx)
  pkt->ucontLen = 0;
    d2bc:	c7 42 14 00 00 00 00 	movl   $0x0,0x14(%edx)
  pkt->ucontData = NULL;
    d2c3:	c7 42 18 00 00 00 00 	movl   $0x0,0x18(%edx)
  pkt->numSiblings = -1;
    d2ca:	c6 42 11 ff          	movb   $0xff,0x11(%edx)
  pkt->position = INVALID_POSITION;
    d2ce:	c6 42 12 ff          	movb   $0xff,0x12(%edx)
	  free_trickles_msk((*cont)->sk, (*cont));
	  free_trickles_msk_finish((*cont)->sk, (*cont));
	  return -ENOMEM;
  }
  makePacket(&(*cont)->packets[0], (*cont)->TCPBase, 0xdeadbeef, MTU, -1, PTYPE_FIRST | PACKET_NORMAL, CONTTYPE_FULL1, 
	     CONTTYPE_FULL_MTU, (*cont)->TCPBase + 1, 1);
#else
  if(!alloc_msk_packets((*cont), 2)) {
	  free_trickles_msk((*cont)->sk, (*cont));
	  free_trickles_msk_finish((*cont)->sk, (*cont));
	  return -ENOMEM;
  }
  makePacket(&(*cont)->packets[0], (*cont)->TCPBase, 0xdeadbeef, MTU, -1, 
	     PTYPE_FIRST | PACKET_NORMAL, CONTTYPE_FULL1, 
	     CONTTYPE_FULL_MTU, (*cont)->TCPBase + 1, 1);

  makePacket(&(*cont)->packets[1], (*cont)->TCPBase, 0xdeadbeef, MTU, -1, 
	     PACKET_NORMAL, CONTTYPE_FULL1, 
	     CONTTYPE_FULL_MTU, (*cont)->TCPBase + 2, 1);
#endif

  if(serverDebugLevel >= 1)
    d2d2:	a1 00 00 00 00       	mov    0x0,%eax
    d2d7:	85 c0                	test   %eax,%eax
    d2d9:	7e 22                	jle    d2fd <DoSlowStartStep+0x10d>
	  printk("slow start step TCPBase - %u seq - %u\n", (*cont)->TCPBase, 
    d2db:	8b 13                	mov    (%ebx),%edx
    d2dd:	8b 82 e0 00 00 00    	mov    0xe0(%edx),%eax
    d2e3:	8b 40 04             	mov    0x4(%eax),%eax
    d2e6:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    d2ea:	8b 42 70             	mov    0x70(%edx),%eax
    d2ed:	c7 04 24 e0 37 00 00 	movl   $0x37e0,(%esp,1)
    d2f4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    d2f8:	e8 fc ff ff ff       	call   d2f9 <DoSlowStartStep+0x109>
		 (*cont)->packets[0].seq);

  DoUpcall((*cont), event);
    d2fd:	8b 45 14             	mov    0x14(%ebp),%eax
    d300:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    d304:	8b 03                	mov    (%ebx),%eax
    d306:	89 04 24             	mov    %eax,(%esp,1)
    d309:	e8 fc ff ff ff       	call   d30a <DoSlowStartStep+0x11a>
  return 0;
    d30e:	31 c0                	xor    %eax,%eax
}
    d310:	83 c4 0c             	add    $0xc,%esp
    d313:	5b                   	pop    %ebx
    d314:	5d                   	pop    %ebp
    d315:	c3                   	ret    
    d316:	8b 03                	mov    (%ebx),%eax
    d318:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    d31c:	8b 40 20             	mov    0x20(%eax),%eax
    d31f:	89 04 24             	mov    %eax,(%esp,1)
    d322:	e8 79 d2 ff ff       	call   a5a0 <free_trickles_msk>
    d327:	8b 03                	mov    (%ebx),%eax
    d329:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    d32d:	8b 40 20             	mov    0x20(%eax),%eax
    d330:	89 04 24             	mov    %eax,(%esp,1)
    d333:	e8 08 d3 ff ff       	call   a640 <free_trickles_msk_finish>
    d338:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
    d33d:	eb d1                	jmp    d310 <DoSlowStartStep+0x120>
    d33f:	90                   	nop    
    d340:	8b 03                	mov    (%ebx),%eax
    d342:	d1 68 6c             	shrl   0x6c(%eax)
    d345:	e9 ff fe ff ff       	jmp    d249 <DoSlowStartStep+0x59>
    d34a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000d350 <AckTCPCwndScalar>:
    d350:	55                   	push   %ebp
    d351:	89 e5                	mov    %esp,%ebp
    d353:	83 ec 0c             	sub    $0xc,%esp
    d356:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    d35d:	00 
    d35e:	8b 45 0c             	mov    0xc(%ebp),%eax
    d361:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    d365:	8b 45 08             	mov    0x8(%ebp),%eax
    d368:	89 04 24             	mov    %eax,(%esp,1)
    d36b:	e8 fc ff ff ff       	call   d36c <AckTCPCwndScalar+0x1c>
    d370:	89 ec                	mov    %ebp,%esp
    d372:	5d                   	pop    %ebp
    d373:	c3                   	ret    
    d374:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    d37a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0000d380 <Sack_contains>:
    d380:	55                   	push   %ebp
    d381:	89 e5                	mov    %esp,%ebp
    d383:	8b 4d 08             	mov    0x8(%ebp),%ecx
    d386:	8b 45 0c             	mov    0xc(%ebp),%eax
    d389:	31 d2                	xor    %edx,%edx
    d38b:	39 01                	cmp    %eax,(%ecx)
    d38d:	77 0b                	ja     d39a <Sack_contains+0x1a>
    d38f:	3b 41 04             	cmp    0x4(%ecx),%eax
    d392:	b8 01 00 00 00       	mov    $0x1,%eax
    d397:	0f 46 d0             	cmovbe %eax,%edx
    d39a:	5d                   	pop    %ebp
    d39b:	89 d0                	mov    %edx,%eax
    d39d:	c3                   	ret    
    d39e:	89 f6                	mov    %esi,%esi

0000d3a0 <Sack_gapLen>:
    d3a0:	55                   	push   %ebp
    d3a1:	89 e5                	mov    %esp,%ebp
    d3a3:	8b 45 0c             	mov    0xc(%ebp),%eax
    d3a6:	8b 55 08             	mov    0x8(%ebp),%edx
    d3a9:	5d                   	pop    %ebp
    d3aa:	8b 00                	mov    (%eax),%eax
    d3ac:	8b 4a 04             	mov    0x4(%edx),%ecx
    d3af:	29 c8                	sub    %ecx,%eax
    d3b1:	48                   	dec    %eax
    d3b2:	c3                   	ret    
    d3b3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    d3b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

0000d3c0 <Sack_adjacent>:
    d3c0:	55                   	push   %ebp
    d3c1:	89 e5                	mov    %esp,%ebp
    d3c3:	8b 45 0c             	mov    0xc(%ebp),%eax
    d3c6:	8b 10                	mov    (%eax),%edx
    d3c8:	8b 45 08             	mov    0x8(%ebp),%eax
    d3cb:	5d                   	pop    %ebp
    d3cc:	4a                   	dec    %edx
    d3cd:	3b 50 04             	cmp    0x4(%eax),%edx
    d3d0:	0f 94 c0             	sete   %al
    d3d3:	0f b6 c0             	movzbl %al,%eax
    d3d6:	c3                   	ret    
    d3d7:	89 f6                	mov    %esi,%esi
    d3d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

0000d3e0 <__constant_memcpy>:
 * This looks horribly ugly, but the compiler can optimize it totally,
 * as the count is constant.
 */
static inline void * __constant_memcpy(void * to, const void * from, size_t n)
{
    d3e0:	55                   	push   %ebp
    d3e1:	89 e5                	mov    %esp,%ebp
    d3e3:	83 ec 0c             	sub    $0xc,%esp
    d3e6:	89 75 f8             	mov    %esi,0xfffffff8(%ebp)
    d3e9:	8b 4d 10             	mov    0x10(%ebp),%ecx
    d3ec:	8b 55 08             	mov    0x8(%ebp),%edx
    d3ef:	89 7d fc             	mov    %edi,0xfffffffc(%ebp)
	switch (n) {
    d3f2:	83 f9 14             	cmp    $0x14,%ecx
    d3f5:	8b 75 0c             	mov    0xc(%ebp),%esi
    d3f8:	0f 87 82 00 00 00    	ja     d480 <__constant_memcpy+0xa0>
    d3fe:	ff 24 8d d0 00 00 00 	jmp    *0xd0(,%ecx,4)
		case 0:
			return to;
		case 1:
			*(unsigned char *)to = *(const unsigned char *)from;
    d405:	0f b6 06             	movzbl (%esi),%eax
    d408:	88 02                	mov    %al,(%edx)
    d40a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			return to;
		case 2:
			*(unsigned short *)to = *(const unsigned short *)from;
			return to;
		case 3:
			*(unsigned short *)to = *(const unsigned short *)from;
			*(2+(unsigned char *)to) = *(2+(const unsigned char *)from);
			return to;
		case 4:
			*(unsigned long *)to = *(const unsigned long *)from;
			return to;
		case 6:	/* for Ethernet addresses */
			*(unsigned long *)to = *(const unsigned long *)from;
			*(2+(unsigned short *)to) = *(2+(const unsigned short *)from);
			return to;
		case 8:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			return to;
		case 12:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
			return to;
		case 16:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
			*(3+(unsigned long *)to) = *(3+(const unsigned long *)from);
			return to;
		case 20:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
			*(3+(unsigned long *)to) = *(3+(const unsigned long *)from);
			*(4+(unsigned long *)to) = *(4+(const unsigned long *)from);
			return to;
	}
#define COMMON(x) \
__asm__ __volatile__( \
	"rep ; movsl" \
	x \
	: "=&c" (d0), "=&D" (d1), "=&S" (d2) \
	: "0" (n/4),"1" ((long) to),"2" ((long) from) \
	: "memory");
{
	int d0, d1, d2;
	switch (n % 4) {
		case 0: COMMON(""); return to;
		case 1: COMMON("\n\tmovsb"); return to;
		case 2: COMMON("\n\tmovsw"); return to;
		default: COMMON("\n\tmovsw\n\tmovsb"); return to;
	}
}
  
#undef COMMON
}
    d410:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
    d413:	89 d0                	mov    %edx,%eax
    d415:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
    d418:	89 ec                	mov    %ebp,%esp
    d41a:	5d                   	pop    %ebp
    d41b:	c3                   	ret    
    d41c:	0f b7 06             	movzwl (%esi),%eax
    d41f:	66 89 02             	mov    %ax,(%edx)
    d422:	eb ec                	jmp    d410 <__constant_memcpy+0x30>
    d424:	0f b7 06             	movzwl (%esi),%eax
    d427:	66 89 02             	mov    %ax,(%edx)
    d42a:	0f b6 46 02          	movzbl 0x2(%esi),%eax
    d42e:	88 42 02             	mov    %al,0x2(%edx)
    d431:	eb dd                	jmp    d410 <__constant_memcpy+0x30>
    d433:	8b 06                	mov    (%esi),%eax
    d435:	89 02                	mov    %eax,(%edx)
    d437:	eb d7                	jmp    d410 <__constant_memcpy+0x30>
    d439:	8b 06                	mov    (%esi),%eax
    d43b:	89 02                	mov    %eax,(%edx)
    d43d:	0f b7 46 04          	movzwl 0x4(%esi),%eax
    d441:	66 89 42 04          	mov    %ax,0x4(%edx)
    d445:	eb c9                	jmp    d410 <__constant_memcpy+0x30>
    d447:	8b 06                	mov    (%esi),%eax
    d449:	89 02                	mov    %eax,(%edx)
    d44b:	8b 46 04             	mov    0x4(%esi),%eax
    d44e:	89 42 04             	mov    %eax,0x4(%edx)
    d451:	eb bd                	jmp    d410 <__constant_memcpy+0x30>
    d453:	8b 06                	mov    (%esi),%eax
    d455:	89 02                	mov    %eax,(%edx)
    d457:	8b 46 04             	mov    0x4(%esi),%eax
    d45a:	89 42 04             	mov    %eax,0x4(%edx)
    d45d:	8b 46 08             	mov    0x8(%esi),%eax
    d460:	89 42 08             	mov    %eax,0x8(%edx)
    d463:	eb ab                	jmp    d410 <__constant_memcpy+0x30>
    d465:	8b 06                	mov    (%esi),%eax
    d467:	89 02                	mov    %eax,(%edx)
    d469:	8b 46 04             	mov    0x4(%esi),%eax
    d46c:	89 42 04             	mov    %eax,0x4(%edx)
    d46f:	8b 46 08             	mov    0x8(%esi),%eax
    d472:	89 42 08             	mov    %eax,0x8(%edx)
    d475:	8b 46 0c             	mov    0xc(%esi),%eax
    d478:	89 42 0c             	mov    %eax,0xc(%edx)
    d47b:	eb 93                	jmp    d410 <__constant_memcpy+0x30>
    d47d:	8d 76 00             	lea    0x0(%esi),%esi
    d480:	89 c8                	mov    %ecx,%eax
    d482:	83 e0 03             	and    $0x3,%eax
    d485:	83 f8 01             	cmp    $0x1,%eax
    d488:	74 36                	je     d4c0 <__constant_memcpy+0xe0>
    d48a:	83 f8 01             	cmp    $0x1,%eax
    d48d:	72 22                	jb     d4b1 <__constant_memcpy+0xd1>
    d48f:	83 f8 02             	cmp    $0x2,%eax
    d492:	74 0f                	je     d4a3 <__constant_memcpy+0xc3>
    d494:	c1 e9 02             	shr    $0x2,%ecx
    d497:	89 d7                	mov    %edx,%edi
    d499:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    d49b:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    d49d:	a4                   	movsb  %ds:(%esi),%es:(%edi)
    d49e:	e9 6d ff ff ff       	jmp    d410 <__constant_memcpy+0x30>
    d4a3:	c1 e9 02             	shr    $0x2,%ecx
    d4a6:	89 d7                	mov    %edx,%edi
    d4a8:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    d4aa:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    d4ac:	e9 5f ff ff ff       	jmp    d410 <__constant_memcpy+0x30>
    d4b1:	c1 e9 02             	shr    $0x2,%ecx
    d4b4:	89 d7                	mov    %edx,%edi
    d4b6:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    d4b8:	e9 53 ff ff ff       	jmp    d410 <__constant_memcpy+0x30>
    d4bd:	8d 76 00             	lea    0x0(%esi),%esi
    d4c0:	c1 e9 02             	shr    $0x2,%ecx
    d4c3:	89 d7                	mov    %edx,%edi
    d4c5:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    d4c7:	a4                   	movsb  %ds:(%esi),%es:(%edi)
    d4c8:	e9 43 ff ff ff       	jmp    d410 <__constant_memcpy+0x30>
    d4cd:	8b 06                	mov    (%esi),%eax
    d4cf:	89 02                	mov    %eax,(%edx)
    d4d1:	8b 46 04             	mov    0x4(%esi),%eax
    d4d4:	89 42 04             	mov    %eax,0x4(%edx)
    d4d7:	8b 46 08             	mov    0x8(%esi),%eax
    d4da:	89 42 08             	mov    %eax,0x8(%edx)
    d4dd:	8b 46 0c             	mov    0xc(%esi),%eax
    d4e0:	89 42 0c             	mov    %eax,0xc(%edx)
    d4e3:	8b 46 10             	mov    0x10(%esi),%eax
    d4e6:	89 42 10             	mov    %eax,0x10(%edx)
    d4e9:	e9 22 ff ff ff       	jmp    d410 <__constant_memcpy+0x30>
    d4ee:	89 f6                	mov    %esi,%esi

0000d4f0 <alloc_msk_packets>:
#endif

#ifndef USERTEST

static inline int alloc_msk_packets(struct cminisock *msk, int numPackets) {
    d4f0:	55                   	push   %ebp
    d4f1:	89 e5                	mov    %esp,%ebp
    d4f3:	56                   	push   %esi
    d4f4:	53                   	push   %ebx
    d4f5:	83 ec 10             	sub    $0x10,%esp
    d4f8:	8b 5d 08             	mov    0x8(%ebp),%ebx
    d4fb:	8b 75 0c             	mov    0xc(%ebp),%esi
	BUG_TRAP(msk->num_packets == 0);
    d4fe:	8b 83 dc 00 00 00    	mov    0xdc(%ebx),%eax
    d504:	85 c0                	test   %eax,%eax
    d506:	0f 85 e5 01 00 00    	jne    d6f1 <alloc_msk_packets+0x201>
	BUG_TRAP(numPackets >= 0);
    d50c:	85 f6                	test   %esi,%esi
    d50e:	0f 88 c4 01 00 00    	js     d6d8 <alloc_msk_packets+0x1e8>
#define MAX_NUM_SIMULATION_PACKETS (8000)
	static struct cminisock_packet packets[NR_CPUS][MAX_NUM_SIMULATION_PACKETS];
	if(!SIMULATION_MODE(msk->sk)) {
    d514:	8b 53 20             	mov    0x20(%ebx),%edx
    d517:	8b 82 a8 02 00 00    	mov    0x2a8(%edx),%eax
    d51d:	a9 01 00 00 00       	test   $0x1,%eax
    d522:	74 09                	je     d52d <alloc_msk_packets+0x3d>
    d524:	83 e0 08             	and    $0x8,%eax
    d527:	0f 84 e3 00 00 00    	je     d610 <alloc_msk_packets+0x120>
		msk->packets = tmalloc(msk->sk, sizeof(struct cminisock_packet) * numPackets);
    d52d:	89 14 24             	mov    %edx,(%esp,1)
    d530:	8d 04 b6             	lea    (%esi,%esi,4),%eax
    d533:	c1 e0 03             	shl    $0x3,%eax
    d536:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    d53a:	e8 fc ff ff ff       	call   d53b <alloc_msk_packets+0x4b>
    d53f:	89 83 e0 00 00 00    	mov    %eax,0xe0(%ebx)
		if(msk->packets == NULL) {
    d545:	85 c0                	test   %eax,%eax
    d547:	0f 85 b3 00 00 00    	jne    d600 <alloc_msk_packets+0x110>
			if(trickles_ratelimit()) {
    d54d:	a1 00 00 00 00       	mov    0x0,%eax
    d552:	9c                   	pushf  
    d553:	59                   	pop    %ecx
    d554:	fa                   	cli    
    d555:	89 c2                	mov    %eax,%edx
    d557:	8b 35 80 b4 0e 00    	mov    0xeb480,%esi
    d55d:	8b 1d dc 00 00 00    	mov    0xdc,%ebx
    d563:	a3 80 b4 0e 00       	mov    %eax,0xeb480
    d568:	29 f2                	sub    %esi,%edx
    d56a:	01 da                	add    %ebx,%edx
    d56c:	89 15 dc 00 00 00    	mov    %edx,0xdc
    d572:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    d578:	76 10                	jbe    d58a <alloc_msk_packets+0x9a>
    d57a:	be 88 13 00 00       	mov    $0x1388,%esi
    d57f:	ba 88 13 00 00       	mov    $0x1388,%edx
    d584:	89 35 dc 00 00 00    	mov    %esi,0xdc
    d58a:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    d590:	76 61                	jbe    d5f3 <alloc_msk_packets+0x103>
    d592:	31 db                	xor    %ebx,%ebx
    d594:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    d59a:	a1 84 b4 0e 00       	mov    0xeb484,%eax
    d59f:	89 15 dc 00 00 00    	mov    %edx,0xdc
    d5a5:	89 1d 84 b4 0e 00    	mov    %ebx,0xeb484
    d5ab:	51                   	push   %ecx
    d5ac:	9d                   	popf   
    d5ad:	85 c0                	test   %eax,%eax
    d5af:	75 20                	jne    d5d1 <alloc_msk_packets+0xe1>
    d5b1:	b8 01 00 00 00       	mov    $0x1,%eax
    d5b6:	85 c0                	test   %eax,%eax
    d5b8:	75 09                	jne    d5c3 <alloc_msk_packets+0xd3>
				printk("out of memory while tmalloc()'ing space for packets\n");
			}
			return 0;
		}
	} else {
		// avoid malloc
		if(numPackets <= MAX_NUM_SIMULATION_PACKETS) {
			msk->packets = packets[smp_processor_id()];
		} else {
			msk->packets = NULL;
			if(trickles_ratelimit()) {
				printk("Too many packets requested during simulation\n");
			}
			return 0;
    d5ba:	31 c0                	xor    %eax,%eax
		}
	}
	msk->num_packets = numPackets;
	return 1;
}
    d5bc:	83 c4 10             	add    $0x10,%esp
    d5bf:	5b                   	pop    %ebx
    d5c0:	5e                   	pop    %esi
    d5c1:	5d                   	pop    %ebp
    d5c2:	c3                   	ret    
    d5c3:	c7 04 24 20 38 00 00 	movl   $0x3820,(%esp,1)
    d5ca:	e8 fc ff ff ff       	call   d5cb <alloc_msk_packets+0xdb>
    d5cf:	eb e9                	jmp    d5ba <alloc_msk_packets+0xca>
    d5d1:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    d5d5:	c7 44 24 08 7b 03 00 	movl   $0x37b,0x8(%esp,1)
    d5dc:	00 
    d5dd:	c7 44 24 04 60 38 00 	movl   $0x3860,0x4(%esp,1)
    d5e4:	00 
    d5e5:	c7 04 24 00 30 00 00 	movl   $0x3000,(%esp,1)
    d5ec:	e8 fc ff ff ff       	call   d5ed <alloc_msk_packets+0xfd>
    d5f1:	eb be                	jmp    d5b1 <alloc_msk_packets+0xc1>
    d5f3:	ff 05 84 b4 0e 00    	incl   0xeb484
    d5f9:	51                   	push   %ecx
    d5fa:	9d                   	popf   
    d5fb:	31 c0                	xor    %eax,%eax
    d5fd:	eb b7                	jmp    d5b6 <alloc_msk_packets+0xc6>
    d5ff:	90                   	nop    
    d600:	89 b3 dc 00 00 00    	mov    %esi,0xdc(%ebx)
    d606:	b8 01 00 00 00       	mov    $0x1,%eax
    d60b:	eb af                	jmp    d5bc <alloc_msk_packets+0xcc>
    d60d:	8d 76 00             	lea    0x0(%esi),%esi
    d610:	81 fe 40 1f 00 00    	cmp    $0x1f40,%esi
    d616:	7f 0d                	jg     d625 <alloc_msk_packets+0x135>
    d618:	b8 80 d2 09 00       	mov    $0x9d280,%eax
    d61d:	89 83 e0 00 00 00    	mov    %eax,0xe0(%ebx)
    d623:	eb db                	jmp    d600 <alloc_msk_packets+0x110>
    d625:	31 c0                	xor    %eax,%eax
    d627:	89 83 e0 00 00 00    	mov    %eax,0xe0(%ebx)
    d62d:	a1 00 00 00 00       	mov    0x0,%eax
    d632:	9c                   	pushf  
    d633:	59                   	pop    %ecx
    d634:	fa                   	cli    
    d635:	89 c2                	mov    %eax,%edx
    d637:	8b 35 88 b4 0e 00    	mov    0xeb488,%esi
    d63d:	8b 1d e0 00 00 00    	mov    0xe0,%ebx
    d643:	a3 88 b4 0e 00       	mov    %eax,0xeb488
    d648:	29 f2                	sub    %esi,%edx
    d64a:	01 da                	add    %ebx,%edx
    d64c:	89 15 e0 00 00 00    	mov    %edx,0xe0
    d652:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    d658:	76 10                	jbe    d66a <alloc_msk_packets+0x17a>
    d65a:	be 88 13 00 00       	mov    $0x1388,%esi
    d65f:	ba 88 13 00 00       	mov    $0x1388,%edx
    d664:	89 35 e0 00 00 00    	mov    %esi,0xe0
    d66a:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    d670:	76 5a                	jbe    d6cc <alloc_msk_packets+0x1dc>
    d672:	31 db                	xor    %ebx,%ebx
    d674:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    d67a:	a1 8c b4 0e 00       	mov    0xeb48c,%eax
    d67f:	89 15 e0 00 00 00    	mov    %edx,0xe0
    d685:	89 1d 8c b4 0e 00    	mov    %ebx,0xeb48c
    d68b:	51                   	push   %ecx
    d68c:	9d                   	popf   
    d68d:	85 c0                	test   %eax,%eax
    d68f:	75 19                	jne    d6aa <alloc_msk_packets+0x1ba>
    d691:	b8 01 00 00 00       	mov    $0x1,%eax
    d696:	85 c0                	test   %eax,%eax
    d698:	0f 84 1c ff ff ff    	je     d5ba <alloc_msk_packets+0xca>
    d69e:	c7 04 24 a0 38 00 00 	movl   $0x38a0,(%esp,1)
    d6a5:	e9 20 ff ff ff       	jmp    d5ca <alloc_msk_packets+0xda>
    d6aa:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    d6ae:	c7 44 24 08 86 03 00 	movl   $0x386,0x8(%esp,1)
    d6b5:	00 
    d6b6:	c7 44 24 04 60 38 00 	movl   $0x3860,0x4(%esp,1)
    d6bd:	00 
    d6be:	c7 04 24 00 30 00 00 	movl   $0x3000,(%esp,1)
    d6c5:	e8 fc ff ff ff       	call   d6c6 <alloc_msk_packets+0x1d6>
    d6ca:	eb c5                	jmp    d691 <alloc_msk_packets+0x1a1>
    d6cc:	ff 05 8c b4 0e 00    	incl   0xeb48c
    d6d2:	51                   	push   %ecx
    d6d3:	9d                   	popf   
    d6d4:	31 c0                	xor    %eax,%eax
    d6d6:	eb be                	jmp    d696 <alloc_msk_packets+0x1a6>
    d6d8:	c7 44 24 04 75 03 00 	movl   $0x375,0x4(%esp,1)
    d6df:	00 
    d6e0:	c7 04 24 e0 38 00 00 	movl   $0x38e0,(%esp,1)
    d6e7:	e8 fc ff ff ff       	call   d6e8 <alloc_msk_packets+0x1f8>
    d6ec:	e9 23 fe ff ff       	jmp    d514 <alloc_msk_packets+0x24>
    d6f1:	c7 44 24 04 74 03 00 	movl   $0x374,0x4(%esp,1)
    d6f8:	00 
    d6f9:	c7 04 24 40 39 00 00 	movl   $0x3940,(%esp,1)
    d700:	e8 fc ff ff ff       	call   d701 <alloc_msk_packets+0x211>
    d705:	e9 02 fe ff ff       	jmp    d50c <alloc_msk_packets+0x1c>
    d70a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000d710 <alloc_trickles_msk>:

static inline 
int can_alloc_trickles_msk(struct sock *sk) {
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
	struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
	struct cminisock *curr = 
		(struct cminisock *)head->next;
	while((struct alloc_head_list*)curr != head && curr->ctl == ALLOC_PROCESSING) {
		//printk("alloc_head loop\n");
		curr = curr->next;
	}
	return (struct alloc_head_list*)curr != head;
}

static inline struct cminisock *alloc_trickles_msk(struct sock *sk) {
    d710:	55                   	push   %ebp
    d711:	89 e5                	mov    %esp,%ebp
    d713:	57                   	push   %edi
    d714:	56                   	push   %esi
    d715:	53                   	push   %ebx
    d716:	83 ec 0c             	sub    $0xc,%esp
    d719:	8b 75 08             	mov    0x8(%ebp),%esi
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
	struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
	struct cminisock *rval = NULL, *curr = (struct cminisock *)tp->cminisock_api_config.msk_freelist.next;

	if(!SIMULATION_MODE(sk)) {
    d71c:	8b 96 a8 02 00 00    	mov    0x2a8(%esi),%edx
    d722:	8d be bc 00 00 00    	lea    0xbc(%esi),%edi
    d728:	8d 8e 90 02 00 00    	lea    0x290(%esi),%ecx
    d72e:	8b 87 d8 01 00 00    	mov    0x1d8(%edi),%eax
    d734:	f7 c2 01 00 00 00    	test   $0x1,%edx
    d73a:	74 09                	je     d745 <alloc_trickles_msk+0x35>
    d73c:	83 e2 08             	and    $0x8,%edx
    d73f:	0f 84 91 00 00 00    	je     d7d6 <alloc_trickles_msk+0xc6>
		while((struct alloc_head_list*)curr != head && curr->ctl == ALLOC_PROCESSING) {
    d745:	39 c8                	cmp    %ecx,%eax
    d747:	74 77                	je     d7c0 <alloc_trickles_msk+0xb0>
    d749:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
    d74d:	74 75                	je     d7c4 <alloc_trickles_msk+0xb4>
			//printk("alloc_head loop\n");
			curr = curr->next;
		}
		//printk("out of alloc_head loop\n");

		if((struct alloc_head_list *)curr == head) return NULL;
    d74f:	39 c8                	cmp    %ecx,%eax
    d751:	74 6d                	je     d7c0 <alloc_trickles_msk+0xb0>
	
		rval = curr;
    d753:	89 c3                	mov    %eax,%ebx
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    d755:	8b 50 04             	mov    0x4(%eax),%edx
    d758:	8b 00                	mov    (%eax),%eax
    d75a:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    d75c:	8b 03                	mov    (%ebx),%eax
	elem->prev = elem->next = NULL;
    d75e:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    d764:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
    d767:	8b 43 08             	mov    0x8(%ebx),%eax
    d76a:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    d771:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    d774:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		}
		tp->t.responseCount++;

		rval->sk = sk;
		rval->ctl = ALLOC_PENDING;
    d77b:	c7 43 0c 02 00 00 00 	movl   $0x2,0xc(%ebx)
    d782:	31 c0                	xor    %eax,%eax
    d784:	89 83 dc 00 00 00    	mov    %eax,0xdc(%ebx)
    d78a:	31 c0                	xor    %eax,%eax
    d78c:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
    d792:	31 c0                	xor    %eax,%eax
    d794:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
    d79a:	31 c0                	xor    %eax,%eax
    d79c:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
    d7a2:	31 c0                	xor    %eax,%eax
    d7a4:	89 83 e0 00 00 00    	mov    %eax,0xe0(%ebx)
	}

	init_minisock(rval);

	return rval;
    d7aa:	89 d8                	mov    %ebx,%eax
    d7ac:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
}
    d7b3:	83 c4 0c             	add    $0xc,%esp
    d7b6:	5b                   	pop    %ebx
    d7b7:	5e                   	pop    %esi
    d7b8:	5f                   	pop    %edi
    d7b9:	5d                   	pop    %ebp
    d7ba:	c3                   	ret    
    d7bb:	90                   	nop    
    d7bc:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    d7c0:	31 c0                	xor    %eax,%eax
    d7c2:	eb ef                	jmp    d7b3 <alloc_trickles_msk+0xa3>
    d7c4:	8b 40 04             	mov    0x4(%eax),%eax
    d7c7:	39 c8                	cmp    %ecx,%eax
    d7c9:	74 f5                	je     d7c0 <alloc_trickles_msk+0xb0>
    d7cb:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
    d7cf:	74 f3                	je     d7c4 <alloc_trickles_msk+0xb4>
    d7d1:	e9 79 ff ff ff       	jmp    d74f <alloc_trickles_msk+0x3f>
    d7d6:	8b 97 54 0b 00 00    	mov    0xb54(%edi),%edx
    d7dc:	85 d2                	test   %edx,%edx
    d7de:	75 28                	jne    d808 <alloc_trickles_msk+0xf8>
    d7e0:	8b 9f 3c 0b 00 00    	mov    0xb3c(%edi),%ebx
    d7e6:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    d7ed:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    d7f3:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    d7fa:	ff 87 54 0b 00 00    	incl   0xb54(%edi)
    d800:	89 73 20             	mov    %esi,0x20(%ebx)
    d803:	e9 73 ff ff ff       	jmp    d77b <alloc_trickles_msk+0x6b>
    d808:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    d80f:	00 
    d810:	c7 04 24 e4 00 00 00 	movl   $0xe4,(%esp,1)
    d817:	e8 fc ff ff ff       	call   d818 <alloc_trickles_msk+0x108>
    d81c:	85 c0                	test   %eax,%eax
    d81e:	89 c3                	mov    %eax,%ebx
    d820:	74 73                	je     d895 <alloc_trickles_msk+0x185>
    d822:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    d828:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    d82f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	elem->list = head;
	head->len++;
}

static inline void insert_tail(struct alloc_head_list *head, struct alloc_head *elem) {
    d836:	8d 86 fc 0b 00 00    	lea    0xbfc(%esi),%eax
    d83c:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
    d83f:	8b 86 fc 0b 00 00    	mov    0xbfc(%esi),%eax
    d845:	39 d8                	cmp    %ebx,%eax
    d847:	74 1f                	je     d868 <alloc_trickles_msk+0x158>
		BUG();
		show_stack(NULL);
	}
	elem->prev = head->prev;
    d849:	89 03                	mov    %eax,(%ebx)
	head->prev->next = elem;
    d84b:	8b 86 fc 0b 00 00    	mov    0xbfc(%esi),%eax
    d851:	89 58 04             	mov    %ebx,0x4(%eax)

	elem->next = (struct alloc_head*)head;
    d854:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    d857:	89 43 04             	mov    %eax,0x4(%ebx)

	elem->list = head;
    d85a:	89 43 08             	mov    %eax,0x8(%ebx)
	head->prev = elem;
	head->len++;
    d85d:	ff 40 10             	incl   0x10(%eax)
    d860:	89 9e fc 0b 00 00    	mov    %ebx,0xbfc(%esi)
    d866:	eb 92                	jmp    d7fa <alloc_trickles_msk+0xea>
    d868:	c7 44 24 04 cc 05 00 	movl   $0x5cc,0x4(%esp,1)
    d86f:	00 
    d870:	c7 04 24 d0 05 00 00 	movl   $0x5d0,(%esp,1)
    d877:	e8 fc ff ff ff       	call   d878 <alloc_trickles_msk+0x168>
    d87c:	e8 fc ff ff ff       	call   d87d <alloc_trickles_msk+0x16d>
    d881:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    d888:	e8 fc ff ff ff       	call   d889 <alloc_trickles_msk+0x179>
    d88d:	8b 86 fc 0b 00 00    	mov    0xbfc(%esi),%eax
    d893:	eb b4                	jmp    d849 <alloc_trickles_msk+0x139>
			rval->next = rval->prev = NULL;
		} else {
			rval = kmalloc(sizeof (struct cminisock), GFP_ATOMIC);
			if(rval == NULL) {
				printk("out of memory during compatibility mode\n");
    d895:	c7 04 24 c0 39 00 00 	movl   $0x39c0,(%esp,1)
    d89c:	e8 fc ff ff ff       	call   d89d <alloc_trickles_msk+0x18d>
    d8a1:	e9 1a ff ff ff       	jmp    d7c0 <alloc_trickles_msk+0xb0>
    d8a6:	8d 76 00             	lea    0x0(%esi),%esi
    d8a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

0000d8b0 <marshallContinuationServer>:
  do{						\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

MARSHALL_CONTINUATION(Server, 1, SERVER_COMPUTE_MAC)
    d8b0:	55                   	push   %ebp
    d8b1:	89 e5                	mov    %esp,%ebp
    d8b3:	57                   	push   %edi
    d8b4:	56                   	push   %esi
    d8b5:	53                   	push   %ebx
    d8b6:	83 ec 30             	sub    $0x30,%esp
    d8b9:	8b 75 10             	mov    0x10(%ebp),%esi
    d8bc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    d8bf:	8b 7d 14             	mov    0x14(%ebp),%edi
    d8c2:	8b 46 3c             	mov    0x3c(%esi),%eax
    d8c5:	85 ff                	test   %edi,%edi
    d8c7:	89 43 09             	mov    %eax,0x9(%ebx)
    d8ca:	8b 46 40             	mov    0x40(%esi),%eax
    d8cd:	89 43 0d             	mov    %eax,0xd(%ebx)
    d8d0:	0f 88 0c 01 00 00    	js     d9e2 <marshallContinuationServer+0x132>
    d8d6:	8b 86 e0 00 00 00    	mov    0xe0(%esi),%eax
    d8dc:	8d 14 bf             	lea    (%edi,%edi,4),%edx
    d8df:	c1 e2 03             	shl    $0x3,%edx
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    d8e2:	8b 44 10 04          	mov    0x4(%eax,%edx,1),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    d8e6:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    d8e8:	89 43 01             	mov    %eax,0x1(%ebx)
  do{						\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

MARSHALL_CONTINUATION(Server, 1, SERVER_COMPUTE_MAC)
    d8eb:	8b 86 e0 00 00 00    	mov    0xe0(%esi),%eax
    d8f1:	0f b6 44 10 10       	movzbl 0x10(%eax,%edx,1),%eax
    d8f6:	c6 43 05 00          	movb   $0x0,0x5(%ebx)
    d8fa:	c0 e8 03             	shr    $0x3,%al
    d8fd:	24 07                	and    $0x7,%al
    d8ff:	88 03                	mov    %al,(%ebx)
    d901:	8b 86 e0 00 00 00    	mov    0xe0(%esi),%eax
    d907:	0f b6 44 10 10       	movzbl 0x10(%eax,%edx,1),%eax
    d90c:	24 03                	and    $0x3,%al
    d90e:	0f b6 f8             	movzbl %al,%edi
    d911:	83 ff 02             	cmp    $0x2,%edi
    d914:	0f 8f aa 00 00 00    	jg     d9c4 <marshallContinuationServer+0x114>
    d91a:	0f b6 04 bd ac 00 00 	movzbl 0xac(,%edi,4),%eax
    d921:	00 
    d922:	88 43 2d             	mov    %al,0x2d(%ebx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    d925:	8b 46 4c             	mov    0x4c(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    d928:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    d92a:	89 43 25             	mov    %eax,0x25(%ebx)
  do{						\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

MARSHALL_CONTINUATION(Server, 1, SERVER_COMPUTE_MAC)
    d92d:	8b 46 50             	mov    0x50(%esi),%eax
    d930:	89 43 11             	mov    %eax,0x11(%ebx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    d933:	8b 46 54             	mov    0x54(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    d936:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    d938:	89 43 29             	mov    %eax,0x29(%ebx)
    d93b:	8b 46 60             	mov    0x60(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    d93e:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    d940:	89 43 2e             	mov    %eax,0x2e(%ebx)
    d943:	8b 46 64             	mov    0x64(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    d946:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    d948:	89 43 32             	mov    %eax,0x32(%ebx)
    d94b:	8b 46 68             	mov    0x68(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    d94e:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    d950:	89 43 36             	mov    %eax,0x36(%ebx)
    d953:	8b 46 6c             	mov    0x6c(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    d956:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    d958:	89 43 3a             	mov    %eax,0x3a(%ebx)
    d95b:	8b 46 70             	mov    0x70(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    d95e:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    d960:	89 43 3e             	mov    %eax,0x3e(%ebx)
  do{						\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

MARSHALL_CONTINUATION(Server, 1, SERVER_COMPUTE_MAC)
    d963:	8b 46 74             	mov    0x74(%esi),%eax
    d966:	8b 56 78             	mov    0x78(%esi),%edx
    d969:	89 43 42             	mov    %eax,0x42(%ebx)
    d96c:	8b 43 01             	mov    0x1(%ebx),%eax
    d96f:	89 53 46             	mov    %edx,0x46(%ebx)
    d972:	8d 55 d4             	lea    0xffffffd4(%ebp),%edx
    d975:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
    d978:	0f b6 03             	movzbl (%ebx),%eax
    d97b:	88 45 d8             	mov    %al,0xffffffd8(%ebp)
    d97e:	80 7b 05 00          	cmpb   $0x0,0x5(%ebx)
    d982:	0f 95 45 d9          	setne  0xffffffd9(%ebp)
    d986:	8b 46 14             	mov    0x14(%esi),%eax
    d989:	89 45 da             	mov    %eax,0xffffffda(%ebp)
    d98c:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
    d990:	66 89 45 de          	mov    %ax,0xffffffde(%ebp)
    d994:	8b 46 18             	mov    0x18(%esi),%eax
    d997:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    d99a:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
    d99e:	89 5c 24 08          	mov    %ebx,0x8(%esp,1)
    d9a2:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    d9a6:	66 89 45 e4          	mov    %ax,0xffffffe4(%ebp)
    d9aa:	8d 43 15             	lea    0x15(%ebx),%eax
    d9ad:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    d9b1:	8b 45 08             	mov    0x8(%ebp),%eax
    d9b4:	89 04 24             	mov    %eax,(%esp,1)
    d9b7:	e8 fc ff ff ff       	call   d9b8 <marshallContinuationServer+0x108>
    d9bc:	83 c4 30             	add    $0x30,%esp
    d9bf:	5b                   	pop    %ebx
    d9c0:	5e                   	pop    %esi
    d9c1:	5f                   	pop    %edi
    d9c2:	5d                   	pop    %ebp
    d9c3:	c3                   	ret    
    d9c4:	c7 44 24 04 cc 05 00 	movl   $0x5cc,0x4(%esp,1)
    d9cb:	00 
    d9cc:	c7 04 24 d0 05 00 00 	movl   $0x5d0,(%esp,1)
    d9d3:	e8 fc ff ff ff       	call   d9d4 <marshallContinuationServer+0x124>
    d9d8:	e8 fc ff ff ff       	call   d9d9 <marshallContinuationServer+0x129>
    d9dd:	e9 38 ff ff ff       	jmp    d91a <marshallContinuationServer+0x6a>
    d9e2:	c7 44 24 04 51 00 00 	movl   $0x51,0x4(%esp,1)
    d9e9:	00 
    d9ea:	c7 04 24 00 3a 00 00 	movl   $0x3a00,(%esp,1)
    d9f1:	e8 fc ff ff ff       	call   d9f2 <marshallContinuationServer+0x142>
    d9f6:	e9 db fe ff ff       	jmp    d8d6 <marshallContinuationServer+0x26>
    d9fb:	90                   	nop    
    d9fc:	90                   	nop    
    d9fd:	90                   	nop    
    d9fe:	90                   	nop    
    d9ff:	90                   	nop    

0000da00 <free_trickles_msk>:
/* Two phase free: first phase disconnects socket from event list,
   sets to ALLOC_PROCESSING; second phase adds the socket to free
   list, sets to ALLOC_FREE and ready for reuse */
#ifndef USERTEST
static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk) {
    da00:	55                   	push   %ebp
    da01:	89 e5                	mov    %esp,%ebp
    da03:	83 ec 0c             	sub    $0xc,%esp
    da06:	89 5d fc             	mov    %ebx,0xfffffffc(%ebp)
	if(!SIMULATION_MODE(sk)) {
    da09:	8b 45 08             	mov    0x8(%ebp),%eax
    da0c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    da0f:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    da15:	a9 01 00 00 00       	test   $0x1,%eax
    da1a:	74 05                	je     da21 <free_trickles_msk+0x21>
    da1c:	83 e0 08             	and    $0x8,%eax
    da1f:	74 16                	je     da37 <free_trickles_msk+0x37>
		if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) {
    da21:	8b 43 0c             	mov    0xc(%ebx),%eax
    da24:	85 c0                	test   %eax,%eax
    da26:	74 48                	je     da70 <free_trickles_msk+0x70>
    da28:	83 f8 03             	cmp    $0x3,%eax
    da2b:	74 43                	je     da70 <free_trickles_msk+0x70>
			printk("double free\n");
			BUG();
		}
		if(msk->ctl == ALLOC_READY && msk->prev != NULL) {
    da2d:	48                   	dec    %eax
    da2e:	74 10                	je     da40 <free_trickles_msk+0x40>
			unlink((struct alloc_head *)msk);
		}
		msk->ctl = ALLOC_PROCESSING;
    da30:	c7 43 0c 03 00 00 00 	movl   $0x3,0xc(%ebx)
	}
}
    da37:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
    da3a:	89 ec                	mov    %ebp,%esp
    da3c:	5d                   	pop    %ebp
    da3d:	c3                   	ret    
    da3e:	89 f6                	mov    %esi,%esi
    da40:	8b 03                	mov    (%ebx),%eax
    da42:	85 c0                	test   %eax,%eax
    da44:	74 ea                	je     da30 <free_trickles_msk+0x30>
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    da46:	8b 53 04             	mov    0x4(%ebx),%edx
    da49:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    da4b:	8b 03                	mov    (%ebx),%eax
	elem->prev = elem->next = NULL;
    da4d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    da53:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
    da56:	8b 43 08             	mov    0x8(%ebx),%eax
    da59:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    da60:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    da63:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    da6a:	eb c4                	jmp    da30 <free_trickles_msk+0x30>
    da6c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
#ifndef USERTEST
static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk) {
	if(!SIMULATION_MODE(sk)) {
		if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) {
			printk("double free\n");
    da70:	c7 04 24 f5 07 00 00 	movl   $0x7f5,(%esp,1)
    da77:	e8 fc ff ff ff       	call   da78 <free_trickles_msk+0x78>
			BUG();
    da7c:	c7 44 24 04 02 08 00 	movl   $0x802,0x4(%esp,1)
    da83:	00 
    da84:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp,1)
    da8b:	e8 fc ff ff ff       	call   da8c <free_trickles_msk+0x8c>
    da90:	e8 fc ff ff ff       	call   da91 <free_trickles_msk+0x91>
    da95:	8b 43 0c             	mov    0xc(%ebx),%eax
    da98:	eb 93                	jmp    da2d <free_trickles_msk+0x2d>
    da9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000daa0 <free_trickles_msk_finish>:
		}
		if(msk->ctl == ALLOC_READY && msk->prev != NULL) {
			unlink((struct alloc_head *)msk);
		}
		msk->ctl = ALLOC_PROCESSING;
	}
}

static inline void free_trickles_msk_finish(struct sock *sk, struct cminisock *msk) {
    daa0:	55                   	push   %ebp
    daa1:	89 e5                	mov    %esp,%ebp
    daa3:	57                   	push   %edi
    daa4:	56                   	push   %esi
    daa5:	31 f6                	xor    %esi,%esi
    daa7:	53                   	push   %ebx
    daa8:	83 ec 10             	sub    $0x10,%esp
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
    daab:	8b 45 08             	mov    0x8(%ebp),%eax
	struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
    daae:	8b 55 08             	mov    0x8(%ebp),%edx
    dab1:	8b 7d 0c             	mov    0xc(%ebp),%edi
    dab4:	05 bc 00 00 00       	add    $0xbc,%eax
    dab9:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    dabc:	81 c2 90 02 00 00    	add    $0x290,%edx
    dac2:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
    dac5:	8b 97 dc 00 00 00    	mov    0xdc(%edi),%edx
    dacb:	39 d6                	cmp    %edx,%esi
    dacd:	7d 2b                	jge    dafa <free_trickles_msk_finish+0x5a>
    dacf:	31 db                	xor    %ebx,%ebx
    dad1:	eb 0d                	jmp    dae0 <free_trickles_msk_finish+0x40>
    dad3:	90                   	nop    
    dad4:	90                   	nop    
    dad5:	90                   	nop    
    dad6:	90                   	nop    
    dad7:	90                   	nop    
    dad8:	90                   	nop    
    dad9:	90                   	nop    
    dada:	90                   	nop    
    dadb:	90                   	nop    
    dadc:	90                   	nop    
    dadd:	90                   	nop    
    dade:	90                   	nop    
    dadf:	90                   	nop    
    dae0:	8b 87 e0 00 00 00    	mov    0xe0(%edi),%eax
    dae6:	8b 44 18 18          	mov    0x18(%eax,%ebx,1),%eax
    daea:	85 c0                	test   %eax,%eax
    daec:	0f 85 6e 01 00 00    	jne    dc60 <free_trickles_msk_finish+0x1c0>
    daf2:	46                   	inc    %esi
    daf3:	83 c3 28             	add    $0x28,%ebx
    daf6:	39 d6                	cmp    %edx,%esi
    daf8:	7c e6                	jl     dae0 <free_trickles_msk_finish+0x40>
    dafa:	8b 55 08             	mov    0x8(%ebp),%edx
    dafd:	8b 82 a8 02 00 00    	mov    0x2a8(%edx),%eax
    db03:	a9 01 00 00 00       	test   $0x1,%eax
    db08:	74 05                	je     db0f <free_trickles_msk_finish+0x6f>
    db0a:	83 e0 08             	and    $0x8,%eax
    db0d:	74 0e                	je     db1d <free_trickles_msk_finish+0x7d>
    db0f:	8b 87 e0 00 00 00    	mov    0xe0(%edi),%eax
    db15:	85 c0                	test   %eax,%eax
    db17:	0f 85 2d 01 00 00    	jne    dc4a <free_trickles_msk_finish+0x1aa>
    db1d:	8b 87 80 00 00 00    	mov    0x80(%edi),%eax
    db23:	85 c0                	test   %eax,%eax
    db25:	0f 85 0b 01 00 00    	jne    dc36 <free_trickles_msk_finish+0x196>
    db2b:	8b 87 88 00 00 00    	mov    0x88(%edi),%eax
    db31:	85 c0                	test   %eax,%eax
    db33:	0f 85 e9 00 00 00    	jne    dc22 <free_trickles_msk_finish+0x182>

	free_minisock(sk,msk);
	if(!SIMULATION_MODE(sk)) {
    db39:	8b 55 08             	mov    0x8(%ebp),%edx
    db3c:	8b 82 a8 02 00 00    	mov    0x2a8(%edx),%eax
    db42:	a9 01 00 00 00       	test   $0x1,%eax
    db47:	74 09                	je     db52 <free_trickles_msk_finish+0xb2>
    db49:	83 e0 08             	and    $0x8,%eax
    db4c:	0f 84 89 00 00 00    	je     dbdb <free_trickles_msk_finish+0x13b>
		if(msk->ctl != ALLOC_PROCESSING && msk->ctl != ALLOC_HALFFREE) {
    db52:	8b 47 0c             	mov    0xc(%edi),%eax
    db55:	83 e8 03             	sub    $0x3,%eax
    db58:	83 f8 01             	cmp    $0x1,%eax
    db5b:	77 57                	ja     dbb4 <free_trickles_msk_finish+0x114>
	if(elem->list) {
		BUG();
	}
#endif
	if(head->next == elem /* || elem->prev != NULL || elem->next != NULL */) {
    db5d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    db60:	39 78 04             	cmp    %edi,0x4(%eax)
    db63:	74 28                	je     db8d <free_trickles_msk_finish+0xed>
		BUG();
		show_stack(NULL);	
	}
	elem->next = head->next;
    db65:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    db68:	8b 42 04             	mov    0x4(%edx),%eax
    db6b:	89 47 04             	mov    %eax,0x4(%edi)
	head->next->prev = elem;
    db6e:	8b 42 04             	mov    0x4(%edx),%eax
    db71:	89 38                	mov    %edi,(%eax)

	elem->prev = (struct alloc_head*)head;
    db73:	89 17                	mov    %edx,(%edi)
	head->next = elem;
    db75:	89 7a 04             	mov    %edi,0x4(%edx)

	elem->list = head;
    db78:	89 57 08             	mov    %edx,0x8(%edi)
	head->len++;
    db7b:	ff 42 10             	incl   0x10(%edx)
			printk("free_rstcp_msk_finish without corresponding free_rstcp_msk\n");
			BUG();
		}
		insert_head(head, (struct alloc_head *)msk);
		msk->ctl = ALLOC_FREE;
    db7e:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
	} else {
		if(msk == tp->t.responseMSK) {
		} else {
			// overflow
			unlink((struct alloc_head*)msk);
			kfree(msk);
		}
		tp->t.responseCount--;
	}
	
}
    db85:	83 c4 10             	add    $0x10,%esp
    db88:	5b                   	pop    %ebx
    db89:	5e                   	pop    %esi
    db8a:	5f                   	pop    %edi
    db8b:	5d                   	pop    %ebp
    db8c:	c3                   	ret    
		BUG();
	}
#endif
	if(head->next == elem /* || elem->prev != NULL || elem->next != NULL */) {
		BUG();
    db8d:	c7 44 24 04 02 08 00 	movl   $0x802,0x4(%esp,1)
    db94:	00 
    db95:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp,1)
    db9c:	e8 fc ff ff ff       	call   db9d <free_trickles_msk_finish+0xfd>
    dba1:	e8 fc ff ff ff       	call   dba2 <free_trickles_msk_finish+0x102>
		show_stack(NULL);	
    dba6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    dbad:	e8 fc ff ff ff       	call   dbae <free_trickles_msk_finish+0x10e>
    dbb2:	eb b1                	jmp    db65 <free_trickles_msk_finish+0xc5>

	free_minisock(sk,msk);
	if(!SIMULATION_MODE(sk)) {
		if(msk->ctl != ALLOC_PROCESSING && msk->ctl != ALLOC_HALFFREE) {
			printk("free_rstcp_msk_finish without corresponding free_rstcp_msk\n");
    dbb4:	c7 04 24 80 3a 00 00 	movl   $0x3a80,(%esp,1)
    dbbb:	e8 fc ff ff ff       	call   dbbc <free_trickles_msk_finish+0x11c>
			BUG();
    dbc0:	c7 44 24 04 02 08 00 	movl   $0x802,0x4(%esp,1)
    dbc7:	00 
    dbc8:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp,1)
    dbcf:	e8 fc ff ff ff       	call   dbd0 <free_trickles_msk_finish+0x130>
    dbd4:	e8 fc ff ff ff       	call   dbd5 <free_trickles_msk_finish+0x135>
    dbd9:	eb 82                	jmp    db5d <free_trickles_msk_finish+0xbd>
		}
		insert_head(head, (struct alloc_head *)msk);
		msk->ctl = ALLOC_FREE;
	} else {
		if(msk == tp->t.responseMSK) {
    dbdb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    dbde:	3b b8 3c 0b 00 00    	cmp    0xb3c(%eax),%edi
    dbe4:	74 2e                	je     dc14 <free_trickles_msk_finish+0x174>
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    dbe6:	8b 57 04             	mov    0x4(%edi),%edx
    dbe9:	8b 07                	mov    (%edi),%eax
    dbeb:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    dbed:	8b 07                	mov    (%edi),%eax
	elem->prev = elem->next = NULL;
    dbef:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    dbf5:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
    dbf8:	8b 47 08             	mov    0x8(%edi),%eax
    dbfb:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
    dc02:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    dc05:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
		if(msk == tp->t.responseMSK) {
		} else {
			// overflow
			unlink((struct alloc_head*)msk);
			kfree(msk);
    dc0c:	89 3c 24             	mov    %edi,(%esp,1)
    dc0f:	e8 fc ff ff ff       	call   dc10 <free_trickles_msk_finish+0x170>
		}
		tp->t.responseCount--;
    dc14:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    dc17:	ff 8a 54 0b 00 00    	decl   0xb54(%edx)
    dc1d:	e9 63 ff ff ff       	jmp    db85 <free_trickles_msk_finish+0xe5>
    dc22:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    dc26:	8b 45 08             	mov    0x8(%ebp),%eax
    dc29:	89 04 24             	mov    %eax,(%esp,1)
    dc2c:	e8 fc ff ff ff       	call   dc2d <free_trickles_msk_finish+0x18d>
    dc31:	e9 03 ff ff ff       	jmp    db39 <free_trickles_msk_finish+0x99>
    dc36:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    dc3a:	8b 55 08             	mov    0x8(%ebp),%edx
    dc3d:	89 14 24             	mov    %edx,(%esp,1)
    dc40:	e8 fc ff ff ff       	call   dc41 <free_trickles_msk_finish+0x1a1>
    dc45:	e9 e1 fe ff ff       	jmp    db2b <free_trickles_msk_finish+0x8b>
    dc4a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    dc4e:	8b 45 08             	mov    0x8(%ebp),%eax
    dc51:	89 04 24             	mov    %eax,(%esp,1)
    dc54:	e8 fc ff ff ff       	call   dc55 <free_trickles_msk_finish+0x1b5>
    dc59:	e9 bf fe ff ff       	jmp    db1d <free_trickles_msk_finish+0x7d>
    dc5e:	89 f6                	mov    %esi,%esi
    dc60:	89 04 24             	mov    %eax,(%esp,1)
    dc63:	e8 fc ff ff ff       	call   dc64 <free_trickles_msk_finish+0x1c4>
    dc68:	8b 97 dc 00 00 00    	mov    0xdc(%edi),%edx
    dc6e:	e9 7f fe ff ff       	jmp    daf2 <free_trickles_msk_finish+0x52>
    dc73:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    dc79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

0000dc80 <unmarshallContinuationServer>:
  do{					\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
    dc80:	55                   	push   %ebp
    dc81:	89 e5                	mov    %esp,%ebp
    dc83:	31 d2                	xor    %edx,%edx
    dc85:	57                   	push   %edi
    dc86:	56                   	push   %esi
    dc87:	53                   	push   %ebx
    dc88:	83 ec 40             	sub    $0x40,%esp
    dc8b:	8b 45 08             	mov    0x8(%ebp),%eax
    dc8e:	8b 58 0c             	mov    0xc(%eax),%ebx
    dc91:	8b 83 a8 02 00 00    	mov    0x2a8(%ebx),%eax
    dc97:	a9 01 00 00 00       	test   $0x1,%eax
    dc9c:	74 05                	je     dca3 <unmarshallContinuationServer+0x23>
    dc9e:	83 e0 08             	and    $0x8,%eax
    dca1:	74 05                	je     dca8 <unmarshallContinuationServer+0x28>
    dca3:	ba 01 00 00 00       	mov    $0x1,%edx
    dca8:	85 d2                	test   %edx,%edx
    dcaa:	0f 85 03 01 00 00    	jne    ddb3 <unmarshallContinuationServer+0x133>
    dcb0:	8b 55 10             	mov    0x10(%ebp),%edx
    dcb3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    dcb6:	0f b6 02             	movzbl (%edx),%eax
    dcb9:	89 41 38             	mov    %eax,0x38(%ecx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    dcbc:	8b 42 01             	mov    0x1(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    dcbf:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    dcc1:	89 41 34             	mov    %eax,0x34(%ecx)
  do{					\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
    dcc4:	8b 42 09             	mov    0x9(%edx),%eax
    dcc7:	89 41 3c             	mov    %eax,0x3c(%ecx)
    dcca:	8b 42 0d             	mov    0xd(%edx),%eax
    dccd:	89 41 40             	mov    %eax,0x40(%ecx)
    dcd0:	8b 42 25             	mov    0x25(%edx),%eax
    dcd3:	89 41 44             	mov    %eax,0x44(%ecx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    dcd6:	8b 42 25             	mov    0x25(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    dcd9:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    dcdb:	89 41 4c             	mov    %eax,0x4c(%ecx)
  do{					\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
    dcde:	8b 42 11             	mov    0x11(%edx),%eax
    dce1:	89 41 50             	mov    %eax,0x50(%ecx)
    dce4:	8b 42 29             	mov    0x29(%edx),%eax
    dce7:	89 41 48             	mov    %eax,0x48(%ecx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    dcea:	8b 42 29             	mov    0x29(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    dced:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    dcef:	89 41 54             	mov    %eax,0x54(%ecx)
  do{					\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
    dcf2:	0f b6 42 2d          	movzbl 0x2d(%edx),%eax
    dcf6:	89 41 58             	mov    %eax,0x58(%ecx)
    dcf9:	0f b6 42 05          	movzbl 0x5(%edx),%eax
    dcfd:	89 41 5c             	mov    %eax,0x5c(%ecx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    dd00:	8b 42 2e             	mov    0x2e(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    dd03:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    dd05:	89 41 60             	mov    %eax,0x60(%ecx)
    dd08:	8b 42 32             	mov    0x32(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    dd0b:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    dd0d:	89 41 64             	mov    %eax,0x64(%ecx)
    dd10:	8b 42 36             	mov    0x36(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    dd13:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    dd15:	89 41 68             	mov    %eax,0x68(%ecx)
    dd18:	8b 42 3a             	mov    0x3a(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    dd1b:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    dd1d:	89 41 6c             	mov    %eax,0x6c(%ecx)
    dd20:	8b 42 3e             	mov    0x3e(%edx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    dd23:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    dd25:	89 41 70             	mov    %eax,0x70(%ecx)
  do{					\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
    dd28:	31 d2                	xor    %edx,%edx
    dd2a:	8b 75 08             	mov    0x8(%ebp),%esi
    dd2d:	8b 46 0c             	mov    0xc(%esi),%eax
    dd30:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    dd36:	a9 01 00 00 00       	test   $0x1,%eax
    dd3b:	74 05                	je     dd42 <unmarshallContinuationServer+0xc2>
    dd3d:	83 e0 08             	and    $0x8,%eax
    dd40:	74 05                	je     dd47 <unmarshallContinuationServer+0xc7>
    dd42:	ba 01 00 00 00       	mov    $0x1,%edx
    dd47:	85 d2                	test   %edx,%edx
    dd49:	75 39                	jne    dd84 <unmarshallContinuationServer+0x104>
    dd4b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    dd4e:	31 db                	xor    %ebx,%ebx
    dd50:	89 99 dc 00 00 00    	mov    %ebx,0xdc(%ecx)
    dd56:	8b 75 10             	mov    0x10(%ebp),%esi
    dd59:	8b 46 42             	mov    0x42(%esi),%eax
    dd5c:	8b 56 46             	mov    0x46(%esi),%edx
    dd5f:	89 41 74             	mov    %eax,0x74(%ecx)
    dd62:	31 c0                	xor    %eax,%eax
    dd64:	89 51 78             	mov    %edx,0x78(%ecx)
    dd67:	31 d2                	xor    %edx,%edx
    dd69:	89 91 c0 00 00 00    	mov    %edx,0xc0(%ecx)
    dd6f:	89 81 c4 00 00 00    	mov    %eax,0xc4(%ecx)
    dd75:	b9 01 00 00 00       	mov    $0x1,%ecx
    dd7a:	83 c4 40             	add    $0x40,%esp
    dd7d:	89 c8                	mov    %ecx,%eax
    dd7f:	5b                   	pop    %ebx
    dd80:	5e                   	pop    %esi
    dd81:	5f                   	pop    %edi
    dd82:	5d                   	pop    %ebp
    dd83:	c3                   	ret    
    dd84:	8b 7d 08             	mov    0x8(%ebp),%edi
    dd87:	8b 55 0c             	mov    0xc(%ebp),%edx
    dd8a:	8b 47 24             	mov    0x24(%edi),%eax
    dd8d:	8b 40 10             	mov    0x10(%eax),%eax
    dd90:	89 42 14             	mov    %eax,0x14(%edx)
    dd93:	8b 47 24             	mov    0x24(%edi),%eax
    dd96:	8b 40 0c             	mov    0xc(%eax),%eax
    dd99:	89 42 18             	mov    %eax,0x18(%edx)
    dd9c:	8b 47 20             	mov    0x20(%edi),%eax
    dd9f:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    dda3:	66 89 42 1c          	mov    %ax,0x1c(%edx)
    dda7:	8b 47 20             	mov    0x20(%edi),%eax
    ddaa:	0f b7 00             	movzwl (%eax),%eax
    ddad:	66 89 42 1e          	mov    %ax,0x1e(%edx)
    ddb1:	eb 98                	jmp    dd4b <unmarshallContinuationServer+0xcb>
    ddb3:	8b 55 10             	mov    0x10(%ebp),%edx
    ddb6:	8d 7d e4             	lea    0xffffffe4(%ebp),%edi
    ddb9:	8b 75 08             	mov    0x8(%ebp),%esi
    ddbc:	8b 42 01             	mov    0x1(%edx),%eax
    ddbf:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
    ddc2:	0f b6 02             	movzbl (%edx),%eax
    ddc5:	88 45 c8             	mov    %al,0xffffffc8(%ebp)
    ddc8:	0f b6 42 05          	movzbl 0x5(%edx),%eax
    ddcc:	88 45 c9             	mov    %al,0xffffffc9(%ebp)
    ddcf:	8b 4e 24             	mov    0x24(%esi),%ecx
    ddd2:	8b 41 10             	mov    0x10(%ecx),%eax
    ddd5:	89 45 ca             	mov    %eax,0xffffffca(%ebp)
    ddd8:	8b 56 20             	mov    0x20(%esi),%edx
    dddb:	89 fe                	mov    %edi,%esi
    dddd:	0f b7 42 02          	movzwl 0x2(%edx),%eax
    dde1:	66 89 45 ce          	mov    %ax,0xffffffce(%ebp)
    dde5:	8b 41 0c             	mov    0xc(%ecx),%eax
    dde8:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    ddeb:	0f b7 02             	movzwl (%edx),%eax
    ddee:	8d 55 c4             	lea    0xffffffc4(%ebp),%edx
    ddf1:	89 7c 24 0c          	mov    %edi,0xc(%esp,1)
    ddf5:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    ddf9:	89 1c 24             	mov    %ebx,(%esp,1)
    ddfc:	66 89 45 d4          	mov    %ax,0xffffffd4(%ebp)
    de00:	8b 45 10             	mov    0x10(%ebp),%eax
    de03:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    de07:	e8 fc ff ff ff       	call   de08 <unmarshallContinuationServer+0x188>
    de0c:	8b 45 10             	mov    0x10(%ebp),%eax
    de0f:	b9 10 00 00 00       	mov    $0x10,%ecx
    de14:	fc                   	cld    
    de15:	83 c0 15             	add    $0x15,%eax
    de18:	89 c7                	mov    %eax,%edi
    de1a:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
    de1c:	0f 97 c2             	seta   %dl
    de1f:	0f 92 c0             	setb   %al
    de22:	31 c9                	xor    %ecx,%ecx
    de24:	38 c2                	cmp    %al,%dl
    de26:	0f 85 4e ff ff ff    	jne    dd7a <unmarshallContinuationServer+0xfa>
    de2c:	e9 7f fe ff ff       	jmp    dcb0 <unmarshallContinuationServer+0x30>
    de31:	eb 0d                	jmp    de40 <unmarshallContinuationClient>
    de33:	90                   	nop    
    de34:	90                   	nop    
    de35:	90                   	nop    
    de36:	90                   	nop    
    de37:	90                   	nop    
    de38:	90                   	nop    
    de39:	90                   	nop    
    de3a:	90                   	nop    
    de3b:	90                   	nop    
    de3c:	90                   	nop    
    de3d:	90                   	nop    
    de3e:	90                   	nop    
    de3f:	90                   	nop    

0000de40 <unmarshallContinuationClient>:
UNMARSHALL_CONTINUATION(Client, CLIENT_COMPUTE_MAC);
    de40:	55                   	push   %ebp
    de41:	89 e5                	mov    %esp,%ebp
    de43:	57                   	push   %edi
    de44:	56                   	push   %esi
    de45:	53                   	push   %ebx
    de46:	83 ec 0c             	sub    $0xc,%esp
    de49:	8b 75 10             	mov    0x10(%ebp),%esi
    de4c:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp,1)
    de53:	00 
    de54:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    de57:	8b 7d 08             	mov    0x8(%ebp),%edi
    de5a:	8d 46 15             	lea    0x15(%esi),%eax
    de5d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    de61:	8d 83 8c 00 00 00    	lea    0x8c(%ebx),%eax
    de67:	89 04 24             	mov    %eax,(%esp,1)
    de6a:	e8 51 4e 00 00       	call   12cc0 <__constant_memcpy>
    de6f:	0f b6 06             	movzbl (%esi),%eax
    de72:	31 d2                	xor    %edx,%edx
    de74:	89 43 38             	mov    %eax,0x38(%ebx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    de77:	8b 46 01             	mov    0x1(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    de7a:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    de7c:	89 43 34             	mov    %eax,0x34(%ebx)
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
UNMARSHALL_CONTINUATION(Client, CLIENT_COMPUTE_MAC);
    de7f:	8b 46 09             	mov    0x9(%esi),%eax
    de82:	89 43 3c             	mov    %eax,0x3c(%ebx)
    de85:	8b 46 0d             	mov    0xd(%esi),%eax
    de88:	89 43 40             	mov    %eax,0x40(%ebx)
    de8b:	8b 46 25             	mov    0x25(%esi),%eax
    de8e:	89 43 44             	mov    %eax,0x44(%ebx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    de91:	8b 46 25             	mov    0x25(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    de94:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    de96:	89 43 4c             	mov    %eax,0x4c(%ebx)
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
UNMARSHALL_CONTINUATION(Client, CLIENT_COMPUTE_MAC);
    de99:	8b 46 11             	mov    0x11(%esi),%eax
    de9c:	89 43 50             	mov    %eax,0x50(%ebx)
    de9f:	8b 46 29             	mov    0x29(%esi),%eax
    dea2:	89 43 48             	mov    %eax,0x48(%ebx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    dea5:	8b 46 29             	mov    0x29(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    dea8:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    deaa:	89 43 54             	mov    %eax,0x54(%ebx)
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
UNMARSHALL_CONTINUATION(Client, CLIENT_COMPUTE_MAC);
    dead:	0f b6 46 2d          	movzbl 0x2d(%esi),%eax
    deb1:	89 43 58             	mov    %eax,0x58(%ebx)
    deb4:	0f b6 46 05          	movzbl 0x5(%esi),%eax
    deb8:	89 43 5c             	mov    %eax,0x5c(%ebx)
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    debb:	8b 46 2e             	mov    0x2e(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    debe:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    dec0:	89 43 60             	mov    %eax,0x60(%ebx)
    dec3:	8b 46 32             	mov    0x32(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    dec6:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    dec8:	89 43 64             	mov    %eax,0x64(%ebx)
    decb:	8b 46 36             	mov    0x36(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    dece:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    ded0:	89 43 68             	mov    %eax,0x68(%ebx)
    ded3:	8b 46 3a             	mov    0x3a(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    ded6:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    ded8:	89 43 6c             	mov    %eax,0x6c(%ebx)
    dedb:	8b 46 3e             	mov    0x3e(%esi),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
    dede:	0f c8                	bswap  %eax
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
    dee0:	89 43 70             	mov    %eax,0x70(%ebx)
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
UNMARSHALL_CONTINUATION(Client, CLIENT_COMPUTE_MAC);
    dee3:	8b 47 0c             	mov    0xc(%edi),%eax
    dee6:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    deec:	a9 01 00 00 00       	test   $0x1,%eax
    def1:	74 05                	je     def8 <unmarshallContinuationClient+0xb8>
    def3:	83 e0 08             	and    $0x8,%eax
    def6:	74 05                	je     defd <unmarshallContinuationClient+0xbd>
    def8:	ba 01 00 00 00       	mov    $0x1,%edx
    defd:	85 d2                	test   %edx,%edx
    deff:	75 31                	jne    df32 <unmarshallContinuationClient+0xf2>
    df01:	31 c0                	xor    %eax,%eax
    df03:	31 ff                	xor    %edi,%edi
    df05:	89 83 dc 00 00 00    	mov    %eax,0xdc(%ebx)
    df0b:	8b 46 42             	mov    0x42(%esi),%eax
    df0e:	8b 56 46             	mov    0x46(%esi),%edx
    df11:	31 f6                	xor    %esi,%esi
    df13:	89 bb c0 00 00 00    	mov    %edi,0xc0(%ebx)
    df19:	89 b3 c4 00 00 00    	mov    %esi,0xc4(%ebx)
    df1f:	89 43 74             	mov    %eax,0x74(%ebx)
    df22:	b8 01 00 00 00       	mov    $0x1,%eax
    df27:	89 53 78             	mov    %edx,0x78(%ebx)
    df2a:	83 c4 0c             	add    $0xc,%esp
    df2d:	5b                   	pop    %ebx
    df2e:	5e                   	pop    %esi
    df2f:	5f                   	pop    %edi
    df30:	5d                   	pop    %ebp
    df31:	c3                   	ret    
    df32:	8b 47 24             	mov    0x24(%edi),%eax
    df35:	8b 40 10             	mov    0x10(%eax),%eax
    df38:	89 43 14             	mov    %eax,0x14(%ebx)
    df3b:	8b 47 24             	mov    0x24(%edi),%eax
    df3e:	8b 40 0c             	mov    0xc(%eax),%eax
    df41:	89 43 18             	mov    %eax,0x18(%ebx)
    df44:	8b 47 20             	mov    0x20(%edi),%eax
    df47:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    df4b:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
    df4f:	8b 47 20             	mov    0x20(%edi),%eax
    df52:	0f b7 00             	movzwl (%eax),%eax
    df55:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
    df59:	eb a6                	jmp    df01 <unmarshallContinuationClient+0xc1>
    df5b:	90                   	nop    
    df5c:	8d 74 26 00          	lea    0x0(%esi,1),%esi

0000df60 <fill_page_desc>:
/* begin functions copied from tcp.c */

static inline void
fill_page_desc(struct sk_buff *skb, int i, struct page *page, int off, int size)
{
    df60:	55                   	push   %ebp
    df61:	89 e5                	mov    %esp,%ebp
    df63:	83 ec 08             	sub    $0x8,%esp
    df66:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    df6a:	8b 75 08             	mov    0x8(%ebp),%esi
    df6d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    df70:	89 1c 24             	mov    %ebx,(%esp,1)
	skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
    df73:	8b 86 9c 00 00 00    	mov    0x9c(%esi),%eax
    df79:	8d 14 c8             	lea    (%eax,%ecx,8),%edx
	frag->page = page;
    df7c:	8b 45 10             	mov    0x10(%ebp),%eax
	frag->page_offset = off;
	frag->size = size;
	skb_shinfo(skb)->nr_frags = i+1;
    df7f:	41                   	inc    %ecx
    df80:	8d 5a 0c             	lea    0xc(%edx),%ebx
    df83:	89 42 0c             	mov    %eax,0xc(%edx)
    df86:	8b 45 14             	mov    0x14(%ebp),%eax
    df89:	66 89 43 04          	mov    %ax,0x4(%ebx)
    df8d:	8b 45 18             	mov    0x18(%ebp),%eax
    df90:	66 89 43 06          	mov    %ax,0x6(%ebx)
    df94:	8b 86 9c 00 00 00    	mov    0x9c(%esi),%eax
    df9a:	89 48 04             	mov    %ecx,0x4(%eax)
}
    df9d:	8b 1c 24             	mov    (%esp,1),%ebx
    dfa0:	8b 74 24 04          	mov    0x4(%esp,1),%esi
    dfa4:	89 ec                	mov    %ebp,%esp
    dfa6:	5d                   	pop    %ebp
    dfa7:	c3                   	ret    
    dfa8:	90                   	nop    
    dfa9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi

0000dfb0 <skb_add_data>:

extern int total_csum_bytes;

static inline int
skb_add_data(struct sk_buff *skb, char *from, int copy)
{
    dfb0:	55                   	push   %ebp
    dfb1:	89 e5                	mov    %esp,%ebp
    dfb3:	57                   	push   %edi
    dfb4:	56                   	push   %esi
    dfb5:	53                   	push   %ebx
    dfb6:	83 ec 28             	sub    $0x28,%esp
	int err = 0;
    dfb9:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
    dfc0:	8b 75 08             	mov    0x8(%ebp),%esi
    dfc3:	8b 5d 10             	mov    0x10(%ebp),%ebx
    dfc6:	8b 7d 0c             	mov    0xc(%ebp),%edi
	unsigned int csum;
	int off = skb->len;
    dfc9:	8b 46 70             	mov    0x70(%esi),%eax

	total_csum_bytes += copy;
    dfcc:	01 1d 00 00 00 00    	add    %ebx,0x0
    dfd2:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
    dfd5:	8b 8e 98 00 00 00    	mov    0x98(%esi),%ecx
    dfdb:	89 4d e8             	mov    %ecx,0xffffffe8(%ebp)
    dfde:	8b 46 74             	mov    0x74(%esi),%eax
    dfe1:	85 c0                	test   %eax,%eax
    dfe3:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    dfe6:	0f 85 1d 01 00 00    	jne    e109 <skb_add_data+0x159>
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
    dfec:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
	skb->len+=len;
    dfef:	01 5e 70             	add    %ebx,0x70(%esi)
    dff2:	01 d8                	add    %ebx,%eax
	if(skb->tail>skb->end) {
    dff4:	3b 86 9c 00 00 00    	cmp    0x9c(%esi),%eax
    dffa:	89 86 98 00 00 00    	mov    %eax,0x98(%esi)
    e000:	0f 87 ea 00 00 00    	ja     e0f0 <skb_add_data+0x140>

static inline struct task_struct * get_current(void)
{
	struct task_struct *current;
	__asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
    e006:	b8 00 e0 ff ff       	mov    $0xffffe000,%eax
    e00b:	89 f9                	mov    %edi,%ecx
    e00d:	21 e0                	and    %esp,%eax
    e00f:	01 d9                	add    %ebx,%ecx
    e011:	19 d2                	sbb    %edx,%edx
    e013:	39 48 0c             	cmp    %ecx,0xc(%eax)
    e016:	83 da 00             	sbb    $0x0,%edx
 * See access_ok() for more details.
 */
static inline int verify_area(int type, const void * addr, unsigned long size)
{
	return access_ok(type,addr,size) ? 0 : -EFAULT;
    e019:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
    e01e:	85 d2                	test   %edx,%edx
    e020:	0f 44 45 e4          	cmove  0xffffffe4(%ebp),%eax
    e024:	85 c0                	test   %eax,%eax
    e026:	0f 84 94 00 00 00    	je     e0c0 <skb_add_data+0x110>
{
	if (verify_area(VERIFY_READ, src, len) == 0)
		return csum_partial_copy_from_user(src, dst, len, sum, err_ptr);

	if (len)
    e02c:	85 db                	test   %ebx,%ebx
    e02e:	74 07                	je     e037 <skb_add_data+0x87>
		*err_ptr = -EFAULT;
    e030:	c7 45 f0 f2 ff ff ff 	movl   $0xfffffff2,0xfffffff0(%ebp)
    e037:	31 c0                	xor    %eax,%eax
	csum = csum_and_copy_from_user(from, skb_put(skb, copy),
				       copy, 0, &err);
	if (!err) {
    e039:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    e03c:	85 d2                	test   %edx,%edx
    e03e:	75 40                	jne    e080 <skb_add_data+0xd0>

static inline unsigned int
csum_block_add(unsigned int csum, unsigned int csum2, int offset)
{
	if (offset&1)
    e040:	f7 45 ec 01 00 00 00 	testl  $0x1,0xffffffec(%ebp)
    e047:	89 c1                	mov    %eax,%ecx
    e049:	8b 5e 78             	mov    0x78(%esi),%ebx
    e04c:	74 16                	je     e064 <skb_add_data+0xb4>
		csum2 = ((csum2&0xFF00FF)<<8)+((csum2>>8)&0xFF00FF);
    e04e:	89 c2                	mov    %eax,%edx
    e050:	c1 e8 08             	shr    $0x8,%eax
    e053:	81 e2 ff 00 ff 00    	and    $0xff00ff,%edx
    e059:	c1 e2 08             	shl    $0x8,%edx
    e05c:	25 ff 00 ff 00       	and    $0xff00ff,%eax
    e061:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e064:	8d 04 19             	lea    (%ecx,%ebx,1),%eax
    e067:	39 c8                	cmp    %ecx,%eax
    e069:	8d 50 01             	lea    0x1(%eax),%edx
    e06c:	0f 42 c2             	cmovb  %edx,%eax
    e06f:	89 46 78             	mov    %eax,0x78(%esi)
		skb->csum = csum_block_add(skb->csum, csum, off);
		return 0;
    e072:	31 c0                	xor    %eax,%eax
	}

	__skb_trim(skb, off);
	return -EFAULT;
}
    e074:	83 c4 28             	add    $0x28,%esp
    e077:	5b                   	pop    %ebx
    e078:	5e                   	pop    %esi
    e079:	5f                   	pop    %edi
    e07a:	5d                   	pop    %ebp
    e07b:	c3                   	ret    
    e07c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
extern int ___pskb_trim(struct sk_buff *skb, unsigned int len, int realloc);

static inline void __skb_trim(struct sk_buff *skb, unsigned int len)
{
	if (!skb->data_len) {
    e080:	8b 46 74             	mov    0x74(%esi),%eax
    e083:	85 c0                	test   %eax,%eax
    e085:	75 1b                	jne    e0a2 <skb_add_data+0xf2>
		skb->len = len;
    e087:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
		skb->tail = skb->data+len;
    e08a:	8b 86 94 00 00 00    	mov    0x94(%esi),%eax
    e090:	89 4e 70             	mov    %ecx,0x70(%esi)
    e093:	01 c1                	add    %eax,%ecx
    e095:	89 8e 98 00 00 00    	mov    %ecx,0x98(%esi)
    e09b:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
    e0a0:	eb d2                	jmp    e074 <skb_add_data+0xc4>
	if (!skb->data_len) {
		skb->len = len;
		skb->tail = skb->data+len;
	} else {
		___pskb_trim(skb, len, 0);
    e0a2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    e0a9:	00 
    e0aa:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    e0ad:	89 34 24             	mov    %esi,(%esp,1)
    e0b0:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    e0b4:	e8 fc ff ff ff       	call   e0b5 <skb_add_data+0x105>
    e0b9:	eb e0                	jmp    e09b <skb_add_data+0xeb>
    e0bb:	90                   	nop    
    e0bc:	8d 74 26 00          	lea    0x0(%esi,1),%esi
static __inline__
unsigned int csum_partial_copy_from_user ( const char *src, char *dst,
						int len, int sum, int *err_ptr)
{
	return csum_partial_copy_generic ( src, dst, len, sum, err_ptr, NULL);
    e0c0:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp,1)
    e0c7:	00 
    e0c8:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
    e0cb:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    e0cf:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    e0d2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp,1)
    e0d9:	00 
    e0da:	89 5c 24 08          	mov    %ebx,0x8(%esp,1)
    e0de:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    e0e2:	89 3c 24             	mov    %edi,(%esp,1)
    e0e5:	e8 fc ff ff ff       	call   e0e6 <skb_add_data+0x136>
static inline
unsigned int csum_and_copy_from_user (const char *src, char *dst,
				      int len, int sum, int *err_ptr)
{
	if (verify_area(VERIFY_READ, src, len) == 0)
    e0ea:	e9 4a ff ff ff       	jmp    e039 <skb_add_data+0x89>
    e0ef:	90                   	nop    
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	if(skb->tail>skb->end) {
		skb_over_panic(skb, len, current_text_addr());
    e0f0:	c7 44 24 08 f8 e0 00 	movl   $0xe0f8,0x8(%esp,1)
    e0f7:	00 
    e0f8:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    e0fc:	89 34 24             	mov    %esi,(%esp,1)
    e0ff:	e8 fc ff ff ff       	call   e100 <skb_add_data+0x150>
    e104:	e9 fd fe ff ff       	jmp    e006 <skb_add_data+0x56>
    e109:	c7 04 24 24 03 00 00 	movl   $0x324,(%esp,1)
    e110:	e8 fc ff ff ff       	call   e111 <skb_add_data+0x161>
    e115:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    e119:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

0000e120 <init_sock>:

/* end functions copied from tcp.c */

static inline void init_sock(struct cminisock *msk, struct sock *sk) {
    e120:	55                   	push   %ebp
    e121:	89 e5                	mov    %esp,%ebp
    e123:	8b 4d 08             	mov    0x8(%ebp),%ecx
    e126:	8b 45 0c             	mov    0xc(%ebp),%eax
	msk->sk = sk;
	msk->sk->dst_cache = NULL;
	msk->sk->protinfo.af_inet.opt = NULL;
    e129:	31 d2                	xor    %edx,%edx
    e12b:	89 41 20             	mov    %eax,0x20(%ecx)
    e12e:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
    e135:	8b 41 20             	mov    0x20(%ecx),%eax
    e138:	89 90 5c 0c 00 00    	mov    %edx,0xc5c(%eax)
	msk->sk->protinfo.af_inet.ttl = 255;
    e13e:	ba ff 00 00 00       	mov    $0xff,%edx
    e143:	8b 41 20             	mov    0x20(%ecx),%eax
    e146:	89 90 50 0c 00 00    	mov    %edx,0xc50(%eax)
	msk->sk->protocol = IPPROTO_TCP;
	msk->sk->protinfo.af_inet.tos = 0;
    e14c:	31 d2                	xor    %edx,%edx
    e14e:	8b 41 20             	mov    0x20(%ecx),%eax
    e151:	c6 80 33 0c 00 00 06 	movb   $0x6,0xc33(%eax)
    e158:	8b 41 20             	mov    0x20(%ecx),%eax
    e15b:	89 90 54 0c 00 00    	mov    %edx,0xc54(%eax)
	msk->sk->tp_pinfo.af_tcp.trickles_opt = 0;
    e161:	31 d2                	xor    %edx,%edx
    e163:	8b 41 20             	mov    0x20(%ecx),%eax
    e166:	89 90 a8 02 00 00    	mov    %edx,0x2a8(%eax)
	msk->sk->localroute = 0;
    e16c:	8b 41 20             	mov    0x20(%ecx),%eax
    e16f:	c6 80 32 0c 00 00 00 	movb   $0x0,0xc32(%eax)
        if (ipv4_config.no_pmtu_disc)
    e176:	a1 08 00 00 00       	mov    0x8,%eax
    e17b:	85 c0                	test   %eax,%eax
    e17d:	74 41                	je     e1c0 <init_sock+0xa0>
                msk->sk->protinfo.af_inet.pmtudisc = IP_PMTUDISC_DONT;
    e17f:	8b 41 20             	mov    0x20(%ecx),%eax
    e182:	c6 80 66 0c 00 00 00 	movb   $0x0,0xc66(%eax)
        else
                msk->sk->protinfo.af_inet.pmtudisc = IP_PMTUDISC_WANT;
	/* following hack won't work correctly for complex socket binding config on the master socket */
	msk->sk->bound_dev_if = 0;
    e189:	8b 41 20             	mov    0x20(%ecx),%eax
    e18c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

	msk->sk->saddr = msk->saddr;
    e193:	8b 51 20             	mov    0x20(%ecx),%edx
    e196:	8b 41 14             	mov    0x14(%ecx),%eax
    e199:	89 42 70             	mov    %eax,0x70(%edx)
	msk->sk->sport = msk->source;
    e19c:	8b 51 20             	mov    0x20(%ecx),%edx
    e19f:	0f b7 41 1c          	movzwl 0x1c(%ecx),%eax
    e1a3:	66 89 42 22          	mov    %ax,0x22(%edx)
	msk->sk->daddr = msk->daddr;
    e1a7:	8b 51 20             	mov    0x20(%ecx),%edx
    e1aa:	8b 41 18             	mov    0x18(%ecx),%eax
    e1ad:	89 02                	mov    %eax,(%edx)
	msk->sk->dport = msk->dest;
    e1af:	8b 51 20             	mov    0x20(%ecx),%edx
    e1b2:	0f b7 41 1e          	movzwl 0x1e(%ecx),%eax
    e1b6:	66 89 42 08          	mov    %ax,0x8(%edx)
}
    e1ba:	5d                   	pop    %ebp
    e1bb:	c3                   	ret    
    e1bc:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    e1c0:	8b 41 20             	mov    0x20(%ecx),%eax
    e1c3:	c6 80 66 0c 00 00 01 	movb   $0x1,0xc66(%eax)
    e1ca:	eb bd                	jmp    e189 <init_sock+0x69>
    e1cc:	8d 74 26 00          	lea    0x0(%esi,1),%esi

0000e1d0 <virt_to_kseg>:


static int upcall_seqnum = 0;

static volatile void *virt_to_kseg(volatile void *address)
{
    e1d0:	55                   	push   %ebp
    e1d1:	89 e5                	mov    %esp,%ebp
    e1d3:	8b 4d 08             	mov    0x8(%ebp),%ecx
    e1d6:	53                   	push   %ebx
 * The "pgd_xxx()" functions here are trivial for a folded two-level
 * setup: the pgd is never bad, and a pmd always exists (as it's folded
 * into the pgd entry)
 */
static inline int pgd_none(pgd_t pgd)		{ return 0; }
    e1d7:	a1 0c 00 00 00       	mov    0xc,%eax
        pgd_t *pgd; pmd_t *pmd; pte_t *ptep, pte;
	unsigned long va, ret = 0UL;
	
	va=VMALLOC_VMADDR((unsigned long)address);
	
	/* get the page directory. Use the kernel memory map. */
	pgd = pgd_offset_k(va);
    e1dc:	89 ca                	mov    %ecx,%edx
    e1de:	c1 ea 16             	shr    $0x16,%edx
 * The "pgd_xxx()" functions here are trivial for a folded two-level
 * setup: the pgd is never bad, and a pmd always exists (as it's folded
 * into the pgd entry)
 */
static inline int pgd_none(pgd_t pgd)		{ return 0; }
    e1e1:	8b 14 90             	mov    (%eax,%edx,4),%edx
    e1e4:	31 db                	xor    %ebx,%ebx

	/* check whether we found an entry */
	if (!pgd_none(*pgd))
        {
	      /* get the page middle directory */
	      pmd = pmd_offset(pgd, va);
	      /* check whether we found an entry */
	      if (!pmd_none(*pmd))
    e1e6:	85 d2                	test   %edx,%edx
    e1e8:	74 64                	je     e24e <virt_to_kseg+0x7e>
              {
		  /* get a pointer to the page table entry */
	          ptep = pte_offset(pmd, va);
    e1ea:	89 c8                	mov    %ecx,%eax
    e1ec:	c1 e8 0a             	shr    $0xa,%eax
    e1ef:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
    e1f5:	25 fc 0f 00 00       	and    $0xffc,%eax
	          pte = *ptep;
    e1fa:	8b 84 10 00 00 00 c0 	mov    0xc0000000(%eax,%edx,1),%eax
		  /* check for a valid page */
	          if (pte_present(pte))
    e201:	a8 81                	test   $0x81,%al
    e203:	74 49                	je     e24e <virt_to_kseg+0x7e>
                  {
		        /* get the address the page is refering to */
		        ret = (unsigned long)page_address(pte_page(pte));
    e205:	89 c2                	mov    %eax,%edx
    e207:	c1 ea 0c             	shr    $0xc,%edx
    e20a:	8d 04 92             	lea    (%edx,%edx,4),%eax
    e20d:	8d 04 42             	lea    (%edx,%eax,2),%eax
    e210:	8b 15 00 00 00 00    	mov    0x0,%edx
			/* add the offset within the page to the page address */
			ret |= (va & (PAGE_SIZE -1));
    e216:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
    e21c:	8d 04 82             	lea    (%edx,%eax,4),%eax
extern struct zone_struct *zone_table[];

static inline zone_t *page_zone(struct page *page)
{
	return zone_table[page->flags >> ZONE_SHIFT];
    e21f:	0f b6 50 1b          	movzbl 0x1b(%eax),%edx
    e223:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
    e22a:	8b 9a c0 00 00 00    	mov    0xc0(%edx),%ebx
    e230:	29 d8                	sub    %ebx,%eax
    e232:	8b 9a c4 00 00 00    	mov    0xc4(%edx),%ebx
    e238:	c1 f8 02             	sar    $0x2,%eax
    e23b:	69 c0 a3 8b 2e ba    	imul   $0xba2e8ba3,%eax,%eax
    e241:	c1 e0 0c             	shl    $0xc,%eax
    e244:	01 d8                	add    %ebx,%eax
    e246:	8d 98 00 00 00 c0    	lea    0xc0000000(%eax),%ebx
    e24c:	09 cb                	or     %ecx,%ebx
		  }
	      }
	}
	return((volatile void *)ret);
}
    e24e:	89 d8                	mov    %ebx,%eax
    e250:	5b                   	pop    %ebx
    e251:	5d                   	pop    %ebp
    e252:	c3                   	ret    
    e253:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    e259:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

0000e260 <queue_upcall_prealloc>:

inline void queue_upcall_prealloc(struct sock *sk, enum cminisock_event_tag tag, struct cminisock *msk) {
    e260:	55                   	push   %ebp
    e261:	89 e5                	mov    %esp,%ebp
    e263:	83 ec 14             	sub    $0x14,%esp
    e266:	89 5d f4             	mov    %ebx,0xfffffff4(%ebp)
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
    e269:	8b 45 08             	mov    0x8(%ebp),%eax
    e26c:	8b 5d 10             	mov    0x10(%ebp),%ebx
    e26f:	89 75 f8             	mov    %esi,0xfffffff8(%ebp)
    e272:	05 bc 00 00 00       	add    $0xbc,%eax
	switch(tag) {
    e277:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
    e27b:	89 7d fc             	mov    %edi,0xfffffffc(%ebp)
    e27e:	77 60                	ja     e2e0 <queue_upcall_prealloc+0x80>
	elem->list = head;
	head->len++;
}

static inline void insert_tail(struct alloc_head_list *head, struct alloc_head *elem) {
    e280:	8b b0 cc 01 00 00    	mov    0x1cc(%eax),%esi
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
    e286:	8b 46 24             	mov    0x24(%esi),%eax
    e289:	8d 7e 24             	lea    0x24(%esi),%edi
    e28c:	39 d8                	cmp    %ebx,%eax
    e28e:	74 21                	je     e2b1 <queue_upcall_prealloc+0x51>
		BUG();
		show_stack(NULL);
	}
	elem->prev = head->prev;
    e290:	89 03                	mov    %eax,(%ebx)
	head->prev->next = elem;
    e292:	8b 46 24             	mov    0x24(%esi),%eax

	elem->next = (struct alloc_head*)head;

	elem->list = head;
    e295:	89 7b 08             	mov    %edi,0x8(%ebx)
    e298:	89 58 04             	mov    %ebx,0x4(%eax)
    e29b:	89 7b 04             	mov    %edi,0x4(%ebx)
	head->prev = elem;
	head->len++;
    e29e:	ff 47 10             	incl   0x10(%edi)
    e2a1:	89 5e 24             	mov    %ebx,0x24(%esi)
	case SYN:
	case RST:
	case FIN:
	case ACK:
		/* enqueue at the end */
		insert_tail(&tp->cminisock_api_config.cfg.ctl->msk_eventlist, (struct alloc_head *)msk);
		break;
    e2a4:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
    e2a7:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
    e2aa:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
    e2ad:	89 ec                	mov    %ebp,%esp
    e2af:	5d                   	pop    %ebp
    e2b0:	c3                   	ret    
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
		BUG();
    e2b1:	c7 44 24 04 02 08 00 	movl   $0x802,0x4(%esp,1)
    e2b8:	00 
    e2b9:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp,1)
    e2c0:	e8 fc ff ff ff       	call   e2c1 <queue_upcall_prealloc+0x61>
    e2c5:	e8 fc ff ff ff       	call   e2c6 <queue_upcall_prealloc+0x66>
		show_stack(NULL);
    e2ca:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    e2d1:	e8 fc ff ff ff       	call   e2d2 <queue_upcall_prealloc+0x72>
    e2d6:	8b 46 24             	mov    0x24(%esi),%eax
    e2d9:	eb b5                	jmp    e290 <queue_upcall_prealloc+0x30>
    e2db:	90                   	nop    
    e2dc:	8d 74 26 00          	lea    0x0(%esi,1),%esi
	default:
		printk("Unsupported tag for preallocation\n");
    e2e0:	c7 45 08 c0 3a 00 00 	movl   $0x3ac0,0x8(%ebp)
    e2e7:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
    e2ea:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
    e2ed:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
    e2f0:	89 ec                	mov    %ebp,%esp
    e2f2:	5d                   	pop    %ebp
    e2f3:	e9 fc ff ff ff       	jmp    e2f4 <queue_upcall_prealloc+0x94>
    e2f8:	90                   	nop    
    e2f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi

0000e300 <queue_upcall>:
	}
}

inline void queue_upcall(enum cminisock_event_tag tag, struct cminisock *msk) {
    e300:	55                   	push   %ebp
    e301:	89 e5                	mov    %esp,%ebp
    e303:	57                   	push   %edi
    e304:	56                   	push   %esi
    e305:	53                   	push   %ebx
    e306:	83 ec 10             	sub    $0x10,%esp
    e309:	8b 45 08             	mov    0x8(%ebp),%eax
    e30c:	8b 75 0c             	mov    0xc(%ebp),%esi
	msk->tag = tag;
	switch(tag) {
    e30f:	83 f8 03             	cmp    $0x3,%eax
    e312:	89 46 10             	mov    %eax,0x10(%esi)
    e315:	77 79                	ja     e390 <queue_upcall+0x90>
	case SYN:
	case RST:
	case FIN:
	case ACK:
		msk->ctl = ALLOC_READY;
    e317:	c7 46 0c 01 00 00 00 	movl   $0x1,0xc(%esi)
		{
			msk->seqnum = upcall_seqnum++;
    e31e:	a1 2c 01 00 00       	mov    0x12c,%eax
    e323:	89 86 c8 00 00 00    	mov    %eax,0xc8(%esi)
		}
		if(userapi_pkt_spew) {
    e329:	8b 1d 00 00 00 00    	mov    0x0,%ebx
    e32f:	ff 05 2c 01 00 00    	incl   0x12c
    e335:	85 db                	test   %ebx,%ebx
    e337:	74 4f                	je     e388 <queue_upcall+0x88>
			int i;
			for(i=0; i < msk->num_packets; i++) {
    e339:	31 ff                	xor    %edi,%edi
    e33b:	3b be dc 00 00 00    	cmp    0xdc(%esi),%edi
    e341:	7d 45                	jge    e388 <queue_upcall+0x88>
    e343:	31 db                	xor    %ebx,%ebx
    e345:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    e349:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
				printk("upcall pkts[%d]: %u-%u\n", i, msk->packets[i].seq, msk->packets[i].seq + msk->packets[i].len);
    e350:	8b 86 e0 00 00 00    	mov    0xe0(%esi),%eax
    e356:	8b 54 18 08          	mov    0x8(%eax,%ebx,1),%edx
    e35a:	8b 4c 18 04          	mov    0x4(%eax,%ebx,1),%ecx
    e35e:	01 ca                	add    %ecx,%edx
    e360:	89 54 24 0c          	mov    %edx,0xc(%esp,1)
    e364:	8b 44 18 04          	mov    0x4(%eax,%ebx,1),%eax
    e368:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
    e36c:	47                   	inc    %edi
    e36d:	83 c3 28             	add    $0x28,%ebx
    e370:	c7 04 24 21 08 00 00 	movl   $0x821,(%esp,1)
    e377:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    e37b:	e8 fc ff ff ff       	call   e37c <queue_upcall+0x7c>
    e380:	3b be dc 00 00 00    	cmp    0xdc(%esi),%edi
    e386:	7c c8                	jl     e350 <queue_upcall+0x50>
			}
		}

		break;
	default:
		printk("queue_upcall: invalid tag\n");
	}
}
    e388:	83 c4 10             	add    $0x10,%esp
    e38b:	5b                   	pop    %ebx
    e38c:	5e                   	pop    %esi
    e38d:	5f                   	pop    %edi
    e38e:	5d                   	pop    %ebp
    e38f:	c3                   	ret    
    e390:	c7 45 08 39 08 00 00 	movl   $0x839,0x8(%ebp)
    e397:	83 c4 10             	add    $0x10,%esp
    e39a:	5b                   	pop    %ebx
    e39b:	5e                   	pop    %esi
    e39c:	5f                   	pop    %edi
    e39d:	5d                   	pop    %ebp
    e39e:	e9 fc ff ff ff       	jmp    e39f <queue_upcall+0x9f>
    e3a3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    e3a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

0000e3b0 <queue_upcall_deliver>:

inline void queue_upcall_deliver(struct sock *sk, struct cminisock *msk) {
    e3b0:	55                   	push   %ebp
#if 0
	if(sk->sleep && waitqueue_active(sk->sleep)) {
		/* XXX: Wake up all sleepers??? */
		if(userapi_time_spew) {
			printk("wakeup time (interrupt): %lu\n", jiffies);
		}
		//printk("empty: %d\n", empty(&sk->tp_pinfo.af_tcp.api_config.cfg.ctl->msk_eventlist));
		if(empty(&sk->tp_pinfo.af_tcp.cminisock_api_config.cfg.ctl->msk_eventlist)) {
			printk("empty event list\n");
		}
		printk("wake up\n");
	}
#endif
	wake_up_interruptible(sk->sleep);
    e3b1:	b9 01 00 00 00       	mov    $0x1,%ecx
    e3b6:	89 e5                	mov    %esp,%ebp
    e3b8:	83 ec 0c             	sub    $0xc,%esp
    e3bb:	ba 01 00 00 00       	mov    $0x1,%edx
    e3c0:	89 5d fc             	mov    %ebx,0xfffffffc(%ebp)
    e3c3:	8b 5d 08             	mov    0x8(%ebp),%ebx
    e3c6:	8b 43 3c             	mov    0x3c(%ebx),%eax
    e3c9:	e8 fc ff ff ff       	call   e3ca <queue_upcall_deliver+0x1a>
	if (!sk->dead) {
    e3ce:	0f b6 83 80 00 00 00 	movzbl 0x80(%ebx),%eax
    e3d5:	84 c0                	test   %al,%al
    e3d7:	74 17                	je     e3f0 <queue_upcall_deliver+0x40>
		/* clear select and other blocking operations */
		sk->data_ready(sk, 0);
	}
	sk->tp_pinfo.af_tcp.cminisock_api_config.cfg.ctl->update_since_poll += 1;
    e3d9:	8b 83 88 02 00 00    	mov    0x288(%ebx),%eax
    e3df:	ff 40 38             	incl   0x38(%eax)
}
    e3e2:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
    e3e5:	89 ec                	mov    %ebp,%esp
    e3e7:	5d                   	pop    %ebp
    e3e8:	c3                   	ret    
    e3e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    e3f0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    e3f7:	00 
    e3f8:	89 1c 24             	mov    %ebx,(%esp,1)
    e3fb:	ff 93 ac 0c 00 00    	call   *0xcac(%ebx)
    e401:	eb d6                	jmp    e3d9 <queue_upcall_deliver+0x29>
    e403:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    e409:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

0000e410 <tcp_prequeue_process>:

static void tcp_prequeue_process(struct sock *sk)
{
    e410:	55                   	push   %ebp
    e411:	89 e5                	mov    %esp,%ebp
    e413:	57                   	push   %edi
    e414:	56                   	push   %esi
    e415:	53                   	push   %ebx
    e416:	83 ec 08             	sub    $0x8,%esp
    e419:	8b 7d 08             	mov    0x8(%ebp),%edi
 *	Return the length of an &sk_buff queue. 
 */
 
static inline __u32 skb_queue_len(struct sk_buff_head *list_)
{
    e41c:	a1 74 01 00 00       	mov    0x174,%eax
    e421:	8d 97 f0 00 00 00    	lea    0xf0(%edi),%edx
    e427:	8b 4a 08             	mov    0x8(%edx),%ecx
	struct sk_buff *skb;
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);

	net_statistics[smp_processor_id()*2+1].TCPPrequeued += skb_queue_len(&tp->ucopy.prequeue);

	/* RX process wants to run with disabled BHs, though it is not necessary */
	local_bh_disable();
    e42a:	ff 05 08 00 00 00    	incl   0x8
    e430:	8d b7 bc 00 00 00    	lea    0xbc(%edi),%esi
 *	Return the length of an &sk_buff queue. 
 */
 
static inline __u32 skb_queue_len(struct sk_buff_head *list_)
{
    e436:	01 c8                	add    %ecx,%eax
    e438:	a3 74 01 00 00       	mov    %eax,0x174
	while ((skb = __skb_dequeue(&tp->ucopy.prequeue)) != NULL)
    e43d:	89 d3                	mov    %edx,%ebx
    e43f:	90                   	nop    
{
	struct sk_buff *next, *prev, *result;

	prev = (struct sk_buff *) list;
	next = prev->next;
    e440:	8b 46 34             	mov    0x34(%esi),%eax
	result = NULL;
    e443:	31 d2                	xor    %edx,%edx
	if (next != prev) {
    e445:	39 d8                	cmp    %ebx,%eax
    e447:	74 21                	je     e46a <tcp_prequeue_process+0x5a>
		result = next;
    e449:	89 c2                	mov    %eax,%edx
		next = next->next;
    e44b:	8b 00                	mov    (%eax),%eax
		list->qlen--;
    e44d:	ff 4b 08             	decl   0x8(%ebx)
		next->prev = prev;
		prev->next = next;
		result->next = NULL;
		result->prev = NULL;
		result->list = NULL;
    e450:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
    e457:	89 58 04             	mov    %ebx,0x4(%eax)
    e45a:	89 46 34             	mov    %eax,0x34(%esi)
    e45d:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
    e464:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
    e46a:	85 d2                	test   %edx,%edx
    e46c:	74 0f                	je     e47d <tcp_prequeue_process+0x6d>
		sk->backlog_rcv(sk, skb);
    e46e:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    e472:	89 3c 24             	mov    %edi,(%esp,1)
    e475:	ff 97 b8 0c 00 00    	call   *0xcb8(%edi)
    e47b:	eb c3                	jmp    e440 <tcp_prequeue_process+0x30>
	local_bh_enable();
    e47d:	ba 08 00 00 00       	mov    $0x8,%edx
    e482:	a1 08 00 00 00       	mov    0x8,%eax
    e487:	48                   	dec    %eax
    e488:	85 c0                	test   %eax,%eax
    e48a:	a3 08 00 00 00       	mov    %eax,0x8
    e48f:	75 0a                	jne    e49b <tcp_prequeue_process+0x8b>
    e491:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
    e495:	0f 85 37 4b 00 00    	jne    12fd2 <.text.lock.tmalloc>

	/* Clear memory counter. */
	tp->ucopy.memory = 0;
    e49b:	c7 46 48 00 00 00 00 	movl   $0x0,0x48(%esi)
}
    e4a2:	83 c4 08             	add    $0x8,%esp
    e4a5:	5b                   	pop    %ebx
    e4a6:	5e                   	pop    %esi
    e4a7:	5f                   	pop    %edi
    e4a8:	5d                   	pop    %ebp
    e4a9:	c3                   	ret    
    e4aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000e4b0 <trickles_do_sendmsg_tiov>:

static int trickles_poll(struct sock *sk);

/* precondition: msk already 1/2 freed, and address verified */
#define SENDMSG_INSTANCE(SUFF, HANDLER)								\
static inline int trickles_do_sendmsg_ ## SUFF							\
		(struct sock *sk, struct cminisock *msk, void *vec, int veclen) {		\
	int rval = 0;										\
	struct sock dummysk;									\
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp),			\
	  *dummy_tp = &(dummysk.tp_pinfo.af_tcp);						\
	struct sk_buff *skb;									\
												\
	/* dummysk = kmalloc(sizeof(struct sock), GFP_KERNEL); */				\
	dummy_tp->trickles_opt = tp->trickles_opt;						\
	dummy_tp->t.hmacCTX = tp->t.hmacCTX;							\
	dummy_tp->t.nonceCTX = tp->t.nonceCTX;							\
												\
	init_sock(msk, &dummysk);  								\
												\
	{											\
		static int last;								\
		if(msk->seqnum != last+1) {							\
			/* printk("missing downcall: out of sequence\n"); */			\
		}										\
		last = msk->seqnum;								\
	}											\
												\
	if(msk->tag == ACK || msk->tag == FIN) {						\
		HANDLER(msk,vec,veclen);							\
	} else {										\
		struct tcp_skb_cb *tcb;								\
												\
		skb = alloc_skb(MAX_TCP_HEADER + MAX_TRICKLES_HDR_LEN + MTU, GFP_KERNEL);	\
		if(skb == NULL) {								\
			printk("could not allocate skb\n");					\
			goto out;								\
		}										\
		tcb = TCP_SKB_CB(skb);								\
		skb->csum = 0;									\
		skb->ip_summed = CHECKSUM_HW;							\
		skb_reserve(skb, MAX_TCP_HEADER + MAX_TRICKLES_HDR_LEN + MTU);			\
												\
		switch(msk->tag) {								\
		case SYN:									\
			/* converted to syn/ack in msk_transmit_skb */				\
			break;									\
		case RST:									\
			/* todo: find out what the proper semantics in response to rst are */	\
			kfree_skb(skb);								\
			goto out;								\
		default:									\
			kfree_skb(skb);								\
			BUG_TRAP(0);								\
			goto out;								\
		}										\
		msk_transmit_skb(msk, skb, 0);							\
	}											\
 out:												\
	free_trickles_msk_finish(sk,msk);							\
	return rval;										\
}

static inline int tiov_handler(struct cminisock *msk, struct tiovec *tiov, int tiovlen);
SENDMSG_INSTANCE(tiov,tiov_handler);
    e4b0:	55                   	push   %ebp
    e4b1:	89 e5                	mov    %esp,%ebp
    e4b3:	56                   	push   %esi
    e4b4:	8d 8d 38 f3 ff ff    	lea    0xfffff338(%ebp),%ecx
    e4ba:	53                   	push   %ebx
    e4bb:	81 ec cc 0c 00 00    	sub    $0xccc,%esp
    e4c1:	8b 75 08             	mov    0x8(%ebp),%esi
    e4c4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    e4c7:	8d 96 bc 00 00 00    	lea    0xbc(%esi),%edx
    e4cd:	8b 82 ec 01 00 00    	mov    0x1ec(%edx),%eax
    e4d3:	89 85 e0 f5 ff ff    	mov    %eax,0xfffff5e0(%ebp)
    e4d9:	8b 82 0c 0b 00 00    	mov    0xb0c(%edx),%eax
    e4df:	89 85 00 ff ff ff    	mov    %eax,0xffffff00(%ebp)
    e4e5:	8b 82 20 0b 00 00    	mov    0xb20(%edx),%eax
    e4eb:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    e4ef:	89 1c 24             	mov    %ebx,(%esp,1)
    e4f2:	89 85 14 ff ff ff    	mov    %eax,0xffffff14(%ebp)
    e4f8:	e8 23 fc ff ff       	call   e120 <init_sock>
    e4fd:	8b 83 c8 00 00 00    	mov    0xc8(%ebx),%eax
    e503:	a3 f0 96 13 00       	mov    %eax,0x1396f0
    e508:	8b 43 10             	mov    0x10(%ebx),%eax
    e50b:	48                   	dec    %eax
    e50c:	83 f8 01             	cmp    $0x1,%eax
    e50f:	77 2f                	ja     e540 <trickles_do_sendmsg_tiov+0x90>
    e511:	89 1c 24             	mov    %ebx,(%esp,1)
    e514:	8b 45 14             	mov    0x14(%ebp),%eax
    e517:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    e51b:	8b 45 10             	mov    0x10(%ebp),%eax
    e51e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    e522:	e8 39 04 00 00       	call   e960 <tiov_handler>
    e527:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    e52b:	89 34 24             	mov    %esi,(%esp,1)
    e52e:	e8 6d f5 ff ff       	call   daa0 <free_trickles_msk_finish>
    e533:	81 c4 cc 0c 00 00    	add    $0xccc,%esp
    e539:	31 c0                	xor    %eax,%eax
    e53b:	5b                   	pop    %ebx
    e53c:	5e                   	pop    %esi
    e53d:	5d                   	pop    %ebp
    e53e:	c3                   	ret    
    e53f:	90                   	nop    
    e540:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
    e547:	00 
    e548:	c7 04 24 40 09 00 00 	movl   $0x940,(%esp,1)
    e54f:	e8 fc ff ff ff       	call   e550 <trickles_do_sendmsg_tiov+0xa0>
    e554:	85 c0                	test   %eax,%eax
    e556:	89 c2                	mov    %eax,%edx
    e558:	0f 84 a2 00 00 00    	je     e600 <trickles_do_sendmsg_tiov+0x150>
 */

static inline void skb_reserve(struct sk_buff *skb, unsigned int len)
{
	skb->data+=len;
    e55e:	81 80 94 00 00 00 40 	addl   $0x940,0x94(%eax)
    e565:	09 00 00 
	skb->tail+=len;
    e568:	81 80 98 00 00 00 40 	addl   $0x940,0x98(%eax)
    e56f:	09 00 00 
    e572:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
    e579:	c6 40 7f 01          	movb   $0x1,0x7f(%eax)
    e57d:	8b 43 10             	mov    0x10(%ebx),%eax
    e580:	85 c0                	test   %eax,%eax
    e582:	74 63                	je     e5e7 <trickles_do_sendmsg_tiov+0x137>
    e584:	83 f8 03             	cmp    $0x3,%eax
    e587:	74 37                	je     e5c0 <trickles_do_sendmsg_tiov+0x110>
 */
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
    e589:	8b 82 84 00 00 00    	mov    0x84(%edx),%eax
    e58f:	48                   	dec    %eax
    e590:	74 0d                	je     e59f <trickles_do_sendmsg_tiov+0xef>
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
	unsigned char c;

	__asm__ __volatile__(
    e592:	ff 8a 84 00 00 00    	decl   0x84(%edx)
    e598:	0f 94 c0             	sete   %al
    e59b:	84 c0                	test   %al,%al
    e59d:	74 08                	je     e5a7 <trickles_do_sendmsg_tiov+0xf7>
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
		__kfree_skb(skb);
    e59f:	89 14 24             	mov    %edx,(%esp,1)
    e5a2:	e8 fc ff ff ff       	call   e5a3 <trickles_do_sendmsg_tiov+0xf3>
    e5a7:	c7 44 24 04 f2 00 00 	movl   $0xf2,0x4(%esp,1)
    e5ae:	00 
    e5af:	c7 04 24 00 3b 00 00 	movl   $0x3b00,(%esp,1)
    e5b6:	e8 fc ff ff ff       	call   e5b7 <trickles_do_sendmsg_tiov+0x107>
    e5bb:	e9 67 ff ff ff       	jmp    e527 <trickles_do_sendmsg_tiov+0x77>
 */
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
    e5c0:	8b 82 84 00 00 00    	mov    0x84(%edx),%eax
    e5c6:	48                   	dec    %eax
    e5c7:	74 11                	je     e5da <trickles_do_sendmsg_tiov+0x12a>
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
	unsigned char c;

	__asm__ __volatile__(
    e5c9:	ff 8a 84 00 00 00    	decl   0x84(%edx)
    e5cf:	0f 94 c0             	sete   %al
    e5d2:	84 c0                	test   %al,%al
    e5d4:	0f 84 4d ff ff ff    	je     e527 <trickles_do_sendmsg_tiov+0x77>
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
		__kfree_skb(skb);
    e5da:	89 14 24             	mov    %edx,(%esp,1)
    e5dd:	e8 fc ff ff ff       	call   e5de <trickles_do_sendmsg_tiov+0x12e>
    e5e2:	e9 40 ff ff ff       	jmp    e527 <trickles_do_sendmsg_tiov+0x77>
    e5e7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    e5ee:	00 
    e5ef:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    e5f3:	89 1c 24             	mov    %ebx,(%esp,1)
    e5f6:	e8 fc ff ff ff       	call   e5f7 <trickles_do_sendmsg_tiov+0x147>
    e5fb:	e9 27 ff ff ff       	jmp    e527 <trickles_do_sendmsg_tiov+0x77>
    e600:	c7 04 24 54 08 00 00 	movl   $0x854,(%esp,1)
    e607:	e8 fc ff ff ff       	call   e608 <trickles_do_sendmsg_tiov+0x158>
    e60c:	e9 16 ff ff ff       	jmp    e527 <trickles_do_sendmsg_tiov+0x77>
    e611:	eb 0d                	jmp    e620 <trickles_do_sendmsg_fiov>
    e613:	90                   	nop    
    e614:	90                   	nop    
    e615:	90                   	nop    
    e616:	90                   	nop    
    e617:	90                   	nop    
    e618:	90                   	nop    
    e619:	90                   	nop    
    e61a:	90                   	nop    
    e61b:	90                   	nop    
    e61c:	90                   	nop    
    e61d:	90                   	nop    
    e61e:	90                   	nop    
    e61f:	90                   	nop    

0000e620 <trickles_do_sendmsg_fiov>:
static inline int fiov_handler(struct cminisock *msk, struct fiovec *fiov, int fiovlen);
SENDMSG_INSTANCE(fiov,fiov_handler);
    e620:	55                   	push   %ebp
    e621:	89 e5                	mov    %esp,%ebp
    e623:	56                   	push   %esi
    e624:	8d 8d 38 f3 ff ff    	lea    0xfffff338(%ebp),%ecx
    e62a:	53                   	push   %ebx
    e62b:	81 ec cc 0c 00 00    	sub    $0xccc,%esp
    e631:	8b 75 08             	mov    0x8(%ebp),%esi
    e634:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    e637:	8d 96 bc 00 00 00    	lea    0xbc(%esi),%edx
    e63d:	8b 82 ec 01 00 00    	mov    0x1ec(%edx),%eax
    e643:	89 85 e0 f5 ff ff    	mov    %eax,0xfffff5e0(%ebp)
    e649:	8b 82 0c 0b 00 00    	mov    0xb0c(%edx),%eax
    e64f:	89 85 00 ff ff ff    	mov    %eax,0xffffff00(%ebp)
    e655:	8b 82 20 0b 00 00    	mov    0xb20(%edx),%eax
    e65b:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    e65f:	89 1c 24             	mov    %ebx,(%esp,1)
    e662:	89 85 14 ff ff ff    	mov    %eax,0xffffff14(%ebp)
    e668:	e8 b3 fa ff ff       	call   e120 <init_sock>
    e66d:	8b 83 c8 00 00 00    	mov    0xc8(%ebx),%eax
    e673:	a3 f4 96 13 00       	mov    %eax,0x1396f4
    e678:	8b 43 10             	mov    0x10(%ebx),%eax
    e67b:	48                   	dec    %eax
    e67c:	83 f8 01             	cmp    $0x1,%eax
    e67f:	77 2f                	ja     e6b0 <trickles_do_sendmsg_fiov+0x90>
    e681:	89 1c 24             	mov    %ebx,(%esp,1)
    e684:	8b 45 14             	mov    0x14(%ebp),%eax
    e687:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    e68b:	8b 45 10             	mov    0x10(%ebp),%eax
    e68e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    e692:	e8 19 20 00 00       	call   106b0 <fiov_handler>
    e697:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    e69b:	89 34 24             	mov    %esi,(%esp,1)
    e69e:	e8 fd f3 ff ff       	call   daa0 <free_trickles_msk_finish>
    e6a3:	81 c4 cc 0c 00 00    	add    $0xccc,%esp
    e6a9:	31 c0                	xor    %eax,%eax
    e6ab:	5b                   	pop    %ebx
    e6ac:	5e                   	pop    %esi
    e6ad:	5d                   	pop    %ebp
    e6ae:	c3                   	ret    
    e6af:	90                   	nop    
    e6b0:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
    e6b7:	00 
    e6b8:	c7 04 24 40 09 00 00 	movl   $0x940,(%esp,1)
    e6bf:	e8 fc ff ff ff       	call   e6c0 <trickles_do_sendmsg_fiov+0xa0>
    e6c4:	85 c0                	test   %eax,%eax
    e6c6:	89 c2                	mov    %eax,%edx
    e6c8:	0f 84 a2 00 00 00    	je     e770 <trickles_do_sendmsg_fiov+0x150>
 */

static inline void skb_reserve(struct sk_buff *skb, unsigned int len)
{
	skb->data+=len;
    e6ce:	81 80 94 00 00 00 40 	addl   $0x940,0x94(%eax)
    e6d5:	09 00 00 
	skb->tail+=len;
    e6d8:	81 80 98 00 00 00 40 	addl   $0x940,0x98(%eax)
    e6df:	09 00 00 
    e6e2:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
    e6e9:	c6 40 7f 01          	movb   $0x1,0x7f(%eax)
    e6ed:	8b 43 10             	mov    0x10(%ebx),%eax
    e6f0:	85 c0                	test   %eax,%eax
    e6f2:	74 63                	je     e757 <trickles_do_sendmsg_fiov+0x137>
    e6f4:	83 f8 03             	cmp    $0x3,%eax
    e6f7:	74 37                	je     e730 <trickles_do_sendmsg_fiov+0x110>
 */
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
    e6f9:	8b 82 84 00 00 00    	mov    0x84(%edx),%eax
    e6ff:	48                   	dec    %eax
    e700:	74 0d                	je     e70f <trickles_do_sendmsg_fiov+0xef>
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
	unsigned char c;

	__asm__ __volatile__(
    e702:	ff 8a 84 00 00 00    	decl   0x84(%edx)
    e708:	0f 94 c0             	sete   %al
    e70b:	84 c0                	test   %al,%al
    e70d:	74 08                	je     e717 <trickles_do_sendmsg_fiov+0xf7>
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
		__kfree_skb(skb);
    e70f:	89 14 24             	mov    %edx,(%esp,1)
    e712:	e8 fc ff ff ff       	call   e713 <trickles_do_sendmsg_fiov+0xf3>
    e717:	c7 44 24 04 f4 00 00 	movl   $0xf4,0x4(%esp,1)
    e71e:	00 
    e71f:	c7 04 24 00 3b 00 00 	movl   $0x3b00,(%esp,1)
    e726:	e8 fc ff ff ff       	call   e727 <trickles_do_sendmsg_fiov+0x107>
    e72b:	e9 67 ff ff ff       	jmp    e697 <trickles_do_sendmsg_fiov+0x77>
 */
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
    e730:	8b 82 84 00 00 00    	mov    0x84(%edx),%eax
    e736:	48                   	dec    %eax
    e737:	74 11                	je     e74a <trickles_do_sendmsg_fiov+0x12a>
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
	unsigned char c;

	__asm__ __volatile__(
    e739:	ff 8a 84 00 00 00    	decl   0x84(%edx)
    e73f:	0f 94 c0             	sete   %al
    e742:	84 c0                	test   %al,%al
    e744:	0f 84 4d ff ff ff    	je     e697 <trickles_do_sendmsg_fiov+0x77>
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
		__kfree_skb(skb);
    e74a:	89 14 24             	mov    %edx,(%esp,1)
    e74d:	e8 fc ff ff ff       	call   e74e <trickles_do_sendmsg_fiov+0x12e>
    e752:	e9 40 ff ff ff       	jmp    e697 <trickles_do_sendmsg_fiov+0x77>
    e757:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    e75e:	00 
    e75f:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    e763:	89 1c 24             	mov    %ebx,(%esp,1)
    e766:	e8 fc ff ff ff       	call   e767 <trickles_do_sendmsg_fiov+0x147>
    e76b:	e9 27 ff ff ff       	jmp    e697 <trickles_do_sendmsg_fiov+0x77>
    e770:	c7 04 24 54 08 00 00 	movl   $0x854,(%esp,1)
    e777:	e8 fc ff ff ff       	call   e778 <trickles_do_sendmsg_fiov+0x158>
    e77c:	e9 16 ff ff ff       	jmp    e697 <trickles_do_sendmsg_fiov+0x77>
    e781:	eb 0d                	jmp    e790 <free_remaining>
    e783:	90                   	nop    
    e784:	90                   	nop    
    e785:	90                   	nop    
    e786:	90                   	nop    
    e787:	90                   	nop    
    e788:	90                   	nop    
    e789:	90                   	nop    
    e78a:	90                   	nop    
    e78b:	90                   	nop    
    e78c:	90                   	nop    
    e78d:	90                   	nop    
    e78e:	90                   	nop    
    e78f:	90                   	nop    

0000e790 <free_remaining>:

#ifdef SETUCONT_COMMAND
static inline
int containsUContDesc(struct cminisock_packet *cpkt) {
	return cpkt->ucontLen < 0;
}

static inline
void extractUContDesc(struct cminisock_packet *cpkt, int *ucontLen, char **user_src) {
	*ucontLen = cpkt->ucontLen = -cpkt->ucontLen;
	*user_src = cpkt->ucontData;
	cpkt->ucontData = NULL;
}

static inline
void insertUContDesc(struct cminisock_packet *cpkt, int ucontLen, char *user_src) {
	BUG_TRAP(cpkt->ucontLen == 0);
	cpkt->ucontLen = -ucontLen;
	cpkt->ucontData = user_src;
}

static inline
int setupUCont(struct cminisock *msk, struct ucontdesc *udesc, int udesclen, 
		int udescstride) {
	int i;
	struct cminisock_packet *pkts = msk->packets;
	int packetNum = 0;

	for(i=0; i < udesclen; i++) {
		struct ucontdesc *curr_tiov = 
			(struct ucontdesc *) ((char*)udesc + udescstride * i);
		int ucontLen = curr_tiov->ucont_len;
		if(ucontLen > 0) {
			if(packetNum >= msk->num_packets) {
				printk("Too many uconts specified in list\n");
				return 0;
			}
			if(pkts[packetNum].ucontLen > 0) {
				printk("UContLen > 0!!!, ptr = %p\n", pkts[packetNum].ucontData);
				return -1;
			}
			insertUContDesc(&pkts[packetNum], ucontLen, curr_tiov->ucont_base);
			packetNum++;
		}
	}
	return 0;
}

static inline 
int copyUCont(struct sk_buff *skb, struct cminisock_packet *cpkt) {
	if(containsUContDesc(cpkt) < 0) {
		int error = 0;
		int ucontLen;
		char *user_src;
		extractUContDesc(cpkt, &ucontLen, &user_src);
		skb->csum =
			csum_and_copy_from_user(user_src, skb_push(skb, ucontLen), 
						ucontLen, skb->csum, &error);
		if(error) {
			printk("csum error on ucont\n");
			return error;
		}
	}
	return 0;
}
#else

#define containsUContDesc(X) (0)

#define extractUContDesc(X,Y,Z) do { BUG_TRAP(0); } while(0)

#define insertUContDesc(X,Y,Z) do { BUG_TRAP(0); } while(0)

#define setupUCont(A,B,C,D) (0)

#define copyUCont(X,Y) (0)

#endif // SETUCONT_COMMAND

static inline
void free_remaining(struct sk_buff **skbs, int offset, int total) {
    e790:	55                   	push   %ebp
    e791:	89 e5                	mov    %esp,%ebp
    e793:	57                   	push   %edi
    e794:	56                   	push   %esi
    e795:	53                   	push   %ebx
    e796:	83 ec 04             	sub    $0x4,%esp
    e799:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    e79c:	8b 75 10             	mov    0x10(%ebp),%esi
    e79f:	8b 7d 08             	mov    0x8(%ebp),%edi
	for(; offset < total; offset++) {
    e7a2:	39 f3                	cmp    %esi,%ebx
    e7a4:	7d 30                	jge    e7d6 <free_remaining+0x46>
    e7a6:	8d 76 00             	lea    0x0(%esi),%esi
    e7a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
 *	hit zero.
 */
 
static inline void kfree_skb(struct sk_buff *skb)
{
    e7b0:	8b 14 9f             	mov    (%edi,%ebx,4),%edx
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
    e7b3:	8b 82 84 00 00 00    	mov    0x84(%edx),%eax
    e7b9:	48                   	dec    %eax
    e7ba:	74 0d                	je     e7c9 <free_remaining+0x39>
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
	unsigned char c;

	__asm__ __volatile__(
    e7bc:	ff 8a 84 00 00 00    	decl   0x84(%edx)
    e7c2:	0f 94 c0             	sete   %al
    e7c5:	84 c0                	test   %al,%al
    e7c7:	74 08                	je     e7d1 <free_remaining+0x41>
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
		__kfree_skb(skb);
    e7c9:	89 14 24             	mov    %edx,(%esp,1)
    e7cc:	e8 fc ff ff ff       	call   e7cd <free_remaining+0x3d>
    e7d1:	43                   	inc    %ebx
    e7d2:	39 f3                	cmp    %esi,%ebx
    e7d4:	7c da                	jl     e7b0 <free_remaining+0x20>
		kfree_skb(skbs[offset]);
	}
}
    e7d6:	5b                   	pop    %ebx
    e7d7:	5b                   	pop    %ebx
    e7d8:	5e                   	pop    %esi
    e7d9:	5f                   	pop    %edi
    e7da:	5d                   	pop    %ebp
    e7db:	c3                   	ret    
    e7dc:	8d 74 26 00          	lea    0x0(%esi,1),%esi

0000e7e0 <finishTransmitHelper>:

#ifdef SETUCONT_COMMAND
#define FINISH_TRANSMIT(MSK,SKBS,NUM_DATA_PACKETS,UDESC,UDESCLEN,UDESCSTRIDE) \
	finishTransmitHelper(MSK,SKBS,NUM_DATA_PACKETS,UDESC,UDESCLEN,UDESCSTRIDE)
#else
#define FINISH_TRANSMIT(MSK,SKBS,NUM_DATA_PACKETS,UDESC,UDESCLEN,UDESCSTRIDE) \
	finishTransmitHelper(MSK,SKBS,NUM_DATA_PACKETS,NULL,0,0)
#endif

static 
void finishTransmitHelper(struct cminisock *msk, struct sk_buff *skbs[], 
		    int numDataPackets, struct ucontdesc *udesc, 
		    int udesclen, int udescstride) {
    e7e0:	55                   	push   %ebp
    e7e1:	89 e5                	mov    %esp,%ebp
    e7e3:	57                   	push   %edi
    e7e4:	56                   	push   %esi
    e7e5:	53                   	push   %ebx
    e7e6:	83 ec 20             	sub    $0x20,%esp
    e7e9:	8b 45 08             	mov    0x8(%ebp),%eax
    e7ec:	8b 55 0c             	mov    0xc(%ebp),%edx
    e7ef:	8b 7d 10             	mov    0x10(%ebp),%edi
    e7f2:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    e7f5:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
#define REALCHILD(PKT) ((PKT).ucontLen != 0)
	struct cminisock_packet *pkts = msk->packets;
	int numUCChildPackets = numDataPackets;
	int i, j, UCposition;
	struct sk_buff *skb;

	if(setupUCont(msk, udesc, udesclen, udescstride)) {
		free_remaining(skbs, 0, numDataPackets);
		// failure
		return;
	}
	for(i=numUCChildPackets; i < msk->num_packets; i++) {
    e7f8:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    e7fb:	8b 80 e0 00 00 00    	mov    0xe0(%eax),%eax
    e801:	89 fe                	mov    %edi,%esi
    e803:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    e806:	8b 8a dc 00 00 00    	mov    0xdc(%edx),%ecx
    e80c:	39 cf                	cmp    %ecx,%edi
    e80e:	89 4d e0             	mov    %ecx,0xffffffe0(%ebp)
    e811:	7d 1c                	jge    e82f <finishTransmitHelper+0x4f>
    e813:	8d 14 bf             	lea    (%edi,%edi,4),%edx
    e816:	8d 54 d0 14          	lea    0x14(%eax,%edx,8),%edx
    e81a:	89 c8                	mov    %ecx,%eax
    e81c:	29 f8                	sub    %edi,%eax
    e81e:	89 c3                	mov    %eax,%ebx
		// find more child packets (e.g., ucont_len > 0)
		if(REALCHILD(pkts[i])) {
    e820:	83 3a 00             	cmpl   $0x0,(%edx)
    e823:	8d 46 01             	lea    0x1(%esi),%eax
    e826:	0f 45 f0             	cmovne %eax,%esi
    e829:	83 c2 28             	add    $0x28,%edx
    e82c:	4b                   	dec    %ebx
    e82d:	75 f1                	jne    e820 <finishTransmitHelper+0x40>
			numUCChildPackets++;
		}
	}
	for(i=0; i < msk->num_packets; i++) {
    e82f:	31 db                	xor    %ebx,%ebx
    e831:	3b 5d e0             	cmp    0xffffffe0(%ebp),%ebx
    e834:	7d 1f                	jge    e855 <finishTransmitHelper+0x75>
    e836:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    e839:	83 c0 11             	add    $0x11,%eax
    e83c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
		pkts[i].numSiblings = numUCChildPackets;
    e840:	89 f2                	mov    %esi,%edx
    e842:	43                   	inc    %ebx
    e843:	88 10                	mov    %dl,(%eax)
    e845:	83 c0 28             	add    $0x28,%eax
    e848:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    e84b:	8b 8a dc 00 00 00    	mov    0xdc(%edx),%ecx
    e851:	39 cb                	cmp    %ecx,%ebx
    e853:	7c eb                	jl     e840 <finishTransmitHelper+0x60>
	}
	UCposition = 0;
    e855:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
	for(j=0; j < numDataPackets; j++) {
    e85c:	31 f6                	xor    %esi,%esi
    e85e:	39 fe                	cmp    %edi,%esi
    e860:	7d 41                	jge    e8a3 <finishTransmitHelper+0xc3>
    e862:	8b 5d e8             	mov    0xffffffe8(%ebp),%ebx
    e865:	83 c3 12             	add    $0x12,%ebx
    e868:	90                   	nop    
    e869:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
		pkts[j].position = UCposition++;
    e870:	0f b6 45 e4          	movzbl 0xffffffe4(%ebp),%eax
    e874:	88 03                	mov    %al,(%ebx)
    e876:	83 c3 28             	add    $0x28,%ebx
    e879:	ff 45 e4             	incl   0xffffffe4(%ebp)
		if(copyUCont(skbs[j], &pkts[j])) {
			free_remaining(skbs, j, numDataPackets);
			return;
		}
		msk_transmit_skb(msk, skbs[j], j);
    e87c:	89 74 24 08          	mov    %esi,0x8(%esp,1)
    e880:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    e883:	8b 04 b2             	mov    (%edx,%esi,4),%eax
    e886:	46                   	inc    %esi
    e887:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    e88b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    e88e:	89 04 24             	mov    %eax,(%esp,1)
    e891:	e8 fc ff ff ff       	call   e892 <finishTransmitHelper+0xb2>
    e896:	39 fe                	cmp    %edi,%esi
    e898:	7c d6                	jl     e870 <finishTransmitHelper+0x90>
    e89a:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    e89d:	8b 8a dc 00 00 00    	mov    0xdc(%edx),%ecx
	}
	for(i = numDataPackets; i < msk->num_packets; i++) {
    e8a3:	39 cf                	cmp    %ecx,%edi
    e8a5:	89 fb                	mov    %edi,%ebx
    e8a7:	0f 8d 7f 00 00 00    	jge    e92c <finishTransmitHelper+0x14c>
    e8ad:	8d 04 bf             	lea    (%edi,%edi,4),%eax
    e8b0:	8d 3c c5 00 00 00 00 	lea    0x0(,%eax,8),%edi
    e8b7:	89 f6                	mov    %esi,%esi
    e8b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
		if(REALCHILD(pkts[i])) {
    e8c0:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    e8c3:	8b 74 38 14          	mov    0x14(%eax,%edi,1),%esi
    e8c7:	85 f6                	test   %esi,%esi
    e8c9:	74 7c                	je     e947 <finishTransmitHelper+0x167>
			pkts[i].position = UCposition++;
    e8cb:	0f b6 55 e4          	movzbl 0xffffffe4(%ebp),%edx
    e8cf:	88 54 38 12          	mov    %dl,0x12(%eax,%edi,1)
    e8d3:	ff 45 e4             	incl   0xffffffe4(%ebp)
		} else {
			pkts[i].position = INVALID_POSITION;
		}
		/* Send out all remaining packets to placate transport level */
		// XXX Should piggyback all of these packets into a single packet

		int ucontLen;
#ifdef SETUCONT_COMMAND
		ucontLen = abs(pkts[i].ucontLen);
#else
		ucontLen = pkts[i].ucontLen;
#endif // SETUCONT_COMMAND
		skb = alloc_skb(MAX_TCP_HEADER + MAX_TRICKLES_HDR_LEN + ucontLen, GFP_KERNEL);
    e8d6:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    e8d9:	8b 74 3a 14          	mov    0x14(%edx,%edi,1),%esi
    e8dd:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
    e8e4:	00 
    e8e5:	81 c6 ee 03 00 00    	add    $0x3ee,%esi
    e8eb:	89 34 24             	mov    %esi,(%esp,1)
    e8ee:	e8 fc ff ff ff       	call   e8ef <finishTransmitHelper+0x10f>
		if(skb == NULL) {
    e8f3:	85 c0                	test   %eax,%eax
    e8f5:	74 3d                	je     e934 <finishTransmitHelper+0x154>
 */

static inline void skb_reserve(struct sk_buff *skb, unsigned int len)
{
	skb->data+=len;
    e8f7:	01 b0 94 00 00 00    	add    %esi,0x94(%eax)
    e8fd:	83 c7 28             	add    $0x28,%edi

static inline void skb_reserve(struct sk_buff *skb, unsigned int len)
{
	skb->data+=len;
	skb->tail+=len;
    e900:	01 b0 98 00 00 00    	add    %esi,0x98(%eax)
			printk("out of memory during finishTransmit\n");
			return;
		}
		skb_reserve(skb, MAX_TCP_HEADER + MAX_TRICKLES_HDR_LEN + ucontLen);
		skb->csum = 0;
    e906:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
		if(copyUCont(skb, &pkts[i])) {
			return;
		}
		msk_transmit_skb(msk, skb, i);
    e90d:	89 5c 24 08          	mov    %ebx,0x8(%esp,1)
    e911:	43                   	inc    %ebx
    e912:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    e916:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    e919:	89 04 24             	mov    %eax,(%esp,1)
    e91c:	e8 fc ff ff ff       	call   e91d <finishTransmitHelper+0x13d>
    e921:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    e924:	3b 9a dc 00 00 00    	cmp    0xdc(%edx),%ebx
    e92a:	7c 94                	jl     e8c0 <finishTransmitHelper+0xe0>
	}
#undef  REALCHILD
}
    e92c:	83 c4 20             	add    $0x20,%esp
    e92f:	5b                   	pop    %ebx
    e930:	5e                   	pop    %esi
    e931:	5f                   	pop    %edi
    e932:	5d                   	pop    %ebp
    e933:	c3                   	ret    
    e934:	c7 45 08 40 3b 00 00 	movl   $0x3b40,0x8(%ebp)
    e93b:	83 c4 20             	add    $0x20,%esp
    e93e:	5b                   	pop    %ebx
    e93f:	5e                   	pop    %esi
    e940:	5f                   	pop    %edi
    e941:	5d                   	pop    %ebp
    e942:	e9 fc ff ff ff       	jmp    e943 <finishTransmitHelper+0x163>
    e947:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    e94a:	c6 44 38 12 ff       	movb   $0xff,0x12(%eax,%edi,1)
    e94f:	eb 85                	jmp    e8d6 <finishTransmitHelper+0xf6>
    e951:	eb 0d                	jmp    e960 <tiov_handler>
    e953:	90                   	nop    
    e954:	90                   	nop    
    e955:	90                   	nop    
    e956:	90                   	nop    
    e957:	90                   	nop    
    e958:	90                   	nop    
    e959:	90                   	nop    
    e95a:	90                   	nop    
    e95b:	90                   	nop    
    e95c:	90                   	nop    
    e95d:	90                   	nop    
    e95e:	90                   	nop    
    e95f:	90                   	nop    

0000e960 <tiov_handler>:

static inline int tiov_handler(struct cminisock *msk, struct tiovec *tiov, int tiovlen) {
    e960:	55                   	push   %ebp
    e961:	89 e5                	mov    %esp,%ebp
    e963:	57                   	push   %edi
    e964:	56                   	push   %esi
    e965:	53                   	push   %ebx
    e966:	83 ec 50             	sub    $0x50,%esp
	int i, numDataPackets = 0, totallen = 0, tiov_pos = 0, tiov_offs = 0;
    e969:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
	struct cminisock_packet *pkts;
	int rval = 0;
#define MAX_SKBS (4)
	struct sk_buff *skb_body[MAX_SKBS];
	struct sk_buff **skbs, *skb;
	if(msk->num_packets > MAX_SKBS) {
    e970:	8b 55 08             	mov    0x8(%ebp),%edx
    e973:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
    e97a:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
    e981:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
    e988:	c7 45 c8 00 00 00 00 	movl   $0x0,0xffffffc8(%ebp)
    e98f:	8b 82 dc 00 00 00    	mov    0xdc(%edx),%eax
    e995:	83 f8 04             	cmp    $0x4,%eax
    e998:	0f 8f f0 05 00 00    	jg     ef8e <tiov_handler+0x62e>
		skbs = kmalloc(sizeof(struct sk_buff *) * msk->num_packets, GFP_USER);
	} else {
		skbs = skb_body;
    e99e:	8d 4d e4             	lea    0xffffffe4(%ebp),%ecx
    e9a1:	89 4d c4             	mov    %ecx,0xffffffc4(%ebp)
	}
	int maxLen = 0;

	if(skbs == NULL)
    e9a4:	8b 75 c4             	mov    0xffffffc4(%ebp),%esi
    e9a7:	31 db                	xor    %ebx,%ebx
    e9a9:	85 f6                	test   %esi,%esi
    e9ab:	0f 84 74 03 00 00    	je     ed25 <tiov_handler+0x3c5>
		goto out;

	pkts = msk->packets;
    e9b1:	8b 45 08             	mov    0x8(%ebp),%eax

	pkts[0].byteNum = msk->byteNum;
    e9b4:	8b 55 08             	mov    0x8(%ebp),%edx
    e9b7:	8b 80 e0 00 00 00    	mov    0xe0(%eax),%eax
    e9bd:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    e9c0:	8b 42 30             	mov    0x30(%edx),%eax
    e9c3:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
    e9c6:	89 41 0c             	mov    %eax,0xc(%ecx)
	for(i=0; i < tiovlen; i++) {
    e9c9:	8b 45 10             	mov    0x10(%ebp),%eax
    e9cc:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
    e9d3:	39 c3                	cmp    %eax,%ebx
    e9d5:	7d 21                	jge    e9f8 <tiov_handler+0x98>
    e9d7:	89 f6                	mov    %esi,%esi
    e9d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
		totallen += tiov[i].iov_len;
    e9e0:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    e9e3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e9e6:	8b 54 d1 04          	mov    0x4(%ecx,%edx,8),%edx
    e9ea:	ff 45 e0             	incl   0xffffffe0(%ebp)
    e9ed:	8b 4d 10             	mov    0x10(%ebp),%ecx
    e9f0:	01 55 d8             	add    %edx,0xffffffd8(%ebp)
    e9f3:	39 4d e0             	cmp    %ecx,0xffffffe0(%ebp)
    e9f6:	7c e8                	jl     e9e0 <tiov_handler+0x80>
	}
	for(i=0; i < msk->num_packets; i++) {
    e9f8:	8b 45 08             	mov    0x8(%ebp),%eax
    e9fb:	8b 90 dc 00 00 00    	mov    0xdc(%eax),%edx
    ea01:	85 d2                	test   %edx,%edx
    ea03:	7e 27                	jle    ea2c <tiov_handler+0xcc>
    ea05:	8b 80 e0 00 00 00    	mov    0xe0(%eax),%eax
    ea0b:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
    ea0e:	83 c0 08             	add    $0x8,%eax
    ea11:	eb 0d                	jmp    ea20 <tiov_handler+0xc0>
    ea13:	90                   	nop    
    ea14:	90                   	nop    
    ea15:	90                   	nop    
    ea16:	90                   	nop    
    ea17:	90                   	nop    
    ea18:	90                   	nop    
    ea19:	90                   	nop    
    ea1a:	90                   	nop    
    ea1b:	90                   	nop    
    ea1c:	90                   	nop    
    ea1d:	90                   	nop    
    ea1e:	90                   	nop    
    ea1f:	90                   	nop    
		maxLen += msk->packets[i].len;
    ea20:	8b 08                	mov    (%eax),%ecx
    ea22:	83 c0 28             	add    $0x28,%eax
    ea25:	01 cb                	add    %ecx,%ebx
    ea27:	ff 4d e0             	decl   0xffffffe0(%ebp)
    ea2a:	75 f4                	jne    ea20 <tiov_handler+0xc0>
	}
	if(totallen < maxLen) {
    ea2c:	39 5d d8             	cmp    %ebx,0xffffffd8(%ebp)
    ea2f:	0f 8d 0b 01 00 00    	jge    eb40 <tiov_handler+0x1e0>
		if(trickles_ratelimit()) {
    ea35:	a1 00 00 00 00       	mov    0x0,%eax
    ea3a:	9c                   	pushf  
    ea3b:	59                   	pop    %ecx
    ea3c:	fa                   	cli    
    ea3d:	89 c2                	mov    %eax,%edx
    ea3f:	8b 3d f8 96 13 00    	mov    0x1396f8,%edi
    ea45:	8b 35 30 01 00 00    	mov    0x130,%esi
    ea4b:	a3 f8 96 13 00       	mov    %eax,0x1396f8
    ea50:	29 fa                	sub    %edi,%edx
    ea52:	01 f2                	add    %esi,%edx
    ea54:	89 15 30 01 00 00    	mov    %edx,0x130
    ea5a:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    ea60:	76 10                	jbe    ea72 <tiov_handler+0x112>
    ea62:	bf 88 13 00 00       	mov    $0x1388,%edi
    ea67:	ba 88 13 00 00       	mov    $0x1388,%edx
    ea6c:	89 3d 30 01 00 00    	mov    %edi,0x130
    ea72:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    ea78:	0f 86 01 05 00 00    	jbe    ef7f <tiov_handler+0x61f>
    ea7e:	31 f6                	xor    %esi,%esi
    ea80:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    ea86:	a1 fc 96 13 00       	mov    0x1396fc,%eax
    ea8b:	89 15 30 01 00 00    	mov    %edx,0x130
    ea91:	89 35 fc 96 13 00    	mov    %esi,0x1396fc
    ea97:	51                   	push   %ecx
    ea98:	9d                   	popf   
    ea99:	85 c0                	test   %eax,%eax
    ea9b:	0f 85 b9 04 00 00    	jne    ef5a <tiov_handler+0x5fa>
    eaa1:	b8 01 00 00 00       	mov    $0x1,%eax
    eaa6:	85 c0                	test   %eax,%eax
    eaa8:	0f 85 8a 04 00 00    	jne    ef38 <tiov_handler+0x5d8>
			printk("Short by %d (%d - %d)\n", maxLen - totallen,
			       maxLen, totallen);
		}
		static int zerocount = 0;
		if(totallen == 0) {
    eaae:	8b 7d d8             	mov    0xffffffd8(%ebp),%edi
    eab1:	85 ff                	test   %edi,%edi
    eab3:	0f 85 71 04 00 00    	jne    ef2a <tiov_handler+0x5ca>
			zerocount++;
    eab9:	ff 05 34 01 00 00    	incl   0x134
			if(trickles_ratelimit()) {
    eabf:	a1 00 00 00 00       	mov    0x0,%eax
    eac4:	9c                   	pushf  
    eac5:	59                   	pop    %ecx
    eac6:	fa                   	cli    
    eac7:	89 c2                	mov    %eax,%edx
    eac9:	8b 35 00 97 13 00    	mov    0x139700,%esi
    eacf:	8b 1d 38 01 00 00    	mov    0x138,%ebx
    ead5:	a3 00 97 13 00       	mov    %eax,0x139700
    eada:	29 f2                	sub    %esi,%edx
    eadc:	01 da                	add    %ebx,%edx
    eade:	89 15 38 01 00 00    	mov    %edx,0x138
    eae4:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    eaea:	76 0f                	jbe    eafb <tiov_handler+0x19b>
    eaec:	b8 88 13 00 00       	mov    $0x1388,%eax
    eaf1:	ba 88 13 00 00       	mov    $0x1388,%edx
    eaf6:	a3 38 01 00 00       	mov    %eax,0x138
    eafb:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    eb01:	0f 86 14 04 00 00    	jbe    ef1b <tiov_handler+0x5bb>
    eb07:	31 ff                	xor    %edi,%edi
    eb09:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    eb0f:	a1 04 97 13 00       	mov    0x139704,%eax
    eb14:	89 15 38 01 00 00    	mov    %edx,0x138
    eb1a:	89 3d 04 97 13 00    	mov    %edi,0x139704
    eb20:	51                   	push   %ecx
    eb21:	9d                   	popf   
    eb22:	85 c0                	test   %eax,%eax
    eb24:	0f 85 cc 03 00 00    	jne    eef6 <tiov_handler+0x596>
    eb2a:	b8 01 00 00 00       	mov    $0x1,%eax
    eb2f:	85 c0                	test   %eax,%eax
    eb31:	0f 85 a5 03 00 00    	jne    eedc <tiov_handler+0x57c>
    eb37:	8b 4d 08             	mov    0x8(%ebp),%ecx
    eb3a:	8b 91 dc 00 00 00    	mov    0xdc(%ecx),%edx
				printk("zero request count: %d\n", zerocount);
			}
		}
	}
	for(i=0; i < msk->num_packets; i++) {
    eb40:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
    eb47:	39 55 e0             	cmp    %edx,0xffffffe0(%ebp)
    eb4a:	0f 8d 2c 01 00 00    	jge    ec7c <tiov_handler+0x31c>
    eb50:	8b 45 10             	mov    0x10(%ebp),%eax
    eb53:	8b 55 0c             	mov    0xc(%ebp),%edx
    eb56:	8d 04 c2             	lea    (%edx,%eax,8),%eax
    eb59:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
		int pkt_remain;
		int short_pkt = 0;

		if(i >= 1) {
    eb5c:	8b 75 e0             	mov    0xffffffe0(%ebp),%esi
    eb5f:	85 f6                	test   %esi,%esi
    eb61:	7e 1a                	jle    eb7d <tiov_handler+0x21d>
			pkts[i].byteNum = pkts[i-1].byteNum + pkts[i-1].len;
    eb63:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
    eb66:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
    eb69:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
    eb6c:	c1 e2 03             	shl    $0x3,%edx
    eb6f:	8b 44 0a e4          	mov    0xffffffe4(%edx,%ecx,1),%eax
    eb73:	8b 5c 0a e0          	mov    0xffffffe0(%edx,%ecx,1),%ebx
    eb77:	01 d8                	add    %ebx,%eax
    eb79:	89 44 11 0c          	mov    %eax,0xc(%ecx,%edx,1)
		}
		if(pkts[i].len > totallen) {
    eb7d:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    eb80:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
    eb83:	8d 04 92             	lea    (%edx,%edx,4),%eax
    eb86:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
    eb8d:	8b 44 19 08          	mov    0x8(%ecx,%ebx,1),%eax
			short_pkt = 1;
		}
		pkt_remain = pkts[i].len = MIN(pkts[i].len, totallen);
    eb91:	39 45 d8             	cmp    %eax,0xffffffd8(%ebp)
    eb94:	0f 46 45 d8          	cmovbe 0xffffffd8(%ebp),%eax
    eb98:	89 c6                	mov    %eax,%esi
    eb9a:	89 44 19 08          	mov    %eax,0x8(%ecx,%ebx,1)
		skb = skbs[i] = alloc_skb(MAX_TCP_HEADER + MAX_TRICKLES_HDR_LEN + pkts[i].ucontLen + pkts[i].len, GFP_KERNEL);
    eb9e:	8b 44 19 14          	mov    0x14(%ecx,%ebx,1),%eax
    eba2:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
    eba9:	00 
    ebaa:	05 4e 03 00 00       	add    $0x34e,%eax
    ebaf:	8d 84 06 a0 00 00 00 	lea    0xa0(%esi,%eax,1),%eax
    ebb6:	89 04 24             	mov    %eax,(%esp,1)
    ebb9:	e8 fc ff ff ff       	call   ebba <tiov_handler+0x25a>
    ebbe:	8b 55 c4             	mov    0xffffffc4(%ebp),%edx
    ebc1:	89 c7                	mov    %eax,%edi
    ebc3:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    ebc6:	89 3c 82             	mov    %edi,(%edx,%eax,4)
		numDataPackets = i+1;
    ebc9:	40                   	inc    %eax
		if(skb == NULL) {
    ebca:	85 ff                	test   %edi,%edi
    ebcc:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    ebcf:	0f 84 f6 02 00 00    	je     eecb <tiov_handler+0x56b>
	return(list_->qlen);
}

static inline void skb_queue_head_init(struct sk_buff_head *list)
{
    ebd5:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
    ebd8:	8b 44 19 14          	mov    0x14(%ecx,%ebx,1),%eax
			printk("could not allocate skb\n");
			goto out;
		}
		skb_reserve(skb, MAX_TCP_HEADER + MAX_TRICKLES_HDR_LEN + pkts[i].ucontLen);

		skb->csum = 0;
    ebdc:	c7 47 78 00 00 00 00 	movl   $0x0,0x78(%edi)
		skb->ip_summed = CHECKSUM_HW;
    ebe3:	c6 47 7f 01          	movb   $0x1,0x7f(%edi)
	return(list_->qlen);
}

static inline void skb_queue_head_init(struct sk_buff_head *list)
{
    ebe7:	05 ee 03 00 00       	add    $0x3ee,%eax
	spin_lock_init(&list->lock);
	list->prev = (struct sk_buff *)list;
	list->next = (struct sk_buff *)list;
	list->qlen = 0;
}

/*
 *	Insert an sk_buff at the start of a list.
 *
 *	The "__skb_xxxx()" functions are the non-atomic ones that
 *	can only be called with interrupts disabled.
 */

/**
 *	__skb_queue_head - queue a buffer at the list head
 *	@list: list to use
 *	@newsk: buffer to queue
 *
 *	Queue a buffer at the start of a list. This function takes no locks
 *	and you must therefore hold required locks before calling it.
 *
 *	A buffer cannot be placed on two lists at the same time.
 */	
 
static inline void __skb_queue_head(struct sk_buff_head *list, struct sk_buff *newsk)
{
	struct sk_buff *prev, *next;

	newsk->list = list;
	list->qlen++;
	prev = (struct sk_buff *)list;
	next = prev->next;
	newsk->next = next;
	newsk->prev = prev;
	next->prev = newsk;
	prev->next = newsk;
}


/**
 *	skb_queue_head - queue a buffer at the list head
 *	@list: list to use
 *	@newsk: buffer to queue
 *
 *	Queue a buffer at the start of the list. This function takes the
 *	list lock and can be used safely with other locking &sk_buff functions
 *	safely.
 *
 *	A buffer cannot be placed on two lists at the same time.
 */	

static inline void skb_queue_head(struct sk_buff_head *list, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&list->lock, flags);
	__skb_queue_head(list, newsk);
	spin_unlock_irqrestore(&list->lock, flags);
}

/**
 *	__skb_queue_tail - queue a buffer at the list tail
 *	@list: list to use
 *	@newsk: buffer to queue
 *
 *	Queue a buffer at the end of a list. This function takes no locks
 *	and you must therefore hold required locks before calling it.
 *
 *	A buffer cannot be placed on two lists at the same time.
 */	
 

static inline void __skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
	struct sk_buff *prev, *next;

	newsk->list = list;
	list->qlen++;
	next = (struct sk_buff *)list;
	prev = next->prev;
	newsk->next = next;
	newsk->prev = prev;
	next->prev = newsk;
	prev->next = newsk;
}

/**
 *	skb_queue_tail - queue a buffer at the list tail
 *	@list: list to use
 *	@newsk: buffer to queue
 *
 *	Queue a buffer at the tail of the list. This function takes the
 *	list lock and can be used safely with other locking &sk_buff functions
 *	safely.
 *
 *	A buffer cannot be placed on two lists at the same time.
 */	

static inline void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&list->lock, flags);
	__skb_queue_tail(list, newsk);
	spin_unlock_irqrestore(&list->lock, flags);
}

/**
 *	__skb_dequeue - remove from the head of the queue
 *	@list: list to dequeue from
 *
 *	Remove the head of the list. This function does not take any locks
 *	so must be used with appropriate locks held only. The head item is
 *	returned or %NULL if the list is empty.
 */

static inline struct sk_buff *__skb_dequeue(struct sk_buff_head *list)
{
	struct sk_buff *next, *prev, *result;

	prev = (struct sk_buff *) list;
	next = prev->next;
	result = NULL;
	if (next != prev) {
		result = next;
		next = next->next;
		list->qlen--;
		next->prev = prev;
		prev->next = next;
		result->next = NULL;
		result->prev = NULL;
		result->list = NULL;
	}
	return result;
}

/**
 *	skb_dequeue - remove from the head of the queue
 *	@list: list to dequeue from
 *
 *	Remove the head of the list. The list lock is taken so the function
 *	may be used safely with other locking list functions. The head item is
 *	returned or %NULL if the list is empty.
 */

static inline struct sk_buff *skb_dequeue(struct sk_buff_head *list)
{
	unsigned long flags;
	struct sk_buff *result;

	spin_lock_irqsave(&list->lock, flags);
	result = __skb_dequeue(list);
	spin_unlock_irqrestore(&list->lock, flags);
	return result;
}

/*
 *	Insert a packet on a list.
 */

static inline void __skb_insert(struct sk_buff *newsk,
	struct sk_buff * prev, struct sk_buff *next,
	struct sk_buff_head * list)
{
	newsk->next = next;
	newsk->prev = prev;
	next->prev = newsk;
	prev->next = newsk;
	newsk->list = list;
	list->qlen++;
}

/**
 *	skb_insert	-	insert a buffer
 *	@old: buffer to insert before
 *	@newsk: buffer to insert
 *
 *	Place a packet before a given packet in a list. The list locks are taken
 *	and this function is atomic with respect to other list locked calls
 *	A buffer cannot be placed on two lists at the same time.
 */

static inline void skb_insert(struct sk_buff *old, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&old->list->lock, flags);
	__skb_insert(newsk, old->prev, old, old->list);
	spin_unlock_irqrestore(&old->list->lock, flags);
}

/*
 *	Place a packet after a given packet in a list.
 */

static inline void __skb_append(struct sk_buff *old, struct sk_buff *newsk)
{
	__skb_insert(newsk, old, old->next, old->list);
}

/**
 *	skb_append	-	append a buffer
 *	@old: buffer to insert after
 *	@newsk: buffer to insert
 *
 *	Place a packet after a given packet in a list. The list locks are taken
 *	and this function is atomic with respect to other list locked calls.
 *	A buffer cannot be placed on two lists at the same time.
 */


static inline void skb_append(struct sk_buff *old, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&old->list->lock, flags);
	__skb_append(old, newsk);
	spin_unlock_irqrestore(&old->list->lock, flags);
}

/*
 * remove sk_buff from list. _Must_ be called atomically, and with
 * the list known..
 */
 
static inline void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
{
	struct sk_buff * next, * prev;

	list->qlen--;
	next = skb->next;
	prev = skb->prev;
	skb->next = NULL;
	skb->prev = NULL;
	skb->list = NULL;
	next->prev = prev;
	prev->next = next;
}

/**
 *	skb_unlink	-	remove a buffer from a list
 *	@skb: buffer to remove
 *
 *	Place a packet after a given packet in a list. The list locks are taken
 *	and this function is atomic with respect to other list locked calls
 *	
 *	Works even without knowing the list it is sitting on, which can be 
 *	handy at times. It also means that THE LIST MUST EXIST when you 
 *	unlink. Thus a list must have its contents unlinked before it is
 *	destroyed.
 */

static inline void skb_unlink(struct sk_buff *skb)
{
	struct sk_buff_head *list = skb->list;

	if(list) {
		unsigned long flags;

		spin_lock_irqsave(&list->lock, flags);
		if(skb->list == list)
			__skb_unlink(skb, skb->list);
		spin_unlock_irqrestore(&list->lock, flags);
	}
}

/* XXX: more streamlined implementation */

/**
 *	__skb_dequeue_tail - remove from the tail of the queue
 *	@list: list to dequeue from
 *
 *	Remove the tail of the list. This function does not take any locks
 *	so must be used with appropriate locks held only. The tail item is
 *	returned or %NULL if the list is empty.
 */

static inline struct sk_buff *__skb_dequeue_tail(struct sk_buff_head *list)
{
	struct sk_buff *skb = skb_peek_tail(list); 
	if (skb)
		__skb_unlink(skb, list);
	return skb;
}

/**
 *	skb_dequeue - remove from the head of the queue
 *	@list: list to dequeue from
 *
 *	Remove the head of the list. The list lock is taken so the function
 *	may be used safely with other locking list functions. The tail item is
 *	returned or %NULL if the list is empty.
 */

static inline struct sk_buff *skb_dequeue_tail(struct sk_buff_head *list)
{
	unsigned long flags;
	struct sk_buff *result;

	spin_lock_irqsave(&list->lock, flags);
	result = __skb_dequeue_tail(list);
	spin_unlock_irqrestore(&list->lock, flags);
	return result;
}

static inline int skb_is_nonlinear(const struct sk_buff *skb)
{
	return skb->data_len;
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
	return skb->len - skb->data_len;
}

#define SKB_PAGE_ASSERT(skb) do { if (skb_shinfo(skb)->nr_frags) out_of_line_bug(); } while (0)
#define SKB_FRAG_ASSERT(skb) do { if (skb_shinfo(skb)->frag_list) out_of_line_bug(); } while (0)
#define SKB_LINEAR_ASSERT(skb) do { if (skb_is_nonlinear(skb)) out_of_line_bug(); } while (0)

/*
 *	Add data to an sk_buff
 */
 
static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	return tmp;
}

/**
 *	skb_put - add data to a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer. If this would
 *	exceed the total buffer size the kernel will panic. A pointer to the
 *	first byte of the extra data is returned.
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	if(skb->tail>skb->end) {
		skb_over_panic(skb, len, current_text_addr());
	}
	return tmp;
}

static inline unsigned char *__skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
	skb->len+=len;
	return skb->data;
}

/**
 *	skb_push - add data to the start of a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer at the buffer
 *	start. If this would exceed the total buffer headroom the kernel will
 *	panic. A pointer to the first byte of the extra data is returned.
 */

static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
	skb->len+=len;
	if(skb->data<skb->head) {
		skb_under_panic(skb, len, current_text_addr());
	}
	return skb->data;
}

static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
	skb->len-=len;
	if (skb->len < skb->data_len)
		out_of_line_bug();
	return 	skb->data+=len;
}

/**
 *	skb_pull - remove data from the start of a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to remove
 *
 *	This function removes data from the start of a buffer, returning
 *	the memory to the headroom. A pointer to the next data in the buffer
 *	is returned. Once the data has been pulled future pushes will overwrite
 *	the old data.
 */

static inline unsigned char * skb_pull(struct sk_buff *skb, unsigned int len)
{	
	if (len > skb->len)
		return NULL;
	return __skb_pull(skb,len);
}

extern unsigned char * __pskb_pull_tail(struct sk_buff *skb, int delta);

static inline char *__pskb_pull(struct sk_buff *skb, unsigned int len)
{
	if (len > skb_headlen(skb) &&
	    __pskb_pull_tail(skb, len-skb_headlen(skb)) == NULL)
		return NULL;
	skb->len -= len;
	return 	skb->data += len;
}

static inline unsigned char * pskb_pull(struct sk_buff *skb, unsigned int len)
{	
	if (len > skb->len)
		return NULL;
	return __pskb_pull(skb,len);
}

static inline int pskb_may_pull(struct sk_buff *skb, unsigned int len)
{
	if (len <= skb_headlen(skb))
		return 1;
	if (len > skb->len)
		return 0;
	return (__pskb_pull_tail(skb, len-skb_headlen(skb)) != NULL);
}

/**
 *	skb_headroom - bytes at buffer head
 *	@skb: buffer to check
 *
 *	Return the number of bytes of free space at the head of an &sk_buff.
 */
 
static inline int skb_headroom(const struct sk_buff *skb)
{
	return skb->data-skb->head;
}

/**
 *	skb_tailroom - bytes at buffer end
 *	@skb: buffer to check
 *
 *	Return the number of bytes of free space at the tail of an sk_buff
 */

static inline int skb_tailroom(const struct sk_buff *skb)
{
	return skb_is_nonlinear(skb) ? 0 : skb->end-skb->tail;
}

/**
 *	skb_reserve - adjust headroom
 *	@skb: buffer to alter
 *	@len: bytes to move
 *
 *	Increase the headroom of an empty &sk_buff by reducing the tail
 *	room. This is only allowed for an empty buffer.
 */

static inline void skb_reserve(struct sk_buff *skb, unsigned int len)
{
	skb->data+=len;
    ebec:	01 87 94 00 00 00    	add    %eax,0x94(%edi)
	skb->tail+=len;
    ebf2:	01 87 98 00 00 00    	add    %eax,0x98(%edi)
		while(tiov_pos < tiovlen) {
    ebf8:	8b 45 10             	mov    0x10(%ebp),%eax
    ebfb:	39 45 d4             	cmp    %eax,0xffffffd4(%ebp)
    ebfe:	0f 8c 1c 02 00 00    	jl     ee20 <tiov_handler+0x4c0>
			int amt = MIN(pkt_remain, tiov[tiov_pos].iov_len - tiov_offs);
			int err = 0;
			char *src = tiov[tiov_pos].iov_base + tiov_offs;
			//printk("tiov copy loop, copying %d\n", amt);

			err = skb_add_data(skb,src,amt);
			//printk("tiov[%d].tiov_base (%p) + tiov_offs (%u) = %p, data = %p, amt = %d, skb->csum = %x, tail = %p, tailroom = %u, tiov_len = %u, &err=%p\n", tiov_pos, tiov[tiov_pos].tiov_base, tiov_offs, tiov[tiov_pos].tiov_base + tiov_offs, data, amt, skb->csum, skb->tail, skb_tailroom(skb), tiov[tiov_pos].iov_len, &err);
			if(err) {
				printk("error while csum/copy, base = %p amt = %d\n", src, amt);
				kfree_skb(skb);
				goto out;
			}

			totallen -= amt;
			pkt_remain -= amt;
			tiov_offs += amt;
			if(tiov_offs == tiov[tiov_pos].iov_len) {
				tiov_offs = 0;
				tiov_pos++;
			}
			if(pkt_remain == 0) break;
		}
		BUG_TRAP(pkt_remain == 0);
    ec04:	85 f6                	test   %esi,%esi
    ec06:	0f 85 f6 01 00 00    	jne    ee02 <tiov_handler+0x4a2>

		if(userapi_pkt_spew) {
    ec0c:	8b 35 00 00 00 00    	mov    0x0,%esi
    ec12:	85 f6                	test   %esi,%esi
    ec14:	0f 85 ae 01 00 00    	jne    edc8 <tiov_handler+0x468>
			printk("sending pkts[%d] %u-%u\n", i, pkts[i].seq, pkts[i].seq + pkts[i].len);
		}

		// on last packet, set the tag to FIN
		if(totallen == 0 && 
    ec1a:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
    ec1d:	85 c9                	test   %ecx,%ecx
    ec1f:	75 2f                	jne    ec50 <tiov_handler+0x2f0>
    ec21:	8b 55 bc             	mov    0xffffffbc(%ebp),%edx
    ec24:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    ec27:	8b 52 f8             	mov    0xfffffff8(%edx),%edx
    ec2a:	83 e8 08             	sub    $0x8,%eax
    ec2d:	85 d2                	test   %edx,%edx
    ec2f:	75 1f                	jne    ec50 <tiov_handler+0x2f0>
    ec31:	8b 40 04             	mov    0x4(%eax),%eax
    ec34:	85 c0                	test   %eax,%eax
    ec36:	75 18                	jne    ec50 <tiov_handler+0x2f0>
		   tiov[tiovlen-1].iov_base == 0 && tiov[tiovlen-1].iov_len == 0) {
			msk->tag = FIN;
    ec38:	8b 4d 08             	mov    0x8(%ebp),%ecx
    ec3b:	c7 41 10 02 00 00 00 	movl   $0x2,0x10(%ecx)
    ec42:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    ec49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
		}
		
		rval += pkts[i].len; // check how much data actually sent?
    ec50:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    ec53:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
		if(totallen == 0) {
    ec56:	8b 7d d8             	mov    0xffffffd8(%ebp),%edi
    ec59:	8d 04 92             	lea    (%edx,%edx,4),%eax
    ec5c:	8b 4c c1 08          	mov    0x8(%ecx,%eax,8),%ecx
    ec60:	01 4d c8             	add    %ecx,0xffffffc8(%ebp)
    ec63:	85 ff                	test   %edi,%edi
    ec65:	74 15                	je     ec7c <tiov_handler+0x31c>
    ec67:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    ec6a:	8b 55 08             	mov    0x8(%ebp),%edx
    ec6d:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    ec70:	3b 82 dc 00 00 00    	cmp    0xdc(%edx),%eax
    ec76:	0f 8c e0 fe ff ff    	jl     eb5c <tiov_handler+0x1fc>
			break;
		}
	}
	FINISH_TRANSMIT(msk, skbs, numDataPackets,
		       (struct ucontdesc *)&tiov[0].ucont_base, tiovlen, 
		       sizeof(*tiov));
    ec7c:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp,1)
    ec83:	00 
    ec84:	8b 4d dc             	mov    0xffffffdc(%ebp),%ecx
    ec87:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    ec8a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp,1)
    ec91:	00 
    ec92:	8b 55 08             	mov    0x8(%ebp),%edx
    ec95:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp,1)
    ec9c:	00 
    ec9d:	89 4c 24 08          	mov    %ecx,0x8(%esp,1)
    eca1:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    eca5:	89 14 24             	mov    %edx,(%esp,1)
    eca8:	e8 33 fb ff ff       	call   e7e0 <finishTransmitHelper>
	if(totallen > 0) {
    ecad:	8b 75 d8             	mov    0xffffffd8(%ebp),%esi
    ecb0:	85 f6                	test   %esi,%esi
    ecb2:	7e 71                	jle    ed25 <tiov_handler+0x3c5>
		if(trickles_ratelimit()) {
    ecb4:	a1 00 00 00 00       	mov    0x0,%eax
    ecb9:	9c                   	pushf  
    ecba:	59                   	pop    %ecx
    ecbb:	fa                   	cli    
    ecbc:	89 c2                	mov    %eax,%edx
    ecbe:	8b 1d 08 97 13 00    	mov    0x139708,%ebx
    ecc4:	8b 3d 3c 01 00 00    	mov    0x13c,%edi
    ecca:	a3 08 97 13 00       	mov    %eax,0x139708
    eccf:	29 da                	sub    %ebx,%edx
    ecd1:	01 fa                	add    %edi,%edx
    ecd3:	89 15 3c 01 00 00    	mov    %edx,0x13c
    ecd9:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
    ecdf:	76 10                	jbe    ecf1 <tiov_handler+0x391>
    ece1:	be 88 13 00 00       	mov    $0x1388,%esi
    ece6:	ba 88 13 00 00       	mov    $0x1388,%edx
    eceb:	89 35 3c 01 00 00    	mov    %esi,0x13c
    ecf1:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
    ecf7:	0f 86 bc 00 00 00    	jbe    edb9 <tiov_handler+0x459>
    ecfd:	31 db                	xor    %ebx,%ebx
    ecff:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
    ed05:	a1 0c 97 13 00       	mov    0x13970c,%eax
    ed0a:	89 15 3c 01 00 00    	mov    %edx,0x13c
    ed10:	89 1d 0c 97 13 00    	mov    %ebx,0x13970c
    ed16:	51                   	push   %ecx
    ed17:	9d                   	popf   
    ed18:	85 c0                	test   %eax,%eax
    ed1a:	75 78                	jne    ed94 <tiov_handler+0x434>
    ed1c:	b8 01 00 00 00       	mov    $0x1,%eax
    ed21:	85 c0                	test   %eax,%eax
    ed23:	75 1e                	jne    ed43 <tiov_handler+0x3e3>
			int i;
			printk("too much data for downcall: %d left, trace = %d\n",
			       totallen, msk->executionTrace);
			for(i=0; i < tiovlen; i++) {
				printk("tiov[%d] = {base = %p, len = %d}\n", i,
				       tiov[i].iov_base, tiov[i].iov_len);
			}
		}
#if 0
		printk("pre showing stack\n");
		show_stack(NULL);
		printk("done showing stack\n");
#endif
	}
 out:
	if(skbs != skb_body) {
    ed25:	8d 4d e4             	lea    0xffffffe4(%ebp),%ecx
    ed28:	39 4d c4             	cmp    %ecx,0xffffffc4(%ebp)
    ed2b:	74 0b                	je     ed38 <tiov_handler+0x3d8>
		kfree(skbs);
    ed2d:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    ed30:	89 04 24             	mov    %eax,(%esp,1)
    ed33:	e8 fc ff ff ff       	call   ed34 <tiov_handler+0x3d4>
	}
	return rval;
}
    ed38:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    ed3b:	83 c4 50             	add    $0x50,%esp
    ed3e:	5b                   	pop    %ebx
    ed3f:	5e                   	pop    %esi
    ed40:	5f                   	pop    %edi
    ed41:	5d                   	pop    %ebp
    ed42:	c3                   	ret    
    ed43:	8b 4d 08             	mov    0x8(%ebp),%ecx
    ed46:	31 db                	xor    %ebx,%ebx
    ed48:	8b 81 d0 00 00 00    	mov    0xd0(%ecx),%eax
    ed4e:	c7 04 24 80 3b 00 00 	movl   $0x3b80,(%esp,1)
    ed55:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    ed59:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    ed5c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ed60:	e8 fc ff ff ff       	call   ed61 <tiov_handler+0x401>
    ed65:	3b 5d 10             	cmp    0x10(%ebp),%ebx
    ed68:	7d bb                	jge    ed25 <tiov_handler+0x3c5>
    ed6a:	8b 55 0c             	mov    0xc(%ebp),%edx
    ed6d:	8b 44 da 04          	mov    0x4(%edx,%ebx,8),%eax
    ed71:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    ed75:	8b 04 da             	mov    (%edx,%ebx,8),%eax
    ed78:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    ed7c:	43                   	inc    %ebx
    ed7d:	c7 04 24 c0 3b 00 00 	movl   $0x3bc0,(%esp,1)
    ed84:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    ed88:	e8 fc ff ff ff       	call   ed89 <tiov_handler+0x429>
    ed8d:	3b 5d 10             	cmp    0x10(%ebp),%ebx
    ed90:	7c d8                	jl     ed6a <tiov_handler+0x40a>
    ed92:	eb 91                	jmp    ed25 <tiov_handler+0x3c5>
    ed94:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    ed98:	c7 44 24 08 fa 01 00 	movl   $0x1fa,0x8(%esp,1)
    ed9f:	00 
    eda0:	c7 44 24 04 6c 08 00 	movl   $0x86c,0x4(%esp,1)
    eda7:	00 
    eda8:	c7 04 24 00 3c 00 00 	movl   $0x3c00,(%esp,1)
    edaf:	e8 fc ff ff ff       	call   edb0 <tiov_handler+0x450>
    edb4:	e9 63 ff ff ff       	jmp    ed1c <tiov_handler+0x3bc>
    edb9:	ff 05 0c 97 13 00    	incl   0x13970c
    edbf:	51                   	push   %ecx
    edc0:	9d                   	popf   
    edc1:	31 c0                	xor    %eax,%eax
    edc3:	e9 59 ff ff ff       	jmp    ed21 <tiov_handler+0x3c1>
    edc8:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    edcb:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
    edce:	8d 04 92             	lea    (%edx,%edx,4),%eax
    edd1:	c1 e0 03             	shl    $0x3,%eax
    edd4:	8b 54 01 08          	mov    0x8(%ecx,%eax,1),%edx
    edd8:	8b 5c 01 04          	mov    0x4(%ecx,%eax,1),%ebx
    eddc:	01 da                	add    %ebx,%edx
    edde:	89 54 24 0c          	mov    %edx,0xc(%esp,1)
    ede2:	8b 44 01 04          	mov    0x4(%ecx,%eax,1),%eax
    ede6:	c7 04 24 7f 08 00 00 	movl   $0x87f,(%esp,1)
    eded:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    edf1:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    edf4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    edf8:	e8 fc ff ff ff       	call   edf9 <tiov_handler+0x499>
    edfd:	e9 18 fe ff ff       	jmp    ec1a <tiov_handler+0x2ba>
    ee02:	c7 44 24 04 e5 01 00 	movl   $0x1e5,0x4(%esp,1)
    ee09:	00 
    ee0a:	c7 04 24 40 3c 00 00 	movl   $0x3c40,(%esp,1)
    ee11:	e8 fc ff ff ff       	call   ee12 <tiov_handler+0x4b2>
    ee16:	e9 f1 fd ff ff       	jmp    ec0c <tiov_handler+0x2ac>
    ee1b:	90                   	nop    
    ee1c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    ee20:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
    ee23:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    ee26:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    ee29:	8b 5c d1 04          	mov    0x4(%ecx,%edx,8),%ebx
    ee2d:	29 c3                	sub    %eax,%ebx
    ee2f:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    ee32:	39 f3                	cmp    %esi,%ebx
    ee34:	0f 4f de             	cmovg  %esi,%ebx
    ee37:	03 04 d1             	add    (%ecx,%edx,8),%eax
    ee3a:	89 3c 24             	mov    %edi,(%esp,1)
    ee3d:	89 5c 24 08          	mov    %ebx,0x8(%esp,1)
    ee41:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
    ee44:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ee48:	e8 63 f1 ff ff       	call   dfb0 <skb_add_data>
    ee4d:	85 c0                	test   %eax,%eax
    ee4f:	75 3c                	jne    ee8d <tiov_handler+0x52d>
    ee51:	01 5d d0             	add    %ebx,0xffffffd0(%ebp)
    ee54:	29 de                	sub    %ebx,%esi
    ee56:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
    ee59:	29 5d d8             	sub    %ebx,0xffffffd8(%ebp)
    ee5c:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee5f:	8b 55 d0             	mov    0xffffffd0(%ebp),%edx
    ee62:	3b 54 c8 04          	cmp    0x4(%eax,%ecx,8),%edx
    ee66:	74 18                	je     ee80 <tiov_handler+0x520>
    ee68:	85 f6                	test   %esi,%esi
    ee6a:	0f 84 9c fd ff ff    	je     ec0c <tiov_handler+0x2ac>
    ee70:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ee73:	39 4d d4             	cmp    %ecx,0xffffffd4(%ebp)
    ee76:	7c a8                	jl     ee20 <tiov_handler+0x4c0>
    ee78:	e9 87 fd ff ff       	jmp    ec04 <tiov_handler+0x2a4>
    ee7d:	8d 76 00             	lea    0x0(%esi),%esi
    ee80:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
    ee87:	41                   	inc    %ecx
    ee88:	89 4d d4             	mov    %ecx,0xffffffd4(%ebp)
    ee8b:	eb db                	jmp    ee68 <tiov_handler+0x508>
    ee8d:	89 5c 24 08          	mov    %ebx,0x8(%esp,1)
    ee91:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
    ee94:	c7 04 24 a0 3c 00 00 	movl   $0x3ca0,(%esp,1)
    ee9b:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    ee9f:	e8 fc ff ff ff       	call   eea0 <tiov_handler+0x540>
 */
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
    eea4:	8b 87 84 00 00 00    	mov    0x84(%edi),%eax
    eeaa:	48                   	dec    %eax
    eeab:	74 11                	je     eebe <tiov_handler+0x55e>
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
	unsigned char c;

	__asm__ __volatile__(
    eead:	ff 8f 84 00 00 00    	decl   0x84(%edi)
    eeb3:	0f 94 c0             	sete   %al
    eeb6:	84 c0                	test   %al,%al
    eeb8:	0f 84 67 fe ff ff    	je     ed25 <tiov_handler+0x3c5>
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
		__kfree_skb(skb);
    eebe:	89 3c 24             	mov    %edi,(%esp,1)
    eec1:	e8 fc ff ff ff       	call   eec2 <tiov_handler+0x562>
    eec6:	e9 5a fe ff ff       	jmp    ed25 <tiov_handler+0x3c5>
    eecb:	c7 04 24 54 08 00 00 	movl   $0x854,(%esp,1)
    eed2:	e8 fc ff ff ff       	call   eed3 <tiov_handler+0x573>
    eed7:	e9 49 fe ff ff       	jmp    ed25 <tiov_handler+0x3c5>
    eedc:	c7 04 24 97 08 00 00 	movl   $0x897,(%esp,1)
    eee3:	a1 34 01 00 00       	mov    0x134,%eax
    eee8:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    eeec:	e8 fc ff ff ff       	call   eeed <tiov_handler+0x58d>
    eef1:	e9 41 fc ff ff       	jmp    eb37 <tiov_handler+0x1d7>
    eef6:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    eefa:	c7 44 24 08 b4 01 00 	movl   $0x1b4,0x8(%esp,1)
    ef01:	00 
    ef02:	c7 44 24 04 6c 08 00 	movl   $0x86c,0x4(%esp,1)
    ef09:	00 
    ef0a:	c7 04 24 00 3c 00 00 	movl   $0x3c00,(%esp,1)
    ef11:	e8 fc ff ff ff       	call   ef12 <tiov_handler+0x5b2>
    ef16:	e9 0f fc ff ff       	jmp    eb2a <tiov_handler+0x1ca>
    ef1b:	ff 05 04 97 13 00    	incl   0x139704
    ef21:	51                   	push   %ecx
    ef22:	9d                   	popf   
    ef23:	31 c0                	xor    %eax,%eax
    ef25:	e9 05 fc ff ff       	jmp    eb2f <tiov_handler+0x1cf>
    ef2a:	8b 45 08             	mov    0x8(%ebp),%eax
    ef2d:	8b 90 dc 00 00 00    	mov    0xdc(%eax),%edx
    ef33:	e9 08 fc ff ff       	jmp    eb40 <tiov_handler+0x1e0>
    ef38:	89 5c 24 08          	mov    %ebx,0x8(%esp,1)
    ef3c:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    ef3f:	c7 04 24 af 08 00 00 	movl   $0x8af,(%esp,1)
    ef46:	29 c3                	sub    %eax,%ebx
    ef48:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    ef4c:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
    ef50:	e8 fc ff ff ff       	call   ef51 <tiov_handler+0x5f1>
    ef55:	e9 54 fb ff ff       	jmp    eaae <tiov_handler+0x14e>
    ef5a:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    ef5e:	c7 44 24 08 ad 01 00 	movl   $0x1ad,0x8(%esp,1)
    ef65:	00 
    ef66:	c7 44 24 04 6c 08 00 	movl   $0x86c,0x4(%esp,1)
    ef6d:	00 
    ef6e:	c7 04 24 00 3c 00 00 	movl   $0x3c00,(%esp,1)
    ef75:	e8 fc ff ff ff       	call   ef76 <tiov_handler+0x616>
    ef7a:	e9 22 fb ff ff       	jmp    eaa1 <tiov_handler+0x141>
    ef7f:	ff 05 fc 96 13 00    	incl   0x1396fc
    ef85:	51                   	push   %ecx
    ef86:	9d                   	popf   
    ef87:	31 c0                	xor    %eax,%eax
    ef89:	e9 18 fb ff ff       	jmp    eaa6 <tiov_handler+0x146>
    ef8e:	c7 44 24 04 d0 01 00 	movl   $0x1d0,0x4(%esp,1)
    ef95:	00 
    ef96:	c1 e0 02             	shl    $0x2,%eax
    ef99:	89 04 24             	mov    %eax,(%esp,1)
    ef9c:	e8 fc ff ff ff       	call   ef9d <tiov_handler+0x63d>
    efa1:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
    efa4:	e9 fb f9 ff ff       	jmp    e9a4 <tiov_handler+0x44>
    efa9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi

0000efb0 <trickles_close>:

void trickles_close(struct sock *sk, long timeout) {
    efb0:	55                   	push   %ebp
    efb1:	89 e5                	mov    %esp,%ebp
    efb3:	57                   	push   %edi
    efb4:	56                   	push   %esi
    efb5:	53                   	push   %ebx
    efb6:	83 ec 04             	sub    $0x4,%esp
    efb9:	8b 7d 08             	mov    0x8(%ebp),%edi
	/* Based on TCP_CLOSE.
	   Zap connections as fast as possible 
	*/
	struct sk_buff *skb;
	int data_was_unread = 0;
#if 1 // 0502 - moving receive queue drain inside bh-safe portion
	// orig
	lock_sock(sk);
    efbc:	ff 05 08 00 00 00    	incl   0x8
    efc2:	8b 4f 2c             	mov    0x2c(%edi),%ecx
    efc5:	85 c9                	test   %ecx,%ecx
    efc7:	0f 85 cd 01 00 00    	jne    f19a <trickles_close+0x1ea>
    efcd:	c7 47 2c 01 00 00 00 	movl   $0x1,0x2c(%edi)
    efd4:	ba 08 00 00 00       	mov    $0x8,%edx
    efd9:	a1 08 00 00 00       	mov    0x8,%eax
    efde:	48                   	dec    %eax
    efdf:	85 c0                	test   %eax,%eax
    efe1:	a3 08 00 00 00       	mov    %eax,0x8
    efe6:	75 0a                	jne    eff2 <trickles_close+0x42>
    efe8:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
    efec:	0f 85 f0 3f 00 00    	jne    12fe2 <.text.lock.tmalloc+0x10>
	sk->shutdown = SHUTDOWN_MASK;
    eff2:	c6 47 27 03          	movb   $0x3,0x27(%edi)

	/* drain receive queue */
	while((skb=__skb_dequeue(&sk->receive_queue))!=NULL) {
    eff6:	8d 5f 48             	lea    0x48(%edi),%ebx
    eff9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
{
	struct sk_buff *next, *prev, *result;

	prev = (struct sk_buff *) list;
	next = prev->next;
    f000:	8b 47 48             	mov    0x48(%edi),%eax
	result = NULL;
    f003:	31 f6                	xor    %esi,%esi
	if (next != prev) {
    f005:	39 d8                	cmp    %ebx,%eax
    f007:	74 21                	je     f02a <trickles_close+0x7a>
		result = next;
    f009:	89 c6                	mov    %eax,%esi
		next = next->next;
    f00b:	8b 00                	mov    (%eax),%eax
		list->qlen--;
    f00d:	ff 4b 08             	decl   0x8(%ebx)
		next->prev = prev;
		prev->next = next;
		result->next = NULL;
		result->prev = NULL;
		result->list = NULL;
    f010:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    f017:	89 58 04             	mov    %ebx,0x4(%eax)
    f01a:	89 47 48             	mov    %eax,0x48(%edi)
    f01d:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
    f024:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    f02a:	85 f6                	test   %esi,%esi
    f02c:	74 0a                	je     f038 <trickles_close+0x88>
		u32 len = TCP_SKB_CB(skb)->end_seq - TCP_SKB_CB(skb)->seq - skb->h.th->fin;
		data_was_unread += len;
		__kfree_skb(skb);
    f02e:	89 34 24             	mov    %esi,(%esp,1)
    f031:	e8 fc ff ff ff       	call   f032 <trickles_close+0x82>
    f036:	eb c8                	jmp    f000 <trickles_close+0x50>
extern int tcp_mem_schedule(struct sock *sk, int size, int kind);

static inline void tcp_mem_reclaim(struct sock *sk)
{
	if (sk->forward_alloc >= TCP_MEM_QUANTUM)
    f038:	81 7f 6c ff 0f 00 00 	cmpl   $0xfff,0x6c(%edi)
    f03f:	0f 8f 48 01 00 00    	jg     f18d <trickles_close+0x1dd>
    f045:	0f b6 47 20          	movzbl 0x20(%edi),%eax
    f049:	0f b6 d8             	movzbl %al,%ebx
    f04c:	83 fb 08             	cmp    $0x8,%ebx
    f04f:	0f 84 1d 01 00 00    	je     f172 <trickles_close+0x1c2>
    f055:	83 fb 01             	cmp    $0x1,%ebx
    f058:	0f 84 14 01 00 00    	je     f172 <trickles_close+0x1c2>
    f05e:	8b 87 b8 00 00 00    	mov    0xb8(%edi),%eax
    f064:	89 3c 24             	mov    %edi,(%esp,1)
    f067:	ff 50 3c             	call   *0x3c(%eax)
    f06a:	8b 47 7c             	mov    0x7c(%edi),%eax
    f06d:	85 c0                	test   %eax,%eax
    f06f:	74 11                	je     f082 <trickles_close+0xd2>
    f071:	0f b6 87 8c 00 00 00 	movzbl 0x8c(%edi),%eax
    f078:	24 08                	and    $0x8,%al
    f07a:	84 c0                	test   %al,%al
    f07c:	0f 84 e3 00 00 00    	je     f165 <trickles_close+0x1b5>
    f082:	4b                   	dec    %ebx
    f083:	0f 84 bd 00 00 00    	je     f146 <trickles_close+0x196>
    f089:	c6 47 20 07          	movb   $0x7,0x20(%edi)
	}
	// printk("%u bytes unread\n", data_was_unread); // 0418

	tcp_mem_reclaim(sk);
	tcp_set_state(sk, TCP_CLOSE);

	release_sock(sk);
    f08d:	ff 05 08 00 00 00    	incl   0x8
    f093:	8b 87 a8 00 00 00    	mov    0xa8(%edi),%eax
    f099:	85 c0                	test   %eax,%eax
    f09b:	0f 85 98 00 00 00    	jne    f139 <trickles_close+0x189>
    f0a1:	c7 47 2c 00 00 00 00 	movl   $0x0,0x2c(%edi)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
    f0a8:	8d 47 30             	lea    0x30(%edi),%eax
    f0ab:	39 47 30             	cmp    %eax,0x30(%edi)
    f0ae:	75 75                	jne    f125 <trickles_close+0x175>
    f0b0:	b9 08 00 00 00       	mov    $0x8,%ecx
    f0b5:	8b 15 08 00 00 00    	mov    0x8,%edx
    f0bb:	8d 42 ff             	lea    0xffffffff(%edx),%eax
    f0be:	85 c0                	test   %eax,%eax
    f0c0:	a3 08 00 00 00       	mov    %eax,0x8
    f0c5:	75 0a                	jne    f0d1 <trickles_close+0x121>
    f0c7:	83 79 f8 00          	cmpl   $0x0,0xfffffff8(%ecx)
    f0cb:	0f 85 21 3f 00 00    	jne    12ff2 <.text.lock.tmalloc+0x20>

	local_bh_disable();
    f0d1:	89 15 08 00 00 00    	mov    %edx,0x8
 * useful range of an atomic_t is only 24 bits.
 */ 
static __inline__ void atomic_inc(atomic_t *v)
{
	__asm__ __volatile__(
    f0d7:	ff 47 28             	incl   0x28(%edi)
	bh_lock_sock(sk);

	sock_hold(sk);
	sock_orphan(sk);
    f0da:	89 3c 24             	mov    %edi,(%esp,1)
    f0dd:	e8 ae 3e 00 00       	call   12f90 <sock_orphan>
	tcp_destroy_sock(sk);
    f0e2:	89 3c 24             	mov    %edi,(%esp,1)
    f0e5:	e8 fc ff ff ff       	call   f0e6 <trickles_close+0x136>

	bh_unlock_sock(sk);
	local_bh_enable();
    f0ea:	ba 08 00 00 00       	mov    $0x8,%edx
    f0ef:	a1 08 00 00 00       	mov    0x8,%eax
    f0f4:	48                   	dec    %eax
    f0f5:	85 c0                	test   %eax,%eax
    f0f7:	a3 08 00 00 00       	mov    %eax,0x8
    f0fc:	75 0a                	jne    f108 <trickles_close+0x158>
    f0fe:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
    f102:	0f 85 fa 3e 00 00    	jne    13002 <.text.lock.tmalloc+0x30>
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
	unsigned char c;

	__asm__ __volatile__(
    f108:	ff 4f 28             	decl   0x28(%edi)
    f10b:	0f 94 c0             	sete   %al
    f10e:	84 c0                	test   %al,%al
    f110:	75 06                	jne    f118 <trickles_close+0x168>
	sock_put(sk);
#else
	local_bh_disable();
	bh_lock_sock(sk);

	sock_hold(sk);
	sock_orphan(sk);

	sk->shutdown = SHUTDOWN_MASK;

	/* drain receive queue */
	while((skb=__skb_dequeue(&sk->receive_queue))!=NULL) {
		u32 len = TCP_SKB_CB(skb)->end_seq - TCP_SKB_CB(skb)->seq - skb->h.th->fin;
		data_was_unread += len;
		__kfree_skb(skb);
	}
	// printk("%u bytes unread\n", data_was_unread); // 0418

	tcp_mem_reclaim(sk);
	tcp_set_state(sk, TCP_CLOSE);

	tcp_destroy_sock(sk);

	bh_unlock_sock(sk);
	local_bh_enable();
	sock_put(sk);
#endif
}
    f112:	5f                   	pop    %edi
    f113:	5b                   	pop    %ebx
    f114:	5e                   	pop    %esi
    f115:	5f                   	pop    %edi
    f116:	5d                   	pop    %ebp
    f117:	c3                   	ret    
/* Ungrab socket and destroy it, if it was the last reference. */
static inline void sock_put(struct sock *sk)
{
	if (atomic_dec_and_test(&sk->refcnt))
		sk_free(sk);
    f118:	89 7d 08             	mov    %edi,0x8(%ebp)
    f11b:	58                   	pop    %eax
    f11c:	5b                   	pop    %ebx
    f11d:	5e                   	pop    %esi
    f11e:	5f                   	pop    %edi
    f11f:	5d                   	pop    %ebp
    f120:	e9 fc ff ff ff       	jmp    f121 <trickles_close+0x171>
    f125:	b9 01 00 00 00       	mov    $0x1,%ecx
    f12a:	ba 03 00 00 00       	mov    $0x3,%edx
    f12f:	e8 fc ff ff ff       	call   f130 <trickles_close+0x180>
    f134:	e9 77 ff ff ff       	jmp    f0b0 <trickles_close+0x100>
    f139:	89 3c 24             	mov    %edi,(%esp,1)
    f13c:	e8 fc ff ff ff       	call   f13d <trickles_close+0x18d>
    f141:	e9 5b ff ff ff       	jmp    f0a1 <trickles_close+0xf1>
			tcp_put_port(sk);
		/* fall through */
	default:
		if (oldstate==TCP_ESTABLISHED)
			tcp_statistics[smp_processor_id()*2+!in_softirq()].TcpCurrEstab--;
    f146:	a1 08 00 00 00       	mov    0x8,%eax
    f14b:	ba 60 00 00 00       	mov    $0x60,%edx
    f150:	85 c0                	test   %eax,%eax
    f152:	b8 20 00 00 00       	mov    $0x20,%eax
    f157:	0f 45 d0             	cmovne %eax,%edx
    f15a:	ff 8a 00 00 00 00    	decl   0x0(%edx)
    f160:	e9 24 ff ff ff       	jmp    f089 <trickles_close+0xd9>
    f165:	89 3c 24             	mov    %edi,(%esp,1)
    f168:	e8 fc ff ff ff       	call   f169 <trickles_close+0x1b9>
    f16d:	e9 10 ff ff ff       	jmp    f082 <trickles_close+0xd2>
    f172:	8b 15 08 00 00 00    	mov    0x8,%edx
    f178:	b8 40 00 00 00       	mov    $0x40,%eax
    f17d:	85 d2                	test   %edx,%edx
    f17f:	0f 45 c6             	cmovne %esi,%eax
    f182:	ff 80 1c 00 00 00    	incl   0x1c(%eax)
    f188:	e9 d1 fe ff ff       	jmp    f05e <trickles_close+0xae>
	}

	/* Change state AFTER socket is unhashed to avoid closed
	 * socket sitting in hash tables.
	 */
	sk->state = state;

#ifdef STATE_TRACE
	SOCK_DEBUG(sk, "TCP sk=%p, State %s -> %s\n",sk, statename[oldstate],statename[state]);
#endif	
}

static __inline__ void tcp_done(struct sock *sk)
{
	tcp_set_state(sk, TCP_CLOSE);
	tcp_clear_xmit_timers(sk);

	sk->shutdown = SHUTDOWN_MASK;

	if (!sk->dead)
		sk->state_change(sk);
	else
		tcp_destroy_sock(sk);
}

static __inline__ void tcp_sack_reset(struct tcp_opt *tp)
{
	tp->dsack = 0;
	tp->eff_sacks = 0;
	tp->num_sacks = 0;
}

static __inline__ void tcp_build_and_update_options(__u32 *ptr, struct tcp_opt *tp, __u32 tstamp)
{
	if (tp->tstamp_ok) {
		*ptr++ = __constant_htonl((TCPOPT_NOP << 24) |
					  (TCPOPT_NOP << 16) |
					  (TCPOPT_TIMESTAMP << 8) |
					  TCPOLEN_TIMESTAMP);
		*ptr++ = htonl(tstamp);
		*ptr++ = htonl(tp->ts_recent);
	}
	if (tp->eff_sacks) {
		struct tcp_sack_block *sp = tp->dsack ? tp->duplicate_sack : tp->selective_acks;
		int this_sack;

		*ptr++ = __constant_htonl((TCPOPT_NOP << 24) |
					  (TCPOPT_NOP << 16) |
					  (TCPOPT_SACK << 8) |
					  (TCPOLEN_SACK_BASE +
					   (tp->eff_sacks * TCPOLEN_SACK_PERBLOCK)));
		for(this_sack = 0; this_sack < tp->eff_sacks; this_sack++) {
			*ptr++ = htonl(sp[this_sack].start_seq);
			*ptr++ = htonl(sp[this_sack].end_seq);
		}
		if (tp->dsack) {
			tp->dsack = 0;
			tp->eff_sacks--;
		}
	}
}

/* Construct a tcp options header for a SYN or SYN_ACK packet.
 * If this is every changed make sure to change the definition of
 * MAX_SYN_SIZE to match the new maximum number of options that you
 * can generate.
 */
static inline void tcp_syn_build_options(__u32 *ptr, int mss, int ts, int sack,
					     int offer_wscale, int wscale, __u32 tstamp, __u32 ts_recent)
{
	/* We always get an MSS option.
	 * The option bytes which will be seen in normal data
	 * packets should timestamps be used, must be in the MSS
	 * advertised.  But we subtract them from tp->mss_cache so
	 * that calculations in tcp_sendmsg are simpler etc.
	 * So account for this fact here if necessary.  If we
	 * don't do this correctly, as a receiver we won't
	 * recognize data packets as being full sized when we
	 * should, and thus we won't abide by the delayed ACK
	 * rules correctly.
	 * SACKs don't matter, we never delay an ACK when we
	 * have any of those going out.
	 */
	*ptr++ = htonl((TCPOPT_MSS << 24) | (TCPOLEN_MSS << 16) | mss);
	if (ts) {
		if(sack)
			*ptr++ = __constant_htonl((TCPOPT_SACK_PERM << 24) | (TCPOLEN_SACK_PERM << 16) |
						  (TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP);
		else
			*ptr++ = __constant_htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
						  (TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP);
		*ptr++ = htonl(tstamp);		/* TSVAL */
		*ptr++ = htonl(ts_recent);	/* TSECR */
	} else if(sack)
		*ptr++ = __constant_htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
					  (TCPOPT_SACK_PERM << 8) | TCPOLEN_SACK_PERM);
	if (offer_wscale)
		*ptr++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_WINDOW << 16) | (TCPOLEN_WINDOW << 8) | (wscale));
}

/* Determine a window scaling and initial window to offer.
 * Based on the assumption that the given amount of space
 * will be offered. Store the results in the tp structure.
 * NOTE: for smooth operation initial space offering should
 * be a multiple of mss if possible. We assume here that mss >= 1.
 * This MUST be enforced by all callers.
 */
static inline void tcp_select_initial_window(int __space, __u32 mss,
	__u32 *rcv_wnd,
	__u32 *window_clamp,
	int wscale_ok,
	__u8 *rcv_wscale)
{
	unsigned int space = (__space < 0 ? 0 : __space);

	/* If no clamp set the clamp to the max possible scaled window */
	if (*window_clamp == 0)
		(*window_clamp) = (65535 << 14);
	space = min(*window_clamp, space);

	/* Quantize space offering to a multiple of mss if possible. */
	if (space > mss)
		space = (space / mss) * mss;

	/* NOTE: offering an initial window larger than 32767
	 * will break some buggy TCP stacks. We try to be nice.
	 * If we are not window scaling, then this truncates
	 * our initial window offering to 32k. There should also
	 * be a sysctl option to stop being nice.
	 */
	(*rcv_wnd) = min(space, MAX_TCP_WINDOW);
	(*rcv_wscale) = 0;
	if (wscale_ok) {
		/* See RFC1323 for an explanation of the limit to 14 */
		while (space > 65535 && (*rcv_wscale) < 14) {
			space >>= 1;
			(*rcv_wscale)++;
		}
		if (*rcv_wscale && sysctl_tcp_app_win && space>=mss &&
		    space - max((space>>sysctl_tcp_app_win), mss>>*rcv_wscale) < 65536/2)
			(*rcv_wscale)--;
	}

	/* Set initial window to value enough for senders,
	 * following RFC1414. Senders, not following this RFC,
	 * will be satisfied with 2.
	 */
	if (mss > (1<<*rcv_wscale)) {
		int init_cwnd = 4;
		if (mss > 1460*3)
			init_cwnd = 2;
		else if (mss > 1460)
			init_cwnd = 3;
		if (*rcv_wnd > init_cwnd*mss)
			*rcv_wnd = init_cwnd*mss;
	}
	/* Set the clamp no higher than max representable value */
	(*window_clamp) = min(65535U << (*rcv_wscale), *window_clamp);
}

static inline int tcp_win_from_space(int space)
{
	return sysctl_tcp_adv_win_scale<=0 ?
		(space>>(-sysctl_tcp_adv_win_scale)) :
		space - (space>>sysctl_tcp_adv_win_scale);
}

/* Note: caller must be prepared to deal with negative returns */ 
static inline int tcp_space(struct sock *sk)
{
	return tcp_win_from_space(sk->rcvbuf - atomic_read(&sk->rmem_alloc));
} 

static inline int tcp_full_space( struct sock *sk)
{
	return tcp_win_from_space(sk->rcvbuf); 
}

static inline void tcp_acceptq_removed(struct sock *sk)
{
	sk->ack_backlog--;
}

static inline void tcp_acceptq_added(struct sock *sk)
{
	sk->ack_backlog++;
}

static inline int tcp_acceptq_is_full(struct sock *sk)
{
	return sk->ack_backlog > sk->max_ack_backlog;
}

static inline void tcp_acceptq_queue(struct sock *sk, struct open_request *req,
					 struct sock *child)
{
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;

	req->sk = child;
	tcp_acceptq_added(sk);

	if (!tp->accept_queue_tail) {
		tp->accept_queue = req;
	} else {
		tp->accept_queue_tail->dl_next = req;
	}
	tp->accept_queue_tail = req;
	req->dl_next = NULL;
}

struct tcp_listen_opt
{
	u8			max_qlen_log;	/* log_2 of maximal queued SYNs */
	int			qlen;
	int			qlen_young;
	int			clock_hand;
	u32			hash_rnd;
	struct open_request	*syn_table[TCP_SYNQ_HSIZE];
};

static inline void
tcp_synq_removed(struct sock *sk, struct open_request *req)
{
	struct tcp_listen_opt *lopt = sk->tp_pinfo.af_tcp.listen_opt;

	if (--lopt->qlen == 0)
		tcp_delete_keepalive_timer(sk);
	if (req->retrans == 0)
		lopt->qlen_young--;
}

static inline void tcp_synq_added(struct sock *sk)
{
	struct tcp_listen_opt *lopt = sk->tp_pinfo.af_tcp.listen_opt;

	if (lopt->qlen++ == 0)
		tcp_reset_keepalive_timer(sk, TCP_TIMEOUT_INIT);
	lopt->qlen_young++;
}

static inline int tcp_synq_len(struct sock *sk)
{
	return sk->tp_pinfo.af_tcp.listen_opt->qlen;
}

static inline int tcp_synq_young(struct sock *sk)
{
	return sk->tp_pinfo.af_tcp.listen_opt->qlen_young;
}

static inline int tcp_synq_is_full(struct sock *sk)
{
	return tcp_synq_len(sk)>>sk->tp_pinfo.af_tcp.listen_opt->max_qlen_log;
}

static inline void tcp_synq_unlink(struct tcp_opt *tp, struct open_request *req,
				       struct open_request **prev)
{
	write_lock(&tp->syn_wait_lock);
	*prev = req->dl_next;
	write_unlock(&tp->syn_wait_lock);
}

static inline void tcp_synq_drop(struct sock *sk, struct open_request *req,
				     struct open_request **prev)
{
	tcp_synq_unlink(&sk->tp_pinfo.af_tcp, req, prev);
	tcp_synq_removed(sk, req);
	tcp_openreq_free(req);
}

static __inline__ void tcp_openreq_init(struct open_request *req,
					struct tcp_opt *tp,
					struct sk_buff *skb)
{
	req->rcv_wnd = 0;		/* So that tcp_send_synack() knows! */
	req->rcv_isn = TCP_SKB_CB(skb)->seq;
	req->mss = tp->mss_clamp;
	req->ts_recent = tp->saw_tstamp ? tp->rcv_tsval : 0;
	req->tstamp_ok = tp->tstamp_ok;
	req->sack_ok = tp->sack_ok;
	req->snd_wscale = tp->snd_wscale;
	req->wscale_ok = tp->wscale_ok;
	req->acked = 0;
	req->ecn_ok = 0;
	req->rmt_port = skb->h.th->source;
}

#define TCP_MEM_QUANTUM	((int)PAGE_SIZE)

static inline void tcp_free_skb(struct sock *sk, struct sk_buff *skb)
{
	sk->tp_pinfo.af_tcp.queue_shrunk = 1;
	sk->wmem_queued -= skb->truesize;
	sk->forward_alloc += skb->truesize;
	__kfree_skb(skb);
}

static inline void tcp_charge_skb(struct sock *sk, struct sk_buff *skb)
{
	sk->wmem_queued += skb->truesize;
	sk->forward_alloc -= skb->truesize;
}

extern void __tcp_mem_reclaim(struct sock *sk);
extern int tcp_mem_schedule(struct sock *sk, int size, int kind);

static inline void tcp_mem_reclaim(struct sock *sk)
{
	if (sk->forward_alloc >= TCP_MEM_QUANTUM)
		__tcp_mem_reclaim(sk);
    f18d:	89 3c 24             	mov    %edi,(%esp,1)
    f190:	e8 fc ff ff ff       	call   f191 <trickles_close+0x1e1>
    f195:	e9 ab fe ff ff       	jmp    f045 <trickles_close+0x95>
    f19a:	89 3c 24             	mov    %edi,(%esp,1)
    f19d:	e8 fc ff ff ff       	call   f19e <trickles_close+0x1ee>
    f1a2:	e9 26 fe ff ff       	jmp    efcd <trickles_close+0x1d>
    f1a7:	89 f6                	mov    %esi,%esi
    f1a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

0000f1b0 <trickles_init_sock_impl>:

void trickles_init_sock_impl(struct sock *sk, int val) {
    f1b0:	55                   	push   %ebp
    f1b1:	89 e5                	mov    %esp,%ebp
    f1b3:	57                   	push   %edi
    f1b4:	56                   	push   %esi
    f1b5:	53                   	push   %ebx
    f1b6:	83 ec 04             	sub    $0x4,%esp
    f1b9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
	local_bh_disable();
    f1bc:	ff 05 08 00 00 00    	incl   0x8
    f1c2:	8b 7d 0c             	mov    0xc(%ebp),%edi
    f1c5:	8d b3 bc 00 00 00    	lea    0xbc(%ebx),%esi
	release_sock(sk);
    f1cb:	ff 05 08 00 00 00    	incl   0x8
    f1d1:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f1d7:	85 c0                	test   %eax,%eax
    f1d9:	0f 85 f5 00 00 00    	jne    f2d4 <trickles_init_sock_impl+0x124>
    f1df:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
    f1e6:	8d 43 30             	lea    0x30(%ebx),%eax
    f1e9:	39 43 30             	cmp    %eax,0x30(%ebx)
    f1ec:	0f 85 ce 00 00 00    	jne    f2c0 <trickles_init_sock_impl+0x110>
    f1f2:	ba 08 00 00 00       	mov    $0x8,%edx
    f1f7:	a1 08 00 00 00       	mov    0x8,%eax
    f1fc:	48                   	dec    %eax
    f1fd:	85 c0                	test   %eax,%eax
    f1ff:	a3 08 00 00 00       	mov    %eax,0x8
    f204:	75 0a                	jne    f210 <trickles_init_sock_impl+0x60>
    f206:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
    f20a:	0f 85 02 3e 00 00    	jne    13012 <.text.lock.tmalloc+0x40>
	bh_lock_sock(sk);
	if(!(tp->trickles_opt & TCP_TRICKLES_ENABLE) &&
    f210:	f6 86 ec 01 00 00 01 	testb  $0x1,0x1ec(%esi)
    f217:	75 2a                	jne    f243 <trickles_init_sock_impl+0x93>
    f219:	f7 c7 01 00 00 00    	test   $0x1,%edi
    f21f:	74 22                	je     f243 <trickles_init_sock_impl+0x93>
	   val & TCP_TRICKLES_ENABLE) {
		if(val & TCP_TRICKLES_RSERVER) {
    f221:	f7 c7 08 00 00 00    	test   $0x8,%edi
    f227:	0f 84 7d 00 00 00    	je     f2aa <trickles_init_sock_impl+0xfa>
			tp->t.testseq = 1;
    f22d:	b8 01 00 00 00       	mov    $0x1,%eax
    f232:	89 86 1c 0a 00 00    	mov    %eax,0xa1c(%esi)
			sk->prot = &trickles_prot;
    f238:	b8 00 00 00 00       	mov    $0x0,%eax
    f23d:	89 83 b8 00 00 00    	mov    %eax,0xb8(%ebx)
			
		} else {
			sk->prot = &trickles_client_prot;
#if 0
			if(val & TCP_TRICKLES_BUFFERDISCARD) {
				sk->rcvbuf = 100000000;
			}
#endif
			/* remember clients so that we can clear timers */
			trickles_add_clientsock(sk);

#ifdef RECORD_LOSS_EVENTS
#define EVENT_RECORD_LEN (8192)
			tp->t.events = kmalloc(EVENT_RECORD_LEN, GFP_ATOMIC);
			tp->t.eventsPos = 0;
			tp->t.eventsSize = EVENT_RECORD_LEN / 
				sizeof(struct TricklesLossEvent);
			int i;
			for(i=0; i < tp->t.eventsSize; i++) {
				tp->t.events[i].valid = 0;
			}
#undef EVENT_RECORD_LEN
#endif // RECORD_LOSS_EVENTS
		}
	}
	tp->trickles_opt = val;
    f243:	89 be ec 01 00 00    	mov    %edi,0x1ec(%esi)
	bh_unlock_sock(sk);
	lock_sock(sk);
    f249:	ff 05 08 00 00 00    	incl   0x8
    f24f:	8b 73 2c             	mov    0x2c(%ebx),%esi
    f252:	85 f6                	test   %esi,%esi
    f254:	75 4a                	jne    f2a0 <trickles_init_sock_impl+0xf0>
    f256:	c7 43 2c 01 00 00 00 	movl   $0x1,0x2c(%ebx)
    f25d:	ba 08 00 00 00       	mov    $0x8,%edx
    f262:	a1 08 00 00 00       	mov    0x8,%eax
    f267:	48                   	dec    %eax
    f268:	85 c0                	test   %eax,%eax
    f26a:	a3 08 00 00 00       	mov    %eax,0x8
    f26f:	75 0a                	jne    f27b <trickles_init_sock_impl+0xcb>
    f271:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
    f275:	0f 85 a7 3d 00 00    	jne    13022 <.text.lock.tmalloc+0x50>
	local_bh_enable();
    f27b:	ba 08 00 00 00       	mov    $0x8,%edx
    f280:	a1 08 00 00 00       	mov    0x8,%eax
    f285:	48                   	dec    %eax
    f286:	85 c0                	test   %eax,%eax
    f288:	a3 08 00 00 00       	mov    %eax,0x8
    f28d:	75 0a                	jne    f299 <trickles_init_sock_impl+0xe9>
    f28f:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
    f293:	0f 85 99 3d 00 00    	jne    13032 <.text.lock.tmalloc+0x60>
}
    f299:	5b                   	pop    %ebx
    f29a:	5b                   	pop    %ebx
    f29b:	5e                   	pop    %esi
    f29c:	5f                   	pop    %edi
    f29d:	5d                   	pop    %ebp
    f29e:	c3                   	ret    
    f29f:	90                   	nop    
    f2a0:	89 1c 24             	mov    %ebx,(%esp,1)
    f2a3:	e8 fc ff ff ff       	call   f2a4 <trickles_init_sock_impl+0xf4>
    f2a8:	eb ac                	jmp    f256 <trickles_init_sock_impl+0xa6>
    f2aa:	b8 00 00 00 00       	mov    $0x0,%eax
    f2af:	89 83 b8 00 00 00    	mov    %eax,0xb8(%ebx)
    f2b5:	89 1c 24             	mov    %ebx,(%esp,1)
    f2b8:	e8 fc ff ff ff       	call   f2b9 <trickles_init_sock_impl+0x109>
    f2bd:	eb 84                	jmp    f243 <trickles_init_sock_impl+0x93>
    f2bf:	90                   	nop    
    f2c0:	b9 01 00 00 00       	mov    $0x1,%ecx
    f2c5:	ba 03 00 00 00       	mov    $0x3,%edx
    f2ca:	e8 fc ff ff ff       	call   f2cb <trickles_init_sock_impl+0x11b>
    f2cf:	e9 1e ff ff ff       	jmp    f1f2 <trickles_init_sock_impl+0x42>
    f2d4:	89 1c 24             	mov    %ebx,(%esp,1)
    f2d7:	e8 fc ff ff ff       	call   f2d8 <trickles_init_sock_impl+0x128>
    f2dc:	e9 fe fe ff ff       	jmp    f1df <trickles_init_sock_impl+0x2f>
    f2e1:	eb 0d                	jmp    f2f0 <trickles_sendmsg>
    f2e3:	90                   	nop    
    f2e4:	90                   	nop    
    f2e5:	90                   	nop    
    f2e6:	90                   	nop    
    f2e7:	90                   	nop    
    f2e8:	90                   	nop    
    f2e9:	90                   	nop    
    f2ea:	90                   	nop    
    f2eb:	90                   	nop    
    f2ec:	90                   	nop    
    f2ed:	90                   	nop    
    f2ee:	90                   	nop    
    f2ef:	90                   	nop    

0000f2f0 <trickles_sendmsg>:

int trickles_sendmsg(struct sock *sk, struct msghdr *msg, int size) {
    f2f0:	55                   	push   %ebp
    f2f1:	89 e5                	mov    %esp,%ebp
    f2f3:	83 ec 34             	sub    $0x34,%esp
    f2f6:	89 5d f4             	mov    %ebx,0xfffffff4(%ebp)
    f2f9:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2fc:	89 7d fc             	mov    %edi,0xfffffffc(%ebp)
    f2ff:	8b 7d 08             	mov    0x8(%ebp),%edi
    f302:	89 75 f8             	mov    %esi,0xfffffff8(%ebp)
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
	struct cminisock *msk;
	int tiovlen = msg->msg_iovlen;
    f305:	8b 50 0c             	mov    0xc(%eax),%edx
	int rval = -EINVAL;
    f308:	c7 45 e8 ea ff ff ff 	movl   $0xffffffea,0xffffffe8(%ebp)
    f30f:	8d 9f bc 00 00 00    	lea    0xbc(%edi),%ebx
    f315:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
	
	struct tiovec *tiov = (struct tiovec *)msg->msg_iov;
    f318:	8b 50 08             	mov    0x8(%eax),%edx
    f31b:	89 55 e4             	mov    %edx,0xffffffe4(%ebp)
	struct cminisock_cmd *cmd = msg->msg_name;
    f31e:	8b 30                	mov    (%eax),%esi

	if(sizeof(*cmd) != msg->msg_namelen || (int)cmd->magic != TRICKLES_MAGIC) {
    f320:	83 78 04 0c          	cmpl   $0xc,0x4(%eax)
    f324:	74 12                	je     f338 <trickles_sendmsg+0x48>
		return -EINVAL;
	}

	if(cmd->cmd == STARTRCV) {
		printk(" StartRcv functionality deprecated\n");
		return -EINVAL;
	}
	if(!TRICKLES_USERAPI_CONFIGURED_TP(tp)) {
		return -EINVAL;
    f326:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	}
	if(cmd->cmd == POLL) {
		int res;
		lock_sock(sk);
		if (skb_queue_len(&tp->ucopy.prequeue)) {
			tcp_prequeue_process(sk);
		}
		res = trickles_poll(sk);
		release_sock(sk);
		return res;
	}

	/* XXX: perhaps allow multiple sockets to be passed down at a time */
	msk = cmd->socket;

	/* TODO: try to get rid of this silly lock ? */
	lock_sock(sk);
	if(!TRICKLES_USERAPI_CONFIGURED_TP(tp)) {
		printk("Socket not configured\n");
		rval = -EINVAL;
		release_sock(sk);
		goto out;
	}

	if(!IS_TRICKLES_SOCK_ADDR(tp,msk) || !(VALID_MSK_CTL(msk))) {
		printk("bad minisocket %d %d\n", !IS_TRICKLES_SOCK_ADDR(tp,msk), !(VALID_MSK_CTL(msk)));
		rval = -EINVAL;
		release_sock(sk);
		goto out;
	}
	free_trickles_msk(sk,msk);

	if(cmd->cmd == DROP) {
		rval = 0;
		free_trickles_msk_finish(sk,msk);
		goto out_put;
	}

	if(cmd->cmd != PROCESS) {
		free_trickles_msk_finish(sk,msk);
		goto out_put;
	}

	rval = trickles_do_sendmsg_tiov(sk,msk,tiov,tiovlen);

 out_put:
	release_sock(sk);
 out:
	return rval;
}
    f32b:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
    f32e:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
    f331:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
    f334:	89 ec                	mov    %ebp,%esp
    f336:	5d                   	pop    %ebp
    f337:	c3                   	ret    
    f338:	81 3e 3d d3 ad ba    	cmpl   $0xbaadd33d,(%esi)
    f33e:	75 e6                	jne    f326 <trickles_sendmsg+0x36>
    f340:	8b 46 08             	mov    0x8(%esi),%eax
    f343:	83 f8 03             	cmp    $0x3,%eax
    f346:	0f 84 ad 03 00 00    	je     f6f9 <trickles_sendmsg+0x409>
    f34c:	8b 93 d0 01 00 00    	mov    0x1d0(%ebx),%edx
    f352:	85 d2                	test   %edx,%edx
    f354:	74 d0                	je     f326 <trickles_sendmsg+0x36>
    f356:	85 c0                	test   %eax,%eax
    f358:	0f 85 c0 00 00 00    	jne    f41e <trickles_sendmsg+0x12e>
    f35e:	ff 05 08 00 00 00    	incl   0x8
    f364:	8b 47 2c             	mov    0x2c(%edi),%eax
    f367:	85 c0                	test   %eax,%eax
    f369:	0f 85 a2 00 00 00    	jne    f411 <trickles_sendmsg+0x121>
    f36f:	c7 47 2c 01 00 00 00 	movl   $0x1,0x2c(%edi)
    f376:	ba 08 00 00 00       	mov    $0x8,%edx
    f37b:	a1 08 00 00 00       	mov    0x8,%eax
    f380:	48                   	dec    %eax
    f381:	85 c0                	test   %eax,%eax
    f383:	a3 08 00 00 00       	mov    %eax,0x8
    f388:	75 0a                	jne    f394 <trickles_sendmsg+0xa4>
    f38a:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
    f38e:	0f 85 ae 3c 00 00    	jne    13042 <.text.lock.tmalloc+0x70>
 *	Return the length of an &sk_buff queue. 
 */
 
static inline __u32 skb_queue_len(struct sk_buff_head *list_)
{
    f394:	8b 87 f8 00 00 00    	mov    0xf8(%edi),%eax
    f39a:	85 c0                	test   %eax,%eax
    f39c:	75 69                	jne    f407 <trickles_sendmsg+0x117>
    f39e:	89 3c 24             	mov    %edi,(%esp,1)
    f3a1:	e8 6a 03 00 00       	call   f710 <trickles_poll>
    f3a6:	ff 05 08 00 00 00    	incl   0x8
    f3ac:	89 c3                	mov    %eax,%ebx
    f3ae:	8b 87 a8 00 00 00    	mov    0xa8(%edi),%eax
    f3b4:	85 c0                	test   %eax,%eax
    f3b6:	75 45                	jne    f3fd <trickles_sendmsg+0x10d>
    f3b8:	c7 47 2c 00 00 00 00 	movl   $0x0,0x2c(%edi)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
    f3bf:	8d 47 30             	lea    0x30(%edi),%eax
    f3c2:	39 47 30             	cmp    %eax,0x30(%edi)
    f3c5:	75 25                	jne    f3ec <trickles_sendmsg+0xfc>
    f3c7:	ba 08 00 00 00       	mov    $0x8,%edx
    f3cc:	a1 08 00 00 00       	mov    0x8,%eax
    f3d1:	48                   	dec    %eax
    f3d2:	85 c0                	test   %eax,%eax
    f3d4:	a3 08 00 00 00       	mov    %eax,0x8
    f3d9:	75 0a                	jne    f3e5 <trickles_sendmsg+0xf5>
    f3db:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
    f3df:	0f 85 6d 3c 00 00    	jne    13052 <.text.lock.tmalloc+0x80>
    f3e5:	89 d8                	mov    %ebx,%eax
    f3e7:	e9 3f ff ff ff       	jmp    f32b <trickles_sendmsg+0x3b>
    f3ec:	b9 01 00 00 00       	mov    $0x1,%ecx
    f3f1:	ba 03 00 00 00       	mov    $0x3,%edx
    f3f6:	e8 fc ff ff ff       	call   f3f7 <trickles_sendmsg+0x107>
    f3fb:	eb ca                	jmp    f3c7 <trickles_sendmsg+0xd7>
    f3fd:	89 3c 24             	mov    %edi,(%esp,1)
    f400:	e8 fc ff ff ff       	call   f401 <trickles_sendmsg+0x111>
    f405:	eb b1                	jmp    f3b8 <trickles_sendmsg+0xc8>
    f407:	89 3c 24             	mov    %edi,(%esp,1)
    f40a:	e8 01 f0 ff ff       	call   e410 <tcp_prequeue_process>
    f40f:	eb 8d                	jmp    f39e <trickles_sendmsg+0xae>
    f411:	89 3c 24             	mov    %edi,(%esp,1)
    f414:	e8 fc ff ff ff       	call   f415 <trickles_sendmsg+0x125>
    f419:	e9 51 ff ff ff       	jmp    f36f <trickles_sendmsg+0x7f>
    f41e:	8b 46 04             	mov    0x4(%esi),%eax
    f421:	ff 05 08 00 00 00    	incl   0x8
    f427:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    f42a:	8b 47 2c             	mov    0x2c(%edi),%eax
    f42d:	85 c0                	test   %eax,%eax
    f42f:	0f 85 b7 02 00 00    	jne    f6ec <trickles_sendmsg+0x3fc>
    f435:	c7 47 2c 01 00 00 00 	movl   $0x1,0x2c(%edi)
    f43c:	ba 08 00 00 00       	mov    $0x8,%edx
    f441:	a1 08 00 00 00       	mov    0x8,%eax
    f446:	48                   	dec    %eax
    f447:	85 c0                	test   %eax,%eax
    f449:	a3 08 00 00 00       	mov    %eax,0x8
    f44e:	75 0a                	jne    f45a <trickles_sendmsg+0x16a>
    f450:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
    f454:	0f 85 08 3c 00 00    	jne    13062 <.text.lock.tmalloc+0x90>
    f45a:	8b 83 d0 01 00 00    	mov    0x1d0(%ebx),%eax
    f460:	85 c0                	test   %eax,%eax
    f462:	0f 84 17 02 00 00    	je     f67f <trickles_sendmsg+0x38f>
    f468:	8b 9b cc 01 00 00    	mov    0x1cc(%ebx),%ebx
    f46e:	b9 3f 82 fb 08       	mov    $0x8fb823f,%ecx
    f473:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    f476:	89 5d e0             	mov    %ebx,0xffffffe0(%ebp)
    f479:	8b 5b 0c             	mov    0xc(%ebx),%ebx
    f47c:	29 d8                	sub    %ebx,%eax
    f47e:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    f481:	89 c2                	mov    %eax,%edx
    f483:	c1 ea 02             	shr    $0x2,%edx
    f486:	89 d0                	mov    %edx,%eax
    f488:	f7 e1                	mul    %ecx
    f48a:	d1 ea                	shr    %edx
    f48c:	69 d2 e4 00 00 00    	imul   $0xe4,%edx,%edx
    f492:	39 55 dc             	cmp    %edx,0xffffffdc(%ebp)
    f495:	0f 85 d9 01 00 00    	jne    f674 <trickles_sendmsg+0x384>
    f49b:	39 5d f0             	cmp    %ebx,0xfffffff0(%ebp)
    f49e:	0f 82 d0 01 00 00    	jb     f674 <trickles_sendmsg+0x384>
    f4a4:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    f4a7:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    f4aa:	8b 4a 14             	mov    0x14(%edx),%ecx
    f4ad:	29 c8                	sub    %ecx,%eax
    f4af:	05 e4 00 00 00       	add    $0xe4,%eax
    f4b4:	3b 42 20             	cmp    0x20(%edx),%eax
    f4b7:	0f 87 b7 01 00 00    	ja     f674 <trickles_sendmsg+0x384>
    f4bd:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    f4c0:	8b 42 0c             	mov    0xc(%edx),%eax
    f4c3:	83 f8 01             	cmp    $0x1,%eax
    f4c6:	0f 84 e2 00 00 00    	je     f5ae <trickles_sendmsg+0x2be>
    f4cc:	83 f8 04             	cmp    $0x4,%eax
    f4cf:	0f 84 d9 00 00 00    	je     f5ae <trickles_sendmsg+0x2be>
    f4d5:	31 d2                	xor    %edx,%edx
    f4d7:	83 f8 01             	cmp    $0x1,%eax
    f4da:	74 0b                	je     f4e7 <trickles_sendmsg+0x1f7>
    f4dc:	83 f8 04             	cmp    $0x4,%eax
    f4df:	b8 01 00 00 00       	mov    $0x1,%eax
    f4e4:	0f 45 d0             	cmovne %eax,%edx
    f4e7:	89 54 24 08          	mov    %edx,0x8(%esp,1)
    f4eb:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    f4ee:	b9 3f 82 fb 08       	mov    $0x8fb823f,%ecx
    f4f3:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    f4f6:	31 f6                	xor    %esi,%esi
    f4f8:	8b 58 0c             	mov    0xc(%eax),%ebx
    f4fb:	29 da                	sub    %ebx,%edx
    f4fd:	89 55 dc             	mov    %edx,0xffffffdc(%ebp)
    f500:	c1 ea 02             	shr    $0x2,%edx
    f503:	89 d0                	mov    %edx,%eax
    f505:	f7 e1                	mul    %ecx
    f507:	d1 ea                	shr    %edx
    f509:	69 d2 e4 00 00 00    	imul   $0xe4,%edx,%edx
    f50f:	39 55 dc             	cmp    %edx,0xffffffdc(%ebp)
    f512:	75 1e                	jne    f532 <trickles_sendmsg+0x242>
    f514:	39 5d f0             	cmp    %ebx,0xfffffff0(%ebp)
    f517:	72 19                	jb     f532 <trickles_sendmsg+0x242>
    f519:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    f51c:	8b 52 14             	mov    0x14(%edx),%edx
    f51f:	29 55 f0             	sub    %edx,0xfffffff0(%ebp)
    f522:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    f525:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    f528:	05 e4 00 00 00       	add    $0xe4,%eax
    f52d:	3b 42 20             	cmp    0x20(%edx),%eax
    f530:	76 05                	jbe    f537 <trickles_sendmsg+0x247>
    f532:	be 01 00 00 00       	mov    $0x1,%esi
    f537:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    f53b:	c7 04 24 c6 08 00 00 	movl   $0x8c6,(%esp,1)
    f542:	e8 fc ff ff ff       	call   f543 <trickles_sendmsg+0x253>
    f547:	c7 45 e8 ea ff ff ff 	movl   $0xffffffea,0xffffffe8(%ebp)
    f54e:	ff 05 08 00 00 00    	incl   0x8
    f554:	8b 87 a8 00 00 00    	mov    0xa8(%edi),%eax
    f55a:	85 c0                	test   %eax,%eax
    f55c:	75 46                	jne    f5a4 <trickles_sendmsg+0x2b4>
    f55e:	c7 47 2c 00 00 00 00 	movl   $0x0,0x2c(%edi)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
    f565:	8d 47 30             	lea    0x30(%edi),%eax
    f568:	39 47 30             	cmp    %eax,0x30(%edi)
    f56b:	75 26                	jne    f593 <trickles_sendmsg+0x2a3>
    f56d:	ba 08 00 00 00       	mov    $0x8,%edx
    f572:	a1 08 00 00 00       	mov    0x8,%eax
    f577:	48                   	dec    %eax
    f578:	85 c0                	test   %eax,%eax
    f57a:	a3 08 00 00 00       	mov    %eax,0x8
    f57f:	75 0a                	jne    f58b <trickles_sendmsg+0x29b>
    f581:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
    f585:	0f 85 e7 3a 00 00    	jne    13072 <.text.lock.tmalloc+0xa0>
    f58b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    f58e:	e9 98 fd ff ff       	jmp    f32b <trickles_sendmsg+0x3b>
    f593:	b9 01 00 00 00       	mov    $0x1,%ecx
    f598:	ba 03 00 00 00       	mov    $0x3,%edx
    f59d:	e8 fc ff ff ff       	call   f59e <trickles_sendmsg+0x2ae>
    f5a2:	eb c9                	jmp    f56d <trickles_sendmsg+0x27d>
    f5a4:	89 3c 24             	mov    %edi,(%esp,1)
    f5a7:	e8 fc ff ff ff       	call   f5a8 <trickles_sendmsg+0x2b8>
    f5ac:	eb b0                	jmp    f55e <trickles_sendmsg+0x26e>
    f5ae:	89 3c 24             	mov    %edi,(%esp,1)
    f5b1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    f5b4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f5b8:	e8 43 e4 ff ff       	call   da00 <free_trickles_msk>
    f5bd:	8b 46 08             	mov    0x8(%esi),%eax
    f5c0:	83 f8 02             	cmp    $0x2,%eax
    f5c3:	0f 84 98 00 00 00    	je     f661 <trickles_sendmsg+0x371>
    f5c9:	48                   	dec    %eax
    f5ca:	74 70                	je     f63c <trickles_sendmsg+0x34c>
    f5cc:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    f5cf:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f5d3:	89 3c 24             	mov    %edi,(%esp,1)
    f5d6:	e8 c5 e4 ff ff       	call   daa0 <free_trickles_msk_finish>
    f5db:	ff 05 08 00 00 00    	incl   0x8
    f5e1:	8b 87 a8 00 00 00    	mov    0xa8(%edi),%eax
    f5e7:	85 c0                	test   %eax,%eax
    f5e9:	75 47                	jne    f632 <trickles_sendmsg+0x342>
    f5eb:	c7 47 2c 00 00 00 00 	movl   $0x0,0x2c(%edi)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
    f5f2:	8d 47 30             	lea    0x30(%edi),%eax
    f5f5:	39 47 30             	cmp    %eax,0x30(%edi)
    f5f8:	75 27                	jne    f621 <trickles_sendmsg+0x331>
    f5fa:	ba 08 00 00 00       	mov    $0x8,%edx
    f5ff:	a1 08 00 00 00       	mov    0x8,%eax
    f604:	48                   	dec    %eax
    f605:	85 c0                	test   %eax,%eax
    f607:	a3 08 00 00 00       	mov    %eax,0x8
    f60c:	0f 85 79 ff ff ff    	jne    f58b <trickles_sendmsg+0x29b>
    f612:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
    f616:	0f 85 66 3a 00 00    	jne    13082 <.text.lock.tmalloc+0xb0>
    f61c:	e9 6a ff ff ff       	jmp    f58b <trickles_sendmsg+0x29b>
    f621:	b9 01 00 00 00       	mov    $0x1,%ecx
    f626:	ba 03 00 00 00       	mov    $0x3,%edx
    f62b:	e8 fc ff ff ff       	call   f62c <trickles_sendmsg+0x33c>
    f630:	eb c8                	jmp    f5fa <trickles_sendmsg+0x30a>
    f632:	89 3c 24             	mov    %edi,(%esp,1)
    f635:	e8 fc ff ff ff       	call   f636 <trickles_sendmsg+0x346>
    f63a:	eb af                	jmp    f5eb <trickles_sendmsg+0x2fb>
    f63c:	89 3c 24             	mov    %edi,(%esp,1)
    f63f:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    f642:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    f645:	89 54 24 0c          	mov    %edx,0xc(%esp,1)
    f649:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    f64c:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    f650:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    f654:	e8 57 ee ff ff       	call   e4b0 <trickles_do_sendmsg_tiov>
    f659:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    f65c:	e9 7a ff ff ff       	jmp    f5db <trickles_sendmsg+0x2eb>
    f661:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
    f668:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    f66b:	89 54 24 04          	mov    %edx,0x4(%esp,1)
    f66f:	e9 5f ff ff ff       	jmp    f5d3 <trickles_sendmsg+0x2e3>
    f674:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    f677:	8b 42 0c             	mov    0xc(%edx),%eax
    f67a:	e9 56 fe ff ff       	jmp    f4d5 <trickles_sendmsg+0x1e5>
    f67f:	c7 04 24 dc 08 00 00 	movl   $0x8dc,(%esp,1)
    f686:	e8 fc ff ff ff       	call   f687 <trickles_sendmsg+0x397>
    f68b:	ff 05 08 00 00 00    	incl   0x8
    f691:	8b 9f a8 00 00 00    	mov    0xa8(%edi),%ebx
    f697:	85 db                	test   %ebx,%ebx
    f699:	75 47                	jne    f6e2 <trickles_sendmsg+0x3f2>
    f69b:	c7 47 2c 00 00 00 00 	movl   $0x0,0x2c(%edi)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
    f6a2:	8d 47 30             	lea    0x30(%edi),%eax
    f6a5:	39 47 30             	cmp    %eax,0x30(%edi)
    f6a8:	75 27                	jne    f6d1 <trickles_sendmsg+0x3e1>
    f6aa:	ba 08 00 00 00       	mov    $0x8,%edx
    f6af:	a1 08 00 00 00       	mov    0x8,%eax
    f6b4:	48                   	dec    %eax
    f6b5:	85 c0                	test   %eax,%eax
    f6b7:	a3 08 00 00 00       	mov    %eax,0x8
    f6bc:	0f 85 c9 fe ff ff    	jne    f58b <trickles_sendmsg+0x29b>
    f6c2:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
    f6c6:	0f 85 c6 39 00 00    	jne    13092 <.text.lock.tmalloc+0xc0>
    f6cc:	e9 ba fe ff ff       	jmp    f58b <trickles_sendmsg+0x29b>
    f6d1:	b9 01 00 00 00       	mov    $0x1,%ecx
    f6d6:	ba 03 00 00 00       	mov    $0x3,%edx
    f6db:	e8 fc ff ff ff       	call   f6dc <trickles_sendmsg+0x3ec>
    f6e0:	eb c8                	jmp    f6aa <trickles_sendmsg+0x3ba>
    f6e2:	89 3c 24             	mov    %edi,(%esp,1)
    f6e5:	e8 fc ff ff ff       	call   f6e6 <trickles_sendmsg+0x3f6>
    f6ea:	eb af                	jmp    f69b <trickles_sendmsg+0x3ab>
    f6ec:	89 3c 24             	mov    %edi,(%esp,1)
    f6ef:	e8 fc ff ff ff       	call   f6f0 <trickles_sendmsg+0x400>
    f6f4:	e9 3c fd ff ff       	jmp    f435 <trickles_sendmsg+0x145>
    f6f9:	c7 04 24 e0 3c 00 00 	movl   $0x3ce0,(%esp,1)
    f700:	e8 fc ff ff ff       	call   f701 <trickles_sendmsg+0x411>
    f705:	e9 1c fc ff ff       	jmp    f326 <trickles_sendmsg+0x36>
    f70a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000f710 <trickles_poll>:

static int trickles_poll(struct sock *sk) {
    f710:	55                   	push   %ebp
    f711:	89 e5                	mov    %esp,%ebp
    f713:	57                   	push   %edi
	int err = 0;
    f714:	31 ff                	xor    %edi,%edi
    f716:	56                   	push   %esi
	/* Algorithm: perform sleep, then return when done */
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);

	/* don't cache a pointer, since the configuration could change
	   under us */

#define NO_EVENT()  (trickles_sock_poll_impl(NULL, &sock, NULL) == 0)

	struct socket sock;
	sock.sk = sk;
	if(NO_EVENT()) {
    f717:	8d 75 c4             	lea    0xffffffc4(%ebp),%esi
    f71a:	53                   	push   %ebx
    f71b:	83 ec 40             	sub    $0x40,%esp
    f71e:	8b 5d 08             	mov    0x8(%ebp),%ebx
    f721:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    f728:	00 
    f729:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    f72d:	89 5d dc             	mov    %ebx,0xffffffdc(%ebp)
    f730:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    f737:	e8 fc ff ff ff       	call   f738 <trickles_poll+0x28>
    f73c:	85 c0                	test   %eax,%eax
    f73e:	0f 85 b6 00 00 00    	jne    f7fa <trickles_poll+0xea>
#define MAX_TIMEOUT (100*HZ)
		int timeout = MAX_TIMEOUT;
		int in_time = jiffies;
		release_sock(sk);
    f744:	ff 05 08 00 00 00    	incl   0x8
    f74a:	a1 00 00 00 00       	mov    0x0,%eax
    f74f:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
    f752:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f758:	85 c0                	test   %eax,%eax
    f75a:	0f 85 04 01 00 00    	jne    f864 <trickles_poll+0x154>
    f760:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
    f767:	8d 43 30             	lea    0x30(%ebx),%eax
    f76a:	39 43 30             	cmp    %eax,0x30(%ebx)
    f76d:	0f 85 dd 00 00 00    	jne    f850 <trickles_poll+0x140>
    f773:	ba 08 00 00 00       	mov    $0x8,%edx
    f778:	a1 08 00 00 00       	mov    0x8,%eax
    f77d:	48                   	dec    %eax
    f77e:	85 c0                	test   %eax,%eax
    f780:	a3 08 00 00 00       	mov    %eax,0x8
    f785:	75 0a                	jne    f791 <trickles_poll+0x81>
    f787:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
    f78b:	0f 85 11 39 00 00    	jne    130a2 <.text.lock.tmalloc+0xd0>
		interruptible_sleep_on_timeout(sk->sleep, timeout);
    f791:	8b 43 3c             	mov    0x3c(%ebx),%eax
    f794:	ba 10 27 00 00       	mov    $0x2710,%edx
    f799:	e8 fc ff ff ff       	call   f79a <trickles_poll+0x8a>
		lock_sock(sk);
    f79e:	ff 05 08 00 00 00    	incl   0x8
    f7a4:	8b 43 2c             	mov    0x2c(%ebx),%eax
    f7a7:	85 c0                	test   %eax,%eax
    f7a9:	0f 85 92 00 00 00    	jne    f841 <trickles_poll+0x131>
    f7af:	c7 43 2c 01 00 00 00 	movl   $0x1,0x2c(%ebx)
    f7b6:	ba 08 00 00 00       	mov    $0x8,%edx
    f7bb:	a1 08 00 00 00       	mov    0x8,%eax
    f7c0:	48                   	dec    %eax
    f7c1:	85 c0                	test   %eax,%eax
    f7c3:	a3 08 00 00 00       	mov    %eax,0x8
    f7c8:	75 0a                	jne    f7d4 <trickles_poll+0xc4>
    f7ca:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
    f7ce:	0f 85 de 38 00 00    	jne    130b2 <.text.lock.tmalloc+0xe0>
		if(!NO_EVENT()) {
    f7d4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    f7db:	00 
    f7dc:	89 74 24 04          	mov    %esi,0x4(%esp,1)
    f7e0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    f7e7:	e8 fc ff ff ff       	call   f7e8 <trickles_poll+0xd8>
    f7ec:	85 c0                	test   %eax,%eax
    f7ee:	74 30                	je     f820 <trickles_poll+0x110>
			if(userapi_time_spew)
    f7f0:	8b 1d 00 00 00 00    	mov    0x0,%ebx
    f7f6:	85 db                	test   %ebx,%ebx
    f7f8:	75 0a                	jne    f804 <trickles_poll+0xf4>
				printk("wakeup time (user): %lu\n", jiffies);
		} else {
			printk("timeout expired %d\n", jiffies - in_time);
			err = -EAGAIN;
		}
	}
	
 out:
	return err;
#undef NO_EVENT
}
    f7fa:	83 c4 40             	add    $0x40,%esp
    f7fd:	89 f8                	mov    %edi,%eax
    f7ff:	5b                   	pop    %ebx
    f800:	5e                   	pop    %esi
    f801:	5f                   	pop    %edi
    f802:	5d                   	pop    %ebp
    f803:	c3                   	ret    
    f804:	c7 04 24 f3 08 00 00 	movl   $0x8f3,(%esp,1)
    f80b:	a1 00 00 00 00       	mov    0x0,%eax
    f810:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f814:	e8 fc ff ff ff       	call   f815 <trickles_poll+0x105>
    f819:	eb df                	jmp    f7fa <trickles_poll+0xea>
    f81b:	90                   	nop    
    f81c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    f820:	c7 04 24 0c 09 00 00 	movl   $0x90c,(%esp,1)
    f827:	a1 00 00 00 00       	mov    0x0,%eax
    f82c:	bf f5 ff ff ff       	mov    $0xfffffff5,%edi
    f831:	8b 4d c0             	mov    0xffffffc0(%ebp),%ecx
    f834:	29 c8                	sub    %ecx,%eax
    f836:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f83a:	e8 fc ff ff ff       	call   f83b <trickles_poll+0x12b>
    f83f:	eb b9                	jmp    f7fa <trickles_poll+0xea>
    f841:	89 1c 24             	mov    %ebx,(%esp,1)
    f844:	e8 fc ff ff ff       	call   f845 <trickles_poll+0x135>
    f849:	e9 61 ff ff ff       	jmp    f7af <trickles_poll+0x9f>
    f84e:	89 f6                	mov    %esi,%esi
    f850:	b9 01 00 00 00       	mov    $0x1,%ecx
    f855:	ba 03 00 00 00       	mov    $0x3,%edx
    f85a:	e8 fc ff ff ff       	call   f85b <trickles_poll+0x14b>
    f85f:	e9 0f ff ff ff       	jmp    f773 <trickles_poll+0x63>
    f864:	89 1c 24             	mov    %ebx,(%esp,1)
    f867:	e8 fc ff ff ff       	call   f868 <trickles_poll+0x158>
    f86c:	e9 ef fe ff ff       	jmp    f760 <trickles_poll+0x50>
    f871:	eb 0d                	jmp    f880 <trickles_sock_poll_impl>
    f873:	90                   	nop    
    f874:	90                   	nop    
    f875:	90                   	nop    
    f876:	90                   	nop    
    f877:	90                   	nop    
    f878:	90                   	nop    
    f879:	90                   	nop    
    f87a:	90                   	nop    
    f87b:	90                   	nop    
    f87c:	90                   	nop    
    f87d:	90                   	nop    
    f87e:	90                   	nop    
    f87f:	90                   	nop    

0000f880 <trickles_sock_poll_impl>:

int trickles_sock_poll_impl(struct file * file, struct socket *sock, poll_table *wait) {
    f880:	55                   	push   %ebp
    f881:	89 e5                	mov    %esp,%ebp
    f883:	53                   	push   %ebx
    struct sock *sk = sock->sk;
    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
    f884:	8b 45 0c             	mov    0xc(%ebp),%eax
    extern int gUpdateSincePollTotal;
    extern int gUpdateSincePollCount;
    int mask = 0;
    f887:	31 db                	xor    %ebx,%ebx
    f889:	8b 50 18             	mov    0x18(%eax),%edx
    f88c:	81 c2 bc 00 00 00    	add    $0xbc,%edx
    if(TRICKLES_USERAPI_CONFIGURED_TP(tp)) {
    f892:	8b 82 d0 01 00 00    	mov    0x1d0(%edx),%eax
    f898:	85 c0                	test   %eax,%eax
    f89a:	74 38                	je     f8d4 <trickles_sock_poll_impl+0x54>
	if((!(tp->trickles_opt & TCP_TRICKLES_EDGE)  && !empty(&tp->cminisock_api_config.cfg.ctl->msk_eventlist)) ||
    f89c:	80 ba ec 01 00 00 00 	cmpb   $0x0,0x1ec(%edx)
    f8a3:	78 3b                	js     f8e0 <trickles_sock_poll_impl+0x60>
#ifdef __KERNEL__
#define VALID_MSK_CTL(X) ((X)->ctl == ALLOC_READY || \
                          (X)->ctl == ALLOC_HALFFREE)

static inline int empty(struct alloc_head_list *head) {
    f8a5:	8b 8a cc 01 00 00    	mov    0x1cc(%edx),%ecx
    f8ab:	8d 41 24             	lea    0x24(%ecx),%eax
    f8ae:	39 40 04             	cmp    %eax,0x4(%eax)
    f8b1:	74 21                	je     f8d4 <trickles_sock_poll_impl+0x54>
	   ((tp->trickles_opt & TCP_TRICKLES_EDGE) && 
	    tp->cminisock_api_config.cfg.ctl->update_since_poll > 0 && 
	    !empty(&tp->cminisock_api_config.cfg.ctl->msk_eventlist))) {
		mask = POLLIN;
		gUpdateSincePollTotal +=
    f8b3:	8b 41 38             	mov    0x38(%ecx),%eax
    f8b6:	bb 01 00 00 00       	mov    $0x1,%ebx
    f8bb:	01 05 00 00 00 00    	add    %eax,0x0
			tp->cminisock_api_config.cfg.ctl->update_since_poll;
		gUpdateSincePollCount++;
    f8c1:	ff 05 00 00 00 00    	incl   0x0
		tp->cminisock_api_config.cfg.ctl->update_since_poll = 0;
    f8c7:	8b 82 cc 01 00 00    	mov    0x1cc(%edx),%eax
    f8cd:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
	}
    }
    return mask;
}
    f8d4:	89 d8                	mov    %ebx,%eax
    f8d6:	5b                   	pop    %ebx
    f8d7:	5d                   	pop    %ebp
    f8d8:	c3                   	ret    
    f8d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
    f8e0:	8b 8a cc 01 00 00    	mov    0x1cc(%edx),%ecx
    f8e6:	8b 41 38             	mov    0x38(%ecx),%eax
    f8e9:	85 c0                	test   %eax,%eax
    f8eb:	7f be                	jg     f8ab <trickles_sock_poll_impl+0x2b>
    f8ed:	eb e5                	jmp    f8d4 <trickles_sock_poll_impl+0x54>
    f8ef:	90                   	nop    

0000f8f0 <vfree_helper>:

/*
 *
 * MMAP support
 *
 */

void vfree_helper(void *ptr) {
    f8f0:	55                   	push   %ebp
    f8f1:	89 e5                	mov    %esp,%ebp
    f8f3:	83 ec 08             	sub    $0x8,%esp
    f8f6:	89 5d fc             	mov    %ebx,0xfffffffc(%ebp)
    f8f9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	printk("Delayed deallocation\n");
    f8fc:	c7 04 24 20 09 00 00 	movl   $0x920,(%esp,1)
    f903:	e8 fc ff ff ff       	call   f904 <vfree_helper+0x14>
	vfree(ptr);
    f908:	89 5d 08             	mov    %ebx,0x8(%ebp)
    f90b:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
    f90e:	89 ec                	mov    %ebp,%esp
    f910:	5d                   	pop    %ebp
    f911:	e9 fc ff ff ff       	jmp    f912 <vfree_helper+0x22>
    f916:	8d 76 00             	lea    0x0(%esi),%esi
    f919:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

0000f920 <trickles_vma_nopage>:
}

static struct page * trickles_vma_nopage(struct vm_area_struct * area, unsigned long address, int unused) {
    f920:	55                   	push   %ebp
    f921:	89 e5                	mov    %esp,%ebp
    f923:	83 ec 08             	sub    $0x8,%esp
    f926:	89 5d fc             	mov    %ebx,0xfffffffc(%ebp)
    f929:	8b 5d 08             	mov    0x8(%ebp),%ebx
	unsigned long offset;
	struct page *page;
	struct trickles_kconfig *api_config = (struct trickles_kconfig*)area->vm_private_data;
	if(api_config == NULL) return NULL;
    f92c:	31 c0                	xor    %eax,%eax
    f92e:	8b 53 40             	mov    0x40(%ebx),%edx
    f931:	85 d2                	test   %edx,%edx
    f933:	74 1f                	je     f954 <trickles_vma_nopage+0x34>

	void *base = api_config->cfg.ctl->ro_base;
	offset = address - (unsigned long)area->vm_start;
    f935:	8b 45 0c             	mov    0xc(%ebp),%eax
    f938:	8b 52 04             	mov    0x4(%edx),%edx
    f93b:	2b 43 04             	sub    0x4(%ebx),%eax
    f93e:	8b 4a 14             	mov    0x14(%edx),%ecx
	if(offset >= api_config->cfg.ctl->ro_len) {
    f941:	3b 42 20             	cmp    0x20(%edx),%eax
    f944:	72 1a                	jb     f960 <trickles_vma_nopage+0x40>
		printk("error, vm_nopage offset >= ro_len\n");
    f946:	c7 04 24 20 3d 00 00 	movl   $0x3d20,(%esp,1)
    f94d:	e8 fc ff ff ff       	call   f94e <trickles_vma_nopage+0x2e>
		return NULL;
    f952:	31 c0                	xor    %eax,%eax
	}
	page = virt_to_page(virt_to_kseg((char *)base + offset));
	if(page)
		get_page(page);
	return page;
}
    f954:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
    f957:	89 ec                	mov    %ebp,%esp
    f959:	5d                   	pop    %ebp
    f95a:	c3                   	ret    
    f95b:	90                   	nop    
    f95c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
    f960:	8d 04 08             	lea    (%eax,%ecx,1),%eax
    f963:	89 04 24             	mov    %eax,(%esp,1)
    f966:	e8 65 e8 ff ff       	call   e1d0 <virt_to_kseg>
    f96b:	05 00 00 00 40       	add    $0x40000000,%eax
    f970:	c1 e8 0c             	shr    $0xc,%eax
    f973:	8d 14 80             	lea    (%eax,%eax,4),%edx
    f976:	8d 14 50             	lea    (%eax,%edx,2),%edx
    f979:	a1 00 00 00 00       	mov    0x0,%eax
    f97e:	8d 04 90             	lea    (%eax,%edx,4),%eax
    f981:	85 c0                	test   %eax,%eax
    f983:	74 cf                	je     f954 <trickles_vma_nopage+0x34>
 * useful range of an atomic_t is only 24 bits.
 */ 
static __inline__ void atomic_inc(atomic_t *v)
{
	__asm__ __volatile__(
    f985:	ff 40 14             	incl   0x14(%eax)
    f988:	eb ca                	jmp    f954 <trickles_vma_nopage+0x34>
    f98a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000f990 <cminisock_config_pipe_impl>:

struct vm_operations_struct trickles_vm_ops = {
	nopage: trickles_vma_nopage,
	open:  NULL,
	close: NULL
};

int cminisock_config_pipe_impl(struct sock *sk, char *optdata, int optlen, int direction) {
    f990:	55                   	push   %ebp
    f991:	89 e5                	mov    %esp,%ebp
    f993:	57                   	push   %edi
    f994:	56                   	push   %esi
    f995:	53                   	push   %ebx
    f996:	83 ec 54             	sub    $0x54,%esp
    f999:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
	struct trickles_config new_config;
	struct trickles_mmap_ctl *ctl;
	struct alloc_head_list *head;
	unsigned int mmap_len;
	int error;
	struct cminisock *msk;

	if(direction == CMINISOCK_IN) {
    f99c:	8b 55 14             	mov    0x14(%ebp),%edx
    f99f:	8d 83 bc 00 00 00    	lea    0xbc(%ebx),%eax
    f9a5:	85 d2                	test   %edx,%edx
    f9a7:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
    f9aa:	0f 85 03 06 00 00    	jne    ffb3 <cminisock_config_pipe_impl+0x623>
		unsigned minisock_len;
		/* big socket lock already acquired; however, we might need to sleep & hold off if a transaction is pending */
		/* 1) Sleep until transaction complete 
		   2) Perform a vmalloc
		   3) Split the new area into read-only and read-write sections */
		while(tp->cminisock_api_config.pending_delivery) {
    f9b0:	8b 80 e8 01 00 00    	mov    0x1e8(%eax),%eax
    f9b6:	85 c0                	test   %eax,%eax
    f9b8:	0f 84 b7 00 00 00    	je     fa75 <cminisock_config_pipe_impl+0xe5>
    f9be:	8d 73 30             	lea    0x30(%ebx),%esi
    f9c1:	bf 00 e0 ff ff       	mov    $0xffffe000,%edi
    f9c6:	21 e7                	and    %esp,%edi
    f9c8:	90                   	nop    
    f9c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
			int timeout = HZ/4;
			printk("config loop\n");
    f9d0:	c7 04 24 36 09 00 00 	movl   $0x936,(%esp,1)
    f9d7:	e8 fc ff ff ff       	call   f9d8 <cminisock_config_pipe_impl+0x48>

struct task_struct;

static inline struct task_struct * get_current(void)
{
    f9dc:	c7 07 01 00 00 00    	movl   $0x1,(%edi)
			__set_task_state(current, TASK_INTERRUPTIBLE);

			release_sock(sk);
    f9e2:	ff 05 08 00 00 00    	incl   0x8
    f9e8:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f9ee:	85 c0                	test   %eax,%eax
    f9f0:	0f 85 b0 05 00 00    	jne    ffa6 <cminisock_config_pipe_impl+0x616>
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
    f9f6:	39 73 30             	cmp    %esi,0x30(%ebx)
    f9f9:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
    fa00:	0f 85 8a 05 00 00    	jne    ff90 <cminisock_config_pipe_impl+0x600>
    fa06:	ba 08 00 00 00       	mov    $0x8,%edx
    fa0b:	a1 08 00 00 00       	mov    0x8,%eax
    fa10:	48                   	dec    %eax
    fa11:	85 c0                	test   %eax,%eax
    fa13:	a3 08 00 00 00       	mov    %eax,0x8
    fa18:	75 0a                	jne    fa24 <cminisock_config_pipe_impl+0x94>
    fa1a:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
    fa1e:	0f 85 9e 36 00 00    	jne    130c2 <.text.lock.tmalloc+0xf0>
			timeout = schedule_timeout(timeout);
    fa24:	b8 19 00 00 00       	mov    $0x19,%eax
    fa29:	e8 fc ff ff ff       	call   fa2a <cminisock_config_pipe_impl+0x9a>
			lock_sock(sk);
    fa2e:	ff 05 08 00 00 00    	incl   0x8
    fa34:	8b 43 2c             	mov    0x2c(%ebx),%eax
    fa37:	85 c0                	test   %eax,%eax
    fa39:	0f 85 41 05 00 00    	jne    ff80 <cminisock_config_pipe_impl+0x5f0>
    fa3f:	c7 43 2c 01 00 00 00 	movl   $0x1,0x2c(%ebx)
    fa46:	ba 08 00 00 00       	mov    $0x8,%edx
    fa4b:	a1 08 00 00 00       	mov    0x8,%eax
    fa50:	48                   	dec    %eax
    fa51:	85 c0                	test   %eax,%eax
    fa53:	a3 08 00 00 00       	mov    %eax,0x8
    fa58:	75 0a                	jne    fa64 <cminisock_config_pipe_impl+0xd4>
    fa5a:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
    fa5e:	0f 85 6e 36 00 00    	jne    130d2 <.text.lock.tmalloc+0x100>
    fa64:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
    fa67:	8b 82 e8 01 00 00    	mov    0x1e8(%edx),%eax
    fa6d:	85 c0                	test   %eax,%eax
    fa6f:	0f 85 5b ff ff ff    	jne    f9d0 <cminisock_config_pipe_impl+0x40>

static inline struct task_struct * get_current(void)
{
	struct task_struct *current;
	__asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
    fa75:	b8 00 e0 ff ff       	mov    $0xffffe000,%eax
    fa7a:	21 e0                	and    %esp,%eax
    fa7c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

		}
		__set_task_state(current, TASK_RUNNING);

		if(optlen != sizeof(new_config)) {
    fa82:	83 7d 10 0c          	cmpl   $0xc,0x10(%ebp)
    fa86:	74 1b                	je     faa3 <cminisock_config_pipe_impl+0x113>
			printk("optlen != sizeof(new_config)\n");
    fa88:	c7 04 24 43 09 00 00 	movl   $0x943,(%esp,1)
    fa8f:	e8 fc ff ff ff       	call   fa90 <cminisock_config_pipe_impl+0x100>
			error = -EINVAL;
			goto out;
		}
		error = copy_from_user(&new_config,optdata,sizeof(new_config));
		if(error) {
		  printk("copy from user error\n");
			error = -EFAULT;
			goto out;
		}

		if((mmap_len = new_config.mmap_len) > MAX_TRICKLES_SHMEM_SIZE) {
			printk("requested mmap area too large\n");
			error = -EINVAL;
    fa94:	be ea ff ff ff       	mov    $0xffffffea,%esi
			goto out;
		}
		new_config.mmap_base = vmalloc(mmap_len);
		printk("mmap_base: %p\n", new_config.mmap_base);
		if(new_config.mmap_base == NULL) {
			printk("could not mmap enough memory\n");
			error = -ENOMEM;
			goto out;
		}

		/* Split the area */
		ctl = new_config.mmap_base;
		new_config.ctl = ctl;
		BUG_TRAP(sizeof(*ctl) + sizeof(struct work_struct) < PAGE_SIZE);
		ctl->ro_base = new_config.mmap_base;
		ctl->ro_len = PAGE_ALIGN(mmap_len / 4);
		ctl->ro_offs = (char*)ctl->ro_base - (char*)new_config.mmap_base;
		ctl->rw_base = (__u8*)ctl->ro_base + ctl->ro_len;
		ctl->rw_len = PAGE_ALIGN(mmap_len - ((char*)ctl->rw_base - (char*)new_config.mmap_base)) - PAGE_SIZE;
		ctl->rw_offs = (char*)ctl->rw_base - (char*)new_config.mmap_base;
		ctl->update_since_poll = 0;
		INIT_WORK((struct work_struct *)(ctl+1), vfree_helper, new_config.mmap_base);
		BUG_TRAP(ctl->rw_len > 0);
		BUG_TRAP(ctl->ro_len > 0);
		BUG_TRAP((char*)ctl->ro_base < (char*)new_config.mmap_base + mmap_len);

		init_head(&ctl->msk_eventlist);

		tp->cminisock_api_config.cfg = new_config;
		new_config.ctl = NULL;

		/* Initialize minisockets */
		head = &tp->cminisock_api_config.msk_freelist;
		init_head(head);

		msk = (struct cminisock *)((char*)ctl->ro_base + PAGE_SIZE);
		ctl->minisock_base = msk;
		ctl->minisock_offs = (char*)ctl->minisock_base - (char*)new_config.mmap_base;

		msk->ctl = ALLOC_FREE;
		msk->prev = msk->next = NULL;
		msk->list = NULL;
		insert_tail(head, (struct alloc_head*)msk);
		//printk("added %p\n", msk);
		msk++;
		minisock_len = MINISOCK_LEN(ctl->ro_len);
		BUG_TRAP(minisock_len > 0);
		while((char*)(msk + 1) <= (char*)ctl->ro_base + minisock_len) {
			memset(msk, 0x3a, sizeof(*msk));
			msk->ctl = ALLOC_FREE;
			msk->prev = msk->next = NULL;
			msk->list = NULL;
			init_minisock(msk);
			insert_tail(head, (struct alloc_head*)msk);
			//printk("added %p\n", msk);
			msk++;
		}
		/* Initialize heap */
		ctl->heap_base = (char*)ctl->minisock_base + minisock_len;
		tp->t.heapbytesize = ctl->ro_len - minisock_len;

		error = copy_to_user(optdata,&new_config,sizeof(new_config));
		if(error) {
			printk("copy to user error\n");
			error = -EINVAL;
			goto out_dealloc;
		}

		// Set up Crypto
		if(generateHMAC) {	
#ifndef FIXED_CRYPTO_KEYS
			__u8 hmac_key[HMAC_KEYLEN];
			get_random_bytes(hmac_key, HMAC_KEYLEN);
#else
#warning "Fixed hmac key"
			__u8 hmac_key[HMAC_KEYLEN] = "\00\01\02\03\04\05\06\07\010\011\012\013\014\015\016\017\020\021\022\023\024";
#endif
#if OPENSSL_HMAC
#warning "OpenSSL HMAC"
			tp->t.hmacCTX = kmalloc(sizeof(*tp->t.hmacCTX), GFP_KERNEL);
			if(tp->t.hmacCTX == NULL) {
				printk("hmac kmalloc error\n");
				error = -ENOMEM;
				goto out_dealloc;
			}
			hmac_setup(tp->t.hmacCTX, hmac_key, HMAC_KEYLEN);
#else
			BUG_TRAP(HMAC_KEYLEN <= HMACLEN);
			memcpy(tp->t.hmacKey, hmac_key, HMAC_KEYLEN);
#endif
		}
		if(generateNonces) {
#ifndef FIXED_CRYPTO_KEYS
			__u8 nonce_key[NONCE_KEYLEN];
			get_random_bytes(nonce_key, NONCE_KEYLEN);
#else
			__u8 nonce_key[NONCE_KEYLEN] = "\00\01\02\03\04\05\06\07\010\011\012\013\014\015\016\017\020\021\022\023\024";
#endif
			tp->t.nonceCTX = kmalloc(sizeof(*tp->t.nonceCTX), GFP_KERNEL);
			if(tp->t.nonceCTX == NULL) {
				printk("nonce kmalloc error\n");
				error = -ENOMEM;
				goto out_dealloc;
			}
			aes_encrypt_key(nonce_key, NONCE_KEYLEN, tp->t.nonceCTX);
		}

		return 0;
	} else {
		int len;
		if(get_user(len, (int*)optlen)) {
			printk("pipe parameter readout: get optlen fault\n");
			return -EFAULT;
		}
		error = copy_to_user(optdata,&tp->cminisock_api_config.cfg,sizeof(tp->cminisock_api_config.cfg));
		if(error) {
			printk("pipe parameter readout: copy out fault\n");
			return -EINVAL;
		}
		if(put_user(len, (int*)optlen)) {
			printk("pipe parameter readout: set optlen fault\n");
			return -EFAULT;
		}
		printk("socket %p configured\n", sk);
		return 0;
	}

 out:
	return error;
 out_dealloc:
	vfree(new_config.mmap_base);
	new_config.mmap_base = NULL;
	return error;
    fa99:	89 f0                	mov    %esi,%eax
}
    fa9b:	83 c4 54             	add    $0x54,%esp
    fa9e:	5b                   	pop    %ebx
    fa9f:	5e                   	pop    %esi
    faa0:	5f                   	pop    %edi
    faa1:	5d                   	pop    %ebp
    faa2:	c3                   	ret    
    faa3:	c7 44 24 08 0c 00 00 	movl   $0xc,0x8(%esp,1)
    faaa:	00 
    faab:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    faae:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
    fab1:	89 04 24             	mov    %eax,(%esp,1)
    fab4:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
    fab8:	e8 33 34 00 00       	call   12ef0 <__constant_copy_from_user>
    fabd:	85 c0                	test   %eax,%eax
    fabf:	0f 85 a2 04 00 00    	jne    ff67 <cminisock_config_pipe_impl+0x5d7>
    fac5:	8b 5d e4             	mov    0xffffffe4(%ebp),%ebx
    fac8:	81 fb 00 00 00 10    	cmp    $0x10000000,%ebx
    face:	76 09                	jbe    fad9 <cminisock_config_pipe_impl+0x149>
    fad0:	c7 04 24 60 3d 00 00 	movl   $0x3d60,(%esp,1)
    fad7:	eb b6                	jmp    fa8f <cminisock_config_pipe_impl+0xff>
 */
 
static inline void * vmalloc (unsigned long size)
{
	return __vmalloc(size, GFP_KERNEL | __GFP_HIGHMEM, PAGE_KERNEL);
    fad9:	c7 44 24 08 63 01 00 	movl   $0x163,0x8(%esp,1)
    fae0:	00 
    fae1:	c7 44 24 04 f2 01 00 	movl   $0x1f2,0x4(%esp,1)
    fae8:	00 
    fae9:	89 1c 24             	mov    %ebx,(%esp,1)
    faec:	e8 fc ff ff ff       	call   faed <cminisock_config_pipe_impl+0x15d>
    faf1:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    faf4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    faf8:	c7 04 24 61 09 00 00 	movl   $0x961,(%esp,1)
    faff:	e8 fc ff ff ff       	call   fb00 <cminisock_config_pipe_impl+0x170>
    fb04:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
    fb07:	85 ff                	test   %edi,%edi
    fb09:	0f 84 42 04 00 00    	je     ff51 <cminisock_config_pipe_impl+0x5c1>
    fb0f:	89 7d e8             	mov    %edi,0xffffffe8(%ebp)
    fb12:	89 d8                	mov    %ebx,%eax
    fb14:	c1 e8 02             	shr    $0x2,%eax
    fb17:	89 7f 14             	mov    %edi,0x14(%edi)
    fb1a:	05 ff 0f 00 00       	add    $0xfff,%eax
    fb1f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    fb24:	89 47 20             	mov    %eax,0x20(%edi)
    fb27:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    fb2a:	89 fa                	mov    %edi,%edx
    fb2c:	8d 04 38             	lea    (%eax,%edi,1),%eax
    fb2f:	89 07                	mov    %eax,(%edi)
    fb31:	29 ca                	sub    %ecx,%edx
    fb33:	89 d9                	mov    %ebx,%ecx
    fb35:	89 57 18             	mov    %edx,0x18(%edi)
    fb38:	89 c2                	mov    %eax,%edx
    fb3a:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
    fb3d:	29 f2                	sub    %esi,%edx
    fb3f:	29 d1                	sub    %edx,%ecx
    fb41:	89 ca                	mov    %ecx,%edx
    fb43:	81 c2 ff 0f 00 00    	add    $0xfff,%edx
    fb49:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
    fb4f:	81 ea 00 10 00 00    	sub    $0x1000,%edx
    fb55:	89 57 08             	mov    %edx,0x8(%edi)
    fb58:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    fb5b:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
    fb62:	c7 47 44 00 00 00 00 	movl   $0x0,0x44(%edi)
    fb69:	c7 47 48 00 00 00 00 	movl   $0x0,0x48(%edi)
    fb70:	29 c8                	sub    %ecx,%eax
    fb72:	85 d2                	test   %edx,%edx
    fb74:	89 47 04             	mov    %eax,0x4(%edi)
    fb77:	8d 47 3c             	lea    0x3c(%edi),%eax
    fb7a:	89 47 3c             	mov    %eax,0x3c(%edi)
    fb7d:	89 47 40             	mov    %eax,0x40(%edi)
    fb80:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    fb83:	89 47 4c             	mov    %eax,0x4c(%edi)
    fb86:	0f 84 ac 03 00 00    	je     ff38 <cminisock_config_pipe_impl+0x5a8>
    fb8c:	8b 57 20             	mov    0x20(%edi),%edx
    fb8f:	85 d2                	test   %edx,%edx
    fb91:	0f 84 88 03 00 00    	je     ff1f <cminisock_config_pipe_impl+0x58f>
    fb97:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    fb9a:	01 c3                	add    %eax,%ebx
    fb9c:	39 5f 14             	cmp    %ebx,0x14(%edi)
    fb9f:	0f 83 61 03 00 00    	jae    ff06 <cminisock_config_pipe_impl+0x576>
static inline int empty(struct alloc_head_list *head) {
	return head->next == (struct alloc_head*)head;
}

static inline void init_head(struct alloc_head_list *head) {
    fba5:	8d 47 24             	lea    0x24(%edi),%eax
	head->next = head->prev = (struct alloc_head*)head;
    fba8:	89 40 04             	mov    %eax,0x4(%eax)
	head->list = head;
    fbab:	89 40 08             	mov    %eax,0x8(%eax)
	head->len = 0;
    fbae:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    fbb5:	89 47 24             	mov    %eax,0x24(%edi)
    fbb8:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
    fbbb:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    fbbe:	89 d6                	mov    %edx,%esi
    fbc0:	81 c6 d4 01 00 00    	add    $0x1d4,%esi
    fbc6:	89 82 c8 01 00 00    	mov    %eax,0x1c8(%edx)
    fbcc:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    fbcf:	89 82 cc 01 00 00    	mov    %eax,0x1cc(%edx)
    fbd5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    fbd8:	89 82 d0 01 00 00    	mov    %eax,0x1d0(%edx)
    fbde:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
	return head->next == (struct alloc_head*)head;
}

static inline void init_head(struct alloc_head_list *head) {
	head->next = head->prev = (struct alloc_head*)head;
    fbe5:	89 b2 d4 01 00 00    	mov    %esi,0x1d4(%edx)
    fbeb:	89 76 04             	mov    %esi,0x4(%esi)
	head->list = head;
    fbee:	89 76 08             	mov    %esi,0x8(%esi)
	head->len = 0;
    fbf1:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
    fbf8:	8b 4f 14             	mov    0x14(%edi),%ecx
    fbfb:	89 cb                	mov    %ecx,%ebx
    fbfd:	89 4d b8             	mov    %ecx,0xffffffb8(%ebp)
    fc00:	81 c3 00 10 00 00    	add    $0x1000,%ebx
    fc06:	89 d8                	mov    %ebx,%eax
    fc08:	89 5f 0c             	mov    %ebx,0xc(%edi)
    fc0b:	2b 45 ec             	sub    0xffffffec(%ebp),%eax
    fc0e:	89 47 1c             	mov    %eax,0x1c(%edi)
    fc11:	31 c0                	xor    %eax,%eax
    fc13:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    fc1a:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    fc21:	89 81 00 10 00 00    	mov    %eax,0x1000(%ecx)
    fc27:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	if(elem->list) {
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
    fc2e:	8b 82 d4 01 00 00    	mov    0x1d4(%edx),%eax
    fc34:	39 d8                	cmp    %ebx,%eax
    fc36:	0f 84 97 02 00 00    	je     fed3 <cminisock_config_pipe_impl+0x543>
		BUG();
		show_stack(NULL);
	}
	elem->prev = head->prev;
    fc3c:	8b 4d b8             	mov    0xffffffb8(%ebp),%ecx
    fc3f:	89 81 00 10 00 00    	mov    %eax,0x1000(%ecx)
	head->prev->next = elem;
    fc45:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
    fc48:	8b 82 d4 01 00 00    	mov    0x1d4(%edx),%eax

	elem->next = (struct alloc_head*)head;

	elem->list = head;
    fc4e:	89 73 08             	mov    %esi,0x8(%ebx)
    fc51:	89 58 04             	mov    %ebx,0x4(%eax)
    fc54:	89 73 04             	mov    %esi,0x4(%ebx)
	head->prev = elem;
	head->len++;
    fc57:	ff 46 10             	incl   0x10(%esi)
    fc5a:	89 9a d4 01 00 00    	mov    %ebx,0x1d4(%edx)
    fc60:	89 cb                	mov    %ecx,%ebx
    fc62:	81 c3 e4 10 00 00    	add    $0x10e4,%ebx
    fc68:	8b 47 20             	mov    0x20(%edi),%eax
    fc6b:	d1 e8                	shr    %eax
    fc6d:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
    fc70:	0f 84 44 02 00 00    	je     feba <cminisock_config_pipe_impl+0x52a>
    fc76:	8b 55 b8             	mov    0xffffffb8(%ebp),%edx
    fc79:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    fc7c:	8b 4f 14             	mov    0x14(%edi),%ecx
    fc7f:	81 c2 c8 11 00 00    	add    $0x11c8,%edx
    fc85:	01 c8                	add    %ecx,%eax
    fc87:	39 c2                	cmp    %eax,%edx
    fc89:	0f 87 9e 00 00 00    	ja     fd2d <cminisock_config_pipe_impl+0x39d>
    fc8f:	89 55 b4             	mov    %edx,0xffffffb4(%ebp)
    fc92:	c7 44 24 08 e4 00 00 	movl   $0xe4,0x8(%esp,1)
    fc99:	00 
    fc9a:	c7 44 24 04 3a 3a 3a 	movl   $0x3a3a3a3a,0x4(%esp,1)
    fca1:	3a 
    fca2:	89 1c 24             	mov    %ebx,(%esp,1)
    fca5:	e8 26 31 00 00       	call   12dd0 <__constant_c_and_count_memset>
	tp->instrumentation = 0;
}

static inline void init_minisock(struct cminisock *msk) {
	msk->num_packets = 0;
    fcaa:	31 c0                	xor    %eax,%eax
	msk->ucont_len = 0;
	msk->ucont_data = NULL;
	msk->input_len = 0;
	msk->input = NULL;
	msk->packets = NULL;
    fcac:	31 c9                	xor    %ecx,%ecx
    fcae:	89 83 dc 00 00 00    	mov    %eax,0xdc(%ebx)
    fcb4:	31 c0                	xor    %eax,%eax
    fcb6:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
    fcbc:	31 c0                	xor    %eax,%eax
    fcbe:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
    fcc4:	31 c0                	xor    %eax,%eax
    fcc6:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    fccd:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    fcd4:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    fcda:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
}

static inline void init_minisock(struct cminisock *msk) {
	msk->num_packets = 0;
	msk->ucont_len = 0;
    fce1:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
	msk->ucont_data = NULL;
	msk->input_len = 0;
	msk->input = NULL;
    fce8:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	msk->packets = NULL;
    fcee:	89 8b e0 00 00 00    	mov    %ecx,0xe0(%ebx)
	if(elem->list) {
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
    fcf4:	39 1e                	cmp    %ebx,(%esi)
    fcf6:	0f 84 94 01 00 00    	je     fe90 <cminisock_config_pipe_impl+0x500>
		BUG();
		show_stack(NULL);
	}
	elem->prev = head->prev;
    fcfc:	8b 06                	mov    (%esi),%eax
    fcfe:	89 03                	mov    %eax,(%ebx)
	head->prev->next = elem;
    fd00:	8b 06                	mov    (%esi),%eax

	elem->next = (struct alloc_head*)head;

	elem->list = head;
    fd02:	89 73 08             	mov    %esi,0x8(%ebx)
    fd05:	89 58 04             	mov    %ebx,0x4(%eax)
    fd08:	89 73 04             	mov    %esi,0x4(%ebx)
	head->prev = elem;
	head->len++;
    fd0b:	ff 46 10             	incl   0x10(%esi)
    fd0e:	89 1e                	mov    %ebx,(%esi)
    fd10:	8b 5d b4             	mov    0xffffffb4(%ebp),%ebx
    fd13:	8d 83 e4 00 00 00    	lea    0xe4(%ebx),%eax
    fd19:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
    fd1c:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    fd1f:	8b 57 14             	mov    0x14(%edi),%edx
    fd22:	01 d0                	add    %edx,%eax
    fd24:	39 45 b4             	cmp    %eax,0xffffffb4(%ebp)
    fd27:	0f 86 65 ff ff ff    	jbe    fc92 <cminisock_config_pipe_impl+0x302>
    fd2d:	8b 77 0c             	mov    0xc(%edi),%esi
    fd30:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    fd33:	01 f0                	add    %esi,%eax
    fd35:	89 47 10             	mov    %eax,0x10(%edi)
    fd38:	8b 47 20             	mov    0x20(%edi),%eax
    fd3b:	8b 5d bc             	mov    0xffffffbc(%ebp),%ebx
    fd3e:	8b 4d c0             	mov    0xffffffc0(%ebp),%ecx
    fd41:	29 d8                	sub    %ebx,%eax
    fd43:	89 81 1c 02 00 00    	mov    %eax,0x21c(%ecx)
    fd49:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
    fd4c:	8b 55 0c             	mov    0xc(%ebp),%edx
    fd4f:	c7 44 24 08 0c 00 00 	movl   $0xc,0x8(%esp,1)
    fd56:	00 
    fd57:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    fd5b:	89 14 24             	mov    %edx,(%esp,1)
    fd5e:	e8 0d 31 00 00       	call   12e70 <__constant_copy_to_user>
    fd63:	85 c0                	test   %eax,%eax
    fd65:	0f 85 0f 01 00 00    	jne    fe7a <cminisock_config_pipe_impl+0x4ea>
    fd6b:	8b 0d 00 00 00 00    	mov    0x0,%ecx
    fd71:	85 c9                	test   %ecx,%ecx
    fd73:	0f 85 96 00 00 00    	jne    fe0f <cminisock_config_pipe_impl+0x47f>
    fd79:	8b 15 00 00 00 00    	mov    0x0,%edx
    fd7f:	85 d2                	test   %edx,%edx
    fd81:	75 07                	jne    fd8a <cminisock_config_pipe_impl+0x3fa>
    fd83:	31 c0                	xor    %eax,%eax
    fd85:	e9 11 fd ff ff       	jmp    fa9b <cminisock_config_pipe_impl+0x10b>
    fd8a:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
    fd91:	00 
    fd92:	a1 50 01 00 00       	mov    0x150,%eax
    fd97:	c7 04 24 f4 00 00 00 	movl   $0xf4,(%esp,1)
    fd9e:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
    fda1:	a1 54 01 00 00       	mov    0x154,%eax
    fda6:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
    fda9:	a1 58 01 00 00       	mov    0x158,%eax
    fdae:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    fdb1:	a1 5c 01 00 00       	mov    0x15c,%eax
    fdb6:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    fdb9:	e8 fc ff ff ff       	call   fdba <cminisock_config_pipe_impl+0x42a>
    fdbe:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
    fdc1:	85 c0                	test   %eax,%eax
    fdc3:	89 82 20 0b 00 00    	mov    %eax,0xb20(%edx)
    fdc9:	75 28                	jne    fdf3 <cminisock_config_pipe_impl+0x463>
    fdcb:	c7 04 24 70 09 00 00 	movl   $0x970,(%esp,1)
    fdd2:	e8 fc ff ff ff       	call   fdd3 <cminisock_config_pipe_impl+0x443>
    fdd7:	be f4 ff ff ff       	mov    $0xfffffff4,%esi
    fddc:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    fddf:	89 04 24             	mov    %eax,(%esp,1)
    fde2:	e8 fc ff ff ff       	call   fde3 <cminisock_config_pipe_impl+0x453>
    fde7:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
    fdee:	e9 a6 fc ff ff       	jmp    fa99 <cminisock_config_pipe_impl+0x109>
    fdf3:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    fdf7:	8d 45 c4             	lea    0xffffffc4(%ebp),%eax
    fdfa:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp,1)
    fe01:	00 
    fe02:	89 04 24             	mov    %eax,(%esp,1)
    fe05:	e8 fc ff ff ff       	call   fe06 <cminisock_config_pipe_impl+0x476>
    fe0a:	e9 74 ff ff ff       	jmp    fd83 <cminisock_config_pipe_impl+0x3f3>
    fe0f:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
    fe16:	00 
    fe17:	a1 50 01 00 00       	mov    0x150,%eax
    fe1c:	c7 04 24 54 01 00 00 	movl   $0x154,(%esp,1)
    fe23:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
    fe26:	a1 54 01 00 00       	mov    0x154,%eax
    fe2b:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    fe2e:	a1 58 01 00 00       	mov    0x158,%eax
    fe33:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    fe36:	a1 5c 01 00 00       	mov    0x15c,%eax
    fe3b:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    fe3e:	e8 fc ff ff ff       	call   fe3f <cminisock_config_pipe_impl+0x4af>
    fe43:	8b 4d c0             	mov    0xffffffc0(%ebp),%ecx
    fe46:	85 c0                	test   %eax,%eax
    fe48:	89 c2                	mov    %eax,%edx
    fe4a:	89 81 0c 0b 00 00    	mov    %eax,0xb0c(%ecx)
    fe50:	75 0c                	jne    fe5e <cminisock_config_pipe_impl+0x4ce>
    fe52:	c7 04 24 85 09 00 00 	movl   $0x985,(%esp,1)
    fe59:	e9 74 ff ff ff       	jmp    fdd2 <cminisock_config_pipe_impl+0x442>
    fe5e:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp,1)
    fe65:	00 
    fe66:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
    fe69:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    fe6d:	89 14 24             	mov    %edx,(%esp,1)
    fe70:	e8 fc ff ff ff       	call   fe71 <cminisock_config_pipe_impl+0x4e1>
    fe75:	e9 ff fe ff ff       	jmp    fd79 <cminisock_config_pipe_impl+0x3e9>
    fe7a:	c7 04 24 99 09 00 00 	movl   $0x999,(%esp,1)
    fe81:	be ea ff ff ff       	mov    $0xffffffea,%esi
    fe86:	e8 fc ff ff ff       	call   fe87 <cminisock_config_pipe_impl+0x4f7>
    fe8b:	e9 4c ff ff ff       	jmp    fddc <cminisock_config_pipe_impl+0x44c>
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
		BUG();
    fe90:	c7 44 24 04 02 08 00 	movl   $0x802,0x4(%esp,1)
    fe97:	00 
    fe98:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp,1)
    fe9f:	e8 fc ff ff ff       	call   fea0 <cminisock_config_pipe_impl+0x510>
    fea4:	e8 fc ff ff ff       	call   fea5 <cminisock_config_pipe_impl+0x515>
		show_stack(NULL);
    fea9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    feb0:	e8 fc ff ff ff       	call   feb1 <cminisock_config_pipe_impl+0x521>
    feb5:	e9 42 fe ff ff       	jmp    fcfc <cminisock_config_pipe_impl+0x36c>
    feba:	c7 44 24 04 6e 03 00 	movl   $0x36e,0x4(%esp,1)
    fec1:	00 
    fec2:	c7 04 24 80 3d 00 00 	movl   $0x3d80,(%esp,1)
    fec9:	e8 fc ff ff ff       	call   feca <cminisock_config_pipe_impl+0x53a>
    fece:	e9 a3 fd ff ff       	jmp    fc76 <cminisock_config_pipe_impl+0x2e6>
    fed3:	c7 44 24 04 02 08 00 	movl   $0x802,0x4(%esp,1)
    feda:	00 
    fedb:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp,1)
    fee2:	e8 fc ff ff ff       	call   fee3 <cminisock_config_pipe_impl+0x553>
    fee7:	e8 fc ff ff ff       	call   fee8 <cminisock_config_pipe_impl+0x558>
    feec:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    fef3:	e8 fc ff ff ff       	call   fef4 <cminisock_config_pipe_impl+0x564>
    fef8:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
    fefb:	8b 82 d4 01 00 00    	mov    0x1d4(%edx),%eax
    ff01:	e9 36 fd ff ff       	jmp    fc3c <cminisock_config_pipe_impl+0x2ac>
    ff06:	c7 44 24 04 58 03 00 	movl   $0x358,0x4(%esp,1)
    ff0d:	00 
    ff0e:	c7 04 24 e0 3d 00 00 	movl   $0x3de0,(%esp,1)
    ff15:	e8 fc ff ff ff       	call   ff16 <cminisock_config_pipe_impl+0x586>
    ff1a:	e9 86 fc ff ff       	jmp    fba5 <cminisock_config_pipe_impl+0x215>
    ff1f:	c7 44 24 04 57 03 00 	movl   $0x357,0x4(%esp,1)
    ff26:	00 
    ff27:	c7 04 24 60 3e 00 00 	movl   $0x3e60,(%esp,1)
    ff2e:	e8 fc ff ff ff       	call   ff2f <cminisock_config_pipe_impl+0x59f>
    ff33:	e9 5f fc ff ff       	jmp    fb97 <cminisock_config_pipe_impl+0x207>
    ff38:	c7 44 24 04 56 03 00 	movl   $0x356,0x4(%esp,1)
    ff3f:	00 
    ff40:	c7 04 24 c0 3e 00 00 	movl   $0x3ec0,(%esp,1)
    ff47:	e8 fc ff ff ff       	call   ff48 <cminisock_config_pipe_impl+0x5b8>
    ff4c:	e9 3b fc ff ff       	jmp    fb8c <cminisock_config_pipe_impl+0x1fc>
    ff51:	c7 04 24 ad 09 00 00 	movl   $0x9ad,(%esp,1)
    ff58:	be f4 ff ff ff       	mov    $0xfffffff4,%esi
    ff5d:	e8 fc ff ff ff       	call   ff5e <cminisock_config_pipe_impl+0x5ce>
    ff62:	e9 32 fb ff ff       	jmp    fa99 <cminisock_config_pipe_impl+0x109>
    ff67:	c7 04 24 cb 09 00 00 	movl   $0x9cb,(%esp,1)
    ff6e:	be f2 ff ff ff       	mov    $0xfffffff2,%esi
    ff73:	e8 fc ff ff ff       	call   ff74 <cminisock_config_pipe_impl+0x5e4>
    ff78:	e9 1c fb ff ff       	jmp    fa99 <cminisock_config_pipe_impl+0x109>
    ff7d:	8d 76 00             	lea    0x0(%esi),%esi
    ff80:	89 1c 24             	mov    %ebx,(%esp,1)
    ff83:	e8 fc ff ff ff       	call   ff84 <cminisock_config_pipe_impl+0x5f4>
    ff88:	e9 b2 fa ff ff       	jmp    fa3f <cminisock_config_pipe_impl+0xaf>
    ff8d:	8d 76 00             	lea    0x0(%esi),%esi
    ff90:	b9 01 00 00 00       	mov    $0x1,%ecx
    ff95:	ba 03 00 00 00       	mov    $0x3,%edx
    ff9a:	89 f0                	mov    %esi,%eax
    ff9c:	e8 fc ff ff ff       	call   ff9d <cminisock_config_pipe_impl+0x60d>
    ffa1:	e9 60 fa ff ff       	jmp    fa06 <cminisock_config_pipe_impl+0x76>
    ffa6:	89 1c 24             	mov    %ebx,(%esp,1)
    ffa9:	e8 fc ff ff ff       	call   ffaa <cminisock_config_pipe_impl+0x61a>
    ffae:	e9 43 fa ff ff       	jmp    f9f6 <cminisock_config_pipe_impl+0x66>
    ffb3:	8b 45 10             	mov    0x10(%ebp),%eax
    ffb6:	e8 fc ff ff ff       	call   ffb7 <cminisock_config_pipe_impl+0x627>
    ffbb:	85 c0                	test   %eax,%eax
    ffbd:	89 d7                	mov    %edx,%edi
    ffbf:	74 16                	je     ffd7 <cminisock_config_pipe_impl+0x647>
    ffc1:	c7 04 24 20 3f 00 00 	movl   $0x3f20,(%esp,1)
    ffc8:	e8 fc ff ff ff       	call   ffc9 <cminisock_config_pipe_impl+0x639>
    ffcd:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
    ffd2:	e9 c4 fa ff ff       	jmp    fa9b <cminisock_config_pipe_impl+0x10b>
    ffd7:	c7 44 24 08 0c 00 00 	movl   $0xc,0x8(%esp,1)
    ffde:	00 
    ffdf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    ffe2:	8d 83 84 02 00 00    	lea    0x284(%ebx),%eax
    ffe8:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ffec:	89 0c 24             	mov    %ecx,(%esp,1)
    ffef:	e8 7c 2e 00 00       	call   12e70 <__constant_copy_to_user>
    fff4:	85 c0                	test   %eax,%eax
    fff6:	89 c6                	mov    %eax,%esi
    fff8:	75 4d                	jne    10047 <cminisock_config_pipe_impl+0x6b7>
    fffa:	c7 45 ac f2 ff ff ff 	movl   $0xfffffff2,0xffffffac(%ebp)

static inline struct task_struct * get_current(void)
{
	struct task_struct *current;
	__asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
   10001:	b8 00 e0 ff ff       	mov    $0xffffe000,%eax
   10006:	8b 4d 10             	mov    0x10(%ebp),%ecx
   10009:	21 e0                	and    %esp,%eax
   1000b:	83 c1 04             	add    $0x4,%ecx
   1000e:	19 d2                	sbb    %edx,%edx
   10010:	39 48 0c             	cmp    %ecx,0xc(%eax)
   10013:	83 da 00             	sbb    $0x0,%edx
   10016:	85 d2                	test   %edx,%edx
   10018:	75 08                	jne    10022 <cminisock_config_pipe_impl+0x692>
   1001a:	8b 45 10             	mov    0x10(%ebp),%eax
   1001d:	89 38                	mov    %edi,(%eax)
   1001f:	89 75 ac             	mov    %esi,0xffffffac(%ebp)
   10022:	8b 45 ac             	mov    0xffffffac(%ebp),%eax
   10025:	85 c0                	test   %eax,%eax
   10027:	74 09                	je     10032 <cminisock_config_pipe_impl+0x6a2>
   10029:	c7 04 24 60 3f 00 00 	movl   $0x3f60,(%esp,1)
   10030:	eb 96                	jmp    ffc8 <cminisock_config_pipe_impl+0x638>
   10032:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
   10036:	c7 04 24 e1 09 00 00 	movl   $0x9e1,(%esp,1)
   1003d:	e8 fc ff ff ff       	call   1003e <cminisock_config_pipe_impl+0x6ae>
   10042:	e9 3c fd ff ff       	jmp    fd83 <cminisock_config_pipe_impl+0x3f3>
   10047:	c7 04 24 a0 3f 00 00 	movl   $0x3fa0,(%esp,1)
   1004e:	e8 fc ff ff ff       	call   1004f <cminisock_config_pipe_impl+0x6bf>
   10053:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   10058:	e9 3e fa ff ff       	jmp    fa9b <cminisock_config_pipe_impl+0x10b>
   1005d:	8d 76 00             	lea    0x0(%esi),%esi

00010060 <trickles_getsockopt_impl>:

int trickles_getsockopt_impl(struct sock *sk, int level, int optname, char *optval, int *optlen) {
   10060:	55                   	push   %ebp
   10061:	89 e5                	mov    %esp,%ebp
   10063:	83 ec 10             	sub    $0x10,%esp
   10066:	89 5d f4             	mov    %ebx,0xfffffff4(%ebp)
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
   10069:	8b 45 08             	mov    0x8(%ebp),%eax
   1006c:	8b 55 10             	mov    0x10(%ebp),%edx
   1006f:	89 75 f8             	mov    %esi,0xfffffff8(%ebp)
   10072:	8b 5d 14             	mov    0x14(%ebp),%ebx
   10075:	05 bc 00 00 00       	add    $0xbc,%eax
	int outputLen, len, rval;
	if(level != SOL_TCP) {
   1007a:	83 7d 0c 06          	cmpl   $0x6,0xc(%ebp)
   1007e:	89 7d fc             	mov    %edi,0xfffffffc(%ebp)
   10081:	74 14                	je     10097 <trickles_getsockopt_impl+0x37>
		return -EINVAL;
   10083:	ba ea ff ff ff       	mov    $0xffffffea,%edx
	}
	switch(optname) {
	case TCP_TRICKLES_CWND:
		outputLen = sizeof(int);
		rval = tp->snd_wnd;
		break;
	case TCP_TRICKLES_SSTHRESH:
		outputLen = sizeof(int);
		rval = tp->snd_ssthresh;
		break;
	default:
		return -ENOPROTOOPT;
	}
	if(get_user(len,optlen)) {
		return -EFAULT;
	}
	if(len < sizeof(int)) {
		return -EFAULT;
	}
	if(put_user(outputLen,optlen)) {
		return -EFAULT;
	}
	if(put_user(rval,optval)) {
		return -EFAULT;
	}
	return 0;
}
   10088:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
   1008b:	89 d0                	mov    %edx,%eax
   1008d:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
   10090:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
   10093:	89 ec                	mov    %ebp,%esp
   10095:	5d                   	pop    %ebp
   10096:	c3                   	ret    
   10097:	83 fa 12             	cmp    $0x12,%edx
   1009a:	0f 84 94 00 00 00    	je     10134 <trickles_getsockopt_impl+0xd4>
   100a0:	83 fa 13             	cmp    $0x13,%edx
   100a3:	74 07                	je     100ac <trickles_getsockopt_impl+0x4c>
   100a5:	ba a4 ff ff ff       	mov    $0xffffffa4,%edx
   100aa:	eb dc                	jmp    10088 <trickles_getsockopt_impl+0x28>
   100ac:	8b b8 90 00 00 00    	mov    0x90(%eax),%edi
   100b2:	8b 45 18             	mov    0x18(%ebp),%eax
   100b5:	e8 fc ff ff ff       	call   100b6 <trickles_getsockopt_impl+0x56>
   100ba:	85 c0                	test   %eax,%eax
   100bc:	89 d1                	mov    %edx,%ecx
   100be:	ba f2 ff ff ff       	mov    $0xfffffff2,%edx
   100c3:	75 c3                	jne    10088 <trickles_getsockopt_impl+0x28>
   100c5:	83 f9 03             	cmp    $0x3,%ecx
   100c8:	ba f2 ff ff ff       	mov    $0xfffffff2,%edx
   100cd:	76 b9                	jbe    10088 <trickles_getsockopt_impl+0x28>

static inline struct task_struct * get_current(void)
{
	struct task_struct *current;
	__asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
   100cf:	b9 00 e0 ff ff       	mov    $0xffffe000,%ecx
   100d4:	8b 55 18             	mov    0x18(%ebp),%edx
   100d7:	be f2 ff ff ff       	mov    $0xfffffff2,%esi

static inline struct task_struct * get_current(void)
{
	struct task_struct *current;
	__asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
   100dc:	21 e1                	and    %esp,%ecx
   100de:	83 c2 04             	add    $0x4,%edx
   100e1:	19 c0                	sbb    %eax,%eax
   100e3:	39 51 0c             	cmp    %edx,0xc(%ecx)
   100e6:	83 d8 00             	sbb    $0x0,%eax
   100e9:	85 c0                	test   %eax,%eax
   100eb:	75 0b                	jne    100f8 <trickles_getsockopt_impl+0x98>
   100ed:	31 f6                	xor    %esi,%esi
   100ef:	8b 45 18             	mov    0x18(%ebp),%eax
   100f2:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
   100f8:	85 f6                	test   %esi,%esi
   100fa:	ba f2 ff ff ff       	mov    $0xfffffff2,%edx
   100ff:	75 87                	jne    10088 <trickles_getsockopt_impl+0x28>
   10101:	c7 45 f0 f2 ff ff ff 	movl   $0xfffffff2,0xfffffff0(%ebp)

struct task_struct;

static inline struct task_struct * get_current(void)
{
   10108:	89 da                	mov    %ebx,%edx
   1010a:	83 c2 01             	add    $0x1,%edx
   1010d:	19 c0                	sbb    %eax,%eax
   1010f:	39 51 0c             	cmp    %edx,0xc(%ecx)
   10112:	83 d8 00             	sbb    $0x0,%eax
   10115:	85 c0                	test   %eax,%eax
   10117:	75 09                	jne    10122 <trickles_getsockopt_impl+0xc2>
   10119:	89 f0                	mov    %esi,%eax
   1011b:	89 fa                	mov    %edi,%edx
   1011d:	88 13                	mov    %dl,(%ebx)
   1011f:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   10122:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
   10125:	ba f2 ff ff ff       	mov    $0xfffffff2,%edx
   1012a:	85 c9                	test   %ecx,%ecx
   1012c:	0f 44 d6             	cmove  %esi,%edx
   1012f:	e9 54 ff ff ff       	jmp    10088 <trickles_getsockopt_impl+0x28>
   10134:	8b 78 54             	mov    0x54(%eax),%edi
   10137:	e9 76 ff ff ff       	jmp    100b2 <trickles_getsockopt_impl+0x52>
   1013c:	8d 74 26 00          	lea    0x0(%esi,1),%esi

00010140 <trickles_sendv_impl>:

static __inline__ void sockfd_put(struct socket *sock)
{
        fput(sock->file);
}

/* syscall */
int trickles_sendv_impl(int fd, struct cminisock *msk, unsigned byteNum, struct tiovec *user_tiov, int tiovlen) {
   10140:	55                   	push   %ebp
   10141:	89 e5                	mov    %esp,%ebp
   10143:	57                   	push   %edi
   10144:	56                   	push   %esi
   10145:	53                   	push   %ebx
   10146:	83 ec 34             	sub    $0x34,%esp
	struct socket *sock;
	struct sock *sk;
	struct tcp_opt *tp;
	int err;

	struct tiovec *tiov;
	int tiov_size;

	extern int gNumSendv;
	gNumSendv++;

	err = -EINVAL;
   10149:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
   10150:	8b 75 0c             	mov    0xc(%ebp),%esi
   10153:	ff 05 00 00 00 00    	incl   0x0
	if (tiovlen < 0 || tiovlen > UIO_MAXIOV) {
   10159:	81 7d 18 00 04 00 00 	cmpl   $0x400,0x18(%ebp)
   10160:	0f 87 25 02 00 00    	ja     1038b <trickles_sendv_impl+0x24b>
		goto out;
	}
	err = -ENOMEM;
   10166:	c7 45 f0 f4 ff ff ff 	movl   $0xfffffff4,0xfffffff0(%ebp)
	tiov_size = sizeof(struct tiovec) * tiovlen;
   1016d:	8b 45 18             	mov    0x18(%ebp),%eax
   10170:	c1 e0 03             	shl    $0x3,%eax
   10173:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
	if(tiov_size > 0) {
   10176:	85 c0                	test   %eax,%eax
   10178:	0f 8e 52 03 00 00    	jle    104d0 <trickles_sendv_impl+0x390>
		tiov = kmalloc(tiov_size, GFP_KERNEL);
   1017e:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
   10185:	00 
   10186:	89 04 24             	mov    %eax,(%esp,1)
   10189:	e8 fc ff ff ff       	call   1018a <trickles_sendv_impl+0x4a>
   1018e:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
		if(tiov == NULL) {
   10191:	85 c0                	test   %eax,%eax
   10193:	0f 84 f2 01 00 00    	je     1038b <trickles_sendv_impl+0x24b>
			goto out;
		}
		err = -EFAULT;
   10199:	c7 45 f0 f2 ff ff ff 	movl   $0xfffffff2,0xfffffff0(%ebp)
		if(copy_from_user(tiov, user_tiov, tiov_size)) {
   101a0:	8b 45 14             	mov    0x14(%ebp),%eax
   101a3:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   101a6:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   101aa:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   101ad:	89 54 24 08          	mov    %edx,0x8(%esp,1)
   101b1:	89 04 24             	mov    %eax,(%esp,1)
   101b4:	e8 fc ff ff ff       	call   101b5 <trickles_sendv_impl+0x75>
   101b9:	85 c0                	test   %eax,%eax
   101bb:	0f 85 b8 01 00 00    	jne    10379 <trickles_sendv_impl+0x239>
			goto out_freeiov;
		}
	} else {
		tiov = NULL;
	}

	sock = sockfd_lookup(fd, &err);
   101c1:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   101c4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   101c8:	8b 45 08             	mov    0x8(%ebp),%eax
   101cb:	89 04 24             	mov    %eax,(%esp,1)
   101ce:	e8 fc ff ff ff       	call   101cf <trickles_sendv_impl+0x8f>
   101d3:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	if (!sock)
   101d6:	85 c0                	test   %eax,%eax
   101d8:	0f 84 9b 01 00 00    	je     10379 <trickles_sendv_impl+0x239>
		goto out_freeiov;

	sk = sock->sk;
   101de:	8b 58 18             	mov    0x18(%eax),%ebx
	tp = &(sk->tp_pinfo.af_tcp);

	lock_sock(sk);
   101e1:	ff 05 08 00 00 00    	incl   0x8
   101e7:	8d 93 bc 00 00 00    	lea    0xbc(%ebx),%edx
   101ed:	89 55 e8             	mov    %edx,0xffffffe8(%ebp)
   101f0:	8b 43 2c             	mov    0x2c(%ebx),%eax
   101f3:	85 c0                	test   %eax,%eax
   101f5:	0f 85 c2 02 00 00    	jne    104bd <trickles_sendv_impl+0x37d>
   101fb:	c7 43 2c 01 00 00 00 	movl   $0x1,0x2c(%ebx)
   10202:	ba 08 00 00 00       	mov    $0x8,%edx
   10207:	a1 08 00 00 00       	mov    0x8,%eax
   1020c:	48                   	dec    %eax
   1020d:	85 c0                	test   %eax,%eax
   1020f:	a3 08 00 00 00       	mov    %eax,0x8
   10214:	75 0a                	jne    10220 <trickles_sendv_impl+0xe0>
   10216:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   1021a:	0f 85 c2 2e 00 00    	jne    130e2 <.text.lock.tmalloc+0x110>
	if(!TRICKLES_USERAPI_CONFIGURED_TP(tp)) {
   10220:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   10223:	8b b8 d0 01 00 00    	mov    0x1d0(%eax),%edi
   10229:	85 ff                	test   %edi,%edi
   1022b:	0f 84 18 02 00 00    	je     10449 <trickles_sendv_impl+0x309>
		printk("Socket not configured\n");
		err = -EINVAL;
		release_sock(sk);
		goto out_put;
	}
	if(!IS_TRICKLES_SOCK_ADDR(tp,msk) || !(VALID_MSK_CTL(msk))) {
   10231:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   10234:	b9 3f 82 fb 08       	mov    $0x8fb823f,%ecx
   10239:	8b ba cc 01 00 00    	mov    0x1cc(%edx),%edi
   1023f:	89 f2                	mov    %esi,%edx
   10241:	8b 47 0c             	mov    0xc(%edi),%eax
   10244:	29 c2                	sub    %eax,%edx
   10246:	89 55 d0             	mov    %edx,0xffffffd0(%ebp)
   10249:	c1 ea 02             	shr    $0x2,%edx
   1024c:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
   1024f:	89 d0                	mov    %edx,%eax
   10251:	f7 e1                	mul    %ecx
   10253:	d1 ea                	shr    %edx
   10255:	69 d2 e4 00 00 00    	imul   $0xe4,%edx,%edx
   1025b:	39 55 d0             	cmp    %edx,0xffffffd0(%ebp)
   1025e:	0f 85 dd 01 00 00    	jne    10441 <trickles_sendv_impl+0x301>
   10264:	3b 75 dc             	cmp    0xffffffdc(%ebp),%esi
   10267:	0f 82 d4 01 00 00    	jb     10441 <trickles_sendv_impl+0x301>
   1026d:	8b 57 14             	mov    0x14(%edi),%edx
   10270:	89 f0                	mov    %esi,%eax
   10272:	29 d0                	sub    %edx,%eax
   10274:	05 e4 00 00 00       	add    $0xe4,%eax
   10279:	3b 47 20             	cmp    0x20(%edi),%eax
   1027c:	0f 87 bf 01 00 00    	ja     10441 <trickles_sendv_impl+0x301>
   10282:	8b 46 0c             	mov    0xc(%esi),%eax
   10285:	83 f8 01             	cmp    $0x1,%eax
   10288:	0f 84 23 01 00 00    	je     103b1 <trickles_sendv_impl+0x271>
   1028e:	83 f8 04             	cmp    $0x4,%eax
   10291:	0f 84 1a 01 00 00    	je     103b1 <trickles_sendv_impl+0x271>
   10297:	89 f6                	mov    %esi,%esi
   10299:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
		printk("bad minisocket %d %d\n", !IS_TRICKLES_SOCK_ADDR(tp,msk), !(VALID_MSK_CTL(msk)));
   102a0:	31 d2                	xor    %edx,%edx
   102a2:	83 f8 01             	cmp    $0x1,%eax
   102a5:	74 0b                	je     102b2 <trickles_sendv_impl+0x172>
   102a7:	83 f8 04             	cmp    $0x4,%eax
   102aa:	b8 01 00 00 00       	mov    $0x1,%eax
   102af:	0f 45 d0             	cmovne %eax,%edx
   102b2:	89 54 24 08          	mov    %edx,0x8(%esp,1)
   102b6:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   102b9:	b9 3f 82 fb 08       	mov    $0x8fb823f,%ecx
   102be:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
   102c5:	8b ba cc 01 00 00    	mov    0x1cc(%edx),%edi
   102cb:	89 f2                	mov    %esi,%edx
   102cd:	8b 47 0c             	mov    0xc(%edi),%eax
   102d0:	29 c2                	sub    %eax,%edx
   102d2:	89 55 d0             	mov    %edx,0xffffffd0(%ebp)
   102d5:	c1 ea 02             	shr    $0x2,%edx
   102d8:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   102db:	89 d0                	mov    %edx,%eax
   102dd:	f7 e1                	mul    %ecx
   102df:	d1 ea                	shr    %edx
   102e1:	69 d2 e4 00 00 00    	imul   $0xe4,%edx,%edx
   102e7:	39 55 d0             	cmp    %edx,0xffffffd0(%ebp)
   102ea:	75 24                	jne    10310 <trickles_sendv_impl+0x1d0>
   102ec:	3b 75 d4             	cmp    0xffffffd4(%ebp),%esi
   102ef:	72 1f                	jb     10310 <trickles_sendv_impl+0x1d0>
   102f1:	8b 47 14             	mov    0x14(%edi),%eax
   102f4:	29 c6                	sub    %eax,%esi
   102f6:	8d 86 e4 00 00 00    	lea    0xe4(%esi),%eax
   102fc:	3b 47 20             	cmp    0x20(%edi),%eax
   102ff:	76 16                	jbe    10317 <trickles_sendv_impl+0x1d7>
   10301:	eb 0d                	jmp    10310 <trickles_sendv_impl+0x1d0>
   10303:	90                   	nop    
   10304:	90                   	nop    
   10305:	90                   	nop    
   10306:	90                   	nop    
   10307:	90                   	nop    
   10308:	90                   	nop    
   10309:	90                   	nop    
   1030a:	90                   	nop    
   1030b:	90                   	nop    
   1030c:	90                   	nop    
   1030d:	90                   	nop    
   1030e:	90                   	nop    
   1030f:	90                   	nop    
   10310:	c7 45 d8 01 00 00 00 	movl   $0x1,0xffffffd8(%ebp)
   10317:	c7 04 24 c6 08 00 00 	movl   $0x8c6,(%esp,1)
   1031e:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   10321:	89 54 24 04          	mov    %edx,0x4(%esp,1)
   10325:	e8 fc ff ff ff       	call   10326 <trickles_sendv_impl+0x1e6>
		err = -EINVAL;
   1032a:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
		release_sock(sk);
   10331:	ff 05 08 00 00 00    	incl   0x8
   10337:	8b bb a8 00 00 00    	mov    0xa8(%ebx),%edi
   1033d:	85 ff                	test   %edi,%edi
   1033f:	75 66                	jne    103a7 <trickles_sendv_impl+0x267>
   10341:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   10348:	8d 43 30             	lea    0x30(%ebx),%eax
   1034b:	39 43 30             	cmp    %eax,0x30(%ebx)
   1034e:	75 46                	jne    10396 <trickles_sendv_impl+0x256>
   10350:	ba 08 00 00 00       	mov    $0x8,%edx
   10355:	a1 08 00 00 00       	mov    0x8,%eax
   1035a:	48                   	dec    %eax
   1035b:	85 c0                	test   %eax,%eax
   1035d:	a3 08 00 00 00       	mov    %eax,0x8
   10362:	75 0a                	jne    1036e <trickles_sendv_impl+0x22e>
   10364:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   10368:	0f 85 84 2d 00 00    	jne    130f2 <.text.lock.tmalloc+0x120>
   1036e:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   10371:	8b 42 14             	mov    0x14(%edx),%eax
   10374:	e8 fc ff ff ff       	call   10375 <trickles_sendv_impl+0x235>
		goto out_put;
	}

	free_trickles_msk(sk,msk);
	msk->byteNum = byteNum;

	err = trickles_do_sendmsg_tiov(sk,msk,tiov,tiovlen);

	release_sock(sk);

out_put:	
	sockfd_put(sock);
 out_freeiov:
	if(tiov_size > 0)
   10379:	8b 5d e0             	mov    0xffffffe0(%ebp),%ebx
   1037c:	85 db                	test   %ebx,%ebx
   1037e:	7e 0b                	jle    1038b <trickles_sendv_impl+0x24b>
		kfree(tiov);
   10380:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   10383:	89 04 24             	mov    %eax,(%esp,1)
   10386:	e8 fc ff ff ff       	call   10387 <trickles_sendv_impl+0x247>
 out:
	return err;
   1038b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
}
   1038e:	83 c4 34             	add    $0x34,%esp
   10391:	5b                   	pop    %ebx
   10392:	5e                   	pop    %esi
   10393:	5f                   	pop    %edi
   10394:	5d                   	pop    %ebp
   10395:	c3                   	ret    
   10396:	b9 01 00 00 00       	mov    $0x1,%ecx
   1039b:	ba 03 00 00 00       	mov    $0x3,%edx
   103a0:	e8 fc ff ff ff       	call   103a1 <trickles_sendv_impl+0x261>
   103a5:	eb a9                	jmp    10350 <trickles_sendv_impl+0x210>
   103a7:	89 1c 24             	mov    %ebx,(%esp,1)
   103aa:	e8 fc ff ff ff       	call   103ab <trickles_sendv_impl+0x26b>
   103af:	eb 90                	jmp    10341 <trickles_sendv_impl+0x201>
   103b1:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   103b5:	89 1c 24             	mov    %ebx,(%esp,1)
   103b8:	e8 43 d6 ff ff       	call   da00 <free_trickles_msk>
   103bd:	8b 45 10             	mov    0x10(%ebp),%eax
   103c0:	89 46 30             	mov    %eax,0x30(%esi)
   103c3:	8b 45 18             	mov    0x18(%ebp),%eax
   103c6:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   103ca:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   103cd:	89 1c 24             	mov    %ebx,(%esp,1)
   103d0:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   103d4:	89 54 24 08          	mov    %edx,0x8(%esp,1)
   103d8:	e8 d3 e0 ff ff       	call   e4b0 <trickles_do_sendmsg_tiov>
   103dd:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   103e0:	ff 05 08 00 00 00    	incl   0x8
   103e6:	8b b3 a8 00 00 00    	mov    0xa8(%ebx),%esi
   103ec:	85 f6                	test   %esi,%esi
   103ee:	75 47                	jne    10437 <trickles_sendv_impl+0x2f7>
   103f0:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   103f7:	8d 43 30             	lea    0x30(%ebx),%eax
   103fa:	39 43 30             	cmp    %eax,0x30(%ebx)
   103fd:	75 27                	jne    10426 <trickles_sendv_impl+0x2e6>
   103ff:	ba 08 00 00 00       	mov    $0x8,%edx
   10404:	a1 08 00 00 00       	mov    0x8,%eax
   10409:	48                   	dec    %eax
   1040a:	85 c0                	test   %eax,%eax
   1040c:	a3 08 00 00 00       	mov    %eax,0x8
   10411:	0f 85 57 ff ff ff    	jne    1036e <trickles_sendv_impl+0x22e>
   10417:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   1041b:	0f 85 e1 2c 00 00    	jne    13102 <.text.lock.tmalloc+0x130>
   10421:	e9 48 ff ff ff       	jmp    1036e <trickles_sendv_impl+0x22e>
   10426:	b9 01 00 00 00       	mov    $0x1,%ecx
   1042b:	ba 03 00 00 00       	mov    $0x3,%edx
   10430:	e8 fc ff ff ff       	call   10431 <trickles_sendv_impl+0x2f1>
   10435:	eb c8                	jmp    103ff <trickles_sendv_impl+0x2bf>
   10437:	89 1c 24             	mov    %ebx,(%esp,1)
   1043a:	e8 fc ff ff ff       	call   1043b <trickles_sendv_impl+0x2fb>
   1043f:	eb af                	jmp    103f0 <trickles_sendv_impl+0x2b0>
   10441:	8b 46 0c             	mov    0xc(%esi),%eax
   10444:	e9 57 fe ff ff       	jmp    102a0 <trickles_sendv_impl+0x160>
   10449:	c7 04 24 dc 08 00 00 	movl   $0x8dc,(%esp,1)
   10450:	e8 fc ff ff ff       	call   10451 <trickles_sendv_impl+0x311>
   10455:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
   1045c:	ff 05 08 00 00 00    	incl   0x8
   10462:	8b 8b a8 00 00 00    	mov    0xa8(%ebx),%ecx
   10468:	85 c9                	test   %ecx,%ecx
   1046a:	75 47                	jne    104b3 <trickles_sendv_impl+0x373>
   1046c:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   10473:	8d 43 30             	lea    0x30(%ebx),%eax
   10476:	39 43 30             	cmp    %eax,0x30(%ebx)
   10479:	75 27                	jne    104a2 <trickles_sendv_impl+0x362>
   1047b:	ba 08 00 00 00       	mov    $0x8,%edx
   10480:	a1 08 00 00 00       	mov    0x8,%eax
   10485:	48                   	dec    %eax
   10486:	85 c0                	test   %eax,%eax
   10488:	a3 08 00 00 00       	mov    %eax,0x8
   1048d:	0f 85 db fe ff ff    	jne    1036e <trickles_sendv_impl+0x22e>
   10493:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   10497:	0f 85 75 2c 00 00    	jne    13112 <.text.lock.tmalloc+0x140>
   1049d:	e9 cc fe ff ff       	jmp    1036e <trickles_sendv_impl+0x22e>
   104a2:	b9 01 00 00 00       	mov    $0x1,%ecx
   104a7:	ba 03 00 00 00       	mov    $0x3,%edx
   104ac:	e8 fc ff ff ff       	call   104ad <trickles_sendv_impl+0x36d>
   104b1:	eb c8                	jmp    1047b <trickles_sendv_impl+0x33b>
   104b3:	89 1c 24             	mov    %ebx,(%esp,1)
   104b6:	e8 fc ff ff ff       	call   104b7 <trickles_sendv_impl+0x377>
   104bb:	eb af                	jmp    1046c <trickles_sendv_impl+0x32c>
   104bd:	89 1c 24             	mov    %ebx,(%esp,1)
   104c0:	e8 fc ff ff ff       	call   104c1 <trickles_sendv_impl+0x381>
   104c5:	e9 31 fd ff ff       	jmp    101fb <trickles_sendv_impl+0xbb>
   104ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   104d0:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
   104d7:	e9 e5 fc ff ff       	jmp    101c1 <trickles_sendv_impl+0x81>
   104dc:	8d 74 26 00          	lea    0x0(%esi,1),%esi

000104e0 <skb_fillpage_actor>:

// copied from filemap.c
static int skb_fillpage_actor(read_descriptor_t * desc, struct page *page, unsigned long offset , unsigned long size)
{
   104e0:	55                   	push   %ebp
   104e1:	89 e5                	mov    %esp,%ebp
   104e3:	83 ec 20             	sub    $0x20,%esp
   104e6:	89 5d f4             	mov    %ebx,0xfffffff4(%ebp)
	ssize_t written;
	unsigned long count = desc->count;
   104e9:	8b 45 08             	mov    0x8(%ebp),%eax
   104ec:	8b 5d 14             	mov    0x14(%ebp),%ebx
   104ef:	89 75 f8             	mov    %esi,0xfffffff8(%ebp)
   104f2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   104f5:	89 7d fc             	mov    %edi,0xfffffffc(%ebp)
	struct sk_buff *skb = (struct sk_buff *) desc->buf;
   104f8:	8b 70 08             	mov    0x8(%eax),%esi
   104fb:	8b 78 04             	mov    0x4(%eax),%edi
	int i = skb_shinfo(skb)->nr_frags;
   104fe:	8b 86 9c 00 00 00    	mov    0x9c(%esi),%eax

	if (size > count)
   10504:	39 fb                	cmp    %edi,%ebx
   10506:	0f 47 df             	cmova  %edi,%ebx
   10509:	8b 50 04             	mov    0x4(%eax),%edx
		size = count;
	
	if(i >= MAX_SKB_FRAGS) {
   1050c:	83 fa 05             	cmp    $0x5,%edx
   1050f:	7e 3f                	jle    10550 <skb_fillpage_actor+0x70>
		printk("too many fragments\n");
   10511:	c7 04 24 f7 09 00 00 	movl   $0x9f7,(%esp,1)
   10518:	e8 fc ff ff ff       	call   10519 <skb_fillpage_actor+0x39>
		written = -EINVAL;
   1051d:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	} else {
		get_page(page);
		fill_page_desc(skb,i,page,offset,size);
		written = size;
		skb->len += size;
		skb->data_len += size;
	}
	if (written < 0) {
   10522:	85 c0                	test   %eax,%eax
   10524:	78 1a                	js     10540 <skb_fillpage_actor+0x60>
		desc->error = written;
		written = 0;
	}
	desc->count = count - written;
   10526:	8b 55 08             	mov    0x8(%ebp),%edx
   10529:	29 c7                	sub    %eax,%edi
	desc->written += written;
   1052b:	01 02                	add    %eax,(%edx)
   1052d:	89 7a 04             	mov    %edi,0x4(%edx)
	return written;
}
   10530:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
   10533:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
   10536:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
   10539:	89 ec                	mov    %ebp,%esp
   1053b:	5d                   	pop    %ebp
   1053c:	c3                   	ret    
   1053d:	8d 76 00             	lea    0x0(%esi),%esi
   10540:	8b 55 08             	mov    0x8(%ebp),%edx
   10543:	89 42 0c             	mov    %eax,0xc(%edx)
   10546:	31 c0                	xor    %eax,%eax
   10548:	eb dc                	jmp    10526 <skb_fillpage_actor+0x46>
   1054a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 * useful range of an atomic_t is only 24 bits.
 */ 
static __inline__ void atomic_inc(atomic_t *v)
{
	__asm__ __volatile__(
   10550:	ff 41 14             	incl   0x14(%ecx)
   10553:	8b 45 10             	mov    0x10(%ebp),%eax
   10556:	89 5c 24 10          	mov    %ebx,0x10(%esp,1)
   1055a:	89 4c 24 08          	mov    %ecx,0x8(%esp,1)
   1055e:	89 54 24 04          	mov    %edx,0x4(%esp,1)
   10562:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   10566:	89 34 24             	mov    %esi,(%esp,1)
   10569:	e8 f2 d9 ff ff       	call   df60 <fill_page_desc>
   1056e:	89 d8                	mov    %ebx,%eax
   10570:	01 5e 70             	add    %ebx,0x70(%esi)
   10573:	01 5e 74             	add    %ebx,0x74(%esi)
   10576:	eb aa                	jmp    10522 <skb_fillpage_actor+0x42>
   10578:	90                   	nop    
   10579:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi

00010580 <file_insertpages>:

/* Insert file pages into sk_buff */
static ssize_t file_insertpages(struct sk_buff *skb, int in_fd, loff_t offset, size_t count)
{
   10580:	55                   	push   %ebp
   10581:	89 e5                	mov    %esp,%ebp
   10583:	83 ec 3c             	sub    $0x3c,%esp
   10586:	89 5d f4             	mov    %ebx,0xfffffff4(%ebp)
   10589:	8b 55 10             	mov    0x10(%ebp),%edx
   1058c:	8b 4d 14             	mov    0x14(%ebp),%ecx
   1058f:	89 75 f8             	mov    %esi,0xfffffff8(%ebp)
   10592:	8b 45 0c             	mov    0xc(%ebp),%eax
	ssize_t retval;
	struct file * in_file;
	struct inode * in_inode;

	/*
	 * Get input file, and verify that it is ok..
	 */
	retval = -EBADF;
   10595:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
   1059a:	89 7d fc             	mov    %edi,0xfffffffc(%ebp)
   1059d:	89 55 dc             	mov    %edx,0xffffffdc(%ebp)
   105a0:	89 4d e0             	mov    %ecx,0xffffffe0(%ebp)
	in_file = fget(in_fd);
   105a3:	e8 fc ff ff ff       	call   105a4 <file_insertpages+0x24>
	if (!in_file)
   105a8:	85 c0                	test   %eax,%eax
   105aa:	89 c3                	mov    %eax,%ebx
   105ac:	74 79                	je     10627 <file_insertpages+0xa7>
		goto out;
	if (!(in_file->f_mode & FMODE_READ))
   105ae:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
   105b2:	83 e0 01             	and    $0x1,%eax
   105b5:	66 85 c0             	test   %ax,%ax
   105b8:	74 66                	je     10620 <file_insertpages+0xa0>
		goto fput_in;
	retval = -EINVAL;
	in_inode = in_file->f_dentry->d_inode;
   105ba:	8b 43 08             	mov    0x8(%ebx),%eax
   105bd:	be ea ff ff ff       	mov    $0xffffffea,%esi
   105c2:	8b 50 08             	mov    0x8(%eax),%edx
	if (!in_inode)
   105c5:	85 d2                	test   %edx,%edx
   105c7:	74 57                	je     10620 <file_insertpages+0xa0>
		goto fput_in;
	if (!in_inode->i_mapping->a_ops->readpage)
   105c9:	8b 82 b0 00 00 00    	mov    0xb0(%edx),%eax
   105cf:	8b 40 1c             	mov    0x1c(%eax),%eax
   105d2:	8b 40 04             	mov    0x4(%eax),%eax
   105d5:	85 c0                	test   %eax,%eax
   105d7:	74 47                	je     10620 <file_insertpages+0xa0>
static inline int locks_verify_area(int read_write, struct inode *inode,
				    struct file *filp, loff_t offset,
				    size_t count)
{
	if (inode->i_flock && MANDATORY_LOCK(inode))
   105d9:	8b 82 ac 00 00 00    	mov    0xac(%edx),%eax
   105df:	8b 73 20             	mov    0x20(%ebx),%esi
   105e2:	8b 7b 24             	mov    0x24(%ebx),%edi
   105e5:	85 c0                	test   %eax,%eax
   105e7:	74 1b                	je     10604 <file_insertpages+0x84>
   105e9:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
   105ef:	f6 40 2c 40          	testb  $0x40,0x2c(%eax)
   105f3:	74 0f                	je     10604 <file_insertpages+0x84>
   105f5:	0f b7 42 32          	movzwl 0x32(%edx),%eax
   105f9:	25 08 04 00 00       	and    $0x408,%eax
   105fe:	66 3d 00 04          	cmp    $0x400,%ax
   10602:	74 76                	je     1067a <file_insertpages+0xfa>
   10604:	31 c0                	xor    %eax,%eax
		goto fput_in;
	retval = locks_verify_area(FLOCK_VERIFY_READ, in_inode, in_file, in_file->f_pos, count);
	if (retval)
   10606:	85 c0                	test   %eax,%eax

static inline int locks_verify_area(int read_write, struct inode *inode,
				    struct file *filp, loff_t offset,
				    size_t count)
{
   10608:	89 c6                	mov    %eax,%esi
   1060a:	75 14                	jne    10620 <file_insertpages+0xa0>
		goto fput_in;

	retval = 0;
	if (count) {
   1060c:	8b 45 18             	mov    0x18(%ebp),%eax
   1060f:	85 c0                	test   %eax,%eax
   10611:	75 23                	jne    10636 <file_insertpages+0xb6>
   10613:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   10619:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
		read_descriptor_t desc;
		
		desc.written = 0;
		desc.count = count;
		desc.buf = (char *) skb;
		desc.error = 0;
		do_generic_file_read(in_file, &offset, &desc, skb_fillpage_actor);

		retval = desc.written;
		if (!retval)
			retval = desc.error;
	}

fput_in:
	fput(in_file);
   10620:	89 d8                	mov    %ebx,%eax
   10622:	e8 fc ff ff ff       	call   10623 <file_insertpages+0xa3>
out:
	return retval;
}
   10627:	89 f0                	mov    %esi,%eax
   10629:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
   1062c:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
   1062f:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
   10632:	89 ec                	mov    %ebp,%esp
   10634:	5d                   	pop    %ebp
   10635:	c3                   	ret    
   10636:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
   1063d:	8b 45 08             	mov    0x8(%ebp),%eax
   10640:	8b 55 18             	mov    0x18(%ebp),%edx
   10643:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
   1064a:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1064d:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   10650:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   10654:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   10657:	89 55 e8             	mov    %edx,0xffffffe8(%ebp)
   1065a:	c7 44 24 0c e0 04 01 	movl   $0x104e0,0xc(%esp,1)
   10661:	00 
   10662:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10666:	89 1c 24             	mov    %ebx,(%esp,1)
   10669:	e8 fc ff ff ff       	call   1066a <file_insertpages+0xea>
   1066e:	8b 75 e4             	mov    0xffffffe4(%ebp),%esi
   10671:	85 f6                	test   %esi,%esi
   10673:	75 ab                	jne    10620 <file_insertpages+0xa0>
   10675:	8b 75 f0             	mov    0xfffffff0(%ebp),%esi
   10678:	eb a6                	jmp    10620 <file_insertpages+0xa0>
   1067a:	89 74 24 0c          	mov    %esi,0xc(%esp,1)
   1067e:	8b 45 18             	mov    0x18(%ebp),%eax
   10681:	89 7c 24 10          	mov    %edi,0x10(%esp,1)
   10685:	89 5c 24 08          	mov    %ebx,0x8(%esp,1)
   10689:	89 44 24 14          	mov    %eax,0x14(%esp,1)
   1068d:	89 54 24 04          	mov    %edx,0x4(%esp,1)
   10691:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp,1)
   10698:	e8 fc ff ff ff       	call   10699 <file_insertpages+0x119>
   1069d:	e9 64 ff ff ff       	jmp    10606 <file_insertpages+0x86>
   106a2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
   106a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

000106b0 <fiov_handler>:

/* same structure as iov_handler */
static inline int fiov_handler(struct cminisock *msk, struct fiovec *fiov, int fiovlen) { 
   106b0:	55                   	push   %ebp
   106b1:	89 e5                	mov    %esp,%ebp
   106b3:	57                   	push   %edi
   106b4:	56                   	push   %esi
   106b5:	53                   	push   %ebx
   106b6:	83 ec 4c             	sub    $0x4c,%esp
	int numDataPackets = 0;
   106b9:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
	int i, totallen = 0, fiov_pos = 0, fiov_offs = 0;
	struct cminisock_packet *pkts;
	int rval = 0;
	struct sk_buff **skbs = 
   106c0:	8b 55 08             	mov    0x8(%ebp),%edx
   106c3:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
   106ca:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
   106d1:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
   106d8:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
   106df:	c7 44 24 04 d0 01 00 	movl   $0x1d0,0x4(%esp,1)
   106e6:	00 
   106e7:	8b 82 dc 00 00 00    	mov    0xdc(%edx),%eax
   106ed:	c1 e0 02             	shl    $0x2,%eax
   106f0:	89 04 24             	mov    %eax,(%esp,1)
   106f3:	e8 fc ff ff ff       	call   106f4 <fiov_handler+0x44>
   106f8:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
		kmalloc(sizeof(struct sk_buff *) * msk->num_packets, GFP_USER), 
		*skb;

	if(skbs == NULL) {
   106fb:	85 c0                	test   %eax,%eax
   106fd:	0f 84 de 02 00 00    	je     109e1 <fiov_handler+0x331>
		goto out;
	}
	pkts = msk->packets;
   10703:	8b 4d 08             	mov    0x8(%ebp),%ecx

	pkts[0].byteNum = msk->byteNum;
   10706:	8b 5d 08             	mov    0x8(%ebp),%ebx
   10709:	8b 89 e0 00 00 00    	mov    0xe0(%ecx),%ecx
   1070f:	89 4d dc             	mov    %ecx,0xffffffdc(%ebp)
   10712:	8b 43 30             	mov    0x30(%ebx),%eax
   10715:	89 41 0c             	mov    %eax,0xc(%ecx)
	for(i=0; i < fiovlen; i++) {
   10718:	8b 45 10             	mov    0x10(%ebp),%eax
   1071b:	39 45 d8             	cmp    %eax,0xffffffd8(%ebp)
   1071e:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
   10725:	7d 24                	jge    1074b <fiov_handler+0x9b>
   10727:	89 f6                	mov    %esi,%esi
   10729:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
		totallen += fiov[i].len;
   10730:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   10733:	8b 55 0c             	mov    0xc(%ebp),%edx
   10736:	8b 4d 10             	mov    0x10(%ebp),%ecx
   10739:	c1 e0 04             	shl    $0x4,%eax
   1073c:	8b 54 02 0c          	mov    0xc(%edx,%eax,1),%edx
   10740:	ff 45 ec             	incl   0xffffffec(%ebp)
   10743:	01 55 e8             	add    %edx,0xffffffe8(%ebp)
   10746:	39 4d ec             	cmp    %ecx,0xffffffec(%ebp)
   10749:	7c e5                	jl     10730 <fiov_handler+0x80>
	}
	for(i=0; i < msk->num_packets; i++) {
   1074b:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
   10752:	8b 45 08             	mov    0x8(%ebp),%eax
   10755:	31 db                	xor    %ebx,%ebx
   10757:	3b 98 dc 00 00 00    	cmp    0xdc(%eax),%ebx
   1075d:	0f 8d d9 01 00 00    	jge    1093c <fiov_handler+0x28c>
		int pkt_remain;
		int short_pkt = 0;
		int copying = 1; /* initial state: allow copies. After first sendfile() request, can no longer copy */
   10763:	c7 45 d0 01 00 00 00 	movl   $0x1,0xffffffd0(%ebp)

		if(i >= 1) {
   1076a:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
   1076d:	85 db                	test   %ebx,%ebx
   1076f:	7e 1a                	jle    1078b <fiov_handler+0xdb>
			pkts[i].byteNum = pkts[i-1].byteNum + pkts[i-1].len;
   10771:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
   10774:	8b 5d dc             	mov    0xffffffdc(%ebp),%ebx
   10777:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
   1077a:	c1 e2 03             	shl    $0x3,%edx
   1077d:	8b 44 1a e4          	mov    0xffffffe4(%edx,%ebx,1),%eax
   10781:	8b 4c 1a e0          	mov    0xffffffe0(%edx,%ebx,1),%ecx
   10785:	01 c8                	add    %ecx,%eax
   10787:	89 44 13 0c          	mov    %eax,0xc(%ebx,%edx,1)
		}
		if(pkts[i].len > totallen) {
   1078b:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   1078e:	8b 4d dc             	mov    0xffffffdc(%ebp),%ecx
   10791:	8d 04 92             	lea    (%edx,%edx,4),%eax
   10794:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
   1079b:	8b 44 19 08          	mov    0x8(%ecx,%ebx,1),%eax
			short_pkt = 1;
		}
		pkt_remain = pkts[i].len = MIN(pkts[i].len, totallen);
   1079f:	39 45 e8             	cmp    %eax,0xffffffe8(%ebp)
   107a2:	0f 46 45 e8          	cmovbe 0xffffffe8(%ebp),%eax
		numDataPackets = i+1;
   107a6:	42                   	inc    %edx
   107a7:	89 c7                	mov    %eax,%edi
   107a9:	89 44 19 08          	mov    %eax,0x8(%ecx,%ebx,1)
   107ad:	89 55 f0             	mov    %edx,0xfffffff0(%ebp)
		skb = skbs[i] = alloc_skb(MAX_TCP_HEADER + MAX_TRICKLES_HDR_LEN + pkts[i].ucontLen + pkts[i].len, GFP_KERNEL);
   107b0:	8b 44 19 14          	mov    0x14(%ecx,%ebx,1),%eax
   107b4:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
   107bb:	00 
   107bc:	05 4e 03 00 00       	add    $0x34e,%eax
   107c1:	8d 84 07 a0 00 00 00 	lea    0xa0(%edi,%eax,1),%eax
   107c8:	89 04 24             	mov    %eax,(%esp,1)
   107cb:	e8 fc ff ff ff       	call   107cc <fiov_handler+0x11c>
   107d0:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   107d3:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
   107d6:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
   107d9:	89 04 91             	mov    %eax,(%ecx,%edx,4)
		if(skb == NULL) {
   107dc:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
   107df:	85 c0                	test   %eax,%eax
   107e1:	0f 84 b3 03 00 00    	je     10b9a <fiov_handler+0x4ea>
#endif

extern atomic_t g_device_skb;
extern atomic_t g_device_skb_num;
extern atomic_t g_other_skb;
   107e7:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   107ea:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
   107ed:	8b 44 1a 14          	mov    0x14(%edx,%ebx,1),%eax
			printk("could not allocate skb\n");
			goto out;
		}
		skb_reserve(skb, MAX_TCP_HEADER + MAX_TRICKLES_HDR_LEN + pkts[i].ucontLen);

		skb->csum = 0;
   107f1:	c7 41 78 00 00 00 00 	movl   $0x0,0x78(%ecx)
		skb->ip_summed = CHECKSUM_HW;
   107f8:	c6 41 7f 01          	movb   $0x1,0x7f(%ecx)
#endif

extern atomic_t g_device_skb;
extern atomic_t g_device_skb_num;
extern atomic_t g_other_skb;
   107fc:	05 ee 03 00 00       	add    $0x3ee,%eax
   10801:	01 81 94 00 00 00    	add    %eax,0x94(%ecx)
   10807:	01 81 98 00 00 00    	add    %eax,0x98(%ecx)
		while(fiov_pos < fiovlen) {
   1080d:	8b 5d 10             	mov    0x10(%ebp),%ebx
   10810:	39 5d e4             	cmp    %ebx,0xffffffe4(%ebp)
   10813:	0f 8d a1 00 00 00    	jge    108ba <fiov_handler+0x20a>
   10819:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1081c:	8b 55 0c             	mov    0xc(%ebp),%edx
   1081f:	c1 e0 04             	shl    $0x4,%eax
   10822:	8d 34 02             	lea    (%edx,%eax,1),%esi
   10825:	8d 74 26 00          	lea    0x0(%esi,1),%esi
   10829:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
			int amt = MIN(pkt_remain, fiov[fiov_pos].len - fiov_offs);
   10830:	8b 5e 0c             	mov    0xc(%esi),%ebx
   10833:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
			int err = 0;
			//printk("iov copy loop, copying %d\n", amt);

			if(fiov[fiov_pos].fd == -2) {
   10836:	8b 0e                	mov    (%esi),%ecx
   10838:	29 c3                	sub    %eax,%ebx
   1083a:	39 fb                	cmp    %edi,%ebx
   1083c:	0f 4f df             	cmovg  %edi,%ebx
   1083f:	83 f9 fe             	cmp    $0xfffffffe,%ecx
   10842:	0f 84 6e 02 00 00    	je     10ab6 <fiov_handler+0x406>
				if(!copying) {
					printk("cannot copy; after first page fragment of packet\n");
					kfree_skb(skb);
					goto out;
				}
				/* not 64 bit safe */
				if(fiov[fiov_pos].offset + fiov_offs >= (0x1ULL << 32ULL)) {
					printk("trickles does not handle file offsets > 32 bits\n");
				}
				char *src = (char*)fiov[fiov_pos].offset + fiov_offs;
				err = skb_add_data(skb,src,amt);
				if(err) {
					printk("error while csum/copy, base = %p amt = %d\n", src, amt);
					kfree_skb(skb);
					rval = -EINVAL;
					goto out;
				}
			} else {
				int res;
				copying = 0;
   10848:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
				res = file_insertpages(skb,fiov[fiov_pos].fd, fiov[fiov_pos].offset + fiov_offs, amt);
   1084f:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   10852:	89 5c 24 10          	mov    %ebx,0x10(%esp,1)
   10856:	99                   	cltd   
   10857:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
   1085a:	89 55 c4             	mov    %edx,0xffffffc4(%ebp)
   1085d:	8b 46 04             	mov    0x4(%esi),%eax
   10860:	8b 56 08             	mov    0x8(%esi),%edx
   10863:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
   10867:	01 45 c0             	add    %eax,0xffffffc0(%ebp)
   1086a:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
   1086d:	11 55 c4             	adc    %edx,0xffffffc4(%ebp)
   10870:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   10874:	8b 55 c4             	mov    0xffffffc4(%ebp),%edx
   10877:	89 54 24 0c          	mov    %edx,0xc(%esp,1)
   1087b:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
   1087e:	89 14 24             	mov    %edx,(%esp,1)
   10881:	e8 fa fc ff ff       	call   10580 <file_insertpages>
				if(res < 0) {
   10886:	85 c0                	test   %eax,%eax
   10888:	0f 88 19 02 00 00    	js     10aa7 <fiov_handler+0x3f7>
					rval = res;
					printk("could not insert pages\n");
					goto out;
				}
				if(res != amt) {
   1088e:	39 d8                	cmp    %ebx,%eax
   10890:	0f 85 02 02 00 00    	jne    10a98 <fiov_handler+0x3e8>
					rval = res;
					printk("insufficient file data for insertion\n");
					goto out;
				}
			}
			//printk("iov[%d].iov_base (%p) + iov_offs (%u) = %p, data = %p, amt = %d, skb->csum = %x, tail = %p, tailroom = %u, iov_len = %u, &err=%p\n", iov_pos, iov[iov_pos].iov_base, iov_offs, iov[iov_pos].iov_base + iov_offs, data, amt, skb->csum, skb->tail, skb_tailroom(skb), iov[iov_pos].iov_len, &err);
			if(err) {
				printk("error while csum/copy\n");
				kfree_skb(skb);
				goto out;
			}

			totallen -= amt;
			pkt_remain -= amt;
			fiov_offs += amt;
   10896:	01 5d e0             	add    %ebx,0xffffffe0(%ebp)
   10899:	29 df                	sub    %ebx,%edi
   1089b:	29 5d e8             	sub    %ebx,0xffffffe8(%ebp)
			if(fiov_offs == fiov[fiov_pos].len) {
   1089e:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
   108a1:	3b 4e 0c             	cmp    0xc(%esi),%ecx
   108a4:	0f 84 dc 01 00 00    	je     10a86 <fiov_handler+0x3d6>
				fiov_offs = 0;
				fiov_pos++;
			}
			if(pkt_remain == 0) break;
   108aa:	85 ff                	test   %edi,%edi
   108ac:	74 14                	je     108c2 <fiov_handler+0x212>
   108ae:	8b 5d 10             	mov    0x10(%ebp),%ebx
   108b1:	39 5d e4             	cmp    %ebx,0xffffffe4(%ebp)
   108b4:	0f 8c 76 ff ff ff    	jl     10830 <fiov_handler+0x180>
		}
		BUG_TRAP(pkt_remain == 0);
   108ba:	85 ff                	test   %edi,%edi
   108bc:	0f 85 ab 01 00 00    	jne    10a6d <fiov_handler+0x3bd>

		if(userapi_pkt_spew) {
   108c2:	8b 35 00 00 00 00    	mov    0x0,%esi
   108c8:	85 f6                	test   %esi,%esi
   108ca:	0f 85 63 01 00 00    	jne    10a33 <fiov_handler+0x383>
			printk("sending pkts[%d] %u-%u\n", i, pkts[i].seq, pkts[i].seq + pkts[i].len);
		}
		// on last packet, set the tag to FIN
		if(totallen == 0 && 
   108d0:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   108d3:	85 c0                	test   %eax,%eax
   108d5:	75 39                	jne    10910 <fiov_handler+0x260>
   108d7:	8b 45 10             	mov    0x10(%ebp),%eax
   108da:	8b 55 0c             	mov    0xc(%ebp),%edx
   108dd:	c1 e0 04             	shl    $0x4,%eax
   108e0:	8d 4c 10 f0          	lea    0xfffffff0(%eax,%edx,1),%ecx
   108e4:	8b 51 08             	mov    0x8(%ecx),%edx
   108e7:	8b 41 04             	mov    0x4(%ecx),%eax
   108ea:	89 d3                	mov    %edx,%ebx
   108ec:	09 c3                	or     %eax,%ebx
   108ee:	75 20                	jne    10910 <fiov_handler+0x260>
   108f0:	8b 41 0c             	mov    0xc(%ecx),%eax
   108f3:	85 c0                	test   %eax,%eax
   108f5:	75 19                	jne    10910 <fiov_handler+0x260>
		   fiov[fiovlen-1].offset == 0 && fiov[fiovlen-1].len == 0) {
			msk->tag = FIN;
   108f7:	8b 45 08             	mov    0x8(%ebp),%eax
   108fa:	c7 40 10 02 00 00 00 	movl   $0x2,0x10(%eax)
   10901:	eb 0d                	jmp    10910 <fiov_handler+0x260>
   10903:	90                   	nop    
   10904:	90                   	nop    
   10905:	90                   	nop    
   10906:	90                   	nop    
   10907:	90                   	nop    
   10908:	90                   	nop    
   10909:	90                   	nop    
   1090a:	90                   	nop    
   1090b:	90                   	nop    
   1090c:	90                   	nop    
   1090d:	90                   	nop    
   1090e:	90                   	nop    
   1090f:	90                   	nop    
		}
		
		rval += pkts[i].len; // check how much data actually sent?
   10910:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   10913:	8b 4d dc             	mov    0xffffffdc(%ebp),%ecx
		if(totallen == 0) break;
   10916:	8b 7d e8             	mov    0xffffffe8(%ebp),%edi
   10919:	8d 04 92             	lea    (%edx,%edx,4),%eax
   1091c:	8b 4c c1 08          	mov    0x8(%ecx,%eax,8),%ecx
   10920:	01 4d d8             	add    %ecx,0xffffffd8(%ebp)
   10923:	85 ff                	test   %edi,%edi
   10925:	74 15                	je     1093c <fiov_handler+0x28c>
   10927:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
   1092a:	8b 45 08             	mov    0x8(%ebp),%eax
   1092d:	89 5d ec             	mov    %ebx,0xffffffec(%ebp)
   10930:	3b 98 dc 00 00 00    	cmp    0xdc(%eax),%ebx
   10936:	0f 8c 27 fe ff ff    	jl     10763 <fiov_handler+0xb3>
	}
	FINISH_TRANSMIT(msk, skbs, numDataPackets, NULL, 0, 0);
   1093c:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp,1)
   10943:	00 
   10944:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   10947:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
   1094a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp,1)
   10951:	00 
   10952:	8b 5d 08             	mov    0x8(%ebp),%ebx
   10955:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp,1)
   1095c:	00 
   1095d:	89 54 24 08          	mov    %edx,0x8(%esp,1)
   10961:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
   10965:	89 1c 24             	mov    %ebx,(%esp,1)
   10968:	e8 73 de ff ff       	call   e7e0 <finishTransmitHelper>
	// end code copied from iov_handler
	if(totallen > 0) {
   1096d:	8b 75 e8             	mov    0xffffffe8(%ebp),%esi
   10970:	85 f6                	test   %esi,%esi
   10972:	7e 6d                	jle    109e1 <fiov_handler+0x331>
		if(trickles_ratelimit())
   10974:	a1 00 00 00 00       	mov    0x0,%eax
   10979:	9c                   	pushf  
   1097a:	59                   	pop    %ecx
   1097b:	fa                   	cli    
   1097c:	89 c2                	mov    %eax,%edx
   1097e:	8b 1d 10 97 13 00    	mov    0x139710,%ebx
   10984:	8b 3d 4c 01 00 00    	mov    0x14c,%edi
   1098a:	a3 10 97 13 00       	mov    %eax,0x139710
   1098f:	29 da                	sub    %ebx,%edx
   10991:	01 fa                	add    %edi,%edx
   10993:	89 15 4c 01 00 00    	mov    %edx,0x14c
   10999:	81 fa 88 13 00 00    	cmp    $0x1388,%edx
   1099f:	76 10                	jbe    109b1 <fiov_handler+0x301>
   109a1:	be 88 13 00 00       	mov    $0x1388,%esi
   109a6:	ba 88 13 00 00       	mov    $0x1388,%edx
   109ab:	89 35 4c 01 00 00    	mov    %esi,0x14c
   109b1:	81 fa f3 01 00 00    	cmp    $0x1f3,%edx
   109b7:	76 6e                	jbe    10a27 <fiov_handler+0x377>
   109b9:	31 db                	xor    %ebx,%ebx
   109bb:	81 ea f4 01 00 00    	sub    $0x1f4,%edx
   109c1:	a1 14 97 13 00       	mov    0x139714,%eax
   109c6:	89 15 4c 01 00 00    	mov    %edx,0x14c
   109cc:	89 1d 14 97 13 00    	mov    %ebx,0x139714
   109d2:	51                   	push   %ecx
   109d3:	9d                   	popf   
   109d4:	85 c0                	test   %eax,%eax
   109d6:	75 2d                	jne    10a05 <fiov_handler+0x355>
   109d8:	b8 01 00 00 00       	mov    $0x1,%eax
   109dd:	85 c0                	test   %eax,%eax
   109df:	75 16                	jne    109f7 <fiov_handler+0x347>
			printk("too much data for downcall\n");
	}
 out:
	kfree(skbs);
   109e1:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   109e4:	89 04 24             	mov    %eax,(%esp,1)
   109e7:	e8 fc ff ff ff       	call   109e8 <fiov_handler+0x338>
	return rval;
}
   109ec:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   109ef:	83 c4 4c             	add    $0x4c,%esp
   109f2:	5b                   	pop    %ebx
   109f3:	5e                   	pop    %esi
   109f4:	5f                   	pop    %edi
   109f5:	5d                   	pop    %ebp
   109f6:	c3                   	ret    
   109f7:	c7 04 24 0b 0a 00 00 	movl   $0xa0b,(%esp,1)
   109fe:	e8 fc ff ff ff       	call   109ff <fiov_handler+0x34f>
   10a03:	eb dc                	jmp    109e1 <fiov_handler+0x331>
   10a05:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   10a09:	c7 44 24 08 ef 04 00 	movl   $0x4ef,0x8(%esp,1)
   10a10:	00 
   10a11:	c7 44 24 04 6c 08 00 	movl   $0x86c,0x4(%esp,1)
   10a18:	00 
   10a19:	c7 04 24 00 3c 00 00 	movl   $0x3c00,(%esp,1)
   10a20:	e8 fc ff ff ff       	call   10a21 <fiov_handler+0x371>
   10a25:	eb b1                	jmp    109d8 <fiov_handler+0x328>
   10a27:	ff 05 14 97 13 00    	incl   0x139714
   10a2d:	51                   	push   %ecx
   10a2e:	9d                   	popf   
   10a2f:	31 c0                	xor    %eax,%eax
   10a31:	eb aa                	jmp    109dd <fiov_handler+0x32d>
   10a33:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   10a36:	8b 4d dc             	mov    0xffffffdc(%ebp),%ecx
   10a39:	8d 04 92             	lea    (%edx,%edx,4),%eax
   10a3c:	c1 e0 03             	shl    $0x3,%eax
   10a3f:	8b 5c 01 04          	mov    0x4(%ecx,%eax,1),%ebx
   10a43:	8b 54 01 08          	mov    0x8(%ecx,%eax,1),%edx
   10a47:	01 da                	add    %ebx,%edx
   10a49:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
   10a4c:	89 54 24 0c          	mov    %edx,0xc(%esp,1)
   10a50:	8b 44 01 04          	mov    0x4(%ecx,%eax,1),%eax
   10a54:	c7 04 24 7f 08 00 00 	movl   $0x87f,(%esp,1)
   10a5b:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
   10a5f:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   10a63:	e8 fc ff ff ff       	call   10a64 <fiov_handler+0x3b4>
   10a68:	e9 63 fe ff ff       	jmp    108d0 <fiov_handler+0x220>
   10a6d:	c7 44 24 04 de 04 00 	movl   $0x4de,0x4(%esp,1)
   10a74:	00 
   10a75:	c7 04 24 40 3c 00 00 	movl   $0x3c40,(%esp,1)
   10a7c:	e8 fc ff ff ff       	call   10a7d <fiov_handler+0x3cd>
   10a81:	e9 3c fe ff ff       	jmp    108c2 <fiov_handler+0x212>
   10a86:	ff 45 e4             	incl   0xffffffe4(%ebp)
   10a89:	83 c6 10             	add    $0x10,%esi
   10a8c:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
   10a93:	e9 12 fe ff ff       	jmp    108aa <fiov_handler+0x1fa>
   10a98:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
   10a9b:	c7 04 24 e0 3f 00 00 	movl   $0x3fe0,(%esp,1)
   10aa2:	e9 57 ff ff ff       	jmp    109fe <fiov_handler+0x34e>
   10aa7:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
   10aaa:	c7 04 24 27 0a 00 00 	movl   $0xa27,(%esp,1)
   10ab1:	e9 48 ff ff ff       	jmp    109fe <fiov_handler+0x34e>
   10ab6:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   10ab9:	85 c0                	test   %eax,%eax
   10abb:	0f 84 a0 00 00 00    	je     10b61 <fiov_handler+0x4b1>
   10ac1:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   10ac4:	99                   	cltd   
   10ac5:	89 55 c4             	mov    %edx,0xffffffc4(%ebp)
   10ac8:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
   10acb:	8b 56 04             	mov    0x4(%esi),%edx
   10ace:	8b 4e 08             	mov    0x8(%esi),%ecx
   10ad1:	01 55 c0             	add    %edx,0xffffffc0(%ebp)
   10ad4:	11 4d c4             	adc    %ecx,0xffffffc4(%ebp)
   10ad7:	83 7d c4 00          	cmpl   $0x0,0xffffffc4(%ebp)
   10adb:	77 73                	ja     10b50 <fiov_handler+0x4a0>
   10add:	8b 46 04             	mov    0x4(%esi),%eax
   10ae0:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
   10ae3:	89 5c 24 08          	mov    %ebx,0x8(%esp,1)
   10ae7:	01 c1                	add    %eax,%ecx
   10ae9:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
   10aec:	89 4d c8             	mov    %ecx,0xffffffc8(%ebp)
   10aef:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
   10af3:	89 04 24             	mov    %eax,(%esp,1)
   10af6:	e8 b5 d4 ff ff       	call   dfb0 <skb_add_data>
   10afb:	85 c0                	test   %eax,%eax
   10afd:	0f 84 93 fd ff ff    	je     10896 <fiov_handler+0x1e6>
   10b03:	89 5c 24 08          	mov    %ebx,0x8(%esp,1)
   10b07:	8b 55 c8             	mov    0xffffffc8(%ebp),%edx
   10b0a:	c7 04 24 a0 3c 00 00 	movl   $0x3ca0,(%esp,1)
   10b11:	89 54 24 04          	mov    %edx,0x4(%esp,1)
   10b15:	e8 fc ff ff ff       	call   10b16 <fiov_handler+0x466>
 */
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
   10b1a:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
   10b1d:	8b 81 84 00 00 00    	mov    0x84(%ecx),%eax
   10b23:	48                   	dec    %eax
   10b24:	74 0d                	je     10b33 <fiov_handler+0x483>
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
	unsigned char c;

	__asm__ __volatile__(
   10b26:	ff 89 84 00 00 00    	decl   0x84(%ecx)
   10b2c:	0f 94 c0             	sete   %al
   10b2f:	84 c0                	test   %al,%al
   10b31:	74 0b                	je     10b3e <fiov_handler+0x48e>
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
		__kfree_skb(skb);
   10b33:	8b 5d cc             	mov    0xffffffcc(%ebp),%ebx
   10b36:	89 1c 24             	mov    %ebx,(%esp,1)
   10b39:	e8 fc ff ff ff       	call   10b3a <fiov_handler+0x48a>
   10b3e:	c7 45 d8 ea ff ff ff 	movl   $0xffffffea,0xffffffd8(%ebp)
   10b45:	e9 97 fe ff ff       	jmp    109e1 <fiov_handler+0x331>
   10b4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   10b50:	c7 04 24 20 40 00 00 	movl   $0x4020,(%esp,1)
   10b57:	e8 fc ff ff ff       	call   10b58 <fiov_handler+0x4a8>
   10b5c:	e9 7c ff ff ff       	jmp    10add <fiov_handler+0x42d>
   10b61:	c7 04 24 60 40 00 00 	movl   $0x4060,(%esp,1)
   10b68:	e8 fc ff ff ff       	call   10b69 <fiov_handler+0x4b9>
 */
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
   10b6d:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
   10b70:	8b 81 84 00 00 00    	mov    0x84(%ecx),%eax
   10b76:	48                   	dec    %eax
   10b77:	74 11                	je     10b8a <fiov_handler+0x4da>
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
	unsigned char c;

	__asm__ __volatile__(
   10b79:	ff 89 84 00 00 00    	decl   0x84(%ecx)
   10b7f:	0f 94 c0             	sete   %al
   10b82:	84 c0                	test   %al,%al
   10b84:	0f 84 57 fe ff ff    	je     109e1 <fiov_handler+0x331>
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
		__kfree_skb(skb);
   10b8a:	8b 5d cc             	mov    0xffffffcc(%ebp),%ebx
   10b8d:	89 1c 24             	mov    %ebx,(%esp,1)
   10b90:	e8 fc ff ff ff       	call   10b91 <fiov_handler+0x4e1>
   10b95:	e9 47 fe ff ff       	jmp    109e1 <fiov_handler+0x331>
   10b9a:	c7 04 24 54 08 00 00 	movl   $0x854,(%esp,1)
   10ba1:	e9 58 fe ff ff       	jmp    109fe <fiov_handler+0x34e>
   10ba6:	8d 76 00             	lea    0x0(%esi),%esi
   10ba9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00010bb0 <trickles_sendfilev_impl>:

int trickles_sendfilev_impl(int fd, struct cminisock *msk, unsigned byteNum, struct fiovec *user_fiov, int fiovlen) {
   10bb0:	55                   	push   %ebp
   10bb1:	89 e5                	mov    %esp,%ebp
   10bb3:	57                   	push   %edi
   10bb4:	56                   	push   %esi
   10bb5:	53                   	push   %ebx
   10bb6:	83 ec 30             	sub    $0x30,%esp
	struct socket *sock;
	struct sock *sk;
	struct tcp_opt *tp;
	int err;
	struct fiovec *fiov;

	err = -EINVAL;
   10bb9:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
   10bc0:	8b 75 0c             	mov    0xc(%ebp),%esi
	if (fiovlen < 0 || fiovlen > UIO_MAXIOV) {
   10bc3:	81 7d 18 00 04 00 00 	cmpl   $0x400,0x18(%ebp)
   10bca:	0f 87 1b 02 00 00    	ja     10deb <trickles_sendfilev_impl+0x23b>
		goto out;
	}
	{
		int fiov_size;
		err = -ENOMEM;
   10bd0:	c7 45 f0 f4 ff ff ff 	movl   $0xfffffff4,0xfffffff0(%ebp)
		fiov_size = sizeof(struct fiovec) * fiovlen;
   10bd7:	8b 5d 18             	mov    0x18(%ebp),%ebx
   10bda:	c1 e3 04             	shl    $0x4,%ebx
		if(fiov_size > 0) {
   10bdd:	85 db                	test   %ebx,%ebx
   10bdf:	0f 8e 41 03 00 00    	jle    10f26 <trickles_sendfilev_impl+0x376>
			fiov = kmalloc(fiov_size, GFP_KERNEL);
   10be5:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
   10bec:	00 
   10bed:	89 1c 24             	mov    %ebx,(%esp,1)
   10bf0:	e8 fc ff ff ff       	call   10bf1 <trickles_sendfilev_impl+0x41>
   10bf5:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
			if(fiov == NULL) {
   10bf8:	85 c0                	test   %eax,%eax
   10bfa:	0f 84 eb 01 00 00    	je     10deb <trickles_sendfilev_impl+0x23b>
				goto out;
			}
			err = -EFAULT;
   10c00:	c7 45 f0 f2 ff ff ff 	movl   $0xfffffff2,0xfffffff0(%ebp)
			if(copy_from_user(fiov, user_fiov, fiov_size)) {
   10c07:	8b 45 14             	mov    0x14(%ebp),%eax
   10c0a:	89 5c 24 08          	mov    %ebx,0x8(%esp,1)
   10c0e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10c12:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   10c15:	89 04 24             	mov    %eax,(%esp,1)
   10c18:	e8 fc ff ff ff       	call   10c19 <trickles_sendfilev_impl+0x69>
   10c1d:	85 c0                	test   %eax,%eax
   10c1f:	0f 85 b4 01 00 00    	jne    10dd9 <trickles_sendfilev_impl+0x229>
				goto out_freefiov;
			}
		} else {
			fiov = NULL;
		}
	}

	sock = sockfd_lookup(fd, &err);
   10c25:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   10c28:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10c2c:	8b 45 08             	mov    0x8(%ebp),%eax
   10c2f:	89 04 24             	mov    %eax,(%esp,1)
   10c32:	e8 fc ff ff ff       	call   10c33 <trickles_sendfilev_impl+0x83>
   10c37:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	if (!sock)
   10c3a:	85 c0                	test   %eax,%eax
   10c3c:	0f 84 97 01 00 00    	je     10dd9 <trickles_sendfilev_impl+0x229>
		goto out_freefiov;

	sk = sock->sk;
   10c42:	8b 58 18             	mov    0x18(%eax),%ebx
	tp = &(sk->tp_pinfo.af_tcp);

	lock_sock(sk);
   10c45:	ff 05 08 00 00 00    	incl   0x8
   10c4b:	8d 93 bc 00 00 00    	lea    0xbc(%ebx),%edx
   10c51:	89 55 e8             	mov    %edx,0xffffffe8(%ebp)
   10c54:	8b 43 2c             	mov    0x2c(%ebx),%eax
   10c57:	85 c0                	test   %eax,%eax
   10c59:	0f 85 ba 02 00 00    	jne    10f19 <trickles_sendfilev_impl+0x369>
   10c5f:	c7 43 2c 01 00 00 00 	movl   $0x1,0x2c(%ebx)
   10c66:	ba 08 00 00 00       	mov    $0x8,%edx
   10c6b:	a1 08 00 00 00       	mov    0x8,%eax
   10c70:	48                   	dec    %eax
   10c71:	85 c0                	test   %eax,%eax
   10c73:	a3 08 00 00 00       	mov    %eax,0x8
   10c78:	75 0a                	jne    10c84 <trickles_sendfilev_impl+0xd4>
   10c7a:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   10c7e:	0f 85 9e 24 00 00    	jne    13122 <.text.lock.tmalloc+0x150>
	if(!TRICKLES_USERAPI_CONFIGURED_TP(tp)) {
   10c84:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   10c87:	8b b8 d0 01 00 00    	mov    0x1d0(%eax),%edi
   10c8d:	85 ff                	test   %edi,%edi
   10c8f:	0f 84 14 02 00 00    	je     10ea9 <trickles_sendfilev_impl+0x2f9>
		printk("Socket not configured\n");
		release_sock(sk);
		err = -EINVAL;
		goto out_put;
	}
	if(!IS_TRICKLES_SOCK_ADDR(tp,msk) || 
   10c95:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   10c98:	b9 3f 82 fb 08       	mov    $0x8fb823f,%ecx
   10c9d:	8b ba cc 01 00 00    	mov    0x1cc(%edx),%edi
   10ca3:	89 f2                	mov    %esi,%edx
   10ca5:	8b 47 0c             	mov    0xc(%edi),%eax
   10ca8:	29 c2                	sub    %eax,%edx
   10caa:	89 55 d4             	mov    %edx,0xffffffd4(%ebp)
   10cad:	c1 ea 02             	shr    $0x2,%edx
   10cb0:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   10cb3:	89 d0                	mov    %edx,%eax
   10cb5:	f7 e1                	mul    %ecx
   10cb7:	d1 ea                	shr    %edx
   10cb9:	69 d2 e4 00 00 00    	imul   $0xe4,%edx,%edx
   10cbf:	39 55 d4             	cmp    %edx,0xffffffd4(%ebp)
   10cc2:	0f 85 d9 01 00 00    	jne    10ea1 <trickles_sendfilev_impl+0x2f1>
   10cc8:	3b 75 e0             	cmp    0xffffffe0(%ebp),%esi
   10ccb:	0f 82 d0 01 00 00    	jb     10ea1 <trickles_sendfilev_impl+0x2f1>
   10cd1:	8b 57 14             	mov    0x14(%edi),%edx
   10cd4:	89 f0                	mov    %esi,%eax
   10cd6:	29 d0                	sub    %edx,%eax
   10cd8:	05 e4 00 00 00       	add    $0xe4,%eax
   10cdd:	3b 47 20             	cmp    0x20(%edi),%eax
   10ce0:	0f 87 bb 01 00 00    	ja     10ea1 <trickles_sendfilev_impl+0x2f1>
   10ce6:	8b 46 0c             	mov    0xc(%esi),%eax
   10ce9:	83 f8 01             	cmp    $0x1,%eax
   10cec:	0f 84 1f 01 00 00    	je     10e11 <trickles_sendfilev_impl+0x261>
   10cf2:	83 f8 04             	cmp    $0x4,%eax
   10cf5:	0f 84 16 01 00 00    	je     10e11 <trickles_sendfilev_impl+0x261>
   10cfb:	90                   	nop    
   10cfc:	8d 74 26 00          	lea    0x0(%esi,1),%esi
	   !(VALID_MSK_CTL(msk))) {
		printk("bad minisocket %d %d\n", !IS_TRICKLES_SOCK_ADDR(tp,msk), !(VALID_MSK_CTL(msk)));
   10d00:	31 d2                	xor    %edx,%edx
   10d02:	83 f8 01             	cmp    $0x1,%eax
   10d05:	74 0b                	je     10d12 <trickles_sendfilev_impl+0x162>
   10d07:	83 f8 04             	cmp    $0x4,%eax
   10d0a:	b8 01 00 00 00       	mov    $0x1,%eax
   10d0f:	0f 45 d0             	cmovne %eax,%edx
   10d12:	89 54 24 08          	mov    %edx,0x8(%esp,1)
   10d16:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   10d19:	b9 3f 82 fb 08       	mov    $0x8fb823f,%ecx
   10d1e:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
   10d25:	8b ba cc 01 00 00    	mov    0x1cc(%edx),%edi
   10d2b:	89 f2                	mov    %esi,%edx
   10d2d:	8b 47 0c             	mov    0xc(%edi),%eax
   10d30:	29 c2                	sub    %eax,%edx
   10d32:	89 55 d4             	mov    %edx,0xffffffd4(%ebp)
   10d35:	c1 ea 02             	shr    $0x2,%edx
   10d38:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
   10d3b:	89 d0                	mov    %edx,%eax
   10d3d:	f7 e1                	mul    %ecx
   10d3f:	d1 ea                	shr    %edx
   10d41:	69 d2 e4 00 00 00    	imul   $0xe4,%edx,%edx
   10d47:	39 55 d4             	cmp    %edx,0xffffffd4(%ebp)
   10d4a:	75 24                	jne    10d70 <trickles_sendfilev_impl+0x1c0>
   10d4c:	3b 75 d8             	cmp    0xffffffd8(%ebp),%esi
   10d4f:	72 1f                	jb     10d70 <trickles_sendfilev_impl+0x1c0>
   10d51:	8b 47 14             	mov    0x14(%edi),%eax
   10d54:	29 c6                	sub    %eax,%esi
   10d56:	8d 86 e4 00 00 00    	lea    0xe4(%esi),%eax
   10d5c:	3b 47 20             	cmp    0x20(%edi),%eax
   10d5f:	76 16                	jbe    10d77 <trickles_sendfilev_impl+0x1c7>
   10d61:	eb 0d                	jmp    10d70 <trickles_sendfilev_impl+0x1c0>
   10d63:	90                   	nop    
   10d64:	90                   	nop    
   10d65:	90                   	nop    
   10d66:	90                   	nop    
   10d67:	90                   	nop    
   10d68:	90                   	nop    
   10d69:	90                   	nop    
   10d6a:	90                   	nop    
   10d6b:	90                   	nop    
   10d6c:	90                   	nop    
   10d6d:	90                   	nop    
   10d6e:	90                   	nop    
   10d6f:	90                   	nop    
   10d70:	c7 45 dc 01 00 00 00 	movl   $0x1,0xffffffdc(%ebp)
   10d77:	c7 04 24 c6 08 00 00 	movl   $0x8c6,(%esp,1)
   10d7e:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   10d81:	89 54 24 04          	mov    %edx,0x4(%esp,1)
   10d85:	e8 fc ff ff ff       	call   10d86 <trickles_sendfilev_impl+0x1d6>
		err = -EINVAL;
   10d8a:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
		release_sock(sk);
   10d91:	ff 05 08 00 00 00    	incl   0x8
   10d97:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
   10d9d:	85 c0                	test   %eax,%eax
   10d9f:	75 66                	jne    10e07 <trickles_sendfilev_impl+0x257>
   10da1:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   10da8:	8d 43 30             	lea    0x30(%ebx),%eax
   10dab:	39 43 30             	cmp    %eax,0x30(%ebx)
   10dae:	75 46                	jne    10df6 <trickles_sendfilev_impl+0x246>
   10db0:	ba 08 00 00 00       	mov    $0x8,%edx
   10db5:	a1 08 00 00 00       	mov    0x8,%eax
   10dba:	48                   	dec    %eax
   10dbb:	85 c0                	test   %eax,%eax
   10dbd:	a3 08 00 00 00       	mov    %eax,0x8
   10dc2:	75 0a                	jne    10dce <trickles_sendfilev_impl+0x21e>
   10dc4:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   10dc8:	0f 85 64 23 00 00    	jne    13132 <.text.lock.tmalloc+0x160>
   10dce:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   10dd1:	8b 42 14             	mov    0x14(%edx),%eax
   10dd4:	e8 fc ff ff ff       	call   10dd5 <trickles_sendfilev_impl+0x225>
		goto out_put;
	}

	free_trickles_msk(sk,msk);
	msk->byteNum = byteNum;

	{
		err = trickles_do_sendmsg_fiov(sk,msk,fiov,fiovlen);
	}

	release_sock(sk);
 out_put:	
	sockfd_put(sock);
 out_freefiov:
	if(fiovlen > 0)
   10dd9:	8b 75 18             	mov    0x18(%ebp),%esi
   10ddc:	85 f6                	test   %esi,%esi
   10dde:	7e 0b                	jle    10deb <trickles_sendfilev_impl+0x23b>
		kfree(fiov);
   10de0:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   10de3:	89 04 24             	mov    %eax,(%esp,1)
   10de6:	e8 fc ff ff ff       	call   10de7 <trickles_sendfilev_impl+0x237>
 out:
	return err;
   10deb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
}
   10dee:	83 c4 30             	add    $0x30,%esp
   10df1:	5b                   	pop    %ebx
   10df2:	5e                   	pop    %esi
   10df3:	5f                   	pop    %edi
   10df4:	5d                   	pop    %ebp
   10df5:	c3                   	ret    
   10df6:	b9 01 00 00 00       	mov    $0x1,%ecx
   10dfb:	ba 03 00 00 00       	mov    $0x3,%edx
   10e00:	e8 fc ff ff ff       	call   10e01 <trickles_sendfilev_impl+0x251>
   10e05:	eb a9                	jmp    10db0 <trickles_sendfilev_impl+0x200>
   10e07:	89 1c 24             	mov    %ebx,(%esp,1)
   10e0a:	e8 fc ff ff ff       	call   10e0b <trickles_sendfilev_impl+0x25b>
   10e0f:	eb 90                	jmp    10da1 <trickles_sendfilev_impl+0x1f1>
   10e11:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   10e15:	89 1c 24             	mov    %ebx,(%esp,1)
   10e18:	e8 e3 cb ff ff       	call   da00 <free_trickles_msk>
   10e1d:	8b 45 10             	mov    0x10(%ebp),%eax
   10e20:	89 46 30             	mov    %eax,0x30(%esi)
   10e23:	8b 45 18             	mov    0x18(%ebp),%eax
   10e26:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   10e2a:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   10e2d:	89 1c 24             	mov    %ebx,(%esp,1)
   10e30:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   10e34:	89 54 24 08          	mov    %edx,0x8(%esp,1)
   10e38:	e8 e3 d7 ff ff       	call   e620 <trickles_do_sendmsg_fiov>
   10e3d:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   10e40:	ff 05 08 00 00 00    	incl   0x8
   10e46:	8b bb a8 00 00 00    	mov    0xa8(%ebx),%edi
   10e4c:	85 ff                	test   %edi,%edi
   10e4e:	75 47                	jne    10e97 <trickles_sendfilev_impl+0x2e7>
   10e50:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   10e57:	8d 43 30             	lea    0x30(%ebx),%eax
   10e5a:	39 43 30             	cmp    %eax,0x30(%ebx)
   10e5d:	75 27                	jne    10e86 <trickles_sendfilev_impl+0x2d6>
   10e5f:	ba 08 00 00 00       	mov    $0x8,%edx
   10e64:	a1 08 00 00 00       	mov    0x8,%eax
   10e69:	48                   	dec    %eax
   10e6a:	85 c0                	test   %eax,%eax
   10e6c:	a3 08 00 00 00       	mov    %eax,0x8
   10e71:	0f 85 57 ff ff ff    	jne    10dce <trickles_sendfilev_impl+0x21e>
   10e77:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   10e7b:	0f 85 c1 22 00 00    	jne    13142 <.text.lock.tmalloc+0x170>
   10e81:	e9 48 ff ff ff       	jmp    10dce <trickles_sendfilev_impl+0x21e>
   10e86:	b9 01 00 00 00       	mov    $0x1,%ecx
   10e8b:	ba 03 00 00 00       	mov    $0x3,%edx
   10e90:	e8 fc ff ff ff       	call   10e91 <trickles_sendfilev_impl+0x2e1>
   10e95:	eb c8                	jmp    10e5f <trickles_sendfilev_impl+0x2af>
   10e97:	89 1c 24             	mov    %ebx,(%esp,1)
   10e9a:	e8 fc ff ff ff       	call   10e9b <trickles_sendfilev_impl+0x2eb>
   10e9f:	eb af                	jmp    10e50 <trickles_sendfilev_impl+0x2a0>
   10ea1:	8b 46 0c             	mov    0xc(%esi),%eax
   10ea4:	e9 57 fe ff ff       	jmp    10d00 <trickles_sendfilev_impl+0x150>
   10ea9:	c7 04 24 dc 08 00 00 	movl   $0x8dc,(%esp,1)
   10eb0:	e8 fc ff ff ff       	call   10eb1 <trickles_sendfilev_impl+0x301>
   10eb5:	ff 05 08 00 00 00    	incl   0x8
   10ebb:	8b 8b a8 00 00 00    	mov    0xa8(%ebx),%ecx
   10ec1:	85 c9                	test   %ecx,%ecx
   10ec3:	75 4a                	jne    10f0f <trickles_sendfilev_impl+0x35f>
   10ec5:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   10ecc:	8d 43 30             	lea    0x30(%ebx),%eax
   10ecf:	39 43 30             	cmp    %eax,0x30(%ebx)
   10ed2:	75 2a                	jne    10efe <trickles_sendfilev_impl+0x34e>
   10ed4:	ba 08 00 00 00       	mov    $0x8,%edx
   10ed9:	a1 08 00 00 00       	mov    0x8,%eax
   10ede:	48                   	dec    %eax
   10edf:	85 c0                	test   %eax,%eax
   10ee1:	a3 08 00 00 00       	mov    %eax,0x8
   10ee6:	75 0a                	jne    10ef2 <trickles_sendfilev_impl+0x342>
   10ee8:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   10eec:	0f 85 60 22 00 00    	jne    13152 <.text.lock.tmalloc+0x180>
   10ef2:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
   10ef9:	e9 d0 fe ff ff       	jmp    10dce <trickles_sendfilev_impl+0x21e>
   10efe:	b9 01 00 00 00       	mov    $0x1,%ecx
   10f03:	ba 03 00 00 00       	mov    $0x3,%edx
   10f08:	e8 fc ff ff ff       	call   10f09 <trickles_sendfilev_impl+0x359>
   10f0d:	eb c5                	jmp    10ed4 <trickles_sendfilev_impl+0x324>
   10f0f:	89 1c 24             	mov    %ebx,(%esp,1)
   10f12:	e8 fc ff ff ff       	call   10f13 <trickles_sendfilev_impl+0x363>
   10f17:	eb ac                	jmp    10ec5 <trickles_sendfilev_impl+0x315>
   10f19:	89 1c 24             	mov    %ebx,(%esp,1)
   10f1c:	e8 fc ff ff ff       	call   10f1d <trickles_sendfilev_impl+0x36d>
   10f21:	e9 39 fd ff ff       	jmp    10c5f <trickles_sendfilev_impl+0xaf>
   10f26:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
   10f2d:	e9 f3 fc ff ff       	jmp    10c25 <trickles_sendfilev_impl+0x75>
   10f32:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
   10f39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00010f40 <trickles_send_impl>:

int trickles_send_impl(int fd, struct cminisock *msk, unsigned byteNum, char *buf, int len) {
   10f40:	55                   	push   %ebp
   10f41:	89 e5                	mov    %esp,%ebp
   10f43:	57                   	push   %edi
   10f44:	56                   	push   %esi
   10f45:	53                   	push   %ebx
   10f46:	83 ec 2c             	sub    $0x2c,%esp
	struct socket *sock;
	struct sock *sk;
	struct tcp_opt *tp;
	int err;
	struct tiovec iov = {iov_base: buf, iov_len: len, 
   10f49:	8b 45 14             	mov    0x14(%ebp),%eax
   10f4c:	8b 75 0c             	mov    0xc(%ebp),%esi
   10f4f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   10f52:	8b 45 18             	mov    0x18(%ebp),%eax
   10f55:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
#ifdef SETUCONT_COMMAND
			     ucont_base: NULL,
			     ucont_len: 0
#endif // SETUCONT_COMMAND
	};

	sock = sockfd_lookup(fd, &err);
   10f58:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   10f5b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10f5f:	8b 45 08             	mov    0x8(%ebp),%eax
   10f62:	89 04 24             	mov    %eax,(%esp,1)
   10f65:	e8 fc ff ff ff       	call   10f66 <trickles_send_impl+0x26>
   10f6a:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
	if (!sock)
   10f6d:	85 c0                	test   %eax,%eax
   10f6f:	0f 84 64 01 00 00    	je     110d9 <trickles_send_impl+0x199>
		goto out;

	sk = sock->sk;
   10f75:	8b 58 18             	mov    0x18(%eax),%ebx
	tp = &(sk->tp_pinfo.af_tcp);

	lock_sock(sk);
   10f78:	ff 05 08 00 00 00    	incl   0x8
   10f7e:	8d bb bc 00 00 00    	lea    0xbc(%ebx),%edi
   10f84:	8b 43 2c             	mov    0x2c(%ebx),%eax
   10f87:	85 c0                	test   %eax,%eax
   10f89:	0f 85 e1 02 00 00    	jne    11270 <trickles_send_impl+0x330>
   10f8f:	c7 43 2c 01 00 00 00 	movl   $0x1,0x2c(%ebx)
   10f96:	ba 08 00 00 00       	mov    $0x8,%edx
   10f9b:	a1 08 00 00 00       	mov    0x8,%eax
   10fa0:	48                   	dec    %eax
   10fa1:	85 c0                	test   %eax,%eax
   10fa3:	a3 08 00 00 00       	mov    %eax,0x8
   10fa8:	75 0a                	jne    10fb4 <trickles_send_impl+0x74>
   10faa:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   10fae:	0f 85 ae 21 00 00    	jne    13162 <.text.lock.tmalloc+0x190>
	if(!TRICKLES_USERAPI_CONFIGURED_TP(tp)) {
   10fb4:	8b 87 d0 01 00 00    	mov    0x1d0(%edi),%eax
   10fba:	85 c0                	test   %eax,%eax
   10fbc:	0f 84 3e 02 00 00    	je     11200 <trickles_send_impl+0x2c0>
		printk("Socket not configured\n");
		release_sock(sk);
		err = -EINVAL;
		goto out_put;
	}
	if(!IS_TRICKLES_SOCK_ADDR(tp,msk) || !(VALID_MSK_CTL(msk))) {
   10fc2:	8b bf cc 01 00 00    	mov    0x1cc(%edi),%edi
   10fc8:	89 f2                	mov    %esi,%edx
   10fca:	b9 3f 82 fb 08       	mov    $0x8fb823f,%ecx
   10fcf:	89 7d e0             	mov    %edi,0xffffffe0(%ebp)
   10fd2:	8b 7f 0c             	mov    0xc(%edi),%edi
   10fd5:	29 fa                	sub    %edi,%edx
   10fd7:	89 55 d8             	mov    %edx,0xffffffd8(%ebp)
   10fda:	c1 ea 02             	shr    $0x2,%edx
   10fdd:	89 d0                	mov    %edx,%eax
   10fdf:	f7 e1                	mul    %ecx
   10fe1:	d1 ea                	shr    %edx
   10fe3:	69 d2 e4 00 00 00    	imul   $0xe4,%edx,%edx
   10fe9:	39 55 d8             	cmp    %edx,0xffffffd8(%ebp)
   10fec:	75 32                	jne    11020 <trickles_send_impl+0xe0>
   10fee:	39 fe                	cmp    %edi,%esi
   10ff0:	72 2e                	jb     11020 <trickles_send_impl+0xe0>
   10ff2:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   10ff5:	89 f0                	mov    %esi,%eax
   10ff7:	8b 4a 14             	mov    0x14(%edx),%ecx
   10ffa:	29 c8                	sub    %ecx,%eax
   10ffc:	05 e4 00 00 00       	add    $0xe4,%eax
   11001:	3b 42 20             	cmp    0x20(%edx),%eax
   11004:	77 1a                	ja     11020 <trickles_send_impl+0xe0>
   11006:	8b 46 0c             	mov    0xc(%esi),%eax
   11009:	83 f8 01             	cmp    $0x1,%eax
   1100c:	0f 84 ed 00 00 00    	je     110ff <trickles_send_impl+0x1bf>
   11012:	83 f8 04             	cmp    $0x4,%eax
   11015:	0f 84 e4 00 00 00    	je     110ff <trickles_send_impl+0x1bf>
   1101b:	90                   	nop    
   1101c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
		printk("bad minisocket %d\n", !IS_TRICKLES_SOCK_ADDR(tp,msk));
   11020:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
   11027:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   1102a:	89 f2                	mov    %esi,%edx
   1102c:	b9 3f 82 fb 08       	mov    $0x8fb823f,%ecx
   11031:	8b 78 0c             	mov    0xc(%eax),%edi
   11034:	29 fa                	sub    %edi,%edx
   11036:	89 55 d8             	mov    %edx,0xffffffd8(%ebp)
   11039:	c1 ea 02             	shr    $0x2,%edx
   1103c:	89 d0                	mov    %edx,%eax
   1103e:	f7 e1                	mul    %ecx
   11040:	d1 ea                	shr    %edx
   11042:	69 d2 e4 00 00 00    	imul   $0xe4,%edx,%edx
   11048:	39 55 d8             	cmp    %edx,0xffffffd8(%ebp)
   1104b:	75 23                	jne    11070 <trickles_send_impl+0x130>
   1104d:	39 fe                	cmp    %edi,%esi
   1104f:	72 1f                	jb     11070 <trickles_send_impl+0x130>
   11051:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   11054:	8b 42 14             	mov    0x14(%edx),%eax
   11057:	29 c6                	sub    %eax,%esi
   11059:	8d 86 e4 00 00 00    	lea    0xe4(%esi),%eax
   1105f:	3b 42 20             	cmp    0x20(%edx),%eax
   11062:	76 13                	jbe    11077 <trickles_send_impl+0x137>
   11064:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   1106a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
   11070:	c7 45 dc 01 00 00 00 	movl   $0x1,0xffffffdc(%ebp)
   11077:	c7 04 24 3f 0a 00 00 	movl   $0xa3f,(%esp,1)
   1107e:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   11081:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   11085:	e8 fc ff ff ff       	call   11086 <trickles_send_impl+0x146>
		err = -EINVAL;
   1108a:	c7 45 e8 ea ff ff ff 	movl   $0xffffffea,0xffffffe8(%ebp)
		release_sock(sk);
   11091:	ff 05 08 00 00 00    	incl   0x8
   11097:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
   1109d:	85 c0                	test   %eax,%eax
   1109f:	75 54                	jne    110f5 <trickles_send_impl+0x1b5>
   110a1:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   110a8:	8d 43 30             	lea    0x30(%ebx),%eax
   110ab:	39 43 30             	cmp    %eax,0x30(%ebx)
   110ae:	75 34                	jne    110e4 <trickles_send_impl+0x1a4>
   110b0:	ba 08 00 00 00       	mov    $0x8,%edx
   110b5:	a1 08 00 00 00       	mov    0x8,%eax
   110ba:	48                   	dec    %eax
   110bb:	85 c0                	test   %eax,%eax
   110bd:	a3 08 00 00 00       	mov    %eax,0x8
   110c2:	75 0a                	jne    110ce <trickles_send_impl+0x18e>
   110c4:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   110c8:	0f 85 a4 20 00 00    	jne    13172 <.text.lock.tmalloc+0x1a0>
   110ce:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   110d1:	8b 42 14             	mov    0x14(%edx),%eax
   110d4:	e8 fc ff ff ff       	call   110d5 <trickles_send_impl+0x195>
		goto out_put;
	}
	free_trickles_msk(sk,msk);
	msk->byteNum = byteNum;

	if(iov.iov_len == -1) {
		free_trickles_msk_finish(sk,msk);
		err = 0;
	} else if(iov.iov_len == -2) {
		if(msk->ctl != ALLOC_HALFFREE) {
			msk->ctl = ALLOC_HALFFREE;
			// Remove from list, but dont deallocate
			err = 0;
		} else {
			/* already half-freed ! */
			printk("already half freed\n");
			err = -EINVAL;
		}
	} else if(iov.iov_len == -3) {
		msk->tag = FIN;
		iov.iov_len = 0;
		goto more;
	} else {
	more:
		err = trickles_do_sendmsg_tiov(sk,msk,&iov,1);
	}

	release_sock(sk);
out_put:	
	sockfd_put(sock);
 out:
	return err;
   110d9:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
}
   110dc:	83 c4 2c             	add    $0x2c,%esp
   110df:	5b                   	pop    %ebx
   110e0:	5e                   	pop    %esi
   110e1:	5f                   	pop    %edi
   110e2:	5d                   	pop    %ebp
   110e3:	c3                   	ret    
   110e4:	b9 01 00 00 00       	mov    $0x1,%ecx
   110e9:	ba 03 00 00 00       	mov    $0x3,%edx
   110ee:	e8 fc ff ff ff       	call   110ef <trickles_send_impl+0x1af>
   110f3:	eb bb                	jmp    110b0 <trickles_send_impl+0x170>
   110f5:	89 1c 24             	mov    %ebx,(%esp,1)
   110f8:	e8 fc ff ff ff       	call   110f9 <trickles_send_impl+0x1b9>
   110fd:	eb a2                	jmp    110a1 <trickles_send_impl+0x161>
   110ff:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   11103:	89 1c 24             	mov    %ebx,(%esp,1)
   11106:	e8 f5 c8 ff ff       	call   da00 <free_trickles_msk>
   1110b:	8b 45 10             	mov    0x10(%ebp),%eax
   1110e:	89 46 30             	mov    %eax,0x30(%esi)
   11111:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   11114:	83 f8 ff             	cmp    $0xffffffff,%eax
   11117:	0f 84 d1 00 00 00    	je     111ee <trickles_send_impl+0x2ae>
   1111d:	83 f8 fe             	cmp    $0xfffffffe,%eax
   11120:	0f 84 97 00 00 00    	je     111bd <trickles_send_impl+0x27d>
   11126:	83 f8 fd             	cmp    $0xfffffffd,%eax
   11129:	74 7f                	je     111aa <trickles_send_impl+0x26a>
   1112b:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp,1)
   11132:	00 
   11133:	8d 55 ec             	lea    0xffffffec(%ebp),%edx
   11136:	89 54 24 08          	mov    %edx,0x8(%esp,1)
   1113a:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   1113e:	89 1c 24             	mov    %ebx,(%esp,1)
   11141:	e8 6a d3 ff ff       	call   e4b0 <trickles_do_sendmsg_tiov>
   11146:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   11149:	ff 05 08 00 00 00    	incl   0x8
   1114f:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
   11155:	85 c0                	test   %eax,%eax
   11157:	75 47                	jne    111a0 <trickles_send_impl+0x260>
   11159:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   11160:	8d 43 30             	lea    0x30(%ebx),%eax
   11163:	39 43 30             	cmp    %eax,0x30(%ebx)
   11166:	75 27                	jne    1118f <trickles_send_impl+0x24f>
   11168:	ba 08 00 00 00       	mov    $0x8,%edx
   1116d:	a1 08 00 00 00       	mov    0x8,%eax
   11172:	48                   	dec    %eax
   11173:	85 c0                	test   %eax,%eax
   11175:	a3 08 00 00 00       	mov    %eax,0x8
   1117a:	0f 85 4e ff ff ff    	jne    110ce <trickles_send_impl+0x18e>
   11180:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   11184:	0f 85 f8 1f 00 00    	jne    13182 <.text.lock.tmalloc+0x1b0>
   1118a:	e9 3f ff ff ff       	jmp    110ce <trickles_send_impl+0x18e>
   1118f:	b9 01 00 00 00       	mov    $0x1,%ecx
   11194:	ba 03 00 00 00       	mov    $0x3,%edx
   11199:	e8 fc ff ff ff       	call   1119a <trickles_send_impl+0x25a>
   1119e:	eb c8                	jmp    11168 <trickles_send_impl+0x228>
   111a0:	89 1c 24             	mov    %ebx,(%esp,1)
   111a3:	e8 fc ff ff ff       	call   111a4 <trickles_send_impl+0x264>
   111a8:	eb af                	jmp    11159 <trickles_send_impl+0x219>
   111aa:	c7 46 10 02 00 00 00 	movl   $0x2,0x10(%esi)
   111b1:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
   111b8:	e9 6e ff ff ff       	jmp    1112b <trickles_send_impl+0x1eb>
   111bd:	83 7e 0c 04          	cmpl   $0x4,0xc(%esi)
   111c1:	74 13                	je     111d6 <trickles_send_impl+0x296>
   111c3:	c7 46 0c 04 00 00 00 	movl   $0x4,0xc(%esi)
   111ca:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
   111d1:	e9 73 ff ff ff       	jmp    11149 <trickles_send_impl+0x209>
   111d6:	c7 04 24 52 0a 00 00 	movl   $0xa52,(%esp,1)
   111dd:	e8 fc ff ff ff       	call   111de <trickles_send_impl+0x29e>
   111e2:	c7 45 e8 ea ff ff ff 	movl   $0xffffffea,0xffffffe8(%ebp)
   111e9:	e9 5b ff ff ff       	jmp    11149 <trickles_send_impl+0x209>
   111ee:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   111f2:	89 1c 24             	mov    %ebx,(%esp,1)
   111f5:	e8 a6 c8 ff ff       	call   daa0 <free_trickles_msk_finish>
   111fa:	eb ce                	jmp    111ca <trickles_send_impl+0x28a>
   111fc:	8d 74 26 00          	lea    0x0(%esi,1),%esi
   11200:	c7 04 24 dc 08 00 00 	movl   $0x8dc,(%esp,1)
   11207:	e8 fc ff ff ff       	call   11208 <trickles_send_impl+0x2c8>
   1120c:	ff 05 08 00 00 00    	incl   0x8
   11212:	8b b3 a8 00 00 00    	mov    0xa8(%ebx),%esi
   11218:	85 f6                	test   %esi,%esi
   1121a:	75 4a                	jne    11266 <trickles_send_impl+0x326>
   1121c:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   11223:	8d 43 30             	lea    0x30(%ebx),%eax
   11226:	39 43 30             	cmp    %eax,0x30(%ebx)
   11229:	75 2a                	jne    11255 <trickles_send_impl+0x315>
   1122b:	ba 08 00 00 00       	mov    $0x8,%edx
   11230:	a1 08 00 00 00       	mov    0x8,%eax
   11235:	48                   	dec    %eax
   11236:	85 c0                	test   %eax,%eax
   11238:	a3 08 00 00 00       	mov    %eax,0x8
   1123d:	75 0a                	jne    11249 <trickles_send_impl+0x309>
   1123f:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   11243:	0f 85 49 1f 00 00    	jne    13192 <.text.lock.tmalloc+0x1c0>
   11249:	c7 45 e8 ea ff ff ff 	movl   $0xffffffea,0xffffffe8(%ebp)
   11250:	e9 79 fe ff ff       	jmp    110ce <trickles_send_impl+0x18e>
   11255:	b9 01 00 00 00       	mov    $0x1,%ecx
   1125a:	ba 03 00 00 00       	mov    $0x3,%edx
   1125f:	e8 fc ff ff ff       	call   11260 <trickles_send_impl+0x320>
   11264:	eb c5                	jmp    1122b <trickles_send_impl+0x2eb>
   11266:	89 1c 24             	mov    %ebx,(%esp,1)
   11269:	e8 fc ff ff ff       	call   1126a <trickles_send_impl+0x32a>
   1126e:	eb ac                	jmp    1121c <trickles_send_impl+0x2dc>
   11270:	89 1c 24             	mov    %ebx,(%esp,1)
   11273:	e8 fc ff ff ff       	call   11274 <trickles_send_impl+0x334>
   11278:	e9 12 fd ff ff       	jmp    10f8f <trickles_send_impl+0x4f>
   1127d:	8d 76 00             	lea    0x0(%esi),%esi

00011280 <trickles_mmap_impl>:

int trickles_mmap_impl(struct file *file, struct socket *sock, struct vm_area_struct *vma) {
   11280:	55                   	push   %ebp
   11281:	89 e5                	mov    %esp,%ebp
   11283:	83 ec 0c             	sub    $0xc,%esp
   11286:	89 75 fc             	mov    %esi,0xfffffffc(%ebp)
	struct sock *sk = sock->sk;
   11289:	8b 45 0c             	mov    0xc(%ebp),%eax
   1128c:	8b 75 10             	mov    0x10(%ebp),%esi
   1128f:	89 5d f8             	mov    %ebx,0xfffffff8(%ebp)
   11292:	8b 58 18             	mov    0x18(%eax),%ebx
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);

	if(!TRICKLES_USERAPI_CONFIGURED_TP(tp)) {
   11295:	8b 83 8c 02 00 00    	mov    0x28c(%ebx),%eax
   1129b:	85 c0                	test   %eax,%eax
   1129d:	75 21                	jne    112c0 <trickles_mmap_impl+0x40>
		printk("mmap before configuration\n");
   1129f:	c7 04 24 66 0a 00 00 	movl   $0xa66,(%esp,1)
   112a6:	e8 fc ff ff ff       	call   112a7 <trickles_mmap_impl+0x27>
		return -EINVAL;
   112ab:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	}
	printk("trickles mmap called\n");
	vma->vm_ops = &trickles_vm_ops;
	vma->vm_private_data = &tp->cminisock_api_config;
	return 0;
}
   112b0:	8b 5d f8             	mov    0xfffffff8(%ebp),%ebx
   112b3:	8b 75 fc             	mov    0xfffffffc(%ebp),%esi
   112b6:	89 ec                	mov    %ebp,%esp
   112b8:	5d                   	pop    %ebp
   112b9:	c3                   	ret    
   112ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   112c0:	c7 04 24 81 0a 00 00 	movl   $0xa81,(%esp,1)
   112c7:	e8 fc ff ff ff       	call   112c8 <trickles_mmap_impl+0x48>
   112cc:	8d 83 84 02 00 00    	lea    0x284(%ebx),%eax
   112d2:	89 46 40             	mov    %eax,0x40(%esi)
   112d5:	31 c0                	xor    %eax,%eax
   112d7:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)
   112de:	eb d0                	jmp    112b0 <trickles_mmap_impl+0x30>

000112e0 <trickles_setucont_impl>:

int trickles_setucont_impl(int fd, struct cminisock *msk, int pkt_num, 
			   char *user_ucont, unsigned ucont_len) {
   112e0:	55                   	push   %ebp
   112e1:	89 e5                	mov    %esp,%ebp
   112e3:	57                   	push   %edi
	struct socket *sock;
	struct sock *sk;
	struct tcp_opt *tp;
	int err;
	char *buf;

	extern int gNumSetUCont;
	gNumSetUCont++;

	sock = sockfd_lookup(fd, &err);
   112e4:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   112e7:	56                   	push   %esi
   112e8:	53                   	push   %ebx
   112e9:	83 ec 20             	sub    $0x20,%esp
   112ec:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   112f0:	8b 45 08             	mov    0x8(%ebp),%eax
   112f3:	ff 05 00 00 00 00    	incl   0x0
   112f9:	89 04 24             	mov    %eax,(%esp,1)
   112fc:	e8 fc ff ff ff       	call   112fd <trickles_setucont_impl+0x1d>
   11301:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	if (!sock)
   11304:	85 c0                	test   %eax,%eax
   11306:	0f 84 9d 01 00 00    	je     114a9 <trickles_setucont_impl+0x1c9>
		goto out;

	sk = sock->sk;
   1130c:	8b 58 18             	mov    0x18(%eax),%ebx
	tp = &(sk->tp_pinfo.af_tcp);

	lock_sock(sk);
   1130f:	ff 05 08 00 00 00    	incl   0x8
   11315:	8d 83 bc 00 00 00    	lea    0xbc(%ebx),%eax
   1131b:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1131e:	8b 7b 2c             	mov    0x2c(%ebx),%edi
   11321:	85 ff                	test   %edi,%edi
   11323:	0f 85 c7 04 00 00    	jne    117f0 <trickles_setucont_impl+0x510>
   11329:	c7 43 2c 01 00 00 00 	movl   $0x1,0x2c(%ebx)
   11330:	ba 08 00 00 00       	mov    $0x8,%edx
   11335:	a1 08 00 00 00       	mov    0x8,%eax
   1133a:	48                   	dec    %eax
   1133b:	85 c0                	test   %eax,%eax
   1133d:	a3 08 00 00 00       	mov    %eax,0x8
   11342:	75 0a                	jne    1134e <trickles_setucont_impl+0x6e>
   11344:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   11348:	0f 85 54 1e 00 00    	jne    131a2 <.text.lock.tmalloc+0x1d0>
	if(!TRICKLES_USERAPI_CONFIGURED_TP(tp)) {
   1134e:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   11351:	8b b2 d0 01 00 00    	mov    0x1d0(%edx),%esi
   11357:	85 f6                	test   %esi,%esi
   11359:	0f 84 21 04 00 00    	je     11780 <trickles_setucont_impl+0x4a0>
		printk("Socket not configured\n");
		release_sock(sk);
		err = -EINVAL;
		goto out_put;
	}
	if(!IS_TRICKLES_SOCK_ADDR(tp,msk) || !(VALID_MSK_CTL(msk))) {
   1135f:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
   11362:	8b 45 0c             	mov    0xc(%ebp),%eax
   11365:	8b b1 cc 01 00 00    	mov    0x1cc(%ecx),%esi
   1136b:	b9 3f 82 fb 08       	mov    $0x8fb823f,%ecx
   11370:	8b 7e 0c             	mov    0xc(%esi),%edi
   11373:	29 f8                	sub    %edi,%eax
   11375:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   11378:	89 c2                	mov    %eax,%edx
   1137a:	c1 ea 02             	shr    $0x2,%edx
   1137d:	89 d0                	mov    %edx,%eax
   1137f:	f7 e1                	mul    %ecx
   11381:	d1 ea                	shr    %edx
   11383:	69 d2 e4 00 00 00    	imul   $0xe4,%edx,%edx
   11389:	39 55 e0             	cmp    %edx,0xffffffe0(%ebp)
   1138c:	0f 85 ce 03 00 00    	jne    11760 <trickles_setucont_impl+0x480>
   11392:	39 7d 0c             	cmp    %edi,0xc(%ebp)
   11395:	0f 82 d5 03 00 00    	jb     11770 <trickles_setucont_impl+0x490>
   1139b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1139e:	8b 56 14             	mov    0x14(%esi),%edx
   113a1:	29 d0                	sub    %edx,%eax
   113a3:	05 e4 00 00 00       	add    $0xe4,%eax
   113a8:	3b 46 20             	cmp    0x20(%esi),%eax
   113ab:	0f 87 af 03 00 00    	ja     11760 <trickles_setucont_impl+0x480>
   113b1:	8b 55 0c             	mov    0xc(%ebp),%edx
   113b4:	8b 42 0c             	mov    0xc(%edx),%eax
   113b7:	83 f8 01             	cmp    $0x1,%eax
   113ba:	0f 84 0f 01 00 00    	je     114cf <trickles_setucont_impl+0x1ef>
   113c0:	83 f8 04             	cmp    $0x4,%eax
   113c3:	0f 84 06 01 00 00    	je     114cf <trickles_setucont_impl+0x1ef>
   113c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
		printk("bad minisocket %d %d\n", !IS_TRICKLES_SOCK_ADDR(tp,msk), !(VALID_MSK_CTL(msk)));
   113d0:	31 d2                	xor    %edx,%edx
   113d2:	83 f8 01             	cmp    $0x1,%eax
   113d5:	74 0b                	je     113e2 <trickles_setucont_impl+0x102>
   113d7:	83 f8 04             	cmp    $0x4,%eax
   113da:	b8 01 00 00 00       	mov    $0x1,%eax
   113df:	0f 45 d0             	cmovne %eax,%edx
   113e2:	89 54 24 08          	mov    %edx,0x8(%esp,1)
   113e6:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   113e9:	b9 3f 82 fb 08       	mov    $0x8fb823f,%ecx
   113ee:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
   113f5:	8b 55 0c             	mov    0xc(%ebp),%edx
   113f8:	8b b0 cc 01 00 00    	mov    0x1cc(%eax),%esi
   113fe:	8b 7e 0c             	mov    0xc(%esi),%edi
   11401:	29 fa                	sub    %edi,%edx
   11403:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
   11406:	c1 ea 02             	shr    $0x2,%edx
   11409:	89 d0                	mov    %edx,%eax
   1140b:	f7 e1                	mul    %ecx
   1140d:	d1 ea                	shr    %edx
   1140f:	69 d2 e4 00 00 00    	imul   $0xe4,%edx,%edx
   11415:	39 55 e0             	cmp    %edx,0xffffffe0(%ebp)
   11418:	75 26                	jne    11440 <trickles_setucont_impl+0x160>
   1141a:	39 7d 0c             	cmp    %edi,0xc(%ebp)
   1141d:	72 21                	jb     11440 <trickles_setucont_impl+0x160>
   1141f:	8b 56 14             	mov    0x14(%esi),%edx
   11422:	29 55 0c             	sub    %edx,0xc(%ebp)
   11425:	8b 45 0c             	mov    0xc(%ebp),%eax
   11428:	05 e4 00 00 00       	add    $0xe4,%eax
   1142d:	3b 46 20             	cmp    0x20(%esi),%eax
   11430:	76 15                	jbe    11447 <trickles_setucont_impl+0x167>
   11432:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
   11439:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
   11440:	c7 45 e4 01 00 00 00 	movl   $0x1,0xffffffe4(%ebp)
   11447:	c7 04 24 c6 08 00 00 	movl   $0x8c6,(%esp,1)
   1144e:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
   11451:	89 4c 24 04          	mov    %ecx,0x4(%esp,1)
   11455:	e8 fc ff ff ff       	call   11456 <trickles_setucont_impl+0x176>
		err = -EINVAL;
   1145a:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
		release_sock(sk);
   11461:	ff 05 08 00 00 00    	incl   0x8
   11467:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
   1146d:	85 c0                	test   %eax,%eax
   1146f:	75 54                	jne    114c5 <trickles_setucont_impl+0x1e5>
   11471:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   11478:	8d 43 30             	lea    0x30(%ebx),%eax
   1147b:	39 43 30             	cmp    %eax,0x30(%ebx)
   1147e:	75 34                	jne    114b4 <trickles_setucont_impl+0x1d4>
   11480:	ba 08 00 00 00       	mov    $0x8,%edx
   11485:	a1 08 00 00 00       	mov    0x8,%eax
   1148a:	48                   	dec    %eax
   1148b:	85 c0                	test   %eax,%eax
   1148d:	a3 08 00 00 00       	mov    %eax,0x8
   11492:	75 0a                	jne    1149e <trickles_setucont_impl+0x1be>
   11494:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   11498:	0f 85 14 1d 00 00    	jne    131b2 <.text.lock.tmalloc+0x1e0>
   1149e:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   114a1:	8b 42 14             	mov    0x14(%edx),%eax
   114a4:	e8 fc ff ff ff       	call   114a5 <trickles_setucont_impl+0x1c5>
		goto out_put;
	}
	if(pkt_num < 0 || pkt_num >= msk->num_packets) {
		printk("invalid packet #\n");
		err = -EINVAL;
		release_sock(sk);
		goto out_put;
	}
	if(ucont_len > 0) {
		buf = kmalloc(ucont_len, GFP_KERNEL);
		if(buf == NULL) {
			printk("set_ucont: out of memory\n");
			err = -ENOMEM;
			release_sock(sk);
			goto out_put;
		}
		if(copy_from_user(buf,user_ucont,ucont_len)) {
			printk("set_ucont: fault while copying\n");
			err = -EFAULT;
			release_sock(sk);
			goto out_put;
		}
	} else {
		buf = NULL;
	}
	setPacketUCont(&msk->packets[pkt_num], buf, ucont_len);
	err = 0;
	release_sock(sk);

 out_put:
	sockfd_put(sock);
 out:
	return err;
   114a9:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
}
   114ac:	83 c4 20             	add    $0x20,%esp
   114af:	5b                   	pop    %ebx
   114b0:	5e                   	pop    %esi
   114b1:	5f                   	pop    %edi
   114b2:	5d                   	pop    %ebp
   114b3:	c3                   	ret    
   114b4:	b9 01 00 00 00       	mov    $0x1,%ecx
   114b9:	ba 03 00 00 00       	mov    $0x3,%edx
   114be:	e8 fc ff ff ff       	call   114bf <trickles_setucont_impl+0x1df>
   114c3:	eb bb                	jmp    11480 <trickles_setucont_impl+0x1a0>
   114c5:	89 1c 24             	mov    %ebx,(%esp,1)
   114c8:	e8 fc ff ff ff       	call   114c9 <trickles_setucont_impl+0x1e9>
   114cd:	eb a2                	jmp    11471 <trickles_setucont_impl+0x191>
   114cf:	8b 45 10             	mov    0x10(%ebp),%eax
   114d2:	85 c0                	test   %eax,%eax
   114d4:	78 0e                	js     114e4 <trickles_setucont_impl+0x204>
   114d6:	8b 55 0c             	mov    0xc(%ebp),%edx
   114d9:	8b 45 10             	mov    0x10(%ebp),%eax
   114dc:	3b 82 dc 00 00 00    	cmp    0xdc(%edx),%eax
   114e2:	7c 74                	jl     11558 <trickles_setucont_impl+0x278>
   114e4:	c7 04 24 97 0a 00 00 	movl   $0xa97,(%esp,1)
   114eb:	e8 fc ff ff ff       	call   114ec <trickles_setucont_impl+0x20c>
   114f0:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
   114f7:	ff 05 08 00 00 00    	incl   0x8
   114fd:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
   11503:	85 c0                	test   %eax,%eax
   11505:	75 47                	jne    1154e <trickles_setucont_impl+0x26e>
   11507:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   1150e:	8d 43 30             	lea    0x30(%ebx),%eax
   11511:	39 43 30             	cmp    %eax,0x30(%ebx)
   11514:	75 27                	jne    1153d <trickles_setucont_impl+0x25d>
   11516:	ba 08 00 00 00       	mov    $0x8,%edx
   1151b:	a1 08 00 00 00       	mov    0x8,%eax
   11520:	48                   	dec    %eax
   11521:	85 c0                	test   %eax,%eax
   11523:	a3 08 00 00 00       	mov    %eax,0x8
   11528:	0f 85 70 ff ff ff    	jne    1149e <trickles_setucont_impl+0x1be>
   1152e:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   11532:	0f 85 8a 1c 00 00    	jne    131c2 <.text.lock.tmalloc+0x1f0>
   11538:	e9 61 ff ff ff       	jmp    1149e <trickles_setucont_impl+0x1be>
   1153d:	b9 01 00 00 00       	mov    $0x1,%ecx
   11542:	ba 03 00 00 00       	mov    $0x3,%edx
   11547:	e8 fc ff ff ff       	call   11548 <trickles_setucont_impl+0x268>
   1154c:	eb c8                	jmp    11516 <trickles_setucont_impl+0x236>
   1154e:	89 1c 24             	mov    %ebx,(%esp,1)
   11551:	e8 fc ff ff ff       	call   11552 <trickles_setucont_impl+0x272>
   11556:	eb af                	jmp    11507 <trickles_setucont_impl+0x227>
   11558:	8b 45 18             	mov    0x18(%ebp),%eax
   1155b:	85 c0                	test   %eax,%eax
   1155d:	0f 85 d6 00 00 00    	jne    11639 <trickles_setucont_impl+0x359>
   11563:	31 ff                	xor    %edi,%edi
  pkt->position = INVALID_POSITION;
}

#ifdef __KERNEL__
static inline void setPacketUCont(struct cminisock_packet *packet, char *buf, unsigned long len) {
   11565:	8b 55 10             	mov    0x10(%ebp),%edx
   11568:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1156b:	8d 04 92             	lea    (%edx,%edx,4),%eax
   1156e:	8b 91 e0 00 00 00    	mov    0xe0(%ecx),%edx
   11574:	8d 34 c2             	lea    (%edx,%eax,8),%esi
	if(len > packet->len + packet->ucontLen) {
   11577:	8b 56 08             	mov    0x8(%esi),%edx
   1157a:	8b 4e 14             	mov    0x14(%esi),%ecx
   1157d:	89 d0                	mov    %edx,%eax
   1157f:	01 c8                	add    %ecx,%eax
   11581:	39 45 18             	cmp    %eax,0x18(%ebp)
   11584:	0f 87 9e 00 00 00    	ja     11628 <trickles_setucont_impl+0x348>
		printk("Not enough space in packet for ucont\n");
		return;
	}
	if(packet->ucontData) {
   1158a:	8b 46 18             	mov    0x18(%esi),%eax
   1158d:	85 c0                	test   %eax,%eax
   1158f:	75 76                	jne    11607 <trickles_setucont_impl+0x327>
		kfree(packet->ucontData);
		packet->len += packet->ucontLen;
		packet->ucontLen = 0;
	}
	packet->ucontData = buf;
   11591:	89 7e 18             	mov    %edi,0x18(%esi)
	packet->ucontLen = len;
   11594:	8b 45 18             	mov    0x18(%ebp),%eax
	packet->len -= packet->ucontLen;
   11597:	29 c2                	sub    %eax,%edx
   11599:	89 46 14             	mov    %eax,0x14(%esi)
   1159c:	89 56 08             	mov    %edx,0x8(%esi)
   1159f:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
   115a6:	ff 05 08 00 00 00    	incl   0x8
   115ac:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
   115b2:	85 c0                	test   %eax,%eax
   115b4:	75 47                	jne    115fd <trickles_setucont_impl+0x31d>
   115b6:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   115bd:	8d 43 30             	lea    0x30(%ebx),%eax
   115c0:	39 43 30             	cmp    %eax,0x30(%ebx)
   115c3:	75 27                	jne    115ec <trickles_setucont_impl+0x30c>
   115c5:	ba 08 00 00 00       	mov    $0x8,%edx
   115ca:	a1 08 00 00 00       	mov    0x8,%eax
   115cf:	48                   	dec    %eax
   115d0:	85 c0                	test   %eax,%eax
   115d2:	a3 08 00 00 00       	mov    %eax,0x8
   115d7:	0f 85 c1 fe ff ff    	jne    1149e <trickles_setucont_impl+0x1be>
   115dd:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   115e1:	0f 85 eb 1b 00 00    	jne    131d2 <.text.lock.tmalloc+0x200>
   115e7:	e9 b2 fe ff ff       	jmp    1149e <trickles_setucont_impl+0x1be>
   115ec:	b9 01 00 00 00       	mov    $0x1,%ecx
   115f1:	ba 03 00 00 00       	mov    $0x3,%edx
   115f6:	e8 fc ff ff ff       	call   115f7 <trickles_setucont_impl+0x317>
   115fb:	eb c8                	jmp    115c5 <trickles_setucont_impl+0x2e5>
   115fd:	89 1c 24             	mov    %ebx,(%esp,1)
   11600:	e8 fc ff ff ff       	call   11601 <trickles_setucont_impl+0x321>
   11605:	eb af                	jmp    115b6 <trickles_setucont_impl+0x2d6>
		printk("Not enough space in packet for ucont\n");
		return;
	}
	if(packet->ucontData) {
		kfree(packet->ucontData);
   11607:	89 04 24             	mov    %eax,(%esp,1)
   1160a:	e8 fc ff ff ff       	call   1160b <trickles_setucont_impl+0x32b>
		packet->len += packet->ucontLen;
   1160f:	8b 56 08             	mov    0x8(%esi),%edx
   11612:	8b 46 14             	mov    0x14(%esi),%eax
		packet->ucontLen = 0;
   11615:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
   1161c:	01 d0                	add    %edx,%eax
   1161e:	89 c2                	mov    %eax,%edx
   11620:	89 46 08             	mov    %eax,0x8(%esi)
   11623:	e9 69 ff ff ff       	jmp    11591 <trickles_setucont_impl+0x2b1>
   11628:	c7 04 24 a0 40 00 00 	movl   $0x40a0,(%esp,1)
   1162f:	e8 fc ff ff ff       	call   11630 <trickles_setucont_impl+0x350>
   11634:	e9 66 ff ff ff       	jmp    1159f <trickles_setucont_impl+0x2bf>
   11639:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
   11640:	00 
   11641:	8b 4d 18             	mov    0x18(%ebp),%ecx
   11644:	89 0c 24             	mov    %ecx,(%esp,1)
   11647:	e8 fc ff ff ff       	call   11648 <trickles_setucont_impl+0x368>
   1164c:	85 c0                	test   %eax,%eax
   1164e:	89 c7                	mov    %eax,%edi
   11650:	0f 84 92 00 00 00    	je     116e8 <trickles_setucont_impl+0x408>
   11656:	89 3c 24             	mov    %edi,(%esp,1)
   11659:	8b 45 18             	mov    0x18(%ebp),%eax
   1165c:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   11660:	8b 45 14             	mov    0x14(%ebp),%eax
   11663:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   11667:	e8 fc ff ff ff       	call   11668 <trickles_setucont_impl+0x388>
   1166c:	85 c0                	test   %eax,%eax
   1166e:	0f 84 f1 fe ff ff    	je     11565 <trickles_setucont_impl+0x285>
   11674:	c7 04 24 e0 40 00 00 	movl   $0x40e0,(%esp,1)
   1167b:	e8 fc ff ff ff       	call   1167c <trickles_setucont_impl+0x39c>
   11680:	c7 45 f0 f2 ff ff ff 	movl   $0xfffffff2,0xfffffff0(%ebp)
   11687:	ff 05 08 00 00 00    	incl   0x8
   1168d:	8b b3 a8 00 00 00    	mov    0xa8(%ebx),%esi
   11693:	85 f6                	test   %esi,%esi
   11695:	75 47                	jne    116de <trickles_setucont_impl+0x3fe>
   11697:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   1169e:	8d 43 30             	lea    0x30(%ebx),%eax
   116a1:	39 43 30             	cmp    %eax,0x30(%ebx)
   116a4:	75 27                	jne    116cd <trickles_setucont_impl+0x3ed>
   116a6:	ba 08 00 00 00       	mov    $0x8,%edx
   116ab:	a1 08 00 00 00       	mov    0x8,%eax
   116b0:	48                   	dec    %eax
   116b1:	85 c0                	test   %eax,%eax
   116b3:	a3 08 00 00 00       	mov    %eax,0x8
   116b8:	0f 85 e0 fd ff ff    	jne    1149e <trickles_setucont_impl+0x1be>
   116be:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   116c2:	0f 85 1a 1b 00 00    	jne    131e2 <.text.lock.tmalloc+0x210>
   116c8:	e9 d1 fd ff ff       	jmp    1149e <trickles_setucont_impl+0x1be>
   116cd:	b9 01 00 00 00       	mov    $0x1,%ecx
   116d2:	ba 03 00 00 00       	mov    $0x3,%edx
   116d7:	e8 fc ff ff ff       	call   116d8 <trickles_setucont_impl+0x3f8>
   116dc:	eb c8                	jmp    116a6 <trickles_setucont_impl+0x3c6>
   116de:	89 1c 24             	mov    %ebx,(%esp,1)
   116e1:	e8 fc ff ff ff       	call   116e2 <trickles_setucont_impl+0x402>
   116e6:	eb af                	jmp    11697 <trickles_setucont_impl+0x3b7>
   116e8:	c7 04 24 a9 0a 00 00 	movl   $0xaa9,(%esp,1)
   116ef:	e8 fc ff ff ff       	call   116f0 <trickles_setucont_impl+0x410>
   116f4:	c7 45 f0 f4 ff ff ff 	movl   $0xfffffff4,0xfffffff0(%ebp)
   116fb:	ff 05 08 00 00 00    	incl   0x8
   11701:	8b bb a8 00 00 00    	mov    0xa8(%ebx),%edi
   11707:	85 ff                	test   %edi,%edi
   11709:	75 47                	jne    11752 <trickles_setucont_impl+0x472>
   1170b:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   11712:	8d 43 30             	lea    0x30(%ebx),%eax
   11715:	39 43 30             	cmp    %eax,0x30(%ebx)
   11718:	75 27                	jne    11741 <trickles_setucont_impl+0x461>
   1171a:	ba 08 00 00 00       	mov    $0x8,%edx
   1171f:	a1 08 00 00 00       	mov    0x8,%eax
   11724:	48                   	dec    %eax
   11725:	85 c0                	test   %eax,%eax
   11727:	a3 08 00 00 00       	mov    %eax,0x8
   1172c:	0f 85 6c fd ff ff    	jne    1149e <trickles_setucont_impl+0x1be>
   11732:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   11736:	0f 85 b6 1a 00 00    	jne    131f2 <.text.lock.tmalloc+0x220>
   1173c:	e9 5d fd ff ff       	jmp    1149e <trickles_setucont_impl+0x1be>
   11741:	b9 01 00 00 00       	mov    $0x1,%ecx
   11746:	ba 03 00 00 00       	mov    $0x3,%edx
   1174b:	e8 fc ff ff ff       	call   1174c <trickles_setucont_impl+0x46c>
   11750:	eb c8                	jmp    1171a <trickles_setucont_impl+0x43a>
   11752:	89 1c 24             	mov    %ebx,(%esp,1)
   11755:	e8 fc ff ff ff       	call   11756 <trickles_setucont_impl+0x476>
   1175a:	eb af                	jmp    1170b <trickles_setucont_impl+0x42b>
   1175c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
   11760:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   11763:	8b 41 0c             	mov    0xc(%ecx),%eax
   11766:	e9 65 fc ff ff       	jmp    113d0 <trickles_setucont_impl+0xf0>
   1176b:	90                   	nop    
   1176c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
   11770:	8b 55 0c             	mov    0xc(%ebp),%edx
   11773:	8b 42 0c             	mov    0xc(%edx),%eax
   11776:	e9 55 fc ff ff       	jmp    113d0 <trickles_setucont_impl+0xf0>
   1177b:	90                   	nop    
   1177c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
   11780:	c7 04 24 dc 08 00 00 	movl   $0x8dc,(%esp,1)
   11787:	e8 fc ff ff ff       	call   11788 <trickles_setucont_impl+0x4a8>
   1178c:	ff 05 08 00 00 00    	incl   0x8
   11792:	8b 8b a8 00 00 00    	mov    0xa8(%ebx),%ecx
   11798:	85 c9                	test   %ecx,%ecx
   1179a:	75 4a                	jne    117e6 <trickles_setucont_impl+0x506>
   1179c:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   117a3:	8d 43 30             	lea    0x30(%ebx),%eax
   117a6:	39 43 30             	cmp    %eax,0x30(%ebx)
   117a9:	75 2a                	jne    117d5 <trickles_setucont_impl+0x4f5>
   117ab:	ba 08 00 00 00       	mov    $0x8,%edx
   117b0:	a1 08 00 00 00       	mov    0x8,%eax
   117b5:	48                   	dec    %eax
   117b6:	85 c0                	test   %eax,%eax
   117b8:	a3 08 00 00 00       	mov    %eax,0x8
   117bd:	75 0a                	jne    117c9 <trickles_setucont_impl+0x4e9>
   117bf:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   117c3:	0f 85 39 1a 00 00    	jne    13202 <.text.lock.tmalloc+0x230>
   117c9:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
   117d0:	e9 c9 fc ff ff       	jmp    1149e <trickles_setucont_impl+0x1be>
   117d5:	b9 01 00 00 00       	mov    $0x1,%ecx
   117da:	ba 03 00 00 00       	mov    $0x3,%edx
   117df:	e8 fc ff ff ff       	call   117e0 <trickles_setucont_impl+0x500>
   117e4:	eb c5                	jmp    117ab <trickles_setucont_impl+0x4cb>
   117e6:	89 1c 24             	mov    %ebx,(%esp,1)
   117e9:	e8 fc ff ff ff       	call   117ea <trickles_setucont_impl+0x50a>
   117ee:	eb ac                	jmp    1179c <trickles_setucont_impl+0x4bc>
   117f0:	89 1c 24             	mov    %ebx,(%esp,1)
   117f3:	e8 fc ff ff ff       	call   117f4 <trickles_setucont_impl+0x514>
   117f8:	e9 2c fb ff ff       	jmp    11329 <trickles_setucont_impl+0x49>
   117fd:	8d 76 00             	lea    0x0(%esi),%esi

00011800 <trickles_write_memory_free>:
#endif // USERTEST

/*
 *
 * COMPATIBILITY LAYER
 * This code is responsible for implementing the bytestream conversion protocol
 *
 */


static int trickles_write_memory_free(struct sock *sk) {
   11800:	55                   	push   %ebp
   11801:	89 e5                	mov    %esp,%ebp
   11803:	8b 55 08             	mov    0x8(%ebp),%edx
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	return tp->t.write_seq - tp->t.snd_una < sk->sndbuf;
}
   11806:	5d                   	pop    %ebp
   11807:	8b 82 88 0b 00 00    	mov    0xb88(%edx),%eax
   1180d:	8b 8a 80 0b 00 00    	mov    0xb80(%edx),%ecx
   11813:	29 c8                	sub    %ecx,%eax
   11815:	3b 42 78             	cmp    0x78(%edx),%eax
   11818:	0f 92 c0             	setb   %al
   1181b:	0f b6 c0             	movzbl %al,%eax
   1181e:	c3                   	ret    
   1181f:	90                   	nop    

00011820 <wait_for_write_memory>:

#ifndef USERTEST
/*
 *	Wait for more write memory
 */
static int wait_for_write_memory(struct sock * sk, long *timeo)
{
   11820:	55                   	push   %ebp
   11821:	89 e5                	mov    %esp,%ebp
   11823:	57                   	push   %edi
  /* copied from standard TCP version */
	int err = 0;
	long vm_wait = 0;
   11824:	31 ff                	xor    %edi,%edi
   11826:	56                   	push   %esi
   11827:	53                   	push   %ebx
   11828:	83 ec 30             	sub    $0x30,%esp
   1182b:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
	long current_timeo = *timeo;
   11832:	8b 45 0c             	mov    0xc(%ebp),%eax
   11835:	8b 5d 08             	mov    0x8(%ebp),%ebx
   11838:	8b 30                	mov    (%eax),%esi
	DECLARE_WAITQUEUE(wait, current);
   1183a:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)

static inline struct task_struct * get_current(void)
{
	struct task_struct *current;
	__asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
   11841:	b8 00 e0 ff ff       	mov    $0xffffe000,%eax
   11846:	21 e0                	and    %esp,%eax
   11848:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
   1184f:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
   11856:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)

static inline struct task_struct * get_current(void)
{
	struct task_struct *current;
	__asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
   1185d:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
   11860:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
   11863:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
   1186a:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1186d:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
   11874:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)

	if (trickles_write_memory_free(sk))
   1187b:	89 1c 24             	mov    %ebx,(%esp,1)
   1187e:	e8 7d ff ff ff       	call   11800 <trickles_write_memory_free>
   11883:	85 c0                	test   %eax,%eax
   11885:	0f 85 c8 01 00 00    	jne    11a53 <wait_for_write_memory+0x233>
		current_timeo = vm_wait = (net_random()%(HZ/5))+2;

	add_wait_queue(sk->sleep, &wait);
   1188b:	8b 43 3c             	mov    0x3c(%ebx),%eax
   1188e:	8d 55 e4             	lea    0xffffffe4(%ebp),%edx
   11891:	e8 fc ff ff ff       	call   11892 <wait_for_write_memory+0x72>
	for (;;) {
   11896:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
   11899:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
   1189c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
 * Note that @nr may be almost arbitrarily large; this function is not
 * restricted to acting on a single-word quantity.
 */
static __inline__ void set_bit(int nr, volatile void * addr)
{
   118a0:	31 d2                	xor    %edx,%edx
   118a2:	8b 83 a0 0c 00 00    	mov    0xca0(%ebx),%eax
	__asm__ __volatile__( LOCK_PREFIX
   118a8:	0f ab 50 04          	bts    %edx,0x4(%eax)

struct task_struct;

static inline struct task_struct * get_current(void)
{
   118ac:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   118af:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		set_bit(SOCK_ASYNC_NOSPACE, &sk->socket->flags);

		set_current_state(TASK_INTERRUPTIBLE);

		if (sk->err || (sk->shutdown & SEND_SHUTDOWN))
   118b5:	8b 83 20 0c 00 00    	mov    0xc20(%ebx),%eax
   118bb:	85 c0                	test   %eax,%eax
   118bd:	0f 85 87 01 00 00    	jne    11a4a <wait_for_write_memory+0x22a>
   118c3:	0f b6 43 27          	movzbl 0x27(%ebx),%eax
   118c7:	24 02                	and    $0x2,%al
   118c9:	84 c0                	test   %al,%al
   118cb:	0f 85 79 01 00 00    	jne    11a4a <wait_for_write_memory+0x22a>
			goto do_error;
		if (!*timeo)
   118d1:	8b 45 0c             	mov    0xc(%ebp),%eax
   118d4:	8b 08                	mov    (%eax),%ecx
   118d6:	85 c9                	test   %ecx,%ecx
   118d8:	0f 84 63 01 00 00    	je     11a41 <wait_for_write_memory+0x221>
extern int do_sigaltstack(const stack_t *, stack_t *, unsigned long);

static inline int signal_pending(struct task_struct *p)
{
	return (p->sigpending != 0);
   118de:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   118e1:	31 d2                	xor    %edx,%edx
   118e3:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
   118e7:	0f 95 c2             	setne  %dl
   118ea:	85 d2                	test   %edx,%edx
   118ec:	0f 85 34 01 00 00    	jne    11a26 <wait_for_write_memory+0x206>
 * you should call smp_mb__before_clear_bit() and/or smp_mb__after_clear_bit()
 * in order to ensure changes are visible on other processors.
 */
static __inline__ void clear_bit(int nr, volatile void * addr)
{
   118f2:	8b 83 a0 0c 00 00    	mov    0xca0(%ebx),%eax
	__asm__ __volatile__( LOCK_PREFIX
   118f8:	0f b3 50 04          	btr    %edx,0x4(%eax)
			goto do_nonblock;
		if (signal_pending(current))
			goto do_interrupted;
		clear_bit(SOCK_ASYNC_NOSPACE, &sk->socket->flags);
		if (trickles_write_memory_free(sk) && !vm_wait)
   118fc:	89 1c 24             	mov    %ebx,(%esp,1)
   118ff:	e8 fc fe ff ff       	call   11800 <trickles_write_memory_free>
   11904:	85 c0                	test   %eax,%eax
   11906:	74 08                	je     11910 <wait_for_write_memory+0xf0>
   11908:	85 ff                	test   %edi,%edi
   1190a:	0f 84 f3 00 00 00    	je     11a03 <wait_for_write_memory+0x1e3>
 * Note that @nr may be almost arbitrarily large; this function is not
 * restricted to acting on a single-word quantity.
 */
static __inline__ void set_bit(int nr, volatile void * addr)
{
   11910:	ba 02 00 00 00       	mov    $0x2,%edx
   11915:	8b 83 a0 0c 00 00    	mov    0xca0(%ebx),%eax
	__asm__ __volatile__( LOCK_PREFIX
   1191b:	0f ab 50 04          	bts    %edx,0x4(%eax)
			break;

		set_bit(SOCK_NOSPACE, &sk->socket->flags);
		release_sock(sk);
   1191f:	ff 05 08 00 00 00    	incl   0x8
   11925:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
   1192b:	85 c0                	test   %eax,%eax
   1192d:	0f 85 c3 00 00 00    	jne    119f6 <wait_for_write_memory+0x1d6>
   11933:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   1193a:	8d 43 30             	lea    0x30(%ebx),%eax
   1193d:	39 43 30             	cmp    %eax,0x30(%ebx)
   11940:	0f 85 9c 00 00 00    	jne    119e2 <wait_for_write_memory+0x1c2>
   11946:	ba 08 00 00 00       	mov    $0x8,%edx
   1194b:	a1 08 00 00 00       	mov    0x8,%eax
   11950:	48                   	dec    %eax
   11951:	85 c0                	test   %eax,%eax
   11953:	a3 08 00 00 00       	mov    %eax,0x8
   11958:	75 0a                	jne    11964 <wait_for_write_memory+0x144>
   1195a:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   1195e:	0f 85 ae 18 00 00    	jne    13212 <.text.lock.tmalloc+0x240>
		if (!trickles_write_memory_free(sk) || vm_wait)
   11964:	89 1c 24             	mov    %ebx,(%esp,1)
   11967:	e8 94 fe ff ff       	call   11800 <trickles_write_memory_free>
   1196c:	85 c0                	test   %eax,%eax
   1196e:	74 04                	je     11974 <wait_for_write_memory+0x154>
   11970:	85 ff                	test   %edi,%edi
   11972:	74 09                	je     1197d <wait_for_write_memory+0x15d>
			current_timeo = schedule_timeout(current_timeo);
   11974:	89 f0                	mov    %esi,%eax
   11976:	e8 fc ff ff ff       	call   11977 <wait_for_write_memory+0x157>
   1197b:	89 c6                	mov    %eax,%esi
		lock_sock(sk);
   1197d:	ff 05 08 00 00 00    	incl   0x8
   11983:	8b 43 2c             	mov    0x2c(%ebx),%eax
   11986:	85 c0                	test   %eax,%eax
   11988:	75 4e                	jne    119d8 <wait_for_write_memory+0x1b8>
   1198a:	c7 43 2c 01 00 00 00 	movl   $0x1,0x2c(%ebx)
   11991:	ba 08 00 00 00       	mov    $0x8,%edx
   11996:	a1 08 00 00 00       	mov    0x8,%eax
   1199b:	48                   	dec    %eax
   1199c:	85 c0                	test   %eax,%eax
   1199e:	a3 08 00 00 00       	mov    %eax,0x8
   119a3:	75 0a                	jne    119af <wait_for_write_memory+0x18f>
   119a5:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   119a9:	0f 85 73 18 00 00    	jne    13222 <.text.lock.tmalloc+0x250>

		if (vm_wait) {
   119af:	85 ff                	test   %edi,%edi
   119b1:	74 1b                	je     119ce <wait_for_write_memory+0x1ae>
			vm_wait -= current_timeo;
			current_timeo = *timeo;
   119b3:	8b 45 0c             	mov    0xc(%ebp),%eax
   119b6:	29 f7                	sub    %esi,%edi
   119b8:	8b 30                	mov    (%eax),%esi
			if (current_timeo != MAX_SCHEDULE_TIMEOUT &&
   119ba:	81 fe ff ff ff 7f    	cmp    $0x7fffffff,%esi
   119c0:	74 0a                	je     119cc <wait_for_write_memory+0x1ac>
   119c2:	29 fe                	sub    %edi,%esi
   119c4:	b8 00 00 00 00       	mov    $0x0,%eax
   119c9:	0f 48 f0             	cmovs  %eax,%esi
			    (current_timeo -= vm_wait) < 0)
				current_timeo = 0;
			vm_wait = 0;
   119cc:	31 ff                	xor    %edi,%edi
		}
		*timeo = current_timeo;
   119ce:	8b 45 0c             	mov    0xc(%ebp),%eax
   119d1:	89 30                	mov    %esi,(%eax)
   119d3:	e9 c8 fe ff ff       	jmp    118a0 <wait_for_write_memory+0x80>
   119d8:	89 1c 24             	mov    %ebx,(%esp,1)
   119db:	e8 fc ff ff ff       	call   119dc <wait_for_write_memory+0x1bc>
   119e0:	eb a8                	jmp    1198a <wait_for_write_memory+0x16a>
   119e2:	b9 01 00 00 00       	mov    $0x1,%ecx
   119e7:	ba 03 00 00 00       	mov    $0x3,%edx
   119ec:	e8 fc ff ff ff       	call   119ed <wait_for_write_memory+0x1cd>
   119f1:	e9 50 ff ff ff       	jmp    11946 <wait_for_write_memory+0x126>
   119f6:	89 1c 24             	mov    %ebx,(%esp,1)
   119f9:	e8 fc ff ff ff       	call   119fa <wait_for_write_memory+0x1da>
   119fe:	e9 30 ff ff ff       	jmp    11933 <wait_for_write_memory+0x113>

static inline struct task_struct * get_current(void)
{
	struct task_struct *current;
	__asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
   11a03:	b8 00 e0 ff ff       	mov    $0xffffe000,%eax
	}
out:
	current->state = TASK_RUNNING;
	remove_wait_queue(sk->sleep, &wait);
   11a08:	8d 55 e4             	lea    0xffffffe4(%ebp),%edx

static inline struct task_struct * get_current(void)
{
	struct task_struct *current;
	__asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
   11a0b:	21 e0                	and    %esp,%eax
   11a0d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   11a13:	8b 43 3c             	mov    0x3c(%ebx),%eax
   11a16:	e8 fc ff ff ff       	call   11a17 <wait_for_write_memory+0x1f7>
	return err;
   11a1b:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   11a1e:	83 c4 30             	add    $0x30,%esp
   11a21:	5b                   	pop    %ebx
   11a22:	5e                   	pop    %esi
   11a23:	5f                   	pop    %edi
   11a24:	5d                   	pop    %ebp
   11a25:	c3                   	ret    
 * Compare this to poll().
 */
static inline int sock_intr_errno(long timeo)
{
	return timeo == MAX_SCHEDULE_TIMEOUT ? -ERESTARTSYS : -EINTR;
   11a26:	c7 45 d0 00 fe ff ff 	movl   $0xfffffe00,0xffffffd0(%ebp)
   11a2d:	81 f9 ff ff ff 7f    	cmp    $0x7fffffff,%ecx
   11a33:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
   11a38:	0f 44 45 d0          	cmove  0xffffffd0(%ebp),%eax
   11a3c:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
   11a3f:	eb c2                	jmp    11a03 <wait_for_write_memory+0x1e3>

do_error:
	err = -EPIPE;
	goto out;
do_nonblock:
	err = -EAGAIN;
   11a41:	c7 45 d0 f5 ff ff ff 	movl   $0xfffffff5,0xffffffd0(%ebp)
	goto out;
   11a48:	eb b9                	jmp    11a03 <wait_for_write_memory+0x1e3>
   11a4a:	c7 45 d0 e0 ff ff ff 	movl   $0xffffffe0,0xffffffd0(%ebp)
   11a51:	eb b0                	jmp    11a03 <wait_for_write_memory+0x1e3>
   11a53:	e8 fc ff ff ff       	call   11a54 <wait_for_write_memory+0x234>
   11a58:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
   11a5d:	89 c1                	mov    %eax,%ecx
   11a5f:	f7 e2                	mul    %edx
   11a61:	c1 ea 04             	shr    $0x4,%edx
   11a64:	8d 14 92             	lea    (%edx,%edx,4),%edx
   11a67:	c1 e2 02             	shl    $0x2,%edx
   11a6a:	29 d1                	sub    %edx,%ecx
   11a6c:	8d 79 02             	lea    0x2(%ecx),%edi
   11a6f:	89 fe                	mov    %edi,%esi
   11a71:	e9 15 fe ff ff       	jmp    1188b <wait_for_write_memory+0x6b>
   11a76:	8d 76 00             	lea    0x0(%esi),%esi
   11a79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00011a80 <trickles_client_sendmsg>:
do_interrupted:
	err = sock_intr_errno(*timeo);
	goto out;
}
#else
static int wait_for_write_memory(struct sock * sk, long *timeo) {
  printk("Not implemented for userspace test\n");
  assert(0);
}
#endif // USERTEST

int trickles_client_sendmsg(struct sock *sk, struct msghdr *msg, int size) {
   11a80:	55                   	push   %ebp
   11a81:	89 e5                	mov    %esp,%ebp
   11a83:	57                   	push   %edi
   11a84:	56                   	push   %esi
	int i;
	int iovlen, totalLen = 0, skb_spaceleft = 0, result = 0, position = 0;
	// NOT tiovec: these are mapped to send()
	struct iovec *iov;
	struct sk_buff *skb = NULL;
   11a85:	31 f6                	xor    %esi,%esi
   11a87:	53                   	push   %ebx
   11a88:	83 ec 34             	sub    $0x34,%esp
   11a8b:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
   11a92:	8b 55 08             	mov    0x8(%ebp),%edx
   11a95:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
   11a9c:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a9f:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
   11aa6:	81 c2 bc 00 00 00    	add    $0xbc,%edx
   11aac:	89 55 d4             	mov    %edx,0xffffffd4(%ebp)
	iov = msg->msg_iov;
   11aaf:	8b 48 08             	mov    0x8(%eax),%ecx
   11ab2:	89 4d d8             	mov    %ecx,0xffffffd8(%ebp)
	iovlen = msg->msg_iovlen;
   11ab5:	8b 40 0c             	mov    0xc(%eax),%eax

	for(i=0; i < iovlen; i++) {
   11ab8:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
   11abf:	39 c6                	cmp    %eax,%esi
   11ac1:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   11ac4:	7d 22                	jge    11ae8 <trickles_client_sendmsg+0x68>
   11ac6:	8d 76 00             	lea    0x0(%esi),%esi
   11ac9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
		totalLen += iov[i].iov_len;
   11ad0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   11ad3:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   11ad6:	8b 44 c2 04          	mov    0x4(%edx,%eax,8),%eax
   11ada:	ff 45 ec             	incl   0xffffffec(%ebp)
   11add:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   11ae0:	01 45 e4             	add    %eax,0xffffffe4(%ebp)
   11ae3:	39 55 ec             	cmp    %edx,0xffffffec(%ebp)
   11ae6:	7c e8                	jl     11ad0 <trickles_client_sendmsg+0x50>
	}
	// Sleep if not enough space 
	lock_sock(sk);
   11ae8:	ff 05 08 00 00 00    	incl   0x8
   11aee:	8b 4d 08             	mov    0x8(%ebp),%ecx
   11af1:	8b 79 2c             	mov    0x2c(%ecx),%edi
   11af4:	85 ff                	test   %edi,%edi
   11af6:	0f 85 e2 03 00 00    	jne    11ede <trickles_client_sendmsg+0x45e>
   11afc:	8b 45 08             	mov    0x8(%ebp),%eax
   11aff:	ba 08 00 00 00       	mov    $0x8,%edx
   11b04:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
   11b0b:	a1 08 00 00 00       	mov    0x8,%eax
   11b10:	48                   	dec    %eax
   11b11:	85 c0                	test   %eax,%eax
   11b13:	a3 08 00 00 00       	mov    %eax,0x8
   11b18:	75 0a                	jne    11b24 <trickles_client_sendmsg+0xa4>
   11b1a:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   11b1e:	0f 85 0e 17 00 00    	jne    13232 <.text.lock.tmalloc+0x260>

	for(i=0; i < iovlen; i++) {
   11b24:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
   11b2b:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   11b2e:	39 55 ec             	cmp    %edx,0xffffffec(%ebp)
   11b31:	0f 8d 65 01 00 00    	jge    11c9c <trickles_client_sendmsg+0x21c>
		char *buf;
		int iov_position = 0;
   11b37:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
		while(iov_position < iov[i].iov_len) {
   11b3e:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
   11b41:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   11b44:	8b 44 ca 04          	mov    0x4(%edx,%ecx,8),%eax
   11b48:	39 45 d0             	cmp    %eax,0xffffffd0(%ebp)
   11b4b:	0f 83 3c 01 00 00    	jae    11c8d <trickles_client_sendmsg+0x20d>
   11b51:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
   11b54:	81 c1 d0 0a 00 00    	add    $0xad0,%ecx
   11b5a:	89 4d cc             	mov    %ecx,0xffffffcc(%ebp)
			int copyLen;
			if(skb_spaceleft == 0) {
   11b5d:	8b 5d e0             	mov    0xffffffe0(%ebp),%ebx
   11b60:	85 db                	test   %ebx,%ebx
   11b62:	0f 85 ae 00 00 00    	jne    11c16 <trickles_client_sendmsg+0x196>
				if(skb != NULL) {
   11b68:	85 f6                	test   %esi,%esi
   11b6a:	74 2d                	je     11b99 <trickles_client_sendmsg+0x119>
					// queue previous skb
					tp->t.write_seq += skb->len;
   11b6c:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
   11b6f:	8b 46 70             	mov    0x70(%esi),%eax
   11b72:	8b 8a cc 0a 00 00    	mov    0xacc(%edx),%ecx
   11b78:	01 c8                	add    %ecx,%eax
   11b7a:	89 82 cc 0a 00 00    	mov    %eax,0xacc(%edx)
					TCP_SKB_CB(skb)->end_seq = tp->t.write_seq;
   11b80:	89 46 44             	mov    %eax,0x44(%esi)
static inline void __skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
	struct sk_buff *prev, *next;

	newsk->list = list;
   11b83:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
	list->qlen++;
	next = (struct sk_buff *)list;
	prev = next->prev;
   11b86:	8b 41 04             	mov    0x4(%ecx),%eax
   11b89:	89 4e 08             	mov    %ecx,0x8(%esi)
   11b8c:	ff 41 08             	incl   0x8(%ecx)
	newsk->next = next;
   11b8f:	89 0e                	mov    %ecx,(%esi)
	newsk->prev = prev;
   11b91:	89 46 04             	mov    %eax,0x4(%esi)
	next->prev = newsk;
	prev->next = newsk;
   11b94:	89 30                	mov    %esi,(%eax)
   11b96:	89 71 04             	mov    %esi,0x4(%ecx)
					__skb_queue_tail(&tp->t.requestBytes, skb);
				}
				if(!TRICKLES_HAS_SENDSPACE(sk)) {
   11b99:	8b 45 08             	mov    0x8(%ebp),%eax
   11b9c:	8b 70 78             	mov    0x78(%eax),%esi
   11b9f:	89 c2                	mov    %eax,%edx
   11ba1:	8b 80 80 0b 00 00    	mov    0xb80(%eax),%eax
   11ba7:	01 f0                	add    %esi,%eax
   11ba9:	39 82 88 0b 00 00    	cmp    %eax,0xb88(%edx)
   11baf:	0f 83 d0 02 00 00    	jae    11e85 <trickles_client_sendmsg+0x405>
					long timeout;
				sleep:
					timeout = HZ/10;
					wait_for_write_memory(sk, &timeout);
				}
				BUG_TRAP(tp->t.write_seq - tp->t.snd_una <= sk->sndbuf);
   11bb5:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
   11bb8:	8b 9a cc 0a 00 00    	mov    0xacc(%edx),%ebx
   11bbe:	8b 8a c4 0a 00 00    	mov    0xac4(%edx),%ecx
   11bc4:	89 d8                	mov    %ebx,%eax
   11bc6:	29 c8                	sub    %ecx,%eax
   11bc8:	39 f0                	cmp    %esi,%eax
   11bca:	0f 87 e0 02 00 00    	ja     11eb0 <trickles_client_sendmsg+0x430>
				skb_spaceleft = MIN(sk->sndbuf - (tp->t.write_seq - tp->t.snd_una), totalLen - position);
				//skb = alloc_skb(skb_spaceleft, GFP_KERNEL);
				skb = alloc_skb(skb_spaceleft, GFP_ATOMIC);
   11bd0:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
   11bd7:	00 
   11bd8:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   11bdb:	29 cb                	sub    %ecx,%ebx
   11bdd:	8b 7d dc             	mov    0xffffffdc(%ebp),%edi
   11be0:	89 f0                	mov    %esi,%eax
   11be2:	29 d8                	sub    %ebx,%eax
   11be4:	29 fa                	sub    %edi,%edx
   11be6:	39 c2                	cmp    %eax,%edx
   11be8:	0f 46 c2             	cmovbe %edx,%eax
   11beb:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   11bee:	89 04 24             	mov    %eax,(%esp,1)
   11bf1:	e8 fc ff ff ff       	call   11bf2 <trickles_client_sendmsg+0x172>
				if(skb == NULL) {
   11bf6:	85 c0                	test   %eax,%eax
   11bf8:	89 c6                	mov    %eax,%esi
   11bfa:	0f 84 79 02 00 00    	je     11e79 <trickles_client_sendmsg+0x3f9>
					printk("Trickles_client_sendmsg: out of memory\n");
					goto sleep;
				}
				TCP_SKB_CB(skb)->seq = tp->t.write_seq;
   11c00:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
   11c03:	8b 81 cc 0a 00 00    	mov    0xacc(%ecx),%eax
   11c09:	89 46 40             	mov    %eax,0x40(%esi)
   11c0c:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   11c0f:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
   11c12:	8b 44 d1 04          	mov    0x4(%ecx,%edx,8),%eax
			}
			copyLen = MIN(iov[i].iov_len - iov_position, skb_spaceleft);
   11c16:	8b 55 d0             	mov    0xffffffd0(%ebp),%edx
   11c19:	8b 5d e0             	mov    0xffffffe0(%ebp),%ebx
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
   11c1c:	8b be 98 00 00 00    	mov    0x98(%esi),%edi
   11c22:	29 d0                	sub    %edx,%eax
   11c24:	39 45 e0             	cmp    %eax,0xffffffe0(%ebp)
   11c27:	0f 47 d8             	cmova  %eax,%ebx
	return result;
}

static inline int skb_is_nonlinear(const struct sk_buff *skb)
{
   11c2a:	8b 46 74             	mov    0x74(%esi),%eax
   11c2d:	85 c0                	test   %eax,%eax
   11c2f:	0f 85 b6 02 00 00    	jne    11eeb <trickles_client_sendmsg+0x46b>
	return skb->data_len;
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
	return skb->len - skb->data_len;
}

#define SKB_PAGE_ASSERT(skb) do { if (skb_shinfo(skb)->nr_frags) out_of_line_bug(); } while (0)
#define SKB_FRAG_ASSERT(skb) do { if (skb_shinfo(skb)->frag_list) out_of_line_bug(); } while (0)
#define SKB_LINEAR_ASSERT(skb) do { if (skb_is_nonlinear(skb)) out_of_line_bug(); } while (0)

/*
 *	Add data to an sk_buff
 */
 
static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	return tmp;
}

/**
 *	skb_put - add data to a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer. If this would
 *	exceed the total buffer size the kernel will panic. A pointer to the
 *	first byte of the extra data is returned.
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
   11c35:	01 5e 70             	add    %ebx,0x70(%esi)
   11c38:	8d 04 3b             	lea    (%ebx,%edi,1),%eax
	if(skb->tail>skb->end) {
   11c3b:	3b 86 9c 00 00 00    	cmp    0x9c(%esi),%eax
   11c41:	89 86 98 00 00 00    	mov    %eax,0x98(%esi)
   11c47:	0f 87 13 02 00 00    	ja     11e60 <trickles_client_sendmsg+0x3e0>
			buf = skb_put(skb, copyLen);
			if(copy_from_user(buf, iov[i].iov_base + iov_position, copyLen)) {
   11c4d:	89 5c 24 08          	mov    %ebx,0x8(%esp,1)
   11c51:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   11c54:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
   11c57:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   11c5a:	03 04 d1             	add    (%ecx,%edx,8),%eax
   11c5d:	89 3c 24             	mov    %edi,(%esp,1)
   11c60:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   11c64:	e8 fc ff ff ff       	call   11c65 <trickles_client_sendmsg+0x1e5>
   11c69:	85 c0                	test   %eax,%eax
   11c6b:	0f 85 57 01 00 00    	jne    11dc8 <trickles_client_sendmsg+0x348>
				printk("Trickles_client_sendmsg: fault while copying from client\n");
				result = -EFAULT;
				goto out_dealloc;
			}
			skb_spaceleft -= copyLen;
   11c71:	29 5d e0             	sub    %ebx,0xffffffe0(%ebp)
			position += copyLen;
			iov_position += copyLen;
   11c74:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   11c77:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
   11c7a:	01 5d dc             	add    %ebx,0xffffffdc(%ebp)
   11c7d:	01 5d d0             	add    %ebx,0xffffffd0(%ebp)
   11c80:	8b 44 d1 04          	mov    0x4(%ecx,%edx,8),%eax
   11c84:	39 45 d0             	cmp    %eax,0xffffffd0(%ebp)
   11c87:	0f 82 d0 fe ff ff    	jb     11b5d <trickles_client_sendmsg+0xdd>
   11c8d:	ff 45 ec             	incl   0xffffffec(%ebp)
   11c90:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   11c93:	39 45 ec             	cmp    %eax,0xffffffec(%ebp)
   11c96:	0f 8c 9b fe ff ff    	jl     11b37 <trickles_client_sendmsg+0xb7>
		}
	}
	BUG_TRAP(skb_spaceleft == 0);
   11c9c:	8b 7d e0             	mov    0xffffffe0(%ebp),%edi
   11c9f:	85 ff                	test   %edi,%edi
   11ca1:	0f 85 08 01 00 00    	jne    11daf <trickles_client_sendmsg+0x32f>
	if(skb != NULL) {
   11ca7:	85 f6                	test   %esi,%esi
   11ca9:	74 31                	je     11cdc <trickles_client_sendmsg+0x25c>
		// queue previous skb
		tp->t.write_seq += skb->len;
   11cab:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
   11cae:	8b 46 70             	mov    0x70(%esi),%eax
   11cb1:	8b 9a cc 0a 00 00    	mov    0xacc(%edx),%ebx
   11cb7:	01 d8                	add    %ebx,%eax
   11cb9:	89 82 cc 0a 00 00    	mov    %eax,0xacc(%edx)
		TCP_SKB_CB(skb)->end_seq = tp->t.write_seq;
   11cbf:	89 46 44             	mov    %eax,0x44(%esi)
 */	
 

static inline void __skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
   11cc2:	89 d0                	mov    %edx,%eax
   11cc4:	05 d0 0a 00 00       	add    $0xad0,%eax
	struct sk_buff *prev, *next;

	newsk->list = list;
   11cc9:	89 46 08             	mov    %eax,0x8(%esi)
	list->qlen++;
	next = (struct sk_buff *)list;
	prev = next->prev;
   11ccc:	8b 50 04             	mov    0x4(%eax),%edx
   11ccf:	ff 40 08             	incl   0x8(%eax)
	newsk->next = next;
   11cd2:	89 06                	mov    %eax,(%esi)
	newsk->prev = prev;
   11cd4:	89 56 04             	mov    %edx,0x4(%esi)
	next->prev = newsk;
	prev->next = newsk;
   11cd7:	89 32                	mov    %esi,(%edx)
   11cd9:	89 70 04             	mov    %esi,0x4(%eax)
		__skb_queue_tail(&tp->t.requestBytes, skb);
	}

	if(tp->t.write_seq - tp->t.snd_una > 0) {
   11cdc:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
   11cdf:	8b 81 c4 0a 00 00    	mov    0xac4(%ecx),%eax
   11ce5:	39 81 cc 0a 00 00    	cmp    %eax,0xacc(%ecx)
   11ceb:	74 19                	je     11d06 <trickles_client_sendmsg+0x286>
		switch(tp->t.conversionState) {
   11ced:	8b 81 c0 0a 00 00    	mov    0xac0(%ecx),%eax
   11cf3:	83 f8 01             	cmp    $0x1,%eax
   11cf6:	74 0e                	je     11d06 <trickles_client_sendmsg+0x286>
   11cf8:	83 f8 01             	cmp    $0x1,%eax
   11cfb:	0f 8e 99 00 00 00    	jle    11d9a <trickles_client_sendmsg+0x31a>
   11d01:	83 f8 02             	cmp    $0x2,%eax
   11d04:	74 6b                	je     11d71 <trickles_client_sendmsg+0x2f1>
		case CONVERSION_IDLE:
			queueConversionRequests(sk);
			tp->t.conversionState = CONVERSION_WAITFORSERVER;
			pushRequests(sk);
			//printk("trickles_sendmsg(0) set conversion state to waitforserver\n");
			break;
		case CONVERSION_WAITFORUSER:
			finishIncompleteRequest(sk);
			tp->t.conversionState = CONVERSION_WAITFORSERVER;
			pushRequests(sk);
			//printk("trickles_sendmsg(1) set conversion state to waitforserver\n");
			break;
		case CONVERSION_WAITFORSERVER:
			// do nothing, since the new data may need to be appended to an existing conversion
			break;
		}
	}

#if 0
	printk("trickles_client_sendmsg (%p): iov[0] = %d@%p, snd_una = %d write_seq = %d\n", 
	       sk, 
	       iov[0].iov_len, iov[0].iov_base, 
	       tp->t.snd_una, tp->t.write_seq);
#endif
	release_sock(sk);
   11d06:	ff 05 08 00 00 00    	incl   0x8
   11d0c:	8b 45 08             	mov    0x8(%ebp),%eax
   11d0f:	8b 90 a8 00 00 00    	mov    0xa8(%eax),%edx
   11d15:	85 d2                	test   %edx,%edx
   11d17:	75 4e                	jne    11d67 <trickles_client_sendmsg+0x2e7>
   11d19:	8b 55 08             	mov    0x8(%ebp),%edx
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   11d1c:	89 d0                	mov    %edx,%eax
   11d1e:	83 c0 30             	add    $0x30,%eax
   11d21:	39 42 30             	cmp    %eax,0x30(%edx)
   11d24:	c7 42 2c 00 00 00 00 	movl   $0x0,0x2c(%edx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   11d2b:	75 29                	jne    11d56 <trickles_client_sendmsg+0x2d6>
   11d2d:	ba 08 00 00 00       	mov    $0x8,%edx
   11d32:	a1 08 00 00 00       	mov    0x8,%eax
   11d37:	48                   	dec    %eax
   11d38:	85 c0                	test   %eax,%eax
   11d3a:	a3 08 00 00 00       	mov    %eax,0x8
   11d3f:	75 0a                	jne    11d4b <trickles_client_sendmsg+0x2cb>
   11d41:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   11d45:	0f 85 f7 14 00 00    	jne    13242 <.text.lock.tmalloc+0x270>
	return totalLen;
   11d4b:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax

 out_dealloc:
	kfree_skb(skb);
	release_sock(sk);
	return result;
}
   11d4e:	83 c4 34             	add    $0x34,%esp
   11d51:	5b                   	pop    %ebx
   11d52:	5e                   	pop    %esi
   11d53:	5f                   	pop    %edi
   11d54:	5d                   	pop    %ebp
   11d55:	c3                   	ret    
   11d56:	b9 01 00 00 00       	mov    $0x1,%ecx
   11d5b:	ba 03 00 00 00       	mov    $0x3,%edx
   11d60:	e8 fc ff ff ff       	call   11d61 <trickles_client_sendmsg+0x2e1>
   11d65:	eb c6                	jmp    11d2d <trickles_client_sendmsg+0x2ad>
   11d67:	89 04 24             	mov    %eax,(%esp,1)
   11d6a:	e8 fc ff ff ff       	call   11d6b <trickles_client_sendmsg+0x2eb>
   11d6f:	eb a8                	jmp    11d19 <trickles_client_sendmsg+0x299>
   11d71:	8b 45 08             	mov    0x8(%ebp),%eax
   11d74:	89 04 24             	mov    %eax,(%esp,1)
   11d77:	e8 fc ff ff ff       	call   11d78 <trickles_client_sendmsg+0x2f8>
   11d7c:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
   11d7f:	b9 01 00 00 00       	mov    $0x1,%ecx
   11d84:	89 8a c0 0a 00 00    	mov    %ecx,0xac0(%edx)
   11d8a:	8b 4d 08             	mov    0x8(%ebp),%ecx
   11d8d:	89 0c 24             	mov    %ecx,(%esp,1)
   11d90:	e8 fc ff ff ff       	call   11d91 <trickles_client_sendmsg+0x311>
   11d95:	e9 6c ff ff ff       	jmp    11d06 <trickles_client_sendmsg+0x286>
   11d9a:	85 c0                	test   %eax,%eax
   11d9c:	0f 85 64 ff ff ff    	jne    11d06 <trickles_client_sendmsg+0x286>
   11da2:	8b 45 08             	mov    0x8(%ebp),%eax
   11da5:	89 04 24             	mov    %eax,(%esp,1)
   11da8:	e8 fc ff ff ff       	call   11da9 <trickles_client_sendmsg+0x329>
   11dad:	eb cd                	jmp    11d7c <trickles_client_sendmsg+0x2fc>
   11daf:	c7 44 24 04 54 06 00 	movl   $0x654,0x4(%esp,1)
   11db6:	00 
   11db7:	c7 04 24 00 41 00 00 	movl   $0x4100,(%esp,1)
   11dbe:	e8 fc ff ff ff       	call   11dbf <trickles_client_sendmsg+0x33f>
   11dc3:	e9 df fe ff ff       	jmp    11ca7 <trickles_client_sendmsg+0x227>
   11dc8:	c7 04 24 60 41 00 00 	movl   $0x4160,(%esp,1)
   11dcf:	e8 fc ff ff ff       	call   11dd0 <trickles_client_sendmsg+0x350>
 */
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
   11dd4:	8b 86 84 00 00 00    	mov    0x84(%esi),%eax
   11dda:	48                   	dec    %eax
   11ddb:	74 0d                	je     11dea <trickles_client_sendmsg+0x36a>
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
	unsigned char c;

	__asm__ __volatile__(
   11ddd:	ff 8e 84 00 00 00    	decl   0x84(%esi)
   11de3:	0f 94 c0             	sete   %al
   11de6:	84 c0                	test   %al,%al
   11de8:	74 08                	je     11df2 <trickles_client_sendmsg+0x372>
 
static inline void kfree_skb(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
		__kfree_skb(skb);
   11dea:	89 34 24             	mov    %esi,(%esp,1)
   11ded:	e8 fc ff ff ff       	call   11dee <trickles_client_sendmsg+0x36e>
   11df2:	ff 05 08 00 00 00    	incl   0x8
   11df8:	8b 4d 08             	mov    0x8(%ebp),%ecx
   11dfb:	8b 81 a8 00 00 00    	mov    0xa8(%ecx),%eax
   11e01:	85 c0                	test   %eax,%eax
   11e03:	75 51                	jne    11e56 <trickles_client_sendmsg+0x3d6>
   11e05:	8b 45 08             	mov    0x8(%ebp),%eax
   11e08:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   11e0f:	8b 45 08             	mov    0x8(%ebp),%eax
   11e12:	8b 55 08             	mov    0x8(%ebp),%edx
   11e15:	83 c0 30             	add    $0x30,%eax
   11e18:	39 42 30             	cmp    %eax,0x30(%edx)
   11e1b:	75 28                	jne    11e45 <trickles_client_sendmsg+0x3c5>
   11e1d:	ba 08 00 00 00       	mov    $0x8,%edx
   11e22:	a1 08 00 00 00       	mov    0x8,%eax
   11e27:	48                   	dec    %eax
   11e28:	85 c0                	test   %eax,%eax
   11e2a:	a3 08 00 00 00       	mov    %eax,0x8
   11e2f:	75 0a                	jne    11e3b <trickles_client_sendmsg+0x3bb>
   11e31:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   11e35:	0f 85 17 14 00 00    	jne    13252 <.text.lock.tmalloc+0x280>
   11e3b:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
   11e40:	e9 09 ff ff ff       	jmp    11d4e <trickles_client_sendmsg+0x2ce>
   11e45:	b9 01 00 00 00       	mov    $0x1,%ecx
   11e4a:	ba 03 00 00 00       	mov    $0x3,%edx
   11e4f:	e8 fc ff ff ff       	call   11e50 <trickles_client_sendmsg+0x3d0>
   11e54:	eb c7                	jmp    11e1d <trickles_client_sendmsg+0x39d>
   11e56:	89 0c 24             	mov    %ecx,(%esp,1)
   11e59:	e8 fc ff ff ff       	call   11e5a <trickles_client_sendmsg+0x3da>
   11e5e:	eb a5                	jmp    11e05 <trickles_client_sendmsg+0x385>
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	if(skb->tail>skb->end) {
		skb_over_panic(skb, len, current_text_addr());
   11e60:	c7 44 24 08 68 1e 01 	movl   $0x11e68,0x8(%esp,1)
   11e67:	00 
   11e68:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
   11e6c:	89 34 24             	mov    %esi,(%esp,1)
   11e6f:	e8 fc ff ff ff       	call   11e70 <trickles_client_sendmsg+0x3f0>
   11e74:	e9 d4 fd ff ff       	jmp    11c4d <trickles_client_sendmsg+0x1cd>
   11e79:	c7 04 24 a0 41 00 00 	movl   $0x41a0,(%esp,1)
   11e80:	e8 fc ff ff ff       	call   11e81 <trickles_client_sendmsg+0x401>
   11e85:	c7 45 f0 0a 00 00 00 	movl   $0xa,0xfffffff0(%ebp)
   11e8c:	8b 4d 08             	mov    0x8(%ebp),%ecx
   11e8f:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   11e92:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   11e96:	89 0c 24             	mov    %ecx,(%esp,1)
   11e99:	e8 82 f9 ff ff       	call   11820 <wait_for_write_memory>
   11e9e:	8b 45 08             	mov    0x8(%ebp),%eax
   11ea1:	8b 70 78             	mov    0x78(%eax),%esi
   11ea4:	e9 0c fd ff ff       	jmp    11bb5 <trickles_client_sendmsg+0x135>
   11ea9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
   11eb0:	c7 44 24 04 3e 06 00 	movl   $0x63e,0x4(%esp,1)
   11eb7:	00 
   11eb8:	c7 04 24 e0 41 00 00 	movl   $0x41e0,(%esp,1)
   11ebf:	e8 fc ff ff ff       	call   11ec0 <trickles_client_sendmsg+0x440>
   11ec4:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
   11ec7:	8b 45 08             	mov    0x8(%ebp),%eax
   11eca:	8b 99 cc 0a 00 00    	mov    0xacc(%ecx),%ebx
   11ed0:	8b 70 78             	mov    0x78(%eax),%esi
   11ed3:	8b 89 c4 0a 00 00    	mov    0xac4(%ecx),%ecx
   11ed9:	e9 f2 fc ff ff       	jmp    11bd0 <trickles_client_sendmsg+0x150>
   11ede:	89 0c 24             	mov    %ecx,(%esp,1)
   11ee1:	e8 fc ff ff ff       	call   11ee2 <trickles_client_sendmsg+0x462>
   11ee6:	e9 11 fc ff ff       	jmp    11afc <trickles_client_sendmsg+0x7c>
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
   11eeb:	c7 04 24 24 03 00 00 	movl   $0x324,(%esp,1)
   11ef2:	e8 fc ff ff ff       	call   11ef3 <trickles_client_sendmsg+0x473>
   11ef7:	89 f6                	mov    %esi,%esi
   11ef9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00011f00 <tcp_data_wait>:

#ifndef USERTEST
/* tcp_data_wait: copied from tcp.c */

static long tcp_data_wait(struct sock *sk, long timeo)
{
   11f00:	55                   	push   %ebp
   11f01:	89 e5                	mov    %esp,%ebp
   11f03:	57                   	push   %edi
	DECLARE_WAITQUEUE(wait, current);

	add_wait_queue(sk->sleep, &wait);
   11f04:	8d 55 e4             	lea    0xffffffe4(%ebp),%edx
   11f07:	56                   	push   %esi

static inline struct task_struct * get_current(void)
{
	struct task_struct *current;
	__asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
   11f08:	be 00 e0 ff ff       	mov    $0xffffe000,%esi
   11f0d:	21 e6                	and    %esp,%esi
   11f0f:	53                   	push   %ebx
   11f10:	83 ec 24             	sub    $0x24,%esp
   11f13:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
   11f1a:	8b 5d 08             	mov    0x8(%ebp),%ebx
   11f1d:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
   11f24:	8b 7d 0c             	mov    0xc(%ebp),%edi
   11f27:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
   11f2e:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)

struct task_struct;

static inline struct task_struct * get_current(void)
{
   11f35:	89 75 d8             	mov    %esi,0xffffffd8(%ebp)
   11f38:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
   11f3f:	89 75 e8             	mov    %esi,0xffffffe8(%ebp)
   11f42:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
   11f49:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
   11f50:	8b 43 3c             	mov    0x3c(%ebx),%eax
   11f53:	e8 fc ff ff ff       	call   11f54 <tcp_data_wait+0x54>

struct task_struct;

static inline struct task_struct * get_current(void)
{
   11f58:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
 * Note that @nr may be almost arbitrarily large; this function is not
 * restricted to acting on a single-word quantity.
 */
static __inline__ void set_bit(int nr, volatile void * addr)
{
   11f5e:	ba 01 00 00 00       	mov    $0x1,%edx
   11f63:	8b 83 a0 0c 00 00    	mov    0xca0(%ebx),%eax
	__asm__ __volatile__( LOCK_PREFIX
   11f69:	0f ab 50 04          	bts    %edx,0x4(%eax)

	__set_current_state(TASK_INTERRUPTIBLE);

	set_bit(SOCK_ASYNC_WAITDATA, &sk->socket->flags);
	release_sock(sk);
   11f6d:	ff 05 08 00 00 00    	incl   0x8
   11f73:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
   11f79:	85 c0                	test   %eax,%eax
   11f7b:	0f 85 c3 00 00 00    	jne    12044 <tcp_data_wait+0x144>
   11f81:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   11f88:	8d 43 30             	lea    0x30(%ebx),%eax
   11f8b:	39 43 30             	cmp    %eax,0x30(%ebx)
   11f8e:	0f 85 9c 00 00 00    	jne    12030 <tcp_data_wait+0x130>
   11f94:	ba 08 00 00 00       	mov    $0x8,%edx
   11f99:	a1 08 00 00 00       	mov    0x8,%eax
   11f9e:	48                   	dec    %eax
   11f9f:	85 c0                	test   %eax,%eax
   11fa1:	a3 08 00 00 00       	mov    %eax,0x8
   11fa6:	75 0a                	jne    11fb2 <tcp_data_wait+0xb2>
   11fa8:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   11fac:	0f 85 b0 12 00 00    	jne    13262 <.text.lock.tmalloc+0x290>
 *	Returns true if the queue is empty, false otherwise.
 */
 
static inline int skb_queue_empty(struct sk_buff_head *list)
{
   11fb2:	8d 43 48             	lea    0x48(%ebx),%eax
   11fb5:	39 43 48             	cmp    %eax,0x48(%ebx)
   11fb8:	74 66                	je     12020 <tcp_data_wait+0x120>

	if (skb_queue_empty(&sk->receive_queue))
		timeo = schedule_timeout(timeo);

	lock_sock(sk);
   11fba:	ff 05 08 00 00 00    	incl   0x8
   11fc0:	8b 43 2c             	mov    0x2c(%ebx),%eax
   11fc3:	85 c0                	test   %eax,%eax
   11fc5:	75 4b                	jne    12012 <tcp_data_wait+0x112>
   11fc7:	c7 43 2c 01 00 00 00 	movl   $0x1,0x2c(%ebx)
   11fce:	ba 08 00 00 00       	mov    $0x8,%edx
   11fd3:	a1 08 00 00 00       	mov    0x8,%eax
   11fd8:	48                   	dec    %eax
   11fd9:	85 c0                	test   %eax,%eax
   11fdb:	a3 08 00 00 00       	mov    %eax,0x8
   11fe0:	75 0a                	jne    11fec <tcp_data_wait+0xec>
   11fe2:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   11fe6:	0f 85 86 12 00 00    	jne    13272 <.text.lock.tmalloc+0x2a0>
 * you should call smp_mb__before_clear_bit() and/or smp_mb__after_clear_bit()
 * in order to ensure changes are visible on other processors.
 */
static __inline__ void clear_bit(int nr, volatile void * addr)
{
   11fec:	8b 83 a0 0c 00 00    	mov    0xca0(%ebx),%eax
	__asm__ __volatile__( LOCK_PREFIX
   11ff2:	0f ba 70 04 01       	btrl   $0x1,0x4(%eax)
	clear_bit(SOCK_ASYNC_WAITDATA, &sk->socket->flags);

	remove_wait_queue(sk->sleep, &wait);
   11ff7:	8d 55 e4             	lea    0xffffffe4(%ebp),%edx
   11ffa:	8b 43 3c             	mov    0x3c(%ebx),%eax
   11ffd:	e8 fc ff ff ff       	call   11ffe <tcp_data_wait+0xfe>

struct task_struct;

static inline struct task_struct * get_current(void)
{
   12002:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
	__set_current_state(TASK_RUNNING);
	return timeo;
}
   12008:	83 c4 24             	add    $0x24,%esp
   1200b:	89 f8                	mov    %edi,%eax
   1200d:	5b                   	pop    %ebx
   1200e:	5e                   	pop    %esi
   1200f:	5f                   	pop    %edi
   12010:	5d                   	pop    %ebp
   12011:	c3                   	ret    
   12012:	89 1c 24             	mov    %ebx,(%esp,1)
   12015:	e8 fc ff ff ff       	call   12016 <tcp_data_wait+0x116>
   1201a:	eb ab                	jmp    11fc7 <tcp_data_wait+0xc7>
   1201c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
   12020:	89 f8                	mov    %edi,%eax
   12022:	e8 fc ff ff ff       	call   12023 <tcp_data_wait+0x123>
   12027:	89 c7                	mov    %eax,%edi
   12029:	eb 8f                	jmp    11fba <tcp_data_wait+0xba>
   1202b:	90                   	nop    
   1202c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
   12030:	b9 01 00 00 00       	mov    $0x1,%ecx
   12035:	ba 03 00 00 00       	mov    $0x3,%edx
   1203a:	e8 fc ff ff ff       	call   1203b <tcp_data_wait+0x13b>
   1203f:	e9 50 ff ff ff       	jmp    11f94 <tcp_data_wait+0x94>
   12044:	89 1c 24             	mov    %ebx,(%esp,1)
   12047:	e8 fc ff ff ff       	call   12048 <tcp_data_wait+0x148>
   1204c:	e9 30 ff ff ff       	jmp    11f81 <tcp_data_wait+0x81>
   12051:	eb 0d                	jmp    12060 <trickles_client_recvmsg>
   12053:	90                   	nop    
   12054:	90                   	nop    
   12055:	90                   	nop    
   12056:	90                   	nop    
   12057:	90                   	nop    
   12058:	90                   	nop    
   12059:	90                   	nop    
   1205a:	90                   	nop    
   1205b:	90                   	nop    
   1205c:	90                   	nop    
   1205d:	90                   	nop    
   1205e:	90                   	nop    
   1205f:	90                   	nop    

00012060 <trickles_client_recvmsg>:

int trickles_client_recvmsg(struct sock *sk, struct msghdr *msg,
			    int len, int nonblock, int flags, int *addr_len) {
   12060:	55                   	push   %ebp
   12061:	89 e5                	mov    %esp,%ebp
   12063:	57                   	push   %edi
   12064:	56                   	push   %esi
   12065:	53                   	push   %ebx
   12066:	83 ec 30             	sub    $0x30,%esp
   12069:	8b 45 0c             	mov    0xc(%ebp),%eax
   1206c:	8b 5d 08             	mov    0x8(%ebp),%ebx
   1206f:	8b 7d 1c             	mov    0x1c(%ebp),%edi
   12072:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   12075:	8b 45 10             	mov    0x10(%ebp),%eax
	/* XXX Support all socket API semantics? */
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
   12078:	8d b3 bc 00 00 00    	lea    0xbc(%ebx),%esi
   1207e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   12081:	8b 45 14             	mov    0x14(%ebp),%eax
   12084:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   12087:	8b 45 18             	mov    0x18(%ebp),%eax
   1208a:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
	int result = 0;
	int target;		/* Read at least this many bytes */
	long timeo;
	
	lock_sock(sk);
   1208d:	ff 05 08 00 00 00    	incl   0x8
   12093:	8b 43 2c             	mov    0x2c(%ebx),%eax
   12096:	85 c0                	test   %eax,%eax
   12098:	0f 85 78 02 00 00    	jne    12316 <trickles_client_recvmsg+0x2b6>
   1209e:	c7 43 2c 01 00 00 00 	movl   $0x1,0x2c(%ebx)
   120a5:	ba 08 00 00 00       	mov    $0x8,%edx
   120aa:	a1 08 00 00 00       	mov    0x8,%eax
   120af:	48                   	dec    %eax
   120b0:	85 c0                	test   %eax,%eax
   120b2:	a3 08 00 00 00       	mov    %eax,0x8
   120b7:	75 0a                	jne    120c3 <trickles_client_recvmsg+0x63>
   120b9:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   120bd:	0f 85 bf 11 00 00    	jne    13282 <.text.lock.tmalloc+0x2b0>
	if(!(tp->trickles_opt & TCP_TRICKLES_RCV_START)) {
   120c3:	8b 86 ec 01 00 00    	mov    0x1ec(%esi),%eax
   120c9:	a9 10 00 00 00       	test   $0x10,%eax
   120ce:	75 09                	jne    120d9 <trickles_client_recvmsg+0x79>
		// also needed in trickles_poll
#if 0 // 0424 - changing client program instead of hacking rcv_start functionality into client
		bh_lock_sock(sk);
		trickles_send_ack_hook(sk);
		bh_unlock_sock(sk);#
#endif
		tp->trickles_opt |= TCP_TRICKLES_RCV_START;
   120d0:	83 c8 10             	or     $0x10,%eax
   120d3:	89 86 ec 01 00 00    	mov    %eax,0x1ec(%esi)
	}

	if(!(tp->trickles_opt & TCP_TRICKLES_BUFFERDISCARD)) {
   120d9:	83 e0 40             	and    $0x40,%eax
   120dc:	0f 85 82 00 00 00    	jne    12164 <trickles_client_recvmsg+0x104>
		/* Normal case: deliver actual data to client */
		release_sock(sk);
   120e2:	ff 05 08 00 00 00    	incl   0x8
   120e8:	8b 8b a8 00 00 00    	mov    0xa8(%ebx),%ecx
   120ee:	85 c9                	test   %ecx,%ecx
   120f0:	75 68                	jne    1215a <trickles_client_recvmsg+0xfa>
   120f2:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   120f9:	8d 43 30             	lea    0x30(%ebx),%eax
   120fc:	39 43 30             	cmp    %eax,0x30(%ebx)
   120ff:	75 48                	jne    12149 <trickles_client_recvmsg+0xe9>
   12101:	ba 08 00 00 00       	mov    $0x8,%edx
   12106:	a1 08 00 00 00       	mov    0x8,%eax
   1210b:	48                   	dec    %eax
   1210c:	85 c0                	test   %eax,%eax
   1210e:	a3 08 00 00 00       	mov    %eax,0x8
   12113:	75 0a                	jne    1211f <trickles_client_recvmsg+0xbf>
   12115:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   12119:	0f 85 73 11 00 00    	jne    13292 <.text.lock.tmalloc+0x2c0>
		return tcp_recvmsg(sk,msg,len,nonblock,flags,addr_len);
   1211f:	89 7d 1c             	mov    %edi,0x1c(%ebp)
   12122:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   12125:	89 5d 08             	mov    %ebx,0x8(%ebp)
   12128:	89 45 18             	mov    %eax,0x18(%ebp)
   1212b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1212e:	89 45 14             	mov    %eax,0x14(%ebp)
   12131:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   12134:	89 45 10             	mov    %eax,0x10(%ebp)
   12137:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1213a:	89 45 0c             	mov    %eax,0xc(%ebp)
   1213d:	83 c4 30             	add    $0x30,%esp
   12140:	5b                   	pop    %ebx
   12141:	5e                   	pop    %esi
   12142:	5f                   	pop    %edi
   12143:	5d                   	pop    %ebp
   12144:	e9 fc ff ff ff       	jmp    12145 <trickles_client_recvmsg+0xe5>
   12149:	b9 01 00 00 00       	mov    $0x1,%ecx
   1214e:	ba 03 00 00 00       	mov    $0x3,%edx
   12153:	e8 fc ff ff ff       	call   12154 <trickles_client_recvmsg+0xf4>
   12158:	eb a7                	jmp    12101 <trickles_client_recvmsg+0xa1>
   1215a:	89 1c 24             	mov    %ebx,(%esp,1)
   1215d:	e8 fc ff ff ff       	call   1215e <trickles_client_recvmsg+0xfe>
   12162:	eb 8e                	jmp    120f2 <trickles_client_recvmsg+0x92>
	}

	// Else, generate fake data (correlated with the network: data
	// is returned from this routine only if data was received on
	// the network. However, the actual network data was discarded)

	result = -ENOTCONN;

	if(flags & (MSG_OOB | MSG_PEEK)) {
   12164:	f7 45 e4 03 00 00 00 	testl  $0x3,0xffffffe4(%ebp)
   1216b:	c7 45 e0 95 ff ff ff 	movl   $0xffffff95,0xffffffe0(%ebp)
   12172:	74 6a                	je     121de <trickles_client_recvmsg+0x17e>
		result = -EINVAL;
   12174:	c7 45 e0 ea ff ff ff 	movl   $0xffffffea,0xffffffe0(%ebp)
		goto done;
	}

	timeo = sock_rcvtimeo(sk, nonblock);
	target = sock_rcvlowat(sk, flags & MSG_WAITALL, len);

	while(1) {
		if(tp->rcv_nxt - tp->copied_seq >= target) {
			result = MIN(len, tp->rcv_nxt - tp->copied_seq); // 0503 - changed from min to MIN to suppress compilation warning
			tp->copied_seq += result;
			cleanup_rbuf(sk, result);
			break;
		} else if(timeo == 0) {
			/* NOWAIT */
			result = MIN(target, tp->rcv_nxt - tp->copied_seq); // 0503 - changed from min to MIN to suppress compilation warning
			tp->copied_seq += result;
			cleanup_rbuf(sk, result);
			break;
		} else {
			/* wait until enough new data is available */
			printk("waiting for data\n");
			timeo = tcp_data_wait(sk, timeo);
		}
		if(tp->rcv_nxt - tp->copied_seq == 0) {
			/* check to see why tcp_data_wait returned without new data. Copied from tcp_recvmsg */
			if (sk->done)
				break;

			if (sk->err) {
				result = sock_error(sk);
				break;
			}

			if (sk->shutdown & RCV_SHUTDOWN)
				break;

			if (sk->state == TCP_CLOSE) {
				if (!sk->done) {
					/* This occurs when user tries to read
					 * from never connected socket.
					 */
					result = -ENOTCONN;
					break;
				}
				break;
			}

			if (!timeo) {
				result = -EAGAIN;
				break;
			}
		}
		cleanup_rbuf(sk, result);
	}
	done:
	release_sock(sk);
   1217b:	ff 05 08 00 00 00    	incl   0x8
   12181:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
   12187:	85 c0                	test   %eax,%eax
   12189:	75 49                	jne    121d4 <trickles_client_recvmsg+0x174>
   1218b:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   12192:	8d 43 30             	lea    0x30(%ebx),%eax
   12195:	39 43 30             	cmp    %eax,0x30(%ebx)
   12198:	75 29                	jne    121c3 <trickles_client_recvmsg+0x163>
   1219a:	ba 08 00 00 00       	mov    $0x8,%edx
   1219f:	a1 08 00 00 00       	mov    0x8,%eax
   121a4:	48                   	dec    %eax
   121a5:	85 c0                	test   %eax,%eax
   121a7:	a3 08 00 00 00       	mov    %eax,0x8
   121ac:	75 0a                	jne    121b8 <trickles_client_recvmsg+0x158>
   121ae:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   121b2:	0f 85 ea 10 00 00    	jne    132a2 <.text.lock.tmalloc+0x2d0>
	return result;
}
   121b8:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   121bb:	83 c4 30             	add    $0x30,%esp
   121be:	5b                   	pop    %ebx
   121bf:	5e                   	pop    %esi
   121c0:	5f                   	pop    %edi
   121c1:	5d                   	pop    %ebp
   121c2:	c3                   	ret    
   121c3:	b9 01 00 00 00       	mov    $0x1,%ecx
   121c8:	ba 03 00 00 00       	mov    $0x3,%edx
   121cd:	e8 fc ff ff ff       	call   121ce <trickles_client_recvmsg+0x16e>
   121d2:	eb c6                	jmp    1219a <trickles_client_recvmsg+0x13a>
   121d4:	89 1c 24             	mov    %ebx,(%esp,1)
   121d7:	e8 fc ff ff ff       	call   121d8 <trickles_client_recvmsg+0x178>
   121dc:	eb ad                	jmp    1218b <trickles_client_recvmsg+0x12b>
}

static inline long sock_rcvtimeo(struct sock *sk, int noblock)
{
	return noblock ? 0 : sk->rcvtimeo;
   121de:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   121e1:	31 c0                	xor    %eax,%eax
   121e3:	85 d2                	test   %edx,%edx
   121e5:	75 06                	jne    121ed <trickles_client_recvmsg+0x18d>
   121e7:	8b 83 44 0c 00 00    	mov    0xc44(%ebx),%eax
}

static inline long sock_sndtimeo(struct sock *sk, int noblock)
{
	return noblock ? 0 : sk->sndtimeo;
}

static inline int sock_rcvlowat(struct sock *sk, int waitall, int len)
{
	return (waitall ? len : min_t(int, sk->rcvlowat, len)) ? : 1;
   121ed:	f7 45 e4 00 01 00 00 	testl  $0x100,0xffffffe4(%ebp)
   121f4:	89 c7                	mov    %eax,%edi
   121f6:	0f 85 12 01 00 00    	jne    1230e <trickles_client_recvmsg+0x2ae>
   121fc:	8b 83 40 0c 00 00    	mov    0xc40(%ebx),%eax
   12202:	39 45 ec             	cmp    %eax,0xffffffec(%ebp)
   12205:	0f 4e 45 ec          	cmovle 0xffffffec(%ebp),%eax
   12209:	c7 45 dc 01 00 00 00 	movl   $0x1,0xffffffdc(%ebp)
   12210:	85 c0                	test   %eax,%eax
   12212:	0f 44 45 dc          	cmove  0xffffffdc(%ebp),%eax
   12216:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
   12219:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
   12220:	8b 56 08             	mov    0x8(%esi),%edx
   12223:	8b 86 fc 00 00 00    	mov    0xfc(%esi),%eax
   12229:	29 c2                	sub    %eax,%edx
   1222b:	3b 55 dc             	cmp    0xffffffdc(%ebp),%edx
   1222e:	0f 83 d1 00 00 00    	jae    12305 <trickles_client_recvmsg+0x2a5>
   12234:	85 ff                	test   %edi,%edi
   12236:	0f 84 a3 00 00 00    	je     122df <trickles_client_recvmsg+0x27f>
   1223c:	c7 04 24 c3 0a 00 00 	movl   $0xac3,(%esp,1)
   12243:	e8 fc ff ff ff       	call   12244 <trickles_client_recvmsg+0x1e4>
   12248:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1224c:	89 1c 24             	mov    %ebx,(%esp,1)
   1224f:	e8 ac fc ff ff       	call   11f00 <tcp_data_wait>
   12254:	89 c7                	mov    %eax,%edi
   12256:	8b 86 fc 00 00 00    	mov    0xfc(%esi),%eax
   1225c:	39 46 08             	cmp    %eax,0x8(%esi)
   1225f:	74 12                	je     12273 <trickles_client_recvmsg+0x213>
   12261:	c7 44 24 04 95 ff ff 	movl   $0xffffff95,0x4(%esp,1)
   12268:	ff 
   12269:	89 1c 24             	mov    %ebx,(%esp,1)
   1226c:	e8 fc ff ff ff       	call   1226d <trickles_client_recvmsg+0x20d>
   12271:	eb ad                	jmp    12220 <trickles_client_recvmsg+0x1c0>
   12273:	0f b6 83 81 00 00 00 	movzbl 0x81(%ebx),%eax
   1227a:	84 c0                	test   %al,%al
   1227c:	0f 85 f9 fe ff ff    	jne    1217b <trickles_client_recvmsg+0x11b>
   12282:	8b 83 20 0c 00 00    	mov    0xc20(%ebx),%eax
   12288:	85 c0                	test   %eax,%eax
   1228a:	75 41                	jne    122cd <trickles_client_recvmsg+0x26d>
   1228c:	0f b6 43 27          	movzbl 0x27(%ebx),%eax
   12290:	24 01                	and    $0x1,%al
   12292:	84 c0                	test   %al,%al
   12294:	0f 85 e1 fe ff ff    	jne    1217b <trickles_client_recvmsg+0x11b>
   1229a:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
   1229e:	3c 07                	cmp    $0x7,%al
   122a0:	74 10                	je     122b2 <trickles_client_recvmsg+0x252>
   122a2:	85 ff                	test   %edi,%edi
   122a4:	75 bb                	jne    12261 <trickles_client_recvmsg+0x201>
   122a6:	c7 45 e0 f5 ff ff ff 	movl   $0xfffffff5,0xffffffe0(%ebp)
   122ad:	e9 c9 fe ff ff       	jmp    1217b <trickles_client_recvmsg+0x11b>
   122b2:	0f b6 83 81 00 00 00 	movzbl 0x81(%ebx),%eax
   122b9:	84 c0                	test   %al,%al
   122bb:	0f 85 ba fe ff ff    	jne    1217b <trickles_client_recvmsg+0x11b>
   122c1:	c7 45 e0 95 ff ff ff 	movl   $0xffffff95,0xffffffe0(%ebp)
   122c8:	e9 ae fe ff ff       	jmp    1217b <trickles_client_recvmsg+0x11b>
 * Note 2: xchg has side effect, so that attribute volatile is necessary,
 *	  but generally the primitive is invalid, *ptr is output argument. --ANK
 */
static inline unsigned long __xchg(unsigned long x, volatile void * ptr, int size)
{
   122cd:	31 c0                	xor    %eax,%eax
	switch (size) {
		case 1:
			__asm__ __volatile__("xchgb %b0,%1"
				:"=q" (x)
				:"m" (*__xg(ptr)), "0" (x)
				:"memory");
			break;
		case 2:
			__asm__ __volatile__("xchgw %w0,%1"
				:"=r" (x)
				:"m" (*__xg(ptr)), "0" (x)
				:"memory");
			break;
		case 4:
			__asm__ __volatile__("xchgl %0,%1"
   122cf:	87 83 20 0c 00 00    	xchg   %eax,0xc20(%ebx)
 *	Recover an error report and clear atomically
 */
 
static inline int sock_error(struct sock *sk)
{
   122d5:	f7 d8                	neg    %eax
   122d7:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   122da:	e9 9c fe ff ff       	jmp    1217b <trickles_client_recvmsg+0x11b>
   122df:	3b 55 dc             	cmp    0xffffffdc(%ebp),%edx
   122e2:	0f 4f 55 dc          	cmovg  0xffffffdc(%ebp),%edx
   122e6:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
   122e9:	01 d0                	add    %edx,%eax
   122eb:	89 86 fc 00 00 00    	mov    %eax,0xfc(%esi)
   122f1:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   122f4:	89 1c 24             	mov    %ebx,(%esp,1)
   122f7:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   122fb:	e8 fc ff ff ff       	call   122fc <trickles_client_recvmsg+0x29c>
   12300:	e9 76 fe ff ff       	jmp    1217b <trickles_client_recvmsg+0x11b>
   12305:	3b 55 ec             	cmp    0xffffffec(%ebp),%edx
   12308:	0f 4f 55 ec          	cmovg  0xffffffec(%ebp),%edx
   1230c:	eb d8                	jmp    122e6 <trickles_client_recvmsg+0x286>
   1230e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   12311:	e9 f3 fe ff ff       	jmp    12209 <trickles_client_recvmsg+0x1a9>
   12316:	89 1c 24             	mov    %ebx,(%esp,1)
   12319:	e8 fc ff ff ff       	call   1231a <trickles_client_recvmsg+0x2ba>
   1231e:	e9 7b fd ff ff       	jmp    1209e <trickles_client_recvmsg+0x3e>
   12323:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   12329:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00012330 <dump_tiov>:

#if 0
	struct mskdesc {
		struct cminisock *msk;
		int tiov_num;
		// tiovec is appended to mskdesc
		struct  tiovec tiov[0];
	};

	struct tiovec {
		// field names are compatible with iov
		void *iov_base;
		int iov_len;

		UCONT_DESC;
	};
#endif

static void dump_tiov(struct tiovec *tiov) {
   12330:	55                   	push   %ebp
   12331:	89 e5                	mov    %esp,%ebp
   12333:	83 ec 0c             	sub    $0xc,%esp
   12336:	8b 45 08             	mov    0x8(%ebp),%eax
	printk("tiov_base = %p\ntiov_len = %d", tiov->iov_base, tiov->iov_len);
   12339:	8b 50 04             	mov    0x4(%eax),%edx
   1233c:	89 54 24 08          	mov    %edx,0x8(%esp,1)
   12340:	8b 00                	mov    (%eax),%eax
   12342:	c7 04 24 d5 0a 00 00 	movl   $0xad5,(%esp,1)
   12349:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1234d:	e8 fc ff ff ff       	call   1234e <dump_tiov+0x1e>
}
   12352:	89 ec                	mov    %ebp,%esp
   12354:	5d                   	pop    %ebp
   12355:	c3                   	ret    
   12356:	8d 76 00             	lea    0x0(%esi),%esi
   12359:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00012360 <dump_mskdesc>:

static void dump_mskdesc(struct mskdesc *mskd) {
   12360:	55                   	push   %ebp
   12361:	89 e5                	mov    %esp,%ebp
   12363:	83 ec 10             	sub    $0x10,%esp
   12366:	89 5d fc             	mov    %ebx,0xfffffffc(%ebp)
   12369:	8b 5d 08             	mov    0x8(%ebp),%ebx
	printk("msk = %p, num =  %d\n", mskd->msk, mskd->tiov_num);
   1236c:	8b 43 08             	mov    0x8(%ebx),%eax
   1236f:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   12373:	8b 03                	mov    (%ebx),%eax
   12375:	c7 04 24 f2 0a 00 00 	movl   $0xaf2,(%esp,1)
	dump_tiov(mskd->tiov);
   1237c:	83 c3 0c             	add    $0xc,%ebx
   1237f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12383:	e8 fc ff ff ff       	call   12384 <dump_mskdesc+0x24>
   12388:	89 5d 08             	mov    %ebx,0x8(%ebp)
   1238b:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
   1238e:	89 ec                	mov    %ebp,%esp
   12390:	5d                   	pop    %ebp
   12391:	eb 9d                	jmp    12330 <dump_tiov>
   12393:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   12399:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

000123a0 <trickles_sendbulk_impl>:
}

int trickles_sendbulk_impl(int fd, struct mskdesc *user_descbuf, int descbuf_len) {
   123a0:	55                   	push   %ebp
   123a1:	89 e5                	mov    %esp,%ebp
   123a3:	57                   	push   %edi
   123a4:	56                   	push   %esi
   123a5:	53                   	push   %ebx
   123a6:	83 ec 38             	sub    $0x38,%esp
   123a9:	8b 5d 10             	mov    0x10(%ebp),%ebx
	struct socket *sock;
	struct sock *sk;
	struct tcp_opt *tp;
	struct mskdesc *descbuf;
	int err;

	extern int gNumSendbulk;
	extern int gNumSendbulkDesc;
	gNumSendbulk++;
   123ac:	ff 05 00 00 00 00    	incl   0x0

	if(descbuf_len <= 0) {
   123b2:	85 db                	test   %ebx,%ebx
   123b4:	0f 8e e6 02 00 00    	jle    126a0 <trickles_sendbulk_impl+0x300>
		err = -EINVAL;
		goto out;
	}

	sock = sockfd_lookup(fd, &err);
   123ba:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   123bd:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   123c1:	8b 45 08             	mov    0x8(%ebp),%eax
   123c4:	89 04 24             	mov    %eax,(%esp,1)
   123c7:	e8 fc ff ff ff       	call   123c8 <trickles_sendbulk_impl+0x28>
   123cc:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	if (!sock)
   123cf:	85 c0                	test   %eax,%eax
   123d1:	0f 84 c3 01 00 00    	je     1259a <trickles_sendbulk_impl+0x1fa>
		goto out;

	sk = sock->sk;
   123d7:	8b 40 18             	mov    0x18(%eax),%eax
	tp = &(sk->tp_pinfo.af_tcp);

	//if(copy_from_user(buf, iov[i].iov_base + iov_position, copyLen)) {
	descbuf = kmalloc(descbuf_len, GFP_KERNEL);
   123da:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
   123e1:	00 
   123e2:	89 1c 24             	mov    %ebx,(%esp,1)
   123e5:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   123e8:	05 bc 00 00 00       	add    $0xbc,%eax
   123ed:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   123f0:	e8 fc ff ff ff       	call   123f1 <trickles_sendbulk_impl+0x51>
   123f5:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
	if(descbuf == NULL) {
   123f8:	85 c0                	test   %eax,%eax
   123fa:	0f 84 8e 02 00 00    	je     1268e <trickles_sendbulk_impl+0x2ee>
		printk("trickles_sendbulk_impl: user desc buf out of memory\n");
		goto out_put;
	}
	if((err = copy_from_user(descbuf,user_descbuf,descbuf_len))) {
   12400:	89 5c 24 08          	mov    %ebx,0x8(%esp,1)
   12404:	8b 45 0c             	mov    0xc(%ebp),%eax
   12407:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   1240a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1240e:	89 14 24             	mov    %edx,(%esp,1)
   12411:	e8 fc ff ff ff       	call   12412 <trickles_sendbulk_impl+0x72>
   12416:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   12419:	85 c0                	test   %eax,%eax
   1241b:	0f 85 51 02 00 00    	jne    12672 <trickles_sendbulk_impl+0x2d2>
		printk("trickles_sendbulk_impl: copy_from_user returned %d\n", err);
		err = -EFAULT;
		goto out_dealloc;
	}
	void *tail = (char*)descbuf + descbuf_len;
	struct mskdesc *curr_desc = descbuf;

	lock_sock(sk);
   12421:	ff 05 08 00 00 00    	incl   0x8
   12427:	8b 75 e0             	mov    0xffffffe0(%ebp),%esi
   1242a:	8b 7d e0             	mov    0xffffffe0(%ebp),%edi
   1242d:	01 f3                	add    %esi,%ebx
   1242f:	89 5d dc             	mov    %ebx,0xffffffdc(%ebp)
   12432:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   12435:	8b 48 2c             	mov    0x2c(%eax),%ecx
   12438:	85 c9                	test   %ecx,%ecx
   1243a:	0f 85 25 02 00 00    	jne    12665 <trickles_sendbulk_impl+0x2c5>
   12440:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   12443:	c7 42 2c 01 00 00 00 	movl   $0x1,0x2c(%edx)
   1244a:	ba 08 00 00 00       	mov    $0x8,%edx
   1244f:	a1 08 00 00 00       	mov    0x8,%eax
   12454:	48                   	dec    %eax
   12455:	85 c0                	test   %eax,%eax
   12457:	a3 08 00 00 00       	mov    %eax,0x8
   1245c:	75 0a                	jne    12468 <trickles_sendbulk_impl+0xc8>
   1245e:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   12462:	0f 85 4a 0e 00 00    	jne    132b2 <.text.lock.tmalloc+0x2e0>
	int descnum = 0;
   12468:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
	while(curr_desc < (struct mskdesc *)tail) {
   1246f:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   12472:	39 45 e0             	cmp    %eax,0xffffffe0(%ebp)
   12475:	0f 83 a5 00 00 00    	jae    12520 <trickles_sendbulk_impl+0x180>
		struct cminisock *msk = curr_desc->msk;
   1247b:	8b 37                	mov    (%edi),%esi
		msk->byteNum = curr_desc->byteNum;
   1247d:	8b 47 04             	mov    0x4(%edi),%eax
		//printk("Minisocket %d = %p\n", descnum, msk);
		if(!IS_TRICKLES_SOCK_ADDR(tp,msk) || !(VALID_MSK_CTL(msk))) {
   12480:	89 f1                	mov    %esi,%ecx
   12482:	89 46 30             	mov    %eax,0x30(%esi)
   12485:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   12488:	8b 9a cc 01 00 00    	mov    0x1cc(%edx),%ebx
   1248e:	8b 43 0c             	mov    0xc(%ebx),%eax
   12491:	29 c1                	sub    %eax,%ecx
   12493:	89 ca                	mov    %ecx,%edx
   12495:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   12498:	c1 ea 02             	shr    $0x2,%edx
   1249b:	b8 3f 82 fb 08       	mov    $0x8fb823f,%eax
   124a0:	f7 e2                	mul    %edx
   124a2:	d1 ea                	shr    %edx
   124a4:	69 d2 e4 00 00 00    	imul   $0xe4,%edx,%edx
   124aa:	39 d1                	cmp    %edx,%ecx
   124ac:	0f 85 26 01 00 00    	jne    125d8 <trickles_sendbulk_impl+0x238>
   124b2:	3b 75 d4             	cmp    0xffffffd4(%ebp),%esi
   124b5:	0f 82 1d 01 00 00    	jb     125d8 <trickles_sendbulk_impl+0x238>
   124bb:	8b 53 14             	mov    0x14(%ebx),%edx
   124be:	89 f0                	mov    %esi,%eax
   124c0:	29 d0                	sub    %edx,%eax
   124c2:	05 e4 00 00 00       	add    $0xe4,%eax
   124c7:	3b 43 20             	cmp    0x20(%ebx),%eax
   124ca:	0f 87 08 01 00 00    	ja     125d8 <trickles_sendbulk_impl+0x238>
   124d0:	8b 46 0c             	mov    0xc(%esi),%eax
   124d3:	83 f8 01             	cmp    $0x1,%eax
   124d6:	74 09                	je     124e1 <trickles_sendbulk_impl+0x141>
   124d8:	83 f8 04             	cmp    $0x4,%eax
   124db:	0f 85 f7 00 00 00    	jne    125d8 <trickles_sendbulk_impl+0x238>
			printk("trickles_sendbulk_impl: bad minisocket %d %d @ %d\n",
			       !IS_TRICKLES_SOCK_ADDR(tp,msk), !(VALID_MSK_CTL(msk)),
			       descnum);
			err = -EINVAL;
			goto out_release;
		}
		free_trickles_msk(sk,msk);
   124e1:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   124e5:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   124e8:	89 04 24             	mov    %eax,(%esp,1)
   124eb:	e8 10 b5 ff ff       	call   da00 <free_trickles_msk>
		trickles_do_sendmsg_tiov(sk, msk, curr_desc->tiov, curr_desc->tiov_num);
   124f0:	8b 47 08             	mov    0x8(%edi),%eax
   124f3:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   124f6:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   124fa:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   124fe:	8d 47 0c             	lea    0xc(%edi),%eax
   12501:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   12505:	89 14 24             	mov    %edx,(%esp,1)
   12508:	e8 a3 bf ff ff       	call   e4b0 <trickles_do_sendmsg_tiov>
		curr_desc = NEXT_MSKDESC(curr_desc);
   1250d:	8b 47 08             	mov    0x8(%edi),%eax
		descnum++;
   12510:	ff 45 d8             	incl   0xffffffd8(%ebp)
   12513:	8d 7c c7 0c          	lea    0xc(%edi,%eax,8),%edi
   12517:	3b 7d dc             	cmp    0xffffffdc(%ebp),%edi
   1251a:	0f 82 5b ff ff ff    	jb     1247b <trickles_sendbulk_impl+0xdb>
#if 0
		// Check prequeue
		if (skb_queue_len(&tp->ucopy.prequeue)) {
			tcp_prequeue_process(sk);
		}
#endif
	}
	gNumSendbulkDesc += descnum;
	if((err = trickles_poll(sk)) >= 0) {
   12520:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   12523:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   12526:	01 05 00 00 00 00    	add    %eax,0x0
   1252c:	89 14 24             	mov    %edx,(%esp,1)
   1252f:	e8 dc d1 ff ff       	call   f710 <trickles_poll>
   12534:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   12537:	85 c0                	test   %eax,%eax
   12539:	0f 88 81 00 00 00    	js     125c0 <trickles_sendbulk_impl+0x220>
		//printk("err = %d\n", err);
	} else {
		printk("err = EAGAIN\n");
		err = -EAGAIN;
	}
 out_release:
	release_sock(sk);
   1253f:	ff 05 08 00 00 00    	incl   0x8
   12545:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   12548:	8b 90 a8 00 00 00    	mov    0xa8(%eax),%edx
   1254e:	85 d2                	test   %edx,%edx
   12550:	75 64                	jne    125b6 <trickles_sendbulk_impl+0x216>
   12552:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   12555:	89 d0                	mov    %edx,%eax
   12557:	83 c0 30             	add    $0x30,%eax
   1255a:	39 42 30             	cmp    %eax,0x30(%edx)
   1255d:	c7 42 2c 00 00 00 00 	movl   $0x0,0x2c(%edx)
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   12564:	75 3f                	jne    125a5 <trickles_sendbulk_impl+0x205>
   12566:	ba 08 00 00 00       	mov    $0x8,%edx
   1256b:	a1 08 00 00 00       	mov    0x8,%eax
   12570:	48                   	dec    %eax
   12571:	85 c0                	test   %eax,%eax
   12573:	a3 08 00 00 00       	mov    %eax,0x8
   12578:	75 0a                	jne    12584 <trickles_sendbulk_impl+0x1e4>
   1257a:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   1257e:	0f 85 3e 0d 00 00    	jne    132c2 <.text.lock.tmalloc+0x2f0>
 out_dealloc:
	kfree(descbuf);
   12584:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   12587:	89 04 24             	mov    %eax,(%esp,1)
   1258a:	e8 fc ff ff ff       	call   1258b <trickles_sendbulk_impl+0x1eb>
   1258f:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   12592:	8b 42 14             	mov    0x14(%edx),%eax
   12595:	e8 fc ff ff ff       	call   12596 <trickles_sendbulk_impl+0x1f6>
 out_put:
	sockfd_put(sock);
 out:
	return err;
   1259a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
}
   1259d:	83 c4 38             	add    $0x38,%esp
   125a0:	5b                   	pop    %ebx
   125a1:	5e                   	pop    %esi
   125a2:	5f                   	pop    %edi
   125a3:	5d                   	pop    %ebp
   125a4:	c3                   	ret    
   125a5:	b9 01 00 00 00       	mov    $0x1,%ecx
   125aa:	ba 03 00 00 00       	mov    $0x3,%edx
   125af:	e8 fc ff ff ff       	call   125b0 <trickles_sendbulk_impl+0x210>
   125b4:	eb b0                	jmp    12566 <trickles_sendbulk_impl+0x1c6>
   125b6:	89 04 24             	mov    %eax,(%esp,1)
   125b9:	e8 fc ff ff ff       	call   125ba <trickles_sendbulk_impl+0x21a>
   125be:	eb 92                	jmp    12552 <trickles_sendbulk_impl+0x1b2>
   125c0:	c7 04 24 07 0b 00 00 	movl   $0xb07,(%esp,1)
   125c7:	e8 fc ff ff ff       	call   125c8 <trickles_sendbulk_impl+0x228>
   125cc:	c7 45 f0 f5 ff ff ff 	movl   $0xfffffff5,0xfffffff0(%ebp)
   125d3:	e9 67 ff ff ff       	jmp    1253f <trickles_sendbulk_impl+0x19f>
   125d8:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   125db:	89 54 24 0c          	mov    %edx,0xc(%esp,1)
   125df:	31 d2                	xor    %edx,%edx
   125e1:	8b 46 0c             	mov    0xc(%esi),%eax
   125e4:	83 f8 01             	cmp    $0x1,%eax
   125e7:	74 0b                	je     125f4 <trickles_sendbulk_impl+0x254>
   125e9:	83 f8 04             	cmp    $0x4,%eax
   125ec:	b8 01 00 00 00       	mov    $0x1,%eax
   125f1:	0f 45 d0             	cmovne %eax,%edx
   125f4:	89 54 24 08          	mov    %edx,0x8(%esp,1)
   125f8:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   125fb:	89 f2                	mov    %esi,%edx
   125fd:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
   12604:	b9 3f 82 fb 08       	mov    $0x8fb823f,%ecx
   12609:	8b 98 cc 01 00 00    	mov    0x1cc(%eax),%ebx
   1260f:	8b 7b 0c             	mov    0xc(%ebx),%edi
   12612:	29 fa                	sub    %edi,%edx
   12614:	89 55 cc             	mov    %edx,0xffffffcc(%ebp)
   12617:	c1 ea 02             	shr    $0x2,%edx
   1261a:	89 d0                	mov    %edx,%eax
   1261c:	f7 e1                	mul    %ecx
   1261e:	d1 ea                	shr    %edx
   12620:	69 d2 e4 00 00 00    	imul   $0xe4,%edx,%edx
   12626:	39 55 cc             	cmp    %edx,0xffffffcc(%ebp)
   12629:	75 14                	jne    1263f <trickles_sendbulk_impl+0x29f>
   1262b:	39 fe                	cmp    %edi,%esi
   1262d:	72 10                	jb     1263f <trickles_sendbulk_impl+0x29f>
   1262f:	8b 4b 14             	mov    0x14(%ebx),%ecx
   12632:	29 ce                	sub    %ecx,%esi
   12634:	8d 86 e4 00 00 00    	lea    0xe4(%esi),%eax
   1263a:	3b 43 20             	cmp    0x20(%ebx),%eax
   1263d:	76 07                	jbe    12646 <trickles_sendbulk_impl+0x2a6>
   1263f:	c7 45 d0 01 00 00 00 	movl   $0x1,0xffffffd0(%ebp)
   12646:	c7 04 24 60 42 00 00 	movl   $0x4260,(%esp,1)
   1264d:	8b 55 d0             	mov    0xffffffd0(%ebp),%edx
   12650:	89 54 24 04          	mov    %edx,0x4(%esp,1)
   12654:	e8 fc ff ff ff       	call   12655 <trickles_sendbulk_impl+0x2b5>
   12659:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
   12660:	e9 da fe ff ff       	jmp    1253f <trickles_sendbulk_impl+0x19f>
   12665:	89 04 24             	mov    %eax,(%esp,1)
   12668:	e8 fc ff ff ff       	call   12669 <trickles_sendbulk_impl+0x2c9>
   1266d:	e9 ce fd ff ff       	jmp    12440 <trickles_sendbulk_impl+0xa0>
   12672:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12676:	c7 04 24 a0 42 00 00 	movl   $0x42a0,(%esp,1)
   1267d:	e8 fc ff ff ff       	call   1267e <trickles_sendbulk_impl+0x2de>
   12682:	c7 45 f0 f2 ff ff ff 	movl   $0xfffffff2,0xfffffff0(%ebp)
   12689:	e9 f6 fe ff ff       	jmp    12584 <trickles_sendbulk_impl+0x1e4>
   1268e:	c7 04 24 e0 42 00 00 	movl   $0x42e0,(%esp,1)
   12695:	e8 fc ff ff ff       	call   12696 <trickles_sendbulk_impl+0x2f6>
   1269a:	e9 f0 fe ff ff       	jmp    1258f <trickles_sendbulk_impl+0x1ef>
   1269f:	90                   	nop    
   126a0:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
   126a7:	e9 ee fe ff ff       	jmp    1259a <trickles_sendbulk_impl+0x1fa>
   126ac:	8d 74 26 00          	lea    0x0(%esi,1),%esi

000126b0 <trickles_read_proc>:

/* Bulk debugging output interface */

struct alloc_head_list tricklesProcLogHead;

#if 0
ctl_table trickles_table[] = {
  {DEV_PM_ON, "on", &on, sizeof(on), 0644, NULL, pm_sysctl_handler},
  {0}
};

ctl_table trickles_trickles_table[] = {
  {DEV_PM, "pm", NULL, 0, 0555, pm_table},
  {0}
};

ctl_table trickles_root_table[] = {
  {CTL_DEV, "dev", NULL, 0, 0555, pm_pm_table},
  {0}
};
#endif

int trickles_read_proc(char *page, char **start, off_t offset, int count,
		       int *eof, void *data)
{
   126b0:	55                   	push   %ebp
   126b1:	89 e5                	mov    %esp,%ebp
    struct TricklesProcLogEntry *logEntry;
    int i, pos = 0, done = 1;
   126b3:	31 c0                	xor    %eax,%eax
   126b5:	57                   	push   %edi
   126b6:	56                   	push   %esi
   126b7:	53                   	push   %ebx
   126b8:	81 ec 78 10 00 00    	sub    $0x1078,%esp
   126be:	89 85 a8 ef ff ff    	mov    %eax,0xffffefa8(%ebp)
   126c4:	b8 01 00 00 00       	mov    $0x1,%eax
   126c9:	89 85 a4 ef ff ff    	mov    %eax,0xffffefa4(%ebp)

    local_bh_disable();
   126cf:	ff 05 08 00 00 00    	incl   0x8
    alloc_head_walk(&tricklesProcLogHead, logEntry) {
   126d5:	a1 04 00 00 00       	mov    0x4,%eax
   126da:	3d 00 00 00 00       	cmp    $0x0,%eax
   126df:	89 85 b0 ef ff ff    	mov    %eax,0xffffefb0(%ebp)
   126e5:	0f 84 d0 02 00 00    	je     129bb <trickles_read_proc+0x30b>
	    char tempBody[4096], *temp = tempBody;
	    int first = logEntry->returnedEvents == 0;
   126eb:	8b 8d b0 ef ff ff    	mov    0xffffefb0(%ebp),%ecx
   126f1:	8d 85 f4 ef ff ff    	lea    0xffffeff4(%ebp),%eax
   126f7:	89 85 a0 ef ff ff    	mov    %eax,0xffffefa0(%ebp)
   126fd:	31 c0                	xor    %eax,%eax
   126ff:	8b 51 24             	mov    0x24(%ecx),%edx
   12702:	85 d2                	test   %edx,%edx
   12704:	0f 94 c0             	sete   %al
	    if(first) {
   12707:	85 c0                	test   %eax,%eax
   12709:	89 85 9c ef ff ff    	mov    %eax,0xffffef9c(%ebp)
   1270f:	0f 84 a8 00 00 00    	je     127bd <trickles_read_proc+0x10d>
		    int count = 0;
		    for(i=logEntry->returnedEvents; i < logEntry->size; i++) {
   12715:	89 95 ac ef ff ff    	mov    %edx,0xffffefac(%ebp)
   1271b:	8b 41 20             	mov    0x20(%ecx),%eax
   1271e:	31 db                	xor    %ebx,%ebx
   12720:	39 c2                	cmp    %eax,%edx
   12722:	7d 30                	jge    12754 <trickles_read_proc+0xa4>
   12724:	8b b5 ac ef ff ff    	mov    0xffffefac(%ebp),%esi
   1272a:	8d 14 92             	lea    (%edx,%edx,4),%edx
   1272d:	8b 79 1c             	mov    0x1c(%ecx),%edi
   12730:	29 f0                	sub    %esi,%eax
   12732:	01 fa                	add    %edi,%edx
   12734:	89 85 ac ef ff ff    	mov    %eax,0xffffefac(%ebp)
   1273a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			    if(logEntry->events[i].valid)
   12740:	f6 02 01             	testb  $0x1,(%edx)
   12743:	8d 43 01             	lea    0x1(%ebx),%eax
   12746:	0f 45 d8             	cmovne %eax,%ebx
   12749:	83 c2 05             	add    $0x5,%edx
   1274c:	ff 8d ac ef ff ff    	decl   0xffffefac(%ebp)
   12752:	75 ec                	jne    12740 <trickles_read_proc+0x90>
				    count++;
		    }
		    sprintf(temp, "Socket (daddr=%X port=%d) (rcv_nxt=%u,trcv_nxt=%u) [%d]\n", 
   12754:	8b 85 b0 ef ff ff    	mov    0xffffefb0(%ebp),%eax
static inline size_t strlen(const char * s)
{
int d0;
register int __res;
__asm__ __volatile__(
   1275a:	8d bd f4 ef ff ff    	lea    0xffffeff4(%ebp),%edi
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
   12760:	8b 48 0c             	mov    0xc(%eax),%ecx
   12763:	0f b7 50 10          	movzwl 0x10(%eax),%edx
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
   12767:	89 5c 24 18          	mov    %ebx,0x18(%esp,1)
   1276b:	89 c3                	mov    %eax,%ebx
   1276d:	8b 40 18             	mov    0x18(%eax),%eax
/* gcc should generate this for open coded C now too. May be worth switching to 
   it because inline assembly cannot be scheduled. -AK */
static __inline__ __const__ __u16 ___arch__swab16(__u16 x)
{
	__asm__("xchgb %b0,%h0"		/* swap bytes		*/
   12770:	86 d6                	xchg   %dl,%dh
#endif /* OPTIMIZE */


static __inline__ __const__ __u16 __fswab16(__u16 x)
{
   12772:	0f b7 d2             	movzwl %dx,%edx
	return __arch__swab16(x);
}
static __inline__ __u16 __swab16p(__u16 *x)
{
	return __arch__swab16p(x);
}
static __inline__ void __swab16s(__u16 *addr)
{
	__arch__swab16s(addr);
}

static __inline__ __const__ __u32 __fswab24(__u32 x)
{
	return __arch__swab24(x);
}
static __inline__ __u32 __swab24p(__u32 *x)
{
	return __arch__swab24p(x);
}
static __inline__ void __swab24s(__u32 *addr)
{
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
   12775:	89 44 24 14          	mov    %eax,0x14(%esp,1)
   12779:	8b 43 14             	mov    0x14(%ebx),%eax

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
   1277c:	0f c9                	bswap  %ecx
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
   1277e:	89 54 24 0c          	mov    %edx,0xc(%esp,1)
   12782:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   12786:	8d 85 f4 ef ff ff    	lea    0xffffeff4(%ebp),%eax
   1278c:	89 4c 24 08          	mov    %ecx,0x8(%esp,1)
   12790:	c7 44 24 04 20 43 00 	movl   $0x4320,0x4(%esp,1)
   12797:	00 
   12798:	89 04 24             	mov    %eax,(%esp,1)
   1279b:	e8 fc ff ff ff       	call   1279c <trickles_read_proc+0xec>
static inline size_t strlen(const char * s)
{
int d0;
register int __res;
__asm__ __volatile__(
   127a0:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
   127a5:	31 c0                	xor    %eax,%eax
   127a7:	f2 ae                	repnz scas %es:(%edi),%al
   127a9:	f7 d1                	not    %ecx
   127ab:	49                   	dec    %ecx
   127ac:	8d 95 f4 ef ff ff    	lea    0xffffeff4(%ebp),%edx
   127b2:	01 ca                	add    %ecx,%edx
   127b4:	89 95 a0 ef ff ff    	mov    %edx,0xffffefa0(%ebp)
   127ba:	8b 53 24             	mov    0x24(%ebx),%edx
			    htonl(logEntry->addr), htons(logEntry->port),
			    logEntry->rcv_nxt, logEntry->t_rcv_nxt, count);
		    temp += strlen(temp);
	    }
	    for(i=logEntry->returnedEvents; i < logEntry->size; i++) {
   127bd:	89 95 ac ef ff ff    	mov    %edx,0xffffefac(%ebp)
   127c3:	8b 8d b0 ef ff ff    	mov    0xffffefb0(%ebp),%ecx
   127c9:	8b 41 20             	mov    0x20(%ecx),%eax
   127cc:	39 c2                	cmp    %eax,%edx
   127ce:	0f 8d b5 01 00 00    	jge    12989 <trickles_read_proc+0x2d9>
   127d4:	8d 1c 92             	lea    (%edx,%edx,4),%ebx
   127d7:	89 9d 98 ef ff ff    	mov    %ebx,0xffffef98(%ebp)
   127dd:	8d 76 00             	lea    0x0(%esi),%esi
		    struct TricklesLossEvent *event = &logEntry->events[i];
   127e0:	8b 95 b0 ef ff ff    	mov    0xffffefb0(%ebp),%edx
   127e6:	8b b5 98 ef ff ff    	mov    0xffffef98(%ebp),%esi
   127ec:	8b 4a 1c             	mov    0x1c(%edx),%ecx
   127ef:	01 ce                	add    %ecx,%esi
		    char locationBuf[64];
		    char *saveLocation;
		    char *state;
		    if(!event->valid) continue;
   127f1:	f6 06 01             	testb  $0x1,(%esi)
   127f4:	0f 84 76 01 00 00    	je     12970 <trickles_read_proc+0x2c0>
		    done = 0;
   127fa:	31 c0                	xor    %eax,%eax
		    switch(event->extra) {
		    case EVENT_EXTRA_SEND:
			    saveLocation = "sendStateChange";
			    break;
		    case EVENT_EXTRA_RECV:
			    saveLocation = "recv";
   127fc:	bb 15 0b 00 00       	mov    $0xb15,%ebx
   12801:	89 85 a4 ef ff ff    	mov    %eax,0xffffefa4(%ebp)
   12807:	0f b6 4e 01          	movzbl 0x1(%esi),%ecx
   1280b:	89 ca                	mov    %ecx,%edx
   1280d:	83 e2 1f             	and    $0x1f,%edx
			    break;
   12810:	83 fa 02             	cmp    $0x2,%edx
   12813:	88 c8                	mov    %cl,%al
   12815:	74 32                	je     12849 <trickles_read_proc+0x199>
   12817:	83 fa 02             	cmp    $0x2,%edx
   1281a:	0f 8f 80 02 00 00    	jg     12aa0 <trickles_read_proc+0x3f0>
   12820:	bb 1a 0b 00 00       	mov    $0xb1a,%ebx
   12825:	4a                   	dec    %edx
   12826:	74 21                	je     12849 <trickles_read_proc+0x199>
		    case EVENT_EXTRA_SAMPLE0:
			    saveLocation = "contList sample0";
			    break;
		    case EVENT_EXTRA_SAMPLE1:
			    saveLocation = "contList sample1";
			    break;
		    default:
			    sprintf(locationBuf, "(bad location %d)", event->extra);
   12828:	c7 44 24 04 2a 0b 00 	movl   $0xb2a,0x4(%esp,1)
   1282f:	00 
   12830:	83 e0 1f             	and    $0x1f,%eax
   12833:	8d 9d b4 ef ff ff    	lea    0xffffefb4(%ebp),%ebx
   12839:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1283d:	89 1c 24             	mov    %ebx,(%esp,1)
   12840:	e8 fc ff ff ff       	call   12841 <trickles_read_proc+0x191>
			    saveLocation = locationBuf;
   12845:	0f b6 4e 01          	movzbl 0x1(%esi),%ecx
		    }
		    switch(event->state) {
   12849:	c0 e9 05             	shr    $0x5,%cl
   1284c:	0f b6 c1             	movzbl %cl,%eax
		    case TRICKLES_CLIENT_NORMAL:
			    state = "(normal)";
			    break;
		    case TRICKLES_CLIENT_RECOVERY:
			    state = "(recovery)";
   1284f:	b9 3c 0b 00 00       	mov    $0xb3c,%ecx
			    break;
   12854:	83 f8 02             	cmp    $0x2,%eax
   12857:	74 16                	je     1286f <trickles_read_proc+0x1bf>
   12859:	83 f8 02             	cmp    $0x2,%eax
   1285c:	0f 8f 1e 02 00 00    	jg     12a80 <trickles_read_proc+0x3d0>
   12862:	b9 47 0b 00 00       	mov    $0xb47,%ecx
   12867:	48                   	dec    %eax
   12868:	74 05                	je     1286f <trickles_read_proc+0x1bf>
		    case TRICKLES_CLIENT_SLOWSTART:
			    state = "(slowstart)";
			    break;
		    case TRICKLES_CLIENT_SYNACK:
			    state = "(synack)";
			    break;
		    default:
			    state = "(bad state)";
   1286a:	b9 50 0b 00 00       	mov    $0xb50,%ecx
		    }
		    sprintf(temp, "%s: cwnd=%d state=%s time=%d\n", saveLocation,
   1286f:	0f b6 56 03          	movzbl 0x3(%esi),%edx
   12873:	0f b6 46 02          	movzbl 0x2(%esi),%eax
   12877:	c1 e2 08             	shl    $0x8,%edx
   1287a:	09 c2                	or     %eax,%edx
   1287c:	0f b6 46 04          	movzbl 0x4(%esi),%eax
   12880:	89 4c 24 10          	mov    %ecx,0x10(%esp,1)
   12884:	8b 8d a0 ef ff ff    	mov    0xffffefa0(%ebp),%ecx
   1288a:	c1 e0 10             	shl    $0x10,%eax
   1288d:	09 d0                	or     %edx,%eax
   1288f:	89 44 24 14          	mov    %eax,0x14(%esp,1)
   12893:	0f b6 06             	movzbl (%esi),%eax
   12896:	89 5c 24 08          	mov    %ebx,0x8(%esp,1)
   1289a:	c7 44 24 04 5c 0b 00 	movl   $0xb5c,0x4(%esp,1)
   128a1:	00 
   128a2:	89 0c 24             	mov    %ecx,(%esp,1)
   128a5:	d0 e8                	shr    %al
   128a7:	0f b6 c0             	movzbl %al,%eax
   128aa:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   128ae:	e8 fc ff ff ff       	call   128af <trickles_read_proc+0x1ff>
			    (int)event->cwnd, state, event->time);
		    if(first) {
   128b3:	8b bd 9c ef ff ff    	mov    0xffffef9c(%ebp),%edi
   128b9:	85 ff                	test   %edi,%edi
   128bb:	74 14                	je     128d1 <trickles_read_proc+0x221>
			    temp = tempBody;
   128bd:	8d 9d f4 ef ff ff    	lea    0xffffeff4(%ebp),%ebx
			    first = 0;
   128c3:	31 f6                	xor    %esi,%esi
   128c5:	89 9d a0 ef ff ff    	mov    %ebx,0xffffefa0(%ebp)
   128cb:	89 b5 9c ef ff ff    	mov    %esi,0xffffef9c(%ebp)
		    }
		    temp += logEntry->sentAmount;
   128d1:	8b 85 b0 ef ff ff    	mov    0xffffefb0(%ebp),%eax
static inline size_t strlen(const char * s)
{
int d0;
register int __res;
__asm__ __volatile__(
   128d7:	be ff ff ff ff       	mov    $0xffffffff,%esi
		    int copyLen = MAX(MIN((int)strlen(temp), count - pos), 0);
   128dc:	8b 55 14             	mov    0x14(%ebp),%edx
   128df:	8b 9d a8 ef ff ff    	mov    0xffffefa8(%ebp),%ebx
   128e5:	8b 40 28             	mov    0x28(%eax),%eax
static inline size_t strlen(const char * s)
{
int d0;
register int __res;
__asm__ __volatile__(
   128e8:	89 f1                	mov    %esi,%ecx
   128ea:	01 85 a0 ef ff ff    	add    %eax,0xffffefa0(%ebp)
   128f0:	29 da                	sub    %ebx,%edx
   128f2:	31 c0                	xor    %eax,%eax
static inline size_t strlen(const char * s)
{
int d0;
register int __res;
__asm__ __volatile__(
   128f4:	8b bd a0 ef ff ff    	mov    0xffffefa0(%ebp),%edi
   128fa:	f2 ae                	repnz scas %es:(%edi),%al
   128fc:	f7 d1                	not    %ecx
   128fe:	49                   	dec    %ecx
   128ff:	39 ca                	cmp    %ecx,%edx
static inline size_t strlen(const char * s)
{
int d0;
register int __res;
__asm__ __volatile__(
   12901:	8b bd a0 ef ff ff    	mov    0xffffefa0(%ebp),%edi
   12907:	0f 4f d1             	cmovg  %ecx,%edx
static inline size_t strlen(const char * s)
{
int d0;
register int __res;
__asm__ __volatile__(
   1290a:	89 f1                	mov    %esi,%ecx
   1290c:	85 d2                	test   %edx,%edx
   1290e:	0f 48 d0             	cmovs  %eax,%edx
static inline size_t strlen(const char * s)
{
int d0;
register int __res;
__asm__ __volatile__(
   12911:	f2 ae                	repnz scas %es:(%edi),%al
   12913:	f7 d1                	not    %ecx
   12915:	49                   	dec    %ecx
   12916:	b8 01 00 00 00       	mov    $0x1,%eax
	"repne\n\t"
	"scasb\n\t"
	"notl %0\n\t"
	"decl %0"
	:"=c" (__res), "=&D" (d0) :"1" (s),"a" (0), "0" (0xffffffff));
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
   1291b:	8b 7d 08             	mov    0x8(%ebp),%edi
   1291e:	39 ca                	cmp    %ecx,%edx
   12920:	0f 45 85 a4 ef ff ff 	cmovne 0xffffefa4(%ebp),%eax
   12927:	8b 8d a8 ef ff ff    	mov    0xffffefa8(%ebp),%ecx
int d0, d1, d2;
__asm__ __volatile__(
   1292d:	8b b5 a0 ef ff ff    	mov    0xffffefa0(%ebp),%esi
   12933:	89 85 a4 ef ff ff    	mov    %eax,0xffffefa4(%ebp)
   12939:	01 cf                	add    %ecx,%edi
   1293b:	89 d1                	mov    %edx,%ecx
   1293d:	c1 e9 02             	shr    $0x2,%ecx
   12940:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   12942:	f6 c2 02             	test   $0x2,%dl
   12945:	74 02                	je     12949 <trickles_read_proc+0x299>
   12947:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
   12949:	f6 c2 01             	test   $0x1,%dl
   1294c:	74 01                	je     1294f <trickles_read_proc+0x29f>
   1294e:	a4                   	movsb  %ds:(%esi),%es:(%edi)
		    if(copyLen == strlen(temp)) {
			    done = 1;
		    }
		    memcpy(page + pos, temp, copyLen);
		    pos += copyLen;
   1294f:	01 95 a8 ef ff ff    	add    %edx,0xffffefa8(%ebp)
		    if(done) {
   12955:	85 c0                	test   %eax,%eax
   12957:	0f 84 f0 00 00 00    	je     12a4d <trickles_read_proc+0x39d>
			    logEntry->returnedEvents++;
   1295d:	8b 9d b0 ef ff ff    	mov    0xffffefb0(%ebp),%ebx
			    logEntry->sentAmount = 0;
   12963:	8b 43 20             	mov    0x20(%ebx),%eax
   12966:	ff 43 24             	incl   0x24(%ebx)
   12969:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
   12970:	ff 85 ac ef ff ff    	incl   0xffffefac(%ebp)
   12976:	83 85 98 ef ff ff 05 	addl   $0x5,0xffffef98(%ebp)
   1297d:	39 85 ac ef ff ff    	cmp    %eax,0xffffefac(%ebp)
   12983:	0f 8c 57 fe ff ff    	jl     127e0 <trickles_read_proc+0x130>
		    } else {
			    logEntry->sentAmount += copyLen;
			    //printk("sentamount = %d\n", logEntry->sentAmount);
			    BUG_TRAP(pos == count);
			    goto done;
		    }
	    }
	    if(done && (i == logEntry->size)) {
   12989:	8b bd a4 ef ff ff    	mov    0xffffefa4(%ebp),%edi
   1298f:	85 ff                	test   %edi,%edi
   12991:	74 08                	je     1299b <trickles_read_proc+0x2eb>
   12993:	39 85 ac ef ff ff    	cmp    %eax,0xffffefac(%ebp)
   12999:	74 66                	je     12a01 <trickles_read_proc+0x351>
   1299b:	8b 9d b0 ef ff ff    	mov    0xffffefb0(%ebp),%ebx
   129a1:	8b 5b 04             	mov    0x4(%ebx),%ebx
   129a4:	81 fb 00 00 00 00    	cmp    $0x0,%ebx
   129aa:	89 9d b0 ef ff ff    	mov    %ebx,0xffffefb0(%ebp)
   129b0:	0f 85 35 fd ff ff    	jne    126eb <trickles_read_proc+0x3b>
   129b6:	a1 04 00 00 00       	mov    0x4,%eax
#ifdef __KERNEL__
#define VALID_MSK_CTL(X) ((X)->ctl == ALLOC_READY || \
                          (X)->ctl == ALLOC_HALFFREE)

static inline int empty(struct alloc_head_list *head) {
   129bb:	31 d2                	xor    %edx,%edx
   129bd:	3d 00 00 00 00       	cmp    $0x0,%eax
   129c2:	8b 45 18             	mov    0x18(%ebp),%eax
   129c5:	0f 94 c2             	sete   %dl
   129c8:	89 10                	mov    %edx,(%eax)
		    struct TricklesProcLogEntry *clean = logEntry;
		    logEntry = (struct TricklesProcLogEntry *)logEntry->prev;
		    unlink((struct alloc_head*)clean);
		    kfree(clean->events);
		    kfree(clean);
	    }
    }
 done:
    if(empty(&tricklesProcLogHead)) {
	    *eof = 1;
    } else {
	    *eof = 0;
    }
    local_bh_enable();
   129ca:	ba 08 00 00 00       	mov    $0x8,%edx
   129cf:	a1 08 00 00 00       	mov    0x8,%eax
   129d4:	48                   	dec    %eax
   129d5:	85 c0                	test   %eax,%eax
   129d7:	a3 08 00 00 00       	mov    %eax,0x8
   129dc:	75 0a                	jne    129e8 <trickles_read_proc+0x338>
   129de:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   129e2:	0f 85 ea 08 00 00    	jne    132d2 <.text.lock.tmalloc+0x300>
    *start = page;
   129e8:	8b 45 0c             	mov    0xc(%ebp),%eax
   129eb:	8b 55 08             	mov    0x8(%ebp),%edx
   129ee:	89 10                	mov    %edx,(%eax)
    //printk("pos=%d, count=%d\n", pos, count);
    return pos;
}
   129f0:	8b 85 a8 ef ff ff    	mov    0xffffefa8(%ebp),%eax
   129f6:	81 c4 78 10 00 00    	add    $0x1078,%esp
   129fc:	5b                   	pop    %ebx
   129fd:	5e                   	pop    %esi
   129fe:	5f                   	pop    %edi
   129ff:	5d                   	pop    %ebp
   12a00:	c3                   	ret    
   12a01:	8b 9d b0 ef ff ff    	mov    0xffffefb0(%ebp),%ebx
   12a07:	8b 0b                	mov    (%ebx),%ecx
   12a09:	89 8d b0 ef ff ff    	mov    %ecx,0xffffefb0(%ebp)
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
   12a0f:	8b 53 04             	mov    0x4(%ebx),%edx
   12a12:	8b 03                	mov    (%ebx),%eax
   12a14:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
   12a16:	8b 03                	mov    (%ebx),%eax
	elem->prev = elem->next = NULL;
   12a18:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
   12a1e:	89 50 04             	mov    %edx,0x4(%eax)

	elem->list->len--;
   12a21:	8b 43 08             	mov    0x8(%ebx),%eax
   12a24:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
   12a2b:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
   12a2e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
   12a35:	8b 43 1c             	mov    0x1c(%ebx),%eax
   12a38:	89 04 24             	mov    %eax,(%esp,1)
   12a3b:	e8 fc ff ff ff       	call   12a3c <trickles_read_proc+0x38c>
   12a40:	89 1c 24             	mov    %ebx,(%esp,1)
   12a43:	e8 fc ff ff ff       	call   12a44 <trickles_read_proc+0x394>
   12a48:	e9 4e ff ff ff       	jmp    1299b <trickles_read_proc+0x2eb>
   12a4d:	8b 85 b0 ef ff ff    	mov    0xffffefb0(%ebp),%eax
   12a53:	01 50 28             	add    %edx,0x28(%eax)
   12a56:	8b 55 14             	mov    0x14(%ebp),%edx
   12a59:	39 95 a8 ef ff ff    	cmp    %edx,0xffffefa8(%ebp)
   12a5f:	0f 84 51 ff ff ff    	je     129b6 <trickles_read_proc+0x306>
   12a65:	c7 44 24 04 c1 07 00 	movl   $0x7c1,0x4(%esp,1)
   12a6c:	00 
   12a6d:	c7 04 24 60 43 00 00 	movl   $0x4360,(%esp,1)
   12a74:	e8 fc ff ff ff       	call   12a75 <trickles_read_proc+0x3c5>
   12a79:	e9 38 ff ff ff       	jmp    129b6 <trickles_read_proc+0x306>
   12a7e:	89 f6                	mov    %esi,%esi
   12a80:	83 f8 03             	cmp    $0x3,%eax
   12a83:	b9 7a 0b 00 00       	mov    $0xb7a,%ecx
   12a88:	0f 84 e1 fd ff ff    	je     1286f <trickles_read_proc+0x1bf>
   12a8e:	b9 86 0b 00 00       	mov    $0xb86,%ecx
   12a93:	83 f8 04             	cmp    $0x4,%eax
   12a96:	e9 cd fd ff ff       	jmp    12868 <trickles_read_proc+0x1b8>
   12a9b:	90                   	nop    
   12a9c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
   12aa0:	83 fa 03             	cmp    $0x3,%edx
   12aa3:	bb 8f 0b 00 00       	mov    $0xb8f,%ebx
   12aa8:	0f 84 9b fd ff ff    	je     12849 <trickles_read_proc+0x199>
   12aae:	bb a0 0b 00 00       	mov    $0xba0,%ebx
   12ab3:	83 fa 04             	cmp    $0x4,%edx
   12ab6:	e9 6b fd ff ff       	jmp    12826 <trickles_read_proc+0x176>
   12abb:	90                   	nop    
   12abc:	8d 74 26 00          	lea    0x0(%esi,1),%esi

00012ac0 <bb_init>:

struct alloc_head_list tricklesCwndProcLogHead;

struct BoundedBuffer {
	char *dest;
	int len;
	int curPos;
};

void bb_init(struct BoundedBuffer *bb, char *buffer, int len) {
   12ac0:	55                   	push   %ebp
   12ac1:	89 e5                	mov    %esp,%ebp
	bb->dest = buffer;
   12ac3:	8b 55 0c             	mov    0xc(%ebp),%edx
   12ac6:	8b 45 08             	mov    0x8(%ebp),%eax
   12ac9:	89 10                	mov    %edx,(%eax)
	bb->len = len;
   12acb:	8b 55 10             	mov    0x10(%ebp),%edx
	bb->curPos = 0;
   12ace:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   12ad5:	89 50 04             	mov    %edx,0x4(%eax)

	//printk("bbinit: %p %d %d\n", bb->dest, bb->len, bb->curPos);
}
   12ad8:	5d                   	pop    %ebp
   12ad9:	c3                   	ret    
   12ada:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00012ae0 <bb_write>:

int bb_write(struct BoundedBuffer *bb, const char *data, int len) {
   12ae0:	55                   	push   %ebp
   12ae1:	89 e5                	mov    %esp,%ebp
   12ae3:	83 ec 08             	sub    $0x8,%esp
   12ae6:	89 34 24             	mov    %esi,(%esp,1)
   12ae9:	8b 4d 08             	mov    0x8(%ebp),%ecx
   12aec:	8b 75 0c             	mov    0xc(%ebp),%esi
   12aef:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
	int prevPos = bb->curPos;
   12af3:	8b 79 08             	mov    0x8(%ecx),%edi
	int copyLen;
	bb->curPos = MIN(prevPos+len, bb->len);
   12af6:	8b 41 04             	mov    0x4(%ecx),%eax
   12af9:	89 fa                	mov    %edi,%edx
   12afb:	03 55 10             	add    0x10(%ebp),%edx
   12afe:	39 d0                	cmp    %edx,%eax
   12b00:	0f 4f c2             	cmovg  %edx,%eax
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
   12b03:	8b 11                	mov    (%ecx),%edx
   12b05:	89 41 08             	mov    %eax,0x8(%ecx)
	copyLen = bb->curPos - prevPos;
   12b08:	29 f8                	sub    %edi,%eax

static inline void * __memcpy(void * to, const void * from, size_t n)
{
int d0, d1, d2;
__asm__ __volatile__(
   12b0a:	89 c1                	mov    %eax,%ecx
   12b0c:	01 d7                	add    %edx,%edi
   12b0e:	c1 e9 02             	shr    $0x2,%ecx
   12b11:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   12b13:	a8 02                	test   $0x2,%al
   12b15:	74 02                	je     12b19 <bb_write+0x39>
   12b17:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
   12b19:	a8 01                	test   $0x1,%al
   12b1b:	74 01                	je     12b1e <bb_write+0x3e>
   12b1d:	a4                   	movsb  %ds:(%esi),%es:(%edi)

	memcpy(bb->dest + prevPos, data, copyLen);
	return copyLen;
}
   12b1e:	8b 34 24             	mov    (%esp,1),%esi
   12b21:	8b 7c 24 04          	mov    0x4(%esp,1),%edi
   12b25:	89 ec                	mov    %ebp,%esp
   12b27:	5d                   	pop    %ebp
   12b28:	c3                   	ret    
   12b29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi

00012b30 <trickles_logCwnd_impl>:

spinlock_t cwndLogLock = SPIN_LOCK_UNLOCKED;

void trickles_logCwnd_impl(int addr, short port, int seq, int ack_seq, 
			   int startCwnd, int effCwnd, int ssthresh, 
			   int rtt, int srtt) {
   12b30:	55                   	push   %ebp
   12b31:	89 e5                	mov    %esp,%ebp
#ifdef LOG_CWND_ENABLE
	struct TricklesCwndProcLogEntry *logentry = 
		kmalloc(sizeof(struct TricklesCwndProcLogEntry), GFP_ATOMIC);
	if(logentry != NULL) {
		logentry->prev = logentry->next = NULL;
		logentry->list = NULL;
		logentry->addr = addr;
		logentry->port = port;
		logentry->seq  = seq;
		logentry->ack_seq = ack_seq;
		logentry->startCwnd= startCwnd;
		logentry->effCwnd  = effCwnd;
		logentry->ssthresh = ssthresh;
		logentry->sentAmount = 0;
#if 0
		logentry->timestamp = jiffies;
#else
		// high resolution timestamp
		struct timeval tv;
		do_gettimeofday(&tv);
		// s, us
		logentry->s = tv.tv_sec;
		logentry->us = tv.tv_usec;
#endif
		logentry->rtt = rtt;
		logentry->srtt = srtt;
		spin_lock(&cwndLogLock);
		insert_tail(&tricklesCwndProcLogHead, (struct alloc_head*)logentry);
		spin_unlock(&cwndLogLock);
	}
#endif
}
   12b33:	5d                   	pop    %ebp
   12b34:	c3                   	ret    
   12b35:	8d 74 26 00          	lea    0x0(%esi,1),%esi
   12b39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00012b40 <trickles_cwnd_read_proc>:

int trickles_cwnd_read_proc(char *page, char **start, off_t offset, int count,
			    int *eof, void *data)
{
   12b40:	55                   	push   %ebp
   12b41:	89 e5                	mov    %esp,%ebp
   12b43:	57                   	push   %edi
    struct TricklesCwndProcLogEntry *logEntry;
    struct BoundedBuffer bb;
    bb_init(&bb, page, count);
   12b44:	8d 55 e4             	lea    0xffffffe4(%ebp),%edx
   12b47:	56                   	push   %esi
   12b48:	53                   	push   %ebx
   12b49:	81 ec 48 04 00 00    	sub    $0x448,%esp
   12b4f:	8b 45 14             	mov    0x14(%ebp),%eax
   12b52:	89 14 24             	mov    %edx,(%esp,1)
   12b55:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   12b59:	8b 45 08             	mov    0x8(%ebp),%eax
   12b5c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12b60:	e8 fc ff ff ff       	call   12b61 <trickles_cwnd_read_proc+0x21>

#define TRICKLES_CWND_READ_DISABLE_BH
#ifdef TRICKLES_CWND_READ_DISABLE_BH
    local_bh_disable();
   12b65:	ff 05 08 00 00 00    	incl   0x8
#else
    #warning "Local bh not disabled while reading from cwnd log"
#endif
    alloc_head_walk(&tricklesCwndProcLogHead, logEntry) {
   12b6b:	a1 04 00 00 00       	mov    0x4,%eax
   12b70:	3d 00 00 00 00       	cmp    $0x0,%eax
   12b75:	89 c3                	mov    %eax,%ebx
   12b77:	0f 84 ba 00 00 00    	je     12c37 <trickles_cwnd_read_proc+0xf7>
   12b7d:	8d 76 00             	lea    0x0(%esi),%esi
	    if(1) {
		    char tempbuf[1024];
		    int wrlen, real_wrlen;
		    sprintf(tempbuf, "%8.8X:%d:%d:%d = %d/%d/%d @ %d s %d us %d rtt0 %d rtt1\n", 
   12b80:	0f b7 53 10          	movzwl 0x10(%ebx),%edx
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
   12b84:	8d bd e4 fb ff ff    	lea    0xfffffbe4(%ebp),%edi
/* gcc should generate this for open coded C now too. May be worth switching to 
   it because inline assembly cannot be scheduled. -AK */
static __inline__ __const__ __u16 ___arch__swab16(__u16 x)
{
	__asm__("xchgb %b0,%h0"		/* swap bytes		*/
   12b8a:	86 d6                	xchg   %dl,%dh
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
   12b8c:	8b 43 30             	mov    0x30(%ebx),%eax
   12b8f:	0f b7 d2             	movzwl %dx,%edx
   12b92:	8b 4b 0c             	mov    0xc(%ebx),%ecx

static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{
#ifdef CONFIG_X86_BSWAP
	__asm__("bswap %0" : "=r" (x) : "0" (x));
   12b95:	0f c9                	bswap  %ecx
	__arch__swab24s(addr);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
   12b97:	89 44 24 30          	mov    %eax,0x30(%esp,1)
   12b9b:	8b 43 2c             	mov    0x2c(%ebx),%eax
   12b9e:	89 44 24 2c          	mov    %eax,0x2c(%esp,1)
   12ba2:	8b 43 28             	mov    0x28(%ebx),%eax
   12ba5:	89 44 24 28          	mov    %eax,0x28(%esp,1)
   12ba9:	8b 43 24             	mov    0x24(%ebx),%eax
   12bac:	89 44 24 24          	mov    %eax,0x24(%esp,1)
   12bb0:	0f b7 43 20          	movzwl 0x20(%ebx),%eax
   12bb4:	89 44 24 20          	mov    %eax,0x20(%esp,1)
   12bb8:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
   12bbc:	89 44 24 1c          	mov    %eax,0x1c(%esp,1)
   12bc0:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
   12bc4:	89 44 24 18          	mov    %eax,0x18(%esp,1)
   12bc8:	8b 43 18             	mov    0x18(%ebx),%eax
   12bcb:	89 44 24 14          	mov    %eax,0x14(%esp,1)
   12bcf:	8b 43 14             	mov    0x14(%ebx),%eax
   12bd2:	89 54 24 0c          	mov    %edx,0xc(%esp,1)
   12bd6:	89 4c 24 08          	mov    %ecx,0x8(%esp,1)
   12bda:	89 3c 24             	mov    %edi,(%esp,1)
   12bdd:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   12be1:	c7 44 24 04 c0 43 00 	movl   $0x43c0,0x4(%esp,1)
   12be8:	00 
   12be9:	e8 fc ff ff ff       	call   12bea <trickles_cwnd_read_proc+0xaa>
			    ntohl(logEntry->addr), ntohs(logEntry->port), 
			    logEntry->seq, logEntry->ack_seq,
			    logEntry->startCwnd, logEntry->effCwnd, logEntry->ssthresh, 
			    logEntry->s, logEntry->us,
			    logEntry->rtt, logEntry->srtt);
		    // , logEntry->timestamp);
		    char *src = tempbuf + logEntry->sentAmount;
   12bee:	8b 43 34             	mov    0x34(%ebx),%eax
   12bf1:	89 fa                	mov    %edi,%edx
static inline size_t strlen(const char * s)
{
int d0;
register int __res;
__asm__ __volatile__(
   12bf3:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
   12bf8:	01 c2                	add    %eax,%edx
static inline size_t strlen(const char * s)
{
int d0;
register int __res;
__asm__ __volatile__(
   12bfa:	31 c0                	xor    %eax,%eax
   12bfc:	89 d7                	mov    %edx,%edi
   12bfe:	f2 ae                	repnz scas %es:(%edi),%al
   12c00:	f7 d1                	not    %ecx
   12c02:	49                   	dec    %ecx
   12c03:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   12c06:	89 4c 24 08          	mov    %ecx,0x8(%esp,1)
   12c0a:	89 ce                	mov    %ecx,%esi
   12c0c:	89 54 24 04          	mov    %edx,0x4(%esp,1)
   12c10:	89 04 24             	mov    %eax,(%esp,1)
   12c13:	e8 fc ff ff ff       	call   12c14 <trickles_cwnd_read_proc+0xd4>
		    real_wrlen = bb_write(&bb, src, wrlen = strlen(src));
		    logEntry->sentAmount = real_wrlen;
   12c18:	89 43 34             	mov    %eax,0x34(%ebx)
	    
		    if(real_wrlen < wrlen) {
   12c1b:	39 f0                	cmp    %esi,%eax
   12c1d:	7c 13                	jl     12c32 <trickles_cwnd_read_proc+0xf2>
			    break;
		    }
		    if(real_wrlen == wrlen) {
   12c1f:	39 f0                	cmp    %esi,%eax
   12c21:	74 5d                	je     12c80 <trickles_cwnd_read_proc+0x140>
   12c23:	8b 5b 04             	mov    0x4(%ebx),%ebx
   12c26:	81 fb 00 00 00 00    	cmp    $0x0,%ebx
   12c2c:	0f 85 4e ff ff ff    	jne    12b80 <trickles_cwnd_read_proc+0x40>
   12c32:	a1 04 00 00 00       	mov    0x4,%eax
#ifdef __KERNEL__
#define VALID_MSK_CTL(X) ((X)->ctl == ALLOC_READY || \
                          (X)->ctl == ALLOC_HALFFREE)

static inline int empty(struct alloc_head_list *head) {
   12c37:	31 d2                	xor    %edx,%edx
   12c39:	3d 00 00 00 00       	cmp    $0x0,%eax
   12c3e:	8b 45 18             	mov    0x18(%ebp),%eax
   12c41:	0f 94 c2             	sete   %dl
   12c44:	89 10                	mov    %edx,(%eax)
			    struct TricklesCwndProcLogEntry *clean;
			    clean = logEntry;
			    logEntry = (struct TricklesCwndProcLogEntry*)logEntry->prev;
			    unlink((struct alloc_head*)clean);
			    kfree(clean);
		    }

	    }
    }
    if(empty(&tricklesCwndProcLogHead)) {
	    // done with all entries
	    //printk("eof\n");
	    *eof = 1;
    } else {
	    *eof = 0;
    }
#ifdef TRICKLES_CWND_READ_DISABLE_BH
    local_bh_enable();
   12c46:	ba 08 00 00 00       	mov    $0x8,%edx
   12c4b:	a1 08 00 00 00       	mov    0x8,%eax
   12c50:	48                   	dec    %eax
   12c51:	85 c0                	test   %eax,%eax
   12c53:	a3 08 00 00 00       	mov    %eax,0x8
   12c58:	75 0a                	jne    12c64 <trickles_cwnd_read_proc+0x124>
   12c5a:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   12c5e:	0f 85 7e 06 00 00    	jne    132e2 <.text.lock.tmalloc+0x310>
#endif

    //printk("curpos = %d %d\n", bb.curPos, loop_count);

    *start = page;
   12c64:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c67:	8b 55 08             	mov    0x8(%ebp),%edx
   12c6a:	89 10                	mov    %edx,(%eax)
    return bb.curPos;
   12c6c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
   12c6f:	81 c4 48 04 00 00    	add    $0x448,%esp
   12c75:	5b                   	pop    %ebx
   12c76:	5e                   	pop    %esi
   12c77:	5f                   	pop    %edi
   12c78:	5d                   	pop    %ebp
   12c79:	c3                   	ret    
   12c7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   12c80:	89 da                	mov    %ebx,%edx
   12c82:	8b 1b                	mov    (%ebx),%ebx
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
   12c84:	8b 4a 04             	mov    0x4(%edx),%ecx
   12c87:	89 19                	mov    %ebx,(%ecx)
	elem->prev->next = elem->next;
   12c89:	8b 02                	mov    (%edx),%eax
	elem->prev = elem->next = NULL;
   12c8b:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
   12c91:	89 48 04             	mov    %ecx,0x4(%eax)

	elem->list->len--;
   12c94:	8b 42 08             	mov    0x8(%edx),%eax
   12c97:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
   12c9e:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
   12ca1:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
   12ca8:	89 14 24             	mov    %edx,(%esp,1)
   12cab:	e8 fc ff ff ff       	call   12cac <trickles_cwnd_read_proc+0x16c>
   12cb0:	e9 6e ff ff ff       	jmp    12c23 <trickles_cwnd_read_proc+0xe3>
   12cb5:	8d 74 26 00          	lea    0x0(%esi,1),%esi
   12cb9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00012cc0 <__constant_memcpy>:
 * This looks horribly ugly, but the compiler can optimize it totally,
 * as the count is constant.
 */
static inline void * __constant_memcpy(void * to, const void * from, size_t n)
{
   12cc0:	55                   	push   %ebp
   12cc1:	89 e5                	mov    %esp,%ebp
   12cc3:	83 ec 0c             	sub    $0xc,%esp
   12cc6:	89 75 f8             	mov    %esi,0xfffffff8(%ebp)
   12cc9:	8b 4d 10             	mov    0x10(%ebp),%ecx
   12ccc:	8b 55 08             	mov    0x8(%ebp),%edx
   12ccf:	89 7d fc             	mov    %edi,0xfffffffc(%ebp)
	switch (n) {
   12cd2:	83 f9 14             	cmp    $0x14,%ecx
   12cd5:	8b 75 0c             	mov    0xc(%ebp),%esi
   12cd8:	0f 87 82 00 00 00    	ja     12d60 <__constant_memcpy+0xa0>
   12cde:	ff 24 8d 68 01 00 00 	jmp    *0x168(,%ecx,4)
		case 0:
			return to;
		case 1:
			*(unsigned char *)to = *(const unsigned char *)from;
   12ce5:	0f b6 06             	movzbl (%esi),%eax
   12ce8:	88 02                	mov    %al,(%edx)
   12cea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			return to;
		case 2:
			*(unsigned short *)to = *(const unsigned short *)from;
			return to;
		case 3:
			*(unsigned short *)to = *(const unsigned short *)from;
			*(2+(unsigned char *)to) = *(2+(const unsigned char *)from);
			return to;
		case 4:
			*(unsigned long *)to = *(const unsigned long *)from;
			return to;
		case 6:	/* for Ethernet addresses */
			*(unsigned long *)to = *(const unsigned long *)from;
			*(2+(unsigned short *)to) = *(2+(const unsigned short *)from);
			return to;
		case 8:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			return to;
		case 12:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
			return to;
		case 16:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
			*(3+(unsigned long *)to) = *(3+(const unsigned long *)from);
			return to;
		case 20:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
			*(3+(unsigned long *)to) = *(3+(const unsigned long *)from);
			*(4+(unsigned long *)to) = *(4+(const unsigned long *)from);
			return to;
	}
#define COMMON(x) \
__asm__ __volatile__( \
	"rep ; movsl" \
	x \
	: "=&c" (d0), "=&D" (d1), "=&S" (d2) \
	: "0" (n/4),"1" ((long) to),"2" ((long) from) \
	: "memory");
{
	int d0, d1, d2;
	switch (n % 4) {
		case 0: COMMON(""); return to;
		case 1: COMMON("\n\tmovsb"); return to;
		case 2: COMMON("\n\tmovsw"); return to;
		default: COMMON("\n\tmovsw\n\tmovsb"); return to;
	}
}
  
#undef COMMON
}
   12cf0:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
   12cf3:	89 d0                	mov    %edx,%eax
   12cf5:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
   12cf8:	89 ec                	mov    %ebp,%esp
   12cfa:	5d                   	pop    %ebp
   12cfb:	c3                   	ret    
   12cfc:	0f b7 06             	movzwl (%esi),%eax
   12cff:	66 89 02             	mov    %ax,(%edx)
   12d02:	eb ec                	jmp    12cf0 <__constant_memcpy+0x30>
   12d04:	0f b7 06             	movzwl (%esi),%eax
   12d07:	66 89 02             	mov    %ax,(%edx)
   12d0a:	0f b6 46 02          	movzbl 0x2(%esi),%eax
   12d0e:	88 42 02             	mov    %al,0x2(%edx)
   12d11:	eb dd                	jmp    12cf0 <__constant_memcpy+0x30>
   12d13:	8b 06                	mov    (%esi),%eax
   12d15:	89 02                	mov    %eax,(%edx)
   12d17:	eb d7                	jmp    12cf0 <__constant_memcpy+0x30>
   12d19:	8b 06                	mov    (%esi),%eax
   12d1b:	89 02                	mov    %eax,(%edx)
   12d1d:	0f b7 46 04          	movzwl 0x4(%esi),%eax
   12d21:	66 89 42 04          	mov    %ax,0x4(%edx)
   12d25:	eb c9                	jmp    12cf0 <__constant_memcpy+0x30>
   12d27:	8b 06                	mov    (%esi),%eax
   12d29:	89 02                	mov    %eax,(%edx)
   12d2b:	8b 46 04             	mov    0x4(%esi),%eax
   12d2e:	89 42 04             	mov    %eax,0x4(%edx)
   12d31:	eb bd                	jmp    12cf0 <__constant_memcpy+0x30>
   12d33:	8b 06                	mov    (%esi),%eax
   12d35:	89 02                	mov    %eax,(%edx)
   12d37:	8b 46 04             	mov    0x4(%esi),%eax
   12d3a:	89 42 04             	mov    %eax,0x4(%edx)
   12d3d:	8b 46 08             	mov    0x8(%esi),%eax
   12d40:	89 42 08             	mov    %eax,0x8(%edx)
   12d43:	eb ab                	jmp    12cf0 <__constant_memcpy+0x30>
   12d45:	8b 06                	mov    (%esi),%eax
   12d47:	89 02                	mov    %eax,(%edx)
   12d49:	8b 46 04             	mov    0x4(%esi),%eax
   12d4c:	89 42 04             	mov    %eax,0x4(%edx)
   12d4f:	8b 46 08             	mov    0x8(%esi),%eax
   12d52:	89 42 08             	mov    %eax,0x8(%edx)
   12d55:	8b 46 0c             	mov    0xc(%esi),%eax
   12d58:	89 42 0c             	mov    %eax,0xc(%edx)
   12d5b:	eb 93                	jmp    12cf0 <__constant_memcpy+0x30>
   12d5d:	8d 76 00             	lea    0x0(%esi),%esi
   12d60:	89 c8                	mov    %ecx,%eax
   12d62:	83 e0 03             	and    $0x3,%eax
   12d65:	83 f8 01             	cmp    $0x1,%eax
   12d68:	74 36                	je     12da0 <__constant_memcpy+0xe0>
   12d6a:	83 f8 01             	cmp    $0x1,%eax
   12d6d:	72 22                	jb     12d91 <__constant_memcpy+0xd1>
   12d6f:	83 f8 02             	cmp    $0x2,%eax
   12d72:	74 0f                	je     12d83 <__constant_memcpy+0xc3>
   12d74:	c1 e9 02             	shr    $0x2,%ecx
   12d77:	89 d7                	mov    %edx,%edi
   12d79:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   12d7b:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
   12d7d:	a4                   	movsb  %ds:(%esi),%es:(%edi)
   12d7e:	e9 6d ff ff ff       	jmp    12cf0 <__constant_memcpy+0x30>
   12d83:	c1 e9 02             	shr    $0x2,%ecx
   12d86:	89 d7                	mov    %edx,%edi
   12d88:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   12d8a:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
   12d8c:	e9 5f ff ff ff       	jmp    12cf0 <__constant_memcpy+0x30>
   12d91:	c1 e9 02             	shr    $0x2,%ecx
   12d94:	89 d7                	mov    %edx,%edi
   12d96:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   12d98:	e9 53 ff ff ff       	jmp    12cf0 <__constant_memcpy+0x30>
   12d9d:	8d 76 00             	lea    0x0(%esi),%esi
   12da0:	c1 e9 02             	shr    $0x2,%ecx
   12da3:	89 d7                	mov    %edx,%edi
   12da5:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   12da7:	a4                   	movsb  %ds:(%esi),%es:(%edi)
   12da8:	e9 43 ff ff ff       	jmp    12cf0 <__constant_memcpy+0x30>
   12dad:	8b 06                	mov    (%esi),%eax
   12daf:	89 02                	mov    %eax,(%edx)
   12db1:	8b 46 04             	mov    0x4(%esi),%eax
   12db4:	89 42 04             	mov    %eax,0x4(%edx)
   12db7:	8b 46 08             	mov    0x8(%esi),%eax
   12dba:	89 42 08             	mov    %eax,0x8(%edx)
   12dbd:	8b 46 0c             	mov    0xc(%esi),%eax
   12dc0:	89 42 0c             	mov    %eax,0xc(%edx)
   12dc3:	8b 46 10             	mov    0x10(%esi),%eax
   12dc6:	89 42 10             	mov    %eax,0x10(%edx)
   12dc9:	e9 22 ff ff ff       	jmp    12cf0 <__constant_memcpy+0x30>
   12dce:	89 f6                	mov    %esi,%esi

00012dd0 <__constant_c_and_count_memset>:

#define __HAVE_ARCH_MEMCPY

#ifdef CONFIG_X86_USE_3DNOW

#include <asm/mmx.h>

/*
 *	This CPU favours 3DNow strongly (eg AMD Athlon)
 */

static inline void * __constant_memcpy3d(void * to, const void * from, size_t len)
{
	if (len < 512)
		return __constant_memcpy(to, from, len);
	return _mmx_memcpy(to, from, len);
}

static __inline__ void *__memcpy3d(void *to, const void *from, size_t len)
{
	if (len < 512)
		return __memcpy(to, from, len);
	return _mmx_memcpy(to, from, len);
}

#define memcpy(t, f, n) \
(__builtin_constant_p(n) ? \
 __constant_memcpy3d((t),(f),(n)) : \
 __memcpy3d((t),(f),(n)))

#else

/*
 *	No 3D Now!
 */
 
#define memcpy(t, f, n) \
(__builtin_constant_p(n) ? \
 __constant_memcpy((t),(f),(n)) : \
 __memcpy((t),(f),(n)))

#endif

/*
 * struct_cpy(x,y), copy structure *x into (matching structure) *y.
 *
 * We get link-time errors if the structure sizes do not match.
 * There is no runtime overhead, it's all optimized away at
 * compile time.
 */
extern void __struct_cpy_bug (void);

#define struct_cpy(x,y) 			\
({						\
	if (sizeof(*(x)) != sizeof(*(y))) 	\
		__struct_cpy_bug;		\
	memcpy(x, y, sizeof(*(x)));		\
})

#define __HAVE_ARCH_MEMMOVE
static inline void * memmove(void * dest,const void * src, size_t n)
{
int d0, d1, d2;
if (dest<src)
__asm__ __volatile__(
	"rep\n\t"
	"movsb"
	: "=&c" (d0), "=&S" (d1), "=&D" (d2)
	:"0" (n),"1" (src),"2" (dest)
	: "memory");
else
__asm__ __volatile__(
	"std\n\t"
	"rep\n\t"
	"movsb\n\t"
	"cld"
	: "=&c" (d0), "=&S" (d1), "=&D" (d2)
	:"0" (n),
	 "1" (n-1+(const char *)src),
	 "2" (n-1+(char *)dest)
	:"memory");
return dest;
}

#define memcmp __builtin_memcmp

#define __HAVE_ARCH_MEMCHR
static inline void * memchr(const void * cs,int c,size_t count)
{
int d0;
register void * __res;
if (!count)
	return NULL;
__asm__ __volatile__(
	"repne\n\t"
	"scasb\n\t"
	"je 1f\n\t"
	"movl $1,%0\n"
	"1:\tdecl %0"
	:"=D" (__res), "=&c" (d0) : "a" (c),"0" (cs),"1" (count));
return __res;
}

static inline void * __memset_generic(void * s, char c,size_t count)
{
int d0, d1;
__asm__ __volatile__(
	"rep\n\t"
	"stosb"
	: "=&c" (d0), "=&D" (d1)
	:"a" (c),"1" (s),"0" (count)
	:"memory");
return s;
}

/* we might want to write optimized versions of these later */
#define __constant_count_memset(s,c,count) __memset_generic((s),(c),(count))

/*
 * memset(x,0,y) is a reasonably common thing to do, so we want to fill
 * things 32 bits at a time even when we don't know the size of the
 * area at compile-time..
 */
static inline void * __constant_c_memset(void * s, unsigned long c, size_t count)
{
int d0, d1;
__asm__ __volatile__(
	"rep ; stosl\n\t"
	"testb $2,%b3\n\t"
	"je 1f\n\t"
	"stosw\n"
	"1:\ttestb $1,%b3\n\t"
	"je 2f\n\t"
	"stosb\n"
	"2:"
	: "=&c" (d0), "=&D" (d1)
	:"a" (c), "q" (count), "0" (count/4), "1" ((long) s)
	:"memory");
return (s);	
}

/* Added by Gertjan van Wingerde to make minix and sysv module work */
#define __HAVE_ARCH_STRNLEN
static inline size_t strnlen(const char * s, size_t count)
{
int d0;
register int __res;
__asm__ __volatile__(
	"movl %2,%0\n\t"
	"jmp 2f\n"
	"1:\tcmpb $0,(%0)\n\t"
	"je 3f\n\t"
	"incl %0\n"
	"2:\tdecl %1\n\t"
	"cmpl $-1,%1\n\t"
	"jne 1b\n"
	"3:\tsubl %2,%0"
	:"=a" (__res), "=&d" (d0)
	:"c" (s),"1" (count));
return __res;
}
/* end of additional stuff */

#define __HAVE_ARCH_STRSTR

extern char *strstr(const char *cs, const char *ct);

/*
 * This looks horribly ugly, but the compiler can optimize it totally,
 * as we by now know that both pattern and count is constant..
 */
static inline void * __constant_c_and_count_memset(void * s, unsigned long pattern, size_t count)
{
   12dd0:	55                   	push   %ebp
   12dd1:	89 e5                	mov    %esp,%ebp
   12dd3:	83 ec 08             	sub    $0x8,%esp
   12dd6:	89 1c 24             	mov    %ebx,(%esp,1)
   12dd9:	8b 4d 10             	mov    0x10(%ebp),%ecx
   12ddc:	8b 55 08             	mov    0x8(%ebp),%edx
   12ddf:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
	switch (count) {
   12de3:	83 f9 04             	cmp    $0x4,%ecx
   12de6:	8b 45 0c             	mov    0xc(%ebp),%eax
   12de9:	77 35                	ja     12e20 <__constant_c_and_count_memset+0x50>
   12deb:	ff 24 8d bc 01 00 00 	jmp    *0x1bc(,%ecx,4)
		case 0:
			return s;
		case 1:
			*(unsigned char *)s = pattern;
   12df2:	88 02                	mov    %al,(%edx)
   12df4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   12dfa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
			return s;
		case 2:
			*(unsigned short *)s = pattern;
			return s;
		case 3:
			*(unsigned short *)s = pattern;
			*(2+(unsigned char *)s) = pattern;
			return s;
		case 4:
			*(unsigned long *)s = pattern;
			return s;
	}
#define COMMON(x) \
__asm__  __volatile__( \
	"rep ; stosl" \
	x \
	: "=&c" (d0), "=&D" (d1) \
	: "a" (pattern),"0" (count/4),"1" ((long) s) \
	: "memory")
{
	int d0, d1;
	switch (count % 4) {
		case 0: COMMON(""); return s;
		case 1: COMMON("\n\tstosb"); return s;
		case 2: COMMON("\n\tstosw"); return s;
		default: COMMON("\n\tstosw\n\tstosb"); return s;
	}
}
  
#undef COMMON
}
   12e00:	8b 1c 24             	mov    (%esp,1),%ebx
   12e03:	89 d0                	mov    %edx,%eax
   12e05:	8b 7c 24 04          	mov    0x4(%esp,1),%edi
   12e09:	89 ec                	mov    %ebp,%esp
   12e0b:	5d                   	pop    %ebp
   12e0c:	c3                   	ret    
   12e0d:	66 89 02             	mov    %ax,(%edx)
   12e10:	eb ee                	jmp    12e00 <__constant_c_and_count_memset+0x30>
   12e12:	66 89 02             	mov    %ax,(%edx)
   12e15:	88 42 02             	mov    %al,0x2(%edx)
   12e18:	eb e6                	jmp    12e00 <__constant_c_and_count_memset+0x30>
   12e1a:	89 02                	mov    %eax,(%edx)
   12e1c:	eb e2                	jmp    12e00 <__constant_c_and_count_memset+0x30>
   12e1e:	89 f6                	mov    %esi,%esi
   12e20:	89 cb                	mov    %ecx,%ebx
   12e22:	83 e3 03             	and    $0x3,%ebx
   12e25:	83 fb 01             	cmp    $0x1,%ebx
   12e28:	74 36                	je     12e60 <__constant_c_and_count_memset+0x90>
   12e2a:	83 fb 01             	cmp    $0x1,%ebx
   12e2d:	72 21                	jb     12e50 <__constant_c_and_count_memset+0x80>
   12e2f:	83 fb 02             	cmp    $0x2,%ebx
   12e32:	74 0c                	je     12e40 <__constant_c_and_count_memset+0x70>
   12e34:	c1 e9 02             	shr    $0x2,%ecx
   12e37:	89 d7                	mov    %edx,%edi
   12e39:	f3 ab                	repz stos %eax,%es:(%edi)
   12e3b:	66 ab                	stos   %ax,%es:(%edi)
   12e3d:	aa                   	stos   %al,%es:(%edi)
   12e3e:	eb c0                	jmp    12e00 <__constant_c_and_count_memset+0x30>
   12e40:	c1 e9 02             	shr    $0x2,%ecx
   12e43:	89 d7                	mov    %edx,%edi
   12e45:	f3 ab                	repz stos %eax,%es:(%edi)
   12e47:	66 ab                	stos   %ax,%es:(%edi)
   12e49:	eb b5                	jmp    12e00 <__constant_c_and_count_memset+0x30>
   12e4b:	90                   	nop    
   12e4c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
   12e50:	c1 e9 02             	shr    $0x2,%ecx
   12e53:	89 d7                	mov    %edx,%edi
   12e55:	f3 ab                	repz stos %eax,%es:(%edi)
   12e57:	eb a7                	jmp    12e00 <__constant_c_and_count_memset+0x30>
   12e59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi
   12e60:	c1 e9 02             	shr    $0x2,%ecx
   12e63:	89 d7                	mov    %edx,%edi
   12e65:	f3 ab                	repz stos %eax,%es:(%edi)
   12e67:	aa                   	stos   %al,%es:(%edi)
   12e68:	eb 96                	jmp    12e00 <__constant_c_and_count_memset+0x30>
   12e6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00012e70 <__constant_copy_to_user>:
unsigned long __generic_copy_from_user(void *, const void *, unsigned long);

static inline unsigned long
__constant_copy_to_user(void *to, const void *from, unsigned long n)
{
   12e70:	55                   	push   %ebp
   12e71:	89 e5                	mov    %esp,%ebp
   12e73:	83 ec 0c             	sub    $0xc,%esp
   12e76:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   12e7a:	8b 4d 10             	mov    0x10(%ebp),%ecx
   12e7d:	8b 75 0c             	mov    0xc(%ebp),%esi
   12e80:	89 7c 24 08          	mov    %edi,0x8(%esp,1)
   12e84:	8b 7d 08             	mov    0x8(%ebp),%edi
   12e87:	89 1c 24             	mov    %ebx,(%esp,1)

#define ARCH_HAS_PREFETCH
static inline void prefetch(const void *x)
{
	__asm__ __volatile__ ("prefetchnta (%0)" : : "r"(x));
   12e8a:	0f 18 06             	prefetchnta (%esi)

static inline struct task_struct * get_current(void)
{
	struct task_struct *current;
	__asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
   12e8d:	b8 00 e0 ff ff       	mov    $0xffffe000,%eax
   12e92:	89 fa                	mov    %edi,%edx
   12e94:	21 e0                	and    %esp,%eax
   12e96:	01 ca                	add    %ecx,%edx
   12e98:	19 db                	sbb    %ebx,%ebx
   12e9a:	39 50 0c             	cmp    %edx,0xc(%eax)
   12e9d:	83 db 00             	sbb    $0x0,%ebx
static inline unsigned long
__constant_copy_to_user(void *to, const void *from, unsigned long n)
{
	prefetch(from);
	if (access_ok(VERIFY_WRITE, to, n))
   12ea0:	85 db                	test   %ebx,%ebx
   12ea2:	75 17                	jne    12ebb <__constant_copy_to_user+0x4b>
		__constant_copy_user(to,from,n);
   12ea4:	89 c8                	mov    %ecx,%eax
   12ea6:	83 e0 03             	and    $0x3,%eax
   12ea9:	83 f8 02             	cmp    $0x2,%eax
   12eac:	74 35                	je     12ee3 <__constant_copy_to_user+0x73>
   12eae:	83 f8 02             	cmp    $0x2,%eax
   12eb1:	77 21                	ja     12ed4 <__constant_copy_to_user+0x64>
   12eb3:	48                   	dec    %eax
   12eb4:	74 16                	je     12ecc <__constant_copy_to_user+0x5c>
   12eb6:	c1 e9 02             	shr    $0x2,%ecx
   12eb9:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
	return n;
}
   12ebb:	8b 1c 24             	mov    (%esp,1),%ebx
   12ebe:	89 c8                	mov    %ecx,%eax
   12ec0:	8b 74 24 04          	mov    0x4(%esp,1),%esi
   12ec4:	8b 7c 24 08          	mov    0x8(%esp,1),%edi
   12ec8:	89 ec                	mov    %ebp,%esp
   12eca:	5d                   	pop    %ebp
   12ecb:	c3                   	ret    
   12ecc:	c1 e9 02             	shr    $0x2,%ecx
   12ecf:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   12ed1:	a4                   	movsb  %ds:(%esi),%es:(%edi)
   12ed2:	eb e7                	jmp    12ebb <__constant_copy_to_user+0x4b>
   12ed4:	83 f8 03             	cmp    $0x3,%eax
   12ed7:	75 dd                	jne    12eb6 <__constant_copy_to_user+0x46>
   12ed9:	c1 e9 02             	shr    $0x2,%ecx
   12edc:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   12ede:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
   12ee0:	a4                   	movsb  %ds:(%esi),%es:(%edi)
   12ee1:	eb d8                	jmp    12ebb <__constant_copy_to_user+0x4b>
   12ee3:	c1 e9 02             	shr    $0x2,%ecx
   12ee6:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   12ee8:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
   12eea:	eb cf                	jmp    12ebb <__constant_copy_to_user+0x4b>
   12eec:	8d 74 26 00          	lea    0x0(%esi,1),%esi

00012ef0 <__constant_copy_from_user>:

static inline unsigned long
__constant_copy_from_user(void *to, const void *from, unsigned long n)
{
   12ef0:	55                   	push   %ebp
   12ef1:	89 e5                	mov    %esp,%ebp
   12ef3:	83 ec 0c             	sub    $0xc,%esp
   12ef6:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   12efa:	8b 75 0c             	mov    0xc(%ebp),%esi

static inline struct task_struct * get_current(void)
{
	struct task_struct *current;
	__asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
   12efd:	b8 00 e0 ff ff       	mov    $0xffffe000,%eax
}

static inline unsigned long
__constant_copy_from_user(void *to, const void *from, unsigned long n)
{
   12f02:	89 1c 24             	mov    %ebx,(%esp,1)

struct task_struct;

static inline struct task_struct * get_current(void)
{
   12f05:	89 f2                	mov    %esi,%edx
}

static inline unsigned long
__constant_copy_from_user(void *to, const void *from, unsigned long n)
{
   12f07:	89 7c 24 08          	mov    %edi,0x8(%esp,1)
   12f0b:	8b 5d 10             	mov    0x10(%ebp),%ebx

static inline struct task_struct * get_current(void)
{
	struct task_struct *current;
	__asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
   12f0e:	21 e0                	and    %esp,%eax
   12f10:	01 da                	add    %ebx,%edx
   12f12:	19 c9                	sbb    %ecx,%ecx
   12f14:	39 50 0c             	cmp    %edx,0xc(%eax)
   12f17:	83 d9 00             	sbb    $0x0,%ecx

static inline unsigned long
__constant_copy_from_user(void *to, const void *from, unsigned long n)
{
	if (access_ok(VERIFY_READ, from, n))
   12f1a:	85 c9                	test   %ecx,%ecx
   12f1c:	8b 7d 08             	mov    0x8(%ebp),%edi
   12f1f:	75 52                	jne    12f73 <__constant_copy_from_user+0x83>
		__constant_copy_user_zeroing(to,from,n);
   12f21:	89 d8                	mov    %ebx,%eax
   12f23:	83 e0 03             	and    $0x3,%eax
   12f26:	83 f8 02             	cmp    $0x2,%eax
   12f29:	74 3d                	je     12f68 <__constant_copy_from_user+0x78>
   12f2b:	83 f8 02             	cmp    $0x2,%eax
   12f2e:	77 27                	ja     12f57 <__constant_copy_from_user+0x67>
   12f30:	48                   	dec    %eax
   12f31:	74 1a                	je     12f4d <__constant_copy_from_user+0x5d>
   12f33:	89 d9                	mov    %ebx,%ecx
   12f35:	c1 e9 02             	shr    $0x2,%ecx
   12f38:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   12f3a:	89 cb                	mov    %ecx,%ebx
	else
		memset(to, 0, n);
	return n;
}
   12f3c:	89 d8                	mov    %ebx,%eax
   12f3e:	8b 74 24 04          	mov    0x4(%esp,1),%esi
   12f42:	8b 1c 24             	mov    (%esp,1),%ebx
   12f45:	8b 7c 24 08          	mov    0x8(%esp,1),%edi
   12f49:	89 ec                	mov    %ebp,%esp
   12f4b:	5d                   	pop    %ebp
   12f4c:	c3                   	ret    
   12f4d:	89 d9                	mov    %ebx,%ecx
   12f4f:	c1 e9 02             	shr    $0x2,%ecx
   12f52:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   12f54:	a4                   	movsb  %ds:(%esi),%es:(%edi)
   12f55:	eb e3                	jmp    12f3a <__constant_copy_from_user+0x4a>
   12f57:	83 f8 03             	cmp    $0x3,%eax
   12f5a:	75 d7                	jne    12f33 <__constant_copy_from_user+0x43>
   12f5c:	89 d9                	mov    %ebx,%ecx
   12f5e:	c1 e9 02             	shr    $0x2,%ecx
   12f61:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   12f63:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
   12f65:	a4                   	movsb  %ds:(%esi),%es:(%edi)
   12f66:	eb d2                	jmp    12f3a <__constant_copy_from_user+0x4a>
   12f68:	89 d9                	mov    %ebx,%ecx
   12f6a:	c1 e9 02             	shr    $0x2,%ecx
   12f6d:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   12f6f:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
   12f71:	eb c7                	jmp    12f3a <__constant_copy_from_user+0x4a>
 */
static inline void * __constant_c_memset(void * s, unsigned long c, size_t count)
{
int d0, d1;
__asm__ __volatile__(
   12f73:	89 d9                	mov    %ebx,%ecx
{
	if (access_ok(VERIFY_READ, from, n))
		__constant_copy_user_zeroing(to,from,n);
	else
		memset(to, 0, n);
   12f75:	31 c0                	xor    %eax,%eax
 */
static inline void * __constant_c_memset(void * s, unsigned long c, size_t count)
{
int d0, d1;
__asm__ __volatile__(
   12f77:	c1 e9 02             	shr    $0x2,%ecx
   12f7a:	f3 ab                	repz stos %eax,%es:(%edi)
   12f7c:	f6 c3 02             	test   $0x2,%bl
   12f7f:	74 02                	je     12f83 <__constant_copy_from_user+0x93>
   12f81:	66 ab                	stos   %ax,%es:(%edi)
   12f83:	f6 c3 01             	test   $0x1,%bl
   12f86:	74 01                	je     12f89 <__constant_copy_from_user+0x99>
   12f88:	aa                   	stos   %al,%es:(%edi)
   12f89:	eb b1                	jmp    12f3c <__constant_copy_from_user+0x4c>
   12f8b:	90                   	nop    
   12f8c:	8d 74 26 00          	lea    0x0(%esi,1),%esi

00012f90 <sock_orphan>:
 * probably wants some additional cleanups or even continuing
 * to work with this socket (TCP).
 */
static inline void sock_orphan(struct sock *sk)
{
   12f90:	55                   	push   %ebp
   12f91:	89 e5                	mov    %esp,%ebp
   12f93:	8b 45 08             	mov    0x8(%ebp),%eax
	write_lock_bh(&sk->callback_lock);
   12f96:	ff 05 08 00 00 00    	incl   0x8
	sk->dead = 1;
	sk->socket = NULL;
   12f9c:	31 d2                	xor    %edx,%edx
   12f9e:	89 90 a0 0c 00 00    	mov    %edx,0xca0(%eax)
	sk->sleep = NULL;
	write_unlock_bh(&sk->callback_lock);
   12fa4:	ba 08 00 00 00       	mov    $0x8,%edx
   12fa9:	c6 80 80 00 00 00 01 	movb   $0x1,0x80(%eax)
   12fb0:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
   12fb7:	a1 08 00 00 00       	mov    0x8,%eax
   12fbc:	48                   	dec    %eax
   12fbd:	85 c0                	test   %eax,%eax
   12fbf:	a3 08 00 00 00       	mov    %eax,0x8
   12fc4:	75 0a                	jne    12fd0 <sock_orphan+0x40>
   12fc6:	83 7a f8 00          	cmpl   $0x0,0xfffffff8(%edx)
   12fca:	0f 85 22 03 00 00    	jne    132f2 <.text.lock.tmalloc+0x320>
}
   12fd0:	5d                   	pop    %ebp
   12fd1:	c3                   	ret    

00012fd2 <.text.lock.tmalloc>:
   12fd2:	50                   	push   %eax
   12fd3:	51                   	push   %ecx
   12fd4:	52                   	push   %edx
   12fd5:	e8 fc ff ff ff       	call   12fd6 <.text.lock.tmalloc+0x4>
   12fda:	5a                   	pop    %edx
   12fdb:	59                   	pop    %ecx
   12fdc:	58                   	pop    %eax
   12fdd:	e9 b9 b4 ff ff       	jmp    e49b <tcp_prequeue_process+0x8b>
   12fe2:	50                   	push   %eax
   12fe3:	51                   	push   %ecx
   12fe4:	52                   	push   %edx
   12fe5:	e8 fc ff ff ff       	call   12fe6 <.text.lock.tmalloc+0x14>
   12fea:	5a                   	pop    %edx
   12feb:	59                   	pop    %ecx
   12fec:	58                   	pop    %eax
   12fed:	e9 00 c0 ff ff       	jmp    eff2 <trickles_close+0x42>
   12ff2:	50                   	push   %eax
   12ff3:	51                   	push   %ecx
   12ff4:	52                   	push   %edx
   12ff5:	e8 fc ff ff ff       	call   12ff6 <.text.lock.tmalloc+0x24>
   12ffa:	5a                   	pop    %edx
   12ffb:	59                   	pop    %ecx
   12ffc:	58                   	pop    %eax
   12ffd:	e9 cf c0 ff ff       	jmp    f0d1 <trickles_close+0x121>
   13002:	50                   	push   %eax
   13003:	51                   	push   %ecx
   13004:	52                   	push   %edx
   13005:	e8 fc ff ff ff       	call   13006 <.text.lock.tmalloc+0x34>
   1300a:	5a                   	pop    %edx
   1300b:	59                   	pop    %ecx
   1300c:	58                   	pop    %eax
   1300d:	e9 f6 c0 ff ff       	jmp    f108 <trickles_close+0x158>
   13012:	50                   	push   %eax
   13013:	51                   	push   %ecx
   13014:	52                   	push   %edx
   13015:	e8 fc ff ff ff       	call   13016 <.text.lock.tmalloc+0x44>
   1301a:	5a                   	pop    %edx
   1301b:	59                   	pop    %ecx
   1301c:	58                   	pop    %eax
   1301d:	e9 ee c1 ff ff       	jmp    f210 <trickles_init_sock_impl+0x60>
   13022:	50                   	push   %eax
   13023:	51                   	push   %ecx
   13024:	52                   	push   %edx
   13025:	e8 fc ff ff ff       	call   13026 <.text.lock.tmalloc+0x54>
   1302a:	5a                   	pop    %edx
   1302b:	59                   	pop    %ecx
   1302c:	58                   	pop    %eax
   1302d:	e9 49 c2 ff ff       	jmp    f27b <trickles_init_sock_impl+0xcb>
   13032:	50                   	push   %eax
   13033:	51                   	push   %ecx
   13034:	52                   	push   %edx
   13035:	e8 fc ff ff ff       	call   13036 <.text.lock.tmalloc+0x64>
   1303a:	5a                   	pop    %edx
   1303b:	59                   	pop    %ecx
   1303c:	58                   	pop    %eax
   1303d:	e9 57 c2 ff ff       	jmp    f299 <trickles_init_sock_impl+0xe9>
   13042:	50                   	push   %eax
   13043:	51                   	push   %ecx
   13044:	52                   	push   %edx
   13045:	e8 fc ff ff ff       	call   13046 <.text.lock.tmalloc+0x74>
   1304a:	5a                   	pop    %edx
   1304b:	59                   	pop    %ecx
   1304c:	58                   	pop    %eax
   1304d:	e9 42 c3 ff ff       	jmp    f394 <trickles_sendmsg+0xa4>
   13052:	50                   	push   %eax
   13053:	51                   	push   %ecx
   13054:	52                   	push   %edx
   13055:	e8 fc ff ff ff       	call   13056 <.text.lock.tmalloc+0x84>
   1305a:	5a                   	pop    %edx
   1305b:	59                   	pop    %ecx
   1305c:	58                   	pop    %eax
   1305d:	e9 83 c3 ff ff       	jmp    f3e5 <trickles_sendmsg+0xf5>
   13062:	50                   	push   %eax
   13063:	51                   	push   %ecx
   13064:	52                   	push   %edx
   13065:	e8 fc ff ff ff       	call   13066 <.text.lock.tmalloc+0x94>
   1306a:	5a                   	pop    %edx
   1306b:	59                   	pop    %ecx
   1306c:	58                   	pop    %eax
   1306d:	e9 e8 c3 ff ff       	jmp    f45a <trickles_sendmsg+0x16a>
   13072:	50                   	push   %eax
   13073:	51                   	push   %ecx
   13074:	52                   	push   %edx
   13075:	e8 fc ff ff ff       	call   13076 <.text.lock.tmalloc+0xa4>
   1307a:	5a                   	pop    %edx
   1307b:	59                   	pop    %ecx
   1307c:	58                   	pop    %eax
   1307d:	e9 09 c5 ff ff       	jmp    f58b <trickles_sendmsg+0x29b>
   13082:	50                   	push   %eax
   13083:	51                   	push   %ecx
   13084:	52                   	push   %edx
   13085:	e8 fc ff ff ff       	call   13086 <.text.lock.tmalloc+0xb4>
   1308a:	5a                   	pop    %edx
   1308b:	59                   	pop    %ecx
   1308c:	58                   	pop    %eax
   1308d:	e9 8a c5 ff ff       	jmp    f61c <trickles_sendmsg+0x32c>
   13092:	50                   	push   %eax
   13093:	51                   	push   %ecx
   13094:	52                   	push   %edx
   13095:	e8 fc ff ff ff       	call   13096 <.text.lock.tmalloc+0xc4>
   1309a:	5a                   	pop    %edx
   1309b:	59                   	pop    %ecx
   1309c:	58                   	pop    %eax
   1309d:	e9 2a c6 ff ff       	jmp    f6cc <trickles_sendmsg+0x3dc>
   130a2:	50                   	push   %eax
   130a3:	51                   	push   %ecx
   130a4:	52                   	push   %edx
   130a5:	e8 fc ff ff ff       	call   130a6 <.text.lock.tmalloc+0xd4>
   130aa:	5a                   	pop    %edx
   130ab:	59                   	pop    %ecx
   130ac:	58                   	pop    %eax
   130ad:	e9 df c6 ff ff       	jmp    f791 <trickles_poll+0x81>
   130b2:	50                   	push   %eax
   130b3:	51                   	push   %ecx
   130b4:	52                   	push   %edx
   130b5:	e8 fc ff ff ff       	call   130b6 <.text.lock.tmalloc+0xe4>
   130ba:	5a                   	pop    %edx
   130bb:	59                   	pop    %ecx
   130bc:	58                   	pop    %eax
   130bd:	e9 12 c7 ff ff       	jmp    f7d4 <trickles_poll+0xc4>
   130c2:	50                   	push   %eax
   130c3:	51                   	push   %ecx
   130c4:	52                   	push   %edx
   130c5:	e8 fc ff ff ff       	call   130c6 <.text.lock.tmalloc+0xf4>
   130ca:	5a                   	pop    %edx
   130cb:	59                   	pop    %ecx
   130cc:	58                   	pop    %eax
   130cd:	e9 52 c9 ff ff       	jmp    fa24 <cminisock_config_pipe_impl+0x94>
   130d2:	50                   	push   %eax
   130d3:	51                   	push   %ecx
   130d4:	52                   	push   %edx
   130d5:	e8 fc ff ff ff       	call   130d6 <.text.lock.tmalloc+0x104>
   130da:	5a                   	pop    %edx
   130db:	59                   	pop    %ecx
   130dc:	58                   	pop    %eax
   130dd:	e9 82 c9 ff ff       	jmp    fa64 <cminisock_config_pipe_impl+0xd4>
   130e2:	50                   	push   %eax
   130e3:	51                   	push   %ecx
   130e4:	52                   	push   %edx
   130e5:	e8 fc ff ff ff       	call   130e6 <.text.lock.tmalloc+0x114>
   130ea:	5a                   	pop    %edx
   130eb:	59                   	pop    %ecx
   130ec:	58                   	pop    %eax
   130ed:	e9 2e d1 ff ff       	jmp    10220 <trickles_sendv_impl+0xe0>
   130f2:	50                   	push   %eax
   130f3:	51                   	push   %ecx
   130f4:	52                   	push   %edx
   130f5:	e8 fc ff ff ff       	call   130f6 <.text.lock.tmalloc+0x124>
   130fa:	5a                   	pop    %edx
   130fb:	59                   	pop    %ecx
   130fc:	58                   	pop    %eax
   130fd:	e9 6c d2 ff ff       	jmp    1036e <trickles_sendv_impl+0x22e>
   13102:	50                   	push   %eax
   13103:	51                   	push   %ecx
   13104:	52                   	push   %edx
   13105:	e8 fc ff ff ff       	call   13106 <.text.lock.tmalloc+0x134>
   1310a:	5a                   	pop    %edx
   1310b:	59                   	pop    %ecx
   1310c:	58                   	pop    %eax
   1310d:	e9 0f d3 ff ff       	jmp    10421 <trickles_sendv_impl+0x2e1>
   13112:	50                   	push   %eax
   13113:	51                   	push   %ecx
   13114:	52                   	push   %edx
   13115:	e8 fc ff ff ff       	call   13116 <.text.lock.tmalloc+0x144>
   1311a:	5a                   	pop    %edx
   1311b:	59                   	pop    %ecx
   1311c:	58                   	pop    %eax
   1311d:	e9 7b d3 ff ff       	jmp    1049d <trickles_sendv_impl+0x35d>
   13122:	50                   	push   %eax
   13123:	51                   	push   %ecx
   13124:	52                   	push   %edx
   13125:	e8 fc ff ff ff       	call   13126 <.text.lock.tmalloc+0x154>
   1312a:	5a                   	pop    %edx
   1312b:	59                   	pop    %ecx
   1312c:	58                   	pop    %eax
   1312d:	e9 52 db ff ff       	jmp    10c84 <trickles_sendfilev_impl+0xd4>
   13132:	50                   	push   %eax
   13133:	51                   	push   %ecx
   13134:	52                   	push   %edx
   13135:	e8 fc ff ff ff       	call   13136 <.text.lock.tmalloc+0x164>
   1313a:	5a                   	pop    %edx
   1313b:	59                   	pop    %ecx
   1313c:	58                   	pop    %eax
   1313d:	e9 8c dc ff ff       	jmp    10dce <trickles_sendfilev_impl+0x21e>
   13142:	50                   	push   %eax
   13143:	51                   	push   %ecx
   13144:	52                   	push   %edx
   13145:	e8 fc ff ff ff       	call   13146 <.text.lock.tmalloc+0x174>
   1314a:	5a                   	pop    %edx
   1314b:	59                   	pop    %ecx
   1314c:	58                   	pop    %eax
   1314d:	e9 2f dd ff ff       	jmp    10e81 <trickles_sendfilev_impl+0x2d1>
   13152:	50                   	push   %eax
   13153:	51                   	push   %ecx
   13154:	52                   	push   %edx
   13155:	e8 fc ff ff ff       	call   13156 <.text.lock.tmalloc+0x184>
   1315a:	5a                   	pop    %edx
   1315b:	59                   	pop    %ecx
   1315c:	58                   	pop    %eax
   1315d:	e9 90 dd ff ff       	jmp    10ef2 <trickles_sendfilev_impl+0x342>
   13162:	50                   	push   %eax
   13163:	51                   	push   %ecx
   13164:	52                   	push   %edx
   13165:	e8 fc ff ff ff       	call   13166 <.text.lock.tmalloc+0x194>
   1316a:	5a                   	pop    %edx
   1316b:	59                   	pop    %ecx
   1316c:	58                   	pop    %eax
   1316d:	e9 42 de ff ff       	jmp    10fb4 <trickles_send_impl+0x74>
   13172:	50                   	push   %eax
   13173:	51                   	push   %ecx
   13174:	52                   	push   %edx
   13175:	e8 fc ff ff ff       	call   13176 <.text.lock.tmalloc+0x1a4>
   1317a:	5a                   	pop    %edx
   1317b:	59                   	pop    %ecx
   1317c:	58                   	pop    %eax
   1317d:	e9 4c df ff ff       	jmp    110ce <trickles_send_impl+0x18e>
   13182:	50                   	push   %eax
   13183:	51                   	push   %ecx
   13184:	52                   	push   %edx
   13185:	e8 fc ff ff ff       	call   13186 <.text.lock.tmalloc+0x1b4>
   1318a:	5a                   	pop    %edx
   1318b:	59                   	pop    %ecx
   1318c:	58                   	pop    %eax
   1318d:	e9 f8 df ff ff       	jmp    1118a <trickles_send_impl+0x24a>
   13192:	50                   	push   %eax
   13193:	51                   	push   %ecx
   13194:	52                   	push   %edx
   13195:	e8 fc ff ff ff       	call   13196 <.text.lock.tmalloc+0x1c4>
   1319a:	5a                   	pop    %edx
   1319b:	59                   	pop    %ecx
   1319c:	58                   	pop    %eax
   1319d:	e9 a7 e0 ff ff       	jmp    11249 <trickles_send_impl+0x309>
   131a2:	50                   	push   %eax
   131a3:	51                   	push   %ecx
   131a4:	52                   	push   %edx
   131a5:	e8 fc ff ff ff       	call   131a6 <.text.lock.tmalloc+0x1d4>
   131aa:	5a                   	pop    %edx
   131ab:	59                   	pop    %ecx
   131ac:	58                   	pop    %eax
   131ad:	e9 9c e1 ff ff       	jmp    1134e <trickles_setucont_impl+0x6e>
   131b2:	50                   	push   %eax
   131b3:	51                   	push   %ecx
   131b4:	52                   	push   %edx
   131b5:	e8 fc ff ff ff       	call   131b6 <.text.lock.tmalloc+0x1e4>
   131ba:	5a                   	pop    %edx
   131bb:	59                   	pop    %ecx
   131bc:	58                   	pop    %eax
   131bd:	e9 dc e2 ff ff       	jmp    1149e <trickles_setucont_impl+0x1be>
   131c2:	50                   	push   %eax
   131c3:	51                   	push   %ecx
   131c4:	52                   	push   %edx
   131c5:	e8 fc ff ff ff       	call   131c6 <.text.lock.tmalloc+0x1f4>
   131ca:	5a                   	pop    %edx
   131cb:	59                   	pop    %ecx
   131cc:	58                   	pop    %eax
   131cd:	e9 66 e3 ff ff       	jmp    11538 <trickles_setucont_impl+0x258>
   131d2:	50                   	push   %eax
   131d3:	51                   	push   %ecx
   131d4:	52                   	push   %edx
   131d5:	e8 fc ff ff ff       	call   131d6 <.text.lock.tmalloc+0x204>
   131da:	5a                   	pop    %edx
   131db:	59                   	pop    %ecx
   131dc:	58                   	pop    %eax
   131dd:	e9 05 e4 ff ff       	jmp    115e7 <trickles_setucont_impl+0x307>
   131e2:	50                   	push   %eax
   131e3:	51                   	push   %ecx
   131e4:	52                   	push   %edx
   131e5:	e8 fc ff ff ff       	call   131e6 <.text.lock.tmalloc+0x214>
   131ea:	5a                   	pop    %edx
   131eb:	59                   	pop    %ecx
   131ec:	58                   	pop    %eax
   131ed:	e9 d6 e4 ff ff       	jmp    116c8 <trickles_setucont_impl+0x3e8>
   131f2:	50                   	push   %eax
   131f3:	51                   	push   %ecx
   131f4:	52                   	push   %edx
   131f5:	e8 fc ff ff ff       	call   131f6 <.text.lock.tmalloc+0x224>
   131fa:	5a                   	pop    %edx
   131fb:	59                   	pop    %ecx
   131fc:	58                   	pop    %eax
   131fd:	e9 3a e5 ff ff       	jmp    1173c <trickles_setucont_impl+0x45c>
   13202:	50                   	push   %eax
   13203:	51                   	push   %ecx
   13204:	52                   	push   %edx
   13205:	e8 fc ff ff ff       	call   13206 <.text.lock.tmalloc+0x234>
   1320a:	5a                   	pop    %edx
   1320b:	59                   	pop    %ecx
   1320c:	58                   	pop    %eax
   1320d:	e9 b7 e5 ff ff       	jmp    117c9 <trickles_setucont_impl+0x4e9>
   13212:	50                   	push   %eax
   13213:	51                   	push   %ecx
   13214:	52                   	push   %edx
   13215:	e8 fc ff ff ff       	call   13216 <.text.lock.tmalloc+0x244>
   1321a:	5a                   	pop    %edx
   1321b:	59                   	pop    %ecx
   1321c:	58                   	pop    %eax
   1321d:	e9 42 e7 ff ff       	jmp    11964 <wait_for_write_memory+0x144>
   13222:	50                   	push   %eax
   13223:	51                   	push   %ecx
   13224:	52                   	push   %edx
   13225:	e8 fc ff ff ff       	call   13226 <.text.lock.tmalloc+0x254>
   1322a:	5a                   	pop    %edx
   1322b:	59                   	pop    %ecx
   1322c:	58                   	pop    %eax
   1322d:	e9 7d e7 ff ff       	jmp    119af <wait_for_write_memory+0x18f>
   13232:	50                   	push   %eax
   13233:	51                   	push   %ecx
   13234:	52                   	push   %edx
   13235:	e8 fc ff ff ff       	call   13236 <.text.lock.tmalloc+0x264>
   1323a:	5a                   	pop    %edx
   1323b:	59                   	pop    %ecx
   1323c:	58                   	pop    %eax
   1323d:	e9 e2 e8 ff ff       	jmp    11b24 <trickles_client_sendmsg+0xa4>
   13242:	50                   	push   %eax
   13243:	51                   	push   %ecx
   13244:	52                   	push   %edx
   13245:	e8 fc ff ff ff       	call   13246 <.text.lock.tmalloc+0x274>
   1324a:	5a                   	pop    %edx
   1324b:	59                   	pop    %ecx
   1324c:	58                   	pop    %eax
   1324d:	e9 f9 ea ff ff       	jmp    11d4b <trickles_client_sendmsg+0x2cb>
   13252:	50                   	push   %eax
   13253:	51                   	push   %ecx
   13254:	52                   	push   %edx
   13255:	e8 fc ff ff ff       	call   13256 <.text.lock.tmalloc+0x284>
   1325a:	5a                   	pop    %edx
   1325b:	59                   	pop    %ecx
   1325c:	58                   	pop    %eax
   1325d:	e9 d9 eb ff ff       	jmp    11e3b <trickles_client_sendmsg+0x3bb>
   13262:	50                   	push   %eax
   13263:	51                   	push   %ecx
   13264:	52                   	push   %edx
   13265:	e8 fc ff ff ff       	call   13266 <.text.lock.tmalloc+0x294>
   1326a:	5a                   	pop    %edx
   1326b:	59                   	pop    %ecx
   1326c:	58                   	pop    %eax
   1326d:	e9 40 ed ff ff       	jmp    11fb2 <tcp_data_wait+0xb2>
   13272:	50                   	push   %eax
   13273:	51                   	push   %ecx
   13274:	52                   	push   %edx
   13275:	e8 fc ff ff ff       	call   13276 <.text.lock.tmalloc+0x2a4>
   1327a:	5a                   	pop    %edx
   1327b:	59                   	pop    %ecx
   1327c:	58                   	pop    %eax
   1327d:	e9 6a ed ff ff       	jmp    11fec <tcp_data_wait+0xec>
   13282:	50                   	push   %eax
   13283:	51                   	push   %ecx
   13284:	52                   	push   %edx
   13285:	e8 fc ff ff ff       	call   13286 <.text.lock.tmalloc+0x2b4>
   1328a:	5a                   	pop    %edx
   1328b:	59                   	pop    %ecx
   1328c:	58                   	pop    %eax
   1328d:	e9 31 ee ff ff       	jmp    120c3 <trickles_client_recvmsg+0x63>
   13292:	50                   	push   %eax
   13293:	51                   	push   %ecx
   13294:	52                   	push   %edx
   13295:	e8 fc ff ff ff       	call   13296 <.text.lock.tmalloc+0x2c4>
   1329a:	5a                   	pop    %edx
   1329b:	59                   	pop    %ecx
   1329c:	58                   	pop    %eax
   1329d:	e9 7d ee ff ff       	jmp    1211f <trickles_client_recvmsg+0xbf>
   132a2:	50                   	push   %eax
   132a3:	51                   	push   %ecx
   132a4:	52                   	push   %edx
   132a5:	e8 fc ff ff ff       	call   132a6 <.text.lock.tmalloc+0x2d4>
   132aa:	5a                   	pop    %edx
   132ab:	59                   	pop    %ecx
   132ac:	58                   	pop    %eax
   132ad:	e9 06 ef ff ff       	jmp    121b8 <trickles_client_recvmsg+0x158>
   132b2:	50                   	push   %eax
   132b3:	51                   	push   %ecx
   132b4:	52                   	push   %edx
   132b5:	e8 fc ff ff ff       	call   132b6 <.text.lock.tmalloc+0x2e4>
   132ba:	5a                   	pop    %edx
   132bb:	59                   	pop    %ecx
   132bc:	58                   	pop    %eax
   132bd:	e9 a6 f1 ff ff       	jmp    12468 <trickles_sendbulk_impl+0xc8>
   132c2:	50                   	push   %eax
   132c3:	51                   	push   %ecx
   132c4:	52                   	push   %edx
   132c5:	e8 fc ff ff ff       	call   132c6 <.text.lock.tmalloc+0x2f4>
   132ca:	5a                   	pop    %edx
   132cb:	59                   	pop    %ecx
   132cc:	58                   	pop    %eax
   132cd:	e9 b2 f2 ff ff       	jmp    12584 <trickles_sendbulk_impl+0x1e4>
   132d2:	50                   	push   %eax
   132d3:	51                   	push   %ecx
   132d4:	52                   	push   %edx
   132d5:	e8 fc ff ff ff       	call   132d6 <.text.lock.tmalloc+0x304>
   132da:	5a                   	pop    %edx
   132db:	59                   	pop    %ecx
   132dc:	58                   	pop    %eax
   132dd:	e9 06 f7 ff ff       	jmp    129e8 <trickles_read_proc+0x338>
   132e2:	50                   	push   %eax
   132e3:	51                   	push   %ecx
   132e4:	52                   	push   %edx
   132e5:	e8 fc ff ff ff       	call   132e6 <.text.lock.tmalloc+0x314>
   132ea:	5a                   	pop    %edx
   132eb:	59                   	pop    %ecx
   132ec:	58                   	pop    %eax
   132ed:	e9 72 f9 ff ff       	jmp    12c64 <trickles_cwnd_read_proc+0x124>
   132f2:	50                   	push   %eax
   132f3:	51                   	push   %ecx
   132f4:	52                   	push   %edx
   132f5:	e8 fc ff ff ff       	call   132f6 <.text.lock.tmalloc+0x324>
   132fa:	5a                   	pop    %edx
   132fb:	59                   	pop    %ecx
   132fc:	58                   	pop    %eax
   132fd:	e9 ce fc ff ff       	jmp    12fd0 <sock_orphan+0x40>
   13302:	90                   	nop    
   13303:	90                   	nop    
   13304:	90                   	nop    
   13305:	90                   	nop    
   13306:	90                   	nop    
   13307:	90                   	nop    
   13308:	90                   	nop    
   13309:	90                   	nop    
   1330a:	90                   	nop    
   1330b:	90                   	nop    
   1330c:	90                   	nop    
   1330d:	90                   	nop    
   1330e:	90                   	nop    
   1330f:	90                   	nop    

00013310 <aes_encrypt>:
   13310:	83 ec 18             	sub    $0x18,%esp
   13313:	89 6c 24 14          	mov    %ebp,0x14(%esp,1)
   13317:	89 5c 24 10          	mov    %ebx,0x10(%esp,1)
   1331b:	89 74 24 0c          	mov    %esi,0xc(%esp,1)
   1331f:	89 7c 24 08          	mov    %edi,0x8(%esp,1)
   13323:	8b 4c 24 1c          	mov    0x1c(%esp,1),%ecx
   13327:	8b 6c 24 24          	mov    0x24(%esp,1),%ebp
   1332b:	8b 01                	mov    (%ecx),%eax
   1332d:	8b 59 04             	mov    0x4(%ecx),%ebx
   13330:	33 45 00             	xor    0x0(%ebp),%eax
   13333:	33 5d 04             	xor    0x4(%ebp),%ebx
   13336:	8b 71 08             	mov    0x8(%ecx),%esi
   13339:	8b 79 0c             	mov    0xc(%ecx),%edi
   1333c:	33 75 08             	xor    0x8(%ebp),%esi
   1333f:	33 7d 0c             	xor    0xc(%ebp),%edi
   13342:	8b 8d f0 00 00 00    	mov    0xf0(%ebp),%ecx
   13348:	83 f9 0a             	cmp    $0xa,%ecx
   1334b:	0f 84 46 03 00 00    	je     13697 <aes_encrypt.3>
   13351:	8d 6d 20             	lea    0x20(%ebp),%ebp
   13354:	83 f9 0c             	cmp    $0xc,%ecx
   13357:	0f 84 a6 01 00 00    	je     13503 <aes_encrypt.2>
   1335d:	8d 6d 20             	lea    0x20(%ebp),%ebp
   13360:	83 f9 0e             	cmp    $0xe,%ecx
   13363:	74 0a                	je     1336f <aes_encrypt.1>
   13365:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1336a:	e9 42 0b 00 00       	jmp    13eb1 <aes_encrypt.4>

0001336f <aes_encrypt.1>:
   1336f:	89 c1                	mov    %eax,%ecx
   13371:	89 34 24             	mov    %esi,(%esp,1)
   13374:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   13378:	0f b6 d1             	movzbl %cl,%edx
   1337b:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   1337e:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   13385:	0f b6 d5             	movzbl %ch,%edx
   13388:	c1 e9 10             	shr    $0x10,%ecx
   1338b:	8b 7d dc             	mov    0xffffffdc(%ebp),%edi
   1338e:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   13395:	0f b6 d1             	movzbl %cl,%edx
   13398:	8b 75 d8             	mov    0xffffffd8(%ebp),%esi
   1339b:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   133a2:	0f b6 d5             	movzbl %ch,%edx
   133a5:	89 d9                	mov    %ebx,%ecx
   133a7:	8b 5d d4             	mov    0xffffffd4(%ebp),%ebx
   133aa:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   133b1:	0f b6 d1             	movzbl %cl,%edx
   133b4:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   133bb:	0f b6 d5             	movzbl %ch,%edx
   133be:	c1 e9 10             	shr    $0x10,%ecx
   133c1:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   133c8:	0f b6 d1             	movzbl %cl,%edx
   133cb:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   133d2:	0f b6 d5             	movzbl %ch,%edx
   133d5:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   133dc:	8b 0c 24             	mov    (%esp,1),%ecx
   133df:	0f b6 d1             	movzbl %cl,%edx
   133e2:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   133e9:	0f b6 d5             	movzbl %ch,%edx
   133ec:	c1 e9 10             	shr    $0x10,%ecx
   133ef:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   133f6:	0f b6 d1             	movzbl %cl,%edx
   133f9:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   13400:	0f b6 d5             	movzbl %ch,%edx
   13403:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1340a:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1340e:	0f b6 d1             	movzbl %cl,%edx
   13411:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   13418:	0f b6 d5             	movzbl %ch,%edx
   1341b:	c1 e9 10             	shr    $0x10,%ecx
   1341e:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   13425:	0f b6 d1             	movzbl %cl,%edx
   13428:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1342f:	0f b6 d5             	movzbl %ch,%edx
   13432:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   13439:	89 c1                	mov    %eax,%ecx
   1343b:	89 34 24             	mov    %esi,(%esp,1)
   1343e:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   13442:	0f b6 d1             	movzbl %cl,%edx
   13445:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   13448:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1344f:	0f b6 d5             	movzbl %ch,%edx
   13452:	c1 e9 10             	shr    $0x10,%ecx
   13455:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
   13458:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1345f:	0f b6 d1             	movzbl %cl,%edx
   13462:	8b 75 e8             	mov    0xffffffe8(%ebp),%esi
   13465:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1346c:	0f b6 d5             	movzbl %ch,%edx
   1346f:	89 d9                	mov    %ebx,%ecx
   13471:	8b 5d e4             	mov    0xffffffe4(%ebp),%ebx
   13474:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1347b:	0f b6 d1             	movzbl %cl,%edx
   1347e:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   13485:	0f b6 d5             	movzbl %ch,%edx
   13488:	c1 e9 10             	shr    $0x10,%ecx
   1348b:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   13492:	0f b6 d1             	movzbl %cl,%edx
   13495:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1349c:	0f b6 d5             	movzbl %ch,%edx
   1349f:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   134a6:	8b 0c 24             	mov    (%esp,1),%ecx
   134a9:	0f b6 d1             	movzbl %cl,%edx
   134ac:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   134b3:	0f b6 d5             	movzbl %ch,%edx
   134b6:	c1 e9 10             	shr    $0x10,%ecx
   134b9:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   134c0:	0f b6 d1             	movzbl %cl,%edx
   134c3:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   134ca:	0f b6 d5             	movzbl %ch,%edx
   134cd:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   134d4:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   134d8:	0f b6 d1             	movzbl %cl,%edx
   134db:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   134e2:	0f b6 d5             	movzbl %ch,%edx
   134e5:	c1 e9 10             	shr    $0x10,%ecx
   134e8:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   134ef:	0f b6 d1             	movzbl %cl,%edx
   134f2:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   134f9:	0f b6 d5             	movzbl %ch,%edx
   134fc:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax

00013503 <aes_encrypt.2>:
   13503:	89 c1                	mov    %eax,%ecx
   13505:	89 34 24             	mov    %esi,(%esp,1)
   13508:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1350c:	0f b6 d1             	movzbl %cl,%edx
   1350f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   13512:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   13519:	0f b6 d5             	movzbl %ch,%edx
   1351c:	c1 e9 10             	shr    $0x10,%ecx
   1351f:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
   13522:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   13529:	0f b6 d1             	movzbl %cl,%edx
   1352c:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
   1352f:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   13536:	0f b6 d5             	movzbl %ch,%edx
   13539:	89 d9                	mov    %ebx,%ecx
   1353b:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
   1353e:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   13545:	0f b6 d1             	movzbl %cl,%edx
   13548:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1354f:	0f b6 d5             	movzbl %ch,%edx
   13552:	c1 e9 10             	shr    $0x10,%ecx
   13555:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1355c:	0f b6 d1             	movzbl %cl,%edx
   1355f:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   13566:	0f b6 d5             	movzbl %ch,%edx
   13569:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   13570:	8b 0c 24             	mov    (%esp,1),%ecx
   13573:	0f b6 d1             	movzbl %cl,%edx
   13576:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1357d:	0f b6 d5             	movzbl %ch,%edx
   13580:	c1 e9 10             	shr    $0x10,%ecx
   13583:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1358a:	0f b6 d1             	movzbl %cl,%edx
   1358d:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   13594:	0f b6 d5             	movzbl %ch,%edx
   13597:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1359e:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   135a2:	0f b6 d1             	movzbl %cl,%edx
   135a5:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   135ac:	0f b6 d5             	movzbl %ch,%edx
   135af:	c1 e9 10             	shr    $0x10,%ecx
   135b2:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   135b9:	0f b6 d1             	movzbl %cl,%edx
   135bc:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   135c3:	0f b6 d5             	movzbl %ch,%edx
   135c6:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   135cd:	89 c1                	mov    %eax,%ecx
   135cf:	89 34 24             	mov    %esi,(%esp,1)
   135d2:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   135d6:	0f b6 d1             	movzbl %cl,%edx
   135d9:	8b 45 00             	mov    0x0(%ebp),%eax
   135dc:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   135e3:	0f b6 d5             	movzbl %ch,%edx
   135e6:	c1 e9 10             	shr    $0x10,%ecx
   135e9:	8b 7d 0c             	mov    0xc(%ebp),%edi
   135ec:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   135f3:	0f b6 d1             	movzbl %cl,%edx
   135f6:	8b 75 08             	mov    0x8(%ebp),%esi
   135f9:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   13600:	0f b6 d5             	movzbl %ch,%edx
   13603:	89 d9                	mov    %ebx,%ecx
   13605:	8b 5d 04             	mov    0x4(%ebp),%ebx
   13608:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1360f:	0f b6 d1             	movzbl %cl,%edx
   13612:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   13619:	0f b6 d5             	movzbl %ch,%edx
   1361c:	c1 e9 10             	shr    $0x10,%ecx
   1361f:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   13626:	0f b6 d1             	movzbl %cl,%edx
   13629:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   13630:	0f b6 d5             	movzbl %ch,%edx
   13633:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1363a:	8b 0c 24             	mov    (%esp,1),%ecx
   1363d:	0f b6 d1             	movzbl %cl,%edx
   13640:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   13647:	0f b6 d5             	movzbl %ch,%edx
   1364a:	c1 e9 10             	shr    $0x10,%ecx
   1364d:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   13654:	0f b6 d1             	movzbl %cl,%edx
   13657:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1365e:	0f b6 d5             	movzbl %ch,%edx
   13661:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   13668:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1366c:	0f b6 d1             	movzbl %cl,%edx
   1366f:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   13676:	0f b6 d5             	movzbl %ch,%edx
   13679:	c1 e9 10             	shr    $0x10,%ecx
   1367c:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   13683:	0f b6 d1             	movzbl %cl,%edx
   13686:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1368d:	0f b6 d5             	movzbl %ch,%edx
   13690:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax

00013697 <aes_encrypt.3>:
   13697:	89 c1                	mov    %eax,%ecx
   13699:	89 34 24             	mov    %esi,(%esp,1)
   1369c:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   136a0:	0f b6 d1             	movzbl %cl,%edx
   136a3:	8b 45 10             	mov    0x10(%ebp),%eax
   136a6:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   136ad:	0f b6 d5             	movzbl %ch,%edx
   136b0:	c1 e9 10             	shr    $0x10,%ecx
   136b3:	8b 7d 1c             	mov    0x1c(%ebp),%edi
   136b6:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   136bd:	0f b6 d1             	movzbl %cl,%edx
   136c0:	8b 75 18             	mov    0x18(%ebp),%esi
   136c3:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   136ca:	0f b6 d5             	movzbl %ch,%edx
   136cd:	89 d9                	mov    %ebx,%ecx
   136cf:	8b 5d 14             	mov    0x14(%ebp),%ebx
   136d2:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   136d9:	0f b6 d1             	movzbl %cl,%edx
   136dc:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   136e3:	0f b6 d5             	movzbl %ch,%edx
   136e6:	c1 e9 10             	shr    $0x10,%ecx
   136e9:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   136f0:	0f b6 d1             	movzbl %cl,%edx
   136f3:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   136fa:	0f b6 d5             	movzbl %ch,%edx
   136fd:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   13704:	8b 0c 24             	mov    (%esp,1),%ecx
   13707:	0f b6 d1             	movzbl %cl,%edx
   1370a:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   13711:	0f b6 d5             	movzbl %ch,%edx
   13714:	c1 e9 10             	shr    $0x10,%ecx
   13717:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1371e:	0f b6 d1             	movzbl %cl,%edx
   13721:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   13728:	0f b6 d5             	movzbl %ch,%edx
   1372b:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   13732:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   13736:	0f b6 d1             	movzbl %cl,%edx
   13739:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   13740:	0f b6 d5             	movzbl %ch,%edx
   13743:	c1 e9 10             	shr    $0x10,%ecx
   13746:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1374d:	0f b6 d1             	movzbl %cl,%edx
   13750:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   13757:	0f b6 d5             	movzbl %ch,%edx
   1375a:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   13761:	89 c1                	mov    %eax,%ecx
   13763:	89 34 24             	mov    %esi,(%esp,1)
   13766:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1376a:	0f b6 d1             	movzbl %cl,%edx
   1376d:	8b 45 20             	mov    0x20(%ebp),%eax
   13770:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   13777:	0f b6 d5             	movzbl %ch,%edx
   1377a:	c1 e9 10             	shr    $0x10,%ecx
   1377d:	8b 7d 2c             	mov    0x2c(%ebp),%edi
   13780:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   13787:	0f b6 d1             	movzbl %cl,%edx
   1378a:	8b 75 28             	mov    0x28(%ebp),%esi
   1378d:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   13794:	0f b6 d5             	movzbl %ch,%edx
   13797:	89 d9                	mov    %ebx,%ecx
   13799:	8b 5d 24             	mov    0x24(%ebp),%ebx
   1379c:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   137a3:	0f b6 d1             	movzbl %cl,%edx
   137a6:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   137ad:	0f b6 d5             	movzbl %ch,%edx
   137b0:	c1 e9 10             	shr    $0x10,%ecx
   137b3:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   137ba:	0f b6 d1             	movzbl %cl,%edx
   137bd:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   137c4:	0f b6 d5             	movzbl %ch,%edx
   137c7:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   137ce:	8b 0c 24             	mov    (%esp,1),%ecx
   137d1:	0f b6 d1             	movzbl %cl,%edx
   137d4:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   137db:	0f b6 d5             	movzbl %ch,%edx
   137de:	c1 e9 10             	shr    $0x10,%ecx
   137e1:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   137e8:	0f b6 d1             	movzbl %cl,%edx
   137eb:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   137f2:	0f b6 d5             	movzbl %ch,%edx
   137f5:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   137fc:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   13800:	0f b6 d1             	movzbl %cl,%edx
   13803:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1380a:	0f b6 d5             	movzbl %ch,%edx
   1380d:	c1 e9 10             	shr    $0x10,%ecx
   13810:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   13817:	0f b6 d1             	movzbl %cl,%edx
   1381a:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   13821:	0f b6 d5             	movzbl %ch,%edx
   13824:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1382b:	89 c1                	mov    %eax,%ecx
   1382d:	89 34 24             	mov    %esi,(%esp,1)
   13830:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   13834:	0f b6 d1             	movzbl %cl,%edx
   13837:	8b 45 30             	mov    0x30(%ebp),%eax
   1383a:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   13841:	0f b6 d5             	movzbl %ch,%edx
   13844:	c1 e9 10             	shr    $0x10,%ecx
   13847:	8b 7d 3c             	mov    0x3c(%ebp),%edi
   1384a:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   13851:	0f b6 d1             	movzbl %cl,%edx
   13854:	8b 75 38             	mov    0x38(%ebp),%esi
   13857:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1385e:	0f b6 d5             	movzbl %ch,%edx
   13861:	89 d9                	mov    %ebx,%ecx
   13863:	8b 5d 34             	mov    0x34(%ebp),%ebx
   13866:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1386d:	0f b6 d1             	movzbl %cl,%edx
   13870:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   13877:	0f b6 d5             	movzbl %ch,%edx
   1387a:	c1 e9 10             	shr    $0x10,%ecx
   1387d:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   13884:	0f b6 d1             	movzbl %cl,%edx
   13887:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1388e:	0f b6 d5             	movzbl %ch,%edx
   13891:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   13898:	8b 0c 24             	mov    (%esp,1),%ecx
   1389b:	0f b6 d1             	movzbl %cl,%edx
   1389e:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   138a5:	0f b6 d5             	movzbl %ch,%edx
   138a8:	c1 e9 10             	shr    $0x10,%ecx
   138ab:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   138b2:	0f b6 d1             	movzbl %cl,%edx
   138b5:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   138bc:	0f b6 d5             	movzbl %ch,%edx
   138bf:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   138c6:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   138ca:	0f b6 d1             	movzbl %cl,%edx
   138cd:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   138d4:	0f b6 d5             	movzbl %ch,%edx
   138d7:	c1 e9 10             	shr    $0x10,%ecx
   138da:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   138e1:	0f b6 d1             	movzbl %cl,%edx
   138e4:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   138eb:	0f b6 d5             	movzbl %ch,%edx
   138ee:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   138f5:	89 c1                	mov    %eax,%ecx
   138f7:	89 34 24             	mov    %esi,(%esp,1)
   138fa:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   138fe:	0f b6 d1             	movzbl %cl,%edx
   13901:	8b 45 40             	mov    0x40(%ebp),%eax
   13904:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1390b:	0f b6 d5             	movzbl %ch,%edx
   1390e:	c1 e9 10             	shr    $0x10,%ecx
   13911:	8b 7d 4c             	mov    0x4c(%ebp),%edi
   13914:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1391b:	0f b6 d1             	movzbl %cl,%edx
   1391e:	8b 75 48             	mov    0x48(%ebp),%esi
   13921:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   13928:	0f b6 d5             	movzbl %ch,%edx
   1392b:	89 d9                	mov    %ebx,%ecx
   1392d:	8b 5d 44             	mov    0x44(%ebp),%ebx
   13930:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   13937:	0f b6 d1             	movzbl %cl,%edx
   1393a:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   13941:	0f b6 d5             	movzbl %ch,%edx
   13944:	c1 e9 10             	shr    $0x10,%ecx
   13947:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1394e:	0f b6 d1             	movzbl %cl,%edx
   13951:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   13958:	0f b6 d5             	movzbl %ch,%edx
   1395b:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   13962:	8b 0c 24             	mov    (%esp,1),%ecx
   13965:	0f b6 d1             	movzbl %cl,%edx
   13968:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1396f:	0f b6 d5             	movzbl %ch,%edx
   13972:	c1 e9 10             	shr    $0x10,%ecx
   13975:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1397c:	0f b6 d1             	movzbl %cl,%edx
   1397f:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   13986:	0f b6 d5             	movzbl %ch,%edx
   13989:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   13990:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   13994:	0f b6 d1             	movzbl %cl,%edx
   13997:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1399e:	0f b6 d5             	movzbl %ch,%edx
   139a1:	c1 e9 10             	shr    $0x10,%ecx
   139a4:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   139ab:	0f b6 d1             	movzbl %cl,%edx
   139ae:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   139b5:	0f b6 d5             	movzbl %ch,%edx
   139b8:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   139bf:	89 c1                	mov    %eax,%ecx
   139c1:	89 34 24             	mov    %esi,(%esp,1)
   139c4:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   139c8:	0f b6 d1             	movzbl %cl,%edx
   139cb:	8b 45 50             	mov    0x50(%ebp),%eax
   139ce:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   139d5:	0f b6 d5             	movzbl %ch,%edx
   139d8:	c1 e9 10             	shr    $0x10,%ecx
   139db:	8b 7d 5c             	mov    0x5c(%ebp),%edi
   139de:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   139e5:	0f b6 d1             	movzbl %cl,%edx
   139e8:	8b 75 58             	mov    0x58(%ebp),%esi
   139eb:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   139f2:	0f b6 d5             	movzbl %ch,%edx
   139f5:	89 d9                	mov    %ebx,%ecx
   139f7:	8b 5d 54             	mov    0x54(%ebp),%ebx
   139fa:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   13a01:	0f b6 d1             	movzbl %cl,%edx
   13a04:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   13a0b:	0f b6 d5             	movzbl %ch,%edx
   13a0e:	c1 e9 10             	shr    $0x10,%ecx
   13a11:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   13a18:	0f b6 d1             	movzbl %cl,%edx
   13a1b:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   13a22:	0f b6 d5             	movzbl %ch,%edx
   13a25:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   13a2c:	8b 0c 24             	mov    (%esp,1),%ecx
   13a2f:	0f b6 d1             	movzbl %cl,%edx
   13a32:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   13a39:	0f b6 d5             	movzbl %ch,%edx
   13a3c:	c1 e9 10             	shr    $0x10,%ecx
   13a3f:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   13a46:	0f b6 d1             	movzbl %cl,%edx
   13a49:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   13a50:	0f b6 d5             	movzbl %ch,%edx
   13a53:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   13a5a:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   13a5e:	0f b6 d1             	movzbl %cl,%edx
   13a61:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   13a68:	0f b6 d5             	movzbl %ch,%edx
   13a6b:	c1 e9 10             	shr    $0x10,%ecx
   13a6e:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   13a75:	0f b6 d1             	movzbl %cl,%edx
   13a78:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   13a7f:	0f b6 d5             	movzbl %ch,%edx
   13a82:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   13a89:	89 c1                	mov    %eax,%ecx
   13a8b:	89 34 24             	mov    %esi,(%esp,1)
   13a8e:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   13a92:	0f b6 d1             	movzbl %cl,%edx
   13a95:	8b 45 60             	mov    0x60(%ebp),%eax
   13a98:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   13a9f:	0f b6 d5             	movzbl %ch,%edx
   13aa2:	c1 e9 10             	shr    $0x10,%ecx
   13aa5:	8b 7d 6c             	mov    0x6c(%ebp),%edi
   13aa8:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   13aaf:	0f b6 d1             	movzbl %cl,%edx
   13ab2:	8b 75 68             	mov    0x68(%ebp),%esi
   13ab5:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   13abc:	0f b6 d5             	movzbl %ch,%edx
   13abf:	89 d9                	mov    %ebx,%ecx
   13ac1:	8b 5d 64             	mov    0x64(%ebp),%ebx
   13ac4:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   13acb:	0f b6 d1             	movzbl %cl,%edx
   13ace:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   13ad5:	0f b6 d5             	movzbl %ch,%edx
   13ad8:	c1 e9 10             	shr    $0x10,%ecx
   13adb:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   13ae2:	0f b6 d1             	movzbl %cl,%edx
   13ae5:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   13aec:	0f b6 d5             	movzbl %ch,%edx
   13aef:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   13af6:	8b 0c 24             	mov    (%esp,1),%ecx
   13af9:	0f b6 d1             	movzbl %cl,%edx
   13afc:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   13b03:	0f b6 d5             	movzbl %ch,%edx
   13b06:	c1 e9 10             	shr    $0x10,%ecx
   13b09:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   13b10:	0f b6 d1             	movzbl %cl,%edx
   13b13:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   13b1a:	0f b6 d5             	movzbl %ch,%edx
   13b1d:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   13b24:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   13b28:	0f b6 d1             	movzbl %cl,%edx
   13b2b:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   13b32:	0f b6 d5             	movzbl %ch,%edx
   13b35:	c1 e9 10             	shr    $0x10,%ecx
   13b38:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   13b3f:	0f b6 d1             	movzbl %cl,%edx
   13b42:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   13b49:	0f b6 d5             	movzbl %ch,%edx
   13b4c:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   13b53:	89 c1                	mov    %eax,%ecx
   13b55:	89 34 24             	mov    %esi,(%esp,1)
   13b58:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   13b5c:	0f b6 d1             	movzbl %cl,%edx
   13b5f:	8b 45 70             	mov    0x70(%ebp),%eax
   13b62:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   13b69:	0f b6 d5             	movzbl %ch,%edx
   13b6c:	c1 e9 10             	shr    $0x10,%ecx
   13b6f:	8b 7d 7c             	mov    0x7c(%ebp),%edi
   13b72:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   13b79:	0f b6 d1             	movzbl %cl,%edx
   13b7c:	8b 75 78             	mov    0x78(%ebp),%esi
   13b7f:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   13b86:	0f b6 d5             	movzbl %ch,%edx
   13b89:	89 d9                	mov    %ebx,%ecx
   13b8b:	8b 5d 74             	mov    0x74(%ebp),%ebx
   13b8e:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   13b95:	0f b6 d1             	movzbl %cl,%edx
   13b98:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   13b9f:	0f b6 d5             	movzbl %ch,%edx
   13ba2:	c1 e9 10             	shr    $0x10,%ecx
   13ba5:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   13bac:	0f b6 d1             	movzbl %cl,%edx
   13baf:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   13bb6:	0f b6 d5             	movzbl %ch,%edx
   13bb9:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   13bc0:	8b 0c 24             	mov    (%esp,1),%ecx
   13bc3:	0f b6 d1             	movzbl %cl,%edx
   13bc6:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   13bcd:	0f b6 d5             	movzbl %ch,%edx
   13bd0:	c1 e9 10             	shr    $0x10,%ecx
   13bd3:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   13bda:	0f b6 d1             	movzbl %cl,%edx
   13bdd:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   13be4:	0f b6 d5             	movzbl %ch,%edx
   13be7:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   13bee:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   13bf2:	0f b6 d1             	movzbl %cl,%edx
   13bf5:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   13bfc:	0f b6 d5             	movzbl %ch,%edx
   13bff:	c1 e9 10             	shr    $0x10,%ecx
   13c02:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   13c09:	0f b6 d1             	movzbl %cl,%edx
   13c0c:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   13c13:	0f b6 d5             	movzbl %ch,%edx
   13c16:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   13c1d:	89 c1                	mov    %eax,%ecx
   13c1f:	89 34 24             	mov    %esi,(%esp,1)
   13c22:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   13c26:	0f b6 d1             	movzbl %cl,%edx
   13c29:	8b 85 80 00 00 00    	mov    0x80(%ebp),%eax
   13c2f:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   13c36:	0f b6 d5             	movzbl %ch,%edx
   13c39:	c1 e9 10             	shr    $0x10,%ecx
   13c3c:	8b bd 8c 00 00 00    	mov    0x8c(%ebp),%edi
   13c42:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   13c49:	0f b6 d1             	movzbl %cl,%edx
   13c4c:	8b b5 88 00 00 00    	mov    0x88(%ebp),%esi
   13c52:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   13c59:	0f b6 d5             	movzbl %ch,%edx
   13c5c:	89 d9                	mov    %ebx,%ecx
   13c5e:	8b 9d 84 00 00 00    	mov    0x84(%ebp),%ebx
   13c64:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   13c6b:	0f b6 d1             	movzbl %cl,%edx
   13c6e:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   13c75:	0f b6 d5             	movzbl %ch,%edx
   13c78:	c1 e9 10             	shr    $0x10,%ecx
   13c7b:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   13c82:	0f b6 d1             	movzbl %cl,%edx
   13c85:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   13c8c:	0f b6 d5             	movzbl %ch,%edx
   13c8f:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   13c96:	8b 0c 24             	mov    (%esp,1),%ecx
   13c99:	0f b6 d1             	movzbl %cl,%edx
   13c9c:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   13ca3:	0f b6 d5             	movzbl %ch,%edx
   13ca6:	c1 e9 10             	shr    $0x10,%ecx
   13ca9:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   13cb0:	0f b6 d1             	movzbl %cl,%edx
   13cb3:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   13cba:	0f b6 d5             	movzbl %ch,%edx
   13cbd:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   13cc4:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   13cc8:	0f b6 d1             	movzbl %cl,%edx
   13ccb:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   13cd2:	0f b6 d5             	movzbl %ch,%edx
   13cd5:	c1 e9 10             	shr    $0x10,%ecx
   13cd8:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   13cdf:	0f b6 d1             	movzbl %cl,%edx
   13ce2:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   13ce9:	0f b6 d5             	movzbl %ch,%edx
   13cec:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   13cf3:	89 c1                	mov    %eax,%ecx
   13cf5:	89 34 24             	mov    %esi,(%esp,1)
   13cf8:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   13cfc:	0f b6 d1             	movzbl %cl,%edx
   13cff:	8b 85 90 00 00 00    	mov    0x90(%ebp),%eax
   13d05:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   13d0c:	0f b6 d5             	movzbl %ch,%edx
   13d0f:	c1 e9 10             	shr    $0x10,%ecx
   13d12:	8b bd 9c 00 00 00    	mov    0x9c(%ebp),%edi
   13d18:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   13d1f:	0f b6 d1             	movzbl %cl,%edx
   13d22:	8b b5 98 00 00 00    	mov    0x98(%ebp),%esi
   13d28:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   13d2f:	0f b6 d5             	movzbl %ch,%edx
   13d32:	89 d9                	mov    %ebx,%ecx
   13d34:	8b 9d 94 00 00 00    	mov    0x94(%ebp),%ebx
   13d3a:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   13d41:	0f b6 d1             	movzbl %cl,%edx
   13d44:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   13d4b:	0f b6 d5             	movzbl %ch,%edx
   13d4e:	c1 e9 10             	shr    $0x10,%ecx
   13d51:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   13d58:	0f b6 d1             	movzbl %cl,%edx
   13d5b:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   13d62:	0f b6 d5             	movzbl %ch,%edx
   13d65:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   13d6c:	8b 0c 24             	mov    (%esp,1),%ecx
   13d6f:	0f b6 d1             	movzbl %cl,%edx
   13d72:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   13d79:	0f b6 d5             	movzbl %ch,%edx
   13d7c:	c1 e9 10             	shr    $0x10,%ecx
   13d7f:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   13d86:	0f b6 d1             	movzbl %cl,%edx
   13d89:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   13d90:	0f b6 d5             	movzbl %ch,%edx
   13d93:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   13d9a:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   13d9e:	0f b6 d1             	movzbl %cl,%edx
   13da1:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   13da8:	0f b6 d5             	movzbl %ch,%edx
   13dab:	c1 e9 10             	shr    $0x10,%ecx
   13dae:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   13db5:	0f b6 d1             	movzbl %cl,%edx
   13db8:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   13dbf:	0f b6 d5             	movzbl %ch,%edx
   13dc2:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   13dc9:	89 c1                	mov    %eax,%ecx
   13dcb:	89 34 24             	mov    %esi,(%esp,1)
   13dce:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   13dd2:	0f b6 d1             	movzbl %cl,%edx
   13dd5:	8b 85 a0 00 00 00    	mov    0xa0(%ebp),%eax
   13ddb:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   13de2:	0f b6 d5             	movzbl %ch,%edx
   13de5:	c1 e9 10             	shr    $0x10,%ecx
   13de8:	8b bd ac 00 00 00    	mov    0xac(%ebp),%edi
   13dee:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   13df5:	0f b6 d1             	movzbl %cl,%edx
   13df8:	8b b5 a8 00 00 00    	mov    0xa8(%ebp),%esi
   13dfe:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   13e05:	0f b6 d5             	movzbl %ch,%edx
   13e08:	89 d9                	mov    %ebx,%ecx
   13e0a:	8b 9d a4 00 00 00    	mov    0xa4(%ebp),%ebx
   13e10:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   13e17:	0f b6 d1             	movzbl %cl,%edx
   13e1a:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   13e21:	0f b6 d5             	movzbl %ch,%edx
   13e24:	c1 e9 10             	shr    $0x10,%ecx
   13e27:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   13e2e:	0f b6 d1             	movzbl %cl,%edx
   13e31:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   13e38:	0f b6 d5             	movzbl %ch,%edx
   13e3b:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   13e42:	8b 0c 24             	mov    (%esp,1),%ecx
   13e45:	0f b6 d1             	movzbl %cl,%edx
   13e48:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   13e4f:	0f b6 d5             	movzbl %ch,%edx
   13e52:	c1 e9 10             	shr    $0x10,%ecx
   13e55:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   13e5c:	0f b6 d1             	movzbl %cl,%edx
   13e5f:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   13e66:	0f b6 d5             	movzbl %ch,%edx
   13e69:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   13e70:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   13e74:	0f b6 d1             	movzbl %cl,%edx
   13e77:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   13e7e:	0f b6 d5             	movzbl %ch,%edx
   13e81:	c1 e9 10             	shr    $0x10,%ecx
   13e84:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   13e8b:	0f b6 d1             	movzbl %cl,%edx
   13e8e:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   13e95:	0f b6 d5             	movzbl %ch,%edx
   13e98:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   13e9f:	8b 6c 24 20          	mov    0x20(%esp,1),%ebp
   13ea3:	89 7d 0c             	mov    %edi,0xc(%ebp)
   13ea6:	89 75 08             	mov    %esi,0x8(%ebp)
   13ea9:	89 5d 04             	mov    %ebx,0x4(%ebp)
   13eac:	89 45 00             	mov    %eax,0x0(%ebp)
   13eaf:	31 c0                	xor    %eax,%eax

00013eb1 <aes_encrypt.4>:
   13eb1:	8b 6c 24 14          	mov    0x14(%esp,1),%ebp
   13eb5:	8b 5c 24 10          	mov    0x10(%esp,1),%ebx
   13eb9:	8b 74 24 0c          	mov    0xc(%esp,1),%esi
   13ebd:	8b 7c 24 08          	mov    0x8(%esp,1),%edi
   13ec1:	8d 64 24 18          	lea    0x18(%esp,1),%esp
   13ec5:	c3                   	ret    

00013ec6 <aes_decrypt>:
   13ec6:	83 ec 18             	sub    $0x18,%esp
   13ec9:	89 6c 24 14          	mov    %ebp,0x14(%esp,1)
   13ecd:	89 5c 24 10          	mov    %ebx,0x10(%esp,1)
   13ed1:	89 74 24 0c          	mov    %esi,0xc(%esp,1)
   13ed5:	89 7c 24 08          	mov    %edi,0x8(%esp,1)
   13ed9:	8b 4c 24 1c          	mov    0x1c(%esp,1),%ecx
   13edd:	8b 6c 24 24          	mov    0x24(%esp,1),%ebp
   13ee1:	8b 01                	mov    (%ecx),%eax
   13ee3:	8b 59 04             	mov    0x4(%ecx),%ebx
   13ee6:	8b 71 08             	mov    0x8(%ecx),%esi
   13ee9:	8b 79 0c             	mov    0xc(%ecx),%edi
   13eec:	8b 8d f0 00 00 00    	mov    0xf0(%ebp),%ecx
   13ef2:	8d 14 8d 00 00 00 00 	lea    0x0(,%ecx,4),%edx
   13ef9:	8d 54 95 00          	lea    0x0(%ebp,%edx,4),%edx
   13efd:	33 02                	xor    (%edx),%eax
   13eff:	33 5a 04             	xor    0x4(%edx),%ebx
   13f02:	33 72 08             	xor    0x8(%edx),%esi
   13f05:	33 7a 0c             	xor    0xc(%edx),%edi
   13f08:	83 f9 0a             	cmp    $0xa,%ecx
   13f0b:	0f 84 70 03 00 00    	je     14281 <aes_decrypt.3>
   13f11:	83 f9 0c             	cmp    $0xc,%ecx
   13f14:	0f 84 bb 01 00 00    	je     140d5 <aes_decrypt.2>
   13f1a:	83 f9 0e             	cmp    $0xe,%ecx
   13f1d:	74 0a                	je     13f29 <aes_decrypt.1>
   13f1f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13f24:	e9 66 0b 00 00       	jmp    14a8f <aes_decrypt.4>

00013f29 <aes_decrypt.1>:
   13f29:	89 c1                	mov    %eax,%ecx
   13f2b:	89 1c 24             	mov    %ebx,(%esp,1)
   13f2e:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   13f32:	0f b6 d1             	movzbl %cl,%edx
   13f35:	8b 85 d0 00 00 00    	mov    0xd0(%ebp),%eax
   13f3b:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   13f42:	0f b6 d5             	movzbl %ch,%edx
   13f45:	c1 e9 10             	shr    $0x10,%ecx
   13f48:	8b 9d d4 00 00 00    	mov    0xd4(%ebp),%ebx
   13f4e:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   13f55:	0f b6 d1             	movzbl %cl,%edx
   13f58:	8b b5 d8 00 00 00    	mov    0xd8(%ebp),%esi
   13f5e:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   13f65:	0f b6 d5             	movzbl %ch,%edx
   13f68:	89 f9                	mov    %edi,%ecx
   13f6a:	8b bd dc 00 00 00    	mov    0xdc(%ebp),%edi
   13f70:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   13f77:	0f b6 d1             	movzbl %cl,%edx
   13f7a:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   13f81:	0f b6 d5             	movzbl %ch,%edx
   13f84:	c1 e9 10             	shr    $0x10,%ecx
   13f87:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   13f8e:	0f b6 d1             	movzbl %cl,%edx
   13f91:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   13f98:	0f b6 d5             	movzbl %ch,%edx
   13f9b:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   13fa2:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   13fa6:	0f b6 d1             	movzbl %cl,%edx
   13fa9:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   13fb0:	0f b6 d5             	movzbl %ch,%edx
   13fb3:	c1 e9 10             	shr    $0x10,%ecx
   13fb6:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   13fbd:	0f b6 d1             	movzbl %cl,%edx
   13fc0:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   13fc7:	0f b6 d5             	movzbl %ch,%edx
   13fca:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   13fd1:	8b 0c 24             	mov    (%esp,1),%ecx
   13fd4:	0f b6 d1             	movzbl %cl,%edx
   13fd7:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   13fde:	0f b6 d5             	movzbl %ch,%edx
   13fe1:	c1 e9 10             	shr    $0x10,%ecx
   13fe4:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   13feb:	0f b6 d1             	movzbl %cl,%edx
   13fee:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   13ff5:	0f b6 d5             	movzbl %ch,%edx
   13ff8:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   13fff:	89 c1                	mov    %eax,%ecx
   14001:	89 1c 24             	mov    %ebx,(%esp,1)
   14004:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   14008:	0f b6 d1             	movzbl %cl,%edx
   1400b:	8b 85 c0 00 00 00    	mov    0xc0(%ebp),%eax
   14011:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   14018:	0f b6 d5             	movzbl %ch,%edx
   1401b:	c1 e9 10             	shr    $0x10,%ecx
   1401e:	8b 9d c4 00 00 00    	mov    0xc4(%ebp),%ebx
   14024:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1402b:	0f b6 d1             	movzbl %cl,%edx
   1402e:	8b b5 c8 00 00 00    	mov    0xc8(%ebp),%esi
   14034:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1403b:	0f b6 d5             	movzbl %ch,%edx
   1403e:	89 f9                	mov    %edi,%ecx
   14040:	8b bd cc 00 00 00    	mov    0xcc(%ebp),%edi
   14046:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1404d:	0f b6 d1             	movzbl %cl,%edx
   14050:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   14057:	0f b6 d5             	movzbl %ch,%edx
   1405a:	c1 e9 10             	shr    $0x10,%ecx
   1405d:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   14064:	0f b6 d1             	movzbl %cl,%edx
   14067:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1406e:	0f b6 d5             	movzbl %ch,%edx
   14071:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   14078:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1407c:	0f b6 d1             	movzbl %cl,%edx
   1407f:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   14086:	0f b6 d5             	movzbl %ch,%edx
   14089:	c1 e9 10             	shr    $0x10,%ecx
   1408c:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   14093:	0f b6 d1             	movzbl %cl,%edx
   14096:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1409d:	0f b6 d5             	movzbl %ch,%edx
   140a0:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   140a7:	8b 0c 24             	mov    (%esp,1),%ecx
   140aa:	0f b6 d1             	movzbl %cl,%edx
   140ad:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   140b4:	0f b6 d5             	movzbl %ch,%edx
   140b7:	c1 e9 10             	shr    $0x10,%ecx
   140ba:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   140c1:	0f b6 d1             	movzbl %cl,%edx
   140c4:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   140cb:	0f b6 d5             	movzbl %ch,%edx
   140ce:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax

000140d5 <aes_decrypt.2>:
   140d5:	89 c1                	mov    %eax,%ecx
   140d7:	89 1c 24             	mov    %ebx,(%esp,1)
   140da:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   140de:	0f b6 d1             	movzbl %cl,%edx
   140e1:	8b 85 b0 00 00 00    	mov    0xb0(%ebp),%eax
   140e7:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   140ee:	0f b6 d5             	movzbl %ch,%edx
   140f1:	c1 e9 10             	shr    $0x10,%ecx
   140f4:	8b 9d b4 00 00 00    	mov    0xb4(%ebp),%ebx
   140fa:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   14101:	0f b6 d1             	movzbl %cl,%edx
   14104:	8b b5 b8 00 00 00    	mov    0xb8(%ebp),%esi
   1410a:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   14111:	0f b6 d5             	movzbl %ch,%edx
   14114:	89 f9                	mov    %edi,%ecx
   14116:	8b bd bc 00 00 00    	mov    0xbc(%ebp),%edi
   1411c:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   14123:	0f b6 d1             	movzbl %cl,%edx
   14126:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1412d:	0f b6 d5             	movzbl %ch,%edx
   14130:	c1 e9 10             	shr    $0x10,%ecx
   14133:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1413a:	0f b6 d1             	movzbl %cl,%edx
   1413d:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   14144:	0f b6 d5             	movzbl %ch,%edx
   14147:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1414e:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   14152:	0f b6 d1             	movzbl %cl,%edx
   14155:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1415c:	0f b6 d5             	movzbl %ch,%edx
   1415f:	c1 e9 10             	shr    $0x10,%ecx
   14162:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   14169:	0f b6 d1             	movzbl %cl,%edx
   1416c:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   14173:	0f b6 d5             	movzbl %ch,%edx
   14176:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1417d:	8b 0c 24             	mov    (%esp,1),%ecx
   14180:	0f b6 d1             	movzbl %cl,%edx
   14183:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1418a:	0f b6 d5             	movzbl %ch,%edx
   1418d:	c1 e9 10             	shr    $0x10,%ecx
   14190:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   14197:	0f b6 d1             	movzbl %cl,%edx
   1419a:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   141a1:	0f b6 d5             	movzbl %ch,%edx
   141a4:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   141ab:	89 c1                	mov    %eax,%ecx
   141ad:	89 1c 24             	mov    %ebx,(%esp,1)
   141b0:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   141b4:	0f b6 d1             	movzbl %cl,%edx
   141b7:	8b 85 a0 00 00 00    	mov    0xa0(%ebp),%eax
   141bd:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   141c4:	0f b6 d5             	movzbl %ch,%edx
   141c7:	c1 e9 10             	shr    $0x10,%ecx
   141ca:	8b 9d a4 00 00 00    	mov    0xa4(%ebp),%ebx
   141d0:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   141d7:	0f b6 d1             	movzbl %cl,%edx
   141da:	8b b5 a8 00 00 00    	mov    0xa8(%ebp),%esi
   141e0:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   141e7:	0f b6 d5             	movzbl %ch,%edx
   141ea:	89 f9                	mov    %edi,%ecx
   141ec:	8b bd ac 00 00 00    	mov    0xac(%ebp),%edi
   141f2:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   141f9:	0f b6 d1             	movzbl %cl,%edx
   141fc:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   14203:	0f b6 d5             	movzbl %ch,%edx
   14206:	c1 e9 10             	shr    $0x10,%ecx
   14209:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   14210:	0f b6 d1             	movzbl %cl,%edx
   14213:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1421a:	0f b6 d5             	movzbl %ch,%edx
   1421d:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   14224:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   14228:	0f b6 d1             	movzbl %cl,%edx
   1422b:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   14232:	0f b6 d5             	movzbl %ch,%edx
   14235:	c1 e9 10             	shr    $0x10,%ecx
   14238:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1423f:	0f b6 d1             	movzbl %cl,%edx
   14242:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   14249:	0f b6 d5             	movzbl %ch,%edx
   1424c:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   14253:	8b 0c 24             	mov    (%esp,1),%ecx
   14256:	0f b6 d1             	movzbl %cl,%edx
   14259:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   14260:	0f b6 d5             	movzbl %ch,%edx
   14263:	c1 e9 10             	shr    $0x10,%ecx
   14266:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1426d:	0f b6 d1             	movzbl %cl,%edx
   14270:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   14277:	0f b6 d5             	movzbl %ch,%edx
   1427a:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax

00014281 <aes_decrypt.3>:
   14281:	89 c1                	mov    %eax,%ecx
   14283:	89 1c 24             	mov    %ebx,(%esp,1)
   14286:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   1428a:	0f b6 d1             	movzbl %cl,%edx
   1428d:	8b 85 90 00 00 00    	mov    0x90(%ebp),%eax
   14293:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1429a:	0f b6 d5             	movzbl %ch,%edx
   1429d:	c1 e9 10             	shr    $0x10,%ecx
   142a0:	8b 9d 94 00 00 00    	mov    0x94(%ebp),%ebx
   142a6:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   142ad:	0f b6 d1             	movzbl %cl,%edx
   142b0:	8b b5 98 00 00 00    	mov    0x98(%ebp),%esi
   142b6:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   142bd:	0f b6 d5             	movzbl %ch,%edx
   142c0:	89 f9                	mov    %edi,%ecx
   142c2:	8b bd 9c 00 00 00    	mov    0x9c(%ebp),%edi
   142c8:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   142cf:	0f b6 d1             	movzbl %cl,%edx
   142d2:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   142d9:	0f b6 d5             	movzbl %ch,%edx
   142dc:	c1 e9 10             	shr    $0x10,%ecx
   142df:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   142e6:	0f b6 d1             	movzbl %cl,%edx
   142e9:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   142f0:	0f b6 d5             	movzbl %ch,%edx
   142f3:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   142fa:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   142fe:	0f b6 d1             	movzbl %cl,%edx
   14301:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   14308:	0f b6 d5             	movzbl %ch,%edx
   1430b:	c1 e9 10             	shr    $0x10,%ecx
   1430e:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   14315:	0f b6 d1             	movzbl %cl,%edx
   14318:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1431f:	0f b6 d5             	movzbl %ch,%edx
   14322:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   14329:	8b 0c 24             	mov    (%esp,1),%ecx
   1432c:	0f b6 d1             	movzbl %cl,%edx
   1432f:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   14336:	0f b6 d5             	movzbl %ch,%edx
   14339:	c1 e9 10             	shr    $0x10,%ecx
   1433c:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   14343:	0f b6 d1             	movzbl %cl,%edx
   14346:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1434d:	0f b6 d5             	movzbl %ch,%edx
   14350:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   14357:	89 c1                	mov    %eax,%ecx
   14359:	89 1c 24             	mov    %ebx,(%esp,1)
   1435c:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   14360:	0f b6 d1             	movzbl %cl,%edx
   14363:	8b 85 80 00 00 00    	mov    0x80(%ebp),%eax
   14369:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   14370:	0f b6 d5             	movzbl %ch,%edx
   14373:	c1 e9 10             	shr    $0x10,%ecx
   14376:	8b 9d 84 00 00 00    	mov    0x84(%ebp),%ebx
   1437c:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   14383:	0f b6 d1             	movzbl %cl,%edx
   14386:	8b b5 88 00 00 00    	mov    0x88(%ebp),%esi
   1438c:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   14393:	0f b6 d5             	movzbl %ch,%edx
   14396:	89 f9                	mov    %edi,%ecx
   14398:	8b bd 8c 00 00 00    	mov    0x8c(%ebp),%edi
   1439e:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   143a5:	0f b6 d1             	movzbl %cl,%edx
   143a8:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   143af:	0f b6 d5             	movzbl %ch,%edx
   143b2:	c1 e9 10             	shr    $0x10,%ecx
   143b5:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   143bc:	0f b6 d1             	movzbl %cl,%edx
   143bf:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   143c6:	0f b6 d5             	movzbl %ch,%edx
   143c9:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   143d0:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   143d4:	0f b6 d1             	movzbl %cl,%edx
   143d7:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   143de:	0f b6 d5             	movzbl %ch,%edx
   143e1:	c1 e9 10             	shr    $0x10,%ecx
   143e4:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   143eb:	0f b6 d1             	movzbl %cl,%edx
   143ee:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   143f5:	0f b6 d5             	movzbl %ch,%edx
   143f8:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   143ff:	8b 0c 24             	mov    (%esp,1),%ecx
   14402:	0f b6 d1             	movzbl %cl,%edx
   14405:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1440c:	0f b6 d5             	movzbl %ch,%edx
   1440f:	c1 e9 10             	shr    $0x10,%ecx
   14412:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   14419:	0f b6 d1             	movzbl %cl,%edx
   1441c:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   14423:	0f b6 d5             	movzbl %ch,%edx
   14426:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1442d:	89 c1                	mov    %eax,%ecx
   1442f:	89 1c 24             	mov    %ebx,(%esp,1)
   14432:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   14436:	0f b6 d1             	movzbl %cl,%edx
   14439:	8b 45 70             	mov    0x70(%ebp),%eax
   1443c:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   14443:	0f b6 d5             	movzbl %ch,%edx
   14446:	c1 e9 10             	shr    $0x10,%ecx
   14449:	8b 5d 74             	mov    0x74(%ebp),%ebx
   1444c:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   14453:	0f b6 d1             	movzbl %cl,%edx
   14456:	8b 75 78             	mov    0x78(%ebp),%esi
   14459:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   14460:	0f b6 d5             	movzbl %ch,%edx
   14463:	89 f9                	mov    %edi,%ecx
   14465:	8b 7d 7c             	mov    0x7c(%ebp),%edi
   14468:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1446f:	0f b6 d1             	movzbl %cl,%edx
   14472:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   14479:	0f b6 d5             	movzbl %ch,%edx
   1447c:	c1 e9 10             	shr    $0x10,%ecx
   1447f:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   14486:	0f b6 d1             	movzbl %cl,%edx
   14489:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   14490:	0f b6 d5             	movzbl %ch,%edx
   14493:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1449a:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1449e:	0f b6 d1             	movzbl %cl,%edx
   144a1:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   144a8:	0f b6 d5             	movzbl %ch,%edx
   144ab:	c1 e9 10             	shr    $0x10,%ecx
   144ae:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   144b5:	0f b6 d1             	movzbl %cl,%edx
   144b8:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   144bf:	0f b6 d5             	movzbl %ch,%edx
   144c2:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   144c9:	8b 0c 24             	mov    (%esp,1),%ecx
   144cc:	0f b6 d1             	movzbl %cl,%edx
   144cf:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   144d6:	0f b6 d5             	movzbl %ch,%edx
   144d9:	c1 e9 10             	shr    $0x10,%ecx
   144dc:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   144e3:	0f b6 d1             	movzbl %cl,%edx
   144e6:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   144ed:	0f b6 d5             	movzbl %ch,%edx
   144f0:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   144f7:	89 c1                	mov    %eax,%ecx
   144f9:	89 1c 24             	mov    %ebx,(%esp,1)
   144fc:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   14500:	0f b6 d1             	movzbl %cl,%edx
   14503:	8b 45 60             	mov    0x60(%ebp),%eax
   14506:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1450d:	0f b6 d5             	movzbl %ch,%edx
   14510:	c1 e9 10             	shr    $0x10,%ecx
   14513:	8b 5d 64             	mov    0x64(%ebp),%ebx
   14516:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1451d:	0f b6 d1             	movzbl %cl,%edx
   14520:	8b 75 68             	mov    0x68(%ebp),%esi
   14523:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1452a:	0f b6 d5             	movzbl %ch,%edx
   1452d:	89 f9                	mov    %edi,%ecx
   1452f:	8b 7d 6c             	mov    0x6c(%ebp),%edi
   14532:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   14539:	0f b6 d1             	movzbl %cl,%edx
   1453c:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   14543:	0f b6 d5             	movzbl %ch,%edx
   14546:	c1 e9 10             	shr    $0x10,%ecx
   14549:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   14550:	0f b6 d1             	movzbl %cl,%edx
   14553:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1455a:	0f b6 d5             	movzbl %ch,%edx
   1455d:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   14564:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   14568:	0f b6 d1             	movzbl %cl,%edx
   1456b:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   14572:	0f b6 d5             	movzbl %ch,%edx
   14575:	c1 e9 10             	shr    $0x10,%ecx
   14578:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1457f:	0f b6 d1             	movzbl %cl,%edx
   14582:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   14589:	0f b6 d5             	movzbl %ch,%edx
   1458c:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   14593:	8b 0c 24             	mov    (%esp,1),%ecx
   14596:	0f b6 d1             	movzbl %cl,%edx
   14599:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   145a0:	0f b6 d5             	movzbl %ch,%edx
   145a3:	c1 e9 10             	shr    $0x10,%ecx
   145a6:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   145ad:	0f b6 d1             	movzbl %cl,%edx
   145b0:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   145b7:	0f b6 d5             	movzbl %ch,%edx
   145ba:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   145c1:	89 c1                	mov    %eax,%ecx
   145c3:	89 1c 24             	mov    %ebx,(%esp,1)
   145c6:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   145ca:	0f b6 d1             	movzbl %cl,%edx
   145cd:	8b 45 50             	mov    0x50(%ebp),%eax
   145d0:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   145d7:	0f b6 d5             	movzbl %ch,%edx
   145da:	c1 e9 10             	shr    $0x10,%ecx
   145dd:	8b 5d 54             	mov    0x54(%ebp),%ebx
   145e0:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   145e7:	0f b6 d1             	movzbl %cl,%edx
   145ea:	8b 75 58             	mov    0x58(%ebp),%esi
   145ed:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   145f4:	0f b6 d5             	movzbl %ch,%edx
   145f7:	89 f9                	mov    %edi,%ecx
   145f9:	8b 7d 5c             	mov    0x5c(%ebp),%edi
   145fc:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   14603:	0f b6 d1             	movzbl %cl,%edx
   14606:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1460d:	0f b6 d5             	movzbl %ch,%edx
   14610:	c1 e9 10             	shr    $0x10,%ecx
   14613:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1461a:	0f b6 d1             	movzbl %cl,%edx
   1461d:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   14624:	0f b6 d5             	movzbl %ch,%edx
   14627:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1462e:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   14632:	0f b6 d1             	movzbl %cl,%edx
   14635:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1463c:	0f b6 d5             	movzbl %ch,%edx
   1463f:	c1 e9 10             	shr    $0x10,%ecx
   14642:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   14649:	0f b6 d1             	movzbl %cl,%edx
   1464c:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   14653:	0f b6 d5             	movzbl %ch,%edx
   14656:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1465d:	8b 0c 24             	mov    (%esp,1),%ecx
   14660:	0f b6 d1             	movzbl %cl,%edx
   14663:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1466a:	0f b6 d5             	movzbl %ch,%edx
   1466d:	c1 e9 10             	shr    $0x10,%ecx
   14670:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   14677:	0f b6 d1             	movzbl %cl,%edx
   1467a:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   14681:	0f b6 d5             	movzbl %ch,%edx
   14684:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1468b:	89 c1                	mov    %eax,%ecx
   1468d:	89 1c 24             	mov    %ebx,(%esp,1)
   14690:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   14694:	0f b6 d1             	movzbl %cl,%edx
   14697:	8b 45 40             	mov    0x40(%ebp),%eax
   1469a:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   146a1:	0f b6 d5             	movzbl %ch,%edx
   146a4:	c1 e9 10             	shr    $0x10,%ecx
   146a7:	8b 5d 44             	mov    0x44(%ebp),%ebx
   146aa:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   146b1:	0f b6 d1             	movzbl %cl,%edx
   146b4:	8b 75 48             	mov    0x48(%ebp),%esi
   146b7:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   146be:	0f b6 d5             	movzbl %ch,%edx
   146c1:	89 f9                	mov    %edi,%ecx
   146c3:	8b 7d 4c             	mov    0x4c(%ebp),%edi
   146c6:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   146cd:	0f b6 d1             	movzbl %cl,%edx
   146d0:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   146d7:	0f b6 d5             	movzbl %ch,%edx
   146da:	c1 e9 10             	shr    $0x10,%ecx
   146dd:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   146e4:	0f b6 d1             	movzbl %cl,%edx
   146e7:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   146ee:	0f b6 d5             	movzbl %ch,%edx
   146f1:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   146f8:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   146fc:	0f b6 d1             	movzbl %cl,%edx
   146ff:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   14706:	0f b6 d5             	movzbl %ch,%edx
   14709:	c1 e9 10             	shr    $0x10,%ecx
   1470c:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   14713:	0f b6 d1             	movzbl %cl,%edx
   14716:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1471d:	0f b6 d5             	movzbl %ch,%edx
   14720:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   14727:	8b 0c 24             	mov    (%esp,1),%ecx
   1472a:	0f b6 d1             	movzbl %cl,%edx
   1472d:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   14734:	0f b6 d5             	movzbl %ch,%edx
   14737:	c1 e9 10             	shr    $0x10,%ecx
   1473a:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   14741:	0f b6 d1             	movzbl %cl,%edx
   14744:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1474b:	0f b6 d5             	movzbl %ch,%edx
   1474e:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   14755:	89 c1                	mov    %eax,%ecx
   14757:	89 1c 24             	mov    %ebx,(%esp,1)
   1475a:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   1475e:	0f b6 d1             	movzbl %cl,%edx
   14761:	8b 45 30             	mov    0x30(%ebp),%eax
   14764:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1476b:	0f b6 d5             	movzbl %ch,%edx
   1476e:	c1 e9 10             	shr    $0x10,%ecx
   14771:	8b 5d 34             	mov    0x34(%ebp),%ebx
   14774:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1477b:	0f b6 d1             	movzbl %cl,%edx
   1477e:	8b 75 38             	mov    0x38(%ebp),%esi
   14781:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   14788:	0f b6 d5             	movzbl %ch,%edx
   1478b:	89 f9                	mov    %edi,%ecx
   1478d:	8b 7d 3c             	mov    0x3c(%ebp),%edi
   14790:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   14797:	0f b6 d1             	movzbl %cl,%edx
   1479a:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   147a1:	0f b6 d5             	movzbl %ch,%edx
   147a4:	c1 e9 10             	shr    $0x10,%ecx
   147a7:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   147ae:	0f b6 d1             	movzbl %cl,%edx
   147b1:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   147b8:	0f b6 d5             	movzbl %ch,%edx
   147bb:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   147c2:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   147c6:	0f b6 d1             	movzbl %cl,%edx
   147c9:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   147d0:	0f b6 d5             	movzbl %ch,%edx
   147d3:	c1 e9 10             	shr    $0x10,%ecx
   147d6:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   147dd:	0f b6 d1             	movzbl %cl,%edx
   147e0:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   147e7:	0f b6 d5             	movzbl %ch,%edx
   147ea:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   147f1:	8b 0c 24             	mov    (%esp,1),%ecx
   147f4:	0f b6 d1             	movzbl %cl,%edx
   147f7:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   147fe:	0f b6 d5             	movzbl %ch,%edx
   14801:	c1 e9 10             	shr    $0x10,%ecx
   14804:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1480b:	0f b6 d1             	movzbl %cl,%edx
   1480e:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   14815:	0f b6 d5             	movzbl %ch,%edx
   14818:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1481f:	89 c1                	mov    %eax,%ecx
   14821:	89 1c 24             	mov    %ebx,(%esp,1)
   14824:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   14828:	0f b6 d1             	movzbl %cl,%edx
   1482b:	8b 45 20             	mov    0x20(%ebp),%eax
   1482e:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   14835:	0f b6 d5             	movzbl %ch,%edx
   14838:	c1 e9 10             	shr    $0x10,%ecx
   1483b:	8b 5d 24             	mov    0x24(%ebp),%ebx
   1483e:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   14845:	0f b6 d1             	movzbl %cl,%edx
   14848:	8b 75 28             	mov    0x28(%ebp),%esi
   1484b:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   14852:	0f b6 d5             	movzbl %ch,%edx
   14855:	89 f9                	mov    %edi,%ecx
   14857:	8b 7d 2c             	mov    0x2c(%ebp),%edi
   1485a:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   14861:	0f b6 d1             	movzbl %cl,%edx
   14864:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1486b:	0f b6 d5             	movzbl %ch,%edx
   1486e:	c1 e9 10             	shr    $0x10,%ecx
   14871:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   14878:	0f b6 d1             	movzbl %cl,%edx
   1487b:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   14882:	0f b6 d5             	movzbl %ch,%edx
   14885:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1488c:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   14890:	0f b6 d1             	movzbl %cl,%edx
   14893:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1489a:	0f b6 d5             	movzbl %ch,%edx
   1489d:	c1 e9 10             	shr    $0x10,%ecx
   148a0:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   148a7:	0f b6 d1             	movzbl %cl,%edx
   148aa:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   148b1:	0f b6 d5             	movzbl %ch,%edx
   148b4:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   148bb:	8b 0c 24             	mov    (%esp,1),%ecx
   148be:	0f b6 d1             	movzbl %cl,%edx
   148c1:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   148c8:	0f b6 d5             	movzbl %ch,%edx
   148cb:	c1 e9 10             	shr    $0x10,%ecx
   148ce:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   148d5:	0f b6 d1             	movzbl %cl,%edx
   148d8:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   148df:	0f b6 d5             	movzbl %ch,%edx
   148e2:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   148e9:	89 c1                	mov    %eax,%ecx
   148eb:	89 1c 24             	mov    %ebx,(%esp,1)
   148ee:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   148f2:	0f b6 d1             	movzbl %cl,%edx
   148f5:	8b 45 10             	mov    0x10(%ebp),%eax
   148f8:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   148ff:	0f b6 d5             	movzbl %ch,%edx
   14902:	c1 e9 10             	shr    $0x10,%ecx
   14905:	8b 5d 14             	mov    0x14(%ebp),%ebx
   14908:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1490f:	0f b6 d1             	movzbl %cl,%edx
   14912:	8b 75 18             	mov    0x18(%ebp),%esi
   14915:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1491c:	0f b6 d5             	movzbl %ch,%edx
   1491f:	89 f9                	mov    %edi,%ecx
   14921:	8b 7d 1c             	mov    0x1c(%ebp),%edi
   14924:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1492b:	0f b6 d1             	movzbl %cl,%edx
   1492e:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   14935:	0f b6 d5             	movzbl %ch,%edx
   14938:	c1 e9 10             	shr    $0x10,%ecx
   1493b:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   14942:	0f b6 d1             	movzbl %cl,%edx
   14945:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1494c:	0f b6 d5             	movzbl %ch,%edx
   1494f:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   14956:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1495a:	0f b6 d1             	movzbl %cl,%edx
   1495d:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   14964:	0f b6 d5             	movzbl %ch,%edx
   14967:	c1 e9 10             	shr    $0x10,%ecx
   1496a:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   14971:	0f b6 d1             	movzbl %cl,%edx
   14974:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1497b:	0f b6 d5             	movzbl %ch,%edx
   1497e:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   14985:	8b 0c 24             	mov    (%esp,1),%ecx
   14988:	0f b6 d1             	movzbl %cl,%edx
   1498b:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   14992:	0f b6 d5             	movzbl %ch,%edx
   14995:	c1 e9 10             	shr    $0x10,%ecx
   14998:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1499f:	0f b6 d1             	movzbl %cl,%edx
   149a2:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   149a9:	0f b6 d5             	movzbl %ch,%edx
   149ac:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   149b3:	89 c1                	mov    %eax,%ecx
   149b5:	89 1c 24             	mov    %ebx,(%esp,1)
   149b8:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   149bc:	0f b6 d1             	movzbl %cl,%edx
   149bf:	8b 45 00             	mov    0x0(%ebp),%eax
   149c2:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   149c9:	0f b6 d5             	movzbl %ch,%edx
   149cc:	c1 e9 10             	shr    $0x10,%ecx
   149cf:	8b 5d 04             	mov    0x4(%ebp),%ebx
   149d2:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   149d9:	0f b6 d1             	movzbl %cl,%edx
   149dc:	8b 75 08             	mov    0x8(%ebp),%esi
   149df:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   149e6:	0f b6 d5             	movzbl %ch,%edx
   149e9:	89 f9                	mov    %edi,%ecx
   149eb:	8b 7d 0c             	mov    0xc(%ebp),%edi
   149ee:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   149f5:	0f b6 d1             	movzbl %cl,%edx
   149f8:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   149ff:	0f b6 d5             	movzbl %ch,%edx
   14a02:	c1 e9 10             	shr    $0x10,%ecx
   14a05:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   14a0c:	0f b6 d1             	movzbl %cl,%edx
   14a0f:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   14a16:	0f b6 d5             	movzbl %ch,%edx
   14a19:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   14a20:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   14a24:	0f b6 d1             	movzbl %cl,%edx
   14a27:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   14a2e:	0f b6 d5             	movzbl %ch,%edx
   14a31:	c1 e9 10             	shr    $0x10,%ecx
   14a34:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   14a3b:	0f b6 d1             	movzbl %cl,%edx
   14a3e:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   14a45:	0f b6 d5             	movzbl %ch,%edx
   14a48:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   14a4f:	8b 0c 24             	mov    (%esp,1),%ecx
   14a52:	0f b6 d1             	movzbl %cl,%edx
   14a55:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   14a5c:	0f b6 d5             	movzbl %ch,%edx
   14a5f:	c1 e9 10             	shr    $0x10,%ecx
   14a62:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   14a69:	0f b6 d1             	movzbl %cl,%edx
   14a6c:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   14a73:	0f b6 d5             	movzbl %ch,%edx
   14a76:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   14a7d:	8b 6c 24 20          	mov    0x20(%esp,1),%ebp
   14a81:	89 7d 0c             	mov    %edi,0xc(%ebp)
   14a84:	89 75 08             	mov    %esi,0x8(%ebp)
   14a87:	89 5d 04             	mov    %ebx,0x4(%ebp)
   14a8a:	89 45 00             	mov    %eax,0x0(%ebp)
   14a8d:	31 c0                	xor    %eax,%eax

00014a8f <aes_decrypt.4>:
   14a8f:	8b 6c 24 14          	mov    0x14(%esp,1),%ebp
   14a93:	8b 5c 24 10          	mov    0x10(%esp,1),%ebx
   14a97:	8b 74 24 0c          	mov    0xc(%esp,1),%esi
   14a9b:	8b 7c 24 08          	mov    0x8(%esp,1),%edi
   14a9f:	8d 64 24 18          	lea    0x18(%esp,1),%esp
   14aa3:	c3                   	ret    

00014aa4 <end>:
   14aa4:	83 ec 18             	sub    $0x18,%esp
   14aa7:	89 6c 24 14          	mov    %ebp,0x14(%esp,1)
   14aab:	89 5c 24 10          	mov    %ebx,0x10(%esp,1)
   14aaf:	89 74 24 0c          	mov    %esi,0xc(%esp,1)
   14ab3:	89 7c 24 08          	mov    %edi,0x8(%esp,1)
   14ab7:	8b 4c 24 1c          	mov    0x1c(%esp,1),%ecx
   14abb:	8b 6c 24 24          	mov    0x24(%esp,1),%ebp
   14abf:	8b 01                	mov    (%ecx),%eax
   14ac1:	8b 59 04             	mov    0x4(%ecx),%ebx
   14ac4:	33 45 00             	xor    0x0(%ebp),%eax
   14ac7:	33 5d 04             	xor    0x4(%ebp),%ebx
   14aca:	8b 71 08             	mov    0x8(%ecx),%esi
   14acd:	8b 79 0c             	mov    0xc(%ecx),%edi
   14ad0:	33 75 08             	xor    0x8(%ebp),%esi
   14ad3:	33 7d 0c             	xor    0xc(%ebp),%edi
   14ad6:	8b 8d f0 00 00 00    	mov    0xf0(%ebp),%ecx
   14adc:	83 f9 0a             	cmp    $0xa,%ecx
   14adf:	0f 84 46 03 00 00    	je     14e2b <end+0x387>
   14ae5:	8d 6d 20             	lea    0x20(%ebp),%ebp
   14ae8:	83 f9 0c             	cmp    $0xc,%ecx
   14aeb:	0f 84 a6 01 00 00    	je     14c97 <end+0x1f3>
   14af1:	8d 6d 20             	lea    0x20(%ebp),%ebp
   14af4:	83 f9 0e             	cmp    $0xe,%ecx
   14af7:	74 0a                	je     14b03 <end+0x5f>
   14af9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14afe:	e9 42 0b 00 00       	jmp    15645 <end+0xba1>
   14b03:	89 c1                	mov    %eax,%ecx
   14b05:	89 34 24             	mov    %esi,(%esp,1)
   14b08:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   14b0c:	0f b6 d1             	movzbl %cl,%edx
   14b0f:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   14b12:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   14b19:	0f b6 d5             	movzbl %ch,%edx
   14b1c:	c1 e9 10             	shr    $0x10,%ecx
   14b1f:	8b 7d dc             	mov    0xffffffdc(%ebp),%edi
   14b22:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   14b29:	0f b6 d1             	movzbl %cl,%edx
   14b2c:	8b 75 d8             	mov    0xffffffd8(%ebp),%esi
   14b2f:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   14b36:	0f b6 d5             	movzbl %ch,%edx
   14b39:	89 d9                	mov    %ebx,%ecx
   14b3b:	8b 5d d4             	mov    0xffffffd4(%ebp),%ebx
   14b3e:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   14b45:	0f b6 d1             	movzbl %cl,%edx
   14b48:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   14b4f:	0f b6 d5             	movzbl %ch,%edx
   14b52:	c1 e9 10             	shr    $0x10,%ecx
   14b55:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   14b5c:	0f b6 d1             	movzbl %cl,%edx
   14b5f:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   14b66:	0f b6 d5             	movzbl %ch,%edx
   14b69:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   14b70:	8b 0c 24             	mov    (%esp,1),%ecx
   14b73:	0f b6 d1             	movzbl %cl,%edx
   14b76:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   14b7d:	0f b6 d5             	movzbl %ch,%edx
   14b80:	c1 e9 10             	shr    $0x10,%ecx
   14b83:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   14b8a:	0f b6 d1             	movzbl %cl,%edx
   14b8d:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   14b94:	0f b6 d5             	movzbl %ch,%edx
   14b97:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   14b9e:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   14ba2:	0f b6 d1             	movzbl %cl,%edx
   14ba5:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   14bac:	0f b6 d5             	movzbl %ch,%edx
   14baf:	c1 e9 10             	shr    $0x10,%ecx
   14bb2:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   14bb9:	0f b6 d1             	movzbl %cl,%edx
   14bbc:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   14bc3:	0f b6 d5             	movzbl %ch,%edx
   14bc6:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   14bcd:	89 c1                	mov    %eax,%ecx
   14bcf:	89 34 24             	mov    %esi,(%esp,1)
   14bd2:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   14bd6:	0f b6 d1             	movzbl %cl,%edx
   14bd9:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   14bdc:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   14be3:	0f b6 d5             	movzbl %ch,%edx
   14be6:	c1 e9 10             	shr    $0x10,%ecx
   14be9:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
   14bec:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   14bf3:	0f b6 d1             	movzbl %cl,%edx
   14bf6:	8b 75 e8             	mov    0xffffffe8(%ebp),%esi
   14bf9:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   14c00:	0f b6 d5             	movzbl %ch,%edx
   14c03:	89 d9                	mov    %ebx,%ecx
   14c05:	8b 5d e4             	mov    0xffffffe4(%ebp),%ebx
   14c08:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   14c0f:	0f b6 d1             	movzbl %cl,%edx
   14c12:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   14c19:	0f b6 d5             	movzbl %ch,%edx
   14c1c:	c1 e9 10             	shr    $0x10,%ecx
   14c1f:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   14c26:	0f b6 d1             	movzbl %cl,%edx
   14c29:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   14c30:	0f b6 d5             	movzbl %ch,%edx
   14c33:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   14c3a:	8b 0c 24             	mov    (%esp,1),%ecx
   14c3d:	0f b6 d1             	movzbl %cl,%edx
   14c40:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   14c47:	0f b6 d5             	movzbl %ch,%edx
   14c4a:	c1 e9 10             	shr    $0x10,%ecx
   14c4d:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   14c54:	0f b6 d1             	movzbl %cl,%edx
   14c57:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   14c5e:	0f b6 d5             	movzbl %ch,%edx
   14c61:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   14c68:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   14c6c:	0f b6 d1             	movzbl %cl,%edx
   14c6f:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   14c76:	0f b6 d5             	movzbl %ch,%edx
   14c79:	c1 e9 10             	shr    $0x10,%ecx
   14c7c:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   14c83:	0f b6 d1             	movzbl %cl,%edx
   14c86:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   14c8d:	0f b6 d5             	movzbl %ch,%edx
   14c90:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   14c97:	89 c1                	mov    %eax,%ecx
   14c99:	89 34 24             	mov    %esi,(%esp,1)
   14c9c:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   14ca0:	0f b6 d1             	movzbl %cl,%edx
   14ca3:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   14ca6:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   14cad:	0f b6 d5             	movzbl %ch,%edx
   14cb0:	c1 e9 10             	shr    $0x10,%ecx
   14cb3:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
   14cb6:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   14cbd:	0f b6 d1             	movzbl %cl,%edx
   14cc0:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
   14cc3:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   14cca:	0f b6 d5             	movzbl %ch,%edx
   14ccd:	89 d9                	mov    %ebx,%ecx
   14ccf:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
   14cd2:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   14cd9:	0f b6 d1             	movzbl %cl,%edx
   14cdc:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   14ce3:	0f b6 d5             	movzbl %ch,%edx
   14ce6:	c1 e9 10             	shr    $0x10,%ecx
   14ce9:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   14cf0:	0f b6 d1             	movzbl %cl,%edx
   14cf3:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   14cfa:	0f b6 d5             	movzbl %ch,%edx
   14cfd:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   14d04:	8b 0c 24             	mov    (%esp,1),%ecx
   14d07:	0f b6 d1             	movzbl %cl,%edx
   14d0a:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   14d11:	0f b6 d5             	movzbl %ch,%edx
   14d14:	c1 e9 10             	shr    $0x10,%ecx
   14d17:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   14d1e:	0f b6 d1             	movzbl %cl,%edx
   14d21:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   14d28:	0f b6 d5             	movzbl %ch,%edx
   14d2b:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   14d32:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   14d36:	0f b6 d1             	movzbl %cl,%edx
   14d39:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   14d40:	0f b6 d5             	movzbl %ch,%edx
   14d43:	c1 e9 10             	shr    $0x10,%ecx
   14d46:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   14d4d:	0f b6 d1             	movzbl %cl,%edx
   14d50:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   14d57:	0f b6 d5             	movzbl %ch,%edx
   14d5a:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   14d61:	89 c1                	mov    %eax,%ecx
   14d63:	89 34 24             	mov    %esi,(%esp,1)
   14d66:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   14d6a:	0f b6 d1             	movzbl %cl,%edx
   14d6d:	8b 45 00             	mov    0x0(%ebp),%eax
   14d70:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   14d77:	0f b6 d5             	movzbl %ch,%edx
   14d7a:	c1 e9 10             	shr    $0x10,%ecx
   14d7d:	8b 7d 0c             	mov    0xc(%ebp),%edi
   14d80:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   14d87:	0f b6 d1             	movzbl %cl,%edx
   14d8a:	8b 75 08             	mov    0x8(%ebp),%esi
   14d8d:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   14d94:	0f b6 d5             	movzbl %ch,%edx
   14d97:	89 d9                	mov    %ebx,%ecx
   14d99:	8b 5d 04             	mov    0x4(%ebp),%ebx
   14d9c:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   14da3:	0f b6 d1             	movzbl %cl,%edx
   14da6:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   14dad:	0f b6 d5             	movzbl %ch,%edx
   14db0:	c1 e9 10             	shr    $0x10,%ecx
   14db3:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   14dba:	0f b6 d1             	movzbl %cl,%edx
   14dbd:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   14dc4:	0f b6 d5             	movzbl %ch,%edx
   14dc7:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   14dce:	8b 0c 24             	mov    (%esp,1),%ecx
   14dd1:	0f b6 d1             	movzbl %cl,%edx
   14dd4:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   14ddb:	0f b6 d5             	movzbl %ch,%edx
   14dde:	c1 e9 10             	shr    $0x10,%ecx
   14de1:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   14de8:	0f b6 d1             	movzbl %cl,%edx
   14deb:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   14df2:	0f b6 d5             	movzbl %ch,%edx
   14df5:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   14dfc:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   14e00:	0f b6 d1             	movzbl %cl,%edx
   14e03:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   14e0a:	0f b6 d5             	movzbl %ch,%edx
   14e0d:	c1 e9 10             	shr    $0x10,%ecx
   14e10:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   14e17:	0f b6 d1             	movzbl %cl,%edx
   14e1a:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   14e21:	0f b6 d5             	movzbl %ch,%edx
   14e24:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   14e2b:	89 c1                	mov    %eax,%ecx
   14e2d:	89 34 24             	mov    %esi,(%esp,1)
   14e30:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   14e34:	0f b6 d1             	movzbl %cl,%edx
   14e37:	8b 45 10             	mov    0x10(%ebp),%eax
   14e3a:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   14e41:	0f b6 d5             	movzbl %ch,%edx
   14e44:	c1 e9 10             	shr    $0x10,%ecx
   14e47:	8b 7d 1c             	mov    0x1c(%ebp),%edi
   14e4a:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   14e51:	0f b6 d1             	movzbl %cl,%edx
   14e54:	8b 75 18             	mov    0x18(%ebp),%esi
   14e57:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   14e5e:	0f b6 d5             	movzbl %ch,%edx
   14e61:	89 d9                	mov    %ebx,%ecx
   14e63:	8b 5d 14             	mov    0x14(%ebp),%ebx
   14e66:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   14e6d:	0f b6 d1             	movzbl %cl,%edx
   14e70:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   14e77:	0f b6 d5             	movzbl %ch,%edx
   14e7a:	c1 e9 10             	shr    $0x10,%ecx
   14e7d:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   14e84:	0f b6 d1             	movzbl %cl,%edx
   14e87:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   14e8e:	0f b6 d5             	movzbl %ch,%edx
   14e91:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   14e98:	8b 0c 24             	mov    (%esp,1),%ecx
   14e9b:	0f b6 d1             	movzbl %cl,%edx
   14e9e:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   14ea5:	0f b6 d5             	movzbl %ch,%edx
   14ea8:	c1 e9 10             	shr    $0x10,%ecx
   14eab:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   14eb2:	0f b6 d1             	movzbl %cl,%edx
   14eb5:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   14ebc:	0f b6 d5             	movzbl %ch,%edx
   14ebf:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   14ec6:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   14eca:	0f b6 d1             	movzbl %cl,%edx
   14ecd:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   14ed4:	0f b6 d5             	movzbl %ch,%edx
   14ed7:	c1 e9 10             	shr    $0x10,%ecx
   14eda:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   14ee1:	0f b6 d1             	movzbl %cl,%edx
   14ee4:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   14eeb:	0f b6 d5             	movzbl %ch,%edx
   14eee:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   14ef5:	89 c1                	mov    %eax,%ecx
   14ef7:	89 34 24             	mov    %esi,(%esp,1)
   14efa:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   14efe:	0f b6 d1             	movzbl %cl,%edx
   14f01:	8b 45 20             	mov    0x20(%ebp),%eax
   14f04:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   14f0b:	0f b6 d5             	movzbl %ch,%edx
   14f0e:	c1 e9 10             	shr    $0x10,%ecx
   14f11:	8b 7d 2c             	mov    0x2c(%ebp),%edi
   14f14:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   14f1b:	0f b6 d1             	movzbl %cl,%edx
   14f1e:	8b 75 28             	mov    0x28(%ebp),%esi
   14f21:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   14f28:	0f b6 d5             	movzbl %ch,%edx
   14f2b:	89 d9                	mov    %ebx,%ecx
   14f2d:	8b 5d 24             	mov    0x24(%ebp),%ebx
   14f30:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   14f37:	0f b6 d1             	movzbl %cl,%edx
   14f3a:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   14f41:	0f b6 d5             	movzbl %ch,%edx
   14f44:	c1 e9 10             	shr    $0x10,%ecx
   14f47:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   14f4e:	0f b6 d1             	movzbl %cl,%edx
   14f51:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   14f58:	0f b6 d5             	movzbl %ch,%edx
   14f5b:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   14f62:	8b 0c 24             	mov    (%esp,1),%ecx
   14f65:	0f b6 d1             	movzbl %cl,%edx
   14f68:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   14f6f:	0f b6 d5             	movzbl %ch,%edx
   14f72:	c1 e9 10             	shr    $0x10,%ecx
   14f75:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   14f7c:	0f b6 d1             	movzbl %cl,%edx
   14f7f:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   14f86:	0f b6 d5             	movzbl %ch,%edx
   14f89:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   14f90:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   14f94:	0f b6 d1             	movzbl %cl,%edx
   14f97:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   14f9e:	0f b6 d5             	movzbl %ch,%edx
   14fa1:	c1 e9 10             	shr    $0x10,%ecx
   14fa4:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   14fab:	0f b6 d1             	movzbl %cl,%edx
   14fae:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   14fb5:	0f b6 d5             	movzbl %ch,%edx
   14fb8:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   14fbf:	89 c1                	mov    %eax,%ecx
   14fc1:	89 34 24             	mov    %esi,(%esp,1)
   14fc4:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   14fc8:	0f b6 d1             	movzbl %cl,%edx
   14fcb:	8b 45 30             	mov    0x30(%ebp),%eax
   14fce:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   14fd5:	0f b6 d5             	movzbl %ch,%edx
   14fd8:	c1 e9 10             	shr    $0x10,%ecx
   14fdb:	8b 7d 3c             	mov    0x3c(%ebp),%edi
   14fde:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   14fe5:	0f b6 d1             	movzbl %cl,%edx
   14fe8:	8b 75 38             	mov    0x38(%ebp),%esi
   14feb:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   14ff2:	0f b6 d5             	movzbl %ch,%edx
   14ff5:	89 d9                	mov    %ebx,%ecx
   14ff7:	8b 5d 34             	mov    0x34(%ebp),%ebx
   14ffa:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   15001:	0f b6 d1             	movzbl %cl,%edx
   15004:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1500b:	0f b6 d5             	movzbl %ch,%edx
   1500e:	c1 e9 10             	shr    $0x10,%ecx
   15011:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   15018:	0f b6 d1             	movzbl %cl,%edx
   1501b:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   15022:	0f b6 d5             	movzbl %ch,%edx
   15025:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1502c:	8b 0c 24             	mov    (%esp,1),%ecx
   1502f:	0f b6 d1             	movzbl %cl,%edx
   15032:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   15039:	0f b6 d5             	movzbl %ch,%edx
   1503c:	c1 e9 10             	shr    $0x10,%ecx
   1503f:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   15046:	0f b6 d1             	movzbl %cl,%edx
   15049:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   15050:	0f b6 d5             	movzbl %ch,%edx
   15053:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1505a:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1505e:	0f b6 d1             	movzbl %cl,%edx
   15061:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   15068:	0f b6 d5             	movzbl %ch,%edx
   1506b:	c1 e9 10             	shr    $0x10,%ecx
   1506e:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   15075:	0f b6 d1             	movzbl %cl,%edx
   15078:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1507f:	0f b6 d5             	movzbl %ch,%edx
   15082:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   15089:	89 c1                	mov    %eax,%ecx
   1508b:	89 34 24             	mov    %esi,(%esp,1)
   1508e:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   15092:	0f b6 d1             	movzbl %cl,%edx
   15095:	8b 45 40             	mov    0x40(%ebp),%eax
   15098:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1509f:	0f b6 d5             	movzbl %ch,%edx
   150a2:	c1 e9 10             	shr    $0x10,%ecx
   150a5:	8b 7d 4c             	mov    0x4c(%ebp),%edi
   150a8:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   150af:	0f b6 d1             	movzbl %cl,%edx
   150b2:	8b 75 48             	mov    0x48(%ebp),%esi
   150b5:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   150bc:	0f b6 d5             	movzbl %ch,%edx
   150bf:	89 d9                	mov    %ebx,%ecx
   150c1:	8b 5d 44             	mov    0x44(%ebp),%ebx
   150c4:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   150cb:	0f b6 d1             	movzbl %cl,%edx
   150ce:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   150d5:	0f b6 d5             	movzbl %ch,%edx
   150d8:	c1 e9 10             	shr    $0x10,%ecx
   150db:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   150e2:	0f b6 d1             	movzbl %cl,%edx
   150e5:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   150ec:	0f b6 d5             	movzbl %ch,%edx
   150ef:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   150f6:	8b 0c 24             	mov    (%esp,1),%ecx
   150f9:	0f b6 d1             	movzbl %cl,%edx
   150fc:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   15103:	0f b6 d5             	movzbl %ch,%edx
   15106:	c1 e9 10             	shr    $0x10,%ecx
   15109:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   15110:	0f b6 d1             	movzbl %cl,%edx
   15113:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1511a:	0f b6 d5             	movzbl %ch,%edx
   1511d:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   15124:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   15128:	0f b6 d1             	movzbl %cl,%edx
   1512b:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   15132:	0f b6 d5             	movzbl %ch,%edx
   15135:	c1 e9 10             	shr    $0x10,%ecx
   15138:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1513f:	0f b6 d1             	movzbl %cl,%edx
   15142:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   15149:	0f b6 d5             	movzbl %ch,%edx
   1514c:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   15153:	89 c1                	mov    %eax,%ecx
   15155:	89 34 24             	mov    %esi,(%esp,1)
   15158:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1515c:	0f b6 d1             	movzbl %cl,%edx
   1515f:	8b 45 50             	mov    0x50(%ebp),%eax
   15162:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   15169:	0f b6 d5             	movzbl %ch,%edx
   1516c:	c1 e9 10             	shr    $0x10,%ecx
   1516f:	8b 7d 5c             	mov    0x5c(%ebp),%edi
   15172:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   15179:	0f b6 d1             	movzbl %cl,%edx
   1517c:	8b 75 58             	mov    0x58(%ebp),%esi
   1517f:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   15186:	0f b6 d5             	movzbl %ch,%edx
   15189:	89 d9                	mov    %ebx,%ecx
   1518b:	8b 5d 54             	mov    0x54(%ebp),%ebx
   1518e:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   15195:	0f b6 d1             	movzbl %cl,%edx
   15198:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1519f:	0f b6 d5             	movzbl %ch,%edx
   151a2:	c1 e9 10             	shr    $0x10,%ecx
   151a5:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   151ac:	0f b6 d1             	movzbl %cl,%edx
   151af:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   151b6:	0f b6 d5             	movzbl %ch,%edx
   151b9:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   151c0:	8b 0c 24             	mov    (%esp,1),%ecx
   151c3:	0f b6 d1             	movzbl %cl,%edx
   151c6:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   151cd:	0f b6 d5             	movzbl %ch,%edx
   151d0:	c1 e9 10             	shr    $0x10,%ecx
   151d3:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   151da:	0f b6 d1             	movzbl %cl,%edx
   151dd:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   151e4:	0f b6 d5             	movzbl %ch,%edx
   151e7:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   151ee:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   151f2:	0f b6 d1             	movzbl %cl,%edx
   151f5:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   151fc:	0f b6 d5             	movzbl %ch,%edx
   151ff:	c1 e9 10             	shr    $0x10,%ecx
   15202:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   15209:	0f b6 d1             	movzbl %cl,%edx
   1520c:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   15213:	0f b6 d5             	movzbl %ch,%edx
   15216:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1521d:	89 c1                	mov    %eax,%ecx
   1521f:	89 34 24             	mov    %esi,(%esp,1)
   15222:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   15226:	0f b6 d1             	movzbl %cl,%edx
   15229:	8b 45 60             	mov    0x60(%ebp),%eax
   1522c:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   15233:	0f b6 d5             	movzbl %ch,%edx
   15236:	c1 e9 10             	shr    $0x10,%ecx
   15239:	8b 7d 6c             	mov    0x6c(%ebp),%edi
   1523c:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   15243:	0f b6 d1             	movzbl %cl,%edx
   15246:	8b 75 68             	mov    0x68(%ebp),%esi
   15249:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   15250:	0f b6 d5             	movzbl %ch,%edx
   15253:	89 d9                	mov    %ebx,%ecx
   15255:	8b 5d 64             	mov    0x64(%ebp),%ebx
   15258:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1525f:	0f b6 d1             	movzbl %cl,%edx
   15262:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   15269:	0f b6 d5             	movzbl %ch,%edx
   1526c:	c1 e9 10             	shr    $0x10,%ecx
   1526f:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   15276:	0f b6 d1             	movzbl %cl,%edx
   15279:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   15280:	0f b6 d5             	movzbl %ch,%edx
   15283:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1528a:	8b 0c 24             	mov    (%esp,1),%ecx
   1528d:	0f b6 d1             	movzbl %cl,%edx
   15290:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   15297:	0f b6 d5             	movzbl %ch,%edx
   1529a:	c1 e9 10             	shr    $0x10,%ecx
   1529d:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   152a4:	0f b6 d1             	movzbl %cl,%edx
   152a7:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   152ae:	0f b6 d5             	movzbl %ch,%edx
   152b1:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   152b8:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   152bc:	0f b6 d1             	movzbl %cl,%edx
   152bf:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   152c6:	0f b6 d5             	movzbl %ch,%edx
   152c9:	c1 e9 10             	shr    $0x10,%ecx
   152cc:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   152d3:	0f b6 d1             	movzbl %cl,%edx
   152d6:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   152dd:	0f b6 d5             	movzbl %ch,%edx
   152e0:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   152e7:	89 c1                	mov    %eax,%ecx
   152e9:	89 34 24             	mov    %esi,(%esp,1)
   152ec:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   152f0:	0f b6 d1             	movzbl %cl,%edx
   152f3:	8b 45 70             	mov    0x70(%ebp),%eax
   152f6:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   152fd:	0f b6 d5             	movzbl %ch,%edx
   15300:	c1 e9 10             	shr    $0x10,%ecx
   15303:	8b 7d 7c             	mov    0x7c(%ebp),%edi
   15306:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1530d:	0f b6 d1             	movzbl %cl,%edx
   15310:	8b 75 78             	mov    0x78(%ebp),%esi
   15313:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1531a:	0f b6 d5             	movzbl %ch,%edx
   1531d:	89 d9                	mov    %ebx,%ecx
   1531f:	8b 5d 74             	mov    0x74(%ebp),%ebx
   15322:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   15329:	0f b6 d1             	movzbl %cl,%edx
   1532c:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   15333:	0f b6 d5             	movzbl %ch,%edx
   15336:	c1 e9 10             	shr    $0x10,%ecx
   15339:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   15340:	0f b6 d1             	movzbl %cl,%edx
   15343:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1534a:	0f b6 d5             	movzbl %ch,%edx
   1534d:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   15354:	8b 0c 24             	mov    (%esp,1),%ecx
   15357:	0f b6 d1             	movzbl %cl,%edx
   1535a:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   15361:	0f b6 d5             	movzbl %ch,%edx
   15364:	c1 e9 10             	shr    $0x10,%ecx
   15367:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1536e:	0f b6 d1             	movzbl %cl,%edx
   15371:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   15378:	0f b6 d5             	movzbl %ch,%edx
   1537b:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   15382:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   15386:	0f b6 d1             	movzbl %cl,%edx
   15389:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   15390:	0f b6 d5             	movzbl %ch,%edx
   15393:	c1 e9 10             	shr    $0x10,%ecx
   15396:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1539d:	0f b6 d1             	movzbl %cl,%edx
   153a0:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   153a7:	0f b6 d5             	movzbl %ch,%edx
   153aa:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   153b1:	89 c1                	mov    %eax,%ecx
   153b3:	89 34 24             	mov    %esi,(%esp,1)
   153b6:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   153ba:	0f b6 d1             	movzbl %cl,%edx
   153bd:	8b 85 80 00 00 00    	mov    0x80(%ebp),%eax
   153c3:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   153ca:	0f b6 d5             	movzbl %ch,%edx
   153cd:	c1 e9 10             	shr    $0x10,%ecx
   153d0:	8b bd 8c 00 00 00    	mov    0x8c(%ebp),%edi
   153d6:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   153dd:	0f b6 d1             	movzbl %cl,%edx
   153e0:	8b b5 88 00 00 00    	mov    0x88(%ebp),%esi
   153e6:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   153ed:	0f b6 d5             	movzbl %ch,%edx
   153f0:	89 d9                	mov    %ebx,%ecx
   153f2:	8b 9d 84 00 00 00    	mov    0x84(%ebp),%ebx
   153f8:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   153ff:	0f b6 d1             	movzbl %cl,%edx
   15402:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   15409:	0f b6 d5             	movzbl %ch,%edx
   1540c:	c1 e9 10             	shr    $0x10,%ecx
   1540f:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   15416:	0f b6 d1             	movzbl %cl,%edx
   15419:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   15420:	0f b6 d5             	movzbl %ch,%edx
   15423:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1542a:	8b 0c 24             	mov    (%esp,1),%ecx
   1542d:	0f b6 d1             	movzbl %cl,%edx
   15430:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   15437:	0f b6 d5             	movzbl %ch,%edx
   1543a:	c1 e9 10             	shr    $0x10,%ecx
   1543d:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   15444:	0f b6 d1             	movzbl %cl,%edx
   15447:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1544e:	0f b6 d5             	movzbl %ch,%edx
   15451:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   15458:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1545c:	0f b6 d1             	movzbl %cl,%edx
   1545f:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   15466:	0f b6 d5             	movzbl %ch,%edx
   15469:	c1 e9 10             	shr    $0x10,%ecx
   1546c:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   15473:	0f b6 d1             	movzbl %cl,%edx
   15476:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1547d:	0f b6 d5             	movzbl %ch,%edx
   15480:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   15487:	89 c1                	mov    %eax,%ecx
   15489:	89 34 24             	mov    %esi,(%esp,1)
   1548c:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   15490:	0f b6 d1             	movzbl %cl,%edx
   15493:	8b 85 90 00 00 00    	mov    0x90(%ebp),%eax
   15499:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   154a0:	0f b6 d5             	movzbl %ch,%edx
   154a3:	c1 e9 10             	shr    $0x10,%ecx
   154a6:	8b bd 9c 00 00 00    	mov    0x9c(%ebp),%edi
   154ac:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   154b3:	0f b6 d1             	movzbl %cl,%edx
   154b6:	8b b5 98 00 00 00    	mov    0x98(%ebp),%esi
   154bc:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   154c3:	0f b6 d5             	movzbl %ch,%edx
   154c6:	89 d9                	mov    %ebx,%ecx
   154c8:	8b 9d 94 00 00 00    	mov    0x94(%ebp),%ebx
   154ce:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   154d5:	0f b6 d1             	movzbl %cl,%edx
   154d8:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   154df:	0f b6 d5             	movzbl %ch,%edx
   154e2:	c1 e9 10             	shr    $0x10,%ecx
   154e5:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   154ec:	0f b6 d1             	movzbl %cl,%edx
   154ef:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   154f6:	0f b6 d5             	movzbl %ch,%edx
   154f9:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   15500:	8b 0c 24             	mov    (%esp,1),%ecx
   15503:	0f b6 d1             	movzbl %cl,%edx
   15506:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1550d:	0f b6 d5             	movzbl %ch,%edx
   15510:	c1 e9 10             	shr    $0x10,%ecx
   15513:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1551a:	0f b6 d1             	movzbl %cl,%edx
   1551d:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   15524:	0f b6 d5             	movzbl %ch,%edx
   15527:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1552e:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   15532:	0f b6 d1             	movzbl %cl,%edx
   15535:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1553c:	0f b6 d5             	movzbl %ch,%edx
   1553f:	c1 e9 10             	shr    $0x10,%ecx
   15542:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   15549:	0f b6 d1             	movzbl %cl,%edx
   1554c:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   15553:	0f b6 d5             	movzbl %ch,%edx
   15556:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1555d:	89 c1                	mov    %eax,%ecx
   1555f:	89 34 24             	mov    %esi,(%esp,1)
   15562:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   15566:	0f b6 d1             	movzbl %cl,%edx
   15569:	8b 85 a0 00 00 00    	mov    0xa0(%ebp),%eax
   1556f:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   15576:	0f b6 d5             	movzbl %ch,%edx
   15579:	c1 e9 10             	shr    $0x10,%ecx
   1557c:	8b bd ac 00 00 00    	mov    0xac(%ebp),%edi
   15582:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   15589:	0f b6 d1             	movzbl %cl,%edx
   1558c:	8b b5 a8 00 00 00    	mov    0xa8(%ebp),%esi
   15592:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   15599:	0f b6 d5             	movzbl %ch,%edx
   1559c:	89 d9                	mov    %ebx,%ecx
   1559e:	8b 9d a4 00 00 00    	mov    0xa4(%ebp),%ebx
   155a4:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   155ab:	0f b6 d1             	movzbl %cl,%edx
   155ae:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   155b5:	0f b6 d5             	movzbl %ch,%edx
   155b8:	c1 e9 10             	shr    $0x10,%ecx
   155bb:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   155c2:	0f b6 d1             	movzbl %cl,%edx
   155c5:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   155cc:	0f b6 d5             	movzbl %ch,%edx
   155cf:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   155d6:	8b 0c 24             	mov    (%esp,1),%ecx
   155d9:	0f b6 d1             	movzbl %cl,%edx
   155dc:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   155e3:	0f b6 d5             	movzbl %ch,%edx
   155e6:	c1 e9 10             	shr    $0x10,%ecx
   155e9:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   155f0:	0f b6 d1             	movzbl %cl,%edx
   155f3:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   155fa:	0f b6 d5             	movzbl %ch,%edx
   155fd:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   15604:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   15608:	0f b6 d1             	movzbl %cl,%edx
   1560b:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   15612:	0f b6 d5             	movzbl %ch,%edx
   15615:	c1 e9 10             	shr    $0x10,%ecx
   15618:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1561f:	0f b6 d1             	movzbl %cl,%edx
   15622:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   15629:	0f b6 d5             	movzbl %ch,%edx
   1562c:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   15633:	8b 6c 24 20          	mov    0x20(%esp,1),%ebp
   15637:	89 7d 0c             	mov    %edi,0xc(%ebp)
   1563a:	89 75 08             	mov    %esi,0x8(%ebp)
   1563d:	89 5d 04             	mov    %ebx,0x4(%ebp)
   15640:	89 45 00             	mov    %eax,0x0(%ebp)
   15643:	31 c0                	xor    %eax,%eax
   15645:	8b 6c 24 14          	mov    0x14(%esp,1),%ebp
   15649:	8b 5c 24 10          	mov    0x10(%esp,1),%ebx
   1564d:	8b 74 24 0c          	mov    0xc(%esp,1),%esi
   15651:	8b 7c 24 08          	mov    0x8(%esp,1),%edi
   15655:	8d 64 24 18          	lea    0x18(%esp,1),%esp
   15659:	c3                   	ret    
   1565a:	83 ec 18             	sub    $0x18,%esp
   1565d:	89 6c 24 14          	mov    %ebp,0x14(%esp,1)
   15661:	89 5c 24 10          	mov    %ebx,0x10(%esp,1)
   15665:	89 74 24 0c          	mov    %esi,0xc(%esp,1)
   15669:	89 7c 24 08          	mov    %edi,0x8(%esp,1)
   1566d:	8b 4c 24 1c          	mov    0x1c(%esp,1),%ecx
   15671:	8b 6c 24 24          	mov    0x24(%esp,1),%ebp
   15675:	8b 01                	mov    (%ecx),%eax
   15677:	8b 59 04             	mov    0x4(%ecx),%ebx
   1567a:	8b 71 08             	mov    0x8(%ecx),%esi
   1567d:	8b 79 0c             	mov    0xc(%ecx),%edi
   15680:	8b 8d f0 00 00 00    	mov    0xf0(%ebp),%ecx
   15686:	8d 14 8d 00 00 00 00 	lea    0x0(,%ecx,4),%edx
   1568d:	8d 54 95 00          	lea    0x0(%ebp,%edx,4),%edx
   15691:	33 02                	xor    (%edx),%eax
   15693:	33 5a 04             	xor    0x4(%edx),%ebx
   15696:	33 72 08             	xor    0x8(%edx),%esi
   15699:	33 7a 0c             	xor    0xc(%edx),%edi
   1569c:	83 f9 0a             	cmp    $0xa,%ecx
   1569f:	0f 84 70 03 00 00    	je     15a15 <end+0xf71>
   156a5:	83 f9 0c             	cmp    $0xc,%ecx
   156a8:	0f 84 bb 01 00 00    	je     15869 <end+0xdc5>
   156ae:	83 f9 0e             	cmp    $0xe,%ecx
   156b1:	74 0a                	je     156bd <end+0xc19>
   156b3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   156b8:	e9 66 0b 00 00       	jmp    16223 <end+0x177f>
   156bd:	89 c1                	mov    %eax,%ecx
   156bf:	89 1c 24             	mov    %ebx,(%esp,1)
   156c2:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   156c6:	0f b6 d1             	movzbl %cl,%edx
   156c9:	8b 85 d0 00 00 00    	mov    0xd0(%ebp),%eax
   156cf:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   156d6:	0f b6 d5             	movzbl %ch,%edx
   156d9:	c1 e9 10             	shr    $0x10,%ecx
   156dc:	8b 9d d4 00 00 00    	mov    0xd4(%ebp),%ebx
   156e2:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   156e9:	0f b6 d1             	movzbl %cl,%edx
   156ec:	8b b5 d8 00 00 00    	mov    0xd8(%ebp),%esi
   156f2:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   156f9:	0f b6 d5             	movzbl %ch,%edx
   156fc:	89 f9                	mov    %edi,%ecx
   156fe:	8b bd dc 00 00 00    	mov    0xdc(%ebp),%edi
   15704:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1570b:	0f b6 d1             	movzbl %cl,%edx
   1570e:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   15715:	0f b6 d5             	movzbl %ch,%edx
   15718:	c1 e9 10             	shr    $0x10,%ecx
   1571b:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   15722:	0f b6 d1             	movzbl %cl,%edx
   15725:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1572c:	0f b6 d5             	movzbl %ch,%edx
   1572f:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   15736:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1573a:	0f b6 d1             	movzbl %cl,%edx
   1573d:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   15744:	0f b6 d5             	movzbl %ch,%edx
   15747:	c1 e9 10             	shr    $0x10,%ecx
   1574a:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   15751:	0f b6 d1             	movzbl %cl,%edx
   15754:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1575b:	0f b6 d5             	movzbl %ch,%edx
   1575e:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   15765:	8b 0c 24             	mov    (%esp,1),%ecx
   15768:	0f b6 d1             	movzbl %cl,%edx
   1576b:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   15772:	0f b6 d5             	movzbl %ch,%edx
   15775:	c1 e9 10             	shr    $0x10,%ecx
   15778:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1577f:	0f b6 d1             	movzbl %cl,%edx
   15782:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   15789:	0f b6 d5             	movzbl %ch,%edx
   1578c:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   15793:	89 c1                	mov    %eax,%ecx
   15795:	89 1c 24             	mov    %ebx,(%esp,1)
   15798:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   1579c:	0f b6 d1             	movzbl %cl,%edx
   1579f:	8b 85 c0 00 00 00    	mov    0xc0(%ebp),%eax
   157a5:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   157ac:	0f b6 d5             	movzbl %ch,%edx
   157af:	c1 e9 10             	shr    $0x10,%ecx
   157b2:	8b 9d c4 00 00 00    	mov    0xc4(%ebp),%ebx
   157b8:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   157bf:	0f b6 d1             	movzbl %cl,%edx
   157c2:	8b b5 c8 00 00 00    	mov    0xc8(%ebp),%esi
   157c8:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   157cf:	0f b6 d5             	movzbl %ch,%edx
   157d2:	89 f9                	mov    %edi,%ecx
   157d4:	8b bd cc 00 00 00    	mov    0xcc(%ebp),%edi
   157da:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   157e1:	0f b6 d1             	movzbl %cl,%edx
   157e4:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   157eb:	0f b6 d5             	movzbl %ch,%edx
   157ee:	c1 e9 10             	shr    $0x10,%ecx
   157f1:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   157f8:	0f b6 d1             	movzbl %cl,%edx
   157fb:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   15802:	0f b6 d5             	movzbl %ch,%edx
   15805:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1580c:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   15810:	0f b6 d1             	movzbl %cl,%edx
   15813:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1581a:	0f b6 d5             	movzbl %ch,%edx
   1581d:	c1 e9 10             	shr    $0x10,%ecx
   15820:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   15827:	0f b6 d1             	movzbl %cl,%edx
   1582a:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   15831:	0f b6 d5             	movzbl %ch,%edx
   15834:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1583b:	8b 0c 24             	mov    (%esp,1),%ecx
   1583e:	0f b6 d1             	movzbl %cl,%edx
   15841:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   15848:	0f b6 d5             	movzbl %ch,%edx
   1584b:	c1 e9 10             	shr    $0x10,%ecx
   1584e:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   15855:	0f b6 d1             	movzbl %cl,%edx
   15858:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1585f:	0f b6 d5             	movzbl %ch,%edx
   15862:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   15869:	89 c1                	mov    %eax,%ecx
   1586b:	89 1c 24             	mov    %ebx,(%esp,1)
   1586e:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   15872:	0f b6 d1             	movzbl %cl,%edx
   15875:	8b 85 b0 00 00 00    	mov    0xb0(%ebp),%eax
   1587b:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   15882:	0f b6 d5             	movzbl %ch,%edx
   15885:	c1 e9 10             	shr    $0x10,%ecx
   15888:	8b 9d b4 00 00 00    	mov    0xb4(%ebp),%ebx
   1588e:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   15895:	0f b6 d1             	movzbl %cl,%edx
   15898:	8b b5 b8 00 00 00    	mov    0xb8(%ebp),%esi
   1589e:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   158a5:	0f b6 d5             	movzbl %ch,%edx
   158a8:	89 f9                	mov    %edi,%ecx
   158aa:	8b bd bc 00 00 00    	mov    0xbc(%ebp),%edi
   158b0:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   158b7:	0f b6 d1             	movzbl %cl,%edx
   158ba:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   158c1:	0f b6 d5             	movzbl %ch,%edx
   158c4:	c1 e9 10             	shr    $0x10,%ecx
   158c7:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   158ce:	0f b6 d1             	movzbl %cl,%edx
   158d1:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   158d8:	0f b6 d5             	movzbl %ch,%edx
   158db:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   158e2:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   158e6:	0f b6 d1             	movzbl %cl,%edx
   158e9:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   158f0:	0f b6 d5             	movzbl %ch,%edx
   158f3:	c1 e9 10             	shr    $0x10,%ecx
   158f6:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   158fd:	0f b6 d1             	movzbl %cl,%edx
   15900:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   15907:	0f b6 d5             	movzbl %ch,%edx
   1590a:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   15911:	8b 0c 24             	mov    (%esp,1),%ecx
   15914:	0f b6 d1             	movzbl %cl,%edx
   15917:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1591e:	0f b6 d5             	movzbl %ch,%edx
   15921:	c1 e9 10             	shr    $0x10,%ecx
   15924:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1592b:	0f b6 d1             	movzbl %cl,%edx
   1592e:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   15935:	0f b6 d5             	movzbl %ch,%edx
   15938:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1593f:	89 c1                	mov    %eax,%ecx
   15941:	89 1c 24             	mov    %ebx,(%esp,1)
   15944:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   15948:	0f b6 d1             	movzbl %cl,%edx
   1594b:	8b 85 a0 00 00 00    	mov    0xa0(%ebp),%eax
   15951:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   15958:	0f b6 d5             	movzbl %ch,%edx
   1595b:	c1 e9 10             	shr    $0x10,%ecx
   1595e:	8b 9d a4 00 00 00    	mov    0xa4(%ebp),%ebx
   15964:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1596b:	0f b6 d1             	movzbl %cl,%edx
   1596e:	8b b5 a8 00 00 00    	mov    0xa8(%ebp),%esi
   15974:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1597b:	0f b6 d5             	movzbl %ch,%edx
   1597e:	89 f9                	mov    %edi,%ecx
   15980:	8b bd ac 00 00 00    	mov    0xac(%ebp),%edi
   15986:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1598d:	0f b6 d1             	movzbl %cl,%edx
   15990:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   15997:	0f b6 d5             	movzbl %ch,%edx
   1599a:	c1 e9 10             	shr    $0x10,%ecx
   1599d:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   159a4:	0f b6 d1             	movzbl %cl,%edx
   159a7:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   159ae:	0f b6 d5             	movzbl %ch,%edx
   159b1:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   159b8:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   159bc:	0f b6 d1             	movzbl %cl,%edx
   159bf:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   159c6:	0f b6 d5             	movzbl %ch,%edx
   159c9:	c1 e9 10             	shr    $0x10,%ecx
   159cc:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   159d3:	0f b6 d1             	movzbl %cl,%edx
   159d6:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   159dd:	0f b6 d5             	movzbl %ch,%edx
   159e0:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   159e7:	8b 0c 24             	mov    (%esp,1),%ecx
   159ea:	0f b6 d1             	movzbl %cl,%edx
   159ed:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   159f4:	0f b6 d5             	movzbl %ch,%edx
   159f7:	c1 e9 10             	shr    $0x10,%ecx
   159fa:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   15a01:	0f b6 d1             	movzbl %cl,%edx
   15a04:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   15a0b:	0f b6 d5             	movzbl %ch,%edx
   15a0e:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   15a15:	89 c1                	mov    %eax,%ecx
   15a17:	89 1c 24             	mov    %ebx,(%esp,1)
   15a1a:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   15a1e:	0f b6 d1             	movzbl %cl,%edx
   15a21:	8b 85 90 00 00 00    	mov    0x90(%ebp),%eax
   15a27:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   15a2e:	0f b6 d5             	movzbl %ch,%edx
   15a31:	c1 e9 10             	shr    $0x10,%ecx
   15a34:	8b 9d 94 00 00 00    	mov    0x94(%ebp),%ebx
   15a3a:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   15a41:	0f b6 d1             	movzbl %cl,%edx
   15a44:	8b b5 98 00 00 00    	mov    0x98(%ebp),%esi
   15a4a:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   15a51:	0f b6 d5             	movzbl %ch,%edx
   15a54:	89 f9                	mov    %edi,%ecx
   15a56:	8b bd 9c 00 00 00    	mov    0x9c(%ebp),%edi
   15a5c:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   15a63:	0f b6 d1             	movzbl %cl,%edx
   15a66:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   15a6d:	0f b6 d5             	movzbl %ch,%edx
   15a70:	c1 e9 10             	shr    $0x10,%ecx
   15a73:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   15a7a:	0f b6 d1             	movzbl %cl,%edx
   15a7d:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   15a84:	0f b6 d5             	movzbl %ch,%edx
   15a87:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   15a8e:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   15a92:	0f b6 d1             	movzbl %cl,%edx
   15a95:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   15a9c:	0f b6 d5             	movzbl %ch,%edx
   15a9f:	c1 e9 10             	shr    $0x10,%ecx
   15aa2:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   15aa9:	0f b6 d1             	movzbl %cl,%edx
   15aac:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   15ab3:	0f b6 d5             	movzbl %ch,%edx
   15ab6:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   15abd:	8b 0c 24             	mov    (%esp,1),%ecx
   15ac0:	0f b6 d1             	movzbl %cl,%edx
   15ac3:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   15aca:	0f b6 d5             	movzbl %ch,%edx
   15acd:	c1 e9 10             	shr    $0x10,%ecx
   15ad0:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   15ad7:	0f b6 d1             	movzbl %cl,%edx
   15ada:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   15ae1:	0f b6 d5             	movzbl %ch,%edx
   15ae4:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   15aeb:	89 c1                	mov    %eax,%ecx
   15aed:	89 1c 24             	mov    %ebx,(%esp,1)
   15af0:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   15af4:	0f b6 d1             	movzbl %cl,%edx
   15af7:	8b 85 80 00 00 00    	mov    0x80(%ebp),%eax
   15afd:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   15b04:	0f b6 d5             	movzbl %ch,%edx
   15b07:	c1 e9 10             	shr    $0x10,%ecx
   15b0a:	8b 9d 84 00 00 00    	mov    0x84(%ebp),%ebx
   15b10:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   15b17:	0f b6 d1             	movzbl %cl,%edx
   15b1a:	8b b5 88 00 00 00    	mov    0x88(%ebp),%esi
   15b20:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   15b27:	0f b6 d5             	movzbl %ch,%edx
   15b2a:	89 f9                	mov    %edi,%ecx
   15b2c:	8b bd 8c 00 00 00    	mov    0x8c(%ebp),%edi
   15b32:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   15b39:	0f b6 d1             	movzbl %cl,%edx
   15b3c:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   15b43:	0f b6 d5             	movzbl %ch,%edx
   15b46:	c1 e9 10             	shr    $0x10,%ecx
   15b49:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   15b50:	0f b6 d1             	movzbl %cl,%edx
   15b53:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   15b5a:	0f b6 d5             	movzbl %ch,%edx
   15b5d:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   15b64:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   15b68:	0f b6 d1             	movzbl %cl,%edx
   15b6b:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   15b72:	0f b6 d5             	movzbl %ch,%edx
   15b75:	c1 e9 10             	shr    $0x10,%ecx
   15b78:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   15b7f:	0f b6 d1             	movzbl %cl,%edx
   15b82:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   15b89:	0f b6 d5             	movzbl %ch,%edx
   15b8c:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   15b93:	8b 0c 24             	mov    (%esp,1),%ecx
   15b96:	0f b6 d1             	movzbl %cl,%edx
   15b99:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   15ba0:	0f b6 d5             	movzbl %ch,%edx
   15ba3:	c1 e9 10             	shr    $0x10,%ecx
   15ba6:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   15bad:	0f b6 d1             	movzbl %cl,%edx
   15bb0:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   15bb7:	0f b6 d5             	movzbl %ch,%edx
   15bba:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   15bc1:	89 c1                	mov    %eax,%ecx
   15bc3:	89 1c 24             	mov    %ebx,(%esp,1)
   15bc6:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   15bca:	0f b6 d1             	movzbl %cl,%edx
   15bcd:	8b 45 70             	mov    0x70(%ebp),%eax
   15bd0:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   15bd7:	0f b6 d5             	movzbl %ch,%edx
   15bda:	c1 e9 10             	shr    $0x10,%ecx
   15bdd:	8b 5d 74             	mov    0x74(%ebp),%ebx
   15be0:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   15be7:	0f b6 d1             	movzbl %cl,%edx
   15bea:	8b 75 78             	mov    0x78(%ebp),%esi
   15bed:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   15bf4:	0f b6 d5             	movzbl %ch,%edx
   15bf7:	89 f9                	mov    %edi,%ecx
   15bf9:	8b 7d 7c             	mov    0x7c(%ebp),%edi
   15bfc:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   15c03:	0f b6 d1             	movzbl %cl,%edx
   15c06:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   15c0d:	0f b6 d5             	movzbl %ch,%edx
   15c10:	c1 e9 10             	shr    $0x10,%ecx
   15c13:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   15c1a:	0f b6 d1             	movzbl %cl,%edx
   15c1d:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   15c24:	0f b6 d5             	movzbl %ch,%edx
   15c27:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   15c2e:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   15c32:	0f b6 d1             	movzbl %cl,%edx
   15c35:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   15c3c:	0f b6 d5             	movzbl %ch,%edx
   15c3f:	c1 e9 10             	shr    $0x10,%ecx
   15c42:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   15c49:	0f b6 d1             	movzbl %cl,%edx
   15c4c:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   15c53:	0f b6 d5             	movzbl %ch,%edx
   15c56:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   15c5d:	8b 0c 24             	mov    (%esp,1),%ecx
   15c60:	0f b6 d1             	movzbl %cl,%edx
   15c63:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   15c6a:	0f b6 d5             	movzbl %ch,%edx
   15c6d:	c1 e9 10             	shr    $0x10,%ecx
   15c70:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   15c77:	0f b6 d1             	movzbl %cl,%edx
   15c7a:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   15c81:	0f b6 d5             	movzbl %ch,%edx
   15c84:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   15c8b:	89 c1                	mov    %eax,%ecx
   15c8d:	89 1c 24             	mov    %ebx,(%esp,1)
   15c90:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   15c94:	0f b6 d1             	movzbl %cl,%edx
   15c97:	8b 45 60             	mov    0x60(%ebp),%eax
   15c9a:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   15ca1:	0f b6 d5             	movzbl %ch,%edx
   15ca4:	c1 e9 10             	shr    $0x10,%ecx
   15ca7:	8b 5d 64             	mov    0x64(%ebp),%ebx
   15caa:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   15cb1:	0f b6 d1             	movzbl %cl,%edx
   15cb4:	8b 75 68             	mov    0x68(%ebp),%esi
   15cb7:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   15cbe:	0f b6 d5             	movzbl %ch,%edx
   15cc1:	89 f9                	mov    %edi,%ecx
   15cc3:	8b 7d 6c             	mov    0x6c(%ebp),%edi
   15cc6:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   15ccd:	0f b6 d1             	movzbl %cl,%edx
   15cd0:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   15cd7:	0f b6 d5             	movzbl %ch,%edx
   15cda:	c1 e9 10             	shr    $0x10,%ecx
   15cdd:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   15ce4:	0f b6 d1             	movzbl %cl,%edx
   15ce7:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   15cee:	0f b6 d5             	movzbl %ch,%edx
   15cf1:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   15cf8:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   15cfc:	0f b6 d1             	movzbl %cl,%edx
   15cff:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   15d06:	0f b6 d5             	movzbl %ch,%edx
   15d09:	c1 e9 10             	shr    $0x10,%ecx
   15d0c:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   15d13:	0f b6 d1             	movzbl %cl,%edx
   15d16:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   15d1d:	0f b6 d5             	movzbl %ch,%edx
   15d20:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   15d27:	8b 0c 24             	mov    (%esp,1),%ecx
   15d2a:	0f b6 d1             	movzbl %cl,%edx
   15d2d:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   15d34:	0f b6 d5             	movzbl %ch,%edx
   15d37:	c1 e9 10             	shr    $0x10,%ecx
   15d3a:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   15d41:	0f b6 d1             	movzbl %cl,%edx
   15d44:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   15d4b:	0f b6 d5             	movzbl %ch,%edx
   15d4e:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   15d55:	89 c1                	mov    %eax,%ecx
   15d57:	89 1c 24             	mov    %ebx,(%esp,1)
   15d5a:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   15d5e:	0f b6 d1             	movzbl %cl,%edx
   15d61:	8b 45 50             	mov    0x50(%ebp),%eax
   15d64:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   15d6b:	0f b6 d5             	movzbl %ch,%edx
   15d6e:	c1 e9 10             	shr    $0x10,%ecx
   15d71:	8b 5d 54             	mov    0x54(%ebp),%ebx
   15d74:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   15d7b:	0f b6 d1             	movzbl %cl,%edx
   15d7e:	8b 75 58             	mov    0x58(%ebp),%esi
   15d81:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   15d88:	0f b6 d5             	movzbl %ch,%edx
   15d8b:	89 f9                	mov    %edi,%ecx
   15d8d:	8b 7d 5c             	mov    0x5c(%ebp),%edi
   15d90:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   15d97:	0f b6 d1             	movzbl %cl,%edx
   15d9a:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   15da1:	0f b6 d5             	movzbl %ch,%edx
   15da4:	c1 e9 10             	shr    $0x10,%ecx
   15da7:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   15dae:	0f b6 d1             	movzbl %cl,%edx
   15db1:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   15db8:	0f b6 d5             	movzbl %ch,%edx
   15dbb:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   15dc2:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   15dc6:	0f b6 d1             	movzbl %cl,%edx
   15dc9:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   15dd0:	0f b6 d5             	movzbl %ch,%edx
   15dd3:	c1 e9 10             	shr    $0x10,%ecx
   15dd6:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   15ddd:	0f b6 d1             	movzbl %cl,%edx
   15de0:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   15de7:	0f b6 d5             	movzbl %ch,%edx
   15dea:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   15df1:	8b 0c 24             	mov    (%esp,1),%ecx
   15df4:	0f b6 d1             	movzbl %cl,%edx
   15df7:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   15dfe:	0f b6 d5             	movzbl %ch,%edx
   15e01:	c1 e9 10             	shr    $0x10,%ecx
   15e04:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   15e0b:	0f b6 d1             	movzbl %cl,%edx
   15e0e:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   15e15:	0f b6 d5             	movzbl %ch,%edx
   15e18:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   15e1f:	89 c1                	mov    %eax,%ecx
   15e21:	89 1c 24             	mov    %ebx,(%esp,1)
   15e24:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   15e28:	0f b6 d1             	movzbl %cl,%edx
   15e2b:	8b 45 40             	mov    0x40(%ebp),%eax
   15e2e:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   15e35:	0f b6 d5             	movzbl %ch,%edx
   15e38:	c1 e9 10             	shr    $0x10,%ecx
   15e3b:	8b 5d 44             	mov    0x44(%ebp),%ebx
   15e3e:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   15e45:	0f b6 d1             	movzbl %cl,%edx
   15e48:	8b 75 48             	mov    0x48(%ebp),%esi
   15e4b:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   15e52:	0f b6 d5             	movzbl %ch,%edx
   15e55:	89 f9                	mov    %edi,%ecx
   15e57:	8b 7d 4c             	mov    0x4c(%ebp),%edi
   15e5a:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   15e61:	0f b6 d1             	movzbl %cl,%edx
   15e64:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   15e6b:	0f b6 d5             	movzbl %ch,%edx
   15e6e:	c1 e9 10             	shr    $0x10,%ecx
   15e71:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   15e78:	0f b6 d1             	movzbl %cl,%edx
   15e7b:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   15e82:	0f b6 d5             	movzbl %ch,%edx
   15e85:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   15e8c:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   15e90:	0f b6 d1             	movzbl %cl,%edx
   15e93:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   15e9a:	0f b6 d5             	movzbl %ch,%edx
   15e9d:	c1 e9 10             	shr    $0x10,%ecx
   15ea0:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   15ea7:	0f b6 d1             	movzbl %cl,%edx
   15eaa:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   15eb1:	0f b6 d5             	movzbl %ch,%edx
   15eb4:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   15ebb:	8b 0c 24             	mov    (%esp,1),%ecx
   15ebe:	0f b6 d1             	movzbl %cl,%edx
   15ec1:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   15ec8:	0f b6 d5             	movzbl %ch,%edx
   15ecb:	c1 e9 10             	shr    $0x10,%ecx
   15ece:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   15ed5:	0f b6 d1             	movzbl %cl,%edx
   15ed8:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   15edf:	0f b6 d5             	movzbl %ch,%edx
   15ee2:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   15ee9:	89 c1                	mov    %eax,%ecx
   15eeb:	89 1c 24             	mov    %ebx,(%esp,1)
   15eee:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   15ef2:	0f b6 d1             	movzbl %cl,%edx
   15ef5:	8b 45 30             	mov    0x30(%ebp),%eax
   15ef8:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   15eff:	0f b6 d5             	movzbl %ch,%edx
   15f02:	c1 e9 10             	shr    $0x10,%ecx
   15f05:	8b 5d 34             	mov    0x34(%ebp),%ebx
   15f08:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   15f0f:	0f b6 d1             	movzbl %cl,%edx
   15f12:	8b 75 38             	mov    0x38(%ebp),%esi
   15f15:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   15f1c:	0f b6 d5             	movzbl %ch,%edx
   15f1f:	89 f9                	mov    %edi,%ecx
   15f21:	8b 7d 3c             	mov    0x3c(%ebp),%edi
   15f24:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   15f2b:	0f b6 d1             	movzbl %cl,%edx
   15f2e:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   15f35:	0f b6 d5             	movzbl %ch,%edx
   15f38:	c1 e9 10             	shr    $0x10,%ecx
   15f3b:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   15f42:	0f b6 d1             	movzbl %cl,%edx
   15f45:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   15f4c:	0f b6 d5             	movzbl %ch,%edx
   15f4f:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   15f56:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   15f5a:	0f b6 d1             	movzbl %cl,%edx
   15f5d:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   15f64:	0f b6 d5             	movzbl %ch,%edx
   15f67:	c1 e9 10             	shr    $0x10,%ecx
   15f6a:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   15f71:	0f b6 d1             	movzbl %cl,%edx
   15f74:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   15f7b:	0f b6 d5             	movzbl %ch,%edx
   15f7e:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   15f85:	8b 0c 24             	mov    (%esp,1),%ecx
   15f88:	0f b6 d1             	movzbl %cl,%edx
   15f8b:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   15f92:	0f b6 d5             	movzbl %ch,%edx
   15f95:	c1 e9 10             	shr    $0x10,%ecx
   15f98:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   15f9f:	0f b6 d1             	movzbl %cl,%edx
   15fa2:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   15fa9:	0f b6 d5             	movzbl %ch,%edx
   15fac:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   15fb3:	89 c1                	mov    %eax,%ecx
   15fb5:	89 1c 24             	mov    %ebx,(%esp,1)
   15fb8:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   15fbc:	0f b6 d1             	movzbl %cl,%edx
   15fbf:	8b 45 20             	mov    0x20(%ebp),%eax
   15fc2:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   15fc9:	0f b6 d5             	movzbl %ch,%edx
   15fcc:	c1 e9 10             	shr    $0x10,%ecx
   15fcf:	8b 5d 24             	mov    0x24(%ebp),%ebx
   15fd2:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   15fd9:	0f b6 d1             	movzbl %cl,%edx
   15fdc:	8b 75 28             	mov    0x28(%ebp),%esi
   15fdf:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   15fe6:	0f b6 d5             	movzbl %ch,%edx
   15fe9:	89 f9                	mov    %edi,%ecx
   15feb:	8b 7d 2c             	mov    0x2c(%ebp),%edi
   15fee:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   15ff5:	0f b6 d1             	movzbl %cl,%edx
   15ff8:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   15fff:	0f b6 d5             	movzbl %ch,%edx
   16002:	c1 e9 10             	shr    $0x10,%ecx
   16005:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1600c:	0f b6 d1             	movzbl %cl,%edx
   1600f:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   16016:	0f b6 d5             	movzbl %ch,%edx
   16019:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   16020:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   16024:	0f b6 d1             	movzbl %cl,%edx
   16027:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1602e:	0f b6 d5             	movzbl %ch,%edx
   16031:	c1 e9 10             	shr    $0x10,%ecx
   16034:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1603b:	0f b6 d1             	movzbl %cl,%edx
   1603e:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   16045:	0f b6 d5             	movzbl %ch,%edx
   16048:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1604f:	8b 0c 24             	mov    (%esp,1),%ecx
   16052:	0f b6 d1             	movzbl %cl,%edx
   16055:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1605c:	0f b6 d5             	movzbl %ch,%edx
   1605f:	c1 e9 10             	shr    $0x10,%ecx
   16062:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   16069:	0f b6 d1             	movzbl %cl,%edx
   1606c:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   16073:	0f b6 d5             	movzbl %ch,%edx
   16076:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1607d:	89 c1                	mov    %eax,%ecx
   1607f:	89 1c 24             	mov    %ebx,(%esp,1)
   16082:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   16086:	0f b6 d1             	movzbl %cl,%edx
   16089:	8b 45 10             	mov    0x10(%ebp),%eax
   1608c:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   16093:	0f b6 d5             	movzbl %ch,%edx
   16096:	c1 e9 10             	shr    $0x10,%ecx
   16099:	8b 5d 14             	mov    0x14(%ebp),%ebx
   1609c:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   160a3:	0f b6 d1             	movzbl %cl,%edx
   160a6:	8b 75 18             	mov    0x18(%ebp),%esi
   160a9:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   160b0:	0f b6 d5             	movzbl %ch,%edx
   160b3:	89 f9                	mov    %edi,%ecx
   160b5:	8b 7d 1c             	mov    0x1c(%ebp),%edi
   160b8:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   160bf:	0f b6 d1             	movzbl %cl,%edx
   160c2:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   160c9:	0f b6 d5             	movzbl %ch,%edx
   160cc:	c1 e9 10             	shr    $0x10,%ecx
   160cf:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   160d6:	0f b6 d1             	movzbl %cl,%edx
   160d9:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   160e0:	0f b6 d5             	movzbl %ch,%edx
   160e3:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   160ea:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   160ee:	0f b6 d1             	movzbl %cl,%edx
   160f1:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   160f8:	0f b6 d5             	movzbl %ch,%edx
   160fb:	c1 e9 10             	shr    $0x10,%ecx
   160fe:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   16105:	0f b6 d1             	movzbl %cl,%edx
   16108:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1610f:	0f b6 d5             	movzbl %ch,%edx
   16112:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   16119:	8b 0c 24             	mov    (%esp,1),%ecx
   1611c:	0f b6 d1             	movzbl %cl,%edx
   1611f:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   16126:	0f b6 d5             	movzbl %ch,%edx
   16129:	c1 e9 10             	shr    $0x10,%ecx
   1612c:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   16133:	0f b6 d1             	movzbl %cl,%edx
   16136:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1613d:	0f b6 d5             	movzbl %ch,%edx
   16140:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   16147:	89 c1                	mov    %eax,%ecx
   16149:	89 1c 24             	mov    %ebx,(%esp,1)
   1614c:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   16150:	0f b6 d1             	movzbl %cl,%edx
   16153:	8b 45 00             	mov    0x0(%ebp),%eax
   16156:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1615d:	0f b6 d5             	movzbl %ch,%edx
   16160:	c1 e9 10             	shr    $0x10,%ecx
   16163:	8b 5d 04             	mov    0x4(%ebp),%ebx
   16166:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1616d:	0f b6 d1             	movzbl %cl,%edx
   16170:	8b 75 08             	mov    0x8(%ebp),%esi
   16173:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1617a:	0f b6 d5             	movzbl %ch,%edx
   1617d:	89 f9                	mov    %edi,%ecx
   1617f:	8b 7d 0c             	mov    0xc(%ebp),%edi
   16182:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   16189:	0f b6 d1             	movzbl %cl,%edx
   1618c:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   16193:	0f b6 d5             	movzbl %ch,%edx
   16196:	c1 e9 10             	shr    $0x10,%ecx
   16199:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   161a0:	0f b6 d1             	movzbl %cl,%edx
   161a3:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   161aa:	0f b6 d5             	movzbl %ch,%edx
   161ad:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   161b4:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   161b8:	0f b6 d1             	movzbl %cl,%edx
   161bb:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   161c2:	0f b6 d5             	movzbl %ch,%edx
   161c5:	c1 e9 10             	shr    $0x10,%ecx
   161c8:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   161cf:	0f b6 d1             	movzbl %cl,%edx
   161d2:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   161d9:	0f b6 d5             	movzbl %ch,%edx
   161dc:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   161e3:	8b 0c 24             	mov    (%esp,1),%ecx
   161e6:	0f b6 d1             	movzbl %cl,%edx
   161e9:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   161f0:	0f b6 d5             	movzbl %ch,%edx
   161f3:	c1 e9 10             	shr    $0x10,%ecx
   161f6:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   161fd:	0f b6 d1             	movzbl %cl,%edx
   16200:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   16207:	0f b6 d5             	movzbl %ch,%edx
   1620a:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   16211:	8b 6c 24 20          	mov    0x20(%esp,1),%ebp
   16215:	89 7d 0c             	mov    %edi,0xc(%ebp)
   16218:	89 75 08             	mov    %esi,0x8(%ebp)
   1621b:	89 5d 04             	mov    %ebx,0x4(%ebp)
   1621e:	89 45 00             	mov    %eax,0x0(%ebp)
   16221:	31 c0                	xor    %eax,%eax
   16223:	8b 6c 24 14          	mov    0x14(%esp,1),%ebp
   16227:	8b 5c 24 10          	mov    0x10(%esp,1),%ebx
   1622b:	8b 74 24 0c          	mov    0xc(%esp,1),%esi
   1622f:	8b 7c 24 08          	mov    0x8(%esp,1),%edi
   16233:	8d 64 24 18          	lea    0x18(%esp,1),%esp
   16237:	c3                   	ret    

00016238 <aes_encrypt_key128>:
   16238:	55                   	push   %ebp
   16239:	89 e5                	mov    %esp,%ebp
   1623b:	83 ec 18             	sub    $0x18,%esp
   1623e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16241:	8b 45 08             	mov    0x8(%ebp),%eax
   16244:	83 c0 03             	add    $0x3,%eax
   16247:	0f b6 00             	movzbl (%eax),%eax
   1624a:	89 c2                	mov    %eax,%edx
   1624c:	c1 e2 18             	shl    $0x18,%edx
   1624f:	8b 45 08             	mov    0x8(%ebp),%eax
   16252:	83 c0 02             	add    $0x2,%eax
   16255:	0f b6 00             	movzbl (%eax),%eax
   16258:	c1 e0 10             	shl    $0x10,%eax
   1625b:	09 c2                	or     %eax,%edx
   1625d:	8b 45 08             	mov    0x8(%ebp),%eax
   16260:	40                   	inc    %eax
   16261:	0f b6 00             	movzbl (%eax),%eax
   16264:	c1 e0 08             	shl    $0x8,%eax
   16267:	09 c2                	or     %eax,%edx
   16269:	8b 45 08             	mov    0x8(%ebp),%eax
   1626c:	0f b6 00             	movzbl (%eax),%eax
   1626f:	09 d0                	or     %edx,%eax
   16271:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   16274:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   16277:	89 01                	mov    %eax,(%ecx)
   16279:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1627c:	8b 45 08             	mov    0x8(%ebp),%eax
   1627f:	83 c0 07             	add    $0x7,%eax
   16282:	0f b6 00             	movzbl (%eax),%eax
   16285:	89 c2                	mov    %eax,%edx
   16287:	c1 e2 18             	shl    $0x18,%edx
   1628a:	8b 45 08             	mov    0x8(%ebp),%eax
   1628d:	83 c0 06             	add    $0x6,%eax
   16290:	0f b6 00             	movzbl (%eax),%eax
   16293:	c1 e0 10             	shl    $0x10,%eax
   16296:	09 c2                	or     %eax,%edx
   16298:	8b 45 08             	mov    0x8(%ebp),%eax
   1629b:	83 c0 05             	add    $0x5,%eax
   1629e:	0f b6 00             	movzbl (%eax),%eax
   162a1:	c1 e0 08             	shl    $0x8,%eax
   162a4:	09 c2                	or     %eax,%edx
   162a6:	8b 45 08             	mov    0x8(%ebp),%eax
   162a9:	83 c0 04             	add    $0x4,%eax
   162ac:	0f b6 00             	movzbl (%eax),%eax
   162af:	09 d0                	or     %edx,%eax
   162b1:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   162b4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   162b7:	89 41 04             	mov    %eax,0x4(%ecx)
   162ba:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   162bd:	8b 45 08             	mov    0x8(%ebp),%eax
   162c0:	83 c0 0b             	add    $0xb,%eax
   162c3:	0f b6 00             	movzbl (%eax),%eax
   162c6:	89 c2                	mov    %eax,%edx
   162c8:	c1 e2 18             	shl    $0x18,%edx
   162cb:	8b 45 08             	mov    0x8(%ebp),%eax
   162ce:	83 c0 0a             	add    $0xa,%eax
   162d1:	0f b6 00             	movzbl (%eax),%eax
   162d4:	c1 e0 10             	shl    $0x10,%eax
   162d7:	09 c2                	or     %eax,%edx
   162d9:	8b 45 08             	mov    0x8(%ebp),%eax
   162dc:	83 c0 09             	add    $0x9,%eax
   162df:	0f b6 00             	movzbl (%eax),%eax
   162e2:	c1 e0 08             	shl    $0x8,%eax
   162e5:	09 c2                	or     %eax,%edx
   162e7:	8b 45 08             	mov    0x8(%ebp),%eax
   162ea:	83 c0 08             	add    $0x8,%eax
   162ed:	0f b6 00             	movzbl (%eax),%eax
   162f0:	09 d0                	or     %edx,%eax
   162f2:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   162f5:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   162f8:	89 41 08             	mov    %eax,0x8(%ecx)
   162fb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   162fe:	8b 45 08             	mov    0x8(%ebp),%eax
   16301:	83 c0 0f             	add    $0xf,%eax
   16304:	0f b6 00             	movzbl (%eax),%eax
   16307:	89 c2                	mov    %eax,%edx
   16309:	c1 e2 18             	shl    $0x18,%edx
   1630c:	8b 45 08             	mov    0x8(%ebp),%eax
   1630f:	83 c0 0e             	add    $0xe,%eax
   16312:	0f b6 00             	movzbl (%eax),%eax
   16315:	c1 e0 10             	shl    $0x10,%eax
   16318:	09 c2                	or     %eax,%edx
   1631a:	8b 45 08             	mov    0x8(%ebp),%eax
   1631d:	83 c0 0d             	add    $0xd,%eax
   16320:	0f b6 00             	movzbl (%eax),%eax
   16323:	c1 e0 08             	shl    $0x8,%eax
   16326:	09 c2                	or     %eax,%edx
   16328:	8b 45 08             	mov    0x8(%ebp),%eax
   1632b:	83 c0 0c             	add    $0xc,%eax
   1632e:	0f b6 00             	movzbl (%eax),%eax
   16331:	09 d0                	or     %edx,%eax
   16333:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   16336:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16339:	89 41 0c             	mov    %eax,0xc(%ecx)
   1633c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1633f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16342:	c1 e8 08             	shr    $0x8,%eax
   16345:	0f b6 d0             	movzbl %al,%edx
   16348:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1634b:	c1 e8 10             	shr    $0x10,%eax
   1634e:	0f b6 c0             	movzbl %al,%eax
   16351:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   16358:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1635f:	31 c2                	xor    %eax,%edx
   16361:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16364:	c1 e8 18             	shr    $0x18,%eax
   16367:	0f b6 c0             	movzbl %al,%eax
   1636a:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   16371:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   16375:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1637c:	89 d0                	mov    %edx,%eax
   1637e:	89 c2                	mov    %eax,%edx
   16380:	33 15 00 00 00 00    	xor    0x0,%edx
   16386:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   16389:	31 10                	xor    %edx,(%eax)
   1638b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1638e:	89 41 10             	mov    %eax,0x10(%ecx)
   16391:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16394:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   16397:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   1639a:	31 10                	xor    %edx,(%eax)
   1639c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1639f:	89 41 14             	mov    %eax,0x14(%ecx)
   163a2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   163a5:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   163a8:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   163ab:	31 10                	xor    %edx,(%eax)
   163ad:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   163b0:	89 41 18             	mov    %eax,0x18(%ecx)
   163b3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   163b6:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   163b9:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   163bc:	31 10                	xor    %edx,(%eax)
   163be:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   163c1:	89 41 1c             	mov    %eax,0x1c(%ecx)
   163c4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   163c7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   163ca:	c1 e8 08             	shr    $0x8,%eax
   163cd:	0f b6 d0             	movzbl %al,%edx
   163d0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   163d3:	c1 e8 10             	shr    $0x10,%eax
   163d6:	0f b6 c0             	movzbl %al,%eax
   163d9:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   163e0:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   163e7:	31 c2                	xor    %eax,%edx
   163e9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   163ec:	c1 e8 18             	shr    $0x18,%eax
   163ef:	0f b6 c0             	movzbl %al,%eax
   163f2:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   163f9:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   163fd:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   16404:	89 d0                	mov    %edx,%eax
   16406:	89 c2                	mov    %eax,%edx
   16408:	33 15 04 00 00 00    	xor    0x4,%edx
   1640e:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   16411:	31 10                	xor    %edx,(%eax)
   16413:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   16416:	89 41 20             	mov    %eax,0x20(%ecx)
   16419:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1641c:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   1641f:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   16422:	31 10                	xor    %edx,(%eax)
   16424:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16427:	89 41 24             	mov    %eax,0x24(%ecx)
   1642a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1642d:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   16430:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   16433:	31 10                	xor    %edx,(%eax)
   16435:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   16438:	89 41 28             	mov    %eax,0x28(%ecx)
   1643b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1643e:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   16441:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   16444:	31 10                	xor    %edx,(%eax)
   16446:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16449:	89 41 2c             	mov    %eax,0x2c(%ecx)
   1644c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1644f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16452:	c1 e8 08             	shr    $0x8,%eax
   16455:	0f b6 d0             	movzbl %al,%edx
   16458:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1645b:	c1 e8 10             	shr    $0x10,%eax
   1645e:	0f b6 c0             	movzbl %al,%eax
   16461:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   16468:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1646f:	31 c2                	xor    %eax,%edx
   16471:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16474:	c1 e8 18             	shr    $0x18,%eax
   16477:	0f b6 c0             	movzbl %al,%eax
   1647a:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   16481:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   16485:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1648c:	89 d0                	mov    %edx,%eax
   1648e:	89 c2                	mov    %eax,%edx
   16490:	33 15 08 00 00 00    	xor    0x8,%edx
   16496:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   16499:	31 10                	xor    %edx,(%eax)
   1649b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1649e:	89 41 30             	mov    %eax,0x30(%ecx)
   164a1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   164a4:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   164a7:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   164aa:	31 10                	xor    %edx,(%eax)
   164ac:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   164af:	89 41 34             	mov    %eax,0x34(%ecx)
   164b2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   164b5:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   164b8:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   164bb:	31 10                	xor    %edx,(%eax)
   164bd:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   164c0:	89 41 38             	mov    %eax,0x38(%ecx)
   164c3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   164c6:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   164c9:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   164cc:	31 10                	xor    %edx,(%eax)
   164ce:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   164d1:	89 41 3c             	mov    %eax,0x3c(%ecx)
   164d4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   164d7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   164da:	c1 e8 08             	shr    $0x8,%eax
   164dd:	0f b6 d0             	movzbl %al,%edx
   164e0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   164e3:	c1 e8 10             	shr    $0x10,%eax
   164e6:	0f b6 c0             	movzbl %al,%eax
   164e9:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   164f0:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   164f7:	31 c2                	xor    %eax,%edx
   164f9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   164fc:	c1 e8 18             	shr    $0x18,%eax
   164ff:	0f b6 c0             	movzbl %al,%eax
   16502:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   16509:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   1650d:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   16514:	89 d0                	mov    %edx,%eax
   16516:	89 c2                	mov    %eax,%edx
   16518:	33 15 0c 00 00 00    	xor    0xc,%edx
   1651e:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   16521:	31 10                	xor    %edx,(%eax)
   16523:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   16526:	89 41 40             	mov    %eax,0x40(%ecx)
   16529:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1652c:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   1652f:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   16532:	31 10                	xor    %edx,(%eax)
   16534:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16537:	89 41 44             	mov    %eax,0x44(%ecx)
   1653a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1653d:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   16540:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   16543:	31 10                	xor    %edx,(%eax)
   16545:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   16548:	89 41 48             	mov    %eax,0x48(%ecx)
   1654b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1654e:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   16551:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   16554:	31 10                	xor    %edx,(%eax)
   16556:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16559:	89 41 4c             	mov    %eax,0x4c(%ecx)
   1655c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1655f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16562:	c1 e8 08             	shr    $0x8,%eax
   16565:	0f b6 d0             	movzbl %al,%edx
   16568:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1656b:	c1 e8 10             	shr    $0x10,%eax
   1656e:	0f b6 c0             	movzbl %al,%eax
   16571:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   16578:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1657f:	31 c2                	xor    %eax,%edx
   16581:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16584:	c1 e8 18             	shr    $0x18,%eax
   16587:	0f b6 c0             	movzbl %al,%eax
   1658a:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   16591:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   16595:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1659c:	89 d0                	mov    %edx,%eax
   1659e:	89 c2                	mov    %eax,%edx
   165a0:	33 15 10 00 00 00    	xor    0x10,%edx
   165a6:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   165a9:	31 10                	xor    %edx,(%eax)
   165ab:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   165ae:	89 41 50             	mov    %eax,0x50(%ecx)
   165b1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   165b4:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   165b7:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   165ba:	31 10                	xor    %edx,(%eax)
   165bc:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   165bf:	89 41 54             	mov    %eax,0x54(%ecx)
   165c2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   165c5:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   165c8:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   165cb:	31 10                	xor    %edx,(%eax)
   165cd:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   165d0:	89 41 58             	mov    %eax,0x58(%ecx)
   165d3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   165d6:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   165d9:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   165dc:	31 10                	xor    %edx,(%eax)
   165de:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   165e1:	89 41 5c             	mov    %eax,0x5c(%ecx)
   165e4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   165e7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   165ea:	c1 e8 08             	shr    $0x8,%eax
   165ed:	0f b6 d0             	movzbl %al,%edx
   165f0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   165f3:	c1 e8 10             	shr    $0x10,%eax
   165f6:	0f b6 c0             	movzbl %al,%eax
   165f9:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   16600:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   16607:	31 c2                	xor    %eax,%edx
   16609:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1660c:	c1 e8 18             	shr    $0x18,%eax
   1660f:	0f b6 c0             	movzbl %al,%eax
   16612:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   16619:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   1661d:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   16624:	89 d0                	mov    %edx,%eax
   16626:	89 c2                	mov    %eax,%edx
   16628:	33 15 14 00 00 00    	xor    0x14,%edx
   1662e:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   16631:	31 10                	xor    %edx,(%eax)
   16633:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   16636:	89 41 60             	mov    %eax,0x60(%ecx)
   16639:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1663c:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   1663f:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   16642:	31 10                	xor    %edx,(%eax)
   16644:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16647:	89 41 64             	mov    %eax,0x64(%ecx)
   1664a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1664d:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   16650:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   16653:	31 10                	xor    %edx,(%eax)
   16655:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   16658:	89 41 68             	mov    %eax,0x68(%ecx)
   1665b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1665e:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   16661:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   16664:	31 10                	xor    %edx,(%eax)
   16666:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16669:	89 41 6c             	mov    %eax,0x6c(%ecx)
   1666c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1666f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16672:	c1 e8 08             	shr    $0x8,%eax
   16675:	0f b6 d0             	movzbl %al,%edx
   16678:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1667b:	c1 e8 10             	shr    $0x10,%eax
   1667e:	0f b6 c0             	movzbl %al,%eax
   16681:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   16688:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1668f:	31 c2                	xor    %eax,%edx
   16691:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16694:	c1 e8 18             	shr    $0x18,%eax
   16697:	0f b6 c0             	movzbl %al,%eax
   1669a:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   166a1:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   166a5:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   166ac:	89 d0                	mov    %edx,%eax
   166ae:	89 c2                	mov    %eax,%edx
   166b0:	33 15 18 00 00 00    	xor    0x18,%edx
   166b6:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   166b9:	31 10                	xor    %edx,(%eax)
   166bb:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   166be:	89 41 70             	mov    %eax,0x70(%ecx)
   166c1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   166c4:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   166c7:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   166ca:	31 10                	xor    %edx,(%eax)
   166cc:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   166cf:	89 41 74             	mov    %eax,0x74(%ecx)
   166d2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   166d5:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   166d8:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   166db:	31 10                	xor    %edx,(%eax)
   166dd:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   166e0:	89 41 78             	mov    %eax,0x78(%ecx)
   166e3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   166e6:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   166e9:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   166ec:	31 10                	xor    %edx,(%eax)
   166ee:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   166f1:	89 41 7c             	mov    %eax,0x7c(%ecx)
   166f4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   166f7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   166fa:	c1 e8 08             	shr    $0x8,%eax
   166fd:	0f b6 d0             	movzbl %al,%edx
   16700:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16703:	c1 e8 10             	shr    $0x10,%eax
   16706:	0f b6 c0             	movzbl %al,%eax
   16709:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   16710:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   16717:	31 c2                	xor    %eax,%edx
   16719:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1671c:	c1 e8 18             	shr    $0x18,%eax
   1671f:	0f b6 c0             	movzbl %al,%eax
   16722:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   16729:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   1672d:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   16734:	89 d0                	mov    %edx,%eax
   16736:	89 c2                	mov    %eax,%edx
   16738:	33 15 1c 00 00 00    	xor    0x1c,%edx
   1673e:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   16741:	31 10                	xor    %edx,(%eax)
   16743:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   16746:	89 81 80 00 00 00    	mov    %eax,0x80(%ecx)
   1674c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1674f:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   16752:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   16755:	31 10                	xor    %edx,(%eax)
   16757:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1675a:	89 81 84 00 00 00    	mov    %eax,0x84(%ecx)
   16760:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16763:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   16766:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   16769:	31 10                	xor    %edx,(%eax)
   1676b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1676e:	89 81 88 00 00 00    	mov    %eax,0x88(%ecx)
   16774:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16777:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   1677a:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   1677d:	31 10                	xor    %edx,(%eax)
   1677f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16782:	89 81 8c 00 00 00    	mov    %eax,0x8c(%ecx)
   16788:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1678b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1678e:	c1 e8 08             	shr    $0x8,%eax
   16791:	0f b6 d0             	movzbl %al,%edx
   16794:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16797:	c1 e8 10             	shr    $0x10,%eax
   1679a:	0f b6 c0             	movzbl %al,%eax
   1679d:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   167a4:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   167ab:	31 c2                	xor    %eax,%edx
   167ad:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   167b0:	c1 e8 18             	shr    $0x18,%eax
   167b3:	0f b6 c0             	movzbl %al,%eax
   167b6:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   167bd:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   167c1:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   167c8:	89 d0                	mov    %edx,%eax
   167ca:	89 c2                	mov    %eax,%edx
   167cc:	33 15 20 00 00 00    	xor    0x20,%edx
   167d2:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   167d5:	31 10                	xor    %edx,(%eax)
   167d7:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   167da:	89 81 90 00 00 00    	mov    %eax,0x90(%ecx)
   167e0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   167e3:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   167e6:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   167e9:	31 10                	xor    %edx,(%eax)
   167eb:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   167ee:	89 81 94 00 00 00    	mov    %eax,0x94(%ecx)
   167f4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   167f7:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   167fa:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   167fd:	31 10                	xor    %edx,(%eax)
   167ff:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   16802:	89 81 98 00 00 00    	mov    %eax,0x98(%ecx)
   16808:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1680b:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   1680e:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   16811:	31 10                	xor    %edx,(%eax)
   16813:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16816:	89 81 9c 00 00 00    	mov    %eax,0x9c(%ecx)
   1681c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1681f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16822:	c1 e8 08             	shr    $0x8,%eax
   16825:	0f b6 d0             	movzbl %al,%edx
   16828:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1682b:	c1 e8 10             	shr    $0x10,%eax
   1682e:	0f b6 c0             	movzbl %al,%eax
   16831:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   16838:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1683f:	31 c2                	xor    %eax,%edx
   16841:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16844:	c1 e8 18             	shr    $0x18,%eax
   16847:	0f b6 c0             	movzbl %al,%eax
   1684a:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   16851:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   16855:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1685c:	89 d0                	mov    %edx,%eax
   1685e:	89 c2                	mov    %eax,%edx
   16860:	33 15 24 00 00 00    	xor    0x24,%edx
   16866:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   16869:	31 10                	xor    %edx,(%eax)
   1686b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1686e:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
   16874:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16877:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   1687a:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   1687d:	31 10                	xor    %edx,(%eax)
   1687f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16882:	89 81 a4 00 00 00    	mov    %eax,0xa4(%ecx)
   16888:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1688b:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   1688e:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   16891:	31 10                	xor    %edx,(%eax)
   16893:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   16896:	89 81 a8 00 00 00    	mov    %eax,0xa8(%ecx)
   1689c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1689f:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   168a2:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   168a5:	31 10                	xor    %edx,(%eax)
   168a7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   168aa:	89 81 ac 00 00 00    	mov    %eax,0xac(%ecx)
   168b0:	8b 45 0c             	mov    0xc(%ebp),%eax
   168b3:	c7 80 f0 00 00 00 0a 	movl   $0xa,0xf0(%eax)
   168ba:	00 00 00 
   168bd:	b8 00 00 00 00       	mov    $0x0,%eax
   168c2:	c9                   	leave  
   168c3:	c3                   	ret    

000168c4 <aes_encrypt_key192>:
   168c4:	55                   	push   %ebp
   168c5:	89 e5                	mov    %esp,%ebp
   168c7:	83 ec 28             	sub    $0x28,%esp
   168ca:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   168cd:	8b 45 08             	mov    0x8(%ebp),%eax
   168d0:	83 c0 03             	add    $0x3,%eax
   168d3:	0f b6 00             	movzbl (%eax),%eax
   168d6:	89 c2                	mov    %eax,%edx
   168d8:	c1 e2 18             	shl    $0x18,%edx
   168db:	8b 45 08             	mov    0x8(%ebp),%eax
   168de:	83 c0 02             	add    $0x2,%eax
   168e1:	0f b6 00             	movzbl (%eax),%eax
   168e4:	c1 e0 10             	shl    $0x10,%eax
   168e7:	09 c2                	or     %eax,%edx
   168e9:	8b 45 08             	mov    0x8(%ebp),%eax
   168ec:	40                   	inc    %eax
   168ed:	0f b6 00             	movzbl (%eax),%eax
   168f0:	c1 e0 08             	shl    $0x8,%eax
   168f3:	09 c2                	or     %eax,%edx
   168f5:	8b 45 08             	mov    0x8(%ebp),%eax
   168f8:	0f b6 00             	movzbl (%eax),%eax
   168fb:	09 d0                	or     %edx,%eax
   168fd:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
   16900:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   16903:	89 01                	mov    %eax,(%ecx)
   16905:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16908:	8b 45 08             	mov    0x8(%ebp),%eax
   1690b:	83 c0 07             	add    $0x7,%eax
   1690e:	0f b6 00             	movzbl (%eax),%eax
   16911:	89 c2                	mov    %eax,%edx
   16913:	c1 e2 18             	shl    $0x18,%edx
   16916:	8b 45 08             	mov    0x8(%ebp),%eax
   16919:	83 c0 06             	add    $0x6,%eax
   1691c:	0f b6 00             	movzbl (%eax),%eax
   1691f:	c1 e0 10             	shl    $0x10,%eax
   16922:	09 c2                	or     %eax,%edx
   16924:	8b 45 08             	mov    0x8(%ebp),%eax
   16927:	83 c0 05             	add    $0x5,%eax
   1692a:	0f b6 00             	movzbl (%eax),%eax
   1692d:	c1 e0 08             	shl    $0x8,%eax
   16930:	09 c2                	or     %eax,%edx
   16932:	8b 45 08             	mov    0x8(%ebp),%eax
   16935:	83 c0 04             	add    $0x4,%eax
   16938:	0f b6 00             	movzbl (%eax),%eax
   1693b:	09 d0                	or     %edx,%eax
   1693d:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
   16940:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16943:	89 41 04             	mov    %eax,0x4(%ecx)
   16946:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16949:	8b 45 08             	mov    0x8(%ebp),%eax
   1694c:	83 c0 0b             	add    $0xb,%eax
   1694f:	0f b6 00             	movzbl (%eax),%eax
   16952:	89 c2                	mov    %eax,%edx
   16954:	c1 e2 18             	shl    $0x18,%edx
   16957:	8b 45 08             	mov    0x8(%ebp),%eax
   1695a:	83 c0 0a             	add    $0xa,%eax
   1695d:	0f b6 00             	movzbl (%eax),%eax
   16960:	c1 e0 10             	shl    $0x10,%eax
   16963:	09 c2                	or     %eax,%edx
   16965:	8b 45 08             	mov    0x8(%ebp),%eax
   16968:	83 c0 09             	add    $0x9,%eax
   1696b:	0f b6 00             	movzbl (%eax),%eax
   1696e:	c1 e0 08             	shl    $0x8,%eax
   16971:	09 c2                	or     %eax,%edx
   16973:	8b 45 08             	mov    0x8(%ebp),%eax
   16976:	83 c0 08             	add    $0x8,%eax
   16979:	0f b6 00             	movzbl (%eax),%eax
   1697c:	09 d0                	or     %edx,%eax
   1697e:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   16981:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   16984:	89 41 08             	mov    %eax,0x8(%ecx)
   16987:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1698a:	8b 45 08             	mov    0x8(%ebp),%eax
   1698d:	83 c0 0f             	add    $0xf,%eax
   16990:	0f b6 00             	movzbl (%eax),%eax
   16993:	89 c2                	mov    %eax,%edx
   16995:	c1 e2 18             	shl    $0x18,%edx
   16998:	8b 45 08             	mov    0x8(%ebp),%eax
   1699b:	83 c0 0e             	add    $0xe,%eax
   1699e:	0f b6 00             	movzbl (%eax),%eax
   169a1:	c1 e0 10             	shl    $0x10,%eax
   169a4:	09 c2                	or     %eax,%edx
   169a6:	8b 45 08             	mov    0x8(%ebp),%eax
   169a9:	83 c0 0d             	add    $0xd,%eax
   169ac:	0f b6 00             	movzbl (%eax),%eax
   169af:	c1 e0 08             	shl    $0x8,%eax
   169b2:	09 c2                	or     %eax,%edx
   169b4:	8b 45 08             	mov    0x8(%ebp),%eax
   169b7:	83 c0 0c             	add    $0xc,%eax
   169ba:	0f b6 00             	movzbl (%eax),%eax
   169bd:	09 d0                	or     %edx,%eax
   169bf:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   169c2:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   169c5:	89 41 0c             	mov    %eax,0xc(%ecx)
   169c8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   169cb:	8b 45 08             	mov    0x8(%ebp),%eax
   169ce:	83 c0 13             	add    $0x13,%eax
   169d1:	0f b6 00             	movzbl (%eax),%eax
   169d4:	89 c2                	mov    %eax,%edx
   169d6:	c1 e2 18             	shl    $0x18,%edx
   169d9:	8b 45 08             	mov    0x8(%ebp),%eax
   169dc:	83 c0 12             	add    $0x12,%eax
   169df:	0f b6 00             	movzbl (%eax),%eax
   169e2:	c1 e0 10             	shl    $0x10,%eax
   169e5:	09 c2                	or     %eax,%edx
   169e7:	8b 45 08             	mov    0x8(%ebp),%eax
   169ea:	83 c0 11             	add    $0x11,%eax
   169ed:	0f b6 00             	movzbl (%eax),%eax
   169f0:	c1 e0 08             	shl    $0x8,%eax
   169f3:	09 c2                	or     %eax,%edx
   169f5:	8b 45 08             	mov    0x8(%ebp),%eax
   169f8:	83 c0 10             	add    $0x10,%eax
   169fb:	0f b6 00             	movzbl (%eax),%eax
   169fe:	09 d0                	or     %edx,%eax
   16a00:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   16a03:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   16a06:	89 41 10             	mov    %eax,0x10(%ecx)
   16a09:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16a0c:	8b 45 08             	mov    0x8(%ebp),%eax
   16a0f:	83 c0 17             	add    $0x17,%eax
   16a12:	0f b6 00             	movzbl (%eax),%eax
   16a15:	89 c2                	mov    %eax,%edx
   16a17:	c1 e2 18             	shl    $0x18,%edx
   16a1a:	8b 45 08             	mov    0x8(%ebp),%eax
   16a1d:	83 c0 16             	add    $0x16,%eax
   16a20:	0f b6 00             	movzbl (%eax),%eax
   16a23:	c1 e0 10             	shl    $0x10,%eax
   16a26:	09 c2                	or     %eax,%edx
   16a28:	8b 45 08             	mov    0x8(%ebp),%eax
   16a2b:	83 c0 15             	add    $0x15,%eax
   16a2e:	0f b6 00             	movzbl (%eax),%eax
   16a31:	c1 e0 08             	shl    $0x8,%eax
   16a34:	09 c2                	or     %eax,%edx
   16a36:	8b 45 08             	mov    0x8(%ebp),%eax
   16a39:	83 c0 14             	add    $0x14,%eax
   16a3c:	0f b6 00             	movzbl (%eax),%eax
   16a3f:	09 d0                	or     %edx,%eax
   16a41:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   16a44:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16a47:	89 41 14             	mov    %eax,0x14(%ecx)
   16a4a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16a4d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16a50:	c1 e8 08             	shr    $0x8,%eax
   16a53:	0f b6 d0             	movzbl %al,%edx
   16a56:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16a59:	c1 e8 10             	shr    $0x10,%eax
   16a5c:	0f b6 c0             	movzbl %al,%eax
   16a5f:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   16a66:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   16a6d:	31 c2                	xor    %eax,%edx
   16a6f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16a72:	c1 e8 18             	shr    $0x18,%eax
   16a75:	0f b6 c0             	movzbl %al,%eax
   16a78:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   16a7f:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
   16a83:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   16a8a:	89 d0                	mov    %edx,%eax
   16a8c:	89 c2                	mov    %eax,%edx
   16a8e:	33 15 00 00 00 00    	xor    0x0,%edx
   16a94:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   16a97:	31 10                	xor    %edx,(%eax)
   16a99:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   16a9c:	89 41 18             	mov    %eax,0x18(%ecx)
   16a9f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16aa2:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   16aa5:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   16aa8:	31 10                	xor    %edx,(%eax)
   16aaa:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16aad:	89 41 1c             	mov    %eax,0x1c(%ecx)
   16ab0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16ab3:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   16ab6:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   16ab9:	31 10                	xor    %edx,(%eax)
   16abb:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   16abe:	89 41 20             	mov    %eax,0x20(%ecx)
   16ac1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16ac4:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   16ac7:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   16aca:	31 10                	xor    %edx,(%eax)
   16acc:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   16acf:	89 41 24             	mov    %eax,0x24(%ecx)
   16ad2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16ad5:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   16ad8:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   16adb:	31 10                	xor    %edx,(%eax)
   16add:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   16ae0:	89 41 28             	mov    %eax,0x28(%ecx)
   16ae3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16ae6:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   16ae9:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   16aec:	31 10                	xor    %edx,(%eax)
   16aee:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16af1:	89 41 2c             	mov    %eax,0x2c(%ecx)
   16af4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16af7:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16afa:	c1 e8 08             	shr    $0x8,%eax
   16afd:	0f b6 d0             	movzbl %al,%edx
   16b00:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16b03:	c1 e8 10             	shr    $0x10,%eax
   16b06:	0f b6 c0             	movzbl %al,%eax
   16b09:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   16b10:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   16b17:	31 c2                	xor    %eax,%edx
   16b19:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16b1c:	c1 e8 18             	shr    $0x18,%eax
   16b1f:	0f b6 c0             	movzbl %al,%eax
   16b22:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   16b29:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
   16b2d:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   16b34:	89 d0                	mov    %edx,%eax
   16b36:	89 c2                	mov    %eax,%edx
   16b38:	33 15 04 00 00 00    	xor    0x4,%edx
   16b3e:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   16b41:	31 10                	xor    %edx,(%eax)
   16b43:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   16b46:	89 41 30             	mov    %eax,0x30(%ecx)
   16b49:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16b4c:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   16b4f:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   16b52:	31 10                	xor    %edx,(%eax)
   16b54:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16b57:	89 41 34             	mov    %eax,0x34(%ecx)
   16b5a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16b5d:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   16b60:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   16b63:	31 10                	xor    %edx,(%eax)
   16b65:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   16b68:	89 41 38             	mov    %eax,0x38(%ecx)
   16b6b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16b6e:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   16b71:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   16b74:	31 10                	xor    %edx,(%eax)
   16b76:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   16b79:	89 41 3c             	mov    %eax,0x3c(%ecx)
   16b7c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16b7f:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   16b82:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   16b85:	31 10                	xor    %edx,(%eax)
   16b87:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   16b8a:	89 41 40             	mov    %eax,0x40(%ecx)
   16b8d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16b90:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   16b93:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   16b96:	31 10                	xor    %edx,(%eax)
   16b98:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16b9b:	89 41 44             	mov    %eax,0x44(%ecx)
   16b9e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16ba1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16ba4:	c1 e8 08             	shr    $0x8,%eax
   16ba7:	0f b6 d0             	movzbl %al,%edx
   16baa:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16bad:	c1 e8 10             	shr    $0x10,%eax
   16bb0:	0f b6 c0             	movzbl %al,%eax
   16bb3:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   16bba:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   16bc1:	31 c2                	xor    %eax,%edx
   16bc3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16bc6:	c1 e8 18             	shr    $0x18,%eax
   16bc9:	0f b6 c0             	movzbl %al,%eax
   16bcc:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   16bd3:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
   16bd7:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   16bde:	89 d0                	mov    %edx,%eax
   16be0:	89 c2                	mov    %eax,%edx
   16be2:	33 15 08 00 00 00    	xor    0x8,%edx
   16be8:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   16beb:	31 10                	xor    %edx,(%eax)
   16bed:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   16bf0:	89 41 48             	mov    %eax,0x48(%ecx)
   16bf3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16bf6:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   16bf9:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   16bfc:	31 10                	xor    %edx,(%eax)
   16bfe:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16c01:	89 41 4c             	mov    %eax,0x4c(%ecx)
   16c04:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16c07:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   16c0a:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   16c0d:	31 10                	xor    %edx,(%eax)
   16c0f:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   16c12:	89 41 50             	mov    %eax,0x50(%ecx)
   16c15:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16c18:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   16c1b:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   16c1e:	31 10                	xor    %edx,(%eax)
   16c20:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   16c23:	89 41 54             	mov    %eax,0x54(%ecx)
   16c26:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16c29:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   16c2c:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   16c2f:	31 10                	xor    %edx,(%eax)
   16c31:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   16c34:	89 41 58             	mov    %eax,0x58(%ecx)
   16c37:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16c3a:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   16c3d:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   16c40:	31 10                	xor    %edx,(%eax)
   16c42:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16c45:	89 41 5c             	mov    %eax,0x5c(%ecx)
   16c48:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16c4b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16c4e:	c1 e8 08             	shr    $0x8,%eax
   16c51:	0f b6 d0             	movzbl %al,%edx
   16c54:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16c57:	c1 e8 10             	shr    $0x10,%eax
   16c5a:	0f b6 c0             	movzbl %al,%eax
   16c5d:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   16c64:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   16c6b:	31 c2                	xor    %eax,%edx
   16c6d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16c70:	c1 e8 18             	shr    $0x18,%eax
   16c73:	0f b6 c0             	movzbl %al,%eax
   16c76:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   16c7d:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
   16c81:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   16c88:	89 d0                	mov    %edx,%eax
   16c8a:	89 c2                	mov    %eax,%edx
   16c8c:	33 15 0c 00 00 00    	xor    0xc,%edx
   16c92:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   16c95:	31 10                	xor    %edx,(%eax)
   16c97:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   16c9a:	89 41 60             	mov    %eax,0x60(%ecx)
   16c9d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16ca0:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   16ca3:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   16ca6:	31 10                	xor    %edx,(%eax)
   16ca8:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16cab:	89 41 64             	mov    %eax,0x64(%ecx)
   16cae:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16cb1:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   16cb4:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   16cb7:	31 10                	xor    %edx,(%eax)
   16cb9:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   16cbc:	89 41 68             	mov    %eax,0x68(%ecx)
   16cbf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16cc2:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   16cc5:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   16cc8:	31 10                	xor    %edx,(%eax)
   16cca:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   16ccd:	89 41 6c             	mov    %eax,0x6c(%ecx)
   16cd0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16cd3:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   16cd6:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   16cd9:	31 10                	xor    %edx,(%eax)
   16cdb:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   16cde:	89 41 70             	mov    %eax,0x70(%ecx)
   16ce1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16ce4:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   16ce7:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   16cea:	31 10                	xor    %edx,(%eax)
   16cec:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16cef:	89 41 74             	mov    %eax,0x74(%ecx)
   16cf2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16cf5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16cf8:	c1 e8 08             	shr    $0x8,%eax
   16cfb:	0f b6 d0             	movzbl %al,%edx
   16cfe:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16d01:	c1 e8 10             	shr    $0x10,%eax
   16d04:	0f b6 c0             	movzbl %al,%eax
   16d07:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   16d0e:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   16d15:	31 c2                	xor    %eax,%edx
   16d17:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16d1a:	c1 e8 18             	shr    $0x18,%eax
   16d1d:	0f b6 c0             	movzbl %al,%eax
   16d20:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   16d27:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
   16d2b:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   16d32:	89 d0                	mov    %edx,%eax
   16d34:	89 c2                	mov    %eax,%edx
   16d36:	33 15 10 00 00 00    	xor    0x10,%edx
   16d3c:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   16d3f:	31 10                	xor    %edx,(%eax)
   16d41:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   16d44:	89 41 78             	mov    %eax,0x78(%ecx)
   16d47:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16d4a:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   16d4d:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   16d50:	31 10                	xor    %edx,(%eax)
   16d52:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16d55:	89 41 7c             	mov    %eax,0x7c(%ecx)
   16d58:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16d5b:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   16d5e:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   16d61:	31 10                	xor    %edx,(%eax)
   16d63:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   16d66:	89 81 80 00 00 00    	mov    %eax,0x80(%ecx)
   16d6c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16d6f:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   16d72:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   16d75:	31 10                	xor    %edx,(%eax)
   16d77:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   16d7a:	89 81 84 00 00 00    	mov    %eax,0x84(%ecx)
   16d80:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16d83:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   16d86:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   16d89:	31 10                	xor    %edx,(%eax)
   16d8b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   16d8e:	89 81 88 00 00 00    	mov    %eax,0x88(%ecx)
   16d94:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16d97:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   16d9a:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   16d9d:	31 10                	xor    %edx,(%eax)
   16d9f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16da2:	89 81 8c 00 00 00    	mov    %eax,0x8c(%ecx)
   16da8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16dab:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16dae:	c1 e8 08             	shr    $0x8,%eax
   16db1:	0f b6 d0             	movzbl %al,%edx
   16db4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16db7:	c1 e8 10             	shr    $0x10,%eax
   16dba:	0f b6 c0             	movzbl %al,%eax
   16dbd:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   16dc4:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   16dcb:	31 c2                	xor    %eax,%edx
   16dcd:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16dd0:	c1 e8 18             	shr    $0x18,%eax
   16dd3:	0f b6 c0             	movzbl %al,%eax
   16dd6:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   16ddd:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
   16de1:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   16de8:	89 d0                	mov    %edx,%eax
   16dea:	89 c2                	mov    %eax,%edx
   16dec:	33 15 14 00 00 00    	xor    0x14,%edx
   16df2:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   16df5:	31 10                	xor    %edx,(%eax)
   16df7:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   16dfa:	89 81 90 00 00 00    	mov    %eax,0x90(%ecx)
   16e00:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16e03:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   16e06:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   16e09:	31 10                	xor    %edx,(%eax)
   16e0b:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16e0e:	89 81 94 00 00 00    	mov    %eax,0x94(%ecx)
   16e14:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16e17:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   16e1a:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   16e1d:	31 10                	xor    %edx,(%eax)
   16e1f:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   16e22:	89 81 98 00 00 00    	mov    %eax,0x98(%ecx)
   16e28:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16e2b:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   16e2e:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   16e31:	31 10                	xor    %edx,(%eax)
   16e33:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   16e36:	89 81 9c 00 00 00    	mov    %eax,0x9c(%ecx)
   16e3c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16e3f:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   16e42:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   16e45:	31 10                	xor    %edx,(%eax)
   16e47:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   16e4a:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
   16e50:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16e53:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   16e56:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   16e59:	31 10                	xor    %edx,(%eax)
   16e5b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16e5e:	89 81 a4 00 00 00    	mov    %eax,0xa4(%ecx)
   16e64:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16e67:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16e6a:	c1 e8 08             	shr    $0x8,%eax
   16e6d:	0f b6 d0             	movzbl %al,%edx
   16e70:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16e73:	c1 e8 10             	shr    $0x10,%eax
   16e76:	0f b6 c0             	movzbl %al,%eax
   16e79:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   16e80:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   16e87:	31 c2                	xor    %eax,%edx
   16e89:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16e8c:	c1 e8 18             	shr    $0x18,%eax
   16e8f:	0f b6 c0             	movzbl %al,%eax
   16e92:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   16e99:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
   16e9d:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   16ea4:	89 d0                	mov    %edx,%eax
   16ea6:	89 c2                	mov    %eax,%edx
   16ea8:	33 15 18 00 00 00    	xor    0x18,%edx
   16eae:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   16eb1:	31 10                	xor    %edx,(%eax)
   16eb3:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   16eb6:	89 81 a8 00 00 00    	mov    %eax,0xa8(%ecx)
   16ebc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16ebf:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   16ec2:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   16ec5:	31 10                	xor    %edx,(%eax)
   16ec7:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16eca:	89 81 ac 00 00 00    	mov    %eax,0xac(%ecx)
   16ed0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16ed3:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   16ed6:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   16ed9:	31 10                	xor    %edx,(%eax)
   16edb:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   16ede:	89 81 b0 00 00 00    	mov    %eax,0xb0(%ecx)
   16ee4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16ee7:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   16eea:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   16eed:	31 10                	xor    %edx,(%eax)
   16eef:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   16ef2:	89 81 b4 00 00 00    	mov    %eax,0xb4(%ecx)
   16ef8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16efb:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   16efe:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   16f01:	31 10                	xor    %edx,(%eax)
   16f03:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   16f06:	89 81 b8 00 00 00    	mov    %eax,0xb8(%ecx)
   16f0c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16f0f:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   16f12:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   16f15:	31 10                	xor    %edx,(%eax)
   16f17:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16f1a:	89 81 bc 00 00 00    	mov    %eax,0xbc(%ecx)
   16f20:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16f23:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16f26:	c1 e8 08             	shr    $0x8,%eax
   16f29:	0f b6 d0             	movzbl %al,%edx
   16f2c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16f2f:	c1 e8 10             	shr    $0x10,%eax
   16f32:	0f b6 c0             	movzbl %al,%eax
   16f35:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   16f3c:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   16f43:	31 c2                	xor    %eax,%edx
   16f45:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16f48:	c1 e8 18             	shr    $0x18,%eax
   16f4b:	0f b6 c0             	movzbl %al,%eax
   16f4e:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   16f55:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
   16f59:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   16f60:	89 d0                	mov    %edx,%eax
   16f62:	89 c2                	mov    %eax,%edx
   16f64:	33 15 1c 00 00 00    	xor    0x1c,%edx
   16f6a:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   16f6d:	31 10                	xor    %edx,(%eax)
   16f6f:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   16f72:	89 81 c0 00 00 00    	mov    %eax,0xc0(%ecx)
   16f78:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16f7b:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   16f7e:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   16f81:	31 10                	xor    %edx,(%eax)
   16f83:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16f86:	89 81 c4 00 00 00    	mov    %eax,0xc4(%ecx)
   16f8c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16f8f:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   16f92:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   16f95:	31 10                	xor    %edx,(%eax)
   16f97:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   16f9a:	89 81 c8 00 00 00    	mov    %eax,0xc8(%ecx)
   16fa0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16fa3:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   16fa6:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   16fa9:	31 10                	xor    %edx,(%eax)
   16fab:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   16fae:	89 81 cc 00 00 00    	mov    %eax,0xcc(%ecx)
   16fb4:	8b 45 0c             	mov    0xc(%ebp),%eax
   16fb7:	c7 80 f0 00 00 00 0c 	movl   $0xc,0xf0(%eax)
   16fbe:	00 00 00 
   16fc1:	b8 00 00 00 00       	mov    $0x0,%eax
   16fc6:	c9                   	leave  
   16fc7:	c3                   	ret    

00016fc8 <aes_encrypt_key256>:
   16fc8:	55                   	push   %ebp
   16fc9:	89 e5                	mov    %esp,%ebp
   16fcb:	83 ec 28             	sub    $0x28,%esp
   16fce:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   16fd1:	8b 45 08             	mov    0x8(%ebp),%eax
   16fd4:	83 c0 03             	add    $0x3,%eax
   16fd7:	0f b6 00             	movzbl (%eax),%eax
   16fda:	89 c2                	mov    %eax,%edx
   16fdc:	c1 e2 18             	shl    $0x18,%edx
   16fdf:	8b 45 08             	mov    0x8(%ebp),%eax
   16fe2:	83 c0 02             	add    $0x2,%eax
   16fe5:	0f b6 00             	movzbl (%eax),%eax
   16fe8:	c1 e0 10             	shl    $0x10,%eax
   16feb:	09 c2                	or     %eax,%edx
   16fed:	8b 45 08             	mov    0x8(%ebp),%eax
   16ff0:	40                   	inc    %eax
   16ff1:	0f b6 00             	movzbl (%eax),%eax
   16ff4:	c1 e0 08             	shl    $0x8,%eax
   16ff7:	09 c2                	or     %eax,%edx
   16ff9:	8b 45 08             	mov    0x8(%ebp),%eax
   16ffc:	0f b6 00             	movzbl (%eax),%eax
   16fff:	09 d0                	or     %edx,%eax
   17001:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
   17004:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   17007:	89 01                	mov    %eax,(%ecx)
   17009:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1700c:	8b 45 08             	mov    0x8(%ebp),%eax
   1700f:	83 c0 07             	add    $0x7,%eax
   17012:	0f b6 00             	movzbl (%eax),%eax
   17015:	89 c2                	mov    %eax,%edx
   17017:	c1 e2 18             	shl    $0x18,%edx
   1701a:	8b 45 08             	mov    0x8(%ebp),%eax
   1701d:	83 c0 06             	add    $0x6,%eax
   17020:	0f b6 00             	movzbl (%eax),%eax
   17023:	c1 e0 10             	shl    $0x10,%eax
   17026:	09 c2                	or     %eax,%edx
   17028:	8b 45 08             	mov    0x8(%ebp),%eax
   1702b:	83 c0 05             	add    $0x5,%eax
   1702e:	0f b6 00             	movzbl (%eax),%eax
   17031:	c1 e0 08             	shl    $0x8,%eax
   17034:	09 c2                	or     %eax,%edx
   17036:	8b 45 08             	mov    0x8(%ebp),%eax
   17039:	83 c0 04             	add    $0x4,%eax
   1703c:	0f b6 00             	movzbl (%eax),%eax
   1703f:	09 d0                	or     %edx,%eax
   17041:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
   17044:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   17047:	89 41 04             	mov    %eax,0x4(%ecx)
   1704a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1704d:	8b 45 08             	mov    0x8(%ebp),%eax
   17050:	83 c0 0b             	add    $0xb,%eax
   17053:	0f b6 00             	movzbl (%eax),%eax
   17056:	89 c2                	mov    %eax,%edx
   17058:	c1 e2 18             	shl    $0x18,%edx
   1705b:	8b 45 08             	mov    0x8(%ebp),%eax
   1705e:	83 c0 0a             	add    $0xa,%eax
   17061:	0f b6 00             	movzbl (%eax),%eax
   17064:	c1 e0 10             	shl    $0x10,%eax
   17067:	09 c2                	or     %eax,%edx
   17069:	8b 45 08             	mov    0x8(%ebp),%eax
   1706c:	83 c0 09             	add    $0x9,%eax
   1706f:	0f b6 00             	movzbl (%eax),%eax
   17072:	c1 e0 08             	shl    $0x8,%eax
   17075:	09 c2                	or     %eax,%edx
   17077:	8b 45 08             	mov    0x8(%ebp),%eax
   1707a:	83 c0 08             	add    $0x8,%eax
   1707d:	0f b6 00             	movzbl (%eax),%eax
   17080:	09 d0                	or     %edx,%eax
   17082:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   17085:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   17088:	89 41 08             	mov    %eax,0x8(%ecx)
   1708b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1708e:	8b 45 08             	mov    0x8(%ebp),%eax
   17091:	83 c0 0f             	add    $0xf,%eax
   17094:	0f b6 00             	movzbl (%eax),%eax
   17097:	89 c2                	mov    %eax,%edx
   17099:	c1 e2 18             	shl    $0x18,%edx
   1709c:	8b 45 08             	mov    0x8(%ebp),%eax
   1709f:	83 c0 0e             	add    $0xe,%eax
   170a2:	0f b6 00             	movzbl (%eax),%eax
   170a5:	c1 e0 10             	shl    $0x10,%eax
   170a8:	09 c2                	or     %eax,%edx
   170aa:	8b 45 08             	mov    0x8(%ebp),%eax
   170ad:	83 c0 0d             	add    $0xd,%eax
   170b0:	0f b6 00             	movzbl (%eax),%eax
   170b3:	c1 e0 08             	shl    $0x8,%eax
   170b6:	09 c2                	or     %eax,%edx
   170b8:	8b 45 08             	mov    0x8(%ebp),%eax
   170bb:	83 c0 0c             	add    $0xc,%eax
   170be:	0f b6 00             	movzbl (%eax),%eax
   170c1:	09 d0                	or     %edx,%eax
   170c3:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   170c6:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   170c9:	89 41 0c             	mov    %eax,0xc(%ecx)
   170cc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   170cf:	8b 45 08             	mov    0x8(%ebp),%eax
   170d2:	83 c0 13             	add    $0x13,%eax
   170d5:	0f b6 00             	movzbl (%eax),%eax
   170d8:	89 c2                	mov    %eax,%edx
   170da:	c1 e2 18             	shl    $0x18,%edx
   170dd:	8b 45 08             	mov    0x8(%ebp),%eax
   170e0:	83 c0 12             	add    $0x12,%eax
   170e3:	0f b6 00             	movzbl (%eax),%eax
   170e6:	c1 e0 10             	shl    $0x10,%eax
   170e9:	09 c2                	or     %eax,%edx
   170eb:	8b 45 08             	mov    0x8(%ebp),%eax
   170ee:	83 c0 11             	add    $0x11,%eax
   170f1:	0f b6 00             	movzbl (%eax),%eax
   170f4:	c1 e0 08             	shl    $0x8,%eax
   170f7:	09 c2                	or     %eax,%edx
   170f9:	8b 45 08             	mov    0x8(%ebp),%eax
   170fc:	83 c0 10             	add    $0x10,%eax
   170ff:	0f b6 00             	movzbl (%eax),%eax
   17102:	09 d0                	or     %edx,%eax
   17104:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   17107:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1710a:	89 41 10             	mov    %eax,0x10(%ecx)
   1710d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17110:	8b 45 08             	mov    0x8(%ebp),%eax
   17113:	83 c0 17             	add    $0x17,%eax
   17116:	0f b6 00             	movzbl (%eax),%eax
   17119:	89 c2                	mov    %eax,%edx
   1711b:	c1 e2 18             	shl    $0x18,%edx
   1711e:	8b 45 08             	mov    0x8(%ebp),%eax
   17121:	83 c0 16             	add    $0x16,%eax
   17124:	0f b6 00             	movzbl (%eax),%eax
   17127:	c1 e0 10             	shl    $0x10,%eax
   1712a:	09 c2                	or     %eax,%edx
   1712c:	8b 45 08             	mov    0x8(%ebp),%eax
   1712f:	83 c0 15             	add    $0x15,%eax
   17132:	0f b6 00             	movzbl (%eax),%eax
   17135:	c1 e0 08             	shl    $0x8,%eax
   17138:	09 c2                	or     %eax,%edx
   1713a:	8b 45 08             	mov    0x8(%ebp),%eax
   1713d:	83 c0 14             	add    $0x14,%eax
   17140:	0f b6 00             	movzbl (%eax),%eax
   17143:	09 d0                	or     %edx,%eax
   17145:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   17148:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1714b:	89 41 14             	mov    %eax,0x14(%ecx)
   1714e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17151:	8b 45 08             	mov    0x8(%ebp),%eax
   17154:	83 c0 1b             	add    $0x1b,%eax
   17157:	0f b6 00             	movzbl (%eax),%eax
   1715a:	89 c2                	mov    %eax,%edx
   1715c:	c1 e2 18             	shl    $0x18,%edx
   1715f:	8b 45 08             	mov    0x8(%ebp),%eax
   17162:	83 c0 1a             	add    $0x1a,%eax
   17165:	0f b6 00             	movzbl (%eax),%eax
   17168:	c1 e0 10             	shl    $0x10,%eax
   1716b:	09 c2                	or     %eax,%edx
   1716d:	8b 45 08             	mov    0x8(%ebp),%eax
   17170:	83 c0 19             	add    $0x19,%eax
   17173:	0f b6 00             	movzbl (%eax),%eax
   17176:	c1 e0 08             	shl    $0x8,%eax
   17179:	09 c2                	or     %eax,%edx
   1717b:	8b 45 08             	mov    0x8(%ebp),%eax
   1717e:	83 c0 18             	add    $0x18,%eax
   17181:	0f b6 00             	movzbl (%eax),%eax
   17184:	09 d0                	or     %edx,%eax
   17186:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   17189:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1718c:	89 41 18             	mov    %eax,0x18(%ecx)
   1718f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17192:	8b 45 08             	mov    0x8(%ebp),%eax
   17195:	83 c0 1f             	add    $0x1f,%eax
   17198:	0f b6 00             	movzbl (%eax),%eax
   1719b:	89 c2                	mov    %eax,%edx
   1719d:	c1 e2 18             	shl    $0x18,%edx
   171a0:	8b 45 08             	mov    0x8(%ebp),%eax
   171a3:	83 c0 1e             	add    $0x1e,%eax
   171a6:	0f b6 00             	movzbl (%eax),%eax
   171a9:	c1 e0 10             	shl    $0x10,%eax
   171ac:	09 c2                	or     %eax,%edx
   171ae:	8b 45 08             	mov    0x8(%ebp),%eax
   171b1:	83 c0 1d             	add    $0x1d,%eax
   171b4:	0f b6 00             	movzbl (%eax),%eax
   171b7:	c1 e0 08             	shl    $0x8,%eax
   171ba:	09 c2                	or     %eax,%edx
   171bc:	8b 45 08             	mov    0x8(%ebp),%eax
   171bf:	83 c0 1c             	add    $0x1c,%eax
   171c2:	0f b6 00             	movzbl (%eax),%eax
   171c5:	09 d0                	or     %edx,%eax
   171c7:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   171ca:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   171cd:	89 41 1c             	mov    %eax,0x1c(%ecx)
   171d0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   171d3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   171d6:	c1 e8 08             	shr    $0x8,%eax
   171d9:	0f b6 d0             	movzbl %al,%edx
   171dc:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   171df:	c1 e8 10             	shr    $0x10,%eax
   171e2:	0f b6 c0             	movzbl %al,%eax
   171e5:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   171ec:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   171f3:	31 c2                	xor    %eax,%edx
   171f5:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   171f8:	c1 e8 18             	shr    $0x18,%eax
   171fb:	0f b6 c0             	movzbl %al,%eax
   171fe:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   17205:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   17209:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   17210:	89 d0                	mov    %edx,%eax
   17212:	89 c2                	mov    %eax,%edx
   17214:	33 15 00 00 00 00    	xor    0x0,%edx
   1721a:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   1721d:	31 10                	xor    %edx,(%eax)
   1721f:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   17222:	89 41 20             	mov    %eax,0x20(%ecx)
   17225:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17228:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   1722b:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   1722e:	31 10                	xor    %edx,(%eax)
   17230:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   17233:	89 41 24             	mov    %eax,0x24(%ecx)
   17236:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17239:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   1723c:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   1723f:	31 10                	xor    %edx,(%eax)
   17241:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   17244:	89 41 28             	mov    %eax,0x28(%ecx)
   17247:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1724a:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   1724d:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   17250:	31 10                	xor    %edx,(%eax)
   17252:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   17255:	89 41 2c             	mov    %eax,0x2c(%ecx)
   17258:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1725b:	0f b6 55 e4          	movzbl 0xffffffe4(%ebp),%edx
   1725f:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   17262:	c1 e8 08             	shr    $0x8,%eax
   17265:	0f b6 c0             	movzbl %al,%eax
   17268:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   1726f:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   17276:	31 c2                	xor    %eax,%edx
   17278:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1727b:	c1 e8 10             	shr    $0x10,%eax
   1727e:	0f b6 c0             	movzbl %al,%eax
   17281:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   17288:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1728b:	c1 e8 18             	shr    $0x18,%eax
   1728e:	0f b6 c0             	movzbl %al,%eax
   17291:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   17298:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   1729b:	31 10                	xor    %edx,(%eax)
   1729d:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   172a0:	89 41 30             	mov    %eax,0x30(%ecx)
   172a3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   172a6:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   172a9:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   172ac:	31 10                	xor    %edx,(%eax)
   172ae:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   172b1:	89 41 34             	mov    %eax,0x34(%ecx)
   172b4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   172b7:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   172ba:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   172bd:	31 10                	xor    %edx,(%eax)
   172bf:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   172c2:	89 41 38             	mov    %eax,0x38(%ecx)
   172c5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   172c8:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   172cb:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   172ce:	31 10                	xor    %edx,(%eax)
   172d0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   172d3:	89 41 3c             	mov    %eax,0x3c(%ecx)
   172d6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   172d9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   172dc:	c1 e8 08             	shr    $0x8,%eax
   172df:	0f b6 d0             	movzbl %al,%edx
   172e2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   172e5:	c1 e8 10             	shr    $0x10,%eax
   172e8:	0f b6 c0             	movzbl %al,%eax
   172eb:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   172f2:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   172f9:	31 c2                	xor    %eax,%edx
   172fb:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   172fe:	c1 e8 18             	shr    $0x18,%eax
   17301:	0f b6 c0             	movzbl %al,%eax
   17304:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   1730b:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   1730f:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   17316:	89 d0                	mov    %edx,%eax
   17318:	89 c2                	mov    %eax,%edx
   1731a:	33 15 04 00 00 00    	xor    0x4,%edx
   17320:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   17323:	31 10                	xor    %edx,(%eax)
   17325:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   17328:	89 41 40             	mov    %eax,0x40(%ecx)
   1732b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1732e:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   17331:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   17334:	31 10                	xor    %edx,(%eax)
   17336:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   17339:	89 41 44             	mov    %eax,0x44(%ecx)
   1733c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1733f:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   17342:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   17345:	31 10                	xor    %edx,(%eax)
   17347:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   1734a:	89 41 48             	mov    %eax,0x48(%ecx)
   1734d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17350:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   17353:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   17356:	31 10                	xor    %edx,(%eax)
   17358:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1735b:	89 41 4c             	mov    %eax,0x4c(%ecx)
   1735e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17361:	0f b6 55 e4          	movzbl 0xffffffe4(%ebp),%edx
   17365:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   17368:	c1 e8 08             	shr    $0x8,%eax
   1736b:	0f b6 c0             	movzbl %al,%eax
   1736e:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   17375:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1737c:	31 c2                	xor    %eax,%edx
   1737e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   17381:	c1 e8 10             	shr    $0x10,%eax
   17384:	0f b6 c0             	movzbl %al,%eax
   17387:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   1738e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   17391:	c1 e8 18             	shr    $0x18,%eax
   17394:	0f b6 c0             	movzbl %al,%eax
   17397:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1739e:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   173a1:	31 10                	xor    %edx,(%eax)
   173a3:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   173a6:	89 41 50             	mov    %eax,0x50(%ecx)
   173a9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   173ac:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   173af:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   173b2:	31 10                	xor    %edx,(%eax)
   173b4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   173b7:	89 41 54             	mov    %eax,0x54(%ecx)
   173ba:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   173bd:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   173c0:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   173c3:	31 10                	xor    %edx,(%eax)
   173c5:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   173c8:	89 41 58             	mov    %eax,0x58(%ecx)
   173cb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   173ce:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   173d1:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   173d4:	31 10                	xor    %edx,(%eax)
   173d6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   173d9:	89 41 5c             	mov    %eax,0x5c(%ecx)
   173dc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   173df:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   173e2:	c1 e8 08             	shr    $0x8,%eax
   173e5:	0f b6 d0             	movzbl %al,%edx
   173e8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   173eb:	c1 e8 10             	shr    $0x10,%eax
   173ee:	0f b6 c0             	movzbl %al,%eax
   173f1:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   173f8:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   173ff:	31 c2                	xor    %eax,%edx
   17401:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   17404:	c1 e8 18             	shr    $0x18,%eax
   17407:	0f b6 c0             	movzbl %al,%eax
   1740a:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   17411:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   17415:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1741c:	89 d0                	mov    %edx,%eax
   1741e:	89 c2                	mov    %eax,%edx
   17420:	33 15 08 00 00 00    	xor    0x8,%edx
   17426:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   17429:	31 10                	xor    %edx,(%eax)
   1742b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   1742e:	89 41 60             	mov    %eax,0x60(%ecx)
   17431:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17434:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   17437:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   1743a:	31 10                	xor    %edx,(%eax)
   1743c:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   1743f:	89 41 64             	mov    %eax,0x64(%ecx)
   17442:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17445:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   17448:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   1744b:	31 10                	xor    %edx,(%eax)
   1744d:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   17450:	89 41 68             	mov    %eax,0x68(%ecx)
   17453:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17456:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   17459:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   1745c:	31 10                	xor    %edx,(%eax)
   1745e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   17461:	89 41 6c             	mov    %eax,0x6c(%ecx)
   17464:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17467:	0f b6 55 e4          	movzbl 0xffffffe4(%ebp),%edx
   1746b:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1746e:	c1 e8 08             	shr    $0x8,%eax
   17471:	0f b6 c0             	movzbl %al,%eax
   17474:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   1747b:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   17482:	31 c2                	xor    %eax,%edx
   17484:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   17487:	c1 e8 10             	shr    $0x10,%eax
   1748a:	0f b6 c0             	movzbl %al,%eax
   1748d:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   17494:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   17497:	c1 e8 18             	shr    $0x18,%eax
   1749a:	0f b6 c0             	movzbl %al,%eax
   1749d:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   174a4:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   174a7:	31 10                	xor    %edx,(%eax)
   174a9:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   174ac:	89 41 70             	mov    %eax,0x70(%ecx)
   174af:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   174b2:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   174b5:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   174b8:	31 10                	xor    %edx,(%eax)
   174ba:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   174bd:	89 41 74             	mov    %eax,0x74(%ecx)
   174c0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   174c3:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   174c6:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   174c9:	31 10                	xor    %edx,(%eax)
   174cb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   174ce:	89 41 78             	mov    %eax,0x78(%ecx)
   174d1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   174d4:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   174d7:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   174da:	31 10                	xor    %edx,(%eax)
   174dc:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   174df:	89 41 7c             	mov    %eax,0x7c(%ecx)
   174e2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   174e5:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   174e8:	c1 e8 08             	shr    $0x8,%eax
   174eb:	0f b6 d0             	movzbl %al,%edx
   174ee:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   174f1:	c1 e8 10             	shr    $0x10,%eax
   174f4:	0f b6 c0             	movzbl %al,%eax
   174f7:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   174fe:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   17505:	31 c2                	xor    %eax,%edx
   17507:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1750a:	c1 e8 18             	shr    $0x18,%eax
   1750d:	0f b6 c0             	movzbl %al,%eax
   17510:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   17517:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   1751b:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   17522:	89 d0                	mov    %edx,%eax
   17524:	89 c2                	mov    %eax,%edx
   17526:	33 15 0c 00 00 00    	xor    0xc,%edx
   1752c:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   1752f:	31 10                	xor    %edx,(%eax)
   17531:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   17534:	89 81 80 00 00 00    	mov    %eax,0x80(%ecx)
   1753a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1753d:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   17540:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   17543:	31 10                	xor    %edx,(%eax)
   17545:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   17548:	89 81 84 00 00 00    	mov    %eax,0x84(%ecx)
   1754e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17551:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   17554:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   17557:	31 10                	xor    %edx,(%eax)
   17559:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   1755c:	89 81 88 00 00 00    	mov    %eax,0x88(%ecx)
   17562:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17565:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   17568:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   1756b:	31 10                	xor    %edx,(%eax)
   1756d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   17570:	89 81 8c 00 00 00    	mov    %eax,0x8c(%ecx)
   17576:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17579:	0f b6 55 e4          	movzbl 0xffffffe4(%ebp),%edx
   1757d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   17580:	c1 e8 08             	shr    $0x8,%eax
   17583:	0f b6 c0             	movzbl %al,%eax
   17586:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   1758d:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   17594:	31 c2                	xor    %eax,%edx
   17596:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   17599:	c1 e8 10             	shr    $0x10,%eax
   1759c:	0f b6 c0             	movzbl %al,%eax
   1759f:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   175a6:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   175a9:	c1 e8 18             	shr    $0x18,%eax
   175ac:	0f b6 c0             	movzbl %al,%eax
   175af:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   175b6:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   175b9:	31 10                	xor    %edx,(%eax)
   175bb:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   175be:	89 81 90 00 00 00    	mov    %eax,0x90(%ecx)
   175c4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   175c7:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   175ca:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   175cd:	31 10                	xor    %edx,(%eax)
   175cf:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   175d2:	89 81 94 00 00 00    	mov    %eax,0x94(%ecx)
   175d8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   175db:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   175de:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   175e1:	31 10                	xor    %edx,(%eax)
   175e3:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   175e6:	89 81 98 00 00 00    	mov    %eax,0x98(%ecx)
   175ec:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   175ef:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   175f2:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   175f5:	31 10                	xor    %edx,(%eax)
   175f7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   175fa:	89 81 9c 00 00 00    	mov    %eax,0x9c(%ecx)
   17600:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17603:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   17606:	c1 e8 08             	shr    $0x8,%eax
   17609:	0f b6 d0             	movzbl %al,%edx
   1760c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1760f:	c1 e8 10             	shr    $0x10,%eax
   17612:	0f b6 c0             	movzbl %al,%eax
   17615:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   1761c:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   17623:	31 c2                	xor    %eax,%edx
   17625:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   17628:	c1 e8 18             	shr    $0x18,%eax
   1762b:	0f b6 c0             	movzbl %al,%eax
   1762e:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   17635:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   17639:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   17640:	89 d0                	mov    %edx,%eax
   17642:	89 c2                	mov    %eax,%edx
   17644:	33 15 10 00 00 00    	xor    0x10,%edx
   1764a:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   1764d:	31 10                	xor    %edx,(%eax)
   1764f:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   17652:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
   17658:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1765b:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   1765e:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   17661:	31 10                	xor    %edx,(%eax)
   17663:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   17666:	89 81 a4 00 00 00    	mov    %eax,0xa4(%ecx)
   1766c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1766f:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   17672:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   17675:	31 10                	xor    %edx,(%eax)
   17677:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   1767a:	89 81 a8 00 00 00    	mov    %eax,0xa8(%ecx)
   17680:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17683:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   17686:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   17689:	31 10                	xor    %edx,(%eax)
   1768b:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1768e:	89 81 ac 00 00 00    	mov    %eax,0xac(%ecx)
   17694:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17697:	0f b6 55 e4          	movzbl 0xffffffe4(%ebp),%edx
   1769b:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1769e:	c1 e8 08             	shr    $0x8,%eax
   176a1:	0f b6 c0             	movzbl %al,%eax
   176a4:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   176ab:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   176b2:	31 c2                	xor    %eax,%edx
   176b4:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   176b7:	c1 e8 10             	shr    $0x10,%eax
   176ba:	0f b6 c0             	movzbl %al,%eax
   176bd:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   176c4:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   176c7:	c1 e8 18             	shr    $0x18,%eax
   176ca:	0f b6 c0             	movzbl %al,%eax
   176cd:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   176d4:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   176d7:	31 10                	xor    %edx,(%eax)
   176d9:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   176dc:	89 81 b0 00 00 00    	mov    %eax,0xb0(%ecx)
   176e2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   176e5:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   176e8:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   176eb:	31 10                	xor    %edx,(%eax)
   176ed:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   176f0:	89 81 b4 00 00 00    	mov    %eax,0xb4(%ecx)
   176f6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   176f9:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   176fc:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   176ff:	31 10                	xor    %edx,(%eax)
   17701:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   17704:	89 81 b8 00 00 00    	mov    %eax,0xb8(%ecx)
   1770a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1770d:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   17710:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   17713:	31 10                	xor    %edx,(%eax)
   17715:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   17718:	89 81 bc 00 00 00    	mov    %eax,0xbc(%ecx)
   1771e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17721:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   17724:	c1 e8 08             	shr    $0x8,%eax
   17727:	0f b6 d0             	movzbl %al,%edx
   1772a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1772d:	c1 e8 10             	shr    $0x10,%eax
   17730:	0f b6 c0             	movzbl %al,%eax
   17733:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   1773a:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   17741:	31 c2                	xor    %eax,%edx
   17743:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   17746:	c1 e8 18             	shr    $0x18,%eax
   17749:	0f b6 c0             	movzbl %al,%eax
   1774c:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   17753:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   17757:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1775e:	89 d0                	mov    %edx,%eax
   17760:	89 c2                	mov    %eax,%edx
   17762:	33 15 14 00 00 00    	xor    0x14,%edx
   17768:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   1776b:	31 10                	xor    %edx,(%eax)
   1776d:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   17770:	89 81 c0 00 00 00    	mov    %eax,0xc0(%ecx)
   17776:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17779:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   1777c:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   1777f:	31 10                	xor    %edx,(%eax)
   17781:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   17784:	89 81 c4 00 00 00    	mov    %eax,0xc4(%ecx)
   1778a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1778d:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   17790:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   17793:	31 10                	xor    %edx,(%eax)
   17795:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   17798:	89 81 c8 00 00 00    	mov    %eax,0xc8(%ecx)
   1779e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   177a1:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   177a4:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   177a7:	31 10                	xor    %edx,(%eax)
   177a9:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   177ac:	89 81 cc 00 00 00    	mov    %eax,0xcc(%ecx)
   177b2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   177b5:	0f b6 55 e4          	movzbl 0xffffffe4(%ebp),%edx
   177b9:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   177bc:	c1 e8 08             	shr    $0x8,%eax
   177bf:	0f b6 c0             	movzbl %al,%eax
   177c2:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   177c9:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   177d0:	31 c2                	xor    %eax,%edx
   177d2:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   177d5:	c1 e8 10             	shr    $0x10,%eax
   177d8:	0f b6 c0             	movzbl %al,%eax
   177db:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   177e2:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   177e5:	c1 e8 18             	shr    $0x18,%eax
   177e8:	0f b6 c0             	movzbl %al,%eax
   177eb:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   177f2:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   177f5:	31 10                	xor    %edx,(%eax)
   177f7:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   177fa:	89 81 d0 00 00 00    	mov    %eax,0xd0(%ecx)
   17800:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17803:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   17806:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   17809:	31 10                	xor    %edx,(%eax)
   1780b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1780e:	89 81 d4 00 00 00    	mov    %eax,0xd4(%ecx)
   17814:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17817:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   1781a:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   1781d:	31 10                	xor    %edx,(%eax)
   1781f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   17822:	89 81 d8 00 00 00    	mov    %eax,0xd8(%ecx)
   17828:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1782b:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   1782e:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   17831:	31 10                	xor    %edx,(%eax)
   17833:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   17836:	89 81 dc 00 00 00    	mov    %eax,0xdc(%ecx)
   1783c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1783f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   17842:	c1 e8 08             	shr    $0x8,%eax
   17845:	0f b6 d0             	movzbl %al,%edx
   17848:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1784b:	c1 e8 10             	shr    $0x10,%eax
   1784e:	0f b6 c0             	movzbl %al,%eax
   17851:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   17858:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1785f:	31 c2                	xor    %eax,%edx
   17861:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   17864:	c1 e8 18             	shr    $0x18,%eax
   17867:	0f b6 c0             	movzbl %al,%eax
   1786a:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   17871:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   17875:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1787c:	89 d0                	mov    %edx,%eax
   1787e:	89 c2                	mov    %eax,%edx
   17880:	33 15 18 00 00 00    	xor    0x18,%edx
   17886:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   17889:	31 10                	xor    %edx,(%eax)
   1788b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   1788e:	89 81 e0 00 00 00    	mov    %eax,0xe0(%ecx)
   17894:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17897:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   1789a:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   1789d:	31 10                	xor    %edx,(%eax)
   1789f:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   178a2:	89 81 e4 00 00 00    	mov    %eax,0xe4(%ecx)
   178a8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   178ab:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   178ae:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   178b1:	31 10                	xor    %edx,(%eax)
   178b3:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   178b6:	89 81 e8 00 00 00    	mov    %eax,0xe8(%ecx)
   178bc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   178bf:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   178c2:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   178c5:	31 10                	xor    %edx,(%eax)
   178c7:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   178ca:	89 81 ec 00 00 00    	mov    %eax,0xec(%ecx)
   178d0:	8b 45 0c             	mov    0xc(%ebp),%eax
   178d3:	c7 80 f0 00 00 00 0e 	movl   $0xe,0xf0(%eax)
   178da:	00 00 00 
   178dd:	b8 00 00 00 00       	mov    $0x0,%eax
   178e2:	c9                   	leave  
   178e3:	c3                   	ret    

000178e4 <aes_encrypt_key>:
   178e4:	55                   	push   %ebp
   178e5:	89 e5                	mov    %esp,%ebp
   178e7:	83 ec 08             	sub    $0x8,%esp
   178ea:	8b 45 0c             	mov    0xc(%ebp),%eax
   178ed:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   178f0:	83 7d f8 20          	cmpl   $0x20,0xfffffff8(%ebp)
   178f4:	74 68                	je     1795e <aes_encrypt_key+0x7a>
   178f6:	83 7d f8 20          	cmpl   $0x20,0xfffffff8(%ebp)
   178fa:	7f 0e                	jg     1790a <aes_encrypt_key+0x26>
   178fc:	83 7d f8 10          	cmpl   $0x10,0xfffffff8(%ebp)
   17900:	74 30                	je     17932 <aes_encrypt_key+0x4e>
   17902:	83 7d f8 18          	cmpl   $0x18,0xfffffff8(%ebp)
   17906:	74 40                	je     17948 <aes_encrypt_key+0x64>
   17908:	eb 6a                	jmp    17974 <aes_encrypt_key+0x90>
   1790a:	81 7d f8 c0 00 00 00 	cmpl   $0xc0,0xfffffff8(%ebp)
   17911:	74 35                	je     17948 <aes_encrypt_key+0x64>
   17913:	81 7d f8 c0 00 00 00 	cmpl   $0xc0,0xfffffff8(%ebp)
   1791a:	7f 0b                	jg     17927 <aes_encrypt_key+0x43>
   1791c:	81 7d f8 80 00 00 00 	cmpl   $0x80,0xfffffff8(%ebp)
   17923:	74 0d                	je     17932 <aes_encrypt_key+0x4e>
   17925:	eb 4d                	jmp    17974 <aes_encrypt_key+0x90>
   17927:	81 7d f8 00 01 00 00 	cmpl   $0x100,0xfffffff8(%ebp)
   1792e:	74 2e                	je     1795e <aes_encrypt_key+0x7a>
   17930:	eb 42                	jmp    17974 <aes_encrypt_key+0x90>
   17932:	83 ec 08             	sub    $0x8,%esp
   17935:	ff 75 10             	pushl  0x10(%ebp)
   17938:	ff 75 08             	pushl  0x8(%ebp)
   1793b:	e8 fc ff ff ff       	call   1793c <aes_encrypt_key+0x58>
   17940:	83 c4 10             	add    $0x10,%esp
   17943:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   17946:	eb 33                	jmp    1797b <aes_encrypt_key+0x97>
   17948:	83 ec 08             	sub    $0x8,%esp
   1794b:	ff 75 10             	pushl  0x10(%ebp)
   1794e:	ff 75 08             	pushl  0x8(%ebp)
   17951:	e8 fc ff ff ff       	call   17952 <aes_encrypt_key+0x6e>
   17956:	83 c4 10             	add    $0x10,%esp
   17959:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   1795c:	eb 1d                	jmp    1797b <aes_encrypt_key+0x97>
   1795e:	83 ec 08             	sub    $0x8,%esp
   17961:	ff 75 10             	pushl  0x10(%ebp)
   17964:	ff 75 08             	pushl  0x8(%ebp)
   17967:	e8 fc ff ff ff       	call   17968 <aes_encrypt_key+0x84>
   1796c:	83 c4 10             	add    $0x10,%esp
   1796f:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   17972:	eb 07                	jmp    1797b <aes_encrypt_key+0x97>
   17974:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,0xfffffffc(%ebp)
   1797b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1797e:	c9                   	leave  
   1797f:	c3                   	ret    

00017980 <aes_decrypt_key128>:
   17980:	55                   	push   %ebp
   17981:	89 e5                	mov    %esp,%ebp
   17983:	83 ec 28             	sub    $0x28,%esp
   17986:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17989:	8b 45 08             	mov    0x8(%ebp),%eax
   1798c:	83 c0 03             	add    $0x3,%eax
   1798f:	0f b6 00             	movzbl (%eax),%eax
   17992:	89 c2                	mov    %eax,%edx
   17994:	c1 e2 18             	shl    $0x18,%edx
   17997:	8b 45 08             	mov    0x8(%ebp),%eax
   1799a:	83 c0 02             	add    $0x2,%eax
   1799d:	0f b6 00             	movzbl (%eax),%eax
   179a0:	c1 e0 10             	shl    $0x10,%eax
   179a3:	09 c2                	or     %eax,%edx
   179a5:	8b 45 08             	mov    0x8(%ebp),%eax
   179a8:	40                   	inc    %eax
   179a9:	0f b6 00             	movzbl (%eax),%eax
   179ac:	c1 e0 08             	shl    $0x8,%eax
   179af:	09 c2                	or     %eax,%edx
   179b1:	8b 45 08             	mov    0x8(%ebp),%eax
   179b4:	0f b6 00             	movzbl (%eax),%eax
   179b7:	09 d0                	or     %edx,%eax
   179b9:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
   179bc:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   179bf:	89 01                	mov    %eax,(%ecx)
   179c1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   179c4:	8b 45 08             	mov    0x8(%ebp),%eax
   179c7:	83 c0 07             	add    $0x7,%eax
   179ca:	0f b6 00             	movzbl (%eax),%eax
   179cd:	89 c2                	mov    %eax,%edx
   179cf:	c1 e2 18             	shl    $0x18,%edx
   179d2:	8b 45 08             	mov    0x8(%ebp),%eax
   179d5:	83 c0 06             	add    $0x6,%eax
   179d8:	0f b6 00             	movzbl (%eax),%eax
   179db:	c1 e0 10             	shl    $0x10,%eax
   179de:	09 c2                	or     %eax,%edx
   179e0:	8b 45 08             	mov    0x8(%ebp),%eax
   179e3:	83 c0 05             	add    $0x5,%eax
   179e6:	0f b6 00             	movzbl (%eax),%eax
   179e9:	c1 e0 08             	shl    $0x8,%eax
   179ec:	09 c2                	or     %eax,%edx
   179ee:	8b 45 08             	mov    0x8(%ebp),%eax
   179f1:	83 c0 04             	add    $0x4,%eax
   179f4:	0f b6 00             	movzbl (%eax),%eax
   179f7:	09 d0                	or     %edx,%eax
   179f9:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
   179fc:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   179ff:	89 41 04             	mov    %eax,0x4(%ecx)
   17a02:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17a05:	8b 45 08             	mov    0x8(%ebp),%eax
   17a08:	83 c0 0b             	add    $0xb,%eax
   17a0b:	0f b6 00             	movzbl (%eax),%eax
   17a0e:	89 c2                	mov    %eax,%edx
   17a10:	c1 e2 18             	shl    $0x18,%edx
   17a13:	8b 45 08             	mov    0x8(%ebp),%eax
   17a16:	83 c0 0a             	add    $0xa,%eax
   17a19:	0f b6 00             	movzbl (%eax),%eax
   17a1c:	c1 e0 10             	shl    $0x10,%eax
   17a1f:	09 c2                	or     %eax,%edx
   17a21:	8b 45 08             	mov    0x8(%ebp),%eax
   17a24:	83 c0 09             	add    $0x9,%eax
   17a27:	0f b6 00             	movzbl (%eax),%eax
   17a2a:	c1 e0 08             	shl    $0x8,%eax
   17a2d:	09 c2                	or     %eax,%edx
   17a2f:	8b 45 08             	mov    0x8(%ebp),%eax
   17a32:	83 c0 08             	add    $0x8,%eax
   17a35:	0f b6 00             	movzbl (%eax),%eax
   17a38:	09 d0                	or     %edx,%eax
   17a3a:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   17a3d:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   17a40:	89 41 08             	mov    %eax,0x8(%ecx)
   17a43:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17a46:	8b 45 08             	mov    0x8(%ebp),%eax
   17a49:	83 c0 0f             	add    $0xf,%eax
   17a4c:	0f b6 00             	movzbl (%eax),%eax
   17a4f:	89 c2                	mov    %eax,%edx
   17a51:	c1 e2 18             	shl    $0x18,%edx
   17a54:	8b 45 08             	mov    0x8(%ebp),%eax
   17a57:	83 c0 0e             	add    $0xe,%eax
   17a5a:	0f b6 00             	movzbl (%eax),%eax
   17a5d:	c1 e0 10             	shl    $0x10,%eax
   17a60:	09 c2                	or     %eax,%edx
   17a62:	8b 45 08             	mov    0x8(%ebp),%eax
   17a65:	83 c0 0d             	add    $0xd,%eax
   17a68:	0f b6 00             	movzbl (%eax),%eax
   17a6b:	c1 e0 08             	shl    $0x8,%eax
   17a6e:	09 c2                	or     %eax,%edx
   17a70:	8b 45 08             	mov    0x8(%ebp),%eax
   17a73:	83 c0 0c             	add    $0xc,%eax
   17a76:	0f b6 00             	movzbl (%eax),%eax
   17a79:	09 d0                	or     %edx,%eax
   17a7b:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   17a7e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   17a81:	89 41 0c             	mov    %eax,0xc(%ecx)
   17a84:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   17a87:	33 45 d8             	xor    0xffffffd8(%ebp),%eax
   17a8a:	33 45 dc             	xor    0xffffffdc(%ebp),%eax
   17a8d:	33 45 e4             	xor    0xffffffe4(%ebp),%eax
   17a90:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
   17a93:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   17a96:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   17a99:	31 10                	xor    %edx,(%eax)
   17a9b:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   17a9e:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   17aa1:	31 10                	xor    %edx,(%eax)
   17aa3:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   17aa6:	c1 e8 08             	shr    $0x8,%eax
   17aa9:	0f b6 d0             	movzbl %al,%edx
   17aac:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   17aaf:	c1 e8 10             	shr    $0x10,%eax
   17ab2:	0f b6 c0             	movzbl %al,%eax
   17ab5:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   17abc:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   17ac3:	31 c2                	xor    %eax,%edx
   17ac5:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   17ac8:	c1 e8 18             	shr    $0x18,%eax
   17acb:	0f b6 c0             	movzbl %al,%eax
   17ace:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   17ad5:	0f b6 45 e4          	movzbl 0xffffffe4(%ebp),%eax
   17ad9:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   17ae0:	89 d0                	mov    %edx,%eax
   17ae2:	33 05 00 00 00 00    	xor    0x0,%eax
   17ae8:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   17aeb:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   17aee:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   17af1:	31 10                	xor    %edx,(%eax)
   17af3:	8b 45 0c             	mov    0xc(%ebp),%eax
   17af6:	8b 10                	mov    (%eax),%edx
   17af8:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   17afb:	31 10                	xor    %edx,(%eax)
   17afd:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17b00:	0f b6 55 e8          	movzbl 0xffffffe8(%ebp),%edx
   17b04:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17b07:	c1 e8 08             	shr    $0x8,%eax
   17b0a:	0f b6 c0             	movzbl %al,%eax
   17b0d:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   17b14:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   17b1b:	31 c2                	xor    %eax,%edx
   17b1d:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17b20:	c1 e8 10             	shr    $0x10,%eax
   17b23:	0f b6 c0             	movzbl %al,%eax
   17b26:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   17b2d:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17b30:	c1 e8 18             	shr    $0x18,%eax
   17b33:	0f b6 c0             	movzbl %al,%eax
   17b36:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   17b3d:	89 d0                	mov    %edx,%eax
   17b3f:	89 41 10             	mov    %eax,0x10(%ecx)
   17b42:	8b 45 0c             	mov    0xc(%ebp),%eax
   17b45:	8b 50 04             	mov    0x4(%eax),%edx
   17b48:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   17b4b:	31 10                	xor    %edx,(%eax)
   17b4d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17b50:	0f b6 55 e8          	movzbl 0xffffffe8(%ebp),%edx
   17b54:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17b57:	c1 e8 08             	shr    $0x8,%eax
   17b5a:	0f b6 c0             	movzbl %al,%eax
   17b5d:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   17b64:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   17b6b:	31 c2                	xor    %eax,%edx
   17b6d:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17b70:	c1 e8 10             	shr    $0x10,%eax
   17b73:	0f b6 c0             	movzbl %al,%eax
   17b76:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   17b7d:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17b80:	c1 e8 18             	shr    $0x18,%eax
   17b83:	0f b6 c0             	movzbl %al,%eax
   17b86:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   17b8d:	89 d0                	mov    %edx,%eax
   17b8f:	89 41 14             	mov    %eax,0x14(%ecx)
   17b92:	8b 45 0c             	mov    0xc(%ebp),%eax
   17b95:	8b 50 08             	mov    0x8(%eax),%edx
   17b98:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   17b9b:	31 10                	xor    %edx,(%eax)
   17b9d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17ba0:	0f b6 55 e8          	movzbl 0xffffffe8(%ebp),%edx
   17ba4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17ba7:	c1 e8 08             	shr    $0x8,%eax
   17baa:	0f b6 c0             	movzbl %al,%eax
   17bad:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   17bb4:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   17bbb:	31 c2                	xor    %eax,%edx
   17bbd:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17bc0:	c1 e8 10             	shr    $0x10,%eax
   17bc3:	0f b6 c0             	movzbl %al,%eax
   17bc6:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   17bcd:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17bd0:	c1 e8 18             	shr    $0x18,%eax
   17bd3:	0f b6 c0             	movzbl %al,%eax
   17bd6:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   17bdd:	89 d0                	mov    %edx,%eax
   17bdf:	89 41 18             	mov    %eax,0x18(%ecx)
   17be2:	8b 45 0c             	mov    0xc(%ebp),%eax
   17be5:	8b 50 0c             	mov    0xc(%eax),%edx
   17be8:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   17beb:	31 10                	xor    %edx,(%eax)
   17bed:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17bf0:	0f b6 55 e8          	movzbl 0xffffffe8(%ebp),%edx
   17bf4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17bf7:	c1 e8 08             	shr    $0x8,%eax
   17bfa:	0f b6 c0             	movzbl %al,%eax
   17bfd:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   17c04:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   17c0b:	31 c2                	xor    %eax,%edx
   17c0d:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17c10:	c1 e8 10             	shr    $0x10,%eax
   17c13:	0f b6 c0             	movzbl %al,%eax
   17c16:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   17c1d:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17c20:	c1 e8 18             	shr    $0x18,%eax
   17c23:	0f b6 c0             	movzbl %al,%eax
   17c26:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   17c2d:	89 d0                	mov    %edx,%eax
   17c2f:	89 41 1c             	mov    %eax,0x1c(%ecx)
   17c32:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   17c35:	c1 e8 08             	shr    $0x8,%eax
   17c38:	0f b6 d0             	movzbl %al,%edx
   17c3b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   17c3e:	c1 e8 10             	shr    $0x10,%eax
   17c41:	0f b6 c0             	movzbl %al,%eax
   17c44:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   17c4b:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   17c52:	31 c2                	xor    %eax,%edx
   17c54:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   17c57:	c1 e8 18             	shr    $0x18,%eax
   17c5a:	0f b6 c0             	movzbl %al,%eax
   17c5d:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   17c64:	0f b6 45 d8          	movzbl 0xffffffd8(%ebp),%eax
   17c68:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   17c6f:	89 d0                	mov    %edx,%eax
   17c71:	33 05 04 00 00 00    	xor    0x4,%eax
   17c77:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   17c7a:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   17c7d:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   17c80:	31 10                	xor    %edx,(%eax)
   17c82:	0f b6 55 e8          	movzbl 0xffffffe8(%ebp),%edx
   17c86:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17c89:	c1 e8 08             	shr    $0x8,%eax
   17c8c:	0f b6 c0             	movzbl %al,%eax
   17c8f:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   17c96:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   17c9d:	31 c2                	xor    %eax,%edx
   17c9f:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17ca2:	c1 e8 10             	shr    $0x10,%eax
   17ca5:	0f b6 c0             	movzbl %al,%eax
   17ca8:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   17caf:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17cb2:	c1 e8 18             	shr    $0x18,%eax
   17cb5:	0f b6 c0             	movzbl %al,%eax
   17cb8:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   17cbf:	89 d0                	mov    %edx,%eax
   17cc1:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   17cc4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17cc7:	8b 45 0c             	mov    0xc(%ebp),%eax
   17cca:	8b 50 10             	mov    0x10(%eax),%edx
   17ccd:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   17cd0:	31 10                	xor    %edx,(%eax)
   17cd2:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17cd5:	89 41 20             	mov    %eax,0x20(%ecx)
   17cd8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17cdb:	8b 45 0c             	mov    0xc(%ebp),%eax
   17cde:	8b 50 14             	mov    0x14(%eax),%edx
   17ce1:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   17ce4:	31 10                	xor    %edx,(%eax)
   17ce6:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17ce9:	89 41 24             	mov    %eax,0x24(%ecx)
   17cec:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17cef:	8b 45 0c             	mov    0xc(%ebp),%eax
   17cf2:	8b 50 18             	mov    0x18(%eax),%edx
   17cf5:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   17cf8:	31 10                	xor    %edx,(%eax)
   17cfa:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17cfd:	89 41 28             	mov    %eax,0x28(%ecx)
   17d00:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17d03:	8b 45 0c             	mov    0xc(%ebp),%eax
   17d06:	8b 50 1c             	mov    0x1c(%eax),%edx
   17d09:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   17d0c:	31 10                	xor    %edx,(%eax)
   17d0e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17d11:	89 41 2c             	mov    %eax,0x2c(%ecx)
   17d14:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   17d17:	c1 e8 08             	shr    $0x8,%eax
   17d1a:	0f b6 d0             	movzbl %al,%edx
   17d1d:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   17d20:	c1 e8 10             	shr    $0x10,%eax
   17d23:	0f b6 c0             	movzbl %al,%eax
   17d26:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   17d2d:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   17d34:	31 c2                	xor    %eax,%edx
   17d36:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   17d39:	c1 e8 18             	shr    $0x18,%eax
   17d3c:	0f b6 c0             	movzbl %al,%eax
   17d3f:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   17d46:	0f b6 45 dc          	movzbl 0xffffffdc(%ebp),%eax
   17d4a:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   17d51:	89 d0                	mov    %edx,%eax
   17d53:	33 05 08 00 00 00    	xor    0x8,%eax
   17d59:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   17d5c:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   17d5f:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   17d62:	31 10                	xor    %edx,(%eax)
   17d64:	0f b6 55 e8          	movzbl 0xffffffe8(%ebp),%edx
   17d68:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17d6b:	c1 e8 08             	shr    $0x8,%eax
   17d6e:	0f b6 c0             	movzbl %al,%eax
   17d71:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   17d78:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   17d7f:	31 c2                	xor    %eax,%edx
   17d81:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17d84:	c1 e8 10             	shr    $0x10,%eax
   17d87:	0f b6 c0             	movzbl %al,%eax
   17d8a:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   17d91:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17d94:	c1 e8 18             	shr    $0x18,%eax
   17d97:	0f b6 c0             	movzbl %al,%eax
   17d9a:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   17da1:	89 d0                	mov    %edx,%eax
   17da3:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   17da6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17da9:	8b 45 0c             	mov    0xc(%ebp),%eax
   17dac:	8b 50 20             	mov    0x20(%eax),%edx
   17daf:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   17db2:	31 10                	xor    %edx,(%eax)
   17db4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17db7:	89 41 30             	mov    %eax,0x30(%ecx)
   17dba:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17dbd:	8b 45 0c             	mov    0xc(%ebp),%eax
   17dc0:	8b 50 24             	mov    0x24(%eax),%edx
   17dc3:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   17dc6:	31 10                	xor    %edx,(%eax)
   17dc8:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17dcb:	89 41 34             	mov    %eax,0x34(%ecx)
   17dce:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17dd1:	8b 45 0c             	mov    0xc(%ebp),%eax
   17dd4:	8b 50 28             	mov    0x28(%eax),%edx
   17dd7:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   17dda:	31 10                	xor    %edx,(%eax)
   17ddc:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17ddf:	89 41 38             	mov    %eax,0x38(%ecx)
   17de2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17de5:	8b 45 0c             	mov    0xc(%ebp),%eax
   17de8:	8b 50 2c             	mov    0x2c(%eax),%edx
   17deb:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   17dee:	31 10                	xor    %edx,(%eax)
   17df0:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17df3:	89 41 3c             	mov    %eax,0x3c(%ecx)
   17df6:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   17df9:	c1 e8 08             	shr    $0x8,%eax
   17dfc:	0f b6 d0             	movzbl %al,%edx
   17dff:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   17e02:	c1 e8 10             	shr    $0x10,%eax
   17e05:	0f b6 c0             	movzbl %al,%eax
   17e08:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   17e0f:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   17e16:	31 c2                	xor    %eax,%edx
   17e18:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   17e1b:	c1 e8 18             	shr    $0x18,%eax
   17e1e:	0f b6 c0             	movzbl %al,%eax
   17e21:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   17e28:	0f b6 45 e0          	movzbl 0xffffffe0(%ebp),%eax
   17e2c:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   17e33:	89 d0                	mov    %edx,%eax
   17e35:	33 05 0c 00 00 00    	xor    0xc,%eax
   17e3b:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   17e3e:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   17e41:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   17e44:	31 10                	xor    %edx,(%eax)
   17e46:	0f b6 55 e8          	movzbl 0xffffffe8(%ebp),%edx
   17e4a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17e4d:	c1 e8 08             	shr    $0x8,%eax
   17e50:	0f b6 c0             	movzbl %al,%eax
   17e53:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   17e5a:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   17e61:	31 c2                	xor    %eax,%edx
   17e63:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17e66:	c1 e8 10             	shr    $0x10,%eax
   17e69:	0f b6 c0             	movzbl %al,%eax
   17e6c:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   17e73:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17e76:	c1 e8 18             	shr    $0x18,%eax
   17e79:	0f b6 c0             	movzbl %al,%eax
   17e7c:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   17e83:	89 d0                	mov    %edx,%eax
   17e85:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   17e88:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17e8b:	8b 45 0c             	mov    0xc(%ebp),%eax
   17e8e:	8b 50 30             	mov    0x30(%eax),%edx
   17e91:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   17e94:	31 10                	xor    %edx,(%eax)
   17e96:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17e99:	89 41 40             	mov    %eax,0x40(%ecx)
   17e9c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17e9f:	8b 45 0c             	mov    0xc(%ebp),%eax
   17ea2:	8b 50 34             	mov    0x34(%eax),%edx
   17ea5:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   17ea8:	31 10                	xor    %edx,(%eax)
   17eaa:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17ead:	89 41 44             	mov    %eax,0x44(%ecx)
   17eb0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17eb3:	8b 45 0c             	mov    0xc(%ebp),%eax
   17eb6:	8b 50 38             	mov    0x38(%eax),%edx
   17eb9:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   17ebc:	31 10                	xor    %edx,(%eax)
   17ebe:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17ec1:	89 41 48             	mov    %eax,0x48(%ecx)
   17ec4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17ec7:	8b 45 0c             	mov    0xc(%ebp),%eax
   17eca:	8b 50 3c             	mov    0x3c(%eax),%edx
   17ecd:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   17ed0:	31 10                	xor    %edx,(%eax)
   17ed2:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17ed5:	89 41 4c             	mov    %eax,0x4c(%ecx)
   17ed8:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   17edb:	c1 e8 08             	shr    $0x8,%eax
   17ede:	0f b6 d0             	movzbl %al,%edx
   17ee1:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   17ee4:	c1 e8 10             	shr    $0x10,%eax
   17ee7:	0f b6 c0             	movzbl %al,%eax
   17eea:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   17ef1:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   17ef8:	31 c2                	xor    %eax,%edx
   17efa:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   17efd:	c1 e8 18             	shr    $0x18,%eax
   17f00:	0f b6 c0             	movzbl %al,%eax
   17f03:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   17f0a:	0f b6 45 e4          	movzbl 0xffffffe4(%ebp),%eax
   17f0e:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   17f15:	89 d0                	mov    %edx,%eax
   17f17:	33 05 10 00 00 00    	xor    0x10,%eax
   17f1d:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   17f20:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   17f23:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   17f26:	31 10                	xor    %edx,(%eax)
   17f28:	0f b6 55 e8          	movzbl 0xffffffe8(%ebp),%edx
   17f2c:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17f2f:	c1 e8 08             	shr    $0x8,%eax
   17f32:	0f b6 c0             	movzbl %al,%eax
   17f35:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   17f3c:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   17f43:	31 c2                	xor    %eax,%edx
   17f45:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17f48:	c1 e8 10             	shr    $0x10,%eax
   17f4b:	0f b6 c0             	movzbl %al,%eax
   17f4e:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   17f55:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17f58:	c1 e8 18             	shr    $0x18,%eax
   17f5b:	0f b6 c0             	movzbl %al,%eax
   17f5e:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   17f65:	89 d0                	mov    %edx,%eax
   17f67:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   17f6a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17f6d:	8b 45 0c             	mov    0xc(%ebp),%eax
   17f70:	8b 50 40             	mov    0x40(%eax),%edx
   17f73:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   17f76:	31 10                	xor    %edx,(%eax)
   17f78:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17f7b:	89 41 50             	mov    %eax,0x50(%ecx)
   17f7e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17f81:	8b 45 0c             	mov    0xc(%ebp),%eax
   17f84:	8b 50 44             	mov    0x44(%eax),%edx
   17f87:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   17f8a:	31 10                	xor    %edx,(%eax)
   17f8c:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17f8f:	89 41 54             	mov    %eax,0x54(%ecx)
   17f92:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17f95:	8b 45 0c             	mov    0xc(%ebp),%eax
   17f98:	8b 50 48             	mov    0x48(%eax),%edx
   17f9b:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   17f9e:	31 10                	xor    %edx,(%eax)
   17fa0:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17fa3:	89 41 58             	mov    %eax,0x58(%ecx)
   17fa6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   17fa9:	8b 45 0c             	mov    0xc(%ebp),%eax
   17fac:	8b 50 4c             	mov    0x4c(%eax),%edx
   17faf:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   17fb2:	31 10                	xor    %edx,(%eax)
   17fb4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17fb7:	89 41 5c             	mov    %eax,0x5c(%ecx)
   17fba:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   17fbd:	c1 e8 08             	shr    $0x8,%eax
   17fc0:	0f b6 d0             	movzbl %al,%edx
   17fc3:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   17fc6:	c1 e8 10             	shr    $0x10,%eax
   17fc9:	0f b6 c0             	movzbl %al,%eax
   17fcc:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   17fd3:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   17fda:	31 c2                	xor    %eax,%edx
   17fdc:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   17fdf:	c1 e8 18             	shr    $0x18,%eax
   17fe2:	0f b6 c0             	movzbl %al,%eax
   17fe5:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   17fec:	0f b6 45 d8          	movzbl 0xffffffd8(%ebp),%eax
   17ff0:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   17ff7:	89 d0                	mov    %edx,%eax
   17ff9:	33 05 14 00 00 00    	xor    0x14,%eax
   17fff:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   18002:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   18005:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   18008:	31 10                	xor    %edx,(%eax)
   1800a:	0f b6 55 e8          	movzbl 0xffffffe8(%ebp),%edx
   1800e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18011:	c1 e8 08             	shr    $0x8,%eax
   18014:	0f b6 c0             	movzbl %al,%eax
   18017:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   1801e:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   18025:	31 c2                	xor    %eax,%edx
   18027:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1802a:	c1 e8 10             	shr    $0x10,%eax
   1802d:	0f b6 c0             	movzbl %al,%eax
   18030:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   18037:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1803a:	c1 e8 18             	shr    $0x18,%eax
   1803d:	0f b6 c0             	movzbl %al,%eax
   18040:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   18047:	89 d0                	mov    %edx,%eax
   18049:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1804c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1804f:	8b 45 0c             	mov    0xc(%ebp),%eax
   18052:	8b 50 50             	mov    0x50(%eax),%edx
   18055:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   18058:	31 10                	xor    %edx,(%eax)
   1805a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1805d:	89 41 60             	mov    %eax,0x60(%ecx)
   18060:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18063:	8b 45 0c             	mov    0xc(%ebp),%eax
   18066:	8b 50 54             	mov    0x54(%eax),%edx
   18069:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   1806c:	31 10                	xor    %edx,(%eax)
   1806e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18071:	89 41 64             	mov    %eax,0x64(%ecx)
   18074:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18077:	8b 45 0c             	mov    0xc(%ebp),%eax
   1807a:	8b 50 58             	mov    0x58(%eax),%edx
   1807d:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   18080:	31 10                	xor    %edx,(%eax)
   18082:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18085:	89 41 68             	mov    %eax,0x68(%ecx)
   18088:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1808b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1808e:	8b 50 5c             	mov    0x5c(%eax),%edx
   18091:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   18094:	31 10                	xor    %edx,(%eax)
   18096:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18099:	89 41 6c             	mov    %eax,0x6c(%ecx)
   1809c:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   1809f:	c1 e8 08             	shr    $0x8,%eax
   180a2:	0f b6 d0             	movzbl %al,%edx
   180a5:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   180a8:	c1 e8 10             	shr    $0x10,%eax
   180ab:	0f b6 c0             	movzbl %al,%eax
   180ae:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   180b5:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   180bc:	31 c2                	xor    %eax,%edx
   180be:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   180c1:	c1 e8 18             	shr    $0x18,%eax
   180c4:	0f b6 c0             	movzbl %al,%eax
   180c7:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   180ce:	0f b6 45 dc          	movzbl 0xffffffdc(%ebp),%eax
   180d2:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   180d9:	89 d0                	mov    %edx,%eax
   180db:	33 05 18 00 00 00    	xor    0x18,%eax
   180e1:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   180e4:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   180e7:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   180ea:	31 10                	xor    %edx,(%eax)
   180ec:	0f b6 55 e8          	movzbl 0xffffffe8(%ebp),%edx
   180f0:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   180f3:	c1 e8 08             	shr    $0x8,%eax
   180f6:	0f b6 c0             	movzbl %al,%eax
   180f9:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   18100:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   18107:	31 c2                	xor    %eax,%edx
   18109:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1810c:	c1 e8 10             	shr    $0x10,%eax
   1810f:	0f b6 c0             	movzbl %al,%eax
   18112:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   18119:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1811c:	c1 e8 18             	shr    $0x18,%eax
   1811f:	0f b6 c0             	movzbl %al,%eax
   18122:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   18129:	89 d0                	mov    %edx,%eax
   1812b:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1812e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18131:	8b 45 0c             	mov    0xc(%ebp),%eax
   18134:	8b 50 60             	mov    0x60(%eax),%edx
   18137:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   1813a:	31 10                	xor    %edx,(%eax)
   1813c:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1813f:	89 41 70             	mov    %eax,0x70(%ecx)
   18142:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18145:	8b 45 0c             	mov    0xc(%ebp),%eax
   18148:	8b 50 64             	mov    0x64(%eax),%edx
   1814b:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   1814e:	31 10                	xor    %edx,(%eax)
   18150:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18153:	89 41 74             	mov    %eax,0x74(%ecx)
   18156:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18159:	8b 45 0c             	mov    0xc(%ebp),%eax
   1815c:	8b 50 68             	mov    0x68(%eax),%edx
   1815f:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   18162:	31 10                	xor    %edx,(%eax)
   18164:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18167:	89 41 78             	mov    %eax,0x78(%ecx)
   1816a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1816d:	8b 45 0c             	mov    0xc(%ebp),%eax
   18170:	8b 50 6c             	mov    0x6c(%eax),%edx
   18173:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   18176:	31 10                	xor    %edx,(%eax)
   18178:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1817b:	89 41 7c             	mov    %eax,0x7c(%ecx)
   1817e:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   18181:	c1 e8 08             	shr    $0x8,%eax
   18184:	0f b6 d0             	movzbl %al,%edx
   18187:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   1818a:	c1 e8 10             	shr    $0x10,%eax
   1818d:	0f b6 c0             	movzbl %al,%eax
   18190:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   18197:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1819e:	31 c2                	xor    %eax,%edx
   181a0:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   181a3:	c1 e8 18             	shr    $0x18,%eax
   181a6:	0f b6 c0             	movzbl %al,%eax
   181a9:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   181b0:	0f b6 45 e0          	movzbl 0xffffffe0(%ebp),%eax
   181b4:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   181bb:	89 d0                	mov    %edx,%eax
   181bd:	33 05 1c 00 00 00    	xor    0x1c,%eax
   181c3:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   181c6:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   181c9:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   181cc:	31 10                	xor    %edx,(%eax)
   181ce:	0f b6 55 e8          	movzbl 0xffffffe8(%ebp),%edx
   181d2:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   181d5:	c1 e8 08             	shr    $0x8,%eax
   181d8:	0f b6 c0             	movzbl %al,%eax
   181db:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   181e2:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   181e9:	31 c2                	xor    %eax,%edx
   181eb:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   181ee:	c1 e8 10             	shr    $0x10,%eax
   181f1:	0f b6 c0             	movzbl %al,%eax
   181f4:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   181fb:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   181fe:	c1 e8 18             	shr    $0x18,%eax
   18201:	0f b6 c0             	movzbl %al,%eax
   18204:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1820b:	89 d0                	mov    %edx,%eax
   1820d:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   18210:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18213:	8b 45 0c             	mov    0xc(%ebp),%eax
   18216:	8b 50 70             	mov    0x70(%eax),%edx
   18219:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   1821c:	31 10                	xor    %edx,(%eax)
   1821e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18221:	89 81 80 00 00 00    	mov    %eax,0x80(%ecx)
   18227:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1822a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1822d:	8b 50 74             	mov    0x74(%eax),%edx
   18230:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   18233:	31 10                	xor    %edx,(%eax)
   18235:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18238:	89 81 84 00 00 00    	mov    %eax,0x84(%ecx)
   1823e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18241:	8b 45 0c             	mov    0xc(%ebp),%eax
   18244:	8b 50 78             	mov    0x78(%eax),%edx
   18247:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   1824a:	31 10                	xor    %edx,(%eax)
   1824c:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1824f:	89 81 88 00 00 00    	mov    %eax,0x88(%ecx)
   18255:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18258:	8b 45 0c             	mov    0xc(%ebp),%eax
   1825b:	8b 50 7c             	mov    0x7c(%eax),%edx
   1825e:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   18261:	31 10                	xor    %edx,(%eax)
   18263:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18266:	89 81 8c 00 00 00    	mov    %eax,0x8c(%ecx)
   1826c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1826f:	c1 e8 08             	shr    $0x8,%eax
   18272:	0f b6 d0             	movzbl %al,%edx
   18275:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   18278:	c1 e8 10             	shr    $0x10,%eax
   1827b:	0f b6 c0             	movzbl %al,%eax
   1827e:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   18285:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1828c:	31 c2                	xor    %eax,%edx
   1828e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   18291:	c1 e8 18             	shr    $0x18,%eax
   18294:	0f b6 c0             	movzbl %al,%eax
   18297:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   1829e:	0f b6 45 e4          	movzbl 0xffffffe4(%ebp),%eax
   182a2:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   182a9:	89 d0                	mov    %edx,%eax
   182ab:	33 05 20 00 00 00    	xor    0x20,%eax
   182b1:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   182b4:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   182b7:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   182ba:	31 10                	xor    %edx,(%eax)
   182bc:	0f b6 55 e8          	movzbl 0xffffffe8(%ebp),%edx
   182c0:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   182c3:	c1 e8 08             	shr    $0x8,%eax
   182c6:	0f b6 c0             	movzbl %al,%eax
   182c9:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   182d0:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   182d7:	31 c2                	xor    %eax,%edx
   182d9:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   182dc:	c1 e8 10             	shr    $0x10,%eax
   182df:	0f b6 c0             	movzbl %al,%eax
   182e2:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   182e9:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   182ec:	c1 e8 18             	shr    $0x18,%eax
   182ef:	0f b6 c0             	movzbl %al,%eax
   182f2:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   182f9:	89 d0                	mov    %edx,%eax
   182fb:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   182fe:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18301:	8b 45 0c             	mov    0xc(%ebp),%eax
   18304:	8b 90 80 00 00 00    	mov    0x80(%eax),%edx
   1830a:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   1830d:	31 10                	xor    %edx,(%eax)
   1830f:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18312:	89 81 90 00 00 00    	mov    %eax,0x90(%ecx)
   18318:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1831b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1831e:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
   18324:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   18327:	31 10                	xor    %edx,(%eax)
   18329:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1832c:	89 81 94 00 00 00    	mov    %eax,0x94(%ecx)
   18332:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18335:	8b 45 0c             	mov    0xc(%ebp),%eax
   18338:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
   1833e:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   18341:	31 10                	xor    %edx,(%eax)
   18343:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18346:	89 81 98 00 00 00    	mov    %eax,0x98(%ecx)
   1834c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1834f:	8b 45 0c             	mov    0xc(%ebp),%eax
   18352:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
   18358:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   1835b:	31 10                	xor    %edx,(%eax)
   1835d:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18360:	89 81 9c 00 00 00    	mov    %eax,0x9c(%ecx)
   18366:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   18369:	c1 e8 08             	shr    $0x8,%eax
   1836c:	0f b6 d0             	movzbl %al,%edx
   1836f:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   18372:	c1 e8 10             	shr    $0x10,%eax
   18375:	0f b6 c0             	movzbl %al,%eax
   18378:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   1837f:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   18386:	31 c2                	xor    %eax,%edx
   18388:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   1838b:	c1 e8 18             	shr    $0x18,%eax
   1838e:	0f b6 c0             	movzbl %al,%eax
   18391:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   18398:	0f b6 45 d8          	movzbl 0xffffffd8(%ebp),%eax
   1839c:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   183a3:	89 d0                	mov    %edx,%eax
   183a5:	33 05 24 00 00 00    	xor    0x24,%eax
   183ab:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   183ae:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   183b1:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   183b4:	31 10                	xor    %edx,(%eax)
   183b6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   183b9:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   183bc:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   183bf:	31 10                	xor    %edx,(%eax)
   183c1:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   183c4:	33 45 e0             	xor    0xffffffe0(%ebp),%eax
   183c7:	33 45 e4             	xor    0xffffffe4(%ebp),%eax
   183ca:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
   183d0:	8b 55 0c             	mov    0xc(%ebp),%edx
   183d3:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   183d6:	33 45 dc             	xor    0xffffffdc(%ebp),%eax
   183d9:	89 82 a4 00 00 00    	mov    %eax,0xa4(%edx)
   183df:	8b 55 0c             	mov    0xc(%ebp),%edx
   183e2:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   183e5:	89 82 a8 00 00 00    	mov    %eax,0xa8(%edx)
   183eb:	8b 55 0c             	mov    0xc(%ebp),%edx
   183ee:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   183f1:	89 82 ac 00 00 00    	mov    %eax,0xac(%edx)
   183f7:	8b 45 0c             	mov    0xc(%ebp),%eax
   183fa:	c7 80 f0 00 00 00 0a 	movl   $0xa,0xf0(%eax)
   18401:	00 00 00 
   18404:	b8 00 00 00 00       	mov    $0x0,%eax
   18409:	c9                   	leave  
   1840a:	c3                   	ret    

0001840b <aes_decrypt_key192>:
   1840b:	55                   	push   %ebp
   1840c:	89 e5                	mov    %esp,%ebp
   1840e:	53                   	push   %ebx
   1840f:	83 ec 24             	sub    $0x24,%esp
   18412:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18415:	8b 45 08             	mov    0x8(%ebp),%eax
   18418:	83 c0 03             	add    $0x3,%eax
   1841b:	0f b6 00             	movzbl (%eax),%eax
   1841e:	89 c2                	mov    %eax,%edx
   18420:	c1 e2 18             	shl    $0x18,%edx
   18423:	8b 45 08             	mov    0x8(%ebp),%eax
   18426:	83 c0 02             	add    $0x2,%eax
   18429:	0f b6 00             	movzbl (%eax),%eax
   1842c:	c1 e0 10             	shl    $0x10,%eax
   1842f:	09 c2                	or     %eax,%edx
   18431:	8b 45 08             	mov    0x8(%ebp),%eax
   18434:	40                   	inc    %eax
   18435:	0f b6 00             	movzbl (%eax),%eax
   18438:	c1 e0 08             	shl    $0x8,%eax
   1843b:	09 c2                	or     %eax,%edx
   1843d:	8b 45 08             	mov    0x8(%ebp),%eax
   18440:	0f b6 00             	movzbl (%eax),%eax
   18443:	09 d0                	or     %edx,%eax
   18445:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
   18448:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   1844b:	89 01                	mov    %eax,(%ecx)
   1844d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18450:	8b 45 08             	mov    0x8(%ebp),%eax
   18453:	83 c0 07             	add    $0x7,%eax
   18456:	0f b6 00             	movzbl (%eax),%eax
   18459:	89 c2                	mov    %eax,%edx
   1845b:	c1 e2 18             	shl    $0x18,%edx
   1845e:	8b 45 08             	mov    0x8(%ebp),%eax
   18461:	83 c0 06             	add    $0x6,%eax
   18464:	0f b6 00             	movzbl (%eax),%eax
   18467:	c1 e0 10             	shl    $0x10,%eax
   1846a:	09 c2                	or     %eax,%edx
   1846c:	8b 45 08             	mov    0x8(%ebp),%eax
   1846f:	83 c0 05             	add    $0x5,%eax
   18472:	0f b6 00             	movzbl (%eax),%eax
   18475:	c1 e0 08             	shl    $0x8,%eax
   18478:	09 c2                	or     %eax,%edx
   1847a:	8b 45 08             	mov    0x8(%ebp),%eax
   1847d:	83 c0 04             	add    $0x4,%eax
   18480:	0f b6 00             	movzbl (%eax),%eax
   18483:	09 d0                	or     %edx,%eax
   18485:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
   18488:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   1848b:	89 41 04             	mov    %eax,0x4(%ecx)
   1848e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18491:	8b 45 08             	mov    0x8(%ebp),%eax
   18494:	83 c0 0b             	add    $0xb,%eax
   18497:	0f b6 00             	movzbl (%eax),%eax
   1849a:	89 c2                	mov    %eax,%edx
   1849c:	c1 e2 18             	shl    $0x18,%edx
   1849f:	8b 45 08             	mov    0x8(%ebp),%eax
   184a2:	83 c0 0a             	add    $0xa,%eax
   184a5:	0f b6 00             	movzbl (%eax),%eax
   184a8:	c1 e0 10             	shl    $0x10,%eax
   184ab:	09 c2                	or     %eax,%edx
   184ad:	8b 45 08             	mov    0x8(%ebp),%eax
   184b0:	83 c0 09             	add    $0x9,%eax
   184b3:	0f b6 00             	movzbl (%eax),%eax
   184b6:	c1 e0 08             	shl    $0x8,%eax
   184b9:	09 c2                	or     %eax,%edx
   184bb:	8b 45 08             	mov    0x8(%ebp),%eax
   184be:	83 c0 08             	add    $0x8,%eax
   184c1:	0f b6 00             	movzbl (%eax),%eax
   184c4:	09 d0                	or     %edx,%eax
   184c6:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   184c9:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   184cc:	89 41 08             	mov    %eax,0x8(%ecx)
   184cf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   184d2:	8b 45 08             	mov    0x8(%ebp),%eax
   184d5:	83 c0 0f             	add    $0xf,%eax
   184d8:	0f b6 00             	movzbl (%eax),%eax
   184db:	89 c2                	mov    %eax,%edx
   184dd:	c1 e2 18             	shl    $0x18,%edx
   184e0:	8b 45 08             	mov    0x8(%ebp),%eax
   184e3:	83 c0 0e             	add    $0xe,%eax
   184e6:	0f b6 00             	movzbl (%eax),%eax
   184e9:	c1 e0 10             	shl    $0x10,%eax
   184ec:	09 c2                	or     %eax,%edx
   184ee:	8b 45 08             	mov    0x8(%ebp),%eax
   184f1:	83 c0 0d             	add    $0xd,%eax
   184f4:	0f b6 00             	movzbl (%eax),%eax
   184f7:	c1 e0 08             	shl    $0x8,%eax
   184fa:	09 c2                	or     %eax,%edx
   184fc:	8b 45 08             	mov    0x8(%ebp),%eax
   184ff:	83 c0 0c             	add    $0xc,%eax
   18502:	0f b6 00             	movzbl (%eax),%eax
   18505:	09 d0                	or     %edx,%eax
   18507:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   1850a:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1850d:	89 41 0c             	mov    %eax,0xc(%ecx)
   18510:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   18513:	8b 45 08             	mov    0x8(%ebp),%eax
   18516:	83 c0 13             	add    $0x13,%eax
   18519:	0f b6 00             	movzbl (%eax),%eax
   1851c:	89 c2                	mov    %eax,%edx
   1851e:	c1 e2 18             	shl    $0x18,%edx
   18521:	8b 45 08             	mov    0x8(%ebp),%eax
   18524:	83 c0 12             	add    $0x12,%eax
   18527:	0f b6 00             	movzbl (%eax),%eax
   1852a:	c1 e0 10             	shl    $0x10,%eax
   1852d:	09 c2                	or     %eax,%edx
   1852f:	8b 45 08             	mov    0x8(%ebp),%eax
   18532:	83 c0 11             	add    $0x11,%eax
   18535:	0f b6 00             	movzbl (%eax),%eax
   18538:	c1 e0 08             	shl    $0x8,%eax
   1853b:	09 c2                	or     %eax,%edx
   1853d:	8b 45 08             	mov    0x8(%ebp),%eax
   18540:	83 c0 10             	add    $0x10,%eax
   18543:	0f b6 00             	movzbl (%eax),%eax
   18546:	09 d0                	or     %edx,%eax
   18548:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1854b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1854e:	0f b6 c8             	movzbl %al,%ecx
   18551:	8b 45 08             	mov    0x8(%ebp),%eax
   18554:	83 c0 13             	add    $0x13,%eax
   18557:	0f b6 00             	movzbl (%eax),%eax
   1855a:	89 c2                	mov    %eax,%edx
   1855c:	c1 e2 18             	shl    $0x18,%edx
   1855f:	8b 45 08             	mov    0x8(%ebp),%eax
   18562:	83 c0 12             	add    $0x12,%eax
   18565:	0f b6 00             	movzbl (%eax),%eax
   18568:	c1 e0 10             	shl    $0x10,%eax
   1856b:	09 c2                	or     %eax,%edx
   1856d:	8b 45 08             	mov    0x8(%ebp),%eax
   18570:	83 c0 11             	add    $0x11,%eax
   18573:	0f b6 00             	movzbl (%eax),%eax
   18576:	c1 e0 08             	shl    $0x8,%eax
   18579:	09 c2                	or     %eax,%edx
   1857b:	8b 45 08             	mov    0x8(%ebp),%eax
   1857e:	83 c0 10             	add    $0x10,%eax
   18581:	0f b6 00             	movzbl (%eax),%eax
   18584:	09 d0                	or     %edx,%eax
   18586:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   18589:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1858c:	c1 e8 08             	shr    $0x8,%eax
   1858f:	0f b6 c0             	movzbl %al,%eax
   18592:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   18599:	8b 0c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%ecx
   185a0:	31 c1                	xor    %eax,%ecx
   185a2:	8b 45 08             	mov    0x8(%ebp),%eax
   185a5:	83 c0 13             	add    $0x13,%eax
   185a8:	0f b6 00             	movzbl (%eax),%eax
   185ab:	89 c2                	mov    %eax,%edx
   185ad:	c1 e2 18             	shl    $0x18,%edx
   185b0:	8b 45 08             	mov    0x8(%ebp),%eax
   185b3:	83 c0 12             	add    $0x12,%eax
   185b6:	0f b6 00             	movzbl (%eax),%eax
   185b9:	c1 e0 10             	shl    $0x10,%eax
   185bc:	09 c2                	or     %eax,%edx
   185be:	8b 45 08             	mov    0x8(%ebp),%eax
   185c1:	83 c0 11             	add    $0x11,%eax
   185c4:	0f b6 00             	movzbl (%eax),%eax
   185c7:	c1 e0 08             	shl    $0x8,%eax
   185ca:	09 c2                	or     %eax,%edx
   185cc:	8b 45 08             	mov    0x8(%ebp),%eax
   185cf:	83 c0 10             	add    $0x10,%eax
   185d2:	0f b6 00             	movzbl (%eax),%eax
   185d5:	09 d0                	or     %edx,%eax
   185d7:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   185da:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   185dd:	c1 e8 10             	shr    $0x10,%eax
   185e0:	0f b6 c0             	movzbl %al,%eax
   185e3:	33 0c 85 00 08 00 00 	xor    0x800(,%eax,4),%ecx
   185ea:	8b 45 08             	mov    0x8(%ebp),%eax
   185ed:	83 c0 13             	add    $0x13,%eax
   185f0:	0f b6 00             	movzbl (%eax),%eax
   185f3:	89 c2                	mov    %eax,%edx
   185f5:	c1 e2 18             	shl    $0x18,%edx
   185f8:	8b 45 08             	mov    0x8(%ebp),%eax
   185fb:	83 c0 12             	add    $0x12,%eax
   185fe:	0f b6 00             	movzbl (%eax),%eax
   18601:	c1 e0 10             	shl    $0x10,%eax
   18604:	09 c2                	or     %eax,%edx
   18606:	8b 45 08             	mov    0x8(%ebp),%eax
   18609:	83 c0 11             	add    $0x11,%eax
   1860c:	0f b6 00             	movzbl (%eax),%eax
   1860f:	c1 e0 08             	shl    $0x8,%eax
   18612:	09 c2                	or     %eax,%edx
   18614:	8b 45 08             	mov    0x8(%ebp),%eax
   18617:	83 c0 10             	add    $0x10,%eax
   1861a:	0f b6 00             	movzbl (%eax),%eax
   1861d:	09 d0                	or     %edx,%eax
   1861f:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   18622:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18625:	c1 e8 18             	shr    $0x18,%eax
   18628:	0f b6 c0             	movzbl %al,%eax
   1862b:	33 0c 85 00 0c 00 00 	xor    0xc00(,%eax,4),%ecx
   18632:	89 c8                	mov    %ecx,%eax
   18634:	89 43 10             	mov    %eax,0x10(%ebx)
   18637:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   1863a:	8b 45 08             	mov    0x8(%ebp),%eax
   1863d:	83 c0 17             	add    $0x17,%eax
   18640:	0f b6 00             	movzbl (%eax),%eax
   18643:	89 c2                	mov    %eax,%edx
   18645:	c1 e2 18             	shl    $0x18,%edx
   18648:	8b 45 08             	mov    0x8(%ebp),%eax
   1864b:	83 c0 16             	add    $0x16,%eax
   1864e:	0f b6 00             	movzbl (%eax),%eax
   18651:	c1 e0 10             	shl    $0x10,%eax
   18654:	09 c2                	or     %eax,%edx
   18656:	8b 45 08             	mov    0x8(%ebp),%eax
   18659:	83 c0 15             	add    $0x15,%eax
   1865c:	0f b6 00             	movzbl (%eax),%eax
   1865f:	c1 e0 08             	shl    $0x8,%eax
   18662:	09 c2                	or     %eax,%edx
   18664:	8b 45 08             	mov    0x8(%ebp),%eax
   18667:	83 c0 14             	add    $0x14,%eax
   1866a:	0f b6 00             	movzbl (%eax),%eax
   1866d:	09 d0                	or     %edx,%eax
   1866f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   18672:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   18675:	0f b6 c8             	movzbl %al,%ecx
   18678:	8b 45 08             	mov    0x8(%ebp),%eax
   1867b:	83 c0 17             	add    $0x17,%eax
   1867e:	0f b6 00             	movzbl (%eax),%eax
   18681:	89 c2                	mov    %eax,%edx
   18683:	c1 e2 18             	shl    $0x18,%edx
   18686:	8b 45 08             	mov    0x8(%ebp),%eax
   18689:	83 c0 16             	add    $0x16,%eax
   1868c:	0f b6 00             	movzbl (%eax),%eax
   1868f:	c1 e0 10             	shl    $0x10,%eax
   18692:	09 c2                	or     %eax,%edx
   18694:	8b 45 08             	mov    0x8(%ebp),%eax
   18697:	83 c0 15             	add    $0x15,%eax
   1869a:	0f b6 00             	movzbl (%eax),%eax
   1869d:	c1 e0 08             	shl    $0x8,%eax
   186a0:	09 c2                	or     %eax,%edx
   186a2:	8b 45 08             	mov    0x8(%ebp),%eax
   186a5:	83 c0 14             	add    $0x14,%eax
   186a8:	0f b6 00             	movzbl (%eax),%eax
   186ab:	09 d0                	or     %edx,%eax
   186ad:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   186b0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   186b3:	c1 e8 08             	shr    $0x8,%eax
   186b6:	0f b6 c0             	movzbl %al,%eax
   186b9:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   186c0:	8b 0c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%ecx
   186c7:	31 c1                	xor    %eax,%ecx
   186c9:	8b 45 08             	mov    0x8(%ebp),%eax
   186cc:	83 c0 17             	add    $0x17,%eax
   186cf:	0f b6 00             	movzbl (%eax),%eax
   186d2:	89 c2                	mov    %eax,%edx
   186d4:	c1 e2 18             	shl    $0x18,%edx
   186d7:	8b 45 08             	mov    0x8(%ebp),%eax
   186da:	83 c0 16             	add    $0x16,%eax
   186dd:	0f b6 00             	movzbl (%eax),%eax
   186e0:	c1 e0 10             	shl    $0x10,%eax
   186e3:	09 c2                	or     %eax,%edx
   186e5:	8b 45 08             	mov    0x8(%ebp),%eax
   186e8:	83 c0 15             	add    $0x15,%eax
   186eb:	0f b6 00             	movzbl (%eax),%eax
   186ee:	c1 e0 08             	shl    $0x8,%eax
   186f1:	09 c2                	or     %eax,%edx
   186f3:	8b 45 08             	mov    0x8(%ebp),%eax
   186f6:	83 c0 14             	add    $0x14,%eax
   186f9:	0f b6 00             	movzbl (%eax),%eax
   186fc:	09 d0                	or     %edx,%eax
   186fe:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   18701:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   18704:	c1 e8 10             	shr    $0x10,%eax
   18707:	0f b6 c0             	movzbl %al,%eax
   1870a:	33 0c 85 00 08 00 00 	xor    0x800(,%eax,4),%ecx
   18711:	8b 45 08             	mov    0x8(%ebp),%eax
   18714:	83 c0 17             	add    $0x17,%eax
   18717:	0f b6 00             	movzbl (%eax),%eax
   1871a:	89 c2                	mov    %eax,%edx
   1871c:	c1 e2 18             	shl    $0x18,%edx
   1871f:	8b 45 08             	mov    0x8(%ebp),%eax
   18722:	83 c0 16             	add    $0x16,%eax
   18725:	0f b6 00             	movzbl (%eax),%eax
   18728:	c1 e0 10             	shl    $0x10,%eax
   1872b:	09 c2                	or     %eax,%edx
   1872d:	8b 45 08             	mov    0x8(%ebp),%eax
   18730:	83 c0 15             	add    $0x15,%eax
   18733:	0f b6 00             	movzbl (%eax),%eax
   18736:	c1 e0 08             	shl    $0x8,%eax
   18739:	09 c2                	or     %eax,%edx
   1873b:	8b 45 08             	mov    0x8(%ebp),%eax
   1873e:	83 c0 14             	add    $0x14,%eax
   18741:	0f b6 00             	movzbl (%eax),%eax
   18744:	09 d0                	or     %edx,%eax
   18746:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   18749:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1874c:	c1 e8 18             	shr    $0x18,%eax
   1874f:	0f b6 c0             	movzbl %al,%eax
   18752:	33 0c 85 00 0c 00 00 	xor    0xc00(,%eax,4),%ecx
   18759:	89 c8                	mov    %ecx,%eax
   1875b:	89 43 14             	mov    %eax,0x14(%ebx)
   1875e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   18761:	c1 e8 08             	shr    $0x8,%eax
   18764:	0f b6 d0             	movzbl %al,%edx
   18767:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1876a:	c1 e8 10             	shr    $0x10,%eax
   1876d:	0f b6 c0             	movzbl %al,%eax
   18770:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   18777:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1877e:	31 c2                	xor    %eax,%edx
   18780:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   18783:	c1 e8 18             	shr    $0x18,%eax
   18786:	0f b6 c0             	movzbl %al,%eax
   18789:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   18790:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
   18794:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1879b:	89 d0                	mov    %edx,%eax
   1879d:	89 c2                	mov    %eax,%edx
   1879f:	33 15 00 00 00 00    	xor    0x0,%edx
   187a5:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   187a8:	31 10                	xor    %edx,(%eax)
   187aa:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   187ad:	0f b6 55 d8          	movzbl 0xffffffd8(%ebp),%edx
   187b1:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   187b4:	c1 e8 08             	shr    $0x8,%eax
   187b7:	0f b6 c0             	movzbl %al,%eax
   187ba:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   187c1:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   187c8:	31 c2                	xor    %eax,%edx
   187ca:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   187cd:	c1 e8 10             	shr    $0x10,%eax
   187d0:	0f b6 c0             	movzbl %al,%eax
   187d3:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   187da:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   187dd:	c1 e8 18             	shr    $0x18,%eax
   187e0:	0f b6 c0             	movzbl %al,%eax
   187e3:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   187ea:	89 d0                	mov    %edx,%eax
   187ec:	89 41 18             	mov    %eax,0x18(%ecx)
   187ef:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   187f2:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   187f5:	31 10                	xor    %edx,(%eax)
   187f7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   187fa:	0f b6 55 dc          	movzbl 0xffffffdc(%ebp),%edx
   187fe:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   18801:	c1 e8 08             	shr    $0x8,%eax
   18804:	0f b6 c0             	movzbl %al,%eax
   18807:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   1880e:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   18815:	31 c2                	xor    %eax,%edx
   18817:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   1881a:	c1 e8 10             	shr    $0x10,%eax
   1881d:	0f b6 c0             	movzbl %al,%eax
   18820:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   18827:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   1882a:	c1 e8 18             	shr    $0x18,%eax
   1882d:	0f b6 c0             	movzbl %al,%eax
   18830:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   18837:	89 d0                	mov    %edx,%eax
   18839:	89 41 1c             	mov    %eax,0x1c(%ecx)
   1883c:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   1883f:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   18842:	31 10                	xor    %edx,(%eax)
   18844:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18847:	0f b6 55 e0          	movzbl 0xffffffe0(%ebp),%edx
   1884b:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   1884e:	c1 e8 08             	shr    $0x8,%eax
   18851:	0f b6 c0             	movzbl %al,%eax
   18854:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   1885b:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   18862:	31 c2                	xor    %eax,%edx
   18864:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   18867:	c1 e8 10             	shr    $0x10,%eax
   1886a:	0f b6 c0             	movzbl %al,%eax
   1886d:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   18874:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   18877:	c1 e8 18             	shr    $0x18,%eax
   1887a:	0f b6 c0             	movzbl %al,%eax
   1887d:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   18884:	89 d0                	mov    %edx,%eax
   18886:	89 41 20             	mov    %eax,0x20(%ecx)
   18889:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   1888c:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   1888f:	31 10                	xor    %edx,(%eax)
   18891:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18894:	0f b6 55 e4          	movzbl 0xffffffe4(%ebp),%edx
   18898:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1889b:	c1 e8 08             	shr    $0x8,%eax
   1889e:	0f b6 c0             	movzbl %al,%eax
   188a1:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   188a8:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   188af:	31 c2                	xor    %eax,%edx
   188b1:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   188b4:	c1 e8 10             	shr    $0x10,%eax
   188b7:	0f b6 c0             	movzbl %al,%eax
   188ba:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   188c1:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   188c4:	c1 e8 18             	shr    $0x18,%eax
   188c7:	0f b6 c0             	movzbl %al,%eax
   188ca:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   188d1:	89 d0                	mov    %edx,%eax
   188d3:	89 41 24             	mov    %eax,0x24(%ecx)
   188d6:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   188d9:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   188dc:	31 10                	xor    %edx,(%eax)
   188de:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   188e1:	0f b6 55 e8          	movzbl 0xffffffe8(%ebp),%edx
   188e5:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   188e8:	c1 e8 08             	shr    $0x8,%eax
   188eb:	0f b6 c0             	movzbl %al,%eax
   188ee:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   188f5:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   188fc:	31 c2                	xor    %eax,%edx
   188fe:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18901:	c1 e8 10             	shr    $0x10,%eax
   18904:	0f b6 c0             	movzbl %al,%eax
   18907:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   1890e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18911:	c1 e8 18             	shr    $0x18,%eax
   18914:	0f b6 c0             	movzbl %al,%eax
   18917:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1891e:	89 d0                	mov    %edx,%eax
   18920:	89 41 28             	mov    %eax,0x28(%ecx)
   18923:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   18926:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   18929:	31 10                	xor    %edx,(%eax)
   1892b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1892e:	0f b6 55 ec          	movzbl 0xffffffec(%ebp),%edx
   18932:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   18935:	c1 e8 08             	shr    $0x8,%eax
   18938:	0f b6 c0             	movzbl %al,%eax
   1893b:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   18942:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   18949:	31 c2                	xor    %eax,%edx
   1894b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1894e:	c1 e8 10             	shr    $0x10,%eax
   18951:	0f b6 c0             	movzbl %al,%eax
   18954:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   1895b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1895e:	c1 e8 18             	shr    $0x18,%eax
   18961:	0f b6 c0             	movzbl %al,%eax
   18964:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1896b:	89 d0                	mov    %edx,%eax
   1896d:	89 41 2c             	mov    %eax,0x2c(%ecx)
   18970:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   18973:	c1 e8 08             	shr    $0x8,%eax
   18976:	0f b6 d0             	movzbl %al,%edx
   18979:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1897c:	c1 e8 10             	shr    $0x10,%eax
   1897f:	0f b6 c0             	movzbl %al,%eax
   18982:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   18989:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   18990:	31 c2                	xor    %eax,%edx
   18992:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   18995:	c1 e8 18             	shr    $0x18,%eax
   18998:	0f b6 c0             	movzbl %al,%eax
   1899b:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   189a2:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
   189a6:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   189ad:	89 d0                	mov    %edx,%eax
   189af:	33 05 04 00 00 00    	xor    0x4,%eax
   189b5:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   189b8:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   189bb:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   189be:	31 10                	xor    %edx,(%eax)
   189c0:	0f b6 55 f0          	movzbl 0xfffffff0(%ebp),%edx
   189c4:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   189c7:	c1 e8 08             	shr    $0x8,%eax
   189ca:	0f b6 c0             	movzbl %al,%eax
   189cd:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   189d4:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   189db:	31 c2                	xor    %eax,%edx
   189dd:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   189e0:	c1 e8 10             	shr    $0x10,%eax
   189e3:	0f b6 c0             	movzbl %al,%eax
   189e6:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   189ed:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   189f0:	c1 e8 18             	shr    $0x18,%eax
   189f3:	0f b6 c0             	movzbl %al,%eax
   189f6:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   189fd:	89 d0                	mov    %edx,%eax
   189ff:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   18a02:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18a05:	8b 45 0c             	mov    0xc(%ebp),%eax
   18a08:	8b 50 18             	mov    0x18(%eax),%edx
   18a0b:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18a0e:	31 10                	xor    %edx,(%eax)
   18a10:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18a13:	89 41 30             	mov    %eax,0x30(%ecx)
   18a16:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   18a19:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   18a1c:	31 10                	xor    %edx,(%eax)
   18a1e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18a21:	8b 45 0c             	mov    0xc(%ebp),%eax
   18a24:	8b 50 1c             	mov    0x1c(%eax),%edx
   18a27:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18a2a:	31 10                	xor    %edx,(%eax)
   18a2c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18a2f:	89 41 34             	mov    %eax,0x34(%ecx)
   18a32:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   18a35:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   18a38:	31 10                	xor    %edx,(%eax)
   18a3a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18a3d:	8b 45 0c             	mov    0xc(%ebp),%eax
   18a40:	8b 50 20             	mov    0x20(%eax),%edx
   18a43:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18a46:	31 10                	xor    %edx,(%eax)
   18a48:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18a4b:	89 41 38             	mov    %eax,0x38(%ecx)
   18a4e:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   18a51:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   18a54:	31 10                	xor    %edx,(%eax)
   18a56:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18a59:	8b 45 0c             	mov    0xc(%ebp),%eax
   18a5c:	8b 50 24             	mov    0x24(%eax),%edx
   18a5f:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18a62:	31 10                	xor    %edx,(%eax)
   18a64:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18a67:	89 41 3c             	mov    %eax,0x3c(%ecx)
   18a6a:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   18a6d:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   18a70:	31 10                	xor    %edx,(%eax)
   18a72:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18a75:	8b 45 0c             	mov    0xc(%ebp),%eax
   18a78:	8b 50 28             	mov    0x28(%eax),%edx
   18a7b:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18a7e:	31 10                	xor    %edx,(%eax)
   18a80:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18a83:	89 41 40             	mov    %eax,0x40(%ecx)
   18a86:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   18a89:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   18a8c:	31 10                	xor    %edx,(%eax)
   18a8e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18a91:	8b 45 0c             	mov    0xc(%ebp),%eax
   18a94:	8b 50 2c             	mov    0x2c(%eax),%edx
   18a97:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18a9a:	31 10                	xor    %edx,(%eax)
   18a9c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18a9f:	89 41 44             	mov    %eax,0x44(%ecx)
   18aa2:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   18aa5:	c1 e8 08             	shr    $0x8,%eax
   18aa8:	0f b6 d0             	movzbl %al,%edx
   18aab:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   18aae:	c1 e8 10             	shr    $0x10,%eax
   18ab1:	0f b6 c0             	movzbl %al,%eax
   18ab4:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   18abb:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   18ac2:	31 c2                	xor    %eax,%edx
   18ac4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   18ac7:	c1 e8 18             	shr    $0x18,%eax
   18aca:	0f b6 c0             	movzbl %al,%eax
   18acd:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   18ad4:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
   18ad8:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   18adf:	89 d0                	mov    %edx,%eax
   18ae1:	33 05 08 00 00 00    	xor    0x8,%eax
   18ae7:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   18aea:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   18aed:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   18af0:	31 10                	xor    %edx,(%eax)
   18af2:	0f b6 55 f0          	movzbl 0xfffffff0(%ebp),%edx
   18af6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18af9:	c1 e8 08             	shr    $0x8,%eax
   18afc:	0f b6 c0             	movzbl %al,%eax
   18aff:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   18b06:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   18b0d:	31 c2                	xor    %eax,%edx
   18b0f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18b12:	c1 e8 10             	shr    $0x10,%eax
   18b15:	0f b6 c0             	movzbl %al,%eax
   18b18:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   18b1f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18b22:	c1 e8 18             	shr    $0x18,%eax
   18b25:	0f b6 c0             	movzbl %al,%eax
   18b28:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   18b2f:	89 d0                	mov    %edx,%eax
   18b31:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   18b34:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18b37:	8b 45 0c             	mov    0xc(%ebp),%eax
   18b3a:	8b 50 30             	mov    0x30(%eax),%edx
   18b3d:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18b40:	31 10                	xor    %edx,(%eax)
   18b42:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18b45:	89 41 48             	mov    %eax,0x48(%ecx)
   18b48:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   18b4b:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   18b4e:	31 10                	xor    %edx,(%eax)
   18b50:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18b53:	8b 45 0c             	mov    0xc(%ebp),%eax
   18b56:	8b 50 34             	mov    0x34(%eax),%edx
   18b59:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18b5c:	31 10                	xor    %edx,(%eax)
   18b5e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18b61:	89 41 4c             	mov    %eax,0x4c(%ecx)
   18b64:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   18b67:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   18b6a:	31 10                	xor    %edx,(%eax)
   18b6c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18b6f:	8b 45 0c             	mov    0xc(%ebp),%eax
   18b72:	8b 50 38             	mov    0x38(%eax),%edx
   18b75:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18b78:	31 10                	xor    %edx,(%eax)
   18b7a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18b7d:	89 41 50             	mov    %eax,0x50(%ecx)
   18b80:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   18b83:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   18b86:	31 10                	xor    %edx,(%eax)
   18b88:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18b8b:	8b 45 0c             	mov    0xc(%ebp),%eax
   18b8e:	8b 50 3c             	mov    0x3c(%eax),%edx
   18b91:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18b94:	31 10                	xor    %edx,(%eax)
   18b96:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18b99:	89 41 54             	mov    %eax,0x54(%ecx)
   18b9c:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   18b9f:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   18ba2:	31 10                	xor    %edx,(%eax)
   18ba4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18ba7:	8b 45 0c             	mov    0xc(%ebp),%eax
   18baa:	8b 50 40             	mov    0x40(%eax),%edx
   18bad:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18bb0:	31 10                	xor    %edx,(%eax)
   18bb2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18bb5:	89 41 58             	mov    %eax,0x58(%ecx)
   18bb8:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   18bbb:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   18bbe:	31 10                	xor    %edx,(%eax)
   18bc0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18bc3:	8b 45 0c             	mov    0xc(%ebp),%eax
   18bc6:	8b 50 44             	mov    0x44(%eax),%edx
   18bc9:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18bcc:	31 10                	xor    %edx,(%eax)
   18bce:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18bd1:	89 41 5c             	mov    %eax,0x5c(%ecx)
   18bd4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   18bd7:	c1 e8 08             	shr    $0x8,%eax
   18bda:	0f b6 d0             	movzbl %al,%edx
   18bdd:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   18be0:	c1 e8 10             	shr    $0x10,%eax
   18be3:	0f b6 c0             	movzbl %al,%eax
   18be6:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   18bed:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   18bf4:	31 c2                	xor    %eax,%edx
   18bf6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   18bf9:	c1 e8 18             	shr    $0x18,%eax
   18bfc:	0f b6 c0             	movzbl %al,%eax
   18bff:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   18c06:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
   18c0a:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   18c11:	89 d0                	mov    %edx,%eax
   18c13:	33 05 0c 00 00 00    	xor    0xc,%eax
   18c19:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   18c1c:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   18c1f:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   18c22:	31 10                	xor    %edx,(%eax)
   18c24:	0f b6 55 f0          	movzbl 0xfffffff0(%ebp),%edx
   18c28:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18c2b:	c1 e8 08             	shr    $0x8,%eax
   18c2e:	0f b6 c0             	movzbl %al,%eax
   18c31:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   18c38:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   18c3f:	31 c2                	xor    %eax,%edx
   18c41:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18c44:	c1 e8 10             	shr    $0x10,%eax
   18c47:	0f b6 c0             	movzbl %al,%eax
   18c4a:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   18c51:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18c54:	c1 e8 18             	shr    $0x18,%eax
   18c57:	0f b6 c0             	movzbl %al,%eax
   18c5a:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   18c61:	89 d0                	mov    %edx,%eax
   18c63:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   18c66:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18c69:	8b 45 0c             	mov    0xc(%ebp),%eax
   18c6c:	8b 50 48             	mov    0x48(%eax),%edx
   18c6f:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18c72:	31 10                	xor    %edx,(%eax)
   18c74:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18c77:	89 41 60             	mov    %eax,0x60(%ecx)
   18c7a:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   18c7d:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   18c80:	31 10                	xor    %edx,(%eax)
   18c82:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18c85:	8b 45 0c             	mov    0xc(%ebp),%eax
   18c88:	8b 50 4c             	mov    0x4c(%eax),%edx
   18c8b:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18c8e:	31 10                	xor    %edx,(%eax)
   18c90:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18c93:	89 41 64             	mov    %eax,0x64(%ecx)
   18c96:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   18c99:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   18c9c:	31 10                	xor    %edx,(%eax)
   18c9e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18ca1:	8b 45 0c             	mov    0xc(%ebp),%eax
   18ca4:	8b 50 50             	mov    0x50(%eax),%edx
   18ca7:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18caa:	31 10                	xor    %edx,(%eax)
   18cac:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18caf:	89 41 68             	mov    %eax,0x68(%ecx)
   18cb2:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   18cb5:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   18cb8:	31 10                	xor    %edx,(%eax)
   18cba:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18cbd:	8b 45 0c             	mov    0xc(%ebp),%eax
   18cc0:	8b 50 54             	mov    0x54(%eax),%edx
   18cc3:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18cc6:	31 10                	xor    %edx,(%eax)
   18cc8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18ccb:	89 41 6c             	mov    %eax,0x6c(%ecx)
   18cce:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   18cd1:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   18cd4:	31 10                	xor    %edx,(%eax)
   18cd6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18cd9:	8b 45 0c             	mov    0xc(%ebp),%eax
   18cdc:	8b 50 58             	mov    0x58(%eax),%edx
   18cdf:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18ce2:	31 10                	xor    %edx,(%eax)
   18ce4:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18ce7:	89 41 70             	mov    %eax,0x70(%ecx)
   18cea:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   18ced:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   18cf0:	31 10                	xor    %edx,(%eax)
   18cf2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18cf5:	8b 45 0c             	mov    0xc(%ebp),%eax
   18cf8:	8b 50 5c             	mov    0x5c(%eax),%edx
   18cfb:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18cfe:	31 10                	xor    %edx,(%eax)
   18d00:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18d03:	89 41 74             	mov    %eax,0x74(%ecx)
   18d06:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   18d09:	c1 e8 08             	shr    $0x8,%eax
   18d0c:	0f b6 d0             	movzbl %al,%edx
   18d0f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   18d12:	c1 e8 10             	shr    $0x10,%eax
   18d15:	0f b6 c0             	movzbl %al,%eax
   18d18:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   18d1f:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   18d26:	31 c2                	xor    %eax,%edx
   18d28:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   18d2b:	c1 e8 18             	shr    $0x18,%eax
   18d2e:	0f b6 c0             	movzbl %al,%eax
   18d31:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   18d38:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
   18d3c:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   18d43:	89 d0                	mov    %edx,%eax
   18d45:	33 05 10 00 00 00    	xor    0x10,%eax
   18d4b:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   18d4e:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   18d51:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   18d54:	31 10                	xor    %edx,(%eax)
   18d56:	0f b6 55 f0          	movzbl 0xfffffff0(%ebp),%edx
   18d5a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18d5d:	c1 e8 08             	shr    $0x8,%eax
   18d60:	0f b6 c0             	movzbl %al,%eax
   18d63:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   18d6a:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   18d71:	31 c2                	xor    %eax,%edx
   18d73:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18d76:	c1 e8 10             	shr    $0x10,%eax
   18d79:	0f b6 c0             	movzbl %al,%eax
   18d7c:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   18d83:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18d86:	c1 e8 18             	shr    $0x18,%eax
   18d89:	0f b6 c0             	movzbl %al,%eax
   18d8c:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   18d93:	89 d0                	mov    %edx,%eax
   18d95:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   18d98:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18d9b:	8b 45 0c             	mov    0xc(%ebp),%eax
   18d9e:	8b 50 60             	mov    0x60(%eax),%edx
   18da1:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18da4:	31 10                	xor    %edx,(%eax)
   18da6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18da9:	89 41 78             	mov    %eax,0x78(%ecx)
   18dac:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   18daf:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   18db2:	31 10                	xor    %edx,(%eax)
   18db4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18db7:	8b 45 0c             	mov    0xc(%ebp),%eax
   18dba:	8b 50 64             	mov    0x64(%eax),%edx
   18dbd:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18dc0:	31 10                	xor    %edx,(%eax)
   18dc2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18dc5:	89 41 7c             	mov    %eax,0x7c(%ecx)
   18dc8:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   18dcb:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   18dce:	31 10                	xor    %edx,(%eax)
   18dd0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18dd3:	8b 45 0c             	mov    0xc(%ebp),%eax
   18dd6:	8b 50 68             	mov    0x68(%eax),%edx
   18dd9:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18ddc:	31 10                	xor    %edx,(%eax)
   18dde:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18de1:	89 81 80 00 00 00    	mov    %eax,0x80(%ecx)
   18de7:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   18dea:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   18ded:	31 10                	xor    %edx,(%eax)
   18def:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18df2:	8b 45 0c             	mov    0xc(%ebp),%eax
   18df5:	8b 50 6c             	mov    0x6c(%eax),%edx
   18df8:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18dfb:	31 10                	xor    %edx,(%eax)
   18dfd:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18e00:	89 81 84 00 00 00    	mov    %eax,0x84(%ecx)
   18e06:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   18e09:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   18e0c:	31 10                	xor    %edx,(%eax)
   18e0e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18e11:	8b 45 0c             	mov    0xc(%ebp),%eax
   18e14:	8b 50 70             	mov    0x70(%eax),%edx
   18e17:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18e1a:	31 10                	xor    %edx,(%eax)
   18e1c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18e1f:	89 81 88 00 00 00    	mov    %eax,0x88(%ecx)
   18e25:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   18e28:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   18e2b:	31 10                	xor    %edx,(%eax)
   18e2d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18e30:	8b 45 0c             	mov    0xc(%ebp),%eax
   18e33:	8b 50 74             	mov    0x74(%eax),%edx
   18e36:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18e39:	31 10                	xor    %edx,(%eax)
   18e3b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18e3e:	89 81 8c 00 00 00    	mov    %eax,0x8c(%ecx)
   18e44:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   18e47:	c1 e8 08             	shr    $0x8,%eax
   18e4a:	0f b6 d0             	movzbl %al,%edx
   18e4d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   18e50:	c1 e8 10             	shr    $0x10,%eax
   18e53:	0f b6 c0             	movzbl %al,%eax
   18e56:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   18e5d:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   18e64:	31 c2                	xor    %eax,%edx
   18e66:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   18e69:	c1 e8 18             	shr    $0x18,%eax
   18e6c:	0f b6 c0             	movzbl %al,%eax
   18e6f:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   18e76:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
   18e7a:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   18e81:	89 d0                	mov    %edx,%eax
   18e83:	33 05 14 00 00 00    	xor    0x14,%eax
   18e89:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   18e8c:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   18e8f:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   18e92:	31 10                	xor    %edx,(%eax)
   18e94:	0f b6 55 f0          	movzbl 0xfffffff0(%ebp),%edx
   18e98:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18e9b:	c1 e8 08             	shr    $0x8,%eax
   18e9e:	0f b6 c0             	movzbl %al,%eax
   18ea1:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   18ea8:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   18eaf:	31 c2                	xor    %eax,%edx
   18eb1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18eb4:	c1 e8 10             	shr    $0x10,%eax
   18eb7:	0f b6 c0             	movzbl %al,%eax
   18eba:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   18ec1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18ec4:	c1 e8 18             	shr    $0x18,%eax
   18ec7:	0f b6 c0             	movzbl %al,%eax
   18eca:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   18ed1:	89 d0                	mov    %edx,%eax
   18ed3:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   18ed6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18ed9:	8b 45 0c             	mov    0xc(%ebp),%eax
   18edc:	8b 50 78             	mov    0x78(%eax),%edx
   18edf:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18ee2:	31 10                	xor    %edx,(%eax)
   18ee4:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18ee7:	89 81 90 00 00 00    	mov    %eax,0x90(%ecx)
   18eed:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   18ef0:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   18ef3:	31 10                	xor    %edx,(%eax)
   18ef5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18ef8:	8b 45 0c             	mov    0xc(%ebp),%eax
   18efb:	8b 50 7c             	mov    0x7c(%eax),%edx
   18efe:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18f01:	31 10                	xor    %edx,(%eax)
   18f03:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18f06:	89 81 94 00 00 00    	mov    %eax,0x94(%ecx)
   18f0c:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   18f0f:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   18f12:	31 10                	xor    %edx,(%eax)
   18f14:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18f17:	8b 45 0c             	mov    0xc(%ebp),%eax
   18f1a:	8b 90 80 00 00 00    	mov    0x80(%eax),%edx
   18f20:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18f23:	31 10                	xor    %edx,(%eax)
   18f25:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18f28:	89 81 98 00 00 00    	mov    %eax,0x98(%ecx)
   18f2e:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   18f31:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   18f34:	31 10                	xor    %edx,(%eax)
   18f36:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18f39:	8b 45 0c             	mov    0xc(%ebp),%eax
   18f3c:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
   18f42:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18f45:	31 10                	xor    %edx,(%eax)
   18f47:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18f4a:	89 81 9c 00 00 00    	mov    %eax,0x9c(%ecx)
   18f50:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   18f53:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   18f56:	31 10                	xor    %edx,(%eax)
   18f58:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18f5b:	8b 45 0c             	mov    0xc(%ebp),%eax
   18f5e:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
   18f64:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18f67:	31 10                	xor    %edx,(%eax)
   18f69:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18f6c:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
   18f72:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   18f75:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   18f78:	31 10                	xor    %edx,(%eax)
   18f7a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   18f7d:	8b 45 0c             	mov    0xc(%ebp),%eax
   18f80:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
   18f86:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18f89:	31 10                	xor    %edx,(%eax)
   18f8b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18f8e:	89 81 a4 00 00 00    	mov    %eax,0xa4(%ecx)
   18f94:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   18f97:	c1 e8 08             	shr    $0x8,%eax
   18f9a:	0f b6 d0             	movzbl %al,%edx
   18f9d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   18fa0:	c1 e8 10             	shr    $0x10,%eax
   18fa3:	0f b6 c0             	movzbl %al,%eax
   18fa6:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   18fad:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   18fb4:	31 c2                	xor    %eax,%edx
   18fb6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   18fb9:	c1 e8 18             	shr    $0x18,%eax
   18fbc:	0f b6 c0             	movzbl %al,%eax
   18fbf:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   18fc6:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
   18fca:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   18fd1:	89 d0                	mov    %edx,%eax
   18fd3:	33 05 18 00 00 00    	xor    0x18,%eax
   18fd9:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   18fdc:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   18fdf:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   18fe2:	31 10                	xor    %edx,(%eax)
   18fe4:	0f b6 55 f0          	movzbl 0xfffffff0(%ebp),%edx
   18fe8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18feb:	c1 e8 08             	shr    $0x8,%eax
   18fee:	0f b6 c0             	movzbl %al,%eax
   18ff1:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   18ff8:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   18fff:	31 c2                	xor    %eax,%edx
   19001:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   19004:	c1 e8 10             	shr    $0x10,%eax
   19007:	0f b6 c0             	movzbl %al,%eax
   1900a:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   19011:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   19014:	c1 e8 18             	shr    $0x18,%eax
   19017:	0f b6 c0             	movzbl %al,%eax
   1901a:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   19021:	89 d0                	mov    %edx,%eax
   19023:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   19026:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19029:	8b 45 0c             	mov    0xc(%ebp),%eax
   1902c:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
   19032:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   19035:	31 10                	xor    %edx,(%eax)
   19037:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1903a:	89 81 a8 00 00 00    	mov    %eax,0xa8(%ecx)
   19040:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   19043:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   19046:	31 10                	xor    %edx,(%eax)
   19048:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1904b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1904e:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
   19054:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   19057:	31 10                	xor    %edx,(%eax)
   19059:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1905c:	89 81 ac 00 00 00    	mov    %eax,0xac(%ecx)
   19062:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   19065:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   19068:	31 10                	xor    %edx,(%eax)
   1906a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1906d:	8b 45 0c             	mov    0xc(%ebp),%eax
   19070:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
   19076:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   19079:	31 10                	xor    %edx,(%eax)
   1907b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1907e:	89 81 b0 00 00 00    	mov    %eax,0xb0(%ecx)
   19084:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   19087:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   1908a:	31 10                	xor    %edx,(%eax)
   1908c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1908f:	8b 45 0c             	mov    0xc(%ebp),%eax
   19092:	8b 90 9c 00 00 00    	mov    0x9c(%eax),%edx
   19098:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   1909b:	31 10                	xor    %edx,(%eax)
   1909d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   190a0:	89 81 b4 00 00 00    	mov    %eax,0xb4(%ecx)
   190a6:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   190a9:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   190ac:	31 10                	xor    %edx,(%eax)
   190ae:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   190b1:	8b 45 0c             	mov    0xc(%ebp),%eax
   190b4:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
   190ba:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   190bd:	31 10                	xor    %edx,(%eax)
   190bf:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   190c2:	89 81 b8 00 00 00    	mov    %eax,0xb8(%ecx)
   190c8:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   190cb:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   190ce:	31 10                	xor    %edx,(%eax)
   190d0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   190d3:	8b 45 0c             	mov    0xc(%ebp),%eax
   190d6:	8b 90 a4 00 00 00    	mov    0xa4(%eax),%edx
   190dc:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   190df:	31 10                	xor    %edx,(%eax)
   190e1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   190e4:	89 81 bc 00 00 00    	mov    %eax,0xbc(%ecx)
   190ea:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   190ed:	c1 e8 08             	shr    $0x8,%eax
   190f0:	0f b6 d0             	movzbl %al,%edx
   190f3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   190f6:	c1 e8 10             	shr    $0x10,%eax
   190f9:	0f b6 c0             	movzbl %al,%eax
   190fc:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   19103:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1910a:	31 c2                	xor    %eax,%edx
   1910c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1910f:	c1 e8 18             	shr    $0x18,%eax
   19112:	0f b6 c0             	movzbl %al,%eax
   19115:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   1911c:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
   19120:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   19127:	89 d0                	mov    %edx,%eax
   19129:	89 c2                	mov    %eax,%edx
   1912b:	33 15 1c 00 00 00    	xor    0x1c,%edx
   19131:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   19134:	31 10                	xor    %edx,(%eax)
   19136:	8b 55 0c             	mov    0xc(%ebp),%edx
   19139:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   1913c:	89 82 c0 00 00 00    	mov    %eax,0xc0(%edx)
   19142:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   19145:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   19148:	31 10                	xor    %edx,(%eax)
   1914a:	8b 55 0c             	mov    0xc(%ebp),%edx
   1914d:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   19150:	89 82 c4 00 00 00    	mov    %eax,0xc4(%edx)
   19156:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   19159:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   1915c:	31 10                	xor    %edx,(%eax)
   1915e:	8b 55 0c             	mov    0xc(%ebp),%edx
   19161:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   19164:	89 82 c8 00 00 00    	mov    %eax,0xc8(%edx)
   1916a:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   1916d:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   19170:	31 10                	xor    %edx,(%eax)
   19172:	8b 55 0c             	mov    0xc(%ebp),%edx
   19175:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   19178:	89 82 cc 00 00 00    	mov    %eax,0xcc(%edx)
   1917e:	8b 45 0c             	mov    0xc(%ebp),%eax
   19181:	c7 80 f0 00 00 00 0c 	movl   $0xc,0xf0(%eax)
   19188:	00 00 00 
   1918b:	b8 00 00 00 00       	mov    $0x0,%eax
   19190:	83 c4 24             	add    $0x24,%esp
   19193:	5b                   	pop    %ebx
   19194:	c9                   	leave  
   19195:	c3                   	ret    

00019196 <aes_decrypt_key256>:
   19196:	55                   	push   %ebp
   19197:	89 e5                	mov    %esp,%ebp
   19199:	53                   	push   %ebx
   1919a:	83 ec 34             	sub    $0x34,%esp
   1919d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   191a0:	8b 45 08             	mov    0x8(%ebp),%eax
   191a3:	83 c0 03             	add    $0x3,%eax
   191a6:	0f b6 00             	movzbl (%eax),%eax
   191a9:	89 c2                	mov    %eax,%edx
   191ab:	c1 e2 18             	shl    $0x18,%edx
   191ae:	8b 45 08             	mov    0x8(%ebp),%eax
   191b1:	83 c0 02             	add    $0x2,%eax
   191b4:	0f b6 00             	movzbl (%eax),%eax
   191b7:	c1 e0 10             	shl    $0x10,%eax
   191ba:	09 c2                	or     %eax,%edx
   191bc:	8b 45 08             	mov    0x8(%ebp),%eax
   191bf:	40                   	inc    %eax
   191c0:	0f b6 00             	movzbl (%eax),%eax
   191c3:	c1 e0 08             	shl    $0x8,%eax
   191c6:	09 c2                	or     %eax,%edx
   191c8:	8b 45 08             	mov    0x8(%ebp),%eax
   191cb:	0f b6 00             	movzbl (%eax),%eax
   191ce:	09 d0                	or     %edx,%eax
   191d0:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
   191d3:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   191d6:	89 01                	mov    %eax,(%ecx)
   191d8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   191db:	8b 45 08             	mov    0x8(%ebp),%eax
   191de:	83 c0 07             	add    $0x7,%eax
   191e1:	0f b6 00             	movzbl (%eax),%eax
   191e4:	89 c2                	mov    %eax,%edx
   191e6:	c1 e2 18             	shl    $0x18,%edx
   191e9:	8b 45 08             	mov    0x8(%ebp),%eax
   191ec:	83 c0 06             	add    $0x6,%eax
   191ef:	0f b6 00             	movzbl (%eax),%eax
   191f2:	c1 e0 10             	shl    $0x10,%eax
   191f5:	09 c2                	or     %eax,%edx
   191f7:	8b 45 08             	mov    0x8(%ebp),%eax
   191fa:	83 c0 05             	add    $0x5,%eax
   191fd:	0f b6 00             	movzbl (%eax),%eax
   19200:	c1 e0 08             	shl    $0x8,%eax
   19203:	09 c2                	or     %eax,%edx
   19205:	8b 45 08             	mov    0x8(%ebp),%eax
   19208:	83 c0 04             	add    $0x4,%eax
   1920b:	0f b6 00             	movzbl (%eax),%eax
   1920e:	09 d0                	or     %edx,%eax
   19210:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
   19213:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   19216:	89 41 04             	mov    %eax,0x4(%ecx)
   19219:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1921c:	8b 45 08             	mov    0x8(%ebp),%eax
   1921f:	83 c0 0b             	add    $0xb,%eax
   19222:	0f b6 00             	movzbl (%eax),%eax
   19225:	89 c2                	mov    %eax,%edx
   19227:	c1 e2 18             	shl    $0x18,%edx
   1922a:	8b 45 08             	mov    0x8(%ebp),%eax
   1922d:	83 c0 0a             	add    $0xa,%eax
   19230:	0f b6 00             	movzbl (%eax),%eax
   19233:	c1 e0 10             	shl    $0x10,%eax
   19236:	09 c2                	or     %eax,%edx
   19238:	8b 45 08             	mov    0x8(%ebp),%eax
   1923b:	83 c0 09             	add    $0x9,%eax
   1923e:	0f b6 00             	movzbl (%eax),%eax
   19241:	c1 e0 08             	shl    $0x8,%eax
   19244:	09 c2                	or     %eax,%edx
   19246:	8b 45 08             	mov    0x8(%ebp),%eax
   19249:	83 c0 08             	add    $0x8,%eax
   1924c:	0f b6 00             	movzbl (%eax),%eax
   1924f:	09 d0                	or     %edx,%eax
   19251:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   19254:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   19257:	89 41 08             	mov    %eax,0x8(%ecx)
   1925a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1925d:	8b 45 08             	mov    0x8(%ebp),%eax
   19260:	83 c0 0f             	add    $0xf,%eax
   19263:	0f b6 00             	movzbl (%eax),%eax
   19266:	89 c2                	mov    %eax,%edx
   19268:	c1 e2 18             	shl    $0x18,%edx
   1926b:	8b 45 08             	mov    0x8(%ebp),%eax
   1926e:	83 c0 0e             	add    $0xe,%eax
   19271:	0f b6 00             	movzbl (%eax),%eax
   19274:	c1 e0 10             	shl    $0x10,%eax
   19277:	09 c2                	or     %eax,%edx
   19279:	8b 45 08             	mov    0x8(%ebp),%eax
   1927c:	83 c0 0d             	add    $0xd,%eax
   1927f:	0f b6 00             	movzbl (%eax),%eax
   19282:	c1 e0 08             	shl    $0x8,%eax
   19285:	09 c2                	or     %eax,%edx
   19287:	8b 45 08             	mov    0x8(%ebp),%eax
   1928a:	83 c0 0c             	add    $0xc,%eax
   1928d:	0f b6 00             	movzbl (%eax),%eax
   19290:	09 d0                	or     %edx,%eax
   19292:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   19295:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   19298:	89 41 0c             	mov    %eax,0xc(%ecx)
   1929b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   1929e:	8b 45 08             	mov    0x8(%ebp),%eax
   192a1:	83 c0 13             	add    $0x13,%eax
   192a4:	0f b6 00             	movzbl (%eax),%eax
   192a7:	89 c2                	mov    %eax,%edx
   192a9:	c1 e2 18             	shl    $0x18,%edx
   192ac:	8b 45 08             	mov    0x8(%ebp),%eax
   192af:	83 c0 12             	add    $0x12,%eax
   192b2:	0f b6 00             	movzbl (%eax),%eax
   192b5:	c1 e0 10             	shl    $0x10,%eax
   192b8:	09 c2                	or     %eax,%edx
   192ba:	8b 45 08             	mov    0x8(%ebp),%eax
   192bd:	83 c0 11             	add    $0x11,%eax
   192c0:	0f b6 00             	movzbl (%eax),%eax
   192c3:	c1 e0 08             	shl    $0x8,%eax
   192c6:	09 c2                	or     %eax,%edx
   192c8:	8b 45 08             	mov    0x8(%ebp),%eax
   192cb:	83 c0 10             	add    $0x10,%eax
   192ce:	0f b6 00             	movzbl (%eax),%eax
   192d1:	09 d0                	or     %edx,%eax
   192d3:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   192d6:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   192d9:	0f b6 c8             	movzbl %al,%ecx
   192dc:	8b 45 08             	mov    0x8(%ebp),%eax
   192df:	83 c0 13             	add    $0x13,%eax
   192e2:	0f b6 00             	movzbl (%eax),%eax
   192e5:	89 c2                	mov    %eax,%edx
   192e7:	c1 e2 18             	shl    $0x18,%edx
   192ea:	8b 45 08             	mov    0x8(%ebp),%eax
   192ed:	83 c0 12             	add    $0x12,%eax
   192f0:	0f b6 00             	movzbl (%eax),%eax
   192f3:	c1 e0 10             	shl    $0x10,%eax
   192f6:	09 c2                	or     %eax,%edx
   192f8:	8b 45 08             	mov    0x8(%ebp),%eax
   192fb:	83 c0 11             	add    $0x11,%eax
   192fe:	0f b6 00             	movzbl (%eax),%eax
   19301:	c1 e0 08             	shl    $0x8,%eax
   19304:	09 c2                	or     %eax,%edx
   19306:	8b 45 08             	mov    0x8(%ebp),%eax
   19309:	83 c0 10             	add    $0x10,%eax
   1930c:	0f b6 00             	movzbl (%eax),%eax
   1930f:	09 d0                	or     %edx,%eax
   19311:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   19314:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   19317:	c1 e8 08             	shr    $0x8,%eax
   1931a:	0f b6 c0             	movzbl %al,%eax
   1931d:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   19324:	8b 0c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%ecx
   1932b:	31 c1                	xor    %eax,%ecx
   1932d:	8b 45 08             	mov    0x8(%ebp),%eax
   19330:	83 c0 13             	add    $0x13,%eax
   19333:	0f b6 00             	movzbl (%eax),%eax
   19336:	89 c2                	mov    %eax,%edx
   19338:	c1 e2 18             	shl    $0x18,%edx
   1933b:	8b 45 08             	mov    0x8(%ebp),%eax
   1933e:	83 c0 12             	add    $0x12,%eax
   19341:	0f b6 00             	movzbl (%eax),%eax
   19344:	c1 e0 10             	shl    $0x10,%eax
   19347:	09 c2                	or     %eax,%edx
   19349:	8b 45 08             	mov    0x8(%ebp),%eax
   1934c:	83 c0 11             	add    $0x11,%eax
   1934f:	0f b6 00             	movzbl (%eax),%eax
   19352:	c1 e0 08             	shl    $0x8,%eax
   19355:	09 c2                	or     %eax,%edx
   19357:	8b 45 08             	mov    0x8(%ebp),%eax
   1935a:	83 c0 10             	add    $0x10,%eax
   1935d:	0f b6 00             	movzbl (%eax),%eax
   19360:	09 d0                	or     %edx,%eax
   19362:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   19365:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   19368:	c1 e8 10             	shr    $0x10,%eax
   1936b:	0f b6 c0             	movzbl %al,%eax
   1936e:	33 0c 85 00 08 00 00 	xor    0x800(,%eax,4),%ecx
   19375:	8b 45 08             	mov    0x8(%ebp),%eax
   19378:	83 c0 13             	add    $0x13,%eax
   1937b:	0f b6 00             	movzbl (%eax),%eax
   1937e:	89 c2                	mov    %eax,%edx
   19380:	c1 e2 18             	shl    $0x18,%edx
   19383:	8b 45 08             	mov    0x8(%ebp),%eax
   19386:	83 c0 12             	add    $0x12,%eax
   19389:	0f b6 00             	movzbl (%eax),%eax
   1938c:	c1 e0 10             	shl    $0x10,%eax
   1938f:	09 c2                	or     %eax,%edx
   19391:	8b 45 08             	mov    0x8(%ebp),%eax
   19394:	83 c0 11             	add    $0x11,%eax
   19397:	0f b6 00             	movzbl (%eax),%eax
   1939a:	c1 e0 08             	shl    $0x8,%eax
   1939d:	09 c2                	or     %eax,%edx
   1939f:	8b 45 08             	mov    0x8(%ebp),%eax
   193a2:	83 c0 10             	add    $0x10,%eax
   193a5:	0f b6 00             	movzbl (%eax),%eax
   193a8:	09 d0                	or     %edx,%eax
   193aa:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   193ad:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   193b0:	c1 e8 18             	shr    $0x18,%eax
   193b3:	0f b6 c0             	movzbl %al,%eax
   193b6:	33 0c 85 00 0c 00 00 	xor    0xc00(,%eax,4),%ecx
   193bd:	89 c8                	mov    %ecx,%eax
   193bf:	89 43 10             	mov    %eax,0x10(%ebx)
   193c2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   193c5:	8b 45 08             	mov    0x8(%ebp),%eax
   193c8:	83 c0 17             	add    $0x17,%eax
   193cb:	0f b6 00             	movzbl (%eax),%eax
   193ce:	89 c2                	mov    %eax,%edx
   193d0:	c1 e2 18             	shl    $0x18,%edx
   193d3:	8b 45 08             	mov    0x8(%ebp),%eax
   193d6:	83 c0 16             	add    $0x16,%eax
   193d9:	0f b6 00             	movzbl (%eax),%eax
   193dc:	c1 e0 10             	shl    $0x10,%eax
   193df:	09 c2                	or     %eax,%edx
   193e1:	8b 45 08             	mov    0x8(%ebp),%eax
   193e4:	83 c0 15             	add    $0x15,%eax
   193e7:	0f b6 00             	movzbl (%eax),%eax
   193ea:	c1 e0 08             	shl    $0x8,%eax
   193ed:	09 c2                	or     %eax,%edx
   193ef:	8b 45 08             	mov    0x8(%ebp),%eax
   193f2:	83 c0 14             	add    $0x14,%eax
   193f5:	0f b6 00             	movzbl (%eax),%eax
   193f8:	09 d0                	or     %edx,%eax
   193fa:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   193fd:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   19400:	0f b6 c8             	movzbl %al,%ecx
   19403:	8b 45 08             	mov    0x8(%ebp),%eax
   19406:	83 c0 17             	add    $0x17,%eax
   19409:	0f b6 00             	movzbl (%eax),%eax
   1940c:	89 c2                	mov    %eax,%edx
   1940e:	c1 e2 18             	shl    $0x18,%edx
   19411:	8b 45 08             	mov    0x8(%ebp),%eax
   19414:	83 c0 16             	add    $0x16,%eax
   19417:	0f b6 00             	movzbl (%eax),%eax
   1941a:	c1 e0 10             	shl    $0x10,%eax
   1941d:	09 c2                	or     %eax,%edx
   1941f:	8b 45 08             	mov    0x8(%ebp),%eax
   19422:	83 c0 15             	add    $0x15,%eax
   19425:	0f b6 00             	movzbl (%eax),%eax
   19428:	c1 e0 08             	shl    $0x8,%eax
   1942b:	09 c2                	or     %eax,%edx
   1942d:	8b 45 08             	mov    0x8(%ebp),%eax
   19430:	83 c0 14             	add    $0x14,%eax
   19433:	0f b6 00             	movzbl (%eax),%eax
   19436:	09 d0                	or     %edx,%eax
   19438:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1943b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1943e:	c1 e8 08             	shr    $0x8,%eax
   19441:	0f b6 c0             	movzbl %al,%eax
   19444:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   1944b:	8b 0c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%ecx
   19452:	31 c1                	xor    %eax,%ecx
   19454:	8b 45 08             	mov    0x8(%ebp),%eax
   19457:	83 c0 17             	add    $0x17,%eax
   1945a:	0f b6 00             	movzbl (%eax),%eax
   1945d:	89 c2                	mov    %eax,%edx
   1945f:	c1 e2 18             	shl    $0x18,%edx
   19462:	8b 45 08             	mov    0x8(%ebp),%eax
   19465:	83 c0 16             	add    $0x16,%eax
   19468:	0f b6 00             	movzbl (%eax),%eax
   1946b:	c1 e0 10             	shl    $0x10,%eax
   1946e:	09 c2                	or     %eax,%edx
   19470:	8b 45 08             	mov    0x8(%ebp),%eax
   19473:	83 c0 15             	add    $0x15,%eax
   19476:	0f b6 00             	movzbl (%eax),%eax
   19479:	c1 e0 08             	shl    $0x8,%eax
   1947c:	09 c2                	or     %eax,%edx
   1947e:	8b 45 08             	mov    0x8(%ebp),%eax
   19481:	83 c0 14             	add    $0x14,%eax
   19484:	0f b6 00             	movzbl (%eax),%eax
   19487:	09 d0                	or     %edx,%eax
   19489:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1948c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1948f:	c1 e8 10             	shr    $0x10,%eax
   19492:	0f b6 c0             	movzbl %al,%eax
   19495:	33 0c 85 00 08 00 00 	xor    0x800(,%eax,4),%ecx
   1949c:	8b 45 08             	mov    0x8(%ebp),%eax
   1949f:	83 c0 17             	add    $0x17,%eax
   194a2:	0f b6 00             	movzbl (%eax),%eax
   194a5:	89 c2                	mov    %eax,%edx
   194a7:	c1 e2 18             	shl    $0x18,%edx
   194aa:	8b 45 08             	mov    0x8(%ebp),%eax
   194ad:	83 c0 16             	add    $0x16,%eax
   194b0:	0f b6 00             	movzbl (%eax),%eax
   194b3:	c1 e0 10             	shl    $0x10,%eax
   194b6:	09 c2                	or     %eax,%edx
   194b8:	8b 45 08             	mov    0x8(%ebp),%eax
   194bb:	83 c0 15             	add    $0x15,%eax
   194be:	0f b6 00             	movzbl (%eax),%eax
   194c1:	c1 e0 08             	shl    $0x8,%eax
   194c4:	09 c2                	or     %eax,%edx
   194c6:	8b 45 08             	mov    0x8(%ebp),%eax
   194c9:	83 c0 14             	add    $0x14,%eax
   194cc:	0f b6 00             	movzbl (%eax),%eax
   194cf:	09 d0                	or     %edx,%eax
   194d1:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   194d4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   194d7:	c1 e8 18             	shr    $0x18,%eax
   194da:	0f b6 c0             	movzbl %al,%eax
   194dd:	33 0c 85 00 0c 00 00 	xor    0xc00(,%eax,4),%ecx
   194e4:	89 c8                	mov    %ecx,%eax
   194e6:	89 43 14             	mov    %eax,0x14(%ebx)
   194e9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   194ec:	8b 45 08             	mov    0x8(%ebp),%eax
   194ef:	83 c0 1b             	add    $0x1b,%eax
   194f2:	0f b6 00             	movzbl (%eax),%eax
   194f5:	89 c2                	mov    %eax,%edx
   194f7:	c1 e2 18             	shl    $0x18,%edx
   194fa:	8b 45 08             	mov    0x8(%ebp),%eax
   194fd:	83 c0 1a             	add    $0x1a,%eax
   19500:	0f b6 00             	movzbl (%eax),%eax
   19503:	c1 e0 10             	shl    $0x10,%eax
   19506:	09 c2                	or     %eax,%edx
   19508:	8b 45 08             	mov    0x8(%ebp),%eax
   1950b:	83 c0 19             	add    $0x19,%eax
   1950e:	0f b6 00             	movzbl (%eax),%eax
   19511:	c1 e0 08             	shl    $0x8,%eax
   19514:	09 c2                	or     %eax,%edx
   19516:	8b 45 08             	mov    0x8(%ebp),%eax
   19519:	83 c0 18             	add    $0x18,%eax
   1951c:	0f b6 00             	movzbl (%eax),%eax
   1951f:	09 d0                	or     %edx,%eax
   19521:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   19524:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   19527:	0f b6 c8             	movzbl %al,%ecx
   1952a:	8b 45 08             	mov    0x8(%ebp),%eax
   1952d:	83 c0 1b             	add    $0x1b,%eax
   19530:	0f b6 00             	movzbl (%eax),%eax
   19533:	89 c2                	mov    %eax,%edx
   19535:	c1 e2 18             	shl    $0x18,%edx
   19538:	8b 45 08             	mov    0x8(%ebp),%eax
   1953b:	83 c0 1a             	add    $0x1a,%eax
   1953e:	0f b6 00             	movzbl (%eax),%eax
   19541:	c1 e0 10             	shl    $0x10,%eax
   19544:	09 c2                	or     %eax,%edx
   19546:	8b 45 08             	mov    0x8(%ebp),%eax
   19549:	83 c0 19             	add    $0x19,%eax
   1954c:	0f b6 00             	movzbl (%eax),%eax
   1954f:	c1 e0 08             	shl    $0x8,%eax
   19552:	09 c2                	or     %eax,%edx
   19554:	8b 45 08             	mov    0x8(%ebp),%eax
   19557:	83 c0 18             	add    $0x18,%eax
   1955a:	0f b6 00             	movzbl (%eax),%eax
   1955d:	09 d0                	or     %edx,%eax
   1955f:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   19562:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   19565:	c1 e8 08             	shr    $0x8,%eax
   19568:	0f b6 c0             	movzbl %al,%eax
   1956b:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   19572:	8b 0c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%ecx
   19579:	31 c1                	xor    %eax,%ecx
   1957b:	8b 45 08             	mov    0x8(%ebp),%eax
   1957e:	83 c0 1b             	add    $0x1b,%eax
   19581:	0f b6 00             	movzbl (%eax),%eax
   19584:	89 c2                	mov    %eax,%edx
   19586:	c1 e2 18             	shl    $0x18,%edx
   19589:	8b 45 08             	mov    0x8(%ebp),%eax
   1958c:	83 c0 1a             	add    $0x1a,%eax
   1958f:	0f b6 00             	movzbl (%eax),%eax
   19592:	c1 e0 10             	shl    $0x10,%eax
   19595:	09 c2                	or     %eax,%edx
   19597:	8b 45 08             	mov    0x8(%ebp),%eax
   1959a:	83 c0 19             	add    $0x19,%eax
   1959d:	0f b6 00             	movzbl (%eax),%eax
   195a0:	c1 e0 08             	shl    $0x8,%eax
   195a3:	09 c2                	or     %eax,%edx
   195a5:	8b 45 08             	mov    0x8(%ebp),%eax
   195a8:	83 c0 18             	add    $0x18,%eax
   195ab:	0f b6 00             	movzbl (%eax),%eax
   195ae:	09 d0                	or     %edx,%eax
   195b0:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   195b3:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   195b6:	c1 e8 10             	shr    $0x10,%eax
   195b9:	0f b6 c0             	movzbl %al,%eax
   195bc:	33 0c 85 00 08 00 00 	xor    0x800(,%eax,4),%ecx
   195c3:	8b 45 08             	mov    0x8(%ebp),%eax
   195c6:	83 c0 1b             	add    $0x1b,%eax
   195c9:	0f b6 00             	movzbl (%eax),%eax
   195cc:	89 c2                	mov    %eax,%edx
   195ce:	c1 e2 18             	shl    $0x18,%edx
   195d1:	8b 45 08             	mov    0x8(%ebp),%eax
   195d4:	83 c0 1a             	add    $0x1a,%eax
   195d7:	0f b6 00             	movzbl (%eax),%eax
   195da:	c1 e0 10             	shl    $0x10,%eax
   195dd:	09 c2                	or     %eax,%edx
   195df:	8b 45 08             	mov    0x8(%ebp),%eax
   195e2:	83 c0 19             	add    $0x19,%eax
   195e5:	0f b6 00             	movzbl (%eax),%eax
   195e8:	c1 e0 08             	shl    $0x8,%eax
   195eb:	09 c2                	or     %eax,%edx
   195ed:	8b 45 08             	mov    0x8(%ebp),%eax
   195f0:	83 c0 18             	add    $0x18,%eax
   195f3:	0f b6 00             	movzbl (%eax),%eax
   195f6:	09 d0                	or     %edx,%eax
   195f8:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   195fb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   195fe:	c1 e8 18             	shr    $0x18,%eax
   19601:	0f b6 c0             	movzbl %al,%eax
   19604:	33 0c 85 00 0c 00 00 	xor    0xc00(,%eax,4),%ecx
   1960b:	89 c8                	mov    %ecx,%eax
   1960d:	89 43 18             	mov    %eax,0x18(%ebx)
   19610:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   19613:	8b 45 08             	mov    0x8(%ebp),%eax
   19616:	83 c0 1f             	add    $0x1f,%eax
   19619:	0f b6 00             	movzbl (%eax),%eax
   1961c:	89 c2                	mov    %eax,%edx
   1961e:	c1 e2 18             	shl    $0x18,%edx
   19621:	8b 45 08             	mov    0x8(%ebp),%eax
   19624:	83 c0 1e             	add    $0x1e,%eax
   19627:	0f b6 00             	movzbl (%eax),%eax
   1962a:	c1 e0 10             	shl    $0x10,%eax
   1962d:	09 c2                	or     %eax,%edx
   1962f:	8b 45 08             	mov    0x8(%ebp),%eax
   19632:	83 c0 1d             	add    $0x1d,%eax
   19635:	0f b6 00             	movzbl (%eax),%eax
   19638:	c1 e0 08             	shl    $0x8,%eax
   1963b:	09 c2                	or     %eax,%edx
   1963d:	8b 45 08             	mov    0x8(%ebp),%eax
   19640:	83 c0 1c             	add    $0x1c,%eax
   19643:	0f b6 00             	movzbl (%eax),%eax
   19646:	09 d0                	or     %edx,%eax
   19648:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1964b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1964e:	0f b6 c8             	movzbl %al,%ecx
   19651:	8b 45 08             	mov    0x8(%ebp),%eax
   19654:	83 c0 1f             	add    $0x1f,%eax
   19657:	0f b6 00             	movzbl (%eax),%eax
   1965a:	89 c2                	mov    %eax,%edx
   1965c:	c1 e2 18             	shl    $0x18,%edx
   1965f:	8b 45 08             	mov    0x8(%ebp),%eax
   19662:	83 c0 1e             	add    $0x1e,%eax
   19665:	0f b6 00             	movzbl (%eax),%eax
   19668:	c1 e0 10             	shl    $0x10,%eax
   1966b:	09 c2                	or     %eax,%edx
   1966d:	8b 45 08             	mov    0x8(%ebp),%eax
   19670:	83 c0 1d             	add    $0x1d,%eax
   19673:	0f b6 00             	movzbl (%eax),%eax
   19676:	c1 e0 08             	shl    $0x8,%eax
   19679:	09 c2                	or     %eax,%edx
   1967b:	8b 45 08             	mov    0x8(%ebp),%eax
   1967e:	83 c0 1c             	add    $0x1c,%eax
   19681:	0f b6 00             	movzbl (%eax),%eax
   19684:	09 d0                	or     %edx,%eax
   19686:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   19689:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1968c:	c1 e8 08             	shr    $0x8,%eax
   1968f:	0f b6 c0             	movzbl %al,%eax
   19692:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   19699:	8b 0c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%ecx
   196a0:	31 c1                	xor    %eax,%ecx
   196a2:	8b 45 08             	mov    0x8(%ebp),%eax
   196a5:	83 c0 1f             	add    $0x1f,%eax
   196a8:	0f b6 00             	movzbl (%eax),%eax
   196ab:	89 c2                	mov    %eax,%edx
   196ad:	c1 e2 18             	shl    $0x18,%edx
   196b0:	8b 45 08             	mov    0x8(%ebp),%eax
   196b3:	83 c0 1e             	add    $0x1e,%eax
   196b6:	0f b6 00             	movzbl (%eax),%eax
   196b9:	c1 e0 10             	shl    $0x10,%eax
   196bc:	09 c2                	or     %eax,%edx
   196be:	8b 45 08             	mov    0x8(%ebp),%eax
   196c1:	83 c0 1d             	add    $0x1d,%eax
   196c4:	0f b6 00             	movzbl (%eax),%eax
   196c7:	c1 e0 08             	shl    $0x8,%eax
   196ca:	09 c2                	or     %eax,%edx
   196cc:	8b 45 08             	mov    0x8(%ebp),%eax
   196cf:	83 c0 1c             	add    $0x1c,%eax
   196d2:	0f b6 00             	movzbl (%eax),%eax
   196d5:	09 d0                	or     %edx,%eax
   196d7:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   196da:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   196dd:	c1 e8 10             	shr    $0x10,%eax
   196e0:	0f b6 c0             	movzbl %al,%eax
   196e3:	33 0c 85 00 08 00 00 	xor    0x800(,%eax,4),%ecx
   196ea:	8b 45 08             	mov    0x8(%ebp),%eax
   196ed:	83 c0 1f             	add    $0x1f,%eax
   196f0:	0f b6 00             	movzbl (%eax),%eax
   196f3:	89 c2                	mov    %eax,%edx
   196f5:	c1 e2 18             	shl    $0x18,%edx
   196f8:	8b 45 08             	mov    0x8(%ebp),%eax
   196fb:	83 c0 1e             	add    $0x1e,%eax
   196fe:	0f b6 00             	movzbl (%eax),%eax
   19701:	c1 e0 10             	shl    $0x10,%eax
   19704:	09 c2                	or     %eax,%edx
   19706:	8b 45 08             	mov    0x8(%ebp),%eax
   19709:	83 c0 1d             	add    $0x1d,%eax
   1970c:	0f b6 00             	movzbl (%eax),%eax
   1970f:	c1 e0 08             	shl    $0x8,%eax
   19712:	09 c2                	or     %eax,%edx
   19714:	8b 45 08             	mov    0x8(%ebp),%eax
   19717:	83 c0 1c             	add    $0x1c,%eax
   1971a:	0f b6 00             	movzbl (%eax),%eax
   1971d:	09 d0                	or     %edx,%eax
   1971f:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   19722:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   19725:	c1 e8 18             	shr    $0x18,%eax
   19728:	0f b6 c0             	movzbl %al,%eax
   1972b:	33 0c 85 00 0c 00 00 	xor    0xc00(,%eax,4),%ecx
   19732:	89 c8                	mov    %ecx,%eax
   19734:	89 43 1c             	mov    %eax,0x1c(%ebx)
   19737:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1973a:	c1 e8 08             	shr    $0x8,%eax
   1973d:	0f b6 d0             	movzbl %al,%edx
   19740:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   19743:	c1 e8 10             	shr    $0x10,%eax
   19746:	0f b6 c0             	movzbl %al,%eax
   19749:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   19750:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   19757:	31 c2                	xor    %eax,%edx
   19759:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1975c:	c1 e8 18             	shr    $0x18,%eax
   1975f:	0f b6 c0             	movzbl %al,%eax
   19762:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   19769:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   1976d:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   19774:	89 d0                	mov    %edx,%eax
   19776:	89 c2                	mov    %eax,%edx
   19778:	33 15 00 00 00 00    	xor    0x0,%edx
   1977e:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   19781:	31 10                	xor    %edx,(%eax)
   19783:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19786:	0f b6 55 d8          	movzbl 0xffffffd8(%ebp),%edx
   1978a:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   1978d:	c1 e8 08             	shr    $0x8,%eax
   19790:	0f b6 c0             	movzbl %al,%eax
   19793:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   1979a:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   197a1:	31 c2                	xor    %eax,%edx
   197a3:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   197a6:	c1 e8 10             	shr    $0x10,%eax
   197a9:	0f b6 c0             	movzbl %al,%eax
   197ac:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   197b3:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   197b6:	c1 e8 18             	shr    $0x18,%eax
   197b9:	0f b6 c0             	movzbl %al,%eax
   197bc:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   197c3:	89 d0                	mov    %edx,%eax
   197c5:	89 41 20             	mov    %eax,0x20(%ecx)
   197c8:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   197cb:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   197ce:	31 10                	xor    %edx,(%eax)
   197d0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   197d3:	0f b6 55 dc          	movzbl 0xffffffdc(%ebp),%edx
   197d7:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   197da:	c1 e8 08             	shr    $0x8,%eax
   197dd:	0f b6 c0             	movzbl %al,%eax
   197e0:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   197e7:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   197ee:	31 c2                	xor    %eax,%edx
   197f0:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   197f3:	c1 e8 10             	shr    $0x10,%eax
   197f6:	0f b6 c0             	movzbl %al,%eax
   197f9:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   19800:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   19803:	c1 e8 18             	shr    $0x18,%eax
   19806:	0f b6 c0             	movzbl %al,%eax
   19809:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   19810:	89 d0                	mov    %edx,%eax
   19812:	89 41 24             	mov    %eax,0x24(%ecx)
   19815:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   19818:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   1981b:	31 10                	xor    %edx,(%eax)
   1981d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19820:	0f b6 55 e0          	movzbl 0xffffffe0(%ebp),%edx
   19824:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   19827:	c1 e8 08             	shr    $0x8,%eax
   1982a:	0f b6 c0             	movzbl %al,%eax
   1982d:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   19834:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1983b:	31 c2                	xor    %eax,%edx
   1983d:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   19840:	c1 e8 10             	shr    $0x10,%eax
   19843:	0f b6 c0             	movzbl %al,%eax
   19846:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   1984d:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   19850:	c1 e8 18             	shr    $0x18,%eax
   19853:	0f b6 c0             	movzbl %al,%eax
   19856:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1985d:	89 d0                	mov    %edx,%eax
   1985f:	89 41 28             	mov    %eax,0x28(%ecx)
   19862:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   19865:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   19868:	31 10                	xor    %edx,(%eax)
   1986a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1986d:	0f b6 55 e4          	movzbl 0xffffffe4(%ebp),%edx
   19871:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   19874:	c1 e8 08             	shr    $0x8,%eax
   19877:	0f b6 c0             	movzbl %al,%eax
   1987a:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   19881:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   19888:	31 c2                	xor    %eax,%edx
   1988a:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1988d:	c1 e8 10             	shr    $0x10,%eax
   19890:	0f b6 c0             	movzbl %al,%eax
   19893:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   1989a:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1989d:	c1 e8 18             	shr    $0x18,%eax
   198a0:	0f b6 c0             	movzbl %al,%eax
   198a3:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   198aa:	89 d0                	mov    %edx,%eax
   198ac:	89 41 2c             	mov    %eax,0x2c(%ecx)
   198af:	0f b6 55 e4          	movzbl 0xffffffe4(%ebp),%edx
   198b3:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   198b6:	c1 e8 08             	shr    $0x8,%eax
   198b9:	0f b6 c0             	movzbl %al,%eax
   198bc:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   198c3:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   198ca:	31 c2                	xor    %eax,%edx
   198cc:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   198cf:	c1 e8 10             	shr    $0x10,%eax
   198d2:	0f b6 c0             	movzbl %al,%eax
   198d5:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   198dc:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   198df:	c1 e8 18             	shr    $0x18,%eax
   198e2:	0f b6 c0             	movzbl %al,%eax
   198e5:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   198ec:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   198ef:	31 10                	xor    %edx,(%eax)
   198f1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   198f4:	0f b6 55 e8          	movzbl 0xffffffe8(%ebp),%edx
   198f8:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   198fb:	c1 e8 08             	shr    $0x8,%eax
   198fe:	0f b6 c0             	movzbl %al,%eax
   19901:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   19908:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1990f:	31 c2                	xor    %eax,%edx
   19911:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   19914:	c1 e8 10             	shr    $0x10,%eax
   19917:	0f b6 c0             	movzbl %al,%eax
   1991a:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   19921:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   19924:	c1 e8 18             	shr    $0x18,%eax
   19927:	0f b6 c0             	movzbl %al,%eax
   1992a:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   19931:	89 d0                	mov    %edx,%eax
   19933:	89 41 30             	mov    %eax,0x30(%ecx)
   19936:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   19939:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   1993c:	31 10                	xor    %edx,(%eax)
   1993e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19941:	0f b6 55 ec          	movzbl 0xffffffec(%ebp),%edx
   19945:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   19948:	c1 e8 08             	shr    $0x8,%eax
   1994b:	0f b6 c0             	movzbl %al,%eax
   1994e:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   19955:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1995c:	31 c2                	xor    %eax,%edx
   1995e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   19961:	c1 e8 10             	shr    $0x10,%eax
   19964:	0f b6 c0             	movzbl %al,%eax
   19967:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   1996e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   19971:	c1 e8 18             	shr    $0x18,%eax
   19974:	0f b6 c0             	movzbl %al,%eax
   19977:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1997e:	89 d0                	mov    %edx,%eax
   19980:	89 41 34             	mov    %eax,0x34(%ecx)
   19983:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   19986:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   19989:	31 10                	xor    %edx,(%eax)
   1998b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1998e:	0f b6 55 f0          	movzbl 0xfffffff0(%ebp),%edx
   19992:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   19995:	c1 e8 08             	shr    $0x8,%eax
   19998:	0f b6 c0             	movzbl %al,%eax
   1999b:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   199a2:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   199a9:	31 c2                	xor    %eax,%edx
   199ab:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   199ae:	c1 e8 10             	shr    $0x10,%eax
   199b1:	0f b6 c0             	movzbl %al,%eax
   199b4:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   199bb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   199be:	c1 e8 18             	shr    $0x18,%eax
   199c1:	0f b6 c0             	movzbl %al,%eax
   199c4:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   199cb:	89 d0                	mov    %edx,%eax
   199cd:	89 41 38             	mov    %eax,0x38(%ecx)
   199d0:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   199d3:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   199d6:	31 10                	xor    %edx,(%eax)
   199d8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   199db:	0f b6 55 f4          	movzbl 0xfffffff4(%ebp),%edx
   199df:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   199e2:	c1 e8 08             	shr    $0x8,%eax
   199e5:	0f b6 c0             	movzbl %al,%eax
   199e8:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   199ef:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   199f6:	31 c2                	xor    %eax,%edx
   199f8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   199fb:	c1 e8 10             	shr    $0x10,%eax
   199fe:	0f b6 c0             	movzbl %al,%eax
   19a01:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   19a08:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   19a0b:	c1 e8 18             	shr    $0x18,%eax
   19a0e:	0f b6 c0             	movzbl %al,%eax
   19a11:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   19a18:	89 d0                	mov    %edx,%eax
   19a1a:	89 41 3c             	mov    %eax,0x3c(%ecx)
   19a1d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   19a20:	c1 e8 08             	shr    $0x8,%eax
   19a23:	0f b6 d0             	movzbl %al,%edx
   19a26:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   19a29:	c1 e8 10             	shr    $0x10,%eax
   19a2c:	0f b6 c0             	movzbl %al,%eax
   19a2f:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   19a36:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   19a3d:	31 c2                	xor    %eax,%edx
   19a3f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   19a42:	c1 e8 18             	shr    $0x18,%eax
   19a45:	0f b6 c0             	movzbl %al,%eax
   19a48:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   19a4f:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   19a53:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   19a5a:	89 d0                	mov    %edx,%eax
   19a5c:	33 05 04 00 00 00    	xor    0x4,%eax
   19a62:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   19a65:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
   19a68:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   19a6b:	31 10                	xor    %edx,(%eax)
   19a6d:	0f b6 55 d4          	movzbl 0xffffffd4(%ebp),%edx
   19a71:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19a74:	c1 e8 08             	shr    $0x8,%eax
   19a77:	0f b6 c0             	movzbl %al,%eax
   19a7a:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   19a81:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   19a88:	31 c2                	xor    %eax,%edx
   19a8a:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19a8d:	c1 e8 10             	shr    $0x10,%eax
   19a90:	0f b6 c0             	movzbl %al,%eax
   19a93:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   19a9a:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19a9d:	c1 e8 18             	shr    $0x18,%eax
   19aa0:	0f b6 c0             	movzbl %al,%eax
   19aa3:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   19aaa:	89 d0                	mov    %edx,%eax
   19aac:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   19aaf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19ab2:	8b 45 0c             	mov    0xc(%ebp),%eax
   19ab5:	8b 50 20             	mov    0x20(%eax),%edx
   19ab8:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19abb:	31 10                	xor    %edx,(%eax)
   19abd:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19ac0:	89 41 40             	mov    %eax,0x40(%ecx)
   19ac3:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   19ac6:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   19ac9:	31 10                	xor    %edx,(%eax)
   19acb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19ace:	8b 45 0c             	mov    0xc(%ebp),%eax
   19ad1:	8b 50 24             	mov    0x24(%eax),%edx
   19ad4:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19ad7:	31 10                	xor    %edx,(%eax)
   19ad9:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19adc:	89 41 44             	mov    %eax,0x44(%ecx)
   19adf:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   19ae2:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   19ae5:	31 10                	xor    %edx,(%eax)
   19ae7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19aea:	8b 45 0c             	mov    0xc(%ebp),%eax
   19aed:	8b 50 28             	mov    0x28(%eax),%edx
   19af0:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19af3:	31 10                	xor    %edx,(%eax)
   19af5:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19af8:	89 41 48             	mov    %eax,0x48(%ecx)
   19afb:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   19afe:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   19b01:	31 10                	xor    %edx,(%eax)
   19b03:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19b06:	8b 45 0c             	mov    0xc(%ebp),%eax
   19b09:	8b 50 2c             	mov    0x2c(%eax),%edx
   19b0c:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19b0f:	31 10                	xor    %edx,(%eax)
   19b11:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19b14:	89 41 4c             	mov    %eax,0x4c(%ecx)
   19b17:	0f b6 55 e4          	movzbl 0xffffffe4(%ebp),%edx
   19b1b:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   19b1e:	c1 e8 08             	shr    $0x8,%eax
   19b21:	0f b6 c0             	movzbl %al,%eax
   19b24:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   19b2b:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   19b32:	31 c2                	xor    %eax,%edx
   19b34:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   19b37:	c1 e8 10             	shr    $0x10,%eax
   19b3a:	0f b6 c0             	movzbl %al,%eax
   19b3d:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   19b44:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   19b47:	c1 e8 18             	shr    $0x18,%eax
   19b4a:	0f b6 c0             	movzbl %al,%eax
   19b4d:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   19b54:	89 d0                	mov    %edx,%eax
   19b56:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   19b59:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
   19b5c:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   19b5f:	31 10                	xor    %edx,(%eax)
   19b61:	0f b6 55 d4          	movzbl 0xffffffd4(%ebp),%edx
   19b65:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19b68:	c1 e8 08             	shr    $0x8,%eax
   19b6b:	0f b6 c0             	movzbl %al,%eax
   19b6e:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   19b75:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   19b7c:	31 c2                	xor    %eax,%edx
   19b7e:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19b81:	c1 e8 10             	shr    $0x10,%eax
   19b84:	0f b6 c0             	movzbl %al,%eax
   19b87:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   19b8e:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19b91:	c1 e8 18             	shr    $0x18,%eax
   19b94:	0f b6 c0             	movzbl %al,%eax
   19b97:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   19b9e:	89 d0                	mov    %edx,%eax
   19ba0:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   19ba3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19ba6:	8b 45 0c             	mov    0xc(%ebp),%eax
   19ba9:	8b 50 30             	mov    0x30(%eax),%edx
   19bac:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19baf:	31 10                	xor    %edx,(%eax)
   19bb1:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19bb4:	89 41 50             	mov    %eax,0x50(%ecx)
   19bb7:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   19bba:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   19bbd:	31 10                	xor    %edx,(%eax)
   19bbf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19bc2:	8b 45 0c             	mov    0xc(%ebp),%eax
   19bc5:	8b 50 34             	mov    0x34(%eax),%edx
   19bc8:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19bcb:	31 10                	xor    %edx,(%eax)
   19bcd:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19bd0:	89 41 54             	mov    %eax,0x54(%ecx)
   19bd3:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   19bd6:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   19bd9:	31 10                	xor    %edx,(%eax)
   19bdb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19bde:	8b 45 0c             	mov    0xc(%ebp),%eax
   19be1:	8b 50 38             	mov    0x38(%eax),%edx
   19be4:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19be7:	31 10                	xor    %edx,(%eax)
   19be9:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19bec:	89 41 58             	mov    %eax,0x58(%ecx)
   19bef:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   19bf2:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   19bf5:	31 10                	xor    %edx,(%eax)
   19bf7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19bfa:	8b 45 0c             	mov    0xc(%ebp),%eax
   19bfd:	8b 50 3c             	mov    0x3c(%eax),%edx
   19c00:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19c03:	31 10                	xor    %edx,(%eax)
   19c05:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19c08:	89 41 5c             	mov    %eax,0x5c(%ecx)
   19c0b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   19c0e:	c1 e8 08             	shr    $0x8,%eax
   19c11:	0f b6 d0             	movzbl %al,%edx
   19c14:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   19c17:	c1 e8 10             	shr    $0x10,%eax
   19c1a:	0f b6 c0             	movzbl %al,%eax
   19c1d:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   19c24:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   19c2b:	31 c2                	xor    %eax,%edx
   19c2d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   19c30:	c1 e8 18             	shr    $0x18,%eax
   19c33:	0f b6 c0             	movzbl %al,%eax
   19c36:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   19c3d:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   19c41:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   19c48:	89 d0                	mov    %edx,%eax
   19c4a:	33 05 08 00 00 00    	xor    0x8,%eax
   19c50:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   19c53:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
   19c56:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   19c59:	31 10                	xor    %edx,(%eax)
   19c5b:	0f b6 55 d4          	movzbl 0xffffffd4(%ebp),%edx
   19c5f:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19c62:	c1 e8 08             	shr    $0x8,%eax
   19c65:	0f b6 c0             	movzbl %al,%eax
   19c68:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   19c6f:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   19c76:	31 c2                	xor    %eax,%edx
   19c78:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19c7b:	c1 e8 10             	shr    $0x10,%eax
   19c7e:	0f b6 c0             	movzbl %al,%eax
   19c81:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   19c88:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19c8b:	c1 e8 18             	shr    $0x18,%eax
   19c8e:	0f b6 c0             	movzbl %al,%eax
   19c91:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   19c98:	89 d0                	mov    %edx,%eax
   19c9a:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   19c9d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19ca0:	8b 45 0c             	mov    0xc(%ebp),%eax
   19ca3:	8b 50 40             	mov    0x40(%eax),%edx
   19ca6:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19ca9:	31 10                	xor    %edx,(%eax)
   19cab:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19cae:	89 41 60             	mov    %eax,0x60(%ecx)
   19cb1:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   19cb4:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   19cb7:	31 10                	xor    %edx,(%eax)
   19cb9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19cbc:	8b 45 0c             	mov    0xc(%ebp),%eax
   19cbf:	8b 50 44             	mov    0x44(%eax),%edx
   19cc2:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19cc5:	31 10                	xor    %edx,(%eax)
   19cc7:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19cca:	89 41 64             	mov    %eax,0x64(%ecx)
   19ccd:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   19cd0:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   19cd3:	31 10                	xor    %edx,(%eax)
   19cd5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19cd8:	8b 45 0c             	mov    0xc(%ebp),%eax
   19cdb:	8b 50 48             	mov    0x48(%eax),%edx
   19cde:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19ce1:	31 10                	xor    %edx,(%eax)
   19ce3:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19ce6:	89 41 68             	mov    %eax,0x68(%ecx)
   19ce9:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   19cec:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   19cef:	31 10                	xor    %edx,(%eax)
   19cf1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19cf4:	8b 45 0c             	mov    0xc(%ebp),%eax
   19cf7:	8b 50 4c             	mov    0x4c(%eax),%edx
   19cfa:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19cfd:	31 10                	xor    %edx,(%eax)
   19cff:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19d02:	89 41 6c             	mov    %eax,0x6c(%ecx)
   19d05:	0f b6 55 e4          	movzbl 0xffffffe4(%ebp),%edx
   19d09:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   19d0c:	c1 e8 08             	shr    $0x8,%eax
   19d0f:	0f b6 c0             	movzbl %al,%eax
   19d12:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   19d19:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   19d20:	31 c2                	xor    %eax,%edx
   19d22:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   19d25:	c1 e8 10             	shr    $0x10,%eax
   19d28:	0f b6 c0             	movzbl %al,%eax
   19d2b:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   19d32:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   19d35:	c1 e8 18             	shr    $0x18,%eax
   19d38:	0f b6 c0             	movzbl %al,%eax
   19d3b:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   19d42:	89 d0                	mov    %edx,%eax
   19d44:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   19d47:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
   19d4a:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   19d4d:	31 10                	xor    %edx,(%eax)
   19d4f:	0f b6 55 d4          	movzbl 0xffffffd4(%ebp),%edx
   19d53:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19d56:	c1 e8 08             	shr    $0x8,%eax
   19d59:	0f b6 c0             	movzbl %al,%eax
   19d5c:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   19d63:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   19d6a:	31 c2                	xor    %eax,%edx
   19d6c:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19d6f:	c1 e8 10             	shr    $0x10,%eax
   19d72:	0f b6 c0             	movzbl %al,%eax
   19d75:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   19d7c:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19d7f:	c1 e8 18             	shr    $0x18,%eax
   19d82:	0f b6 c0             	movzbl %al,%eax
   19d85:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   19d8c:	89 d0                	mov    %edx,%eax
   19d8e:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   19d91:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19d94:	8b 45 0c             	mov    0xc(%ebp),%eax
   19d97:	8b 50 50             	mov    0x50(%eax),%edx
   19d9a:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19d9d:	31 10                	xor    %edx,(%eax)
   19d9f:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19da2:	89 41 70             	mov    %eax,0x70(%ecx)
   19da5:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   19da8:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   19dab:	31 10                	xor    %edx,(%eax)
   19dad:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19db0:	8b 45 0c             	mov    0xc(%ebp),%eax
   19db3:	8b 50 54             	mov    0x54(%eax),%edx
   19db6:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19db9:	31 10                	xor    %edx,(%eax)
   19dbb:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19dbe:	89 41 74             	mov    %eax,0x74(%ecx)
   19dc1:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   19dc4:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   19dc7:	31 10                	xor    %edx,(%eax)
   19dc9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19dcc:	8b 45 0c             	mov    0xc(%ebp),%eax
   19dcf:	8b 50 58             	mov    0x58(%eax),%edx
   19dd2:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19dd5:	31 10                	xor    %edx,(%eax)
   19dd7:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19dda:	89 41 78             	mov    %eax,0x78(%ecx)
   19ddd:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   19de0:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   19de3:	31 10                	xor    %edx,(%eax)
   19de5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19de8:	8b 45 0c             	mov    0xc(%ebp),%eax
   19deb:	8b 50 5c             	mov    0x5c(%eax),%edx
   19dee:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19df1:	31 10                	xor    %edx,(%eax)
   19df3:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19df6:	89 41 7c             	mov    %eax,0x7c(%ecx)
   19df9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   19dfc:	c1 e8 08             	shr    $0x8,%eax
   19dff:	0f b6 d0             	movzbl %al,%edx
   19e02:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   19e05:	c1 e8 10             	shr    $0x10,%eax
   19e08:	0f b6 c0             	movzbl %al,%eax
   19e0b:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   19e12:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   19e19:	31 c2                	xor    %eax,%edx
   19e1b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   19e1e:	c1 e8 18             	shr    $0x18,%eax
   19e21:	0f b6 c0             	movzbl %al,%eax
   19e24:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   19e2b:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   19e2f:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   19e36:	89 d0                	mov    %edx,%eax
   19e38:	33 05 0c 00 00 00    	xor    0xc,%eax
   19e3e:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   19e41:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
   19e44:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   19e47:	31 10                	xor    %edx,(%eax)
   19e49:	0f b6 55 d4          	movzbl 0xffffffd4(%ebp),%edx
   19e4d:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19e50:	c1 e8 08             	shr    $0x8,%eax
   19e53:	0f b6 c0             	movzbl %al,%eax
   19e56:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   19e5d:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   19e64:	31 c2                	xor    %eax,%edx
   19e66:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19e69:	c1 e8 10             	shr    $0x10,%eax
   19e6c:	0f b6 c0             	movzbl %al,%eax
   19e6f:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   19e76:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19e79:	c1 e8 18             	shr    $0x18,%eax
   19e7c:	0f b6 c0             	movzbl %al,%eax
   19e7f:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   19e86:	89 d0                	mov    %edx,%eax
   19e88:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   19e8b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19e8e:	8b 45 0c             	mov    0xc(%ebp),%eax
   19e91:	8b 50 60             	mov    0x60(%eax),%edx
   19e94:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19e97:	31 10                	xor    %edx,(%eax)
   19e99:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19e9c:	89 81 80 00 00 00    	mov    %eax,0x80(%ecx)
   19ea2:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   19ea5:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   19ea8:	31 10                	xor    %edx,(%eax)
   19eaa:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19ead:	8b 45 0c             	mov    0xc(%ebp),%eax
   19eb0:	8b 50 64             	mov    0x64(%eax),%edx
   19eb3:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19eb6:	31 10                	xor    %edx,(%eax)
   19eb8:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19ebb:	89 81 84 00 00 00    	mov    %eax,0x84(%ecx)
   19ec1:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   19ec4:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   19ec7:	31 10                	xor    %edx,(%eax)
   19ec9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19ecc:	8b 45 0c             	mov    0xc(%ebp),%eax
   19ecf:	8b 50 68             	mov    0x68(%eax),%edx
   19ed2:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19ed5:	31 10                	xor    %edx,(%eax)
   19ed7:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19eda:	89 81 88 00 00 00    	mov    %eax,0x88(%ecx)
   19ee0:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   19ee3:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   19ee6:	31 10                	xor    %edx,(%eax)
   19ee8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19eeb:	8b 45 0c             	mov    0xc(%ebp),%eax
   19eee:	8b 50 6c             	mov    0x6c(%eax),%edx
   19ef1:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19ef4:	31 10                	xor    %edx,(%eax)
   19ef6:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19ef9:	89 81 8c 00 00 00    	mov    %eax,0x8c(%ecx)
   19eff:	0f b6 55 e4          	movzbl 0xffffffe4(%ebp),%edx
   19f03:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   19f06:	c1 e8 08             	shr    $0x8,%eax
   19f09:	0f b6 c0             	movzbl %al,%eax
   19f0c:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   19f13:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   19f1a:	31 c2                	xor    %eax,%edx
   19f1c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   19f1f:	c1 e8 10             	shr    $0x10,%eax
   19f22:	0f b6 c0             	movzbl %al,%eax
   19f25:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   19f2c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   19f2f:	c1 e8 18             	shr    $0x18,%eax
   19f32:	0f b6 c0             	movzbl %al,%eax
   19f35:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   19f3c:	89 d0                	mov    %edx,%eax
   19f3e:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   19f41:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
   19f44:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   19f47:	31 10                	xor    %edx,(%eax)
   19f49:	0f b6 55 d4          	movzbl 0xffffffd4(%ebp),%edx
   19f4d:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19f50:	c1 e8 08             	shr    $0x8,%eax
   19f53:	0f b6 c0             	movzbl %al,%eax
   19f56:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   19f5d:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   19f64:	31 c2                	xor    %eax,%edx
   19f66:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19f69:	c1 e8 10             	shr    $0x10,%eax
   19f6c:	0f b6 c0             	movzbl %al,%eax
   19f6f:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   19f76:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19f79:	c1 e8 18             	shr    $0x18,%eax
   19f7c:	0f b6 c0             	movzbl %al,%eax
   19f7f:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   19f86:	89 d0                	mov    %edx,%eax
   19f88:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   19f8b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19f8e:	8b 45 0c             	mov    0xc(%ebp),%eax
   19f91:	8b 50 70             	mov    0x70(%eax),%edx
   19f94:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19f97:	31 10                	xor    %edx,(%eax)
   19f99:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19f9c:	89 81 90 00 00 00    	mov    %eax,0x90(%ecx)
   19fa2:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   19fa5:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   19fa8:	31 10                	xor    %edx,(%eax)
   19faa:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19fad:	8b 45 0c             	mov    0xc(%ebp),%eax
   19fb0:	8b 50 74             	mov    0x74(%eax),%edx
   19fb3:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19fb6:	31 10                	xor    %edx,(%eax)
   19fb8:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19fbb:	89 81 94 00 00 00    	mov    %eax,0x94(%ecx)
   19fc1:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   19fc4:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   19fc7:	31 10                	xor    %edx,(%eax)
   19fc9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19fcc:	8b 45 0c             	mov    0xc(%ebp),%eax
   19fcf:	8b 50 78             	mov    0x78(%eax),%edx
   19fd2:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19fd5:	31 10                	xor    %edx,(%eax)
   19fd7:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19fda:	89 81 98 00 00 00    	mov    %eax,0x98(%ecx)
   19fe0:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   19fe3:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   19fe6:	31 10                	xor    %edx,(%eax)
   19fe8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19feb:	8b 45 0c             	mov    0xc(%ebp),%eax
   19fee:	8b 50 7c             	mov    0x7c(%eax),%edx
   19ff1:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   19ff4:	31 10                	xor    %edx,(%eax)
   19ff6:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19ff9:	89 81 9c 00 00 00    	mov    %eax,0x9c(%ecx)
   19fff:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1a002:	c1 e8 08             	shr    $0x8,%eax
   1a005:	0f b6 d0             	movzbl %al,%edx
   1a008:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1a00b:	c1 e8 10             	shr    $0x10,%eax
   1a00e:	0f b6 c0             	movzbl %al,%eax
   1a011:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   1a018:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1a01f:	31 c2                	xor    %eax,%edx
   1a021:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1a024:	c1 e8 18             	shr    $0x18,%eax
   1a027:	0f b6 c0             	movzbl %al,%eax
   1a02a:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   1a031:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   1a035:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1a03c:	89 d0                	mov    %edx,%eax
   1a03e:	33 05 10 00 00 00    	xor    0x10,%eax
   1a044:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   1a047:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
   1a04a:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   1a04d:	31 10                	xor    %edx,(%eax)
   1a04f:	0f b6 55 d4          	movzbl 0xffffffd4(%ebp),%edx
   1a053:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a056:	c1 e8 08             	shr    $0x8,%eax
   1a059:	0f b6 c0             	movzbl %al,%eax
   1a05c:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   1a063:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1a06a:	31 c2                	xor    %eax,%edx
   1a06c:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a06f:	c1 e8 10             	shr    $0x10,%eax
   1a072:	0f b6 c0             	movzbl %al,%eax
   1a075:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   1a07c:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a07f:	c1 e8 18             	shr    $0x18,%eax
   1a082:	0f b6 c0             	movzbl %al,%eax
   1a085:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1a08c:	89 d0                	mov    %edx,%eax
   1a08e:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   1a091:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1a094:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a097:	8b 90 80 00 00 00    	mov    0x80(%eax),%edx
   1a09d:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   1a0a0:	31 10                	xor    %edx,(%eax)
   1a0a2:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a0a5:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
   1a0ab:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   1a0ae:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   1a0b1:	31 10                	xor    %edx,(%eax)
   1a0b3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1a0b6:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a0b9:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
   1a0bf:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   1a0c2:	31 10                	xor    %edx,(%eax)
   1a0c4:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a0c7:	89 81 a4 00 00 00    	mov    %eax,0xa4(%ecx)
   1a0cd:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   1a0d0:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   1a0d3:	31 10                	xor    %edx,(%eax)
   1a0d5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1a0d8:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a0db:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
   1a0e1:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   1a0e4:	31 10                	xor    %edx,(%eax)
   1a0e6:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a0e9:	89 81 a8 00 00 00    	mov    %eax,0xa8(%ecx)
   1a0ef:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   1a0f2:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   1a0f5:	31 10                	xor    %edx,(%eax)
   1a0f7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1a0fa:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a0fd:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
   1a103:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   1a106:	31 10                	xor    %edx,(%eax)
   1a108:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a10b:	89 81 ac 00 00 00    	mov    %eax,0xac(%ecx)
   1a111:	0f b6 55 e4          	movzbl 0xffffffe4(%ebp),%edx
   1a115:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1a118:	c1 e8 08             	shr    $0x8,%eax
   1a11b:	0f b6 c0             	movzbl %al,%eax
   1a11e:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   1a125:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1a12c:	31 c2                	xor    %eax,%edx
   1a12e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1a131:	c1 e8 10             	shr    $0x10,%eax
   1a134:	0f b6 c0             	movzbl %al,%eax
   1a137:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   1a13e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1a141:	c1 e8 18             	shr    $0x18,%eax
   1a144:	0f b6 c0             	movzbl %al,%eax
   1a147:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1a14e:	89 d0                	mov    %edx,%eax
   1a150:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   1a153:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
   1a156:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   1a159:	31 10                	xor    %edx,(%eax)
   1a15b:	0f b6 55 d4          	movzbl 0xffffffd4(%ebp),%edx
   1a15f:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a162:	c1 e8 08             	shr    $0x8,%eax
   1a165:	0f b6 c0             	movzbl %al,%eax
   1a168:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   1a16f:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1a176:	31 c2                	xor    %eax,%edx
   1a178:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a17b:	c1 e8 10             	shr    $0x10,%eax
   1a17e:	0f b6 c0             	movzbl %al,%eax
   1a181:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   1a188:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a18b:	c1 e8 18             	shr    $0x18,%eax
   1a18e:	0f b6 c0             	movzbl %al,%eax
   1a191:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1a198:	89 d0                	mov    %edx,%eax
   1a19a:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   1a19d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1a1a0:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a1a3:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
   1a1a9:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   1a1ac:	31 10                	xor    %edx,(%eax)
   1a1ae:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a1b1:	89 81 b0 00 00 00    	mov    %eax,0xb0(%ecx)
   1a1b7:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   1a1ba:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   1a1bd:	31 10                	xor    %edx,(%eax)
   1a1bf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1a1c2:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a1c5:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
   1a1cb:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   1a1ce:	31 10                	xor    %edx,(%eax)
   1a1d0:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a1d3:	89 81 b4 00 00 00    	mov    %eax,0xb4(%ecx)
   1a1d9:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   1a1dc:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   1a1df:	31 10                	xor    %edx,(%eax)
   1a1e1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1a1e4:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a1e7:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
   1a1ed:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   1a1f0:	31 10                	xor    %edx,(%eax)
   1a1f2:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a1f5:	89 81 b8 00 00 00    	mov    %eax,0xb8(%ecx)
   1a1fb:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   1a1fe:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   1a201:	31 10                	xor    %edx,(%eax)
   1a203:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1a206:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a209:	8b 90 9c 00 00 00    	mov    0x9c(%eax),%edx
   1a20f:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   1a212:	31 10                	xor    %edx,(%eax)
   1a214:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a217:	89 81 bc 00 00 00    	mov    %eax,0xbc(%ecx)
   1a21d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1a220:	c1 e8 08             	shr    $0x8,%eax
   1a223:	0f b6 d0             	movzbl %al,%edx
   1a226:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1a229:	c1 e8 10             	shr    $0x10,%eax
   1a22c:	0f b6 c0             	movzbl %al,%eax
   1a22f:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   1a236:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1a23d:	31 c2                	xor    %eax,%edx
   1a23f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1a242:	c1 e8 18             	shr    $0x18,%eax
   1a245:	0f b6 c0             	movzbl %al,%eax
   1a248:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   1a24f:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   1a253:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1a25a:	89 d0                	mov    %edx,%eax
   1a25c:	33 05 14 00 00 00    	xor    0x14,%eax
   1a262:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   1a265:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
   1a268:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   1a26b:	31 10                	xor    %edx,(%eax)
   1a26d:	0f b6 55 d4          	movzbl 0xffffffd4(%ebp),%edx
   1a271:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a274:	c1 e8 08             	shr    $0x8,%eax
   1a277:	0f b6 c0             	movzbl %al,%eax
   1a27a:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   1a281:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1a288:	31 c2                	xor    %eax,%edx
   1a28a:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a28d:	c1 e8 10             	shr    $0x10,%eax
   1a290:	0f b6 c0             	movzbl %al,%eax
   1a293:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   1a29a:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a29d:	c1 e8 18             	shr    $0x18,%eax
   1a2a0:	0f b6 c0             	movzbl %al,%eax
   1a2a3:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1a2aa:	89 d0                	mov    %edx,%eax
   1a2ac:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   1a2af:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1a2b2:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a2b5:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
   1a2bb:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   1a2be:	31 10                	xor    %edx,(%eax)
   1a2c0:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a2c3:	89 81 c0 00 00 00    	mov    %eax,0xc0(%ecx)
   1a2c9:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   1a2cc:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   1a2cf:	31 10                	xor    %edx,(%eax)
   1a2d1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1a2d4:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a2d7:	8b 90 a4 00 00 00    	mov    0xa4(%eax),%edx
   1a2dd:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   1a2e0:	31 10                	xor    %edx,(%eax)
   1a2e2:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a2e5:	89 81 c4 00 00 00    	mov    %eax,0xc4(%ecx)
   1a2eb:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   1a2ee:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   1a2f1:	31 10                	xor    %edx,(%eax)
   1a2f3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1a2f6:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a2f9:	8b 90 a8 00 00 00    	mov    0xa8(%eax),%edx
   1a2ff:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   1a302:	31 10                	xor    %edx,(%eax)
   1a304:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a307:	89 81 c8 00 00 00    	mov    %eax,0xc8(%ecx)
   1a30d:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   1a310:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   1a313:	31 10                	xor    %edx,(%eax)
   1a315:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1a318:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a31b:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
   1a321:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   1a324:	31 10                	xor    %edx,(%eax)
   1a326:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a329:	89 81 cc 00 00 00    	mov    %eax,0xcc(%ecx)
   1a32f:	0f b6 55 e4          	movzbl 0xffffffe4(%ebp),%edx
   1a333:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1a336:	c1 e8 08             	shr    $0x8,%eax
   1a339:	0f b6 c0             	movzbl %al,%eax
   1a33c:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   1a343:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1a34a:	31 c2                	xor    %eax,%edx
   1a34c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1a34f:	c1 e8 10             	shr    $0x10,%eax
   1a352:	0f b6 c0             	movzbl %al,%eax
   1a355:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   1a35c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1a35f:	c1 e8 18             	shr    $0x18,%eax
   1a362:	0f b6 c0             	movzbl %al,%eax
   1a365:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1a36c:	89 d0                	mov    %edx,%eax
   1a36e:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   1a371:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
   1a374:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   1a377:	31 10                	xor    %edx,(%eax)
   1a379:	0f b6 55 d4          	movzbl 0xffffffd4(%ebp),%edx
   1a37d:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a380:	c1 e8 08             	shr    $0x8,%eax
   1a383:	0f b6 c0             	movzbl %al,%eax
   1a386:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   1a38d:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1a394:	31 c2                	xor    %eax,%edx
   1a396:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a399:	c1 e8 10             	shr    $0x10,%eax
   1a39c:	0f b6 c0             	movzbl %al,%eax
   1a39f:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   1a3a6:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a3a9:	c1 e8 18             	shr    $0x18,%eax
   1a3ac:	0f b6 c0             	movzbl %al,%eax
   1a3af:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1a3b6:	89 d0                	mov    %edx,%eax
   1a3b8:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   1a3bb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1a3be:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a3c1:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
   1a3c7:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   1a3ca:	31 10                	xor    %edx,(%eax)
   1a3cc:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a3cf:	89 81 d0 00 00 00    	mov    %eax,0xd0(%ecx)
   1a3d5:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   1a3d8:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   1a3db:	31 10                	xor    %edx,(%eax)
   1a3dd:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1a3e0:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a3e3:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
   1a3e9:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   1a3ec:	31 10                	xor    %edx,(%eax)
   1a3ee:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a3f1:	89 81 d4 00 00 00    	mov    %eax,0xd4(%ecx)
   1a3f7:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   1a3fa:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   1a3fd:	31 10                	xor    %edx,(%eax)
   1a3ff:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1a402:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a405:	8b 90 b8 00 00 00    	mov    0xb8(%eax),%edx
   1a40b:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   1a40e:	31 10                	xor    %edx,(%eax)
   1a410:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a413:	89 81 d8 00 00 00    	mov    %eax,0xd8(%ecx)
   1a419:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   1a41c:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   1a41f:	31 10                	xor    %edx,(%eax)
   1a421:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1a424:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a427:	8b 90 bc 00 00 00    	mov    0xbc(%eax),%edx
   1a42d:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   1a430:	31 10                	xor    %edx,(%eax)
   1a432:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1a435:	89 81 dc 00 00 00    	mov    %eax,0xdc(%ecx)
   1a43b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1a43e:	c1 e8 08             	shr    $0x8,%eax
   1a441:	0f b6 d0             	movzbl %al,%edx
   1a444:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1a447:	c1 e8 10             	shr    $0x10,%eax
   1a44a:	0f b6 c0             	movzbl %al,%eax
   1a44d:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   1a454:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
   1a45b:	31 c2                	xor    %eax,%edx
   1a45d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1a460:	c1 e8 18             	shr    $0x18,%eax
   1a463:	0f b6 c0             	movzbl %al,%eax
   1a466:	33 14 85 00 08 00 00 	xor    0x800(,%eax,4),%edx
   1a46d:	0f b6 45 f4          	movzbl 0xfffffff4(%ebp),%eax
   1a471:	33 14 85 00 0c 00 00 	xor    0xc00(,%eax,4),%edx
   1a478:	89 d0                	mov    %edx,%eax
   1a47a:	89 c2                	mov    %eax,%edx
   1a47c:	33 15 18 00 00 00    	xor    0x18,%edx
   1a482:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   1a485:	31 10                	xor    %edx,(%eax)
   1a487:	8b 55 0c             	mov    0xc(%ebp),%edx
   1a48a:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   1a48d:	89 82 e0 00 00 00    	mov    %eax,0xe0(%edx)
   1a493:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   1a496:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   1a499:	31 10                	xor    %edx,(%eax)
   1a49b:	8b 55 0c             	mov    0xc(%ebp),%edx
   1a49e:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   1a4a1:	89 82 e4 00 00 00    	mov    %eax,0xe4(%edx)
   1a4a7:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   1a4aa:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   1a4ad:	31 10                	xor    %edx,(%eax)
   1a4af:	8b 55 0c             	mov    0xc(%ebp),%edx
   1a4b2:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   1a4b5:	89 82 e8 00 00 00    	mov    %eax,0xe8(%edx)
   1a4bb:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   1a4be:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   1a4c1:	31 10                	xor    %edx,(%eax)
   1a4c3:	8b 55 0c             	mov    0xc(%ebp),%edx
   1a4c6:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1a4c9:	89 82 ec 00 00 00    	mov    %eax,0xec(%edx)
   1a4cf:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a4d2:	c7 80 f0 00 00 00 0e 	movl   $0xe,0xf0(%eax)
   1a4d9:	00 00 00 
   1a4dc:	b8 00 00 00 00       	mov    $0x0,%eax
   1a4e1:	83 c4 34             	add    $0x34,%esp
   1a4e4:	5b                   	pop    %ebx
   1a4e5:	c9                   	leave  
   1a4e6:	c3                   	ret    

0001a4e7 <aes_decrypt_key>:
   1a4e7:	55                   	push   %ebp
   1a4e8:	89 e5                	mov    %esp,%ebp
   1a4ea:	83 ec 08             	sub    $0x8,%esp
   1a4ed:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a4f0:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   1a4f3:	83 7d f8 20          	cmpl   $0x20,0xfffffff8(%ebp)
   1a4f7:	74 68                	je     1a561 <aes_decrypt_key+0x7a>
   1a4f9:	83 7d f8 20          	cmpl   $0x20,0xfffffff8(%ebp)
   1a4fd:	7f 0e                	jg     1a50d <aes_decrypt_key+0x26>
   1a4ff:	83 7d f8 10          	cmpl   $0x10,0xfffffff8(%ebp)
   1a503:	74 30                	je     1a535 <aes_decrypt_key+0x4e>
   1a505:	83 7d f8 18          	cmpl   $0x18,0xfffffff8(%ebp)
   1a509:	74 40                	je     1a54b <aes_decrypt_key+0x64>
   1a50b:	eb 6a                	jmp    1a577 <aes_decrypt_key+0x90>
   1a50d:	81 7d f8 c0 00 00 00 	cmpl   $0xc0,0xfffffff8(%ebp)
   1a514:	74 35                	je     1a54b <aes_decrypt_key+0x64>
   1a516:	81 7d f8 c0 00 00 00 	cmpl   $0xc0,0xfffffff8(%ebp)
   1a51d:	7f 0b                	jg     1a52a <aes_decrypt_key+0x43>
   1a51f:	81 7d f8 80 00 00 00 	cmpl   $0x80,0xfffffff8(%ebp)
   1a526:	74 0d                	je     1a535 <aes_decrypt_key+0x4e>
   1a528:	eb 4d                	jmp    1a577 <aes_decrypt_key+0x90>
   1a52a:	81 7d f8 00 01 00 00 	cmpl   $0x100,0xfffffff8(%ebp)
   1a531:	74 2e                	je     1a561 <aes_decrypt_key+0x7a>
   1a533:	eb 42                	jmp    1a577 <aes_decrypt_key+0x90>
   1a535:	83 ec 08             	sub    $0x8,%esp
   1a538:	ff 75 10             	pushl  0x10(%ebp)
   1a53b:	ff 75 08             	pushl  0x8(%ebp)
   1a53e:	e8 fc ff ff ff       	call   1a53f <aes_decrypt_key+0x58>
   1a543:	83 c4 10             	add    $0x10,%esp
   1a546:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   1a549:	eb 33                	jmp    1a57e <aes_decrypt_key+0x97>
   1a54b:	83 ec 08             	sub    $0x8,%esp
   1a54e:	ff 75 10             	pushl  0x10(%ebp)
   1a551:	ff 75 08             	pushl  0x8(%ebp)
   1a554:	e8 fc ff ff ff       	call   1a555 <aes_decrypt_key+0x6e>
   1a559:	83 c4 10             	add    $0x10,%esp
   1a55c:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   1a55f:	eb 1d                	jmp    1a57e <aes_decrypt_key+0x97>
   1a561:	83 ec 08             	sub    $0x8,%esp
   1a564:	ff 75 10             	pushl  0x10(%ebp)
   1a567:	ff 75 08             	pushl  0x8(%ebp)
   1a56a:	e8 fc ff ff ff       	call   1a56b <aes_decrypt_key+0x84>
   1a56f:	83 c4 10             	add    $0x10,%esp
   1a572:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   1a575:	eb 07                	jmp    1a57e <aes_decrypt_key+0x97>
   1a577:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,0xfffffffc(%ebp)
   1a57e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1a581:	c9                   	leave  
   1a582:	c3                   	ret    
   1a583:	90                   	nop    

0001a584 <gen_tabs>:
   1a584:	55                   	push   %ebp
   1a585:	89 e5                	mov    %esp,%ebp
   1a587:	c9                   	leave  
   1a588:	c3                   	ret    
   1a589:	90                   	nop    
   1a58a:	90                   	nop    
   1a58b:	90                   	nop    

0001a58c <MD5>:
   1a58c:	55                   	push   %ebp
   1a58d:	89 e5                	mov    %esp,%ebp
   1a58f:	83 ec 68             	sub    $0x68,%esp
   1a592:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1a596:	75 07                	jne    1a59f <MD5+0x13>
   1a598:	c7 45 10 40 97 13 00 	movl   $0x139740,0x10(%ebp)
   1a59f:	83 ec 0c             	sub    $0xc,%esp
   1a5a2:	8d 45 98             	lea    0xffffff98(%ebp),%eax
   1a5a5:	50                   	push   %eax
   1a5a6:	e8 fc ff ff ff       	call   1a5a7 <MD5+0x1b>
   1a5ab:	83 c4 10             	add    $0x10,%esp
   1a5ae:	83 ec 04             	sub    $0x4,%esp
   1a5b1:	ff 75 0c             	pushl  0xc(%ebp)
   1a5b4:	ff 75 08             	pushl  0x8(%ebp)
   1a5b7:	8d 45 98             	lea    0xffffff98(%ebp),%eax
   1a5ba:	50                   	push   %eax
   1a5bb:	e8 fc ff ff ff       	call   1a5bc <MD5+0x30>
   1a5c0:	83 c4 10             	add    $0x10,%esp
   1a5c3:	83 ec 08             	sub    $0x8,%esp
   1a5c6:	8d 45 98             	lea    0xffffff98(%ebp),%eax
   1a5c9:	50                   	push   %eax
   1a5ca:	ff 75 10             	pushl  0x10(%ebp)
   1a5cd:	e8 fc ff ff ff       	call   1a5ce <MD5+0x42>
   1a5d2:	83 c4 10             	add    $0x10,%esp
   1a5d5:	83 ec 08             	sub    $0x8,%esp
   1a5d8:	6a 5c                	push   $0x5c
   1a5da:	8d 45 98             	lea    0xffffff98(%ebp),%eax
   1a5dd:	50                   	push   %eax
   1a5de:	e8 08 00 00 00       	call   1a5eb <OPENSSL_cleanse>
   1a5e3:	83 c4 10             	add    $0x10,%esp
   1a5e6:	8b 45 10             	mov    0x10(%ebp),%eax
   1a5e9:	c9                   	leave  
   1a5ea:	c3                   	ret    

0001a5eb <OPENSSL_cleanse>:
   1a5eb:	55                   	push   %ebp
   1a5ec:	89 e5                	mov    %esp,%ebp
   1a5ee:	83 ec 04             	sub    $0x4,%esp
   1a5f1:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   1a5f8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1a5fb:	3b 45 0c             	cmp    0xc(%ebp),%eax
   1a5fe:	7c 02                	jl     1a602 <OPENSSL_cleanse+0x17>
   1a600:	eb 10                	jmp    1a612 <OPENSSL_cleanse+0x27>
   1a602:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1a605:	03 45 08             	add    0x8(%ebp),%eax
   1a608:	c6 00 00             	movb   $0x0,(%eax)
   1a60b:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
   1a60e:	ff 00                	incl   (%eax)
   1a610:	eb e6                	jmp    1a5f8 <OPENSSL_cleanse+0xd>
   1a612:	c9                   	leave  
   1a613:	c3                   	ret    
   1a614:	90                   	nop    
   1a615:	90                   	nop    
   1a616:	90                   	nop    
   1a617:	90                   	nop    
   1a618:	90                   	nop    
   1a619:	90                   	nop    
   1a61a:	90                   	nop    
   1a61b:	90                   	nop    
   1a61c:	90                   	nop    
   1a61d:	90                   	nop    
   1a61e:	90                   	nop    
   1a61f:	90                   	nop    

0001a620 <MD5_Update>:
 * Time for some action:-)
 */

void HASH_UPDATE (HASH_CTX *c, const void *data_, unsigned long len)
	{
   1a620:	55                   	push   %ebp
   1a621:	89 e5                	mov    %esp,%ebp
   1a623:	57                   	push   %edi
   1a624:	56                   	push   %esi
   1a625:	53                   	push   %ebx
   1a626:	83 ec 14             	sub    $0x14,%esp
   1a629:	8b 75 10             	mov    0x10(%ebp),%esi
	const unsigned char *data=data_;
   1a62c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	register HASH_LONG * p;
	register unsigned long l;
	int sw,sc,ew,ec;

	if (len==0) return;
   1a62f:	85 f6                	test   %esi,%esi
   1a631:	0f 84 74 01 00 00    	je     1a7ab <MD5_Update+0x18b>

	l=(c->Nl+(len<<3))&0xffffffffL;
   1a637:	8b 55 08             	mov    0x8(%ebp),%edx
   1a63a:	8b 42 10             	mov    0x10(%edx),%eax
   1a63d:	8d 14 f0             	lea    (%eax,%esi,8),%edx
	/* 95-05-24 eay Fixed a bug with the overflow handling, thanks to
	 * Wei Dai <weidai@eskimo.com> for pointing it out. */
	if (l < c->Nl) /* overflow */
   1a640:	39 c2                	cmp    %eax,%edx
   1a642:	73 06                	jae    1a64a <MD5_Update+0x2a>
		c->Nh++;
   1a644:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1a647:	ff 41 14             	incl   0x14(%ecx)
	c->Nh+=(len>>29);
   1a64a:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1a64d:	89 f0                	mov    %esi,%eax
   1a64f:	c1 e8 1d             	shr    $0x1d,%eax
   1a652:	01 41 14             	add    %eax,0x14(%ecx)
	c->Nl=l;

	if (c->num != 0)
   1a655:	8b 41 58             	mov    0x58(%ecx),%eax
   1a658:	89 51 10             	mov    %edx,0x10(%ecx)
   1a65b:	85 c0                	test   %eax,%eax
   1a65d:	0f 84 b6 00 00 00    	je     1a719 <MD5_Update+0xf9>
		{
		p=c->data;
   1a663:	83 c1 18             	add    $0x18,%ecx
		sw=c->num>>2;
   1a666:	89 c7                	mov    %eax,%edi
		sc=c->num&0x03;

		if ((c->num+len) >= HASH_CBLOCK)
   1a668:	8d 14 06             	lea    (%esi,%eax,1),%edx
   1a66b:	89 4d f0             	mov    %ecx,0xfffffff0(%ebp)
   1a66e:	89 c1                	mov    %eax,%ecx
   1a670:	c1 ff 02             	sar    $0x2,%edi
   1a673:	83 e1 03             	and    $0x3,%ecx
   1a676:	83 fa 3f             	cmp    $0x3f,%edx
   1a679:	0f 86 84 01 00 00    	jbe    1a803 <MD5_Update+0x1e3>
			{
			l=p[sw]; HOST_p_c2l(data,l,sc); p[sw++]=l;
   1a67f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1a682:	83 f9 01             	cmp    $0x1,%ecx
   1a685:	8b 14 b8             	mov    (%eax,%edi,4),%edx
   1a688:	0f 84 6a 01 00 00    	je     1a7f8 <MD5_Update+0x1d8>
   1a68e:	83 f9 01             	cmp    $0x1,%ecx
   1a691:	0f 8e 55 01 00 00    	jle    1a7ec <MD5_Update+0x1cc>
   1a697:	83 f9 02             	cmp    $0x2,%ecx
   1a69a:	0f 84 41 01 00 00    	je     1a7e1 <MD5_Update+0x1c1>
   1a6a0:	83 f9 03             	cmp    $0x3,%ecx
   1a6a3:	0f 84 2a 01 00 00    	je     1a7d3 <MD5_Update+0x1b3>
   1a6a9:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
   1a6ac:	89 14 b9             	mov    %edx,(%ecx,%edi,4)
   1a6af:	47                   	inc    %edi
			for (; sw<HASH_LBLOCK; sw++)
   1a6b0:	83 ff 0f             	cmp    $0xf,%edi
   1a6b3:	7f 36                	jg     1a6eb <MD5_Update+0xcb>
   1a6b5:	8d 74 26 00          	lea    0x0(%esi,1),%esi
   1a6b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
				{
				HOST_c2l(data,l); p[sw]=l;
   1a6c0:	0f b6 13             	movzbl (%ebx),%edx
   1a6c3:	43                   	inc    %ebx
   1a6c4:	0f b6 03             	movzbl (%ebx),%eax
   1a6c7:	43                   	inc    %ebx
   1a6c8:	c1 e0 08             	shl    $0x8,%eax
   1a6cb:	09 c2                	or     %eax,%edx
   1a6cd:	0f b6 03             	movzbl (%ebx),%eax
   1a6d0:	43                   	inc    %ebx
   1a6d1:	c1 e0 10             	shl    $0x10,%eax
   1a6d4:	09 c2                	or     %eax,%edx
   1a6d6:	0f b6 03             	movzbl (%ebx),%eax
   1a6d9:	43                   	inc    %ebx
   1a6da:	c1 e0 18             	shl    $0x18,%eax
   1a6dd:	09 c2                	or     %eax,%edx
   1a6df:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1a6e2:	89 14 b8             	mov    %edx,(%eax,%edi,4)
   1a6e5:	47                   	inc    %edi
   1a6e6:	83 ff 0f             	cmp    $0xf,%edi
   1a6e9:	7e d5                	jle    1a6c0 <MD5_Update+0xa0>
				}
			HASH_BLOCK_HOST_ORDER (c,p,1);
   1a6eb:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp,1)
   1a6f2:	00 
   1a6f3:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   1a6f6:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1a6f9:	89 54 24 04          	mov    %edx,0x4(%esp,1)
   1a6fd:	89 0c 24             	mov    %ecx,(%esp,1)
   1a700:	e8 fc ff ff ff       	call   1a701 <MD5_Update+0xe1>
			len-=(HASH_CBLOCK-c->num);
   1a705:	8b 55 08             	mov    0x8(%ebp),%edx
   1a708:	89 f0                	mov    %esi,%eax
   1a70a:	8b 7a 58             	mov    0x58(%edx),%edi
			c->num=0;
   1a70d:	c7 42 58 00 00 00 00 	movl   $0x0,0x58(%edx)
   1a714:	01 f8                	add    %edi,%eax
   1a716:	8d 70 c0             	lea    0xffffffc0(%eax),%esi
			/* drop through and do the rest */
			}
		else
			{
			c->num+=len;
			if ((sc+len) < 4) /* ugly, add char's to a word */
				{
				l=p[sw]; HOST_p_c2l_p(data,l,sc,len); p[sw]=l;
				}
			else
				{
				ew=(c->num>>2);
				ec=(c->num&0x03);
				l=p[sw]; HOST_p_c2l(data,l,sc); p[sw++]=l;
				for (; sw < ew; sw++)
					{
					HOST_c2l(data,l); p[sw]=l;
					}
				if (ec)
					{
					HOST_c2l_p(data,l,ec); p[sw]=l;
					}
				}
			return;
			}
		}

	sw=len/HASH_CBLOCK;
   1a719:	89 f7                	mov    %esi,%edi
   1a71b:	c1 ef 06             	shr    $0x6,%edi
	if (sw > 0)
   1a71e:	85 ff                	test   %edi,%edi
   1a720:	7e 1a                	jle    1a73c <MD5_Update+0x11c>
		{
#if defined(HASH_BLOCK_DATA_ORDER_ALIGNED)
		/*
		 * Note that HASH_BLOCK_DATA_ORDER_ALIGNED gets defined
		 * only if sizeof(HASH_LONG)==4.
		 */
		if ((((unsigned long)data)%4) == 0)
			{
			/* data is properly aligned so that we can cast it: */
			HASH_BLOCK_DATA_ORDER_ALIGNED (c,(HASH_LONG *)data,sw);
			sw*=HASH_CBLOCK;
			data+=sw;
			len-=sw;
			}
		else
#if !defined(HASH_BLOCK_DATA_ORDER)
			while (sw--)
				{
				memcpy (p=c->data,data,HASH_CBLOCK);
				HASH_BLOCK_DATA_ORDER_ALIGNED(c,p,1);
				data+=HASH_CBLOCK;
				len-=HASH_CBLOCK;
				}
#endif
#endif
#if defined(HASH_BLOCK_DATA_ORDER)
			{
			HASH_BLOCK_DATA_ORDER(c,data,sw);
   1a722:	89 7c 24 08          	mov    %edi,0x8(%esp,1)
   1a726:	8b 45 08             	mov    0x8(%ebp),%eax
			sw*=HASH_CBLOCK;
   1a729:	c1 e7 06             	shl    $0x6,%edi
   1a72c:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
			data+=sw;
			len-=sw;
   1a730:	29 fe                	sub    %edi,%esi
   1a732:	89 04 24             	mov    %eax,(%esp,1)
   1a735:	01 fb                	add    %edi,%ebx
   1a737:	e8 fc ff ff ff       	call   1a738 <MD5_Update+0x118>
			}
#endif
		}

	if (len!=0)
   1a73c:	85 f6                	test   %esi,%esi
   1a73e:	74 6b                	je     1a7ab <MD5_Update+0x18b>
		{
		p = c->data;
   1a740:	8b 55 08             	mov    0x8(%ebp),%edx
		c->num = len;
		ew=len>>2;	/* words to copy */
		ec=len&0x03;
   1a743:	89 f0                	mov    %esi,%eax
   1a745:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1a748:	83 e0 03             	and    $0x3,%eax
   1a74b:	83 c2 18             	add    $0x18,%edx
   1a74e:	89 55 f0             	mov    %edx,0xfffffff0(%ebp)
   1a751:	89 71 58             	mov    %esi,0x58(%ecx)
		for (; ew; ew--,p++)
   1a754:	c1 ee 02             	shr    $0x2,%esi
   1a757:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1a75a:	74 31                	je     1a78d <MD5_Update+0x16d>
   1a75c:	8d 74 26 00          	lea    0x0(%esi,1),%esi
			{
			HOST_c2l(data,l); *p=l;
   1a760:	0f b6 13             	movzbl (%ebx),%edx
   1a763:	43                   	inc    %ebx
   1a764:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
   1a767:	0f b6 03             	movzbl (%ebx),%eax
   1a76a:	43                   	inc    %ebx
   1a76b:	c1 e0 08             	shl    $0x8,%eax
   1a76e:	09 c2                	or     %eax,%edx
   1a770:	0f b6 03             	movzbl (%ebx),%eax
   1a773:	43                   	inc    %ebx
   1a774:	c1 e0 10             	shl    $0x10,%eax
   1a777:	09 c2                	or     %eax,%edx
   1a779:	0f b6 03             	movzbl (%ebx),%eax
   1a77c:	43                   	inc    %ebx
   1a77d:	c1 e0 18             	shl    $0x18,%eax
   1a780:	09 c2                	or     %eax,%edx
   1a782:	89 11                	mov    %edx,(%ecx)
   1a784:	83 c1 04             	add    $0x4,%ecx
   1a787:	4e                   	dec    %esi
   1a788:	89 4d f0             	mov    %ecx,0xfffffff0(%ebp)
   1a78b:	75 d3                	jne    1a760 <MD5_Update+0x140>
			}
		HOST_c2l_p(data,l,ec);
   1a78d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1a790:	31 d2                	xor    %edx,%edx
   1a792:	01 c3                	add    %eax,%ebx
   1a794:	83 7d ec 02          	cmpl   $0x2,0xffffffec(%ebp)
   1a798:	74 2e                	je     1a7c8 <MD5_Update+0x1a8>
   1a79a:	83 7d ec 02          	cmpl   $0x2,0xffffffec(%ebp)
   1a79e:	7f 1b                	jg     1a7bb <MD5_Update+0x19b>
   1a7a0:	83 7d ec 01          	cmpl   $0x1,0xffffffec(%ebp)
   1a7a4:	74 0d                	je     1a7b3 <MD5_Update+0x193>
		*p=l;
   1a7a6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1a7a9:	89 10                	mov    %edx,(%eax)
		}
	}
   1a7ab:	83 c4 14             	add    $0x14,%esp
   1a7ae:	5b                   	pop    %ebx
   1a7af:	5e                   	pop    %esi
   1a7b0:	5f                   	pop    %edi
   1a7b1:	5d                   	pop    %ebp
   1a7b2:	c3                   	ret    
   1a7b3:	0f b6 43 ff          	movzbl 0xffffffff(%ebx),%eax
   1a7b7:	09 c2                	or     %eax,%edx
   1a7b9:	eb eb                	jmp    1a7a6 <MD5_Update+0x186>
   1a7bb:	83 7d ec 03          	cmpl   $0x3,0xffffffec(%ebp)
   1a7bf:	75 e5                	jne    1a7a6 <MD5_Update+0x186>
   1a7c1:	4b                   	dec    %ebx
   1a7c2:	0f b6 13             	movzbl (%ebx),%edx
   1a7c5:	c1 e2 10             	shl    $0x10,%edx
   1a7c8:	4b                   	dec    %ebx
   1a7c9:	0f b6 03             	movzbl (%ebx),%eax
   1a7cc:	c1 e0 08             	shl    $0x8,%eax
   1a7cf:	09 c2                	or     %eax,%edx
   1a7d1:	eb e0                	jmp    1a7b3 <MD5_Update+0x193>
   1a7d3:	0f b6 03             	movzbl (%ebx),%eax
   1a7d6:	43                   	inc    %ebx
   1a7d7:	c1 e0 18             	shl    $0x18,%eax
   1a7da:	09 c2                	or     %eax,%edx
   1a7dc:	e9 c8 fe ff ff       	jmp    1a6a9 <MD5_Update+0x89>
   1a7e1:	0f b6 03             	movzbl (%ebx),%eax
   1a7e4:	43                   	inc    %ebx
   1a7e5:	c1 e0 10             	shl    $0x10,%eax
   1a7e8:	09 c2                	or     %eax,%edx
   1a7ea:	eb e7                	jmp    1a7d3 <MD5_Update+0x1b3>
   1a7ec:	85 c9                	test   %ecx,%ecx
   1a7ee:	0f 85 b5 fe ff ff    	jne    1a6a9 <MD5_Update+0x89>
   1a7f4:	0f b6 13             	movzbl (%ebx),%edx
   1a7f7:	43                   	inc    %ebx
   1a7f8:	0f b6 03             	movzbl (%ebx),%eax
   1a7fb:	43                   	inc    %ebx
   1a7fc:	c1 e0 08             	shl    $0x8,%eax
   1a7ff:	09 c2                	or     %eax,%edx
   1a801:	eb de                	jmp    1a7e1 <MD5_Update+0x1c1>
   1a803:	8b 45 08             	mov    0x8(%ebp),%eax
   1a806:	89 50 58             	mov    %edx,0x58(%eax)
   1a809:	8d 04 0e             	lea    (%esi,%ecx,1),%eax
   1a80c:	83 f8 03             	cmp    $0x3,%eax
   1a80f:	77 43                	ja     1a854 <MD5_Update+0x234>
   1a811:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1a814:	83 f9 01             	cmp    $0x1,%ecx
   1a817:	8b 14 b8             	mov    (%eax,%edi,4),%edx
   1a81a:	74 2a                	je     1a846 <MD5_Update+0x226>
   1a81c:	83 f9 01             	cmp    $0x1,%ecx
   1a81f:	7e 1a                	jle    1a83b <MD5_Update+0x21b>
   1a821:	83 f9 02             	cmp    $0x2,%ecx
   1a824:	74 0b                	je     1a831 <MD5_Update+0x211>
   1a826:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
   1a829:	89 14 b9             	mov    %edx,(%ecx,%edi,4)
   1a82c:	e9 7a ff ff ff       	jmp    1a7ab <MD5_Update+0x18b>
   1a831:	0f b6 03             	movzbl (%ebx),%eax
   1a834:	c1 e0 10             	shl    $0x10,%eax
   1a837:	09 c2                	or     %eax,%edx
   1a839:	eb eb                	jmp    1a826 <MD5_Update+0x206>
   1a83b:	85 c9                	test   %ecx,%ecx
   1a83d:	75 e7                	jne    1a826 <MD5_Update+0x206>
   1a83f:	0f b6 13             	movzbl (%ebx),%edx
   1a842:	43                   	inc    %ebx
   1a843:	4e                   	dec    %esi
   1a844:	74 e0                	je     1a826 <MD5_Update+0x206>
   1a846:	0f b6 03             	movzbl (%ebx),%eax
   1a849:	43                   	inc    %ebx
   1a84a:	c1 e0 08             	shl    $0x8,%eax
   1a84d:	09 c2                	or     %eax,%edx
   1a84f:	4e                   	dec    %esi
   1a850:	74 d4                	je     1a826 <MD5_Update+0x206>
   1a852:	eb dd                	jmp    1a831 <MD5_Update+0x211>
   1a854:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1a857:	89 d6                	mov    %edx,%esi
   1a859:	83 e2 03             	and    $0x3,%edx
   1a85c:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
   1a85f:	c1 fe 02             	sar    $0x2,%esi
   1a862:	83 f9 01             	cmp    $0x1,%ecx
   1a865:	8b 14 b8             	mov    (%eax,%edi,4),%edx
   1a868:	0f 84 ce 00 00 00    	je     1a93c <MD5_Update+0x31c>
   1a86e:	83 f9 01             	cmp    $0x1,%ecx
   1a871:	0f 8e b9 00 00 00    	jle    1a930 <MD5_Update+0x310>
   1a877:	83 f9 02             	cmp    $0x2,%ecx
   1a87a:	0f 84 a5 00 00 00    	je     1a925 <MD5_Update+0x305>
   1a880:	83 f9 03             	cmp    $0x3,%ecx
   1a883:	0f 84 8e 00 00 00    	je     1a917 <MD5_Update+0x2f7>
   1a889:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
   1a88c:	89 14 b9             	mov    %edx,(%ecx,%edi,4)
   1a88f:	47                   	inc    %edi
   1a890:	39 f7                	cmp    %esi,%edi
   1a892:	7d 36                	jge    1a8ca <MD5_Update+0x2aa>
   1a894:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   1a89a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
   1a8a0:	0f b6 13             	movzbl (%ebx),%edx
   1a8a3:	43                   	inc    %ebx
   1a8a4:	0f b6 03             	movzbl (%ebx),%eax
   1a8a7:	43                   	inc    %ebx
   1a8a8:	c1 e0 08             	shl    $0x8,%eax
   1a8ab:	09 c2                	or     %eax,%edx
   1a8ad:	0f b6 03             	movzbl (%ebx),%eax
   1a8b0:	43                   	inc    %ebx
   1a8b1:	c1 e0 10             	shl    $0x10,%eax
   1a8b4:	09 c2                	or     %eax,%edx
   1a8b6:	0f b6 03             	movzbl (%ebx),%eax
   1a8b9:	43                   	inc    %ebx
   1a8ba:	c1 e0 18             	shl    $0x18,%eax
   1a8bd:	09 c2                	or     %eax,%edx
   1a8bf:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1a8c2:	89 14 b8             	mov    %edx,(%eax,%edi,4)
   1a8c5:	47                   	inc    %edi
   1a8c6:	39 f7                	cmp    %esi,%edi
   1a8c8:	7c d6                	jl     1a8a0 <MD5_Update+0x280>
   1a8ca:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
   1a8cd:	85 f6                	test   %esi,%esi
   1a8cf:	0f 84 d6 fe ff ff    	je     1a7ab <MD5_Update+0x18b>
   1a8d5:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
   1a8d8:	31 d2                	xor    %edx,%edx
   1a8da:	01 cb                	add    %ecx,%ebx
   1a8dc:	83 7d ec 02          	cmpl   $0x2,0xffffffec(%ebp)
   1a8e0:	74 2a                	je     1a90c <MD5_Update+0x2ec>
   1a8e2:	83 7d ec 02          	cmpl   $0x2,0xffffffec(%ebp)
   1a8e6:	7f 13                	jg     1a8fb <MD5_Update+0x2db>
   1a8e8:	83 7d ec 01          	cmpl   $0x1,0xffffffec(%ebp)
   1a8ec:	0f 85 34 ff ff ff    	jne    1a826 <MD5_Update+0x206>
   1a8f2:	0f b6 43 ff          	movzbl 0xffffffff(%ebx),%eax
   1a8f6:	e9 3c ff ff ff       	jmp    1a837 <MD5_Update+0x217>
   1a8fb:	83 7d ec 03          	cmpl   $0x3,0xffffffec(%ebp)
   1a8ff:	0f 85 21 ff ff ff    	jne    1a826 <MD5_Update+0x206>
   1a905:	4b                   	dec    %ebx
   1a906:	0f b6 13             	movzbl (%ebx),%edx
   1a909:	c1 e2 10             	shl    $0x10,%edx
   1a90c:	4b                   	dec    %ebx
   1a90d:	0f b6 03             	movzbl (%ebx),%eax
   1a910:	c1 e0 08             	shl    $0x8,%eax
   1a913:	09 c2                	or     %eax,%edx
   1a915:	eb db                	jmp    1a8f2 <MD5_Update+0x2d2>
   1a917:	0f b6 03             	movzbl (%ebx),%eax
   1a91a:	43                   	inc    %ebx
   1a91b:	c1 e0 18             	shl    $0x18,%eax
   1a91e:	09 c2                	or     %eax,%edx
   1a920:	e9 64 ff ff ff       	jmp    1a889 <MD5_Update+0x269>
   1a925:	0f b6 03             	movzbl (%ebx),%eax
   1a928:	43                   	inc    %ebx
   1a929:	c1 e0 10             	shl    $0x10,%eax
   1a92c:	09 c2                	or     %eax,%edx
   1a92e:	eb e7                	jmp    1a917 <MD5_Update+0x2f7>
   1a930:	85 c9                	test   %ecx,%ecx
   1a932:	0f 85 51 ff ff ff    	jne    1a889 <MD5_Update+0x269>
   1a938:	0f b6 13             	movzbl (%ebx),%edx
   1a93b:	43                   	inc    %ebx
   1a93c:	0f b6 03             	movzbl (%ebx),%eax
   1a93f:	43                   	inc    %ebx
   1a940:	c1 e0 08             	shl    $0x8,%eax
   1a943:	09 c2                	or     %eax,%edx
   1a945:	eb de                	jmp    1a925 <MD5_Update+0x305>
   1a947:	89 f6                	mov    %esi,%esi
   1a949:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

0001a950 <MD5_Transform>:


void HASH_TRANSFORM (HASH_CTX *c, const unsigned char *data)
	{
   1a950:	55                   	push   %ebp
   1a951:	89 e5                	mov    %esp,%ebp
   1a953:	83 ec 0c             	sub    $0xc,%esp
#if defined(HASH_BLOCK_DATA_ORDER_ALIGNED)
	if ((((unsigned long)data)%4) == 0)
		/* data is properly aligned so that we can cast it: */
		HASH_BLOCK_DATA_ORDER_ALIGNED (c,(HASH_LONG *)data,1);
	else
#if !defined(HASH_BLOCK_DATA_ORDER)
		{
		memcpy (c->data,data,HASH_CBLOCK);
		HASH_BLOCK_DATA_ORDER_ALIGNED (c,c->data,1);
		}
#endif
#endif
#if defined(HASH_BLOCK_DATA_ORDER)
	HASH_BLOCK_DATA_ORDER (c,data,1);
   1a956:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp,1)
   1a95d:	00 
   1a95e:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a961:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1a965:	8b 45 08             	mov    0x8(%ebp),%eax
   1a968:	89 04 24             	mov    %eax,(%esp,1)
   1a96b:	e8 fc ff ff ff       	call   1a96c <MD5_Transform+0x1c>
#endif
	}
   1a970:	89 ec                	mov    %ebp,%esp
   1a972:	5d                   	pop    %ebp
   1a973:	c3                   	ret    
   1a974:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   1a97a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0001a980 <MD5_Final>:


void HASH_FINAL (unsigned char *md, HASH_CTX *c)
	{
   1a980:	55                   	push   %ebp
   1a981:	89 e5                	mov    %esp,%ebp
   1a983:	57                   	push   %edi
	register HASH_LONG *p;
	register unsigned long l;
	register int i,j;
	static const unsigned char end[4]={0x80,0x00,0x00,0x00};
	const unsigned char *cp=end;
   1a984:	bf 20 52 00 00       	mov    $0x5220,%edi
   1a989:	56                   	push   %esi
   1a98a:	53                   	push   %ebx
   1a98b:	83 ec 0c             	sub    $0xc,%esp

	/* c->num should definitly have room for at least one more byte. */
	p=c->data;
	i=c->num>>2;
   1a98e:	8b 55 0c             	mov    0xc(%ebp),%edx
   1a991:	8b 75 0c             	mov    0xc(%ebp),%esi
   1a994:	8b 5d 08             	mov    0x8(%ebp),%ebx
   1a997:	8b 42 58             	mov    0x58(%edx),%eax
   1a99a:	83 c6 18             	add    $0x18,%esi
   1a99d:	89 c2                	mov    %eax,%edx
   1a99f:	c1 fa 02             	sar    $0x2,%edx
	j=c->num&0x03;

#if 0
	/* purify often complains about the following line as an
	 * Uninitialized Memory Read.  While this can be true, the
	 * following p_c2l macro will reset l when that case is true.
	 * This is because j&0x03 contains the number of 'valid' bytes
	 * already in p[i].  If and only if j&0x03 == 0, the UMR will
	 * occur but this is also the only time p_c2l will do
	 * l= *(cp++) instead of l|= *(cp++)
	 * Many thanks to Alex Tang <altitude@cic.net> for pickup this
	 * 'potential bug' */
#ifdef PURIFY
	if (j==0) p[i]=0; /* Yeah, but that's not the way to fix it:-) */
#endif
	l=p[i];
#else
	l = (j==0) ? 0 : p[i];
   1a9a2:	83 e0 03             	and    $0x3,%eax
   1a9a5:	0f 84 3c 01 00 00    	je     1aae7 <MD5_Final+0x167>
   1a9ab:	8b 0c 96             	mov    (%esi,%edx,4),%ecx
#endif
	HOST_p_c2l(cp,l,j); p[i++]=l; /* i is the next 'undefined word' */
   1a9ae:	83 f8 01             	cmp    $0x1,%eax
   1a9b1:	0f 84 25 01 00 00    	je     1aadc <MD5_Final+0x15c>
   1a9b7:	83 f8 01             	cmp    $0x1,%eax
   1a9ba:	0f 8e 08 01 00 00    	jle    1aac8 <MD5_Final+0x148>
   1a9c0:	83 f8 02             	cmp    $0x2,%eax
   1a9c3:	0f 84 f4 00 00 00    	je     1aabd <MD5_Final+0x13d>
   1a9c9:	83 f8 03             	cmp    $0x3,%eax
   1a9cc:	0f 84 de 00 00 00    	je     1aab0 <MD5_Final+0x130>
   1a9d2:	89 0c 96             	mov    %ecx,(%esi,%edx,4)
   1a9d5:	42                   	inc    %edx

	if (i>(HASH_LBLOCK-2)) /* save room for Nl and Nh */
   1a9d6:	83 fa 0e             	cmp    $0xe,%edx
   1a9d9:	7e 25                	jle    1aa00 <MD5_Final+0x80>
		{
		if (i<HASH_LBLOCK) p[i]=0;
   1a9db:	83 fa 0f             	cmp    $0xf,%edx
   1a9de:	7f 07                	jg     1a9e7 <MD5_Final+0x67>
   1a9e0:	c7 04 96 00 00 00 00 	movl   $0x0,(%esi,%edx,4)
		HASH_BLOCK_HOST_ORDER (c,p,1);
   1a9e7:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp,1)
   1a9ee:	00 
   1a9ef:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a9f2:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   1a9f6:	89 04 24             	mov    %eax,(%esp,1)
   1a9f9:	e8 fc ff ff ff       	call   1a9fa <MD5_Final+0x7a>
		i=0;
   1a9fe:	31 d2                	xor    %edx,%edx
		}
	for (; i<(HASH_LBLOCK-2); i++)
   1aa00:	83 fa 0d             	cmp    $0xd,%edx
   1aa03:	7f 18                	jg     1aa1d <MD5_Final+0x9d>
   1aa05:	8d 74 26 00          	lea    0x0(%esi,1),%esi
   1aa09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
		p[i]=0;
   1aa10:	c7 04 96 00 00 00 00 	movl   $0x0,(%esi,%edx,4)
   1aa17:	42                   	inc    %edx
   1aa18:	83 fa 0d             	cmp    $0xd,%edx
   1aa1b:	7e f3                	jle    1aa10 <MD5_Final+0x90>

#if   defined(DATA_ORDER_IS_BIG_ENDIAN)
	p[HASH_LBLOCK-2]=c->Nh;
	p[HASH_LBLOCK-1]=c->Nl;
#elif defined(DATA_ORDER_IS_LITTLE_ENDIAN)
	p[HASH_LBLOCK-2]=c->Nl;
   1aa1d:	8b 55 0c             	mov    0xc(%ebp),%edx
   1aa20:	8b 42 10             	mov    0x10(%edx),%eax
   1aa23:	89 46 38             	mov    %eax,0x38(%esi)
	p[HASH_LBLOCK-1]=c->Nh;
   1aa26:	8b 42 14             	mov    0x14(%edx),%eax
   1aa29:	89 46 3c             	mov    %eax,0x3c(%esi)
#endif
	HASH_BLOCK_HOST_ORDER (c,p,1);
   1aa2c:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   1aa30:	89 14 24             	mov    %edx,(%esp,1)
   1aa33:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp,1)
   1aa3a:	00 
   1aa3b:	e8 fc ff ff ff       	call   1aa3c <MD5_Final+0xbc>

#ifndef HASH_MAKE_STRING
#error "HASH_MAKE_STRING must be defined!"
#else
	HASH_MAKE_STRING(c,md);
   1aa40:	8b 55 0c             	mov    0xc(%ebp),%edx
   1aa43:	8b 02                	mov    (%edx),%eax
   1aa45:	88 03                	mov    %al,(%ebx)
   1aa47:	43                   	inc    %ebx
   1aa48:	c1 e8 08             	shr    $0x8,%eax
   1aa4b:	88 03                	mov    %al,(%ebx)
   1aa4d:	43                   	inc    %ebx
   1aa4e:	c1 e8 08             	shr    $0x8,%eax
   1aa51:	88 03                	mov    %al,(%ebx)
   1aa53:	43                   	inc    %ebx
   1aa54:	c1 e8 08             	shr    $0x8,%eax
   1aa57:	88 03                	mov    %al,(%ebx)
   1aa59:	43                   	inc    %ebx
   1aa5a:	8b 42 04             	mov    0x4(%edx),%eax
   1aa5d:	88 03                	mov    %al,(%ebx)
   1aa5f:	43                   	inc    %ebx
   1aa60:	c1 e8 08             	shr    $0x8,%eax
   1aa63:	88 03                	mov    %al,(%ebx)
   1aa65:	43                   	inc    %ebx
   1aa66:	c1 e8 08             	shr    $0x8,%eax
   1aa69:	88 03                	mov    %al,(%ebx)
   1aa6b:	43                   	inc    %ebx
   1aa6c:	c1 e8 08             	shr    $0x8,%eax
   1aa6f:	88 03                	mov    %al,(%ebx)
   1aa71:	43                   	inc    %ebx
   1aa72:	8b 42 08             	mov    0x8(%edx),%eax
   1aa75:	88 03                	mov    %al,(%ebx)
   1aa77:	43                   	inc    %ebx
   1aa78:	c1 e8 08             	shr    $0x8,%eax
   1aa7b:	88 03                	mov    %al,(%ebx)
   1aa7d:	43                   	inc    %ebx
   1aa7e:	c1 e8 08             	shr    $0x8,%eax
   1aa81:	88 03                	mov    %al,(%ebx)
   1aa83:	43                   	inc    %ebx
   1aa84:	c1 e8 08             	shr    $0x8,%eax
   1aa87:	88 03                	mov    %al,(%ebx)
   1aa89:	43                   	inc    %ebx
   1aa8a:	8b 42 0c             	mov    0xc(%edx),%eax
   1aa8d:	88 03                	mov    %al,(%ebx)
   1aa8f:	43                   	inc    %ebx
   1aa90:	c1 e8 08             	shr    $0x8,%eax
   1aa93:	88 03                	mov    %al,(%ebx)
   1aa95:	43                   	inc    %ebx
   1aa96:	c1 e8 08             	shr    $0x8,%eax
   1aa99:	88 03                	mov    %al,(%ebx)
   1aa9b:	c1 e8 08             	shr    $0x8,%eax
   1aa9e:	88 43 01             	mov    %al,0x1(%ebx)
#endif

	c->num=0;
   1aaa1:	c7 42 58 00 00 00 00 	movl   $0x0,0x58(%edx)
	/* clear stuff, HASH_BLOCK may be leaving some stuff on the stack
	 * but I'm not worried :-)
	OPENSSL_cleanse((void *)c,sizeof(HASH_CTX));
	 */
	}
   1aaa8:	83 c4 0c             	add    $0xc,%esp
   1aaab:	5b                   	pop    %ebx
   1aaac:	5e                   	pop    %esi
   1aaad:	5f                   	pop    %edi
   1aaae:	5d                   	pop    %ebp
   1aaaf:	c3                   	ret    
   1aab0:	0f b6 07             	movzbl (%edi),%eax
   1aab3:	c1 e0 18             	shl    $0x18,%eax
   1aab6:	09 c1                	or     %eax,%ecx
   1aab8:	e9 15 ff ff ff       	jmp    1a9d2 <MD5_Final+0x52>
   1aabd:	0f b6 07             	movzbl (%edi),%eax
   1aac0:	47                   	inc    %edi
   1aac1:	c1 e0 10             	shl    $0x10,%eax
   1aac4:	09 c1                	or     %eax,%ecx
   1aac6:	eb e8                	jmp    1aab0 <MD5_Final+0x130>
   1aac8:	85 c0                	test   %eax,%eax
   1aaca:	0f 85 02 ff ff ff    	jne    1a9d2 <MD5_Final+0x52>
   1aad0:	0f b6 0d 20 52 00 00 	movzbl 0x5220,%ecx
   1aad7:	bf 21 52 00 00       	mov    $0x5221,%edi
   1aadc:	0f b6 07             	movzbl (%edi),%eax
   1aadf:	47                   	inc    %edi
   1aae0:	c1 e0 08             	shl    $0x8,%eax
   1aae3:	09 c1                	or     %eax,%ecx
   1aae5:	eb d6                	jmp    1aabd <MD5_Final+0x13d>
   1aae7:	31 c9                	xor    %ecx,%ecx
   1aae9:	e9 c0 fe ff ff       	jmp    1a9ae <MD5_Final+0x2e>
   1aaee:	89 f6                	mov    %esi,%esi

0001aaf0 <MD5_Init>:
#define INIT_DATA_C (unsigned long)0x98badcfeL
#define INIT_DATA_D (unsigned long)0x10325476L

void MD5_Init(MD5_CTX *c)
	{
   1aaf0:	55                   	push   %ebp
   1aaf1:	89 e5                	mov    %esp,%ebp
   1aaf3:	8b 45 08             	mov    0x8(%ebp),%eax
	c->A=INIT_DATA_A;
   1aaf6:	c7 00 01 23 45 67    	movl   $0x67452301,(%eax)
	c->B=INIT_DATA_B;
   1aafc:	c7 40 04 89 ab cd ef 	movl   $0xefcdab89,0x4(%eax)
	c->C=INIT_DATA_C;
   1ab03:	c7 40 08 fe dc ba 98 	movl   $0x98badcfe,0x8(%eax)
	c->D=INIT_DATA_D;
   1ab0a:	c7 40 0c 76 54 32 10 	movl   $0x10325476,0xc(%eax)
	c->Nl=0;
   1ab11:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->Nh=0;
   1ab18:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	c->num=0;
   1ab1f:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
	}
   1ab26:	5d                   	pop    %ebp
   1ab27:	c3                   	ret    
   1ab28:	90                   	nop    
   1ab29:	90                   	nop    
   1ab2a:	90                   	nop    
   1ab2b:	90                   	nop    
   1ab2c:	90                   	nop    
   1ab2d:	90                   	nop    
   1ab2e:	90                   	nop    
   1ab2f:	90                   	nop    

0001ab30 <md5_block_asm_host_order>:
   1ab30:	56                   	push   %esi
   1ab31:	57                   	push   %edi
   1ab32:	8b 7c 24 0c          	mov    0xc(%esp,1),%edi
   1ab36:	8b 74 24 10          	mov    0x10(%esp,1),%esi
   1ab3a:	8b 4c 24 14          	mov    0x14(%esp,1),%ecx
   1ab3e:	55                   	push   %ebp
   1ab3f:	c1 e1 06             	shl    $0x6,%ecx
   1ab42:	53                   	push   %ebx
   1ab43:	01 f1                	add    %esi,%ecx
   1ab45:	83 e9 40             	sub    $0x40,%ecx
   1ab48:	8b 07                	mov    (%edi),%eax
   1ab4a:	51                   	push   %ecx
   1ab4b:	8b 5f 04             	mov    0x4(%edi),%ebx
   1ab4e:	8b 4f 08             	mov    0x8(%edi),%ecx
   1ab51:	8b 57 0c             	mov    0xc(%edi),%edx
   1ab54:	89 cf                	mov    %ecx,%edi
   1ab56:	8b 2e                	mov    (%esi),%ebp
   1ab58:	31 d7                	xor    %edx,%edi
   1ab5a:	21 df                	and    %ebx,%edi
   1ab5c:	8d 84 28 78 a4 6a d7 	lea    0xd76aa478(%eax,%ebp,1),%eax
   1ab63:	31 d7                	xor    %edx,%edi
   1ab65:	01 f8                	add    %edi,%eax
   1ab67:	89 df                	mov    %ebx,%edi
   1ab69:	c1 c0 07             	rol    $0x7,%eax
   1ab6c:	8b 6e 04             	mov    0x4(%esi),%ebp
   1ab6f:	01 d8                	add    %ebx,%eax
   1ab71:	31 cf                	xor    %ecx,%edi
   1ab73:	21 c7                	and    %eax,%edi
   1ab75:	8d 94 2a 56 b7 c7 e8 	lea    0xe8c7b756(%edx,%ebp,1),%edx
   1ab7c:	31 cf                	xor    %ecx,%edi
   1ab7e:	01 fa                	add    %edi,%edx
   1ab80:	89 c7                	mov    %eax,%edi
   1ab82:	c1 c2 0c             	rol    $0xc,%edx
   1ab85:	8b 6e 08             	mov    0x8(%esi),%ebp
   1ab88:	01 c2                	add    %eax,%edx
   1ab8a:	31 df                	xor    %ebx,%edi
   1ab8c:	21 d7                	and    %edx,%edi
   1ab8e:	8d 8c 29 db 70 20 24 	lea    0x242070db(%ecx,%ebp,1),%ecx
   1ab95:	31 df                	xor    %ebx,%edi
   1ab97:	01 f9                	add    %edi,%ecx
   1ab99:	89 d7                	mov    %edx,%edi
   1ab9b:	c1 c1 11             	rol    $0x11,%ecx
   1ab9e:	8b 6e 0c             	mov    0xc(%esi),%ebp
   1aba1:	01 d1                	add    %edx,%ecx
   1aba3:	31 c7                	xor    %eax,%edi
   1aba5:	21 cf                	and    %ecx,%edi
   1aba7:	8d 9c 2b ee ce bd c1 	lea    0xc1bdceee(%ebx,%ebp,1),%ebx
   1abae:	31 c7                	xor    %eax,%edi
   1abb0:	01 fb                	add    %edi,%ebx
   1abb2:	89 cf                	mov    %ecx,%edi
   1abb4:	c1 c3 16             	rol    $0x16,%ebx
   1abb7:	8b 6e 10             	mov    0x10(%esi),%ebp
   1abba:	01 cb                	add    %ecx,%ebx
   1abbc:	31 d7                	xor    %edx,%edi
   1abbe:	21 df                	and    %ebx,%edi
   1abc0:	8d 84 28 af 0f 7c f5 	lea    0xf57c0faf(%eax,%ebp,1),%eax
   1abc7:	31 d7                	xor    %edx,%edi
   1abc9:	01 f8                	add    %edi,%eax
   1abcb:	89 df                	mov    %ebx,%edi
   1abcd:	c1 c0 07             	rol    $0x7,%eax
   1abd0:	8b 6e 14             	mov    0x14(%esi),%ebp
   1abd3:	01 d8                	add    %ebx,%eax
   1abd5:	31 cf                	xor    %ecx,%edi
   1abd7:	21 c7                	and    %eax,%edi
   1abd9:	8d 94 2a 2a c6 87 47 	lea    0x4787c62a(%edx,%ebp,1),%edx
   1abe0:	31 cf                	xor    %ecx,%edi
   1abe2:	01 fa                	add    %edi,%edx
   1abe4:	89 c7                	mov    %eax,%edi
   1abe6:	c1 c2 0c             	rol    $0xc,%edx
   1abe9:	8b 6e 18             	mov    0x18(%esi),%ebp
   1abec:	01 c2                	add    %eax,%edx
   1abee:	31 df                	xor    %ebx,%edi
   1abf0:	21 d7                	and    %edx,%edi
   1abf2:	8d 8c 29 13 46 30 a8 	lea    0xa8304613(%ecx,%ebp,1),%ecx
   1abf9:	31 df                	xor    %ebx,%edi
   1abfb:	01 f9                	add    %edi,%ecx
   1abfd:	89 d7                	mov    %edx,%edi
   1abff:	c1 c1 11             	rol    $0x11,%ecx
   1ac02:	8b 6e 1c             	mov    0x1c(%esi),%ebp
   1ac05:	01 d1                	add    %edx,%ecx
   1ac07:	31 c7                	xor    %eax,%edi
   1ac09:	21 cf                	and    %ecx,%edi
   1ac0b:	8d 9c 2b 01 95 46 fd 	lea    0xfd469501(%ebx,%ebp,1),%ebx
   1ac12:	31 c7                	xor    %eax,%edi
   1ac14:	01 fb                	add    %edi,%ebx
   1ac16:	89 cf                	mov    %ecx,%edi
   1ac18:	c1 c3 16             	rol    $0x16,%ebx
   1ac1b:	8b 6e 20             	mov    0x20(%esi),%ebp
   1ac1e:	01 cb                	add    %ecx,%ebx
   1ac20:	31 d7                	xor    %edx,%edi
   1ac22:	21 df                	and    %ebx,%edi
   1ac24:	8d 84 28 d8 98 80 69 	lea    0x698098d8(%eax,%ebp,1),%eax
   1ac2b:	31 d7                	xor    %edx,%edi
   1ac2d:	01 f8                	add    %edi,%eax
   1ac2f:	89 df                	mov    %ebx,%edi
   1ac31:	c1 c0 07             	rol    $0x7,%eax
   1ac34:	8b 6e 24             	mov    0x24(%esi),%ebp
   1ac37:	01 d8                	add    %ebx,%eax
   1ac39:	31 cf                	xor    %ecx,%edi
   1ac3b:	21 c7                	and    %eax,%edi
   1ac3d:	8d 94 2a af f7 44 8b 	lea    0x8b44f7af(%edx,%ebp,1),%edx
   1ac44:	31 cf                	xor    %ecx,%edi
   1ac46:	01 fa                	add    %edi,%edx
   1ac48:	89 c7                	mov    %eax,%edi
   1ac4a:	c1 c2 0c             	rol    $0xc,%edx
   1ac4d:	8b 6e 28             	mov    0x28(%esi),%ebp
   1ac50:	01 c2                	add    %eax,%edx
   1ac52:	31 df                	xor    %ebx,%edi
   1ac54:	21 d7                	and    %edx,%edi
   1ac56:	8d 8c 29 b1 5b ff ff 	lea    0xffff5bb1(%ecx,%ebp,1),%ecx
   1ac5d:	31 df                	xor    %ebx,%edi
   1ac5f:	01 f9                	add    %edi,%ecx
   1ac61:	89 d7                	mov    %edx,%edi
   1ac63:	c1 c1 11             	rol    $0x11,%ecx
   1ac66:	8b 6e 2c             	mov    0x2c(%esi),%ebp
   1ac69:	01 d1                	add    %edx,%ecx
   1ac6b:	31 c7                	xor    %eax,%edi
   1ac6d:	21 cf                	and    %ecx,%edi
   1ac6f:	8d 9c 2b be d7 5c 89 	lea    0x895cd7be(%ebx,%ebp,1),%ebx
   1ac76:	31 c7                	xor    %eax,%edi
   1ac78:	01 fb                	add    %edi,%ebx
   1ac7a:	89 cf                	mov    %ecx,%edi
   1ac7c:	c1 c3 16             	rol    $0x16,%ebx
   1ac7f:	8b 6e 30             	mov    0x30(%esi),%ebp
   1ac82:	01 cb                	add    %ecx,%ebx
   1ac84:	31 d7                	xor    %edx,%edi
   1ac86:	21 df                	and    %ebx,%edi
   1ac88:	8d 84 28 22 11 90 6b 	lea    0x6b901122(%eax,%ebp,1),%eax
   1ac8f:	31 d7                	xor    %edx,%edi
   1ac91:	01 f8                	add    %edi,%eax
   1ac93:	89 df                	mov    %ebx,%edi
   1ac95:	c1 c0 07             	rol    $0x7,%eax
   1ac98:	8b 6e 34             	mov    0x34(%esi),%ebp
   1ac9b:	01 d8                	add    %ebx,%eax
   1ac9d:	31 cf                	xor    %ecx,%edi
   1ac9f:	21 c7                	and    %eax,%edi
   1aca1:	8d 94 2a 93 71 98 fd 	lea    0xfd987193(%edx,%ebp,1),%edx
   1aca8:	31 cf                	xor    %ecx,%edi
   1acaa:	01 fa                	add    %edi,%edx
   1acac:	89 c7                	mov    %eax,%edi
   1acae:	c1 c2 0c             	rol    $0xc,%edx
   1acb1:	8b 6e 38             	mov    0x38(%esi),%ebp
   1acb4:	01 c2                	add    %eax,%edx
   1acb6:	31 df                	xor    %ebx,%edi
   1acb8:	21 d7                	and    %edx,%edi
   1acba:	8d 8c 29 8e 43 79 a6 	lea    0xa679438e(%ecx,%ebp,1),%ecx
   1acc1:	31 df                	xor    %ebx,%edi
   1acc3:	01 f9                	add    %edi,%ecx
   1acc5:	89 d7                	mov    %edx,%edi
   1acc7:	c1 c1 11             	rol    $0x11,%ecx
   1acca:	8b 6e 3c             	mov    0x3c(%esi),%ebp
   1accd:	01 d1                	add    %edx,%ecx
   1accf:	31 c7                	xor    %eax,%edi
   1acd1:	21 cf                	and    %ecx,%edi
   1acd3:	8d 9c 2b 21 08 b4 49 	lea    0x49b40821(%ebx,%ebp,1),%ebx
   1acda:	31 c7                	xor    %eax,%edi
   1acdc:	01 fb                	add    %edi,%ebx
   1acde:	89 cf                	mov    %ecx,%edi
   1ace0:	c1 c3 16             	rol    $0x16,%ebx
   1ace3:	8b 6e 04             	mov    0x4(%esi),%ebp
   1ace6:	01 cb                	add    %ecx,%ebx
   1ace8:	8d 84 28 62 25 1e f6 	lea    0xf61e2562(%eax,%ebp,1),%eax
   1acef:	31 df                	xor    %ebx,%edi
   1acf1:	21 d7                	and    %edx,%edi
   1acf3:	8b 6e 18             	mov    0x18(%esi),%ebp
   1acf6:	31 cf                	xor    %ecx,%edi
   1acf8:	01 f8                	add    %edi,%eax
   1acfa:	89 df                	mov    %ebx,%edi
   1acfc:	c1 c0 05             	rol    $0x5,%eax
   1acff:	01 d8                	add    %ebx,%eax
   1ad01:	8d 94 2a 40 b3 40 c0 	lea    0xc040b340(%edx,%ebp,1),%edx
   1ad08:	31 c7                	xor    %eax,%edi
   1ad0a:	21 cf                	and    %ecx,%edi
   1ad0c:	8b 6e 2c             	mov    0x2c(%esi),%ebp
   1ad0f:	31 df                	xor    %ebx,%edi
   1ad11:	01 fa                	add    %edi,%edx
   1ad13:	89 c7                	mov    %eax,%edi
   1ad15:	c1 c2 09             	rol    $0x9,%edx
   1ad18:	01 c2                	add    %eax,%edx
   1ad1a:	8d 8c 29 51 5a 5e 26 	lea    0x265e5a51(%ecx,%ebp,1),%ecx
   1ad21:	31 d7                	xor    %edx,%edi
   1ad23:	21 df                	and    %ebx,%edi
   1ad25:	8b 2e                	mov    (%esi),%ebp
   1ad27:	31 c7                	xor    %eax,%edi
   1ad29:	01 f9                	add    %edi,%ecx
   1ad2b:	89 d7                	mov    %edx,%edi
   1ad2d:	c1 c1 0e             	rol    $0xe,%ecx
   1ad30:	01 d1                	add    %edx,%ecx
   1ad32:	8d 9c 2b aa c7 b6 e9 	lea    0xe9b6c7aa(%ebx,%ebp,1),%ebx
   1ad39:	31 cf                	xor    %ecx,%edi
   1ad3b:	21 c7                	and    %eax,%edi
   1ad3d:	8b 6e 14             	mov    0x14(%esi),%ebp
   1ad40:	31 d7                	xor    %edx,%edi
   1ad42:	01 fb                	add    %edi,%ebx
   1ad44:	89 cf                	mov    %ecx,%edi
   1ad46:	c1 c3 14             	rol    $0x14,%ebx
   1ad49:	01 cb                	add    %ecx,%ebx
   1ad4b:	8d 84 28 5d 10 2f d6 	lea    0xd62f105d(%eax,%ebp,1),%eax
   1ad52:	31 df                	xor    %ebx,%edi
   1ad54:	21 d7                	and    %edx,%edi
   1ad56:	8b 6e 28             	mov    0x28(%esi),%ebp
   1ad59:	31 cf                	xor    %ecx,%edi
   1ad5b:	01 f8                	add    %edi,%eax
   1ad5d:	89 df                	mov    %ebx,%edi
   1ad5f:	c1 c0 05             	rol    $0x5,%eax
   1ad62:	01 d8                	add    %ebx,%eax
   1ad64:	8d 94 2a 53 14 44 02 	lea    0x2441453(%edx,%ebp,1),%edx
   1ad6b:	31 c7                	xor    %eax,%edi
   1ad6d:	21 cf                	and    %ecx,%edi
   1ad6f:	8b 6e 3c             	mov    0x3c(%esi),%ebp
   1ad72:	31 df                	xor    %ebx,%edi
   1ad74:	01 fa                	add    %edi,%edx
   1ad76:	89 c7                	mov    %eax,%edi
   1ad78:	c1 c2 09             	rol    $0x9,%edx
   1ad7b:	01 c2                	add    %eax,%edx
   1ad7d:	8d 8c 29 81 e6 a1 d8 	lea    0xd8a1e681(%ecx,%ebp,1),%ecx
   1ad84:	31 d7                	xor    %edx,%edi
   1ad86:	21 df                	and    %ebx,%edi
   1ad88:	8b 6e 10             	mov    0x10(%esi),%ebp
   1ad8b:	31 c7                	xor    %eax,%edi
   1ad8d:	01 f9                	add    %edi,%ecx
   1ad8f:	89 d7                	mov    %edx,%edi
   1ad91:	c1 c1 0e             	rol    $0xe,%ecx
   1ad94:	01 d1                	add    %edx,%ecx
   1ad96:	8d 9c 2b c8 fb d3 e7 	lea    0xe7d3fbc8(%ebx,%ebp,1),%ebx
   1ad9d:	31 cf                	xor    %ecx,%edi
   1ad9f:	21 c7                	and    %eax,%edi
   1ada1:	8b 6e 24             	mov    0x24(%esi),%ebp
   1ada4:	31 d7                	xor    %edx,%edi
   1ada6:	01 fb                	add    %edi,%ebx
   1ada8:	89 cf                	mov    %ecx,%edi
   1adaa:	c1 c3 14             	rol    $0x14,%ebx
   1adad:	01 cb                	add    %ecx,%ebx
   1adaf:	8d 84 28 e6 cd e1 21 	lea    0x21e1cde6(%eax,%ebp,1),%eax
   1adb6:	31 df                	xor    %ebx,%edi
   1adb8:	21 d7                	and    %edx,%edi
   1adba:	8b 6e 38             	mov    0x38(%esi),%ebp
   1adbd:	31 cf                	xor    %ecx,%edi
   1adbf:	01 f8                	add    %edi,%eax
   1adc1:	89 df                	mov    %ebx,%edi
   1adc3:	c1 c0 05             	rol    $0x5,%eax
   1adc6:	01 d8                	add    %ebx,%eax
   1adc8:	8d 94 2a d6 07 37 c3 	lea    0xc33707d6(%edx,%ebp,1),%edx
   1adcf:	31 c7                	xor    %eax,%edi
   1add1:	21 cf                	and    %ecx,%edi
   1add3:	8b 6e 0c             	mov    0xc(%esi),%ebp
   1add6:	31 df                	xor    %ebx,%edi
   1add8:	01 fa                	add    %edi,%edx
   1adda:	89 c7                	mov    %eax,%edi
   1addc:	c1 c2 09             	rol    $0x9,%edx
   1addf:	01 c2                	add    %eax,%edx
   1ade1:	8d 8c 29 87 0d d5 f4 	lea    0xf4d50d87(%ecx,%ebp,1),%ecx
   1ade8:	31 d7                	xor    %edx,%edi
   1adea:	21 df                	and    %ebx,%edi
   1adec:	8b 6e 20             	mov    0x20(%esi),%ebp
   1adef:	31 c7                	xor    %eax,%edi
   1adf1:	01 f9                	add    %edi,%ecx
   1adf3:	89 d7                	mov    %edx,%edi
   1adf5:	c1 c1 0e             	rol    $0xe,%ecx
   1adf8:	01 d1                	add    %edx,%ecx
   1adfa:	8d 9c 2b ed 14 5a 45 	lea    0x455a14ed(%ebx,%ebp,1),%ebx
   1ae01:	31 cf                	xor    %ecx,%edi
   1ae03:	21 c7                	and    %eax,%edi
   1ae05:	8b 6e 34             	mov    0x34(%esi),%ebp
   1ae08:	31 d7                	xor    %edx,%edi
   1ae0a:	01 fb                	add    %edi,%ebx
   1ae0c:	89 cf                	mov    %ecx,%edi
   1ae0e:	c1 c3 14             	rol    $0x14,%ebx
   1ae11:	01 cb                	add    %ecx,%ebx
   1ae13:	8d 84 28 05 e9 e3 a9 	lea    0xa9e3e905(%eax,%ebp,1),%eax
   1ae1a:	31 df                	xor    %ebx,%edi
   1ae1c:	21 d7                	and    %edx,%edi
   1ae1e:	8b 6e 08             	mov    0x8(%esi),%ebp
   1ae21:	31 cf                	xor    %ecx,%edi
   1ae23:	01 f8                	add    %edi,%eax
   1ae25:	89 df                	mov    %ebx,%edi
   1ae27:	c1 c0 05             	rol    $0x5,%eax
   1ae2a:	01 d8                	add    %ebx,%eax
   1ae2c:	8d 94 2a f8 a3 ef fc 	lea    0xfcefa3f8(%edx,%ebp,1),%edx
   1ae33:	31 c7                	xor    %eax,%edi
   1ae35:	21 cf                	and    %ecx,%edi
   1ae37:	8b 6e 1c             	mov    0x1c(%esi),%ebp
   1ae3a:	31 df                	xor    %ebx,%edi
   1ae3c:	01 fa                	add    %edi,%edx
   1ae3e:	89 c7                	mov    %eax,%edi
   1ae40:	c1 c2 09             	rol    $0x9,%edx
   1ae43:	01 c2                	add    %eax,%edx
   1ae45:	8d 8c 29 d9 02 6f 67 	lea    0x676f02d9(%ecx,%ebp,1),%ecx
   1ae4c:	31 d7                	xor    %edx,%edi
   1ae4e:	21 df                	and    %ebx,%edi
   1ae50:	8b 6e 30             	mov    0x30(%esi),%ebp
   1ae53:	31 c7                	xor    %eax,%edi
   1ae55:	01 f9                	add    %edi,%ecx
   1ae57:	89 d7                	mov    %edx,%edi
   1ae59:	c1 c1 0e             	rol    $0xe,%ecx
   1ae5c:	01 d1                	add    %edx,%ecx
   1ae5e:	8d 9c 2b 8a 4c 2a 8d 	lea    0x8d2a4c8a(%ebx,%ebp,1),%ebx
   1ae65:	31 cf                	xor    %ecx,%edi
   1ae67:	21 c7                	and    %eax,%edi
   1ae69:	8b 6e 14             	mov    0x14(%esi),%ebp
   1ae6c:	31 d7                	xor    %edx,%edi
   1ae6e:	01 fb                	add    %edi,%ebx
   1ae70:	89 cf                	mov    %ecx,%edi
   1ae72:	c1 c3 14             	rol    $0x14,%ebx
   1ae75:	01 cb                	add    %ecx,%ebx
   1ae77:	31 d7                	xor    %edx,%edi
   1ae79:	31 df                	xor    %ebx,%edi
   1ae7b:	8d 84 28 42 39 fa ff 	lea    0xfffa3942(%eax,%ebp,1),%eax
   1ae82:	01 f8                	add    %edi,%eax
   1ae84:	c1 c0 04             	rol    $0x4,%eax
   1ae87:	8b 6e 20             	mov    0x20(%esi),%ebp
   1ae8a:	89 df                	mov    %ebx,%edi
   1ae8c:	8d 94 2a 81 f6 71 87 	lea    0x8771f681(%edx,%ebp,1),%edx
   1ae93:	01 d8                	add    %ebx,%eax
   1ae95:	31 cf                	xor    %ecx,%edi
   1ae97:	31 c7                	xor    %eax,%edi
   1ae99:	8b 6e 2c             	mov    0x2c(%esi),%ebp
   1ae9c:	01 fa                	add    %edi,%edx
   1ae9e:	89 c7                	mov    %eax,%edi
   1aea0:	c1 c2 0b             	rol    $0xb,%edx
   1aea3:	01 c2                	add    %eax,%edx
   1aea5:	31 df                	xor    %ebx,%edi
   1aea7:	31 d7                	xor    %edx,%edi
   1aea9:	8d 8c 29 22 61 9d 6d 	lea    0x6d9d6122(%ecx,%ebp,1),%ecx
   1aeb0:	01 f9                	add    %edi,%ecx
   1aeb2:	c1 c1 10             	rol    $0x10,%ecx
   1aeb5:	8b 6e 38             	mov    0x38(%esi),%ebp
   1aeb8:	89 d7                	mov    %edx,%edi
   1aeba:	8d 9c 2b 0c 38 e5 fd 	lea    0xfde5380c(%ebx,%ebp,1),%ebx
   1aec1:	01 d1                	add    %edx,%ecx
   1aec3:	31 c7                	xor    %eax,%edi
   1aec5:	31 cf                	xor    %ecx,%edi
   1aec7:	8b 6e 04             	mov    0x4(%esi),%ebp
   1aeca:	01 fb                	add    %edi,%ebx
   1aecc:	89 cf                	mov    %ecx,%edi
   1aece:	c1 c3 17             	rol    $0x17,%ebx
   1aed1:	01 cb                	add    %ecx,%ebx
   1aed3:	31 d7                	xor    %edx,%edi
   1aed5:	31 df                	xor    %ebx,%edi
   1aed7:	8d 84 28 44 ea be a4 	lea    0xa4beea44(%eax,%ebp,1),%eax
   1aede:	01 f8                	add    %edi,%eax
   1aee0:	c1 c0 04             	rol    $0x4,%eax
   1aee3:	8b 6e 10             	mov    0x10(%esi),%ebp
   1aee6:	89 df                	mov    %ebx,%edi
   1aee8:	8d 94 2a a9 cf de 4b 	lea    0x4bdecfa9(%edx,%ebp,1),%edx
   1aeef:	01 d8                	add    %ebx,%eax
   1aef1:	31 cf                	xor    %ecx,%edi
   1aef3:	31 c7                	xor    %eax,%edi
   1aef5:	8b 6e 1c             	mov    0x1c(%esi),%ebp
   1aef8:	01 fa                	add    %edi,%edx
   1aefa:	89 c7                	mov    %eax,%edi
   1aefc:	c1 c2 0b             	rol    $0xb,%edx
   1aeff:	01 c2                	add    %eax,%edx
   1af01:	31 df                	xor    %ebx,%edi
   1af03:	31 d7                	xor    %edx,%edi
   1af05:	8d 8c 29 60 4b bb f6 	lea    0xf6bb4b60(%ecx,%ebp,1),%ecx
   1af0c:	01 f9                	add    %edi,%ecx
   1af0e:	c1 c1 10             	rol    $0x10,%ecx
   1af11:	8b 6e 28             	mov    0x28(%esi),%ebp
   1af14:	89 d7                	mov    %edx,%edi
   1af16:	8d 9c 2b 70 bc bf be 	lea    0xbebfbc70(%ebx,%ebp,1),%ebx
   1af1d:	01 d1                	add    %edx,%ecx
   1af1f:	31 c7                	xor    %eax,%edi
   1af21:	31 cf                	xor    %ecx,%edi
   1af23:	8b 6e 34             	mov    0x34(%esi),%ebp
   1af26:	01 fb                	add    %edi,%ebx
   1af28:	89 cf                	mov    %ecx,%edi
   1af2a:	c1 c3 17             	rol    $0x17,%ebx
   1af2d:	01 cb                	add    %ecx,%ebx
   1af2f:	31 d7                	xor    %edx,%edi
   1af31:	31 df                	xor    %ebx,%edi
   1af33:	8d 84 28 c6 7e 9b 28 	lea    0x289b7ec6(%eax,%ebp,1),%eax
   1af3a:	01 f8                	add    %edi,%eax
   1af3c:	c1 c0 04             	rol    $0x4,%eax
   1af3f:	8b 2e                	mov    (%esi),%ebp
   1af41:	89 df                	mov    %ebx,%edi
   1af43:	8d 94 2a fa 27 a1 ea 	lea    0xeaa127fa(%edx,%ebp,1),%edx
   1af4a:	01 d8                	add    %ebx,%eax
   1af4c:	31 cf                	xor    %ecx,%edi
   1af4e:	31 c7                	xor    %eax,%edi
   1af50:	8b 6e 0c             	mov    0xc(%esi),%ebp
   1af53:	01 fa                	add    %edi,%edx
   1af55:	89 c7                	mov    %eax,%edi
   1af57:	c1 c2 0b             	rol    $0xb,%edx
   1af5a:	01 c2                	add    %eax,%edx
   1af5c:	31 df                	xor    %ebx,%edi
   1af5e:	31 d7                	xor    %edx,%edi
   1af60:	8d 8c 29 85 30 ef d4 	lea    0xd4ef3085(%ecx,%ebp,1),%ecx
   1af67:	01 f9                	add    %edi,%ecx
   1af69:	c1 c1 10             	rol    $0x10,%ecx
   1af6c:	8b 6e 18             	mov    0x18(%esi),%ebp
   1af6f:	89 d7                	mov    %edx,%edi
   1af71:	8d 9c 2b 05 1d 88 04 	lea    0x4881d05(%ebx,%ebp,1),%ebx
   1af78:	01 d1                	add    %edx,%ecx
   1af7a:	31 c7                	xor    %eax,%edi
   1af7c:	31 cf                	xor    %ecx,%edi
   1af7e:	8b 6e 24             	mov    0x24(%esi),%ebp
   1af81:	01 fb                	add    %edi,%ebx
   1af83:	89 cf                	mov    %ecx,%edi
   1af85:	c1 c3 17             	rol    $0x17,%ebx
   1af88:	01 cb                	add    %ecx,%ebx
   1af8a:	31 d7                	xor    %edx,%edi
   1af8c:	31 df                	xor    %ebx,%edi
   1af8e:	8d 84 28 39 d0 d4 d9 	lea    0xd9d4d039(%eax,%ebp,1),%eax
   1af95:	01 f8                	add    %edi,%eax
   1af97:	c1 c0 04             	rol    $0x4,%eax
   1af9a:	8b 6e 30             	mov    0x30(%esi),%ebp
   1af9d:	89 df                	mov    %ebx,%edi
   1af9f:	8d 94 2a e5 99 db e6 	lea    0xe6db99e5(%edx,%ebp,1),%edx
   1afa6:	01 d8                	add    %ebx,%eax
   1afa8:	31 cf                	xor    %ecx,%edi
   1afaa:	31 c7                	xor    %eax,%edi
   1afac:	8b 6e 3c             	mov    0x3c(%esi),%ebp
   1afaf:	01 fa                	add    %edi,%edx
   1afb1:	89 c7                	mov    %eax,%edi
   1afb3:	c1 c2 0b             	rol    $0xb,%edx
   1afb6:	01 c2                	add    %eax,%edx
   1afb8:	31 df                	xor    %ebx,%edi
   1afba:	31 d7                	xor    %edx,%edi
   1afbc:	8d 8c 29 f8 7c a2 1f 	lea    0x1fa27cf8(%ecx,%ebp,1),%ecx
   1afc3:	01 f9                	add    %edi,%ecx
   1afc5:	c1 c1 10             	rol    $0x10,%ecx
   1afc8:	8b 6e 08             	mov    0x8(%esi),%ebp
   1afcb:	89 d7                	mov    %edx,%edi
   1afcd:	8d 9c 2b 65 56 ac c4 	lea    0xc4ac5665(%ebx,%ebp,1),%ebx
   1afd4:	01 d1                	add    %edx,%ecx
   1afd6:	31 c7                	xor    %eax,%edi
   1afd8:	31 cf                	xor    %ecx,%edi
   1afda:	8b 2e                	mov    (%esi),%ebp
   1afdc:	01 fb                	add    %edi,%ebx
   1afde:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   1afe3:	c1 c3 17             	rol    $0x17,%ebx
   1afe6:	01 cb                	add    %ecx,%ebx
   1afe8:	31 d7                	xor    %edx,%edi
   1afea:	09 df                	or     %ebx,%edi
   1afec:	8d 84 28 44 22 29 f4 	lea    0xf4292244(%eax,%ebp,1),%eax
   1aff3:	31 cf                	xor    %ecx,%edi
   1aff5:	8b 6e 1c             	mov    0x1c(%esi),%ebp
   1aff8:	01 f8                	add    %edi,%eax
   1affa:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   1afff:	c1 c0 06             	rol    $0x6,%eax
   1b002:	31 cf                	xor    %ecx,%edi
   1b004:	01 d8                	add    %ebx,%eax
   1b006:	09 c7                	or     %eax,%edi
   1b008:	8d 94 2a 97 ff 2a 43 	lea    0x432aff97(%edx,%ebp,1),%edx
   1b00f:	31 df                	xor    %ebx,%edi
   1b011:	8b 6e 38             	mov    0x38(%esi),%ebp
   1b014:	01 fa                	add    %edi,%edx
   1b016:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   1b01b:	c1 c2 0a             	rol    $0xa,%edx
   1b01e:	31 df                	xor    %ebx,%edi
   1b020:	01 c2                	add    %eax,%edx
   1b022:	09 d7                	or     %edx,%edi
   1b024:	8d 8c 29 a7 23 94 ab 	lea    0xab9423a7(%ecx,%ebp,1),%ecx
   1b02b:	31 c7                	xor    %eax,%edi
   1b02d:	8b 6e 14             	mov    0x14(%esi),%ebp
   1b030:	01 f9                	add    %edi,%ecx
   1b032:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   1b037:	c1 c1 0f             	rol    $0xf,%ecx
   1b03a:	31 c7                	xor    %eax,%edi
   1b03c:	01 d1                	add    %edx,%ecx
   1b03e:	09 cf                	or     %ecx,%edi
   1b040:	8d 9c 2b 39 a0 93 fc 	lea    0xfc93a039(%ebx,%ebp,1),%ebx
   1b047:	31 d7                	xor    %edx,%edi
   1b049:	8b 6e 30             	mov    0x30(%esi),%ebp
   1b04c:	01 fb                	add    %edi,%ebx
   1b04e:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   1b053:	c1 c3 15             	rol    $0x15,%ebx
   1b056:	31 d7                	xor    %edx,%edi
   1b058:	01 cb                	add    %ecx,%ebx
   1b05a:	09 df                	or     %ebx,%edi
   1b05c:	8d 84 28 c3 59 5b 65 	lea    0x655b59c3(%eax,%ebp,1),%eax
   1b063:	31 cf                	xor    %ecx,%edi
   1b065:	8b 6e 0c             	mov    0xc(%esi),%ebp
   1b068:	01 f8                	add    %edi,%eax
   1b06a:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   1b06f:	c1 c0 06             	rol    $0x6,%eax
   1b072:	31 cf                	xor    %ecx,%edi
   1b074:	01 d8                	add    %ebx,%eax
   1b076:	09 c7                	or     %eax,%edi
   1b078:	8d 94 2a 92 cc 0c 8f 	lea    0x8f0ccc92(%edx,%ebp,1),%edx
   1b07f:	31 df                	xor    %ebx,%edi
   1b081:	8b 6e 28             	mov    0x28(%esi),%ebp
   1b084:	01 fa                	add    %edi,%edx
   1b086:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   1b08b:	c1 c2 0a             	rol    $0xa,%edx
   1b08e:	31 df                	xor    %ebx,%edi
   1b090:	01 c2                	add    %eax,%edx
   1b092:	09 d7                	or     %edx,%edi
   1b094:	8d 8c 29 7d f4 ef ff 	lea    0xffeff47d(%ecx,%ebp,1),%ecx
   1b09b:	31 c7                	xor    %eax,%edi
   1b09d:	8b 6e 04             	mov    0x4(%esi),%ebp
   1b0a0:	01 f9                	add    %edi,%ecx
   1b0a2:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   1b0a7:	c1 c1 0f             	rol    $0xf,%ecx
   1b0aa:	31 c7                	xor    %eax,%edi
   1b0ac:	01 d1                	add    %edx,%ecx
   1b0ae:	09 cf                	or     %ecx,%edi
   1b0b0:	8d 9c 2b d1 5d 84 85 	lea    0x85845dd1(%ebx,%ebp,1),%ebx
   1b0b7:	31 d7                	xor    %edx,%edi
   1b0b9:	8b 6e 20             	mov    0x20(%esi),%ebp
   1b0bc:	01 fb                	add    %edi,%ebx
   1b0be:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   1b0c3:	c1 c3 15             	rol    $0x15,%ebx
   1b0c6:	31 d7                	xor    %edx,%edi
   1b0c8:	01 cb                	add    %ecx,%ebx
   1b0ca:	09 df                	or     %ebx,%edi
   1b0cc:	8d 84 28 4f 7e a8 6f 	lea    0x6fa87e4f(%eax,%ebp,1),%eax
   1b0d3:	31 cf                	xor    %ecx,%edi
   1b0d5:	8b 6e 3c             	mov    0x3c(%esi),%ebp
   1b0d8:	01 f8                	add    %edi,%eax
   1b0da:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   1b0df:	c1 c0 06             	rol    $0x6,%eax
   1b0e2:	31 cf                	xor    %ecx,%edi
   1b0e4:	01 d8                	add    %ebx,%eax
   1b0e6:	09 c7                	or     %eax,%edi
   1b0e8:	8d 94 2a e0 e6 2c fe 	lea    0xfe2ce6e0(%edx,%ebp,1),%edx
   1b0ef:	31 df                	xor    %ebx,%edi
   1b0f1:	8b 6e 18             	mov    0x18(%esi),%ebp
   1b0f4:	01 fa                	add    %edi,%edx
   1b0f6:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   1b0fb:	c1 c2 0a             	rol    $0xa,%edx
   1b0fe:	31 df                	xor    %ebx,%edi
   1b100:	01 c2                	add    %eax,%edx
   1b102:	09 d7                	or     %edx,%edi
   1b104:	8d 8c 29 14 43 01 a3 	lea    0xa3014314(%ecx,%ebp,1),%ecx
   1b10b:	31 c7                	xor    %eax,%edi
   1b10d:	8b 6e 34             	mov    0x34(%esi),%ebp
   1b110:	01 f9                	add    %edi,%ecx
   1b112:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   1b117:	c1 c1 0f             	rol    $0xf,%ecx
   1b11a:	31 c7                	xor    %eax,%edi
   1b11c:	01 d1                	add    %edx,%ecx
   1b11e:	09 cf                	or     %ecx,%edi
   1b120:	8d 9c 2b a1 11 08 4e 	lea    0x4e0811a1(%ebx,%ebp,1),%ebx
   1b127:	31 d7                	xor    %edx,%edi
   1b129:	8b 6e 10             	mov    0x10(%esi),%ebp
   1b12c:	01 fb                	add    %edi,%ebx
   1b12e:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   1b133:	c1 c3 15             	rol    $0x15,%ebx
   1b136:	31 d7                	xor    %edx,%edi
   1b138:	01 cb                	add    %ecx,%ebx
   1b13a:	09 df                	or     %ebx,%edi
   1b13c:	8d 84 28 82 7e 53 f7 	lea    0xf7537e82(%eax,%ebp,1),%eax
   1b143:	31 cf                	xor    %ecx,%edi
   1b145:	8b 6e 2c             	mov    0x2c(%esi),%ebp
   1b148:	01 f8                	add    %edi,%eax
   1b14a:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   1b14f:	c1 c0 06             	rol    $0x6,%eax
   1b152:	31 cf                	xor    %ecx,%edi
   1b154:	01 d8                	add    %ebx,%eax
   1b156:	09 c7                	or     %eax,%edi
   1b158:	8d 94 2a 35 f2 3a bd 	lea    0xbd3af235(%edx,%ebp,1),%edx
   1b15f:	31 df                	xor    %ebx,%edi
   1b161:	8b 6e 08             	mov    0x8(%esi),%ebp
   1b164:	01 fa                	add    %edi,%edx
   1b166:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   1b16b:	c1 c2 0a             	rol    $0xa,%edx
   1b16e:	31 df                	xor    %ebx,%edi
   1b170:	01 c2                	add    %eax,%edx
   1b172:	09 d7                	or     %edx,%edi
   1b174:	8d 8c 29 bb d2 d7 2a 	lea    0x2ad7d2bb(%ecx,%ebp,1),%ecx
   1b17b:	31 c7                	xor    %eax,%edi
   1b17d:	8b 6e 24             	mov    0x24(%esi),%ebp
   1b180:	01 f9                	add    %edi,%ecx
   1b182:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   1b187:	c1 c1 0f             	rol    $0xf,%ecx
   1b18a:	31 c7                	xor    %eax,%edi
   1b18c:	01 d1                	add    %edx,%ecx
   1b18e:	09 cf                	or     %ecx,%edi
   1b190:	8d 9c 2b 91 d3 86 eb 	lea    0xeb86d391(%ebx,%ebp,1),%ebx
   1b197:	31 d7                	xor    %edx,%edi
   1b199:	8b 6c 24 18          	mov    0x18(%esp,1),%ebp
   1b19d:	01 fb                	add    %edi,%ebx
   1b19f:	83 c6 40             	add    $0x40,%esi
   1b1a2:	c1 c3 15             	rol    $0x15,%ebx
   1b1a5:	8b 7d 00             	mov    0x0(%ebp),%edi
   1b1a8:	01 cb                	add    %ecx,%ebx
   1b1aa:	01 f8                	add    %edi,%eax
   1b1ac:	8b 7d 04             	mov    0x4(%ebp),%edi
   1b1af:	01 fb                	add    %edi,%ebx
   1b1b1:	8b 7d 08             	mov    0x8(%ebp),%edi
   1b1b4:	01 f9                	add    %edi,%ecx
   1b1b6:	8b 7d 0c             	mov    0xc(%ebp),%edi
   1b1b9:	01 fa                	add    %edi,%edx
   1b1bb:	89 45 00             	mov    %eax,0x0(%ebp)
   1b1be:	89 5d 04             	mov    %ebx,0x4(%ebp)
   1b1c1:	8b 3c 24             	mov    (%esp,1),%edi
   1b1c4:	89 4d 08             	mov    %ecx,0x8(%ebp)
   1b1c7:	89 55 0c             	mov    %edx,0xc(%ebp)
   1b1ca:	39 f7                	cmp    %esi,%edi
   1b1cc:	0f 83 82 f9 ff ff    	jae    1ab54 <md5_block_asm_host_order+0x24>
   1b1d2:	58                   	pop    %eax
   1b1d3:	5b                   	pop    %ebx
   1b1d4:	5d                   	pop    %ebp
   1b1d5:	5f                   	pop    %edi
   1b1d6:	5e                   	pop    %esi
   1b1d7:	c3                   	ret    
Disassembly of section .fixup:

00000000 <.fixup>:
   0:	be f2 ff ff ff       	mov    $0xfffffff2,%esi
   5:	e9 1b 00 01 00       	jmp    10025 <cminisock_config_pipe_impl+0x695>
   a:	be f2 ff ff ff       	mov    $0xfffffff2,%esi
   f:	e9 f4 00 01 00       	jmp    10108 <trickles_getsockopt_impl+0xa8>
  14:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
  19:	e9 1b 01 01 00       	jmp    10139 <trickles_getsockopt_impl+0xd9>
  1e:	c1 e1 02             	shl    $0x2,%ecx
/* Two phase free: first phase disconnects socket from event list,
   sets to ALLOC_PROCESSING; second phase adds the socket to free
   list, sets to ALLOC_FREE and ready for reuse */
#ifndef USERTEST
static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk) {
  21:	e9 b7 2e 01 00       	jmp    12edd <__constant_copy_to_user+0x6d>
  26:	c1 e1 02             	shl    $0x2,%ecx
	if(!SIMULATION_MODE(sk)) {
  29:	41                   	inc    %ecx
  2a:	e9 ce 2e 01 00       	jmp    12efd <__constant_copy_from_user+0xd>
  2f:	c1 e1 02             	shl    $0x2,%ecx
  32:	83 c1 02             	add    $0x2,%ecx
  35:	41                   	inc    %ecx
  36:	e9 dd 2e 01 00       	jmp    12f18 <__constant_copy_from_user+0x28>
  3b:	c1 e1 02             	shl    $0x2,%ecx
  3e:	83 c1 02             	add    $0x2,%ecx
		if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) {
  41:	e9 e6 2e 01 00       	jmp    12f2c <__constant_copy_from_user+0x3c>
  46:	51                   	push   %ecx
  47:	50                   	push   %eax
  48:	31 c0                	xor    %eax,%eax
  4a:	f3 ab                	repz stos %eax,%es:(%edi)
  4c:	58                   	pop    %eax
			printk("double free\n");
			BUG();
		}
		if(msk->ctl == ALLOC_READY && msk->prev != NULL) {
  4d:	59                   	pop    %ecx
  4e:	c1 e1 02             	shl    $0x2,%ecx
			unlink((struct alloc_head *)msk);
		}
		msk->ctl = ALLOC_PROCESSING;
  51:	e9 36 2f 01 00       	jmp    12f8c <__constant_copy_from_user+0x9c>
  56:	51                   	push   %ecx
	}
}
  57:	50                   	push   %eax
  58:	31 c0                	xor    %eax,%eax
  5a:	f3 ab                	repz stos %eax,%es:(%edi)
  5c:	aa                   	stos   %al,%es:(%edi)
  5d:	58                   	pop    %eax
  5e:	59                   	pop    %ecx
  5f:	c1 e1 02             	shl    $0x2,%ecx
  62:	41                   	inc    %ecx
  63:	e9 51 2f 01 00       	jmp    12fb9 <sock_orphan+0x29>
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
  68:	50                   	push   %eax
  69:	31 c0                	xor    %eax,%eax
	elem->prev->next = elem->next;
  6b:	aa                   	stos   %al,%es:(%edi)
  6c:	58                   	pop    %eax
	elem->prev = elem->next = NULL;
  6d:	41                   	inc    %ecx
  6e:	e9 51 2f 01 00       	jmp    12fc4 <sock_orphan+0x34>
  73:	51                   	push   %ecx
  74:	50                   	push   %eax
  75:	31 c0                	xor    %eax,%eax

	elem->list->len--;
  77:	f3 ab                	repz stos %eax,%es:(%edi)
  79:	66 ab                	stos   %ax,%es:(%edi)
  7b:	aa                   	stos   %al,%es:(%edi)
  7c:	58                   	pop    %eax
  7d:	59                   	pop    %ecx
  7e:	c1 e1 02             	shl    $0x2,%ecx
  81:	83 c1 03             	add    $0x3,%ecx
	elem->list = NULL;
  84:	e9 61 2f 01 00       	jmp    12fea <.text.lock.tmalloc+0x18>
  89:	50                   	push   %eax
  8a:	31 c0                	xor    %eax,%eax
  8c:	66 ab                	stos   %ax,%es:(%edi)
  8e:	aa                   	stos   %al,%es:(%edi)
  8f:	58                   	pop    %eax
#ifndef USERTEST
static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk) {
	if(!SIMULATION_MODE(sk)) {
		if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) {
			printk("double free\n");
  90:	83 c1 03             	add    $0x3,%ecx
  93:	e9 61 2f 01 00       	jmp    12ff9 <.text.lock.tmalloc+0x27>
  98:	50                   	push   %eax
  99:	31 c0                	xor    %eax,%eax
  9b:	aa                   	stos   %al,%es:(%edi)
			BUG();
  9c:	58                   	pop    %eax
  9d:	41                   	inc    %ecx
  9e:	e9 62 2f 01 00       	jmp    13005 <.text.lock.tmalloc+0x33>
  a3:	51                   	push   %ecx
  a4:	50                   	push   %eax
  a5:	31 c0                	xor    %eax,%eax
  a7:	f3 ab                	repz stos %eax,%es:(%edi)
  a9:	66 ab                	stos   %ax,%es:(%edi)
  ab:	58                   	pop    %eax
  ac:	59                   	pop    %ecx
  ad:	c1 e1 02             	shl    $0x2,%ecx
  b0:	83 c1 02             	add    $0x2,%ecx
  b3:	e9 6d 2f 01 00       	jmp    13025 <.text.lock.tmalloc+0x53>
  b8:	50                   	push   %eax
  b9:	31 c0                	xor    %eax,%eax
  bb:	66 ab                	stos   %ax,%es:(%edi)
  bd:	58                   	pop    %eax
  be:	83 c1 02             	add    $0x2,%ecx
		}
		if(msk->ctl == ALLOC_READY && msk->prev != NULL) {
			unlink((struct alloc_head *)msk);
		}
		msk->ctl = ALLOC_PROCESSING;
	}
}

static inline void free_trickles_msk_finish(struct sock *sk, struct cminisock *msk) {
  c1:	e9 6d 2f 01 00       	jmp    13033 <.text.lock.tmalloc+0x61>
