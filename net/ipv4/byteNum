af_inet.c:12: *		Florian La Roche, <flla@stud.uni-sb.de>
af_inet.c:22: *					don't return -EINPROGRESS.
af_inet.c:162:	__skb_queue_purge(&sk->receive_queue);
af_inet.c:163:	__skb_queue_purge(&sk->error_queue);
af_inet.c:165:	if (sk->type == SOCK_STREAM && sk->state != TCP_CLOSE) {
af_inet.c:167:		       sk->state,
af_inet.c:171:	if (!sk->dead) {
af_inet.c:176:	BUG_TRAP(atomic_read(&sk->rmem_alloc) == 0);
af_inet.c:177:	BUG_TRAP(atomic_read(&sk->wmem_alloc) == 0);
af_inet.c:178:	BUG_TRAP(sk->wmem_queued == 0);
af_inet.c:179:	BUG_TRAP(sk->forward_alloc == 0);
af_inet.c:181:	if (sk->protinfo.af_inet.opt)
af_inet.c:182:		kfree(sk->protinfo.af_inet.opt);
af_inet.c:183:	dst_release(sk->dst_cache);
af_inet.c:192:	if (sk->prot->destroy)
af_inet.c:193:		sk->prot->destroy(sk);
af_inet.c:202:	sk->prot->unhash(sk);
af_inet.c:220:	if (atomic_read(&sk->refcnt) != 1) {
af_inet.c:221:		printk(KERN_DEBUG "Destruction inet %p delayed, c=%d\n", sk, atomic_read(&sk->refcnt));
af_inet.c:242:	struct sock *sk=sock->sk;
af_inet.c:244:	return sk->prot->setsockopt(sk,level,optname,optval,optlen);
af_inet.c:258:	struct sock *sk=sock->sk;
af_inet.c:260:	return sk->prot->getsockopt(sk,level,optname,optval,optlen);
af_inet.c:271:	if (sk->num == 0) {
af_inet.c:272:		if (sk->prot->get_port(sk, 0) != 0) {
af_inet.c:274:			return -EAGAIN;
af_inet.c:276:		sk->sport = htons(sk->num);
af_inet.c:288:	struct sock *sk = sock->sk;
af_inet.c:294:	err = -EINVAL;
af_inet.c:295:	if (sock->state != SS_UNCONNECTED || sock->type != SOCK_STREAM)
af_inet.c:298:	old_state = sk->state;
af_inet.c:310:	sk->max_ack_backlog = backlog;
af_inet.c:328:	sock->state = SS_UNCONNECTED;
af_inet.c:336:	list_for_each(p, &inetsw[sock->type]) {
af_inet.c:339:		/* Check the non-wild match. */
af_inet.c:340:		if (protocol == answer->protocol) {
af_inet.c:346:				protocol = answer->protocol;
af_inet.c:349:			if (IPPROTO_IP == answer->protocol)
af_inet.c:358:	if (answer->capability > 0 && !capable(answer->capability))
af_inet.c:363:	sock->ops = answer->ops;
af_inet.c:364:	sk->prot = answer->prot;
af_inet.c:365:	sk->no_check = answer->no_check;
af_inet.c:366:	if (INET_PROTOSW_REUSE & answer->flags)
af_inet.c:367:		sk->reuse = 1;
af_inet.c:369:	if (SOCK_RAW == sock->type) {
af_inet.c:370:		sk->num = protocol;
af_inet.c:372:			sk->protinfo.af_inet.hdrincl = 1;
af_inet.c:376:		sk->protinfo.af_inet.pmtudisc = IP_PMTUDISC_DONT;
af_inet.c:378:		sk->protinfo.af_inet.pmtudisc = IP_PMTUDISC_WANT;
af_inet.c:380:	sk->protinfo.af_inet.id = 0;
af_inet.c:384:	sk->destruct = inet_sock_destruct;
af_inet.c:386:	sk->zapped	= 0;
af_inet.c:387:	sk->family	= PF_INET;
af_inet.c:388:	sk->protocol	= protocol;
af_inet.c:390:	sk->backlog_rcv = sk->prot->backlog_rcv;
af_inet.c:392:	sk->protinfo.af_inet.ttl	= sysctl_ip_default_ttl;
af_inet.c:394:	sk->protinfo.af_inet.mc_loop	= 1;
af_inet.c:395:	sk->protinfo.af_inet.mc_ttl	= 1;
af_inet.c:396:	sk->protinfo.af_inet.mc_index	= 0;
af_inet.c:397:	sk->protinfo.af_inet.mc_list	= NULL;
af_inet.c:403:	if (sk->num) {
af_inet.c:409:		sk->sport = htons(sk->num);
af_inet.c:412:		sk->prot->hash(sk);
af_inet.c:415:	if (sk->prot->init) {
af_inet.c:416:		int err = sk->prot->init(sk);
af_inet.c:426:	return -ESOCKTNOSUPPORT;
af_inet.c:430:	return -EPERM;
af_inet.c:434:	return -EPROTONOSUPPORT;
af_inet.c:437:	return -ENOBUFS;
af_inet.c:449:	struct sock *sk = sock->sk;
af_inet.c:465:		if (sk->linger && !(current->flags & PF_EXITING))
af_inet.c:466:			timeout = sk->lingertime;
af_inet.c:467:		sock->sk = NULL;
af_inet.c:468:		sk->prot->close(sk, timeout);
af_inet.c:479:	struct sock *sk=sock->sk;
af_inet.c:485:	if(sk->prot->bind)
af_inet.c:486:		return sk->prot->bind(sk, uaddr, addr_len);
af_inet.c:489:		return -EINVAL;
af_inet.c:491:	chk_addr_ret = inet_addr_type(addr->sin_addr.s_addr);
af_inet.c:493:	/* Not specified by any standard per-se, however it breaks too
af_inet.c:495:	 * allowing applications to make a non-local bind solves
af_inet.c:501:	    sk->protinfo.af_inet.freebind == 0 &&
af_inet.c:502:	    addr->sin_addr.s_addr != INADDR_ANY &&
af_inet.c:506:		return -EADDRNOTAVAIL;
af_inet.c:508:	snum = ntohs(addr->sin_port);
af_inet.c:510:		return -EACCES;
af_inet.c:522:	err = -EINVAL;
af_inet.c:523:	if ((sk->state != TCP_CLOSE)			||
af_inet.c:524:	    (sk->num != 0))
af_inet.c:527:	sk->rcv_saddr = sk->saddr = addr->sin_addr.s_addr;
af_inet.c:529:		sk->saddr = 0;  /* Use device */
af_inet.c:532:	if (sk->prot->get_port(sk, snum) != 0) {
af_inet.c:533:		sk->saddr = sk->rcv_saddr = 0;
af_inet.c:534:		err = -EADDRINUSE;
af_inet.c:538:	if (sk->rcv_saddr)
af_inet.c:539:		sk->userlocks |= SOCK_BINDADDR_LOCK;
af_inet.c:541:		sk->userlocks |= SOCK_BINDPORT_LOCK;
af_inet.c:542:	sk->sport = htons(sk->num);
af_inet.c:543:	sk->daddr = 0;
af_inet.c:544:	sk->dport = 0;
af_inet.c:555:	struct sock *sk=sock->sk;
af_inet.c:557:	if (uaddr->sa_family == AF_UNSPEC)
af_inet.c:558:		return sk->prot->disconnect(sk, flags);
af_inet.c:560:	if (sk->num==0 && inet_autobind(sk) != 0)
af_inet.c:561:		return -EAGAIN;
af_inet.c:562:	return sk->prot->connect(sk, (struct sockaddr *)uaddr, addr_len);
af_inet.c:570:	add_wait_queue(sk->sleep, &wait);
af_inet.c:572:	/* Basic assumption: if someone sets sk->err, he _must_
af_inet.c:577:	while ((1<<sk->state)&(TCPF_SYN_SENT|TCPF_SYN_RECV)) {
af_inet.c:586:	remove_wait_queue(sk->sleep, &wait);
af_inet.c:598:	struct sock *sk=sock->sk;
af_inet.c:604:	if (uaddr->sa_family == AF_UNSPEC) {
af_inet.c:605:		err = sk->prot->disconnect(sk, flags);
af_inet.c:606:		sock->state = err ? SS_DISCONNECTING : SS_UNCONNECTED;
af_inet.c:610:	switch (sock->state) {
af_inet.c:612:		err = -EINVAL;
af_inet.c:615:		err = -EISCONN;
af_inet.c:618:		err = -EALREADY;
af_inet.c:622:		err = -EISCONN;
af_inet.c:623:		if (sk->state != TCP_CLOSE) 
af_inet.c:626:		err = sk->prot->connect(sk, uaddr, addr_len);
af_inet.c:630:  		sock->state = SS_CONNECTING;
af_inet.c:633:		 * difference is that return value in non-blocking
af_inet.c:636:		err = -EINPROGRESS;
af_inet.c:642:	if ((1<<sk->state)&(TCPF_SYN_SENT|TCPF_SYN_RECV)) {
af_inet.c:655:	if (sk->state == TCP_CLOSE)
af_inet.c:658:	/* sk->err may be not zero now, if RECVERR was ordered by user
af_inet.c:663:	sock->state = SS_CONNECTED;
af_inet.c:670:	err = sock_error(sk) ? : -ECONNABORTED;
af_inet.c:671:	sock->state = SS_UNCONNECTED;
af_inet.c:672:	if (sk->prot->disconnect(sk, flags))
af_inet.c:673:		sock->state = SS_DISCONNECTING;
af_inet.c:683:	struct sock *sk1 = sock->sk;
af_inet.c:685:	int err = -EINVAL;
af_inet.c:687:	if((sk2 = sk1->prot->accept(sk1,flags,&err)) == NULL)
af_inet.c:692:	BUG_TRAP((1<<sk2->state)&(TCPF_ESTABLISHED|TCPF_CLOSE_WAIT|TCPF_CLOSE));
af_inet.c:696:	newsock->state = SS_CONNECTED;
af_inet.c:712:	struct sock *sk		= sock->sk;
af_inet.c:715:	sin->sin_family = AF_INET;
af_inet.c:717:		if (!sk->dport)
af_inet.c:718:			return -ENOTCONN;
af_inet.c:719:		if (((1<<sk->state)&(TCPF_CLOSE|TCPF_SYN_SENT)) && peer == 1)
af_inet.c:720:			return -ENOTCONN;
af_inet.c:721:		sin->sin_port = sk->dport;
af_inet.c:722:		sin->sin_addr.s_addr = sk->daddr;
af_inet.c:724:		__u32 addr = sk->rcv_saddr;
af_inet.c:726:			addr = sk->saddr;
af_inet.c:727:		sin->sin_port = sk->sport;
af_inet.c:728:		sin->sin_addr.s_addr = addr;
af_inet.c:739:	struct sock *sk = sock->sk;
af_inet.c:743:	err = sk->prot->recvmsg(sk, msg, size, flags&MSG_DONTWAIT,
af_inet.c:746:		msg->msg_namelen = addr_len;
af_inet.c:754:	struct sock *sk = sock->sk;
af_inet.c:757:	if (sk->num==0 && inet_autobind(sk) != 0)
af_inet.c:758:		return -EAGAIN;
af_inet.c:760:	return sk->prot->sendmsg(sk, msg, size);
af_inet.c:765:	struct sock *sk = sock->sk;
af_inet.c:771:	how++; /* maps 0->1 has the advantage of making bit 1 rcvs and
af_inet.c:772:		       1->2 bit 2 snds.
af_inet.c:773:		       2->3 */
af_inet.c:774:	if ((how & ~SHUTDOWN_MASK) || how==0)	/* MAXINT->0 */
af_inet.c:775:		return -EINVAL;
af_inet.c:778:	if (sock->state == SS_CONNECTING) {
af_inet.c:779:		if ((1<<sk->state)&(TCPF_SYN_SENT|TCPF_SYN_RECV|TCPF_CLOSE))
af_inet.c:780:			sock->state = SS_DISCONNECTING;
af_inet.c:782:			sock->state = SS_CONNECTED;
af_inet.c:785:	switch (sk->state) {
af_inet.c:787:		err = -ENOTCONN;
af_inet.c:789:		   POLLHUP, even on eg. unconnected UDP sockets -- RR */
af_inet.c:791:		sk->shutdown |= how;
af_inet.c:792:		if (sk->prot->shutdown)
af_inet.c:793:			sk->prot->shutdown(sk, how);
af_inet.c:805:		err = sk->prot->disconnect(sk, O_NONBLOCK);
af_inet.c:806:		sock->state = err ? SS_DISCONNECTING : SS_UNCONNECTED;
af_inet.c:811:	sk->state_change(sk);
af_inet.c:828:	struct sock *sk = sock->sk;
af_inet.c:838:			if (current->pid != pid && current->pgrp != -pid && 
af_inet.c:840:				return -EPERM;
af_inet.c:841:			sk->proc = pid;
af_inet.c:845:			return put_user(sk->proc, (int *)arg);
af_inet.c:847:			if(sk->stamp.tv_sec==0)
af_inet.c:848:				return -ENOENT;
af_inet.c:849:			err = copy_to_user((void *)arg,&sk->stamp,sizeof(struct timeval));
af_inet.c:851:				err = -EFAULT;
af_inet.c:883:			return -ENOPKG;
af_inet.c:895:			return -ENOPKG;
af_inet.c:902:			return -ENOPKG;
af_inet.c:928:			return -ENOPKG;
af_inet.c:940:			if (sk->prot->ioctl==NULL || (err=sk->prot->ioctl(sk, cmd, arg))==-ENOIOCTLCMD)
af_inet.c:1014:                capability:  -1,
af_inet.c:1024:                capability:  -1,
af_inet.c:1048:	int protocol = p->protocol;
af_inet.c:1053:	if (p->type > SOCK_MAX)
af_inet.c:1058:	last_perm = &inetsw[p->type];
af_inet.c:1059:	list_for_each(lh, &inetsw[p->type]) {
af_inet.c:1062:		/* Check only the non-wild match. */
af_inet.c:1063:		if (INET_PROTOSW_PERMANENT & answer->flags) {
af_inet.c:1064:			if (protocol == answer->protocol)
af_inet.c:1076:	 * a wild-card protocol. But it is allowed to override any existing
af_inet.c:1077:	 * non-permanent entry.  This means that when we remove this entry, the 
af_inet.c:1080:	list_add(&p->list, last_perm);
af_inet.c:1093:	       p->type);
af_inet.c:1100:	if (INET_PROTOSW_PERMANENT & p->flags) {
af_inet.c:1103:		       p->protocol);
af_inet.c:1106:		list_del(&p->list);
af_inet.c:1126:	if (sizeof(struct inet_skb_parm) > sizeof(dummy_skb->cb)) {
af_inet.c:1128:		return -EINVAL;
af_inet.c:1143:		struct inet_protocol *tmp = (struct inet_protocol *) p->next;
af_inet.c:1145:		printk("%s%s",p->name,tmp?", ":"\n");
af_inet.c:1149:	/* Register the socket-side information for inet_create. */
af_inet.c:1181:	   I had to move IPIP from net/ipv4/protocol.c :-( --ANK
arp.c:9: * high-level addresses) into a low-level hardware address (like an Ethernet
arp.c:33: *					re-arranged proxy handling.
arp.c:200:	switch (dev->type) {
arp.c:211:			memcpy(haddr, dev->broadcast, dev->addr_len);
arp.c:215:	return -EINVAL;
arp.c:227:	hash_val = (hash_val^dev->ifindex)&NEIGH_HASHMASK;
arp.c:234:	u32 addr = *(u32*)neigh->primary_key;
arp.c:235:	struct net_device *dev = neigh->dev;
arp.c:239:		return -EINVAL;
arp.c:241:	neigh->type = inet_addr_type(addr);
arp.c:242:	if (in_dev->arp_parms)
arp.c:243:		neigh->parms = in_dev->arp_parms;
arp.c:247:	if (dev->hard_header == NULL) {
arp.c:248:		neigh->nud_state = NUD_NOARP;
arp.c:249:		neigh->ops = &arp_direct_ops;
arp.c:250:		neigh->output = neigh->ops->queue_xmit;
arp.c:279:		switch (dev->type) {
arp.c:288:			neigh->ops = &arp_broken_ops;
arp.c:289:			neigh->output = neigh->ops->output;
arp.c:294:		if (neigh->type == RTN_MULTICAST) {
arp.c:295:			neigh->nud_state = NUD_NOARP;
arp.c:296:			arp_mc_map(addr, neigh->ha, dev, 1);
arp.c:297:		} else if (dev->flags&(IFF_NOARP|IFF_LOOPBACK)) {
arp.c:298:			neigh->nud_state = NUD_NOARP;
arp.c:299:			memcpy(neigh->ha, dev->dev_addr, dev->addr_len);
arp.c:300:		} else if (neigh->type == RTN_BROADCAST || dev->flags&IFF_POINTOPOINT) {
arp.c:301:			neigh->nud_state = NUD_NOARP;
arp.c:302:			memcpy(neigh->ha, dev->broadcast, dev->addr_len);
arp.c:304:		if (dev->hard_header_cache)
arp.c:305:			neigh->ops = &arp_hh_ops;
arp.c:307:			neigh->ops = &arp_generic_ops;
arp.c:308:		if (neigh->nud_state&NUD_VALID)
arp.c:309:			neigh->output = neigh->ops->connected_output;
arp.c:311:			neigh->output = neigh->ops->output;
arp.c:326:	struct net_device *dev = neigh->dev;
arp.c:327:	u32 target = *(u32*)neigh->primary_key;
arp.c:328:	int probes = atomic_read(&neigh->probes);
arp.c:337:		if (skb && inet_addr_type(skb->nh.iph->saddr) == RTN_LOCAL)
arp.c:338:			saddr = skb->nh.iph->saddr;
arp.c:343:		saddr = skb->nh.iph->saddr;
arp.c:360:	if ((probes -= neigh->parms->ucast_probes) < 0) {
arp.c:361:		if (!(neigh->nud_state&NUD_VALID))
arp.c:363:		dst_ha = neigh->ha;
arp.c:364:		read_lock_bh(&neigh->lock);
arp.c:365:	} else if ((probes -= neigh->parms->app_probes) < 0) {
arp.c:373:		 dst_ha, dev->dev_addr, NULL);
arp.c:375:		read_unlock_bh(&neigh->lock);
arp.c:422:	if (rt->u.dst.dev != dev) { 
arp.c:435: *	It is very UGLY routine: it DOES NOT use skb->dst->neighbour,
arp.c:436: *	even if it exists. It is supposed that skb->dev was mangled
arp.c:438: *	is allowed to use this function, it is scheduled to be removed. --ANK
arp.c:446:		memcpy(haddr, dev->dev_addr, dev->addr_len);
arp.c:452:		memcpy(haddr, dev->broadcast, dev->addr_len);
arp.c:461:	struct net_device *dev = skb->dev;
arp.c:465:	if (!skb->dst) {
arp.c:471:	paddr = ((struct rtable*)skb->dst)->rt_gateway;
arp.c:479:		n->used = jiffies;
arp.c:480:		if (n->nud_state&NUD_VALID || neigh_event_send(n, skb) == 0) {
arp.c:481:			read_lock_bh(&n->lock);
arp.c:482: 			memcpy(haddr, n->ha, dev->addr_len);
arp.c:483:			read_unlock_bh(&n->lock);
arp.c:497:	struct net_device *dev = dst->dev;
arp.c:498:	struct neighbour *n = dst->neighbour;
arp.c:501:		return -EINVAL;
arp.c:503:		u32 nexthop = ((struct rtable*)dst)->rt_gateway;
arp.c:504:		if (dev->flags&(IFF_LOOPBACK|IFF_POINTOPOINT))
arp.c:508:		    dev->type == ARPHRD_ATM ? clip_tbl_hook :
arp.c:513:		dst->neighbour = n;
arp.c:525:	int imi, omi = -1;
arp.c:532:	if (imi == -1)
arp.c:537:	if ((out_dev = in_dev_get(rt->u.dst.dev)) != NULL) {
arp.c:541:	return (omi != imi && omi != -1);
arp.c:565:	skb = alloc_skb(sizeof(struct arphdr)+ 2*(dev->addr_len+4)
arp.c:566:				+ dev->hard_header_len + 15, GFP_ATOMIC);
arp.c:570:	skb_reserve(skb, (dev->hard_header_len+15)&~15);
arp.c:571:	skb->nh.raw = skb->data;
arp.c:572:	arp = (struct arphdr *) skb_put(skb,sizeof(struct arphdr) + 2*(dev->addr_len+4));
arp.c:573:	skb->dev = dev;
arp.c:574:	skb->protocol = htons (ETH_P_ARP);
arp.c:576:		src_hw = dev->dev_addr;
arp.c:578:		dest_hw = dev->broadcast;
arp.c:583:	if (dev->hard_header &&
arp.c:584:	    dev->hard_header(skb,dev,ptype,dest_hw,src_hw,skb->len) < 0)
arp.c:597:	switch (dev->type) {
arp.c:599:		arp->ar_hrd = htons(dev->type);
arp.c:600:		arp->ar_pro = htons(ETH_P_IP);
arp.c:605:		arp->ar_hrd = htons(ARPHRD_AX25);
arp.c:606:		arp->ar_pro = htons(AX25_P_IP);
arp.c:611:		arp->ar_hrd = htons(ARPHRD_NETROM);
arp.c:612:		arp->ar_pro = htons(AX25_P_IP);
arp.c:619:		arp->ar_hrd = htons(ARPHRD_ETHER);
arp.c:620:		arp->ar_pro = htons(ETH_P_IP);
arp.c:625:		arp->ar_hrd = htons(ARPHRD_IEEE802);
arp.c:626:		arp->ar_pro = htons(ETH_P_IP);
arp.c:631:	arp->ar_hln = dev->addr_len;
arp.c:632:	arp->ar_pln = 4;
arp.c:633:	arp->ar_op = htons(type);
arp.c:637:	memcpy(arp_ptr, src_hw, dev->addr_len);
arp.c:638:	arp_ptr+=dev->addr_len;
arp.c:642:		memcpy(arp_ptr, target_hw, dev->addr_len);
arp.c:644:		memset(arp_ptr, 0, dev->addr_len);
arp.c:645:	arp_ptr+=dev->addr_len;
arp.c:661:	NF_HOOK(NF_ARP, NF_ARP_OUT, skb, NULL, skb->dev, dev_queue_xmit);
arp.c:678:	if (dev->flags&IFF_NOARP)
arp.c:692:	arp_rcv(skb, skb->dev, NULL);
arp.c:701:	struct net_device *dev = skb->dev;
arp.c:708:	u16 dev_type = dev->type;
arp.c:719:	arp = skb->nh.arph;
arp.c:724:		if (arp->ar_pro != htons(ETH_P_IP))
arp.c:726:		if (htons(dev_type) != arp->ar_hrd)
arp.c:735:		if (arp->ar_hrd != htons(ARPHRD_ETHER) &&
arp.c:736:		    arp->ar_hrd != htons(ARPHRD_IEEE802))
arp.c:738:		if (arp->ar_pro != htons(ETH_P_IP))
arp.c:748:		if (arp->ar_hrd != htons(ARPHRD_ETHER) &&
arp.c:749:		    arp->ar_hrd != htons(ARPHRD_IEEE802))
arp.c:751:		if (arp->ar_pro != htons(ETH_P_IP))
arp.c:762:		if (arp->ar_hrd != htons(ARPHRD_ETHER) &&
arp.c:763:		    arp->ar_hrd != htons(ARPHRD_IEEE802))
arp.c:765:		if (arp->ar_pro != htons(ETH_P_IP))
arp.c:776:		if (arp->ar_hrd != htons(ARPHRD_ETHER) &&
arp.c:777:		    arp->ar_hrd != htons(ARPHRD_IEEE802))
arp.c:779:		if (arp->ar_pro != htons(ETH_P_IP))
arp.c:785:		if (arp->ar_pro != htons(AX25_P_IP))
arp.c:787:		if (arp->ar_hrd != htons(ARPHRD_AX25))
arp.c:792:		if (arp->ar_pro != htons(AX25_P_IP))
arp.c:794:		if (arp->ar_hrd != htons(ARPHRD_NETROM))
arp.c:803:	if (arp->ar_op != htons(ARPOP_REPLY) &&
arp.c:804:	    arp->ar_op != htons(ARPOP_REQUEST))
arp.c:811:	arp_ptr += dev->addr_len;
arp.c:815:	arp_ptr += dev->addr_len;
arp.c:828:		sha = dev->broadcast;
arp.c:849:		if (arp->ar_op == htons(ARPOP_REQUEST) &&
arp.c:852:			arp_send(ARPOP_REPLY,ETH_P_ARP,tip,dev,tip,sha,dev->dev_addr,dev->dev_addr);
arp.c:856:	if (arp->ar_op == htons(ARPOP_REQUEST) &&
arp.c:859:		rt = (struct rtable*)skb->dst;
arp.c:860:		addr_type = rt->rt_type;
arp.c:872:					arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dev->dev_addr,sha);
arp.c:878:			if ((rt->rt_flags&RTCF_DNAT) ||
arp.c:879:			    (addr_type == RTN_UNICAST  && rt->u.dst.dev != dev &&
arp.c:885:				if (skb->stamp.tv_sec == 0 ||
arp.c:886:				    skb->pkt_type == PACKET_HOST ||
arp.c:887:				    in_dev->arp_parms->proxy_delay == 0) {
arp.c:888:					arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dev->dev_addr,sha);
arp.c:890:					pneigh_enqueue(&arp_tbl, in_dev->arp_parms, skb);
arp.c:909:	    arp->ar_op == htons(ARPOP_REPLY) &&
arp.c:911:		n = __neigh_lookup(&arp_tbl, &sip, dev, -1);
arp.c:918:		/* If several different ARP replies follows back-to-back,
arp.c:923:		if (jiffies - n->updated >= n->parms->locktime)
arp.c:929:		if (arp->ar_op != htons(ARPOP_REPLY) ||
arp.c:930:		    skb->pkt_type != PACKET_HOST)
arp.c:954:				 (2 * dev->addr_len) +
arp.c:958:	arp = skb->nh.arph;
arp.c:959:	if (arp->ar_hln != dev->addr_len ||
arp.c:960:	    dev->flags & IFF_NOARP ||
arp.c:961:	    skb->pkt_type == PACKET_OTHERHOST ||
arp.c:962:	    skb->pkt_type == PACKET_LOOPBACK ||
arp.c:963:	    arp->ar_pln != 4)
arp.c:987:	u32 ip = ((struct sockaddr_in *) &r->arp_pa)->sin_addr.s_addr;
arp.c:991:	if (r->arp_flags&ATF_PUBL) {
arp.c:992:		u32 mask = ((struct sockaddr_in *) &r->arp_netmask)->sin_addr.s_addr;
arp.c:994:			return -EINVAL;
arp.c:995:		if (!dev && (r->arp_flags & ATF_COM)) {
arp.c:996:			dev = dev_getbyhwaddr(r->arp_ha.sa_family, r->arp_ha.sa_data);
arp.c:998:				return -ENODEV;
arp.c:1002:				return -ENOBUFS;
arp.c:1010:			__in_dev_get(dev)->cnf.proxy_arp = 1;
arp.c:1013:		return -ENXIO;
arp.c:1016:	if (r->arp_flags & ATF_PERM)
arp.c:1017:		r->arp_flags |= ATF_COM;
arp.c:1022:		dev = rt->u.dst.dev;
arp.c:1025:			return -EINVAL;
arp.c:1027:	if (r->arp_ha.sa_family != dev->type)	
arp.c:1028:		return -EINVAL;
arp.c:1034:		if (r->arp_flags & ATF_PERM)
arp.c:1036:		err = neigh_update(neigh, (r->arp_flags&ATF_COM) ?
arp.c:1037:				   r->arp_ha.sa_data : NULL, state, 1, 0);
arp.c:1046:	if (neigh->nud_state&NUD_PERMANENT)
arp.c:1048:	else if (neigh->nud_state&NUD_VALID)
arp.c:1059:	u32 ip = ((struct sockaddr_in *) &r->arp_pa)->sin_addr.s_addr;
arp.c:1061:	int err = -ENXIO;
arp.c:1065:		read_lock_bh(&neigh->lock);
arp.c:1066:		memcpy(r->arp_ha.sa_data, neigh->ha, dev->addr_len);
arp.c:1067:		r->arp_flags = arp_state_to_flags(neigh);
arp.c:1068:		read_unlock_bh(&neigh->lock);
arp.c:1069:		r->arp_ha.sa_family = dev->type;
arp.c:1070:		strncpy(r->arp_dev, dev->name, sizeof(r->arp_dev));
arp.c:1080:	u32 ip = ((struct sockaddr_in *)&r->arp_pa)->sin_addr.s_addr;
arp.c:1083:	if (r->arp_flags & ATF_PUBL) {
arp.c:1084:		u32 mask = ((struct sockaddr_in *) &r->arp_netmask)->sin_addr.s_addr;
arp.c:1093:				__in_dev_get(dev)->cnf.proxy_arp = 0;
arp.c:1096:			return -ENXIO;
arp.c:1098:		return -EINVAL;
arp.c:1105:		dev = rt->u.dst.dev;
arp.c:1108:			return -EINVAL;
arp.c:1110:	err = -ENXIO;
arp.c:1113:		if (neigh->nud_state&~NUD_NOARP)
arp.c:1134:				return -EPERM;
arp.c:1138:				return -EFAULT;
arp.c:1141:			return -EINVAL;
arp.c:1145:		return -EPFNOSUPPORT;
arp.c:1149:		return -EINVAL;
arp.c:1151:		((struct sockaddr_in *)&r.arp_netmask)->sin_addr.s_addr=htonl(0xFFFFFFFFUL);
arp.c:1155:		err = -ENODEV;
arp.c:1161:			r.arp_ha.sa_family = dev->type;
arp.c:1162:		err = -EINVAL;
arp.c:1163:		if ((r.arp_flags & ATF_COM) && r.arp_ha.sa_family != dev->type)
arp.c:1166:		err = -ENODEV;
arp.c:1180:			err = -EFAULT;
arp.c:1216:		for (n=arp_tbl.hash_buckets[i]; n; n=n->next) {
arp.c:1217:			struct net_device *dev = n->dev;
arp.c:1218:			int hatype = dev->type;
arp.c:1220:			/* Do not confuse users "arp -a" with magic entries */
arp.c:1221:			if (!(n->nud_state&~NUD_NOARP))
arp.c:1224:			read_lock(&n->lock);
arp.c:1231:				ax2asc2((ax25_address *)n->ha, hbuffer);
arp.c:1234:			for (k=0,j=0;k<HBUFFERLEN-3 && j<dev->addr_len;j++) {
arp.c:1235:				hbuffer[k++]=hexbuf[(n->ha[j]>>4)&15 ];
arp.c:1236:				hbuffer[k++]=hexbuf[n->ha[j]&15     ];
arp.c:1239:			hbuffer[--k]=0;
arp.c:1247:				sprintf(tbuf, "%u.%u.%u.%u", NIPQUAD(*(u32*)n->primary_key));
arp.c:1248:				size = sprintf(buffer+len, "%-16s 0x%-10x0x%-10x%s"
arp.c:1254:					dev->name);
arp.c:1257:			read_unlock(&n->lock);
arp.c:1274:		for (n=arp_tbl.phash_buckets[i]; n; n=n->next) {
arp.c:1275:			struct net_device *dev = n->dev;
arp.c:1276:			int hatype = dev ? dev->type : 0;
arp.c:1280:				sprintf(tbuf, "%u.%u.%u.%u", NIPQUAD(*(u32*)n->key));
arp.c:1281:				size = sprintf(buffer+len, "%-16s 0x%-10x0x%-10x%s"
arp.c:1287:					dev ? dev->name : "*");
arp.c:1302:	*start = buffer+len-(pos-offset);	/* Start of wanted data */
arp.c:1303:	len = pos-offset;			/* Start slop */
arp.c:1371: *	ax25 -> ASCII conversion
arp.c:1379:		c = (a->ax25_call[n] >> 1) & 0x7F;
arp.c:1384:	*s++ = '-';
arp.c:1386:	if ((n = ((a->ax25_call[6] >> 1) & 0x0F)) > 9) {
arp.c:1388:		n -= 10;
arp.c:1394:	if (*buf == '\0' || *buf == '-')
devinet.c:98:	if (ifa->ifa_dev)
devinet.c:99:		__in_dev_put(ifa->ifa_dev);
devinet.c:101:	inet_ifa_count--;
devinet.c:106:	struct net_device *dev = idev->dev;
devinet.c:108:	BUG_TRAP(idev->ifa_list==NULL);
devinet.c:109:	BUG_TRAP(idev->mc_list==NULL);
devinet.c:111:	printk(KERN_DEBUG "in_dev_finish_destroy: %p=%s\n", idev, dev ? dev->name : "NIL");
devinet.c:114:	if (!idev->dead) {
devinet.c:118:	inet_dev_count--;
devinet.c:132:	in_dev->lock = RW_LOCK_UNLOCKED;
devinet.c:133:	memcpy(&in_dev->cnf, &ipv4_devconf_dflt, sizeof(in_dev->cnf));
devinet.c:134:	in_dev->cnf.sysctl = NULL;
devinet.c:135:	in_dev->dev = dev;
devinet.c:136:	if ((in_dev->arp_parms = neigh_parms_alloc(dev, &arp_tbl)) == NULL) {
devinet.c:141:	/* Reference in_dev->dev */
devinet.c:144:	neigh_sysctl_register(dev, in_dev->arp_parms, NET_IPV4, NET_IPV4_NEIGH, "ipv4");
devinet.c:147:	dev->ip_ptr = in_dev;
devinet.c:148:	/* Account for reference dev->ip_ptr */
devinet.c:152:	devinet_sysctl_register(in_dev, &in_dev->cnf);
devinet.c:155:	if (dev->flags & IFF_UP)
devinet.c:166:	in_dev->dead = 1;
devinet.c:170:	while ((ifa = in_dev->ifa_list) != NULL) {
devinet.c:171:		inet_del_ifa(in_dev, &in_dev->ifa_list, 0);
devinet.c:176:	devinet_sysctl_unregister(&in_dev->cnf);
devinet.c:179:	in_dev->dev->ip_ptr = NULL;
devinet.c:184:	neigh_parms_release(&arp_tbl, in_dev->arp_parms);
devinet.c:190:	read_lock(&in_dev->lock);
devinet.c:194:				read_unlock(&in_dev->lock);
devinet.c:199:	read_unlock(&in_dev->lock);
devinet.c:212:	if (!(ifa1->ifa_flags&IFA_F_SECONDARY)) {
devinet.c:214:		struct in_ifaddr **ifap1 = &ifa1->ifa_next;
devinet.c:217:			if (!(ifa->ifa_flags&IFA_F_SECONDARY) ||
devinet.c:218:			    ifa1->ifa_mask != ifa->ifa_mask ||
devinet.c:219:			    !inet_ifa_match(ifa1->ifa_address, ifa)) {
devinet.c:220:				ifap1 = &ifa->ifa_next;
devinet.c:223:			write_lock_bh(&in_dev->lock);
devinet.c:224:			*ifap1 = ifa->ifa_next;
devinet.c:225:			write_unlock_bh(&in_dev->lock);
devinet.c:235:	write_lock_bh(&in_dev->lock);
devinet.c:236:	*ifap = ifa1->ifa_next;
devinet.c:237:	write_unlock_bh(&in_dev->lock);
devinet.c:254:		if (in_dev->ifa_list == NULL)
devinet.c:262:	struct in_device *in_dev = ifa->ifa_dev;
devinet.c:267:	if (ifa->ifa_local == 0) {
devinet.c:272:	ifa->ifa_flags &= ~IFA_F_SECONDARY;
devinet.c:273:	last_primary = &in_dev->ifa_list;
devinet.c:275:	for (ifap=&in_dev->ifa_list; (ifa1=*ifap)!=NULL; ifap=&ifa1->ifa_next) {
devinet.c:276:		if (!(ifa1->ifa_flags&IFA_F_SECONDARY) && ifa->ifa_scope <= ifa1->ifa_scope)
devinet.c:277:			last_primary = &ifa1->ifa_next;
devinet.c:278:		if (ifa1->ifa_mask == ifa->ifa_mask && inet_ifa_match(ifa1->ifa_address, ifa)) {
devinet.c:279:			if (ifa1->ifa_local == ifa->ifa_local) {
devinet.c:281:				return -EEXIST;
devinet.c:283:			if (ifa1->ifa_scope != ifa->ifa_scope) {
devinet.c:285:				return -EINVAL;
devinet.c:287:			ifa->ifa_flags |= IFA_F_SECONDARY;
devinet.c:291:	if (!(ifa->ifa_flags&IFA_F_SECONDARY)) {
devinet.c:292:		net_srandom(ifa->ifa_local);
devinet.c:296:	ifa->ifa_next = *ifap;
devinet.c:297:	write_lock_bh(&in_dev->lock);
devinet.c:299:	write_unlock_bh(&in_dev->lock);
devinet.c:321:			return -ENOBUFS;
devinet.c:324:	if (ifa->ifa_dev != in_dev) {
devinet.c:325:		BUG_TRAP(ifa->ifa_dev==NULL);
devinet.c:327:		ifa->ifa_dev=in_dev;
devinet.c:329:	if (LOOPBACK(ifa->ifa_local))
devinet.c:330:		ifa->ifa_scope = RT_SCOPE_HOST;
devinet.c:353:		if (ifa->ifa_mask == mask && inet_ifa_match(prefix, ifa))
devinet.c:369:	if ((in_dev = inetdev_by_index(ifm->ifa_index)) == NULL)
devinet.c:370:		return -EADDRNOTAVAIL;
devinet.c:373:	for (ifap=&in_dev->ifa_list; (ifa=*ifap)!=NULL; ifap=&ifa->ifa_next) {
devinet.c:374:		if ((rta[IFA_LOCAL-1] && memcmp(RTA_DATA(rta[IFA_LOCAL-1]), &ifa->ifa_local, 4)) ||
devinet.c:375:		    (rta[IFA_LABEL-1] && strcmp(RTA_DATA(rta[IFA_LABEL-1]), ifa->ifa_label)) ||
devinet.c:376:		    (rta[IFA_ADDRESS-1] &&
devinet.c:377:		     (ifm->ifa_prefixlen != ifa->ifa_prefixlen ||
devinet.c:378:		      !inet_ifa_match(*(u32*)RTA_DATA(rta[IFA_ADDRESS-1]), ifa))))
devinet.c:384:	return -EADDRNOTAVAIL;
devinet.c:398:	if (ifm->ifa_prefixlen > 32 || rta[IFA_LOCAL-1] == NULL)
devinet.c:399:		return -EINVAL;
devinet.c:401:	if ((dev = __dev_get_by_index(ifm->ifa_index)) == NULL)
devinet.c:402:		return -ENODEV;
devinet.c:407:			return -ENOBUFS;
devinet.c:411:		return -ENOBUFS;
devinet.c:413:	if (rta[IFA_ADDRESS-1] == NULL)
devinet.c:414:		rta[IFA_ADDRESS-1] = rta[IFA_LOCAL-1];
devinet.c:415:	memcpy(&ifa->ifa_local, RTA_DATA(rta[IFA_LOCAL-1]), 4);
devinet.c:416:	memcpy(&ifa->ifa_address, RTA_DATA(rta[IFA_ADDRESS-1]), 4);
devinet.c:417:	ifa->ifa_prefixlen = ifm->ifa_prefixlen;
devinet.c:418:	ifa->ifa_mask = inet_make_mask(ifm->ifa_prefixlen);
devinet.c:419:	if (rta[IFA_BROADCAST-1])
devinet.c:420:		memcpy(&ifa->ifa_broadcast, RTA_DATA(rta[IFA_BROADCAST-1]), 4);
devinet.c:421:	if (rta[IFA_ANYCAST-1])
devinet.c:422:		memcpy(&ifa->ifa_anycast, RTA_DATA(rta[IFA_ANYCAST-1]), 4);
devinet.c:423:	ifa->ifa_flags = ifm->ifa_flags;
devinet.c:424:	ifa->ifa_scope = ifm->ifa_scope;
devinet.c:426:	ifa->ifa_dev = in_dev;
devinet.c:427:	if (rta[IFA_LABEL-1])
devinet.c:428:		memcpy(ifa->ifa_label, RTA_DATA(rta[IFA_LABEL-1]), IFNAMSIZ);
devinet.c:430:		memcpy(ifa->ifa_label, dev->name, IFNAMSIZ);
devinet.c:456:  	return -1;
devinet.c:478:		return -EFAULT;
devinet.c:479:	ifr.ifr_name[IFNAMSIZ-1] = 0;
devinet.c:503:		sin->sin_family = AF_INET;
devinet.c:508:			return -EACCES;
devinet.c:515:			return -EACCES;
devinet.c:516:		if (sin->sin_family != AF_INET)
devinet.c:517:			return -EINVAL;
devinet.c:520:		return -EINVAL;
devinet.c:527:		ret = -ENODEV;
devinet.c:541:			for (ifap=&in_dev->ifa_list; (ifa=*ifap) != NULL; ifap=&ifa->ifa_next) {
devinet.c:542:				if ((strcmp(ifr.ifr_name, ifa->ifa_label) == 0)
devinet.c:543:				    && (sin_orig.sin_addr.s_addr == ifa->ifa_address)) {
devinet.c:549:		   4.3BSD-style and passed in junk so we fall back to 
devinet.c:552:			for (ifap=&in_dev->ifa_list; (ifa=*ifap) != NULL; ifap=&ifa->ifa_next)
devinet.c:553:				if (strcmp(ifr.ifr_name, ifa->ifa_label) == 0)
devinet.c:559:		ret = -EADDRNOTAVAIL;
devinet.c:565:			sin->sin_addr.s_addr = ifa->ifa_local;
devinet.c:569:			sin->sin_addr.s_addr = ifa->ifa_broadcast;
devinet.c:573:			sin->sin_addr.s_addr = ifa->ifa_address;
devinet.c:577:			sin->sin_addr.s_addr = ifa->ifa_mask;
devinet.c:583:					ret = -EADDRNOTAVAIL;
devinet.c:594:			if (inet_abc_len(sin->sin_addr.s_addr) < 0) {
devinet.c:595:				ret = -EINVAL;
devinet.c:601:					ret = -ENOBUFS;
devinet.c:605:					memcpy(ifa->ifa_label, ifr.ifr_name, IFNAMSIZ);
devinet.c:607:					memcpy(ifa->ifa_label, dev->name, IFNAMSIZ);
devinet.c:610:				if (ifa->ifa_local == sin->sin_addr.s_addr)
devinet.c:613:				ifa->ifa_broadcast = 0;
devinet.c:614:				ifa->ifa_anycast = 0;
devinet.c:617:			ifa->ifa_address =
devinet.c:618:			ifa->ifa_local = sin->sin_addr.s_addr;
devinet.c:620:			if (!(dev->flags&IFF_POINTOPOINT)) {
devinet.c:621:				ifa->ifa_prefixlen = inet_abc_len(ifa->ifa_address);
devinet.c:622:				ifa->ifa_mask = inet_make_mask(ifa->ifa_prefixlen);
devinet.c:623:				if ((dev->flags&IFF_BROADCAST) && ifa->ifa_prefixlen < 31)
devinet.c:624:					ifa->ifa_broadcast = ifa->ifa_address|~ifa->ifa_mask;
devinet.c:626:				ifa->ifa_prefixlen = 32;
devinet.c:627:				ifa->ifa_mask = inet_make_mask(32);
devinet.c:633:			if (ifa->ifa_broadcast != sin->sin_addr.s_addr) {
devinet.c:635:				ifa->ifa_broadcast = sin->sin_addr.s_addr;
devinet.c:641:			if (ifa->ifa_address != sin->sin_addr.s_addr) {
devinet.c:642:				if (inet_abc_len(sin->sin_addr.s_addr) < 0) {
devinet.c:643:					ret = -EINVAL;
devinet.c:647:				ifa->ifa_address = sin->sin_addr.s_addr;
devinet.c:657:			if (bad_mask(sin->sin_addr.s_addr, 0)) {
devinet.c:658:				ret = -EINVAL;
devinet.c:662:			if (ifa->ifa_mask != sin->sin_addr.s_addr) {
devinet.c:664:				ifa->ifa_mask = sin->sin_addr.s_addr;
devinet.c:665:				ifa->ifa_prefixlen = inet_mask_len(ifa->ifa_mask);
devinet.c:679:		return -EFAULT;
devinet.c:691:	if (in_dev==NULL || (ifa=in_dev->ifa_list)==NULL)
devinet.c:694:	for ( ; ifa; ifa = ifa->ifa_next) {
devinet.c:702:		if (ifa->ifa_label)
devinet.c:703:			strcpy(ifr.ifr_name, ifa->ifa_label);
devinet.c:705:			strcpy(ifr.ifr_name, dev->name);
devinet.c:708:		(*(struct sockaddr_in *) &ifr.ifr_addr).sin_addr.s_addr = ifa->ifa_local;
devinet.c:711:			return -EFAULT;
devinet.c:713:		len -= sizeof(struct ifreq);
devinet.c:731:	read_lock(&in_dev->lock);
devinet.c:733:		if (ifa->ifa_scope > scope)
devinet.c:736:			addr = ifa->ifa_local;
devinet.c:740:			addr = ifa->ifa_local;
devinet.c:742:	read_unlock(&in_dev->lock);
devinet.c:754:	for (dev=dev_base; dev; dev=dev->next) {
devinet.c:758:		read_lock(&in_dev->lock);
devinet.c:760:			if (ifa->ifa_scope != RT_SCOPE_LINK &&
devinet.c:761:			    ifa->ifa_scope <= scope) {
devinet.c:762:				read_unlock(&in_dev->lock);
devinet.c:765:				return ifa->ifa_local;
devinet.c:768:		read_unlock(&in_dev->lock);
devinet.c:784:		    (local == ifa->ifa_local || !local) &&
devinet.c:785:		    ifa->ifa_scope <= scope) {
devinet.c:786:			addr = ifa->ifa_local;
devinet.c:800:				if (ifa->ifa_scope <= scope) {
devinet.c:801:					addr = ifa->ifa_local;
devinet.c:815: * - dev: only on this interface, 0=any interface
devinet.c:816: * - dst: only in the same subnet as dst, 0=any dst
devinet.c:817: * - local: address, 0=autoselect the local address
devinet.c:818: * - scope: maximum allowed scope value for the local address
devinet.c:828:			read_lock(&in_dev->lock);
devinet.c:830:			read_unlock(&in_dev->lock);
devinet.c:839:	for (dev = dev_base; dev; dev = dev->next) {
devinet.c:841:			read_lock(&in_dev->lock);
devinet.c:843:			read_unlock(&in_dev->lock);
devinet.c:876:	for (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next) { 
devinet.c:879:		memcpy(old, ifa->ifa_label, IFNAMSIZ);
devinet.c:880:		memcpy(ifa->ifa_label, dev->name, IFNAMSIZ); 
devinet.c:883:		dot = strchr(ifa->ifa_label, ':');
devinet.c:888:		if (strlen(dot) + strlen(dev->name) < IFNAMSIZ) { 
devinet.c:889:			strcat(ifa->ifa_label, dot); 
devinet.c:891:			strcpy(ifa->ifa_label + (IFNAMSIZ - strlen(dot) - 1), dot); 
devinet.c:911:		dev->ip_ptr = NULL;
devinet.c:914:		if (dev->mtu < 68)
devinet.c:919:				ifa->ifa_local =
devinet.c:920:				ifa->ifa_address = htonl(INADDR_LOOPBACK);
devinet.c:921:				ifa->ifa_prefixlen = 8;
devinet.c:922:				ifa->ifa_mask = inet_make_mask(8);
devinet.c:924:				ifa->ifa_dev = in_dev;
devinet.c:925:				ifa->ifa_scope = RT_SCOPE_HOST;
devinet.c:926:				memcpy(ifa->ifa_label, dev->name, IFNAMSIZ);
devinet.c:936:		if (dev->mtu >= 68)
devinet.c:962:	unsigned char	 *b = skb->tail;
devinet.c:965:	if (pid) nlh->nlmsg_flags |= NLM_F_MULTI;
devinet.c:967:	ifm->ifa_family = AF_INET;
devinet.c:968:	ifm->ifa_prefixlen = ifa->ifa_prefixlen;
devinet.c:969:	ifm->ifa_flags = ifa->ifa_flags|IFA_F_PERMANENT;
devinet.c:970:	ifm->ifa_scope = ifa->ifa_scope;
devinet.c:971:	ifm->ifa_index = ifa->ifa_dev->dev->ifindex;
devinet.c:972:	if (ifa->ifa_address)
devinet.c:973:		RTA_PUT(skb, IFA_ADDRESS, 4, &ifa->ifa_address);
devinet.c:974:	if (ifa->ifa_local)
devinet.c:975:		RTA_PUT(skb, IFA_LOCAL, 4, &ifa->ifa_local);
devinet.c:976:	if (ifa->ifa_broadcast)
devinet.c:977:		RTA_PUT(skb, IFA_BROADCAST, 4, &ifa->ifa_broadcast);
devinet.c:978:	if (ifa->ifa_anycast)
devinet.c:979:		RTA_PUT(skb, IFA_ANYCAST, 4, &ifa->ifa_anycast);
devinet.c:980:	if (ifa->ifa_label[0])
devinet.c:981:		RTA_PUT(skb, IFA_LABEL, IFNAMSIZ, &ifa->ifa_label);
devinet.c:982:	nlh->nlmsg_len = skb->tail - b;
devinet.c:983:	return skb->len;
devinet.c:987:	skb_trim(skb, b - skb->data);
devinet.c:988:	return -1;
devinet.c:999:	s_idx = cb->args[0];
devinet.c:1000:	s_ip_idx = ip_idx = cb->args[1];
devinet.c:1002:	for (dev=dev_base, idx=0; dev; dev = dev->next, idx++) {
devinet.c:1012:		read_lock(&in_dev->lock);
devinet.c:1013:		for (ifa = in_dev->ifa_list, ip_idx = 0; ifa;
devinet.c:1014:		     ifa = ifa->ifa_next, ip_idx++) {
devinet.c:1017:			if (inet_fill_ifaddr(skb, ifa, NETLINK_CB(cb->skb).pid,
devinet.c:1018:					     cb->nlh->nlmsg_seq, RTM_NEWADDR) <= 0) {
devinet.c:1019:				read_unlock(&in_dev->lock);
devinet.c:1024:		read_unlock(&in_dev->lock);
devinet.c:1030:	cb->args[0] = idx;
devinet.c:1031:	cb->args[1] = ip_idx;
devinet.c:1033:	return skb->len;
devinet.c:1056:static struct rtnetlink_link inet_rtnetlink_table[RTM_MAX-RTM_BASE+1] =
devinet.c:1102:	for (dev = dev_base; dev; dev = dev->next) {
devinet.c:1107:			in_dev->cnf.forwarding = on;
devinet.c:1119:	int *valp = ctl->data;
devinet.c:1207:	struct net_device *dev = in_dev ? in_dev->dev : NULL;
devinet.c:1214:	for (i=0; i<sizeof(t->devinet_vars)/sizeof(t->devinet_vars[0])-1; i++) {
devinet.c:1215:		t->devinet_vars[i].data += (char*)p - (char*)&ipv4_devconf;
devinet.c:1216:		t->devinet_vars[i].de = NULL;
devinet.c:1219:		t->devinet_dev[0].procname = dev->name;
devinet.c:1220:		t->devinet_dev[0].ctl_name = dev->ifindex;
devinet.c:1222:		t->devinet_dev[0].procname = "default";
devinet.c:1223:		t->devinet_dev[0].ctl_name = NET_PROTO_CONF_DEFAULT;
devinet.c:1225:	t->devinet_dev[0].child = t->devinet_vars;
devinet.c:1226:	t->devinet_dev[0].de = NULL;
devinet.c:1227:	t->devinet_conf_dir[0].child = t->devinet_dev;
devinet.c:1228:	t->devinet_conf_dir[0].de = NULL;
devinet.c:1229:	t->devinet_proto_dir[0].child = t->devinet_conf_dir;
devinet.c:1230:	t->devinet_proto_dir[0].de = NULL;
devinet.c:1231:	t->devinet_root_dir[0].child = t->devinet_proto_dir;
devinet.c:1232:	t->devinet_root_dir[0].de = NULL;
devinet.c:1234:	t->sysctl_header = register_sysctl_table(t->devinet_root_dir, 0);
devinet.c:1235:	if (t->sysctl_header == NULL)
devinet.c:1238:		p->sysctl = t;
devinet.c:1243:	if (p->sysctl) {
devinet.c:1244:		struct devinet_sysctl_table *t = p->sysctl;
devinet.c:1245:		p->sysctl = NULL;
devinet.c:1246:		unregister_sysctl_table(t->sysctl_header);
fib_frontend.c:85:	for (id = RT_TABLE_MAX; id>0; id--) {
fib_frontend.c:88:		flushed += tb->tb_flush(tb);
fib_frontend.c:91:	flushed += main_table->tb_flush(main_table);
fib_frontend.c:92:	flushed += local_table->tb_flush(local_table);
fib_frontend.c:96:		rt_cache_flush(-1);
fib_frontend.c:119:	if (--first < 0) {
fib_frontend.c:120:		sprintf(buffer, "%-127s\n", "Iface\tDestination\tGateway \tFlags\tRefCnt\tUse\tMetric\tMask\t\tMTU\tWindow\tIRTT");
fib_frontend.c:121:		--count;
fib_frontend.c:127:		int n = main_table->tb_get_info(main_table, ptr, first, count);
fib_frontend.c:128:		count -= n;
fib_frontend.c:131:	len = ptr - *start;
fib_frontend.c:157:	if (!local_table || local_table->tb_lookup(local_table, &key, &res)) {
fib_frontend.c:190:		if (local_table->tb_lookup(local_table, &key, &res) == 0) {
fib_frontend.c:199:   - (main) check, that source is valid i.e. not broadcast or our local
fib_frontend.c:201:   - figure out what "logical" interface this packet arrived
fib_frontend.c:203:   - check, that packet arrived from expected physical interface.
fib_frontend.c:226:		no_addr = in_dev->ifa_list == NULL;
fib_frontend.c:241:	if (FIB_RES_DEV(res) == dev || res.fi->fib_nhs > 1)
fib_frontend.c:255:	key.oif = dev->ifindex;
fib_frontend.c:277:	return -EINVAL;
fib_frontend.c:300:			return -EPERM;
fib_frontend.c:302:			return -EFAULT;
fib_frontend.c:308:				err = -ESRCH;
fib_frontend.c:310:					err = tb->tb_delete(tb, &req.rtm, &rta, &req.nlh, NULL);
fib_frontend.c:313:				err = -ENOBUFS;
fib_frontend.c:315:					err = tb->tb_insert(tb, &req.rtm, &rta, &req.nlh, NULL);
fib_frontend.c:323:	return -EINVAL;
fib_frontend.c:330:	return -EINVAL;
fib_frontend.c:340:		struct rtattr *attr = rta[i-1];
fib_frontend.c:343:				return -EINVAL;
fib_frontend.c:345:				rta[i-1] = (struct rtattr*)RTA_DATA(attr);
fib_frontend.c:358:		return -EINVAL;
fib_frontend.c:360:	tb = fib_get_table(r->rtm_table);
fib_frontend.c:362:		return tb->tb_delete(tb, r, (struct kern_rta*)rta, nlh, &NETLINK_CB(skb));
fib_frontend.c:363:	return -ESRCH;
fib_frontend.c:373:		return -EINVAL;
fib_frontend.c:375:	tb = fib_new_table(r->rtm_table);
fib_frontend.c:377:		return tb->tb_insert(tb, r, (struct kern_rta*)rta, nlh, &NETLINK_CB(skb));
fib_frontend.c:378:	return -ENOBUFS;
fib_frontend.c:387:	if (NLMSG_PAYLOAD(cb->nlh, 0) >= sizeof(struct rtmsg) &&
fib_frontend.c:388:	    ((struct rtmsg*)NLMSG_DATA(cb->nlh))->rtm_flags&RTM_F_CLONED)
fib_frontend.c:391:	s_t = cb->args[0];
fib_frontend.c:393:		s_t = cb->args[0] = RT_TABLE_MIN;
fib_frontend.c:398:			memset(&cb->args[1], 0, sizeof(cb->args)-sizeof(cb->args[0]));
fib_frontend.c:401:		if (tb->tb_dump(tb, skb, cb) < 0) 
fib_frontend.c:405:	cb->args[0] = t;
fib_frontend.c:407:	return skb->len;
fib_frontend.c:410:/* Prepare and feed intra-kernel routing request.
fib_frontend.c:411:   Really, it should be netlink message, but :-( netlink
fib_frontend.c:444:	req.rtm.rtm_table = tb->tb_id;
fib_frontend.c:450:	rta.rta_prefsrc = &ifa->ifa_local;
fib_frontend.c:451:	rta.rta_oif = &ifa->ifa_dev->dev->ifindex;
fib_frontend.c:454:		tb->tb_insert(tb, &req.rtm, &rta, &req.nlh, NULL);
fib_frontend.c:456:		tb->tb_delete(tb, &req.rtm, &rta, &req.nlh, NULL);
fib_frontend.c:461:	struct in_device *in_dev = ifa->ifa_dev;
fib_frontend.c:462:	struct net_device *dev = in_dev->dev;
fib_frontend.c:464:	u32 mask = ifa->ifa_mask;
fib_frontend.c:465:	u32 addr = ifa->ifa_local;
fib_frontend.c:466:	u32 prefix = ifa->ifa_address&mask;
fib_frontend.c:468:	if (ifa->ifa_flags&IFA_F_SECONDARY) {
fib_frontend.c:478:	if (!(dev->flags&IFF_UP))
fib_frontend.c:482:	if (ifa->ifa_broadcast && ifa->ifa_broadcast != 0xFFFFFFFF)
fib_frontend.c:483:		fib_magic(RTM_NEWROUTE, RTN_BROADCAST, ifa->ifa_broadcast, 32, prim);
fib_frontend.c:485:	if (!ZERONET(prefix) && !(ifa->ifa_flags&IFA_F_SECONDARY) &&
fib_frontend.c:486:	    (prefix != addr || ifa->ifa_prefixlen < 32)) {
fib_frontend.c:487:		fib_magic(RTM_NEWROUTE, dev->flags&IFF_LOOPBACK ? RTN_LOCAL :
fib_frontend.c:488:			  RTN_UNICAST, prefix, ifa->ifa_prefixlen, prim);
fib_frontend.c:491:		if (ifa->ifa_prefixlen < 31) {
fib_frontend.c:500:	struct in_device *in_dev = ifa->ifa_dev;
fib_frontend.c:501:	struct net_device *dev = in_dev->dev;
fib_frontend.c:504:	u32 brd = ifa->ifa_address|~ifa->ifa_mask;
fib_frontend.c:505:	u32 any = ifa->ifa_address&ifa->ifa_mask;
fib_frontend.c:512:	if (!(ifa->ifa_flags&IFA_F_SECONDARY))
fib_frontend.c:513:		fib_magic(RTM_DELROUTE, dev->flags&IFF_LOOPBACK ? RTN_LOCAL :
fib_frontend.c:514:			  RTN_UNICAST, any, ifa->ifa_prefixlen, prim);
fib_frontend.c:516:		prim = inet_ifa_byprefix(in_dev, any, ifa->ifa_mask);
fib_frontend.c:524:	   We should take care of not to delete too much :-)
fib_frontend.c:529:	for (ifa1 = in_dev->ifa_list; ifa1; ifa1 = ifa1->ifa_next) {
fib_frontend.c:530:		if (ifa->ifa_local == ifa1->ifa_local)
fib_frontend.c:532:		if (ifa->ifa_broadcast == ifa1->ifa_broadcast)
fib_frontend.c:534:		if (brd == ifa1->ifa_broadcast)
fib_frontend.c:536:		if (any == ifa1->ifa_broadcast)
fib_frontend.c:541:		fib_magic(RTM_DELROUTE, RTN_BROADCAST, ifa->ifa_broadcast, 32, prim);
fib_frontend.c:547:		fib_magic(RTM_DELROUTE, RTN_LOCAL, ifa->ifa_local, 32, prim);
fib_frontend.c:550:		if (inet_addr_type(ifa->ifa_local) != RTN_LOCAL) {
fib_frontend.c:557:			if (fib_sync_down(ifa->ifa_local, NULL, 0))
fib_frontend.c:583:		fib_sync_up(ifa->ifa_dev->dev);
fib_frontend.c:585:		rt_cache_flush(-1);
fib_frontend.c:589:		if (ifa->ifa_dev && ifa->ifa_dev->ifa_list == NULL) {
fib_frontend.c:593:			fib_disable_ip(ifa->ifa_dev->dev, 1);
fib_frontend.c:595:			rt_cache_flush(-1);
fib_frontend.c:623:		rt_cache_flush(-1);
fib_hash.c:72:#define FIB_INFO(f)	((f)->fn_info)
fib_hash.c:92:	u32		fz_hashmask;	/* (fz_divisor - 1)	*/
fib_hash.c:93:#define FZ_HASHMASK(fz)	((fz)->fz_hashmask)
fib_hash.c:97:#define FZ_MASK(fz)	((fz)->fz_mask)
fib_hash.c:112:	u32 h = ntohl(key.datum)>>(32 - fz->fz_order);
fib_hash.c:132:	return &fz->fz_hash[fn_hash(key, fz).datum];
fib_hash.c:137:	return fz->fz_hash[fn_hash(key, fz).datum];
fib_hash.c:176:			next = f->fn_next;
fib_hash.c:177:			for (fp = fz_chain_p(f->fn_key, fz);
fib_hash.c:178:			     *fp && fn_key_leq((*fp)->fn_key, f->fn_key);
fib_hash.c:179:			     fp = &(*fp)->fn_next)
fib_hash.c:181:			f->fn_next = *fp;
fib_hash.c:202:	old_divisor = fz->fz_divisor;
fib_hash.c:220:	new_hashmask = (new_divisor - 1);
fib_hash.c:223:	printk("fn_rehash_zone: hash for zone %d grows from %d\n", fz->fz_order, old_divisor);
fib_hash.c:232:		old_ht = fz->fz_hash;
fib_hash.c:233:		fz->fz_hash = ht;
fib_hash.c:234:		fz->fz_hashmask = new_hashmask;
fib_hash.c:235:		fz->fz_divisor = new_divisor;
fib_hash.c:260:		fz->fz_divisor = 16;
fib_hash.c:262:		fz->fz_divisor = 1;
fib_hash.c:264:	fz->fz_hashmask = (fz->fz_divisor - 1);
fib_hash.c:265:	fz->fz_hash = fz_hash_alloc(fz->fz_divisor);
fib_hash.c:266:	if (!fz->fz_hash) {
fib_hash.c:270:	memset(fz->fz_hash, 0, fz->fz_divisor*sizeof(struct fib_node*));
fib_hash.c:271:	fz->fz_order = z;
fib_hash.c:272:	fz->fz_mask = inet_make_mask(z);
fib_hash.c:276:		if (table->fn_zones[i])
fib_hash.c:281:		fz->fz_next = table->fn_zone_list;
fib_hash.c:282:		table->fn_zone_list = fz;
fib_hash.c:284:		fz->fz_next = table->fn_zones[i]->fz_next;
fib_hash.c:285:		table->fn_zones[i]->fz_next = fz;
fib_hash.c:287:	table->fn_zones[z] = fz;
fib_hash.c:297:	struct fn_hash *t = (struct fn_hash*)tb->tb_data;
fib_hash.c:300:	for (fz = t->fn_zone_list; fz; fz = fz->fz_next) {
fib_hash.c:302:		fn_key_t k = fz_key(key->dst, fz);
fib_hash.c:304:		for (f = fz_chain(k, fz); f; f = f->fn_next) {
fib_hash.c:305:			if (!fn_key_eq(k, f->fn_key)) {
fib_hash.c:306:				if (fn_key_leq(k, f->fn_key))
fib_hash.c:312:			if (f->fn_tos && f->fn_tos != key->tos)
fib_hash.c:315:			f->fn_state |= FN_S_ACCESSED;
fib_hash.c:317:			if (f->fn_state&FN_S_ZOMBIE)
fib_hash.c:319:			if (f->fn_scope < key->scope)
fib_hash.c:322:			err = fib_semantic_match(f->fn_type, FIB_INFO(f), key, res);
fib_hash.c:324:				res->type = f->fn_type;
fib_hash.c:325:				res->scope = f->fn_scope;
fib_hash.c:326:				res->prefixlen = fz->fz_order;
fib_hash.c:339:static int fn_hash_last_dflt=-1;
fib_hash.c:347:	n = neigh_lookup(&arp_tbl, &fi->fib_nh[0].nh_gw, fi->fib_dev);
fib_hash.c:349:		state = n->nud_state;
fib_hash.c:371:	struct fn_hash *t = (struct fn_hash*)tb->tb_data;
fib_hash.c:372:	struct fn_zone *fz = t->fn_zones[0];
fib_hash.c:377:	last_idx = -1;
fib_hash.c:379:	order = -1;
fib_hash.c:382:	for (f = fz->fz_hash[0]; f; f = f->fn_next) {
fib_hash.c:385:		if ((f->fn_state&FN_S_ZOMBIE) ||
fib_hash.c:386:		    f->fn_scope != res->scope ||
fib_hash.c:387:		    f->fn_type != RTN_UNICAST)
fib_hash.c:390:		if (next_fi->fib_priority > res->fi->fib_priority)
fib_hash.c:392:		if (!next_fi->fib_nh[0].nh_gw || next_fi->fib_nh[0].nh_scope != RT_SCOPE_LINK)
fib_hash.c:394:		f->fn_state |= FN_S_ACCESSED;
fib_hash.c:397:			if (next_fi != res->fi)
fib_hash.c:400:			if (res->fi)
fib_hash.c:401:				fib_info_put(res->fi);
fib_hash.c:402:			res->fi = fi;
fib_hash.c:403:			atomic_inc(&fi->fib_clntref);
fib_hash.c:412:		fn_hash_last_dflt = -1;
fib_hash.c:417:		if (res->fi)
fib_hash.c:418:			fib_info_put(res->fi);
fib_hash.c:419:		res->fi = fi;
fib_hash.c:420:		atomic_inc(&fi->fib_clntref);
fib_hash.c:426:		if (res->fi)
fib_hash.c:427:			fib_info_put(res->fi);
fib_hash.c:428:		res->fi = last_resort;
fib_hash.c:430:			atomic_inc(&last_resort->fib_clntref);
fib_hash.c:438:for ( ; ((f) = *(fp)) != NULL; (fp) = &(f)->fn_next)
fib_hash.c:441:for ( ; ((f) = *(fp)) != NULL && fn_key_eq((f)->fn_key, (key)); (fp) = &(f)->fn_next)
fib_hash.c:447:for ( ; ((f) = *(fp)) != NULL && fn_key_eq((f)->fn_key, (key)) && \
fib_hash.c:448:     (f)->fn_tos == (tos) ; (fp) = &(f)->fn_next)
fib_hash.c:460:	struct fn_hash *table = (struct fn_hash*)tb->tb_data;
fib_hash.c:465:	int z = r->rtm_dst_len;
fib_hash.c:466:	int type = r->rtm_type;
fib_hash.c:468:	u8 tos = r->rtm_tos;
fib_hash.c:473:FTprint("tb(%d)_insert: %d %08x/%d %d %08x\n", tb->tb_id, r->rtm_type, rta->rta_dst ?
fib_hash.c:474:*(u32*)rta->rta_dst : 0, z, rta->rta_oif ? *rta->rta_oif : -1,
fib_hash.c:475:rta->rta_prefsrc ? *(u32*)rta->rta_prefsrc : 0);
fib_hash.c:477:		return -EINVAL;
fib_hash.c:478:	fz = table->fn_zones[z];
fib_hash.c:480:		return -ENOBUFS;
fib_hash.c:483:	if (rta->rta_dst) {
fib_hash.c:485:		memcpy(&dst, rta->rta_dst, 4);
fib_hash.c:487:			return -EINVAL;
fib_hash.c:494:	if (fz->fz_nent > (fz->fz_divisor<<1) &&
fib_hash.c:495:	    fz->fz_divisor < FZ_MAX_DIVISOR &&
fib_hash.c:496:	    (z==32 || (1<<z) > fz->fz_divisor))
fib_hash.c:506:		if (fn_key_leq(key,f->fn_key))
fib_hash.c:515:		if (f->fn_tos <= tos)
fib_hash.c:522:	if (f && (f->fn_state&FN_S_ZOMBIE) &&
fib_hash.c:524:	    f->fn_tos == tos &&
fib_hash.c:526:	    fn_key_eq(f->fn_key, key)) {
fib_hash.c:528:		fp = &f->fn_next;
fib_hash.c:534:		if (fi->fib_priority <= FIB_INFO(f)->fib_priority)
fib_hash.c:545:	    f->fn_tos == tos &&
fib_hash.c:547:	    fn_key_eq(f->fn_key, key) &&
fib_hash.c:548:	    fi->fib_priority == FIB_INFO(f)->fib_priority) {
fib_hash.c:551:		err = -EEXIST;
fib_hash.c:552:		if (n->nlmsg_flags&NLM_F_EXCL)
fib_hash.c:555:		if (n->nlmsg_flags&NLM_F_REPLACE) {
fib_hash.c:557:			fp = &f->fn_next;
fib_hash.c:563:		err = -EEXIST;
fib_hash.c:566:			if (fi->fib_priority != FIB_INFO(f)->fib_priority)
fib_hash.c:568:			if (f->fn_type == type && f->fn_scope == r->rtm_scope
fib_hash.c:573:		if (!(n->nlmsg_flags&NLM_F_APPEND)) {
fib_hash.c:580:	err = -ENOENT;
fib_hash.c:581:	if (!(n->nlmsg_flags&NLM_F_CREATE))
fib_hash.c:585:	err = -ENOBUFS;
fib_hash.c:592:	new_f->fn_key = key;
fib_hash.c:594:	new_f->fn_tos = tos;
fib_hash.c:596:	new_f->fn_type = type;
fib_hash.c:597:	new_f->fn_scope = r->rtm_scope;
fib_hash.c:604:	new_f->fn_next = f;
fib_hash.c:608:	fz->fz_nent++;
fib_hash.c:614:		*del_fp = f->fn_next;
fib_hash.c:617:		if (!(f->fn_state&FN_S_ZOMBIE))
fib_hash.c:618:			rtmsg_fib(RTM_DELROUTE, f, z, tb->tb_id, n, req);
fib_hash.c:619:		if (f->fn_state&FN_S_ACCESSED)
fib_hash.c:620:			rt_cache_flush(-1);
fib_hash.c:622:		fz->fz_nent--;
fib_hash.c:624:		rt_cache_flush(-1);
fib_hash.c:626:	rtmsg_fib(RTM_NEWROUTE, new_f, z, tb->tb_id, n, req);
fib_hash.c:639:	struct fn_hash *table = (struct fn_hash*)tb->tb_data;
fib_hash.c:641:	int z = r->rtm_dst_len;
fib_hash.c:646:	u8 tos = r->rtm_tos;
fib_hash.c:649:FTprint("tb(%d)_delete: %d %08x/%d %d\n", tb->tb_id, r->rtm_type, rta->rta_dst ?
fib_hash.c:650:       *(u32*)rta->rta_dst : 0, z, rta->rta_oif ? *rta->rta_oif : -1);
fib_hash.c:652:		return -EINVAL;
fib_hash.c:653:	if ((fz  = table->fn_zones[z]) == NULL)
fib_hash.c:654:		return -ESRCH;
fib_hash.c:657:	if (rta->rta_dst) {
fib_hash.c:659:		memcpy(&dst, rta->rta_dst, 4);
fib_hash.c:661:			return -EINVAL;
fib_hash.c:669:		if (fn_key_eq(f->fn_key, key))
fib_hash.c:671:		if (fn_key_leq(key, f->fn_key)) {
fib_hash.c:672:			return -ESRCH;
fib_hash.c:677:		if (f->fn_tos == tos)
fib_hash.c:687:		if (f->fn_state&FN_S_ZOMBIE) {
fib_hash.c:688:			return -ESRCH;
fib_hash.c:693:		    (!r->rtm_type || f->fn_type == r->rtm_type) &&
fib_hash.c:694:		    (r->rtm_scope == RT_SCOPE_NOWHERE || f->fn_scope == r->rtm_scope) &&
fib_hash.c:695:		    (!r->rtm_protocol || fi->fib_protocol == r->rtm_protocol) &&
fib_hash.c:702:		rtmsg_fib(RTM_DELROUTE, f, z, tb->tb_id, n, req);
fib_hash.c:706:			*del_fp = f->fn_next;
fib_hash.c:709:			if (f->fn_state&FN_S_ACCESSED)
fib_hash.c:710:				rt_cache_flush(-1);
fib_hash.c:712:			fz->fz_nent--;
fib_hash.c:714:			f->fn_state |= FN_S_ZOMBIE;
fib_hash.c:715:			if (f->fn_state&FN_S_ACCESSED) {
fib_hash.c:716:				f->fn_state &= ~FN_S_ACCESSED;
fib_hash.c:717:				rt_cache_flush(-1);
fib_hash.c:725:	return -ESRCH;
fib_hash.c:737:		if (fi && ((f->fn_state&FN_S_ZOMBIE) || (fi->fib_flags&RTNH_F_DEAD))) {
fib_hash.c:739:			*fp = f->fn_next;
fib_hash.c:746:		fp = &f->fn_next;
fib_hash.c:753:	struct fn_hash *table = (struct fn_hash*)tb->tb_data;
fib_hash.c:758:	for (fz = table->fn_zone_list; fz; fz = fz->fz_next) {
fib_hash.c:761:		for (i=fz->fz_divisor-1; i>=0; i--)
fib_hash.c:762:			tmp += fn_flush_list(&fz->fz_hash[i], fz->fz_order, table);
fib_hash.c:763:		fz->fz_nent -= tmp;
fib_hash.c:774:	struct fn_hash *table = (struct fn_hash*)tb->tb_data;
fib_hash.c:780:	for (fz=table->fn_zone_list; fz; fz = fz->fz_next) {
fib_hash.c:783:		int maxslot = fz->fz_divisor;
fib_hash.c:784:		struct fib_node **fp = fz->fz_hash;
fib_hash.c:786:		if (fz->fz_nent == 0)
fib_hash.c:789:		if (pos + fz->fz_nent <= first) {
fib_hash.c:790:			pos += fz->fz_nent;
fib_hash.c:795:			for (f = *fp; f; f = f->fn_next) {
fib_hash.c:798:				fib_node_get_info(f->fn_type,
fib_hash.c:799:						  f->fn_state&FN_S_ZOMBIE,
fib_hash.c:801:						  fz_prefix(f->fn_key, fz),
fib_hash.c:824:	s_i = cb->args[3];
fib_hash.c:825:	for (i=0; f; i++, f=f->fn_next) {
fib_hash.c:827:		if (f->fn_state&FN_S_ZOMBIE) continue;
fib_hash.c:828:		if (fib_dump_info(skb, NETLINK_CB(cb->skb).pid, cb->nlh->nlmsg_seq,
fib_hash.c:830:				  tb->tb_id, (f->fn_state&FN_S_ZOMBIE) ? 0 : f->fn_type, f->fn_scope,
fib_hash.c:831:				  &f->fn_key, fz->fz_order, f->fn_tos,
fib_hash.c:832:				  f->fn_info) < 0) {
fib_hash.c:833:			cb->args[3] = i;
fib_hash.c:834:			return -1;
fib_hash.c:837:	cb->args[3] = i;
fib_hash.c:838:	return skb->len;
fib_hash.c:848:	s_h = cb->args[2];
fib_hash.c:849:	for (h=0; h < fz->fz_divisor; h++) {
fib_hash.c:852:			memset(&cb->args[3], 0, sizeof(cb->args) - 3*sizeof(cb->args[0]));
fib_hash.c:853:		if (fz->fz_hash == NULL || fz->fz_hash[h] == NULL)
fib_hash.c:855:		if (fn_hash_dump_bucket(skb, cb, tb, fz, fz->fz_hash[h]) < 0) {
fib_hash.c:856:			cb->args[2] = h;
fib_hash.c:857:			return -1;
fib_hash.c:860:	cb->args[2] = h;
fib_hash.c:861:	return skb->len;
fib_hash.c:868:	struct fn_hash *table = (struct fn_hash*)tb->tb_data;
fib_hash.c:870:	s_m = cb->args[1];
fib_hash.c:872:	for (fz = table->fn_zone_list, m=0; fz; fz = fz->fz_next, m++) {
fib_hash.c:875:			memset(&cb->args[2], 0, sizeof(cb->args) - 2*sizeof(cb->args[0]));
fib_hash.c:877:			cb->args[1] = m;
fib_hash.c:879:			return -1;
fib_hash.c:883:	cb->args[1] = m;
fib_hash.c:884:	return skb->len;
fib_hash.c:891:	u32 pid = req ? req->pid : 0;
fib_hash.c:898:	if (fib_dump_info(skb, pid, n->nlmsg_seq, event, tb_id,
fib_hash.c:899:			  f->fn_type, f->fn_scope, &f->fn_key, z, f->fn_tos,
fib_hash.c:905:	if (n->nlmsg_flags&NLM_F_ECHO)
fib_hash.c:906:		atomic_inc(&skb->users);
fib_hash.c:908:	if (n->nlmsg_flags&NLM_F_ECHO)
fib_hash.c:930:	tb->tb_id = id;
fib_hash.c:931:	tb->tb_lookup = fn_hash_lookup;
fib_hash.c:932:	tb->tb_insert = fn_hash_insert;
fib_hash.c:933:	tb->tb_delete = fn_hash_delete;
fib_hash.c:934:	tb->tb_flush = fn_hash_flush;
fib_hash.c:935:	tb->tb_select_default = fn_hash_select_default;
fib_hash.c:936:	tb->tb_dump = fn_hash_dump;
fib_hash.c:938:	tb->tb_get_info = fn_hash_get_info;
fib_hash.c:940:	memset(tb->tb_data, 0, sizeof(struct fn_hash));
fib_rules.c:109:	int err = -ESRCH;
fib_rules.c:111:	for (rp=&fib_rules; (r=*rp) != NULL; rp=&r->r_next) {
fib_rules.c:112:		if ((!rta[RTA_SRC-1] || memcmp(RTA_DATA(rta[RTA_SRC-1]), &r->r_src, 4) == 0) &&
fib_rules.c:113:		    rtm->rtm_src_len == r->r_src_len &&
fib_rules.c:114:		    rtm->rtm_dst_len == r->r_dst_len &&
fib_rules.c:115:		    (!rta[RTA_DST-1] || memcmp(RTA_DATA(rta[RTA_DST-1]), &r->r_dst, 4) == 0) &&
fib_rules.c:116:		    rtm->rtm_tos == r->r_tos &&
fib_rules.c:118:		    (!rta[RTA_PROTOINFO-1] || memcmp(RTA_DATA(rta[RTA_PROTOINFO-1]), &r->r_fwmark, 4) == 0) &&
fib_rules.c:120:		    (!rtm->rtm_type || rtm->rtm_type == r->r_action) &&
fib_rules.c:121:		    (!rta[RTA_PRIORITY-1] || memcmp(RTA_DATA(rta[RTA_PRIORITY-1]), &r->r_preference, 4) == 0) &&
fib_rules.c:122:		    (!rta[RTA_IIF-1] || strcmp(RTA_DATA(rta[RTA_IIF-1]), r->r_ifname) == 0) &&
fib_rules.c:123:		    (!rtm->rtm_table || (r && rtm->rtm_table == r->r_table))) {
fib_rules.c:124:			err = -EPERM;
fib_rules.c:129:			*rp = r->r_next;
fib_rules.c:130:			r->r_dead = 1;
fib_rules.c:154:	if (atomic_dec_and_test(&r->r_clntref)) {
fib_rules.c:155:		if (r->r_dead)
fib_rules.c:169:	if (rtm->rtm_src_len > 32 || rtm->rtm_dst_len > 32 ||
fib_rules.c:170:	    (rtm->rtm_tos & ~IPTOS_TOS_MASK))
fib_rules.c:171:		return -EINVAL;
fib_rules.c:173:	if (rta[RTA_IIF-1] && RTA_PAYLOAD(rta[RTA_IIF-1]) > IFNAMSIZ)
fib_rules.c:174:		return -EINVAL;
fib_rules.c:176:	table_id = rtm->rtm_table;
fib_rules.c:179:		if (rtm->rtm_type == RTN_UNICAST || rtm->rtm_type == RTN_NAT) {
fib_rules.c:181:				return -ENOBUFS;
fib_rules.c:182:			table_id = table->tb_id;
fib_rules.c:188:		return -ENOMEM;
fib_rules.c:190:	if (rta[RTA_SRC-1])
fib_rules.c:191:		memcpy(&new_r->r_src, RTA_DATA(rta[RTA_SRC-1]), 4);
fib_rules.c:192:	if (rta[RTA_DST-1])
fib_rules.c:193:		memcpy(&new_r->r_dst, RTA_DATA(rta[RTA_DST-1]), 4);
fib_rules.c:194:	if (rta[RTA_GATEWAY-1])
fib_rules.c:195:		memcpy(&new_r->r_srcmap, RTA_DATA(rta[RTA_GATEWAY-1]), 4);
fib_rules.c:196:	new_r->r_src_len = rtm->rtm_src_len;
fib_rules.c:197:	new_r->r_dst_len = rtm->rtm_dst_len;
fib_rules.c:198:	new_r->r_srcmask = inet_make_mask(rtm->rtm_src_len);
fib_rules.c:199:	new_r->r_dstmask = inet_make_mask(rtm->rtm_dst_len);
fib_rules.c:200:	new_r->r_tos = rtm->rtm_tos;
fib_rules.c:202:	if (rta[RTA_PROTOINFO-1])
fib_rules.c:203:		memcpy(&new_r->r_fwmark, RTA_DATA(rta[RTA_PROTOINFO-1]), 4);
fib_rules.c:205:	new_r->r_action = rtm->rtm_type;
fib_rules.c:206:	new_r->r_flags = rtm->rtm_flags;
fib_rules.c:207:	if (rta[RTA_PRIORITY-1])
fib_rules.c:208:		memcpy(&new_r->r_preference, RTA_DATA(rta[RTA_PRIORITY-1]), 4);
fib_rules.c:209:	new_r->r_table = table_id;
fib_rules.c:210:	if (rta[RTA_IIF-1]) {
fib_rules.c:212:		memcpy(new_r->r_ifname, RTA_DATA(rta[RTA_IIF-1]), IFNAMSIZ);
fib_rules.c:213:		new_r->r_ifname[IFNAMSIZ-1] = 0;
fib_rules.c:214:		new_r->r_ifindex = -1;
fib_rules.c:215:		dev = __dev_get_by_name(new_r->r_ifname);
fib_rules.c:217:			new_r->r_ifindex = dev->ifindex;
fib_rules.c:220:	if (rta[RTA_FLOW-1])
fib_rules.c:221:		memcpy(&new_r->r_tclassid, RTA_DATA(rta[RTA_FLOW-1]), 4);
fib_rules.c:225:	if (!new_r->r_preference) {
fib_rules.c:227:		if (r && (r = r->r_next) != NULL) {
fib_rules.c:228:			rp = &fib_rules->r_next;
fib_rules.c:229:			if (r->r_preference)
fib_rules.c:230:				new_r->r_preference = r->r_preference - 1;
fib_rules.c:235:		if (r->r_preference > new_r->r_preference)
fib_rules.c:237:		rp = &r->r_next;
fib_rules.c:240:	new_r->r_next = r;
fib_rules.c:241:	atomic_inc(&new_r->r_clntref);
fib_rules.c:250:	u32 mask = inet_make_mask(res->prefixlen);
fib_rules.c:251:	return (daddr&~mask)|res->fi->fib_nh->nh_gw;
fib_rules.c:256:	struct fib_rule *r = res->r;
fib_rules.c:258:	if (r->r_action == RTN_NAT) {
fib_rules.c:259:		int addrtype = inet_addr_type(r->r_srcmap);
fib_rules.c:263:			saddr = (saddr&~r->r_srcmask)|r->r_srcmap;
fib_rules.c:265:		} else if (addrtype == RTN_LOCAL || r->r_srcmap == 0) {
fib_rules.c:267:			saddr = r->r_srcmap;
fib_rules.c:277:	if (res->r)
fib_rules.c:278:		return res->r->r_tclassid;
fib_rules.c:288:	for (r=fib_rules; r; r=r->r_next) {
fib_rules.c:289:		if (r->r_ifindex == dev->ifindex) {
fib_rules.c:291:			r->r_ifindex = -1;
fib_rules.c:301:	for (r=fib_rules; r; r=r->r_next) {
fib_rules.c:302:		if (r->r_ifindex == -1 && strcmp(dev->name, r->r_ifname) == 0) {
fib_rules.c:304:			r->r_ifindex = dev->ifindex;
fib_rules.c:316:	u32 daddr = key->dst;
fib_rules.c:317:	u32 saddr = key->src;
fib_rules.c:319:FRprintk("Lookup: %u.%u.%u.%u <- %u.%u.%u.%u ",
fib_rules.c:320:	NIPQUAD(key->dst), NIPQUAD(key->src));
fib_rules.c:322:	for (r = fib_rules; r; r=r->r_next) {
fib_rules.c:323:		if (((saddr^r->r_src) & r->r_srcmask) ||
fib_rules.c:324:		    ((daddr^r->r_dst) & r->r_dstmask) ||
fib_rules.c:326:		    (r->r_tos && r->r_tos != key->tos) ||
fib_rules.c:329:		    (r->r_fwmark && r->r_fwmark != key->fwmark) ||
fib_rules.c:331:		    (r->r_ifindex && r->r_ifindex != key->iif))
fib_rules.c:334:FRprintk("tb %d r %d ", r->r_table, r->r_action);
fib_rules.c:335:		switch (r->r_action) {
fib_rules.c:342:			return -ENETUNREACH;
fib_rules.c:346:			return -EINVAL;
fib_rules.c:349:			return -EACCES;
fib_rules.c:352:		if ((tb = fib_get_table(r->r_table)) == NULL)
fib_rules.c:354:		err = tb->tb_lookup(tb, key, res);
fib_rules.c:356:			res->r = policy;
fib_rules.c:358:				atomic_inc(&policy->r_clntref);
fib_rules.c:362:		if (err < 0 && err != -EAGAIN) {
fib_rules.c:369:	return -ENETUNREACH;
fib_rules.c:374:	if (res->r && res->r->r_action == RTN_UNICAST &&
fib_rules.c:377:		if ((tb = fib_get_table(res->r->r_table)) != NULL)
fib_rules.c:378:			tb->tb_select_default(tb, key, res);
fib_rules.c:404:	unsigned char	 *b = skb->tail;
fib_rules.c:406:	nlh = NLMSG_PUT(skb, NETLINK_CREDS(cb->skb)->pid, cb->nlh->nlmsg_seq, RTM_NEWRULE, sizeof(*rtm));
fib_rules.c:408:	rtm->rtm_family = AF_INET;
fib_rules.c:409:	rtm->rtm_dst_len = r->r_dst_len;
fib_rules.c:410:	rtm->rtm_src_len = r->r_src_len;
fib_rules.c:411:	rtm->rtm_tos = r->r_tos;
fib_rules.c:413:	if (r->r_fwmark)
fib_rules.c:414:		RTA_PUT(skb, RTA_PROTOINFO, 4, &r->r_fwmark);
fib_rules.c:416:	rtm->rtm_table = r->r_table;
fib_rules.c:417:	rtm->rtm_protocol = 0;
fib_rules.c:418:	rtm->rtm_scope = 0;
fib_rules.c:419:	rtm->rtm_type = r->r_action;
fib_rules.c:420:	rtm->rtm_flags = r->r_flags;
fib_rules.c:422:	if (r->r_dst_len)
fib_rules.c:423:		RTA_PUT(skb, RTA_DST, 4, &r->r_dst);
fib_rules.c:424:	if (r->r_src_len)
fib_rules.c:425:		RTA_PUT(skb, RTA_SRC, 4, &r->r_src);
fib_rules.c:426:	if (r->r_ifname[0])
fib_rules.c:427:		RTA_PUT(skb, RTA_IIF, IFNAMSIZ, &r->r_ifname);
fib_rules.c:428:	if (r->r_preference)
fib_rules.c:429:		RTA_PUT(skb, RTA_PRIORITY, 4, &r->r_preference);
fib_rules.c:430:	if (r->r_srcmap)
fib_rules.c:431:		RTA_PUT(skb, RTA_GATEWAY, 4, &r->r_srcmap);
fib_rules.c:433:	if (r->r_tclassid)
fib_rules.c:434:		RTA_PUT(skb, RTA_FLOW, 4, &r->r_tclassid);
fib_rules.c:436:	nlh->nlmsg_len = skb->tail - b;
fib_rules.c:437:	return skb->len;
fib_rules.c:441:	skb_trim(skb, b - skb->data);
fib_rules.c:442:	return -1;
fib_rules.c:448:	int s_idx = cb->args[0];
fib_rules.c:452:	for (r=fib_rules, idx=0; r; r = r->r_next, idx++) {
fib_rules.c:459:	cb->args[0] = idx;
fib_rules.c:461:	return skb->len;
fib_semantics.c:53:	for (fi = fib_info_list; fi; fi = fi->fib_next)
fib_semantics.c:62:for (nhsel=0, nh = (fi)->fib_nh; nhsel < (fi)->fib_nhs; nh++, nhsel++)
fib_semantics.c:65:for (nhsel=0, nh = (struct fib_nh*)((fi)->fib_nh); nhsel < (fi)->fib_nhs; nh++, nhsel++)
fib_semantics.c:71:#define for_nexthops(fi) { int nhsel=0; const struct fib_nh * nh = (fi)->fib_nh; \
fib_semantics.c:74:#define change_nexthops(fi) { int nhsel=0; struct fib_nh * nh = (struct fib_nh*)((fi)->fib_nh); \
fib_semantics.c:93:	{ -EINVAL, RT_SCOPE_UNIVERSE},	/* RTN_BLACKHOLE */
fib_semantics.c:94:	{ -EHOSTUNREACH, RT_SCOPE_UNIVERSE},/* RTN_UNREACHABLE */
fib_semantics.c:95:	{ -EACCES, RT_SCOPE_UNIVERSE},	/* RTN_PROHIBIT */
fib_semantics.c:96:	{ -EAGAIN, RT_SCOPE_UNIVERSE},	/* RTN_THROW */
fib_semantics.c:100:	{ -EINVAL, RT_SCOPE_NOWHERE},	/* RTN_NAT */
fib_semantics.c:102:	{ -EINVAL, RT_SCOPE_NOWHERE}	/* RTN_XRESOLVE */
fib_semantics.c:110:	if (fi->fib_dead == 0) {
fib_semantics.c:115:		if (nh->nh_dev)
fib_semantics.c:116:			dev_put(nh->nh_dev);
fib_semantics.c:117:		nh->nh_dev = NULL;
fib_semantics.c:119:	fib_info_cnt--;
fib_semantics.c:126:	if (fi && --fi->fib_treeref == 0) {
fib_semantics.c:127:		if (fi->fib_next)
fib_semantics.c:128:			fi->fib_next->fib_prev = fi->fib_prev;
fib_semantics.c:129:		if (fi->fib_prev)
fib_semantics.c:130:			fi->fib_prev->fib_next = fi->fib_next;
fib_semantics.c:132:			fib_info_list = fi->fib_next;
fib_semantics.c:133:		fi->fib_dead = 1;
fib_semantics.c:141:	const struct fib_nh *onh = ofi->fib_nh;
fib_semantics.c:144:		if (nh->nh_oif != onh->nh_oif ||
fib_semantics.c:145:		    nh->nh_gw  != onh->nh_gw ||
fib_semantics.c:146:		    nh->nh_scope != onh->nh_scope ||
fib_semantics.c:148:		    nh->nh_weight != onh->nh_weight ||
fib_semantics.c:151:		    nh->nh_tclassid != onh->nh_tclassid ||
fib_semantics.c:153:		    ((nh->nh_flags^onh->nh_flags)&~RTNH_F_DEAD))
fib_semantics.c:154:			return -1;
fib_semantics.c:163:		if (fi->fib_nhs != nfi->fib_nhs)
fib_semantics.c:165:		if (nfi->fib_protocol == fi->fib_protocol &&
fib_semantics.c:166:		    nfi->fib_prefsrc == fi->fib_prefsrc &&
fib_semantics.c:167:		    nfi->fib_priority == fi->fib_priority &&
fib_semantics.c:168:		    memcmp(nfi->fib_metrics, fi->fib_metrics, sizeof(fi->fib_metrics)) == 0 &&
fib_semantics.c:169:		    ((nfi->fib_flags^fi->fib_flags)&~RTNH_F_DEAD) == 0 &&
fib_semantics.c:170:		    (nfi->fib_nhs == 0 || nh_comp(fi, nfi) == 0))
fib_semantics.c:184:		if (fi->fib_flags & RTNH_F_DEAD)
fib_semantics.c:187:			if (nh->nh_dev == dev && nh->nh_gw == gw &&
fib_semantics.c:188:			    nh->nh_scope == RT_SCOPE_LINK &&
fib_semantics.c:189:			    !(nh->nh_flags&RTNH_F_DEAD)) {
fib_semantics.c:196:	return -1;
fib_semantics.c:204:		if (attr->rta_type == type)
fib_semantics.c:219:		if ((nhlen -= nhp->rtnh_len) < 0)
fib_semantics.c:234:		int attrlen = nhlen - sizeof(struct rtnexthop);
fib_semantics.c:235:		if (attrlen < 0 || (nhlen -= nhp->rtnh_len) < 0)
fib_semantics.c:236:			return -EINVAL;
fib_semantics.c:237:		nh->nh_flags = (r->rtm_flags&~0xFF) | nhp->rtnh_flags;
fib_semantics.c:238:		nh->nh_oif = nhp->rtnh_ifindex;
fib_semantics.c:239:		nh->nh_weight = nhp->rtnh_hops + 1;
fib_semantics.c:241:			nh->nh_gw = fib_get_attr32(RTNH_DATA(nhp), attrlen, RTA_GATEWAY);
fib_semantics.c:243:			nh->nh_tclassid = fib_get_attr32(RTNH_DATA(nhp), attrlen, RTA_FLOW);
fib_semantics.c:261:	if (rta->rta_priority &&
fib_semantics.c:262:	    *rta->rta_priority != fi->fib_priority)
fib_semantics.c:265:	if (rta->rta_oif || rta->rta_gw) {
fib_semantics.c:266:		if ((!rta->rta_oif || *rta->rta_oif == fi->fib_nh->nh_oif) &&
fib_semantics.c:267:		    (!rta->rta_gw  || memcmp(rta->rta_gw, &fi->fib_nh->nh_gw, 4) == 0))
fib_semantics.c:273:	if (rta->rta_mp == NULL)
fib_semantics.c:275:	nhp = RTA_DATA(rta->rta_mp);
fib_semantics.c:276:	nhlen = RTA_PAYLOAD(rta->rta_mp);
fib_semantics.c:279:		int attrlen = nhlen - sizeof(struct rtnexthop);
fib_semantics.c:282:		if (attrlen < 0 || (nhlen -= nhp->rtnh_len) < 0)
fib_semantics.c:283:			return -EINVAL;
fib_semantics.c:284:		if (nhp->rtnh_ifindex && nhp->rtnh_ifindex != nh->nh_oif)
fib_semantics.c:288:			if (gw && gw != nh->nh_gw)
fib_semantics.c:292:			if (gw && gw != nh->nh_tclassid)
fib_semantics.c:305:   -------
fib_semantics.c:311:   b) gateway must be on-link address, possibly
fib_semantics.c:315:   d) If we use tunnel routes, gateway could be not on-link.
fib_semantics.c:317:   Attempt to reconcile all of these (alas, self-contradictory) conditions
fib_semantics.c:334:   consistent and very flexible. F.e. as by-product it allows
fib_semantics.c:335:   to co-exists in peace independent exterior and interior
fib_semantics.c:340:   {universe prefix}  -> (gw, oif) [scope link]
fib_semantics.c:342:			  |-> {link prefix} -> (gw, oif) [scope local]
fib_semantics.c:344:						|-> {local prefix} (terminal node)
fib_semantics.c:351:	if (nh->nh_gw) {
fib_semantics.c:356:		if (nh->nh_flags&RTNH_F_PERVASIVE)
fib_semantics.c:359:		if (nh->nh_flags&RTNH_F_ONLINK) {
fib_semantics.c:362:			if (r->rtm_scope >= RT_SCOPE_LINK)
fib_semantics.c:363:				return -EINVAL;
fib_semantics.c:364:			if (inet_addr_type(nh->nh_gw) != RTN_UNICAST)
fib_semantics.c:365:				return -EINVAL;
fib_semantics.c:366:			if ((dev = __dev_get_by_index(nh->nh_oif)) == NULL)
fib_semantics.c:367:				return -ENODEV;
fib_semantics.c:368:			if (!(dev->flags&IFF_UP))
fib_semantics.c:369:				return -ENETDOWN;
fib_semantics.c:370:			nh->nh_dev = dev;
fib_semantics.c:372:			nh->nh_scope = RT_SCOPE_LINK;
fib_semantics.c:376:		key.dst = nh->nh_gw;
fib_semantics.c:377:		key.oif = nh->nh_oif;
fib_semantics.c:378:		key.scope = r->rtm_scope + 1;
fib_semantics.c:385:		err = -EINVAL;
fib_semantics.c:388:		nh->nh_scope = res.scope;
fib_semantics.c:389:		nh->nh_oif = FIB_RES_OIF(res);
fib_semantics.c:390:		if ((nh->nh_dev = FIB_RES_DEV(res)) == NULL)
fib_semantics.c:392:		dev_hold(nh->nh_dev);
fib_semantics.c:393:		err = -ENETDOWN;
fib_semantics.c:394:		if (!(nh->nh_dev->flags & IFF_UP))
fib_semantics.c:403:		if (nh->nh_flags&(RTNH_F_PERVASIVE|RTNH_F_ONLINK))
fib_semantics.c:404:			return -EINVAL;
fib_semantics.c:406:		in_dev = inetdev_by_index(nh->nh_oif);
fib_semantics.c:408:			return -ENODEV;
fib_semantics.c:409:		if (!(in_dev->dev->flags&IFF_UP)) {
fib_semantics.c:411:			return -ENETDOWN;
fib_semantics.c:413:		nh->nh_dev = in_dev->dev;
fib_semantics.c:414:		dev_hold(nh->nh_dev);
fib_semantics.c:415:		nh->nh_scope = RT_SCOPE_HOST;
fib_semantics.c:435:	if (fib_props[r->rtm_type].scope > r->rtm_scope)
fib_semantics.c:439:	if (rta->rta_mp) {
fib_semantics.c:440:		nhs = fib_count_nexthops(rta->rta_mp);
fib_semantics.c:447:	err = -ENOBUFS;
fib_semantics.c:453:	fi->fib_protocol = r->rtm_protocol;
fib_semantics.c:454:	fi->fib_nhs = nhs;
fib_semantics.c:455:	fi->fib_flags = r->rtm_flags;
fib_semantics.c:456:	if (rta->rta_priority)
fib_semantics.c:457:		fi->fib_priority = *rta->rta_priority;
fib_semantics.c:458:	if (rta->rta_mx) {
fib_semantics.c:459:		int attrlen = RTA_PAYLOAD(rta->rta_mx);
fib_semantics.c:460:		struct rtattr *attr = RTA_DATA(rta->rta_mx);
fib_semantics.c:463:			unsigned flavor = attr->rta_type;
fib_semantics.c:467:				fi->fib_metrics[flavor-1] = *(unsigned*)RTA_DATA(attr);
fib_semantics.c:472:	if (rta->rta_prefsrc)
fib_semantics.c:473:		memcpy(&fi->fib_prefsrc, rta->rta_prefsrc, 4);
fib_semantics.c:475:	if (rta->rta_mp) {
fib_semantics.c:477:		if ((err = fib_get_nhs(fi, rta->rta_mp, r)) != 0)
fib_semantics.c:479:		if (rta->rta_oif && fi->fib_nh->nh_oif != *rta->rta_oif)
fib_semantics.c:481:		if (rta->rta_gw && memcmp(&fi->fib_nh->nh_gw, rta->rta_gw, 4))
fib_semantics.c:484:		if (rta->rta_flow && memcmp(&fi->fib_nh->nh_tclassid, rta->rta_flow, 4))
fib_semantics.c:491:		struct fib_nh *nh = fi->fib_nh;
fib_semantics.c:492:		if (rta->rta_oif)
fib_semantics.c:493:			nh->nh_oif = *rta->rta_oif;
fib_semantics.c:494:		if (rta->rta_gw)
fib_semantics.c:495:			memcpy(&nh->nh_gw, rta->rta_gw, 4);
fib_semantics.c:497:		if (rta->rta_flow)
fib_semantics.c:498:			memcpy(&nh->nh_tclassid, rta->rta_flow, 4);
fib_semantics.c:500:		nh->nh_flags = r->rtm_flags;
fib_semantics.c:502:		nh->nh_weight = 1;
fib_semantics.c:507:	if (r->rtm_type == RTN_NAT) {
fib_semantics.c:508:		if (rta->rta_gw == NULL || nhs != 1 || rta->rta_oif)
fib_semantics.c:510:		memcpy(&fi->fib_nh->nh_gw, rta->rta_gw, 4);
fib_semantics.c:515:	if (fib_props[r->rtm_type].error) {
fib_semantics.c:516:		if (rta->rta_gw || rta->rta_oif || rta->rta_mp)
fib_semantics.c:521:	if (r->rtm_scope > RT_SCOPE_HOST)
fib_semantics.c:524:	if (r->rtm_scope == RT_SCOPE_HOST) {
fib_semantics.c:525:		struct fib_nh *nh = fi->fib_nh;
fib_semantics.c:528:		if (nhs != 1 || nh->nh_gw)
fib_semantics.c:530:		nh->nh_scope = RT_SCOPE_NOWHERE;
fib_semantics.c:531:		nh->nh_dev = dev_get_by_index(fi->fib_nh->nh_oif);
fib_semantics.c:532:		err = -ENODEV;
fib_semantics.c:533:		if (nh->nh_dev == NULL)
fib_semantics.c:542:	if (fi->fib_prefsrc) {
fib_semantics.c:543:		if (r->rtm_type != RTN_LOCAL || rta->rta_dst == NULL ||
fib_semantics.c:544:		    memcmp(&fi->fib_prefsrc, rta->rta_dst, 4))
fib_semantics.c:545:			if (inet_addr_type(fi->fib_prefsrc) != RTN_LOCAL)
fib_semantics.c:551:		fi->fib_dead = 1;
fib_semantics.c:553:		ofi->fib_treeref++;
fib_semantics.c:557:	fi->fib_treeref++;
fib_semantics.c:558:	atomic_inc(&fi->fib_clntref);
fib_semantics.c:560:	fi->fib_next = fib_info_list;
fib_semantics.c:561:	fi->fib_prev = NULL;
fib_semantics.c:563:		fib_info_list->fib_prev = fi;
fib_semantics.c:569:	err = -EINVAL;
fib_semantics.c:574:		fi->fib_dead = 1;
fib_semantics.c:586:		if (fi->fib_flags&RTNH_F_DEAD)
fib_semantics.c:589:		res->fi = fi;
fib_semantics.c:595:			atomic_inc(&fi->fib_clntref);
fib_semantics.c:604:				if (nh->nh_flags&RTNH_F_DEAD)
fib_semantics.c:606:				if (!key->oif || key->oif == nh->nh_oif)
fib_semantics.c:610:			if (nhsel < fi->fib_nhs) {
fib_semantics.c:611:				res->nh_sel = nhsel;
fib_semantics.c:612:				atomic_inc(&fi->fib_clntref);
fib_semantics.c:617:				atomic_inc(&fi->fib_clntref);
fib_semantics.c:622:			res->fi = NULL;
fib_semantics.c:625:			res->fi = NULL;
fib_semantics.c:627:			return -EINVAL;
fib_semantics.c:637:	return inet_select_addr(FIB_RES_DEV(*res), FIB_RES_GW(*res), res->scope);
fib_semantics.c:647:	unsigned char	 *b = skb->tail;
fib_semantics.c:651:	rtm->rtm_family = AF_INET;
fib_semantics.c:652:	rtm->rtm_dst_len = dst_len;
fib_semantics.c:653:	rtm->rtm_src_len = 0;
fib_semantics.c:654:	rtm->rtm_tos = tos;
fib_semantics.c:655:	rtm->rtm_table = tb_id;
fib_semantics.c:656:	rtm->rtm_type = type;
fib_semantics.c:657:	rtm->rtm_flags = fi->fib_flags;
fib_semantics.c:658:	rtm->rtm_scope = scope;
fib_semantics.c:659:	if (rtm->rtm_dst_len)
fib_semantics.c:661:	rtm->rtm_protocol = fi->fib_protocol;
fib_semantics.c:662:	if (fi->fib_priority)
fib_semantics.c:663:		RTA_PUT(skb, RTA_PRIORITY, 4, &fi->fib_priority);
fib_semantics.c:665:	if (fi->fib_nh[0].nh_tclassid)
fib_semantics.c:666:		RTA_PUT(skb, RTA_FLOW, 4, &fi->fib_nh[0].nh_tclassid);
fib_semantics.c:668:	if (rtnetlink_put_metrics(skb, fi->fib_metrics) < 0)
fib_semantics.c:670:	if (fi->fib_prefsrc)
fib_semantics.c:671:		RTA_PUT(skb, RTA_PREFSRC, 4, &fi->fib_prefsrc);
fib_semantics.c:672:	if (fi->fib_nhs == 1) {
fib_semantics.c:673:		if (fi->fib_nh->nh_gw)
fib_semantics.c:674:			RTA_PUT(skb, RTA_GATEWAY, 4, &fi->fib_nh->nh_gw);
fib_semantics.c:675:		if (fi->fib_nh->nh_oif)
fib_semantics.c:676:			RTA_PUT(skb, RTA_OIF, sizeof(int), &fi->fib_nh->nh_oif);
fib_semantics.c:679:	if (fi->fib_nhs > 1) {
fib_semantics.c:690:			nhp->rtnh_flags = nh->nh_flags & 0xFF;
fib_semantics.c:691:			nhp->rtnh_hops = nh->nh_weight-1;
fib_semantics.c:692:			nhp->rtnh_ifindex = nh->nh_oif;
fib_semantics.c:693:			if (nh->nh_gw)
fib_semantics.c:694:				RTA_PUT(skb, RTA_GATEWAY, 4, &nh->nh_gw);
fib_semantics.c:695:			nhp->rtnh_len = skb->tail - (unsigned char*)nhp;
fib_semantics.c:697:		mp_head->rta_type = RTA_MULTIPATH;
fib_semantics.c:698:		mp_head->rta_len = skb->tail - (u8*)mp_head;
fib_semantics.c:701:	nlh->nlmsg_len = skb->tail - b;
fib_semantics.c:702:	return skb->len;
fib_semantics.c:706:	skb_trim(skb, b - skb->data);
fib_semantics.c:707:	return -1;
fib_semantics.c:722:	if (r->rt_dst.sa_family != AF_INET)
fib_semantics.c:723:		return -EAFNOSUPPORT;
fib_semantics.c:733:	ptr = &((struct sockaddr_in*)&r->rt_dst)->sin_addr.s_addr;
fib_semantics.c:734:	if (!(r->rt_flags&RTF_HOST)) {
fib_semantics.c:735:		u32 mask = ((struct sockaddr_in*)&r->rt_genmask)->sin_addr.s_addr;
fib_semantics.c:736:		if (r->rt_genmask.sa_family != AF_INET) {
fib_semantics.c:737:			if (mask || r->rt_genmask.sa_family)
fib_semantics.c:738:				return -EAFNOSUPPORT;
fib_semantics.c:741:			return -EINVAL;
fib_semantics.c:745:	nl->nlmsg_flags = NLM_F_REQUEST;
fib_semantics.c:746:	nl->nlmsg_pid = 0;
fib_semantics.c:747:	nl->nlmsg_seq = 0;
fib_semantics.c:748:	nl->nlmsg_len = NLMSG_LENGTH(sizeof(*rtm));
fib_semantics.c:750:		nl->nlmsg_type = RTM_DELROUTE;
fib_semantics.c:751:		nl->nlmsg_flags = 0;
fib_semantics.c:753:		nl->nlmsg_type = RTM_NEWROUTE;
fib_semantics.c:754:		nl->nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE;
fib_semantics.c:755:		rtm->rtm_protocol = RTPROT_BOOT;
fib_semantics.c:758:	rtm->rtm_dst_len = plen;
fib_semantics.c:759:	rta->rta_dst = ptr;
fib_semantics.c:761:	if (r->rt_metric) {
fib_semantics.c:762:		*(u32*)&r->rt_pad3 = r->rt_metric - 1;
fib_semantics.c:763:		rta->rta_priority = (u32*)&r->rt_pad3;
fib_semantics.c:765:	if (r->rt_flags&RTF_REJECT) {
fib_semantics.c:766:		rtm->rtm_scope = RT_SCOPE_HOST;
fib_semantics.c:767:		rtm->rtm_type = RTN_UNREACHABLE;
fib_semantics.c:770:	rtm->rtm_scope = RT_SCOPE_NOWHERE;
fib_semantics.c:771:	rtm->rtm_type = RTN_UNICAST;
fib_semantics.c:773:	if (r->rt_dev) {
fib_semantics.c:778:		if (copy_from_user(devname, r->rt_dev, IFNAMSIZ-1))
fib_semantics.c:779:			return -EFAULT;
fib_semantics.c:780:		devname[IFNAMSIZ-1] = 0;
fib_semantics.c:786:			return -ENODEV;
fib_semantics.c:787:		rta->rta_oif = &dev->ifindex;
fib_semantics.c:792:				return -ENODEV;
fib_semantics.c:794:			for (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next)
fib_semantics.c:795:				if (strcmp(ifa->ifa_label, devname) == 0)
fib_semantics.c:798:				return -ENODEV;
fib_semantics.c:799:			rta->rta_prefsrc = &ifa->ifa_local;
fib_semantics.c:803:	ptr = &((struct sockaddr_in*)&r->rt_gateway)->sin_addr.s_addr;
fib_semantics.c:804:	if (r->rt_gateway.sa_family == AF_INET && *ptr) {
fib_semantics.c:805:		rta->rta_gw = ptr;
fib_semantics.c:806:		if (r->rt_flags&RTF_GATEWAY && inet_addr_type(*ptr) == RTN_UNICAST)
fib_semantics.c:807:			rtm->rtm_scope = RT_SCOPE_UNIVERSE;
fib_semantics.c:813:	if (r->rt_flags&RTF_GATEWAY && rta->rta_gw == NULL)
fib_semantics.c:814:		return -EINVAL;
fib_semantics.c:816:	if (rtm->rtm_scope == RT_SCOPE_NOWHERE)
fib_semantics.c:817:		rtm->rtm_scope = RT_SCOPE_LINK;
fib_semantics.c:819:	if (r->rt_flags&(RTF_MTU|RTF_WINDOW|RTF_IRTT)) {
fib_semantics.c:823:			return -ENOMEM;
fib_semantics.c:824:		rta->rta_mx = mx;
fib_semantics.c:825:		mx->rta_type = RTA_METRICS;
fib_semantics.c:826:		mx->rta_len  = RTA_LENGTH(0);
fib_semantics.c:827:		if (r->rt_flags&RTF_MTU) {
fib_semantics.c:828:			rec = (void*)((char*)mx + RTA_ALIGN(mx->rta_len));
fib_semantics.c:829:			rec->rta_type = RTAX_ADVMSS;
fib_semantics.c:830:			rec->rta_len = RTA_LENGTH(4);
fib_semantics.c:831:			mx->rta_len += RTA_LENGTH(4);
fib_semantics.c:832:			*(u32*)RTA_DATA(rec) = r->rt_mtu - 40;
fib_semantics.c:834:		if (r->rt_flags&RTF_WINDOW) {
fib_semantics.c:835:			rec = (void*)((char*)mx + RTA_ALIGN(mx->rta_len));
fib_semantics.c:836:			rec->rta_type = RTAX_WINDOW;
fib_semantics.c:837:			rec->rta_len = RTA_LENGTH(4);
fib_semantics.c:838:			mx->rta_len += RTA_LENGTH(4);
fib_semantics.c:839:			*(u32*)RTA_DATA(rec) = r->rt_window;
fib_semantics.c:841:		if (r->rt_flags&RTF_IRTT) {
fib_semantics.c:842:			rec = (void*)((char*)mx + RTA_ALIGN(mx->rta_len));
fib_semantics.c:843:			rec->rta_type = RTAX_RTT;
fib_semantics.c:844:			rec->rta_len = RTA_LENGTH(4);
fib_semantics.c:845:			mx->rta_len += RTA_LENGTH(4);
fib_semantics.c:846:			*(u32*)RTA_DATA(rec) = r->rt_irtt<<3;
fib_semantics.c:856:   - local address disappeared -> we must delete all the entries
fib_semantics.c:858:   - device went down -> we must shutdown all nexthops going via it.
fib_semantics.c:867:		scope = -1;
fib_semantics.c:870:		if (local && fi->fib_prefsrc == local) {
fib_semantics.c:871:			fi->fib_flags |= RTNH_F_DEAD;
fib_semantics.c:873:		} else if (dev && fi->fib_nhs) {
fib_semantics.c:877:				if (nh->nh_flags&RTNH_F_DEAD)
fib_semantics.c:879:				else if (nh->nh_dev == dev &&
fib_semantics.c:880:					 nh->nh_scope != scope) {
fib_semantics.c:881:					nh->nh_flags |= RTNH_F_DEAD;
fib_semantics.c:884:					fi->fib_power -= nh->nh_power;
fib_semantics.c:885:					nh->nh_power = 0;
fib_semantics.c:891:				if (force > 1 && nh->nh_dev == dev) {
fib_semantics.c:892:					dead = fi->fib_nhs;
fib_semantics.c:897:			if (dead == fi->fib_nhs) {
fib_semantics.c:898:				fi->fib_flags |= RTNH_F_DEAD;
fib_semantics.c:917:	if (!(dev->flags&IFF_UP))
fib_semantics.c:924:			if (!(nh->nh_flags&RTNH_F_DEAD)) {
fib_semantics.c:928:			if (nh->nh_dev == NULL || !(nh->nh_dev->flags&IFF_UP))
fib_semantics.c:930:			if (nh->nh_dev != dev || __in_dev_get(dev) == NULL)
fib_semantics.c:934:			nh->nh_power = 0;
fib_semantics.c:935:			nh->nh_flags &= ~RTNH_F_DEAD;
fib_semantics.c:940:			fi->fib_flags &= ~RTNH_F_DEAD;
fib_semantics.c:954:	struct fib_info *fi = res->fi;
fib_semantics.c:958:	if (fi->fib_power <= 0) {
fib_semantics.c:961:			if (!(nh->nh_flags&RTNH_F_DEAD)) {
fib_semantics.c:962:				power += nh->nh_weight;
fib_semantics.c:963:				nh->nh_power = nh->nh_weight;
fib_semantics.c:966:		fi->fib_power = power;
fib_semantics.c:970:			res->nh_sel = 0;
fib_semantics.c:976:	/* w should be random number [0..fi->fib_power-1],
fib_semantics.c:980:	w = jiffies % fi->fib_power;
fib_semantics.c:983:		if (!(nh->nh_flags&RTNH_F_DEAD) && nh->nh_power) {
fib_semantics.c:984:			if ((w -= nh->nh_power) <= 0) {
fib_semantics.c:985:				nh->nh_power--;
fib_semantics.c:986:				fi->fib_power--;
fib_semantics.c:987:				res->nh_sel = nhsel;
fib_semantics.c:995:	res->nh_sel = 0;
fib_semantics.c:1010:	if (fi && fi->fib_nh->nh_gw)
fib_semantics.c:1026:			      fi->fib_dev ? fi->fib_dev->name : "*", prefix,
fib_semantics.c:1027:			      fi->fib_nh->nh_gw, flags, 0, 0, fi->fib_priority,
fib_semantics.c:1028:			      mask, (fi->fib_advmss ? fi->fib_advmss+40 : 0),
fib_semantics.c:1029:			      fi->fib_window, fi->fib_rtt>>3);
fib_semantics.c:1036:	memset(buffer+len, ' ', 127-len);
hmac-test.c:9:	for(runs = 10; runs > 0; runs--) {
icmp.c:54: *					- IP option length was accounted wrongly
icmp.c:55: *					- ICMP header length was not accounted at all.
icmp.c:61: *	- Should use skb_pull() instead of all the manual checking.
icmp.c:62: *	  This would also greatly simply some upper layer error handlers. --AK
icmp.c:148:/* Control parameter - ignore bogus broadcast responses? */
icmp.c:154: *	ratelimit defines tokens/packet consumed for dst->rate_token bucket
icmp.c:193:	if (unlikely(!spin_trylock(&icmp_socket->sk->lock.slock))) {
icmp.c:205:	spin_unlock_bh(&icmp_socket->sk->lock.slock);
icmp.c:221: *	for one "ip object" is shared - and these ICMPs are twice limited:
icmp.c:235:	dst->rate_tokens += now - dst->rate_last;
icmp.c:236:	dst->rate_last = now;
icmp.c:237:	if (dst->rate_tokens > XRLIM_BURST_FACTOR*timeout)
icmp.c:238:        	dst->rate_tokens = XRLIM_BURST_FACTOR*timeout;
icmp.c:239:	if (dst->rate_tokens >= timeout) {
icmp.c:240:		dst->rate_tokens -= timeout;
icmp.c:248:	struct dst_entry *dst = &rt->u.dst; 
icmp.c:258:	if (dst->dev && (dst->dev->flags&IFF_LOOPBACK))
icmp.c:291:		icmp_param->csum=skb_copy_and_csum_bits(icmp_param->skb,
icmp.c:292:							icmp_param->offset+(offset-icmp_param->head_len), 
icmp.c:293:							to, fraglen,icmp_param->csum);
icmp.c:302:	csum = csum_partial_copy_nocheck((void *)&icmp_param->data,
icmp.c:303:		to, icmp_param->head_len,
icmp.c:304:		icmp_param->csum);
icmp.c:305:	csum=skb_copy_and_csum_bits(icmp_param->skb,
icmp.c:306:				    icmp_param->offset, 
icmp.c:307:				    to+icmp_param->head_len,
icmp.c:308:				    fraglen-icmp_param->head_len,
icmp.c:311:	icmph->checksum = csum_fold(csum);
icmp.c:321:	struct sock *sk=icmp_socket->sk;
icmp.c:323:	struct rtable *rt = (struct rtable*)skb->dst;
icmp.c:326:	if (ip_options_echo(&icmp_param->replyopts, skb))
icmp.c:332:	icmp_param->data.icmph.checksum=0;
icmp.c:333:	icmp_param->csum=0;
icmp.c:334:	icmp_out_count(icmp_param->data.icmph.type);
icmp.c:336:	sk->protinfo.af_inet.tos = skb->nh.iph->tos;
icmp.c:337:	sk->protinfo.af_inet.ttl = sysctl_ip_default_ttl;
icmp.c:338:	daddr = ipc.addr = rt->rt_src;
icmp.c:340:	if (icmp_param->replyopts.optlen) {
icmp.c:341:		ipc.opt = &icmp_param->replyopts;
icmp.c:342:		if (ipc.opt->srr)
icmp.c:343:			daddr = icmp_param->replyopts.faddr;
icmp.c:345:	if (ip_route_output(&rt, daddr, rt->rt_spec_dst, RT_TOS(skb->nh.iph->tos), 0))
icmp.c:347:	if (icmpv4_xrlim_allow(rt, icmp_param->data.icmph.type, 
icmp.c:348:			       icmp_param->data.icmph.code)) { 
icmp.c:350:			      icmp_param->data_len+icmp_param->head_len,
icmp.c:374:	struct rtable *rt = (struct rtable*)skb_in->dst;
icmp.c:387:	iph = skb_in->nh.iph;
icmp.c:389:	if ((u8*)iph < skb_in->head || (u8*)(iph+1) > skb_in->tail)
icmp.c:395:	if (skb_in->pkt_type!=PACKET_HOST)
icmp.c:401:	if (rt->rt_flags&(RTCF_BROADCAST|RTCF_MULTICAST))
icmp.c:405:	 *	Only reply to fragment 0. We byte re-order the constant
icmp.c:408:	if (iph->frag_off&htons(IP_OFFSET))
icmp.c:418:		if (iph->protocol==IPPROTO_ICMP) {
icmp.c:422:					  skb_in->nh.raw + (iph->ihl<<2)
icmp.c:424:					  - skb_in->data,
icmp.c:448:	if (rt->rt_flags&RTCF_NAT && IPCB(skb_in)->flags&IPSKB_TRANSLATED) {
icmp.c:449:		iph->daddr = rt->key.dst;
icmp.c:450:		iph->saddr = rt->key.src;
icmp.c:454:	saddr = iph->daddr;
icmp.c:455:	if (!(rt->rt_flags & RTCF_LOCAL))
icmp.c:459:		((iph->tos & IPTOS_TOS_MASK) | IPTOS_PREC_INTERNETCONTROL) :
icmp.c:460:			iph->tos;
icmp.c:462:	if (ip_route_output(&rt, iph->saddr, saddr, RT_TOS(tos), 0))
icmp.c:479:	icmp_param.offset=skb_in->nh.raw - skb_in->data;
icmp.c:481:	icmp_socket->sk->protinfo.af_inet.tos = tos;
icmp.c:482:	icmp_socket->sk->protinfo.af_inet.ttl = sysctl_ip_default_ttl;
icmp.c:483:	ipc.addr = iph->saddr;
icmp.c:496:	room = rt->u.dst.pmtu;
icmp.c:499:	room -= sizeof(struct iphdr) + icmp_param.replyopts.optlen;
icmp.c:500:	room -= sizeof(struct icmphdr);
icmp.c:502:	icmp_param.data_len=skb_in->len-icmp_param.offset;
icmp.c:507:	ip_build_xmit(icmp_socket->sk, icmp_glue_bits, &icmp_param, 
icmp.c:542:	icmph = skb->h.icmph;
icmp.c:543:	iph = (struct iphdr *) skb->data;
icmp.c:545:	if (iph->ihl<5) {
icmp.c:551:	if(icmph->type==ICMP_DEST_UNREACH) {
icmp.c:552:		switch(icmph->code & 15) {
icmp.c:565:						       NIPQUAD(iph->daddr));
icmp.c:567:					info = ip_rt_frag_needed(iph, ntohs(icmph->un.frag.mtu));
icmp.c:574:					printk(KERN_INFO "ICMP: %u.%u.%u.%u: Source Route Failed.\n", NIPQUAD(iph->daddr));
icmp.c:579:		if (icmph->code>NR_ICMP_UNREACH)
icmp.c:581:	} else if (icmph->type == ICMP_PARAMETERPROB) {
icmp.c:582:		info = ntohl(icmph->un.gateway)>>24;
icmp.c:603:		if (inet_addr_type(iph->daddr) == RTN_BROADCAST)
icmp.c:607:					NIPQUAD(skb->nh.iph->saddr),
icmp.c:608:					icmph->type, icmph->code,
icmp.c:609:					NIPQUAD(iph->daddr),
icmp.c:610:					skb->dev->name);
icmp.c:618:	if (!pskb_may_pull(skb, iph->ihl*4+8))
icmp.c:621:	iph = (struct iphdr *) skb->data;
icmp.c:622:	protocol = iph->protocol;
icmp.c:629:	hash = protocol & (MAX_INET_PROTOS - 1);
icmp.c:633:		while ((raw_sk = __raw_v4_lookup(raw_sk, protocol, iph->daddr,
icmp.c:634:						 iph->saddr, skb->dev->ifindex)) != NULL) {
icmp.c:636:			raw_sk = raw_sk->next;
icmp.c:637:			iph = (struct iphdr *)skb->data;
icmp.c:652:		nextip = (struct inet_protocol *) ipprot->next;
icmp.c:661:		if (protocol == ipprot->protocol && ipprot->err_handler)
icmp.c:662: 			ipprot->err_handler(skb, info);
icmp.c:679:	if (skb->len < sizeof(struct iphdr)) {
icmp.c:690:	iph = (struct iphdr *) skb->data;
icmp.c:691:	ip = iph->daddr;
icmp.c:693:	switch (skb->h.icmph->code & 7) {
icmp.c:703:			ip_rt_redirect(skb->nh.iph->saddr, ip, skb->h.icmph->un.gateway, iph->saddr, iph->tos, skb->dev);
icmp.c:724:		icmp_param.data.icmph=*skb->h.icmph;
icmp.c:728:		icmp_param.data_len=skb->len;
icmp.c:751:	if (skb->len < 4) {
icmp.c:764:	icmp_param.data.icmph=*skb->h.icmph;
icmp.c:783: * I guess. -- MS
icmp.c:789: * Gratuitous replies, zero-source replies are not implemented,
icmp.c:798: * that is pretty silly. --ANK
icmp.c:802: * any case. --ANK
icmp.c:823:	struct rtable *rt = (struct rtable*)skb->dst;
icmp.c:824:	struct net_device *dev = skb->dev;
icmp.c:829:	if (skb->len < 4 || !(rt->rt_flags&RTCF_DIRECTSRC))
icmp.c:835:	read_lock(&in_dev->lock);
icmp.c:836:	if (in_dev->ifa_list &&
icmp.c:841:		for (ifa=in_dev->ifa_list; ifa; ifa = ifa->ifa_next) {
icmp.c:842:			if (mask == ifa->ifa_mask && inet_ifa_match(rt->rt_src, ifa))
icmp.c:847:			       NIPQUAD(mask), dev->name, NIPQUAD(rt->rt_src));
icmp.c:850:	read_unlock(&in_dev->lock);
icmp.c:865:	struct rtable *rt = (struct rtable*)skb->dst;
icmp.c:869:	switch (skb->ip_summed) {
icmp.c:871:		if ((u16)csum_fold(skb->csum) == 0)
icmp.c:875:		if ((u16)csum_fold(skb_checksum(skb, 0, skb->len, 0)))
icmp.c:883:	icmph = skb->h.icmph;
icmp.c:890:	if (icmph->type > NR_ICMP_TYPES)
icmp.c:898: 	if (rt->rt_flags&(RTCF_BROADCAST|RTCF_MULTICAST)) {
icmp.c:905:		if (icmph->type == ICMP_ECHO &&
icmp.c:909:		if (icmph->type != ICMP_ECHO &&
icmp.c:910:		    icmph->type != ICMP_TIMESTAMP &&
icmp.c:911:		    icmph->type != ICMP_ADDRESS &&
icmp.c:912:		    icmph->type != ICMP_ADDRESSREPLY) {
icmp.c:917:	icmp_pointers[icmph->type].input[smp_processor_id()*2*sizeof(struct icmp_mib)/sizeof(unsigned long)]++;
icmp.c:918:	(icmp_pointers[icmph->type].handler)(skb);
icmp.c:979:		icmp_socket_cpu(i)->inode = &__icmp_inode[i];
icmp.c:980:		icmp_socket_cpu(i)->state = SS_UNCONNECTED;
icmp.c:981:		icmp_socket_cpu(i)->type = SOCK_RAW;
icmp.c:983:		if ((err=ops->create(icmp_socket_cpu(i), IPPROTO_ICMP)) < 0)
icmp.c:986:		icmp_socket_cpu(i)->sk->allocation=GFP_ATOMIC;
icmp.c:991:		icmp_socket_cpu(i)->sk->sndbuf =
icmp.c:994:		icmp_socket_cpu(i)->sk->protinfo.af_inet.ttl = MAXTTL;
icmp.c:995:		icmp_socket_cpu(i)->sk->protinfo.af_inet.pmtudisc = IP_PMTUDISC_DONT;
icmp.c:1001:		icmp_socket_cpu(i)->sk->prot->unhash(icmp_socket_cpu(i)->sk);
igmp.c:36: *		Chih-Jen Chang	:	Tried to revise IGMP to Version 2
igmp.c:37: *		Tsu-Sheng Tsao		E-mail: chihjenc@scf.usc.edu and tsusheng@scf.usc.edu
igmp.c:39: * 					ipmulti-3.5 source code.
igmp.c:40: *		Chih-Jen Chang	:	Added the igmp_get_mrouter_info and
igmp.c:41: *		Tsu-Sheng Tsao		igmp_set_mrouter_info to keep track of
igmp.c:43: *		Chih-Jen Chang	:	Added the max_resp_time parameter to
igmp.c:44: *		Tsu-Sheng Tsao		igmp_heard_query(). Using this parameter
igmp.c:47: *		Chih-Jen Chang	:	Added a timer to revert to IGMP V2 router
igmp.c:48: *		Tsu-Sheng Tsao		if the specified time expired.
igmp.c:59: *                                     igmp_timer_expire if tm->running is
igmp.c:70: *		Alexey Kuznetsov:	Accordance to igmp-v2-06 draft.
igmp.c:108:/* Parameter names and values are taken from igmp-v2-06 draft */
igmp.c:127:		(in_dev)->cnf.force_igmp_version == 1 || \
igmp.c:128:		((in_dev)->mr_v1_seen && \
igmp.c:129:		time_before(jiffies, (in_dev)->mr_v1_seen)))
igmp.c:131:		(in_dev)->cnf.force_igmp_version == 2 || \
igmp.c:132:		((in_dev)->mr_v2_seen && \
igmp.c:133:		time_before(jiffies, (in_dev)->mr_v2_seen)))
igmp.c:147:	if (atomic_dec_and_test(&im->refcnt)) {
igmp.c:148:		in_dev_put(im->interface);
igmp.c:161:	spin_lock_bh(&im->lock);
igmp.c:162:	if (del_timer(&im->timer))
igmp.c:163:		atomic_dec(&im->refcnt);
igmp.c:164:	im->tm_running=0;
igmp.c:165:	im->reporter = 0;
igmp.c:166:	im->unsolicit_count = 0;
igmp.c:167:	spin_unlock_bh(&im->lock);
igmp.c:170:/* It must be called with locked im->lock */
igmp.c:175:	im->tm_running=1;
igmp.c:176:	if (!mod_timer(&im->timer, jiffies+tv+2))
igmp.c:177:		atomic_inc(&im->refcnt);
igmp.c:182:	int tv = net_random() % in_dev->mr_maxdelay;
igmp.c:184:	in_dev->mr_gq_running = 1;
igmp.c:185:	if (!mod_timer(&in_dev->mr_gq_timer, jiffies+tv+2))
igmp.c:193:	if (!mod_timer(&in_dev->mr_ifc_timer, jiffies+tv+2))
igmp.c:199:	spin_lock_bh(&im->lock);
igmp.c:200:	im->unsolicit_count = 0;
igmp.c:201:	if (del_timer(&im->timer)) {
igmp.c:202:		if ((long)(im->timer.expires-jiffies) < max_delay) {
igmp.c:203:			add_timer(&im->timer);
igmp.c:204:			im->tm_running=1;
igmp.c:205:			spin_unlock_bh(&im->lock);
igmp.c:208:		atomic_dec(&im->refcnt);
igmp.c:211:	spin_unlock_bh(&im->lock);
igmp.c:221:/* Don't just hand NF_HOOK skb->dst->output, in case netfilter hook
igmp.c:226:	return skb->dst->output(skb);
igmp.c:238:		return !(pmc->gsquery && !psf->sf_gsresp);
igmp.c:242:		return psf->sf_count[MCAST_INCLUDE] != 0;
igmp.c:246:		if (pmc->sfcount[MCAST_EXCLUDE] == 0 ||
igmp.c:247:		    psf->sf_count[MCAST_INCLUDE])
igmp.c:249:		return pmc->sfcount[MCAST_EXCLUDE] ==
igmp.c:250:			psf->sf_count[MCAST_EXCLUDE];
igmp.c:252:		if (gdeleted || !psf->sf_crcount)
igmp.c:254:		return (pmc->sfmode == MCAST_INCLUDE) ^ sdeleted;
igmp.c:256:		if (pmc->sfmode == MCAST_INCLUDE)
igmp.c:257:			return gdeleted || (psf->sf_crcount && sdeleted);
igmp.c:258:		return psf->sf_crcount && !gdeleted && !sdeleted;
igmp.c:269:	for (psf=pmc->sources; psf; psf=psf->sf_next) {
igmp.c:286:	if (ip_route_output(&rt, dst, 0, 0, dev->ifindex))
igmp.c:288:	if (rt->rt_src == 0) {
igmp.c:292:	skb = alloc_skb(size + dev->hard_header_len + 15, GFP_ATOMIC);
igmp.c:298:	skb->dst = &rt->u.dst;
igmp.c:299:	skb->dev = dev;
igmp.c:301:	skb_reserve(skb, (dev->hard_header_len+15)&~15);
igmp.c:303:	skb->nh.iph = pip =(struct iphdr *)skb_put(skb, sizeof(struct iphdr)+4);
igmp.c:305:	pip->version  = 4;
igmp.c:306:	pip->ihl      = (sizeof(struct iphdr)+4)>>2;
igmp.c:307:	pip->tos      = 0xc0;
igmp.c:308:	pip->frag_off = htons(IP_DF);
igmp.c:309:	pip->ttl      = 1;
igmp.c:310:	pip->daddr    = rt->rt_dst;
igmp.c:311:	pip->saddr    = rt->rt_src;
igmp.c:312:	pip->protocol = IPPROTO_IGMP;
igmp.c:313:	pip->tot_len  = 0;	/* filled in later */
igmp.c:314:	ip_select_ident(pip, &rt->u.dst, NULL);
igmp.c:321:	skb->h.igmph = (struct igmphdr *)pig;
igmp.c:322:	pig->type = IGMPV3_HOST_MEMBERSHIP_REPORT;
igmp.c:323:	pig->resv1 = 0;
igmp.c:324:	pig->csum = 0;
igmp.c:325:	pig->resv2 = 0;
igmp.c:326:	pig->ngrec = 0;
igmp.c:332:	struct iphdr *pip = skb->nh.iph;
igmp.c:333:	struct igmphdr *pig = skb->h.igmph;
igmp.c:336:	iplen = skb->tail - (unsigned char *)skb->nh.iph;
igmp.c:337:	pip->tot_len = htons(iplen);
igmp.c:340:	igmplen = skb->tail - (unsigned char *)skb->h.igmph;
igmp.c:341:	pig->csum = ip_compute_csum((void *)skb->h.igmph, igmplen);
igmp.c:343:	return NF_HOOK(PF_INET, NF_IP_LOCAL_OUT, skb, NULL, skb->dev,
igmp.c:355:	struct net_device *dev = pmc->interface->dev;
igmp.c:360:		skb = igmpv3_newpack(dev, dev->mtu);
igmp.c:364:	pgr->grec_type = type;
igmp.c:365:	pgr->grec_auxwords = 0;
igmp.c:366:	pgr->grec_nsrcs = 0;
igmp.c:367:	pgr->grec_mca = pmc->multiaddr;
igmp.c:368:	pih = (struct igmpv3_report *)skb->h.igmph;
igmp.c:369:	pih->ngrec = htons(ntohs(pih->ngrec)+1);
igmp.c:374:#define AVAILABLE(skb) ((skb) ? ((skb)->dev ? (skb)->dev->mtu - (skb)->len : \
igmp.c:380:	struct net_device *dev = pmc->interface->dev;
igmp.c:386:	if (pmc->multiaddr == IGMP_ALL_HOSTS)
igmp.c:394:	psf_list = sdeleted ? &pmc->tomb : &pmc->sources;
igmp.c:400:		if (pmc->crcount || isquery) {
igmp.c:413:	pih = skb ? (struct igmpv3_report *)skb->h.igmph : 0;
igmp.c:417:		if (pih && pih->ngrec &&
igmp.c:421:			skb = igmpv3_newpack(dev, dev->mtu);
igmp.c:430:		psf_next = psf->sf_next;
igmp.c:439:			psf->sf_gsresp = 0;
igmp.c:446:				pgr->grec_nsrcs = htons(scount);
igmp.c:449:			skb = igmpv3_newpack(dev, dev->mtu);
igmp.c:458:		*psrc = psf->sf_inaddr;
igmp.c:461:		     type == IGMPV3_BLOCK_OLD_SOURCES) && psf->sf_crcount) {
igmp.c:462:			psf->sf_crcount--;
igmp.c:463:			if ((sdeleted || gdeleted) && psf->sf_crcount == 0) {
igmp.c:465:					psf_prev->sf_next = psf->sf_next;
igmp.c:467:					*psf_list = psf->sf_next;
igmp.c:475:		pgr->grec_nsrcs = htons(scount);
igmp.c:478:		pmc->gsquery = 0;	/* clear query state on report */
igmp.c:488:		read_lock(&in_dev->lock);
igmp.c:489:		for (pmc=in_dev->mc_list; pmc; pmc=pmc->next) {
igmp.c:490:			if (pmc->multiaddr == IGMP_ALL_HOSTS)
igmp.c:492:			spin_lock_bh(&pmc->lock);
igmp.c:493:			if (pmc->sfcount[MCAST_EXCLUDE])
igmp.c:498:			spin_unlock_bh(&pmc->lock);
igmp.c:500:		read_unlock(&in_dev->lock);
igmp.c:502:		spin_lock_bh(&pmc->lock);
igmp.c:503:		if (pmc->sfcount[MCAST_EXCLUDE])
igmp.c:508:		spin_unlock_bh(&pmc->lock);
igmp.c:516: * remove zero-count source records from a source filter list
igmp.c:524:		psf_next = psf->sf_next;
igmp.c:525:		if (psf->sf_crcount == 0) {
igmp.c:527:				psf_prev->sf_next = psf->sf_next;
igmp.c:529:				*ppsf = psf->sf_next;
igmp.c:542:	read_lock(&in_dev->lock);
igmp.c:543:	write_lock_bh(&in_dev->mc_lock);
igmp.c:547:	for (pmc=in_dev->mc_tomb; pmc; pmc=pmc_next) {
igmp.c:548:		pmc_next = pmc->next;
igmp.c:549:		if (pmc->sfmode == MCAST_INCLUDE) {
igmp.c:555:		if (pmc->crcount) {
igmp.c:556:			pmc->crcount--;
igmp.c:557:			if (pmc->sfmode == MCAST_EXCLUDE) {
igmp.c:561:			if (pmc->crcount == 0) {
igmp.c:562:				igmpv3_clear_zeros(&pmc->tomb);
igmp.c:563:				igmpv3_clear_zeros(&pmc->sources);
igmp.c:566:		if (pmc->crcount == 0 && !pmc->tomb && !pmc->sources) {
igmp.c:568:				pmc_prev->next = pmc_next;
igmp.c:570:				in_dev->mc_tomb = pmc_next;
igmp.c:571:			in_dev_put(pmc->interface);
igmp.c:576:	write_unlock_bh(&in_dev->mc_lock);
igmp.c:579:	for (pmc=in_dev->mc_list; pmc; pmc=pmc->next) {
igmp.c:580:		spin_lock_bh(&pmc->lock);
igmp.c:581:		if (pmc->sfcount[MCAST_EXCLUDE]) {
igmp.c:592:		if (pmc->crcount) {
igmp.c:593:			pmc->crcount--;
igmp.c:594:			if (pmc->sfmode == MCAST_EXCLUDE)
igmp.c:600:		spin_unlock_bh(&pmc->lock);
igmp.c:602:	read_unlock(&in_dev->lock);
igmp.c:615:	struct net_device *dev = in_dev->dev;
igmp.c:616:	u32	group = pmc ? pmc->multiaddr : 0;
igmp.c:626:	if (ip_route_output(&rt, dst, 0, 0, dev->ifindex))
igmp.c:627:		return -1;
igmp.c:628:	if (rt->rt_src == 0) {
igmp.c:630:		return -1;
igmp.c:633:	skb=alloc_skb(IGMP_SIZE+dev->hard_header_len+15, GFP_ATOMIC);
igmp.c:636:		return -1;
igmp.c:639:	skb->dst = &rt->u.dst;
igmp.c:641:	skb_reserve(skb, (dev->hard_header_len+15)&~15);
igmp.c:643:	skb->nh.iph = iph = (struct iphdr *)skb_put(skb, sizeof(struct iphdr)+4);
igmp.c:645:	iph->version  = 4;
igmp.c:646:	iph->ihl      = (sizeof(struct iphdr)+4)>>2;
igmp.c:647:	iph->tos      = 0xc0;
igmp.c:648:	iph->frag_off = htons(IP_DF);
igmp.c:649:	iph->ttl      = 1;
igmp.c:650:	iph->daddr    = dst;
igmp.c:651:	iph->saddr    = rt->rt_src;
igmp.c:652:	iph->protocol = IPPROTO_IGMP;
igmp.c:653:	iph->tot_len  = htons(IGMP_SIZE);
igmp.c:654:	ip_select_ident(iph, &rt->u.dst, NULL);
igmp.c:662:	ih->type=type;
igmp.c:663:	ih->code=0;
igmp.c:664:	ih->csum=0;
igmp.c:665:	ih->group=group;
igmp.c:666:	ih->csum=ip_compute_csum((void *)ih, sizeof(struct igmphdr));
igmp.c:668:	return NF_HOOK(PF_INET, NF_IP_LOCAL_OUT, skb, NULL, rt->u.dst.dev,
igmp.c:676:	in_dev->mr_gq_running = 0;
igmp.c:686:	if (in_dev->mr_ifc_count) {
igmp.c:687:		in_dev->mr_ifc_count--;
igmp.c:697:	in_dev->mr_ifc_count = in_dev->mr_qrv ? in_dev->mr_qrv : 
igmp.c:706:	struct in_device *in_dev = im->interface;
igmp.c:708:	spin_lock(&im->lock);
igmp.c:709:	im->tm_running=0;
igmp.c:711:	if (im->unsolicit_count) {
igmp.c:712:		im->unsolicit_count--;
igmp.c:715:	im->reporter = 1;
igmp.c:716:	spin_unlock(&im->lock);
igmp.c:734:	for (psf=pmc->sources; psf; psf=psf->sf_next) {
igmp.c:738:			if (srcs[i] == psf->sf_inaddr) {
igmp.c:739:				psf->sf_gsresp = 1;
igmp.c:750:	/* Timers are only set for non-local groups */
igmp.c:755:	read_lock(&in_dev->lock);
igmp.c:756:	for (im=in_dev->mc_list; im!=NULL; im=im->next) {
igmp.c:757:		if (im->multiaddr == group) {
igmp.c:762:	read_unlock(&in_dev->lock);
igmp.c:770:	u32			group = ih->group;
igmp.c:776:		if (ih->code == 0) {
igmp.c:780:			in_dev->mr_v1_seen = jiffies +
igmp.c:785:			max_delay = ih->code*(HZ/IGMP_TIMER_SCALE);
igmp.c:786:			in_dev->mr_v2_seen = jiffies +
igmp.c:790:		in_dev->mr_ifc_count = 0;
igmp.c:791:		if (del_timer(&in_dev->mr_ifc_timer))
igmp.c:798:		max_delay = IGMPV3_MRC(ih3->code)*(HZ/IGMP_TIMER_SCALE);
igmp.c:801:		in_dev->mr_maxdelay = max_delay;
igmp.c:802:		if (ih3->qrv)
igmp.c:803:			in_dev->mr_qrv = ih3->qrv;
igmp.c:805:			if (ih3->nsrcs)
igmp.c:810:		/* mark sources to include, if group & source-specific */
igmp.c:811:		mark = ih3->nsrcs != 0;
igmp.c:815:	 * - Start the timers in all of our membership records
igmp.c:819:	 * - For timers already running check if they need to
igmp.c:821:	 * - Use the igmp->igmp_code field as the maximum
igmp.c:824:	read_lock(&in_dev->lock);
igmp.c:825:	for (im=in_dev->mc_list; im!=NULL; im=im->next) {
igmp.c:826:		if (group && group != im->multiaddr)
igmp.c:828:		if (im->multiaddr == IGMP_ALL_HOSTS)
igmp.c:830:		spin_lock_bh(&im->lock);
igmp.c:831:		if (im->tm_running)
igmp.c:832:			im->gsquery = im->gsquery && mark;
igmp.c:834:			im->gsquery = mark;
igmp.c:835:		if (im->gsquery)
igmp.c:836:			igmp_marksources(im, ntohs(ih3->nsrcs), ih3->srcs);
igmp.c:837:		spin_unlock_bh(&im->lock);
igmp.c:840:	read_unlock(&in_dev->lock);
igmp.c:845:	/* This basically follows the spec line by line -- see RFC1112 */
igmp.c:846:	struct igmphdr *ih = skb->h.igmph;
igmp.c:847:	struct in_device *in_dev = in_dev_get(skb->dev);
igmp.c:848:	int len = skb->len;
igmp.c:858:			return -ENOMEM;
igmp.c:860:		ih = skb->h.igmph;
igmp.c:869:	switch (ih->type) {
igmp.c:877:		if (((struct rtable*)skb->dst)->key.iif == 0)
igmp.c:879:		igmp_heard_report(in_dev, ih->group);
igmp.c:893:		NETDEBUG(printk(KERN_DEBUG "New IGMP type=%d, why we do not know about it?\n", ih->type));
igmp.c:910:	struct net_device *dev = in_dev->dev;
igmp.c:912:	/* Checking for IFF_MULTICAST here is WRONG-WRONG-WRONG.
igmp.c:914:	   is changed. This check should be done in dev->set_multicast_list
igmp.c:916:	   if (dev->mc_list && dev->flags&IFF_MULTICAST) { do it; }
igmp.c:917:	   --ANK
igmp.c:920:		dev_mc_add(dev,buf,dev->addr_len,0);
igmp.c:930:	struct net_device *dev = in_dev->dev;
igmp.c:933:		dev_mc_delete(dev,buf,dev->addr_len,0);
igmp.c:948:	 * non-deleted or query-response MCA's.
igmp.c:954:	spin_lock_bh(&im->lock);
igmp.c:955:	pmc->interface = im->interface;
igmp.c:957:	pmc->multiaddr = im->multiaddr;
igmp.c:958:	pmc->crcount = in_dev->mr_qrv ? in_dev->mr_qrv :
igmp.c:960:	pmc->sfmode = im->sfmode;
igmp.c:961:	if (pmc->sfmode == MCAST_INCLUDE) {
igmp.c:964:		pmc->tomb = im->tomb;
igmp.c:965:		pmc->sources = im->sources;
igmp.c:966:		im->tomb = im->sources = 0;
igmp.c:967:		for (psf=pmc->sources; psf; psf=psf->sf_next)
igmp.c:968:			psf->sf_crcount = pmc->crcount;
igmp.c:970:	spin_unlock_bh(&im->lock);
igmp.c:972:	write_lock_bh(&in_dev->mc_lock);
igmp.c:973:	pmc->next = in_dev->mc_tomb;
igmp.c:974:	in_dev->mc_tomb = pmc;
igmp.c:975:	write_unlock_bh(&in_dev->mc_lock);
igmp.c:983:	write_lock_bh(&in_dev->mc_lock);
igmp.c:985:	for (pmc=in_dev->mc_tomb; pmc; pmc=pmc->next) {
igmp.c:986:		if (pmc->multiaddr == multiaddr)
igmp.c:992:			pmc_prev->next = pmc->next;
igmp.c:994:			in_dev->mc_tomb = pmc->next;
igmp.c:996:	write_unlock_bh(&in_dev->mc_lock);
igmp.c:998:		for (psf=pmc->tomb; psf; psf=psf_next) {
igmp.c:999:			psf_next = psf->sf_next;
igmp.c:1002:		in_dev_put(pmc->interface);
igmp.c:1011:	write_lock_bh(&in_dev->mc_lock);
igmp.c:1012:	pmc = in_dev->mc_tomb;
igmp.c:1013:	in_dev->mc_tomb = 0;
igmp.c:1014:	write_unlock_bh(&in_dev->mc_lock);
igmp.c:1017:		nextpmc = pmc->next;
igmp.c:1019:		in_dev_put(pmc->interface);
igmp.c:1023:	read_lock(&in_dev->lock);
igmp.c:1024:	for (pmc=in_dev->mc_list; pmc; pmc=pmc->next) {
igmp.c:1027:		spin_lock_bh(&pmc->lock);
igmp.c:1028:		psf = pmc->tomb;
igmp.c:1029:		pmc->tomb = 0;
igmp.c:1030:		spin_unlock_bh(&pmc->lock);
igmp.c:1032:			psf_next = psf->sf_next;
igmp.c:1036:	read_unlock(&in_dev->lock);
igmp.c:1042:	struct in_device *in_dev = im->interface;
igmp.c:1047:	if (im->loaded) {
igmp.c:1048:		im->loaded = 0;
igmp.c:1049:		ip_mc_filter_del(in_dev, im->multiaddr);
igmp.c:1053:	if (im->multiaddr == IGMP_ALL_HOSTS)
igmp.c:1056:	reporter = im->reporter;
igmp.c:1059:	if (!in_dev->dead) {
igmp.c:1079:	struct in_device *in_dev = im->interface;
igmp.c:1081:	if (im->loaded == 0) {
igmp.c:1082:		im->loaded = 1;
igmp.c:1083:		ip_mc_filter_add(in_dev, im->multiaddr);
igmp.c:1087:	if (im->multiaddr == IGMP_ALL_HOSTS)
igmp.c:1090:	if (in_dev->dead)
igmp.c:1093:		spin_lock_bh(&im->lock);
igmp.c:1095:		spin_unlock_bh(&im->lock);
igmp.c:1100:	im->crcount = in_dev->mr_qrv ? in_dev->mr_qrv :
igmp.c:1122:	for (im=in_dev->mc_list; im; im=im->next) {
igmp.c:1123:		if (im->multiaddr == addr) {
igmp.c:1124:			im->users++;
igmp.c:1134:	im->users=1;
igmp.c:1135:	im->interface=in_dev;
igmp.c:1137:	im->multiaddr=addr;
igmp.c:1139:	im->sfmode = MCAST_EXCLUDE;
igmp.c:1140:	im->sfcount[MCAST_INCLUDE] = 0;
igmp.c:1141:	im->sfcount[MCAST_EXCLUDE] = 1;
igmp.c:1142:	im->sources = 0;
igmp.c:1143:	im->tomb = 0;
igmp.c:1144:	im->crcount = 0;
igmp.c:1145:	atomic_set(&im->refcnt, 1);
igmp.c:1146:	spin_lock_init(&im->lock);
igmp.c:1148:	im->tm_running=0;
igmp.c:1149:	init_timer(&im->timer);
igmp.c:1150:	im->timer.data=(unsigned long)im;
igmp.c:1151:	im->timer.function=&igmp_timer_expire;
igmp.c:1152:	im->unsolicit_count = IGMP_Unsolicited_Report_Count;
igmp.c:1153:	im->reporter = 0;
igmp.c:1154:	im->gsquery = 0;
igmp.c:1156:	im->loaded = 0;
igmp.c:1157:	write_lock_bh(&in_dev->lock);
igmp.c:1158:	im->next=in_dev->mc_list;
igmp.c:1159:	in_dev->mc_list=im;
igmp.c:1160:	write_unlock_bh(&in_dev->lock);
igmp.c:1162:	igmpv3_del_delrec(in_dev, im->multiaddr);
igmp.c:1165:	if (!in_dev->dead)
igmp.c:1181:	for (ip=&in_dev->mc_list; (i=*ip)!=NULL; ip=&i->next) {
igmp.c:1182:		if (i->multiaddr==addr) {
igmp.c:1183:			if (--i->users == 0) {
igmp.c:1184:				write_lock_bh(&in_dev->lock);
igmp.c:1185:				*ip = i->next;
igmp.c:1186:				write_unlock_bh(&in_dev->lock);
igmp.c:1189:				if (!in_dev->dead)
igmp.c:1208:	for (i=in_dev->mc_list; i; i=i->next)
igmp.c:1212:	in_dev->mr_ifc_count = 0;
igmp.c:1213:	if (del_timer(&in_dev->mr_ifc_timer))
igmp.c:1215:	in_dev->mr_gq_running = 0;
igmp.c:1216:	if (del_timer(&in_dev->mr_gq_timer))
igmp.c:1228:	in_dev->mc_tomb = 0;
igmp.c:1230:	in_dev->mr_gq_running = 0;
igmp.c:1231:	init_timer(&in_dev->mr_gq_timer);
igmp.c:1232:	in_dev->mr_gq_timer.data=(unsigned long) in_dev;
igmp.c:1233:	in_dev->mr_gq_timer.function=&igmp_gq_timer_expire;
igmp.c:1234:	in_dev->mr_ifc_count = 0;
igmp.c:1235:	init_timer(&in_dev->mr_ifc_timer);
igmp.c:1236:	in_dev->mr_ifc_timer.data=(unsigned long) in_dev;
igmp.c:1237:	in_dev->mr_ifc_timer.function=&igmp_ifc_timer_expire;
igmp.c:1238:	in_dev->mr_qrv = IGMP_Unsolicited_Report_Count;
igmp.c:1241:	in_dev->mc_lock = RW_LOCK_UNLOCKED;
igmp.c:1254:	for (i=in_dev->mc_list; i; i=i->next)
igmp.c:1271:	write_lock_bh(&in_dev->lock);
igmp.c:1272:	while ((i = in_dev->mc_list) != NULL) {
igmp.c:1273:		in_dev->mc_list = i->next;
igmp.c:1274:		write_unlock_bh(&in_dev->lock);
igmp.c:1279:		write_lock_bh(&in_dev->lock);
igmp.c:1281:	write_unlock_bh(&in_dev->lock);
igmp.c:1290:	if (imr->imr_ifindex) {
igmp.c:1291:		idev = inetdev_by_index(imr->imr_ifindex);
igmp.c:1296:	if (imr->imr_address.s_addr) {
igmp.c:1297:		dev = ip_dev_find(imr->imr_address.s_addr);
igmp.c:1303:	if (!dev && !ip_route_output(&rt, imr->imr_multiaddr.s_addr, 0, 0, 0)) {
igmp.c:1304:		dev = rt->u.dst.dev;
igmp.c:1308:		imr->imr_ifindex = dev->ifindex;
igmp.c:1328:	for (psf=pmc->sources; psf; psf=psf->sf_next) {
igmp.c:1329:		if (psf->sf_inaddr == *psfsrc)
igmp.c:1333:	if (!psf || psf->sf_count[sfmode] == 0) {
igmp.c:1335:		return -ESRCH;
igmp.c:1337:	psf->sf_count[sfmode]--;
igmp.c:1338:	if (psf->sf_count[sfmode] == 0) {
igmp.c:1339:		ip_rt_multicast_event(pmc->interface);
igmp.c:1341:	if (!psf->sf_count[MCAST_INCLUDE] && !psf->sf_count[MCAST_EXCLUDE]) {
igmp.c:1343:		struct in_device *in_dev = pmc->interface;
igmp.c:1348:			psf_prev->sf_next = psf->sf_next;
igmp.c:1350:			pmc->sources = psf->sf_next;
igmp.c:1352:		if (psf->sf_oldin &&
igmp.c:1354:			psf->sf_crcount = in_dev->mr_qrv ? in_dev->mr_qrv : 
igmp.c:1356:			psf->sf_next = pmc->tomb;
igmp.c:1357:			pmc->tomb = psf;
igmp.c:1374:		return -ENODEV;
igmp.c:1375:	read_lock(&in_dev->lock);
igmp.c:1376:	for (pmc=in_dev->mc_list; pmc; pmc=pmc->next) {
igmp.c:1377:		if (*pmca == pmc->multiaddr)
igmp.c:1382:		read_unlock(&in_dev->lock);
igmp.c:1383:		return -ESRCH;
igmp.c:1385:	spin_lock_bh(&pmc->lock);
igmp.c:1386:	read_unlock(&in_dev->lock);
igmp.c:1391:		err = -EINVAL;
igmp.c:1392:		if (!pmc->sfcount[sfmode])
igmp.c:1394:		pmc->sfcount[sfmode]--;
igmp.c:1404:	if (pmc->sfmode == MCAST_EXCLUDE &&
igmp.c:1405:	    pmc->sfcount[MCAST_EXCLUDE] == 0 &&
igmp.c:1406:	    pmc->sfcount[MCAST_INCLUDE]) {
igmp.c:1412:		pmc->sfmode = MCAST_INCLUDE;
igmp.c:1414:		pmc->crcount = in_dev->mr_qrv ? in_dev->mr_qrv : 
igmp.c:1416:		in_dev->mr_ifc_count = pmc->crcount;
igmp.c:1417:		for (psf=pmc->sources; psf; psf = psf->sf_next)
igmp.c:1418:			psf->sf_crcount = 0;
igmp.c:1419:		igmp_ifc_event(pmc->interface);
igmp.c:1421:		igmp_ifc_event(pmc->interface);
igmp.c:1425:	spin_unlock_bh(&pmc->lock);
igmp.c:1430: * Add multicast single-source filter to the interface list
igmp.c:1438:	for (psf=pmc->sources; psf; psf=psf->sf_next) {
igmp.c:1439:		if (psf->sf_inaddr == *psfsrc)
igmp.c:1446:			return -ENOBUFS;
igmp.c:1448:		psf->sf_inaddr = *psfsrc;
igmp.c:1450:			psf_prev->sf_next = psf;
igmp.c:1452:			pmc->sources = psf;
igmp.c:1454:	psf->sf_count[sfmode]++;
igmp.c:1455:	if (psf->sf_count[sfmode] == 1) {
igmp.c:1456:		ip_rt_multicast_event(pmc->interface);
igmp.c:1465:	int mca_xcount = pmc->sfcount[MCAST_EXCLUDE];
igmp.c:1467:	for (psf=pmc->sources; psf; psf=psf->sf_next)
igmp.c:1468:		if (pmc->sfcount[MCAST_EXCLUDE]) {
igmp.c:1469:			psf->sf_oldin = mca_xcount ==
igmp.c:1470:				psf->sf_count[MCAST_EXCLUDE] &&
igmp.c:1471:				!psf->sf_count[MCAST_INCLUDE];
igmp.c:1473:			psf->sf_oldin = psf->sf_count[MCAST_INCLUDE] != 0;
igmp.c:1479:	int mca_xcount = pmc->sfcount[MCAST_EXCLUDE];
igmp.c:1480:	int qrv = pmc->interface->mr_qrv;
igmp.c:1484:	for (psf=pmc->sources; psf; psf=psf->sf_next) {
igmp.c:1485:		if (pmc->sfcount[MCAST_EXCLUDE]) {
igmp.c:1486:			new_in = mca_xcount == psf->sf_count[MCAST_EXCLUDE] &&
igmp.c:1487:				!psf->sf_count[MCAST_INCLUDE];
igmp.c:1489:			new_in = psf->sf_count[MCAST_INCLUDE] != 0;
igmp.c:1490:		if (new_in != psf->sf_oldin) {
igmp.c:1491:			psf->sf_crcount = qrv;
igmp.c:1510:		return -ENODEV;
igmp.c:1511:	read_lock(&in_dev->lock);
igmp.c:1512:	for (pmc=in_dev->mc_list; pmc; pmc=pmc->next) {
igmp.c:1513:		if (*pmca == pmc->multiaddr)
igmp.c:1518:		read_unlock(&in_dev->lock);
igmp.c:1519:		return -ESRCH;
igmp.c:1521:	spin_lock_bh(&pmc->lock);
igmp.c:1522:	read_unlock(&in_dev->lock);
igmp.c:1527:	isexclude = pmc->sfmode == MCAST_EXCLUDE;
igmp.c:1529:		pmc->sfcount[sfmode]++;
igmp.c:1539:		pmc->sfcount[sfmode]--;
igmp.c:1542:	} else if (isexclude != (pmc->sfcount[MCAST_EXCLUDE] != 0)) {
igmp.c:1544:		struct in_device *in_dev = pmc->interface;
igmp.c:1549:		if (pmc->sfcount[MCAST_EXCLUDE])
igmp.c:1550:			pmc->sfmode = MCAST_EXCLUDE;
igmp.c:1551:		else if (pmc->sfcount[MCAST_INCLUDE])
igmp.c:1552:			pmc->sfmode = MCAST_INCLUDE;
igmp.c:1556:		pmc->crcount = in_dev->mr_qrv ? in_dev->mr_qrv : 
igmp.c:1558:		in_dev->mr_ifc_count = pmc->crcount;
igmp.c:1559:		for (psf=pmc->sources; psf; psf = psf->sf_next)
igmp.c:1560:			psf->sf_crcount = 0;
igmp.c:1566:	spin_unlock_bh(&pmc->lock);
igmp.c:1574:	for (psf=pmc->tomb; psf; psf=nextpsf) {
igmp.c:1575:		nextpsf = psf->sf_next;
igmp.c:1578:	pmc->tomb = 0;
igmp.c:1579:	for (psf=pmc->sources; psf; psf=nextpsf) {
igmp.c:1580:		nextpsf = psf->sf_next;
igmp.c:1583:	pmc->sources = 0;
igmp.c:1584:	pmc->sfmode = MCAST_EXCLUDE;
igmp.c:1585:	pmc->sfcount[MCAST_EXCLUDE] = 0;
igmp.c:1586:	pmc->sfcount[MCAST_EXCLUDE] = 1;
igmp.c:1596:	u32 addr = imr->imr_multiaddr.s_addr;
igmp.c:1599:	struct inet_opt *inet = &sk->protinfo.af_inet;
igmp.c:1603:		return -EINVAL;
igmp.c:1611:		err = -ENODEV;
igmp.c:1617:	err = -EADDRINUSE;
igmp.c:1618:	for (i = inet->mc_list; i; i = i->next) {
igmp.c:1619:		if (memcmp(&i->multi, imr, sizeof(*imr)) == 0) {
igmp.c:1621:			if (imr->imr_address.s_addr == 0) {
igmp.c:1622:				i->count++;
igmp.c:1629:	err = -ENOBUFS;
igmp.c:1632:	memcpy(&iml->multi, imr, sizeof(*imr));
igmp.c:1633:	iml->next = sk->protinfo.af_inet.mc_list;
igmp.c:1634:	iml->count = 1;
igmp.c:1635:	iml->sflist = NULL;
igmp.c:1636:	iml->sfmode = MCAST_EXCLUDE;
igmp.c:1637:	inet->mc_list = iml;
igmp.c:1654:	if (iml->sflist == 0) {
igmp.c:1655:		/* any-source empty exclude case */
igmp.c:1656:		return ip_mc_del_src(in_dev, &iml->multi.imr_multiaddr.s_addr,
igmp.c:1657:			iml->sfmode, 0, 0, 0);
igmp.c:1659:	err = ip_mc_del_src(in_dev, &iml->multi.imr_multiaddr.s_addr,
igmp.c:1660:			iml->sfmode, iml->sflist->sl_count,
igmp.c:1661:			iml->sflist->sl_addr, 0);
igmp.c:1662:	sock_kfree_s(sk, iml->sflist, IP_SFLSIZE(iml->sflist->sl_max));
igmp.c:1663:	iml->sflist = 0;
igmp.c:1673:	struct inet_opt *inet = &sk->protinfo.af_inet;
igmp.c:1677:	for (imlp = &inet->mc_list; (iml = *imlp) != NULL; imlp = &iml->next) {
igmp.c:1678:		if (iml->multi.imr_multiaddr.s_addr==imr->imr_multiaddr.s_addr &&
igmp.c:1679:		    iml->multi.imr_address.s_addr==imr->imr_address.s_addr &&
igmp.c:1680:		    (!imr->imr_ifindex || iml->multi.imr_ifindex==imr->imr_ifindex)) {
igmp.c:1683:			in_dev = inetdev_by_index(iml->multi.imr_ifindex);
igmp.c:1686:			if (--iml->count) {
igmp.c:1693:			*imlp = iml->next;
igmp.c:1696:				ip_mc_dec_group(in_dev, imr->imr_multiaddr.s_addr);
igmp.c:1705:	return -EADDRNOTAVAIL;
igmp.c:1713:	u32 addr = mreqs->imr_multiaddr;
igmp.c:1716:	struct inet_opt *inet = &sk->protinfo.af_inet;
igmp.c:1721:		return -EINVAL;
igmp.c:1725:	imr.imr_multiaddr.s_addr = mreqs->imr_multiaddr;
igmp.c:1726:	imr.imr_address.s_addr = mreqs->imr_interface;
igmp.c:1731:		err = -ENODEV;
igmp.c:1734:	err = -EADDRNOTAVAIL;
igmp.c:1736:	for (pmc=inet->mc_list; pmc; pmc=pmc->next) {
igmp.c:1737:		if (memcmp(&pmc->multi, mreqs, 2*sizeof(__u32)) == 0)
igmp.c:1743:	if (pmc->sflist) {
igmp.c:1744:		if (pmc->sfmode != omode)
igmp.c:1746:	} else if (pmc->sfmode != omode) {
igmp.c:1747:		/* allow mode switches for empty-set filters */
igmp.c:1748:		ip_mc_add_src(in_dev, &mreqs->imr_multiaddr, omode, 0, 0, 0);
igmp.c:1749:		ip_mc_del_src(in_dev, &mreqs->imr_multiaddr, pmc->sfmode, 0, 
igmp.c:1751:		pmc->sfmode = omode;
igmp.c:1754:	psl = pmc->sflist;
igmp.c:1759:		for (i=0; i<psl->sl_count; i++) {
igmp.c:1760:			rv = memcmp(&psl->sl_addr, &mreqs->imr_multiaddr,
igmp.c:1769:		ip_mc_del_src(in_dev, &mreqs->imr_multiaddr, omode, 1, 
igmp.c:1770:			&mreqs->imr_sourceaddr, 1);
igmp.c:1772:		for (j=i+1; j<psl->sl_count; j++)
igmp.c:1773:			psl->sl_addr[j-1] = psl->sl_addr[j];
igmp.c:1774:		psl->sl_count--;
igmp.c:1780:	if (psl && psl->sl_count >= sysctl_igmp_max_msf) {
igmp.c:1781:		err = -ENOBUFS;
igmp.c:1784:	if (!psl || psl->sl_count == psl->sl_max) {
igmp.c:1789:			count += psl->sl_max;
igmp.c:1793:			err = -ENOBUFS;
igmp.c:1796:		newpsl->sl_max = count;
igmp.c:1797:		newpsl->sl_count = count - IP_SFBLOCK;
igmp.c:1799:			for (i=0; i<psl->sl_count; i++)
igmp.c:1800:				newpsl->sl_addr[i] = psl->sl_addr[i];
igmp.c:1801:			sock_kfree_s(sk, psl, IP_SFLSIZE(psl->sl_max));
igmp.c:1803:		pmc->sflist = psl = newpsl;
igmp.c:1806:	for (i=0; i<psl->sl_count; i++) {
igmp.c:1807:		rv = memcmp(&psl->sl_addr, &mreqs->imr_multiaddr,
igmp.c:1814:	for (j=psl->sl_count-1; j>=i; j--)
igmp.c:1815:		psl->sl_addr[j+1] = psl->sl_addr[j];
igmp.c:1816:	psl->sl_addr[i] = mreqs->imr_sourceaddr;
igmp.c:1817:	psl->sl_count++;
igmp.c:1820:	ip_mc_add_src(in_dev, &mreqs->imr_multiaddr, omode, 1, 
igmp.c:1821:		&mreqs->imr_sourceaddr, 1);
igmp.c:1831:	u32 addr = msf->imsf_multiaddr;
igmp.c:1834:	struct inet_opt *inet = &sk->protinfo.af_inet;
igmp.c:1838:		return -EINVAL;
igmp.c:1839:	if (msf->imsf_fmode != MCAST_INCLUDE &&
igmp.c:1840:	    msf->imsf_fmode != MCAST_EXCLUDE)
igmp.c:1841:		return -EINVAL;
igmp.c:1845:	imr.imr_multiaddr.s_addr = msf->imsf_multiaddr;
igmp.c:1846:	imr.imr_address.s_addr = msf->imsf_interface;
igmp.c:1851:		err = -ENODEV;
igmp.c:1854:	err = -EADDRNOTAVAIL;
igmp.c:1856:	for (pmc=inet->mc_list; pmc; pmc=pmc->next) {
igmp.c:1857:		if (pmc->multi.imr_multiaddr.s_addr == msf->imsf_multiaddr &&
igmp.c:1858:		    pmc->multi.imr_ifindex == imr.imr_ifindex)
igmp.c:1863:	if (msf->imsf_numsrc) {
igmp.c:1865:				IP_SFLSIZE(msf->imsf_numsrc), GFP_KERNEL);
igmp.c:1867:			err = -ENOBUFS;
igmp.c:1870:		newpsl->sl_max = newpsl->sl_count = msf->imsf_numsrc;
igmp.c:1871:		memcpy(newpsl->sl_addr, msf->imsf_slist,
igmp.c:1872:			msf->imsf_numsrc * sizeof(msf->imsf_slist[0]));
igmp.c:1873:		err = ip_mc_add_src(in_dev, &msf->imsf_multiaddr,
igmp.c:1874:			msf->imsf_fmode, newpsl->sl_count, newpsl->sl_addr, 0);
igmp.c:1876:			sock_kfree_s(sk, newpsl, IP_SFLSIZE(newpsl->sl_max));
igmp.c:1881:	psl = pmc->sflist;
igmp.c:1883:		(void) ip_mc_del_src(in_dev, &msf->imsf_multiaddr, pmc->sfmode,
igmp.c:1884:			psl->sl_count, psl->sl_addr, 0);
igmp.c:1885:		sock_kfree_s(sk, psl, IP_SFLSIZE(psl->sl_max));
igmp.c:1887:		(void) ip_mc_del_src(in_dev, &msf->imsf_multiaddr, pmc->sfmode,
igmp.c:1889:	pmc->sflist = newpsl;
igmp.c:1890:	pmc->sfmode = msf->imsf_fmode;
igmp.c:1901:	u32 addr = msf->imsf_multiaddr;
igmp.c:1904:	struct inet_opt *inet = &sk->protinfo.af_inet;
igmp.c:1908:		return -EINVAL;
igmp.c:1912:	imr.imr_multiaddr.s_addr = msf->imsf_multiaddr;
igmp.c:1913:	imr.imr_address.s_addr = msf->imsf_interface;
igmp.c:1918:		err = -ENODEV;
igmp.c:1921:	err = -EADDRNOTAVAIL;
igmp.c:1923:	for (pmc=inet->mc_list; pmc; pmc=pmc->next) {
igmp.c:1924:		if (pmc->multi.imr_multiaddr.s_addr == msf->imsf_multiaddr &&
igmp.c:1925:		    pmc->multi.imr_ifindex == imr.imr_ifindex)
igmp.c:1930:	msf->imsf_fmode = pmc->sfmode;
igmp.c:1931:	psl = pmc->sflist;
igmp.c:1937:		count = psl->sl_count;
igmp.c:1939:	copycount = count < msf->imsf_numsrc ? count : msf->imsf_numsrc;
igmp.c:1940:	len = copycount * sizeof(psl->sl_addr[0]);
igmp.c:1941:	msf->imsf_numsrc = count;
igmp.c:1944:		return -EFAULT;
igmp.c:1947:	    copy_to_user((void *)&optval->imsf_slist[0], psl->sl_addr, len))
igmp.c:1948:		return -EFAULT;
igmp.c:1962:	struct inet_opt *inet = &sk->protinfo.af_inet;
igmp.c:1965:	psin = (struct sockaddr_in *)&gsf->gf_group;
igmp.c:1966:	if (psin->sin_family != AF_INET)
igmp.c:1967:		return -EINVAL;
igmp.c:1968:	addr = psin->sin_addr.s_addr;
igmp.c:1970:		return -EINVAL;
igmp.c:1974:	err = -EADDRNOTAVAIL;
igmp.c:1976:	for (pmc=inet->mc_list; pmc; pmc=pmc->next) {
igmp.c:1977:		if (pmc->multi.imr_multiaddr.s_addr == addr &&
igmp.c:1978:		    pmc->multi.imr_ifindex == gsf->gf_interface)
igmp.c:1983:	gsf->gf_fmode = pmc->sfmode;
igmp.c:1984:	psl = pmc->sflist;
igmp.c:1986:	count = psl ? psl->sl_count : 0;
igmp.c:1987:	copycount = count < gsf->gf_numsrc ? count : gsf->gf_numsrc;
igmp.c:1988:	gsf->gf_numsrc = count;
igmp.c:1991:		return -EFAULT;
igmp.c:1999:		psin->sin_family = AF_INET;
igmp.c:2000:		psin->sin_addr.s_addr = psl->sl_addr[i];
igmp.c:2001:		if (copy_to_user((void *)&optval->gf_slist[i], &ss, sizeof(ss)))
igmp.c:2002:			return -EFAULT;
igmp.c:2015:	struct inet_opt *inet = &sk->protinfo.af_inet;
igmp.c:2023:	for (pmc=inet->mc_list; pmc; pmc=pmc->next) {
igmp.c:2024:		if (pmc->multi.imr_multiaddr.s_addr == loc_addr &&
igmp.c:2025:		    pmc->multi.imr_ifindex == dif)
igmp.c:2030:	psl = pmc->sflist;
igmp.c:2032:		return pmc->sfmode == MCAST_EXCLUDE;
igmp.c:2034:	for (i=0; i<psl->sl_count; i++) {
igmp.c:2035:		if (psl->sl_addr[i] == rmt_addr)
igmp.c:2038:	if (pmc->sfmode == MCAST_INCLUDE && i >= psl->sl_count)
igmp.c:2040:	if (pmc->sfmode == MCAST_EXCLUDE && i < psl->sl_count)
igmp.c:2051:	struct inet_opt *inet = &sk->protinfo.af_inet;
igmp.c:2054:	if (inet->mc_list == NULL)
igmp.c:2058:	while ((iml = inet->mc_list) != NULL) {
igmp.c:2060:		inet->mc_list = iml->next;
igmp.c:2062:		if ((in_dev = inetdev_by_index(iml->multi.imr_ifindex)) != NULL) {
igmp.c:2064:			ip_mc_dec_group(in_dev, iml->multi.imr_multiaddr.s_addr);
igmp.c:2079:	read_lock(&in_dev->lock);
igmp.c:2080:	for (im=in_dev->mc_list; im; im=im->next) {
igmp.c:2081:		if (im->multiaddr == mc_addr)
igmp.c:2089:	 * Differs from 2.5.x here.	+-DLS 4/23/03
igmp.c:2093:			for (psf=im->sources; psf; psf=psf->sf_next) {
igmp.c:2094:				if (psf->sf_inaddr == src_addr)
igmp.c:2098:				rv = psf->sf_count[MCAST_INCLUDE] ||
igmp.c:2099:					psf->sf_count[MCAST_EXCLUDE] !=
igmp.c:2100:					im->sfcount[MCAST_EXCLUDE];
igmp.c:2102:				rv = im->sfcount[MCAST_EXCLUDE] != 0;
igmp.c:2106:	read_unlock(&in_dev->lock);
igmp.c:2121:	for(dev = dev_base; dev; dev = dev->next) {
igmp.c:2132:		len+=sprintf(buffer+len,"%d\t%-10s: %5d %7s\n",
igmp.c:2133:			     dev->ifindex, dev->name, dev->mc_count, querier);
igmp.c:2135:		read_lock(&in_dev->lock);
igmp.c:2136:		for (im = in_dev->mc_list; im; im = im->next) {
igmp.c:2139:				     im->multiaddr, im->users,
igmp.c:2140:				     im->tm_running, im->timer.expires-jiffies, im->reporter);
igmp.c:2149:				read_unlock(&in_dev->lock);
igmp.c:2154:		read_unlock(&in_dev->lock);
igmp.c:2160:	*start=buffer+(offset-begin);
igmp.c:2161:	len-=(offset-begin);
igmp.c:2177:	for(dev=dev_base; dev; dev=dev->next) {
igmp.c:2184:		read_lock(&in_dev->lock);
igmp.c:2186:		for (imc=in_dev->mc_list; imc; imc=imc->next) {
igmp.c:2189:			spin_lock_bh(&imc->lock);
igmp.c:2190:			for (psf=imc->sources; psf; psf=psf->sf_next) {
igmp.c:2199:					"0x%08x %6lu %6lu\n", dev->ifindex,
igmp.c:2200:					dev->name, ntohl(imc->multiaddr),
igmp.c:2201:					ntohl(psf->sf_inaddr),
igmp.c:2202:					psf->sf_count[MCAST_INCLUDE],
igmp.c:2203:					psf->sf_count[MCAST_EXCLUDE]);
igmp.c:2211:					spin_unlock_bh(&imc->lock);
igmp.c:2212:					read_unlock(&in_dev->lock);
igmp.c:2217:			spin_unlock_bh(&imc->lock);
igmp.c:2219:		read_unlock(&in_dev->lock);
igmp.c:2225:	*start=buffer+(offset-begin);
igmp.c:2226:	len-=(offset-begin);
inetpeer.c:2: *		INETPEER - A storage for permanent information about peers
inetpeer.c:25: *  We keep one entry for each peer IP address.  The nodes contains long-living
inetpeer.c:43: *  time has been passed since its last use.  The less-recently-used entry can
inetpeer.c:45: *  entries is greater-or-equal than the threshold.
inetpeer.c:75:#define node_height(x) x->avl_height
inetpeer.c:116:	 * myself.  --SAW
inetpeer.c:143:	if (p->unused_prevp != NULL) {
inetpeer.c:145:		*p->unused_prevp = p->unused_next;
inetpeer.c:146:		if (p->unused_next != NULL)
inetpeer.c:147:			p->unused_next->unused_prevp = p->unused_prevp;
inetpeer.c:149:			inet_peer_unused_tailp = p->unused_prevp;
inetpeer.c:150:		p->unused_prevp = NULL; /* mark it as removed */
inetpeer.c:162:		if (daddr == u->v4daddr)			\
inetpeer.c:164:		if (daddr < u->v4daddr)				\
inetpeer.c:165:			v = &u->avl_left;			\
inetpeer.c:167:			v = &u->avl_right;			\
inetpeer.c:178:	*stackptr++ = &start->avl_left;				\
inetpeer.c:179:	v = &start->avl_left;					\
inetpeer.c:180:	for (u = *v; u->avl_right != peer_avl_empty; ) {	\
inetpeer.c:181:		v = &u->avl_right;				\
inetpeer.c:198:		nodep = *--stackend;
inetpeer.c:200:		l = node->avl_left;
inetpeer.c:201:		r = node->avl_right;
inetpeer.c:207:			ll = l->avl_left;
inetpeer.c:208:			lr = l->avl_right;
inetpeer.c:211:				node->avl_left = lr;	/* lr: RH or RH+1 */
inetpeer.c:212:				node->avl_right = r;	/* r: RH */
inetpeer.c:213:				node->avl_height = lrh + 1; /* RH+1 or RH+2 */
inetpeer.c:214:				l->avl_left = ll;	/* ll: RH+1 */
inetpeer.c:215:				l->avl_right = node;	/* node: RH+1 or RH+2 */
inetpeer.c:216:				l->avl_height = node->avl_height + 1;
inetpeer.c:219:				lrl = lr->avl_left;	/* lrl: RH or RH-1 */
inetpeer.c:220:				lrr = lr->avl_right;	/* lrr: RH or RH-1 */
inetpeer.c:221:				node->avl_left = lrr;	/* lrr: RH or RH-1 */
inetpeer.c:222:				node->avl_right = r;	/* r: RH */
inetpeer.c:223:				node->avl_height = rh + 1; /* node: RH+1 */
inetpeer.c:224:				l->avl_left = ll;	/* ll: RH */
inetpeer.c:225:				l->avl_right = lrl;	/* lrl: RH or RH-1 */
inetpeer.c:226:				l->avl_height = rh + 1;	/* l: RH+1 */
inetpeer.c:227:				lr->avl_left = l;	/* l: RH+1 */
inetpeer.c:228:				lr->avl_right = node;	/* node: RH+1 */
inetpeer.c:229:				lr->avl_height = rh + 2;
inetpeer.c:235:			rr = r->avl_right;
inetpeer.c:236:			rl = r->avl_left;
inetpeer.c:239:				node->avl_right = rl;	/* rl: LH or LH+1 */
inetpeer.c:240:				node->avl_left = l;	/* l: LH */
inetpeer.c:241:				node->avl_height = rlh + 1; /* LH+1 or LH+2 */
inetpeer.c:242:				r->avl_right = rr;	/* rr: LH+1 */
inetpeer.c:243:				r->avl_left = node;	/* node: LH+1 or LH+2 */
inetpeer.c:244:				r->avl_height = node->avl_height + 1;
inetpeer.c:247:				rlr = rl->avl_right;	/* rlr: LH or LH-1 */
inetpeer.c:248:				rll = rl->avl_left;	/* rll: LH or LH-1 */
inetpeer.c:249:				node->avl_right = rll;	/* rll: LH or LH-1 */
inetpeer.c:250:				node->avl_left = l;	/* l: LH */
inetpeer.c:251:				node->avl_height = lh + 1; /* node: LH+1 */
inetpeer.c:252:				r->avl_right = rr;	/* rr: LH */
inetpeer.c:253:				r->avl_left = rlr;	/* rlr: LH or LH-1 */
inetpeer.c:254:				r->avl_height = lh + 1;	/* r: LH+1 */
inetpeer.c:255:				rl->avl_right = r;	/* r: LH+1 */
inetpeer.c:256:				rl->avl_left = node;	/* node: LH+1 */
inetpeer.c:257:				rl->avl_height = lh + 2;
inetpeer.c:261:			node->avl_height = (lh > rh ? lh : rh) + 1;
inetpeer.c:269:	n->avl_height = 1;					\
inetpeer.c:270:	n->avl_left = peer_avl_empty;				\
inetpeer.c:271:	n->avl_right = peer_avl_empty;				\
inetpeer.c:272:	**--stackptr = n;					\
inetpeer.c:289:	if (atomic_read(&p->refcnt) == 1) {
inetpeer.c:292:		if (lookup(p->v4daddr) != p)
inetpeer.c:294:		delp = stackptr - 1; /* *delp[0] == p */
inetpeer.c:295:		if (p->avl_left == peer_avl_empty) {
inetpeer.c:296:			*delp[0] = p->avl_right;
inetpeer.c:297:			--stackptr;
inetpeer.c:302:			if (*stackptr[-1] != t)
inetpeer.c:304:			**--stackptr = t->avl_left;
inetpeer.c:305:			/* t is removed, t->v4daddr > x->v4daddr for any
inetpeer.c:306:			 * x in p->avl_left subtree.
inetpeer.c:309:			t->avl_left = p->avl_left;
inetpeer.c:310:			t->avl_right = p->avl_right;
inetpeer.c:311:			t->avl_height = p->avl_height;
inetpeer.c:312:			if (delp[1] != &p->avl_left)
inetpeer.c:314:			delp[1] = &t->avl_left; /* was &p->avl_left */
inetpeer.c:317:		peer_total--;
inetpeer.c:326:		 * back.  The loop "cleanup -> unlink_from_unused
inetpeer.c:327:		 *   -> unlink_from_pool -> putpeer -> link_to_unused
inetpeer.c:328:		 *   -> cleanup (for the same node)"
inetpeer.c:343:		if (time_after(p->dtime + ttl, jiffies)) {
inetpeer.c:346:			return -1;
inetpeer.c:348:		inet_peer_unused_head = p->unused_next;
inetpeer.c:349:		if (p->unused_next != NULL)
inetpeer.c:350:			p->unused_next->unused_prevp = p->unused_prevp;
inetpeer.c:352:			inet_peer_unused_tailp = p->unused_prevp;
inetpeer.c:353:		p->unused_prevp = NULL; /* mark as not on the list */
inetpeer.c:356:		atomic_inc(&p->refcnt);
inetpeer.c:364:		return -1;
inetpeer.c:380:		atomic_inc(&p->refcnt);
inetpeer.c:397:	n->v4daddr = daddr;
inetpeer.c:398:	atomic_set(&n->refcnt, 1);
inetpeer.c:399:	n->ip_id_count = secure_ip_id(daddr);
inetpeer.c:400:	n->tcp_ts_stamp = 0;
inetpeer.c:410:	n->unused_prevp = NULL; /* not on the list */
inetpeer.c:415:		/* Remove one less-recently-used entry. */
inetpeer.c:422:	atomic_inc(&p->refcnt);
inetpeer.c:441:				- (inet_peer_maxttl - inet_peer_minttl) / HZ *
inetpeer.c:450:		- (inet_peer_gc_maxtime - inet_peer_gc_mintime) / HZ *
ipconfig.c:4: *  Automatic Configuration of IP -- use DHCP, BOOTP, RARP, or
ipconfig.c:5: *  user-supplied information to configure own IP address and routes.
ipconfig.c:7: *  Copyright (C) 1996-1998 Martin Mares <mj@atrey.karlin.mff.cuni.cz>
ipconfig.c:13: *  of misusing the IP layer. num_bugs_causing_wrong_arp_replies--;
ipconfig.c:14: *					     -- MJ, December 1998
ipconfig.c:18: *	- Arnaldo Carvalho de Melo <acme@conectiva.com.br>, 08/11/1999
ipconfig.c:22: *		-- Chip Salzenberg <chip@valinux.com>, May 2000
ipconfig.c:24: *  Ported DHCP support from 2.2.16 to 2.4.0-test4
ipconfig.c:25: *              -- Eric Biederman <ebiederman@lnxi.com>, 30 Aug 2000
ipconfig.c:28: *              -- Eric Biederman <ebiederman@lnxi.com>, 22 April Aug 2001
ipconfig.c:31: *              --  Josef Siemes <jsiemes@web.de>, Aug 2002
ipconfig.c:91:#define CONF_INTER_TIMEOUT	(HZ/2)	/* Inter-device timeout: 1/2 second */
ipconfig.c:97:                                           - '3' from resolv.h */
ipconfig.c:146:/* Name of user-selected boot device */
ipconfig.c:184:	for (dev = dev_base; dev; dev = dev->next) {
ipconfig.c:185:		if (user_dev_name[0] ? !strcmp(dev->name, user_dev_name) :
ipconfig.c:186:		    (!(dev->flags & IFF_LOOPBACK) &&
ipconfig.c:187:		     (dev->flags & (IFF_POINTOPOINT|IFF_BROADCAST)) &&
ipconfig.c:188:		     strncmp(dev->name, "dummy", 5))) {
ipconfig.c:190:			if (dev->mtu >= 364)
ipconfig.c:193:				printk(KERN_WARNING "DHCP/BOOTP: Ignoring device %s, MTU %d too small", dev->name, dev->mtu);
ipconfig.c:194:			if (!(dev->flags & IFF_NOARP))
ipconfig.c:199:			oflags = dev->flags;
ipconfig.c:201:				printk(KERN_ERR "IP-Config: Failed to open %s\n", dev->name);
ipconfig.c:206:				return -1;
ipconfig.c:208:			d->dev = dev;
ipconfig.c:210:			last = &d->next;
ipconfig.c:211:			d->flags = oflags;
ipconfig.c:212:			d->able = able;
ipconfig.c:214:				get_random_bytes(&d->xid, sizeof(u32));
ipconfig.c:216:				d->xid = 0;
ipconfig.c:218:			DBG(("IP-Config: %s UP (able=%d, xid=%08x)\n",
ipconfig.c:219:				dev->name, able, d->xid));
ipconfig.c:228:			printk(KERN_ERR "IP-Config: Device `%s' not found.\n", user_dev_name);
ipconfig.c:230:			printk(KERN_ERR "IP-Config: No network devices available.\n");
ipconfig.c:231:		return -1;
ipconfig.c:244:		next = d->next;
ipconfig.c:245:		dev = d->dev;
ipconfig.c:247:			DBG(("IP-Config: Downing %s\n", dev->name));
ipconfig.c:248:			dev_change_flags(dev, d->flags);
ipconfig.c:262:	sin->sin_family = AF_INET;
ipconfig.c:263:	sin->sin_addr.s_addr = addr;
ipconfig.c:264:	sin->sin_port = port;
ipconfig.c:300:	strcpy(ir.ifr_ifrn.ifrn_name, ic_dev->name);
ipconfig.c:303:		printk(KERN_ERR "IP-Config: Unable to set interface address (%d).\n", err);
ipconfig.c:304:		return -1;
ipconfig.c:308:		printk(KERN_ERR "IP-Config: Unable to set interface netmask (%d).\n", err);
ipconfig.c:309:		return -1;
ipconfig.c:313:		printk(KERN_ERR "IP-Config: Unable to set interface broadcast address (%d).\n", err);
ipconfig.c:314:		return -1;
ipconfig.c:329:			printk(KERN_ERR "IP-Config: Gateway not on directly connected network.\n");
ipconfig.c:330:			return -1;
ipconfig.c:337:			printk(KERN_ERR "IP-Config: Cannot add default route (%d).\n", err);
ipconfig.c:338:			return -1;
ipconfig.c:370:			printk(KERN_ERR "IP-Config: Unable to guess netmask for address %u.%u.%u.%u\n",
ipconfig.c:372:			return -1;
ipconfig.c:374:		printk("IP-Config: Guessing netmask %u.%u.%u.%u\n", NIPQUAD(ic_netmask));
ipconfig.c:409:	struct arphdr *rarp = (struct arphdr *)skb->h.raw;
ipconfig.c:424:	while (d && d->dev != dev)
ipconfig.c:425:		d = d->next;
ipconfig.c:430:	if (rarp->ar_hln != dev->addr_len || dev->type != ntohs(rarp->ar_hrd))
ipconfig.c:434:	if (rarp->ar_op != htons(ARPOP_RREPLY))
ipconfig.c:438:	if (rarp->ar_pro != htons(ETH_P_IP))
ipconfig.c:441:	/* Extract variable-width fields */
ipconfig.c:443:	rarp_ptr += dev->addr_len;
ipconfig.c:447:	rarp_ptr += dev->addr_len;
ipconfig.c:451:	if (memcmp(tha, dev->dev_addr, dev->addr_len))
ipconfig.c:480:	struct net_device *dev = d->dev;
ipconfig.c:482:		 dev->dev_addr, dev->dev_addr);
ipconfig.c:655:	struct net_device *dev = d->dev;
ipconfig.c:658:	int hh_len = (dev->hard_header_len + 15) & ~15;
ipconfig.c:670:	skb->nh.iph = h = &b->iph;
ipconfig.c:671:	h->version = 4;
ipconfig.c:672:	h->ihl = 5;
ipconfig.c:673:	h->tot_len = htons(sizeof(struct bootp_pkt));
ipconfig.c:674:	h->frag_off = htons(IP_DF);
ipconfig.c:675:	h->ttl = 64;
ipconfig.c:676:	h->protocol = IPPROTO_UDP;
ipconfig.c:677:	h->daddr = INADDR_BROADCAST;
ipconfig.c:678:	h->check = ip_fast_csum((unsigned char *) h, h->ihl);
ipconfig.c:681:	b->udph.source = htons(68);
ipconfig.c:682:	b->udph.dest = htons(67);
ipconfig.c:683:	b->udph.len = htons(sizeof(struct bootp_pkt) - sizeof(struct iphdr));
ipconfig.c:684:	/* UDP checksum not calculated -- explicitly allowed in BOOTP RFC */
ipconfig.c:687:	b->op = BOOTP_REQUEST;
ipconfig.c:688:	if (dev->type < 256) /* check for false types */
ipconfig.c:689:		b->htype = dev->type;
ipconfig.c:690:	else if (dev->type == ARPHRD_IEEE802_TR) /* fix for token ring */
ipconfig.c:691:		b->htype = ARPHRD_IEEE802;
ipconfig.c:693:		printk("Unknown ARP type 0x%04x for device %s\n", dev->type, dev->name);
ipconfig.c:694:		b->htype = dev->type; /* can cause undefined behavior */
ipconfig.c:696:	b->hlen = dev->addr_len;
ipconfig.c:697:	b->your_ip = INADDR_NONE;
ipconfig.c:698:	b->server_ip = INADDR_NONE;
ipconfig.c:699:	memcpy(b->hw_addr, dev->dev_addr, dev->addr_len);
ipconfig.c:700:	b->secs = htons(jiffies_diff / HZ);
ipconfig.c:701:	b->xid = d->xid;
ipconfig.c:706:		ic_dhcp_init_options(b->exten);
ipconfig.c:709:		ic_bootp_init_ext(b->exten);
ipconfig.c:712:	skb->dev = dev;
ipconfig.c:713:	skb->protocol = htons(ETH_P_IP);
ipconfig.c:714:	if ((dev->hard_header &&
ipconfig.c:715:	     dev->hard_header(skb, dev, ntohs(skb->protocol), dev->broadcast, dev->dev_addr, skb->len) < 0) ||
ipconfig.c:722: *  Copy BOOTP-supplied string if not already set.
ipconfig.c:728:	if (len > max-1)
ipconfig.c:729:		len = max-1;
ipconfig.c:794:	struct bootp_pkt *b = (struct bootp_pkt *) skb->nh.iph;
ipconfig.c:795:	struct iphdr *h = &b->iph;
ipconfig.c:808:	while (d && d->dev != dev)
ipconfig.c:809:		d = d->next;
ipconfig.c:814:	if (skb->pkt_type == PACKET_OTHERHOST ||
ipconfig.c:815:	    skb->len < sizeof(struct udphdr) + sizeof(struct iphdr) ||
ipconfig.c:816:	    h->ihl != 5 ||
ipconfig.c:817:	    h->version != 4 ||
ipconfig.c:818:	    ip_fast_csum((char *) h, h->ihl) != 0 ||
ipconfig.c:819:	    skb->len < ntohs(h->tot_len) ||
ipconfig.c:820:	    h->protocol != IPPROTO_UDP ||
ipconfig.c:821:	    b->udph.source != htons(67) ||
ipconfig.c:822:	    b->udph.dest != htons(68) ||
ipconfig.c:823:	    ntohs(h->tot_len) < ntohs(b->udph.len) + sizeof(struct iphdr))
ipconfig.c:827:	if (h->frag_off & htons(IP_OFFSET | IP_MF)) {
ipconfig.c:833:	len = ntohs(b->udph.len) - sizeof(struct udphdr);
ipconfig.c:835:	    b->op != BOOTP_REPLY ||
ipconfig.c:836:	    b->xid != d->xid) {
ipconfig.c:842:	if (!memcmp(b->exten, ic_bootp_cookie, 4)) { /* Check magic cookie */
ipconfig.c:843:                u8 *end = (u8 *) b + ntohs(b->iph.tot_len);
ipconfig.c:851:			ext = &b->exten[4];
ipconfig.c:884:				ic_myaddr = b->your_ip;
ipconfig.c:897:				    (b->server_ip != server_id))
ipconfig.c:898:					b->server_ip = ic_servaddr;
ipconfig.c:917:		ext = &b->exten[4];
ipconfig.c:930:	ic_myaddr = b->your_ip;
ipconfig.c:931:	ic_servaddr = b->server_ip;
ipconfig.c:932:	if (ic_gateway == INADDR_NONE && b->relay_ip)
ipconfig.c:933:		ic_gateway = b->relay_ip;
ipconfig.c:953: *	Dynamic IP configuration -- DHCP, BOOTP, RARP.
ipconfig.c:972:		printk(KERN_ERR "IP-Config: Incomplete network configuration information.\n");
ipconfig.c:973:		return -1;
ipconfig.c:987:		return -1;
ipconfig.c:1007:	 *  applies.. - AC]
ipconfig.c:1022:		if (do_bootp && (d->able & IC_BOOTP))
ipconfig.c:1023:			ic_bootp_send_if(d, jiffies - start_jiffies);
ipconfig.c:1026:		if (do_rarp && (d->able & IC_RARP))
ipconfig.c:1030:		jiff = jiffies + (d->next ? CONF_INTER_TIMEOUT : timeout);
ipconfig.c:1052:		if ((d = d->next))
ipconfig.c:1055:		if (! --retries) {
ipconfig.c:1079:		return -1;
ipconfig.c:1081:	printk("IP-Config: Got %s answer from %u.%u.%u.%u, ",
ipconfig.c:1127:		length = len - offset;
ipconfig.c:1148:		if (cp == cq || cp - cq > 3)
ipconfig.c:1183:	DBG(("IP-Config: Entered.\n"));
ipconfig.c:1195:		return -1;
ipconfig.c:1214:	    ic_first_dev->next) {
ipconfig.c:1230:			 * Also, if the root will be NFS-mounted, we
ipconfig.c:1234:			 * 				-- Chip
ipconfig.c:1239:					"IP-Config: Retrying forever (NFS root)...\n");
ipconfig.c:1244:			if (--retries) {
ipconfig.c:1246:				       "IP-Config: Reopening network devices...\n");
ipconfig.c:1251:			printk(KERN_ERR "IP-Config: Auto-configuration of network failed.\n");
ipconfig.c:1252:			return -1;
ipconfig.c:1255:		printk(KERN_ERR "IP-Config: Incomplete network configuration information.\n");
ipconfig.c:1257:		return -1;
ipconfig.c:1260:		/* Device selected manually or only one device -> use it */
ipconfig.c:1261:		ic_dev = ic_first_dev->dev;
ipconfig.c:1272:		return -1;
ipconfig.c:1280:		return -1;
ipconfig.c:1293:	printk("IP-Config: Complete:");
ipconfig.c:1294:	printk("\n      device=%s", ic_dev->name);
ipconfig.c:1298:	printk(",\n     host=%s, domain=%s, nis-domain=%s",
ipconfig.c:1317: *  <client-ip>:<server-ip>:<gw-ip>:<netmask>:<host name>:<device>:<PROTO>
ipconfig.c:1320: *	<client-ip>	- address given by BOOTP or RARP
ipconfig.c:1321: *	<server-ip>	- address of host returning BOOTP or RARP packet
ipconfig.c:1322: *	<gw-ip>		- none, or the address returned by BOOTP
ipconfig.c:1323: *	<netmask>	- automatically determined from <client-ip>, or the
ipconfig.c:1325: *	<host name>	- <client-ip> in ASCII notation, or the name returned
ipconfig.c:1327: *	<device>	- use all available devices
ipconfig.c:1329: *	   off|none	    - don't do autoconfig at all (DEFAULT)
ipconfig.c:1330: *	   on|any           - use any configured protocol
ipconfig.c:1331: *	   dhcp|bootp|rarp  - use only the specified protocol
ipconfig.c:1332: *	   both             - use both BOOTP and RARP (not DHCP)
ipconfig.c:1359:		ic_proto_enabled &= ~IC_USE_DHCP; /* backward compat :-( */
ipconfig.c:1388:			DBG(("IP-Config: Parameter #%d: `%s'\n", num, ip));
ipconfig.c:1418:				user_dev_name[IFNAMSIZ-1] = '\0';
ip_forward.c:46:	struct ip_options * opt	= &(IPCB(skb)->opt);
ip_forward.c:50:	if (opt->optlen == 0) {
ip_forward.c:52:		struct rtable *rt = (struct rtable*)skb->dst;
ip_forward.c:54:		if (rt->rt_flags&RTCF_FAST && !netdev_fastroute_obstacles) {
ip_forward.c:56:			unsigned h = ((*(u8*)&rt->key.dst)^(*(u8*)&rt->key.src))&NETDEV_FASTROUTE_HMASK;
ip_forward.c:58:			write_lock_irq(&skb->dev->fastpath_lock);
ip_forward.c:59:			old_dst = skb->dev->fastpath[h];
ip_forward.c:60:			skb->dev->fastpath[h] = dst_clone(&rt->u.dst);
ip_forward.c:61:			write_unlock_irq(&skb->dev->fastpath_lock);
ip_forward.c:78:	struct ip_options * opt	= &(IPCB(skb)->opt);
ip_forward.c:81:	if (IPCB(skb)->opt.router_alert && ip_call_ra_chain(skb))
ip_forward.c:84:	if (skb->pkt_type != PACKET_HOST)
ip_forward.c:87:	skb->ip_summed = CHECKSUM_NONE;
ip_forward.c:95:	iph = skb->nh.iph;
ip_forward.c:96:	rt = (struct rtable*)skb->dst;
ip_forward.c:98:	if (iph->ttl <= 1)
ip_forward.c:101:	if (opt->is_strictroute && rt->rt_dst != rt->rt_gateway)
ip_forward.c:109:	skb->priority = rt_tos2priority(iph->tos);
ip_forward.c:110:	dev2 = rt->u.dst.dev;
ip_forward.c:111:	mtu = rt->u.dst.pmtu;
ip_forward.c:117:	if (rt->rt_flags&RTCF_DOREDIRECT && !opt->srr)
ip_forward.c:121:	if (skb_cow(skb, dev2->hard_header_len))
ip_forward.c:123:	iph = skb->nh.iph;
ip_forward.c:133:	if (skb->len > mtu && (ntohs(iph->frag_off) & IP_DF))
ip_forward.c:137:	if (rt->rt_flags & RTCF_NAT) {
ip_forward.c:145:	return NF_HOOK(PF_INET, NF_IP_FORWARD, skb, skb->dev, dev2,
ip_fragment.c:47: * as well. Or notify me, at least. --ANK
ip_fragment.c:69:#define FRAG_CB(skb)	((struct ipfrag_skb_cb*)((skb)->cb))
ip_fragment.c:99:/* Per-bucket lock is easy to add now. */
ip_fragment.c:108:	if(qp->next)
ip_fragment.c:109:		qp->next->pprev = qp->pprev;
ip_fragment.c:110:	*qp->pprev = qp->next;
ip_fragment.c:111:	list_del(&qp->lru_list);
ip_fragment.c:112:	ip_frag_nqueues--;
ip_fragment.c:125:			    ipfrag_hash_rnd) & (IPQ_HASHSZ - 1);
ip_fragment.c:143:			struct ipq *next = q->next;
ip_fragment.c:144:			unsigned int hval = ipqhashfn(q->id, q->saddr,
ip_fragment.c:145:						      q->daddr, q->protocol);
ip_fragment.c:149:				if (q->next)
ip_fragment.c:150:					q->next->pprev = q->pprev;
ip_fragment.c:151:				*q->pprev = q->next;
ip_fragment.c:154:				if ((q->next = ipq_hash[hval]) != NULL)
ip_fragment.c:155:					q->next->pprev = &q->next;
ip_fragment.c:157:				q->pprev = &ipq_hash[hval];
ip_fragment.c:173:	atomic_sub(skb->truesize, &ip_frag_mem);
ip_fragment.c:201:	BUG_TRAP(qp->last_in&COMPLETE);
ip_fragment.c:202:	BUG_TRAP(del_timer(&qp->timer) == 0);
ip_fragment.c:205:	fp = qp->fragments;
ip_fragment.c:207:		struct sk_buff *xp = fp->next;
ip_fragment.c:219:	if (atomic_dec_and_test(&ipq->refcnt))
ip_fragment.c:228:	if (del_timer(&ipq->timer))
ip_fragment.c:229:		atomic_dec(&ipq->refcnt);
ip_fragment.c:231:	if (!(ipq->last_in & COMPLETE)) {
ip_fragment.c:233:		atomic_dec(&ipq->refcnt);
ip_fragment.c:234:		ipq->last_in |= COMPLETE;
ip_fragment.c:256:		atomic_inc(&qp->refcnt);
ip_fragment.c:259:		spin_lock(&qp->lock);
ip_fragment.c:260:		if (!(qp->last_in&COMPLETE))
ip_fragment.c:262:		spin_unlock(&qp->lock);
ip_fragment.c:276:	spin_lock(&qp->lock);
ip_fragment.c:278:	if (qp->last_in & COMPLETE)
ip_fragment.c:286:	if ((qp->last_in&FIRST_IN) && qp->fragments != NULL) {
ip_fragment.c:287:		struct sk_buff *head = qp->fragments;
ip_fragment.c:289:		if ((head->dev = dev_get_by_index(qp->iif)) != NULL) {
ip_fragment.c:291:			dev_put(head->dev);
ip_fragment.c:295:	spin_unlock(&qp->lock);
ip_fragment.c:311:	for(qp = ipq_hash[hash]; qp; qp = qp->next) {
ip_fragment.c:312:		if(qp->id == qp_in->id		&&
ip_fragment.c:313:		   qp->saddr == qp_in->saddr	&&
ip_fragment.c:314:		   qp->daddr == qp_in->daddr	&&
ip_fragment.c:315:		   qp->protocol == qp_in->protocol) {
ip_fragment.c:316:			atomic_inc(&qp->refcnt);
ip_fragment.c:318:			qp_in->last_in |= COMPLETE;
ip_fragment.c:326:	if (!mod_timer(&qp->timer, jiffies + sysctl_ipfrag_time))
ip_fragment.c:327:		atomic_inc(&qp->refcnt);
ip_fragment.c:329:	atomic_inc(&qp->refcnt);
ip_fragment.c:330:	if((qp->next = ipq_hash[hash]) != NULL)
ip_fragment.c:331:		qp->next->pprev = &qp->next;
ip_fragment.c:333:	qp->pprev = &ipq_hash[hash];
ip_fragment.c:334:	INIT_LIST_HEAD(&qp->lru_list);
ip_fragment.c:335:	list_add_tail(&qp->lru_list, &ipq_lru_list);
ip_fragment.c:349:	qp->protocol = iph->protocol;
ip_fragment.c:350:	qp->last_in = 0;
ip_fragment.c:351:	qp->id = iph->id;
ip_fragment.c:352:	qp->saddr = iph->saddr;
ip_fragment.c:353:	qp->daddr = iph->daddr;
ip_fragment.c:354:	qp->len = 0;
ip_fragment.c:355:	qp->meat = 0;
ip_fragment.c:356:	qp->fragments = NULL;
ip_fragment.c:357:	qp->iif = 0;
ip_fragment.c:360:	init_timer(&qp->timer);
ip_fragment.c:361:	qp->timer.data = (unsigned long) qp;	/* pointer to queue	*/
ip_fragment.c:362:	qp->timer.function = ip_expire;		/* expire function	*/
ip_fragment.c:363:	qp->lock = SPIN_LOCK_UNLOCKED;
ip_fragment.c:364:	atomic_set(&qp->refcnt, 1);
ip_fragment.c:378:	__u16 id = iph->id;
ip_fragment.c:379:	__u32 saddr = iph->saddr;
ip_fragment.c:380:	__u32 daddr = iph->daddr;
ip_fragment.c:381:	__u8 protocol = iph->protocol;
ip_fragment.c:386:	for(qp = ipq_hash[hash]; qp; qp = qp->next) {
ip_fragment.c:387:		if(qp->id == id		&&
ip_fragment.c:388:		   qp->saddr == saddr	&&
ip_fragment.c:389:		   qp->daddr == daddr	&&
ip_fragment.c:390:		   qp->protocol == protocol) {
ip_fragment.c:391:			atomic_inc(&qp->refcnt);
ip_fragment.c:408:	if (qp->last_in & COMPLETE)
ip_fragment.c:411: 	offset = ntohs(skb->nh.iph->frag_off);
ip_fragment.c:414:	offset <<= 3;		/* offset is in 8-byte chunks */
ip_fragment.c:415: 	ihl = skb->nh.iph->ihl * 4;
ip_fragment.c:418: 	end = offset + skb->len - ihl;
ip_fragment.c:425:		if (end < qp->len ||
ip_fragment.c:426:		    ((qp->last_in & LAST_IN) && end != qp->len))
ip_fragment.c:428:		qp->last_in |= LAST_IN;
ip_fragment.c:429:		qp->len = end;
ip_fragment.c:433:			if (skb->ip_summed != CHECKSUM_UNNECESSARY)
ip_fragment.c:434:				skb->ip_summed = CHECKSUM_NONE;
ip_fragment.c:436:		if (end > qp->len) {
ip_fragment.c:437:			/* Some bits beyond end -> corruption. */
ip_fragment.c:438:			if (qp->last_in & LAST_IN)
ip_fragment.c:440:			qp->len = end;
ip_fragment.c:448:	if (pskb_trim(skb, end-offset))
ip_fragment.c:456:	for(next = qp->fragments; next != NULL; next = next->next) {
ip_fragment.c:457:		if (FRAG_CB(next)->offset >= offset)
ip_fragment.c:467:		int i = (FRAG_CB(prev)->offset + prev->len) - offset;
ip_fragment.c:475:			if (skb->ip_summed != CHECKSUM_UNNECESSARY)
ip_fragment.c:476:				skb->ip_summed = CHECKSUM_NONE;
ip_fragment.c:480:	while (next && FRAG_CB(next)->offset < end) {
ip_fragment.c:481:		int i = end - FRAG_CB(next)->offset; /* overlap is 'i' bytes */
ip_fragment.c:483:		if (i < next->len) {
ip_fragment.c:489:			FRAG_CB(next)->offset += i;
ip_fragment.c:490:			qp->meat -= i;
ip_fragment.c:491:			if (next->ip_summed != CHECKSUM_UNNECESSARY)
ip_fragment.c:492:				next->ip_summed = CHECKSUM_NONE;
ip_fragment.c:500:			next = next->next;
ip_fragment.c:503:				prev->next = next;
ip_fragment.c:505:				qp->fragments = next;
ip_fragment.c:507:			qp->meat -= free_it->len;
ip_fragment.c:512:	FRAG_CB(skb)->offset = offset;
ip_fragment.c:515:	skb->next = next;
ip_fragment.c:517:		prev->next = skb;
ip_fragment.c:519:		qp->fragments = skb;
ip_fragment.c:521: 	if (skb->dev)
ip_fragment.c:522: 		qp->iif = skb->dev->ifindex;
ip_fragment.c:523:	skb->dev = NULL;
ip_fragment.c:524:	qp->stamp = skb->stamp;
ip_fragment.c:525:	qp->meat += skb->len;
ip_fragment.c:526:	atomic_add(skb->truesize, &ip_frag_mem);
ip_fragment.c:528:		qp->last_in |= FIRST_IN;
ip_fragment.c:531:	list_move_tail(&qp->lru_list, &ipq_lru_list);
ip_fragment.c:546:	struct sk_buff *fp, *head = qp->fragments;
ip_fragment.c:553:	BUG_TRAP(FRAG_CB(head)->offset == 0);
ip_fragment.c:556:	ihlen = head->nh.iph->ihl*4;
ip_fragment.c:557:	len = ihlen + qp->len;
ip_fragment.c:569:	if (skb_shinfo(head)->frag_list) {
ip_fragment.c:575:		clone->next = head->next;
ip_fragment.c:576:		head->next = clone;
ip_fragment.c:577:		skb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;
ip_fragment.c:578:		skb_shinfo(head)->frag_list = NULL;
ip_fragment.c:579:		for (i=0; i<skb_shinfo(head)->nr_frags; i++)
ip_fragment.c:580:			plen += skb_shinfo(head)->frags[i].size;
ip_fragment.c:581:		clone->len = clone->data_len = head->data_len - plen;
ip_fragment.c:582:		head->data_len -= clone->len;
ip_fragment.c:583:		head->len -= clone->len;
ip_fragment.c:584:		clone->csum = 0;
ip_fragment.c:585:		clone->ip_summed = head->ip_summed;
ip_fragment.c:586:		atomic_add(clone->truesize, &ip_frag_mem);
ip_fragment.c:589:	skb_shinfo(head)->frag_list = head->next;
ip_fragment.c:590:	skb_push(head, head->data - head->nh.raw);
ip_fragment.c:591:	atomic_sub(head->truesize, &ip_frag_mem);
ip_fragment.c:593:	for (fp=head->next; fp; fp = fp->next) {
ip_fragment.c:594:		head->data_len += fp->len;
ip_fragment.c:595:		head->len += fp->len;
ip_fragment.c:596:		if (head->ip_summed != fp->ip_summed)
ip_fragment.c:597:			head->ip_summed = CHECKSUM_NONE;
ip_fragment.c:598:		else if (head->ip_summed == CHECKSUM_HW)
ip_fragment.c:599:			head->csum = csum_add(head->csum, fp->csum);
ip_fragment.c:600:		head->truesize += fp->truesize;
ip_fragment.c:601:		atomic_sub(fp->truesize, &ip_frag_mem);
ip_fragment.c:604:	head->next = NULL;
ip_fragment.c:605:	head->dev = dev;
ip_fragment.c:606:	head->stamp = qp->stamp;
ip_fragment.c:608:	iph = head->nh.iph;
ip_fragment.c:609:	iph->frag_off = 0;
ip_fragment.c:610:	iph->tot_len = htons(len);
ip_fragment.c:612:	qp->fragments = NULL;
ip_fragment.c:625:			NIPQUAD(qp->saddr));
ip_fragment.c:634:	struct iphdr *iph = skb->nh.iph;
ip_fragment.c:644:	dev = skb->dev;
ip_fragment.c:650:		spin_lock(&qp->lock);
ip_fragment.c:654:		if (qp->last_in == (FIRST_IN|LAST_IN) &&
ip_fragment.c:655:		    qp->meat == qp->len)
ip_fragment.c:658:		spin_unlock(&qp->lock);
ip_gre.c:49:   --------------------
ip_gre.c:58:   to keep skb->encapsulation counter (sort of local ttl),
ip_gre.c:63:   Current solution: t->recursion lock breaks dead loops. It looks 
ip_gre.c:64:   like dev->tbusy flag, but I preferred new variable, because
ip_gre.c:66:   will be multithreaded we will have to use skb->encapsulation.
ip_gre.c:71:   kill network. IP hop limit plays role of "t->recursion" in this case,
ip_gre.c:75:   - Routing protocols, using packets with ttl=1 (OSPF, RIP2),
ip_gre.c:77:   - traceroute does not work. I planned to relay ICMP from tunnel,
ip_gre.c:81:     true router now :-)), all routers (at least, in neighbourhood of mine)
ip_gre.c:93:   that is ALL. :-) Well, it does not remove the problem completely,
ip_gre.c:102:   fatal static route: you are innocent. :-)
ip_gre.c:168:	for (t = tunnels_r_l[h0^h1]; t; t = t->next) {
ip_gre.c:169:		if (local == t->parms.iph.saddr && remote == t->parms.iph.daddr) {
ip_gre.c:170:			if (t->parms.i_key == key && (t->dev->flags&IFF_UP))
ip_gre.c:174:	for (t = tunnels_r[h0^h1]; t; t = t->next) {
ip_gre.c:175:		if (remote == t->parms.iph.daddr) {
ip_gre.c:176:			if (t->parms.i_key == key && (t->dev->flags&IFF_UP))
ip_gre.c:180:	for (t = tunnels_l[h1]; t; t = t->next) {
ip_gre.c:181:		if (local == t->parms.iph.saddr ||
ip_gre.c:182:		     (local == t->parms.iph.daddr && MULTICAST(local))) {
ip_gre.c:183:			if (t->parms.i_key == key && (t->dev->flags&IFF_UP))
ip_gre.c:187:	for (t = tunnels_wc[h1]; t; t = t->next) {
ip_gre.c:188:		if (t->parms.i_key == key && (t->dev->flags&IFF_UP))
ip_gre.c:198:	u32 remote = t->parms.iph.daddr;
ip_gre.c:199:	u32 local = t->parms.iph.saddr;
ip_gre.c:200:	u32 key = t->parms.i_key;
ip_gre.c:218:	t->next = *tp;
ip_gre.c:228:	for (tp = ipgre_bucket(t); *tp; tp = &(*tp)->next) {
ip_gre.c:231:			*tp = t->next;
ip_gre.c:240:	u32 remote = parms->iph.daddr;
ip_gre.c:241:	u32 local = parms->iph.saddr;
ip_gre.c:242:	u32 key = parms->i_key;
ip_gre.c:254:	for (tp = &tunnels[prio][h]; (t = *tp) != NULL; tp = &t->next) {
ip_gre.c:255:		if (local == t->parms.iph.saddr && remote == t->parms.iph.daddr) {
ip_gre.c:256:			if (key == t->parms.i_key)
ip_gre.c:270:	dev->priv = (void*)(dev+1);
ip_gre.c:271:	nt = (struct ip_tunnel*)dev->priv;
ip_gre.c:272:	nt->dev = dev;
ip_gre.c:273:	dev->init = ipgre_tunnel_init;
ip_gre.c:274:	dev->features |= NETIF_F_DYNALLOC;
ip_gre.c:275:	memcpy(&nt->parms, parms, sizeof(*parms));
ip_gre.c:276:	nt->parms.name[IFNAMSIZ-1] = '\0';
ip_gre.c:277:	strcpy(dev->name, nt->parms.name);
ip_gre.c:278:	if (dev->name[0] == 0) {
ip_gre.c:281:			sprintf(dev->name, "gre%d", i);
ip_gre.c:282:			if (__dev_get_by_name(dev->name) == NULL)
ip_gre.c:287:		memcpy(nt->parms.name, dev->name, IFNAMSIZ);
ip_gre.c:312:	ipgre_tunnel_unlink((struct ip_tunnel*)dev->priv);
ip_gre.c:321:/* It is not :-( All the routers (except for Linux) return only
ip_gre.c:334:	struct iphdr *iph = (struct iphdr*)skb->data;
ip_gre.c:335:	u16	     *p = (u16*)(skb->data+(iph->ihl<<2));
ip_gre.c:336:	int grehlen = (iph->ihl<<2) + 4;
ip_gre.c:337:	int type = skb->h.icmph->type;
ip_gre.c:338:	int code = skb->h.icmph->code;
ip_gre.c:374:			   I believe they are just ether pollution. --ANK
ip_gre.c:386:	t = ipgre_tunnel_lookup(iph->daddr, iph->saddr, (flags&GRE_KEY) ? *(((u32*)p) + (grehlen>>2) - 1) : 0);
ip_gre.c:387:	if (t == NULL || t->parms.iph.daddr == 0 || MULTICAST(t->parms.iph.daddr))
ip_gre.c:390:	if (t->parms.iph.ttl == 0 && type == ICMP_TIME_EXCEEDED)
ip_gre.c:393:	if (jiffies - t->err_time < IPTUNNEL_ERR_TIMEO)
ip_gre.c:394:		t->err_count++;
ip_gre.c:396:		t->err_count = 1;
ip_gre.c:397:	t->err_time = jiffies;
ip_gre.c:404:	u16	     *p = (u16*)(dp+(iph->ihl<<2));
ip_gre.c:405:	int type = skb->h.icmph->type;
ip_gre.c:406:	int code = skb->h.icmph->code;
ip_gre.c:411:	int grehlen = (iph->ihl<<2) + 4;
ip_gre.c:437:		if (skb->h.icmph->un.gateway < (iph->ihl<<2))
ip_gre.c:444:		rel_info = skb->h.icmph->un.gateway - grehlen;
ip_gre.c:454:			/* And it is the only really necesary thing :-) */
ip_gre.c:455:			rel_info = ntohs(skb->h.icmph->un.frag.mtu);
ip_gre.c:458:			rel_info -= grehlen;
ip_gre.c:460:			if (rel_info > ntohs(eiph->tot_len))
ip_gre.c:466:			   I believe, it is just ether pollution. --ANK
ip_gre.c:483:	dst_release(skb2->dst);
ip_gre.c:484:	skb2->dst = NULL;
ip_gre.c:485:	skb_pull(skb2, skb->data - (u8*)eiph);
ip_gre.c:486:	skb2->nh.raw = skb2->data;
ip_gre.c:489:	if (ip_route_output(&rt, eiph->saddr, 0, RT_TOS(eiph->tos), 0)) {
ip_gre.c:493:	skb2->dev = rt->u.dst.dev;
ip_gre.c:496:	if (rt->rt_flags&RTCF_LOCAL) {
ip_gre.c:499:		if (ip_route_output(&rt, eiph->daddr, eiph->saddr, eiph->tos, 0) ||
ip_gre.c:500:		    rt->u.dst.dev->type != ARPHRD_IPGRE) {
ip_gre.c:507:		if (ip_route_input(skb2, eiph->daddr, eiph->saddr, eiph->tos, skb2->dev) ||
ip_gre.c:508:		    skb2->dst->dev->type != ARPHRD_IPGRE) {
ip_gre.c:516:		if (rel_info > skb2->dst->pmtu) {
ip_gre.c:520:		skb2->dst->pmtu = rel_info;
ip_gre.c:523:		struct ip_tunnel *t = (struct ip_tunnel*)skb2->dev->priv;
ip_gre.c:524:		if (t->parms.iph.ttl) {
ip_gre.c:537:	if (INET_ECN_is_ce(iph->tos)) {
ip_gre.c:538:		if (skb->protocol == htons(ETH_P_IP)) {
ip_gre.c:539:			if (INET_ECN_is_not_ce(skb->nh.iph->tos))
ip_gre.c:540:				IP_ECN_set_ce(skb->nh.iph);
ip_gre.c:541:		} else if (skb->protocol == htons(ETH_P_IPV6)) {
ip_gre.c:542:			if (INET_ECN_is_not_ce(ip6_get_dsfield(skb->nh.ipv6h)))
ip_gre.c:543:				IP6_ECN_set_ce(skb->nh.ipv6h);
ip_gre.c:552:	if (skb->protocol == htons(ETH_P_IP))
ip_gre.c:553:		inner = old_iph->tos;
ip_gre.c:554:	else if (skb->protocol == htons(ETH_P_IPV6))
ip_gre.c:573:	iph = skb->nh.iph;
ip_gre.c:574:	h = skb->data;
ip_gre.c:578:		/* - Version must be 0.
ip_gre.c:579:		   - We do not support routing headers.
ip_gre.c:585:			if (skb->ip_summed == CHECKSUM_HW) {
ip_gre.c:586:				csum = (u16)csum_fold(skb->csum);
ip_gre.c:588:					skb->ip_summed = CHECKSUM_NONE;
ip_gre.c:590:			if (skb->ip_summed == CHECKSUM_NONE) {
ip_gre.c:591:				skb->csum = skb_checksum(skb, 0, skb->len, 0);
ip_gre.c:592:				skb->ip_summed = CHECKSUM_HW;
ip_gre.c:593:				csum = (u16)csum_fold(skb->csum);
ip_gre.c:608:	if ((tunnel = ipgre_tunnel_lookup(iph->saddr, iph->daddr, key)) != NULL) {
ip_gre.c:609:		skb->mac.raw = skb->nh.raw;
ip_gre.c:610:		skb->nh.raw = __pskb_pull(skb, offset);
ip_gre.c:611:		memset(&(IPCB(skb)->opt), 0, sizeof(struct ip_options));
ip_gre.c:612:		if (skb->ip_summed == CHECKSUM_HW)
ip_gre.c:613:			skb->csum = csum_sub(skb->csum,
ip_gre.c:614:					     csum_partial(skb->mac.raw, skb->nh.raw-skb->mac.raw, 0));
ip_gre.c:615:		skb->protocol = *(u16*)(h + 2);
ip_gre.c:616:		skb->pkt_type = PACKET_HOST;
ip_gre.c:618:		if (MULTICAST(iph->daddr)) {
ip_gre.c:620:			if (((struct rtable*)skb->dst)->key.iif == 0)
ip_gre.c:622:			tunnel->stat.multicast++;
ip_gre.c:623:			skb->pkt_type = PACKET_BROADCAST;
ip_gre.c:628:		    (!(flags&GRE_CSUM) && tunnel->parms.i_flags&GRE_CSUM)) {
ip_gre.c:629:			tunnel->stat.rx_crc_errors++;
ip_gre.c:630:			tunnel->stat.rx_errors++;
ip_gre.c:633:		if (tunnel->parms.i_flags&GRE_SEQ) {
ip_gre.c:635:			    (tunnel->i_seqno && (s32)(seqno - tunnel->i_seqno) < 0)) {
ip_gre.c:636:				tunnel->stat.rx_fifo_errors++;
ip_gre.c:637:				tunnel->stat.rx_errors++;
ip_gre.c:640:			tunnel->i_seqno = seqno + 1;
ip_gre.c:642:		tunnel->stat.rx_packets++;
ip_gre.c:643:		tunnel->stat.rx_bytes += skb->len;
ip_gre.c:644:		skb->dev = tunnel->dev;
ip_gre.c:645:		dst_release(skb->dst);
ip_gre.c:646:		skb->dst = NULL;
ip_gre.c:648:		nf_conntrack_put(skb->nfct);
ip_gre.c:649:		skb->nfct = NULL;
ip_gre.c:651:		skb->nf_debug = 0;
ip_gre.c:676:	struct ip_tunnel *tunnel = (struct ip_tunnel*)dev->priv;
ip_gre.c:677:	struct net_device_stats *stats = &tunnel->stat;
ip_gre.c:678:	struct iphdr  *old_iph = skb->nh.iph;
ip_gre.c:690:	if (tunnel->recursion++) {
ip_gre.c:691:		tunnel->stat.collisions++;
ip_gre.c:695:	if (dev->hard_header) {
ip_gre.c:697:		tiph = (struct iphdr*)skb->data;
ip_gre.c:699:		gre_hlen = tunnel->hlen;
ip_gre.c:700:		tiph = &tunnel->parms.iph;
ip_gre.c:703:	if ((dst = tiph->daddr) == 0) {
ip_gre.c:706:		if (skb->dst == NULL) {
ip_gre.c:707:			tunnel->stat.tx_fifo_errors++;
ip_gre.c:711:		if (skb->protocol == htons(ETH_P_IP)) {
ip_gre.c:712:			rt = (struct rtable*)skb->dst;
ip_gre.c:713:			if ((dst = rt->rt_gateway) == 0)
ip_gre.c:717:		else if (skb->protocol == htons(ETH_P_IPV6)) {
ip_gre.c:720:			struct neighbour *neigh = skb->dst->neighbour;
ip_gre.c:725:			addr6 = (struct in6_addr*)&neigh->primary_key;
ip_gre.c:729:				addr6 = &skb->nh.ipv6h->daddr;
ip_gre.c:736:			dst = addr6->s6_addr32[3];
ip_gre.c:743:	tos = tiph->tos;
ip_gre.c:745:		if (skb->protocol == htons(ETH_P_IP))
ip_gre.c:746:			tos = old_iph->tos;
ip_gre.c:750:	if (ip_route_output(&rt, dst, tiph->saddr, RT_TOS(tos), tunnel->parms.link)) {
ip_gre.c:751:		tunnel->stat.tx_carrier_errors++;
ip_gre.c:754:	tdev = rt->u.dst.dev;
ip_gre.c:758:		tunnel->stat.collisions++;
ip_gre.c:762:	df = tiph->frag_off;
ip_gre.c:764:		mtu = rt->u.dst.pmtu - tunnel->hlen;
ip_gre.c:766:		mtu = skb->dst ? skb->dst->pmtu : dev->mtu;
ip_gre.c:768:	if (skb->protocol == htons(ETH_P_IP)) {
ip_gre.c:769:		if (skb->dst && mtu < skb->dst->pmtu && mtu >= 68)
ip_gre.c:770:			skb->dst->pmtu = mtu;
ip_gre.c:772:		df |= (old_iph->frag_off&htons(IP_DF));
ip_gre.c:774:		if ((old_iph->frag_off&htons(IP_DF)) &&
ip_gre.c:775:		    mtu < ntohs(old_iph->tot_len)) {
ip_gre.c:782:	else if (skb->protocol == htons(ETH_P_IPV6)) {
ip_gre.c:783:		struct rt6_info *rt6 = (struct rt6_info*)skb->dst;
ip_gre.c:785:		if (rt6 && mtu < rt6->u.dst.pmtu && mtu >= IPV6_MIN_MTU) {
ip_gre.c:786:			if ((tunnel->parms.iph.daddr && !MULTICAST(tunnel->parms.iph.daddr)) ||
ip_gre.c:787:			    rt6->rt6i_dst.plen == 128) {
ip_gre.c:788:				rt6->rt6i_flags |= RTF_MODIFIED;
ip_gre.c:789:				skb->dst->pmtu = mtu;
ip_gre.c:793:		if (mtu >= IPV6_MIN_MTU && mtu < skb->len - tunnel->hlen + gre_hlen) {
ip_gre.c:801:	if (tunnel->err_count > 0) {
ip_gre.c:802:		if (jiffies - tunnel->err_time < IPTUNNEL_ERR_TIMEO) {
ip_gre.c:803:			tunnel->err_count--;
ip_gre.c:807:			tunnel->err_count = 0;
ip_gre.c:810:	max_headroom = ((tdev->hard_header_len+15)&~15)+ gre_hlen;
ip_gre.c:816:  			stats->tx_dropped++;
ip_gre.c:818:			tunnel->recursion--;
ip_gre.c:821:		if (skb->sk)
ip_gre.c:822:			skb_set_owner_w(new_skb, skb->sk);
ip_gre.c:825:		old_iph = skb->nh.iph;
ip_gre.c:828:	skb->h.raw = skb->nh.raw;
ip_gre.c:829:	skb->nh.raw = skb_push(skb, gre_hlen);
ip_gre.c:830:	memset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));
ip_gre.c:831:	dst_release(skb->dst);
ip_gre.c:832:	skb->dst = &rt->u.dst;
ip_gre.c:838:	iph 			=	skb->nh.iph;
ip_gre.c:839:	iph->version		=	4;
ip_gre.c:840:	iph->ihl		=	sizeof(struct iphdr) >> 2;
ip_gre.c:841:	iph->frag_off		=	df;
ip_gre.c:842:	iph->protocol		=	IPPROTO_GRE;
ip_gre.c:843:	iph->tos		=	ipgre_ecn_encapsulate(tos, old_iph, skb);
ip_gre.c:844:	iph->daddr		=	rt->rt_dst;
ip_gre.c:845:	iph->saddr		=	rt->rt_src;
ip_gre.c:847:	if ((iph->ttl = tiph->ttl) == 0) {
ip_gre.c:848:		if (skb->protocol == htons(ETH_P_IP))
ip_gre.c:849:			iph->ttl = old_iph->ttl;
ip_gre.c:851:		else if (skb->protocol == htons(ETH_P_IPV6))
ip_gre.c:852:			iph->ttl = ((struct ipv6hdr*)old_iph)->hop_limit;
ip_gre.c:855:			iph->ttl = sysctl_ip_default_ttl;
ip_gre.c:858:	((u16*)(iph+1))[0] = tunnel->parms.o_flags;
ip_gre.c:859:	((u16*)(iph+1))[1] = skb->protocol;
ip_gre.c:861:	if (tunnel->parms.o_flags&(GRE_KEY|GRE_CSUM|GRE_SEQ)) {
ip_gre.c:862:		u32 *ptr = (u32*)(((u8*)iph) + tunnel->hlen - 4);
ip_gre.c:864:		if (tunnel->parms.o_flags&GRE_SEQ) {
ip_gre.c:865:			++tunnel->o_seqno;
ip_gre.c:866:			*ptr = htonl(tunnel->o_seqno);
ip_gre.c:867:			ptr--;
ip_gre.c:869:		if (tunnel->parms.o_flags&GRE_KEY) {
ip_gre.c:870:			*ptr = tunnel->parms.o_key;
ip_gre.c:871:			ptr--;
ip_gre.c:873:		if (tunnel->parms.o_flags&GRE_CSUM) {
ip_gre.c:875:			*(__u16*)ptr = ip_compute_csum((void*)(iph+1), skb->len - sizeof(struct iphdr));
ip_gre.c:880:	nf_conntrack_put(skb->nfct);
ip_gre.c:881:	skb->nfct = NULL;
ip_gre.c:883:	skb->nf_debug = 0;
ip_gre.c:888:	tunnel->recursion--;
ip_gre.c:895:	stats->tx_errors++;
ip_gre.c:897:	tunnel->recursion--;
ip_gre.c:914:			if (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p))) {
ip_gre.c:915:				err = -EFAULT;
ip_gre.c:921:			t = (struct ip_tunnel*)dev->priv;
ip_gre.c:922:		memcpy(&p, &t->parms, sizeof(p));
ip_gre.c:923:		if (copy_to_user(ifr->ifr_ifru.ifru_data, &p, sizeof(p)))
ip_gre.c:924:			err = -EFAULT;
ip_gre.c:929:		err = -EPERM;
ip_gre.c:933:		err = -EFAULT;
ip_gre.c:934:		if (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))
ip_gre.c:937:		err = -EINVAL;
ip_gre.c:955:				if (t->dev != dev) {
ip_gre.c:956:					err = -EEXIST;
ip_gre.c:962:				t = (struct ip_tunnel*)dev->priv;
ip_gre.c:969:				if ((dev->flags^nflags)&(IFF_POINTOPOINT|IFF_BROADCAST)) {
ip_gre.c:970:					err = -EINVAL;
ip_gre.c:974:				t->parms.iph.saddr = p.iph.saddr;
ip_gre.c:975:				t->parms.iph.daddr = p.iph.daddr;
ip_gre.c:976:				t->parms.i_key = p.i_key;
ip_gre.c:977:				t->parms.o_key = p.o_key;
ip_gre.c:978:				memcpy(dev->dev_addr, &p.iph.saddr, 4);
ip_gre.c:979:				memcpy(dev->broadcast, &p.iph.daddr, 4);
ip_gre.c:988:				t->parms.iph.ttl = p.iph.ttl;
ip_gre.c:989:				t->parms.iph.tos = p.iph.tos;
ip_gre.c:990:				t->parms.iph.frag_off = p.iph.frag_off;
ip_gre.c:992:			if (copy_to_user(ifr->ifr_ifru.ifru_data, &t->parms, sizeof(p)))
ip_gre.c:993:				err = -EFAULT;
ip_gre.c:995:			err = (cmd == SIOCADDTUNNEL ? -ENOBUFS : -ENOENT);
ip_gre.c:999:		err = -EPERM;
ip_gre.c:1004:			err = -EFAULT;
ip_gre.c:1005:			if (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))
ip_gre.c:1007:			err = -ENOENT;
ip_gre.c:1010:			err = -EPERM;
ip_gre.c:1013:			dev = t->dev;
ip_gre.c:1019:		err = -EINVAL;
ip_gre.c:1029:	return &(((struct ip_tunnel*)dev->priv)->stat);
ip_gre.c:1034:	struct ip_tunnel *tunnel = (struct ip_tunnel*)dev->priv;
ip_gre.c:1035:	if (new_mtu < 68 || new_mtu > 0xFFF8 - tunnel->hlen)
ip_gre.c:1036:		return -EINVAL;
ip_gre.c:1037:	dev->mtu = new_mtu;
ip_gre.c:1042:/* Nice toy. Unfortunately, useless in real life :-)
ip_gre.c:1053:   with broadcast 224.66.66.66. If you have access to mbone, play with me :-)
ip_gre.c:1055:   ping -t 255 224.66.66.66
ip_gre.c:1074:	struct ip_tunnel *t = (struct ip_tunnel*)dev->priv;
ip_gre.c:1075:	struct iphdr *iph = (struct iphdr *)skb_push(skb, t->hlen);
ip_gre.c:1078:	memcpy(iph, &t->parms.iph, sizeof(struct iphdr));
ip_gre.c:1079:	p[0]		= t->parms.o_flags;
ip_gre.c:1087:		memcpy(&iph->saddr, saddr, 4);
ip_gre.c:1090:		memcpy(&iph->daddr, daddr, 4);
ip_gre.c:1091:		return t->hlen;
ip_gre.c:1093:	if (iph->daddr && !MULTICAST(iph->daddr))
ip_gre.c:1094:		return t->hlen;
ip_gre.c:1096:	return -t->hlen;
ip_gre.c:1101:	struct ip_tunnel *t = (struct ip_tunnel*)dev->priv;
ip_gre.c:1104:	if (MULTICAST(t->parms.iph.daddr)) {
ip_gre.c:1106:		if (ip_route_output(&rt, t->parms.iph.daddr,
ip_gre.c:1107:				    t->parms.iph.saddr, RT_TOS(t->parms.iph.tos), 
ip_gre.c:1108:				    t->parms.link)) {
ip_gre.c:1110:			return -EADDRNOTAVAIL;
ip_gre.c:1112:		dev = rt->u.dst.dev;
ip_gre.c:1116:			return -EADDRNOTAVAIL;
ip_gre.c:1118:		t->mlink = dev->ifindex;
ip_gre.c:1119:		ip_mc_inc_group(__in_dev_get(dev), t->parms.iph.daddr);
ip_gre.c:1126:	struct ip_tunnel *t = (struct ip_tunnel*)dev->priv;
ip_gre.c:1127:	if (MULTICAST(t->parms.iph.daddr) && t->mlink) {
ip_gre.c:1128:		struct in_device *in_dev = inetdev_by_index(t->mlink);
ip_gre.c:1130:			ip_mc_dec_group(in_dev, t->parms.iph.daddr);
ip_gre.c:1142:	struct ip_tunnel *t = (struct ip_tunnel*)dev->priv;
ip_gre.c:1144:	dev->uninit		= ipgre_tunnel_uninit;
ip_gre.c:1145:	dev->destructor		= ipgre_tunnel_destructor;
ip_gre.c:1146:	dev->hard_start_xmit	= ipgre_tunnel_xmit;
ip_gre.c:1147:	dev->get_stats		= ipgre_tunnel_get_stats;
ip_gre.c:1148:	dev->do_ioctl		= ipgre_tunnel_ioctl;
ip_gre.c:1149:	dev->change_mtu		= ipgre_tunnel_change_mtu;
ip_gre.c:1151:	dev->type		= ARPHRD_IPGRE;
ip_gre.c:1152:	dev->hard_header_len 	= LL_MAX_HEADER + sizeof(struct iphdr) + 4;
ip_gre.c:1153:	dev->mtu		= 1500 - sizeof(struct iphdr) - 4;
ip_gre.c:1154:	dev->flags		= IFF_NOARP;
ip_gre.c:1155:	dev->iflink		= 0;
ip_gre.c:1156:	dev->addr_len		= 4;
ip_gre.c:1157:	memcpy(dev->dev_addr, &t->parms.iph.saddr, 4);
ip_gre.c:1158:	memcpy(dev->broadcast, &t->parms.iph.daddr, 4);
ip_gre.c:1170:	tunnel = (struct ip_tunnel*)dev->priv;
ip_gre.c:1171:	iph = &tunnel->parms.iph;
ip_gre.c:1177:	if (iph->daddr) {
ip_gre.c:1179:		if (!ip_route_output(&rt, iph->daddr, iph->saddr, RT_TOS(iph->tos), tunnel->parms.link)) {
ip_gre.c:1180:			tdev = rt->u.dst.dev;
ip_gre.c:1184:		dev->flags |= IFF_POINTOPOINT;
ip_gre.c:1187:		if (MULTICAST(iph->daddr)) {
ip_gre.c:1188:			if (!iph->saddr)
ip_gre.c:1189:				return -EINVAL;
ip_gre.c:1190:			dev->flags = IFF_BROADCAST;
ip_gre.c:1191:			dev->hard_header = ipgre_header;
ip_gre.c:1192:			dev->open = ipgre_open;
ip_gre.c:1193:			dev->stop = ipgre_close;
ip_gre.c:1198:	if (!tdev && tunnel->parms.link)
ip_gre.c:1199:		tdev = __dev_get_by_index(tunnel->parms.link);
ip_gre.c:1202:		hlen = tdev->hard_header_len;
ip_gre.c:1203:		mtu = tdev->mtu;
ip_gre.c:1205:	dev->iflink = tunnel->parms.link;
ip_gre.c:1208:	if (tunnel->parms.o_flags&(GRE_CSUM|GRE_KEY|GRE_SEQ)) {
ip_gre.c:1209:		if (tunnel->parms.o_flags&GRE_CSUM)
ip_gre.c:1211:		if (tunnel->parms.o_flags&GRE_KEY)
ip_gre.c:1213:		if (tunnel->parms.o_flags&GRE_SEQ)
ip_gre.c:1216:	dev->hard_header_len = hlen + addend;
ip_gre.c:1217:	dev->mtu = mtu - addend;
ip_gre.c:1218:	tunnel->hlen = addend;
ip_gre.c:1238:	struct ip_tunnel *tunnel = (struct ip_tunnel*)dev->priv;
ip_gre.c:1243:	dev->open		= ipgre_fb_tunnel_open;
ip_gre.c:1244:	dev->stop		= ipgre_fb_tunnel_close;
ip_gre.c:1248:	iph->version		= 4;
ip_gre.c:1249:	iph->protocol		= IPPROTO_GRE;
ip_gre.c:1250:	iph->ihl		= 5;
ip_gre.c:1251:	tunnel->hlen		= sizeof(struct iphdr) + 4;
ip_input.c:36: *		Gerhard Koerting: 	Fixes to my fix of the above 8-).
ip_input.c:59: *		Alan Cox	: 	IP options adjust sk->priority.
ip_input.c:78: *		Alan Cox	:	Loopback didn't work right in original ip_build_xmit - fixed it.
ip_input.c:148:	if(skb->nfmark == 0xdeadbeef)					\
ip_input.c:163:	u8 protocol = skb->nh.iph->protocol;
ip_input.c:167:	for (ra = ip_ra_chain; ra; ra = ra->next) {
ip_input.c:168:		struct sock *sk = ra->sk;
ip_input.c:173:		if (sk && sk->num == protocol 
ip_input.c:174:		    && ((sk->bound_dev_if == 0) 
ip_input.c:175:			|| (sk->bound_dev_if == skb->dev->ifindex))) {
ip_input.c:176:			if (skb->nh.iph->frag_off & htons(IP_MF|IP_OFFSET)) {
ip_input.c:208:		if (ipprot->protocol == iph->protocol) {
ip_input.c:210:			if (ipprot->copy || force_copy)
ip_input.c:214:				ipprot->handler(skb2);
ip_input.c:217:		ipprot = (struct inet_protocol *) ipprot->next;
ip_input.c:225:	int ihl = skb->nh.iph->ihl*4;
ip_input.c:236:	nf_conntrack_put(skb->nfct);
ip_input.c:237:	skb->nfct = NULL;
ip_input.c:241:        skb->h.raw = skb->data;
ip_input.c:245:		int protocol = skb->nh.iph->protocol;
ip_input.c:246:		int hash = protocol & (MAX_INET_PROTOS - 1);
ip_input.c:251:		/* If there maybe a raw socket we must check - if not we
ip_input.c:255:			raw_sk = raw_v4_input(skb, skb->nh.iph, hash);
ip_input.c:261:			   ipprot->next == NULL &&
ip_input.c:262:			   ipprot->protocol == protocol) {
ip_input.c:266:				ret = ipprot->handler(skb);
ip_input.c:270:				flag = ip_run_ipprot(skb, skb->nh.iph, ipprot, (raw_sk != NULL));
ip_input.c:300:	if (skb->nh.iph->frag_off & htons(IP_MF|IP_OFFSET)) {
ip_input.c:306:	return NF_HOOK(PF_INET, NF_IP_LOCAL_IN, skb, skb->dev, NULL,
ip_input.c:312:	struct net_device *dev = skb->dev;
ip_input.c:313:	struct iphdr *iph = skb->nh.iph;
ip_input.c:320:	if (skb->dst == NULL) {
ip_input.c:322:		if (ip_route_input(skb, iph->daddr, iph->saddr, iph->tos, dev))
ip_input.c:327:	if (skb->dst->tclassid) {
ip_input.c:329:		u32 idx = skb->dst->tclassid;
ip_input.c:331:		st[idx&0xFF].o_bytes+=skb->len;
ip_input.c:333:		st[(idx>>16)&0xFF].i_bytes+=skb->len;
ip_input.c:337:	if (iph->ihl > 5) {
ip_input.c:346:		                                      --ANK (980813)
ip_input.c:351:		iph = skb->nh.iph;
ip_input.c:356:		opt = &(IPCB(skb)->opt);
ip_input.c:357:		if (opt->srr) {
ip_input.c:362:						printk(KERN_INFO "source route option %u.%u.%u.%u -> %u.%u.%u.%u\n",
ip_input.c:363:						       NIPQUAD(iph->saddr), NIPQUAD(iph->daddr));
ip_input.c:375:	return skb->dst->input(skb);
ip_input.c:394:	if (skb->pkt_type == PACKET_OTHERHOST)
ip_input.c:405:	iph = skb->nh.iph;
ip_input.c:418:	if (iph->ihl < 5 || iph->version != 4)
ip_input.c:421:	if (!pskb_may_pull(skb, iph->ihl*4))
ip_input.c:424:	iph = skb->nh.iph;
ip_input.c:426:	if (ip_fast_csum((u8 *)iph, iph->ihl) != 0)
ip_input.c:430:		__u32 len = ntohs(iph->tot_len); 
ip_input.c:431:		if (skb->len < len || len < (iph->ihl<<2))
ip_input.c:436:		 * Note this now means skb->len holds ntohs(iph->tot_len).
ip_input.c:438:		if (skb->len > len) {
ip_input.c:440:			if (skb->ip_summed == CHECKSUM_HW)
ip_input.c:441:				skb->ip_summed = CHECKSUM_NONE;
ipip.c:12: *		Alan Cox	: 	Fixed bug with 1.3.18 and IPIP not working (now needs to set skb->h.iph)
ipip.c:15: *		Kai Schulte	:	Fixed #defines for IP_FIREWALL->FIREWALL
ipip.c:37:		-Sam Lantinga	(slouken@cs.ucdavis.edu)  02/01/95
ipip.c:40:		Cleaned up the code a little and added some pre-1.3.0 tweaks.
ipip.c:41:		dev->hard_header/hard_header_len changed to use no headers.
ipip.c:43:		Made the tunnels use dev->name not tunnel: when error reporting.
ipip.c:46:		-Alan Cox	(Alan.Cox@linux.org) 21 March 95
ipip.c:54:		-Sam Lantinga	(slouken@cs.ucdavis.edu) 02/13/96
ipip.c:74:	that buffer.  skb->len is set to the amount of space you have
ipip.c:75:	"allocated" with skb_put().  You can then write up to skb->len
ipip.c:92:   For comments look at net/ipv4/ip_gre.c --ANK
ipip.c:149:	for (t = tunnels_r_l[h0^h1]; t; t = t->next) {
ipip.c:150:		if (local == t->parms.iph.saddr &&
ipip.c:151:		    remote == t->parms.iph.daddr && (t->dev->flags&IFF_UP))
ipip.c:154:	for (t = tunnels_r[h0]; t; t = t->next) {
ipip.c:155:		if (remote == t->parms.iph.daddr && (t->dev->flags&IFF_UP))
ipip.c:158:	for (t = tunnels_l[h1]; t; t = t->next) {
ipip.c:159:		if (local == t->parms.iph.saddr && (t->dev->flags&IFF_UP))
ipip.c:162:	if ((t = tunnels_wc[0]) != NULL && (t->dev->flags&IFF_UP))
ipip.c:169:	u32 remote = t->parms.iph.daddr;
ipip.c:170:	u32 local = t->parms.iph.saddr;
ipip.c:190:	for (tp = ipip_bucket(t); *tp; tp = &(*tp)->next) {
ipip.c:193:			*tp = t->next;
ipip.c:204:	t->next = *tp;
ipip.c:212:	u32 remote = parms->iph.daddr;
ipip.c:213:	u32 local = parms->iph.saddr;
ipip.c:227:	for (tp = &tunnels[prio][h]; (t = *tp) != NULL; tp = &t->next) {
ipip.c:228:		if (local == t->parms.iph.saddr && remote == t->parms.iph.daddr)
ipip.c:241:	dev->priv = (void*)(dev+1);
ipip.c:242:	nt = (struct ip_tunnel*)dev->priv;
ipip.c:243:	nt->dev = dev;
ipip.c:244:	dev->init = ipip_tunnel_init;
ipip.c:245:	dev->features |= NETIF_F_DYNALLOC;
ipip.c:246:	memcpy(&nt->parms, parms, sizeof(*parms));
ipip.c:247:	nt->parms.name[IFNAMSIZ-1] = '\0';
ipip.c:248:	strcpy(dev->name, nt->parms.name);
ipip.c:249:	if (dev->name[0] == 0) {
ipip.c:252:			sprintf(dev->name, "tunl%d", i);
ipip.c:253:			if (__dev_get_by_name(dev->name) == NULL)
ipip.c:258:		memcpy(nt->parms.name, dev->name, IFNAMSIZ);
ipip.c:288:		ipip_tunnel_unlink((struct ip_tunnel*)dev->priv);
ipip.c:296:/* It is not :-( All the routers (except for Linux) return only
ipip.c:300:	struct iphdr *iph = (struct iphdr*)skb->data;
ipip.c:301:	int type = skb->h.icmph->type;
ipip.c:302:	int code = skb->h.icmph->code;
ipip.c:322:			   I believe they are just ether pollution. --ANK
ipip.c:334:	t = ipip_tunnel_lookup(iph->daddr, iph->saddr);
ipip.c:335:	if (t == NULL || t->parms.iph.daddr == 0)
ipip.c:337:	if (t->parms.iph.ttl == 0 && type == ICMP_TIME_EXCEEDED)
ipip.c:340:	if (jiffies - t->err_time < IPTUNNEL_ERR_TIMEO)
ipip.c:341:		t->err_count++;
ipip.c:343:		t->err_count = 1;
ipip.c:344:	t->err_time = jiffies;
ipip.c:350:	int hlen = iph->ihl<<2;
ipip.c:352:	int type = skb->h.icmph->type;
ipip.c:353:	int code = skb->h.icmph->code;
ipip.c:368:		if (skb->h.icmph->un.gateway < hlen)
ipip.c:375:		rel_info = skb->h.icmph->un.gateway - hlen;
ipip.c:385:			/* And it is the only really necesary thing :-) */
ipip.c:386:			rel_info = ntohs(skb->h.icmph->un.frag.mtu);
ipip.c:389:			rel_info -= hlen;
ipip.c:391:			if (rel_info > ntohs(eiph->tot_len))
ipip.c:397:			   I believe, it is just ether pollution. --ANK
ipip.c:414:	dst_release(skb2->dst);
ipip.c:415:	skb2->dst = NULL;
ipip.c:416:	skb_pull(skb2, skb->data - (u8*)eiph);
ipip.c:417:	skb2->nh.raw = skb2->data;
ipip.c:420:	if (ip_route_output(&rt, eiph->saddr, 0, RT_TOS(eiph->tos), 0)) {
ipip.c:424:	skb2->dev = rt->u.dst.dev;
ipip.c:427:	if (rt->rt_flags&RTCF_LOCAL) {
ipip.c:430:		if (ip_route_output(&rt, eiph->daddr, eiph->saddr, eiph->tos, 0) ||
ipip.c:431:		    rt->u.dst.dev->type != ARPHRD_IPGRE) {
ipip.c:438:		if (ip_route_input(skb2, eiph->daddr, eiph->saddr, eiph->tos, skb2->dev) ||
ipip.c:439:		    skb2->dst->dev->type != ARPHRD_IPGRE) {
ipip.c:447:		if (rel_info > skb2->dst->pmtu) {
ipip.c:451:		skb2->dst->pmtu = rel_info;
ipip.c:454:		struct ip_tunnel *t = (struct ip_tunnel*)skb2->dev->priv;
ipip.c:455:		if (t->parms.iph.ttl) {
ipip.c:469:	struct iphdr *inner_iph = skb->nh.iph;
ipip.c:471:	if (INET_ECN_is_ce(outer_iph->tos) &&
ipip.c:472:	    INET_ECN_is_not_ce(inner_iph->tos))
ipip.c:484:	iph = skb->nh.iph;
ipip.c:485:	skb->mac.raw = skb->nh.raw;
ipip.c:486:	skb->nh.raw = skb->data;
ipip.c:487:	memset(&(IPCB(skb)->opt), 0, sizeof(struct ip_options));
ipip.c:488:	skb->protocol = htons(ETH_P_IP);
ipip.c:489:	skb->pkt_type = PACKET_HOST;
ipip.c:492:	if ((tunnel = ipip_tunnel_lookup(iph->saddr, iph->daddr)) != NULL) {
ipip.c:493:		tunnel->stat.rx_packets++;
ipip.c:494:		tunnel->stat.rx_bytes += skb->len;
ipip.c:495:		skb->dev = tunnel->dev;
ipip.c:496:		dst_release(skb->dst);
ipip.c:497:		skb->dst = NULL;
ipip.c:499:		nf_conntrack_put(skb->nfct);
ipip.c:500:		skb->nfct = NULL;
ipip.c:502:		skb->nf_debug = 0;
ipip.c:531:	struct ip_tunnel *tunnel = (struct ip_tunnel*)dev->priv;
ipip.c:532:	struct net_device_stats *stats = &tunnel->stat;
ipip.c:533:	struct iphdr  *tiph = &tunnel->parms.iph;
ipip.c:534:	u8     tos = tunnel->parms.iph.tos;
ipip.c:535:	u16    df = tiph->frag_off;
ipip.c:538:	struct iphdr  *old_iph = skb->nh.iph;
ipip.c:541:	u32    dst = tiph->daddr;
ipip.c:544:	if (tunnel->recursion++) {
ipip.c:545:		tunnel->stat.collisions++;
ipip.c:549:	if (skb->protocol != htons(ETH_P_IP))
ipip.c:553:		tos = old_iph->tos;
ipip.c:557:		if ((rt = (struct rtable*)skb->dst) == NULL) {
ipip.c:558:			tunnel->stat.tx_fifo_errors++;
ipip.c:561:		if ((dst = rt->rt_gateway) == 0)
ipip.c:565:	if (ip_route_output(&rt, dst, tiph->saddr, RT_TOS(tos), tunnel->parms.link)) {
ipip.c:566:		tunnel->stat.tx_carrier_errors++;
ipip.c:569:	tdev = rt->u.dst.dev;
ipip.c:573:		tunnel->stat.collisions++;
ipip.c:577:	if (tiph->frag_off)
ipip.c:578:		mtu = rt->u.dst.pmtu - sizeof(struct iphdr);
ipip.c:580:		mtu = skb->dst ? skb->dst->pmtu : dev->mtu;
ipip.c:583:		tunnel->stat.collisions++;
ipip.c:587:	if (skb->dst && mtu < skb->dst->pmtu)
ipip.c:588:		skb->dst->pmtu = mtu;
ipip.c:590:	df |= (old_iph->frag_off&htons(IP_DF));
ipip.c:592:	if ((old_iph->frag_off&htons(IP_DF)) && mtu < ntohs(old_iph->tot_len)) {
ipip.c:598:	if (tunnel->err_count > 0) {
ipip.c:599:		if (jiffies - tunnel->err_time < IPTUNNEL_ERR_TIMEO) {
ipip.c:600:			tunnel->err_count--;
ipip.c:603:			tunnel->err_count = 0;
ipip.c:607:	 * Okay, now see if we can stuff it in the buffer as-is.
ipip.c:609:	max_headroom = (((tdev->hard_header_len+15)&~15)+sizeof(struct iphdr));
ipip.c:615:  			stats->tx_dropped++;
ipip.c:617:			tunnel->recursion--;
ipip.c:620:		if (skb->sk)
ipip.c:621:			skb_set_owner_w(new_skb, skb->sk);
ipip.c:624:		old_iph = skb->nh.iph;
ipip.c:627:	skb->h.raw = skb->nh.raw;
ipip.c:628:	skb->nh.raw = skb_push(skb, sizeof(struct iphdr));
ipip.c:629:	memset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));
ipip.c:630:	dst_release(skb->dst);
ipip.c:631:	skb->dst = &rt->u.dst;
ipip.c:637:	iph 			=	skb->nh.iph;
ipip.c:638:	iph->version		=	4;
ipip.c:639:	iph->ihl		=	sizeof(struct iphdr)>>2;
ipip.c:640:	iph->frag_off		=	df;
ipip.c:641:	iph->protocol		=	IPPROTO_IPIP;
ipip.c:642:	iph->tos		=	INET_ECN_encapsulate(tos, old_iph->tos);
ipip.c:643:	iph->daddr		=	rt->rt_dst;
ipip.c:644:	iph->saddr		=	rt->rt_src;
ipip.c:646:	if ((iph->ttl = tiph->ttl) == 0)
ipip.c:647:		iph->ttl	=	old_iph->ttl;
ipip.c:650:	nf_conntrack_put(skb->nfct);
ipip.c:651:	skb->nfct = NULL;
ipip.c:653:	skb->nf_debug = 0;
ipip.c:658:	tunnel->recursion--;
ipip.c:664:	stats->tx_errors++;
ipip.c:666:	tunnel->recursion--;
ipip.c:683:			if (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p))) {
ipip.c:684:				err = -EFAULT;
ipip.c:690:			t = (struct ip_tunnel*)dev->priv;
ipip.c:691:		memcpy(&p, &t->parms, sizeof(p));
ipip.c:692:		if (copy_to_user(ifr->ifr_ifru.ifru_data, &p, sizeof(p)))
ipip.c:693:			err = -EFAULT;
ipip.c:698:		err = -EPERM;
ipip.c:702:		err = -EFAULT;
ipip.c:703:		if (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))
ipip.c:706:		err = -EINVAL;
ipip.c:718:				if (t->dev != dev) {
ipip.c:719:					err = -EEXIST;
ipip.c:723:				if (((dev->flags&IFF_POINTOPOINT) && !p.iph.daddr) ||
ipip.c:724:				    (!(dev->flags&IFF_POINTOPOINT) && p.iph.daddr)) {
ipip.c:725:					err = -EINVAL;
ipip.c:728:				t = (struct ip_tunnel*)dev->priv;
ipip.c:730:				t->parms.iph.saddr = p.iph.saddr;
ipip.c:731:				t->parms.iph.daddr = p.iph.daddr;
ipip.c:732:				memcpy(dev->dev_addr, &p.iph.saddr, 4);
ipip.c:733:				memcpy(dev->broadcast, &p.iph.daddr, 4);
ipip.c:742:				t->parms.iph.ttl = p.iph.ttl;
ipip.c:743:				t->parms.iph.tos = p.iph.tos;
ipip.c:744:				t->parms.iph.frag_off = p.iph.frag_off;
ipip.c:746:			if (copy_to_user(ifr->ifr_ifru.ifru_data, &t->parms, sizeof(p)))
ipip.c:747:				err = -EFAULT;
ipip.c:749:			err = (cmd == SIOCADDTUNNEL ? -ENOBUFS : -ENOENT);
ipip.c:753:		err = -EPERM;
ipip.c:758:			err = -EFAULT;
ipip.c:759:			if (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))
ipip.c:761:			err = -ENOENT;
ipip.c:764:			err = -EPERM;
ipip.c:767:			dev = t->dev;
ipip.c:773:		err = -EINVAL;
ipip.c:783:	return &(((struct ip_tunnel*)dev->priv)->stat);
ipip.c:788:	if (new_mtu < 68 || new_mtu > 0xFFF8 - sizeof(struct iphdr))
ipip.c:789:		return -EINVAL;
ipip.c:790:	dev->mtu = new_mtu;
ipip.c:796:	struct ip_tunnel *t = (struct ip_tunnel*)dev->priv;
ipip.c:798:	dev->uninit		= ipip_tunnel_uninit;
ipip.c:799:	dev->destructor		= ipip_tunnel_destructor;
ipip.c:800:	dev->hard_start_xmit	= ipip_tunnel_xmit;
ipip.c:801:	dev->get_stats		= ipip_tunnel_get_stats;
ipip.c:802:	dev->do_ioctl		= ipip_tunnel_ioctl;
ipip.c:803:	dev->change_mtu		= ipip_tunnel_change_mtu;
ipip.c:805:	dev->type		= ARPHRD_TUNNEL;
ipip.c:806:	dev->hard_header_len 	= LL_MAX_HEADER + sizeof(struct iphdr);
ipip.c:807:	dev->mtu		= 1500 - sizeof(struct iphdr);
ipip.c:808:	dev->flags		= IFF_NOARP;
ipip.c:809:	dev->iflink		= 0;
ipip.c:810:	dev->addr_len		= 4;
ipip.c:811:	memcpy(dev->dev_addr, &t->parms.iph.saddr, 4);
ipip.c:812:	memcpy(dev->broadcast, &t->parms.iph.daddr, 4);
ipip.c:821:	tunnel = (struct ip_tunnel*)dev->priv;
ipip.c:822:	iph = &tunnel->parms.iph;
ipip.c:826:	if (iph->daddr) {
ipip.c:828:		if (!ip_route_output(&rt, iph->daddr, iph->saddr, RT_TOS(iph->tos), tunnel->parms.link)) {
ipip.c:829:			tdev = rt->u.dst.dev;
ipip.c:832:		dev->flags |= IFF_POINTOPOINT;
ipip.c:835:	if (!tdev && tunnel->parms.link)
ipip.c:836:		tdev = __dev_get_by_index(tunnel->parms.link);
ipip.c:839:		dev->hard_header_len = tdev->hard_header_len + sizeof(struct iphdr);
ipip.c:840:		dev->mtu = tdev->mtu - sizeof(struct iphdr);
ipip.c:842:	dev->iflink = tunnel->parms.link;
ipip.c:867:	dev->open		= ipip_fb_tunnel_open;
ipip.c:868:	dev->stop		= ipip_fb_tunnel_close;
ipip.c:872:	iph->version		= 4;
ipip.c:873:	iph->protocol		= IPPROTO_IPIP;
ipip.c:874:	iph->ihl		= 5;
ipmr.c:132:		p.iph.daddr = v->vifc_rmt_addr.s_addr;
ipmr.c:133:		p.iph.saddr = v->vifc_lcl_addr.s_addr;
ipmr.c:137:		sprintf(p.name, "dvmrp%d", v->vifc_vifi);
ipmr.c:141:		err = dev->do_ioctl(dev, &ifr, SIOCADDTUNNEL);
ipmr.c:147:			dev->flags |= IFF_MULTICAST;
ipmr.c:152:			in_dev->cnf.rp_filter = 0;
ipmr.c:167:static int reg_vif_num = -1;
ipmr.c:172:	((struct net_device_stats*)dev->priv)->tx_bytes += skb->len;
ipmr.c:173:	((struct net_device_stats*)dev->priv)->tx_packets++;
ipmr.c:182:	return (struct net_device_stats*)dev->priv;
ipmr.c:199:	dev->priv = dev + 1;
ipmr.c:201:	strcpy(dev->name, "pimreg");
ipmr.c:203:	dev->type		= ARPHRD_PIMREG;
ipmr.c:204:	dev->mtu		= 1500 - sizeof(struct iphdr) - 8;
ipmr.c:205:	dev->flags		= IFF_NOARP;
ipmr.c:206:	dev->hard_start_xmit	= reg_vif_xmit;
ipmr.c:207:	dev->get_stats		= reg_vif_get_stats;
ipmr.c:208:	dev->features		|= NETIF_F_DYNALLOC;
ipmr.c:214:	dev->iflink = 0;
ipmr.c:219:	in_dev->cnf.rp_filter = 0;
ipmr.c:243:		return -EADDRNOTAVAIL;
ipmr.c:248:	dev = v->dev;
ipmr.c:249:	v->dev = NULL;
ipmr.c:253:		return -EADDRNOTAVAIL;
ipmr.c:258:		reg_vif_num = -1;
ipmr.c:263:		for (tmp=vifi-1; tmp>=0; tmp--) {
ipmr.c:272:	dev_set_allmulti(dev, -1);
ipmr.c:275:		in_dev->cnf.mc_forwarding--;
ipmr.c:279:	if (v->flags&(VIFF_TUNNEL|VIFF_REGISTER))
ipmr.c:296:	while((skb=skb_dequeue(&c->mfc_un.unres.unresolved))) {
ipmr.c:297:		if (skb->nh.iph->version == 0) {
ipmr.c:299:			nlh->nlmsg_type = NLMSG_ERROR;
ipmr.c:300:			nlh->nlmsg_len = NLMSG_LENGTH(sizeof(struct nlmsgerr));
ipmr.c:301:			skb_trim(skb, nlh->nlmsg_len);
ipmr.c:302:			((struct nlmsgerr*)NLMSG_DATA(nlh))->error = -ETIMEDOUT;
ipmr.c:333:		long interval = c->mfc_un.unres.expires - now;
ipmr.c:338:			cp = &c->next;
ipmr.c:342:		*cp = c->next;
ipmr.c:360:	cache->mfc_un.res.minvif = MAXVIFS;
ipmr.c:361:	cache->mfc_un.res.maxvif = 0;
ipmr.c:362:	memset(cache->mfc_un.res.ttls, 255, MAXVIFS);
ipmr.c:366:			cache->mfc_un.res.ttls[vifi] = ttls[vifi];
ipmr.c:367:			if (cache->mfc_un.res.minvif > vifi)
ipmr.c:368:				cache->mfc_un.res.minvif = vifi;
ipmr.c:369:			if (cache->mfc_un.res.maxvif <= vifi)
ipmr.c:370:				cache->mfc_un.res.maxvif = vifi + 1;
ipmr.c:377:	int vifi = vifc->vifc_vifi;
ipmr.c:384:		return -EADDRINUSE;
ipmr.c:386:	switch (vifc->vifc_flags) {
ipmr.c:394:			return -EADDRINUSE;
ipmr.c:397:			return -ENOBUFS;
ipmr.c:403:			return -ENOBUFS;
ipmr.c:406:		dev=ip_dev_find(vifc->vifc_lcl_addr.s_addr);
ipmr.c:408:			return -EADDRNOTAVAIL;
ipmr.c:412:		return -EINVAL;
ipmr.c:416:		return -EADDRNOTAVAIL;
ipmr.c:417:	in_dev->cnf.mc_forwarding++;
ipmr.c:424:	v->rate_limit=vifc->vifc_rate_limit;
ipmr.c:425:	v->local=vifc->vifc_lcl_addr.s_addr;
ipmr.c:426:	v->remote=vifc->vifc_rmt_addr.s_addr;
ipmr.c:427:	v->flags=vifc->vifc_flags;
ipmr.c:429:		v->flags |= VIFF_STATIC;
ipmr.c:430:	v->threshold=vifc->vifc_threshold;
ipmr.c:431:	v->bytes_in = 0;
ipmr.c:432:	v->bytes_out = 0;
ipmr.c:433:	v->pkt_in = 0;
ipmr.c:434:	v->pkt_out = 0;
ipmr.c:435:	v->link = dev->ifindex;
ipmr.c:436:	if (v->flags&(VIFF_TUNNEL|VIFF_REGISTER))
ipmr.c:437:		v->link = dev->iflink;
ipmr.c:442:	v->dev=dev;
ipmr.c:444:	if (v->flags&VIFF_REGISTER)
ipmr.c:458:	for (c=mfc_cache_array[line]; c; c = c->next) {
ipmr.c:459:		if (c->mfc_origin==origin && c->mfc_mcastgrp==mcastgrp)
ipmr.c:474:	c->mfc_un.res.minvif = MAXVIFS;
ipmr.c:484:	skb_queue_head_init(&c->mfc_un.unres.unresolved);
ipmr.c:485:	c->mfc_un.unres.expires = jiffies + 10*HZ;
ipmr.c:501:	while((skb=__skb_dequeue(&uc->mfc_un.unres.unresolved))) {
ipmr.c:502:		if (skb->nh.iph->version == 0) {
ipmr.c:507:				nlh->nlmsg_len = skb->tail - (u8*)nlh;
ipmr.c:509:				nlh->nlmsg_type = NLMSG_ERROR;
ipmr.c:510:				nlh->nlmsg_len = NLMSG_LENGTH(sizeof(struct nlmsgerr));
ipmr.c:511:				skb_trim(skb, nlh->nlmsg_len);
ipmr.c:512:				((struct nlmsgerr*)NLMSG_DATA(nlh))->error = -EMSGSIZE;
ipmr.c:530:	int ihl = pkt->nh.iph->ihl<<2;
ipmr.c:543:		return -ENOBUFS;
ipmr.c:549:		   And all this only to mangle msg->im_msgtype and
ipmr.c:550:		   to set msg->im_mbz to "mbz" :-)
ipmr.c:553:		skb->nh.raw = skb->h.raw = (u8*)msg;
ipmr.c:554:		memcpy(msg, pkt->nh.raw, sizeof(struct iphdr));
ipmr.c:555:		msg->im_msgtype = IGMPMSG_WHOLEPKT;
ipmr.c:556:		msg->im_mbz = 0;
ipmr.c:557: 		msg->im_vif = reg_vif_num;
ipmr.c:558:		skb->nh.iph->ihl = sizeof(struct iphdr) >> 2;
ipmr.c:559:		skb->nh.iph->tot_len = htons(ntohs(pkt->nh.iph->tot_len) + sizeof(struct iphdr));
ipmr.c:568:	skb->nh.iph = (struct iphdr *)skb_put(skb, ihl);
ipmr.c:569:	memcpy(skb->data,pkt->data,ihl);
ipmr.c:570:	skb->nh.iph->protocol = 0;			/* Flag to the kernel this is a route add */
ipmr.c:571:	msg = (struct igmpmsg*)skb->nh.iph;
ipmr.c:572:	msg->im_vif = vifi;
ipmr.c:573:	skb->dst = dst_clone(pkt->dst);
ipmr.c:580:	igmp->type	=
ipmr.c:581:	msg->im_msgtype = assert;
ipmr.c:582:	igmp->code 	=	0;
ipmr.c:583:	skb->nh.iph->tot_len=htons(skb->len);			/* Fix the length */
ipmr.c:584:	skb->h.raw = skb->nh.raw;
ipmr.c:589:		return -EINVAL;
ipmr.c:615:	for (c=mfc_unres_queue; c; c=c->next) {
ipmr.c:616:		if (c->mfc_mcastgrp == skb->nh.iph->daddr &&
ipmr.c:617:		    c->mfc_origin == skb->nh.iph->saddr)
ipmr.c:631:			return -ENOBUFS;
ipmr.c:637:		c->mfc_parent=-1;
ipmr.c:638:		c->mfc_origin=skb->nh.iph->saddr;
ipmr.c:639:		c->mfc_mcastgrp=skb->nh.iph->daddr;
ipmr.c:646:			   out - Brad Parker
ipmr.c:656:		c->next = mfc_unres_queue;
ipmr.c:659:		mod_timer(&ipmr_expire_timer, c->mfc_un.unres.expires);
ipmr.c:665:	if (c->mfc_un.unres.unresolved.qlen>3) {
ipmr.c:667:		err = -ENOBUFS;
ipmr.c:669:		skb_queue_tail(&c->mfc_un.unres.unresolved,skb);
ipmr.c:686:	line=MFC_HASH(mfc->mfcc_mcastgrp.s_addr, mfc->mfcc_origin.s_addr);
ipmr.c:688:	for (cp=&mfc_cache_array[line]; (c=*cp) != NULL; cp = &c->next) {
ipmr.c:689:		if (c->mfc_origin == mfc->mfcc_origin.s_addr &&
ipmr.c:690:		    c->mfc_mcastgrp == mfc->mfcc_mcastgrp.s_addr) {
ipmr.c:692:			*cp = c->next;
ipmr.c:699:	return -ENOENT;
ipmr.c:707:	line=MFC_HASH(mfc->mfcc_mcastgrp.s_addr, mfc->mfcc_origin.s_addr);
ipmr.c:709:	for (cp=&mfc_cache_array[line]; (c=*cp) != NULL; cp = &c->next) {
ipmr.c:710:		if (c->mfc_origin == mfc->mfcc_origin.s_addr &&
ipmr.c:711:		    c->mfc_mcastgrp == mfc->mfcc_mcastgrp.s_addr)
ipmr.c:717:		c->mfc_parent = mfc->mfcc_parent;
ipmr.c:718:		ipmr_update_threshoulds(c, mfc->mfcc_ttls);
ipmr.c:720:			c->mfc_flags |= MFC_STATIC;
ipmr.c:725:	if(!MULTICAST(mfc->mfcc_mcastgrp.s_addr))
ipmr.c:726:		return -EINVAL;
ipmr.c:730:		return -ENOMEM;
ipmr.c:732:	c->mfc_origin=mfc->mfcc_origin.s_addr;
ipmr.c:733:	c->mfc_mcastgrp=mfc->mfcc_mcastgrp.s_addr;
ipmr.c:734:	c->mfc_parent=mfc->mfcc_parent;
ipmr.c:735:	ipmr_update_threshoulds(c, mfc->mfcc_ttls);
ipmr.c:737:		c->mfc_flags |= MFC_STATIC;
ipmr.c:740:	c->next = mfc_cache_array[line];
ipmr.c:750:	     cp = &uc->next) {
ipmr.c:751:		if (uc->mfc_origin == c->mfc_origin &&
ipmr.c:752:		    uc->mfc_mcastgrp == c->mfc_mcastgrp) {
ipmr.c:753:			*cp = uc->next;
ipmr.c:792:			if (c->mfc_flags&MFC_STATIC) {
ipmr.c:793:				cp = &c->next;
ipmr.c:797:			*cp = c->next;
ipmr.c:810:			mfc_unres_queue = c->next;
ipmr.c:825:		ipv4_devconf.mc_forwarding--;
ipmr.c:852:			return -EACCES;
ipmr.c:858:			if(sk->type!=SOCK_RAW || sk->num!=IPPROTO_IGMP)
ipmr.c:859:				return -EOPNOTSUPP;
ipmr.c:861:				return -ENOPROTOOPT;
ipmr.c:866:				return -EADDRINUSE;
ipmr.c:881:				return -EACCES;
ipmr.c:886:				return -EINVAL;
ipmr.c:888:				return -EFAULT; 
ipmr.c:890:				return -ENFILE;
ipmr.c:907:				return -EINVAL;
ipmr.c:909:				return -EFAULT;
ipmr.c:924:				return -EFAULT;
ipmr.c:933:				return -EFAULT;
ipmr.c:955:			return -ENOPROTOOPT;
ipmr.c:973:		return -ENOPROTOOPT;
ipmr.c:976:		return -EFAULT;
ipmr.c:980:		return -EINVAL;
ipmr.c:983:		return -EFAULT;
ipmr.c:993:		return -EFAULT;
ipmr.c:1012:				return -EFAULT; 
ipmr.c:1014:				return -EINVAL;
ipmr.c:1018:				vr.icount=vif->pkt_in;
ipmr.c:1019:				vr.ocount=vif->pkt_out;
ipmr.c:1020:				vr.ibytes=vif->bytes_in;
ipmr.c:1021:				vr.obytes=vif->bytes_out;
ipmr.c:1025:					return -EFAULT;
ipmr.c:1029:			return -EADDRNOTAVAIL;
ipmr.c:1032:				return -EFAULT;
ipmr.c:1037:				sr.pktcnt = c->mfc_un.res.pkt;
ipmr.c:1038:				sr.bytecnt = c->mfc_un.res.bytes;
ipmr.c:1039:				sr.wrong_if = c->mfc_un.res.wrong_if;
ipmr.c:1043:					return -EFAULT;
ipmr.c:1047:			return -EADDRNOTAVAIL;
ipmr.c:1049:			return -ENOIOCTLCMD;
ipmr.c:1062:		if (v->dev==ptr)
ipmr.c:1085:	iph->version	= 	4;
ipmr.c:1086:	iph->tos	=	skb->nh.iph->tos;
ipmr.c:1087:	iph->ttl	=	skb->nh.iph->ttl;
ipmr.c:1088:	iph->frag_off	=	0;
ipmr.c:1089:	iph->daddr	=	daddr;
ipmr.c:1090:	iph->saddr	=	saddr;
ipmr.c:1091:	iph->protocol	=	IPPROTO_IPIP;
ipmr.c:1092:	iph->ihl	=	5;
ipmr.c:1093:	iph->tot_len	=	htons(skb->len);
ipmr.c:1094:	ip_select_ident(iph, skb->dst, NULL);
ipmr.c:1097:	skb->h.ipiph = skb->nh.iph;
ipmr.c:1098:	skb->nh.iph = iph;
ipmr.c:1099:	memset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));
ipmr.c:1101:	nf_conntrack_put(skb->nfct);
ipmr.c:1102:	skb->nfct = NULL;
ipmr.c:1108:	struct ip_options *opt = &(IPCB(skb)->opt);
ipmr.c:1109:	struct dst_entry *dst = skb->dst;
ipmr.c:1111:	if (unlikely(opt->optlen))
ipmr.c:1114:	if (skb->len <= dst->pmtu)
ipmr.c:1115:		return dst->output(skb);
ipmr.c:1117:		return ip_fragment(skb, dst->output);
ipmr.c:1127:	struct iphdr *iph = skb->nh.iph;
ipmr.c:1134:	if (vif->dev == NULL)
ipmr.c:1138:	if (vif->flags & VIFF_REGISTER) {
ipmr.c:1139:		vif->pkt_out++;
ipmr.c:1140:		vif->bytes_out+=skb->len;
ipmr.c:1141:		((struct net_device_stats*)vif->dev->priv)->tx_bytes += skb->len;
ipmr.c:1142:		((struct net_device_stats*)vif->dev->priv)->tx_packets++;
ipmr.c:1148:	if (vif->flags&VIFF_TUNNEL) {
ipmr.c:1149:		if (ip_route_output(&rt, vif->remote, vif->local, RT_TOS(iph->tos), vif->link))
ipmr.c:1153:		if (ip_route_output(&rt, iph->daddr, 0, RT_TOS(iph->tos), vif->link))
ipmr.c:1157:	dev = rt->u.dst.dev;
ipmr.c:1159:	if (skb->len+encap > rt->u.dst.pmtu && (ntohs(iph->frag_off) & IP_DF)) {
ipmr.c:1170:	encap += dev->hard_header_len;
ipmr.c:1174:	else if (atomic_read(&skb->users) != 1)
ipmr.c:1177:		atomic_inc(&skb->users);
ipmr.c:1186:	vif->pkt_out++;
ipmr.c:1187:	vif->bytes_out+=skb->len;
ipmr.c:1189:	dst_release(skb2->dst);
ipmr.c:1190:	skb2->dst = &rt->u.dst;
ipmr.c:1191:	iph = skb2->nh.iph;
ipmr.c:1195:	 * What do we do with netfilter? -- RR */
ipmr.c:1196:	if (vif->flags & VIFF_TUNNEL) {
ipmr.c:1197:		ip_encap(skb2, vif->local, vif->remote);
ipmr.c:1198:		/* FIXME: extra output firewall step used to be here. --RR */
ipmr.c:1199:		((struct ip_tunnel *)vif->dev->priv)->stat.tx_packets++;
ipmr.c:1200:		((struct ip_tunnel *)vif->dev->priv)->stat.tx_bytes+=skb2->len;
ipmr.c:1203:	IPCB(skb2)->flags |= IPSKB_FORWARDED;
ipmr.c:1213:	 * not mrouter) cannot join to more than one interface - it will
ipmr.c:1216:	NF_HOOK(PF_INET, NF_IP_FORWARD, skb2, skb->dev, dev, 
ipmr.c:1223:	for (ct=maxvif-1; ct>=0; ct--) {
ipmr.c:1234:	int psend = -1;
ipmr.c:1237:	vif = cache->mfc_parent;
ipmr.c:1238:	cache->mfc_un.res.pkt++;
ipmr.c:1239:	cache->mfc_un.res.bytes += skb->len;
ipmr.c:1244:	if (vif_table[vif].dev != skb->dev) {
ipmr.c:1247:		if (((struct rtable*)skb->dst)->key.iif == 0) {
ipmr.c:1262:		cache->mfc_un.res.wrong_if++;
ipmr.c:1263:		true_vifi = ipmr_find_vif(skb->dev);
ipmr.c:1269:		       large chunk of pimd to kernel. Ough... --ANK
ipmr.c:1271:		    (mroute_do_pim || cache->mfc_un.res.ttls[true_vifi] < 255) &&
ipmr.c:1272:		    jiffies - cache->mfc_un.res.last_assert > MFC_ASSERT_THRESH) {
ipmr.c:1273:			cache->mfc_un.res.last_assert = jiffies;
ipmr.c:1280:	vif_table[vif].bytes_in+=skb->len;
ipmr.c:1285:	for (ct = cache->mfc_un.res.maxvif-1; ct >= cache->mfc_un.res.minvif; ct--) {
ipmr.c:1286:		if (skb->nh.iph->ttl > cache->mfc_un.res.ttls[ct]) {
ipmr.c:1287:			if (psend != -1)
ipmr.c:1292:	if (psend != -1)
ipmr.c:1309:	int local = ((struct rtable*)skb->dst)->rt_flags&RTCF_LOCAL;
ipmr.c:1314:	if (IPCB(skb)->flags&IPSKB_FORWARDED)
ipmr.c:1318:		    if (IPCB(skb)->opt.router_alert) {
ipmr.c:1321:		    } else if (skb->nh.iph->protocol == IPPROTO_IGMP){
ipmr.c:1339:	cache = ipmr_cache_find(skb->nh.iph->saddr, skb->nh.iph->daddr);
ipmr.c:1352:				return -ENOBUFS;
ipmr.c:1357:		vif = ipmr_find_vif(skb->dev);
ipmr.c:1366:		return -ENODEV;
ipmr.c:1392:	struct igmphdr *pim = (struct igmphdr*)skb->h.raw;
ipmr.c:1399:			return -ENOMEM;
ipmr.c:1401:		pim = (struct igmphdr*)skb->h.raw;
ipmr.c:1405:	    skb->len < sizeof(*pim) + sizeof(*encap) ||
ipmr.c:1406:	    pim->group != PIM_V1_VERSION || pim->code != PIM_V1_REGISTER) {
ipmr.c:1408:                return -EINVAL;
ipmr.c:1411:	encap = (struct iphdr*)(skb->h.raw + sizeof(struct igmphdr));
ipmr.c:1415:	   b. packet is not a NULL-REGISTER
ipmr.c:1418:	if (!MULTICAST(encap->daddr) ||
ipmr.c:1419:	    ntohs(encap->tot_len) == 0 ||
ipmr.c:1420:	    ntohs(encap->tot_len) + sizeof(*pim) > skb->len) {
ipmr.c:1422:		return -EINVAL;
ipmr.c:1434:		return -EINVAL;
ipmr.c:1437:	skb->mac.raw = skb->nh.raw;
ipmr.c:1438:	skb_pull(skb, (u8*)encap - skb->data);
ipmr.c:1439:	skb->nh.iph = (struct iphdr *)skb->data;
ipmr.c:1440:	skb->dev = reg_dev;
ipmr.c:1441:	memset(&(IPCB(skb)->opt), 0, sizeof(struct ip_options));
ipmr.c:1442:	skb->protocol = htons(ETH_P_IP);
ipmr.c:1443:	skb->ip_summed = 0;
ipmr.c:1444:	skb->pkt_type = PACKET_HOST;
ipmr.c:1445:	dst_release(skb->dst);
ipmr.c:1446:	skb->dst = NULL;
ipmr.c:1447:	((struct net_device_stats*)reg_dev->priv)->rx_bytes += skb->len;
ipmr.c:1448:	((struct net_device_stats*)reg_dev->priv)->rx_packets++;
ipmr.c:1450:	nf_conntrack_put(skb->nfct);
ipmr.c:1451:	skb->nfct = NULL;
ipmr.c:1462:	struct pimreghdr *pim = (struct pimreghdr*)skb->h.raw;
ipmr.c:1469:			return -ENOMEM;
ipmr.c:1471:		pim = (struct pimreghdr*)skb->h.raw;
ipmr.c:1474:        if (skb->len < sizeof(*pim) + sizeof(*encap) ||
ipmr.c:1475:	    pim->type != ((PIM_VERSION<<4)|(PIM_REGISTER)) ||
ipmr.c:1476:	    (pim->flags&PIM_NULL_REGISTER) ||
ipmr.c:1478:	     ip_compute_csum((void *)pim, skb->len))) {
ipmr.c:1480:                return -EINVAL;
ipmr.c:1484:	encap = (struct iphdr*)(skb->h.raw + sizeof(struct pimreghdr));
ipmr.c:1485:	if (!MULTICAST(encap->daddr) ||
ipmr.c:1486:	    ntohs(encap->tot_len) == 0 ||
ipmr.c:1487:	    ntohs(encap->tot_len) + sizeof(*pim) > skb->len) {
ipmr.c:1489:		return -EINVAL;
ipmr.c:1501:		return -EINVAL;
ipmr.c:1504:	skb->mac.raw = skb->nh.raw;
ipmr.c:1505:	skb_pull(skb, (u8*)encap - skb->data);
ipmr.c:1506:	skb->nh.iph = (struct iphdr *)skb->data;
ipmr.c:1507:	skb->dev = reg_dev;
ipmr.c:1508:	memset(&(IPCB(skb)->opt), 0, sizeof(struct ip_options));
ipmr.c:1509:	skb->protocol = htons(ETH_P_IP);
ipmr.c:1510:	skb->ip_summed = 0;
ipmr.c:1511:	skb->pkt_type = PACKET_HOST;
ipmr.c:1512:	dst_release(skb->dst);
ipmr.c:1513:	((struct net_device_stats*)reg_dev->priv)->rx_bytes += skb->len;
ipmr.c:1514:	((struct net_device_stats*)reg_dev->priv)->rx_packets++;
ipmr.c:1515:	skb->dst = NULL;
ipmr.c:1517:	nf_conntrack_put(skb->nfct);
ipmr.c:1518:	skb->nfct = NULL;
ipmr.c:1531:	struct net_device *dev = vif_table[c->mfc_parent].dev;
ipmr.c:1532:	u8 *b = skb->tail;
ipmr.c:1536:		RTA_PUT(skb, RTA_IIF, 4, &dev->ifindex);
ipmr.c:1540:	for (ct = c->mfc_un.res.minvif; ct < c->mfc_un.res.maxvif; ct++) {
ipmr.c:1541:		if (c->mfc_un.res.ttls[ct] < 255) {
ipmr.c:1545:			nhp->rtnh_flags = 0;
ipmr.c:1546:			nhp->rtnh_hops = c->mfc_un.res.ttls[ct];
ipmr.c:1547:			nhp->rtnh_ifindex = vif_table[ct].dev->ifindex;
ipmr.c:1548:			nhp->rtnh_len = sizeof(*nhp);
ipmr.c:1551:	mp_head->rta_type = RTA_MULTIPATH;
ipmr.c:1552:	mp_head->rta_len = skb->tail - (u8*)mp_head;
ipmr.c:1553:	rtm->rtm_type = RTN_MULTICAST;
ipmr.c:1557:	skb_trim(skb, b - skb->data);
ipmr.c:1558:	return -EMSGSIZE;
ipmr.c:1565:	struct rtable *rt = (struct rtable*)skb->dst;
ipmr.c:1568:	cache = ipmr_cache_find(rt->rt_src, rt->rt_dst);
ipmr.c:1576:			return -EAGAIN;
ipmr.c:1579:		dev = skb->dev;
ipmr.c:1582:			return -ENODEV;
ipmr.c:1584:		skb->nh.raw = skb_push(skb, sizeof(struct iphdr));
ipmr.c:1585:		skb->nh.iph->ihl = sizeof(struct iphdr)>>2;
ipmr.c:1586:		skb->nh.iph->saddr = rt->rt_src;
ipmr.c:1587:		skb->nh.iph->daddr = rt->rt_dst;
ipmr.c:1588:		skb->nh.iph->version = 0;
ipmr.c:1594:	if (!nowait && (rtm->rtm_flags&RTM_F_NOTIFY))
ipmr.c:1595:		cache->mfc_flags |= MFC_NOTIFY;
ipmr.c:1626:		if (vif->dev)
ipmr.c:1627:			name = vif->dev->name;
ipmr.c:1628:        	size = sprintf(buffer+len, "%2d %-10s %8ld %7ld  %8ld %7ld %05X %08X %08X\n",
ipmr.c:1629:        		ct, name, vif->bytes_in, vif->pkt_in, vif->bytes_out, vif->pkt_out,
ipmr.c:1630:        		vif->flags, vif->local, vif->remote);
ipmr.c:1643:  	*start=buffer+(offset-begin);
ipmr.c:1644:  	len-=(offset-begin);
ipmr.c:1668:		for(mfc=mfc_cache_array[ct]; mfc; mfc=mfc->next)
ipmr.c:1675:			size = sprintf(buffer+len, "%08lX %08lX %-3d %8ld %8ld %8ld",
ipmr.c:1676:				(unsigned long)mfc->mfc_mcastgrp,
ipmr.c:1677:				(unsigned long)mfc->mfc_origin,
ipmr.c:1678:				mfc->mfc_parent,
ipmr.c:1679:				mfc->mfc_un.res.pkt,
ipmr.c:1680:				mfc->mfc_un.res.bytes,
ipmr.c:1681:				mfc->mfc_un.res.wrong_if);
ipmr.c:1682:			for(n=mfc->mfc_un.res.minvif;n<mfc->mfc_un.res.maxvif;n++)
ipmr.c:1684:				if(VIF_EXISTS(n) && mfc->mfc_un.res.ttls[n] < 255)
ipmr.c:1685:					size += sprintf(buffer+len+size, " %2d:%-3d", n, mfc->mfc_un.res.ttls[n]);
ipmr.c:1701:	for(mfc=mfc_unres_queue; mfc; mfc=mfc->next) {
ipmr.c:1702:		size = sprintf(buffer+len, "%08lX %08lX %-3d %8ld %8ld %8ld\n",
ipmr.c:1703:			       (unsigned long)mfc->mfc_mcastgrp,
ipmr.c:1704:			       (unsigned long)mfc->mfc_origin,
ipmr.c:1705:			       -1,
ipmr.c:1706:				(long)mfc->mfc_un.unres.unresolved.qlen,
ipmr.c:1722:  	*start=buffer+(offset-begin);
ipmr.c:1723:  	len-=(offset-begin);
ipmr.c:1754:	printk(KERN_INFO "Linux IP multicast router 0.06 plus PIM-SM\n");
ip_nat_dumb.c:49:	struct rtable *rt = (struct rtable*)skb->dst;
ip_nat_dumb.c:50:	struct iphdr *iph = skb->nh.iph;
ip_nat_dumb.c:51:	u32 odaddr = iph->daddr;
ip_nat_dumb.c:52:	u32 osaddr = iph->saddr;
ip_nat_dumb.c:55:	IPCB(skb)->flags |= IPSKB_TRANSLATED;
ip_nat_dumb.c:58:	iph->daddr = rt->rt_dst_map;
ip_nat_dumb.c:59:	iph->saddr = rt->rt_src_map;
ip_nat_dumb.c:60:	iph->check = 0;
ip_nat_dumb.c:61:	iph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);
ip_nat_dumb.c:65:	if (!(iph->frag_off & htons(IP_OFFSET))) {
ip_nat_dumb.c:68:		switch(iph->protocol) {
ip_nat_dumb.c:70:			cksum  = (u16*)&((struct tcphdr*)(((char*)iph) + (iph->ihl<<2)))->check;
ip_nat_dumb.c:71:			if ((u8*)(cksum+1) > skb->tail)
ip_nat_dumb.c:74:			if (skb->ip_summed != CHECKSUM_HW)
ip_nat_dumb.c:76:			check = csum_tcpudp_magic(iph->saddr, iph->daddr, 0, 0, check);
ip_nat_dumb.c:78:			if (skb->ip_summed == CHECKSUM_HW)
ip_nat_dumb.c:83:			cksum  = (u16*)&((struct udphdr*)(((char*)iph) + (iph->ihl<<2)))->check;
ip_nat_dumb.c:84:			if ((u8*)(cksum+1) > skb->tail)
ip_nat_dumb.c:87:				check = csum_tcpudp_magic(iph->saddr, iph->daddr, 0, 0, ~check);
ip_nat_dumb.c:94:			struct icmphdr *icmph = (struct icmphdr*)((char*)iph + (iph->ihl<<2));
ip_nat_dumb.c:99:			if ((icmph->type != ICMP_DEST_UNREACH) &&
ip_nat_dumb.c:100:			    (icmph->type != ICMP_TIME_EXCEEDED) &&
ip_nat_dumb.c:101:			    (icmph->type != ICMP_PARAMETERPROB))
ip_nat_dumb.c:106:			if ((u8*)(ciph+1) > skb->tail)
ip_nat_dumb.c:109:			isaddr = ciph->saddr;
ip_nat_dumb.c:110:			idaddr = ciph->daddr;
ip_nat_dumb.c:113:			if (rt->rt_flags&RTCF_DNAT && ciph->saddr == odaddr) {
ip_nat_dumb.c:114:				ciph->saddr = iph->daddr;
ip_nat_dumb.c:117:			if (rt->rt_flags&RTCF_SNAT) {
ip_nat_dumb.c:118:				if (ciph->daddr != osaddr) {
ip_nat_dumb.c:123:					key.src = ciph->daddr;
ip_nat_dumb.c:124:					key.dst = ciph->saddr;
ip_nat_dumb.c:125:					key.iif = skb->dev->ifindex;
ip_nat_dumb.c:128:					key.tos = RT_TOS(ciph->tos);
ip_nat_dumb.c:134:					 * hash table of NATed hosts -- Rani
ip_nat_dumb.c:138:							ciph->daddr = fib_rules_policy(ciph->daddr, &res, &flags);
ip_nat_dumb.c:139:							if (ciph->daddr != idaddr)
ip_nat_dumb.c:145:					ciph->daddr = iph->saddr;
ip_nat_dumb.c:150:				cksum  = &icmph->checksum;
ip_nat_dumb.c:152:				check  = csum_tcpudp_magic(ciph->saddr, ciph->daddr, 0, 0, ~(*cksum));
ip_nat_dumb.c:165:	return -EINVAL;
ip_options.c:39:	unsigned char * iph = skb->nh.raw;
ip_options.c:41:	memcpy(&(IPCB(skb)->opt), opt, sizeof(struct ip_options));
ip_options.c:42:	memcpy(iph+sizeof(struct iphdr), opt->__data, opt->optlen);
ip_options.c:43:	opt = &(IPCB(skb)->opt);
ip_options.c:44:	opt->is_data = 0;
ip_options.c:46:	if (opt->srr)
ip_options.c:47:		memcpy(iph+opt->srr+iph[opt->srr+1]-4, &daddr, 4);
ip_options.c:50:		if (opt->rr_needaddr)
ip_options.c:51:			ip_rt_get_source(iph+opt->rr+iph[opt->rr+2]-5, rt);
ip_options.c:52:		if (opt->ts_needaddr)
ip_options.c:53:			ip_rt_get_source(iph+opt->ts+iph[opt->ts+2]-9, rt);
ip_options.c:54:		if (opt->ts_needtime) {
ip_options.c:59:			memcpy(iph+opt->ts+iph[opt->ts+2]-5, &midtime, 4);
ip_options.c:63:	if (opt->rr) {
ip_options.c:64:		memset(iph+opt->rr, IPOPT_NOP, iph[opt->rr+1]);
ip_options.c:65:		opt->rr = 0;
ip_options.c:66:		opt->rr_needaddr = 0;
ip_options.c:68:	if (opt->ts) {
ip_options.c:69:		memset(iph+opt->ts, IPOPT_NOP, iph[opt->ts+1]);
ip_options.c:70:		opt->ts = 0;
ip_options.c:71:		opt->ts_needaddr = opt->ts_needtime = 0;
ip_options.c:94:	dopt->is_data = 1;
ip_options.c:96:	sopt = &(IPCB(skb)->opt);
ip_options.c:98:	if (sopt->optlen == 0) {
ip_options.c:99:		dopt->optlen = 0;
ip_options.c:103:	sptr = skb->nh.raw;
ip_options.c:104:	dptr = dopt->__data;
ip_options.c:106:	if (skb->dst)
ip_options.c:107:		daddr = ((struct rtable*)skb->dst)->rt_spec_dst;
ip_options.c:109:		daddr = skb->nh.iph->daddr;
ip_options.c:111:	if (sopt->rr) {
ip_options.c:112:		optlen  = sptr[sopt->rr+1];
ip_options.c:113:		soffset = sptr[sopt->rr+2];
ip_options.c:114:		dopt->rr = dopt->optlen + sizeof(struct iphdr);
ip_options.c:115:		memcpy(dptr, sptr+sopt->rr, optlen);
ip_options.c:116:		if (sopt->rr_needaddr && soffset <= optlen) {
ip_options.c:118:				return -EINVAL;
ip_options.c:120:			dopt->rr_needaddr = 1;
ip_options.c:123:		dopt->optlen += optlen;
ip_options.c:125:	if (sopt->ts) {
ip_options.c:126:		optlen = sptr[sopt->ts+1];
ip_options.c:127:		soffset = sptr[sopt->ts+2];
ip_options.c:128:		dopt->ts = dopt->optlen + sizeof(struct iphdr);
ip_options.c:129:		memcpy(dptr, sptr+sopt->ts, optlen);
ip_options.c:131:			if (sopt->ts_needaddr) {
ip_options.c:133:					return -EINVAL;
ip_options.c:134:				dopt->ts_needaddr = 1;
ip_options.c:137:			if (sopt->ts_needtime) {
ip_options.c:139:					return -EINVAL;
ip_options.c:141:					dopt->ts_needtime = 1;
ip_options.c:144:					dopt->ts_needtime = 0;
ip_options.c:149:						memcpy(&addr, sptr+soffset-1, 4);
ip_options.c:151:							dopt->ts_needtime = 1;
ip_options.c:160:		dopt->optlen += optlen;
ip_options.c:162:	if (sopt->srr) {
ip_options.c:163:		unsigned char * start = sptr+sopt->srr;
ip_options.c:171:		soffset -= 4;
ip_options.c:173:			memcpy(&faddr, &start[soffset-1], 4);
ip_options.c:174:			for (soffset-=4, doffset=4; soffset > 3; soffset-=4, doffset+=4)
ip_options.c:175:				memcpy(&dptr[doffset-1], &start[soffset-1], 4);
ip_options.c:179:			if (memcmp(&skb->nh.iph->saddr, &start[soffset+3], 4) == 0)
ip_options.c:180:				doffset -= 4;
ip_options.c:183:			memcpy(&start[doffset-1], &daddr, 4);
ip_options.c:184:			dopt->faddr = faddr;
ip_options.c:189:			dopt->srr = dopt->optlen + sizeof(struct iphdr);
ip_options.c:190:			dopt->optlen += doffset+3;
ip_options.c:191:			dopt->is_strictroute = sopt->is_strictroute;
ip_options.c:194:	while (dopt->optlen & 3) {
ip_options.c:196:		dopt->optlen++;
ip_options.c:209:	unsigned char * optptr = skb->nh.raw;
ip_options.c:210:	struct ip_options * opt = &(IPCB(skb)->opt);
ip_options.c:211:	int  l = opt->optlen;
ip_options.c:219:			l--;
ip_options.c:228:		l -= optlen;
ip_options.c:231:	opt->ts = 0;
ip_options.c:232:	opt->rr = 0;
ip_options.c:233:	opt->rr_needaddr = 0;
ip_options.c:234:	opt->ts_needaddr = 0;
ip_options.c:235:	opt->ts_needtime = 0;
ip_options.c:241: * Caller should clear *opt, and set opt->data.
ip_options.c:242: * If opt == NULL, then skb->data should point to IP header.
ip_options.c:252:	struct rtable *rt = skb ? (struct rtable*)skb->dst : NULL;
ip_options.c:255:		opt = &(IPCB(skb)->opt);
ip_options.c:257:		iph = skb->nh.raw;
ip_options.c:258:		opt->optlen = ((struct iphdr *)iph)->ihl*4 - sizeof(struct iphdr);
ip_options.c:260:		opt->is_data = 0;
ip_options.c:262:		optptr = opt->is_data ? opt->__data : (unsigned char*)&(skb->nh.iph[1]);
ip_options.c:263:		iph = optptr - sizeof(struct iphdr);
ip_options.c:266:	for (l = opt->optlen; l > 0; ) {
ip_options.c:269:			for (optptr++, l--; l>0; optptr++, l--) {
ip_options.c:272:					opt->is_changed = 1;
ip_options.c:277:			l--;
ip_options.c:297:			/* NB: cf RFC-1812 5.2.4.1 */
ip_options.c:298:			if (opt->srr) {
ip_options.c:303:				if (optptr[2] != 4 || optlen < 7 || ((optlen-3) & 3)) {
ip_options.c:307:				memcpy(&opt->faddr, &optptr[3], 4);
ip_options.c:309:					memmove(&optptr[3], &optptr[7], optlen-7);
ip_options.c:311:			opt->is_strictroute = (optptr[0] == IPOPT_SSRR);
ip_options.c:312:			opt->srr = optptr - iph;
ip_options.c:315:			if (opt->rr) {
ip_options.c:333:					memcpy(&optptr[optptr[2]-1], &rt->rt_spec_dst, 4);
ip_options.c:334:					opt->is_changed = 1;
ip_options.c:337:				opt->rr_needaddr = 1;
ip_options.c:339:			opt->rr = optptr - iph;
ip_options.c:342:			if (opt->ts) {
ip_options.c:362:					opt->ts = optptr - iph;
ip_options.c:364:						timeptr = (__u32*)&optptr[optptr[2]-1];
ip_options.c:365:					opt->ts_needtime = 1;
ip_options.c:373:					opt->ts = optptr - iph;
ip_options.c:375:						memcpy(&optptr[optptr[2]-1], &rt->rt_spec_dst, 4);
ip_options.c:378:					opt->ts_needaddr = 1;
ip_options.c:379:					opt->ts_needtime = 1;
ip_options.c:387:					opt->ts = optptr - iph;
ip_options.c:390:						memcpy(&addr, &optptr[optptr[2]-1], 4);
ip_options.c:396:					opt->ts_needtime = 1;
ip_options.c:412:					opt->is_changed = 1;
ip_options.c:420:				opt->ts = optptr - iph;
ip_options.c:423:					opt->is_changed = 1;
ip_options.c:433:				opt->router_alert = optptr - iph;
ip_options.c:444:		l -= optlen;
ip_options.c:454:		icmp_send(skb, ICMP_PARAMETERPROB, 0, htonl((pp_ptr-iph)<<24));
ip_options.c:456:	return -EINVAL;
ip_options.c:466:	if (opt->srr) {
ip_options.c:467:		unsigned  char * optptr = opt->__data+opt->srr-sizeof(struct  iphdr);
ip_options.c:468:		memmove(optptr+7, optptr+3, optptr[1]-7);
ip_options.c:469:		memcpy(optptr+3, &opt->faddr, 4);
ip_options.c:471:	if (opt->rr_needaddr) {
ip_options.c:472:		unsigned  char * optptr = opt->__data+opt->rr-sizeof(struct  iphdr);
ip_options.c:473:		optptr[2] -= 4;
ip_options.c:474:		memset(&optptr[optptr[2]-1], 0, 4);
ip_options.c:476:	if (opt->ts) {
ip_options.c:477:		unsigned  char * optptr = opt->__data+opt->ts-sizeof(struct  iphdr);
ip_options.c:478:		if (opt->ts_needtime) {
ip_options.c:479:			optptr[2] -= 4;
ip_options.c:480:			memset(&optptr[optptr[2]-1], 0, 4);
ip_options.c:482:				optptr[2] -= 4;
ip_options.c:484:		if (opt->ts_needaddr) {
ip_options.c:485:			optptr[2] -= 4;
ip_options.c:486:			memset(&optptr[optptr[2]-1], 0, 4);
ip_options.c:497:		return -ENOMEM;
ip_options.c:501:			if (copy_from_user(opt->__data, data, optlen)) {
ip_options.c:503:				return -EFAULT;
ip_options.c:506:			memcpy(opt->__data, data, optlen);
ip_options.c:509:		opt->__data[optlen++] = IPOPT_END;
ip_options.c:510:	opt->optlen = optlen;
ip_options.c:511:	opt->is_data = 1;
ip_options.c:512:	opt->is_setbyuser = 1;
ip_options.c:515:		return -EINVAL;
ip_options.c:523:	struct   ip_options * opt	= &(IPCB(skb)->opt);
ip_options.c:525:	struct rtable *rt = (struct rtable*)skb->dst;
ip_options.c:526:	unsigned char *raw = skb->nh.raw;
ip_options.c:528:	if (opt->rr_needaddr) {
ip_options.c:529:		optptr = (unsigned char *)raw + opt->rr;
ip_options.c:530:		ip_rt_get_source(&optptr[optptr[2]-5], rt);
ip_options.c:531:		opt->is_changed = 1;
ip_options.c:533:	if (opt->srr_is_hit) {
ip_options.c:536:		optptr = raw + opt->srr;
ip_options.c:544:			if (memcmp(&rt->rt_dst, &optptr[srrptr-1], 4) == 0)
ip_options.c:548:			opt->is_changed = 1;
ip_options.c:549:			ip_rt_get_source(&optptr[srrptr-1], rt);
ip_options.c:550:			skb->nh.iph->daddr = rt->rt_dst;
ip_options.c:554:		if (opt->ts_needaddr) {
ip_options.c:555:			optptr = raw + opt->ts;
ip_options.c:556:			ip_rt_get_source(&optptr[optptr[2]-9], rt);
ip_options.c:557:			opt->is_changed = 1;
ip_options.c:560:	if (opt->is_changed) {
ip_options.c:561:		opt->is_changed = 0;
ip_options.c:562:		ip_send_check(skb->nh.iph);
ip_options.c:568:	struct ip_options *opt = &(IPCB(skb)->opt);
ip_options.c:571:	struct iphdr *iph = skb->nh.iph;
ip_options.c:572:	unsigned char * optptr = skb->nh.raw + opt->srr;
ip_options.c:573:	struct rtable *rt = (struct rtable*)skb->dst;
ip_options.c:577:	if (!opt->srr)
ip_options.c:580:	if (skb->pkt_type != PACKET_HOST)
ip_options.c:581:		return -EINVAL;
ip_options.c:582:	if (rt->rt_type == RTN_UNICAST) {
ip_options.c:583:		if (!opt->is_strictroute)
ip_options.c:586:		return -EINVAL;
ip_options.c:588:	if (rt->rt_type != RTN_LOCAL)
ip_options.c:589:		return -EINVAL;
ip_options.c:593:			icmp_send(skb, ICMP_PARAMETERPROB, 0, htonl((opt->srr+2)<<24));
ip_options.c:594:			return -EINVAL;
ip_options.c:596:		memcpy(&nexthop, &optptr[srrptr-1], 4);
ip_options.c:598:		rt = (struct rtable*)skb->dst;
ip_options.c:599:		skb->dst = NULL;
ip_options.c:600:		err = ip_route_input(skb, nexthop, iph->saddr, iph->tos, skb->dev);
ip_options.c:601:		rt2 = (struct rtable*)skb->dst;
ip_options.c:602:		if (err || (rt2->rt_type != RTN_UNICAST && rt2->rt_type != RTN_LOCAL)) {
ip_options.c:604:			skb->dst = &rt->u.dst;
ip_options.c:605:			return -EINVAL;
ip_options.c:608:		if (rt2->rt_type != RTN_LOCAL)
ip_options.c:611:		memcpy(&iph->daddr, &optptr[srrptr-1], 4);
ip_options.c:612:		opt->is_changed = 1;
ip_options.c:615:		opt->srr_is_hit = 1;
ip_options.c:616:		opt->is_changed = 1;
ip_output.c:39: *					silently drop skb instead of failing with -EPERM.
ip_output.c:91:	iph->check = 0;
ip_output.c:92:	iph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);
ip_output.c:98:	newskb->mac.raw = newskb->data;
ip_output.c:99:	__skb_pull(newskb, newskb->nh.raw - newskb->data);
ip_output.c:100:	newskb->pkt_type = PACKET_LOOPBACK;
ip_output.c:101:	newskb->ip_summed = CHECKSUM_UNNECESSARY;
ip_output.c:102:	BUG_TRAP(newskb->dst);
ip_output.c:111:/* Don't just hand NF_HOOK skb->dst->output, in case netfilter hook
ip_output.c:116:	return skb->dst->output(skb);
ip_output.c:125:	struct rtable *rt = (struct rtable *)skb->dst;
ip_output.c:130:		iph=(struct iphdr *)skb_push(skb,sizeof(struct iphdr) + opt->optlen);
ip_output.c:134:	iph->version  = 4;
ip_output.c:135:	iph->ihl      = 5;
ip_output.c:136:	iph->tos      = sk->protinfo.af_inet.tos;
ip_output.c:137:	if (ip_dont_fragment(sk, &rt->u.dst))
ip_output.c:138:		iph->frag_off = htons(IP_DF);
ip_output.c:140:		iph->frag_off = 0;
ip_output.c:141:	iph->ttl      = sk->protinfo.af_inet.ttl;
ip_output.c:142:	iph->daddr    = rt->rt_dst;
ip_output.c:143:	iph->saddr    = rt->rt_src;
ip_output.c:144:	iph->protocol = sk->protocol;
ip_output.c:145:	iph->tot_len  = htons(skb->len);
ip_output.c:146:	ip_select_ident(iph, &rt->u.dst, sk);
ip_output.c:147:	skb->nh.iph   = iph;
ip_output.c:149:	if (opt && opt->optlen) {
ip_output.c:150:		iph->ihl += opt->optlen>>2;
ip_output.c:156:	return NF_HOOK(PF_INET, NF_IP_LOCAL_OUT, skb, NULL, rt->u.dst.dev,
ip_output.c:162:	struct dst_entry *dst = skb->dst;
ip_output.c:163:	struct hh_cache *hh = dst->hh;
ip_output.c:172:		read_lock_bh(&hh->hh_lock);
ip_output.c:173:		hh_alen = HH_DATA_ALIGN(hh->hh_len);
ip_output.c:174:  		memcpy(skb->data - hh_alen, hh->hh_data, hh_alen);
ip_output.c:175:		read_unlock_bh(&hh->hh_lock);
ip_output.c:176:	        skb_push(skb, hh->hh_len);
ip_output.c:177:		return hh->hh_output(skb);
ip_output.c:178:	} else if (dst->neighbour)
ip_output.c:179:		return dst->neighbour->output(skb);
ip_output.c:184:	return -EINVAL;
ip_output.c:189:	struct net_device *dev = skb->dst->dev;
ip_output.c:191:	skb->dev = dev;
ip_output.c:192:	skb->protocol = htons(ETH_P_IP);
ip_output.c:200:	struct sock *sk = skb->sk;
ip_output.c:201:	struct rtable *rt = (struct rtable*)skb->dst;
ip_output.c:202:	struct net_device *dev = rt->u.dst.dev;
ip_output.c:209:	if (rt->rt_flags & RTCF_NAT)
ip_output.c:213:	skb->dev = dev;
ip_output.c:214:	skb->protocol = htons(ETH_P_IP);
ip_output.c:220:	if (rt->rt_flags&RTCF_MULTICAST) {
ip_output.c:221:		if ((!sk || sk->protinfo.af_inet.mc_loop)
ip_output.c:231:		    && ((rt->rt_flags&RTCF_LOCAL) || !(IPCB(skb)->flags&IPSKB_FORWARDED))
ip_output.c:237:					newskb->dev, 
ip_output.c:243:		if (skb->nh.iph->ttl == 0) {
ip_output.c:249:	if (rt->rt_flags&RTCF_BROADCAST) {
ip_output.c:253:				newskb->dev, ip_dev_loopback_xmit);
ip_output.c:262:	struct rtable *rt = (struct rtable*)skb->dst;
ip_output.c:268:	if (rt->rt_flags&RTCF_NAT)
ip_output.c:286:	struct sock *sk = skb->sk;
ip_output.c:287:	struct rtable *rt = (struct rtable *)skb->dst;
ip_output.c:289:	struct iphdr *iph = skb->nh.iph;
ip_output.c:291:	dev = rt->u.dst.dev;
ip_output.c:295:	 * re-routed to a device with a different MTU than the original
ip_output.c:298:	if (skb_headroom(skb) < dev->hard_header_len && dev->hard_header) {
ip_output.c:301:		skb2 = skb_realloc_headroom(skb, (dev->hard_header_len + 15) & ~15);
ip_output.c:304:			return -ENOMEM;
ip_output.c:308:		iph = skb->nh.iph;
ip_output.c:311:	if (skb->len > rt->u.dst.pmtu)
ip_output.c:314:	ip_select_ident(iph, &rt->u.dst, sk);
ip_output.c:319:	skb->priority = sk->priority;
ip_output.c:320:	return skb->dst->output(skb);
ip_output.c:323:	if (ip_dont_fragment(sk, &rt->u.dst)) {
ip_output.c:328:				skb->len, rt->u.dst.pmtu));
ip_output.c:331:			  htonl(rt->u.dst.pmtu));
ip_output.c:333:		return -EMSGSIZE;
ip_output.c:335:	ip_select_ident(iph, &rt->u.dst, sk);
ip_output.c:336:	if (skb->ip_summed == CHECKSUM_HW &&
ip_output.c:338:		return -ENOMEM;
ip_output.c:339:	return ip_fragment(skb, skb->dst->output);
ip_output.c:344:	struct sock *sk = skb->sk;
ip_output.c:345:	struct ip_options *opt = sk->protinfo.af_inet.opt;
ip_output.c:352:	rt = (struct rtable *) skb->dst;
ip_output.c:362:		daddr = sk->daddr;
ip_output.c:363:		if(opt && opt->srr)
ip_output.c:364:			daddr = opt->faddr;
ip_output.c:370:		if (ip_route_output(&rt, daddr, sk->saddr,
ip_output.c:372:				    sk->bound_dev_if))
ip_output.c:374:		__sk_dst_set(sk, &rt->u.dst);
ip_output.c:375:		sk->route_caps = rt->u.dst.dev->features;
ip_output.c:377:	skb->dst = dst_clone(&rt->u.dst);
ip_output.c:380:	if (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)
ip_output.c:384:	iph = (struct iphdr *) skb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));
ip_output.c:385:	*((__u16 *)iph)	= htons((4 << 12) | (5 << 8) | (sk->protinfo.af_inet.tos & 0xff));
ip_output.c:386:	iph->tot_len = htons(skb->len);
ip_output.c:387:	if (ip_dont_fragment(sk, &rt->u.dst) && !ipfragok)
ip_output.c:388:		iph->frag_off = htons(IP_DF);
ip_output.c:390:		iph->frag_off = 0;
ip_output.c:391:	iph->ttl      = sk->protinfo.af_inet.ttl;
ip_output.c:392:	iph->protocol = sk->protocol;
ip_output.c:393:	iph->saddr    = rt->rt_src;
ip_output.c:394:	iph->daddr    = rt->rt_dst;
ip_output.c:395:	skb->nh.iph   = iph;
ip_output.c:396:	/* Transport layer set skb->h.foo itself. */
ip_output.c:398:	if(opt && opt->optlen) {
ip_output.c:399:		iph->ihl += opt->optlen >> 2;
ip_output.c:400:		ip_options_build(skb, opt, sk->daddr, rt, 0);
ip_output.c:403:	return NF_HOOK(PF_INET, NF_IP_LOCAL_OUT, skb, NULL, rt->u.dst.dev,
ip_output.c:409:	return -EHOSTUNREACH;
ip_output.c:449:	int hh_len = (rt->u.dst.dev->hard_header_len + 15)&~15;
ip_output.c:451:	struct ip_options *opt = ipc->opt;
ip_output.c:454:	mtu = rt->u.dst.pmtu;
ip_output.c:455:	if (ip_dont_fragment(sk, &rt->u.dst))
ip_output.c:458:	length -= sizeof(struct iphdr);
ip_output.c:461:		fragheaderlen = sizeof(struct iphdr) + opt->optlen;
ip_output.c:462:		maxfraglen = ((mtu-sizeof(struct iphdr)-opt->optlen) & ~7) + fragheaderlen;
ip_output.c:471:		maxfraglen = ((mtu-sizeof(struct iphdr)) & ~7) + fragheaderlen;
ip_output.c:475:		ip_local_error(sk, EMSGSIZE, rt->rt_dst, sk->dport, mtu);
ip_output.c:476:		return -EMSGSIZE;
ip_output.c:483:	offset = length - (length % (maxfraglen - fragheaderlen));
ip_output.c:489:	fraglen = length - offset + fragheaderlen;
ip_output.c:491:	if (length-offset==0) {
ip_output.c:493:		offset -= maxfraglen-fragheaderlen;
ip_output.c:506:	if (offset > 0 && sk->protinfo.af_inet.pmtudisc==IP_PMTUDISC_DO) { 
ip_output.c:507:		ip_local_error(sk, EMSGSIZE, rt->rt_dst, sk->dport, mtu);
ip_output.c:508: 		return -EMSGSIZE;
ip_output.c:517:	id = sk->protinfo.af_inet.id++;
ip_output.c:530:			/* On a non-blocking write, we check for send buffer
ip_output.c:534:					   sk->allocation);
ip_output.c:536:				err = -ENOBUFS;
ip_output.c:545:		skb->priority = sk->priority;
ip_output.c:546:		skb->dst = dst_clone(&rt->u.dst);
ip_output.c:554:		skb->nh.iph = (struct iphdr *)data;
ip_output.c:557:		 *	Only write IP header onto non-raw packets 
ip_output.c:563:			iph->version = 4;
ip_output.c:564:			iph->ihl = 5;
ip_output.c:566:				iph->ihl += opt->optlen>>2;
ip_output.c:568:						 ipc->addr, rt, offset);
ip_output.c:570:			iph->tos = sk->protinfo.af_inet.tos;
ip_output.c:571:			iph->tot_len = htons(fraglen - fragheaderlen + iph->ihl*4);
ip_output.c:572:			iph->frag_off = htons(offset>>3)|mf|df;
ip_output.c:573:			iph->id = id;
ip_output.c:580:					__ip_select_ident(iph, &rt->u.dst);
ip_output.c:581:					id = iph->id;
ip_output.c:589:			if (rt->rt_type == RTN_MULTICAST)
ip_output.c:590:				iph->ttl = sk->protinfo.af_inet.mc_ttl;
ip_output.c:592:				iph->ttl = sk->protinfo.af_inet.ttl;
ip_output.c:593:			iph->protocol = sk->protocol;
ip_output.c:594:			iph->check = 0;
ip_output.c:595:			iph->saddr = rt->rt_src;
ip_output.c:596:			iph->daddr = rt->rt_dst;
ip_output.c:597:			iph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);
ip_output.c:598:			data += iph->ihl*4;
ip_output.c:605:		if (getfrag(frag, data, offset, fraglen-fragheaderlen)) {
ip_output.c:606:			err = -EFAULT;
ip_output.c:611:		offset -= (maxfraglen-fragheaderlen);
ip_output.c:617:			      skb->dst->dev, output_maybe_reroute);
ip_output.c:620:				err = sk->protinfo.af_inet.recverr ? net_xmit_errno(err) : 0;
ip_output.c:662:	if (!sk->protinfo.af_inet.hdrincl) {
ip_output.c:668:		if (length > rt->u.dst.pmtu || ipc->opt != NULL)  
ip_output.c:671:		if (length > rt->u.dst.dev->mtu) {
ip_output.c:672:			ip_local_error(sk, EMSGSIZE, rt->rt_dst, sk->dport, rt->u.dst.dev->mtu);
ip_output.c:673:			return -EMSGSIZE;
ip_output.c:683:	if (ip_dont_fragment(sk, &rt->u.dst))
ip_output.c:690:	int hh_len = (rt->u.dst.dev->hard_header_len + 15)&~15;
ip_output.c:699:	skb->priority = sk->priority;
ip_output.c:700:	skb->dst = dst_clone(&rt->u.dst);
ip_output.c:702:	skb->nh.iph = iph = (struct iphdr *)skb_put(skb, length);
ip_output.c:704:	if(!sk->protinfo.af_inet.hdrincl) {
ip_output.c:705:		iph->version=4;
ip_output.c:706:		iph->ihl=5;
ip_output.c:707:		iph->tos=sk->protinfo.af_inet.tos;
ip_output.c:708:		iph->tot_len = htons(length);
ip_output.c:709:		iph->frag_off = df;
ip_output.c:710:		iph->ttl=sk->protinfo.af_inet.mc_ttl;
ip_output.c:711:		ip_select_ident(iph, &rt->u.dst, sk);
ip_output.c:712:		if (rt->rt_type != RTN_MULTICAST)
ip_output.c:713:			iph->ttl=sk->protinfo.af_inet.ttl;
ip_output.c:714:		iph->protocol=sk->protocol;
ip_output.c:715:		iph->saddr=rt->rt_src;
ip_output.c:716:		iph->daddr=rt->rt_dst;
ip_output.c:717:		iph->check=0;
ip_output.c:718:		iph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);
ip_output.c:719:		err = getfrag(frag, ((char *)iph)+iph->ihl*4,0, length-iph->ihl*4);
ip_output.c:727:	err = NF_HOOK(PF_INET, NF_IP_LOCAL_OUT, skb, NULL, rt->u.dst.dev,
ip_output.c:730:		err = sk->protinfo.af_inet.recverr ? net_xmit_errno(err) : 0;
ip_output.c:737:	err = -EFAULT;
ip_output.c:763:	struct rtable *rt = (struct rtable*)skb->dst;
ip_output.c:766:	dev = rt->u.dst.dev;
ip_output.c:772:	iph = skb->nh.iph;
ip_output.c:778:	hlen = iph->ihl * 4;
ip_output.c:779:	left = skb->len - hlen;		/* Space per frame */
ip_output.c:780:	mtu = rt->u.dst.pmtu - hlen;	/* Size of data space */
ip_output.c:787:	offset = (ntohs(iph->frag_off) & IP_OFFSET) << 3;
ip_output.c:788:	not_last_frag = iph->frag_off & htons(IP_MF);
ip_output.c:796:		/* IF: it doesn't fit, use 'mtu' - the data space left */
ip_output.c:808:		if ((skb2 = alloc_skb(len+hlen+dev->hard_header_len+15,GFP_ATOMIC)) == NULL) {
ip_output.c:810:			err = -ENOMEM;
ip_output.c:818:		skb2->pkt_type = skb->pkt_type;
ip_output.c:819:		skb2->priority = skb->priority;
ip_output.c:820:		skb_reserve(skb2, (dev->hard_header_len+15)&~15);
ip_output.c:822:		skb2->nh.raw = skb2->data;
ip_output.c:823:		skb2->h.raw = skb2->data + hlen;
ip_output.c:824:		skb2->protocol = skb->protocol;
ip_output.c:825:		skb2->security = skb->security;
ip_output.c:832:		if (skb->sk)
ip_output.c:833:			skb_set_owner_w(skb2, skb->sk);
ip_output.c:834:		skb2->dst = dst_clone(skb->dst);
ip_output.c:835:		skb2->dev = skb->dev;
ip_output.c:841:		memcpy(skb2->nh.raw, skb->data, hlen);
ip_output.c:846:		if (skb_copy_bits(skb, ptr, skb2->h.raw, len))
ip_output.c:848:		left -= len;
ip_output.c:853:		iph = skb2->nh.iph;
ip_output.c:854:		iph->frag_off = htons((offset >> 3));
ip_output.c:866:		IPCB(skb2)->flags = IPCB(skb)->flags;
ip_output.c:873:			iph->frag_off |= htons(IP_MF);
ip_output.c:878:		skb2->tc_index = skb->tc_index;
ip_output.c:881:		skb2->nfmark = skb->nfmark;
ip_output.c:882:		skb2->nfcache = skb->nfcache;
ip_output.c:883:		/* Connection association is same as pre-frag packet */
ip_output.c:884:		skb2->nfct = skb->nfct;
ip_output.c:885:		nf_conntrack_get(skb2->nfct);
ip_output.c:887:		skb2->nf_debug = skb->nf_debug;
ip_output.c:897:		iph->tot_len = htons(len + hlen);
ip_output.c:927:	iov = &dp->iov[0]; 
ip_output.c:928:	if (offset >= iov->iov_len) { 
ip_output.c:929:		offset -= iov->iov_len;
ip_output.c:933:	len = iov->iov_len - offset;
ip_output.c:935:		dp->csum = csum_partial_copy_nocheck(iov->iov_base+offset, to, len,
ip_output.c:936:					     dp->csum);
ip_output.c:938:		fraglen -= len; 
ip_output.c:943:	dp->csum = csum_partial_copy_nocheck(iov->iov_base+offset, to, fraglen, 
ip_output.c:944:					     dp->csum); 
ip_output.c:946:	if (hdrflag && dp->csumoffset)
ip_output.c:947:		*(pktp + dp->csumoffset) = csum_fold(dp->csum); /* fill in checksum */
ip_output.c:967:	struct rtable *rt = (struct rtable*)skb->dst;
ip_output.c:972:	daddr = ipc.addr = rt->rt_src;
ip_output.c:978:		if (ipc.opt->srr)
ip_output.c:982:	if (ip_route_output(&rt, daddr, rt->rt_spec_dst, RT_TOS(skb->nh.iph->tos), 0))
ip_output.c:992:	sk->protinfo.af_inet.tos = skb->nh.iph->tos;
ip_output.c:993:	sk->priority = skb->priority;
ip_output.c:994:	sk->protocol = skb->nh.iph->protocol;
ip_sockglue.c:59:	struct rtable *rt = (struct rtable *)skb->dst;
ip_sockglue.c:61:	info.ipi_addr.s_addr = skb->nh.iph->daddr;
ip_sockglue.c:63:		info.ipi_ifindex = rt->rt_iif;
ip_sockglue.c:64:		info.ipi_spec_dst.s_addr = rt->rt_spec_dst;
ip_sockglue.c:75:	int ttl = skb->nh.iph->ttl;
ip_sockglue.c:81:	put_cmsg(msg, SOL_IP, IP_TOS, 1, &skb->nh.iph->tos);
ip_sockglue.c:86:	if (IPCB(skb)->opt.optlen == 0)
ip_sockglue.c:89:	put_cmsg(msg, SOL_IP, IP_RECVOPTS, IPCB(skb)->opt.optlen, skb->nh.iph+1);
ip_sockglue.c:98:	if (IPCB(skb)->opt.optlen == 0)
ip_sockglue.c:102:		msg->msg_flags |= MSG_CTRUNC;
ip_sockglue.c:107:	put_cmsg(msg, SOL_IP, IP_RETOPTS, opt->optlen, opt->__data);
ip_sockglue.c:113:	unsigned flags = skb->sk->protinfo.af_inet.cmsg_flags;
ip_sockglue.c:146:		if (cmsg->cmsg_len < sizeof(struct cmsghdr) ||
ip_sockglue.c:147:		    (unsigned long)(((char*)cmsg - (char*)msg->msg_control)
ip_sockglue.c:148:				    + cmsg->cmsg_len) > msg->msg_controllen) {
ip_sockglue.c:149:			return -EINVAL;
ip_sockglue.c:151:		if (cmsg->cmsg_level != SOL_IP)
ip_sockglue.c:153:		switch (cmsg->cmsg_type) {
ip_sockglue.c:155:			err = cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr));
ip_sockglue.c:156:			err = ip_options_get(&ipc->opt, CMSG_DATA(cmsg), err < 40 ? err : 40, 0);
ip_sockglue.c:163:			if (cmsg->cmsg_len != CMSG_LEN(sizeof(struct in_pktinfo)))
ip_sockglue.c:164:				return -EINVAL;
ip_sockglue.c:166:			ipc->oif = info->ipi_ifindex;
ip_sockglue.c:167:			ipc->addr = info->ipi_spec_dst.s_addr;
ip_sockglue.c:171:			return -EINVAL;
ip_sockglue.c:184:   I have no idea, how it will masquearde or NAT them (it is joke, joke :-)),
ip_sockglue.c:195:	if (sk->type != SOCK_RAW || sk->num == IPPROTO_RAW)
ip_sockglue.c:196:		return -EINVAL;
ip_sockglue.c:201:	for (rap = &ip_ra_chain; (ra=*rap) != NULL; rap = &ra->next) {
ip_sockglue.c:202:		if (ra->sk == sk) {
ip_sockglue.c:207:				return -EADDRINUSE;
ip_sockglue.c:209:			*rap = ra->next;
ip_sockglue.c:212:			if (ra->destructor)
ip_sockglue.c:213:				ra->destructor(sk);
ip_sockglue.c:221:		return -ENOBUFS;
ip_sockglue.c:223:	new_ra->sk = sk;
ip_sockglue.c:224:	new_ra->destructor = destructor;
ip_sockglue.c:226:	new_ra->next = ra;
ip_sockglue.c:239:	if (!sk->protinfo.af_inet.recverr)
ip_sockglue.c:247:	serr->ee.ee_errno = err;
ip_sockglue.c:248:	serr->ee.ee_origin = SO_EE_ORIGIN_ICMP;
ip_sockglue.c:249:	serr->ee.ee_type = skb->h.icmph->type; 
ip_sockglue.c:250:	serr->ee.ee_code = skb->h.icmph->code;
ip_sockglue.c:251:	serr->ee.ee_pad = 0;
ip_sockglue.c:252:	serr->ee.ee_info = info;
ip_sockglue.c:253:	serr->ee.ee_data = 0;
ip_sockglue.c:254:	serr->addr_offset = (u8*)&(((struct iphdr*)(skb->h.icmph+1))->daddr) - skb->nh.raw;
ip_sockglue.c:255:	serr->port = port;
ip_sockglue.c:257:	skb->h.raw = payload;
ip_sockglue.c:258:	if (!skb_pull(skb, payload - skb->data) ||
ip_sockglue.c:269:	if (!sk->protinfo.af_inet.recverr)
ip_sockglue.c:277:	skb->nh.iph = iph;
ip_sockglue.c:278:	iph->daddr = daddr;
ip_sockglue.c:281:	serr->ee.ee_errno = err;
ip_sockglue.c:282:	serr->ee.ee_origin = SO_EE_ORIGIN_LOCAL;
ip_sockglue.c:283:	serr->ee.ee_type = 0; 
ip_sockglue.c:284:	serr->ee.ee_code = 0;
ip_sockglue.c:285:	serr->ee.ee_pad = 0;
ip_sockglue.c:286:	serr->ee.ee_info = info;
ip_sockglue.c:287:	serr->ee.ee_data = 0;
ip_sockglue.c:288:	serr->addr_offset = (u8*)&iph->daddr - skb->nh.raw;
ip_sockglue.c:289:	serr->port = port;
ip_sockglue.c:291:	skb->h.raw = skb->tail;
ip_sockglue.c:292:	__skb_pull(skb, skb->tail - skb->data);
ip_sockglue.c:313:	err = -EAGAIN;
ip_sockglue.c:314:	skb = skb_dequeue(&sk->error_queue);
ip_sockglue.c:318:	copied = skb->len;
ip_sockglue.c:320:		msg->msg_flags |= MSG_TRUNC;
ip_sockglue.c:323:	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
ip_sockglue.c:331:	sin = (struct sockaddr_in *)msg->msg_name;
ip_sockglue.c:333:		sin->sin_family = AF_INET;
ip_sockglue.c:334:		sin->sin_addr.s_addr = *(u32*)(skb->nh.raw + serr->addr_offset);
ip_sockglue.c:335:		sin->sin_port = serr->port;
ip_sockglue.c:336:		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
ip_sockglue.c:339:	memcpy(&errhdr.ee, &serr->ee, sizeof(struct sock_extended_err));
ip_sockglue.c:341:	sin->sin_family = AF_UNSPEC;
ip_sockglue.c:342:	if (serr->ee.ee_origin == SO_EE_ORIGIN_ICMP) {
ip_sockglue.c:343:		sin->sin_family = AF_INET;
ip_sockglue.c:344:		sin->sin_addr.s_addr = skb->nh.iph->saddr;
ip_sockglue.c:345:		sin->sin_port = 0;
ip_sockglue.c:346:		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
ip_sockglue.c:347:		if (sk->protinfo.af_inet.cmsg_flags)
ip_sockglue.c:355:	msg->msg_flags |= MSG_ERRQUEUE;
ip_sockglue.c:359:	spin_lock_irq(&sk->error_queue.lock);
ip_sockglue.c:360:	sk->err = 0;
ip_sockglue.c:361:	if ((skb2 = skb_peek(&sk->error_queue)) != NULL) {
ip_sockglue.c:362:		sk->err = SKB_EXT_ERR(skb2)->ee.ee_errno;
ip_sockglue.c:363:		spin_unlock_irq(&sk->error_queue.lock);
ip_sockglue.c:364:		sk->error_report(sk);
ip_sockglue.c:366:		spin_unlock_irq(&sk->error_queue.lock);
ip_sockglue.c:386:		return -ENOPROTOOPT;
ip_sockglue.c:398:				return -EFAULT;
ip_sockglue.c:403:				return -EFAULT;
ip_sockglue.c:427:			if (sk->type == SOCK_STREAM) {
ip_sockglue.c:428:				struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
ip_sockglue.c:430:				if (sk->family == PF_INET ||
ip_sockglue.c:431:				    (!((1<<sk->state)&(TCPF_LISTEN|TCPF_CLOSE))
ip_sockglue.c:432:				     && sk->daddr != LOOPBACK4_IPV6)) {
ip_sockglue.c:435:						tp->ext_header_len = opt->optlen;
ip_sockglue.c:436:					tcp_sync_mss(sk, tp->pmtu_cookie);
ip_sockglue.c:441:			opt = xchg(&sk->protinfo.af_inet.opt, opt);
ip_sockglue.c:448:				sk->protinfo.af_inet.cmsg_flags |= IP_CMSG_PKTINFO;
ip_sockglue.c:450:				sk->protinfo.af_inet.cmsg_flags &= ~IP_CMSG_PKTINFO;
ip_sockglue.c:454:				sk->protinfo.af_inet.cmsg_flags |=  IP_CMSG_TTL;
ip_sockglue.c:456:				sk->protinfo.af_inet.cmsg_flags &= ~IP_CMSG_TTL;
ip_sockglue.c:460:				sk->protinfo.af_inet.cmsg_flags |=  IP_CMSG_TOS;
ip_sockglue.c:462:				sk->protinfo.af_inet.cmsg_flags &= ~IP_CMSG_TOS;
ip_sockglue.c:466:				sk->protinfo.af_inet.cmsg_flags |=  IP_CMSG_RECVOPTS;
ip_sockglue.c:468:				sk->protinfo.af_inet.cmsg_flags &= ~IP_CMSG_RECVOPTS;
ip_sockglue.c:472:				sk->protinfo.af_inet.cmsg_flags |= IP_CMSG_RETOPTS;
ip_sockglue.c:474:				sk->protinfo.af_inet.cmsg_flags &= ~IP_CMSG_RETOPTS;
ip_sockglue.c:477:			if (sk->type == SOCK_STREAM) {
ip_sockglue.c:479:				val |= sk->protinfo.af_inet.tos & 3;
ip_sockglue.c:483:				err = -EPERM;
ip_sockglue.c:486:			if (sk->protinfo.af_inet.tos != val) {
ip_sockglue.c:487:				sk->protinfo.af_inet.tos=val;
ip_sockglue.c:488:				sk->priority = rt_tos2priority(val);
ip_sockglue.c:495:			if(val==-1)
ip_sockglue.c:499:			sk->protinfo.af_inet.ttl=val;
ip_sockglue.c:502:			if(sk->type!=SOCK_RAW) {
ip_sockglue.c:503:				err = -ENOPROTOOPT;
ip_sockglue.c:506:			sk->protinfo.af_inet.hdrincl=val?1:0;
ip_sockglue.c:511:			sk->protinfo.af_inet.pmtudisc = val;
ip_sockglue.c:514:			sk->protinfo.af_inet.recverr = !!val;
ip_sockglue.c:516:				skb_queue_purge(&sk->error_queue);
ip_sockglue.c:519:			if (sk->type == SOCK_STREAM)
ip_sockglue.c:523:			if (val==-1)
ip_sockglue.c:527:			sk->protinfo.af_inet.mc_ttl=val;
ip_sockglue.c:532:			sk->protinfo.af_inet.mc_loop = val ? 1 : 0;
ip_sockglue.c:539:			if (sk->type == SOCK_STREAM)
ip_sockglue.c:545:			err = -EFAULT;
ip_sockglue.c:558:					sk->protinfo.af_inet.mc_index = 0;
ip_sockglue.c:559:					sk->protinfo.af_inet.mc_addr  = 0;
ip_sockglue.c:565:					mreq.imr_ifindex = dev->ifindex;
ip_sockglue.c:572:			err = -EADDRNOTAVAIL;
ip_sockglue.c:576:			err = -EINVAL;
ip_sockglue.c:577:			if (sk->bound_dev_if && mreq.imr_ifindex != sk->bound_dev_if)
ip_sockglue.c:580:			sk->protinfo.af_inet.mc_index = mreq.imr_ifindex;
ip_sockglue.c:581:			sk->protinfo.af_inet.mc_addr  = mreq.imr_address.s_addr;
ip_sockglue.c:593:			err = -EFAULT;
ip_sockglue.c:618:				err = -ENOBUFS;
ip_sockglue.c:623:				err = -ENOBUFS;
ip_sockglue.c:626:			err = -EFAULT;
ip_sockglue.c:631:			/* numsrc >= (1G-4) overflow in 32 bits */
ip_sockglue.c:632:			if (msf->imsf_numsrc >= 0x3ffffffcU ||
ip_sockglue.c:633:			    msf->imsf_numsrc > sysctl_igmp_max_msf) {
ip_sockglue.c:635:				err = -ENOBUFS;
ip_sockglue.c:638:			if (IP_MSFILTER_SIZE(msf->imsf_numsrc) > optlen) {
ip_sockglue.c:640:				err = -EINVAL;
ip_sockglue.c:658:				err = -EFAULT;
ip_sockglue.c:694:			err = -EFAULT;
ip_sockglue.c:698:			if (psin->sin_family != AF_INET)
ip_sockglue.c:701:			mreq.imr_multiaddr = psin->sin_addr;
ip_sockglue.c:723:				err = -EFAULT;
ip_sockglue.c:728:				err = -EADDRNOTAVAIL;
ip_sockglue.c:732:			mreqs.imr_multiaddr = psin->sin_addr.s_addr;
ip_sockglue.c:734:			mreqs.imr_sourceaddr = psin->sin_addr.s_addr;
ip_sockglue.c:747:				mreq.imr_multiaddr = psin->sin_addr;
ip_sockglue.c:775:				err = -ENOBUFS;
ip_sockglue.c:780:				err = -ENOBUFS;
ip_sockglue.c:783:			err = -EFAULT;
ip_sockglue.c:787:			/* numsrc >= (4G-140)/128 overflow in 32 bits */
ip_sockglue.c:788:			if (gsf->gf_numsrc >= 0x1ffffff ||
ip_sockglue.c:789:			    gsf->gf_numsrc > sysctl_igmp_max_msf) {
ip_sockglue.c:790:				err = -ENOBUFS;
ip_sockglue.c:793:			if (GROUP_FILTER_SIZE(gsf->gf_numsrc) > optlen) {
ip_sockglue.c:797:			msize = IP_MSFILTER_SIZE(gsf->gf_numsrc);
ip_sockglue.c:800:				err = -ENOBUFS;
ip_sockglue.c:803:			ifindex = gsf->gf_interface;
ip_sockglue.c:804:			psin = (struct sockaddr_in *)&gsf->gf_group;
ip_sockglue.c:805:			if (psin->sin_family != AF_INET) {
ip_sockglue.c:806:				err = -EADDRNOTAVAIL;
ip_sockglue.c:809:			msf->imsf_multiaddr = psin->sin_addr.s_addr;
ip_sockglue.c:810:			msf->imsf_interface = 0;
ip_sockglue.c:811:			msf->imsf_fmode = gsf->gf_fmode;
ip_sockglue.c:812:			msf->imsf_numsrc = gsf->gf_numsrc;
ip_sockglue.c:813:			err = -EADDRNOTAVAIL;
ip_sockglue.c:814:			for (i=0; i<gsf->gf_numsrc; ++i) {
ip_sockglue.c:815:				psin = (struct sockaddr_in *)&gsf->gf_slist[i];
ip_sockglue.c:817:				if (psin->sin_family != AF_INET)
ip_sockglue.c:819:				msf->imsf_slist[i] = psin->sin_addr.s_addr;
ip_sockglue.c:839:			sk->protinfo.af_inet.freebind = !!val; 
ip_sockglue.c:847:			err = -ENOPROTOOPT;
ip_sockglue.c:856:	return -EINVAL;
ip_sockglue.c:870:		return -EOPNOTSUPP;
ip_sockglue.c:880:		return -EFAULT;
ip_sockglue.c:882:		return -EINVAL;
ip_sockglue.c:891:				opt->optlen = 0;
ip_sockglue.c:892:				if (sk->protinfo.af_inet.opt)
ip_sockglue.c:893:					memcpy(optbuf, sk->protinfo.af_inet.opt,
ip_sockglue.c:895:					       sk->protinfo.af_inet.opt->optlen);
ip_sockglue.c:898:				if (opt->optlen == 0) 
ip_sockglue.c:903:				len = min_t(unsigned int, len, opt->optlen);
ip_sockglue.c:905:					return -EFAULT;
ip_sockglue.c:906:				if(copy_to_user(optval, opt->__data, len))
ip_sockglue.c:907:					return -EFAULT;
ip_sockglue.c:911:			val = (sk->protinfo.af_inet.cmsg_flags & IP_CMSG_PKTINFO) != 0;
ip_sockglue.c:914:			val = (sk->protinfo.af_inet.cmsg_flags & IP_CMSG_TTL) != 0;
ip_sockglue.c:917:			val = (sk->protinfo.af_inet.cmsg_flags & IP_CMSG_TOS) != 0;
ip_sockglue.c:920:			val = (sk->protinfo.af_inet.cmsg_flags & IP_CMSG_RECVOPTS) != 0;
ip_sockglue.c:923:			val = (sk->protinfo.af_inet.cmsg_flags & IP_CMSG_RETOPTS) != 0;
ip_sockglue.c:926:			val=sk->protinfo.af_inet.tos;
ip_sockglue.c:929:			val=sk->protinfo.af_inet.ttl;
ip_sockglue.c:932:			val=sk->protinfo.af_inet.hdrincl;
ip_sockglue.c:935:			val=sk->protinfo.af_inet.pmtudisc;
ip_sockglue.c:943:				val = dst->pmtu;
ip_sockglue.c:948:				return -ENOTCONN;
ip_sockglue.c:953:			val=sk->protinfo.af_inet.recverr;
ip_sockglue.c:956:			val=sk->protinfo.af_inet.mc_ttl;
ip_sockglue.c:959:			val=sk->protinfo.af_inet.mc_loop;
ip_sockglue.c:965:			addr.s_addr = sk->protinfo.af_inet.mc_addr;
ip_sockglue.c:969:  				return -EFAULT;
ip_sockglue.c:971:				return -EFAULT;
ip_sockglue.c:981:				return -EINVAL;
ip_sockglue.c:985:				return -EFAULT;
ip_sockglue.c:999:				return -EINVAL;
ip_sockglue.c:1003:				return -EFAULT;
ip_sockglue.c:1016:			if (sk->type != SOCK_STREAM)
ip_sockglue.c:1017:				return -ENOPROTOOPT;
ip_sockglue.c:1023:			if (sk->protinfo.af_inet.cmsg_flags&IP_CMSG_PKTINFO) {
ip_sockglue.c:1026:				info.ipi_addr.s_addr = sk->rcv_saddr;
ip_sockglue.c:1027:				info.ipi_spec_dst.s_addr = sk->rcv_saddr;
ip_sockglue.c:1028:				info.ipi_ifindex = sk->protinfo.af_inet.mc_index;
ip_sockglue.c:1031:			if (sk->protinfo.af_inet.cmsg_flags&IP_CMSG_TTL) {
ip_sockglue.c:1032:				int hlim = sk->protinfo.af_inet.mc_ttl;
ip_sockglue.c:1035:			len -= msg.msg_controllen;
ip_sockglue.c:1039:			val = sk->protinfo.af_inet.freebind; 
ip_sockglue.c:1051:			return -ENOPROTOOPT;
ip_sockglue.c:1060:			return -EFAULT;
ip_sockglue.c:1062:			return -EFAULT;
ip_sockglue.c:1066:			return -EFAULT;
ip_sockglue.c:1068:			return -EFAULT;
memdump-test.c:4:#include "memdump-util.h"
memdump-test.c:7:	char *input = "About This DocumentTable of Contents1. Overview2. Quick Start3. Settings3.1. Appearance3.2. Actions3.3. Feedback3.4. Access Methods3.5. Prediction4. Screen-by-Screen Description4.1. Back4.2. Compose4.3. Launcher4.4. Activate4.5. Menus4.6. Toolbars4.7. UI Grab";
memdump-test.c:10:	hexdump_helper(input + half, total - half, cont);
proc.c:13: *		Gerald J. Heim, <heim@peanuts.informatik.uni-tuebingen.de>
proc.c:14: *		Fred Baumgarten, <dc6iq@insu1.etec.uni-karlsruhe.de>
proc.c:15: *		Erik Schoenfelder, <schoenfr@ibr.cs.tu-bs.de>
proc.c:59:		res += proto->stats[cpu_logical_map(cpu)].inuse;
proc.c:91:	len -= offset;
proc.c:162:	len -= offset;
proc.c:216:	len -= offset;
proc.c:250:		slen += meminfo_read_proc(sbuffer + slen, &start, 0, 4096 - slen,
proc.c:267:	len -= offset;
proc.c:273:	slen -= len;
protocol.c:113:	hash = prot->protocol & (MAX_INET_PROTOS - 1);
protocol.c:115:	prot ->next = inet_protos[hash];
protocol.c:117:	prot->copy = 0;
protocol.c:123:	p2 = (struct inet_protocol *) prot->next;
protocol.c:125:		if (p2->protocol == prot->protocol) {
protocol.c:126:			prot->copy = 1;
protocol.c:129:		p2 = (struct inet_protocol *) p2->next;
protocol.c:144:	hash = prot->protocol & (MAX_INET_PROTOS - 1);
protocol.c:147:		inet_protos[hash] = (struct inet_protocol *) inet_protos[hash]->next;
protocol.c:154:	if (p != NULL && p->protocol == prot->protocol)
protocol.c:163:		if (p->next && p->next == prot) {
protocol.c:168:			if (prot->copy == 0 && lp != NULL)
protocol.c:169:				lp->copy = 0;
protocol.c:170:			p->next = prot->next;
protocol.c:174:		if (p->next != NULL && p->next->protocol == prot->protocol) 
protocol.c:175:			lp = p->next;
protocol.c:177:		p = (struct inet_protocol *) p->next;
protocol.c:180:	return -1;
raw.c:6: *		RAW - implementation of IP "raw" sockets.
raw.c:20: *		Alan Cox	:	Checks sk->broadcast.
raw.c:73:	struct sock **skp = &raw_v4_htable[sk->num & (RAWV4_HTABLE_SIZE - 1)];
raw.c:76:	if ((sk->next = *skp) != NULL)
raw.c:77:		(*skp)->pprev = &sk->next;
raw.c:79:	sk->pprev = skp;
raw.c:80:	sock_prot_inc_use(sk->prot);
raw.c:88:	if (sk->pprev) {
raw.c:89:		if (sk->next)
raw.c:90:			sk->next->pprev = sk->pprev;
raw.c:91:		*sk->pprev = sk->next;
raw.c:92:		sk->pprev = NULL;
raw.c:93:		sock_prot_dec_use(sk->prot);
raw.c:105:	for (s = sk; s; s = s->next) {
raw.c:106:		if (s->num == num 				&&
raw.c:107:		    !(s->daddr && s->daddr != raddr) 		&&
raw.c:108:		    !(s->rcv_saddr && s->rcv_saddr != laddr)	&&
raw.c:109:		    !(s->bound_dev_if && s->bound_dev_if != dif))
raw.c:116: *	0 - deliver
raw.c:117: *	1 - block
raw.c:123:	type = skb->h.icmph->type;
raw.c:125:		__u32 data = sk->tp_pinfo.tp_raw4.filter.data;
raw.c:139: * -> It does. And not only TOS, but all IP header.
raw.c:148:	sk = __raw_v4_lookup(sk, iph->protocol,
raw.c:149:			     iph->saddr, iph->daddr,
raw.c:150:			     skb->dev->ifindex);
raw.c:153:		struct sock *sknext = __raw_v4_lookup(sk->next, iph->protocol,
raw.c:154:						      iph->saddr, iph->daddr,
raw.c:155:						      skb->dev->ifindex);
raw.c:156:		if (iph->protocol != IPPROTO_ICMP ||
raw.c:179:	int type = skb->h.icmph->type;
raw.c:180:	int code = skb->h.icmph->code;
raw.c:189:	if (!sk->protinfo.af_inet.recverr && sk->state != TCP_ESTABLISHED)
raw.c:210:			harderr = sk->protinfo.af_inet.pmtudisc !=
raw.c:216:	if (sk->protinfo.af_inet.recverr) {
raw.c:217:		struct iphdr *iph = (struct iphdr*)skb->data;
raw.c:218:		u8 *payload = skb->data + (iph->ihl << 2);
raw.c:220:		if (sk->protinfo.af_inet.hdrincl)
raw.c:221:			payload = skb->data;
raw.c:225:	if (sk->protinfo.af_inet.recverr || harderr) {
raw.c:226:		sk->err = err;
raw.c:227:		sk->error_report(sk);
raw.c:247:	skb_push(skb, skb->data - skb->nh.raw);
raw.c:272:	return memcpy_fromiovecend(to, rfh->iov, offset, fraglen);
raw.c:284:	if (memcpy_fromiovecend(to, rfh->iov, offset, fraglen))
raw.c:285:		return -EFAULT;
raw.c:289:		if (!iph->saddr)
raw.c:290:			iph->saddr = rfh->saddr;
raw.c:291:		iph->check   = 0;
raw.c:292:		iph->tot_len = htons(fraglen); /* This is right as you can't
raw.c:298:		if (!iph->id)
raw.c:299:			ip_select_ident(iph, rfh->dst, NULL);
raw.c:300:		iph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);
raw.c:317:	   in ip_build_xmit --ANK
raw.c:319:	   BTW socket.c -> af_*.c -> ... make multiple
raw.c:320:	   invalid conversions size_t -> int. We MUST repair it f.e.
raw.c:323:	   If len was ULONG_MAX-10 it would be cathastrophe  --ANK
raw.c:326:	err = -EMSGSIZE;
raw.c:334:	err = -EOPNOTSUPP;
raw.c:335:	if (msg->msg_flags & MSG_OOB)	/* Mirror BSD error message */
raw.c:342:	if (msg->msg_namelen) {
raw.c:343:		struct sockaddr_in *usin = (struct sockaddr_in*)msg->msg_name;
raw.c:344:		err = -EINVAL;
raw.c:345:		if (msg->msg_namelen < sizeof(*usin))
raw.c:347:		if (usin->sin_family != AF_INET) {
raw.c:352:						 current->comm);
raw.c:353:			err = -EINVAL;
raw.c:354:			if (usin->sin_family)
raw.c:357:		daddr = usin->sin_addr.s_addr;
raw.c:363:		err = -EDESTADDRREQ;
raw.c:364:		if (sk->state != TCP_ESTABLISHED) 
raw.c:366:		daddr = sk->daddr;
raw.c:369:	ipc.addr = sk->saddr;
raw.c:371:	ipc.oif = sk->bound_dev_if;
raw.c:373:	if (msg->msg_controllen) {
raw.c:385:		ipc.opt = sk->protinfo.af_inet.opt;
raw.c:388:		err = -EINVAL;
raw.c:390:		 * so that IP options + IP_HDRINCL is non-sense.
raw.c:392:		if (sk->protinfo.af_inet.hdrincl)
raw.c:394:		if (ipc.opt->srr) {
raw.c:397:			daddr = ipc.opt->faddr;
raw.c:400:	tos = RT_TOS(sk->protinfo.af_inet.tos) | sk->localroute;
raw.c:401:	if (msg->msg_flags & MSG_DONTROUTE)
raw.c:406:			ipc.oif = sk->protinfo.af_inet.mc_index;
raw.c:408:			rfh.saddr = sk->protinfo.af_inet.mc_addr;
raw.c:416:	err = -EACCES;
raw.c:417:	if (rt->rt_flags & RTCF_BROADCAST && !sk->broadcast)
raw.c:420:	if (msg->msg_flags & MSG_CONFIRM)
raw.c:424:	rfh.iov		= msg->msg_iov;
raw.c:425:	rfh.saddr	= rt->rt_src;
raw.c:426:	rfh.dst		= &rt->u.dst;
raw.c:428:		ipc.addr = rt->rt_dst;
raw.c:429:	err = ip_build_xmit(sk, sk->protinfo.af_inet.hdrincl ? raw_getrawfrag :
raw.c:430:		       	    raw_getfrag, &rfh, len, &ipc, rt, msg->msg_flags);
raw.c:440:	dst_confirm(&rt->u.dst);
raw.c:441:	if (!(msg->msg_flags & MSG_PROBE) || len)
raw.c:457:/* This gets rid of all the nasties in af_inet. -DaveM */
raw.c:461:	int ret = -EINVAL;
raw.c:464:	if (sk->state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_in))
raw.c:466:	chk_addr_ret = inet_addr_type(addr->sin_addr.s_addr);
raw.c:467:	ret = -EADDRNOTAVAIL;
raw.c:468:	if (addr->sin_addr.s_addr && chk_addr_ret != RTN_LOCAL &&
raw.c:471:	sk->rcv_saddr = sk->saddr = addr->sin_addr.s_addr;
raw.c:473:		sk->saddr = 0;  /* Use device */
raw.c:488:	int err = -EOPNOTSUPP;
raw.c:489:	struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
raw.c:507:	copied = skb->len;
raw.c:509:		msg->msg_flags |= MSG_TRUNC;
raw.c:513:	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
raw.c:521:		sin->sin_family = AF_INET;
raw.c:522:		sin->sin_addr.s_addr = skb->nh.iph->saddr;
raw.c:523:		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
raw.c:525:	if (sk->protinfo.af_inet.cmsg_flags)
raw.c:534:	struct raw_opt *tp = &(sk->tp_pinfo.tp_raw4);
raw.c:535:	if (sk->num == IPPROTO_ICMP)
raw.c:536:		memset(&tp->filter, 0, sizeof(tp->filter));
raw.c:544:	if (copy_from_user(&sk->tp_pinfo.tp_raw4.filter, optval, optlen))
raw.c:545:		return -EFAULT;
raw.c:551:	int len, ret = -EFAULT;
raw.c:555:	ret = -EINVAL;
raw.c:560:	ret = -EFAULT;
raw.c:562:	    copy_to_user(optval, &sk->tp_pinfo.tp_raw4.filter, len))
raw.c:575:		if (sk->num != IPPROTO_ICMP)
raw.c:576:			return -EOPNOTSUPP;
raw.c:580:	return -ENOPROTOOPT;
raw.c:590:		if (sk->num != IPPROTO_ICMP)
raw.c:591:			return -EOPNOTSUPP;
raw.c:595:	return -ENOPROTOOPT;
raw.c:602:			int amount = atomic_read(&sk->wmem_alloc);
raw.c:609:			spin_lock_irq(&sk->receive_queue.lock);
raw.c:610:			skb = skb_peek(&sk->receive_queue);
raw.c:612:				amount = skb->len;
raw.c:613:			spin_unlock_irq(&sk->receive_queue.lock);
raw.c:621:			return -ENOIOCTLCMD;
raw.c:628:	unsigned int dest = sp->daddr,
raw.c:629:		     src = sp->rcv_saddr;
raw.c:631:	      srcp  = sp->num;
raw.c:635:		i, src, srcp, dest, destp, sp->state, 
raw.c:636:		atomic_read(&sp->wmem_alloc), atomic_read(&sp->rmem_alloc),
raw.c:640:		atomic_read(&sp->refcnt), sp);
raw.c:651:		len += sprintf(buffer, "%-127s\n",
raw.c:653:			       "rx_queue tr tm->when retrnsmt   uid  timeout "
raw.c:659:		for (sk = raw_v4_htable[i]; sk; sk = sk->next, num++) {
raw.c:660:			if (sk->family != PF_INET)
raw.c:666:			len += sprintf(buffer + len, "%-127s\n", tmpbuf);
raw.c:673:	begin = len - (pos - offset);
raw.c:675:	len -= begin;
route.c:6: *		ROUTE - implementation of the IP router.
route.c:49: *		Andi Kleen	:	Load-limit warning messages.
route.c:222:		sprintf(buffer, "%-127s\n",
route.c:229:	for (i = rt_hash_mask; i >= 0; i--) {
route.c:231:		for (r = rt_hash_table[i].chain; r; r = r->u.rt_next) {
route.c:243:				r->u.dst.dev ? r->u.dst.dev->name : "*",
route.c:244:				(unsigned long)r->rt_dst,
route.c:245:				(unsigned long)r->rt_gateway,
route.c:246:				r->rt_flags,
route.c:247:				atomic_read(&r->u.dst.__refcnt),
route.c:248:				r->u.dst.__use,
route.c:250:				(unsigned long)r->rt_src,
route.c:251:				(r->u.dst.advmss ?
route.c:252:				 (int) r->u.dst.advmss + 40 : 0),
route.c:253:				r->u.dst.window,
route.c:254:				(int)((r->u.dst.rtt >> 3) + r->u.dst.rttvar),
route.c:255:				r->key.tos,
route.c:256:				r->u.dst.hh ?
route.c:257:					atomic_read(&r->u.dst.hh->hh_refcnt) :
route.c:258:					-1,
route.c:259:				r->u.dst.hh ?
route.c:260:			       		(r->u.dst.hh->hh_output ==
route.c:262:				r->rt_spec_dst);
route.c:263:			sprintf(buffer + len, "%-127s\n", temp);
route.c:274:  	*start = buffer + len - (pos - offset);
route.c:275:  	len = pos - offset;
route.c:313:	len -= offset;
route.c:326:	dst_free(&rt->u.dst);
route.c:332:	dst_free(&rt->u.dst);
route.c:339:	return (rth->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST)) &&
route.c:340:		rth->key.iif && rth->u.rt_next;
route.c:345:	return (rth->rt_flags & (RTCF_REDIRECTED | RTCF_NOTIFY)) ||
route.c:346:		rth->u.dst.expires;
route.c:354:	if (atomic_read(&rth->u.dst.__refcnt))
route.c:358:	if (rth->u.dst.expires &&
route.c:359:	    time_after_eq(jiffies, rth->u.dst.expires))
route.c:362:	age = jiffies - rth->u.dst.lastuse;
route.c:378:	u32 score = jiffies - rt->u.dst.lastuse;
route.c:385:	if (!rt->key.iif ||
route.c:386:	    !(rt->rt_flags & (RTCF_BROADCAST|RTCF_MULTICAST|RTCF_LOCAL)))
route.c:401:	     t -= ip_rt_gc_timeout) {
route.c:409:			if (rth->u.dst.expires) {
route.c:411:				if (time_before_eq(now, rth->u.dst.expires)) {
route.c:413:					rthp = &rth->u.rt_next;
route.c:418:				rthp = &rth->u.rt_next;
route.c:423:			*rthp = rth->u.rt_next;
route.c:438:/* This can run from both BH and non-BH contexts, the latter
route.c:450:	for (i = rt_hash_mask; i >= 0; i--) {
route.c:458:			next = rth->u.rt_next;
route.c:479:		long tmo = (long)(rt_deadline - now);
route.c:488:		if (user_mode && tmo < ip_rt_max_delay-ip_rt_min_delay)
route.c:546:	if (now - last_gc < ip_rt_gc_min_interval &&
route.c:553:	goal = atomic_read(&ipv4_dst_ops.entries) -
route.c:558:		goal = atomic_read(&ipv4_dst_ops.entries) - equilibrium;
route.c:561:			goal = atomic_read(&ipv4_dst_ops.entries) - equilibrium;
route.c:568:		equilibrium = atomic_read(&ipv4_dst_ops.entries) - goal;
route.c:571:	if (now - last_gc >= ip_rt_gc_min_interval)
route.c:582:		for (i = rt_hash_mask, k = rover; i >= 0; i--) {
route.c:591:					rthp = &rth->u.rt_next;
route.c:594:				*rthp = rth->u.rt_next;
route.c:596:				goal--;
route.c:609:		   - if expire reduced to zero. Otherwise, expire is halfed.
route.c:610:		   - if table is not full.
route.c:611:		   - if we are called from interrupt.
route.c:612:		   - jiffies check is just fallback/debug loop breaker.
route.c:670:		if (memcmp(&rth->key, &rt->key, sizeof(rt->key)) == 0) {
route.c:672:			*rthp = rth->u.rt_next;
route.c:673:			rth->u.rt_next = rt_hash_table[hash].chain;
route.c:676:			rth->u.dst.__use++;
route.c:677:			dst_hold(&rth->u.dst);
route.c:678:			rth->u.dst.lastuse = now;
route.c:686:		if (!atomic_read(&rth->u.dst.__refcnt)) {
route.c:698:		rthp = &rth->u.rt_next;
route.c:709:			*candp = cand->u.rt_next;
route.c:717:	if (rt->rt_type == RTN_UNICAST || rt->key.iif == 0) {
route.c:718:		int err = arp_bind_neighbour(&rt->u.dst);
route.c:722:			if (err != -ENOBUFS) {
route.c:731:			if (attempts-- > 0) {
route.c:745:			return -ENOBUFS;
route.c:749:	rt->u.rt_next = rt_hash_table[hash].chain;
route.c:751:	if (rt->u.rt_next) {
route.c:754:		       NIPQUAD(rt->rt_dst));
route.c:755:		for (trt = rt->u.rt_next; trt; trt = trt->u.rt_next)
route.c:756:			printk(" . %u.%u.%u.%u", NIPQUAD(trt->rt_dst));
route.c:771:	peer = inet_getpeer(rt->rt_dst, create);
route.c:774:	if (rt->peer == NULL) {
route.c:775:		rt->peer = peer;
route.c:784: * Peer allocation may fail only in serious out-of-memory conditions.  However
route.c:797:	salt = secure_ip_id(ip_fallback_id ^ iph->daddr);
route.c:798:	iph->id = htons(salt & 0xFFFF);
route.c:808:		if (rt->peer == NULL)
route.c:814:		if (rt->peer) {
route.c:815:			iph->id = htons(inet_getid(rt->peer));
route.c:831:	     rthp = &(*rthp)->u.rt_next)
route.c:833:			*rthp = rt->u.rt_next;
route.c:847:	int  ikeys[2] = { dev->ifindex, 0 };
route.c:880:				if (rth->key.dst != daddr ||
route.c:881:				    rth->key.src != skeys[i] ||
route.c:882:				    rth->key.tos != tos ||
route.c:883:				    rth->key.oif != ikeys[k] ||
route.c:884:				    rth->key.iif != 0) {
route.c:885:					rthp = &rth->u.rt_next;
route.c:889:				if (rth->rt_dst != daddr ||
route.c:890:				    rth->rt_src != saddr ||
route.c:891:				    rth->u.dst.error ||
route.c:892:				    rth->rt_gateway != old_gw ||
route.c:893:				    rth->u.dst.dev != dev)
route.c:896:				dst_hold(&rth->u.dst);
route.c:908:				rt->u.dst.__use		= 1;
route.c:909:				atomic_set(&rt->u.dst.__refcnt, 1);
route.c:910:				if (rt->u.dst.dev)
route.c:911:					dev_hold(rt->u.dst.dev);
route.c:912:				rt->u.dst.lastuse	= jiffies;
route.c:913:				rt->u.dst.neighbour	= NULL;
route.c:914:				rt->u.dst.hh		= NULL;
route.c:915:				rt->u.dst.obsolete	= 0;
route.c:917:				rt->rt_flags		|= RTCF_REDIRECTED;
route.c:920:				rt->rt_gateway		= new_gw;
route.c:922:				/* Redirect received -> path was valid */
route.c:923:				dst_confirm(&rth->u.dst);
route.c:925:				if (rt->peer)
route.c:926:					atomic_inc(&rt->peer->refcnt);
route.c:928:				if (arp_bind_neighbour(&rt->u.dst) ||
route.c:929:				    !(rt->u.dst.neighbour->nud_state &
route.c:931:					if (rt->u.dst.neighbour)
route.c:932:						neigh_event_send(rt->u.dst.neighbour, NULL);
route.c:956:			"  Advised path = %u.%u.%u.%u -> %u.%u.%u.%u, "
route.c:958:		       NIPQUAD(old_gw), dev->name, NIPQUAD(new_gw),
route.c:970:		if (dst->obsolete) {
route.c:973:		} else if ((rt->rt_flags & RTCF_REDIRECTED) ||
route.c:974:			   rt->u.dst.expires) {
route.c:975:			unsigned hash = rt_hash_code(rt->key.dst,
route.c:976:						     rt->key.src ^
route.c:977:							(rt->key.oif << 5),
route.c:978:						     rt->key.tos);
route.c:982:				NIPQUAD(rt->rt_dst), rt->key.tos);
route.c:1009:	struct rtable *rt = (struct rtable*)skb->dst;
route.c:1010:	struct in_device *in_dev = in_dev_get(rt->u.dst.dev);
route.c:1021:	if (time_after(jiffies, rt->u.dst.rate_last + ip_rt_redirect_silence))
route.c:1022:		rt->u.dst.rate_tokens = 0;
route.c:1027:	if (rt->u.dst.rate_tokens >= ip_rt_redirect_number) {
route.c:1028:		rt->u.dst.rate_last = jiffies;
route.c:1036:		       (rt->u.dst.rate_last +
route.c:1037:			(ip_rt_redirect_load << rt->u.dst.rate_tokens)))) {
route.c:1038:		icmp_send(skb, ICMP_REDIRECT, ICMP_REDIR_HOST, rt->rt_gateway);
route.c:1039:		rt->u.dst.rate_last = jiffies;
route.c:1040:		++rt->u.dst.rate_tokens;
route.c:1043:		    rt->u.dst.rate_tokens == ip_rt_redirect_number &&
route.c:1047:				NIPQUAD(rt->rt_src), rt->rt_iif,
route.c:1048:				NIPQUAD(rt->rt_dst), NIPQUAD(rt->rt_gateway));
route.c:1057:	struct rtable *rt = (struct rtable*)skb->dst;
route.c:1061:	switch (rt->u.dst.error) {
route.c:1077:	rt->u.dst.rate_tokens += now - rt->u.dst.rate_last;
route.c:1078:	if (rt->u.dst.rate_tokens > ip_rt_error_burst)
route.c:1079:		rt->u.dst.rate_tokens = ip_rt_error_burst;
route.c:1080:	rt->u.dst.rate_last = now;
route.c:1081:	if (rt->u.dst.rate_tokens >= ip_rt_error_cost) {
route.c:1082:		rt->u.dst.rate_tokens -= ip_rt_error_cost;
route.c:1111:	unsigned short old_mtu = ntohs(iph->tot_len);
route.c:1113:	u32  skeys[2] = { iph->saddr, 0, };
route.c:1114:	u32  daddr = iph->daddr;
route.c:1115:	u8   tos = iph->tos & IPTOS_RT_MASK;
route.c:1126:		     rth = rth->u.rt_next) {
route.c:1127:			if (rth->key.dst == daddr &&
route.c:1128:			    rth->key.src == skeys[i] &&
route.c:1129:			    rth->rt_dst  == daddr &&
route.c:1130:			    rth->rt_src  == iph->saddr &&
route.c:1131:			    rth->key.tos == tos &&
route.c:1132:			    rth->key.iif == 0 &&
route.c:1133:			    !(rth->u.dst.mxlock & (1 << RTAX_MTU))) {
route.c:1138:					/* BSD 4.2 compatibility hack :-( */
route.c:1140:					    old_mtu >= rth->u.dst.pmtu &&
route.c:1141:					    old_mtu >= 68 + (iph->ihl << 2))
route.c:1142:						old_mtu -= iph->ihl << 2;
route.c:1146:				if (mtu <= rth->u.dst.pmtu) {
route.c:1147:					if (mtu < rth->u.dst.pmtu) { 
route.c:1148:						dst_confirm(&rth->u.dst);
route.c:1151:							rth->u.dst.mxlock |=
route.c:1154:						rth->u.dst.pmtu = mtu;
route.c:1155:						dst_set_expires(&rth->u.dst,
route.c:1169:	if (dst->pmtu > mtu && mtu >= 68 &&
route.c:1170:	    !(dst->mxlock & (1 << RTAX_MTU))) {
route.c:1173:			dst->mxlock |= (1 << RTAX_MTU);
route.c:1175:		dst->pmtu = mtu;
route.c:1195:	struct inet_peer *peer = rt->peer;
route.c:1198:		rt->peer = NULL;
route.c:1209:	rt = (struct rtable *) skb->dst;
route.c:1211:		dst_set_expires(&rt->u.dst, 0);
route.c:1216:	printk(KERN_DEBUG "ip_rt_bug: %u.%u.%u.%u -> %u.%u.%u.%u, %s\n",
route.c:1217:		NIPQUAD(skb->nh.iph->saddr), NIPQUAD(skb->nh.iph->daddr),
route.c:1218:		skb->dev ? skb->dev->name : "?");
route.c:1237:	if (rt->key.iif == 0)
route.c:1238:		src = rt->rt_src;
route.c:1239:	else if (fib_lookup(&rt->key, &res) == 0) {
route.c:1242:			src = inet_select_addr(rt->u.dst.dev, rt->rt_gateway,
route.c:1249:		src = inet_select_addr(rt->u.dst.dev, rt->rt_gateway,
route.c:1257:	if (!(rt->u.dst.tclassid & 0xFFFF))
route.c:1258:		rt->u.dst.tclassid |= tag & 0xFFFF;
route.c:1259:	if (!(rt->u.dst.tclassid & 0xFFFF0000))
route.c:1260:		rt->u.dst.tclassid |= tag & 0xFFFF0000;
route.c:1266:	struct fib_info *fi = res->fi;
route.c:1271:			rt->rt_gateway = FIB_RES_GW(*res);
route.c:1272:		memcpy(&rt->u.dst.mxlock, fi->fib_metrics,
route.c:1273:			sizeof(fi->fib_metrics));
route.c:1274:		if (fi->fib_mtu == 0) {
route.c:1275:			rt->u.dst.pmtu = rt->u.dst.dev->mtu;
route.c:1276:			if (rt->u.dst.mxlock & (1 << RTAX_MTU) &&
route.c:1277:			    rt->rt_gateway != rt->rt_dst &&
route.c:1278:			    rt->u.dst.pmtu > 576)
route.c:1279:				rt->u.dst.pmtu = 576;
route.c:1282:		rt->u.dst.tclassid = FIB_RES_NH(*res).nh_tclassid;
route.c:1285:		rt->u.dst.pmtu	= rt->u.dst.dev->mtu;
route.c:1287:	if (rt->u.dst.pmtu > IP_MAX_MTU)
route.c:1288:		rt->u.dst.pmtu = IP_MAX_MTU;
route.c:1289:	if (rt->u.dst.advmss == 0)
route.c:1290:		rt->u.dst.advmss = max_t(unsigned int, rt->u.dst.dev->mtu - 40,
route.c:1292:	if (rt->u.dst.advmss > 65535 - 40)
route.c:1293:		rt->u.dst.advmss = 65535 - 40;
route.c:1301:        rt->rt_type = res->type;
route.c:1316:		return -EINVAL;
route.c:1319:	    skb->protocol != htons(ETH_P_IP))
route.c:1334:	rth->u.dst.output= ip_rt_bug;
route.c:1336:	atomic_set(&rth->u.dst.__refcnt, 1);
route.c:1337:	rth->u.dst.flags= DST_HOST;
route.c:1338:	rth->key.dst	= daddr;
route.c:1339:	rth->rt_dst	= daddr;
route.c:1340:	rth->key.tos	= tos;
route.c:1342:	rth->key.fwmark	= skb->nfmark;
route.c:1344:	rth->key.src	= saddr;
route.c:1345:	rth->rt_src	= saddr;
route.c:1347:	rth->rt_dst_map	= daddr;
route.c:1348:	rth->rt_src_map	= saddr;
route.c:1351:	rth->u.dst.tclassid = itag;
route.c:1353:	rth->rt_iif	=
route.c:1354:	rth->key.iif	= dev->ifindex;
route.c:1355:	rth->u.dst.dev	= &loopback_dev;
route.c:1356:	dev_hold(rth->u.dst.dev);
route.c:1357:	rth->key.oif	= 0;
route.c:1358:	rth->rt_gateway	= daddr;
route.c:1359:	rth->rt_spec_dst= spec_dst;
route.c:1360:	rth->rt_type	= RTN_MULTICAST;
route.c:1361:	rth->rt_flags	= RTCF_MULTICAST;
route.c:1363:		rth->u.dst.input= ip_local_deliver;
route.c:1364:		rth->rt_flags |= RTCF_LOCAL;
route.c:1369:		rth->u.dst.input = ip_mr_input;
route.c:1374:	hash = rt_hash_code(daddr, saddr ^ (dev->ifindex << 5), tos);
route.c:1375:	return rt_intern_hash(hash, rth, (struct rtable**) &skb->dst);
route.c:1379:	return -ENOBUFS;
route.c:1383:	return -EINVAL;
route.c:1408:	int		err = -EINVAL;
route.c:1420:	key.fwmark	= skb->nfmark;
route.c:1422:	key.iif		= dev->ifindex;
route.c:1439:	 * I even do not know to fix it or not. Waiting for complains :-)
route.c:1506:	if (res.fi->fib_nhs > 1 && key.oif == 0)
route.c:1530:	if (skb->protocol != htons(ETH_P_IP)) {
route.c:1542:	atomic_set(&rth->u.dst.__refcnt, 1);
route.c:1543:	rth->u.dst.flags= DST_HOST;
route.c:1544:	rth->key.dst	= daddr;
route.c:1545:	rth->rt_dst	= daddr;
route.c:1546:	rth->key.tos	= tos;
route.c:1548:	rth->key.fwmark	= skb->nfmark;
route.c:1550:	rth->key.src	= saddr;
route.c:1551:	rth->rt_src	= saddr;
route.c:1552:	rth->rt_gateway	= daddr;
route.c:1554:	rth->rt_src_map	= key.src;
route.c:1555:	rth->rt_dst_map	= key.dst;
route.c:1557:		rth->rt_gateway	= key.dst;
route.c:1559:	rth->rt_iif 	=
route.c:1560:	rth->key.iif	= dev->ifindex;
route.c:1561:	rth->u.dst.dev	= out_dev->dev;
route.c:1562:	dev_hold(rth->u.dst.dev);
route.c:1563:	rth->key.oif 	= 0;
route.c:1564:	rth->rt_spec_dst= spec_dst;
route.c:1566:	rth->u.dst.input = ip_forward;
route.c:1567:	rth->u.dst.output = ip_output;
route.c:1571:	rth->rt_flags = flags;
route.c:1575:		struct net_device *odev = rth->u.dst.dev;
route.c:1577:		    dev->accept_fastpath &&
route.c:1578:		    odev->mtu >= dev->mtu &&
route.c:1579:		    dev->accept_fastpath(dev, &rth->u.dst) == 0)
route.c:1580:			rth->rt_flags |= RTCF_FAST;
route.c:1585:	err = rt_intern_hash(hash, rth, (struct rtable**)&skb->dst);
route.c:1595:	if (skb->protocol != htons(ETH_P_IP))
route.c:1617:	rth->u.dst.output= ip_rt_bug;
route.c:1619:	atomic_set(&rth->u.dst.__refcnt, 1);
route.c:1620:	rth->u.dst.flags= DST_HOST;
route.c:1621:	rth->key.dst	= daddr;
route.c:1622:	rth->rt_dst	= daddr;
route.c:1623:	rth->key.tos	= tos;
route.c:1625:	rth->key.fwmark	= skb->nfmark;
route.c:1627:	rth->key.src	= saddr;
route.c:1628:	rth->rt_src	= saddr;
route.c:1630:	rth->rt_dst_map	= key.dst;
route.c:1631:	rth->rt_src_map	= key.src;
route.c:1634:	rth->u.dst.tclassid = itag;
route.c:1636:	rth->rt_iif	=
route.c:1637:	rth->key.iif	= dev->ifindex;
route.c:1638:	rth->u.dst.dev	= &loopback_dev;
route.c:1639:	dev_hold(rth->u.dst.dev);
route.c:1640:	rth->key.oif 	= 0;
route.c:1641:	rth->rt_gateway	= daddr;
route.c:1642:	rth->rt_spec_dst= spec_dst;
route.c:1643:	rth->u.dst.input= ip_local_deliver;
route.c:1644:	rth->rt_flags 	= flags|RTCF_LOCAL;
route.c:1646:		rth->u.dst.input= ip_error;
route.c:1647:		rth->u.dst.error= -err;
route.c:1648:		rth->rt_flags 	&= ~RTCF_LOCAL;
route.c:1650:	rth->rt_type	= res.type;
route.c:1668:			NIPQUAD(daddr), NIPQUAD(saddr), dev->name);
route.c:1671:	err = -EINVAL;
route.c:1675:	err = -ENOBUFS;
route.c:1689:			NIPQUAD(daddr), NIPQUAD(saddr), dev->name);
route.c:1690:		if (dev->hard_header_len) {
route.c:1692:			unsigned char *p = skb->mac.raw;
route.c:1694:			for (i = 0; i < dev->hard_header_len; i++, p++) {
route.c:1696:				if (i < (dev->hard_header_len - 1))
route.c:1711:	int iif = dev->ifindex;
route.c:1717:	for (rth = rt_hash_table[hash].chain; rth; rth = rth->u.rt_next) {
route.c:1718:		if (rth->key.dst == daddr &&
route.c:1719:		    rth->key.src == saddr &&
route.c:1720:		    rth->key.iif == iif &&
route.c:1721:		    rth->key.oif == 0 &&
route.c:1723:		    rth->key.fwmark == skb->nfmark &&
route.c:1725:		    rth->key.tos == tos) {
route.c:1726:			rth->u.dst.lastuse = jiffies;
route.c:1727:			dst_hold(&rth->u.dst);
route.c:1728:			rth->u.dst.__use++;
route.c:1731:			skb->dst = (struct dst_entry*)rth;
route.c:1740:	   hardware multicast filters :-( As result the host on multicasting
route.c:1766:		return -EINVAL;
route.c:1787:	tos		= oldkey->tos & (IPTOS_RT_MASK | RTO_ONLINK);
route.c:1788:	key.dst		= oldkey->dst;
route.c:1789:	key.src		= oldkey->src;
route.c:1792:	key.oif		= oldkey->oif;
route.c:1794:	key.fwmark	= oldkey->fwmark;
route.c:1803:	if (oldkey->src) {
route.c:1804:		err = -EINVAL;
route.c:1805:		if (MULTICAST(oldkey->src) ||
route.c:1806:		    BADCLASS(oldkey->src) ||
route.c:1807:		    ZERONET(oldkey->src))
route.c:1811:		dev_out = ip_dev_find(oldkey->src);
route.c:1815:		/* I removed check for oif == dev_out->oif here.
route.c:1820:		      of another iface. --ANK
route.c:1823:		if (oldkey->oif == 0
route.c:1824:		    && (MULTICAST(oldkey->dst) || oldkey->dst == 0xFFFFFFFF)) {
route.c:1840:			key.oif = dev_out->ifindex;
route.c:1847:	if (oldkey->oif) {
route.c:1848:		dev_out = dev_get_by_index(oldkey->oif);
route.c:1849:		err = -ENODEV;
route.c:1857:		if (LOCAL_MCAST(oldkey->dst) || oldkey->dst == 0xFFFFFFFF) {
route.c:1864:			if (MULTICAST(oldkey->dst))
route.c:1867:			else if (!oldkey->dst)
route.c:1889:		if (oldkey->oif) {
route.c:1901:			   and ifaddr state. --ANK
route.c:1916:		err = -ENETUNREACH;
route.c:1931:		key.oif = dev_out->ifindex;
route.c:1940:	if (res.fi->fib_nhs > 1 && key.oif == 0)
route.c:1954:	key.oif = dev_out->ifindex;
route.c:1957:	if (LOOPBACK(key.src) && !(dev_out->flags&IFF_LOOPBACK))
route.c:1967:	if (dev_out->flags & IFF_LOOPBACK)
route.c:1980:		    !ip_check_mc(__in_dev_get(dev_out),oldkey->dst,oldkey->src))
route.c:1997:	atomic_set(&rth->u.dst.__refcnt, 1);
route.c:1998:	rth->u.dst.flags= DST_HOST;
route.c:1999:	rth->key.dst	= oldkey->dst;
route.c:2000:	rth->key.tos	= tos;
route.c:2001:	rth->key.src	= oldkey->src;
route.c:2002:	rth->key.iif	= 0;
route.c:2003:	rth->key.oif	= oldkey->oif;
route.c:2005:	rth->key.fwmark	= oldkey->fwmark;
route.c:2007:	rth->rt_dst	= key.dst;
route.c:2008:	rth->rt_src	= key.src;
route.c:2010:	rth->rt_dst_map	= key.dst;
route.c:2011:	rth->rt_src_map	= key.src;
route.c:2013:	rth->rt_iif	= oldkey->oif ? : dev_out->ifindex;
route.c:2014:	rth->u.dst.dev	= dev_out;
route.c:2016:	rth->rt_gateway = key.dst;
route.c:2017:	rth->rt_spec_dst= key.src;
route.c:2019:	rth->u.dst.output=ip_output;
route.c:2024:		rth->u.dst.input = ip_local_deliver;
route.c:2025:		rth->rt_spec_dst = key.dst;
route.c:2028:		rth->rt_spec_dst = key.src;
route.c:2029:		if (flags & RTCF_LOCAL && !(dev_out->flags & IFF_LOOPBACK)) {
route.c:2030:			rth->u.dst.output = ip_mc_output;
route.c:2038:				    !LOCAL_MCAST(oldkey->dst)) {
route.c:2039:					rth->u.dst.input = ip_mr_input;
route.c:2040:					rth->u.dst.output = ip_mc_output;
route.c:2050:	rth->rt_flags = flags;
route.c:2052:	hash = rt_hash_code(oldkey->dst, oldkey->src ^ (oldkey->oif << 5), tos);
route.c:2062:	err = -EINVAL;
route.c:2065:	err = -ENOBUFS;
route.c:2074:	hash = rt_hash_code(key->dst, key->src ^ (key->oif << 5), key->tos);
route.c:2077:	for (rth = rt_hash_table[hash].chain; rth; rth = rth->u.rt_next) {
route.c:2078:		if (rth->key.dst == key->dst &&
route.c:2079:		    rth->key.src == key->src &&
route.c:2080:		    rth->key.iif == 0 &&
route.c:2081:		    rth->key.oif == key->oif &&
route.c:2083:		    rth->key.fwmark == key->fwmark &&
route.c:2085:		    !((rth->key.tos ^ key->tos) &
route.c:2087:			rth->u.dst.lastuse = jiffies;
route.c:2088:			dst_hold(&rth->u.dst);
route.c:2089:			rth->u.dst.__use++;
route.c:2105:	struct rtable *rt = (struct rtable*)skb->dst;
route.c:2108:	unsigned char	 *b = skb->tail;
route.c:2115:	nlh->nlmsg_flags = (nowait && pid) ? NLM_F_MULTI : 0;
route.c:2116:	r->rtm_family	 = AF_INET;
route.c:2117:	r->rtm_dst_len	= 32;
route.c:2118:	r->rtm_src_len	= 0;
route.c:2119:	r->rtm_tos	= rt->key.tos;
route.c:2120:	r->rtm_table	= RT_TABLE_MAIN;
route.c:2121:	r->rtm_type	= rt->rt_type;
route.c:2122:	r->rtm_scope	= RT_SCOPE_UNIVERSE;
route.c:2123:	r->rtm_protocol = RTPROT_UNSPEC;
route.c:2124:	r->rtm_flags	= (rt->rt_flags & ~0xFFFF) | RTM_F_CLONED;
route.c:2125:	if (rt->rt_flags & RTCF_NOTIFY)
route.c:2126:		r->rtm_flags |= RTM_F_NOTIFY;
route.c:2127:	RTA_PUT(skb, RTA_DST, 4, &rt->rt_dst);
route.c:2128:	if (rt->key.src) {
route.c:2129:		r->rtm_src_len = 32;
route.c:2130:		RTA_PUT(skb, RTA_SRC, 4, &rt->key.src);
route.c:2132:	if (rt->u.dst.dev)
route.c:2133:		RTA_PUT(skb, RTA_OIF, sizeof(int), &rt->u.dst.dev->ifindex);
route.c:2135:	if (rt->u.dst.tclassid)
route.c:2136:		RTA_PUT(skb, RTA_FLOW, 4, &rt->u.dst.tclassid);
route.c:2138:	if (rt->key.iif)
route.c:2139:		RTA_PUT(skb, RTA_PREFSRC, 4, &rt->rt_spec_dst);
route.c:2140:	else if (rt->rt_src != rt->key.src)
route.c:2141:		RTA_PUT(skb, RTA_PREFSRC, 4, &rt->rt_src);
route.c:2142:	if (rt->rt_dst != rt->rt_gateway)
route.c:2143:		RTA_PUT(skb, RTA_GATEWAY, 4, &rt->rt_gateway);
route.c:2144:	if (rtnetlink_put_metrics(skb, &rt->u.dst.mxlock) < 0)
route.c:2146:	ci.rta_lastuse	= jiffies - rt->u.dst.lastuse;
route.c:2147:	ci.rta_used	= rt->u.dst.__use;
route.c:2148:	ci.rta_clntref	= atomic_read(&rt->u.dst.__refcnt);
route.c:2149:	if (rt->u.dst.expires)
route.c:2150:		ci.rta_expires = rt->u.dst.expires - jiffies;
route.c:2153:	ci.rta_error	= rt->u.dst.error;
route.c:2155:	if (rt->peer) {
route.c:2156:		ci.rta_id = rt->peer->ip_id_count;
route.c:2157:		if (rt->peer->tcp_ts_stamp) {
route.c:2158:			ci.rta_ts = rt->peer->tcp_ts;
route.c:2159:			ci.rta_tsage = xtime.tv_sec - rt->peer->tcp_ts_stamp;
route.c:2163:	eptr = (struct rtattr*)skb->tail;
route.c:2166:	if (rt->key.iif) {
route.c:2168:		u32 dst = rt->rt_dst;
route.c:2179:					if (err == -EMSGSIZE)
route.c:2181:					((struct rta_cacheinfo*)RTA_DATA(eptr))->rta_error = err;
route.c:2186:			RTA_PUT(skb, RTA_IIF, sizeof(int), &rt->key.iif);
route.c:2189:	nlh->nlmsg_len = skb->tail - b;
route.c:2190:	return skb->len;
route.c:2194:	skb_trim(skb, b - skb->data);
route.c:2195:	return -1;
route.c:2206:	int err = -ENOBUFS;
route.c:2216:	skb->mac.raw = skb->data;
route.c:2219:	if (rta[RTA_SRC - 1])
route.c:2220:		memcpy(&src, RTA_DATA(rta[RTA_SRC - 1]), 4);
route.c:2221:	if (rta[RTA_DST - 1])
route.c:2222:		memcpy(&dst, RTA_DATA(rta[RTA_DST - 1]), 4);
route.c:2223:	if (rta[RTA_IIF - 1])
route.c:2224:		memcpy(&iif, RTA_DATA(rta[RTA_IIF - 1]), sizeof(int));
route.c:2228:		err = -ENODEV;
route.c:2231:		skb->protocol	= htons(ETH_P_IP);
route.c:2232:		skb->dev	= dev;
route.c:2234:		err = ip_route_input(skb, dst, src, rtm->rtm_tos, dev);
route.c:2236:		rt = (struct rtable*)skb->dst;
route.c:2237:		if (!err && rt->u.dst.error)
route.c:2238:			err = -rt->u.dst.error;
route.c:2241:		if (rta[RTA_OIF - 1])
route.c:2242:			memcpy(&oif, RTA_DATA(rta[RTA_OIF - 1]), sizeof(int));
route.c:2243:		err = ip_route_output(&rt, dst, src, rtm->rtm_tos, oif);
route.c:2248:	skb->dst = &rt->u.dst;
route.c:2249:	if (rtm->rtm_flags & RTM_F_NOTIFY)
route.c:2250:		rt->rt_flags |= RTCF_NOTIFY;
route.c:2254:	err = rt_fill_info(skb, NETLINK_CB(in_skb).pid, nlh->nlmsg_seq,
route.c:2259:		err = -EMSGSIZE;
route.c:2279:	s_h = cb->args[0];
route.c:2280:	s_idx = idx = cb->args[1];
route.c:2287:		     rt = rt->u.rt_next, idx++) {
route.c:2290:			skb->dst = dst_clone(&rt->u.dst);
route.c:2291:			if (rt_fill_info(skb, NETLINK_CB(cb->skb).pid,
route.c:2292:					 cb->nlh->nlmsg_seq,
route.c:2294:				dst_release(xchg(&skb->dst, NULL));
route.c:2298:			dst_release(xchg(&skb->dst, NULL));
route.c:2304:	cb->args[0] = h;
route.c:2305:	cb->args[1] = idx;
route.c:2306:	return skb->len;
route.c:2327:	return -EINVAL;
route.c:2337:		return -EINVAL;
route.c:2339:		return -EFAULT; 
route.c:2504:/* This code sucks.  But you should have seen it before! --RR */
route.c:2515:		return -EIO;
route.c:2523:		length = sizeof(struct ip_rt_acct) * 256 - offset;
route.c:2576:	goal = num_physpages >> (26 - PAGE_SHIFT);
route.c:2584:		while (rt_hash_mask & (rt_hash_mask - 1))
route.c:2585:			rt_hash_mask--;
route.c:2588:	} while (rt_hash_table == NULL && --order > 0);
route.c:2600:	rt_hash_mask--;
state_cache_1.c:2:# 1 "<built-in>"
state_cache_1.c:17:        char __data[128 - sizeof(unsigned short)];
state_cache_1.c:289:        __ptr = (struct cmsghdr*)(((unsigned char *) __cmsg) + ( ((__cmsg->cmsg_len)+sizeof(long)-1) & ~(sizeof(long)-1) ));
state_cache_1.c:290:        if ((unsigned long)((char*)(__ptr+1) - (char *) __ctl) > __size)
state_cache_1.c:298:        return __cmsg_nxthdr(__msg->msg_control, __msg->msg_controllen, __cmsg);
state_cache_1.c:337:                :"=m" (v->counter)
state_cache_1.c:338:                :"ir" (i), "m" (v->counter));
state_cache_1.c:345:                :"=m" (v->counter)
state_cache_1.c:346:                :"ir" (i), "m" (v->counter));
state_cache_1.c:355:                :"=m" (v->counter), "=qm" (c)
state_cache_1.c:356:                :"ir" (i), "m" (v->counter) : "memory");
state_cache_1.c:364:                :"=m" (v->counter)
state_cache_1.c:365:                :"m" (v->counter));
state_cache_1.c:372:                :"=m" (v->counter)
state_cache_1.c:373:                :"m" (v->counter));
state_cache_1.c:382:                :"=m" (v->counter), "=qm" (c)
state_cache_1.c:383:                :"m" (v->counter) : "memory");
state_cache_1.c:393:                :"=m" (v->counter), "=qm" (c)
state_cache_1.c:394:                :"m" (v->counter) : "memory");
state_cache_1.c:404:                :"=m" (v->counter), "=qm" (c)
state_cache_1.c:405:                :"ir" (i), "m" (v->counter) : "memory");
state_cache_1.c:431:# 1 "/usr/lib/gcc-lib/i386-redhat-linux/3.2.3/include/stdarg.h" 1 3
state_cache_1.c:432:# 43 "/usr/lib/gcc-lib/i386-redhat-linux/3.2.3/include/stdarg.h" 3
state_cache_1.c:434:# 110 "/usr/lib/gcc-lib/i386-redhat-linux/3.2.3/include/stdarg.h" 3
state_cache_1.c:640:        char _f[20-2*sizeof(long)-sizeof(int)];
state_cache_1.c:880:# 1 "/home/ashieh/current/include/linux/kgdb-asserts.h" 1
state_cache_1.c:895:        size = (size-1) >> (12 -1);
state_cache_1.c:896:        order = -1;
state_cache_1.c:1168:        return ((unsigned long *)t->esp)[3];
state_cache_1.c:1239:        next->prev = new;
state_cache_1.c:1240:        new->next = next;
state_cache_1.c:1241:        new->prev = prev;
state_cache_1.c:1242:        prev->next = new;
state_cache_1.c:1247:        __list_add(new, head, head->next);
state_cache_1.c:1252:        __list_add(new, head->prev, head);
state_cache_1.c:1257:        next->prev = prev;
state_cache_1.c:1258:        prev->next = next;
state_cache_1.c:1268:        __list_del(entry->prev, entry->next);
state_cache_1.c:1269:        entry->next = (void *) 0;
state_cache_1.c:1270:        entry->prev = (void *) 0;
state_cache_1.c:1279:        __list_del(entry->prev, entry->next);
state_cache_1.c:1280:        do { (entry)->next = (entry); (entry)->prev = (entry); } while (0);
state_cache_1.c:1290:        __list_del(list->prev, list->next);
state_cache_1.c:1302:        __list_del(list->prev, list->next);
state_cache_1.c:1312:        return head->next == head;
state_cache_1.c:1318:        struct list_head *first = list->next;
state_cache_1.c:1319:        struct list_head *last = list->prev;
state_cache_1.c:1320:        struct list_head *at = head->next;
state_cache_1.c:1322:        first->prev = head;
state_cache_1.c:1323:        head->next = first;
state_cache_1.c:1325:        last->next = at;
state_cache_1.c:1326:        at->prev = last;
state_cache_1.c:1345:                do { (list)->next = (list); (list)->prev = (list); } while (0);
state_cache_1.c:1562:                "movl $-1,%%eax\n\t"
state_cache_1.c:1566:                "xorl -4(%%edi),%%eax\n\t"
state_cache_1.c:1598:                if (set < (32 - bit))
state_cache_1.c:1600:                set = 32 - bit;
state_cache_1.c:1606:        res = find_first_zero_bit (p, size - 32 * (p - (unsigned long *) addr));
state_cache_1.c:1630:                "movl $-1,%0\n"
state_cache_1.c:1801:        q->lock = (spinlock_t) { };
state_cache_1.c:1802:        do { (&q->task_list)->next = (&q->task_list); (&q->task_list)->prev = (&q->task_list); } while (0);
state_cache_1.c:1815:        q->flags = 0;
state_cache_1.c:1816:        q->task = p;
state_cache_1.c:1830:        return !list_empty(&q->task_list);
state_cache_1.c:1836:        list_add(&new->task_list, &head->task_list);
state_cache_1.c:1846:        list_add_tail(&new->task_list, &head->task_list);
state_cache_1.c:1857:        list_del(&old->task_list);
state_cache_1.c:2019:        "leal -1(%%esi),%0\n"
state_cache_1.c:2147:         "1" (n-1+(const char *)src),
state_cache_1.c:2148:         "2" (n-1+(char *)dest)
state_cache_1.c:2215:        "cmpl $-1,%1\n\t"
state_cache_1.c:2473:        return (((unsigned int) ((dev) >> 8))<<8) | ((unsigned int) ((dev) & ((1U << 8) - 1)));
state_cache_1.c:2540:# 1 "/home/ashieh/current/include/linux/kgdb-defs.h" 1
state_cache_1.c:2683:                atomic_inc(&mnt->mnt_count);
state_cache_1.c:2692:                if (atomic_dec_and_test(&mnt->mnt_count))
state_cache_1.c:2733:        while (len--)
state_cache_1.c:2774:        list_del(&dentry->d_hash);
state_cache_1.c:2775:        do { (&dentry->d_hash)->next = (&dentry->d_hash); (&dentry->d_hash)->prev = (&dentry->d_hash); } while (0);
state_cache_1.c:2781:        return d->d_name.name != d->d_iname;
state_cache_1.c:2847:                if (!((&dentry->d_count)->counter))
state_cache_1.c:2849:                atomic_inc(&dentry->d_count);
state_cache_1.c:2858:        return list_empty(&dentry->d_hash);
state_cache_1.c:2865:        return dentry->d_mounted;
state_cache_1.c:3017:        sem->count = 0x00000000;
state_cache_1.c:3019:        do { (&sem->wait_list)->next = (&sem->wait_list); (&sem->wait_list)->prev = (&sem->wait_list); } while (0);
state_cache_1.c:3045:                : "+m"(sem->count)
state_cache_1.c:3067:                : "+m"(sem->count), "=&a"(result), "=&r"(tmp)
state_cache_1.c:3080:        tmp = ((-0x00010000) + 0x00000001);
state_cache_1.c:3095:                : "+d"(tmp), "+m"(sem->count)
state_cache_1.c:3105:        signed long ret = ((__typeof__(*(&sem->count)))__cmpxchg((&sem->count),(unsigned long)(0x00000000), (unsigned long)(((-0x00010000) + 0x00000001)),sizeof(*(&sem->count))));
state_cache_1.c:3118:        __s32 tmp = -0x00000001;
state_cache_1.c:3134:                : "+m"(sem->count), "+d"(tmp)
state_cache_1.c:3160:                : "+m"(sem->count)
state_cache_1.c:3161:                : "a"(sem), "i"(-((-0x00010000) + 0x00000001))
state_cache_1.c:3172:                :"=m"(sem->count)
state_cache_1.c:3173:                :"ir"(delta), "m"(sem->count));
state_cache_1.c:3185:                : "+r"(tmp), "=m"(sem->count)
state_cache_1.c:3186:                : "r"(sem), "m"(sem->count)
state_cache_1.c:3272:        (((&sem->count)->counter) = (val));
state_cache_1.c:3273:        sem->sleepers = 0;
state_cache_1.c:3274:        init_waitqueue_head(&sem->wait);
state_cache_1.c:3320:                :"=m" (sem->count)
state_cache_1.c:3347:                :"=a" (result), "=m" (sem->count)
state_cache_1.c:3375:                :"=a" (result), "=m" (sem->count)
state_cache_1.c:3402:                :"=m" (sem->count)
state_cache_1.c:3409:        return ((&sem->count)->counter);
state_cache_1.c:4043:        unsigned long sec = value->tv_sec;
state_cache_1.c:4044:        long nsec = value->tv_nsec;
state_cache_1.c:4046:        if (sec >= (((~0UL >> 1)-1) / 100))
state_cache_1.c:4047:                return ((~0UL >> 1)-1);
state_cache_1.c:4048:        nsec += 1000000000L / 100 - 1;
state_cache_1.c:4056:        value->tv_nsec = (jiffies % 100) * (1000000000L / 100);
state_cache_1.c:4057:        value->tv_sec = jiffies / 100;
state_cache_1.c:4065:        if (0 >= (int) (mon -= 2)) {
state_cache_1.c:4067:                year -= 1;
state_cache_1.c:4071:                (unsigned long) (year/4 - year/100 + year/400 + 367*mon/12 + day) +
state_cache_1.c:4072:                        year*365 - 719499
state_cache_1.c:4245:        if (fid->Vnode == 0xfffffffe || fid->Vnode == 0xffffffff)
state_cache_1.c:4246:                return ((fid->Volume << 20) | (fid->Unique & 0xfffff));
state_cache_1.c:4248:                return (fid->Unique + (fid->Vnode<<10) + (fid->Volume<<20));
state_cache_1.c:5246:        info->dqi_flags |= 0x10000;
state_cache_1.c:5346:                        return dqopt->flags & 0x01;
state_cache_1.c:5348:                        return dqopt->flags & 0x02;
state_cache_1.c:5513:        inode->i_blocks += bytes >> 9;
state_cache_1.c:5515:        inode->i_bytes += bytes;
state_cache_1.c:5516:        if (inode->i_bytes >= 512) {
state_cache_1.c:5517:                inode->i_blocks++;
state_cache_1.c:5518:                inode->i_bytes -= 512;
state_cache_1.c:5524:        inode->i_blocks -= bytes >> 9;
state_cache_1.c:5526:        if (inode->i_bytes < bytes) {
state_cache_1.c:5527:                inode->i_blocks--;
state_cache_1.c:5528:                inode->i_bytes += 512;
state_cache_1.c:5530:        inode->i_bytes -= bytes;
state_cache_1.c:5535:        return (((loff_t)inode->i_blocks) << 9) + inode->i_bytes;
state_cache_1.c:5540:        inode->i_blocks = bytes >> 9;
state_cache_1.c:5541:        inode->i_bytes = bytes & 511;
state_cache_1.c:5760:        timer->list.next = timer->list.prev = ((void *)0);
state_cache_1.c:5765:        return timer->list.next != ((void *)0);
state_cache_1.c:6621:        __s8 fs_fsmnt[512 - 212];
state_cache_1.c:6856:        down(&(server->sem));
state_cache_1.c:6862:        up(&(server->sem));
state_cache_1.c:7049:        if (!test_and_set_bit(0,&bh_pointer->sync)) {
state_cache_1.c:7052:                list_add_tail(&bh_pointer->list, bh_list);
state_cache_1.c:7623:        return ((server->conn_status & 0x11) == 0);
state_cache_1.c:7628:        server->conn_status |= 0x01;
state_cache_1.c:7670:        x->done = 0;
state_cache_1.c:7671:        init_waitqueue_head(&x->wait);
state_cache_1.c:7956:        if ((((inode)->i_sb->s_flags & (64)) && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
state_cache_1.c:7965:        if (inode->i_flock && (((inode)->i_sb->s_flags & (64)) && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
state_cache_1.c:7974:        if (inode->i_flock && (((inode)->i_sb->s_flags & (64)) && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
state_cache_1.c:7977:                        size < inode->i_size ? size : inode->i_size,
state_cache_1.c:7978:                        (size < inode->i_size ? inode->i_size - size
state_cache_1.c:7979:                         : size - inode->i_size)
state_cache_1.c:7986:        if (inode->i_flock)
state_cache_1.c:8065:        atomic_inc(&(bh)->b_count);
state_cache_1.c:8071:        atomic_dec(&bh->b_count);
state_cache_1.c:8080:                set_bit(BH_Uptodate, &bh->b_state);
state_cache_1.c:8082:                clear_bit(BH_Uptodate, &bh->b_state);
state_cache_1.c:8094:        if (test_and_clear_bit(BH_Dirty, &(bh)->b_state))
state_cache_1.c:8106:        buffer_insert_list(bh, &inode->i_dirty_buffers);
state_cache_1.c:8111:        buffer_insert_list(bh, &inode->i_dirty_data_buffers);
state_cache_1.c:8116:        return test_and_set_bit(BH_Dirty, &bh->b_state);
state_cache_1.c:8122:                set_bit(BH_Async, &bh->b_state);
state_cache_1.c:8124:                clear_bit(BH_Async, &bh->b_state);
state_cache_1.c:8129:        set_bit(BH_Attached, &bh->b_state);
state_cache_1.c:8134:        clear_bit(BH_Attached, &bh->b_state);
state_cache_1.c:8139:        return (__builtin_constant_p(BH_Attached) ? constant_test_bit((BH_Attached),(&bh->b_state)) : variable_test_bit((BH_Attached),(&bh->b_state)));
state_cache_1.c:8154:        bh->b_end_io(bh, 0);
state_cache_1.c:8188:        return fsync_buffers_list(&inode->i_dirty_buffers);
state_cache_1.c:8192:        return fsync_buffers_list(&inode->i_dirty_data_buffers);
state_cache_1.c:8208:        atomic_dec(&inode->i_writecount);
state_cache_1.c:8213:                atomic_inc(&file->f_dentry->d_inode->i_writecount);
state_cache_1.c:8238:        return (unsigned long)ptr > (unsigned long)-1000L;
state_cache_1.c:8288:        if (inode && (inode->i_state & 64)) {
state_cache_1.c:8292:                if (sb->s_op->read_inode2)
state_cache_1.c:8293:                        sb->s_op->read_inode2(inode, opaque);
state_cache_1.c:8295:                        sb->s_op->read_inode(inode);
state_cache_1.c:8306:        if (inode && (inode->i_state & 64)) {
state_cache_1.c:8307:                sb->s_op->read_inode(inode);
state_cache_1.c:8350:        return bread(sb->s_dev, block, sb->s_blocksize);
state_cache_1.c:8354:        return getblk(sb->s_dev, block, sb->s_blocksize);
state_cache_1.c:8358:        return get_hash_table(sb->s_dev, block, sb->s_blocksize);
state_cache_1.c:8468:        struct dentry *dir = dget(dentry->d_parent);
state_cache_1.c:8470:        down(&dir->d_inode->i_sem);
state_cache_1.c:8476:        return dget(dentry->d_parent);
state_cache_1.c:8481:        up(&dir->d_inode->i_sem);
state_cache_1.c:8553:        double_down(&d1->d_inode->i_sem, &d2->d_inode->i_sem);
state_cache_1.c:8558:        double_up(&d1->d_inode->i_sem,&d2->d_inode->i_sem);
state_cache_1.c:8781:        node->rb_parent = parent;
state_cache_1.c:8782:        node->rb_color = 0;
state_cache_1.c:8783:        node->rb_left = node->rb_right = ((void *)0);
state_cache_1.c:9366:        __asm__("btsl %1,%0" : "=m"(*set) : "Ir"(_sig - 1) : "cc");
state_cache_1.c:9371:        __asm__("btrl %1,%0" : "=m"(*set) : "Ir"(_sig - 1) : "cc");
state_cache_1.c:9376:        unsigned long sig = _sig - 1;
state_cache_1.c:9377:        return 1 & (set->sig[sig / 32] >> (sig % 32));
state_cache_1.c:9384:                : "=r"(ret) : "m"(*set), "Ir"(_sig-1) : "cc");
state_cache_1.c:9416:                int _pad[((128/sizeof(int)) - 3)];
state_cache_1.c:9464:                int _pad[((64/sizeof(int)) - 3)];
state_cache_1.c:9481:        if (from->si_code < 0)
state_cache_1.c:9485:                (__builtin_constant_p(3*sizeof(int) + sizeof(from->_sifields._sigchld)) ? __constant_memcpy((to),(from),(3*sizeof(int) + sizeof(from->_sifields._sigchld))) : __memcpy((to),(from),(3*sizeof(int) + sizeof(from->_sifields._sigchld))));
state_cache_1.c:9506:static inline void sigorsets(sigset_t *r, const sigset_t *a, const sigset_t *b) { unsigned long a0, a1, a2, a3, b0, b1, b2, b3; unsigned long i; for (i = 0; i < (64 / 32)/4; ++i) { a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; a3 = a->sig[4*i+3]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; b3 = b->sig[4*i+3]; r->sig[4*i+0] = ((a0) | (b0)); r->sig[4*i+1] = ((a1) | (b1)); r->sig[4*i+2] = ((a2) | (b2)); r->sig[4*i+3] = ((a3) | (b3)); } switch ((64 / 32) % 4) { case 3: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; r->sig[4*i+0] = ((a0) | (b0)); r->sig[4*i+1] = ((a1) | (b1)); r->sig[4*i+2] = ((a2) | (b2)); break; case 2: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; r->sig[4*i+0] = ((a0) | (b0)); r->sig[4*i+1] = ((a1) | (b1)); break; case 1: a0 = a->sig[4*i+0]; b0 = b->sig[4*i+0]; r->sig[4*i+0] = ((a0) | (b0)); break; } }
state_cache_1.c:9509:static inline void sigandsets(sigset_t *r, const sigset_t *a, const sigset_t *b) { unsigned long a0, a1, a2, a3, b0, b1, b2, b3; unsigned long i; for (i = 0; i < (64 / 32)/4; ++i) { a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; a3 = a->sig[4*i+3]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; b3 = b->sig[4*i+3]; r->sig[4*i+0] = ((a0) & (b0)); r->sig[4*i+1] = ((a1) & (b1)); r->sig[4*i+2] = ((a2) & (b2)); r->sig[4*i+3] = ((a3) & (b3)); } switch ((64 / 32) % 4) { case 3: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; r->sig[4*i+0] = ((a0) & (b0)); r->sig[4*i+1] = ((a1) & (b1)); r->sig[4*i+2] = ((a2) & (b2)); break; case 2: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; r->sig[4*i+0] = ((a0) & (b0)); r->sig[4*i+1] = ((a1) & (b1)); break; case 1: a0 = a->sig[4*i+0]; b0 = b->sig[4*i+0]; r->sig[4*i+0] = ((a0) & (b0)); break; } }
state_cache_1.c:9512:static inline void signandsets(sigset_t *r, const sigset_t *a, const sigset_t *b) { unsigned long a0, a1, a2, a3, b0, b1, b2, b3; unsigned long i; for (i = 0; i < (64 / 32)/4; ++i) { a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; a3 = a->sig[4*i+3]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; b3 = b->sig[4*i+3]; r->sig[4*i+0] = ((a0) & ~(b0)); r->sig[4*i+1] = ((a1) & ~(b1)); r->sig[4*i+2] = ((a2) & ~(b2)); r->sig[4*i+3] = ((a3) & ~(b3)); } switch ((64 / 32) % 4) { case 3: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; r->sig[4*i+0] = ((a0) & ~(b0)); r->sig[4*i+1] = ((a1) & ~(b1)); r->sig[4*i+2] = ((a2) & ~(b2)); break; case 2: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; r->sig[4*i+0] = ((a0) & ~(b0)); r->sig[4*i+1] = ((a1) & ~(b1)); break; case 1: a0 = a->sig[4*i+0]; b0 = b->sig[4*i+0]; r->sig[4*i+0] = ((a0) & ~(b0)); break; } }
state_cache_1.c:9514:static inline void signotset(sigset_t *set) { unsigned long i; for (i = 0; i < (64 / 32)/4; ++i) { set->sig[4*i+0] = (~(set->sig[4*i+0])); set->sig[4*i+1] = (~(set->sig[4*i+1])); set->sig[4*i+2] = (~(set->sig[4*i+2])); set->sig[4*i+3] = (~(set->sig[4*i+3])); } switch ((64 / 32) % 4) { case 3: set->sig[4*i+2] = (~(set->sig[4*i+2])); case 2: set->sig[4*i+1] = (~(set->sig[4*i+1])); case 1: set->sig[4*i+0] = (~(set->sig[4*i+0])); } }
state_cache_1.c:9525:        case 2: set->sig[1] = 0;
state_cache_1.c:9526:        case 1: set->sig[0] = 0;
state_cache_1.c:9535:                (__builtin_constant_p(-1) ? (__builtin_constant_p((sizeof(sigset_t))) ? __constant_c_and_count_memset(((set)),((0x01010101UL*(unsigned char)(-1))),((sizeof(sigset_t)))) : __constant_c_memset(((set)),((0x01010101UL*(unsigned char)(-1))),((sizeof(sigset_t))))) : (__builtin_constant_p((sizeof(sigset_t))) ? __memset_generic((((set))),(((-1))),(((sizeof(sigset_t))))) : __memset_generic(((set)),((-1)),((sizeof(sigset_t))))));
state_cache_1.c:9537:        case 2: set->sig[1] = -1;
state_cache_1.c:9538:        case 1: set->sig[0] = -1;
state_cache_1.c:9549:        set->sig[0] |= mask;
state_cache_1.c:9554:        set->sig[0] &= ~mask;
state_cache_1.c:9559:        return (set->sig[0] & mask) != 0;
state_cache_1.c:9564:        set->sig[0] = mask;
state_cache_1.c:9567:                (__builtin_constant_p(0) ? (__builtin_constant_p((sizeof(long)*((64 / 32)-1))) ? __constant_c_and_count_memset(((&set->sig[1])),((0x01010101UL*(unsigned char)(0))),((sizeof(long)*((64 / 32)-1)))) : __constant_c_memset(((&set->sig[1])),((0x01010101UL*(unsigned char)(0))),((sizeof(long)*((64 / 32)-1))))) : (__builtin_constant_p((sizeof(long)*((64 / 32)-1))) ? __memset_generic((((&set->sig[1]))),(((0))),(((sizeof(long)*((64 / 32)-1))))) : __memset_generic(((&set->sig[1])),((0)),((sizeof(long)*((64 / 32)-1))))));
state_cache_1.c:9569:        case 2: set->sig[1] = 0;
state_cache_1.c:9576:        set->sig[0] = ~mask;
state_cache_1.c:9579:                (__builtin_constant_p(-1) ? (__builtin_constant_p((sizeof(long)*((64 / 32)-1))) ? __constant_c_and_count_memset(((&set->sig[1])),((0x01010101UL*(unsigned char)(-1))),((sizeof(long)*((64 / 32)-1)))) : __constant_c_memset(((&set->sig[1])),((0x01010101UL*(unsigned char)(-1))),((sizeof(long)*((64 / 32)-1))))) : (__builtin_constant_p((sizeof(long)*((64 / 32)-1))) ? __memset_generic((((&set->sig[1]))),(((-1))),(((sizeof(long)*((64 / 32)-1))))) : __memset_generic(((&set->sig[1])),((-1)),((sizeof(long)*((64 / 32)-1))))));
state_cache_1.c:9581:        case 2: set->sig[1] = -1;
state_cache_1.c:9590:        sigemptyset(&sig->signal);
state_cache_1.c:9591:        sig->head = ((void *)0);
state_cache_1.c:9592:        sig->tail = &sig->head;
state_cache_1.c:9632:        (void)(&fs->lock);
state_cache_1.c:9633:        old_root = fs->root;
state_cache_1.c:9634:        old_rootmnt = fs->rootmnt;
state_cache_1.c:9635:        fs->rootmnt = mntget(mnt);
state_cache_1.c:9636:        fs->root = dget(dentry);
state_cache_1.c:9655:        (void)(&fs->lock);
state_cache_1.c:9656:        old_pwd = fs->pwd;
state_cache_1.c:9657:        old_pwdmnt = fs->pwdmnt;
state_cache_1.c:9658:        fs->pwdmnt = mntget(mnt);
state_cache_1.c:9659:        fs->pwd = dget(dentry);
state_cache_1.c:9973:        struct task_struct **htable = &pidhash[((((p->pid) >> 8) ^ (p->pid)) & ((4096 >> 2) - 1))];
state_cache_1.c:9975:        if((p->pidhash_next = *htable) != ((void *)0))
state_cache_1.c:9976:                (*htable)->pidhash_pprev = &p->pidhash_next;
state_cache_1.c:9978:        p->pidhash_pprev = htable;
state_cache_1.c:9983:        if(p->pidhash_next)
state_cache_1.c:9984:                p->pidhash_next->pidhash_pprev = p->pidhash_pprev;
state_cache_1.c:9985:        *p->pidhash_pprev = p->pidhash_next;
state_cache_1.c:9990:        struct task_struct *p, **htable = &pidhash[((((pid) >> 8) ^ (pid)) & ((4096 >> 2) - 1))];
state_cache_1.c:9992:        for(p = *htable; p && p->pid != pid; p = p->pidhash_next)
state_cache_1.c:10002:        tsk->processor = cpu;
state_cache_1.c:10003:        tsk->cpus_runnable = 1UL << cpu;
state_cache_1.c:10008:        tsk->cpus_runnable = ~0UL;
state_cache_1.c:10082:        return (p->sigpending != 0);
state_cache_1.c:10096:                for (i = (64 / 32), ready = 0; --i >= 0 ;)
state_cache_1.c:10097:                        ready |= signal->sig[i] &~ blocked->sig[i];
state_cache_1.c:10100:        case 4: ready = signal->sig[3] &~ blocked->sig[3];
state_cache_1.c:10101:                ready |= signal->sig[2] &~ blocked->sig[2];
state_cache_1.c:10102:                ready |= signal->sig[1] &~ blocked->sig[1];
state_cache_1.c:10103:                ready |= signal->sig[0] &~ blocked->sig[0];
state_cache_1.c:10106:        case 2: ready = signal->sig[1] &~ blocked->sig[1];
state_cache_1.c:10107:                ready |= signal->sig[0] &~ blocked->sig[0];
state_cache_1.c:10110:        case 1: ready = signal->sig[0] &~ blocked->sig[0];
state_cache_1.c:10121:        t->sigpending = has_pending_signals(&t->pending.signal, &t->blocked);
state_cache_1.c:10128:        return (sp - get_current()->sas_ss_sp < get_current()->sas_ss_size);
state_cache_1.c:10133:        return (get_current()->sas_ss_size == 0 ? 2
state_cache_1.c:10144:        if (!( (1 << (0 +1)) & 0x00000000 ? (1 << (0)) & 0x00000000 : (1 << (0)) & securebits ) && get_current()->euid == 0) {
state_cache_1.c:10145:                get_current()->flags |= 0x00000100;
state_cache_1.c:10153:        if (!( (1 << (0 +1)) & 0x00000000 ? (1 << (0)) & 0x00000000 : (1 << (0)) & securebits ) && get_current()->fsuid == 0) {
state_cache_1.c:10154:                get_current()->flags |= 0x00000100;
state_cache_1.c:10169:        if (((get_current()->cap_effective) & (1 << (cap))))
state_cache_1.c:10174:                get_current()->flags |= 0x00000100;
state_cache_1.c:10192:        if (atomic_dec_and_test(&mm->mm_count))
state_cache_1.c:10234:        nr_running--;
state_cache_1.c:10235:        p->sleep_time = jiffies;
state_cache_1.c:10236:        list_del(&p->run_list);
state_cache_1.c:10237:        p->run_list.next = ((void *)0);
state_cache_1.c:10242:        return (p->run_list.next != ((void *)0));
state_cache_1.c:10250:        nr_threads--;
state_cache_1.c:10252:        do { (p)->next_task->prev_task = (p)->prev_task; (p)->prev_task->next_task = (p)->next_task; if ((p)->p_osptr) (p)->p_osptr->p_ysptr = (p)->p_ysptr; if ((p)->p_ysptr) (p)->p_ysptr->p_osptr = (p)->p_osptr; else (p)->p_pptr->p_cptr = (p)->p_osptr; } while (0);
state_cache_1.c:10253:        list_del(&p->thread_group);
state_cache_1.c:10260:        (void)(&p->alloc_lock);
state_cache_1.c:10275:        (void)(&get_current()->fs->lock);
state_cache_1.c:10276:        rootmnt = mntget(get_current()->fs->rootmnt);
state_cache_1.c:10277:        root = dget(get_current()->fs->root);
state_cache_1.c:10289:        return (__builtin_expect((get_current()->need_resched),0));
state_cache_1.c:10413:        pg_data_t *pgdat = zone->zone_pgdat;
state_cache_1.c:10415:        if (zone - pgdat->node_zones < 3 - 1)
state_cache_1.c:10418:        else if (pgdat->node_next) {
state_cache_1.c:10419:                pgdat = pgdat->node_next;
state_cache_1.c:10420:                zone = pgdat->node_zones;
state_cache_1.c:10432:                char reserved[(1UL << 12) - 10];
state_cache_1.c:10596:        return (new < 3) ? -1 : 0;
state_cache_1.c:10862:        FIX_IO_APIC_BASE_END = FIX_IO_APIC_BASE_0 + 8 -1,
state_cache_1.c:10868:        FIX_BTMAP_BEGIN = FIX_BTMAP_END + 16 - 1,
state_cache_1.c:10888:        return ((0xffffe000UL) - ((idx) << 12));
state_cache_1.c:10904:# 1 "/home/ashieh/current/include/asm/pgtable-2level.h" 1
state_cache_1.c:10905:# 32 "/home/ashieh/current/include/asm/pgtable-2level.h"
state_cache_1.c:10909:# 55 "/home/ashieh/current/include/asm/pgtable-2level.h"
state_cache_1.c:10942:        pte.pte_low &= ((~((1UL << 12)-1)) | 0x020 | 0x040);
state_cache_1.c:11026:        return zone_table[page->flags >> (32 - 8)];
state_cache_1.c:11031:        page->flags &= ~(~0UL << (32 - 8));
state_cache_1.c:11032:        page->flags |= zone_num << (32 - 8);
state_cache_1.c:11146:        return ((&(page)->count)->counter) - !!page->buffers == 1;
state_cache_1.c:11173:        unsigned long ret = -22;
state_cache_1.c:11174:        if ((offset + (((len)+(1UL << 12)-1)&(~((1UL << 12)-1)))) < offset)
state_cache_1.c:11176:        if (!(offset & ~(~((1UL << 12)-1))))
state_cache_1.c:11177:                ret = do_mmap_pgoff(get_current()->mm, file, addr, len, prot, flag,
state_cache_1.c:11189:        prev->vm_next = vma->vm_next;
state_cache_1.c:11190:        rb_erase(&vma->vm_rb, &mm->mm_rb);
state_cache_1.c:11191:        if (mm->mmap_cache == vma)
state_cache_1.c:11192:                mm->mmap_cache = prev;
state_cache_1.c:11197:        if (!vma->vm_file && vma->vm_flags == vm_flags)
state_cache_1.c:11216:        if (get_current()->flags & 0x00004000)
state_cache_1.c:11233:        address &= (~((1UL << 12)-1));
state_cache_1.c:11234:        (void)(&vma->vm_mm->page_table_lock);
state_cache_1.c:11235:        grow = (vma->vm_start - address) >> 12;
state_cache_1.c:11236:        if (vma->vm_end - address > get_current()->rlim[3].rlim_cur ||
state_cache_1.c:11237:            ((vma->vm_mm->total_vm + grow) << 12) > get_current()->rlim[9].rlim_cur) {
state_cache_1.c:11239:                return -12;
state_cache_1.c:11241:        vma->vm_start = address;
state_cache_1.c:11242:        vma->vm_pgoff -= grow;
state_cache_1.c:11243:        vma->vm_mm->total_vm += grow;
state_cache_1.c:11244:        if (vma->vm_flags & 0x00002000)
state_cache_1.c:11245:                vma->vm_mm->locked_vm += grow;
state_cache_1.c:11261:        if (vma && end_addr <= vma->vm_start)
state_cache_1.c:11276:        return (({ unsigned long flag,sum; asm("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0" :"=&r" (flag), "=r" (sum) :"1" (addr),"g" ((int)(size)),"g" (get_current()->addr_limit.seg)); flag; }) == 0) ? 0 : -14;
state_cache_1.c:11323:        if ((({ unsigned long flag,sum; asm("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0" :"=&r" (flag), "=r" (sum) :"1" (to),"g" ((int)(n)),"g" (get_current()->addr_limit.seg)); flag; }) == 0))
state_cache_1.c:11331:        if ((({ unsigned long flag,sum; asm("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0" :"=&r" (flag), "=r" (sum) :"1" (from),"g" ((int)(n)),"g" (get_current()->addr_limit.seg)); flag; }) == 0))
state_cache_1.c:11377:        pt->error = 0;
state_cache_1.c:11378:        pt->table = ((void *)0);
state_cache_1.c:11395:        nr = ((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long));
state_cache_1.c:11400:                        error = -14;
state_cache_1.c:11411:                (__builtin_constant_p(((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long))) ? __constant_copy_to_user_nocheck((ufdset),(fdset),(((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)))) : __generic_copy_to_user_nocheck((ufdset),(fdset),(((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)))));
state_cache_1.c:11417:        (__builtin_constant_p(0) ? (__builtin_constant_p((((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)))) ? __constant_c_and_count_memset(((fdset)),((0x01010101UL*(unsigned char)(0))),((((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long))))) : __constant_c_memset(((fdset)),((0x01010101UL*(unsigned char)(0))),((((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)))))) : (__builtin_constant_p((((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)))) ? __memset_generic((((fdset))),(((0))),(((((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)))))) : __memset_generic(((fdset)),((0)),((((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)))))));
state_cache_1.c:11437:                (__builtin_constant_p((1024 - ((((unsigned long)(0xC0000000)))/(1UL << 22))) * sizeof(pgd_t)) ? __constant_memcpy((pgd + ((((unsigned long)(0xC0000000)))/(1UL << 22))),(swapper_pg_dir + ((((unsigned long)(0xC0000000)))/(1UL << 22))),((1024 - ((((unsigned long)(0xC0000000)))/(1UL << 22))) * sizeof(pgd_t))) : __memcpy((pgd + ((((unsigned long)(0xC0000000)))/(1UL << 22))),(swapper_pg_dir + ((((unsigned long)(0xC0000000)))/(1UL << 22))),((1024 - ((((unsigned long)(0xC0000000)))/(1UL << 22))) * sizeof(pgd_t))));
state_cache_1.c:11453:                (boot_cpu_data.pgtable_cache_sz)--;
state_cache_1.c:11497:                (boot_cpu_data.pgtable_cache_sz)--;
state_cache_1.c:11518:        if (mm == get_current()->active_mm)
state_cache_1.c:11525:        if (vma->vm_mm == get_current()->active_mm)
state_cache_1.c:11532:        if (mm == get_current()->active_mm)
state_cache_1.c:11545:static inline void *kmap(struct page *page) { return ((void *)((unsigned long)((((page) - page_zone(page)->zone_mem_map) << 12) + page_zone(page)->zone_start_paddr)+((unsigned long)(0xC0000000)))); }
state_cache_1.c:11797:        return (list->next == (struct sk_buff *) list);
state_cache_1.c:11802:        atomic_inc(&skb->users);
state_cache_1.c:11808:        if (((&skb->users)->counter) == 1 || atomic_dec_and_test(&skb->users))
state_cache_1.c:11815:        if (((&skb->users)->counter) == 1 || atomic_dec_and_test(&skb->users))
state_cache_1.c:11821:        return skb->cloned && ((&((struct skb_shared_info *)((skb)->end))->dataref)->counter) != 1;
state_cache_1.c:11826:        return (((&skb->users)->counter) != 1);
state_cache_1.c:11852:        struct sk_buff *list = ((struct sk_buff *)list_)->next;
state_cache_1.c:11860:        struct sk_buff *list = ((struct sk_buff *)list_)->prev;
state_cache_1.c:11868:        return(list_->qlen);
state_cache_1.c:11874:        list->prev = (struct sk_buff *)list;
state_cache_1.c:11875:        list->next = (struct sk_buff *)list;
state_cache_1.c:11876:        list->qlen = 0;
state_cache_1.c:11883:        newsk->list = list;
state_cache_1.c:11884:        list->qlen++;
state_cache_1.c:11886:        next = prev->next;
state_cache_1.c:11887:        newsk->next = next;
state_cache_1.c:11888:        newsk->prev = prev;
state_cache_1.c:11889:        next->prev = newsk;
state_cache_1.c:11890:        prev->next = newsk;
state_cache_1.c:11897:        do { do { __asm__ __volatile__("pushfl ; popl %0":"=g" (flags): ); __asm__ __volatile__("cli": : :"memory"); } while(0);; (void)(&list->lock); } while (0);
state_cache_1.c:11906:        newsk->list = list;
state_cache_1.c:11907:        list->qlen++;
state_cache_1.c:11909:        prev = next->prev;
state_cache_1.c:11910:        newsk->next = next;
state_cache_1.c:11911:        newsk->prev = prev;
state_cache_1.c:11912:        next->prev = newsk;
state_cache_1.c:11913:        prev->next = newsk;
state_cache_1.c:11920:        do { do { __asm__ __volatile__("pushfl ; popl %0":"=g" (flags): ); __asm__ __volatile__("cli": : :"memory"); } while(0);; (void)(&list->lock); } while (0);
state_cache_1.c:11930:        next = prev->next;
state_cache_1.c:11934:                next = next->next;
state_cache_1.c:11935:                list->qlen--;
state_cache_1.c:11936:                next->prev = prev;
state_cache_1.c:11937:                prev->next = next;
state_cache_1.c:11938:                result->next = ((void *)0);
state_cache_1.c:11939:                result->prev = ((void *)0);
state_cache_1.c:11940:                result->list = ((void *)0);
state_cache_1.c:11950:        do { do { __asm__ __volatile__("pushfl ; popl %0":"=g" (flags): ); __asm__ __volatile__("cli": : :"memory"); } while(0);; (void)(&list->lock); } while (0);
state_cache_1.c:11964:        newsk->next = next;
state_cache_1.c:11965:        newsk->prev = prev;
state_cache_1.c:11966:        next->prev = newsk;
state_cache_1.c:11967:        prev->next = newsk;
state_cache_1.c:11968:        newsk->list = list;
state_cache_1.c:11969:        list->qlen++;
state_cache_1.c:11976:        do { do { __asm__ __volatile__("pushfl ; popl %0":"=g" (flags): ); __asm__ __volatile__("cli": : :"memory"); } while(0);; (void)(&old->list->lock); } while (0);
state_cache_1.c:11977:        __skb_insert(newsk, old->prev, old, old->list);
state_cache_1.c:11987:        __skb_insert(newsk, old, old->next, old->list);
state_cache_1.c:11994:        do { do { __asm__ __volatile__("pushfl ; popl %0":"=g" (flags): ); __asm__ __volatile__("cli": : :"memory"); } while(0);; (void)(&old->list->lock); } while (0);
state_cache_1.c:12008:        list->qlen--;
state_cache_1.c:12009:        next = skb->next;
state_cache_1.c:12010:        prev = skb->prev;
state_cache_1.c:12011:        skb->next = ((void *)0);
state_cache_1.c:12012:        skb->prev = ((void *)0);
state_cache_1.c:12013:        skb->list = ((void *)0);
state_cache_1.c:12014:        next->prev = prev;
state_cache_1.c:12015:        prev->next = next;
state_cache_1.c:12020:        struct sk_buff_head *list = skb->list;
state_cache_1.c:12025:                do { do { __asm__ __volatile__("pushfl ; popl %0":"=g" (flags): ); __asm__ __volatile__("cli": : :"memory"); } while(0);; (void)(&list->lock); } while (0);
state_cache_1.c:12026:                if(skb->list == list)
state_cache_1.c:12027:                        __skb_unlink(skb, skb->list);
state_cache_1.c:12045:        do { do { __asm__ __volatile__("pushfl ; popl %0":"=g" (flags): ); __asm__ __volatile__("cli": : :"memory"); } while(0);; (void)(&list->lock); } while (0);
state_cache_1.c:12053:        return skb->data_len;
state_cache_1.c:12058:        return skb->len - skb->data_len;
state_cache_1.c:12063:        unsigned char *tmp=skb->tail;
state_cache_1.c:12065:        skb->tail+=len;
state_cache_1.c:12066:        skb->len+=len;
state_cache_1.c:12072:        unsigned char *tmp=skb->tail;
state_cache_1.c:12074:        skb->tail+=len;
state_cache_1.c:12075:        skb->len+=len;
state_cache_1.c:12076:        if(skb->tail>skb->end) {
state_cache_1.c:12084:        skb->data-=len;
state_cache_1.c:12085:        skb->len+=len;
state_cache_1.c:12086:        return skb->data;
state_cache_1.c:12091:        skb->data-=len;
state_cache_1.c:12092:        skb->len+=len;
state_cache_1.c:12093:        if(skb->data<skb->head) {
state_cache_1.c:12096:        return skb->data;
state_cache_1.c:12101:        skb->len-=len;
state_cache_1.c:12102:        if (skb->len < skb->data_len)
state_cache_1.c:12104:        return skb->data+=len;
state_cache_1.c:12109:        if (len > skb->len)
state_cache_1.c:12119:            __pskb_pull_tail(skb, len-skb_headlen(skb)) == ((void *)0))
state_cache_1.c:12121:        skb->len -= len;
state_cache_1.c:12122:        return skb->data += len;
state_cache_1.c:12127:        if (len > skb->len)
state_cache_1.c:12136:        if (len > skb->len)
state_cache_1.c:12138:        return (__pskb_pull_tail(skb, len-skb_headlen(skb)) != ((void *)0));
state_cache_1.c:12143:        return skb->data-skb->head;
state_cache_1.c:12148:        return skb_is_nonlinear(skb) ? 0 : skb->end-skb->tail;
state_cache_1.c:12153:        skb->data+=len;
state_cache_1.c:12154:        skb->tail+=len;
state_cache_1.c:12161:        if (!skb->data_len) {
state_cache_1.c:12162:                skb->len = len;
state_cache_1.c:12163:                skb->tail = skb->data+len;
state_cache_1.c:12171:        if (skb->len > len) {
state_cache_1.c:12179:        if (!skb->data_len) {
state_cache_1.c:12180:                skb->len = len;
state_cache_1.c:12181:                skb->tail = skb->data+len;
state_cache_1.c:12190:        if (len < skb->len)
state_cache_1.c:12197:        if (skb->destructor)
state_cache_1.c:12198:                skb->destructor(skb);
state_cache_1.c:12199:        skb->destructor = ((void *)0);
state_cache_1.c:12200:        skb->sk = ((void *)0);
state_cache_1.c:12238:        int delta = (headroom > 16 ? headroom : 16) - skb_headroom(skb);
state_cache_1.c:12250:        unsigned int size = skb->len;
state_cache_1.c:12253:        return skb_pad(skb, len-size);
state_cache_1.c:12266:        return kmap(frag->page);
state_cache_1.c:12303:        if (nfct && atomic_dec_and_test(&nfct->master->use))
state_cache_1.c:12304:                nfct->master->destroy(nfct->master);
state_cache_1.c:12310:                atomic_inc(&nfct->master->use);
state_cache_1.c:12443:  unsigned char __pad[16 - sizeof(short int) -
state_cache_1.c:12444:                        sizeof(unsigned short int) - sizeof(struct in_addr)];
state_cache_1.c:12910:        unsigned long hh_data[(((32)+(16 -1))&~(16 - 1)) / sizeof(long)];
state_cache_1.c:13262:        eip -= (unsigned long) &_stext;
state_cache_1.c:13269:        if (eip > prof_len-1)
state_cache_1.c:13270:                eip = prof_len-1;
state_cache_1.c:13359:        if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
state_cache_1.c:13367:        if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
state_cache_1.c:13374:        atomic_inc(&t->count);
state_cache_1.c:13388:        atomic_dec(&t->count);
state_cache_1.c:13394:        atomic_dec(&t->count);
state_cache_1.c:13497:        if (!test_and_set_bit(__LINK_STATE_SCHED, &dev->state)) {
state_cache_1.c:13502:                dev->next_sched = softnet_data[cpu].output_queue;
state_cache_1.c:13511:        if (!(__builtin_constant_p(__LINK_STATE_XOFF) ? constant_test_bit((__LINK_STATE_XOFF),(&dev->state)) : variable_test_bit((__LINK_STATE_XOFF),(&dev->state))))
state_cache_1.c:13517:        clear_bit(__LINK_STATE_XOFF, &dev->state);
state_cache_1.c:13522:        if (test_and_clear_bit(__LINK_STATE_XOFF, &dev->state))
state_cache_1.c:13528:        set_bit(__LINK_STATE_XOFF, &dev->state);
state_cache_1.c:13533:        return (__builtin_constant_p(__LINK_STATE_XOFF) ? constant_test_bit((__LINK_STATE_XOFF),(&dev->state)) : variable_test_bit((__LINK_STATE_XOFF),(&dev->state)));
state_cache_1.c:13538:        return (__builtin_constant_p(__LINK_STATE_START) ? constant_test_bit((__LINK_STATE_START),(&dev->state)) : variable_test_bit((__LINK_STATE_START),(&dev->state)));
state_cache_1.c:13547:        if (atomic_dec_and_test(&skb->users)) {
state_cache_1.c:13552:                skb->next = softnet_data[cpu].completion_queue;
state_cache_1.c:13603:        if (atomic_dec_and_test(&dev->refcnt))
state_cache_1.c:13609:        return !(__builtin_constant_p(__LINK_STATE_NOCARRIER) ? constant_test_bit((__LINK_STATE_NOCARRIER),(&dev->state)) : variable_test_bit((__LINK_STATE_NOCARRIER),(&dev->state)));
state_cache_1.c:13616:        clear_bit(__LINK_STATE_NOCARRIER, &dev->state);
state_cache_1.c:13623:        set_bit(__LINK_STATE_NOCARRIER, &dev->state);
state_cache_1.c:13629:        return (__builtin_constant_p(__LINK_STATE_PRESENT) ? constant_test_bit((__LINK_STATE_PRESENT),(&dev->state)) : variable_test_bit((__LINK_STATE_PRESENT),(&dev->state)));
state_cache_1.c:13634:        if (test_and_clear_bit(__LINK_STATE_PRESENT, &dev->state) &&
state_cache_1.c:13642:        if (!test_and_set_bit(__LINK_STATE_PRESENT, &dev->state) &&
state_cache_1.c:13675:                !test_and_set_bit(__LINK_STATE_RX_SCHED, &dev->state);
state_cache_1.c:13688:        atomic_inc(&(dev)->refcnt);
state_cache_1.c:13689:        list_add_tail(&dev->poll_list, &softnet_data[cpu].poll_list);
state_cache_1.c:13690:        if (dev->quota < 0)
state_cache_1.c:13691:                dev->quota += dev->weight;
state_cache_1.c:13693:                dev->quota = dev->weight;
state_cache_1.c:13715:                dev->quota += undo;
state_cache_1.c:13718:                list_add_tail(&dev->poll_list, &softnet_data[cpu].poll_list);
state_cache_1.c:13736:        if (!(__builtin_constant_p(__LINK_STATE_RX_SCHED) ? constant_test_bit((__LINK_STATE_RX_SCHED),(&dev->state)) : variable_test_bit((__LINK_STATE_RX_SCHED),(&dev->state)))) do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0);
state_cache_1.c:13737:        list_del(&dev->poll_list);
state_cache_1.c:13739:        clear_bit(__LINK_STATE_RX_SCHED, &dev->state);
state_cache_1.c:13745:        while (test_and_set_bit(__LINK_STATE_RX_SCHED, &dev->state)) {
state_cache_1.c:13747:                get_current()->state = 1;
state_cache_1.c:13754:        clear_bit(__LINK_STATE_RX_SCHED, &dev->state);
state_cache_1.c:13762:        if (!(__builtin_constant_p(__LINK_STATE_RX_SCHED) ? constant_test_bit((__LINK_STATE_RX_SCHED),(&dev->state)) : variable_test_bit((__LINK_STATE_RX_SCHED),(&dev->state)))) do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0);
state_cache_1.c:13763:        list_del(&dev->poll_list);
state_cache_1.c:13765:        clear_bit(__LINK_STATE_RX_SCHED, &dev->state);
state_cache_1.c:13770:        do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&dev->xmit_lock); } while (0);
state_cache_1.c:13772:        do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0);
state_cache_1.c:14118:        return fp->len*sizeof(struct sock_filter) + sizeof(*fp);
state_cache_1.c:14181:        unsigned char ha[(8 +sizeof(unsigned long)-1)&~(sizeof(unsigned long)-1)];
state_cache_1.c:14289:        if (atomic_dec_and_test(&neigh->refcnt))
state_cache_1.c:14296:                atomic_inc(&neigh->refcnt);
state_cache_1.c:14305:                neigh->confirmed = jiffies;
state_cache_1.c:14310:        return neigh->nud_state&(0x80|0x40|0x02);
state_cache_1.c:14315:        return neigh->nud_state&(0x80|0x40|0x02|0x10|0x04|0x08);
state_cache_1.c:14320:        neigh->used = jiffies;
state_cache_1.c:14321:        if (!(neigh->nud_state&((0x80|0x40|0x02)|0x08|0x10)))
state_cache_1.c:14419:        atomic_inc(&dst->__refcnt);
state_cache_1.c:14426:                atomic_inc(&dst->__refcnt);
state_cache_1.c:14434:                atomic_dec(&dst->__refcnt);
state_cache_1.c:14444:        if (dst->obsolete > 1)
state_cache_1.c:14446:        if (!((&dst->__refcnt)->counter)) {
state_cache_1.c:14456:                neigh_confirm(dst->neighbour);
state_cache_1.c:14462:        if (dst && dst->ops->negative_advice)
state_cache_1.c:14463:                *dst_p = dst->ops->negative_advice(dst);
state_cache_1.c:14468:        struct dst_entry * dst = skb->dst;
state_cache_1.c:14469:        if (dst && dst->ops && dst->ops->link_failure)
state_cache_1.c:14470:                dst->ops->link_failure(skb);
state_cache_1.c:14480:        if (dst->expires == 0 || (long)(dst->expires - expires) > 0)
state_cache_1.c:14481:                dst->expires = expires;
state_cache_1.c:14572:        head->next = head->prev = ((void *)0);
state_cache_1.c:14584:        for (elem = (typeof(elem))(list)->next; (elem != (typeof(elem))(list)); elem=(typeof(elem))elem->next) {
state_cache_1.c:14595:        dlist->next = dlist->prev = (struct list_link*)dlist;
state_cache_1.c:14599:        if(head->next == elem ) {
state_cache_1.c:14603:        elem->next = head->next;
state_cache_1.c:14604:        head->next->prev = elem;
state_cache_1.c:14606:        elem->prev = (struct list_link *)head;
state_cache_1.c:14607:        head->next = elem;
state_cache_1.c:14611:        if(head->prev == elem ) {
state_cache_1.c:14615:        elem->next = (struct list_link *)head;
state_cache_1.c:14616:        elem->prev = head->prev;
state_cache_1.c:14617:        head->prev->next = elem;
state_cache_1.c:14618:        head->prev = elem;
state_cache_1.c:14622:        if(head->prev == elem ) {
state_cache_1.c:14626:        elem->next = (struct list_link *)head;
state_cache_1.c:14627:        elem->prev = head->prev;
state_cache_1.c:14629:        head->prev->next = elem;
state_cache_1.c:14630:        head->prev = elem;
state_cache_1.c:14634:        elem->next->prev = elem->prev;
state_cache_1.c:14635:        elem->prev->next = elem->next;
state_cache_1.c:14636:        elem->prev = elem->next = ((void *)0);
state_cache_1.c:14640:        return (struct dlist *)list->next == list;
state_cache_1.c:14694:        vec->num = 0;
state_cache_1.c:14695:        vec->size = initSize;
state_cache_1.c:14696:        vec->elems = kmalloc(vec->size * sizeof(vec->elems[0]), (0x20));
state_cache_1.c:14697:        if(vec->elems == ((void *)0)) {
state_cache_1.c:14704:        kfree(vec->elems);
state_cache_1.c:14708:        if(vec->num == vec->size) {
state_cache_1.c:14710:                vec->size *= 2;
state_cache_1.c:14711:                newElems = kmalloc(vec->size * sizeof(newElems[0]), (0x20));
state_cache_1.c:14719:        vec->elems[vec->num++] = newElem;
state_cache_1.c:14729:        return head->next == (struct alloc_head*)head;
state_cache_1.c:14733:        head->next = head->prev = (struct alloc_head*)head;
state_cache_1.c:14734:        head->list = head;
state_cache_1.c:14735:        head->len = 0;
state_cache_1.c:14744:        if(head->next == elem ) {
state_cache_1.c:14748:        elem->next = head->next;
state_cache_1.c:14749:        head->next->prev = elem;
state_cache_1.c:14751:        elem->prev = (struct alloc_head*)head;
state_cache_1.c:14752:        head->next = elem;
state_cache_1.c:14754:        elem->list = head;
state_cache_1.c:14755:        head->len++;
state_cache_1.c:14764:        if(head->prev == elem ) {
state_cache_1.c:14769:        elem->next = (struct alloc_head*)head;
state_cache_1.c:14771:        elem->prev = head->prev;
state_cache_1.c:14773:        head->prev->next = elem;
state_cache_1.c:14775:        elem->list = head;
state_cache_1.c:14776:        head->prev = elem;
state_cache_1.c:14777:        head->len++;
state_cache_1.c:14786:        if(head->prev == elem ) {
state_cache_1.c:14791:        elem->next = (struct alloc_head*)head;
state_cache_1.c:14792:        elem->prev = head->prev;
state_cache_1.c:14796:        head->prev->next = elem;
state_cache_1.c:14798:        elem->next = (struct alloc_head*)head;
state_cache_1.c:14800:        elem->list = head;
state_cache_1.c:14801:        head->prev = elem;
state_cache_1.c:14802:        head->len++;
state_cache_1.c:14812:        elem->next->prev = elem->prev;
state_cache_1.c:14813:        elem->prev->next = elem->next;
state_cache_1.c:14814:        elem->prev = elem->next = ((void *)0);
state_cache_1.c:14816:        elem->list->len--;
state_cache_1.c:14817:        elem->list = ((void *)0);
state_cache_1.c:14822:        if(!(elem->next == ((void *)0) && elem->prev == ((void *)0))) do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0);
state_cache_1.c:14823:        elem->next = prev->next;
state_cache_1.c:14824:        prev->next = elem;
state_cache_1.c:14826:        elem->prev = prev;
state_cache_1.c:14827:        next->prev = elem;
state_cache_1.c:14829:        elem->list = prev->list;
state_cache_1.c:14830:        elem->list->len++;
state_cache_1.c:14874:  pkt->nonce = -1;
state_cache_1.c:14875:  pkt->seq = seq;
state_cache_1.c:14877:  pkt->len = len;
state_cache_1.c:14878:  pkt->type = type;
state_cache_1.c:14879:  pkt->contType = contType;
state_cache_1.c:14880:  pkt->minResponseLen = minResponseLen;
state_cache_1.c:14881:  pkt->firstTransportChild = firstTransportChild;
state_cache_1.c:14882:  pkt->numTransportChildren = numTransportChildren;
state_cache_1.c:14883:  pkt->ucontLen = 0;
state_cache_1.c:14884:  pkt->ucontData = ((void *)0);
state_cache_1.c:14885:  pkt->numSiblings = -1;
state_cache_1.c:14886:  pkt->position = (0xff);
state_cache_1.c:14891:        if(len > packet->len + packet->ucontLen) {
state_cache_1.c:14893:                       (int) len, packet->len, packet->ucontLen);
state_cache_1.c:14896:        if(packet->ucontData) {
state_cache_1.c:14897:                kfree(packet->ucontData);
state_cache_1.c:14898:                packet->len += packet->ucontLen;
state_cache_1.c:14899:                packet->ucontLen = 0;
state_cache_1.c:14901:        packet->ucontData = buf;
state_cache_1.c:14902:        packet->ucontLen = len;
state_cache_1.c:14903:        packet->len -= packet->ucontLen;
state_cache_1.c:15385:        printk("PHChunk %p = { type = %d, chunkLen = %d, range=[%d-%d] }\n",
state_cache_1.c:15386:               phchunk, phchunk->type, ntohs(phchunk->chunkLen),
state_cache_1.c:15387:               ntohl(phchunk->start), ntohl(phchunk->end));
state_cache_1.c:16209:                u8 __pad[(1 << ((5))) - sizeof(int)];
state_cache_1.c:16216:        prot->stats[0].inuse++;
state_cache_1.c:16221:        prot->stats[0].inuse--;
state_cache_1.c:16316:        if (sk->filter) {
state_cache_1.c:16320:                        (void)(&((sk)->lock.slock));
state_cache_1.c:16322:                filter = sk->filter;
state_cache_1.c:16324:                        int pkt_len = sk_run_filter(skb, filter->insns,
state_cache_1.c:16325:                                                    filter->len);
state_cache_1.c:16327:                                err = -1;
state_cache_1.c:16342:        atomic_sub(size, &sk->omem_alloc);
state_cache_1.c:16344:        if (atomic_dec_and_test(&fp->refcnt))
state_cache_1.c:16350:        atomic_inc(&fp->refcnt);
state_cache_1.c:16351:        atomic_add(sk_filter_len(fp), &sk->omem_alloc);
state_cache_1.c:16356:        atomic_inc(&sk->refcnt);
state_cache_1.c:16364:        atomic_dec(&sk->refcnt);
state_cache_1.c:16370:        if (atomic_dec_and_test(&sk->refcnt))
state_cache_1.c:16376:        do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&sk->callback_lock); } while (0);
state_cache_1.c:16377:        sk->dead = 1;
state_cache_1.c:16378:        sk->socket = ((void *)0);
state_cache_1.c:16379:        sk->sleep = ((void *)0);
state_cache_1.c:16380:        do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0);
state_cache_1.c:16385:        do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&sk->callback_lock); } while (0);
state_cache_1.c:16386:        sk->sleep = &parent->wait;
state_cache_1.c:16387:        parent->sk = sk;
state_cache_1.c:16388:        sk->socket = parent;
state_cache_1.c:16389:        do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0);
state_cache_1.c:16396:        (void)(&sk->callback_lock);
state_cache_1.c:16397:        uid = sk->socket ? sk->socket->inode->i_uid : 0;
state_cache_1.c:16406:        (void)(&sk->callback_lock);
state_cache_1.c:16407:        ino = sk->socket ? sk->socket->inode->i_ino : 0;
state_cache_1.c:16415:        return sk->dst_cache;
state_cache_1.c:16423:        (void)(&sk->dst_lock);
state_cache_1.c:16424:        dst = sk->dst_cache;
state_cache_1.c:16436:        old_dst = sk->dst_cache;
state_cache_1.c:16437:        sk->dst_cache = dst;
state_cache_1.c:16444:        (void)(&sk->dst_lock);
state_cache_1.c:16454:        old_dst = sk->dst_cache;
state_cache_1.c:16455:        sk->dst_cache = ((void *)0);
state_cache_1.c:16462:        (void)(&sk->dst_lock);
state_cache_1.c:16470:        struct dst_entry *dst = sk->dst_cache;
state_cache_1.c:16472:        if (dst && dst->obsolete && dst->ops->check(dst, cookie) == ((void *)0)) {
state_cache_1.c:16473:                sk->dst_cache = ((void *)0);
state_cache_1.c:16485:        if (dst && dst->obsolete && dst->ops->check(dst, cookie) == ((void *)0)) {
state_cache_1.c:16496:        skb->sk = sk;
state_cache_1.c:16497:        skb->destructor = sock_wfree;
state_cache_1.c:16498:        atomic_add(skb->truesize, &sk->wmem_alloc);
state_cache_1.c:16503:        skb->sk = sk;
state_cache_1.c:16504:        skb->destructor = sock_rfree;
state_cache_1.c:16505:        atomic_add(skb->truesize, &sk->rmem_alloc);
state_cache_1.c:16516:        if (((&sk->rmem_alloc)->counter) + skb->truesize >= (unsigned)sk->rcvbuf) {
state_cache_1.c:16517:                err = -12;
state_cache_1.c:16529:        skb->dev = ((void *)0);
state_cache_1.c:16537:        skb_len = skb->len;
state_cache_1.c:16539:        skb_queue_tail(&sk->receive_queue, skb);
state_cache_1.c:16540:        if (!sk->dead)
state_cache_1.c:16541:                sk->data_ready(sk,skb_len);
state_cache_1.c:16551:        if (((&sk->rmem_alloc)->counter) + skb->truesize >= (unsigned)sk->rcvbuf)
state_cache_1.c:16552:                return -12;
state_cache_1.c:16554:        skb_queue_tail(&sk->error_queue,skb);
state_cache_1.c:16555:        if (!sk->dead)
state_cache_1.c:16556:                sk->data_ready(sk,skb->len);
state_cache_1.c:16566:        int err=((__typeof__(*(&sk->err)))__xchg((unsigned long)(0),(&sk->err),sizeof(*(&sk->err))));
state_cache_1.c:16567:        return -err;
state_cache_1.c:16574:        if (!(sk->shutdown & 2)) {
state_cache_1.c:16575:                amt = sk->sndbuf - ((&sk->wmem_alloc)->counter);
state_cache_1.c:16584:        if (sk->socket && sk->socket->fasync_list)
state_cache_1.c:16585:                sock_wake_async(sk->socket, how, band);
state_cache_1.c:16596:        return ((&sk->wmem_alloc)->counter) < (sk->sndbuf / 2);
state_cache_1.c:16606:        return noblock ? 0 : sk->rcvtimeo;
state_cache_1.c:16611:        return noblock ? 0 : sk->sndtimeo;
state_cache_1.c:16616:        return (waitall ? len : ({ int __x = (sk->rcvlowat); int __y = (len); __x < __y ? __x: __y; })) ? : 1;
state_cache_1.c:16624:        return timeo == ((long)(~0UL>>1)) ? -512 : -4;
state_cache_1.c:16630:        if (sk->rcvtstamp)
state_cache_1.c:16631:                put_cmsg(msg, 1, 29, sizeof(skb->stamp), &skb->stamp);
state_cache_1.c:16633:                sk->stamp = skb->stamp;
state_cache_1.c:16729:        return !((addr^ifa->ifa_address)&ifa->ifa_mask);
state_cache_1.c:16755:        in_dev = dev->ip_ptr;
state_cache_1.c:16757:                atomic_inc(&in_dev->refcnt);
state_cache_1.c:16765:        return (struct in_device*)dev->ip_ptr;
state_cache_1.c:16773:        if (atomic_dec_and_test(&idev->refcnt))
state_cache_1.c:16785:                return htonl(~((1<<(32-logmask))-1));
state_cache_1.c:16793:        return 32 - ffz(~mask);
state_cache_1.c:16828:        if (atomic_dec_and_test(&p->refcnt)) {
state_cache_1.c:16829:                p->unused_prevp = inet_peer_unused_tailp;
state_cache_1.c:16830:                p->unused_next = ((void *)0);
state_cache_1.c:16832:                inet_peer_unused_tailp = &p->unused_next;
state_cache_1.c:16833:                p->dtime = jiffies;
state_cache_1.c:16835:        do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0);
state_cache_1.c:16845:        id = p->ip_id_count++;
state_cache_1.c:16846:        do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0);
state_cache_1.c:16931:        int size = ((len)+( ((sizeof(struct nlmsghdr))+4 -1) & ~(4 -1) ));
state_cache_1.c:16933:        nlh = (struct nlmsghdr*)skb_put(skb, ( ((size)+4 -1) & ~(4 -1) ));
state_cache_1.c:16934:        nlh->nlmsg_type = type;
state_cache_1.c:16935:        nlh->nlmsg_len = size;
state_cache_1.c:16936:        nlh->nlmsg_flags = 0;
state_cache_1.c:16937:        nlh->nlmsg_pid = pid;
state_cache_1.c:16938:        nlh->nlmsg_seq = seq;
state_cache_1.c:17219:        return len > rta->rta_len || __builtin_memcmp(((void*)(((char*)(rta)) + (( ((sizeof(struct rtattr))+4 -1) & ~(4 -1) ) + (0)))), str, len);
state_cache_1.c:17380:                dst_release(&rt->u.dst);
state_cache_1.c:17398:        dst = (*rp)->rt_dst;
state_cache_1.c:17399:        src = (*rp)->rt_src;
state_cache_1.c:17409:        if (rt->peer)
state_cache_1.c:17410:                return rt->peer;
state_cache_1.c:17413:        return rt->peer;
state_cache_1.c:17855:        if (skb->len > skb->dst->pmtu)
state_cache_1.c:17866:        u32 check = iph->check;
state_cache_1.c:17868:        iph->check = check + (check>=0xFFFF);
state_cache_1.c:17869:        return --iph->ttl;
state_cache_1.c:17875:        return (sk->protinfo.af_inet.pmtudisc == 2 ||
state_cache_1.c:17876:                (sk->protinfo.af_inet.pmtudisc == 1 &&
state_cache_1.c:17877:                 !(dst->mxlock&(1<<RTAX_MTU))));
state_cache_1.c:17884:        if (iph->frag_off&((__u16)( (((__u16)((0x4000)) & (__u16)0x00ffU) << 8) | (((__u16)((0x4000)) & (__u16)0xff00U) >> 8) ))) {
state_cache_1.c:17890:                iph->id = ((sk && sk->daddr) ? htons(sk->protinfo.af_inet.id++) : 0);
state_cache_1.c:18103:        if ((({ unsigned long flag,sum; asm("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0" :"=&r" (flag), "=r" (sum) :"1" (dst),"g" ((int)(len)),"g" (get_current()->addr_limit.seg)); flag; }) == 0))
state_cache_1.c:18107:                *err_ptr = -14;
state_cache_1.c:18109:        return -1;
state_cache_1.c:18121:                *err_ptr = -14;
state_cache_1.c:18218:        return (lport & ((tcp_hashinfo.__tcp_bhash_size) - 1));
state_cache_1.c:18270:        if (atomic_dec_and_test(&tw->refcnt)) {
state_cache_1.c:18287:        return num & (32 - 1);
state_cache_1.c:18292:        return tcp_lhashfn(sk->num);
state_cache_1.c:18388:        req->class->destructor(req);
state_cache_1.c:18441:        return (__s32)(seq1-seq2) < 0;
state_cache_1.c:18446:        return (__s32)(seq2-seq1) < 0;
state_cache_1.c:18453:        return seq3 - seq2 >= seq1 - seq2;
state_cache_1.c:18506:        tp->ack.pending |= TCP_ACK_SCHED;
state_cache_1.c:18511:        return tp->ack.pending&TCP_ACK_SCHED;
state_cache_1.c:18516:        if (tp->ack.quick && --tp->ack.quick == 0) {
state_cache_1.c:18518:                tp->ack.ato = ((unsigned)(100/25));
state_cache_1.c:18526:        (__builtin_constant_p(0) ? (__builtin_constant_p((sizeof(tp->ack))) ? __constant_c_and_count_memset(((&tp->ack)),((0x01010101UL*(unsigned char)(0))),((sizeof(tp->ack)))) : __constant_c_memset(((&tp->ack)),((0x01010101UL*(unsigned char)(0))),((sizeof(tp->ack))))) : (__builtin_constant_p((sizeof(tp->ack))) ? __memset_generic((((&tp->ack))),(((0))),(((sizeof(tp->ack))))) : __memset_generic(((&tp->ack)),((0)),((sizeof(tp->ack))))));
state_cache_1.c:18531:        tp->tstamp_ok = tp->sack_ok = tp->wscale_ok = tp->snd_wscale = 0;
state_cache_1.c:18674:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_1.c:18679:                tp->pending = 0;
state_cache_1.c:18688:                tp->ack.blocked = 0;
state_cache_1.c:18689:                tp->ack.pending = 0;
state_cache_1.c:18709:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_1.c:18721:                tp->pending = what;
state_cache_1.c:18722:                tp->timeout = jiffies+when;
state_cache_1.c:18723:                if (!mod_timer(&tp->retransmit_timer, tp->timeout))
state_cache_1.c:18728:                tp->ack.pending |= TCP_ACK_TIMER;
state_cache_1.c:18729:                tp->ack.timeout = jiffies+when;
state_cache_1.c:18730:                if (!mod_timer(&tp->delack_timer, tp->ack.timeout))
state_cache_1.c:18745:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_1.c:18747:        int mss_now = tp->mss_cache;
state_cache_1.c:18749:        if (dst && dst->pmtu != tp->pmtu_cookie)
state_cache_1.c:18750:                mss_now = tcp_sync_mss(sk, dst->pmtu);
state_cache_1.c:18752:        if (tp->eff_sacks)
state_cache_1.c:18753:                mss_now -= (4 +
state_cache_1.c:18754:                            (tp->eff_sacks * 8));
state_cache_1.c:18760:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_1.c:18761:        unsigned int hint = ({ const typeof(tp->advmss) _x = (tp->advmss); const typeof(tp->mss_cache) _y = (tp->mss_cache); (void) (&_x == &_y); _x < _y ? _x : _y; });
state_cache_1.c:18763:        hint = ({ const typeof(hint) _x = (hint); const typeof(tp->rcv_wnd/2) _y = (tp->rcv_wnd/2); (void) (&_x == &_y); _x < _y ? _x : _y; });
state_cache_1.c:18767:        tp->ack.rcv_mss = hint;
state_cache_1.c:18772:        tp->pred_flags = htonl((tp->tcp_header_len << 26) |
state_cache_1.c:18779:        __tcp_fast_path_on(tp, tp->snd_wnd>>tp->snd_wscale);
state_cache_1.c:18784:        if (skb_queue_len(&tp->out_of_order_queue) == 0 &&
state_cache_1.c:18785:            tp->rcv_wnd &&
state_cache_1.c:18786:            ((&sk->rmem_alloc)->counter) < sk->rcvbuf &&
state_cache_1.c:18787:            !tp->urg_data)
state_cache_1.c:18797:        s32 win = tp->rcv_wup + tp->rcv_wnd - tp->rcv_nxt;
state_cache_1.c:18876:        u32 check = iph->check;
state_cache_1.c:18878:        iph->check = check + (check>=0xFFFF);
state_cache_1.c:18879:        iph->tos |= 1;
state_cache_1.c:18899:        if (tp->ecn_flags&1)
state_cache_1.c:18900:                tp->ecn_flags |= 2;
state_cache_1.c:18909:        ((struct tcp_skb_cb *)&((skb)->cb[0]))->flags &= ~0x80;
state_cache_1.c:18910:        if (!(tp->ecn_flags&1))
state_cache_1.c:18911:                ((struct tcp_skb_cb *)&((skb)->cb[0]))->flags &= ~0x40;
state_cache_1.c:18917:        tp->ecn_flags = 0;
state_cache_1.c:18919:                ((struct tcp_skb_cb *)&((skb)->cb[0]))->flags |= 0x40|0x80;
state_cache_1.c:18920:                tp->ecn_flags = 1;
state_cache_1.c:18927:        if (req->ecn_ok)
state_cache_1.c:18928:                th->ece = 1;
state_cache_1.c:18934:        if (tp->ecn_flags & 1) {
state_cache_1.c:18936:                if (skb->len != tcp_header_len &&
state_cache_1.c:18937:                    !before(((struct tcp_skb_cb *)&((skb)->cb[0]))->seq, tp->snd_nxt)) {
state_cache_1.c:18938:                        do { (sk)->protinfo.af_inet.tos |= 2; } while (0);
state_cache_1.c:18939:                        if (tp->ecn_flags&2) {
state_cache_1.c:18940:                                tp->ecn_flags &= ~2;
state_cache_1.c:18941:                                skb->h.th->cwr = 1;
state_cache_1.c:18945:                        do { (sk)->protinfo.af_inet.tos &= ~3; } while (0);
state_cache_1.c:18947:                if (tp->ecn_flags & 4)
state_cache_1.c:18948:                        skb->h.th->ece = 1;
state_cache_1.c:18957:        if (skb->h.th->cwr)
state_cache_1.c:18958:                tp->ecn_flags &= ~4;
state_cache_1.c:18964:        tp->ecn_flags &= ~4;
state_cache_1.c:18970:        if (tp->ecn_flags&1) {
state_cache_1.c:18971:                if (INET_ECN_is_ce(((struct tcp_skb_cb *)&((skb)->cb[0]))->flags))
state_cache_1.c:18972:                        tp->ecn_flags |= 4;
state_cache_1.c:18976:                else if (!INET_ECN_is_capable((((struct tcp_skb_cb *)&((skb)->cb[0]))->flags)))
state_cache_1.c:18984:        if ((tp->ecn_flags&1) && (!th->ece || th->cwr))
state_cache_1.c:18985:                tp->ecn_flags &= ~1;
state_cache_1.c:18991:        if ((tp->ecn_flags&1) && (!th->ece || !th->cwr))
state_cache_1.c:18992:                tp->ecn_flags &= ~1;
state_cache_1.c:18998:        if (th->ece && !th->syn && (tp->ecn_flags&1))
state_cache_1.c:19006:        tp->ecn_flags = req->ecn_ok ? 1 : 0;
state_cache_1.c:19012:        if (sysctl_tcp_ecn && th->ece && th->cwr)
state_cache_1.c:19013:                req->ecn_ok = 1;
state_cache_1.c:19023:        return sk->wmem_queued/2;
state_cache_1.c:19028:        return sk->sndbuf - sk->wmem_queued;
state_cache_1.c:19033:        return tp->packets_out - tp->left_out + tp->retrans_out;
state_cache_1.c:19043:        return ({ const typeof(tp->snd_cwnd >> 1U) _x = (tp->snd_cwnd >> 1U); const typeof(2U) _y = (2U); (void) (&_x == &_y); _x > _y ? _x : _y; });
state_cache_1.c:19052:        if ((1<<tp->ca_state)&((1<<TCP_CA_CWR)|(1<<TCP_CA_Recovery)))
state_cache_1.c:19053:                return tp->snd_ssthresh;
state_cache_1.c:19055:                return ({ const typeof(tp->snd_ssthresh) _x = (tp->snd_ssthresh); const typeof(((tp->snd_cwnd >> 1) + (tp->snd_cwnd >> 2))) _y = (((tp->snd_cwnd >> 1) + (tp->snd_cwnd >> 2))); (void) (&_x == &_y); _x > _y ? _x : _y; });
state_cache_1.c:19062:        if (tp->sack_ok && tp->sacked_out >= tp->packets_out - tp->lost_out)
state_cache_1.c:19063:                tp->sacked_out = tp->packets_out - tp->lost_out;
state_cache_1.c:19064:        tp->left_out = tp->sacked_out + tp->lost_out;
state_cache_1.c:19073:        if (tp->packets_out >= tp->snd_cwnd) {
state_cache_1.c:19075:                tp->snd_cwnd_used = 0;
state_cache_1.c:19076:                tp->snd_cwnd_stamp = ((__u32)(jiffies));
state_cache_1.c:19079:                if (tp->packets_out > tp->snd_cwnd_used)
state_cache_1.c:19080:                        tp->snd_cwnd_used = tp->packets_out;
state_cache_1.c:19082:                if ((s32)(((__u32)(jiffies)) - tp->snd_cwnd_stamp) >= tp->rto)
state_cache_1.c:19090:        tp->undo_marker = 0;
state_cache_1.c:19091:        tp->snd_ssthresh = tcp_recalc_ssthresh(tp);
state_cache_1.c:19092:        tp->snd_cwnd = ({ const typeof(tp->snd_cwnd) _x = (tp->snd_cwnd); const typeof(tcp_packets_in_flight(tp) + 1U) _y = (tcp_packets_in_flight(tp) + 1U); (void) (&_x == &_y); _x < _y ? _x : _y; });
state_cache_1.c:19094:        tp->snd_cwnd_cnt = 0;
state_cache_1.c:19095:        tp->high_seq = tp->snd_nxt;
state_cache_1.c:19096:        tp->snd_cwnd_stamp = ((__u32)(jiffies));
state_cache_1.c:19102:        tp->prior_ssthresh = 0;
state_cache_1.c:19103:        if (tp->ca_state < TCP_CA_CWR) {
state_cache_1.c:19105:                tp->ca_state = TCP_CA_CWR;
state_cache_1.c:19121:        return after(tp->snd_sml,tp->snd_una) &&
state_cache_1.c:19122:                !after(tp->snd_sml, tp->snd_nxt);
state_cache_1.c:19127:        if (skb->len < mss)
state_cache_1.c:19128:                tp->snd_sml = ((struct tcp_skb_cb *)&((skb)->cb[0]))->end_seq;
state_cache_1.c:19134:        return (skb->len < mss_now &&
state_cache_1.c:19135:                !(((struct tcp_skb_cb *)&((skb)->cb[0]))->flags & 0x01) &&
state_cache_1.c:19138:                  tp->packets_out &&
state_cache_1.c:19149:        return ((nonagle==1 || tp->urg_mode
state_cache_1.c:19151:                ((tcp_packets_in_flight(tp) < tp->snd_cwnd) ||
state_cache_1.c:19152:                 (((struct tcp_skb_cb *)&((skb)->cb[0]))->flags & 0x01)) &&
state_cache_1.c:19153:                !after(((struct tcp_skb_cb *)&((skb)->cb[0]))->end_seq, tp->snd_una + tp->snd_wnd));
state_cache_1.c:19158:        if (!tp->packets_out && !tp->pending)
state_cache_1.c:19159:                tcp_reset_xmit_timer(sk, 3, tp->rto);
state_cache_1.c:19164:        return (skb->next == (struct sk_buff*)&sk->write_queue);
state_cache_1.c:19176:        struct sk_buff *skb = tp->send_head;
state_cache_1.c:19191:        __tcp_push_pending_frames(sk, tp, tcp_current_mss(sk), tp->nonagle);
state_cache_1.c:19196:        struct sk_buff *skb = tp->send_head;
state_cache_1.c:19200:                             tcp_skb_is_last(sk, skb) ? 1 : tp->nonagle));
state_cache_1.c:19205:        tp->snd_wl1 = seq;
state_cache_1.c:19210:        tp->snd_wl1 = seq;
state_cache_1.c:19228:        return (unsigned short)csum_fold(skb_checksum(skb, 0, skb->len, skb->csum));
state_cache_1.c:19233:        return skb->ip_summed != 2 &&
state_cache_1.c:19241:        tp->ucopy.task = ((void *)0);
state_cache_1.c:19242:        tp->ucopy.len = 0;
state_cache_1.c:19243:        tp->ucopy.memory = 0;
state_cache_1.c:19244:        skb_queue_head_init(&tp->ucopy.prequeue);
state_cache_1.c:19249:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_1.c:19251:        if (!sysctl_tcp_low_latency && tp->ucopy.task) {
state_cache_1.c:19252:                __skb_queue_tail(&tp->ucopy.prequeue, skb);
state_cache_1.c:19253:                tp->ucopy.memory += skb->truesize;
state_cache_1.c:19254:                if (tp->ucopy.memory > sk->rcvbuf) {
state_cache_1.c:19257:                        if (sk->lock.users)
state_cache_1.c:19260:                        while ((skb1 = __skb_dequeue(&tp->ucopy.prequeue)) != ((void *)0)) {
state_cache_1.c:19261:                                sk->backlog_rcv(sk, skb1);
state_cache_1.c:19265:                        tp->ucopy.memory = 0;
state_cache_1.c:19266:                } else if (skb_queue_len(&tp->ucopy.prequeue) == 1) {
state_cache_1.c:19267:                        __wake_up((sk->sleep),1, 1);
state_cache_1.c:19278:        int oldstate = sk->state;
state_cache_1.c:19290:                sk->prot->unhash(sk);
state_cache_1.c:19291:                if (sk->prev && !(sk->userlocks&8))
state_cache_1.c:19296:                        tcp_statistics[0*2+!(((void)((0)), irq_stat[0].__local_bh_count) != 0)].TcpCurrEstab--;
state_cache_1.c:19302:        sk->state = state;
state_cache_1.c:19314:        sk->shutdown = 3;
state_cache_1.c:19316:        if (!sk->dead)
state_cache_1.c:19317:                sk->state_change(sk);
state_cache_1.c:19324:        tp->dsack = 0;
state_cache_1.c:19325:        tp->eff_sacks = 0;
state_cache_1.c:19326:        tp->num_sacks = 0;
state_cache_1.c:19331:        if (tp->tstamp_ok) {
state_cache_1.c:19337:                *ptr++ = htonl(tp->ts_recent);
state_cache_1.c:19339:        if (tp->eff_sacks) {
state_cache_1.c:19340:                struct tcp_sack_block *sp = tp->dsack ? tp->duplicate_sack : tp->selective_acks;
state_cache_1.c:19343:                *ptr++ = ((__u32)( (((__u32)(((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) & (__u32)0x000000ffUL) << 24) | (((__u32)(((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) & (__u32)0x0000ff00UL) << 8) | (((__u32)(((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) & (__u32)0xff000000UL) >> 24) ));
state_cache_1.c:19348:                for(this_sack = 0; this_sack < tp->eff_sacks; this_sack++) {
state_cache_1.c:19352:                if (tp->dsack) {
state_cache_1.c:19353:                        tp->dsack = 0;
state_cache_1.c:19354:                        tp->eff_sacks--;
state_cache_1.c:19417:                    space - ({ const typeof((space>>sysctl_tcp_app_win)) _x = ((space>>sysctl_tcp_app_win)); const typeof(mss>>*rcv_wscale) _y = (mss>>*rcv_wscale); (void) (&_x == &_y); _x > _y ? _x : _y; }) < 65536/2)
state_cache_1.c:19418:                        (*rcv_wscale)--;
state_cache_1.c:19441:                (space>>(-sysctl_tcp_adv_win_scale)) :
state_cache_1.c:19442:                space - (space>>sysctl_tcp_adv_win_scale);
state_cache_1.c:19448:        return tcp_win_from_space(sk->rcvbuf - ((&sk->rmem_alloc)->counter));
state_cache_1.c:19453:        return tcp_win_from_space(sk->rcvbuf);
state_cache_1.c:19458:        sk->ack_backlog--;
state_cache_1.c:19463:        sk->ack_backlog++;
state_cache_1.c:19468:        return sk->ack_backlog > sk->max_ack_backlog;
state_cache_1.c:19474:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_1.c:19476:        req->sk = child;
state_cache_1.c:19479:        if (!tp->accept_queue_tail) {
state_cache_1.c:19480:                tp->accept_queue = req;
state_cache_1.c:19482:                tp->accept_queue_tail->dl_next = req;
state_cache_1.c:19484:        tp->accept_queue_tail = req;
state_cache_1.c:19485:        req->dl_next = ((void *)0);
state_cache_1.c:19501:        struct tcp_listen_opt *lopt = sk->tp_pinfo.af_tcp.listen_opt;
state_cache_1.c:19503:        if (--lopt->qlen == 0)
state_cache_1.c:19505:        if (req->retrans == 0)
state_cache_1.c:19506:                lopt->qlen_young--;
state_cache_1.c:19511:        struct tcp_listen_opt *lopt = sk->tp_pinfo.af_tcp.listen_opt;
state_cache_1.c:19513:        if (lopt->qlen++ == 0)
state_cache_1.c:19515:        lopt->qlen_young++;
state_cache_1.c:19520:        return sk->tp_pinfo.af_tcp.listen_opt->qlen;
state_cache_1.c:19525:        return sk->tp_pinfo.af_tcp.listen_opt->qlen_young;
state_cache_1.c:19530:        return tcp_synq_len(sk)>>sk->tp_pinfo.af_tcp.listen_opt->max_qlen_log;
state_cache_1.c:19536:        (void)(&tp->syn_wait_lock);
state_cache_1.c:19537:        *prev = req->dl_next;
state_cache_1.c:19544:        tcp_synq_unlink(&sk->tp_pinfo.af_tcp, req, prev);
state_cache_1.c:19553:        req->rcv_wnd = 0;
state_cache_1.c:19554:        req->rcv_isn = ((struct tcp_skb_cb *)&((skb)->cb[0]))->seq;
state_cache_1.c:19555:        req->mss = tp->mss_clamp;
state_cache_1.c:19556:        req->ts_recent = tp->saw_tstamp ? tp->rcv_tsval : 0;
state_cache_1.c:19557:        req->tstamp_ok = tp->tstamp_ok;
state_cache_1.c:19558:        req->sack_ok = tp->sack_ok;
state_cache_1.c:19559:        req->snd_wscale = tp->snd_wscale;
state_cache_1.c:19560:        req->wscale_ok = tp->wscale_ok;
state_cache_1.c:19561:        req->acked = 0;
state_cache_1.c:19562:        req->ecn_ok = 0;
state_cache_1.c:19563:        req->rmt_port = skb->h.th->source;
state_cache_1.c:19570:        sk->tp_pinfo.af_tcp.queue_shrunk = 1;
state_cache_1.c:19571:        sk->wmem_queued -= skb->truesize;
state_cache_1.c:19572:        sk->forward_alloc += skb->truesize;
state_cache_1.c:19578:        sk->wmem_queued += skb->truesize;
state_cache_1.c:19579:        sk->forward_alloc -= skb->truesize;
state_cache_1.c:19587:        if (sk->forward_alloc >= ((int)(1UL << 12)))
state_cache_1.c:19601:        if (!(sk->userlocks&1)) {
state_cache_1.c:19602:                sk->sndbuf = ({ const typeof(sk->sndbuf) _x = (sk->sndbuf); const typeof(sk->wmem_queued/2) _y = (sk->wmem_queued/2); (void) (&_x == &_y); _x < _y ? _x : _y; });
state_cache_1.c:19603:                sk->sndbuf = ({ const typeof(sk->sndbuf) _x = (sk->sndbuf); const typeof(2048) _y = (2048); (void) (&_x == &_y); _x > _y ? _x : _y; });
state_cache_1.c:19612:                skb->truesize += mem;
state_cache_1.c:19613:                if (sk->forward_alloc >= (int)skb->truesize ||
state_cache_1.c:19614:                    tcp_mem_schedule(sk, skb->truesize, 0)) {
state_cache_1.c:19633:        if (sk->forward_alloc >= (int)(1UL << 12) ||
state_cache_1.c:19635:                struct page *page = alloc_pages(sk->allocation, 0);
state_cache_1.c:19648:        while ((skb = __skb_dequeue(&sk->write_queue)) != ((void *)0))
state_cache_1.c:19657:        skb->sk = sk;
state_cache_1.c:19658:        skb->destructor = tcp_rfree;
state_cache_1.c:19659:        atomic_add(skb->truesize, &sk->rmem_alloc);
state_cache_1.c:19660:        sk->forward_alloc -= skb->truesize;
state_cache_1.c:19686:        return tp->keepalive_intvl ? : sysctl_tcp_keepalive_intvl;
state_cache_1.c:19691:        return tp->keepalive_time ? : sysctl_tcp_keepalive_time;
state_cache_1.c:19696:        int fin_timeout = tp->linger2 ? : sysctl_tcp_fin_timeout;
state_cache_1.c:19698:        if (fin_timeout < (tp->rto<<2) - (tp->rto>>1))
state_cache_1.c:19699:                fin_timeout = (tp->rto<<2) - (tp->rto>>1);
state_cache_1.c:19706:        if ((s32)(tp->rcv_tsval - tp->ts_recent) >= 0)
state_cache_1.c:19708:        if (xtime.tv_sec >= tp->ts_recent_stamp + (60 * 60 * 24 * 24))
state_cache_1.c:19711:        if (rst && xtime.tv_sec >= tp->ts_recent_stamp + 60)
state_cache_1.c:19720:        const struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_1.c:19726:        return (sysctl_tcp_frto && tp->send_head &&
state_cache_1.c:19727:                !after(((struct tcp_skb_cb *)&((tp->send_head)->cb[0]))->end_seq,
state_cache_1.c:19728:                       tp->snd_una + tp->snd_wnd));
state_cache_1.c:19737:        ((tcp_statistics)[2*0 +1].TcpMaxConn += -1);
state_cache_1.c:19749:                tp->westwood.rtt = rtt_seq;
state_cache_1.c:19757:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
state_cache_1.c:19759:        tp->westwood.bw_ns_est = 0;
state_cache_1.c:19760:        tp->westwood.bw_est = 0;
state_cache_1.c:19761:        tp->westwood.accounted = 0;
state_cache_1.c:19762:        tp->westwood.cumul_ack = 0;
state_cache_1.c:19763:        tp->westwood.rtt_win_sx = ((__u32)(jiffies));
state_cache_1.c:19764:        tp->westwood.rtt = 20*100;
state_cache_1.c:19765:        tp->westwood.rtt_min = 20*100;
state_cache_1.c:19766:        tp->westwood.snd_una = tp->snd_una;
state_cache_1.c:19788:        return (__u32) ((tp->westwood.bw_est) * (tp->westwood.rtt_min) /
state_cache_1.c:19789:                        (__u32) (tp->mss_cache));
state_cache_1.c:19811:                tp->snd_ssthresh = ssthresh;
state_cache_1.c:19827:                tp->snd_cwnd = cwnd;
state_cache_1.c:19840:                        tp->snd_ssthresh = tp->snd_cwnd;
state_cache_1.c:19863:# 1 "/home/ashieh/current/include/net/trickles-crypto.h" 1
state_cache_1.c:19883:# 6 "/home/ashieh/current/include/net/trickles-crypto.h" 2
state_cache_1.c:19961:# 13 "/home/ashieh/current/include/net/trickles-crypto.h" 2
state_cache_1.c:20113:        struct sock *sk = skb->sk;
state_cache_1.c:20114:        if(skb->ip_summed == 1) {
state_cache_1.c:20115:                skb->h.th->check = 0;
state_cache_1.c:20116:                skb->h.th->check = ~tcp_v4_check(skb->h.th, skb->len, sk->saddr, sk->daddr,
state_cache_1.c:20118:                skb->csum = ((size_t) &((struct tcphdr *)0)->check);
state_cache_1.c:20120:                skb->h.th->check = 0;
state_cache_1.c:20121:                skb->h.th->check = tcp_v4_check(skb->h.th, skb->len, sk->saddr, sk->daddr,
state_cache_1.c:20122:                                         csum_partial((char*)skb->h.th, headerLen, skb->csum));
state_cache_1.c:20147:  POISONEDRANGE = -1,
state_cache_1.c:20198:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_1.c:20199:        if (!(dataReq->list == ((void *)0))) { printk("KERNEL: assertion (" "dataReq->list == NULL" ") failed at " "/home/ashieh/current/include/net/trickles_client.h" "(%d)\n", 47); };
state_cache_1.c:20200:        dataReq->completed = 0;
state_cache_1.c:20201:        dataReq->sent = 0;
state_cache_1.c:20203:        dataReq->transportResponseSeqStart = (4294967295U);
state_cache_1.c:20204:        dataReq->transportResponseSeqEnd = (4294967295U);
state_cache_1.c:20205:        dataReq->timestamp = (4294967295U);
state_cache_1.c:20206:        dataReq->start = newStart;
state_cache_1.c:20207:        dataReq->end = newEnd;
state_cache_1.c:20208:        insert_tail(&tp->t.missingDataMap, (struct alloc_head*)dataReq);
state_cache_1.c:20235:        newMapping->next = newMapping->prev = ((void *)0);
state_cache_1.c:20236:        newMapping->list = ((void *)0);
state_cache_1.c:20238:        newMapping->completed = 0;
state_cache_1.c:20239:        newMapping->ucont = ucont;
state_cache_1.c:20240:        newMapping->transportResponseSeqStart = tseq_start;
state_cache_1.c:20241:        newMapping->transportResponseSeqEnd = tseq_end;
state_cache_1.c:20242:        newMapping->sent = 0;
state_cache_1.c:20243:        newMapping->start = start;
state_cache_1.c:20244:        newMapping->end = end;
state_cache_1.c:20246:        newMapping->timestamp = jiffies;
state_cache_1.c:20254:        numDataRequestMappings--;
state_cache_1.c:20275:        req->numChildren = 0;
state_cache_1.c:20276:        req->childrenMask = 0;
state_cache_1.c:20277:        req->transport_seq = -1;
state_cache_1.c:20278:        req->seq = -1;
state_cache_1.c:20279:        req->isNew = 1;
state_cache_1.c:20284:        req->type = type;
state_cache_1.c:20285:        req->prev = req->next = ((void *)0);
state_cache_1.c:20286:        req->list = ((void *)0);
state_cache_1.c:20288:        req->start = req->end = -1;
state_cache_1.c:20289:        req->allocated = 1;
state_cache_1.c:20295:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_1.c:20296:        insert_tail(&tp->t.queuedRequests, (struct alloc_head*)req);
state_cache_1.c:20297:        tp->t.timerState |= (0x1);
state_cache_1.c:20324:        req->incomplete = 0;
state_cache_1.c:20325:        req->completePred = pred;
state_cache_1.c:20326:        atomic_inc(&req->completePred->refcnt);
state_cache_1.c:20328:        if(((&req->completePred->refcnt)->counter) < 2) {
state_cache_1.c:20332:        req->data = data;
state_cache_1.c:20333:        req->start = start;
state_cache_1.c:20334:        req->offset = req->start - ((struct tcp_skb_cb *)&((data)->cb[0]))->seq;
state_cache_1.c:20339:        req->incomplete = 1;
state_cache_1.c:20340:        req->incompletePred = pred;
state_cache_1.c:20341:        req->predLength = predLength;
state_cache_1.c:20342:        req->data = data;
state_cache_1.c:20343:        req->offset = offset;
state_cache_1.c:20360:        req->start = start;
state_cache_1.c:20361:        req->end = end;
state_cache_1.c:20362:        req->numConts = numConts;
state_cache_1.c:20363:        req->conts = kmalloc(sizeof(struct UC_Continuation*) * numConts, (0x20));
state_cache_1.c:20367:                return -1;
state_cache_1.c:20378:        newReq->conts = kmalloc(sizeof(struct UC_Continuation*) * newReq->numConts, (0x20));
state_cache_1.c:20379:        if(newReq->conts == ((void *)0)) {
state_cache_1.c:20383:        (__builtin_constant_p(sizeof(struct UC_Continuation*) * newReq->numConts) ? __constant_memcpy((newReq->conts),(src->conts),(sizeof(struct UC_Continuation*) * newReq->numConts)) : __memcpy((newReq->conts),(src->conts),(sizeof(struct UC_Continuation*) * newReq->numConts)));
state_cache_1.c:20408:        rval->prev = rval->next = ((void *)0);
state_cache_1.c:20409:        rval->list = ((void *)0);
state_cache_1.c:20411:        rval->cont = cont;
state_cache_1.c:20412:        rval->isSynack = isSynack;
state_cache_1.c:20413:        rval->parent = parent;
state_cache_1.c:20414:        rval->numSiblings = numSiblings;
state_cache_1.c:20415:        rval->position = position;
state_cache_1.c:20455:static inline void marshallContinuationServer(struct sock *sk, WireContinuation *dcont, const struct cminisock *scont, int pktNum) { dcont->clientState = scont->clientState; dcont->parent = scont->parent; if(1) { ({ (dcont)->seq = htonl((scont)->packets[pktNum].seq); (dcont)->continuationType = (scont)->packets[pktNum].contType; if((scont)->packets[pktNum].type & (0x80)) { (dcont)->firstChild = 1; } else { (dcont)->firstChild = 0; } static const int stateConversionMap[] = { 0, 1, 2 }; int conversionOffset = (scont)->packets[pktNum].type & (0x3); if(conversionOffset >= (3)) { do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } (dcont)->state = stateConversionMap[conversionOffset]; }); dcont->timestamp = htonl(scont->timestamp); dcont->clientTimestamp = scont->clientTimestamp; dcont->mrtt = htonl(scont->mrtt); } else { dcont->seq = htonl(scont->seq); dcont->continuationType = scont->continuationType; dcont->firstChild = scont->firstChild; dcont->state = scont->state; dcont->timestamp = scont->rawTimestamp; dcont->clientTimestamp = scont->clientTimestamp; dcont->mrtt = scont->rawMrtt; } dcont->firstLoss = htonl(scont->firstLoss); dcont->firstBootstrapSeq = htonl(scont->firstBootstrapSeq); dcont->startCwnd = htonl(scont->startCwnd); dcont->ssthresh = htonl(scont->ssthresh); dcont->TCPBase = htonl(scont->TCPBase); dcont->tokenCounterBase = scont->tokenCounterBase; do { PseudoHeader hdr, *phdr = &hdr; phdr->seq = dcont->seq; phdr->type = dcont->continuationType; phdr->first = dcont->firstChild ? 1 : 0; phdr->serverAddr = scont->saddr; phdr->serverPort = scont->source; phdr->clientAddr = scont->daddr; phdr->clientPort = scont->dest; computeMAC(sk, phdr, dcont, dcont->mac); } while(0); }
state_cache_1.c:20456:static inline void marshallContinuationServerCopyMAC(struct sock *sk, WireContinuation *dcont, const struct cminisock *scont, int pktNum) { dcont->clientState = scont->clientState; dcont->parent = scont->parent; if(1) { ({ (dcont)->seq = htonl((scont)->packets[pktNum].seq); (dcont)->continuationType = (scont)->packets[pktNum].contType; if((scont)->packets[pktNum].type & (0x80)) { (dcont)->firstChild = 1; } else { (dcont)->firstChild = 0; } static const int stateConversionMap[] = { 0, 1, 2 }; int conversionOffset = (scont)->packets[pktNum].type & (0x3); if(conversionOffset >= (3)) { do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } (dcont)->state = stateConversionMap[conversionOffset]; }); dcont->timestamp = htonl(scont->timestamp); dcont->clientTimestamp = scont->clientTimestamp; dcont->mrtt = htonl(scont->mrtt); } else { dcont->seq = htonl(scont->seq); dcont->continuationType = scont->continuationType; dcont->firstChild = scont->firstChild; dcont->state = scont->state; dcont->timestamp = scont->rawTimestamp; dcont->clientTimestamp = scont->clientTimestamp; dcont->mrtt = scont->rawMrtt; } dcont->firstLoss = htonl(scont->firstLoss); dcont->firstBootstrapSeq = htonl(scont->firstBootstrapSeq); dcont->startCwnd = htonl(scont->startCwnd); dcont->ssthresh = htonl(scont->ssthresh); dcont->TCPBase = htonl(scont->TCPBase); dcont->tokenCounterBase = scont->tokenCounterBase; do{ (__builtin_constant_p(16) ? __constant_memcpy((dcont->mac),(scont->mac),(16)) : __memcpy((dcont->mac),(scont->mac),(16))); } while(0); }
state_cache_1.c:20457:static inline void marshallContinuationClient(struct sock *sk, WireContinuation *dcont, const struct cminisock *scont, int pktNum) { dcont->clientState = scont->clientState; dcont->parent = scont->parent; if(0) { ({ (dcont)->seq = htonl((scont)->packets[pktNum].seq); (dcont)->continuationType = (scont)->packets[pktNum].contType; if((scont)->packets[pktNum].type & (0x80)) { (dcont)->firstChild = 1; } else { (dcont)->firstChild = 0; } static const int stateConversionMap[] = { 0, 1, 2 }; int conversionOffset = (scont)->packets[pktNum].type & (0x3); if(conversionOffset >= (3)) { do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } (dcont)->state = stateConversionMap[conversionOffset]; }); dcont->timestamp = htonl(scont->timestamp); dcont->clientTimestamp = scont->clientTimestamp; dcont->mrtt = htonl(scont->mrtt); } else { dcont->seq = htonl(scont->seq); dcont->continuationType = scont->continuationType; dcont->firstChild = scont->firstChild; dcont->state = scont->state; dcont->timestamp = scont->rawTimestamp; dcont->clientTimestamp = scont->clientTimestamp; dcont->mrtt = scont->rawMrtt; } dcont->firstLoss = htonl(scont->firstLoss); dcont->firstBootstrapSeq = htonl(scont->firstBootstrapSeq); dcont->startCwnd = htonl(scont->startCwnd); dcont->ssthresh = htonl(scont->ssthresh); dcont->TCPBase = htonl(scont->TCPBase); dcont->tokenCounterBase = scont->tokenCounterBase; do{ (__builtin_constant_p(16) ? __constant_memcpy((dcont->mac),(scont->mac),(16)) : __memcpy((dcont->mac),(scont->mac),(16))); } while(0); }
state_cache_1.c:20466:  dproof->numSacks = ({ typeof(sproof->numSacks) Z = (typeof(sproof->numSacks))(64); ({ const typeof(sproof->numSacks) _x = (sproof->numSacks); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y; }); });
state_cache_1.c:20467:  for(i=0; i < dproof->numSacks; i++) {
state_cache_1.c:20468:    dproof->sacks[i].left = htonl(sproof->sacks[i].left);;
state_cache_1.c:20469:    dproof->sacks[i].right = htonl(sproof->sacks[i].right);;
state_cache_1.c:20470:    dproof->sacks[i].nonceSummary = sproof->sacks[i].nonceSummary;
state_cache_1.c:20481:static inline int unmarshallContinuationServerMSK(struct sk_buff *skb, struct cminisock *dcont, const WireContinuation *scont) { do { if(__builtin_expect((!(((skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((skb->sk)->tp_pinfo.af_tcp.trickles_opt & (skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))),0)) { char mac[16]; PseudoHeader hdr, *phdr = &hdr; phdr->seq = scont->seq; phdr->type = scont->continuationType; phdr->first = scont->firstChild; phdr->serverAddr = skb->nh.iph->daddr; phdr->serverPort = skb->h.th->dest; phdr->clientAddr = skb->nh.iph->saddr; phdr->clientPort = skb->h.th->source; computeMAC(skb->sk, phdr, scont, mac); if(__builtin_memcmp(mac, scont->mac, 16)) { printk("failed hmac comparison\n"); return 0; } } } while(0);; dcont->continuationType = scont->continuationType; dcont->seq = ntohl(scont->seq);; dcont->clientState = scont->clientState; dcont->parent = scont->parent; dcont->rawTimestamp = scont->timestamp; dcont->timestamp = ntohl(scont->timestamp); dcont->rawMrtt = scont->mrtt; dcont->mrtt = ntohl(scont->mrtt);; dcont->clientTimestamp = scont->clientTimestamp; dcont->state = scont->state; dcont->firstChild = scont->firstChild; dcont->firstLoss = ntohl(scont->firstLoss);; dcont->firstBootstrapSeq = ntohl(scont->firstBootstrapSeq);; dcont->startCwnd = ntohl(scont->startCwnd);; dcont->ssthresh = ntohl(scont->ssthresh);; dcont->TCPBase = ntohl(scont->TCPBase);; if(__builtin_expect((!(((skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((skb->sk)->tp_pinfo.af_tcp.trickles_opt & (skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))),0)) { dcont->saddr = skb->nh.iph->daddr; dcont->daddr = skb->nh.iph->saddr; dcont->source = skb->h.th->dest; dcont->dest = skb->h.th->source; }; dcont->tokenCounterBase = scont->tokenCounterBase; dcont->num_packets = 0; dcont->numChildrenReceived = 0; dcont->parentMSK = ((void *)0);; return 1; };
state_cache_1.c:20488:static inline int unmarshallContinuationServerPMSK(struct sk_buff *skb, struct pminisock *dcont, const WireContinuation *scont) { do { if(__builtin_expect((!(((skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((skb->sk)->tp_pinfo.af_tcp.trickles_opt & (skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))),0)) { char mac[16]; PseudoHeader hdr, *phdr = &hdr; phdr->seq = scont->seq; phdr->type = scont->continuationType; phdr->first = scont->firstChild; phdr->serverAddr = skb->nh.iph->daddr; phdr->serverPort = skb->h.th->dest; phdr->clientAddr = skb->nh.iph->saddr; phdr->clientPort = skb->h.th->source; computeMAC(skb->sk, phdr, scont, mac); if(__builtin_memcmp(mac, scont->mac, 16)) { printk("failed hmac comparison\n"); return 0; } } } while(0);; dcont->continuationType = scont->continuationType; dcont->seq = ntohl(scont->seq);; dcont->clientState = scont->clientState; dcont->parent = scont->parent; dcont->rawTimestamp = scont->timestamp; dcont->rawMrtt = scont->mrtt;; dcont->clientTimestamp = scont->clientTimestamp; dcont->state = scont->state; dcont->firstChild = scont->firstChild; dcont->firstLoss = ntohl(scont->firstLoss);; dcont->firstBootstrapSeq = ntohl(scont->firstBootstrapSeq);; dcont->startCwnd = ntohl(scont->startCwnd);; dcont->ssthresh = ntohl(scont->ssthresh);; dcont->TCPBase = ntohl(scont->TCPBase);; dcont->daddr = skb->nh.iph->saddr; dcont->dest = skb->h.th->source;; dcont->tokenCounterBase = scont->tokenCounterBase; dcont->num_packets = 0;; return 1; };
state_cache_1.c:20495:static inline int unmarshallContinuationServerPMSK2MSK(struct sock *sk, struct cminisock *dcont, struct pminisock *scont) { ; dcont->continuationType = scont->continuationType; dcont->seq = scont->seq; dcont->clientState = scont->clientState; dcont->parent = scont->parent; dcont->rawTimestamp = scont->rawTimestamp; dcont->timestamp = ntohl(scont->rawTimestamp); dcont->rawMrtt = scont->rawMrtt; dcont->mrtt = ntohl(scont->rawMrtt);; dcont->clientTimestamp = scont->clientTimestamp; dcont->state = scont->state; dcont->firstChild = scont->firstChild; dcont->firstLoss = scont->firstLoss; dcont->firstBootstrapSeq = scont->firstBootstrapSeq; dcont->startCwnd = scont->startCwnd; dcont->ssthresh = scont->ssthresh; dcont->TCPBase = scont->TCPBase; dcont->saddr = sk->saddr; dcont->source = sk->sport; dcont->daddr = scont->daddr; dcont->dest = scont->dest;; dcont->tokenCounterBase = scont->tokenCounterBase; dcont->num_packets = 0;; return 1; };
state_cache_1.c:20502:static inline int unmarshallContinuationServerMSK2PMSK(struct sock *sk, struct pminisock *dcont, struct cminisock *scont) { ; dcont->continuationType = scont->continuationType; dcont->seq = scont->seq; dcont->clientState = scont->clientState; dcont->parent = scont->parent; dcont->rawTimestamp = scont->rawTimestamp; dcont->rawMrtt = scont->rawMrtt;; dcont->clientTimestamp = scont->clientTimestamp; dcont->state = scont->state; dcont->firstChild = scont->firstChild; dcont->firstLoss = scont->firstLoss; dcont->firstBootstrapSeq = scont->firstBootstrapSeq; dcont->startCwnd = scont->startCwnd; dcont->ssthresh = scont->ssthresh; dcont->TCPBase = scont->TCPBase; dcont->daddr = scont->daddr; dcont->dest = scont->dest;; dcont->tokenCounterBase = scont->tokenCounterBase; dcont->num_packets = 0;; return 1; };
state_cache_1.c:20509:static inline int unmarshallContinuationClient(struct sk_buff *skb, struct cminisock *dcont, const WireContinuation *scont) { do { (__builtin_constant_p(16) ? __constant_memcpy((dcont->mac),(scont->mac),(16)) : __memcpy((dcont->mac),(scont->mac),(16))); } while(0); dcont->continuationType = scont->continuationType; dcont->seq = ntohl(scont->seq);; dcont->clientState = scont->clientState; dcont->parent = scont->parent; dcont->rawTimestamp = scont->timestamp; dcont->timestamp = ntohl(scont->timestamp); dcont->rawMrtt = scont->mrtt; dcont->mrtt = ntohl(scont->mrtt);; dcont->clientTimestamp = scont->clientTimestamp; dcont->state = scont->state; dcont->firstChild = scont->firstChild; dcont->firstLoss = ntohl(scont->firstLoss);; dcont->firstBootstrapSeq = ntohl(scont->firstBootstrapSeq);; dcont->startCwnd = ntohl(scont->startCwnd);; dcont->ssthresh = ntohl(scont->ssthresh);; dcont->TCPBase = ntohl(scont->TCPBase);; if(__builtin_expect((!(((skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((skb->sk)->tp_pinfo.af_tcp.trickles_opt & (skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))),0)) { dcont->saddr = skb->nh.iph->daddr; dcont->daddr = skb->nh.iph->saddr; dcont->source = skb->h.th->dest; dcont->dest = skb->h.th->source; }; dcont->tokenCounterBase = scont->tokenCounterBase; dcont->num_packets = 0; dcont->numChildrenReceived = 0; dcont->parentMSK = ((void *)0);; return 1; };
state_cache_1.c:20526:        for(i=0; i < (((cont)+1)->num_packets); i++) {
state_cache_1.c:20527:                total += (((cont)+1)->packets)[i].len;
state_cache_1.c:20563:  rval->prev = rval->next = ((void *)0);
state_cache_1.c:20564:  rval->list = ((void *)0);
state_cache_1.c:20570:          (rval+i)->ucont_len = 0;
state_cache_1.c:20571:          (rval+i)->ucont_data = ((void *)0);
state_cache_1.c:20572:          (rval+i)->input_len = 0;
state_cache_1.c:20573:          (rval+i)->input = ((void *)0);
state_cache_1.c:20575:          (rval+i)->mark = 0;
state_cache_1.c:20576:          (rval+i)->simulated = 0;
state_cache_1.c:20578:  rval->sk = ((void *)0);
state_cache_1.c:20603:  rval->prev = rval->next = ((void *)0);
state_cache_1.c:20604:  rval->list = ((void *)0);
state_cache_1.c:20606:  (__builtin_constant_p((int)((struct cminisock *)0)->clientside_copy_end) ? __constant_memcpy((rval),(cont),((int)((struct cminisock *)0)->clientside_copy_end)) : __memcpy((rval),(cont),((int)((struct cminisock *)0)->clientside_copy_end)));
state_cache_1.c:20609:          (rval+i)->ucont_len = 0;
state_cache_1.c:20610:          (rval+i)->ucont_data = ((void *)0);
state_cache_1.c:20612:          (rval+i)->input_len = 0;
state_cache_1.c:20613:          (rval+i)->input = ((void *)0);
state_cache_1.c:20615:          (rval+i)->mark = 0;
state_cache_1.c:20616:          (rval+i)->simulated = 0;
state_cache_1.c:20617:          (rval+i)->num_packets = 0;
state_cache_1.c:20618:          (rval+i)->actualCwnd = 0;
state_cache_1.c:20629:  if(cont->list) {
state_cache_1.c:20634:    if((cont+i)->ucont_data)
state_cache_1.c:20635:      kfree((cont+i)->ucont_data);
state_cache_1.c:20636:    if((cont+i)->input)
state_cache_1.c:20637:      kfree((cont+i)->input);
state_cache_1.c:20650:  dproof->numSacks = sproof->numSacks;
state_cache_1.c:20651:  for(i=0; i < sproof->numSacks; i++) {
state_cache_1.c:20652:    dproof->sacks[i].left = ntohl(sproof->sacks[i].left);;
state_cache_1.c:20653:    dproof->sacks[i].right = ntohl(sproof->sacks[i].right);;
state_cache_1.c:20654:    dproof->sacks[i].nonceSummary = sproof->sacks[i].nonceSummary;
state_cache_1.c:20661:  unsigned dataLen = length - sizeof(struct WireUC_Continuation);
state_cache_1.c:20668:  rval->prev = rval->next = ((void *)0);
state_cache_1.c:20669:  rval->list = ((void *)0);
state_cache_1.c:20671:  rval->seq = ntohl(scont->seq);
state_cache_1.c:20672:  rval->validStart = ntohl(scont->validStart);
state_cache_1.c:20673:  rval->validEnd = ntohl(scont->validEnd);
state_cache_1.c:20674:  rval->fields = scont->fields;
state_cache_1.c:20675:  rval->dataLen = dataLen;
state_cache_1.c:20676:  rval->kernel.obsoleteAt = rval->validEnd;
state_cache_1.c:20677:  (__builtin_constant_p(dataLen) ? __constant_memcpy((rval->kernel.data),(scont->data),(dataLen)) : __memcpy((rval->kernel.data),(scont->data),(dataLen)));
state_cache_1.c:20682:  int dataLen = scont->dataLen;
state_cache_1.c:20683:  dcont->seq = htonl(scont->seq);
state_cache_1.c:20684:  dcont->validStart = htonl(scont->validStart);
state_cache_1.c:20685:  dcont->validEnd = htonl(scont->validEnd);
state_cache_1.c:20686:  dcont->fields = scont->fields;
state_cache_1.c:20687:  (__builtin_constant_p(dataLen) ? __constant_memcpy((dcont->data),(scont->kernel.data),(dataLen)) : __memcpy((dcont->data),(scont->kernel.data),(dataLen)));
state_cache_1.c:20694:  completeResp->fields |= (0x01);
state_cache_1.c:20701:  int dataLen = scont->dataLen;
state_cache_1.c:20708:  rval->prev = rval->next = ((void *)0);
state_cache_1.c:20709:  rval->list = ((void *)0);
state_cache_1.c:20711:  (__builtin_constant_p(dataLen) ? __constant_memcpy((rval->kernel.data),(scont->kernel.data),(dataLen)) : __memcpy((rval->kernel.data),(scont->kernel.data),(dataLen)));
state_cache_1.c:20727:  return -1;
state_cache_1.c:20751:  return -1;
state_cache_1.c:20760:  wireContinuation->fields = 0;
state_cache_1.c:20764:  char *rval = wireContinuation->data;
state_cache_1.c:20766:  if(wireContinuation->fields & (0x01)) {
state_cache_1.c:20770:  if(wireContinuation->fields & ~((0x01))) {
state_cache_1.c:20780:  resp->type = type;
state_cache_1.c:20781:  resp->error = error;
state_cache_1.c:20782:  resp->len = htons((short)len);
state_cache_1.c:20790:  incompleteResp->ack_seq = htonl(ack_seq);
state_cache_1.c:20791:  incompleteResp->newCont.validStart = htonl(validStart);
state_cache_1.c:20799:  completeResp->ack_seq = htonl(ack_seq);
state_cache_1.c:20800:  completeResp->newCont.seq = htonl(seq);
state_cache_1.c:20801:  completeResp->newCont.validStart = htonl(validStart);
state_cache_1.c:20802:  completeResp->newCont.validEnd = htonl(validEnd);
state_cache_1.c:20803:  completeResp->newCont.fields = 0;
state_cache_1.c:20811:        newContinuationResp->newCont.seq = htonl(seq);
state_cache_1.c:20812:        newContinuationResp->newCont.validStart = htonl(validStart);
state_cache_1.c:20813:        newContinuationResp->newCont.validEnd = htonl(validEnd);
state_cache_1.c:20814:        newContinuationResp->newCont.fields = 0;
state_cache_1.c:20819:         printk("seq=[%d]\n", ucont->seq);
state_cache_1.c:20820:         printk("valid=[%d-%d] [%d-%d]\n", ucont->validStart, ucont->validEnd,
state_cache_1.c:20821:                htonl(ucont->validStart), htonl(ucont->validEnd));
state_cache_1.c:20822:         printk("cvalid=[%d-%d] [%d-%d]\n", ucont->clientValidStart, ucont->clientValidEnd,
state_cache_1.c:20823:                htonl(ucont->clientValidStart), htonl(ucont->clientValidEnd));
state_cache_1.c:20830:        chunk->byteNum = htonl(byteNum);
state_cache_1.c:20831:        chunk->type = RCHUNK_DATA;
state_cache_1.c:20832:        chunk->chunkLen = htons(chunkLen + sizeof(struct DataChunk));
state_cache_1.c:20834:        return (struct DataChunk *) (chunk->data + chunkLen);
state_cache_1.c:20840:        phchunk->type = RCHUNK_PUSH_HINT;
state_cache_1.c:20841:        phchunk->chunkLen = htons(sizeof(struct PushHintChunk));
state_cache_1.c:20842:        phchunk->start = htonl(start);
state_cache_1.c:20843:        phchunk->end = htonl(end);
state_cache_1.c:20864:        ctx->packetNum = 0;
state_cache_1.c:20865:        ctx->packetPos = 0;
state_cache_1.c:20866:        ctx->outputPos = ctx->outputStart = dest;
state_cache_1.c:20867:        ctx->packets = packets;
state_cache_1.c:20868:        ctx->numPackets = numPackets;
state_cache_1.c:20874:        for(i=0; i < ctx->numPackets; i++) {
state_cache_1.c:20875:                printk("Packet [%d] = %d\n", i, ctx->packets[i].len);
state_cache_1.c:20882:               ctx->packetNum, ctx->packetPos, ctx->outputPos, ctx->numPackets, ctx->packets);
state_cache_1.c:20887:        if(ctx->packetNum >= ctx->numPackets) {
state_cache_1.c:20890:        return ctx->packets[ctx->packetNum].len - ctx->packetPos;
state_cache_1.c:20896:        if(numBytes == 0) return ctx->outputPos;
state_cache_1.c:20898:        do { if(ctx->packetNum >= ctx->numPackets) { return ((void *)0); } } while(0);
state_cache_1.c:20900:        if(!(ctx->packetNum <= ctx->numPackets)) {
state_cache_1.c:20901:                if (!(ctx->packetNum <= ctx->numPackets)) { printk("KERNEL: assertion (" "ctx->packetNum <= ctx->numPackets" ") failed at " "/home/ashieh/current/include/net/trickles_packet_helpers.h" "(%d)\n", 845); };
state_cache_1.c:20902:                printk("%d !<= %d\n", ctx->packetNum, ctx->numPackets);
state_cache_1.c:20910:                if (!(numBytes <= ctx->packets[ctx->packetNum].len)) { printk("KERNEL: assertion (" "numBytes <= ctx->packets[ctx->packetNum].len" ") failed at " "/home/ashieh/current/include/net/trickles_packet_helpers.h" "(%d)\n", 854); };
state_cache_1.c:20911:                ctx->outputPos += ctx->packets[ctx->packetNum].len - ctx->packetPos;
state_cache_1.c:20912:                ctx->packetPos = 0;
state_cache_1.c:20913:                ctx->packetNum++;
state_cache_1.c:20915:        temp = ctx->outputPos;
state_cache_1.c:20916:        ctx->packetPos += numBytes;
state_cache_1.c:20917:        ctx->outputPos += numBytes;
state_cache_1.c:20919:        do { if(ctx->packetNum >= ctx->numPackets) { return ((void *)0); } } while(0);
state_cache_1.c:20921:        if (!(ctx->packetPos <= ctx->packets[ctx->packetNum].len)) { printk("KERNEL: assertion (" "ctx->packetPos <= ctx->packets[ctx->packetNum].len" ") failed at " "/home/ashieh/current/include/net/trickles_packet_helpers.h" "(%d)\n", 865); };
state_cache_1.c:20923:        if(ctx->packetPos == ctx->packets[ctx->packetNum].len) {
state_cache_1.c:20924:                ctx->packetPos = 0;
state_cache_1.c:20925:                ctx->packetNum++;
state_cache_1.c:20934:        char *currpos = ctx->outputPos;
state_cache_1.c:20960:                return -1;
state_cache_1.c:20972:        while((char*)(chunk+1) - start < len) {
state_cache_1.c:20973:                int len = ntohs((chunk)->chunkLen) - sizeof(struct DataChunk);
state_cache_1.c:20976:                                printk("bad length chunk(%d) -- ", len);
state_cache_1.c:20984:                chunk = ((void*)((char*)(chunk) + ntohs((chunk)->chunkLen)));
state_cache_1.c:20990:                        return -1;
state_cache_1.c:20993:        if((char*)chunk - start > len) {
state_cache_1.c:20994:                printk("data chunk validation failed, %d > %d\n", (char*)chunk-start, len);
state_cache_1.c:20995:                return -chunknum - 1;
state_cache_1.c:21007:        if (!(gctx->packetNum <= gctx->numPackets)) { printk("KERNEL: assertion (" "gctx->packetNum <= gctx->numPackets" ") failed at " "/home/ashieh/current/include/net/trickles_packet_helpers.h" "(%d)\n", 951); };
state_cache_1.c:21012:        int outputLen = gctx->outputPos - gctx->outputStart;
state_cache_1.c:21013:        char *buf = gctx->outputStart;
state_cache_1.c:21020:        if (!(entry->prev == ((void *)0) && entry->next == ((void *)0) && entry->list == ((void *)0))) { printk("KERNEL: assertion (" "entry->prev == NULL && entry->next == NULL && entry->list == NULL" ") failed at " "/home/ashieh/current/include/net/trickles_client.h" "(%d)\n", 295); };
state_cache_1.c:21022:        freeClientSide_Continuation(entry->cont);
state_cache_1.c:21035:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
state_cache_1.c:21036:        tp->trickles_opt = 0;
state_cache_1.c:21037:        tp->mac_changed = 0;
state_cache_1.c:21041:                (__builtin_constant_p(0) ? (__builtin_constant_p((sizeof(tp->cminisock_api_config))) ? __constant_c_and_count_memset(((&tp->cminisock_api_config)),((0x01010101UL*(unsigned char)(0))),((sizeof(tp->cminisock_api_config)))) : __constant_c_memset(((&tp->cminisock_api_config)),((0x01010101UL*(unsigned char)(0))),((sizeof(tp->cminisock_api_config))))) : (__builtin_constant_p((sizeof(tp->cminisock_api_config))) ? __memset_generic((((&tp->cminisock_api_config))),(((0))),(((sizeof(tp->cminisock_api_config))))) : __memset_generic(((&tp->cminisock_api_config)),((0)),((sizeof(tp->cminisock_api_config))))));
state_cache_1.c:21042:                init_head(&tp->cminisock_api_config.msk_freelist);
state_cache_1.c:21044:                tp->cminisock_api_config.cfg.ctl = ((void *)0);
state_cache_1.c:21046:                tp->cminisock_api_config.event_lock = (rwlock_t) { };
state_cache_1.c:21049:        tp->t.malloc_initialized = 0;
state_cache_1.c:21051:        tp->t.heapbytesize = 0;
state_cache_1.c:21052:        tp->t.heapbytesallocated = 0;
state_cache_1.c:21055:                tp->t.fragblocks[i] = 0;
state_cache_1.c:21056:                tp->t.fraghead[i].next = tp->t.fraghead[i].prev = ((void *)0);
state_cache_1.c:21059:        tp->t.clientStateCounter = 0;
state_cache_1.c:21060:        tp->t.state = 1;
state_cache_1.c:21061:        tp->t.A = 0;
state_cache_1.c:21062:        tp->t.D = 0;
state_cache_1.c:21063:        tp->t.RTO = 0;
state_cache_1.c:21064:        tp->t.timerState = 0;
state_cache_1.c:21065:        tp->t.rcv_nxt = 0;
state_cache_1.c:21066:        tp->t.previous_base = 0;
state_cache_1.c:21067:        skb_queue_head_init(&tp->t.ofo_queue);
state_cache_1.c:21069:        tp->t.ack_prev = ((void *)0);
state_cache_1.c:21071:        tp->t.ack_last = 0;
state_cache_1.c:21072:        tp->t.oo_count = 0;
state_cache_1.c:21073:        tp->t.in_flight = 0;
state_cache_1.c:21075:        tp->t.standardProof.numSacks = 0;
state_cache_1.c:21076:        tp->t.altProof.numSacks = 0;
state_cache_1.c:21079:        tp->t.dprev = tp->t.dnext = ((void *)0);
state_cache_1.c:21080:        tp->t.dbg_skb = ((void *)0);
state_cache_1.c:21081:        init_head(&tp->t.cont_list);
state_cache_1.c:21083:        init_timer(&tp->t.slowstart_timer);
state_cache_1.c:21087:        tp->t.request_rcv_nxt = 0;
state_cache_1.c:21088:        tp->t.request_snd_nxt = 0;
state_cache_1.c:21089:        init_head(&tp->t.request_ofo_queue);
state_cache_1.c:21090:        skb_queue_head_init(&tp->t.data_ofo_queue);
state_cache_1.c:21091:        init_head(&tp->t.sentRequests);
state_cache_1.c:21092:        init_head(&tp->t.queuedRequests);
state_cache_1.c:21094:        init_head(&tp->t.dataRequestMap);
state_cache_1.c:21095:        init_head(&tp->t.missingDataMap);
state_cache_1.c:21097:        tp->t.byteReqNext = 0;
state_cache_1.c:21098:        tp->t.byteReqHint = ((void *)0);
state_cache_1.c:21102:        tp->t.conversionState = (1);
state_cache_1.c:21103:        tp->t.snd_una = tp->t.write_seq = 0;
state_cache_1.c:21104:        tp->t.snd_end = 0;
state_cache_1.c:21105:        skb_queue_head_init(&tp->t.requestBytes);
state_cache_1.c:21106:        tp->t.newIncompleteRequest = ((void *)0);
state_cache_1.c:21107:        tp->t.prevConvCont = ((void *)0);
state_cache_1.c:21109:        init_head(&tp->t.ucontList);
state_cache_1.c:21110:        init_head(&tp->t.depNodeList);
state_cache_1.c:21116:        tp->t.nonceCTX = ((void *)0);
state_cache_1.c:21117:        skb_queue_head_init(&tp->t.prequeueOverflow);
state_cache_1.c:21118:        skb_queue_head_init(&tp->t.sendAckOverflow);
state_cache_1.c:21119:        skb_queue_head_init(&tp->t.recycleList);
state_cache_1.c:21121:        tp->t.responseMSK = ((void *)0);
state_cache_1.c:21122:        init_head(&tp->t.responseList);
state_cache_1.c:21123:        tp->t.responseCount = 0;
state_cache_1.c:21125:        tp->t.events = ((void *)0);
state_cache_1.c:21126:        tp->drop_rate = 0;
state_cache_1.c:21127:        tp->instrumentation = 0;
state_cache_1.c:21242:        msk->num_packets = 0;
state_cache_1.c:21243:        msk->ucont_len = 0;
state_cache_1.c:21244:        msk->ucont_data = ((void *)0);
state_cache_1.c:21245:        msk->input_len = 0;
state_cache_1.c:21246:        msk->input = ((void *)0);
state_cache_1.c:21247:        msk->packets = ((void *)0);
state_cache_1.c:21249:        msk->refCnt = 1;
state_cache_1.c:21251:        msk->cacheRecycleIndex = -1;
state_cache_1.c:21252:        msk->serverSK = ((void *)0);
state_cache_1.c:21253:        msk->pmsk = ((void *)0);
state_cache_1.c:21254:        msk->isStatic = 0;
state_cache_1.c:21258:        pmsk->num_packets = 0;
state_cache_1.c:21259:        pmsk->ucont_len = 0;
state_cache_1.c:21260:        pmsk->ucont_data = ((void *)0);
state_cache_1.c:21261:        pmsk->input_len = 0;
state_cache_1.c:21262:        pmsk->input = ((void *)0);
state_cache_1.c:21263:        pmsk->packets = ((void *)0);
state_cache_1.c:21264:        pmsk->refCnt = 1;
state_cache_1.c:21276:        if(msk->num_packets > 0) {
state_cache_1.c:21277:                printk("msk packets is %d\n", msk->num_packets);
state_cache_1.c:21279:        if (!(msk->num_packets == 0)) { printk("KERNEL: assertion (" "msk->num_packets == 0" ") failed at " "/home/ashieh/current/include/net/trickles_minisock_functions.h" "(%d)\n", 45); };
state_cache_1.c:21283:        if(!(((msk->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((msk->sk)->tp_pinfo.af_tcp.trickles_opt & (msk->sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) {
state_cache_1.c:21284:                msk->packets = tmalloc(msk->sk, sizeof(struct cminisock_packet) * numPackets);
state_cache_1.c:21288:                if(msk->packets == ((void *)0)) {
state_cache_1.c:21297:                        msk->packets = packets[0];
state_cache_1.c:21299:                        msk->packets = ((void *)0);
state_cache_1.c:21306:        msk->num_packets = numPackets;
state_cache_1.c:21312:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
state_cache_1.c:21313:        struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
state_cache_1.c:21315:                (struct cminisock *)head->next;
state_cache_1.c:21316:        while((struct alloc_head_list*)curr != head && curr->ctl == ALLOC_PROCESSING) {
state_cache_1.c:21318:                curr = curr->next;
state_cache_1.c:21324:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
state_cache_1.c:21325:        struct list_link *phead = (struct list_link *)&tp->cminisock_api_config.pmsk_freelist;
state_cache_1.c:21327:                tp->cminisock_api_config.pmsk_freelist.next;
state_cache_1.c:21329:        if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) {
state_cache_1.c:21331:                      pcurr->ctl == ALLOC_PROCESSING) {
state_cache_1.c:21333:                        pcurr = pcurr->next;
state_cache_1.c:21348:        rval->ctl = ALLOC_PENDING;
state_cache_1.c:21356:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
state_cache_1.c:21357:        struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
state_cache_1.c:21359:                tp->cminisock_api_config.msk_freelist.next;
state_cache_1.c:21361:        if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) {
state_cache_1.c:21363:                      curr->ctl == ALLOC_PROCESSING) {
state_cache_1.c:21365:                        curr = curr->next;
state_cache_1.c:21376:                rval->ctl = ALLOC_PENDING;
state_cache_1.c:21378:                if(tp->t.responseCount == 0) {
state_cache_1.c:21379:                        rval = tp->t.responseMSK;
state_cache_1.c:21380:                        rval->list = ((void *)0);
state_cache_1.c:21381:                        rval->next = rval->prev = ((void *)0);
state_cache_1.c:21388:                        rval->next = rval->prev = ((void *)0);
state_cache_1.c:21389:                        rval->list = ((void *)0);
state_cache_1.c:21390:                        insert_tail(&tp->t.responseList, (struct alloc_head*)rval);
state_cache_1.c:21392:                tp->t.responseCount++;
state_cache_1.c:21394:                rval->sk = sk;
state_cache_1.c:21395:                rval->ctl = ALLOC_PENDING;
state_cache_1.c:21411:static inline void msk_hold(struct cminisock *msk) { msk->refCnt++; } static struct cminisock *shallow_copy_msk(struct sock *sk, struct cminisock *pmsk) { struct cminisock *rval = alloc_trickles_msk(sk); struct alloc_head_list head; if(rval == ((void *)0)) { struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp); printk("out of memory while shallow copying msk\n"); printk("list len is %d\n", tp->cminisock_api_config.msk_freelist.len); return ((void *)0); } head = *(struct alloc_head_list *)rval; *rval = *pmsk; *(struct alloc_head_list *)rval = head; rval->refCnt = 1; rval->isStatic = 0; return rval; } static struct cminisock *copy_msk(struct sock *sk, struct cminisock *pmsk) { struct cminisock *rval = shallow_copy_msk(sk, pmsk); if(rval == ((void *)0)) { printk("out of memory while copying msk\n"); return ((void *)0); } rval->num_packets = 0; rval->packets = ((void *)0); rval->pmsk = ((void *)0); if(rval->ucont_len > 0) { rval->ucont_data = tmalloc(sk,rval->ucont_len); if(rval->ucont_data == ((void *)0)) { printk("out of tmalloc memory while copying msk (len = %d)\n", rval->ucont_len); free_trickles_msk(sk,rval); free_trickles_msk_finish(sk,rval); return ((void *)0); } } else { rval->ucont_data = ((void *)0); } if(rval->input_len > 0) { rval->input = tmalloc(sk,rval->input_len); if(rval->input == ((void *)0)) { printk("out of tmalloc memory while copying msk (%s len = %d)\n", "msk", rval->input_len); tfree(sk,rval->ucont_data); free_trickles_msk(sk,rval); free_trickles_msk_finish(sk,rval); return ((void *)0); } } else { rval->input = ((void *)0); } if(rval->ucont_data) (__builtin_constant_p(rval->ucont_len) ? __constant_memcpy((rval->ucont_data),(pmsk->ucont_data),(rval->ucont_len)) : __memcpy((rval->ucont_data),(pmsk->ucont_data),(rval->ucont_len))); if(rval->input) (__builtin_constant_p(rval->input_len) ? __constant_memcpy((rval->input),(pmsk->input),(rval->input_len)) : __memcpy((rval->input),(pmsk->input),(rval->input_len))); return rval; } static void free_trickles_msk(struct sock *sk, struct cminisock *msk) { if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) { if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) { printk("double free\n"); do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } if(msk->ctl == ALLOC_READY && msk->prev != ((void *)0)) { unlink((struct alloc_head*)msk); } msk->ctl = ALLOC_PROCESSING; } } static void free_msk(struct sock *sk, struct cminisock *msk) { int i; for(i=0; i < msk->num_packets; i++) { if(msk->packets[i].ucontData != ((void *)0)) { kfree(msk->packets[i].ucontData); } } if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8)) && msk->packets) { tfree(sk,msk->packets); msk->packets = ((void *)0); } msk->num_packets = 0; if(msk->ucont_data != ((void *)0)) { tfree(sk,msk->ucont_data); msk->ucont_data = ((void *)0); } msk->ucont_len = 0; if(msk->input != ((void *)0)) { tfree(sk,msk->input); msk->input = ((void *)0); } msk->input_len = 0; } static void msk_release(struct sock *sk, struct cminisock *msk) { msk->refCnt--; if (!(msk->refCnt <= 3)) { printk("KERNEL: assertion (" "msk->refCnt <= 3" ") failed at " "/home/ashieh/current/include/net/trickles_minisock_functions.h" "(%d)\n", 373); }; if(msk->refCnt == 0) { struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp); struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist; free_msk(sk,msk); if(!msk->isStatic) { if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) { insert_head((head), (struct alloc_head *)(msk)); msk->ctl = ALLOC_FREE; } else { if(msk != tp->t.responseMSK) { unlink((struct alloc_head*)msk); kfree(msk); } tp->t.responseCount--; } } } else { } if(msk->pmsk != ((void *)0)) { struct pminisock *pmsk = msk->pmsk; free_trickles_pmsk(sk, pmsk); free_trickles_pmsk_finish(sk, pmsk); }; } static void free_trickles_msk_finish(struct sock *sk, struct cminisock *msk) { if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) { if(msk->ctl != ALLOC_PROCESSING && msk->ctl != ALLOC_HALFFREE) { printk("(free_trickles_msk_finish %s) without corresponding free_trickles_msk: msk->ctl = %d\n", "msk", msk->ctl); do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } } msk_release(sk,msk); } static inline void msk_clear_fields(struct cminisock *msk) { msk->num_packets = 0; msk->packets = ((void *)0); msk->ucont_len = 0; msk->ucont_data = ((void *)0); msk->input_len = 0; msk->input = ((void *)0); };
state_cache_1.c:21413:static inline void pmsk_hold(struct pminisock *msk) { msk->refCnt++; } static struct pminisock *shallow_copy_pmsk(struct sock *sk, struct pminisock *pmsk) { struct pminisock *rval = alloc_trickles_pmsk(sk); struct list_link head; if(rval == ((void *)0)) { struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp); printk("out of memory while shallow copying msk\n"); ; return ((void *)0); } head = *(struct list_link *)rval; *rval = *pmsk; *(struct list_link *)rval = head; rval->refCnt = 1; return rval; } static struct pminisock *copy_pmsk(struct sock *sk, struct pminisock *pmsk) { struct pminisock *rval = shallow_copy_pmsk(sk, pmsk); if(rval == ((void *)0)) { printk("out of memory while copying msk\n"); return ((void *)0); } rval->num_packets = 0; rval->packets = ((void *)0); if(rval->ucont_len > 0) { rval->ucont_data = tmalloc(sk,rval->ucont_len); if(rval->ucont_data == ((void *)0)) { printk("out of tmalloc memory while copying msk (len = %d)\n", rval->ucont_len); free_trickles_pmsk(sk,rval); free_trickles_pmsk_finish(sk,rval); return ((void *)0); } } else { rval->ucont_data = ((void *)0); } if(rval->input_len > 0) { rval->input = tmalloc(sk,rval->input_len); if(rval->input == ((void *)0)) { printk("out of tmalloc memory while copying msk (%s len = %d)\n", "pmsk", rval->input_len); tfree(sk,rval->ucont_data); free_trickles_pmsk(sk,rval); free_trickles_pmsk_finish(sk,rval); return ((void *)0); } } else { rval->input = ((void *)0); } if(rval->ucont_data) (__builtin_constant_p(rval->ucont_len) ? __constant_memcpy((rval->ucont_data),(pmsk->ucont_data),(rval->ucont_len)) : __memcpy((rval->ucont_data),(pmsk->ucont_data),(rval->ucont_len))); if(rval->input) (__builtin_constant_p(rval->input_len) ? __constant_memcpy((rval->input),(pmsk->input),(rval->input_len)) : __memcpy((rval->input),(pmsk->input),(rval->input_len))); return rval; } static void free_trickles_pmsk(struct sock *sk, struct pminisock *msk) { if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) { if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) { printk("double free\n"); do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } if(msk->ctl == ALLOC_READY && msk->prev != ((void *)0)) { dlist_unlink((struct list_link*)(msk)); } msk->ctl = ALLOC_PROCESSING; } } static void free_pmsk(struct sock *sk, struct pminisock *msk) { int i; for(i=0; i < msk->num_packets; i++) { if(msk->packets[i].ucontData != ((void *)0)) { kfree(msk->packets[i].ucontData); } } if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8)) && msk->packets) { tfree(sk,msk->packets); msk->packets = ((void *)0); } msk->num_packets = 0; if(msk->ucont_data != ((void *)0)) { tfree(sk,msk->ucont_data); msk->ucont_data = ((void *)0); } msk->ucont_len = 0; if(msk->input != ((void *)0)) { tfree(sk,msk->input); msk->input = ((void *)0); } msk->input_len = 0; } static void pmsk_release(struct sock *sk, struct pminisock *msk) { msk->refCnt--; if (!(msk->refCnt <= 3)) { printk("KERNEL: assertion (" "msk->refCnt <= 3" ") failed at " "/home/ashieh/current/include/net/trickles_minisock_functions.h" "(%d)\n", 384); }; if(msk->refCnt == 0) { struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp); struct dlist *head = &tp->cminisock_api_config.pmsk_freelist; free_pmsk(sk,msk); if(!!(msk >= (struct pminisock *)tp->cminisock_api_config.cfg.ctl->pminisock_base && (msk+1) <= (struct pminisock *)tp->cminisock_api_config.cfg.ctl->pminisock_limit)) { if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) { dlist_insert_head(head, (struct list_link*)(msk)); msk->ctl = ALLOC_FREE; } else { ; } } } else { } ; } static void free_trickles_pmsk_finish(struct sock *sk, struct pminisock *msk) { if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) { if(msk->ctl != ALLOC_PROCESSING && msk->ctl != ALLOC_HALFFREE) { printk("(free_trickles_msk_finish %s) without corresponding free_trickles_msk: msk->ctl = %d\n", "pmsk", msk->ctl); do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } } pmsk_release(sk,msk); } static inline void pmsk_clear_fields(struct pminisock *msk) { msk->num_packets = 0; msk->packets = ((void *)0); msk->ucont_len = 0; msk->ucont_data = ((void *)0); msk->input_len = 0; msk->input = ((void *)0); };
state_cache_1.c:21425:        skb->next = ((void *)0);
state_cache_1.c:21426:        skb->prev = ((void *)0);
state_cache_1.c:21427:        skb->list = ((void *)0);
state_cache_1.c:21428:        skb->sk = ((void *)0);
state_cache_1.c:21429:        skb->stamp.tv_sec=0;
state_cache_1.c:21430:        skb->dev = ((void *)0);
state_cache_1.c:21431:        skb->real_dev = ((void *)0);
state_cache_1.c:21432:        skb->dst = ((void *)0);
state_cache_1.c:21433:        (__builtin_constant_p(0) ? (__builtin_constant_p((sizeof(skb->cb))) ? __constant_c_and_count_memset(((skb->cb)),((0x01010101UL*(unsigned char)(0))),((sizeof(skb->cb)))) : __constant_c_memset(((skb->cb)),((0x01010101UL*(unsigned char)(0))),((sizeof(skb->cb))))) : (__builtin_constant_p((sizeof(skb->cb))) ? __memset_generic((((skb->cb))),(((0))),(((sizeof(skb->cb))))) : __memset_generic(((skb->cb)),((0)),((sizeof(skb->cb))))));
state_cache_1.c:21434:        skb->pkt_type = 0;
state_cache_1.c:21435:        skb->ip_summed = 0;
state_cache_1.c:21436:        skb->priority = 0;
state_cache_1.c:21437:        skb->security = 0;
state_cache_1.c:21438:        skb->destructor = ((void *)0);
state_cache_1.c:21441:        skb->nfmark = skb->nfcache = 0;
state_cache_1.c:21442:        skb->nfct = ((void *)0);
state_cache_1.c:21448:        skb->tc_index = 0;
state_cache_1.c:21454:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_1.c:21455:        int r0 = ((struct skb_shared_info *)((skb)->end))->nr_frags != 0,
state_cache_1.c:21456:                r1 = tp->t.recycleList.qlen >= (1000),
state_cache_1.c:21457:                r2 = skb->truesize - sizeof(struct sk_buff) < ((128 + 32) + (sizeof(WireTrickleResponse)) + (sysctl_trickles_mss));
state_cache_1.c:21461:                                printk("Unsuitable for recycling %d %d %d truesize = %d skblen = %d\n", r0, r1, r2, skb->truesize, ((128 + 32) + (sizeof(WireTrickleResponse)) + (sysctl_trickles_mss)));
state_cache_1.c:21469:        skb->tail = skb->data = skb->head;
state_cache_1.c:21470:        skb->len = 0;
state_cache_1.c:21471:        skb->cloned = 0;
state_cache_1.c:21472:        skb->data_len =0;
state_cache_1.c:21474:        (((&skb->users)->counter) = (1));
state_cache_1.c:21475:        (((&(((struct skb_shared_info *)((skb)->end))->dataref))->counter) = (1));
state_cache_1.c:21476:        ((struct skb_shared_info *)((skb)->end))->nr_frags = 0;
state_cache_1.c:21477:        ((struct skb_shared_info *)((skb)->end))->frag_list = ((void *)0);
state_cache_1.c:21479:        __skb_queue_tail(&tp->t.recycleList, skb);
state_cache_1.c:21488:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_1.c:21490:        struct sk_buff *skb = __skb_dequeue_tail(&tp->t.recycleList);
state_cache_1.c:21525:      { a=a-b; a=a-c; a=a^(c>>13); b=b-c; b=b-a; b=b^(a<<8); c=c-a; c=c-b; c=c^(b>>13); a=a-b; a=a-c; a=a^(c>>12); b=b-c; b=b-a; b=b^(a<<16); c=c-a; c=c-b; c=c^(b>>5); a=a-b; a=a-c; a=a^(c>>3); b=b-c; b=b-a; b=b^(a<<10); c=c-a; c=c-b; c=c^(b>>15); };
state_cache_1.c:21526:      k = k+12; len = len-12;
state_cache_1.c:21547:   { a=a-b; a=a-c; a=a^(c>>13); b=b-c; b=b-a; b=b^(a<<8); c=c-a; c=c-b; c=c^(b>>13); a=a-b; a=a-c; a=a^(c>>12); b=b-c; b=b-a; b=b^(a<<16); c=c-a; c=c-b; c=c^(b>>5); a=a-b; a=a-c; a=a^(c>>3); b=b-c; b=b-a; b=b^(a<<10); c=c-a; c=c-b; c=c^(b>>15); };
state_cache_1.c:21555:        int runStart = -1;
state_cache_1.c:21565:                                printk("[%d-%d]: ", runStart, i - 1);
state_cache_1.c:21580:        for (elem = (typeof(elem))(list)->next; (elem != (typeof(elem))(list)); elem=(typeof(elem))elem->next) {
state_cache_1.c:21581:                do { if(!(elem->list == list)) { printk("(%s) failed at %s:%s():%d\n", "elem->list == list", "cache_util.h", __PRETTY_FUNCTION__, 135); return 0; } } while(0);
state_cache_1.c:21584:        do { if(!(count == list->len)) { printk("(%s) failed at %s:%s():%d\n", "count == list->len", "cache_util.h", __PRETTY_FUNCTION__, 138); return 0; } } while(0);
state_cache_1.c:21608:        key.seq = cmsk->pmsk->seq;
state_cache_1.c:21613:        return hash((u1 *)&key->seq, sizeof(key->seq), 0);
state_cache_1.c:21623:                k0->seq == k1->seq;
state_cache_1.c:21634:        if(cmsk->pmsk == ((void *)0)) {
state_cache_1.c:21638:                pmsk_release(sk, cmsk->pmsk);
state_cache_1.c:21641:        cmsk->pmsk = ((void *)0);
state_cache_1.c:21644:struct ParsedPMinisock_cell { struct pminisock_key key; struct cached_pminisock elem; }; struct ParsedPMinisock_bucket { struct ParsedPMinisock_cell fastCell; }; struct ParsedPMinisock_cache_root { struct ParsedPMinisock_bucket buckets[(128)]; int count; int numBuckets; int maxCount; int hitCount; int total; int cellMem; int maxCellMem; int linkCount; int lookupCount; void *evictContext; struct ParsedPMinisock_cell *cells; } ParsedPMinisock_cache; static inline int ParsedPMinisock_isFastCell(struct ParsedPMinisock_cell *cell) { struct ParsedPMinisock_cache_root *cache = &ParsedPMinisock_cache; return cell >= (struct ParsedPMinisock_cell*)cache->buckets && cell < (struct ParsedPMinisock_cell*)(cache->buckets + (128)); } static struct ParsedPMinisock_cell *ParsedPMinisock_newCell(void); static void ParsedPMinisock_deleteCell(struct ParsedPMinisock_cell *cell); static int ParsedPMinisock_integrityCheck(void); static void ParsedPMinisock_evictOne(struct ParsedPMinisock_cell **cell); static int ParsedPMinisock_evict(int toEvict); static void ParsedPMinisock_cache_init(void) { struct ParsedPMinisock_cache_root *cache = &ParsedPMinisock_cache; cache->count = 0; cache->numBuckets = (128); cache->maxCount = (128); cache->hitCount = 0; cache->total = 0; cache->cellMem = 0; cache->maxCellMem = 0; cache->linkCount = 0; cache->lookupCount = 0; int i; for(i=0; i < cache->numBuckets; i++) { struct ParsedPMinisock_bucket *bucket = &cache->buckets[i]; *(int*)&(bucket)->fastCell.elem = 0; } ; } static void ParsedPMinisock_cache_invalidate(void) { struct ParsedPMinisock_cache_root *cache = &ParsedPMinisock_cache; int i; for(i=0; i < cache->numBuckets; i++) { struct ParsedPMinisock_bucket *bucket = &cache->buckets[i]; if((*(int*)&(bucket)->fastCell.elem != 0)) { pminisock_evict(cache->evictContext, &bucket->fastCell.elem); ParsedPMinisock_deleteCell(&bucket->fastCell); } } } static void ParsedPMinisock_cache_destroy(void) { ParsedPMinisock_cache_invalidate(); } static int ParsedPMinisock_getCount(void) { ; return ParsedPMinisock_cache.count; } static int ParsedPMinisock_integrityCheck(void) { struct ParsedPMinisock_cache_root *cache = &ParsedPMinisock_cache; (cache->hitCount >= 0 && cache->total >= 0 && cache->hitCount <= cache->total) || ((({ printk("stat integrity" "\n"); 1; })) && ({ return(0); 1; })); int i, lookupCount = 0; for(i=0; i < cache->numBuckets; i++) { struct ParsedPMinisock_bucket *bucket = &cache->buckets[i]; if((*(int*)&(bucket)->fastCell.elem != 0)) { struct ParsedPMinisock_cell *cell = &bucket->fastCell; ( (pminisock_hash(&cell->key) % ParsedPMinisock_cache.numBuckets) == i ) || ( (({ printk("pminisock hash index integrity" "\n"); 1; })) && ({ return(0); 1; }) ); lookupCount++; } } do { if(!(lookupCount == cache->count)) { printk("(%s) failed at %s:%s():%d\n", "lookupCount == cache->count", "state_cache.c", __PRETTY_FUNCTION__, 120); return 0; } } while(0); do { if(!(cache->count <= cache->maxCount)) { printk("(%s) failed at %s:%s():%d\n", "cache->count <= cache->maxCount", "state_cache.c", __PRETTY_FUNCTION__, 120); return 0; } } while(0); return 1; } static void ParsedPMinisock_resetStats(void) { struct ParsedPMinisock_cache_root *cache = &ParsedPMinisock_cache; cache->hitCount = 0; cache->total = 0; } static struct ParsedPMinisock_cell *ParsedPMinisock_findInBucket(struct ParsedPMinisock_bucket *bucket, struct pminisock_key *key) { struct ParsedPMinisock_cache_root *cache = &ParsedPMinisock_cache; cache->lookupCount++; if((*(int*)&(bucket)->fastCell.elem != 0)) { struct ParsedPMinisock_cell *cell = &bucket->fastCell; if(pminisock_cmp(key, ((void *)0), &cell->key, &cell->elem)) { return cell; } } return ((void *)0); } static struct ParsedPMinisock_cell *ParsedPMinisock_insert_helper(struct pminisock_key *key) { struct ParsedPMinisock_cache_root *cache = &ParsedPMinisock_cache; struct ParsedPMinisock_bucket *bucket = &cache->buckets[pminisock_hash(key) % cache->numBuckets]; struct ParsedPMinisock_cell *cell = ((void *)0); if(!(*(int*)&(bucket)->fastCell.elem != 0)) { cell = &bucket->fastCell; } else { cell = &bucket->fastCell; pminisock_evict(cache->evictContext, &cell->elem); ParsedPMinisock_deleteCell(cell); } cache->count++; cell->key = *key; return cell; } static int ParsedPMinisock_insert(struct cached_pminisock *elem) { ; struct pminisock_key key = pminisock_toKey(elem); struct ParsedPMinisock_cell *cell = ParsedPMinisock_insert_helper(&key); if(cell == ((void *)0)) return 0; cell->elem = *elem; ; return 1; } static int ParsedPMinisock_find_helper(struct pminisock_key *key, struct ParsedPMinisock_cell **hint) { struct ParsedPMinisock_cache_root *cache = &ParsedPMinisock_cache; struct ParsedPMinisock_bucket *bucket = &cache->buckets[pminisock_hash(key) % cache->numBuckets]; struct ParsedPMinisock_cell *lookup; lookup = ParsedPMinisock_findInBucket(bucket, key); if(lookup != ((void *)0)) { *hint = lookup; } ; int found = lookup != ((void *)0); if(found) { cache->hitCount++; } cache->total++; return found; } static int ParsedPMinisock_find(struct pminisock_key *key, struct cached_pminisock *result) { struct ParsedPMinisock_cell *cell = ((void *)0); int found = ParsedPMinisock_find_helper(key, &cell); if(found) { *result = cell->elem; } ; return found; } static void ParsedPMinisock_freeCell(struct ParsedPMinisock_cell *cell); static void ParsedPMinisock_deleteCell(struct ParsedPMinisock_cell *cell) { ParsedPMinisock_freeCell(cell); } static int ParsedPMinisock_delete(struct pminisock_key *key) { struct ParsedPMinisock_cell *cell = ((void *)0); int found = ParsedPMinisock_find_helper(key, &cell); if((found)) { ParsedPMinisock_deleteCell(cell); } ; return found; } static void ParsedPMinisock_freeCell(struct ParsedPMinisock_cell *cell) { struct ParsedPMinisock_bucket *bucket = ((struct ParsedPMinisock_bucket*) (((char*) cell) - ((char*) &((struct ParsedPMinisock_bucket*)0)->fastCell))); *(int*)&(bucket)->fastCell.elem = 0; };
state_cache_1.c:21661:                struct pminisock *pmsk = cell->elem.pmsk;
state_cache_1.c:21665:                     pmsk->daddr == iph->saddr &&
state_cache_1.c:21666:                     pmsk->dest == th->source)) {
state_cache_1.c:21691:        key.seq = pmsk->seq;
state_cache_1.c:21696:                cell->elem.pmsk = pmsk;
state_cache_1.c:21719:        return seqnoToKey(msk->hdr.seq);
state_cache_1.c:21742:        return map->key;
state_cache_1.c:21758:struct Continuation_cell { CachedWireContinuationKey key; struct CachedWireContinuation elem; }; struct Continuation_bucket { struct Continuation_cell fastCell; }; struct Continuation_cache_root { struct Continuation_bucket buckets[(128)]; int count; int numBuckets; int maxCount; int hitCount; int total; int cellMem; int maxCellMem; int linkCount; int lookupCount; void *evictContext; struct Continuation_cell *cells; } Continuation_cache; static inline int Continuation_isFastCell(struct Continuation_cell *cell) { struct Continuation_cache_root *cache = &Continuation_cache; return cell >= (struct Continuation_cell*)cache->buckets && cell < (struct Continuation_cell*)(cache->buckets + (128)); } static struct Continuation_cell *Continuation_newCell(void); static void Continuation_deleteCell(struct Continuation_cell *cell); static int Continuation_integrityCheck(void); static void Continuation_evictOne(struct Continuation_cell **cell); static int Continuation_evict(int toEvict); static void Continuation_cache_init(void) { struct Continuation_cache_root *cache = &Continuation_cache; cache->count = 0; cache->numBuckets = (128); cache->maxCount = (128); cache->hitCount = 0; cache->total = 0; cache->cellMem = 0; cache->maxCellMem = 0; cache->linkCount = 0; cache->lookupCount = 0; int i; for(i=0; i < cache->numBuckets; i++) { struct Continuation_bucket *bucket = &cache->buckets[i]; *(int*)&(bucket)->fastCell.elem = 0; } ; } static void Continuation_cache_invalidate(void) { struct Continuation_cache_root *cache = &Continuation_cache; int i; for(i=0; i < cache->numBuckets; i++) { struct Continuation_bucket *bucket = &cache->buckets[i]; if((*(int*)&(bucket)->fastCell.elem != 0)) { CachedWireContinuation_evict(cache->evictContext, &bucket->fastCell.elem); Continuation_deleteCell(&bucket->fastCell); } } } static void Continuation_cache_destroy(void) { Continuation_cache_invalidate(); } static int Continuation_getCount(void) { ; return Continuation_cache.count; } static int Continuation_integrityCheck(void) { struct Continuation_cache_root *cache = &Continuation_cache; (cache->hitCount >= 0 && cache->total >= 0 && cache->hitCount <= cache->total) || ((({ printk("stat integrity" "\n"); 1; })) && ({ return(0); 1; })); int i, lookupCount = 0; for(i=0; i < cache->numBuckets; i++) { struct Continuation_bucket *bucket = &cache->buckets[i]; if((*(int*)&(bucket)->fastCell.elem != 0)) { struct Continuation_cell *cell = &bucket->fastCell; ( (CachedWireContinuation_hash(&cell->key) % Continuation_cache.numBuckets) == i ) || ( (({ printk("hash index integrity %X %X, %d %d" "\n", cell->key, CachedWireContinuation_hash(&cell->key), CachedWireContinuation_hash(&cell->key) % Continuation_cache.numBuckets, i); 1; })) && ({ return(0); 1; }) ); lookupCount++; } } do { if(!(lookupCount == cache->count)) { printk("(%s) failed at %s:%s():%d\n", "lookupCount == cache->count", "state_cache.c", __PRETTY_FUNCTION__, 275); return 0; } } while(0); do { if(!(cache->count <= cache->maxCount)) { printk("(%s) failed at %s:%s():%d\n", "cache->count <= cache->maxCount", "state_cache.c", __PRETTY_FUNCTION__, 275); return 0; } } while(0); return 1; } static void Continuation_resetStats(void) { struct Continuation_cache_root *cache = &Continuation_cache; cache->hitCount = 0; cache->total = 0; } static struct Continuation_cell *Continuation_findInBucket(struct Continuation_bucket *bucket, CachedWireContinuationKey *key) { struct Continuation_cache_root *cache = &Continuation_cache; cache->lookupCount++; if((*(int*)&(bucket)->fastCell.elem != 0)) { struct Continuation_cell *cell = &bucket->fastCell; if(CachedWireContinuation_cache_cmp(key, ((void *)0), &cell->key, &cell->elem)) { return cell; } } return ((void *)0); } static struct Continuation_cell *Continuation_insert_helper(CachedWireContinuationKey *key) { struct Continuation_cache_root *cache = &Continuation_cache; struct Continuation_bucket *bucket = &cache->buckets[CachedWireContinuation_hash(key) % cache->numBuckets]; struct Continuation_cell *cell = ((void *)0); if(!(*(int*)&(bucket)->fastCell.elem != 0)) { cell = &bucket->fastCell; } else { cell = &bucket->fastCell; CachedWireContinuation_evict(cache->evictContext, &cell->elem); Continuation_deleteCell(cell); } cache->count++; cell->key = *key; return cell; } static int Continuation_insert(struct CachedWireContinuation *elem) { ; CachedWireContinuationKey key = CachedWireContinuation_toKey(elem); struct Continuation_cell *cell = Continuation_insert_helper(&key); if(cell == ((void *)0)) return 0; cell->elem = *elem; ; return 1; } static int Continuation_find_helper(CachedWireContinuationKey *key, struct Continuation_cell **hint) { struct Continuation_cache_root *cache = &Continuation_cache; struct Continuation_bucket *bucket = &cache->buckets[CachedWireContinuation_hash(key) % cache->numBuckets]; struct Continuation_cell *lookup; lookup = Continuation_findInBucket(bucket, key); if(lookup != ((void *)0)) { *hint = lookup; } ; int found = lookup != ((void *)0); if(found) { cache->hitCount++; } cache->total++; return found; } static int Continuation_find(CachedWireContinuationKey *key, struct CachedWireContinuation *result) { struct Continuation_cell *cell = ((void *)0); int found = Continuation_find_helper(key, &cell); if(found) { *result = cell->elem; } ; return found; } static void Continuation_freeCell(struct Continuation_cell *cell); static void Continuation_deleteCell(struct Continuation_cell *cell) { Continuation_freeCell(cell); } static int Continuation_delete(CachedWireContinuationKey *key) { struct Continuation_cell *cell = ((void *)0); int found = Continuation_find_helper(key, &cell); if((found)) { Continuation_deleteCell(cell); } ; return found; } static void Continuation_freeCell(struct Continuation_cell *cell) { struct Continuation_bucket *bucket = ((struct Continuation_bucket*) (((char*) cell) - ((char*) &((struct Continuation_bucket*)0)->fastCell))); *(int*)&(bucket)->fastCell.elem = 0; };
state_cache_1.c:21760:struct NonceKey_cell { __u64 key; struct NonceMap elem; }; struct NonceKey_bucket { struct NonceKey_cell fastCell; }; struct NonceKey_cache_root { struct NonceKey_bucket buckets[(32)]; int count; int numBuckets; int maxCount; int hitCount; int total; int cellMem; int maxCellMem; int linkCount; int lookupCount; void *evictContext; struct NonceKey_cell *cells; } NonceKey_cache; static inline int NonceKey_isFastCell(struct NonceKey_cell *cell) { struct NonceKey_cache_root *cache = &NonceKey_cache; return cell >= (struct NonceKey_cell*)cache->buckets && cell < (struct NonceKey_cell*)(cache->buckets + (32)); } static struct NonceKey_cell *NonceKey_newCell(void); static void NonceKey_deleteCell(struct NonceKey_cell *cell); static int NonceKey_integrityCheck(void); static void NonceKey_evictOne(struct NonceKey_cell **cell); static int NonceKey_evict(int toEvict); static void NonceKey_cache_init(void) { struct NonceKey_cache_root *cache = &NonceKey_cache; cache->count = 0; cache->numBuckets = (32); cache->maxCount = (100); cache->hitCount = 0; cache->total = 0; cache->cellMem = 0; cache->maxCellMem = 0; cache->linkCount = 0; cache->lookupCount = 0; int i; for(i=0; i < cache->numBuckets; i++) { struct NonceKey_bucket *bucket = &cache->buckets[i]; *(int*)&(bucket)->fastCell.elem = 0; } if((0) >= (2)) { NonceKey_integrityCheck() || ({ do { printk("dying at %s:%s():%d\n", "state_cache.c", __PRETTY_FUNCTION__, 292); do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } while(0) ; 1 ; }); }; } static void NonceKey_cache_invalidate(void) { struct NonceKey_cache_root *cache = &NonceKey_cache; int i; for(i=0; i < cache->numBuckets; i++) { struct NonceKey_bucket *bucket = &cache->buckets[i]; if((*(int*)&(bucket)->fastCell.elem != 0)) { nonce_evict(cache->evictContext, &bucket->fastCell.elem); NonceKey_deleteCell(&bucket->fastCell); } } } static void NonceKey_cache_destroy(void) { NonceKey_cache_invalidate(); } static int NonceKey_getCount(void) { if((0) >= (2)) { NonceKey_integrityCheck() || ({ do { printk("dying at %s:%s():%d\n", "state_cache.c", __PRETTY_FUNCTION__, 292); do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } while(0) ; 1 ; }); }; return NonceKey_cache.count; } static int NonceKey_integrityCheck(void) { struct NonceKey_cache_root *cache = &NonceKey_cache; (cache->hitCount >= 0 && cache->total >= 0 && cache->hitCount <= cache->total) || ((({ printk("stat integrity" "\n"); 1; })) && ({ return(0); 1; })); int i, lookupCount = 0; for(i=0; i < cache->numBuckets; i++) { struct NonceKey_bucket *bucket = &cache->buckets[i]; if((*(int*)&(bucket)->fastCell.elem != 0)) { struct NonceKey_cell *cell = &bucket->fastCell; ( (nonce_hash(&cell->key) % NonceKey_cache.numBuckets) == i ) || ( (({ printk("hash index integrity" "\n"); 1; })) && ({ return(0); 1; }) ); lookupCount++; } } do { if(!(lookupCount == cache->count)) { printk("(%s) failed at %s:%s():%d\n", "lookupCount == cache->count", "state_cache.c", __PRETTY_FUNCTION__, 292); return 0; } } while(0); do { if(!(cache->count <= cache->maxCount)) { printk("(%s) failed at %s:%s():%d\n", "cache->count <= cache->maxCount", "state_cache.c", __PRETTY_FUNCTION__, 292); return 0; } } while(0); return 1; } static void NonceKey_resetStats(void) { struct NonceKey_cache_root *cache = &NonceKey_cache; cache->hitCount = 0; cache->total = 0; } static struct NonceKey_cell *NonceKey_findInBucket(struct NonceKey_bucket *bucket, __u64 *key) { struct NonceKey_cache_root *cache = &NonceKey_cache; cache->lookupCount++; if((*(int*)&(bucket)->fastCell.elem != 0)) { struct NonceKey_cell *cell = &bucket->fastCell; if(nonce_cmp(key, ((void *)0), &cell->key, &cell->elem)) { return cell; } } return ((void *)0); } static struct NonceKey_cell *NonceKey_insert_helper(__u64 *key) { struct NonceKey_cache_root *cache = &NonceKey_cache; struct NonceKey_bucket *bucket = &cache->buckets[nonce_hash(key) % cache->numBuckets]; struct NonceKey_cell *cell = ((void *)0); if(!(*(int*)&(bucket)->fastCell.elem != 0)) { cell = &bucket->fastCell; } else { cell = &bucket->fastCell; nonce_evict(cache->evictContext, &cell->elem); NonceKey_deleteCell(cell); } cache->count++; cell->key = *key; return cell; } static int NonceKey_insert(struct NonceMap *elem) { if((0) >= (2)) { NonceKey_integrityCheck() || ({ do { printk("dying at %s:%s():%d\n", "state_cache.c", __PRETTY_FUNCTION__, 292); do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } while(0) ; 1 ; }); }; __u64 key = nonce_toKey(elem); struct NonceKey_cell *cell = NonceKey_insert_helper(&key); if(cell == ((void *)0)) return 0; cell->elem = *elem; if((0) >= (2)) { NonceKey_integrityCheck() || ({ do { printk("dying at %s:%s():%d\n", "state_cache.c", __PRETTY_FUNCTION__, 292); do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } while(0) ; 1 ; }); }; return 1; } static int NonceKey_find_helper(__u64 *key, struct NonceKey_cell **hint) { struct NonceKey_cache_root *cache = &NonceKey_cache; struct NonceKey_bucket *bucket = &cache->buckets[nonce_hash(key) % cache->numBuckets]; struct NonceKey_cell *lookup; lookup = NonceKey_findInBucket(bucket, key); if(lookup != ((void *)0)) { *hint = lookup; } if((0) >= (2)) { NonceKey_integrityCheck() || ({ do { printk("dying at %s:%s():%d\n", "state_cache.c", __PRETTY_FUNCTION__, 292); do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } while(0) ; 1 ; }); }; int found = lookup != ((void *)0); if(found) { cache->hitCount++; } cache->total++; return found; } static int NonceKey_find(__u64 *key, struct NonceMap *result) { struct NonceKey_cell *cell = ((void *)0); int found = NonceKey_find_helper(key, &cell); if(found) { *result = cell->elem; } if((0) >= (2)) { NonceKey_integrityCheck() || ({ do { printk("dying at %s:%s():%d\n", "state_cache.c", __PRETTY_FUNCTION__, 292); do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } while(0) ; 1 ; }); }; return found; } static void NonceKey_freeCell(struct NonceKey_cell *cell); static void NonceKey_deleteCell(struct NonceKey_cell *cell) { NonceKey_freeCell(cell); } static int NonceKey_delete(__u64 *key) { struct NonceKey_cell *cell = ((void *)0); int found = NonceKey_find_helper(key, &cell); if((found)) { NonceKey_deleteCell(cell); } if((0) >= (2)) { NonceKey_integrityCheck() || ({ do { printk("dying at %s:%s():%d\n", "state_cache.c", __PRETTY_FUNCTION__, 292); do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } while(0) ; 1 ; }); }; return found; } static void NonceKey_freeCell(struct NonceKey_cell *cell) { struct NonceKey_bucket *bucket = ((struct NonceKey_bucket*) (((char*) cell) - ((char*) &((struct NonceKey_bucket*)0)->fastCell))); *(int*)&(bucket)->fastCell.elem = 0; };
state_cache_1.c:21769:               (char*)&ParsedPMinisock_cache.buckets[1] -
state_cache_1.c:21789:        PseudoHeader *phdr = &c->hdr;
state_cache_1.c:21790:        phdr->seq = dcont->seq; phdr->type = dcont->continuationType; phdr->first = dcont->firstChild ? 1 : 0; phdr->serverAddr = scont->saddr; phdr->serverPort = scont->source; phdr->clientAddr = scont->daddr; phdr->clientPort = scont->dest;
state_cache_1.c:21792:        (__builtin_constant_p((((__u8*)(((WireContinuation *)0) + 1) - (__u8*)((WireContinuation *)0)->hmac_start))) ? __constant_memcpy((c->copy_start),(dcont->hmac_start),((((__u8*)(((WireContinuation *)0) + 1) - (__u8*)((WireContinuation *)0)->hmac_start)))) : __memcpy((c->copy_start),(dcont->hmac_start),((((__u8*)(((WireContinuation *)0) + 1) - (__u8*)((WireContinuation *)0)->hmac_start)))));
state_cache_1.c:21799:        PseudoHeader *phdr = &c->hdr;
state_cache_1.c:21800:        if(phdr->seq == w->seq &&
state_cache_1.c:21801:           phdr->type == w->continuationType &&
state_cache_1.c:21802:           phdr->first == w->firstChild &&
state_cache_1.c:21803:           phdr->serverAddr == iph->daddr &&
state_cache_1.c:21804:           phdr->serverPort == th->dest &&
state_cache_1.c:21805:           phdr->clientAddr == iph->saddr &&
state_cache_1.c:21806:           phdr->clientPort == th->source &&
state_cache_1.c:21807:           w->tokenCounterBase == c->tokenCounterBase) {
state_cache_1.c:21808:                (__builtin_constant_p((((__u8*)(((WireContinuation *)0) + 1) - (__u8*)((WireContinuation *)0)->hmac_start))) ? __constant_memcpy((w->hmac_start),(c->copy_start),((((__u8*)(((WireContinuation *)0) + 1) - (__u8*)((WireContinuation *)0)->hmac_start)))) : __memcpy((w->hmac_start),(c->copy_start),((((__u8*)(((WireContinuation *)0) + 1) - (__u8*)((WireContinuation *)0)->hmac_start)))));
state_cache_1.c:21818:        return __builtin_memcmp(w->hmac_start, c->copy_start, (((__u8*)(((WireContinuation *)0) + 1) - (__u8*)((WireContinuation *)0)->hmac_start)));
state_cache_1.c:21823:        CachedWireContinuationKey key = seqnoToKey(cont->seq);
state_cache_1.c:21827:                if(!WireContinuation_checkAndCopyOut(cont, &cell->elem, iph, th)) {
state_cache_1.c:21848:        CachedWireContinuationKey key = seqnoToKey(wcont->seq);
state_cache_1.c:21851:                WireContinuation_copyIn(&cell->elem, wcont, scont);
state_cache_2.c:2:# 1 "<built-in>"
state_cache_2.c:18:  char __data[128 - sizeof (unsigned short)];
state_cache_2.c:299:			(((__cmsg->cmsg_len) + sizeof (long) -
state_cache_2.c:300:			  1) & ~(sizeof (long) - 1)));
state_cache_2.c:301:  if ((unsigned long) ((char *) (__ptr + 1) - (char *) __ctl) > __size)
state_cache_2.c:310:  return __cmsg_nxthdr (__msg->msg_control, __msg->msg_controllen, __cmsg);
state_cache_2.c:355:  __asm__ __volatile__ ("" "addl %1,%0":"=m" (v->counter):"ir" (i),
state_cache_2.c:356:			"m" (v->counter));
state_cache_2.c:363:  __asm__ __volatile__ ("" "subl %1,%0":"=m" (v->counter):"ir" (i),
state_cache_2.c:364:			"m" (v->counter));
state_cache_2.c:373:  __asm__ __volatile__ ("" "subl %2,%0; sete %1":"=m" (v->counter),
state_cache_2.c:374:			"=qm" (c):"ir" (i), "m" (v->counter):"memory");
state_cache_2.c:382:  __asm__ __volatile__ ("" "incl %0":"=m" (v->counter):"m" (v->counter));
state_cache_2.c:389:  __asm__ __volatile__ ("" "decl %0":"=m" (v->counter):"m" (v->counter));
state_cache_2.c:398:  __asm__ __volatile__ ("" "decl %0; sete %1":"=m" (v->counter),
state_cache_2.c:399:			"=qm" (c):"m" (v->counter):"memory");
state_cache_2.c:409:  __asm__ __volatile__ ("" "incl %0; sete %1":"=m" (v->counter),
state_cache_2.c:410:			"=qm" (c):"m" (v->counter):"memory");
state_cache_2.c:420:  __asm__ __volatile__ ("" "addl %2,%0; sets %1":"=m" (v->counter),
state_cache_2.c:421:			"=qm" (c):"ir" (i), "m" (v->counter):"memory");
state_cache_2.c:449:# 1 "/usr/lib/gcc-lib/i386-redhat-linux/3.2.3/include/stdarg.h" 1 3
state_cache_2.c:450:# 43 "/usr/lib/gcc-lib/i386-redhat-linux/3.2.3/include/stdarg.h" 3
state_cache_2.c:452:# 110 "/usr/lib/gcc-lib/i386-redhat-linux/3.2.3/include/stdarg.h" 3
state_cache_2.c:754:  char _f[20 - 2 * sizeof (long) - sizeof (int)];
state_cache_2.c:1019:# 1 "/home/ashieh/current/include/linux/kgdb-asserts.h" 1
state_cache_2.c:1035:  size = (size - 1) >> (12 - 1);
state_cache_2.c:1036:  order = -1;
state_cache_2.c:1311:  return ((unsigned long *) t->esp)[3];
state_cache_2.c:1394:  next->prev = new;
state_cache_2.c:1395:  new->next = next;
state_cache_2.c:1396:  new->prev = prev;
state_cache_2.c:1397:  prev->next = new;
state_cache_2.c:1404:  __list_add (new, head, head->next);
state_cache_2.c:1411:  __list_add (new, head->prev, head);
state_cache_2.c:1418:  next->prev = prev;
state_cache_2.c:1419:  prev->next = next;
state_cache_2.c:1430:  __list_del (entry->prev, entry->next);
state_cache_2.c:1431:  entry->next = (void *) 0;
state_cache_2.c:1432:  entry->prev = (void *) 0;
state_cache_2.c:1442:  __list_del (entry->prev, entry->next);
state_cache_2.c:1445:      (entry)->next = (entry);
state_cache_2.c:1446:      (entry)->prev = (entry);
state_cache_2.c:1459:  __list_del (list->prev, list->next);
state_cache_2.c:1471:  __list_del (list->prev, list->next);
state_cache_2.c:1482:  return head->next == head;
state_cache_2.c:1488:  struct list_head *first = list->next;
state_cache_2.c:1489:  struct list_head *last = list->prev;
state_cache_2.c:1490:  struct list_head *at = head->next;
state_cache_2.c:1492:  first->prev = head;
state_cache_2.c:1493:  head->next = first;
state_cache_2.c:1495:  last->next = at;
state_cache_2.c:1496:  at->prev = last;
state_cache_2.c:1520:	  (list)->next = (list);
state_cache_2.c:1521:	  (list)->prev = (list);
state_cache_2.c:1755:  __asm__ __volatile__ ("movl $-1,%%eax\n\t"
state_cache_2.c:1759:			"xorl -4(%%edi),%%eax\n\t"
state_cache_2.c:1790:      if (set < (32 - bit))
state_cache_2.c:1792:      set = 32 - bit;
state_cache_2.c:1798:  res = find_first_zero_bit (p, size - 32 * (p - (unsigned long *) addr));
state_cache_2.c:1821:__asm__ ("bsfl %1,%0\n\t" "jnz 1f\n\t" "movl $-1,%0\n" "1:": "=r" (r):"rm" (x));
state_cache_2.c:1986:  q->lock = (spinlock_t)
state_cache_2.c:1991:      (&q->task_list)->next = (&q->task_list);
state_cache_2.c:1992:      (&q->task_list)->prev = (&q->task_list);
state_cache_2.c:2008:  q->flags = 0;
state_cache_2.c:2009:  q->task = p;
state_cache_2.c:2024:  return !list_empty (&q->task_list);
state_cache_2.c:2031:  list_add (&new->task_list, &head->task_list);
state_cache_2.c:2041:  list_add_tail (&new->task_list, &head->task_list);
state_cache_2.c:2052:  list_del (&old->task_list);
state_cache_2.c:2210:			"leal -1(%%esi),%0\n"
state_cache_2.c:2339:__asm__ __volatile__ ("std\n\t" "rep\n\t" "movsb\n\t" "cld": "=&c" (d0), "=&S" (d1), "=&D" (d2): "0" (n), "1" (n - 1 + (const char *) src), "2" (n - 1 + (char *) dest):"memory");
state_cache_2.c:2402:			"cmpl $-1,%1\n\t"
state_cache_2.c:2682:    ((unsigned int) ((dev) & ((1U << 8) - 1)));
state_cache_2.c:2751:# 1 "/home/ashieh/current/include/linux/kgdb-defs.h" 1
state_cache_2.c:2897:    atomic_inc (&mnt->mnt_count);
state_cache_2.c:2908:      if (atomic_dec_and_test (&mnt->mnt_count))
state_cache_2.c:2955:  while (len--)
state_cache_2.c:2999:  list_del (&dentry->d_hash);
state_cache_2.c:3002:      (&dentry->d_hash)->next = (&dentry->d_hash);
state_cache_2.c:3003:      (&dentry->d_hash)->prev = (&dentry->d_hash);
state_cache_2.c:3015:  return d->d_name.name != d->d_iname;
state_cache_2.c:3084:      if (!((&dentry->d_count)->counter))
state_cache_2.c:3086:      atomic_inc (&dentry->d_count);
state_cache_2.c:3096:  return list_empty (&dentry->d_hash);
state_cache_2.c:3104:  return dentry->d_mounted;
state_cache_2.c:3266:  sem->count = 0x00000000;
state_cache_2.c:3273:      (&sem->wait_list)->next = (&sem->wait_list);
state_cache_2.c:3274:      (&sem->wait_list)->prev = (&sem->wait_list);
state_cache_2.c:3299:			"# ending down_read\n\t":"+m" (sem->
state_cache_2.c:3320:			"# ending __down_read_trylock\n\t":"+m" (sem->
state_cache_2.c:3335:  tmp = ((-0x00010000) + 0x00000001);
state_cache_2.c:3347:			"+m" (sem->count):"a" (sem):"memory", "cc");
state_cache_2.c:3357:    ((__typeof__ (*(&sem->count)))
state_cache_2.c:3358:     __cmpxchg ((&sem->count), (unsigned long) (0x00000000),
state_cache_2.c:3359:		(unsigned long) (((-0x00010000) + 0x00000001)),
state_cache_2.c:3360:		sizeof (*(&sem->count))));
state_cache_2.c:3374:  __s32 tmp = -0x00000001;
state_cache_2.c:3385:			"# ending __up_read\n":"+m" (sem->count),
state_cache_2.c:3406:			"# ending __up_write\n":"+m" (sem->count):"a" (sem),
state_cache_2.c:3407:			"i" (-((-0x00010000) + 0x00000001)):"memory", "cc",
state_cache_2.c:3417:  __asm__ __volatile__ ("" "addl %1,%0":"=m" (sem->count):"ir" (delta),
state_cache_2.c:3418:			"m" (sem->count));
state_cache_2.c:3430:			"=m" (sem->count):"r" (sem),
state_cache_2.c:3431:			"m" (sem->count):"memory");
state_cache_2.c:3526:  (((&sem->count)->counter) = (val));
state_cache_2.c:3527:  sem->sleepers = 0;
state_cache_2.c:3528:  init_waitqueue_head (&sem->wait);
state_cache_2.c:3582:			".previous\n\t":"=m" (sem->count):"c" (sem):"memory");
state_cache_2.c:3608:			"=m" (sem->count):"c" (sem):"memory");
state_cache_2.c:3634:			"=m" (sem->count):"c" (sem):"memory");
state_cache_2.c:3657:			".previous\n\t" ".subsection 0\n":"=m" (sem->
state_cache_2.c:3665:  return ((&sem->count)->counter);
state_cache_2.c:4331:  unsigned long sec = value->tv_sec;
state_cache_2.c:4332:  long nsec = value->tv_nsec;
state_cache_2.c:4334:  if (sec >= (((~0UL >> 1) - 1) / 100))
state_cache_2.c:4335:    return ((~0UL >> 1) - 1);
state_cache_2.c:4336:  nsec += 1000000000L / 100 - 1;
state_cache_2.c:4344:  value->tv_nsec = (jiffies % 100) * (1000000000L / 100);
state_cache_2.c:4345:  value->tv_sec = jiffies / 100;
state_cache_2.c:4354:  if (0 >= (int) (mon -= 2))
state_cache_2.c:4357:      year -= 1;
state_cache_2.c:4360:  return ((((unsigned long) (year / 4 - year / 100 + year / 400 +
state_cache_2.c:4361:			     367 * mon / 12 + day) + year * 365 -
state_cache_2.c:4549:  if (fid->Vnode == 0xfffffffe || fid->Vnode == 0xffffffff)
state_cache_2.c:4550:    return ((fid->Volume << 20) | (fid->Unique & 0xfffff));
state_cache_2.c:4552:    return (fid->Unique + (fid->Vnode << 10) + (fid->Volume << 20));
state_cache_2.c:5652:  info->dqi_flags |= 0x10000;
state_cache_2.c:5764:      return dqopt->flags & 0x01;
state_cache_2.c:5766:      return dqopt->flags & 0x02;
state_cache_2.c:5939:  inode->i_blocks += bytes >> 9;
state_cache_2.c:5941:  inode->i_bytes += bytes;
state_cache_2.c:5942:  if (inode->i_bytes >= 512)
state_cache_2.c:5944:      inode->i_blocks++;
state_cache_2.c:5945:      inode->i_bytes -= 512;
state_cache_2.c:5952:  inode->i_blocks -= bytes >> 9;
state_cache_2.c:5954:  if (inode->i_bytes < bytes)
state_cache_2.c:5956:      inode->i_blocks--;
state_cache_2.c:5957:      inode->i_bytes += 512;
state_cache_2.c:5959:  inode->i_bytes -= bytes;
state_cache_2.c:5965:  return (((loff_t) inode->i_blocks) << 9) + inode->i_bytes;
state_cache_2.c:5971:  inode->i_blocks = bytes >> 9;
state_cache_2.c:5972:  inode->i_bytes = bytes & 511;
state_cache_2.c:6203:  timer->list.next = timer->list.prev = ((void *) 0);
state_cache_2.c:6209:  return timer->list.next != ((void *) 0);
state_cache_2.c:7111:  __s8 fs_fsmnt[512 - 212];
state_cache_2.c:7363:  down (&(server->sem));
state_cache_2.c:7369:  up (&(server->sem));
state_cache_2.c:7567:  if (!test_and_set_bit (0, &bh_pointer->sync))
state_cache_2.c:7581:      list_add_tail (&bh_pointer->list, bh_list);
state_cache_2.c:8187:  return ((server->conn_status & 0x11) == 0);
state_cache_2.c:8193:  server->conn_status |= 0x01;
state_cache_2.c:8239:  x->done = 0;
state_cache_2.c:8240:  init_waitqueue_head (&x->wait);
state_cache_2.c:8547:  if ((((inode)->i_sb->s_flags & (64))
state_cache_2.c:8548:       && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
state_cache_2.c:8557:  if (inode->i_flock
state_cache_2.c:8558:      && (((inode)->i_sb->s_flags & (64))
state_cache_2.c:8559:	  && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
state_cache_2.c:8567:  if (inode->i_flock
state_cache_2.c:8568:      && (((inode)->i_sb->s_flags & (64))
state_cache_2.c:8569:	  && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
state_cache_2.c:8571:				 size < inode->i_size ? size : inode->i_size,
state_cache_2.c:8573:				  inode->i_size ? inode->i_size -
state_cache_2.c:8574:				  size : size - inode->i_size));
state_cache_2.c:8581:  if (inode->i_flock)
state_cache_2.c:8668:  atomic_inc (&(bh)->b_count);
state_cache_2.c:8675:  atomic_dec (&bh->b_count);
state_cache_2.c:8685:    set_bit (BH_Uptodate, &bh->b_state);
state_cache_2.c:8687:    clear_bit (BH_Uptodate, &bh->b_state);
state_cache_2.c:8701:  if (test_and_clear_bit (BH_Dirty, &(bh)->b_state))
state_cache_2.c:8718:  buffer_insert_list (bh, &inode->i_dirty_buffers);
state_cache_2.c:8724:  buffer_insert_list (bh, &inode->i_dirty_data_buffers);
state_cache_2.c:8730:  return test_and_set_bit (BH_Dirty, &bh->b_state);
state_cache_2.c:8737:    set_bit (BH_Async, &bh->b_state);
state_cache_2.c:8739:    clear_bit (BH_Async, &bh->b_state);
state_cache_2.c:8745:  set_bit (BH_Attached, &bh->b_state);
state_cache_2.c:8751:  clear_bit (BH_Attached, &bh->b_state);
state_cache_2.c:8759:			     (&bh->
state_cache_2.c:8761:							     (&bh->b_state)));
state_cache_2.c:8777:  bh->b_end_io (bh, 0);
state_cache_2.c:8813:  return fsync_buffers_list (&inode->i_dirty_buffers);
state_cache_2.c:8818:  return fsync_buffers_list (&inode->i_dirty_data_buffers);
state_cache_2.c:8835:  atomic_dec (&inode->i_writecount);
state_cache_2.c:8841:    atomic_inc (&file->f_dentry->d_inode->i_writecount);
state_cache_2.c:8869:  return (unsigned long) ptr > (unsigned long) -1000L;
state_cache_2.c:8929:  if (inode && (inode->i_state & 64))
state_cache_2.c:8934:      if (sb->s_op->read_inode2)
state_cache_2.c:8935:	sb->s_op->read_inode2 (inode, opaque);
state_cache_2.c:8937:	sb->s_op->read_inode (inode);
state_cache_2.c:8949:  if (inode && (inode->i_state & 64))
state_cache_2.c:8951:      sb->s_op->read_inode (inode);
state_cache_2.c:8998:  return bread (sb->s_dev, block, sb->s_blocksize);
state_cache_2.c:9003:  return getblk (sb->s_dev, block, sb->s_blocksize);
state_cache_2.c:9008:  return get_hash_table (sb->s_dev, block, sb->s_blocksize);
state_cache_2.c:9133:  struct dentry *dir = dget (dentry->d_parent);
state_cache_2.c:9135:  down (&dir->d_inode->i_sem);
state_cache_2.c:9142:  return dget (dentry->d_parent);
state_cache_2.c:9148:  up (&dir->d_inode->i_sem);
state_cache_2.c:9240:  double_down (&d1->d_inode->i_sem, &d2->d_inode->i_sem);
state_cache_2.c:9246:  double_up (&d1->d_inode->i_sem, &d2->d_inode->i_sem);
state_cache_2.c:9493:  node->rb_parent = parent;
state_cache_2.c:9494:  node->rb_color = 0;
state_cache_2.c:9495:  node->rb_left = node->rb_right = ((void *) 0);
state_cache_2.c:10129:__asm__ ("btsl %1,%0": "=m" (*set): "Ir" (_sig - 1):"cc");
state_cache_2.c:10135:__asm__ ("btrl %1,%0": "=m" (*set): "Ir" (_sig - 1):"cc");
state_cache_2.c:10141:  unsigned long sig = _sig - 1;
state_cache_2.c:10142:  return 1 & (set->sig[sig / 32] >> (sig % 32));
state_cache_2.c:10149:__asm__ ("btl %2,%1\n\tsbbl %0,%0": "=r" (ret): "m" (*set), "Ir" (_sig - 1):"cc");
state_cache_2.c:10187:    int _pad[((128 / sizeof (int)) - 3)];
state_cache_2.c:10243:    int _pad[((64 / sizeof (int)) - 3)];
state_cache_2.c:10262:  if (from->si_code < 0)
state_cache_2.c:10272:      sizeof (from->_sifields._sigchld)) ? __constant_memcpy ((to), (from),
state_cache_2.c:10275:							       sizeof (from->
state_cache_2.c:10279:		 (3 * sizeof (int) + sizeof (from->_sifields._sigchld))));
state_cache_2.c:10309:      a0 = a->sig[4 * i + 0];
state_cache_2.c:10310:      a1 = a->sig[4 * i + 1];
state_cache_2.c:10311:      a2 = a->sig[4 * i + 2];
state_cache_2.c:10312:      a3 = a->sig[4 * i + 3];
state_cache_2.c:10313:      b0 = b->sig[4 * i + 0];
state_cache_2.c:10314:      b1 = b->sig[4 * i + 1];
state_cache_2.c:10315:      b2 = b->sig[4 * i + 2];
state_cache_2.c:10316:      b3 = b->sig[4 * i + 3];
state_cache_2.c:10317:      r->sig[4 * i + 0] = ((a0) | (b0));
state_cache_2.c:10318:      r->sig[4 * i + 1] = ((a1) | (b1));
state_cache_2.c:10319:      r->sig[4 * i + 2] = ((a2) | (b2));
state_cache_2.c:10320:      r->sig[4 * i + 3] = ((a3) | (b3));
state_cache_2.c:10325:      a0 = a->sig[4 * i + 0];
state_cache_2.c:10326:      a1 = a->sig[4 * i + 1];
state_cache_2.c:10327:      a2 = a->sig[4 * i + 2];
state_cache_2.c:10328:      b0 = b->sig[4 * i + 0];
state_cache_2.c:10329:      b1 = b->sig[4 * i + 1];
state_cache_2.c:10330:      b2 = b->sig[4 * i + 2];
state_cache_2.c:10331:      r->sig[4 * i + 0] = ((a0) | (b0));
state_cache_2.c:10332:      r->sig[4 * i + 1] = ((a1) | (b1));
state_cache_2.c:10333:      r->sig[4 * i + 2] = ((a2) | (b2));
state_cache_2.c:10336:      a0 = a->sig[4 * i + 0];
state_cache_2.c:10337:      a1 = a->sig[4 * i + 1];
state_cache_2.c:10338:      b0 = b->sig[4 * i + 0];
state_cache_2.c:10339:      b1 = b->sig[4 * i + 1];
state_cache_2.c:10340:      r->sig[4 * i + 0] = ((a0) | (b0));
state_cache_2.c:10341:      r->sig[4 * i + 1] = ((a1) | (b1));
state_cache_2.c:10344:      a0 = a->sig[4 * i + 0];
state_cache_2.c:10345:      b0 = b->sig[4 * i + 0];
state_cache_2.c:10346:      r->sig[4 * i + 0] = ((a0) | (b0));
state_cache_2.c:10359:      a0 = a->sig[4 * i + 0];
state_cache_2.c:10360:      a1 = a->sig[4 * i + 1];
state_cache_2.c:10361:      a2 = a->sig[4 * i + 2];
state_cache_2.c:10362:      a3 = a->sig[4 * i + 3];
state_cache_2.c:10363:      b0 = b->sig[4 * i + 0];
state_cache_2.c:10364:      b1 = b->sig[4 * i + 1];
state_cache_2.c:10365:      b2 = b->sig[4 * i + 2];
state_cache_2.c:10366:      b3 = b->sig[4 * i + 3];
state_cache_2.c:10367:      r->sig[4 * i + 0] = ((a0) & (b0));
state_cache_2.c:10368:      r->sig[4 * i + 1] = ((a1) & (b1));
state_cache_2.c:10369:      r->sig[4 * i + 2] = ((a2) & (b2));
state_cache_2.c:10370:      r->sig[4 * i + 3] = ((a3) & (b3));
state_cache_2.c:10375:      a0 = a->sig[4 * i + 0];
state_cache_2.c:10376:      a1 = a->sig[4 * i + 1];
state_cache_2.c:10377:      a2 = a->sig[4 * i + 2];
state_cache_2.c:10378:      b0 = b->sig[4 * i + 0];
state_cache_2.c:10379:      b1 = b->sig[4 * i + 1];
state_cache_2.c:10380:      b2 = b->sig[4 * i + 2];
state_cache_2.c:10381:      r->sig[4 * i + 0] = ((a0) & (b0));
state_cache_2.c:10382:      r->sig[4 * i + 1] = ((a1) & (b1));
state_cache_2.c:10383:      r->sig[4 * i + 2] = ((a2) & (b2));
state_cache_2.c:10386:      a0 = a->sig[4 * i + 0];
state_cache_2.c:10387:      a1 = a->sig[4 * i + 1];
state_cache_2.c:10388:      b0 = b->sig[4 * i + 0];
state_cache_2.c:10389:      b1 = b->sig[4 * i + 1];
state_cache_2.c:10390:      r->sig[4 * i + 0] = ((a0) & (b0));
state_cache_2.c:10391:      r->sig[4 * i + 1] = ((a1) & (b1));
state_cache_2.c:10394:      a0 = a->sig[4 * i + 0];
state_cache_2.c:10395:      b0 = b->sig[4 * i + 0];
state_cache_2.c:10396:      r->sig[4 * i + 0] = ((a0) & (b0));
state_cache_2.c:10409:      a0 = a->sig[4 * i + 0];
state_cache_2.c:10410:      a1 = a->sig[4 * i + 1];
state_cache_2.c:10411:      a2 = a->sig[4 * i + 2];
state_cache_2.c:10412:      a3 = a->sig[4 * i + 3];
state_cache_2.c:10413:      b0 = b->sig[4 * i + 0];
state_cache_2.c:10414:      b1 = b->sig[4 * i + 1];
state_cache_2.c:10415:      b2 = b->sig[4 * i + 2];
state_cache_2.c:10416:      b3 = b->sig[4 * i + 3];
state_cache_2.c:10417:      r->sig[4 * i + 0] = ((a0) & ~(b0));
state_cache_2.c:10418:      r->sig[4 * i + 1] = ((a1) & ~(b1));
state_cache_2.c:10419:      r->sig[4 * i + 2] = ((a2) & ~(b2));
state_cache_2.c:10420:      r->sig[4 * i + 3] = ((a3) & ~(b3));
state_cache_2.c:10425:      a0 = a->sig[4 * i + 0];
state_cache_2.c:10426:      a1 = a->sig[4 * i + 1];
state_cache_2.c:10427:      a2 = a->sig[4 * i + 2];
state_cache_2.c:10428:      b0 = b->sig[4 * i + 0];
state_cache_2.c:10429:      b1 = b->sig[4 * i + 1];
state_cache_2.c:10430:      b2 = b->sig[4 * i + 2];
state_cache_2.c:10431:      r->sig[4 * i + 0] = ((a0) & ~(b0));
state_cache_2.c:10432:      r->sig[4 * i + 1] = ((a1) & ~(b1));
state_cache_2.c:10433:      r->sig[4 * i + 2] = ((a2) & ~(b2));
state_cache_2.c:10436:      a0 = a->sig[4 * i + 0];
state_cache_2.c:10437:      a1 = a->sig[4 * i + 1];
state_cache_2.c:10438:      b0 = b->sig[4 * i + 0];
state_cache_2.c:10439:      b1 = b->sig[4 * i + 1];
state_cache_2.c:10440:      r->sig[4 * i + 0] = ((a0) & ~(b0));
state_cache_2.c:10441:      r->sig[4 * i + 1] = ((a1) & ~(b1));
state_cache_2.c:10444:      a0 = a->sig[4 * i + 0];
state_cache_2.c:10445:      b0 = b->sig[4 * i + 0];
state_cache_2.c:10446:      r->sig[4 * i + 0] = ((a0) & ~(b0));
state_cache_2.c:10458:      set->sig[4 * i + 0] = (~(set->sig[4 * i + 0]));
state_cache_2.c:10459:      set->sig[4 * i + 1] = (~(set->sig[4 * i + 1]));
state_cache_2.c:10460:      set->sig[4 * i + 2] = (~(set->sig[4 * i + 2]));
state_cache_2.c:10461:      set->sig[4 * i + 3] = (~(set->sig[4 * i + 3]));
state_cache_2.c:10466:      set->sig[4 * i + 2] = (~(set->sig[4 * i + 2]));
state_cache_2.c:10468:      set->sig[4 * i + 1] = (~(set->sig[4 * i + 1]));
state_cache_2.c:10470:      set->sig[4 * i + 0] = (~(set->sig[4 * i + 0]));
state_cache_2.c:10498:      set->sig[1] = 0;
state_cache_2.c:10500:      set->sig[0] = 0;
state_cache_2.c:10511:      (__builtin_constant_p (-1)
state_cache_2.c:10515:					   (unsigned char) (-1))),
state_cache_2.c:10518:			       ((0x01010101UL * (unsigned char) (-1))),
state_cache_2.c:10521:	  __memset_generic ((((set))), (((-1))),
state_cache_2.c:10523:	  __memset_generic (((set)), ((-1)), ((sizeof (sigset_t))))));
state_cache_2.c:10526:      set->sig[1] = -1;
state_cache_2.c:10528:      set->sig[0] = -1;
state_cache_2.c:10540:  set->sig[0] |= mask;
state_cache_2.c:10546:  set->sig[0] &= ~mask;
state_cache_2.c:10552:  return (set->sig[0] & mask) != 0;
state_cache_2.c:10558:  set->sig[0] = mask;
state_cache_2.c:10563:       ? (__builtin_constant_p ((sizeof (long) * ((64 / 32) - 1))) ?
state_cache_2.c:10564:	  __constant_c_and_count_memset (((&set->sig[1])),
state_cache_2.c:10568:					   ((64 / 32) -
state_cache_2.c:10570:	  __constant_c_memset (((&set->sig[1])),
state_cache_2.c:10573:				 ((64 / 32) -
state_cache_2.c:10575:       : (__builtin_constant_p ((sizeof (long) * ((64 / 32) - 1))) ?
state_cache_2.c:10576:	  __memset_generic ((((&set->sig[1]))), (((0))),
state_cache_2.c:10578:			       ((64 / 32) -
state_cache_2.c:10579:				1))))) : __memset_generic (((&set->sig[1])),
state_cache_2.c:10582:							     ((64 / 32) -
state_cache_2.c:10586:      set->sig[1] = 0;
state_cache_2.c:10594:  set->sig[0] = ~mask;
state_cache_2.c:10598:      (__builtin_constant_p (-1)
state_cache_2.c:10599:       ? (__builtin_constant_p ((sizeof (long) * ((64 / 32) - 1))) ?
state_cache_2.c:10600:	  __constant_c_and_count_memset (((&set->sig[1])),
state_cache_2.c:10602:					   (unsigned char) (-1))),
state_cache_2.c:10604:					   ((64 / 32) -
state_cache_2.c:10606:	  __constant_c_memset (((&set->sig[1])),
state_cache_2.c:10607:			       ((0x01010101UL * (unsigned char) (-1))),
state_cache_2.c:10609:				 ((64 / 32) -
state_cache_2.c:10611:       : (__builtin_constant_p ((sizeof (long) * ((64 / 32) - 1))) ?
state_cache_2.c:10612:	  __memset_generic ((((&set->sig[1]))), (((-1))),
state_cache_2.c:10614:			       ((64 / 32) -
state_cache_2.c:10615:				1))))) : __memset_generic (((&set->sig[1])),
state_cache_2.c:10616:							   ((-1)),
state_cache_2.c:10618:							     ((64 / 32) -
state_cache_2.c:10622:      set->sig[1] = -1;
state_cache_2.c:10632:  sigemptyset (&sig->signal);
state_cache_2.c:10633:  sig->head = ((void *) 0);
state_cache_2.c:10634:  sig->tail = &sig->head;
state_cache_2.c:10675:  (void) (&fs->lock);
state_cache_2.c:10676:  old_root = fs->root;
state_cache_2.c:10677:  old_rootmnt = fs->rootmnt;
state_cache_2.c:10678:  fs->rootmnt = mntget (mnt);
state_cache_2.c:10679:  fs->root = dget (dentry);
state_cache_2.c:10701:  (void) (&fs->lock);
state_cache_2.c:10702:  old_pwd = fs->pwd;
state_cache_2.c:10703:  old_pwdmnt = fs->pwdmnt;
state_cache_2.c:10704:  fs->pwdmnt = mntget (mnt);
state_cache_2.c:10705:  fs->pwd = dget (dentry);
state_cache_2.c:11215:    &pidhash[((((p->pid) >> 8) ^ (p->pid)) & ((4096 >> 2) - 1))];
state_cache_2.c:11217:  if ((p->pidhash_next = *htable) != ((void *) 0))
state_cache_2.c:11218:    (*htable)->pidhash_pprev = &p->pidhash_next;
state_cache_2.c:11220:  p->pidhash_pprev = htable;
state_cache_2.c:11226:  if (p->pidhash_next)
state_cache_2.c:11227:    p->pidhash_next->pidhash_pprev = p->pidhash_pprev;
state_cache_2.c:11228:  *p->pidhash_pprev = p->pidhash_next;
state_cache_2.c:11235:    &pidhash[((((pid) >> 8) ^ (pid)) & ((4096 >> 2) - 1))];
state_cache_2.c:11237:  for (p = *htable; p && p->pid != pid; p = p->pidhash_next)
state_cache_2.c:11248:  tsk->processor = cpu;
state_cache_2.c:11249:  tsk->cpus_runnable = 1UL << cpu;
state_cache_2.c:11255:  tsk->cpus_runnable = ~0UL;
state_cache_2.c:11365:  return (p->sigpending != 0);
state_cache_2.c:11381:      for (i = (64 / 32), ready = 0; --i >= 0;)
state_cache_2.c:11382:	ready |= signal->sig[i] & ~blocked->sig[i];
state_cache_2.c:11386:      ready = signal->sig[3] & ~blocked->sig[3];
state_cache_2.c:11387:      ready |= signal->sig[2] & ~blocked->sig[2];
state_cache_2.c:11388:      ready |= signal->sig[1] & ~blocked->sig[1];
state_cache_2.c:11389:      ready |= signal->sig[0] & ~blocked->sig[0];
state_cache_2.c:11393:      ready = signal->sig[1] & ~blocked->sig[1];
state_cache_2.c:11394:      ready |= signal->sig[0] & ~blocked->sig[0];
state_cache_2.c:11398:      ready = signal->sig[0] & ~blocked->sig[0];
state_cache_2.c:11410:  t->sigpending = has_pending_signals (&t->pending.signal, &t->blocked);
state_cache_2.c:11418:  return (sp - get_current ()->sas_ss_sp < get_current ()->sas_ss_size);
state_cache_2.c:11424:  return (get_current ()->sas_ss_size == 0 ? 2 : on_sig_stack (sp) ? 1 : 0);
state_cache_2.c:11437:       securebits) && get_current ()->euid == 0)
state_cache_2.c:11439:      get_current ()->flags |= 0x00000100;
state_cache_2.c:11450:       securebits) && get_current ()->fsuid == 0)
state_cache_2.c:11452:      get_current ()->flags |= 0x00000100;
state_cache_2.c:11468:  if (((get_current ()->cap_effective) & (1 << (cap))))
state_cache_2.c:11473:      get_current ()->flags |= 0x00000100;
state_cache_2.c:11493:  if (atomic_dec_and_test (&mm->mm_count))
state_cache_2.c:11543:  nr_running--;
state_cache_2.c:11544:  p->sleep_time = jiffies;
state_cache_2.c:11545:  list_del (&p->run_list);
state_cache_2.c:11546:  p->run_list.next = ((void *) 0);
state_cache_2.c:11552:  return (p->run_list.next != ((void *) 0));
state_cache_2.c:11566:  nr_threads--;
state_cache_2.c:11570:      (p)->next_task->prev_task = (p)->prev_task;
state_cache_2.c:11571:      (p)->prev_task->next_task = (p)->next_task;
state_cache_2.c:11572:      if ((p)->p_osptr)
state_cache_2.c:11573:	(p)->p_osptr->p_ysptr = (p)->p_ysptr;
state_cache_2.c:11574:      if ((p)->p_ysptr)
state_cache_2.c:11575:	(p)->p_ysptr->p_osptr = (p)->p_osptr;
state_cache_2.c:11577:	(p)->p_pptr->p_cptr = (p)->p_osptr;
state_cache_2.c:11580:  list_del (&p->thread_group);
state_cache_2.c:11596:  (void) (&p->alloc_lock);
state_cache_2.c:11615:  (void) (&get_current ()->fs->lock);
state_cache_2.c:11616:  rootmnt = mntget (get_current ()->fs->rootmnt);
state_cache_2.c:11617:  root = dget (get_current ()->fs->root);
state_cache_2.c:11636:  return (__builtin_expect ((get_current ()->need_resched), 0));
state_cache_2.c:11772:  pg_data_t *pgdat = zone->zone_pgdat;
state_cache_2.c:11774:  if (zone - pgdat->node_zones < 3 - 1)
state_cache_2.c:11777:  else if (pgdat->node_next)
state_cache_2.c:11779:      pgdat = pgdat->node_next;
state_cache_2.c:11780:      zone = pgdat->node_zones;
state_cache_2.c:11795:    char reserved[(1UL << 12) - 10];
state_cache_2.c:11986:  return (new < 3) ? -1 : 0;
state_cache_2.c:12311:  FIX_IO_APIC_BASE_END = FIX_IO_APIC_BASE_0 + 8 - 1,
state_cache_2.c:12317:  FIX_BTMAP_BEGIN = FIX_BTMAP_END + 16 - 1,
state_cache_2.c:12338:  return ((0xffffe000UL) - ((idx) << 12));
state_cache_2.c:12355:# 1 "/home/ashieh/current/include/asm/pgtable-2level.h" 1
state_cache_2.c:12356:# 32 "/home/ashieh/current/include/asm/pgtable-2level.h"
state_cache_2.c:12373:# 55 "/home/ashieh/current/include/asm/pgtable-2level.h"
state_cache_2.c:12496:  pte.pte_low &= ((~((1UL << 12) - 1)) | 0x020 | 0x040);
state_cache_2.c:12586:  return zone_table[page->flags >> (32 - 8)];
state_cache_2.c:12592:  page->flags &= ~(~0UL << (32 - 8));
state_cache_2.c:12593:  page->flags |= zone_num << (32 - 8);
state_cache_2.c:12737:  return ((&(page)->count)->counter) - !!page->buffers == 1;
state_cache_2.c:12768:  unsigned long ret = -22;
state_cache_2.c:12769:  if ((offset + (((len) + (1UL << 12) - 1) & (~((1UL << 12) - 1)))) < offset)
state_cache_2.c:12771:  if (!(offset & ~(~((1UL << 12) - 1))))
state_cache_2.c:12772:    ret = do_mmap_pgoff (get_current ()->mm, file, addr, len, prot, flag,
state_cache_2.c:12786:  prev->vm_next = vma->vm_next;
state_cache_2.c:12787:  rb_erase (&vma->vm_rb, &mm->mm_rb);
state_cache_2.c:12788:  if (mm->mmap_cache == vma)
state_cache_2.c:12789:    mm->mmap_cache = prev;
state_cache_2.c:12795:  if (!vma->vm_file && vma->vm_flags == vm_flags)
state_cache_2.c:12817:  if (get_current ()->flags & 0x00004000)
state_cache_2.c:12835:  address &= (~((1UL << 12) - 1));
state_cache_2.c:12836:  (void) (&vma->vm_mm->page_table_lock);
state_cache_2.c:12837:  grow = (vma->vm_start - address) >> 12;
state_cache_2.c:12838:  if (vma->vm_end - address > get_current ()->rlim[3].rlim_cur ||
state_cache_2.c:12839:      ((vma->vm_mm->total_vm + grow) << 12) >
state_cache_2.c:12840:      get_current ()->rlim[9].rlim_cur)
state_cache_2.c:12846:      return -12;
state_cache_2.c:12848:  vma->vm_start = address;
state_cache_2.c:12849:  vma->vm_pgoff -= grow;
state_cache_2.c:12850:  vma->vm_mm->total_vm += grow;
state_cache_2.c:12851:  if (vma->vm_flags & 0x00002000)
state_cache_2.c:12852:    vma->vm_mm->locked_vm += grow;
state_cache_2.c:12875:  if (vma && end_addr <= vma->vm_start)
state_cache_2.c:12896:		 "g" (get_current ()->addr_limit.
state_cache_2.c:12899:	    }) == 0) ? 0 : -14;
state_cache_2.c:12997:unsigned long flag, sum; asm ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag), "=r" (sum):"1" (to), "g" ((int) (n)), "g" (get_current ()->addr_limit.seg));
state_cache_2.c:13028:unsigned long flag, sum; asm ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag), "=r" (sum):"1" (from), "g" ((int) (n)), "g" (get_current ()->addr_limit.seg));
state_cache_2.c:13145:  pt->error = 0;
state_cache_2.c:13146:  pt->table = ((void *) 0);
state_cache_2.c:13165:    ((((nr) + (8 * sizeof (long)) -
state_cache_2.c:13176:	error = -14;
state_cache_2.c:13193:     (((((nr) + (8 * sizeof (long)) -
state_cache_2.c:13199:							      -
state_cache_2.c:13205:				     (((((nr) + (8 * sizeof (long)) -
state_cache_2.c:13215:      ((((((nr) + (8 * sizeof (long)) -
state_cache_2.c:13224:								 (long)) -
state_cache_2.c:13232:			   ((((((nr) + (8 * sizeof (long)) -
state_cache_2.c:13236:      ((((((nr) + (8 * sizeof (long)) -
state_cache_2.c:13240:						    (8 * sizeof (long)) -
state_cache_2.c:13245:			((((((nr) + (8 * sizeof (long)) -
state_cache_2.c:13299:       ((1024 -
state_cache_2.c:13309:					     ((1024 -
state_cache_2.c:13317:		 ((1024 -
state_cache_2.c:13337:      (boot_cpu_data.pgtable_cache_sz)--;
state_cache_2.c:13397:      (boot_cpu_data.pgtable_cache_sz)--;
state_cache_2.c:13422:  if (mm == get_current ()->active_mm)
state_cache_2.c:13436:  if (vma->vm_mm == get_current ()->active_mm)
state_cache_2.c:13443:  if (mm == get_current ()->active_mm)
state_cache_2.c:13475:		long) ((((page) - page_zone (page)->zone_mem_map) << 12) +
state_cache_2.c:13476:		       page_zone (page)->zone_start_paddr) +
state_cache_2.c:13814:  return (list->next == (struct sk_buff *) list);
state_cache_2.c:13821:  atomic_inc (&skb->users);
state_cache_2.c:13829:  if (((&skb->users)->counter) == 1 || atomic_dec_and_test (&skb->users))
state_cache_2.c:13837:  if (((&skb->users)->counter) == 1 || atomic_dec_and_test (&skb->users))
state_cache_2.c:13845:  return skb->cloned
state_cache_2.c:13846:    && ((&((struct skb_shared_info *) ((skb)->end))->dataref)->counter) != 1;
state_cache_2.c:13853:  return (((&skb->users)->counter) != 1);
state_cache_2.c:13886:  struct sk_buff *list = ((struct sk_buff *) list_)->next;
state_cache_2.c:13896:  struct sk_buff *list = ((struct sk_buff *) list_)->prev;
state_cache_2.c:13906:  return (list_->qlen);
state_cache_2.c:13916:  list->prev = (struct sk_buff *) list;
state_cache_2.c:13917:  list->next = (struct sk_buff *) list;
state_cache_2.c:13918:  list->qlen = 0;
state_cache_2.c:13927:  newsk->list = list;
state_cache_2.c:13928:  list->qlen++;
state_cache_2.c:13930:  next = prev->next;
state_cache_2.c:13931:  newsk->next = next;
state_cache_2.c:13932:  newsk->prev = prev;
state_cache_2.c:13933:  next->prev = newsk;
state_cache_2.c:13934:  prev->next = newsk;
state_cache_2.c:13951:      (void) (&list->lock);
state_cache_2.c:13972:  newsk->list = list;
state_cache_2.c:13973:  list->qlen++;
state_cache_2.c:13975:  prev = next->prev;
state_cache_2.c:13976:  newsk->next = next;
state_cache_2.c:13977:  newsk->prev = prev;
state_cache_2.c:13978:  next->prev = newsk;
state_cache_2.c:13979:  prev->next = newsk;
state_cache_2.c:13996:      (void) (&list->lock);
state_cache_2.c:14018:  next = prev->next;
state_cache_2.c:14023:      next = next->next;
state_cache_2.c:14024:      list->qlen--;
state_cache_2.c:14025:      next->prev = prev;
state_cache_2.c:14026:      prev->next = next;
state_cache_2.c:14027:      result->next = ((void *) 0);
state_cache_2.c:14028:      result->prev = ((void *) 0);
state_cache_2.c:14029:      result->list = ((void *) 0);
state_cache_2.c:14049:      (void) (&list->lock);
state_cache_2.c:14074:  newsk->next = next;
state_cache_2.c:14075:  newsk->prev = prev;
state_cache_2.c:14076:  next->prev = newsk;
state_cache_2.c:14077:  prev->next = newsk;
state_cache_2.c:14078:  newsk->list = list;
state_cache_2.c:14079:  list->qlen++;
state_cache_2.c:14096:      (void) (&old->list->lock);
state_cache_2.c:14099:  __skb_insert (newsk, old->prev, old, old->list);
state_cache_2.c:14118:  __skb_insert (newsk, old, old->next, old->list);
state_cache_2.c:14135:      (void) (&old->list->lock);
state_cache_2.c:14160:  list->qlen--;
state_cache_2.c:14161:  next = skb->next;
state_cache_2.c:14162:  prev = skb->prev;
state_cache_2.c:14163:  skb->next = ((void *) 0);
state_cache_2.c:14164:  skb->prev = ((void *) 0);
state_cache_2.c:14165:  skb->list = ((void *) 0);
state_cache_2.c:14166:  next->prev = prev;
state_cache_2.c:14167:  prev->next = next;
state_cache_2.c:14174:  struct sk_buff_head *list = skb->list;
state_cache_2.c:14188:	  (void) (&list->lock);
state_cache_2.c:14191:      if (skb->list == list)
state_cache_2.c:14192:	__skb_unlink (skb, skb->list);
state_cache_2.c:14231:      (void) (&list->lock);
state_cache_2.c:14250:  return skb->data_len;
state_cache_2.c:14256:  return skb->len - skb->data_len;
state_cache_2.c:14263:  unsigned char *tmp = skb->tail;
state_cache_2.c:14270:  skb->tail += len;
state_cache_2.c:14271:  skb->len += len;
state_cache_2.c:14279:  unsigned char *tmp = skb->tail;
state_cache_2.c:14286:  skb->tail += len;
state_cache_2.c:14287:  skb->len += len;
state_cache_2.c:14288:  if (skb->tail > skb->end)
state_cache_2.c:14303:  skb->data -= len;
state_cache_2.c:14304:  skb->len += len;
state_cache_2.c:14305:  return skb->data;
state_cache_2.c:14312:  skb->data -= len;
state_cache_2.c:14313:  skb->len += len;
state_cache_2.c:14314:  if (skb->data < skb->head)
state_cache_2.c:14323:  return skb->data;
state_cache_2.c:14329:  skb->len -= len;
state_cache_2.c:14330:  if (skb->len < skb->data_len)
state_cache_2.c:14332:  return skb->data += len;
state_cache_2.c:14339:  if (len > skb->len)
state_cache_2.c:14350:      __pskb_pull_tail (skb, len - skb_headlen (skb)) == ((void *) 0))
state_cache_2.c:14352:  skb->len -= len;
state_cache_2.c:14353:  return skb->data += len;
state_cache_2.c:14359:  if (len > skb->len)
state_cache_2.c:14369:  if (len > skb->len)
state_cache_2.c:14371:  return (__pskb_pull_tail (skb, len - skb_headlen (skb)) != ((void *) 0));
state_cache_2.c:14378:  return skb->data - skb->head;
state_cache_2.c:14385:  return skb_is_nonlinear (skb) ? 0 : skb->end - skb->tail;
state_cache_2.c:14392:  skb->data += len;
state_cache_2.c:14393:  skb->tail += len;
state_cache_2.c:14401:  if (!skb->data_len)
state_cache_2.c:14403:      skb->len = len;
state_cache_2.c:14404:      skb->tail = skb->data + len;
state_cache_2.c:14416:  if (skb->len > len)
state_cache_2.c:14426:  if (!skb->data_len)
state_cache_2.c:14428:      skb->len = len;
state_cache_2.c:14429:      skb->tail = skb->data + len;
state_cache_2.c:14441:  if (len < skb->len)
state_cache_2.c:14450:  if (skb->destructor)
state_cache_2.c:14451:    skb->destructor (skb);
state_cache_2.c:14452:  skb->destructor = ((void *) 0);
state_cache_2.c:14453:  skb->sk = ((void *) 0);
state_cache_2.c:14500:  int delta = (headroom > 16 ? headroom : 16) - skb_headroom (skb);
state_cache_2.c:14514:  unsigned int size = skb->len;
state_cache_2.c:14517:  return skb_pad (skb, len - size);
state_cache_2.c:14532:  return kmap (frag->page);
state_cache_2.c:14583:  if (nfct && atomic_dec_and_test (&nfct->master->use))
state_cache_2.c:14584:    nfct->master->destroy (nfct->master);
state_cache_2.c:14590:    atomic_inc (&nfct->master->use);
state_cache_2.c:14733:  unsigned char __pad[16 - sizeof (short int) -
state_cache_2.c:14734:		      sizeof (unsigned short int) - sizeof (struct in_addr)];
state_cache_2.c:15261:  unsigned long hh_data[(((32) + (16 - 1)) & ~(16 - 1)) / sizeof (long)];
state_cache_2.c:15607:  eip -= (unsigned long) &_stext;
state_cache_2.c:15614:  if (eip > prof_len - 1)
state_cache_2.c:15615:    eip = prof_len - 1;
state_cache_2.c:15727:  if (!test_and_set_bit (TASKLET_STATE_SCHED, &t->state))
state_cache_2.c:15737:  if (!test_and_set_bit (TASKLET_STATE_SCHED, &t->state))
state_cache_2.c:15745:  atomic_inc (&t->count);
state_cache_2.c:15764:  atomic_dec (&t->count);
state_cache_2.c:15771:  atomic_dec (&t->count);
state_cache_2.c:15880:  if (!test_and_set_bit (__LINK_STATE_SCHED, &dev->state))
state_cache_2.c:15891:      dev->next_sched = softnet_data[cpu].output_queue;
state_cache_2.c:15904:			  (&dev->
state_cache_2.c:15906:							(&dev->state))))
state_cache_2.c:15913:  clear_bit (__LINK_STATE_XOFF, &dev->state);
state_cache_2.c:15919:  if (test_and_clear_bit (__LINK_STATE_XOFF, &dev->state))
state_cache_2.c:15926:  set_bit (__LINK_STATE_XOFF, &dev->state);
state_cache_2.c:15934:			     (&dev->
state_cache_2.c:15936:	  variable_test_bit ((__LINK_STATE_XOFF), (&dev->state)));
state_cache_2.c:15944:			     (&dev->
state_cache_2.c:15946:	  variable_test_bit ((__LINK_STATE_START), (&dev->state)));
state_cache_2.c:15956:  if (atomic_dec_and_test (&skb->users))
state_cache_2.c:15967:      skb->next = softnet_data[cpu].completion_queue;
state_cache_2.c:16022:  if (atomic_dec_and_test (&dev->refcnt))
state_cache_2.c:16032:			      (&dev->
state_cache_2.c:16034:	   variable_test_bit ((__LINK_STATE_NOCARRIER), (&dev->state)));
state_cache_2.c:16042:  clear_bit (__LINK_STATE_NOCARRIER, &dev->state);
state_cache_2.c:16050:  set_bit (__LINK_STATE_NOCARRIER, &dev->state);
state_cache_2.c:16059:			     (&dev->
state_cache_2.c:16061:	  variable_test_bit ((__LINK_STATE_PRESENT), (&dev->state)));
state_cache_2.c:16067:  if (test_and_clear_bit (__LINK_STATE_PRESENT, &dev->state) &&
state_cache_2.c:16077:  if (!test_and_set_bit (__LINK_STATE_PRESENT, &dev->state) &&
state_cache_2.c:16113:    !test_and_set_bit (__LINK_STATE_RX_SCHED, &dev->state);
state_cache_2.c:16132:  atomic_inc (&(dev)->refcnt);
state_cache_2.c:16133:  list_add_tail (&dev->poll_list, &softnet_data[cpu].poll_list);
state_cache_2.c:16134:  if (dev->quota < 0)
state_cache_2.c:16135:    dev->quota += dev->weight;
state_cache_2.c:16137:    dev->quota = dev->weight;
state_cache_2.c:16167:      dev->quota += undo;
state_cache_2.c:16175:      list_add_tail (&dev->poll_list, &softnet_data[cpu].poll_list);
state_cache_2.c:16207:			  (&dev->
state_cache_2.c:16209:       variable_test_bit ((__LINK_STATE_RX_SCHED), (&dev->state))))
state_cache_2.c:16220:  list_del (&dev->poll_list);
state_cache_2.c:16222:  clear_bit (__LINK_STATE_RX_SCHED, &dev->state);
state_cache_2.c:16229:  while (test_and_set_bit (__LINK_STATE_RX_SCHED, &dev->state))
state_cache_2.c:16232:      get_current ()->state = 1;
state_cache_2.c:16240:  clear_bit (__LINK_STATE_RX_SCHED, &dev->state);
state_cache_2.c:16252:			  (&dev->
state_cache_2.c:16254:       variable_test_bit ((__LINK_STATE_RX_SCHED), (&dev->state))))
state_cache_2.c:16265:  list_del (&dev->poll_list);
state_cache_2.c:16267:  clear_bit (__LINK_STATE_RX_SCHED, &dev->state);
state_cache_2.c:16281:      (void) (&dev->xmit_lock);
state_cache_2.c:16295:	  if (!--*ptr)
state_cache_2.c:16296:	    __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;"
state_cache_2.c:16669:  return fp->len * sizeof (struct sock_filter) + sizeof (*fp);
state_cache_2.c:16734:  unsigned char ha[(8 + sizeof (unsigned long) - 1) &
state_cache_2.c:16735:		   ~(sizeof (unsigned long) - 1)];
state_cache_2.c:16853:  if (atomic_dec_and_test (&neigh->refcnt))
state_cache_2.c:16861:    atomic_inc (&neigh->refcnt);
state_cache_2.c:16871:    neigh->confirmed = jiffies;
state_cache_2.c:16877:  return neigh->nud_state & (0x80 | 0x40 | 0x02);
state_cache_2.c:16883:  return neigh->nud_state & (0x80 | 0x40 | 0x02 | 0x10 | 0x04 | 0x08);
state_cache_2.c:16889:  neigh->used = jiffies;
state_cache_2.c:16890:  if (!(neigh->nud_state & ((0x80 | 0x40 | 0x02) | 0x08 | 0x10)))
state_cache_2.c:16990:  atomic_inc (&dst->__refcnt);
state_cache_2.c:16997:    atomic_inc (&dst->__refcnt);
state_cache_2.c:17005:    atomic_dec (&dst->__refcnt);
state_cache_2.c:17015:  if (dst->obsolete > 1)
state_cache_2.c:17017:  if (!((&dst->__refcnt)->counter))
state_cache_2.c:17029:    neigh_confirm (dst->neighbour);
state_cache_2.c:17036:  if (dst && dst->ops->negative_advice)
state_cache_2.c:17037:    *dst_p = dst->ops->negative_advice (dst);
state_cache_2.c:17043:  struct dst_entry *dst = skb->dst;
state_cache_2.c:17044:  if (dst && dst->ops && dst->ops->link_failure)
state_cache_2.c:17045:    dst->ops->link_failure (skb);
state_cache_2.c:17056:  if (dst->expires == 0 || (long) (dst->expires - expires) > 0)
state_cache_2.c:17057:    dst->expires = expires;
state_cache_2.c:17155:  head->next = head->prev = ((void *) 0);
state_cache_2.c:17169:  for (elem = (typeof (elem)) (list)->next; (elem != (typeof (elem)) (list));
state_cache_2.c:17170:       elem = (typeof (elem)) elem->next)
state_cache_2.c:17185:  dlist->next = dlist->prev = (struct list_link *) dlist;
state_cache_2.c:17191:  if (head->next == elem)
state_cache_2.c:17205:  elem->next = head->next;
state_cache_2.c:17206:  head->next->prev = elem;
state_cache_2.c:17208:  elem->prev = (struct list_link *) head;
state_cache_2.c:17209:  head->next = elem;
state_cache_2.c:17215:  if (head->prev == elem)
state_cache_2.c:17229:  elem->next = (struct list_link *) head;
state_cache_2.c:17230:  elem->prev = head->prev;
state_cache_2.c:17231:  head->prev->next = elem;
state_cache_2.c:17232:  head->prev = elem;
state_cache_2.c:17238:  if (head->prev == elem)
state_cache_2.c:17252:  elem->next = (struct list_link *) head;
state_cache_2.c:17253:  elem->prev = head->prev;
state_cache_2.c:17255:  head->prev->next = elem;
state_cache_2.c:17256:  head->prev = elem;
state_cache_2.c:17262:  elem->next->prev = elem->prev;
state_cache_2.c:17263:  elem->prev->next = elem->next;
state_cache_2.c:17264:  elem->prev = elem->next = ((void *) 0);
state_cache_2.c:17270:  return (struct dlist *) list->next == list;
state_cache_2.c:17332:  vec->num = 0;
state_cache_2.c:17333:  vec->size = initSize;
state_cache_2.c:17334:  vec->elems = kmalloc (vec->size * sizeof (vec->elems[0]), (0x20));
state_cache_2.c:17335:  if (vec->elems == ((void *) 0))
state_cache_2.c:17345:  kfree (vec->elems);
state_cache_2.c:17351:  if (vec->num == vec->size)
state_cache_2.c:17354:      vec->size *= 2;
state_cache_2.c:17355:      newElems = kmalloc (vec->size * sizeof (newElems[0]), (0x20));
state_cache_2.c:17373:  vec->elems[vec->num++] = newElem;
state_cache_2.c:17385:  return head->next == (struct alloc_head *) head;
state_cache_2.c:17391:  head->next = head->prev = (struct alloc_head *) head;
state_cache_2.c:17392:  head->list = head;
state_cache_2.c:17393:  head->len = 0;
state_cache_2.c:17405:  if (head->next == elem)
state_cache_2.c:17419:  elem->next = head->next;
state_cache_2.c:17420:  head->next->prev = elem;
state_cache_2.c:17422:  elem->prev = (struct alloc_head *) head;
state_cache_2.c:17423:  head->next = elem;
state_cache_2.c:17425:  elem->list = head;
state_cache_2.c:17426:  head->len++;
state_cache_2.c:17437:  if (head->prev == elem)
state_cache_2.c:17452:  elem->next = (struct alloc_head *) head;
state_cache_2.c:17454:  elem->prev = head->prev;
state_cache_2.c:17456:  head->prev->next = elem;
state_cache_2.c:17458:  elem->list = head;
state_cache_2.c:17459:  head->prev = elem;
state_cache_2.c:17460:  head->len++;
state_cache_2.c:17471:  if (head->prev == elem)
state_cache_2.c:17486:  elem->next = (struct alloc_head *) head;
state_cache_2.c:17487:  elem->prev = head->prev;
state_cache_2.c:17491:  head->prev->next = elem;
state_cache_2.c:17493:  elem->next = (struct alloc_head *) head;
state_cache_2.c:17495:  elem->list = head;
state_cache_2.c:17496:  head->prev = elem;
state_cache_2.c:17497:  head->len++;
state_cache_2.c:17509:  elem->next->prev = elem->prev;
state_cache_2.c:17510:  elem->prev->next = elem->next;
state_cache_2.c:17511:  elem->prev = elem->next = ((void *) 0);
state_cache_2.c:17513:  elem->list->len--;
state_cache_2.c:17514:  elem->list = ((void *) 0);
state_cache_2.c:17522:  if (!(elem->next == ((void *) 0) && elem->prev == ((void *) 0)))
state_cache_2.c:17533:  elem->next = prev->next;
state_cache_2.c:17534:  prev->next = elem;
state_cache_2.c:17536:  elem->prev = prev;
state_cache_2.c:17537:  next->prev = elem;
state_cache_2.c:17539:  elem->list = prev->list;
state_cache_2.c:17540:  elem->list->len++;
state_cache_2.c:17587:  pkt->nonce = -1;
state_cache_2.c:17588:  pkt->seq = seq;
state_cache_2.c:17590:  pkt->len = len;
state_cache_2.c:17591:  pkt->type = type;
state_cache_2.c:17592:  pkt->contType = contType;
state_cache_2.c:17593:  pkt->minResponseLen = minResponseLen;
state_cache_2.c:17594:  pkt->firstTransportChild = firstTransportChild;
state_cache_2.c:17595:  pkt->numTransportChildren = numTransportChildren;
state_cache_2.c:17596:  pkt->ucontLen = 0;
state_cache_2.c:17597:  pkt->ucontData = ((void *) 0);
state_cache_2.c:17598:  pkt->numSiblings = -1;
state_cache_2.c:17599:  pkt->position = (0xff);
state_cache_2.c:17606:  if (len > packet->len + packet->ucontLen)
state_cache_2.c:17609:	      (int) len, packet->len, packet->ucontLen);
state_cache_2.c:17612:  if (packet->ucontData)
state_cache_2.c:17614:      kfree (packet->ucontData);
state_cache_2.c:17615:      packet->len += packet->ucontLen;
state_cache_2.c:17616:      packet->ucontLen = 0;
state_cache_2.c:17618:  packet->ucontData = buf;
state_cache_2.c:17619:  packet->ucontLen = len;
state_cache_2.c:17620:  packet->len -= packet->ucontLen;
state_cache_2.c:18148:  printk ("PHChunk %p = { type = %d, chunkLen = %d, range=[%d-%d] }\n",
state_cache_2.c:18149:	  phchunk, phchunk->type, ntohs (phchunk->chunkLen),
state_cache_2.c:18150:	  ntohl (phchunk->start), ntohl (phchunk->end));
state_cache_2.c:19021:    u8 __pad[(1 << ((5))) - sizeof (int)];
state_cache_2.c:19029:  prot->stats[0].inuse++;
state_cache_2.c:19035:  prot->stats[0].inuse--;
state_cache_2.c:19115:  if (sk->filter)
state_cache_2.c:19120:	(void) (&((sk)->lock.slock));
state_cache_2.c:19122:      filter = sk->filter;
state_cache_2.c:19125:	  int pkt_len = sk_run_filter (skb, filter->insns,
state_cache_2.c:19126:				       filter->len);
state_cache_2.c:19128:	    err = -1;
state_cache_2.c:19148:  atomic_sub (size, &sk->omem_alloc);
state_cache_2.c:19150:  if (atomic_dec_and_test (&fp->refcnt))
state_cache_2.c:19157:  atomic_inc (&fp->refcnt);
state_cache_2.c:19158:  atomic_add (sk_filter_len (fp), &sk->omem_alloc);
state_cache_2.c:19165:  atomic_inc (&sk->refcnt);
state_cache_2.c:19174:  atomic_dec (&sk->refcnt);
state_cache_2.c:19181:  if (atomic_dec_and_test (&sk->refcnt))
state_cache_2.c:19197:      (void) (&sk->callback_lock);
state_cache_2.c:19200:  sk->dead = 1;
state_cache_2.c:19201:  sk->socket = ((void *) 0);
state_cache_2.c:19202:  sk->sleep = ((void *) 0);
state_cache_2.c:19213:	  if (!--*ptr)
state_cache_2.c:19214:	    __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;"
state_cache_2.c:19240:      (void) (&sk->callback_lock);
state_cache_2.c:19243:  sk->sleep = &parent->wait;
state_cache_2.c:19244:  parent->sk = sk;
state_cache_2.c:19245:  sk->socket = parent;
state_cache_2.c:19256:	  if (!--*ptr)
state_cache_2.c:19257:	    __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;"
state_cache_2.c:19277:  (void) (&sk->callback_lock);
state_cache_2.c:19278:  uid = sk->socket ? sk->socket->inode->i_uid : 0;
state_cache_2.c:19291:  (void) (&sk->callback_lock);
state_cache_2.c:19292:  ino = sk->socket ? sk->socket->inode->i_ino : 0;
state_cache_2.c:19303:  return sk->dst_cache;
state_cache_2.c:19311:  (void) (&sk->dst_lock);
state_cache_2.c:19312:  dst = sk->dst_cache;
state_cache_2.c:19327:  old_dst = sk->dst_cache;
state_cache_2.c:19328:  sk->dst_cache = dst;
state_cache_2.c:19335:  (void) (&sk->dst_lock);
state_cache_2.c:19348:  old_dst = sk->dst_cache;
state_cache_2.c:19349:  sk->dst_cache = ((void *) 0);
state_cache_2.c:19356:  (void) (&sk->dst_lock);
state_cache_2.c:19367:  struct dst_entry *dst = sk->dst_cache;
state_cache_2.c:19369:  if (dst && dst->obsolete && dst->ops->check (dst, cookie) == ((void *) 0))
state_cache_2.c:19371:      sk->dst_cache = ((void *) 0);
state_cache_2.c:19383:  if (dst && dst->obsolete && dst->ops->check (dst, cookie) == ((void *) 0))
state_cache_2.c:19397:  skb->sk = sk;
state_cache_2.c:19398:  skb->destructor = sock_wfree;
state_cache_2.c:19399:  atomic_add (skb->truesize, &sk->wmem_alloc);
state_cache_2.c:19405:  skb->sk = sk;
state_cache_2.c:19406:  skb->destructor = sock_rfree;
state_cache_2.c:19407:  atomic_add (skb->truesize, &sk->rmem_alloc);
state_cache_2.c:19419:  if (((&sk->rmem_alloc)->counter) + skb->truesize >= (unsigned) sk->rcvbuf)
state_cache_2.c:19421:      err = -12;
state_cache_2.c:19433:  skb->dev = ((void *) 0);
state_cache_2.c:19441:  skb_len = skb->len;
state_cache_2.c:19443:  skb_queue_tail (&sk->receive_queue, skb);
state_cache_2.c:19444:  if (!sk->dead)
state_cache_2.c:19445:    sk->data_ready (sk, skb_len);
state_cache_2.c:19456:  if (((&sk->rmem_alloc)->counter) + skb->truesize >= (unsigned) sk->rcvbuf)
state_cache_2.c:19457:    return -12;
state_cache_2.c:19459:  skb_queue_tail (&sk->error_queue, skb);
state_cache_2.c:19460:  if (!sk->dead)
state_cache_2.c:19461:    sk->data_ready (sk, skb->len);
state_cache_2.c:19473:    ((__typeof__ (*(&sk->err)))
state_cache_2.c:19474:     __xchg ((unsigned long) (0), (&sk->err), sizeof (*(&sk->err))));
state_cache_2.c:19475:  return -err;
state_cache_2.c:19483:  if (!(sk->shutdown & 2))
state_cache_2.c:19485:      amt = sk->sndbuf - ((&sk->wmem_alloc)->counter);
state_cache_2.c:19495:  if (sk->socket && sk->socket->fasync_list)
state_cache_2.c:19496:    sock_wake_async (sk->socket, how, band);
state_cache_2.c:19508:  return ((&sk->wmem_alloc)->counter) < (sk->sndbuf / 2);
state_cache_2.c:19522:  return noblock ? 0 : sk->rcvtimeo;
state_cache_2.c:19528:  return noblock ? 0 : sk->sndtimeo;
state_cache_2.c:19536:			    int __x = (sk->rcvlowat);
state_cache_2.c:19548:  return timeo == ((long) (~0UL >> 1)) ? -512 : -4;
state_cache_2.c:19554:  if (sk->rcvtstamp)
state_cache_2.c:19555:    put_cmsg (msg, 1, 29, sizeof (skb->stamp), &skb->stamp);
state_cache_2.c:19557:    sk->stamp = skb->stamp;
state_cache_2.c:19658:  return !((addr ^ ifa->ifa_address) & ifa->ifa_mask);
state_cache_2.c:19686:  in_dev = dev->ip_ptr;
state_cache_2.c:19688:    atomic_inc (&in_dev->refcnt);
state_cache_2.c:19699:  return (struct in_device *) dev->ip_ptr;
state_cache_2.c:19707:  if (atomic_dec_and_test (&idev->refcnt))
state_cache_2.c:19720:    return htonl (~((1 << (32 - logmask)) - 1));
state_cache_2.c:19729:  return 32 - ffz (~mask);
state_cache_2.c:19776:  if (atomic_dec_and_test (&p->refcnt))
state_cache_2.c:19778:      p->unused_prevp = inet_peer_unused_tailp;
state_cache_2.c:19779:      p->unused_next = ((void *) 0);
state_cache_2.c:19781:      inet_peer_unused_tailp = &p->unused_next;
state_cache_2.c:19782:      p->dtime = jiffies;
state_cache_2.c:19794:	  if (!--*ptr)
state_cache_2.c:19795:	    __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;"
state_cache_2.c:19828:  id = p->ip_id_count++;
state_cache_2.c:19839:	  if (!--*ptr)
state_cache_2.c:19840:	    __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;"
state_cache_2.c:19944:  int size = ((len) + (((sizeof (struct nlmsghdr)) + 4 - 1) & ~(4 - 1)));
state_cache_2.c:19946:  nlh = (struct nlmsghdr *) skb_put (skb, (((size) + 4 - 1) & ~(4 - 1)));
state_cache_2.c:19947:  nlh->nlmsg_type = type;
state_cache_2.c:19948:  nlh->nlmsg_len = size;
state_cache_2.c:19949:  nlh->nlmsg_flags = 0;
state_cache_2.c:19950:  nlh->nlmsg_pid = pid;
state_cache_2.c:19951:  nlh->nlmsg_seq = seq;
state_cache_2.c:20234:  return len > rta->rta_len
state_cache_2.c:20237:				 ((((sizeof (struct rtattr)) + 4 - 1) & ~(4 -
state_cache_2.c:20406:    dst_release (&rt->u.dst);
state_cache_2.c:20426:  dst = (*rp)->rt_dst;
state_cache_2.c:20427:  src = (*rp)->rt_src;
state_cache_2.c:20438:  if (rt->peer)
state_cache_2.c:20439:    return rt->peer;
state_cache_2.c:20442:  return rt->peer;
state_cache_2.c:20891:  if (skb->len > skb->dst->pmtu)
state_cache_2.c:20902:  u32 check = iph->check;
state_cache_2.c:20907:  iph->check = check + (check >= 0xFFFF);
state_cache_2.c:20908:  return --iph->ttl;
state_cache_2.c:20914:  return (sk->protinfo.af_inet.pmtudisc == 2 ||
state_cache_2.c:20915:	  (sk->protinfo.af_inet.pmtudisc == 1 &&
state_cache_2.c:20916:	   !(dst->mxlock & (1 << RTAX_MTU))));
state_cache_2.c:20924:  if (iph->
state_cache_2.c:20935:      iph->id = ((sk && sk->daddr) ? htons (sk->protinfo.af_inet.id++) : 0);
state_cache_2.c:21141:unsigned long flag, sum; asm ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag), "=r" (sum):"1" (dst), "g" ((int) (len)), "g" (get_current ()->addr_limit.seg));
state_cache_2.c:21148:    *err_ptr = -14;
state_cache_2.c:21150:  return -1;
state_cache_2.c:21163:    *err_ptr = -14;
state_cache_2.c:21270:  return (lport & ((tcp_hashinfo.__tcp_bhash_size) - 1));
state_cache_2.c:21322:  if (atomic_dec_and_test (&tw->refcnt))
state_cache_2.c:21341:  return num & (32 - 1);
state_cache_2.c:21347:  return tcp_lhashfn (sk->num);
state_cache_2.c:21445:  req->class->destructor (req);
state_cache_2.c:21490:  return (__s32) (seq1 - seq2) < 0;
state_cache_2.c:21496:  return (__s32) (seq2 - seq1) < 0;
state_cache_2.c:21504:  return seq3 - seq2 >= seq1 - seq2;
state_cache_2.c:21555:  tp->ack.pending |= TCP_ACK_SCHED;
state_cache_2.c:21561:  return tp->ack.pending & TCP_ACK_SCHED;
state_cache_2.c:21567:  if (tp->ack.quick && --tp->ack.quick == 0)
state_cache_2.c:21570:      tp->ack.ato = ((unsigned) (100 / 25));
state_cache_2.c:21580:   ? (__builtin_constant_p ((sizeof (tp->ack))) ?
state_cache_2.c:21581:      __constant_c_and_count_memset (((&tp->ack)),
state_cache_2.c:21583:				     ((sizeof (tp->ack)))) :
state_cache_2.c:21584:      __constant_c_memset (((&tp->ack)),
state_cache_2.c:21586:			   ((sizeof (tp->ack)))))
state_cache_2.c:21587:   : (__builtin_constant_p ((sizeof (tp->ack))) ?
state_cache_2.c:21588:      __memset_generic ((((&tp->ack))), (((0))),
state_cache_2.c:21589:			(((sizeof (tp->ack))))) :
state_cache_2.c:21590:      __memset_generic (((&tp->ack)), ((0)), ((sizeof (tp->ack))))));
state_cache_2.c:21596:  tp->tstamp_ok = tp->sack_ok = tp->wscale_ok = tp->snd_wscale = 0;
state_cache_2.c:21733:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_2.c:21739:      tp->pending = 0;
state_cache_2.c:21748:      tp->ack.blocked = 0;
state_cache_2.c:21749:      tp->ack.pending = 0;
state_cache_2.c:21770:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_2.c:21790:      tp->pending = what;
state_cache_2.c:21791:      tp->timeout = jiffies + when;
state_cache_2.c:21792:      if (!mod_timer (&tp->retransmit_timer, tp->timeout))
state_cache_2.c:21797:      tp->ack.pending |= TCP_ACK_TIMER;
state_cache_2.c:21798:      tp->ack.timeout = jiffies + when;
state_cache_2.c:21799:      if (!mod_timer (&tp->delack_timer, tp->ack.timeout))
state_cache_2.c:21815:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_2.c:21817:  int mss_now = tp->mss_cache;
state_cache_2.c:21819:  if (dst && dst->pmtu != tp->pmtu_cookie)
state_cache_2.c:21820:    mss_now = tcp_sync_mss (sk, dst->pmtu);
state_cache_2.c:21822:  if (tp->eff_sacks)
state_cache_2.c:21823:    mss_now -= (4 + (tp->eff_sacks * 8));
state_cache_2.c:21831:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_2.c:21832:  unsigned int hint = ({ const typeof (tp->advmss) _x = (tp->advmss);
state_cache_2.c:21833:		       const typeof (tp->mss_cache) _y = (tp->mss_cache);
state_cache_2.c:21841:	   const typeof (tp->rcv_wnd / 2) _y = (tp->rcv_wnd / 2);
state_cache_2.c:21860:  tp->ack.rcv_mss = hint;
state_cache_2.c:21866:  tp->pred_flags = htonl ((tp->tcp_header_len << 26) |
state_cache_2.c:21873:  __tcp_fast_path_on (tp, tp->snd_wnd >> tp->snd_wscale);
state_cache_2.c:21879:  if (skb_queue_len (&tp->out_of_order_queue) == 0 &&
state_cache_2.c:21880:      tp->rcv_wnd &&
state_cache_2.c:21881:      ((&sk->rmem_alloc)->counter) < sk->rcvbuf && !tp->urg_data)
state_cache_2.c:21892:  s32 win = tp->rcv_wup + tp->rcv_wnd - tp->rcv_nxt;
state_cache_2.c:21979:  u32 check = iph->check;
state_cache_2.c:21984:  iph->check = check + (check >= 0xFFFF);
state_cache_2.c:21985:  iph->tos |= 1;
state_cache_2.c:22007:  if (tp->ecn_flags & 1)
state_cache_2.c:22008:    tp->ecn_flags |= 2;
state_cache_2.c:22017:  ((struct tcp_skb_cb *) &((skb)->cb[0]))->flags &= ~0x80;
state_cache_2.c:22018:  if (!(tp->ecn_flags & 1))
state_cache_2.c:22019:    ((struct tcp_skb_cb *) &((skb)->cb[0]))->flags &= ~0x40;
state_cache_2.c:22025:  tp->ecn_flags = 0;
state_cache_2.c:22028:      ((struct tcp_skb_cb *) &((skb)->cb[0]))->flags |= 0x40 | 0x80;
state_cache_2.c:22029:      tp->ecn_flags = 1;
state_cache_2.c:22036:  if (req->ecn_ok)
state_cache_2.c:22037:    th->ece = 1;
state_cache_2.c:22044:  if (tp->ecn_flags & 1)
state_cache_2.c:22047:      if (skb->len != tcp_header_len &&
state_cache_2.c:22048:	  !before (((struct tcp_skb_cb *) &((skb)->cb[0]))->seq, tp->snd_nxt))
state_cache_2.c:22052:	      (sk)->protinfo.af_inet.tos |= 2;
state_cache_2.c:22055:	  if (tp->ecn_flags & 2)
state_cache_2.c:22057:	      tp->ecn_flags &= ~2;
state_cache_2.c:22058:	      skb->h.th->cwr = 1;
state_cache_2.c:22066:	      (sk)->protinfo.af_inet.tos &= ~3;
state_cache_2.c:22070:      if (tp->ecn_flags & 4)
state_cache_2.c:22071:	skb->h.th->ece = 1;
state_cache_2.c:22080:  if (skb->h.th->cwr)
state_cache_2.c:22081:    tp->ecn_flags &= ~4;
state_cache_2.c:22087:  tp->ecn_flags &= ~4;
state_cache_2.c:22093:  if (tp->ecn_flags & 1)
state_cache_2.c:22095:      if (INET_ECN_is_ce (((struct tcp_skb_cb *) &((skb)->cb[0]))->flags))
state_cache_2.c:22096:	tp->ecn_flags |= 4;
state_cache_2.c:22102:	    ((((struct tcp_skb_cb *) &((skb)->cb[0]))->flags)))
state_cache_2.c:22110:  if ((tp->ecn_flags & 1) && (!th->ece || th->cwr))
state_cache_2.c:22111:    tp->ecn_flags &= ~1;
state_cache_2.c:22117:  if ((tp->ecn_flags & 1) && (!th->ece || !th->cwr))
state_cache_2.c:22118:    tp->ecn_flags &= ~1;
state_cache_2.c:22124:  if (th->ece && !th->syn && (tp->ecn_flags & 1))
state_cache_2.c:22132:  tp->ecn_flags = req->ecn_ok ? 1 : 0;
state_cache_2.c:22138:  if (sysctl_tcp_ecn && th->ece && th->cwr)
state_cache_2.c:22139:    req->ecn_ok = 1;
state_cache_2.c:22151:  return sk->wmem_queued / 2;
state_cache_2.c:22157:  return sk->sndbuf - sk->wmem_queued;
state_cache_2.c:22164:  return tp->packets_out - tp->left_out + tp->retrans_out;
state_cache_2.c:22177:	   const typeof (tp->snd_cwnd >> 1U) _x = (tp->snd_cwnd >> 1U);
state_cache_2.c:22191:  if ((1 << tp->ca_state) & ((1 << TCP_CA_CWR) | (1 << TCP_CA_Recovery)))
state_cache_2.c:22192:    return tp->snd_ssthresh;
state_cache_2.c:22196:	     const typeof (tp->snd_ssthresh) _x = (tp->snd_ssthresh);
state_cache_2.c:22197:	     const typeof (((tp->snd_cwnd >> 1) + (tp->snd_cwnd >> 2))) _y =
state_cache_2.c:22198:	     (((tp->snd_cwnd >> 1) + (tp->snd_cwnd >> 2)));
state_cache_2.c:22209:  if (tp->sack_ok && tp->sacked_out >= tp->packets_out - tp->lost_out)
state_cache_2.c:22210:    tp->sacked_out = tp->packets_out - tp->lost_out;
state_cache_2.c:22211:  tp->left_out = tp->sacked_out + tp->lost_out;
state_cache_2.c:22221:  if (tp->packets_out >= tp->snd_cwnd)
state_cache_2.c:22224:      tp->snd_cwnd_used = 0;
state_cache_2.c:22225:      tp->snd_cwnd_stamp = ((__u32) (jiffies));
state_cache_2.c:22230:      if (tp->packets_out > tp->snd_cwnd_used)
state_cache_2.c:22231:	tp->snd_cwnd_used = tp->packets_out;
state_cache_2.c:22233:      if ((s32) (((__u32) (jiffies)) - tp->snd_cwnd_stamp) >= tp->rto)
state_cache_2.c:22242:  tp->undo_marker = 0;
state_cache_2.c:22243:  tp->snd_ssthresh = tcp_recalc_ssthresh (tp);
state_cache_2.c:22244:  tp->snd_cwnd = (
state_cache_2.c:22246:		   const typeof (tp->snd_cwnd) _x = (tp->snd_cwnd);
state_cache_2.c:22253:  tp->snd_cwnd_cnt = 0;
state_cache_2.c:22254:  tp->high_seq = tp->snd_nxt;
state_cache_2.c:22255:  tp->snd_cwnd_stamp = ((__u32) (jiffies));
state_cache_2.c:22262:  tp->prior_ssthresh = 0;
state_cache_2.c:22263:  if (tp->ca_state < TCP_CA_CWR)
state_cache_2.c:22266:      tp->ca_state = TCP_CA_CWR;
state_cache_2.c:22284:  return after (tp->snd_sml, tp->snd_una) &&
state_cache_2.c:22285:    !after (tp->snd_sml, tp->snd_nxt);
state_cache_2.c:22291:  if (skb->len < mss)
state_cache_2.c:22292:    tp->snd_sml = ((struct tcp_skb_cb *) &((skb)->cb[0]))->end_seq;
state_cache_2.c:22300:  return (skb->len < mss_now &&
state_cache_2.c:22301:	  !(((struct tcp_skb_cb *) &((skb)->cb[0]))->flags & 0x01) &&
state_cache_2.c:22303:	   (!nonagle && tp->packets_out && tcp_minshall_check (tp))));
state_cache_2.c:22314:  return ((nonagle == 1 || tp->urg_mode
state_cache_2.c:22316:	  ((tcp_packets_in_flight (tp) < tp->snd_cwnd) ||
state_cache_2.c:22317:	   (((struct tcp_skb_cb *) &((skb)->cb[0]))->flags & 0x01)) &&
state_cache_2.c:22318:	  !after (((struct tcp_skb_cb *) &((skb)->cb[0]))->end_seq,
state_cache_2.c:22319:		  tp->snd_una + tp->snd_wnd));
state_cache_2.c:22325:  if (!tp->packets_out && !tp->pending)
state_cache_2.c:22326:    tcp_reset_xmit_timer (sk, 3, tp->rto);
state_cache_2.c:22332:  return (skb->next == (struct sk_buff *) &sk->write_queue);
state_cache_2.c:22343:  struct sk_buff *skb = tp->send_head;
state_cache_2.c:22359:  __tcp_push_pending_frames (sk, tp, tcp_current_mss (sk), tp->nonagle);
state_cache_2.c:22365:  struct sk_buff *skb = tp->send_head;
state_cache_2.c:22369:			tcp_skb_is_last (sk, skb) ? 1 : tp->nonagle));
state_cache_2.c:22375:  tp->snd_wl1 = seq;
state_cache_2.c:22381:  tp->snd_wl1 = seq;
state_cache_2.c:22401:    csum_fold (skb_checksum (skb, 0, skb->len, skb->csum));
state_cache_2.c:22407:  return skb->ip_summed != 2 && __tcp_checksum_complete (skb);
state_cache_2.c:22415:  tp->ucopy.task = ((void *) 0);
state_cache_2.c:22416:  tp->ucopy.len = 0;
state_cache_2.c:22417:  tp->ucopy.memory = 0;
state_cache_2.c:22418:  skb_queue_head_init (&tp->ucopy.prequeue);
state_cache_2.c:22425:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_2.c:22427:  if (!sysctl_tcp_low_latency && tp->ucopy.task)
state_cache_2.c:22429:      __skb_queue_tail (&tp->ucopy.prequeue, skb);
state_cache_2.c:22430:      tp->ucopy.memory += skb->truesize;
state_cache_2.c:22431:      if (tp->ucopy.memory > sk->rcvbuf)
state_cache_2.c:22435:	  if (sk->lock.users)
state_cache_2.c:22438:	  while ((skb1 = __skb_dequeue (&tp->ucopy.prequeue)) != ((void *) 0))
state_cache_2.c:22440:	      sk->backlog_rcv (sk, skb1);
state_cache_2.c:22444:	  tp->ucopy.memory = 0;
state_cache_2.c:22446:      else if (skb_queue_len (&tp->ucopy.prequeue) == 1)
state_cache_2.c:22448:	  __wake_up ((sk->sleep), 1, 1);
state_cache_2.c:22461:  int oldstate = sk->state;
state_cache_2.c:22480:      sk->prot->unhash (sk);
state_cache_2.c:22481:      if (sk->prev && !(sk->userlocks & 8))
state_cache_2.c:22488:			  irq_stat[0].__local_bh_count) != 0)].TcpCurrEstab--;
state_cache_2.c:22494:  sk->state = state;
state_cache_2.c:22507:  sk->shutdown = 3;
state_cache_2.c:22509:  if (!sk->dead)
state_cache_2.c:22510:    sk->state_change (sk);
state_cache_2.c:22518:  tp->dsack = 0;
state_cache_2.c:22519:  tp->eff_sacks = 0;
state_cache_2.c:22520:  tp->num_sacks = 0;
state_cache_2.c:22526:  if (tp->tstamp_ok)
state_cache_2.c:22542:      *ptr++ = htonl (tp->ts_recent);
state_cache_2.c:22544:  if (tp->eff_sacks)
state_cache_2.c:22547:	tp->dsack ? tp->duplicate_sack : tp->selective_acks;
state_cache_2.c:22553:	    (((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) &
state_cache_2.c:22556:	    (((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) &
state_cache_2.c:22559:	    (((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) &
state_cache_2.c:22562:	    (((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) &
state_cache_2.c:22568:      for (this_sack = 0; this_sack < tp->eff_sacks; this_sack++)
state_cache_2.c:22573:      if (tp->dsack)
state_cache_2.c:22575:	  tp->dsack = 0;
state_cache_2.c:22576:	  tp->eff_sacks--;
state_cache_2.c:22684:      if (*rcv_wscale && sysctl_tcp_app_win && space >= mss && space - (
state_cache_2.c:22689:	(*rcv_wscale)--;
state_cache_2.c:22721:    (space >> (-sysctl_tcp_adv_win_scale)) :
state_cache_2.c:22722:    space - (space >> sysctl_tcp_adv_win_scale);
state_cache_2.c:22729:  return tcp_win_from_space (sk->rcvbuf - ((&sk->rmem_alloc)->counter));
state_cache_2.c:22735:  return tcp_win_from_space (sk->rcvbuf);
state_cache_2.c:22741:  sk->ack_backlog--;
state_cache_2.c:22747:  sk->ack_backlog++;
state_cache_2.c:22753:  return sk->ack_backlog > sk->max_ack_backlog;
state_cache_2.c:22760:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_2.c:22762:  req->sk = child;
state_cache_2.c:22765:  if (!tp->accept_queue_tail)
state_cache_2.c:22767:      tp->accept_queue = req;
state_cache_2.c:22771:      tp->accept_queue_tail->dl_next = req;
state_cache_2.c:22773:  tp->accept_queue_tail = req;
state_cache_2.c:22774:  req->dl_next = ((void *) 0);
state_cache_2.c:22790:  struct tcp_listen_opt *lopt = sk->tp_pinfo.af_tcp.listen_opt;
state_cache_2.c:22792:  if (--lopt->qlen == 0)
state_cache_2.c:22794:  if (req->retrans == 0)
state_cache_2.c:22795:    lopt->qlen_young--;
state_cache_2.c:22801:  struct tcp_listen_opt *lopt = sk->tp_pinfo.af_tcp.listen_opt;
state_cache_2.c:22803:  if (lopt->qlen++ == 0)
state_cache_2.c:22805:  lopt->qlen_young++;
state_cache_2.c:22811:  return sk->tp_pinfo.af_tcp.listen_opt->qlen;
state_cache_2.c:22817:  return sk->tp_pinfo.af_tcp.listen_opt->qlen_young;
state_cache_2.c:22823:  return tcp_synq_len (sk) >> sk->tp_pinfo.af_tcp.listen_opt->max_qlen_log;
state_cache_2.c:22830:  (void) (&tp->syn_wait_lock);
state_cache_2.c:22831:  *prev = req->dl_next;
state_cache_2.c:22842:  tcp_synq_unlink (&sk->tp_pinfo.af_tcp, req, prev);
state_cache_2.c:22851:  req->rcv_wnd = 0;
state_cache_2.c:22852:  req->rcv_isn = ((struct tcp_skb_cb *) &((skb)->cb[0]))->seq;
state_cache_2.c:22853:  req->mss = tp->mss_clamp;
state_cache_2.c:22854:  req->ts_recent = tp->saw_tstamp ? tp->rcv_tsval : 0;
state_cache_2.c:22855:  req->tstamp_ok = tp->tstamp_ok;
state_cache_2.c:22856:  req->sack_ok = tp->sack_ok;
state_cache_2.c:22857:  req->snd_wscale = tp->snd_wscale;
state_cache_2.c:22858:  req->wscale_ok = tp->wscale_ok;
state_cache_2.c:22859:  req->acked = 0;
state_cache_2.c:22860:  req->ecn_ok = 0;
state_cache_2.c:22861:  req->rmt_port = skb->h.th->source;
state_cache_2.c:22869:  sk->tp_pinfo.af_tcp.queue_shrunk = 1;
state_cache_2.c:22870:  sk->wmem_queued -= skb->truesize;
state_cache_2.c:22871:  sk->forward_alloc += skb->truesize;
state_cache_2.c:22878:  sk->wmem_queued += skb->truesize;
state_cache_2.c:22879:  sk->forward_alloc -= skb->truesize;
state_cache_2.c:22888:  if (sk->forward_alloc >= ((int) (1UL << 12)))
state_cache_2.c:22908:  if (!(sk->userlocks & 1))
state_cache_2.c:22910:      sk->sndbuf = (
state_cache_2.c:22912:		     const typeof (sk->sndbuf) _x = (sk->sndbuf);
state_cache_2.c:22913:		     const typeof (sk->wmem_queued / 2) _y =
state_cache_2.c:22914:		     (sk->wmem_queued / 2);
state_cache_2.c:22918:      sk->sndbuf = (
state_cache_2.c:22920:		     const typeof (sk->sndbuf) _x = (sk->sndbuf);
state_cache_2.c:22935:      skb->truesize += mem;
state_cache_2.c:22936:      if (sk->forward_alloc >= (int) skb->truesize ||
state_cache_2.c:22937:	  tcp_mem_schedule (sk, skb->truesize, 0))
state_cache_2.c:22961:  if (sk->forward_alloc >= (int) (1UL << 12) ||
state_cache_2.c:22964:      struct page *page = alloc_pages (sk->allocation, 0);
state_cache_2.c:22978:  while ((skb = __skb_dequeue (&sk->write_queue)) != ((void *) 0))
state_cache_2.c:22988:  skb->sk = sk;
state_cache_2.c:22989:  skb->destructor = tcp_rfree;
state_cache_2.c:22990:  atomic_add (skb->truesize, &sk->rmem_alloc);
state_cache_2.c:22991:  sk->forward_alloc -= skb->truesize;
state_cache_2.c:23023:  return tp->keepalive_intvl ? : sysctl_tcp_keepalive_intvl;
state_cache_2.c:23029:  return tp->keepalive_time ? : sysctl_tcp_keepalive_time;
state_cache_2.c:23035:  int fin_timeout = tp->linger2 ? : sysctl_tcp_fin_timeout;
state_cache_2.c:23037:  if (fin_timeout < (tp->rto << 2) - (tp->rto >> 1))
state_cache_2.c:23038:    fin_timeout = (tp->rto << 2) - (tp->rto >> 1);
state_cache_2.c:23046:  if ((s32) (tp->rcv_tsval - tp->ts_recent) >= 0)
state_cache_2.c:23048:  if (xtime.tv_sec >= tp->ts_recent_stamp + (60 * 60 * 24 * 24))
state_cache_2.c:23051:  if (rst && xtime.tv_sec >= tp->ts_recent_stamp + 60)
state_cache_2.c:23061:  const struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_2.c:23067:  return (sysctl_tcp_frto && tp->send_head &&
state_cache_2.c:23068:	  !after (((struct tcp_skb_cb *) &((tp->send_head)->cb[0]))->end_seq,
state_cache_2.c:23069:		  tp->snd_una + tp->snd_wnd));
state_cache_2.c:23081:  ((tcp_statistics)[2 * 0 + 1].TcpMaxConn += -1);
state_cache_2.c:23094:    tp->westwood.rtt = rtt_seq;
state_cache_2.c:23103:  struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
state_cache_2.c:23105:  tp->westwood.bw_ns_est = 0;
state_cache_2.c:23106:  tp->westwood.bw_est = 0;
state_cache_2.c:23107:  tp->westwood.accounted = 0;
state_cache_2.c:23108:  tp->westwood.cumul_ack = 0;
state_cache_2.c:23109:  tp->westwood.rtt_win_sx = ((__u32) (jiffies));
state_cache_2.c:23110:  tp->westwood.rtt = 20 * 100;
state_cache_2.c:23111:  tp->westwood.rtt_min = 20 * 100;
state_cache_2.c:23112:  tp->westwood.snd_una = tp->snd_una;
state_cache_2.c:23138:  return (__u32) ((tp->westwood.bw_est) * (tp->westwood.rtt_min) /
state_cache_2.c:23139:		  (__u32) (tp->mss_cache));
state_cache_2.c:23172:      tp->snd_ssthresh = ssthresh;
state_cache_2.c:23190:      tp->snd_cwnd = cwnd;
state_cache_2.c:23206:	  tp->snd_ssthresh = tp->snd_cwnd;
state_cache_2.c:23230:# 1 "/home/ashieh/current/include/net/trickles-crypto.h" 1
state_cache_2.c:23251:# 6 "/home/ashieh/current/include/net/trickles-crypto.h" 2
state_cache_2.c:23335:# 13 "/home/ashieh/current/include/net/trickles-crypto.h" 2
state_cache_2.c:23495:  struct sock *sk = skb->sk;
state_cache_2.c:23496:  if (skb->ip_summed == 1)
state_cache_2.c:23498:      skb->h.th->check = 0;
state_cache_2.c:23499:      skb->h.th->check =
state_cache_2.c:23500:	~tcp_v4_check (skb->h.th, skb->len, sk->saddr, sk->daddr, 0);
state_cache_2.c:23501:      skb->csum = ((size_t) & ((struct tcphdr *) 0)->check);
state_cache_2.c:23505:      skb->h.th->check = 0;
state_cache_2.c:23506:      skb->h.th->check =
state_cache_2.c:23507:	tcp_v4_check (skb->h.th, skb->len, sk->saddr, sk->daddr,
state_cache_2.c:23508:		      csum_partial ((char *) skb->h.th, headerLen,
state_cache_2.c:23509:				    skb->csum));
state_cache_2.c:23539:  POISONEDRANGE = -1,
state_cache_2.c:23595:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_2.c:23596:  if (!(dataReq->list == ((void *) 0)))
state_cache_2.c:23598:      printk ("KERNEL: assertion (" "dataReq->list == NULL" ") failed at "
state_cache_2.c:23602:  dataReq->completed = 0;
state_cache_2.c:23603:  dataReq->sent = 0;
state_cache_2.c:23605:  dataReq->transportResponseSeqStart = (4294967295U);
state_cache_2.c:23606:  dataReq->transportResponseSeqEnd = (4294967295U);
state_cache_2.c:23607:  dataReq->timestamp = (4294967295U);
state_cache_2.c:23608:  dataReq->start = newStart;
state_cache_2.c:23609:  dataReq->end = newEnd;
state_cache_2.c:23610:  insert_tail (&tp->t.missingDataMap, (struct alloc_head *) dataReq);
state_cache_2.c:23644:  newMapping->next = newMapping->prev = ((void *) 0);
state_cache_2.c:23645:  newMapping->list = ((void *) 0);
state_cache_2.c:23647:  newMapping->completed = 0;
state_cache_2.c:23648:  newMapping->ucont = ucont;
state_cache_2.c:23649:  newMapping->transportResponseSeqStart = tseq_start;
state_cache_2.c:23650:  newMapping->transportResponseSeqEnd = tseq_end;
state_cache_2.c:23651:  newMapping->sent = 0;
state_cache_2.c:23652:  newMapping->start = start;
state_cache_2.c:23653:  newMapping->end = end;
state_cache_2.c:23655:  newMapping->timestamp = jiffies;
state_cache_2.c:23665:  numDataRequestMappings--;
state_cache_2.c:23705:  req->numChildren = 0;
state_cache_2.c:23706:  req->childrenMask = 0;
state_cache_2.c:23707:  req->transport_seq = -1;
state_cache_2.c:23708:  req->seq = -1;
state_cache_2.c:23709:  req->isNew = 1;
state_cache_2.c:23716:  req->type = type;
state_cache_2.c:23717:  req->prev = req->next = ((void *) 0);
state_cache_2.c:23718:  req->list = ((void *) 0);
state_cache_2.c:23720:  req->start = req->end = -1;
state_cache_2.c:23721:  req->allocated = 1;
state_cache_2.c:23729:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_2.c:23730:  insert_tail (&tp->t.queuedRequests, (struct alloc_head *) req);
state_cache_2.c:23731:  tp->t.timerState |= (0x1);
state_cache_2.c:23779:  req->incomplete = 0;
state_cache_2.c:23780:  req->completePred = pred;
state_cache_2.c:23781:  atomic_inc (&req->completePred->refcnt);
state_cache_2.c:23783:  if (((&req->completePred->refcnt)->counter) < 2)
state_cache_2.c:23788:  req->data = data;
state_cache_2.c:23789:  req->start = start;
state_cache_2.c:23790:  req->offset = req->start - ((struct tcp_skb_cb *) &((data)->cb[0]))->seq;
state_cache_2.c:23800:  req->incomplete = 1;
state_cache_2.c:23801:  req->incompletePred = pred;
state_cache_2.c:23802:  req->predLength = predLength;
state_cache_2.c:23803:  req->data = data;
state_cache_2.c:23804:  req->offset = offset;
state_cache_2.c:23840:  req->start = start;
state_cache_2.c:23841:  req->end = end;
state_cache_2.c:23842:  req->numConts = numConts;
state_cache_2.c:23843:  req->conts = kmalloc (sizeof (struct UC_Continuation *) * numConts, (0x20));
state_cache_2.c:23848:      return -1;
state_cache_2.c:23863:  newReq->conts =
state_cache_2.c:23864:    kmalloc (sizeof (struct UC_Continuation *) * newReq->numConts, (0x20));
state_cache_2.c:23865:  if (newReq->conts == ((void *) 0))
state_cache_2.c:23870:  (__builtin_constant_p (sizeof (struct UC_Continuation *) * newReq->numConts)
state_cache_2.c:23871:   ? __constant_memcpy ((newReq->conts), (src->conts),
state_cache_2.c:23873:			 newReq->numConts)) : __memcpy ((newReq->conts),
state_cache_2.c:23874:							(src->conts),
state_cache_2.c:23878:							 newReq->numConts)));
state_cache_2.c:23907:  rval->prev = rval->next = ((void *) 0);
state_cache_2.c:23908:  rval->list = ((void *) 0);
state_cache_2.c:23910:  rval->cont = cont;
state_cache_2.c:23911:  rval->isSynack = isSynack;
state_cache_2.c:23912:  rval->parent = parent;
state_cache_2.c:23913:  rval->numSiblings = numSiblings;
state_cache_2.c:23914:  rval->position = position;
state_cache_2.c:23962:  dcont->clientState = scont->clientState;
state_cache_2.c:23963:  dcont->parent = scont->parent;
state_cache_2.c:23968:	(dcont)->seq = htonl ((scont)->packets[pktNum].seq);
state_cache_2.c:23969:	(dcont)->continuationType = (scont)->packets[pktNum].contType;
state_cache_2.c:23970:	if ((scont)->packets[pktNum].type & (0x80))
state_cache_2.c:23972:	(dcont)->firstChild = 1;}
state_cache_2.c:23975:	(dcont)->firstChild = 0;}
state_cache_2.c:23979:	int conversionOffset = (scont)->packets[pktNum].type & (0x3);
state_cache_2.c:23989:	(dcont)->state = stateConversionMap[conversionOffset];}
state_cache_2.c:23991:	  dcont->timestamp = htonl (scont->timestamp);
state_cache_2.c:23992:	  dcont->clientTimestamp = scont->clientTimestamp;
state_cache_2.c:23993:	  dcont->mrtt = htonl (scont->mrtt);
state_cache_2.c:23997:	  dcont->seq = htonl (scont->seq);
state_cache_2.c:23998:	  dcont->continuationType = scont->continuationType;
state_cache_2.c:23999:	  dcont->firstChild = scont->firstChild;
state_cache_2.c:24000:	  dcont->state = scont->state;
state_cache_2.c:24001:	  dcont->timestamp = scont->rawTimestamp;
state_cache_2.c:24002:	  dcont->clientTimestamp = scont->clientTimestamp;
state_cache_2.c:24003:	  dcont->mrtt = scont->rawMrtt;
state_cache_2.c:24005:	dcont->firstLoss = htonl (scont->firstLoss);
state_cache_2.c:24006:	dcont->firstBootstrapSeq = htonl (scont->firstBootstrapSeq);
state_cache_2.c:24007:	dcont->startCwnd = htonl (scont->startCwnd);
state_cache_2.c:24008:	dcont->ssthresh = htonl (scont->ssthresh);
state_cache_2.c:24009:	dcont->TCPBase = htonl (scont->TCPBase);
state_cache_2.c:24010:	dcont->tokenCounterBase = scont->tokenCounterBase;
state_cache_2.c:24014:	    phdr->seq = dcont->seq;
state_cache_2.c:24015:	    phdr->type = dcont->continuationType;
state_cache_2.c:24016:	    phdr->first = dcont->firstChild ? 1 : 0;
state_cache_2.c:24017:	    phdr->serverAddr = scont->saddr;
state_cache_2.c:24018:	    phdr->serverPort = scont->source;
state_cache_2.c:24019:	    phdr->clientAddr = scont->daddr;
state_cache_2.c:24020:	    phdr->clientPort = scont->dest;
state_cache_2.c:24021:	    computeMAC (sk, phdr, dcont, dcont->mac);
state_cache_2.c:24032:	dcont->clientState = scont->clientState;
state_cache_2.c:24033:	dcont->parent = scont->parent;
state_cache_2.c:24038:	      (dcont)->seq = htonl ((scont)->packets[pktNum].seq);
state_cache_2.c:24039:	      (dcont)->continuationType = (scont)->packets[pktNum].contType;
state_cache_2.c:24040:	      if ((scont)->packets[pktNum].type & (0x80))
state_cache_2.c:24042:	      (dcont)->firstChild = 1;}
state_cache_2.c:24045:	      (dcont)->firstChild = 0;}
state_cache_2.c:24049:	      int conversionOffset = (scont)->packets[pktNum].type & (0x3);
state_cache_2.c:24059:	      (dcont)->state = stateConversionMap[conversionOffset];}
state_cache_2.c:24061:		dcont->timestamp = htonl (scont->timestamp);
state_cache_2.c:24062:		dcont->clientTimestamp = scont->clientTimestamp;
state_cache_2.c:24063:		dcont->mrtt = htonl (scont->mrtt);
state_cache_2.c:24067:		dcont->seq = htonl (scont->seq);
state_cache_2.c:24068:		dcont->continuationType = scont->continuationType;
state_cache_2.c:24069:		dcont->firstChild = scont->firstChild;
state_cache_2.c:24070:		dcont->state = scont->state;
state_cache_2.c:24071:		dcont->timestamp = scont->rawTimestamp;
state_cache_2.c:24072:		dcont->clientTimestamp = scont->clientTimestamp;
state_cache_2.c:24073:		dcont->mrtt = scont->rawMrtt;
state_cache_2.c:24075:	      dcont->firstLoss = htonl (scont->firstLoss);
state_cache_2.c:24076:	      dcont->firstBootstrapSeq = htonl (scont->firstBootstrapSeq);
state_cache_2.c:24077:	      dcont->startCwnd = htonl (scont->startCwnd);
state_cache_2.c:24078:	      dcont->ssthresh = htonl (scont->ssthresh);
state_cache_2.c:24079:	      dcont->TCPBase = htonl (scont->TCPBase);
state_cache_2.c:24080:	      dcont->tokenCounterBase = scont->tokenCounterBase;
state_cache_2.c:24084:		   __constant_memcpy ((dcont->mac), (scont->mac),
state_cache_2.c:24085:				      (16)) : __memcpy ((dcont->mac),
state_cache_2.c:24086:							(scont->mac), (16)));
state_cache_2.c:24097:	      dcont->clientState = scont->clientState;
state_cache_2.c:24098:	      dcont->parent = scont->parent;
state_cache_2.c:24103:		    (dcont)->seq = htonl ((scont)->packets[pktNum].seq);
state_cache_2.c:24104:		    (dcont)->continuationType =
state_cache_2.c:24105:		    (scont)->packets[pktNum].contType;
state_cache_2.c:24106:		    if ((scont)->packets[pktNum].type & (0x80))
state_cache_2.c:24108:		    (dcont)->firstChild = 1;}
state_cache_2.c:24111:		    (dcont)->firstChild = 0;}
state_cache_2.c:24116:		    (scont)->packets[pktNum].type & (0x3);
state_cache_2.c:24126:		    (dcont)->state = stateConversionMap[conversionOffset];}
state_cache_2.c:24128:		      dcont->timestamp = htonl (scont->timestamp);
state_cache_2.c:24129:		      dcont->clientTimestamp = scont->clientTimestamp;
state_cache_2.c:24130:		      dcont->mrtt = htonl (scont->mrtt);
state_cache_2.c:24134:		      dcont->seq = htonl (scont->seq);
state_cache_2.c:24135:		      dcont->continuationType = scont->continuationType;
state_cache_2.c:24136:		      dcont->firstChild = scont->firstChild;
state_cache_2.c:24137:		      dcont->state = scont->state;
state_cache_2.c:24138:		      dcont->timestamp = scont->rawTimestamp;
state_cache_2.c:24139:		      dcont->clientTimestamp = scont->clientTimestamp;
state_cache_2.c:24140:		      dcont->mrtt = scont->rawMrtt;
state_cache_2.c:24142:		    dcont->firstLoss = htonl (scont->firstLoss);
state_cache_2.c:24143:		    dcont->firstBootstrapSeq =
state_cache_2.c:24144:		      htonl (scont->firstBootstrapSeq);
state_cache_2.c:24145:		    dcont->startCwnd = htonl (scont->startCwnd);
state_cache_2.c:24146:		    dcont->ssthresh = htonl (scont->ssthresh);
state_cache_2.c:24147:		    dcont->TCPBase = htonl (scont->TCPBase);
state_cache_2.c:24148:		    dcont->tokenCounterBase = scont->tokenCounterBase;
state_cache_2.c:24152:			 __constant_memcpy ((dcont->mac), (scont->mac),
state_cache_2.c:24153:					    (16)) : __memcpy ((dcont->mac),
state_cache_2.c:24154:							      (scont->mac),
state_cache_2.c:24170:		    dproof->numSacks = (
state_cache_2.c:24172:					 typeof (sproof->numSacks) Z =
state_cache_2.c:24173:					 (typeof (sproof->numSacks)) (64);
state_cache_2.c:24176:					   const typeof (sproof->
state_cache_2.c:24178:					   (sproof->numSacks);
state_cache_2.c:24184:		    for (i = 0; i < dproof->numSacks; i++)
state_cache_2.c:24186:			dproof->sacks[i].left =
state_cache_2.c:24187:			  htonl (sproof->sacks[i].left);;
state_cache_2.c:24188:			dproof->sacks[i].right =
state_cache_2.c:24189:			  htonl (sproof->sacks[i].right);;
state_cache_2.c:24190:			dproof->sacks[i].nonceSummary =
state_cache_2.c:24191:			  sproof->sacks[i].nonceSummary;
state_cache_2.c:24215:			    ((!(((skb->sk)->tp_pinfo.af_tcp.
state_cache_2.c:24217:				&& !((skb->sk)->tp_pinfo.af_tcp.
state_cache_2.c:24218:				     trickles_opt & (skb->sk)->tp_pinfo.
state_cache_2.c:24223:			    phdr->seq = scont->seq;
state_cache_2.c:24224:			    phdr->type = scont->continuationType;
state_cache_2.c:24225:			    phdr->first = scont->firstChild;
state_cache_2.c:24226:			    phdr->serverAddr = skb->nh.iph->daddr;
state_cache_2.c:24227:			    phdr->serverPort = skb->h.th->dest;
state_cache_2.c:24228:			    phdr->clientAddr = skb->nh.iph->saddr;
state_cache_2.c:24229:			    phdr->clientPort = skb->h.th->source;
state_cache_2.c:24230:			    computeMAC (skb->sk, phdr, scont, mac);
state_cache_2.c:24231:			    if (__builtin_memcmp (mac, scont->mac, 16))
state_cache_2.c:24239:		    dcont->continuationType = scont->continuationType;
state_cache_2.c:24240:		    dcont->seq = ntohl (scont->seq);;
state_cache_2.c:24241:		    dcont->clientState = scont->clientState;
state_cache_2.c:24242:		    dcont->parent = scont->parent;
state_cache_2.c:24243:		    dcont->rawTimestamp = scont->timestamp;
state_cache_2.c:24244:		    dcont->timestamp = ntohl (scont->timestamp);
state_cache_2.c:24245:		    dcont->rawMrtt = scont->mrtt;
state_cache_2.c:24246:		    dcont->mrtt = ntohl (scont->mrtt);;
state_cache_2.c:24247:		    dcont->clientTimestamp = scont->clientTimestamp;
state_cache_2.c:24248:		    dcont->state = scont->state;
state_cache_2.c:24249:		    dcont->firstChild = scont->firstChild;
state_cache_2.c:24250:		    dcont->firstLoss = ntohl (scont->firstLoss);;
state_cache_2.c:24251:		    dcont->firstBootstrapSeq =
state_cache_2.c:24252:		      ntohl (scont->firstBootstrapSeq);;
state_cache_2.c:24253:		    dcont->startCwnd = ntohl (scont->startCwnd);;
state_cache_2.c:24254:		    dcont->ssthresh = ntohl (scont->ssthresh);;
state_cache_2.c:24255:		    dcont->TCPBase = ntohl (scont->TCPBase);;
state_cache_2.c:24257:			((!(((skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
state_cache_2.c:24258:			    && !((skb->sk)->tp_pinfo.af_tcp.
state_cache_2.c:24259:				 trickles_opt & (skb->sk)->tp_pinfo.af_tcp.
state_cache_2.c:24262:			dcont->saddr = skb->nh.iph->daddr;
state_cache_2.c:24263:			dcont->daddr = skb->nh.iph->saddr;
state_cache_2.c:24264:			dcont->source = skb->h.th->dest;
state_cache_2.c:24265:			dcont->dest = skb->h.th->source;
state_cache_2.c:24267:		    dcont->tokenCounterBase = scont->tokenCounterBase;
state_cache_2.c:24268:		    dcont->num_packets = 0;
state_cache_2.c:24269:		    dcont->numChildrenReceived = 0;
state_cache_2.c:24270:		    dcont->parentMSK = ((void *) 0);;
state_cache_2.c:24292:			    ((!(((skb->sk)->tp_pinfo.af_tcp.
state_cache_2.c:24294:				&& !((skb->sk)->tp_pinfo.af_tcp.
state_cache_2.c:24295:				     trickles_opt & (skb->sk)->tp_pinfo.
state_cache_2.c:24300:			    phdr->seq = scont->seq;
state_cache_2.c:24301:			    phdr->type = scont->continuationType;
state_cache_2.c:24302:			    phdr->first = scont->firstChild;
state_cache_2.c:24303:			    phdr->serverAddr = skb->nh.iph->daddr;
state_cache_2.c:24304:			    phdr->serverPort = skb->h.th->dest;
state_cache_2.c:24305:			    phdr->clientAddr = skb->nh.iph->saddr;
state_cache_2.c:24306:			    phdr->clientPort = skb->h.th->source;
state_cache_2.c:24307:			    computeMAC (skb->sk, phdr, scont, mac);
state_cache_2.c:24308:			    if (__builtin_memcmp (mac, scont->mac, 16))
state_cache_2.c:24316:		    dcont->continuationType = scont->continuationType;
state_cache_2.c:24317:		    dcont->seq = ntohl (scont->seq);;
state_cache_2.c:24318:		    dcont->clientState = scont->clientState;
state_cache_2.c:24319:		    dcont->parent = scont->parent;
state_cache_2.c:24320:		    dcont->rawTimestamp = scont->timestamp;
state_cache_2.c:24321:		    dcont->rawMrtt = scont->mrtt;;
state_cache_2.c:24322:		    dcont->clientTimestamp = scont->clientTimestamp;
state_cache_2.c:24323:		    dcont->state = scont->state;
state_cache_2.c:24324:		    dcont->firstChild = scont->firstChild;
state_cache_2.c:24325:		    dcont->firstLoss = ntohl (scont->firstLoss);;
state_cache_2.c:24326:		    dcont->firstBootstrapSeq =
state_cache_2.c:24327:		      ntohl (scont->firstBootstrapSeq);;
state_cache_2.c:24328:		    dcont->startCwnd = ntohl (scont->startCwnd);;
state_cache_2.c:24329:		    dcont->ssthresh = ntohl (scont->ssthresh);;
state_cache_2.c:24330:		    dcont->TCPBase = ntohl (scont->TCPBase);;
state_cache_2.c:24331:		    dcont->daddr = skb->nh.iph->saddr;
state_cache_2.c:24332:		    dcont->dest = skb->h.th->source;;
state_cache_2.c:24333:		    dcont->tokenCounterBase = scont->tokenCounterBase;
state_cache_2.c:24334:		    dcont->num_packets = 0;;
state_cache_2.c:24350:		    dcont->continuationType = scont->continuationType;
state_cache_2.c:24351:		    dcont->seq = scont->seq;
state_cache_2.c:24352:		    dcont->clientState = scont->clientState;
state_cache_2.c:24353:		    dcont->parent = scont->parent;
state_cache_2.c:24354:		    dcont->rawTimestamp = scont->rawTimestamp;
state_cache_2.c:24355:		    dcont->timestamp = ntohl (scont->rawTimestamp);
state_cache_2.c:24356:		    dcont->rawMrtt = scont->rawMrtt;
state_cache_2.c:24357:		    dcont->mrtt = ntohl (scont->rawMrtt);;
state_cache_2.c:24358:		    dcont->clientTimestamp = scont->clientTimestamp;
state_cache_2.c:24359:		    dcont->state = scont->state;
state_cache_2.c:24360:		    dcont->firstChild = scont->firstChild;
state_cache_2.c:24361:		    dcont->firstLoss = scont->firstLoss;
state_cache_2.c:24362:		    dcont->firstBootstrapSeq = scont->firstBootstrapSeq;
state_cache_2.c:24363:		    dcont->startCwnd = scont->startCwnd;
state_cache_2.c:24364:		    dcont->ssthresh = scont->ssthresh;
state_cache_2.c:24365:		    dcont->TCPBase = scont->TCPBase;
state_cache_2.c:24366:		    dcont->saddr = sk->saddr;
state_cache_2.c:24367:		    dcont->source = sk->sport;
state_cache_2.c:24368:		    dcont->daddr = scont->daddr;
state_cache_2.c:24369:		    dcont->dest = scont->dest;;
state_cache_2.c:24370:		    dcont->tokenCounterBase = scont->tokenCounterBase;
state_cache_2.c:24371:		    dcont->num_packets = 0;;
state_cache_2.c:24387:		    dcont->continuationType = scont->continuationType;
state_cache_2.c:24388:		    dcont->seq = scont->seq;
state_cache_2.c:24389:		    dcont->clientState = scont->clientState;
state_cache_2.c:24390:		    dcont->parent = scont->parent;
state_cache_2.c:24391:		    dcont->rawTimestamp = scont->rawTimestamp;
state_cache_2.c:24392:		    dcont->rawMrtt = scont->rawMrtt;;
state_cache_2.c:24393:		    dcont->clientTimestamp = scont->clientTimestamp;
state_cache_2.c:24394:		    dcont->state = scont->state;
state_cache_2.c:24395:		    dcont->firstChild = scont->firstChild;
state_cache_2.c:24396:		    dcont->firstLoss = scont->firstLoss;
state_cache_2.c:24397:		    dcont->firstBootstrapSeq = scont->firstBootstrapSeq;
state_cache_2.c:24398:		    dcont->startCwnd = scont->startCwnd;
state_cache_2.c:24399:		    dcont->ssthresh = scont->ssthresh;
state_cache_2.c:24400:		    dcont->TCPBase = scont->TCPBase;
state_cache_2.c:24401:		    dcont->daddr = scont->daddr;
state_cache_2.c:24402:		    dcont->dest = scont->dest;;
state_cache_2.c:24403:		    dcont->tokenCounterBase = scont->tokenCounterBase;
state_cache_2.c:24404:		    dcont->num_packets = 0;;
state_cache_2.c:24426:			 __constant_memcpy ((dcont->mac), (scont->mac),
state_cache_2.c:24427:					    (16)) : __memcpy ((dcont->mac),
state_cache_2.c:24428:							      (scont->mac),
state_cache_2.c:24432:		    dcont->continuationType = scont->continuationType;
state_cache_2.c:24433:		    dcont->seq = ntohl (scont->seq);;
state_cache_2.c:24434:		    dcont->clientState = scont->clientState;
state_cache_2.c:24435:		    dcont->parent = scont->parent;
state_cache_2.c:24436:		    dcont->rawTimestamp = scont->timestamp;
state_cache_2.c:24437:		    dcont->timestamp = ntohl (scont->timestamp);
state_cache_2.c:24438:		    dcont->rawMrtt = scont->mrtt;
state_cache_2.c:24439:		    dcont->mrtt = ntohl (scont->mrtt);;
state_cache_2.c:24440:		    dcont->clientTimestamp = scont->clientTimestamp;
state_cache_2.c:24441:		    dcont->state = scont->state;
state_cache_2.c:24442:		    dcont->firstChild = scont->firstChild;
state_cache_2.c:24443:		    dcont->firstLoss = ntohl (scont->firstLoss);;
state_cache_2.c:24444:		    dcont->firstBootstrapSeq =
state_cache_2.c:24445:		      ntohl (scont->firstBootstrapSeq);;
state_cache_2.c:24446:		    dcont->startCwnd = ntohl (scont->startCwnd);;
state_cache_2.c:24447:		    dcont->ssthresh = ntohl (scont->ssthresh);;
state_cache_2.c:24448:		    dcont->TCPBase = ntohl (scont->TCPBase);;
state_cache_2.c:24450:			((!(((skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
state_cache_2.c:24451:			    && !((skb->sk)->tp_pinfo.af_tcp.
state_cache_2.c:24452:				 trickles_opt & (skb->sk)->tp_pinfo.af_tcp.
state_cache_2.c:24455:			dcont->saddr = skb->nh.iph->daddr;
state_cache_2.c:24456:			dcont->daddr = skb->nh.iph->saddr;
state_cache_2.c:24457:			dcont->source = skb->h.th->dest;
state_cache_2.c:24458:			dcont->dest = skb->h.th->source;
state_cache_2.c:24460:		    dcont->tokenCounterBase = scont->tokenCounterBase;
state_cache_2.c:24461:		    dcont->num_packets = 0;
state_cache_2.c:24462:		    dcont->numChildrenReceived = 0;
state_cache_2.c:24463:		    dcont->parentMSK = ((void *) 0);;
state_cache_2.c:24484:		    for (i = 0; i < (((cont) + 1)->num_packets); i++)
state_cache_2.c:24486:			total += (((cont) + 1)->packets)[i].len;
state_cache_2.c:24531:		    rval->prev = rval->next = ((void *) 0);
state_cache_2.c:24532:		    rval->list = ((void *) 0);
state_cache_2.c:24539:			(rval + i)->ucont_len = 0;
state_cache_2.c:24540:			(rval + i)->ucont_data = ((void *) 0);
state_cache_2.c:24541:			(rval + i)->input_len = 0;
state_cache_2.c:24542:			(rval + i)->input = ((void *) 0);
state_cache_2.c:24544:			(rval + i)->mark = 0;
state_cache_2.c:24545:			(rval + i)->simulated = 0;
state_cache_2.c:24547:		    rval->sk = ((void *) 0);
state_cache_2.c:24584:		    rval->prev = rval->next = ((void *) 0);
state_cache_2.c:24585:		    rval->list = ((void *) 0);
state_cache_2.c:24588:		     ((int) ((struct cminisock *) 0)->
state_cache_2.c:24594:								   *) 0)->
state_cache_2.c:24597:				 ((int) ((struct cminisock *) 0)->
state_cache_2.c:24602:			(rval + i)->ucont_len = 0;
state_cache_2.c:24603:			(rval + i)->ucont_data = ((void *) 0);
state_cache_2.c:24605:			(rval + i)->input_len = 0;
state_cache_2.c:24606:			(rval + i)->input = ((void *) 0);
state_cache_2.c:24608:			(rval + i)->mark = 0;
state_cache_2.c:24609:			(rval + i)->simulated = 0;
state_cache_2.c:24610:			(rval + i)->num_packets = 0;
state_cache_2.c:24611:			(rval + i)->actualCwnd = 0;
state_cache_2.c:24625:		    if (cont->list)
state_cache_2.c:24641:			if ((cont + i)->ucont_data)
state_cache_2.c:24642:			  kfree ((cont + i)->ucont_data);
state_cache_2.c:24643:			if ((cont + i)->input)
state_cache_2.c:24644:			  kfree ((cont + i)->input);
state_cache_2.c:24660:		    dproof->numSacks = sproof->numSacks;
state_cache_2.c:24661:		    for (i = 0; i < sproof->numSacks; i++)
state_cache_2.c:24663:			dproof->sacks[i].left =
state_cache_2.c:24664:			  ntohl (sproof->sacks[i].left);;
state_cache_2.c:24665:			dproof->sacks[i].right =
state_cache_2.c:24666:			  ntohl (sproof->sacks[i].right);;
state_cache_2.c:24667:			dproof->sacks[i].nonceSummary =
state_cache_2.c:24668:			  sproof->sacks[i].nonceSummary;
state_cache_2.c:24679:		      length - sizeof (struct WireUC_Continuation);
state_cache_2.c:24690:		    rval->prev = rval->next = ((void *) 0);
state_cache_2.c:24691:		    rval->list = ((void *) 0);
state_cache_2.c:24693:		    rval->seq = ntohl (scont->seq);
state_cache_2.c:24694:		    rval->validStart = ntohl (scont->validStart);
state_cache_2.c:24695:		    rval->validEnd = ntohl (scont->validEnd);
state_cache_2.c:24696:		    rval->fields = scont->fields;
state_cache_2.c:24697:		    rval->dataLen = dataLen;
state_cache_2.c:24698:		    rval->kernel.obsoleteAt = rval->validEnd;
state_cache_2.c:24700:		     __constant_memcpy ((rval->kernel.data), (scont->data),
state_cache_2.c:24701:					(dataLen)) : __memcpy ((rval->kernel.
state_cache_2.c:24703:							       (scont->data),
state_cache_2.c:24715:		    int dataLen = scont->dataLen;
state_cache_2.c:24716:		    dcont->seq = htonl (scont->seq);
state_cache_2.c:24717:		    dcont->validStart = htonl (scont->validStart);
state_cache_2.c:24718:		    dcont->validEnd = htonl (scont->validEnd);
state_cache_2.c:24719:		    dcont->fields = scont->fields;
state_cache_2.c:24721:		     __constant_memcpy ((dcont->data), (scont->kernel.data),
state_cache_2.c:24722:					(dataLen)) : __memcpy ((dcont->data),
state_cache_2.c:24723:							       (scont->kernel.
state_cache_2.c:24747:		    completeResp->fields |= (0x01);
state_cache_2.c:24756:		    int dataLen = scont->dataLen;
state_cache_2.c:24766:		    rval->prev = rval->next = ((void *) 0);
state_cache_2.c:24767:		    rval->list = ((void *) 0);
state_cache_2.c:24770:		     __constant_memcpy ((rval->kernel.data),
state_cache_2.c:24771:					(scont->kernel.data),
state_cache_2.c:24772:					(dataLen)) : __memcpy ((rval->kernel.
state_cache_2.c:24774:							       (scont->kernel.
state_cache_2.c:24817:		    return -1;
state_cache_2.c:24882:		    return -1;
state_cache_2.c:24893:		    wireContinuation->fields = 0;
state_cache_2.c:24900:		    char *rval = wireContinuation->data;
state_cache_2.c:24902:		    if (wireContinuation->fields & (0x01))
state_cache_2.c:24917:		    if (wireContinuation->fields & ~((0x01)))
state_cache_2.c:24943:		    resp->type = type;
state_cache_2.c:24944:		    resp->error = error;
state_cache_2.c:24945:		    resp->len = htons ((short) len);
state_cache_2.c:24963:		    incompleteResp->ack_seq = htonl (ack_seq);
state_cache_2.c:24964:		    incompleteResp->newCont.validStart = htonl (validStart);
state_cache_2.c:24983:		    completeResp->ack_seq = htonl (ack_seq);
state_cache_2.c:24984:		    completeResp->newCont.seq = htonl (seq);
state_cache_2.c:24985:		    completeResp->newCont.validStart = htonl (validStart);
state_cache_2.c:24986:		    completeResp->newCont.validEnd = htonl (validEnd);
state_cache_2.c:24987:		    completeResp->newCont.fields = 0;
state_cache_2.c:25007:		    newContinuationResp->newCont.seq = htonl (seq);
state_cache_2.c:25008:		    newContinuationResp->newCont.validStart =
state_cache_2.c:25010:		    newContinuationResp->newCont.validEnd = htonl (validEnd);
state_cache_2.c:25011:		    newContinuationResp->newCont.fields = 0;
state_cache_2.c:25019:		    printk ("seq=[%d]\n", ucont->seq);
state_cache_2.c:25020:		    printk ("valid=[%d-%d] [%d-%d]\n", ucont->validStart,
state_cache_2.c:25021:			    ucont->validEnd, htonl (ucont->validStart),
state_cache_2.c:25022:			    htonl (ucont->validEnd));
state_cache_2.c:25023:		    printk ("cvalid=[%d-%d] [%d-%d]\n",
state_cache_2.c:25024:			    ucont->clientValidStart, ucont->clientValidEnd,
state_cache_2.c:25025:			    htonl (ucont->clientValidStart),
state_cache_2.c:25026:			    htonl (ucont->clientValidEnd));
state_cache_2.c:25041:		    chunk->byteNum = htonl (byteNum);
state_cache_2.c:25042:		    chunk->type = RCHUNK_DATA;
state_cache_2.c:25043:		    chunk->chunkLen =
state_cache_2.c:25046:		    return (struct DataChunk *) (chunk->data + chunkLen);
state_cache_2.c:25055:		    phchunk->type = RCHUNK_PUSH_HINT;
state_cache_2.c:25056:		    phchunk->chunkLen = htons (sizeof (struct PushHintChunk));
state_cache_2.c:25057:		    phchunk->start = htonl (start);
state_cache_2.c:25058:		    phchunk->end = htonl (end);
state_cache_2.c:25083:		    ctx->packetNum = 0;
state_cache_2.c:25084:		    ctx->packetPos = 0;
state_cache_2.c:25085:		    ctx->outputPos = ctx->outputStart = dest;
state_cache_2.c:25086:		    ctx->packets = packets;
state_cache_2.c:25087:		    ctx->numPackets = numPackets;
state_cache_2.c:25096:		    for (i = 0; i < ctx->numPackets; i++)
state_cache_2.c:25098:			printk ("Packet [%d] = %d\n", i, ctx->packets[i].len);
state_cache_2.c:25108:		       ctx->packetNum, ctx->packetPos, ctx->outputPos,
state_cache_2.c:25109:		       ctx->numPackets, ctx->packets);
state_cache_2.c:25117:		    if (ctx->packetNum >= ctx->numPackets)
state_cache_2.c:25121:		    return ctx->packets[ctx->packetNum].len - ctx->packetPos;
state_cache_2.c:25130:		      return ctx->outputPos;
state_cache_2.c:25134:			if (ctx->packetNum >= ctx->numPackets)
state_cache_2.c:25141:		    if (!(ctx->packetNum <= ctx->numPackets))
state_cache_2.c:25143:			if (!(ctx->packetNum <= ctx->numPackets))
state_cache_2.c:25146:				    "ctx->packetNum <= ctx->numPackets"
state_cache_2.c:25151:			printk ("%d !<= %d\n", ctx->packetNum,
state_cache_2.c:25152:				ctx->numPackets);
state_cache_2.c:25163:			if (!(numBytes <= ctx->packets[ctx->packetNum].len))
state_cache_2.c:25166:				    "numBytes <= ctx->packets[ctx->packetNum].len"
state_cache_2.c:25171:			ctx->outputPos +=
state_cache_2.c:25172:			  ctx->packets[ctx->packetNum].len - ctx->packetPos;
state_cache_2.c:25173:			ctx->packetPos = 0;
state_cache_2.c:25174:			ctx->packetNum++;
state_cache_2.c:25176:		    temp = ctx->outputPos;
state_cache_2.c:25177:		    ctx->packetPos += numBytes;
state_cache_2.c:25178:		    ctx->outputPos += numBytes;
state_cache_2.c:25182:			if (ctx->packetNum >= ctx->numPackets)
state_cache_2.c:25189:		    if (!(ctx->packetPos <= ctx->packets[ctx->packetNum].len))
state_cache_2.c:25192:				"ctx->packetPos <= ctx->packets[ctx->packetNum].len"
state_cache_2.c:25198:		    if (ctx->packetPos == ctx->packets[ctx->packetNum].len)
state_cache_2.c:25200:			ctx->packetPos = 0;
state_cache_2.c:25201:			ctx->packetNum++;
state_cache_2.c:25215:		    char *currpos = ctx->outputPos;
state_cache_2.c:25256:			return -1;
state_cache_2.c:25270:		    while ((char *) (chunk + 1) - start < len)
state_cache_2.c:25273:			  ntohs ((chunk)->chunkLen) -
state_cache_2.c:25278:			      printk ("bad length chunk(%d) -- ", len);
state_cache_2.c:25290:				     ntohs ((chunk)->chunkLen)));
state_cache_2.c:25299:			    return -1;
state_cache_2.c:25302:		    if ((char *) chunk - start > len)
state_cache_2.c:25305:				(char *) chunk - start, len);
state_cache_2.c:25306:			return -chunknum - 1;
state_cache_2.c:25322:		    if (!(gctx->packetNum <= gctx->numPackets))
state_cache_2.c:25325:				"gctx->packetNum <= gctx->numPackets"
state_cache_2.c:25334:		    int outputLen = gctx->outputPos - gctx->outputStart;
state_cache_2.c:25335:		    char *buf = gctx->outputStart;
state_cache_2.c:25344:			(entry->prev == ((void *) 0)
state_cache_2.c:25345:			 && entry->next == ((void *) 0)
state_cache_2.c:25346:			 && entry->list == ((void *) 0)))
state_cache_2.c:25349:				"entry->prev == NULL && entry->next == NULL && entry->list == NULL"
state_cache_2.c:25355:		    freeClientSide_Continuation (entry->cont);
state_cache_2.c:25371:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
state_cache_2.c:25372:		    tp->trickles_opt = 0;
state_cache_2.c:25373:		    tp->mac_changed = 0;
state_cache_2.c:25379:			  ((sizeof (tp->cminisock_api_config))) ?
state_cache_2.c:25380:			  __constant_c_and_count_memset (((&tp->
state_cache_2.c:25386:							   (tp->
state_cache_2.c:25389:			  __constant_c_memset (((&tp->cminisock_api_config)),
state_cache_2.c:25393:						 (tp->
state_cache_2.c:25396:			  ((sizeof (tp->cminisock_api_config))) ?
state_cache_2.c:25397:			  __memset_generic ((((&tp->cminisock_api_config))),
state_cache_2.c:25400:					       (tp->
state_cache_2.c:25402:			  __memset_generic (((&tp->cminisock_api_config)),
state_cache_2.c:25405:					      (tp->cminisock_api_config))))));
state_cache_2.c:25406:		      init_head (&tp->cminisock_api_config.msk_freelist);
state_cache_2.c:25408:		      tp->cminisock_api_config.cfg.ctl = ((void *) 0);
state_cache_2.c:25410:		      tp->cminisock_api_config.event_lock = (rwlock_t)
state_cache_2.c:25415:		    tp->t.malloc_initialized = 0;
state_cache_2.c:25417:		    tp->t.heapbytesize = 0;
state_cache_2.c:25418:		    tp->t.heapbytesallocated = 0;
state_cache_2.c:25422:			tp->t.fragblocks[i] = 0;
state_cache_2.c:25423:			tp->t.fraghead[i].next = tp->t.fraghead[i].prev =
state_cache_2.c:25427:		    tp->t.clientStateCounter = 0;
state_cache_2.c:25428:		    tp->t.state = 1;
state_cache_2.c:25429:		    tp->t.A = 0;
state_cache_2.c:25430:		    tp->t.D = 0;
state_cache_2.c:25431:		    tp->t.RTO = 0;
state_cache_2.c:25432:		    tp->t.timerState = 0;
state_cache_2.c:25433:		    tp->t.rcv_nxt = 0;
state_cache_2.c:25434:		    tp->t.previous_base = 0;
state_cache_2.c:25435:		    skb_queue_head_init (&tp->t.ofo_queue);
state_cache_2.c:25437:		    tp->t.ack_prev = ((void *) 0);
state_cache_2.c:25439:		    tp->t.ack_last = 0;
state_cache_2.c:25440:		    tp->t.oo_count = 0;
state_cache_2.c:25441:		    tp->t.in_flight = 0;
state_cache_2.c:25443:		    tp->t.standardProof.numSacks = 0;
state_cache_2.c:25444:		    tp->t.altProof.numSacks = 0;
state_cache_2.c:25447:		    tp->t.dprev = tp->t.dnext = ((void *) 0);
state_cache_2.c:25448:		    tp->t.dbg_skb = ((void *) 0);
state_cache_2.c:25449:		    init_head (&tp->t.cont_list);
state_cache_2.c:25451:		    init_timer (&tp->t.slowstart_timer);
state_cache_2.c:25455:		    tp->t.request_rcv_nxt = 0;
state_cache_2.c:25456:		    tp->t.request_snd_nxt = 0;
state_cache_2.c:25457:		    init_head (&tp->t.request_ofo_queue);
state_cache_2.c:25458:		    skb_queue_head_init (&tp->t.data_ofo_queue);
state_cache_2.c:25459:		    init_head (&tp->t.sentRequests);
state_cache_2.c:25460:		    init_head (&tp->t.queuedRequests);
state_cache_2.c:25462:		    init_head (&tp->t.dataRequestMap);
state_cache_2.c:25463:		    init_head (&tp->t.missingDataMap);
state_cache_2.c:25465:		    tp->t.byteReqNext = 0;
state_cache_2.c:25466:		    tp->t.byteReqHint = ((void *) 0);
state_cache_2.c:25470:		    tp->t.conversionState = (1);
state_cache_2.c:25471:		    tp->t.snd_una = tp->t.write_seq = 0;
state_cache_2.c:25472:		    tp->t.snd_end = 0;
state_cache_2.c:25473:		    skb_queue_head_init (&tp->t.requestBytes);
state_cache_2.c:25474:		    tp->t.newIncompleteRequest = ((void *) 0);
state_cache_2.c:25475:		    tp->t.prevConvCont = ((void *) 0);
state_cache_2.c:25477:		    init_head (&tp->t.ucontList);
state_cache_2.c:25478:		    init_head (&tp->t.depNodeList);
state_cache_2.c:25484:		    tp->t.nonceCTX = ((void *) 0);
state_cache_2.c:25485:		    skb_queue_head_init (&tp->t.prequeueOverflow);
state_cache_2.c:25486:		    skb_queue_head_init (&tp->t.sendAckOverflow);
state_cache_2.c:25487:		    skb_queue_head_init (&tp->t.recycleList);
state_cache_2.c:25489:		    tp->t.responseMSK = ((void *) 0);
state_cache_2.c:25490:		    init_head (&tp->t.responseList);
state_cache_2.c:25491:		    tp->t.responseCount = 0;
state_cache_2.c:25493:		    tp->t.events = ((void *) 0);
state_cache_2.c:25494:		    tp->drop_rate = 0;
state_cache_2.c:25495:		    tp->instrumentation = 0;
state_cache_2.c:25711:		    msk->num_packets = 0;
state_cache_2.c:25712:		    msk->ucont_len = 0;
state_cache_2.c:25713:		    msk->ucont_data = ((void *) 0);
state_cache_2.c:25714:		    msk->input_len = 0;
state_cache_2.c:25715:		    msk->input = ((void *) 0);
state_cache_2.c:25716:		    msk->packets = ((void *) 0);
state_cache_2.c:25718:		    msk->refCnt = 1;
state_cache_2.c:25720:		    msk->cacheRecycleIndex = -1;
state_cache_2.c:25721:		    msk->serverSK = ((void *) 0);
state_cache_2.c:25722:		    msk->pmsk = ((void *) 0);
state_cache_2.c:25723:		    msk->isStatic = 0;
state_cache_2.c:25728:		    pmsk->num_packets = 0;
state_cache_2.c:25729:		    pmsk->ucont_len = 0;
state_cache_2.c:25730:		    pmsk->ucont_data = ((void *) 0);
state_cache_2.c:25731:		    pmsk->input_len = 0;
state_cache_2.c:25732:		    pmsk->input = ((void *) 0);
state_cache_2.c:25733:		    pmsk->packets = ((void *) 0);
state_cache_2.c:25734:		    pmsk->refCnt = 1;
state_cache_2.c:25751:		    if (msk->num_packets > 0)
state_cache_2.c:25753:			printk ("msk packets is %d\n", msk->num_packets);
state_cache_2.c:25755:		    if (!(msk->num_packets == 0))
state_cache_2.c:25757:			printk ("KERNEL: assertion (" "msk->num_packets == 0"
state_cache_2.c:25772:			(((msk->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
state_cache_2.c:25773:			 && !((msk->sk)->tp_pinfo.af_tcp.
state_cache_2.c:25774:			      trickles_opt & (msk->sk)->tp_pinfo.af_tcp.
state_cache_2.c:25777:			msk->packets =
state_cache_2.c:25778:			  tmalloc (msk->sk,
state_cache_2.c:25784:			if (msk->packets == ((void *) 0))
state_cache_2.c:25799:			    msk->packets = packets[0];
state_cache_2.c:25803:			    msk->packets = ((void *) 0);
state_cache_2.c:25812:		    msk->num_packets = numPackets;
state_cache_2.c:25818:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
state_cache_2.c:25820:		      &tp->cminisock_api_config.msk_freelist;
state_cache_2.c:25821:		    struct cminisock *curr = (struct cminisock *) head->next;
state_cache_2.c:25823:			   && curr->ctl == ALLOC_PROCESSING)
state_cache_2.c:25826:			curr = curr->next;
state_cache_2.c:25834:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
state_cache_2.c:25836:		      (struct list_link *) &tp->cminisock_api_config.
state_cache_2.c:25839:		      (struct pminisock *) tp->cminisock_api_config.
state_cache_2.c:25843:			(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
state_cache_2.c:25844:			 && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
state_cache_2.c:25848:			       pcurr->ctl == ALLOC_PROCESSING)
state_cache_2.c:25851:			    pcurr = pcurr->next;
state_cache_2.c:25869:		    rval->ctl = ALLOC_PENDING;
state_cache_2.c:25880:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
state_cache_2.c:25882:		      &tp->cminisock_api_config.msk_freelist;
state_cache_2.c:25884:		      (struct cminisock *) tp->cminisock_api_config.
state_cache_2.c:25888:			(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
state_cache_2.c:25889:			 && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
state_cache_2.c:25893:			       curr->ctl == ALLOC_PROCESSING)
state_cache_2.c:25896:			    curr = curr->next;
state_cache_2.c:25908:			rval->ctl = ALLOC_PENDING;
state_cache_2.c:25912:			if (tp->t.responseCount == 0)
state_cache_2.c:25914:			    rval = tp->t.responseMSK;
state_cache_2.c:25915:			    rval->list = ((void *) 0);
state_cache_2.c:25916:			    rval->next = rval->prev = ((void *) 0);
state_cache_2.c:25928:			    rval->next = rval->prev = ((void *) 0);
state_cache_2.c:25929:			    rval->list = ((void *) 0);
state_cache_2.c:25930:			    insert_tail (&tp->t.responseList,
state_cache_2.c:25933:			tp->t.responseCount++;
state_cache_2.c:25935:			rval->sk = sk;
state_cache_2.c:25936:			rval->ctl = ALLOC_PENDING;
state_cache_2.c:25960:		    msk->refCnt++;
state_cache_2.c:25971:			struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
state_cache_2.c:25974:				tp->cminisock_api_config.msk_freelist.len);
state_cache_2.c:25980:		    rval->refCnt = 1;
state_cache_2.c:25981:		    rval->isStatic = 0;
state_cache_2.c:25993:		    rval->num_packets = 0;
state_cache_2.c:25994:		    rval->packets = ((void *) 0);
state_cache_2.c:25995:		    rval->pmsk = ((void *) 0);
state_cache_2.c:25996:		    if (rval->ucont_len > 0)
state_cache_2.c:25998:			rval->ucont_data = tmalloc (sk, rval->ucont_len);
state_cache_2.c:25999:			if (rval->ucont_data == ((void *) 0))
state_cache_2.c:26003:			       rval->ucont_len);
state_cache_2.c:26011:			rval->ucont_data = ((void *) 0);
state_cache_2.c:26012:		    } if (rval->input_len > 0)
state_cache_2.c:26014:			rval->input = tmalloc (sk, rval->input_len);
state_cache_2.c:26015:			if (rval->input == ((void *) 0))
state_cache_2.c:26019:			       "msk", rval->input_len);
state_cache_2.c:26020:			    tfree (sk, rval->ucont_data);
state_cache_2.c:26028:			rval->input = ((void *) 0);
state_cache_2.c:26029:		    } if (rval->ucont_data)
state_cache_2.c:26030:		      (__builtin_constant_p (rval->ucont_len) ?
state_cache_2.c:26031:		       __constant_memcpy ((rval->ucont_data),
state_cache_2.c:26032:					  (pmsk->ucont_data),
state_cache_2.c:26033:					  (rval->
state_cache_2.c:26034:					   ucont_len)) : __memcpy ((rval->
state_cache_2.c:26036:								   (pmsk->
state_cache_2.c:26038:								   (rval->
state_cache_2.c:26040:		    if (rval->input)
state_cache_2.c:26041:		      (__builtin_constant_p (rval->input_len) ?
state_cache_2.c:26042:		       __constant_memcpy ((rval->input), (pmsk->input),
state_cache_2.c:26043:					  (rval->
state_cache_2.c:26044:					   input_len)) : __memcpy ((rval->
state_cache_2.c:26046:								   (pmsk->
state_cache_2.c:26048:								   (rval->
state_cache_2.c:26056:			(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
state_cache_2.c:26057:			 && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
state_cache_2.c:26060:			if (msk->ctl == ALLOC_FREE
state_cache_2.c:26061:			    || msk->ctl == ALLOC_PROCESSING)
state_cache_2.c:26076:			if (msk->ctl == ALLOC_READY
state_cache_2.c:26077:			    && msk->prev != ((void *) 0))
state_cache_2.c:26081:			msk->ctl = ALLOC_PROCESSING;
state_cache_2.c:26087:		    for (i = 0; i < msk->num_packets; i++)
state_cache_2.c:26089:			if (msk->packets[i].ucontData != ((void *) 0))
state_cache_2.c:26091:			    kfree (msk->packets[i].ucontData);
state_cache_2.c:26095:			    (((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
state_cache_2.c:26096:			       && !((sk)->tp_pinfo.af_tcp.
state_cache_2.c:26097:				      trickles_opt & (sk)->tp_pinfo.af_tcp.
state_cache_2.c:26098:				      trickles_opt & 0x8)) && msk->packets)
state_cache_2.c:26100:			tfree (sk, msk->packets);
state_cache_2.c:26101:			msk->packets = ((void *) 0);
state_cache_2.c:26103:		    msk->num_packets = 0;
state_cache_2.c:26104:		    if (msk->ucont_data != ((void *) 0))
state_cache_2.c:26106:			tfree (sk, msk->ucont_data);
state_cache_2.c:26107:			msk->ucont_data = ((void *) 0);
state_cache_2.c:26109:		    msk->ucont_len = 0;
state_cache_2.c:26110:		    if (msk->input != ((void *) 0))
state_cache_2.c:26112:			tfree (sk, msk->input);
state_cache_2.c:26113:			msk->input = ((void *) 0);
state_cache_2.c:26115:		    msk->input_len = 0;
state_cache_2.c:26119:		    msk->refCnt--;
state_cache_2.c:26120:		    if (!(msk->refCnt <= 3))
state_cache_2.c:26122:			printk ("KERNEL: assertion (" "msk->refCnt <= 3"
state_cache_2.c:26127:		    if (msk->refCnt == 0)
state_cache_2.c:26129:			struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
state_cache_2.c:26131:			  &tp->cminisock_api_config.msk_freelist;
state_cache_2.c:26133:			if (!msk->isStatic)
state_cache_2.c:26136:				(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
state_cache_2.c:26137:				 && !((sk)->tp_pinfo.af_tcp.
state_cache_2.c:26138:				      trickles_opt & (sk)->tp_pinfo.af_tcp.
state_cache_2.c:26143:				msk->ctl = ALLOC_FREE;
state_cache_2.c:26147:				if (msk != tp->t.responseMSK)
state_cache_2.c:26152:				tp->t.responseCount--;
state_cache_2.c:26158:		    if (msk->pmsk != ((void *) 0))
state_cache_2.c:26160:			struct pminisock *pmsk = msk->pmsk;
state_cache_2.c:26169:			(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
state_cache_2.c:26170:			 && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
state_cache_2.c:26173:			if (msk->ctl != ALLOC_PROCESSING
state_cache_2.c:26174:			    && msk->ctl != ALLOC_HALFFREE)
state_cache_2.c:26177:			      ("(free_trickles_msk_finish %s) without corresponding free_trickles_msk: msk->ctl = %d\n",
state_cache_2.c:26178:			       "msk", msk->ctl);
state_cache_2.c:26196:		    msk->num_packets = 0;
state_cache_2.c:26197:		    msk->packets = ((void *) 0);
state_cache_2.c:26198:		    msk->ucont_len = 0;
state_cache_2.c:26199:		    msk->ucont_data = ((void *) 0);
state_cache_2.c:26200:		    msk->input_len = 0;
state_cache_2.c:26201:		    msk->input = ((void *) 0);
state_cache_2.c:26206:		    msk->refCnt++;
state_cache_2.c:26217:			struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
state_cache_2.c:26224:		    rval->refCnt = 1;
state_cache_2.c:26236:		    rval->num_packets = 0;
state_cache_2.c:26237:		    rval->packets = ((void *) 0);
state_cache_2.c:26238:		    if (rval->ucont_len > 0)
state_cache_2.c:26240:			rval->ucont_data = tmalloc (sk, rval->ucont_len);
state_cache_2.c:26241:			if (rval->ucont_data == ((void *) 0))
state_cache_2.c:26245:			       rval->ucont_len);
state_cache_2.c:26253:			rval->ucont_data = ((void *) 0);
state_cache_2.c:26254:		    } if (rval->input_len > 0)
state_cache_2.c:26256:			rval->input = tmalloc (sk, rval->input_len);
state_cache_2.c:26257:			if (rval->input == ((void *) 0))
state_cache_2.c:26261:			       "pmsk", rval->input_len);
state_cache_2.c:26262:			    tfree (sk, rval->ucont_data);
state_cache_2.c:26270:			rval->input = ((void *) 0);
state_cache_2.c:26271:		    } if (rval->ucont_data)
state_cache_2.c:26272:		      (__builtin_constant_p (rval->ucont_len) ?
state_cache_2.c:26273:		       __constant_memcpy ((rval->ucont_data),
state_cache_2.c:26274:					  (pmsk->ucont_data),
state_cache_2.c:26275:					  (rval->
state_cache_2.c:26276:					   ucont_len)) : __memcpy ((rval->
state_cache_2.c:26278:								   (pmsk->
state_cache_2.c:26280:								   (rval->
state_cache_2.c:26282:		    if (rval->input)
state_cache_2.c:26283:		      (__builtin_constant_p (rval->input_len) ?
state_cache_2.c:26284:		       __constant_memcpy ((rval->input), (pmsk->input),
state_cache_2.c:26285:					  (rval->
state_cache_2.c:26286:					   input_len)) : __memcpy ((rval->
state_cache_2.c:26288:								   (pmsk->
state_cache_2.c:26290:								   (rval->
state_cache_2.c:26298:			(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
state_cache_2.c:26299:			 && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
state_cache_2.c:26302:			if (msk->ctl == ALLOC_FREE
state_cache_2.c:26303:			    || msk->ctl == ALLOC_PROCESSING)
state_cache_2.c:26318:			if (msk->ctl == ALLOC_READY
state_cache_2.c:26319:			    && msk->prev != ((void *) 0))
state_cache_2.c:26323:			msk->ctl = ALLOC_PROCESSING;
state_cache_2.c:26329:		    for (i = 0; i < msk->num_packets; i++)
state_cache_2.c:26331:			if (msk->packets[i].ucontData != ((void *) 0))
state_cache_2.c:26333:			    kfree (msk->packets[i].ucontData);
state_cache_2.c:26337:			    (((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
state_cache_2.c:26338:			       && !((sk)->tp_pinfo.af_tcp.
state_cache_2.c:26339:				      trickles_opt & (sk)->tp_pinfo.af_tcp.
state_cache_2.c:26340:				      trickles_opt & 0x8)) && msk->packets)
state_cache_2.c:26342:			tfree (sk, msk->packets);
state_cache_2.c:26343:			msk->packets = ((void *) 0);
state_cache_2.c:26345:		    msk->num_packets = 0;
state_cache_2.c:26346:		    if (msk->ucont_data != ((void *) 0))
state_cache_2.c:26348:			tfree (sk, msk->ucont_data);
state_cache_2.c:26349:			msk->ucont_data = ((void *) 0);
state_cache_2.c:26351:		    msk->ucont_len = 0;
state_cache_2.c:26352:		    if (msk->input != ((void *) 0))
state_cache_2.c:26354:			tfree (sk, msk->input);
state_cache_2.c:26355:			msk->input = ((void *) 0);
state_cache_2.c:26357:		    msk->input_len = 0;
state_cache_2.c:26361:		    msk->refCnt--;
state_cache_2.c:26362:		    if (!(msk->refCnt <= 3))
state_cache_2.c:26364:			printk ("KERNEL: assertion (" "msk->refCnt <= 3"
state_cache_2.c:26369:		    if (msk->refCnt == 0)
state_cache_2.c:26371:			struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
state_cache_2.c:26373:			  &tp->cminisock_api_config.pmsk_freelist;
state_cache_2.c:26377:			     (struct pminisock *) tp->cminisock_api_config.
state_cache_2.c:26378:			     cfg.ctl->pminisock_base
state_cache_2.c:26380:			     (struct pminisock *) tp->cminisock_api_config.
state_cache_2.c:26381:			     cfg.ctl->pminisock_limit))
state_cache_2.c:26384:				(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
state_cache_2.c:26385:				 && !((sk)->tp_pinfo.af_tcp.
state_cache_2.c:26386:				      trickles_opt & (sk)->tp_pinfo.af_tcp.
state_cache_2.c:26392:				msk->ctl = ALLOC_FREE;
state_cache_2.c:26408:			(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
state_cache_2.c:26409:			 && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
state_cache_2.c:26412:			if (msk->ctl != ALLOC_PROCESSING
state_cache_2.c:26413:			    && msk->ctl != ALLOC_HALFFREE)
state_cache_2.c:26416:			      ("(free_trickles_msk_finish %s) without corresponding free_trickles_msk: msk->ctl = %d\n",
state_cache_2.c:26417:			       "pmsk", msk->ctl);
state_cache_2.c:26435:		    msk->num_packets = 0;
state_cache_2.c:26436:		    msk->packets = ((void *) 0);
state_cache_2.c:26437:		    msk->ucont_len = 0;
state_cache_2.c:26438:		    msk->ucont_data = ((void *) 0);
state_cache_2.c:26439:		    msk->input_len = 0;
state_cache_2.c:26440:		    msk->input = ((void *) 0);
state_cache_2.c:26455:		    skb->next = ((void *) 0);
state_cache_2.c:26456:		    skb->prev = ((void *) 0);
state_cache_2.c:26457:		    skb->list = ((void *) 0);
state_cache_2.c:26458:		    skb->sk = ((void *) 0);
state_cache_2.c:26459:		    skb->stamp.tv_sec = 0;
state_cache_2.c:26460:		    skb->dev = ((void *) 0);
state_cache_2.c:26461:		    skb->real_dev = ((void *) 0);
state_cache_2.c:26462:		    skb->dst = ((void *) 0);
state_cache_2.c:26464:		     ? (__builtin_constant_p ((sizeof (skb->cb))) ?
state_cache_2.c:26465:			__constant_c_and_count_memset (((skb->cb)),
state_cache_2.c:26469:						       ((sizeof (skb->cb)))) :
state_cache_2.c:26470:			__constant_c_memset (((skb->cb)),
state_cache_2.c:26473:					     ((sizeof (skb->cb)))))
state_cache_2.c:26474:		     : (__builtin_constant_p ((sizeof (skb->cb))) ?
state_cache_2.c:26475:			__memset_generic ((((skb->cb))), (((0))),
state_cache_2.c:26476:					  (((sizeof (skb->cb))))) :
state_cache_2.c:26477:			__memset_generic (((skb->cb)), ((0)),
state_cache_2.c:26478:					  ((sizeof (skb->cb))))));
state_cache_2.c:26479:		    skb->pkt_type = 0;
state_cache_2.c:26480:		    skb->ip_summed = 0;
state_cache_2.c:26481:		    skb->priority = 0;
state_cache_2.c:26482:		    skb->security = 0;
state_cache_2.c:26483:		    skb->destructor = ((void *) 0);
state_cache_2.c:26486:		    skb->nfmark = skb->nfcache = 0;
state_cache_2.c:26487:		    skb->nfct = ((void *) 0);
state_cache_2.c:26493:		    skb->tc_index = 0;
state_cache_2.c:26501:		    struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_2.c:26503:		      ((struct skb_shared_info *) ((skb)->end))->nr_frags !=
state_cache_2.c:26504:		      0, r1 = tp->t.recycleList.qlen >= (1000), r2 =
state_cache_2.c:26505:		      skb->truesize - sizeof (struct sk_buff) <
state_cache_2.c:26515:				 r0, r1, r2, skb->truesize,
state_cache_2.c:26526:		    skb->tail = skb->data = skb->head;
state_cache_2.c:26527:		    skb->len = 0;
state_cache_2.c:26528:		    skb->cloned = 0;
state_cache_2.c:26529:		    skb->data_len = 0;
state_cache_2.c:26531:		    (((&skb->users)->counter) = (1));
state_cache_2.c:26533:		       (((struct skb_shared_info *) ((skb)->end))->dataref))->
state_cache_2.c:26535:		    ((struct skb_shared_info *) ((skb)->end))->nr_frags = 0;
state_cache_2.c:26536:		    ((struct skb_shared_info *) ((skb)->end))->frag_list =
state_cache_2.c:26539:		    __skb_queue_tail (&tp->t.recycleList, skb);
state_cache_2.c:26549:		    struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_2.c:26552:		      __skb_dequeue_tail (&tp->t.recycleList);
state_cache_2.c:26590:			  a = a - b;
state_cache_2.c:26591:			  a = a - c;
state_cache_2.c:26593:			  b = b - c;
state_cache_2.c:26594:			  b = b - a;
state_cache_2.c:26596:			  c = c - a;
state_cache_2.c:26597:			  c = c - b;
state_cache_2.c:26599:			  a = a - b;
state_cache_2.c:26600:			  a = a - c;
state_cache_2.c:26602:			  b = b - c;
state_cache_2.c:26603:			  b = b - a;
state_cache_2.c:26605:			  c = c - a;
state_cache_2.c:26606:			  c = c - b;
state_cache_2.c:26608:			  a = a - b;
state_cache_2.c:26609:			  a = a - c;
state_cache_2.c:26611:			  b = b - c;
state_cache_2.c:26612:			  b = b - a;
state_cache_2.c:26614:			  c = c - a;
state_cache_2.c:26615:			  c = c - b;
state_cache_2.c:26619:			len = len - 12;
state_cache_2.c:26652:		      a = a - b;
state_cache_2.c:26653:		      a = a - c;
state_cache_2.c:26655:		      b = b - c;
state_cache_2.c:26656:		      b = b - a;
state_cache_2.c:26658:		      c = c - a;
state_cache_2.c:26659:		      c = c - b;
state_cache_2.c:26661:		      a = a - b;
state_cache_2.c:26662:		      a = a - c;
state_cache_2.c:26664:		      b = b - c;
state_cache_2.c:26665:		      b = b - a;
state_cache_2.c:26667:		      c = c - a;
state_cache_2.c:26668:		      c = c - b;
state_cache_2.c:26670:		      a = a - b;
state_cache_2.c:26671:		      a = a - c;
state_cache_2.c:26673:		      b = b - c;
state_cache_2.c:26674:		      b = b - a;
state_cache_2.c:26676:		      c = c - a;
state_cache_2.c:26677:		      c = c - b;
state_cache_2.c:26689:		    int runStart = -1;
state_cache_2.c:26705:				printk ("[%d-%d]: ", runStart, i - 1);
state_cache_2.c:26724:		    for (elem = (typeof (elem)) (list)->next;
state_cache_2.c:26726:			 elem = (typeof (elem)) elem->next)
state_cache_2.c:26730:			    if (!(elem->list == list))
state_cache_2.c:26733:					"elem->list == list", "cache_util.h",
state_cache_2.c:26743:			if (!(count == list->len))
state_cache_2.c:26746:				    "count == list->len", "cache_util.h",
state_cache_2.c:26780:		    key.seq = cmsk->pmsk->seq;
state_cache_2.c:26787:		    return hash ((u1 *) & key->seq, sizeof (key->seq), 0);
state_cache_2.c:26798:		    return k0->seq == k1->seq;
state_cache_2.c:26811:		    if (cmsk->pmsk == ((void *) 0))
state_cache_2.c:26827:			pmsk_release (sk, cmsk->pmsk);
state_cache_2.c:26830:		    cmsk->pmsk = ((void *) 0);
state_cache_2.c:26864:		      (struct ParsedPMinisock_cell *) cache->buckets
state_cache_2.c:26866:		      (struct ParsedPMinisock_cell *) (cache->buckets +
state_cache_2.c:26882:		    cache->count = 0;
state_cache_2.c:26883:		    cache->numBuckets = (128);
state_cache_2.c:26884:		    cache->maxCount = (128);
state_cache_2.c:26885:		    cache->hitCount = 0;
state_cache_2.c:26886:		    cache->total = 0;
state_cache_2.c:26887:		    cache->cellMem = 0;
state_cache_2.c:26888:		    cache->maxCellMem = 0;
state_cache_2.c:26889:		    cache->linkCount = 0;
state_cache_2.c:26890:		    cache->lookupCount = 0;
state_cache_2.c:26892:		    for (i = 0; i < cache->numBuckets; i++)
state_cache_2.c:26895:			  &cache->buckets[i];
state_cache_2.c:26896:			*(int *) &(bucket)->fastCell.elem = 0;
state_cache_2.c:26903:		    for (i = 0; i < cache->numBuckets; i++)
state_cache_2.c:26906:			  &cache->buckets[i];
state_cache_2.c:26907:			if ((*(int *) &(bucket)->fastCell.elem != 0))
state_cache_2.c:26909:			    pminisock_evict (cache->evictContext,
state_cache_2.c:26910:					     &bucket->fastCell.elem);
state_cache_2.c:26911:			    ParsedPMinisock_deleteCell (&bucket->fastCell);
state_cache_2.c:26924:		    (cache->hitCount >= 0 && cache->total >= 0
state_cache_2.c:26925:		     && cache->hitCount <= cache->total) || (((
state_cache_2.c:26939:		    for (i = 0; i < cache->numBuckets; i++)
state_cache_2.c:26942:			  &cache->buckets[i];
state_cache_2.c:26943:			if ((*(int *) &(bucket)->fastCell.elem != 0))
state_cache_2.c:26946:			      &bucket->fastCell;
state_cache_2.c:26947:			    ((pminisock_hash (&cell->key) %
state_cache_2.c:26967:			if (!(lookupCount == cache->count))
state_cache_2.c:26970:				    "lookupCount == cache->count",
state_cache_2.c:26979:			if (!(cache->count <= cache->maxCount))
state_cache_2.c:26982:				    "cache->count <= cache->maxCount",
state_cache_2.c:26995:		    cache->hitCount = 0;
state_cache_2.c:26996:		    cache->total = 0;
state_cache_2.c:27005:		    cache->lookupCount++;
state_cache_2.c:27006:		    if ((*(int *) &(bucket)->fastCell.elem != 0))
state_cache_2.c:27008:			struct ParsedPMinisock_cell *cell = &bucket->fastCell;
state_cache_2.c:27010:			    (key, ((void *) 0), &cell->key, &cell->elem))
state_cache_2.c:27022:		      &cache->buckets[pminisock_hash (key) %
state_cache_2.c:27023:				      cache->numBuckets];
state_cache_2.c:27025:		    if (!(*(int *) &(bucket)->fastCell.elem != 0))
state_cache_2.c:27027:			cell = &bucket->fastCell;
state_cache_2.c:27031:			cell = &bucket->fastCell;
state_cache_2.c:27032:			pminisock_evict (cache->evictContext, &cell->elem);
state_cache_2.c:27035:		    cache->count++;
state_cache_2.c:27036:		    cell->key = *key;
state_cache_2.c:27047:		    cell->elem = *elem;;
state_cache_2.c:27059:		      &cache->buckets[pminisock_hash (key) %
state_cache_2.c:27060:				      cache->numBuckets];
state_cache_2.c:27070:			cache->hitCount++;
state_cache_2.c:27072:		    cache->total++;
state_cache_2.c:27083:			*result = cell->elem;
state_cache_2.c:27111:		      ((struct ParsedPMinisock_bucket *) (((char *) cell) -
state_cache_2.c:27115:							      *) 0)->
state_cache_2.c:27117:		    *(int *) &(bucket)->fastCell.elem = 0;
state_cache_2.c:27139:			struct pminisock *pmsk = cell->elem.pmsk;
state_cache_2.c:27142:			if (!(pmsk->daddr == iph->saddr &&
state_cache_2.c:27143:			      pmsk->dest == th->source))
state_cache_2.c:27175:		    key.seq = pmsk->seq;
state_cache_2.c:27182:			cell->elem.pmsk = pmsk;
state_cache_2.c:27222:		    return seqnoToKey (msk->hdr.seq);
state_cache_2.c:27264:		    return map->key;
state_cache_2.c:27316:		    return cell >= (struct Continuation_cell *) cache->buckets
state_cache_2.c:27318:		      (struct Continuation_cell *) (cache->buckets + (128));
state_cache_2.c:27332:		    cache->count = 0;
state_cache_2.c:27333:		    cache->numBuckets = (128);
state_cache_2.c:27334:		    cache->maxCount = (128);
state_cache_2.c:27335:		    cache->hitCount = 0;
state_cache_2.c:27336:		    cache->total = 0;
state_cache_2.c:27337:		    cache->cellMem = 0;
state_cache_2.c:27338:		    cache->maxCellMem = 0;
state_cache_2.c:27339:		    cache->linkCount = 0;
state_cache_2.c:27340:		    cache->lookupCount = 0;
state_cache_2.c:27342:		    for (i = 0; i < cache->numBuckets; i++)
state_cache_2.c:27345:			  &cache->buckets[i];
state_cache_2.c:27346:			*(int *) &(bucket)->fastCell.elem = 0;
state_cache_2.c:27353:		    for (i = 0; i < cache->numBuckets; i++)
state_cache_2.c:27356:			  &cache->buckets[i];
state_cache_2.c:27357:			if ((*(int *) &(bucket)->fastCell.elem != 0))
state_cache_2.c:27359:			    CachedWireContinuation_evict (cache->evictContext,
state_cache_2.c:27360:							  &bucket->fastCell.
state_cache_2.c:27362:			    Continuation_deleteCell (&bucket->fastCell);
state_cache_2.c:27375:		    (cache->hitCount >= 0 && cache->total >= 0
state_cache_2.c:27376:		     && cache->hitCount <= cache->total) || (((
state_cache_2.c:27390:		    for (i = 0; i < cache->numBuckets; i++)
state_cache_2.c:27393:			  &cache->buckets[i];
state_cache_2.c:27394:			if ((*(int *) &(bucket)->fastCell.elem != 0))
state_cache_2.c:27397:			      &bucket->fastCell;
state_cache_2.c:27398:			    ((CachedWireContinuation_hash (&cell->key) %
state_cache_2.c:27404:									    cell->
state_cache_2.c:27407:									    (&cell->
state_cache_2.c:27410:									    (&cell->
state_cache_2.c:27430:			if (!(lookupCount == cache->count))
state_cache_2.c:27433:				    "lookupCount == cache->count",
state_cache_2.c:27442:			if (!(cache->count <= cache->maxCount))
state_cache_2.c:27445:				    "cache->count <= cache->maxCount",
state_cache_2.c:27458:		    cache->hitCount = 0;
state_cache_2.c:27459:		    cache->total = 0;
state_cache_2.c:27468:		    cache->lookupCount++;
state_cache_2.c:27469:		    if ((*(int *) &(bucket)->fastCell.elem != 0))
state_cache_2.c:27471:			struct Continuation_cell *cell = &bucket->fastCell;
state_cache_2.c:27473:			    (key, ((void *) 0), &cell->key, &cell->elem))
state_cache_2.c:27486:		      &cache->buckets[CachedWireContinuation_hash (key) %
state_cache_2.c:27487:				      cache->numBuckets];
state_cache_2.c:27489:		    if (!(*(int *) &(bucket)->fastCell.elem != 0))
state_cache_2.c:27491:			cell = &bucket->fastCell;
state_cache_2.c:27495:			cell = &bucket->fastCell;
state_cache_2.c:27496:			CachedWireContinuation_evict (cache->evictContext,
state_cache_2.c:27497:						      &cell->elem);
state_cache_2.c:27500:		    cache->count++;
state_cache_2.c:27501:		    cell->key = *key;
state_cache_2.c:27514:		    cell->elem = *elem;;
state_cache_2.c:27524:		      &cache->buckets[CachedWireContinuation_hash (key) %
state_cache_2.c:27525:				      cache->numBuckets];
state_cache_2.c:27535:			cache->hitCount++;
state_cache_2.c:27537:		    cache->total++;
state_cache_2.c:27549:			*result = cell->elem;
state_cache_2.c:27575:		      ((struct Continuation_bucket *) (((char *) cell) -
state_cache_2.c:27579:							   *) 0)->fastCell)));
state_cache_2.c:27580:		    *(int *) &(bucket)->fastCell.elem = 0;
state_cache_2.c:27611:		    return cell >= (struct NonceKey_cell *) cache->buckets
state_cache_2.c:27613:		      (struct NonceKey_cell *) (cache->buckets + (32));
state_cache_2.c:27623:		    cache->count = 0;
state_cache_2.c:27624:		    cache->numBuckets = (32);
state_cache_2.c:27625:		    cache->maxCount = (100);
state_cache_2.c:27626:		    cache->hitCount = 0;
state_cache_2.c:27627:		    cache->total = 0;
state_cache_2.c:27628:		    cache->cellMem = 0;
state_cache_2.c:27629:		    cache->maxCellMem = 0;
state_cache_2.c:27630:		    cache->linkCount = 0;
state_cache_2.c:27631:		    cache->lookupCount = 0;
state_cache_2.c:27633:		    for (i = 0; i < cache->numBuckets; i++)
state_cache_2.c:27635:			struct NonceKey_bucket *bucket = &cache->buckets[i];
state_cache_2.c:27636:			*(int *) &(bucket)->fastCell.elem = 0;
state_cache_2.c:27667:			    for (i = 0; i < cache->numBuckets; i++)
state_cache_2.c:27670:				  &cache->buckets[i];
state_cache_2.c:27671:				if ((*(int *) &(bucket)->fastCell.elem != 0))
state_cache_2.c:27673:				    nonce_evict (cache->evictContext,
state_cache_2.c:27674:						 &bucket->fastCell.elem);
state_cache_2.c:27675:				    NonceKey_deleteCell (&bucket->fastCell);
state_cache_2.c:27711:				    (cache->hitCount >= 0 && cache->total >= 0
state_cache_2.c:27712:				     && cache->hitCount <= cache->total)
state_cache_2.c:27724:				    for (i = 0; i < cache->numBuckets; i++)
state_cache_2.c:27727:					  &cache->buckets[i];
state_cache_2.c:27728:					if ((*(int *) &(bucket)->fastCell.
state_cache_2.c:27732:					      &bucket->fastCell;
state_cache_2.c:27733:					    ((nonce_hash (&cell->key) %
state_cache_2.c:27752:					if (!(lookupCount == cache->count))
state_cache_2.c:27756:					       "lookupCount == cache->count",
state_cache_2.c:27766:					    (cache->count <= cache->maxCount))
state_cache_2.c:27770:					       "cache->count <= cache->maxCount",
state_cache_2.c:27783:				    cache->hitCount = 0;
state_cache_2.c:27784:				    cache->total = 0;
state_cache_2.c:27793:				    cache->lookupCount++;
state_cache_2.c:27794:				    if ((*(int *) &(bucket)->fastCell.elem !=
state_cache_2.c:27798:					  &bucket->fastCell;
state_cache_2.c:27800:					    (key, ((void *) 0), &cell->key,
state_cache_2.c:27801:					     &cell->elem))
state_cache_2.c:27813:				      &cache->buckets[nonce_hash (key) %
state_cache_2.c:27814:						      cache->numBuckets];
state_cache_2.c:27817:					(*(int *) &(bucket)->fastCell.elem !=
state_cache_2.c:27820:					cell = &bucket->fastCell;
state_cache_2.c:27824:					cell = &bucket->fastCell;
state_cache_2.c:27825:					nonce_evict (cache->evictContext,
state_cache_2.c:27826:						     &cell->elem);
state_cache_2.c:27829:				    cache->count++;
state_cache_2.c:27830:				    cell->key = *key;
state_cache_2.c:27869:					    cell->elem = *elem;
state_cache_2.c:27912:						      &cache->
state_cache_2.c:27915:							      cache->
state_cache_2.c:27961:							      cache->
state_cache_2.c:27964:							    cache->total++;
state_cache_2.c:27983:								    cell->
state_cache_2.c:28106:										((struct NonceKey_bucket *) (((char *) cell) - ((char *) &((struct NonceKey_bucket *) 0)->fastCell)));
state_cache_2.c:28107:									      *(int *) &(bucket)->fastCell.elem = 0;
state_cache_2.c:28129:										 -
state_cache_2.c:28179:										&c->
state_cache_2.c:28181:									      phdr->
state_cache_2.c:28184:										dcont->
state_cache_2.c:28186:									      phdr->
state_cache_2.c:28189:										dcont->
state_cache_2.c:28191:									      phdr->
state_cache_2.c:28194:										dcont->
state_cache_2.c:28200:									      phdr->
state_cache_2.c:28203:										scont->
state_cache_2.c:28205:									      phdr->
state_cache_2.c:28208:										scont->
state_cache_2.c:28210:									      phdr->
state_cache_2.c:28213:										scont->
state_cache_2.c:28215:									      phdr->
state_cache_2.c:28218:										scont->
state_cache_2.c:28221:									      (__builtin_constant_p ((((__u8 *) (((WireContinuation *) 0) + 1) - (__u8 *) ((WireContinuation *) 0)->hmac_start))) ? __constant_memcpy ((c->copy_start), (dcont->hmac_start), ((((__u8 *) (((WireContinuation *) 0) + 1) - (__u8 *) ((WireContinuation *) 0)->hmac_start)))) : __memcpy ((c->copy_start), (dcont->hmac_start), ((((__u8 *) (((WireContinuation *) 0) + 1) - (__u8 *) ((WireContinuation *) 0)->hmac_start)))));
state_cache_2.c:28244:										&c->
state_cache_2.c:28246:									      if (phdr->seq == w->seq && phdr->type == w->continuationType && phdr->first == w->firstChild && phdr->serverAddr == iph->daddr && phdr->serverPort == th->dest && phdr->clientAddr == iph->saddr && phdr->clientPort == th->source && w->tokenCounterBase == c->tokenCounterBase)
state_cache_2.c:28248:										  (__builtin_constant_p ((((__u8 *) (((WireContinuation *) 0) + 1) - (__u8 *) ((WireContinuation *) 0)->hmac_start))) ? __constant_memcpy ((w->hmac_start), (c->copy_start), ((((__u8 *) (((WireContinuation *) 0) + 1) - (__u8 *) ((WireContinuation *) 0)->hmac_start)))) : __memcpy ((w->hmac_start), (c->copy_start), ((((__u8 *) (((WireContinuation *) 0) + 1) - (__u8 *) ((WireContinuation *) 0)->hmac_start)))));
state_cache_2.c:28272:										(w->
state_cache_2.c:28274:										 c->
state_cache_2.c:28276:										 (((__u8 *) (((WireContinuation *) 0) + 1) - (__u8 *) ((WireContinuation *) 0)->hmac_start)));
state_cache_2.c:28295:										(cont->
state_cache_2.c:28303:										  if (!WireContinuation_checkAndCopyOut (cont, &cell->elem, iph, th))
state_cache_2.c:28344:										(wcont->
state_cache_2.c:28355:										    (&cell->
state_cache_3.c:4:  char __data[128 - sizeof (unsigned short)];
state_cache_3.c:147:			(((__cmsg->cmsg_len) + sizeof (long) -
state_cache_3.c:148:			  1) & ~(sizeof (long) - 1)));
state_cache_3.c:149:  if ((unsigned long) ((char *) (__ptr + 1) - (char *) __ctl) > __size)
state_cache_3.c:156:  return __cmsg_nxthdr (__msg->msg_control, __msg->msg_controllen, __cmsg);
state_cache_3.c:187:  __asm__ __volatile__ ("" "addl %1,%0":"=m" (v->counter):"ir" (i),
state_cache_3.c:188:			"m" (v->counter));
state_cache_3.c:193:  __asm__ __volatile__ ("" "subl %1,%0":"=m" (v->counter):"ir" (i),
state_cache_3.c:194:			"m" (v->counter));
state_cache_3.c:200:  __asm__ __volatile__ ("" "subl %2,%0; sete %1":"=m" (v->counter),
state_cache_3.c:201:			"=qm" (c):"ir" (i), "m" (v->counter):"memory");
state_cache_3.c:207:  __asm__ __volatile__ ("" "incl %0":"=m" (v->counter):"m" (v->counter));
state_cache_3.c:212:  __asm__ __volatile__ ("" "decl %0":"=m" (v->counter):"m" (v->counter));
state_cache_3.c:218:  __asm__ __volatile__ ("" "decl %0; sete %1":"=m" (v->counter),
state_cache_3.c:219:			"=qm" (c):"m" (v->counter):"memory");
state_cache_3.c:226:  __asm__ __volatile__ ("" "incl %0; sete %1":"=m" (v->counter),
state_cache_3.c:227:			"=qm" (c):"m" (v->counter):"memory");
state_cache_3.c:234:  __asm__ __volatile__ ("" "addl %2,%0; sets %1":"=m" (v->counter),
state_cache_3.c:235:			"=qm" (c):"ir" (i), "m" (v->counter):"memory");
state_cache_3.c:476:  char _f[20 - 2 * sizeof (long) - sizeof (int)];
state_cache_3.c:674:  size = (size - 1) >> (12 - 1);
state_cache_3.c:675:  order = -1;
state_cache_3.c:878:  return ((unsigned long *) t->esp)[3];
state_cache_3.c:936:  next->prev = new;
state_cache_3.c:937:  new->next = next;
state_cache_3.c:938:  new->prev = prev;
state_cache_3.c:939:  prev->next = new;
state_cache_3.c:944:  __list_add (new, head, head->next);
state_cache_3.c:949:  __list_add (new, head->prev, head);
state_cache_3.c:954:  next->prev = prev;
state_cache_3.c:955:  prev->next = next;
state_cache_3.c:960:  __list_del (entry->prev, entry->next);
state_cache_3.c:961:  entry->next = (void *) 0;
state_cache_3.c:962:  entry->prev = (void *) 0;
state_cache_3.c:967:  __list_del (entry->prev, entry->next);
state_cache_3.c:970:      (entry)->next = (entry);
state_cache_3.c:971:      (entry)->prev = (entry);
state_cache_3.c:978:  __list_del (list->prev, list->next);
state_cache_3.c:984:  __list_del (list->prev, list->next);
state_cache_3.c:990:  return head->next == head;
state_cache_3.c:995:  struct list_head *first = list->next;
state_cache_3.c:996:  struct list_head *last = list->prev;
state_cache_3.c:997:  struct list_head *at = head->next;
state_cache_3.c:998:  first->prev = head;
state_cache_3.c:999:  head->next = first;
state_cache_3.c:1000:  last->next = at;
state_cache_3.c:1001:  at->prev = last;
state_cache_3.c:1017:	  (list)->next = (list);
state_cache_3.c:1018:	  (list)->prev = (list);
state_cache_3.c:1185:  __asm__ __volatile__ ("movl $-1,%%eax\n\t"
state_cache_3.c:1189:			"xorl -4(%%edi),%%eax\n\t"
state_cache_3.c:1209:      if (set < (32 - bit))
state_cache_3.c:1211:      set = 32 - bit;
state_cache_3.c:1214:  res = find_first_zero_bit (p, size - 32 * (p - (unsigned long *) addr));
state_cache_3.c:1227:__asm__ ("bsfl %1,%0\n\t" "jnz 1f\n\t" "movl $-1,%0\n" "1:": "=r" (r):"rm" (x));
state_cache_3.c:1340:  q->lock = (spinlock_t)
state_cache_3.c:1345:      (&q->task_list)->next = (&q->task_list);
state_cache_3.c:1346:      (&q->task_list)->prev = (&q->task_list);
state_cache_3.c:1353:  q->flags = 0;
state_cache_3.c:1354:  q->task = p;
state_cache_3.c:1359:  return !list_empty (&q->task_list);
state_cache_3.c:1364:  list_add (&new->task_list, &head->task_list);
state_cache_3.c:1369:  list_add_tail (&new->task_list, &head->task_list);
state_cache_3.c:1374:  list_del (&old->task_list);
state_cache_3.c:1507:			"leal -1(%%esi),%0\n"
state_cache_3.c:1616:__asm__ __volatile__ ("std\n\t" "rep\n\t" "movsb\n\t" "cld": "=&c" (d0), "=&S" (d1), "=&D" (d2): "0" (n), "1" (n - 1 + (const char *) src), "2" (n - 1 + (char *) dest):"memory");
state_cache_3.c:1669:			"cmpl $-1,%1\n\t"
state_cache_3.c:1853:    ((unsigned int) ((dev) & ((1U << 8) - 1)));
state_cache_3.c:1983:    atomic_inc (&mnt->mnt_count);
state_cache_3.c:1992:      if (atomic_dec_and_test (&mnt->mnt_count))
state_cache_3.c:2025:  while (len--)
state_cache_3.c:2063:  list_del (&dentry->d_hash);
state_cache_3.c:2066:      (&dentry->d_hash)->next = (&dentry->d_hash);
state_cache_3.c:2067:      (&dentry->d_hash)->prev = (&dentry->d_hash);
state_cache_3.c:2078:  return d->d_name.name != d->d_iname;
state_cache_3.c:2114:      if (!((&dentry->d_count)->counter))
state_cache_3.c:2116:      atomic_inc (&dentry->d_count);
state_cache_3.c:2124:  return list_empty (&dentry->d_hash);
state_cache_3.c:2130:  return dentry->d_mounted;
state_cache_3.c:2226:  sem->count = 0x00000000;
state_cache_3.c:2233:      (&sem->wait_list)->next = (&sem->wait_list);
state_cache_3.c:2234:      (&sem->wait_list)->prev = (&sem->wait_list);
state_cache_3.c:2252:			"# ending down_read\n\t":"+m" (sem->
state_cache_3.c:2269:			"# ending __down_read_trylock\n\t":"+m" (sem->
state_cache_3.c:2279:  tmp = ((-0x00010000) + 0x00000001);
state_cache_3.c:2291:			"+m" (sem->count):"a" (sem):"memory", "cc");
state_cache_3.c:2297:    ((__typeof__ (*(&sem->count)))
state_cache_3.c:2298:     __cmpxchg ((&sem->count), (unsigned long) (0x00000000),
state_cache_3.c:2299:		(unsigned long) (((-0x00010000) + 0x00000001)),
state_cache_3.c:2300:		sizeof (*(&sem->count))));
state_cache_3.c:2308:  __s32 tmp = -0x00000001;
state_cache_3.c:2319:			"# ending __up_read\n":"+m" (sem->count),
state_cache_3.c:2336:			"# ending __up_write\n":"+m" (sem->count):"a" (sem),
state_cache_3.c:2337:			"i" (-((-0x00010000) + 0x00000001)):"memory", "cc",
state_cache_3.c:2343:  __asm__ __volatile__ ("" "addl %1,%0":"=m" (sem->count):"ir" (delta),
state_cache_3.c:2344:			"m" (sem->count));
state_cache_3.c:2351:			"=m" (sem->count):"r" (sem),
state_cache_3.c:2352:			"m" (sem->count):"memory");
state_cache_3.c:2410:  (((&sem->count)->counter) = (val));
state_cache_3.c:2411:  sem->sleepers = 0;
state_cache_3.c:2412:  init_waitqueue_head (&sem->wait);
state_cache_3.c:2450:			".previous\n\t":"=m" (sem->count):"c" (sem):"memory");
state_cache_3.c:2466:			"=m" (sem->count):"c" (sem):"memory");
state_cache_3.c:2482:			"=m" (sem->count):"c" (sem):"memory");
state_cache_3.c:2495:			".previous\n\t" ".subsection 0\n":"=m" (sem->
state_cache_3.c:2502:  return ((&sem->count)->counter);
state_cache_3.c:2890:  unsigned long sec = value->tv_sec;
state_cache_3.c:2891:  long nsec = value->tv_nsec;
state_cache_3.c:2892:  if (sec >= (((~0UL >> 1) - 1) / 100))
state_cache_3.c:2893:    return ((~0UL >> 1) - 1);
state_cache_3.c:2894:  nsec += 1000000000L / 100 - 1;
state_cache_3.c:2901:  value->tv_nsec = (jiffies % 100) * (1000000000L / 100);
state_cache_3.c:2902:  value->tv_sec = jiffies / 100;
state_cache_3.c:2909:  if (0 >= (int) (mon -= 2))
state_cache_3.c:2912:      year -= 1;
state_cache_3.c:2914:  return ((((unsigned long) (year / 4 - year / 100 + year / 400 +
state_cache_3.c:2915:			     367 * mon / 12 + day) + year * 365 -
state_cache_3.c:3048:  if (fid->Vnode == 0xfffffffe || fid->Vnode == 0xffffffff)
state_cache_3.c:3049:    return ((fid->Volume << 20) | (fid->Unique & 0xfffff));
state_cache_3.c:3051:    return (fid->Unique + (fid->Vnode << 10) + (fid->Volume << 20));
state_cache_3.c:3815:  info->dqi_flags |= 0x10000;
state_cache_3.c:3904:      return dqopt->flags & 0x01;
state_cache_3.c:3906:      return dqopt->flags & 0x02;
state_cache_3.c:4048:  inode->i_blocks += bytes >> 9;
state_cache_3.c:4050:  inode->i_bytes += bytes;
state_cache_3.c:4051:  if (inode->i_bytes >= 512)
state_cache_3.c:4053:      inode->i_blocks++;
state_cache_3.c:4054:      inode->i_bytes -= 512;
state_cache_3.c:4060:  inode->i_blocks -= bytes >> 9;
state_cache_3.c:4062:  if (inode->i_bytes < bytes)
state_cache_3.c:4064:      inode->i_blocks--;
state_cache_3.c:4065:      inode->i_bytes += 512;
state_cache_3.c:4067:  inode->i_bytes -= bytes;
state_cache_3.c:4072:  return (((loff_t) inode->i_blocks) << 9) + inode->i_bytes;
state_cache_3.c:4077:  inode->i_blocks = bytes >> 9;
state_cache_3.c:4078:  inode->i_bytes = bytes & 511;
state_cache_3.c:4248:  timer->list.next = timer->list.prev = ((void *) 0);
state_cache_3.c:4253:  return timer->list.next != ((void *) 0);
state_cache_3.c:4993:  __s8 fs_fsmnt[512 - 212];
state_cache_3.c:5177:  down (&(server->sem));
state_cache_3.c:5182:  up (&(server->sem));
state_cache_3.c:5314:  if (!test_and_set_bit (0, &bh_pointer->sync))
state_cache_3.c:5328:      list_add_tail (&bh_pointer->list, bh_list);
state_cache_3.c:5756:  return ((server->conn_status & 0x11) == 0);
state_cache_3.c:5761:  server->conn_status |= 0x01;
state_cache_3.c:5785:  x->done = 0;
state_cache_3.c:5786:  init_waitqueue_head (&x->wait);
state_cache_3.c:6020:  if ((((inode)->i_sb->s_flags & (64))
state_cache_3.c:6021:       && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
state_cache_3.c:6029:  if (inode->i_flock
state_cache_3.c:6030:      && (((inode)->i_sb->s_flags & (64))
state_cache_3.c:6031:	  && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
state_cache_3.c:6038:  if (inode->i_flock
state_cache_3.c:6039:      && (((inode)->i_sb->s_flags & (64))
state_cache_3.c:6040:	  && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
state_cache_3.c:6042:				 size < inode->i_size ? size : inode->i_size,
state_cache_3.c:6044:				  inode->i_size ? inode->i_size -
state_cache_3.c:6045:				  size : size - inode->i_size));
state_cache_3.c:6051:  if (inode->i_flock)
state_cache_3.c:6114:  atomic_inc (&(bh)->b_count);
state_cache_3.c:6120:  atomic_dec (&bh->b_count);
state_cache_3.c:6126:    set_bit (BH_Uptodate, &bh->b_state);
state_cache_3.c:6128:    clear_bit (BH_Uptodate, &bh->b_state);
state_cache_3.c:6138:  if (test_and_clear_bit (BH_Dirty, &(bh)->b_state))
state_cache_3.c:6152:  buffer_insert_list (bh, &inode->i_dirty_buffers);
state_cache_3.c:6157:  buffer_insert_list (bh, &inode->i_dirty_data_buffers);
state_cache_3.c:6162:  return test_and_set_bit (BH_Dirty, &bh->b_state);
state_cache_3.c:6168:    set_bit (BH_Async, &bh->b_state);
state_cache_3.c:6170:    clear_bit (BH_Async, &bh->b_state);
state_cache_3.c:6175:  set_bit (BH_Attached, &bh->b_state);
state_cache_3.c:6180:  clear_bit (BH_Attached, &bh->b_state);
state_cache_3.c:6187:			     (&bh->
state_cache_3.c:6189:							     (&bh->b_state)));
state_cache_3.c:6195:  bh->b_end_io (bh, 0);
state_cache_3.c:6227:  return fsync_buffers_list (&inode->i_dirty_buffers);
state_cache_3.c:6232:  return fsync_buffers_list (&inode->i_dirty_data_buffers);
state_cache_3.c:6249:  atomic_dec (&inode->i_writecount);
state_cache_3.c:6255:    atomic_inc (&file->f_dentry->d_inode->i_writecount);
state_cache_3.c:6276:  return (unsigned long) ptr > (unsigned long) -1000L;
state_cache_3.c:6323:  if (inode && (inode->i_state & 64))
state_cache_3.c:6325:      if (sb->s_op->read_inode2)
state_cache_3.c:6326:	sb->s_op->read_inode2 (inode, opaque);
state_cache_3.c:6328:	sb->s_op->read_inode (inode);
state_cache_3.c:6337:  if (inode && (inode->i_state & 64))
state_cache_3.c:6339:      sb->s_op->read_inode (inode);
state_cache_3.c:6382:  return bread (sb->s_dev, block, sb->s_blocksize);
state_cache_3.c:6387:  return getblk (sb->s_dev, block, sb->s_blocksize);
state_cache_3.c:6392:  return get_hash_table (sb->s_dev, block, sb->s_blocksize);
state_cache_3.c:6490:  struct dentry *dir = dget (dentry->d_parent);
state_cache_3.c:6491:  down (&dir->d_inode->i_sem);
state_cache_3.c:6497:  return dget (dentry->d_parent);
state_cache_3.c:6502:  up (&dir->d_inode->i_sem);
state_cache_3.c:6584:  double_down (&d1->d_inode->i_sem, &d2->d_inode->i_sem);
state_cache_3.c:6589:  double_up (&d1->d_inode->i_sem, &d2->d_inode->i_sem);
state_cache_3.c:6763:  node->rb_parent = parent;
state_cache_3.c:6764:  node->rb_color = 0;
state_cache_3.c:6765:  node->rb_left = node->rb_right = ((void *) 0);
state_cache_3.c:7217:__asm__ ("btsl %1,%0": "=m" (*set): "Ir" (_sig - 1):"cc");
state_cache_3.c:7222:__asm__ ("btrl %1,%0": "=m" (*set): "Ir" (_sig - 1):"cc");
state_cache_3.c:7227:  unsigned long sig = _sig - 1;
state_cache_3.c:7228:  return 1 & (set->sig[sig / 32] >> (sig % 32));
state_cache_3.c:7234:__asm__ ("btl %2,%1\n\tsbbl %0,%0": "=r" (ret): "m" (*set), "Ir" (_sig - 1):"cc");
state_cache_3.c:7255:    int _pad[((128 / sizeof (int)) - 3)];
state_cache_3.c:7298:    int _pad[((64 / sizeof (int)) - 3)];
state_cache_3.c:7309:  if (from->si_code < 0)
state_cache_3.c:7318:      sizeof (from->_sifields._sigchld)) ? __constant_memcpy ((to), (from),
state_cache_3.c:7321:							       sizeof (from->
state_cache_3.c:7325:		 (3 * sizeof (int) + sizeof (from->_sifields._sigchld))));
state_cache_3.c:7345:      a0 = a->sig[4 * i + 0];
state_cache_3.c:7346:      a1 = a->sig[4 * i + 1];
state_cache_3.c:7347:      a2 = a->sig[4 * i + 2];
state_cache_3.c:7348:      a3 = a->sig[4 * i + 3];
state_cache_3.c:7349:      b0 = b->sig[4 * i + 0];
state_cache_3.c:7350:      b1 = b->sig[4 * i + 1];
state_cache_3.c:7351:      b2 = b->sig[4 * i + 2];
state_cache_3.c:7352:      b3 = b->sig[4 * i + 3];
state_cache_3.c:7353:      r->sig[4 * i + 0] = ((a0) | (b0));
state_cache_3.c:7354:      r->sig[4 * i + 1] = ((a1) | (b1));
state_cache_3.c:7355:      r->sig[4 * i + 2] = ((a2) | (b2));
state_cache_3.c:7356:      r->sig[4 * i + 3] = ((a3) | (b3));
state_cache_3.c:7361:      a0 = a->sig[4 * i + 0];
state_cache_3.c:7362:      a1 = a->sig[4 * i + 1];
state_cache_3.c:7363:      a2 = a->sig[4 * i + 2];
state_cache_3.c:7364:      b0 = b->sig[4 * i + 0];
state_cache_3.c:7365:      b1 = b->sig[4 * i + 1];
state_cache_3.c:7366:      b2 = b->sig[4 * i + 2];
state_cache_3.c:7367:      r->sig[4 * i + 0] = ((a0) | (b0));
state_cache_3.c:7368:      r->sig[4 * i + 1] = ((a1) | (b1));
state_cache_3.c:7369:      r->sig[4 * i + 2] = ((a2) | (b2));
state_cache_3.c:7372:      a0 = a->sig[4 * i + 0];
state_cache_3.c:7373:      a1 = a->sig[4 * i + 1];
state_cache_3.c:7374:      b0 = b->sig[4 * i + 0];
state_cache_3.c:7375:      b1 = b->sig[4 * i + 1];
state_cache_3.c:7376:      r->sig[4 * i + 0] = ((a0) | (b0));
state_cache_3.c:7377:      r->sig[4 * i + 1] = ((a1) | (b1));
state_cache_3.c:7380:      a0 = a->sig[4 * i + 0];
state_cache_3.c:7381:      b0 = b->sig[4 * i + 0];
state_cache_3.c:7382:      r->sig[4 * i + 0] = ((a0) | (b0));
state_cache_3.c:7393:      a0 = a->sig[4 * i + 0];
state_cache_3.c:7394:      a1 = a->sig[4 * i + 1];
state_cache_3.c:7395:      a2 = a->sig[4 * i + 2];
state_cache_3.c:7396:      a3 = a->sig[4 * i + 3];
state_cache_3.c:7397:      b0 = b->sig[4 * i + 0];
state_cache_3.c:7398:      b1 = b->sig[4 * i + 1];
state_cache_3.c:7399:      b2 = b->sig[4 * i + 2];
state_cache_3.c:7400:      b3 = b->sig[4 * i + 3];
state_cache_3.c:7401:      r->sig[4 * i + 0] = ((a0) & (b0));
state_cache_3.c:7402:      r->sig[4 * i + 1] = ((a1) & (b1));
state_cache_3.c:7403:      r->sig[4 * i + 2] = ((a2) & (b2));
state_cache_3.c:7404:      r->sig[4 * i + 3] = ((a3) & (b3));
state_cache_3.c:7409:      a0 = a->sig[4 * i + 0];
state_cache_3.c:7410:      a1 = a->sig[4 * i + 1];
state_cache_3.c:7411:      a2 = a->sig[4 * i + 2];
state_cache_3.c:7412:      b0 = b->sig[4 * i + 0];
state_cache_3.c:7413:      b1 = b->sig[4 * i + 1];
state_cache_3.c:7414:      b2 = b->sig[4 * i + 2];
state_cache_3.c:7415:      r->sig[4 * i + 0] = ((a0) & (b0));
state_cache_3.c:7416:      r->sig[4 * i + 1] = ((a1) & (b1));
state_cache_3.c:7417:      r->sig[4 * i + 2] = ((a2) & (b2));
state_cache_3.c:7420:      a0 = a->sig[4 * i + 0];
state_cache_3.c:7421:      a1 = a->sig[4 * i + 1];
state_cache_3.c:7422:      b0 = b->sig[4 * i + 0];
state_cache_3.c:7423:      b1 = b->sig[4 * i + 1];
state_cache_3.c:7424:      r->sig[4 * i + 0] = ((a0) & (b0));
state_cache_3.c:7425:      r->sig[4 * i + 1] = ((a1) & (b1));
state_cache_3.c:7428:      a0 = a->sig[4 * i + 0];
state_cache_3.c:7429:      b0 = b->sig[4 * i + 0];
state_cache_3.c:7430:      r->sig[4 * i + 0] = ((a0) & (b0));
state_cache_3.c:7441:      a0 = a->sig[4 * i + 0];
state_cache_3.c:7442:      a1 = a->sig[4 * i + 1];
state_cache_3.c:7443:      a2 = a->sig[4 * i + 2];
state_cache_3.c:7444:      a3 = a->sig[4 * i + 3];
state_cache_3.c:7445:      b0 = b->sig[4 * i + 0];
state_cache_3.c:7446:      b1 = b->sig[4 * i + 1];
state_cache_3.c:7447:      b2 = b->sig[4 * i + 2];
state_cache_3.c:7448:      b3 = b->sig[4 * i + 3];
state_cache_3.c:7449:      r->sig[4 * i + 0] = ((a0) & ~(b0));
state_cache_3.c:7450:      r->sig[4 * i + 1] = ((a1) & ~(b1));
state_cache_3.c:7451:      r->sig[4 * i + 2] = ((a2) & ~(b2));
state_cache_3.c:7452:      r->sig[4 * i + 3] = ((a3) & ~(b3));
state_cache_3.c:7457:      a0 = a->sig[4 * i + 0];
state_cache_3.c:7458:      a1 = a->sig[4 * i + 1];
state_cache_3.c:7459:      a2 = a->sig[4 * i + 2];
state_cache_3.c:7460:      b0 = b->sig[4 * i + 0];
state_cache_3.c:7461:      b1 = b->sig[4 * i + 1];
state_cache_3.c:7462:      b2 = b->sig[4 * i + 2];
state_cache_3.c:7463:      r->sig[4 * i + 0] = ((a0) & ~(b0));
state_cache_3.c:7464:      r->sig[4 * i + 1] = ((a1) & ~(b1));
state_cache_3.c:7465:      r->sig[4 * i + 2] = ((a2) & ~(b2));
state_cache_3.c:7468:      a0 = a->sig[4 * i + 0];
state_cache_3.c:7469:      a1 = a->sig[4 * i + 1];
state_cache_3.c:7470:      b0 = b->sig[4 * i + 0];
state_cache_3.c:7471:      b1 = b->sig[4 * i + 1];
state_cache_3.c:7472:      r->sig[4 * i + 0] = ((a0) & ~(b0));
state_cache_3.c:7473:      r->sig[4 * i + 1] = ((a1) & ~(b1));
state_cache_3.c:7476:      a0 = a->sig[4 * i + 0];
state_cache_3.c:7477:      b0 = b->sig[4 * i + 0];
state_cache_3.c:7478:      r->sig[4 * i + 0] = ((a0) & ~(b0));
state_cache_3.c:7488:      set->sig[4 * i + 0] = (~(set->sig[4 * i + 0]));
state_cache_3.c:7489:      set->sig[4 * i + 1] = (~(set->sig[4 * i + 1]));
state_cache_3.c:7490:      set->sig[4 * i + 2] = (~(set->sig[4 * i + 2]));
state_cache_3.c:7491:      set->sig[4 * i + 3] = (~(set->sig[4 * i + 3]));
state_cache_3.c:7496:      set->sig[4 * i + 2] = (~(set->sig[4 * i + 2]));
state_cache_3.c:7498:      set->sig[4 * i + 1] = (~(set->sig[4 * i + 1]));
state_cache_3.c:7500:      set->sig[4 * i + 0] = (~(set->sig[4 * i + 0]));
state_cache_3.c:7524:      set->sig[1] = 0;
state_cache_3.c:7526:      set->sig[0] = 0;
state_cache_3.c:7536:      (__builtin_constant_p (-1)
state_cache_3.c:7540:					   (unsigned char) (-1))),
state_cache_3.c:7543:			       ((0x01010101UL * (unsigned char) (-1))),
state_cache_3.c:7546:	  __memset_generic ((((set))), (((-1))),
state_cache_3.c:7548:	  __memset_generic (((set)), ((-1)), ((sizeof (sigset_t))))));
state_cache_3.c:7551:      set->sig[1] = -1;
state_cache_3.c:7553:      set->sig[0] = -1;
state_cache_3.c:7561:  set->sig[0] |= mask;
state_cache_3.c:7566:  set->sig[0] &= ~mask;
state_cache_3.c:7571:  return (set->sig[0] & mask) != 0;
state_cache_3.c:7576:  set->sig[0] = mask;
state_cache_3.c:7581:       ? (__builtin_constant_p ((sizeof (long) * ((64 / 32) - 1))) ?
state_cache_3.c:7582:	  __constant_c_and_count_memset (((&set->sig[1])),
state_cache_3.c:7586:					   ((64 / 32) -
state_cache_3.c:7588:	  __constant_c_memset (((&set->sig[1])),
state_cache_3.c:7591:				 ((64 / 32) -
state_cache_3.c:7593:       : (__builtin_constant_p ((sizeof (long) * ((64 / 32) - 1))) ?
state_cache_3.c:7594:	  __memset_generic ((((&set->sig[1]))), (((0))),
state_cache_3.c:7596:			       ((64 / 32) -
state_cache_3.c:7597:				1))))) : __memset_generic (((&set->sig[1])),
state_cache_3.c:7600:							     ((64 / 32) -
state_cache_3.c:7604:      set->sig[1] = 0;
state_cache_3.c:7611:  set->sig[0] = ~mask;
state_cache_3.c:7615:      (__builtin_constant_p (-1)
state_cache_3.c:7616:       ? (__builtin_constant_p ((sizeof (long) * ((64 / 32) - 1))) ?
state_cache_3.c:7617:	  __constant_c_and_count_memset (((&set->sig[1])),
state_cache_3.c:7619:					   (unsigned char) (-1))),
state_cache_3.c:7621:					   ((64 / 32) -
state_cache_3.c:7623:	  __constant_c_memset (((&set->sig[1])),
state_cache_3.c:7624:			       ((0x01010101UL * (unsigned char) (-1))),
state_cache_3.c:7626:				 ((64 / 32) -
state_cache_3.c:7628:       : (__builtin_constant_p ((sizeof (long) * ((64 / 32) - 1))) ?
state_cache_3.c:7629:	  __memset_generic ((((&set->sig[1]))), (((-1))),
state_cache_3.c:7631:			       ((64 / 32) -
state_cache_3.c:7632:				1))))) : __memset_generic (((&set->sig[1])),
state_cache_3.c:7633:							   ((-1)),
state_cache_3.c:7635:							     ((64 / 32) -
state_cache_3.c:7639:      set->sig[1] = -1;
state_cache_3.c:7646:  sigemptyset (&sig->signal);
state_cache_3.c:7647:  sig->head = ((void *) 0);
state_cache_3.c:7648:  sig->tail = &sig->head;
state_cache_3.c:7668:  (void) (&fs->lock);
state_cache_3.c:7669:  old_root = fs->root;
state_cache_3.c:7670:  old_rootmnt = fs->rootmnt;
state_cache_3.c:7671:  fs->rootmnt = mntget (mnt);
state_cache_3.c:7672:  fs->root = dget (dentry);
state_cache_3.c:7688:  (void) (&fs->lock);
state_cache_3.c:7689:  old_pwd = fs->pwd;
state_cache_3.c:7690:  old_pwdmnt = fs->pwdmnt;
state_cache_3.c:7691:  fs->pwdmnt = mntget (mnt);
state_cache_3.c:7692:  fs->pwd = dget (dentry);
state_cache_3.c:8089:    &pidhash[((((p->pid) >> 8) ^ (p->pid)) & ((4096 >> 2) - 1))];
state_cache_3.c:8090:  if ((p->pidhash_next = *htable) != ((void *) 0))
state_cache_3.c:8091:    (*htable)->pidhash_pprev = &p->pidhash_next;
state_cache_3.c:8093:  p->pidhash_pprev = htable;
state_cache_3.c:8098:  if (p->pidhash_next)
state_cache_3.c:8099:    p->pidhash_next->pidhash_pprev = p->pidhash_pprev;
state_cache_3.c:8100:  *p->pidhash_pprev = p->pidhash_next;
state_cache_3.c:8106:    &pidhash[((((pid) >> 8) ^ (pid)) & ((4096 >> 2) - 1))];
state_cache_3.c:8107:  for (p = *htable; p && p->pid != pid; p = p->pidhash_next)
state_cache_3.c:8114:  tsk->processor = cpu;
state_cache_3.c:8115:  tsk->cpus_runnable = 1UL << cpu;
state_cache_3.c:8120:  tsk->cpus_runnable = ~0UL;
state_cache_3.c:8209:  return (p->sigpending != 0);
state_cache_3.c:8219:      for (i = (64 / 32), ready = 0; --i >= 0;)
state_cache_3.c:8220:	ready |= signal->sig[i] & ~blocked->sig[i];
state_cache_3.c:8223:      ready = signal->sig[3] & ~blocked->sig[3];
state_cache_3.c:8224:      ready |= signal->sig[2] & ~blocked->sig[2];
state_cache_3.c:8225:      ready |= signal->sig[1] & ~blocked->sig[1];
state_cache_3.c:8226:      ready |= signal->sig[0] & ~blocked->sig[0];
state_cache_3.c:8229:      ready = signal->sig[1] & ~blocked->sig[1];
state_cache_3.c:8230:      ready |= signal->sig[0] & ~blocked->sig[0];
state_cache_3.c:8233:      ready = signal->sig[0] & ~blocked->sig[0];
state_cache_3.c:8240:  t->sigpending = has_pending_signals (&t->pending.signal, &t->blocked);
state_cache_3.c:8245:  return (sp - get_current ()->sas_ss_sp < get_current ()->sas_ss_size);
state_cache_3.c:8250:  return (get_current ()->sas_ss_size == 0 ? 2 : on_sig_stack (sp) ? 1 : 0);
state_cache_3.c:8261:       securebits) && get_current ()->euid == 0)
state_cache_3.c:8263:      get_current ()->flags |= 0x00000100;
state_cache_3.c:8273:       securebits) && get_current ()->fsuid == 0)
state_cache_3.c:8275:      get_current ()->flags |= 0x00000100;
state_cache_3.c:8283:  if (((get_current ()->cap_effective) & (1 << (cap))))
state_cache_3.c:8285:      get_current ()->flags |= 0x00000100;
state_cache_3.c:8298:  if (atomic_dec_and_test (&mm->mm_count))
state_cache_3.c:8333:  nr_running--;
state_cache_3.c:8334:  p->sleep_time = jiffies;
state_cache_3.c:8335:  list_del (&p->run_list);
state_cache_3.c:8336:  p->run_list.next = ((void *) 0);
state_cache_3.c:8341:  return (p->run_list.next != ((void *) 0));
state_cache_3.c:8354:  nr_threads--;
state_cache_3.c:8358:      (p)->next_task->prev_task = (p)->prev_task;
state_cache_3.c:8359:      (p)->prev_task->next_task = (p)->next_task;
state_cache_3.c:8360:      if ((p)->p_osptr)
state_cache_3.c:8361:	(p)->p_osptr->p_ysptr = (p)->p_ysptr;
state_cache_3.c:8362:      if ((p)->p_ysptr)
state_cache_3.c:8363:	(p)->p_ysptr->p_osptr = (p)->p_osptr;
state_cache_3.c:8365:	(p)->p_pptr->p_cptr = (p)->p_osptr;
state_cache_3.c:8368:  list_del (&p->thread_group);
state_cache_3.c:8382:  (void) (&p->alloc_lock);
state_cache_3.c:8398:  (void) (&get_current ()->fs->lock);
state_cache_3.c:8399:  rootmnt = mntget (get_current ()->fs->rootmnt);
state_cache_3.c:8400:  root = dget (get_current ()->fs->root);
state_cache_3.c:8418:  return (__builtin_expect ((get_current ()->need_resched), 0));
state_cache_3.c:8495:  pg_data_t *pgdat = zone->zone_pgdat;
state_cache_3.c:8496:  if (zone - pgdat->node_zones < 3 - 1)
state_cache_3.c:8498:  else if (pgdat->node_next)
state_cache_3.c:8500:      pgdat = pgdat->node_next;
state_cache_3.c:8501:      zone = pgdat->node_zones;
state_cache_3.c:8511:    char reserved[(1UL << 12) - 10];
state_cache_3.c:8642:  return (new < 3) ? -1 : 0;
state_cache_3.c:8911:  FIX_IO_APIC_BASE_END = FIX_IO_APIC_BASE_0 + 8 - 1,
state_cache_3.c:8914:  FIX_BTMAP_BEGIN = FIX_BTMAP_END + 16 - 1,
state_cache_3.c:8925:  return ((0xffffe000UL) - ((idx) << 12));
state_cache_3.c:9060:  pte.pte_low &= ((~((1UL << 12) - 1)) | 0x020 | 0x040);
state_cache_3.c:9110:  return zone_table[page->flags >> (32 - 8)];
state_cache_3.c:9115:  page->flags &= ~(~0UL << (32 - 8));
state_cache_3.c:9116:  page->flags |= zone_num << (32 - 8);
state_cache_3.c:9215:  return ((&(page)->count)->counter) - !!page->buffers == 1;
state_cache_3.c:9239:  unsigned long ret = -22;
state_cache_3.c:9240:  if ((offset + (((len) + (1UL << 12) - 1) & (~((1UL << 12) - 1)))) < offset)
state_cache_3.c:9242:  if (!(offset & ~(~((1UL << 12) - 1))))
state_cache_3.c:9243:    ret = do_mmap_pgoff (get_current ()->mm, file, addr, len, prot, flag,
state_cache_3.c:9254:  prev->vm_next = vma->vm_next;
state_cache_3.c:9255:  rb_erase (&vma->vm_rb, &mm->mm_rb);
state_cache_3.c:9256:  if (mm->mmap_cache == vma)
state_cache_3.c:9257:    mm->mmap_cache = prev;
state_cache_3.c:9262:  if (!vma->vm_file && vma->vm_flags == vm_flags)
state_cache_3.c:9278:  if (get_current ()->flags & 0x00004000)
state_cache_3.c:9286:  address &= (~((1UL << 12) - 1));
state_cache_3.c:9287:  (void) (&vma->vm_mm->page_table_lock);
state_cache_3.c:9288:  grow = (vma->vm_start - address) >> 12;
state_cache_3.c:9289:  if (vma->vm_end - address > get_current ()->rlim[3].rlim_cur ||
state_cache_3.c:9290:      ((vma->vm_mm->total_vm + grow) << 12) >
state_cache_3.c:9291:      get_current ()->rlim[9].rlim_cur)
state_cache_3.c:9297:      return -12;
state_cache_3.c:9299:  vma->vm_start = address;
state_cache_3.c:9300:  vma->vm_pgoff -= grow;
state_cache_3.c:9301:  vma->vm_mm->total_vm += grow;
state_cache_3.c:9302:  if (vma->vm_flags & 0x00002000)
state_cache_3.c:9303:    vma->vm_mm->locked_vm += grow;
state_cache_3.c:9320:  if (vma && end_addr <= vma->vm_start)
state_cache_3.c:9335:		 "g" (get_current ()->addr_limit.
state_cache_3.c:9338:	    }) == 0) ? 0 : -14;
state_cache_3.c:9422:unsigned long flag, sum; asm ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag), "=r" (sum):"1" (to), "g" ((int) (n)), "g" (get_current ()->addr_limit.seg));
state_cache_3.c:9452:unsigned long flag, sum; asm ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag), "=r" (sum):"1" (from), "g" ((int) (n)), "g" (get_current ()->addr_limit.seg));
state_cache_3.c:9558:  pt->error = 0;
state_cache_3.c:9559:  pt->table = ((void *) 0);
state_cache_3.c:9571:    ((((nr) + (8 * sizeof (long)) -
state_cache_3.c:9582:	error = -14;
state_cache_3.c:9598:     (((((nr) + (8 * sizeof (long)) -
state_cache_3.c:9604:							      -
state_cache_3.c:9610:				     (((((nr) + (8 * sizeof (long)) -
state_cache_3.c:9619:      ((((((nr) + (8 * sizeof (long)) -
state_cache_3.c:9628:								 (long)) -
state_cache_3.c:9636:			   ((((((nr) + (8 * sizeof (long)) -
state_cache_3.c:9640:      ((((((nr) + (8 * sizeof (long)) -
state_cache_3.c:9644:						    (8 * sizeof (long)) -
state_cache_3.c:9649:			((((((nr) + (8 * sizeof (long)) -
state_cache_3.c:9691:       ((1024 -
state_cache_3.c:9701:					     ((1024 -
state_cache_3.c:9709:		 ((1024 -
state_cache_3.c:9723:      (boot_cpu_data.pgtable_cache_sz)--;
state_cache_3.c:9769:      (boot_cpu_data.pgtable_cache_sz)--;
state_cache_3.c:9789:  if (mm == get_current ()->active_mm)
state_cache_3.c:9802:  if (vma->vm_mm == get_current ()->active_mm)
state_cache_3.c:9808:  if (mm == get_current ()->active_mm)
state_cache_3.c:9834:		long) ((((page) - page_zone (page)->zone_mem_map) << 12) +
state_cache_3.c:9835:		       page_zone (page)->zone_start_paddr) +
state_cache_3.c:10092:  return (list->next == (struct sk_buff *) list);
state_cache_3.c:10097:  atomic_inc (&skb->users);
state_cache_3.c:10103:  if (((&skb->users)->counter) == 1 || atomic_dec_and_test (&skb->users))
state_cache_3.c:10109:  if (((&skb->users)->counter) == 1 || atomic_dec_and_test (&skb->users))
state_cache_3.c:10115:  return skb->cloned
state_cache_3.c:10116:    && ((&((struct skb_shared_info *) ((skb)->end))->dataref)->counter) != 1;
state_cache_3.c:10121:  return (((&skb->users)->counter) != 1);
state_cache_3.c:10148:  struct sk_buff *list = ((struct sk_buff *) list_)->next;
state_cache_3.c:10156:  struct sk_buff *list = ((struct sk_buff *) list_)->prev;
state_cache_3.c:10164:  return (list_->qlen);
state_cache_3.c:10173:  list->prev = (struct sk_buff *) list;
state_cache_3.c:10174:  list->next = (struct sk_buff *) list;
state_cache_3.c:10175:  list->qlen = 0;
state_cache_3.c:10181:  newsk->list = list;
state_cache_3.c:10182:  list->qlen++;
state_cache_3.c:10184:  next = prev->next;
state_cache_3.c:10185:  newsk->next = next;
state_cache_3.c:10186:  newsk->prev = prev;
state_cache_3.c:10187:  next->prev = newsk;
state_cache_3.c:10188:  prev->next = newsk;
state_cache_3.c:10202:      (void) (&list->lock);
state_cache_3.c:10220:  newsk->list = list;
state_cache_3.c:10221:  list->qlen++;
state_cache_3.c:10223:  prev = next->prev;
state_cache_3.c:10224:  newsk->next = next;
state_cache_3.c:10225:  newsk->prev = prev;
state_cache_3.c:10226:  next->prev = newsk;
state_cache_3.c:10227:  prev->next = newsk;
state_cache_3.c:10241:      (void) (&list->lock);
state_cache_3.c:10260:  next = prev->next;
state_cache_3.c:10265:      next = next->next;
state_cache_3.c:10266:      list->qlen--;
state_cache_3.c:10267:      next->prev = prev;
state_cache_3.c:10268:      prev->next = next;
state_cache_3.c:10269:      result->next = ((void *) 0);
state_cache_3.c:10270:      result->prev = ((void *) 0);
state_cache_3.c:10271:      result->list = ((void *) 0);
state_cache_3.c:10288:      (void) (&list->lock);
state_cache_3.c:10308:  newsk->next = next;
state_cache_3.c:10309:  newsk->prev = prev;
state_cache_3.c:10310:  next->prev = newsk;
state_cache_3.c:10311:  prev->next = newsk;
state_cache_3.c:10312:  newsk->list = list;
state_cache_3.c:10313:  list->qlen++;
state_cache_3.c:10327:      (void) (&old->list->lock);
state_cache_3.c:10330:  __skb_insert (newsk, old->prev, old, old->list);
state_cache_3.c:10344:  __skb_insert (newsk, old, old->next, old->list);
state_cache_3.c:10358:      (void) (&old->list->lock);
state_cache_3.c:10376:  list->qlen--;
state_cache_3.c:10377:  next = skb->next;
state_cache_3.c:10378:  prev = skb->prev;
state_cache_3.c:10379:  skb->next = ((void *) 0);
state_cache_3.c:10380:  skb->prev = ((void *) 0);
state_cache_3.c:10381:  skb->list = ((void *) 0);
state_cache_3.c:10382:  next->prev = prev;
state_cache_3.c:10383:  prev->next = next;
state_cache_3.c:10388:  struct sk_buff_head *list = skb->list;
state_cache_3.c:10400:	  (void) (&list->lock);
state_cache_3.c:10403:      if (skb->list == list)
state_cache_3.c:10404:	__skb_unlink (skb, skb->list);
state_cache_3.c:10438:      (void) (&list->lock);
state_cache_3.c:10456:  return skb->data_len;
state_cache_3.c:10461:  return skb->len - skb->data_len;
state_cache_3.c:10466:  unsigned char *tmp = skb->tail;
state_cache_3.c:10473:  skb->tail += len;
state_cache_3.c:10474:  skb->len += len;
state_cache_3.c:10480:  unsigned char *tmp = skb->tail;
state_cache_3.c:10487:  skb->tail += len;
state_cache_3.c:10488:  skb->len += len;
state_cache_3.c:10489:  if (skb->tail > skb->end)
state_cache_3.c:10503:  skb->data -= len;
state_cache_3.c:10504:  skb->len += len;
state_cache_3.c:10505:  return skb->data;
state_cache_3.c:10510:  skb->data -= len;
state_cache_3.c:10511:  skb->len += len;
state_cache_3.c:10512:  if (skb->data < skb->head)
state_cache_3.c:10521:  return skb->data;
state_cache_3.c:10526:  skb->len -= len;
state_cache_3.c:10527:  if (skb->len < skb->data_len)
state_cache_3.c:10529:  return skb->data += len;
state_cache_3.c:10534:  if (len > skb->len)
state_cache_3.c:10543:      __pskb_pull_tail (skb, len - skb_headlen (skb)) == ((void *) 0))
state_cache_3.c:10545:  skb->len -= len;
state_cache_3.c:10546:  return skb->data += len;
state_cache_3.c:10551:  if (len > skb->len)
state_cache_3.c:10560:  if (len > skb->len)
state_cache_3.c:10562:  return (__pskb_pull_tail (skb, len - skb_headlen (skb)) != ((void *) 0));
state_cache_3.c:10567:  return skb->data - skb->head;
state_cache_3.c:10572:  return skb_is_nonlinear (skb) ? 0 : skb->end - skb->tail;
state_cache_3.c:10577:  skb->data += len;
state_cache_3.c:10578:  skb->tail += len;
state_cache_3.c:10584:  if (!skb->data_len)
state_cache_3.c:10586:      skb->len = len;
state_cache_3.c:10587:      skb->tail = skb->data + len;
state_cache_3.c:10597:  if (skb->len > len)
state_cache_3.c:10605:  if (!skb->data_len)
state_cache_3.c:10607:      skb->len = len;
state_cache_3.c:10608:      skb->tail = skb->data + len;
state_cache_3.c:10619:  if (len < skb->len)
state_cache_3.c:10626:  if (skb->destructor)
state_cache_3.c:10627:    skb->destructor (skb);
state_cache_3.c:10628:  skb->destructor = ((void *) 0);
state_cache_3.c:10629:  skb->sk = ((void *) 0);
state_cache_3.c:10665:  int delta = (headroom > 16 ? headroom : 16) - skb_headroom (skb);
state_cache_3.c:10675:  unsigned int size = skb->len;
state_cache_3.c:10678:  return skb_pad (skb, len - size);
state_cache_3.c:10684:  return kmap (frag->page);
state_cache_3.c:10720:  if (nfct && atomic_dec_and_test (&nfct->master->use))
state_cache_3.c:10721:    nfct->master->destroy (nfct->master);
state_cache_3.c:10727:    atomic_inc (&nfct->master->use);
state_cache_3.c:10830:  unsigned char __pad[16 - sizeof (short int) -
state_cache_3.c:10831:		      sizeof (unsigned short int) - sizeof (struct in_addr)];
state_cache_3.c:11227:  unsigned long hh_data[(((32) + (16 - 1)) & ~(16 - 1)) / sizeof (long)];
state_cache_3.c:11428:  eip -= (unsigned long) &_stext;
state_cache_3.c:11430:  if (eip > prof_len - 1)
state_cache_3.c:11431:    eip = prof_len - 1;
state_cache_3.c:11512:  if (!test_and_set_bit (TASKLET_STATE_SCHED, &t->state))
state_cache_3.c:11520:  if (!test_and_set_bit (TASKLET_STATE_SCHED, &t->state))
state_cache_3.c:11526:  atomic_inc (&t->count);
state_cache_3.c:11543:  atomic_dec (&t->count);
state_cache_3.c:11549:  atomic_dec (&t->count);
state_cache_3.c:11628:  if (!test_and_set_bit (__LINK_STATE_SCHED, &dev->state))
state_cache_3.c:11638:      dev->next_sched = softnet_data[cpu].output_queue;
state_cache_3.c:11650:			  (&dev->
state_cache_3.c:11652:							(&dev->state))))
state_cache_3.c:11658:  clear_bit (__LINK_STATE_XOFF, &dev->state);
state_cache_3.c:11663:  if (test_and_clear_bit (__LINK_STATE_XOFF, &dev->state))
state_cache_3.c:11669:  set_bit (__LINK_STATE_XOFF, &dev->state);
state_cache_3.c:11676:			     (&dev->
state_cache_3.c:11678:	  variable_test_bit ((__LINK_STATE_XOFF), (&dev->state)));
state_cache_3.c:11685:			     (&dev->
state_cache_3.c:11687:	  variable_test_bit ((__LINK_STATE_START), (&dev->state)));
state_cache_3.c:11692:  if (atomic_dec_and_test (&skb->users))
state_cache_3.c:11702:      skb->next = softnet_data[cpu].completion_queue;
state_cache_3.c:11740:  if (atomic_dec_and_test (&dev->refcnt))
state_cache_3.c:11748:			      (&dev->
state_cache_3.c:11750:	   variable_test_bit ((__LINK_STATE_NOCARRIER), (&dev->state)));
state_cache_3.c:11756:  clear_bit (__LINK_STATE_NOCARRIER, &dev->state);
state_cache_3.c:11763:  set_bit (__LINK_STATE_NOCARRIER, &dev->state);
state_cache_3.c:11770:			     (&dev->
state_cache_3.c:11772:	  variable_test_bit ((__LINK_STATE_PRESENT), (&dev->state)));
state_cache_3.c:11777:  if (test_and_clear_bit (__LINK_STATE_PRESENT, &dev->state) &&
state_cache_3.c:11786:  if (!test_and_set_bit (__LINK_STATE_PRESENT, &dev->state) &&
state_cache_3.c:11815:    !test_and_set_bit (__LINK_STATE_RX_SCHED, &dev->state);
state_cache_3.c:11828:  atomic_inc (&(dev)->refcnt);
state_cache_3.c:11829:  list_add_tail (&dev->poll_list, &softnet_data[cpu].poll_list);
state_cache_3.c:11830:  if (dev->quota < 0)
state_cache_3.c:11831:    dev->quota += dev->weight;
state_cache_3.c:11833:    dev->quota = dev->weight;
state_cache_3.c:11855:      dev->quota += undo;
state_cache_3.c:11862:      list_add_tail (&dev->poll_list, &softnet_data[cpu].poll_list);
state_cache_3.c:11887:			  (&dev->
state_cache_3.c:11889:       variable_test_bit ((__LINK_STATE_RX_SCHED), (&dev->state))))
state_cache_3.c:11900:  list_del (&dev->poll_list);
state_cache_3.c:11902:  clear_bit (__LINK_STATE_RX_SCHED, &dev->state);
state_cache_3.c:11908:  while (test_and_set_bit (__LINK_STATE_RX_SCHED, &dev->state))
state_cache_3.c:11910:      get_current ()->state = 1;
state_cache_3.c:11917:  clear_bit (__LINK_STATE_RX_SCHED, &dev->state);
state_cache_3.c:11925:			  (&dev->
state_cache_3.c:11927:       variable_test_bit ((__LINK_STATE_RX_SCHED), (&dev->state))))
state_cache_3.c:11938:  list_del (&dev->poll_list);
state_cache_3.c:11940:  clear_bit (__LINK_STATE_RX_SCHED, &dev->state);
state_cache_3.c:11953:      (void) (&dev->xmit_lock);
state_cache_3.c:11967:	  if (!--*ptr)
state_cache_3.c:11968:	    __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;"
state_cache_3.c:12205:  return fp->len * sizeof (struct sock_filter) + sizeof (*fp);
state_cache_3.c:12255:  unsigned char ha[(8 + sizeof (unsigned long) - 1) &
state_cache_3.c:12256:		   ~(sizeof (unsigned long) - 1)];
state_cache_3.c:12360:  if (atomic_dec_and_test (&neigh->refcnt))
state_cache_3.c:12367:    atomic_inc (&neigh->refcnt);
state_cache_3.c:12374:    neigh->confirmed = jiffies;
state_cache_3.c:12379:  return neigh->nud_state & (0x80 | 0x40 | 0x02);
state_cache_3.c:12384:  return neigh->nud_state & (0x80 | 0x40 | 0x02 | 0x10 | 0x04 | 0x08);
state_cache_3.c:12389:  neigh->used = jiffies;
state_cache_3.c:12390:  if (!(neigh->nud_state & ((0x80 | 0x40 | 0x02) | 0x08 | 0x10)))
state_cache_3.c:12461:  atomic_inc (&dst->__refcnt);
state_cache_3.c:12467:    atomic_inc (&dst->__refcnt);
state_cache_3.c:12474:    atomic_dec (&dst->__refcnt);
state_cache_3.c:12482:  if (dst->obsolete > 1)
state_cache_3.c:12484:  if (!((&dst->__refcnt)->counter))
state_cache_3.c:12495:    neigh_confirm (dst->neighbour);
state_cache_3.c:12501:  if (dst && dst->ops->negative_advice)
state_cache_3.c:12502:    *dst_p = dst->ops->negative_advice (dst);
state_cache_3.c:12507:  struct dst_entry *dst = skb->dst;
state_cache_3.c:12508:  if (dst && dst->ops && dst->ops->link_failure)
state_cache_3.c:12509:    dst->ops->link_failure (skb);
state_cache_3.c:12517:  if (dst->expires == 0 || (long) (dst->expires - expires) > 0)
state_cache_3.c:12518:    dst->expires = expires;
state_cache_3.c:12580:  head->next = head->prev = ((void *) 0);
state_cache_3.c:12589:    ASSERT_OR_RETURN (elem->list == list);
state_cache_3.c:12592:  ASSERT_OR_RETURN (count == list->len);
state_cache_3.c:12601:  for (elem = (typeof (elem)) (list)->next; (elem != (typeof (elem)) (list));
state_cache_3.c:12602:       elem = (typeof (elem)) elem->next)
state_cache_3.c:12616:  dlist->next = dlist->prev = (struct list_link *) dlist;
state_cache_3.c:12621:  if (head->next == elem)
state_cache_3.c:12635:  elem->next = head->next;
state_cache_3.c:12636:  head->next->prev = elem;
state_cache_3.c:12637:  elem->prev = (struct list_link *) head;
state_cache_3.c:12638:  head->next = elem;
state_cache_3.c:12643:  if (head->prev == elem)
state_cache_3.c:12657:  elem->next = (struct list_link *) head;
state_cache_3.c:12658:  elem->prev = head->prev;
state_cache_3.c:12659:  head->prev->next = elem;
state_cache_3.c:12660:  head->prev = elem;
state_cache_3.c:12665:  elem->next->prev = elem->prev;
state_cache_3.c:12666:  elem->prev->next = elem->next;
state_cache_3.c:12667:  elem->prev = elem->next = ((void *) 0);
state_cache_3.c:12672:  return (struct dlist *) list->next == list;
state_cache_3.c:12712:  vec->num = 0;
state_cache_3.c:12713:  vec->size = initSize;
state_cache_3.c:12714:  vec->elems = kmalloc (vec->size * sizeof (vec->elems[0]), (0x20));
state_cache_3.c:12715:  if (vec->elems == ((void *) 0))
state_cache_3.c:12724:  kfree (vec->elems);
state_cache_3.c:12730:  if (vec->num == vec->size)
state_cache_3.c:12733:      vec->size *= 2;
state_cache_3.c:12734:      newElems = kmalloc (vec->size * sizeof (newElems[0]), (0x20));
state_cache_3.c:12751:  vec->elems[vec->num++] = newElem;
state_cache_3.c:12756:  return head->next == (struct alloc_head *) head;
state_cache_3.c:12761:  head->next = head->prev = (struct alloc_head *) head;
state_cache_3.c:12762:  head->list = head;
state_cache_3.c:12763:  head->len = 0;
state_cache_3.c:12768:  if (head->next == elem)
state_cache_3.c:12782:  elem->next = head->next;
state_cache_3.c:12783:  head->next->prev = elem;
state_cache_3.c:12784:  elem->prev = (struct alloc_head *) head;
state_cache_3.c:12785:  head->next = elem;
state_cache_3.c:12786:  elem->list = head;
state_cache_3.c:12787:  head->len++;
state_cache_3.c:12792:  if (head->prev == elem)
state_cache_3.c:12806:  elem->next = (struct alloc_head *) head;
state_cache_3.c:12807:  elem->prev = head->prev;
state_cache_3.c:12808:  head->prev->next = elem;
state_cache_3.c:12809:  elem->list = head;
state_cache_3.c:12810:  head->prev = elem;
state_cache_3.c:12811:  head->len++;
state_cache_3.c:12816:  if (head->prev == elem)
state_cache_3.c:12830:  elem->next = (struct alloc_head *) head;
state_cache_3.c:12831:  elem->prev = head->prev;
state_cache_3.c:12833:  head->prev->next = elem;
state_cache_3.c:12834:  elem->list = head;
state_cache_3.c:12835:  head->prev = elem;
state_cache_3.c:12836:  head->len++;
state_cache_3.c:12841:  elem->next->prev = elem->prev;
state_cache_3.c:12842:  elem->prev->next = elem->next;
state_cache_3.c:12843:  elem->prev = elem->next = ((void *) 0);
state_cache_3.c:12844:  elem->list->len--;
state_cache_3.c:12845:  elem->list = ((void *) 0);
state_cache_3.c:12851:  if (!(elem->next == ((void *) 0) && elem->prev == ((void *) 0)))
state_cache_3.c:12862:  elem->next = prev->next;
state_cache_3.c:12863:  prev->next = elem;
state_cache_3.c:12864:  elem->prev = prev;
state_cache_3.c:12865:  next->prev = elem;
state_cache_3.c:12866:  elem->list = prev->list;
state_cache_3.c:12867:  elem->list->len++;
state_cache_3.c:12894:  pkt->nonce = -1;
state_cache_3.c:12895:  pkt->seq = seq;
state_cache_3.c:12896:  pkt->len = len;
state_cache_3.c:12897:  pkt->type = type;
state_cache_3.c:12898:  pkt->contType = contType;
state_cache_3.c:12899:  pkt->minResponseLen = minResponseLen;
state_cache_3.c:12900:  pkt->firstTransportChild = firstTransportChild;
state_cache_3.c:12901:  pkt->numTransportChildren = numTransportChildren;
state_cache_3.c:12902:  pkt->ucontLen = 0;
state_cache_3.c:12903:  pkt->ucontData = ((void *) 0);
state_cache_3.c:12904:  pkt->numSiblings = -1;
state_cache_3.c:12905:  pkt->position = (0xff);
state_cache_3.c:12910:  if (len > packet->len + packet->ucontLen)
state_cache_3.c:12913:	      (int) len, packet->len, packet->ucontLen);
state_cache_3.c:12916:  if (packet->ucontData)
state_cache_3.c:12918:      kfree (packet->ucontData);
state_cache_3.c:12919:      packet->len += packet->ucontLen;
state_cache_3.c:12920:      packet->ucontLen = 0;
state_cache_3.c:12922:  packet->ucontData = buf;
state_cache_3.c:12923:  packet->ucontLen = len;
state_cache_3.c:12924:  packet->len -= packet->ucontLen;
state_cache_3.c:13241:  printk ("PHChunk %p = { type = %d, chunkLen = %d, range=[%d-%d] }\n",
state_cache_3.c:13242:	  phchunk, phchunk->type, ntohs (phchunk->chunkLen),
state_cache_3.c:13243:	  ntohl (phchunk->start), ntohl (phchunk->end));
state_cache_3.c:13787:    u8 __pad[(1 << ((5))) - sizeof (int)];
state_cache_3.c:13793:  prot->stats[0].inuse++;
state_cache_3.c:13798:  prot->stats[0].inuse--;
state_cache_3.c:13857:  if (sk->filter)
state_cache_3.c:13861:	(void) (&((sk)->lock.slock));
state_cache_3.c:13862:      filter = sk->filter;
state_cache_3.c:13865:	  int pkt_len = sk_run_filter (skb, filter->insns,
state_cache_3.c:13866:				       filter->len);
state_cache_3.c:13868:	    err = -1;
state_cache_3.c:13884:  atomic_sub (size, &sk->omem_alloc);
state_cache_3.c:13885:  if (atomic_dec_and_test (&fp->refcnt))
state_cache_3.c:13891:  atomic_inc (&fp->refcnt);
state_cache_3.c:13892:  atomic_add (sk_filter_len (fp), &sk->omem_alloc);
state_cache_3.c:13897:  atomic_inc (&sk->refcnt);
state_cache_3.c:13902:  atomic_dec (&sk->refcnt);
state_cache_3.c:13907:  if (atomic_dec_and_test (&sk->refcnt))
state_cache_3.c:13921:      (void) (&sk->callback_lock);
state_cache_3.c:13924:  sk->dead = 1;
state_cache_3.c:13925:  sk->socket = ((void *) 0);
state_cache_3.c:13926:  sk->sleep = ((void *) 0);
state_cache_3.c:13937:	  if (!--*ptr)
state_cache_3.c:13938:	    __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;"
state_cache_3.c:13963:      (void) (&sk->callback_lock);
state_cache_3.c:13966:  sk->sleep = &parent->wait;
state_cache_3.c:13967:  parent->sk = sk;
state_cache_3.c:13968:  sk->socket = parent;
state_cache_3.c:13979:	  if (!--*ptr)
state_cache_3.c:13980:	    __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;"
state_cache_3.c:13998:  (void) (&sk->callback_lock);
state_cache_3.c:13999:  uid = sk->socket ? sk->socket->inode->i_uid : 0;
state_cache_3.c:14010:  (void) (&sk->callback_lock);
state_cache_3.c:14011:  ino = sk->socket ? sk->socket->inode->i_ino : 0;
state_cache_3.c:14021:  return sk->dst_cache;
state_cache_3.c:14027:  (void) (&sk->dst_lock);
state_cache_3.c:14028:  dst = sk->dst_cache;
state_cache_3.c:14041:  old_dst = sk->dst_cache;
state_cache_3.c:14042:  sk->dst_cache = dst;
state_cache_3.c:14048:  (void) (&sk->dst_lock);
state_cache_3.c:14059:  old_dst = sk->dst_cache;
state_cache_3.c:14060:  sk->dst_cache = ((void *) 0);
state_cache_3.c:14066:  (void) (&sk->dst_lock);
state_cache_3.c:14076:  struct dst_entry *dst = sk->dst_cache;
state_cache_3.c:14077:  if (dst && dst->obsolete && dst->ops->check (dst, cookie) == ((void *) 0))
state_cache_3.c:14079:      sk->dst_cache = ((void *) 0);
state_cache_3.c:14088:  if (dst && dst->obsolete && dst->ops->check (dst, cookie) == ((void *) 0))
state_cache_3.c:14099:  skb->sk = sk;
state_cache_3.c:14100:  skb->destructor = sock_wfree;
state_cache_3.c:14101:  atomic_add (skb->truesize, &sk->wmem_alloc);
state_cache_3.c:14106:  skb->sk = sk;
state_cache_3.c:14107:  skb->destructor = sock_rfree;
state_cache_3.c:14108:  atomic_add (skb->truesize, &sk->rmem_alloc);
state_cache_3.c:14115:  if (((&sk->rmem_alloc)->counter) + skb->truesize >= (unsigned) sk->rcvbuf)
state_cache_3.c:14117:      err = -12;
state_cache_3.c:14123:  skb->dev = ((void *) 0);
state_cache_3.c:14125:  skb_len = skb->len;
state_cache_3.c:14126:  skb_queue_tail (&sk->receive_queue, skb);
state_cache_3.c:14127:  if (!sk->dead)
state_cache_3.c:14128:    sk->data_ready (sk, skb_len);
state_cache_3.c:14135:  if (((&sk->rmem_alloc)->counter) + skb->truesize >= (unsigned) sk->rcvbuf)
state_cache_3.c:14136:    return -12;
state_cache_3.c:14138:  skb_queue_tail (&sk->error_queue, skb);
state_cache_3.c:14139:  if (!sk->dead)
state_cache_3.c:14140:    sk->data_ready (sk, skb->len);
state_cache_3.c:14147:    ((__typeof__ (*(&sk->err)))
state_cache_3.c:14148:     __xchg ((unsigned long) (0), (&sk->err), sizeof (*(&sk->err))));
state_cache_3.c:14149:  return -err;
state_cache_3.c:14155:  if (!(sk->shutdown & 2))
state_cache_3.c:14157:      amt = sk->sndbuf - ((&sk->wmem_alloc)->counter);
state_cache_3.c:14166:  if (sk->socket && sk->socket->fasync_list)
state_cache_3.c:14167:    sock_wake_async (sk->socket, how, band);
state_cache_3.c:14172:  return ((&sk->wmem_alloc)->counter) < (sk->sndbuf / 2);
state_cache_3.c:14184:  return noblock ? 0 : sk->rcvtimeo;
state_cache_3.c:14189:  return noblock ? 0 : sk->sndtimeo;
state_cache_3.c:14196:			    int __x = (sk->rcvlowat);
state_cache_3.c:14204:  return timeo == ((long) (~0UL >> 1)) ? -512 : -4;
state_cache_3.c:14209:  if (sk->rcvtstamp)
state_cache_3.c:14210:    put_cmsg (msg, 1, 29, sizeof (skb->stamp), &skb->stamp);
state_cache_3.c:14212:    sk->stamp = skb->stamp;
state_cache_3.c:14291:  return !((addr ^ ifa->ifa_address) & ifa->ifa_mask);
state_cache_3.c:14309:  in_dev = dev->ip_ptr;
state_cache_3.c:14311:    atomic_inc (&in_dev->refcnt);
state_cache_3.c:14321:  return (struct in_device *) dev->ip_ptr;
state_cache_3.c:14327:  if (atomic_dec_and_test (&idev->refcnt))
state_cache_3.c:14334:    return htonl (~((1 << (32 - logmask)) - 1));
state_cache_3.c:14342:  return 32 - ffz (~mask);
state_cache_3.c:14375:  if (atomic_dec_and_test (&p->refcnt))
state_cache_3.c:14377:      p->unused_prevp = inet_peer_unused_tailp;
state_cache_3.c:14378:      p->unused_next = ((void *) 0);
state_cache_3.c:14380:      inet_peer_unused_tailp = &p->unused_next;
state_cache_3.c:14381:      p->dtime = jiffies;
state_cache_3.c:14393:	  if (!--*ptr)
state_cache_3.c:14394:	    __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;"
state_cache_3.c:14424:  id = p->ip_id_count++;
state_cache_3.c:14435:	  if (!--*ptr)
state_cache_3.c:14436:	    __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;"
state_cache_3.c:14516:  int size = ((len) + (((sizeof (struct nlmsghdr)) + 4 - 1) & ~(4 - 1)));
state_cache_3.c:14517:  nlh = (struct nlmsghdr *) skb_put (skb, (((size) + 4 - 1) & ~(4 - 1)));
state_cache_3.c:14518:  nlh->nlmsg_type = type;
state_cache_3.c:14519:  nlh->nlmsg_len = size;
state_cache_3.c:14520:  nlh->nlmsg_flags = 0;
state_cache_3.c:14521:  nlh->nlmsg_pid = pid;
state_cache_3.c:14522:  nlh->nlmsg_seq = seq;
state_cache_3.c:14732:  return len > rta->rta_len
state_cache_3.c:14735:				 ((((sizeof (struct rtattr)) + 4 - 1) & ~(4 -
state_cache_3.c:14860:    dst_release (&rt->u.dst);
state_cache_3.c:14875:  dst = (*rp)->rt_dst;
state_cache_3.c:14876:  src = (*rp)->rt_src;
state_cache_3.c:14885:  if (rt->peer)
state_cache_3.c:14886:    return rt->peer;
state_cache_3.c:14888:  return rt->peer;
state_cache_3.c:15245:  if (skb->len > skb->dst->pmtu)
state_cache_3.c:15253:  u32 check = iph->check;
state_cache_3.c:15258:  iph->check = check + (check >= 0xFFFF);
state_cache_3.c:15259:  return --iph->ttl;
state_cache_3.c:15264:  return (sk->protinfo.af_inet.pmtudisc == 2 ||
state_cache_3.c:15265:	  (sk->protinfo.af_inet.pmtudisc == 1 &&
state_cache_3.c:15266:	   !(dst->mxlock & (1 << RTAX_MTU))));
state_cache_3.c:15272:  if (iph->
state_cache_3.c:15278:      iph->id = ((sk && sk->daddr) ? htons (sk->protinfo.af_inet.id++) : 0);
state_cache_3.c:15419:unsigned long flag, sum; asm ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag), "=r" (sum):"1" (dst), "g" ((int) (len)), "g" (get_current ()->addr_limit.seg));
state_cache_3.c:15425:    *err_ptr = -14;
state_cache_3.c:15426:  return -1;
state_cache_3.c:15435:    *err_ptr = -14;
state_cache_3.c:15503:  return (lport & ((tcp_hashinfo.__tcp_bhash_size) - 1));
state_cache_3.c:15537:  if (atomic_dec_and_test (&tw->refcnt))
state_cache_3.c:15551:  return num & (32 - 1);
state_cache_3.c:15556:  return tcp_lhashfn (sk->num);
state_cache_3.c:15637:  req->class->destructor (req);
state_cache_3.c:15663:  return (__s32) (seq1 - seq2) < 0;
state_cache_3.c:15668:  return (__s32) (seq2 - seq1) < 0;
state_cache_3.c:15673:  return seq3 - seq2 >= seq1 - seq2;
state_cache_3.c:15704:  tp->ack.pending |= TCP_ACK_SCHED;
state_cache_3.c:15709:  return tp->ack.pending & TCP_ACK_SCHED;
state_cache_3.c:15714:  if (tp->ack.quick && --tp->ack.quick == 0)
state_cache_3.c:15716:      tp->ack.ato = ((unsigned) (100 / 25));
state_cache_3.c:15724:   ? (__builtin_constant_p ((sizeof (tp->ack))) ?
state_cache_3.c:15725:      __constant_c_and_count_memset (((&tp->ack)),
state_cache_3.c:15727:				     ((sizeof (tp->ack)))) :
state_cache_3.c:15728:      __constant_c_memset (((&tp->ack)),
state_cache_3.c:15730:			   ((sizeof (tp->ack)))))
state_cache_3.c:15731:   : (__builtin_constant_p ((sizeof (tp->ack))) ?
state_cache_3.c:15732:      __memset_generic ((((&tp->ack))), (((0))),
state_cache_3.c:15733:			(((sizeof (tp->ack))))) :
state_cache_3.c:15734:      __memset_generic (((&tp->ack)), ((0)), ((sizeof (tp->ack))))));
state_cache_3.c:15739:  tp->tstamp_ok = tp->sack_ok = tp->wscale_ok = tp->snd_wscale = 0;
state_cache_3.c:15835:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_3.c:15840:      tp->pending = 0;
state_cache_3.c:15843:      tp->ack.blocked = 0;
state_cache_3.c:15844:      tp->ack.pending = 0;
state_cache_3.c:15854:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_3.c:15870:      tp->pending = what;
state_cache_3.c:15871:      tp->timeout = jiffies + when;
state_cache_3.c:15872:      if (!mod_timer (&tp->retransmit_timer, tp->timeout))
state_cache_3.c:15876:      tp->ack.pending |= TCP_ACK_TIMER;
state_cache_3.c:15877:      tp->ack.timeout = jiffies + when;
state_cache_3.c:15878:      if (!mod_timer (&tp->delack_timer, tp->ack.timeout))
state_cache_3.c:15888:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_3.c:15890:  int mss_now = tp->mss_cache;
state_cache_3.c:15891:  if (dst && dst->pmtu != tp->pmtu_cookie)
state_cache_3.c:15892:    mss_now = tcp_sync_mss (sk, dst->pmtu);
state_cache_3.c:15893:  if (tp->eff_sacks)
state_cache_3.c:15894:    mss_now -= (4 + (tp->eff_sacks * 8));
state_cache_3.c:15900:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_3.c:15901:  unsigned int hint = ({ const typeof (tp->advmss) _x = (tp->advmss);
state_cache_3.c:15902:		       const typeof (tp->mss_cache) _y = (tp->mss_cache);
state_cache_3.c:15909:	   const typeof (tp->rcv_wnd / 2) _y = (tp->rcv_wnd / 2);
state_cache_3.c:15927:  tp->ack.rcv_mss = hint;
state_cache_3.c:15932:  tp->pred_flags = htonl ((tp->tcp_header_len << 26) |
state_cache_3.c:15938:  __tcp_fast_path_on (tp, tp->snd_wnd >> tp->snd_wscale);
state_cache_3.c:15943:  if (skb_queue_len (&tp->out_of_order_queue) == 0 &&
state_cache_3.c:15944:      tp->rcv_wnd &&
state_cache_3.c:15945:      ((&sk->rmem_alloc)->counter) < sk->rcvbuf && !tp->urg_data)
state_cache_3.c:15951:  s32 win = tp->rcv_wup + tp->rcv_wnd - tp->rcv_nxt;
state_cache_3.c:16008:  u32 check = iph->check;
state_cache_3.c:16013:  iph->check = check + (check >= 0xFFFF);
state_cache_3.c:16014:  iph->tos |= 1;
state_cache_3.c:16025:  if (tp->ecn_flags & 1)
state_cache_3.c:16026:    tp->ecn_flags |= 2;
state_cache_3.c:16031:  ((struct tcp_skb_cb *) &((skb)->cb[0]))->flags &= ~0x80;
state_cache_3.c:16032:  if (!(tp->ecn_flags & 1))
state_cache_3.c:16033:    ((struct tcp_skb_cb *) &((skb)->cb[0]))->flags &= ~0x40;
state_cache_3.c:16038:  tp->ecn_flags = 0;
state_cache_3.c:16041:      ((struct tcp_skb_cb *) &((skb)->cb[0]))->flags |= 0x40 | 0x80;
state_cache_3.c:16042:      tp->ecn_flags = 1;
state_cache_3.c:16048:  if (req->ecn_ok)
state_cache_3.c:16049:    th->ece = 1;
state_cache_3.c:16055:  if (tp->ecn_flags & 1)
state_cache_3.c:16057:      if (skb->len != tcp_header_len &&
state_cache_3.c:16058:	  !before (((struct tcp_skb_cb *) &((skb)->cb[0]))->seq, tp->snd_nxt))
state_cache_3.c:16062:	      (sk)->protinfo.af_inet.tos |= 2;
state_cache_3.c:16065:	  if (tp->ecn_flags & 2)
state_cache_3.c:16067:	      tp->ecn_flags &= ~2;
state_cache_3.c:16068:	      skb->h.th->cwr = 1;
state_cache_3.c:16075:	      (sk)->protinfo.af_inet.tos &= ~3;
state_cache_3.c:16079:      if (tp->ecn_flags & 4)
state_cache_3.c:16080:	skb->h.th->ece = 1;
state_cache_3.c:16086:  if (skb->h.th->cwr)
state_cache_3.c:16087:    tp->ecn_flags &= ~4;
state_cache_3.c:16092:  tp->ecn_flags &= ~4;
state_cache_3.c:16097:  if (tp->ecn_flags & 1)
state_cache_3.c:16099:      if (INET_ECN_is_ce (((struct tcp_skb_cb *) &((skb)->cb[0]))->flags))
state_cache_3.c:16100:	tp->ecn_flags |= 4;
state_cache_3.c:16103:	    ((((struct tcp_skb_cb *) &((skb)->cb[0]))->flags)))
state_cache_3.c:16110:  if ((tp->ecn_flags & 1) && (!th->ece || th->cwr))
state_cache_3.c:16111:    tp->ecn_flags &= ~1;
state_cache_3.c:16116:  if ((tp->ecn_flags & 1) && (!th->ece || !th->cwr))
state_cache_3.c:16117:    tp->ecn_flags &= ~1;
state_cache_3.c:16122:  if (th->ece && !th->syn && (tp->ecn_flags & 1))
state_cache_3.c:16129:  tp->ecn_flags = req->ecn_ok ? 1 : 0;
state_cache_3.c:16134:  if (sysctl_tcp_ecn && th->ece && th->cwr)
state_cache_3.c:16135:    req->ecn_ok = 1;
state_cache_3.c:16140:  return sk->wmem_queued / 2;
state_cache_3.c:16145:  return sk->sndbuf - sk->wmem_queued;
state_cache_3.c:16150:  return tp->packets_out - tp->left_out + tp->retrans_out;
state_cache_3.c:16157:	   const typeof (tp->snd_cwnd >> 1U) _x = (tp->snd_cwnd >> 1U);
state_cache_3.c:16166:  if ((1 << tp->ca_state) & ((1 << TCP_CA_CWR) | (1 << TCP_CA_Recovery)))
state_cache_3.c:16167:    return tp->snd_ssthresh;
state_cache_3.c:16171:	     const typeof (tp->snd_ssthresh) _x = (tp->snd_ssthresh);
state_cache_3.c:16172:	     const typeof (((tp->snd_cwnd >> 1) + (tp->snd_cwnd >> 2))) _y =
state_cache_3.c:16173:	     (((tp->snd_cwnd >> 1) + (tp->snd_cwnd >> 2)));
state_cache_3.c:16181:  if (tp->sack_ok && tp->sacked_out >= tp->packets_out - tp->lost_out)
state_cache_3.c:16182:    tp->sacked_out = tp->packets_out - tp->lost_out;
state_cache_3.c:16183:  tp->left_out = tp->sacked_out + tp->lost_out;
state_cache_3.c:16189:  if (tp->packets_out >= tp->snd_cwnd)
state_cache_3.c:16191:      tp->snd_cwnd_used = 0;
state_cache_3.c:16192:      tp->snd_cwnd_stamp = ((__u32) (jiffies));
state_cache_3.c:16196:      if (tp->packets_out > tp->snd_cwnd_used)
state_cache_3.c:16197:	tp->snd_cwnd_used = tp->packets_out;
state_cache_3.c:16198:      if ((s32) (((__u32) (jiffies)) - tp->snd_cwnd_stamp) >= tp->rto)
state_cache_3.c:16205:  tp->undo_marker = 0;
state_cache_3.c:16206:  tp->snd_ssthresh = tcp_recalc_ssthresh (tp);
state_cache_3.c:16207:  tp->snd_cwnd = (
state_cache_3.c:16209:		   const typeof (tp->snd_cwnd) _x = (tp->snd_cwnd);
state_cache_3.c:16215:  tp->snd_cwnd_cnt = 0;
state_cache_3.c:16216:  tp->high_seq = tp->snd_nxt;
state_cache_3.c:16217:  tp->snd_cwnd_stamp = ((__u32) (jiffies));
state_cache_3.c:16223:  tp->prior_ssthresh = 0;
state_cache_3.c:16224:  if (tp->ca_state < TCP_CA_CWR)
state_cache_3.c:16227:      tp->ca_state = TCP_CA_CWR;
state_cache_3.c:16239:  return after (tp->snd_sml, tp->snd_una) &&
state_cache_3.c:16240:    !after (tp->snd_sml, tp->snd_nxt);
state_cache_3.c:16245:  if (skb->len < mss)
state_cache_3.c:16246:    tp->snd_sml = ((struct tcp_skb_cb *) &((skb)->cb[0]))->end_seq;
state_cache_3.c:16252:  return (skb->len < mss_now &&
state_cache_3.c:16253:	  !(((struct tcp_skb_cb *) &((skb)->cb[0]))->flags & 0x01) &&
state_cache_3.c:16255:	   (!nonagle && tp->packets_out && tcp_minshall_check (tp))));
state_cache_3.c:16261:  return ((nonagle == 1 || tp->urg_mode
state_cache_3.c:16263:	  ((tcp_packets_in_flight (tp) < tp->snd_cwnd) ||
state_cache_3.c:16264:	   (((struct tcp_skb_cb *) &((skb)->cb[0]))->flags & 0x01)) &&
state_cache_3.c:16265:	  !after (((struct tcp_skb_cb *) &((skb)->cb[0]))->end_seq,
state_cache_3.c:16266:		  tp->snd_una + tp->snd_wnd));
state_cache_3.c:16271:  if (!tp->packets_out && !tp->pending)
state_cache_3.c:16272:    tcp_reset_xmit_timer (sk, 3, tp->rto);
state_cache_3.c:16277:  return (skb->next == (struct sk_buff *) &sk->write_queue);
state_cache_3.c:16283:  struct sk_buff *skb = tp->send_head;
state_cache_3.c:16297:  __tcp_push_pending_frames (sk, tp, tcp_current_mss (sk), tp->nonagle);
state_cache_3.c:16302:  struct sk_buff *skb = tp->send_head;
state_cache_3.c:16305:			tcp_skb_is_last (sk, skb) ? 1 : tp->nonagle));
state_cache_3.c:16310:  tp->snd_wl1 = seq;
state_cache_3.c:16315:  tp->snd_wl1 = seq;
state_cache_3.c:16328:    csum_fold (skb_checksum (skb, 0, skb->len, skb->csum));
state_cache_3.c:16333:  return skb->ip_summed != 2 && __tcp_checksum_complete (skb);
state_cache_3.c:16338:  tp->ucopy.task = ((void *) 0);
state_cache_3.c:16339:  tp->ucopy.len = 0;
state_cache_3.c:16340:  tp->ucopy.memory = 0;
state_cache_3.c:16341:  skb_queue_head_init (&tp->ucopy.prequeue);
state_cache_3.c:16346:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_3.c:16347:  if (!sysctl_tcp_low_latency && tp->ucopy.task)
state_cache_3.c:16349:      __skb_queue_tail (&tp->ucopy.prequeue, skb);
state_cache_3.c:16350:      tp->ucopy.memory += skb->truesize;
state_cache_3.c:16351:      if (tp->ucopy.memory > sk->rcvbuf)
state_cache_3.c:16354:	  if (sk->lock.users)
state_cache_3.c:16356:	  while ((skb1 = __skb_dequeue (&tp->ucopy.prequeue)) != ((void *) 0))
state_cache_3.c:16358:	      sk->backlog_rcv (sk, skb1);
state_cache_3.c:16361:	  tp->ucopy.memory = 0;
state_cache_3.c:16363:      else if (skb_queue_len (&tp->ucopy.prequeue) == 1)
state_cache_3.c:16365:	  __wake_up ((sk->sleep), 1, 1);
state_cache_3.c:16376:  int oldstate = sk->state;
state_cache_3.c:16392:      sk->prot->unhash (sk);
state_cache_3.c:16393:      if (sk->prev && !(sk->userlocks & 8))
state_cache_3.c:16399:			  irq_stat[0].__local_bh_count) != 0)].TcpCurrEstab--;
state_cache_3.c:16401:  sk->state = state;
state_cache_3.c:16408:  sk->shutdown = 3;
state_cache_3.c:16409:  if (!sk->dead)
state_cache_3.c:16410:    sk->state_change (sk);
state_cache_3.c:16417:  tp->dsack = 0;
state_cache_3.c:16418:  tp->eff_sacks = 0;
state_cache_3.c:16419:  tp->num_sacks = 0;
state_cache_3.c:16424:  if (tp->tstamp_ok)
state_cache_3.c:16437:      *ptr++ = htonl (tp->ts_recent);
state_cache_3.c:16439:  if (tp->eff_sacks)
state_cache_3.c:16442:	tp->dsack ? tp->duplicate_sack : tp->selective_acks;
state_cache_3.c:16447:	    (((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) &
state_cache_3.c:16450:	    (((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) &
state_cache_3.c:16453:	    (((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) &
state_cache_3.c:16456:	    (((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) &
state_cache_3.c:16458:      for (this_sack = 0; this_sack < tp->eff_sacks; this_sack++)
state_cache_3.c:16463:      if (tp->dsack)
state_cache_3.c:16465:	  tp->dsack = 0;
state_cache_3.c:16466:	  tp->eff_sacks--;
state_cache_3.c:16550:      if (*rcv_wscale && sysctl_tcp_app_win && space >= mss && space - (
state_cache_3.c:16555:	(*rcv_wscale)--;
state_cache_3.c:16580:    (space >> (-sysctl_tcp_adv_win_scale)) :
state_cache_3.c:16581:    space - (space >> sysctl_tcp_adv_win_scale);
state_cache_3.c:16586:  return tcp_win_from_space (sk->rcvbuf - ((&sk->rmem_alloc)->counter));
state_cache_3.c:16591:  return tcp_win_from_space (sk->rcvbuf);
state_cache_3.c:16596:  sk->ack_backlog--;
state_cache_3.c:16601:  sk->ack_backlog++;
state_cache_3.c:16606:  return sk->ack_backlog > sk->max_ack_backlog;
state_cache_3.c:16612:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_3.c:16613:  req->sk = child;
state_cache_3.c:16615:  if (!tp->accept_queue_tail)
state_cache_3.c:16617:      tp->accept_queue = req;
state_cache_3.c:16621:      tp->accept_queue_tail->dl_next = req;
state_cache_3.c:16623:  tp->accept_queue_tail = req;
state_cache_3.c:16624:  req->dl_next = ((void *) 0);
state_cache_3.c:16638:  struct tcp_listen_opt *lopt = sk->tp_pinfo.af_tcp.listen_opt;
state_cache_3.c:16639:  if (--lopt->qlen == 0)
state_cache_3.c:16641:  if (req->retrans == 0)
state_cache_3.c:16642:    lopt->qlen_young--;
state_cache_3.c:16647:  struct tcp_listen_opt *lopt = sk->tp_pinfo.af_tcp.listen_opt;
state_cache_3.c:16648:  if (lopt->qlen++ == 0)
state_cache_3.c:16650:  lopt->qlen_young++;
state_cache_3.c:16655:  return sk->tp_pinfo.af_tcp.listen_opt->qlen;
state_cache_3.c:16660:  return sk->tp_pinfo.af_tcp.listen_opt->qlen_young;
state_cache_3.c:16665:  return tcp_synq_len (sk) >> sk->tp_pinfo.af_tcp.listen_opt->max_qlen_log;
state_cache_3.c:16671:  (void) (&tp->syn_wait_lock);
state_cache_3.c:16672:  *prev = req->dl_next;
state_cache_3.c:16682:  tcp_synq_unlink (&sk->tp_pinfo.af_tcp, req, prev);
state_cache_3.c:16690:  req->rcv_wnd = 0;
state_cache_3.c:16691:  req->rcv_isn = ((struct tcp_skb_cb *) &((skb)->cb[0]))->seq;
state_cache_3.c:16692:  req->mss = tp->mss_clamp;
state_cache_3.c:16693:  req->ts_recent = tp->saw_tstamp ? tp->rcv_tsval : 0;
state_cache_3.c:16694:  req->tstamp_ok = tp->tstamp_ok;
state_cache_3.c:16695:  req->sack_ok = tp->sack_ok;
state_cache_3.c:16696:  req->snd_wscale = tp->snd_wscale;
state_cache_3.c:16697:  req->wscale_ok = tp->wscale_ok;
state_cache_3.c:16698:  req->acked = 0;
state_cache_3.c:16699:  req->ecn_ok = 0;
state_cache_3.c:16700:  req->rmt_port = skb->h.th->source;
state_cache_3.c:16705:  sk->tp_pinfo.af_tcp.queue_shrunk = 1;
state_cache_3.c:16706:  sk->wmem_queued -= skb->truesize;
state_cache_3.c:16707:  sk->forward_alloc += skb->truesize;
state_cache_3.c:16713:  sk->wmem_queued += skb->truesize;
state_cache_3.c:16714:  sk->forward_alloc -= skb->truesize;
state_cache_3.c:16721:  if (sk->forward_alloc >= ((int) (1UL << 12)))
state_cache_3.c:16739:  if (!(sk->userlocks & 1))
state_cache_3.c:16741:      sk->sndbuf = (
state_cache_3.c:16743:		     const typeof (sk->sndbuf) _x = (sk->sndbuf);
state_cache_3.c:16744:		     const typeof (sk->wmem_queued / 2) _y =
state_cache_3.c:16745:		     (sk->wmem_queued / 2);
state_cache_3.c:16749:      sk->sndbuf = (
state_cache_3.c:16751:		     const typeof (sk->sndbuf) _x = (sk->sndbuf);
state_cache_3.c:16764:      skb->truesize += mem;
state_cache_3.c:16765:      if (sk->forward_alloc >= (int) skb->truesize ||
state_cache_3.c:16766:	  tcp_mem_schedule (sk, skb->truesize, 0))
state_cache_3.c:16788:  if (sk->forward_alloc >= (int) (1UL << 12) ||
state_cache_3.c:16791:      struct page *page = alloc_pages (sk->allocation, 0);
state_cache_3.c:16803:  while ((skb = __skb_dequeue (&sk->write_queue)) != ((void *) 0))
state_cache_3.c:16811:  skb->sk = sk;
state_cache_3.c:16812:  skb->destructor = tcp_rfree;
state_cache_3.c:16813:  atomic_add (skb->truesize, &sk->rmem_alloc);
state_cache_3.c:16814:  sk->forward_alloc -= skb->truesize;
state_cache_3.c:16836:  return tp->keepalive_intvl ? : sysctl_tcp_keepalive_intvl;
state_cache_3.c:16841:  return tp->keepalive_time ? : sysctl_tcp_keepalive_time;
state_cache_3.c:16846:  int fin_timeout = tp->linger2 ? : sysctl_tcp_fin_timeout;
state_cache_3.c:16847:  if (fin_timeout < (tp->rto << 2) - (tp->rto >> 1))
state_cache_3.c:16848:    fin_timeout = (tp->rto << 2) - (tp->rto >> 1);
state_cache_3.c:16854:  if ((s32) (tp->rcv_tsval - tp->ts_recent) >= 0)
state_cache_3.c:16856:  if (xtime.tv_sec >= tp->ts_recent_stamp + (60 * 60 * 24 * 24))
state_cache_3.c:16858:  if (rst && xtime.tv_sec >= tp->ts_recent_stamp + 60)
state_cache_3.c:16865:  const struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_3.c:16866:  return (sysctl_tcp_frto && tp->send_head &&
state_cache_3.c:16867:	  !after (((struct tcp_skb_cb *) &((tp->send_head)->cb[0]))->end_seq,
state_cache_3.c:16868:		  tp->snd_una + tp->snd_wnd));
state_cache_3.c:16878:  ((tcp_statistics)[2 * 0 + 1].TcpMaxConn += -1);
state_cache_3.c:16884:    tp->westwood.rtt = rtt_seq;
state_cache_3.c:16891:  struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
state_cache_3.c:16892:  tp->westwood.bw_ns_est = 0;
state_cache_3.c:16893:  tp->westwood.bw_est = 0;
state_cache_3.c:16894:  tp->westwood.accounted = 0;
state_cache_3.c:16895:  tp->westwood.cumul_ack = 0;
state_cache_3.c:16896:  tp->westwood.rtt_win_sx = ((__u32) (jiffies));
state_cache_3.c:16897:  tp->westwood.rtt = 20 * 100;
state_cache_3.c:16898:  tp->westwood.rtt_min = 20 * 100;
state_cache_3.c:16899:  tp->westwood.snd_una = tp->snd_una;
state_cache_3.c:16921:  return (__u32) ((tp->westwood.bw_est) * (tp->westwood.rtt_min) /
state_cache_3.c:16922:		  (__u32) (tp->mss_cache));
state_cache_3.c:16949:      tp->snd_ssthresh = ssthresh;
state_cache_3.c:16963:      tp->snd_cwnd = cwnd;
state_cache_3.c:16976:	  tp->snd_ssthresh = tp->snd_cwnd;
state_cache_3.c:17130:  struct sock *sk = skb->sk;
state_cache_3.c:17131:  if (skb->ip_summed == 1)
state_cache_3.c:17133:      skb->h.th->check = 0;
state_cache_3.c:17134:      skb->h.th->check =
state_cache_3.c:17135:	~tcp_v4_check (skb->h.th, skb->len, sk->saddr, sk->daddr, 0);
state_cache_3.c:17136:      skb->csum = ((size_t) & ((struct tcphdr *) 0)->check);
state_cache_3.c:17140:      skb->h.th->check = 0;
state_cache_3.c:17141:      skb->h.th->check =
state_cache_3.c:17142:	tcp_v4_check (skb->h.th, skb->len, sk->saddr, sk->daddr,
state_cache_3.c:17143:		      csum_partial ((char *) skb->h.th, headerLen,
state_cache_3.c:17144:				    skb->csum));
state_cache_3.c:17166:  POISONEDRANGE = -1,
state_cache_3.c:17203:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_3.c:17204:  if (!(dataReq->list == ((void *) 0)))
state_cache_3.c:17206:      printk ("KERNEL: assertion (" "dataReq->list == NULL" ") failed at "
state_cache_3.c:17210:  dataReq->completed = 0;
state_cache_3.c:17211:  dataReq->sent = 0;
state_cache_3.c:17212:  dataReq->transportResponseSeqStart = (4294967295U);
state_cache_3.c:17213:  dataReq->transportResponseSeqEnd = (4294967295U);
state_cache_3.c:17214:  dataReq->timestamp = (4294967295U);
state_cache_3.c:17215:  dataReq->start = newStart;
state_cache_3.c:17216:  dataReq->end = newEnd;
state_cache_3.c:17217:  insert_tail (&tp->t.missingDataMap, (struct alloc_head *) dataReq);
state_cache_3.c:17246:  newMapping->next = newMapping->prev = ((void *) 0);
state_cache_3.c:17247:  newMapping->list = ((void *) 0);
state_cache_3.c:17248:  newMapping->completed = 0;
state_cache_3.c:17249:  newMapping->ucont = ucont;
state_cache_3.c:17250:  newMapping->transportResponseSeqStart = tseq_start;
state_cache_3.c:17251:  newMapping->transportResponseSeqEnd = tseq_end;
state_cache_3.c:17252:  newMapping->sent = 0;
state_cache_3.c:17253:  newMapping->start = start;
state_cache_3.c:17254:  newMapping->end = end;
state_cache_3.c:17255:  newMapping->timestamp = jiffies;
state_cache_3.c:17262:  numDataRequestMappings--;
state_cache_3.c:17292:  req->numChildren = 0;
state_cache_3.c:17293:  req->childrenMask = 0;
state_cache_3.c:17294:  req->transport_seq = -1;
state_cache_3.c:17295:  req->seq = -1;
state_cache_3.c:17296:  req->isNew = 1;
state_cache_3.c:17301:  req->type = type;
state_cache_3.c:17302:  req->prev = req->next = ((void *) 0);
state_cache_3.c:17303:  req->list = ((void *) 0);
state_cache_3.c:17305:  req->start = req->end = -1;
state_cache_3.c:17306:  req->allocated = 1;
state_cache_3.c:17312:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_3.c:17313:  insert_tail (&tp->t.queuedRequests, (struct alloc_head *) req);
state_cache_3.c:17314:  tp->t.timerState |= (0x1);
state_cache_3.c:17351:  req->incomplete = 0;
state_cache_3.c:17352:  req->completePred = pred;
state_cache_3.c:17353:  atomic_inc (&req->completePred->refcnt);
state_cache_3.c:17354:  if (((&req->completePred->refcnt)->counter) < 2)
state_cache_3.c:17358:  req->data = data;
state_cache_3.c:17359:  req->start = start;
state_cache_3.c:17360:  req->offset = req->start - ((struct tcp_skb_cb *) &((data)->cb[0]))->seq;
state_cache_3.c:17369:  req->incomplete = 1;
state_cache_3.c:17370:  req->incompletePred = pred;
state_cache_3.c:17371:  req->predLength = predLength;
state_cache_3.c:17372:  req->data = data;
state_cache_3.c:17373:  req->offset = offset;
state_cache_3.c:17401:  req->start = start;
state_cache_3.c:17402:  req->end = end;
state_cache_3.c:17403:  req->numConts = numConts;
state_cache_3.c:17404:  req->conts = kmalloc (sizeof (struct UC_Continuation *) * numConts, (0x20));
state_cache_3.c:17409:      return -1;
state_cache_3.c:17423:  newReq->conts =
state_cache_3.c:17424:    kmalloc (sizeof (struct UC_Continuation *) * newReq->numConts, (0x20));
state_cache_3.c:17425:  if (newReq->conts == ((void *) 0))
state_cache_3.c:17430:  (__builtin_constant_p (sizeof (struct UC_Continuation *) * newReq->numConts)
state_cache_3.c:17431:   ? __constant_memcpy ((newReq->conts), (src->conts),
state_cache_3.c:17433:			 newReq->numConts)) : __memcpy ((newReq->conts),
state_cache_3.c:17434:							(src->conts),
state_cache_3.c:17438:							 newReq->numConts)));
state_cache_3.c:17464:  rval->prev = rval->next = ((void *) 0);
state_cache_3.c:17465:  rval->list = ((void *) 0);
state_cache_3.c:17466:  rval->cont = cont;
state_cache_3.c:17467:  rval->isSynack = isSynack;
state_cache_3.c:17468:  rval->parent = parent;
state_cache_3.c:17469:  rval->numSiblings = numSiblings;
state_cache_3.c:17470:  rval->position = position;
state_cache_3.c:17493:  dcont->clientState = scont->clientState;
state_cache_3.c:17494:  dcont->parent = scont->parent;
state_cache_3.c:17499:	(dcont)->seq = htonl ((scont)->packets[pktNum].seq);
state_cache_3.c:17500:	(dcont)->continuationType = (scont)->packets[pktNum].contType;
state_cache_3.c:17501:	if ((scont)->packets[pktNum].type & (0x80))
state_cache_3.c:17503:	(dcont)->firstChild = 1;}
state_cache_3.c:17506:	(dcont)->firstChild = 0;}
state_cache_3.c:17510:	int conversionOffset = (scont)->packets[pktNum].type & (0x3);
state_cache_3.c:17520:	(dcont)->state = stateConversionMap[conversionOffset];}
state_cache_3.c:17522:	  dcont->timestamp = htonl (scont->timestamp);
state_cache_3.c:17523:	  dcont->clientTimestamp = scont->clientTimestamp;
state_cache_3.c:17524:	  dcont->mrtt = htonl (scont->mrtt);
state_cache_3.c:17528:	  dcont->seq = htonl (scont->seq);
state_cache_3.c:17529:	  dcont->continuationType = scont->continuationType;
state_cache_3.c:17530:	  dcont->firstChild = scont->firstChild;
state_cache_3.c:17531:	  dcont->state = scont->state;
state_cache_3.c:17532:	  dcont->timestamp = scont->rawTimestamp;
state_cache_3.c:17533:	  dcont->clientTimestamp = scont->clientTimestamp;
state_cache_3.c:17534:	  dcont->mrtt = scont->rawMrtt;
state_cache_3.c:17536:	dcont->firstLoss = htonl (scont->firstLoss);
state_cache_3.c:17537:	dcont->firstBootstrapSeq = htonl (scont->firstBootstrapSeq);
state_cache_3.c:17538:	dcont->startCwnd = htonl (scont->startCwnd);
state_cache_3.c:17539:	dcont->ssthresh = htonl (scont->ssthresh);
state_cache_3.c:17540:	dcont->TCPBase = htonl (scont->TCPBase);
state_cache_3.c:17541:	dcont->tokenCounterBase = scont->tokenCounterBase;
state_cache_3.c:17545:	    phdr->seq = dcont->seq;
state_cache_3.c:17546:	    phdr->type = dcont->continuationType;
state_cache_3.c:17547:	    phdr->first = dcont->firstChild ? 1 : 0;
state_cache_3.c:17548:	    phdr->serverAddr = scont->saddr;
state_cache_3.c:17549:	    phdr->serverPort = scont->source;
state_cache_3.c:17550:	    phdr->clientAddr = scont->daddr;
state_cache_3.c:17551:	    phdr->clientPort = scont->dest;
state_cache_3.c:17552:	    computeMAC (sk, phdr, dcont, dcont->mac);
state_cache_3.c:17563:	dcont->clientState = scont->clientState;
state_cache_3.c:17564:	dcont->parent = scont->parent;
state_cache_3.c:17569:	      (dcont)->seq = htonl ((scont)->packets[pktNum].seq);
state_cache_3.c:17570:	      (dcont)->continuationType = (scont)->packets[pktNum].contType;
state_cache_3.c:17571:	      if ((scont)->packets[pktNum].type & (0x80))
state_cache_3.c:17573:	      (dcont)->firstChild = 1;}
state_cache_3.c:17576:	      (dcont)->firstChild = 0;}
state_cache_3.c:17580:	      int conversionOffset = (scont)->packets[pktNum].type & (0x3);
state_cache_3.c:17590:	      (dcont)->state = stateConversionMap[conversionOffset];}
state_cache_3.c:17592:		dcont->timestamp = htonl (scont->timestamp);
state_cache_3.c:17593:		dcont->clientTimestamp = scont->clientTimestamp;
state_cache_3.c:17594:		dcont->mrtt = htonl (scont->mrtt);
state_cache_3.c:17598:		dcont->seq = htonl (scont->seq);
state_cache_3.c:17599:		dcont->continuationType = scont->continuationType;
state_cache_3.c:17600:		dcont->firstChild = scont->firstChild;
state_cache_3.c:17601:		dcont->state = scont->state;
state_cache_3.c:17602:		dcont->timestamp = scont->rawTimestamp;
state_cache_3.c:17603:		dcont->clientTimestamp = scont->clientTimestamp;
state_cache_3.c:17604:		dcont->mrtt = scont->rawMrtt;
state_cache_3.c:17606:	      dcont->firstLoss = htonl (scont->firstLoss);
state_cache_3.c:17607:	      dcont->firstBootstrapSeq = htonl (scont->firstBootstrapSeq);
state_cache_3.c:17608:	      dcont->startCwnd = htonl (scont->startCwnd);
state_cache_3.c:17609:	      dcont->ssthresh = htonl (scont->ssthresh);
state_cache_3.c:17610:	      dcont->TCPBase = htonl (scont->TCPBase);
state_cache_3.c:17611:	      dcont->tokenCounterBase = scont->tokenCounterBase;
state_cache_3.c:17615:		   __constant_memcpy ((dcont->mac), (scont->mac),
state_cache_3.c:17616:				      (16)) : __memcpy ((dcont->mac),
state_cache_3.c:17617:							(scont->mac), (16)));
state_cache_3.c:17628:	      dcont->clientState = scont->clientState;
state_cache_3.c:17629:	      dcont->parent = scont->parent;
state_cache_3.c:17634:		    (dcont)->seq = htonl ((scont)->packets[pktNum].seq);
state_cache_3.c:17635:		    (dcont)->continuationType =
state_cache_3.c:17636:		    (scont)->packets[pktNum].contType;
state_cache_3.c:17637:		    if ((scont)->packets[pktNum].type & (0x80))
state_cache_3.c:17639:		    (dcont)->firstChild = 1;}
state_cache_3.c:17642:		    (dcont)->firstChild = 0;}
state_cache_3.c:17647:		    (scont)->packets[pktNum].type & (0x3);
state_cache_3.c:17657:		    (dcont)->state = stateConversionMap[conversionOffset];}
state_cache_3.c:17659:		      dcont->timestamp = htonl (scont->timestamp);
state_cache_3.c:17660:		      dcont->clientTimestamp = scont->clientTimestamp;
state_cache_3.c:17661:		      dcont->mrtt = htonl (scont->mrtt);
state_cache_3.c:17665:		      dcont->seq = htonl (scont->seq);
state_cache_3.c:17666:		      dcont->continuationType = scont->continuationType;
state_cache_3.c:17667:		      dcont->firstChild = scont->firstChild;
state_cache_3.c:17668:		      dcont->state = scont->state;
state_cache_3.c:17669:		      dcont->timestamp = scont->rawTimestamp;
state_cache_3.c:17670:		      dcont->clientTimestamp = scont->clientTimestamp;
state_cache_3.c:17671:		      dcont->mrtt = scont->rawMrtt;
state_cache_3.c:17673:		    dcont->firstLoss = htonl (scont->firstLoss);
state_cache_3.c:17674:		    dcont->firstBootstrapSeq =
state_cache_3.c:17675:		      htonl (scont->firstBootstrapSeq);
state_cache_3.c:17676:		    dcont->startCwnd = htonl (scont->startCwnd);
state_cache_3.c:17677:		    dcont->ssthresh = htonl (scont->ssthresh);
state_cache_3.c:17678:		    dcont->TCPBase = htonl (scont->TCPBase);
state_cache_3.c:17679:		    dcont->tokenCounterBase = scont->tokenCounterBase;
state_cache_3.c:17683:			 __constant_memcpy ((dcont->mac), (scont->mac),
state_cache_3.c:17684:					    (16)) : __memcpy ((dcont->mac),
state_cache_3.c:17685:							      (scont->mac),
state_cache_3.c:17695:		    dproof->numSacks = (
state_cache_3.c:17697:					 typeof (sproof->numSacks) Z =
state_cache_3.c:17698:					 (typeof (sproof->numSacks)) (64);
state_cache_3.c:17701:					   const typeof (sproof->
state_cache_3.c:17703:					   (sproof->numSacks);
state_cache_3.c:17709:		    for (i = 0; i < dproof->numSacks; i++)
state_cache_3.c:17711:			dproof->sacks[i].left =
state_cache_3.c:17712:			  htonl (sproof->sacks[i].left);;
state_cache_3.c:17713:			dproof->sacks[i].right =
state_cache_3.c:17714:			  htonl (sproof->sacks[i].right);;
state_cache_3.c:17715:			dproof->sacks[i].nonceSummary =
state_cache_3.c:17716:			  sproof->sacks[i].nonceSummary;
state_cache_3.c:17733:			    ((!(((skb->sk)->tp_pinfo.af_tcp.
state_cache_3.c:17735:				&& !((skb->sk)->tp_pinfo.af_tcp.
state_cache_3.c:17736:				     trickles_opt & (skb->sk)->tp_pinfo.
state_cache_3.c:17741:			    phdr->seq = scont->seq;
state_cache_3.c:17742:			    phdr->type = scont->continuationType;
state_cache_3.c:17743:			    phdr->first = scont->firstChild;
state_cache_3.c:17744:			    phdr->serverAddr = skb->nh.iph->daddr;
state_cache_3.c:17745:			    phdr->serverPort = skb->h.th->dest;
state_cache_3.c:17746:			    phdr->clientAddr = skb->nh.iph->saddr;
state_cache_3.c:17747:			    phdr->clientPort = skb->h.th->source;
state_cache_3.c:17748:			    computeMAC (skb->sk, phdr, scont, mac);
state_cache_3.c:17749:			    if (__builtin_memcmp (mac, scont->mac, 16))
state_cache_3.c:17757:		    dcont->continuationType = scont->continuationType;
state_cache_3.c:17758:		    dcont->seq = ntohl (scont->seq);;
state_cache_3.c:17759:		    dcont->clientState = scont->clientState;
state_cache_3.c:17760:		    dcont->parent = scont->parent;
state_cache_3.c:17761:		    dcont->rawTimestamp = scont->timestamp;
state_cache_3.c:17762:		    dcont->timestamp = ntohl (scont->timestamp);
state_cache_3.c:17763:		    dcont->rawMrtt = scont->mrtt;
state_cache_3.c:17764:		    dcont->mrtt = ntohl (scont->rawMrtt);;
state_cache_3.c:17765:		    dcont->clientTimestamp = scont->clientTimestamp;
state_cache_3.c:17766:		    dcont->state = scont->state;
state_cache_3.c:17767:		    dcont->firstChild = scont->firstChild;
state_cache_3.c:17768:		    dcont->firstLoss = ntohl (scont->firstLoss);;
state_cache_3.c:17769:		    dcont->firstBootstrapSeq =
state_cache_3.c:17770:		      ntohl (scont->firstBootstrapSeq);;
state_cache_3.c:17771:		    dcont->startCwnd = ntohl (scont->startCwnd);;
state_cache_3.c:17772:		    dcont->ssthresh = ntohl (scont->ssthresh);;
state_cache_3.c:17773:		    dcont->TCPBase = ntohl (scont->TCPBase);;
state_cache_3.c:17775:			((!(((skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
state_cache_3.c:17776:			    && !((skb->sk)->tp_pinfo.af_tcp.
state_cache_3.c:17777:				 trickles_opt & (skb->sk)->tp_pinfo.af_tcp.
state_cache_3.c:17780:			dcont->saddr = skb->nh.iph->daddr;
state_cache_3.c:17781:			dcont->daddr = skb->nh.iph->saddr;
state_cache_3.c:17782:			dcont->source = skb->h.th->dest;
state_cache_3.c:17783:			dcont->dest = skb->h.th->source;
state_cache_3.c:17785:		    dcont->tokenCounterBase = scont->tokenCounterBase;
state_cache_3.c:17786:		    dcont->num_packets = 0;
state_cache_3.c:17787:		    dcont->numChildrenReceived = 0;
state_cache_3.c:17788:		    dcont->parentMSK = ((void *) 0);;
state_cache_3.c:17804:			    ((!(((skb->sk)->tp_pinfo.af_tcp.
state_cache_3.c:17806:				&& !((skb->sk)->tp_pinfo.af_tcp.
state_cache_3.c:17807:				     trickles_opt & (skb->sk)->tp_pinfo.
state_cache_3.c:17812:			    phdr->seq = scont->seq;
state_cache_3.c:17813:			    phdr->type = scont->continuationType;
state_cache_3.c:17814:			    phdr->first = scont->firstChild;
state_cache_3.c:17815:			    phdr->serverAddr = skb->nh.iph->daddr;
state_cache_3.c:17816:			    phdr->serverPort = skb->h.th->dest;
state_cache_3.c:17817:			    phdr->clientAddr = skb->nh.iph->saddr;
state_cache_3.c:17818:			    phdr->clientPort = skb->h.th->source;
state_cache_3.c:17819:			    computeMAC (skb->sk, phdr, scont, mac);
state_cache_3.c:17820:			    if (__builtin_memcmp (mac, scont->mac, 16))
state_cache_3.c:17828:		    dcont->continuationType = scont->continuationType;
state_cache_3.c:17829:		    dcont->seq = ntohl (scont->seq);;
state_cache_3.c:17830:		    dcont->clientState = scont->clientState;
state_cache_3.c:17831:		    dcont->parent = scont->parent;
state_cache_3.c:17832:		    dcont->rawTimestamp = scont->timestamp;
state_cache_3.c:17833:		    dcont->rawMrtt = scont->mrtt;;
state_cache_3.c:17834:		    dcont->clientTimestamp = scont->clientTimestamp;
state_cache_3.c:17835:		    dcont->state = scont->state;
state_cache_3.c:17836:		    dcont->firstChild = scont->firstChild;
state_cache_3.c:17837:		    dcont->firstLoss = ntohl (scont->firstLoss);;
state_cache_3.c:17838:		    dcont->firstBootstrapSeq =
state_cache_3.c:17839:		      ntohl (scont->firstBootstrapSeq);;
state_cache_3.c:17840:		    dcont->startCwnd = ntohl (scont->startCwnd);;
state_cache_3.c:17841:		    dcont->ssthresh = ntohl (scont->ssthresh);;
state_cache_3.c:17842:		    dcont->TCPBase = ntohl (scont->TCPBase);;
state_cache_3.c:17843:		    dcont->daddr = skb->nh.iph->saddr;
state_cache_3.c:17844:		    dcont->dest = skb->h.th->source;;
state_cache_3.c:17845:		    dcont->tokenCounterBase = scont->tokenCounterBase;
state_cache_3.c:17846:		    dcont->num_packets = 0;;
state_cache_3.c:17856:		    dcont->continuationType = scont->continuationType;
state_cache_3.c:17857:		    dcont->seq = scont->seq;
state_cache_3.c:17858:		    dcont->clientState = scont->clientState;
state_cache_3.c:17859:		    dcont->parent = scont->parent;
state_cache_3.c:17861:		    dcont->timestamp = ntohl (scont->rawTimestamp);
state_cache_3.c:17863:		    dcont->mrtt = ntohl (scont->rawMrtt);;
state_cache_3.c:17864:		    dcont->clientTimestamp = scont->clientTimestamp;
state_cache_3.c:17865:		    dcont->state = scont->state;
state_cache_3.c:17866:		    dcont->firstChild = scont->firstChild;
state_cache_3.c:17867:		    dcont->firstLoss = scont->firstLoss;
state_cache_3.c:17868:		    dcont->firstBootstrapSeq = scont->firstBootstrapSeq;
state_cache_3.c:17869:		    dcont->startCwnd = scont->startCwnd;
state_cache_3.c:17870:		    dcont->ssthresh = scont->ssthresh;
state_cache_3.c:17871:		    dcont->TCPBase = scont->TCPBase;
state_cache_3.c:17872:		    dcont->saddr = sk->saddr;
state_cache_3.c:17873:		    dcont->source = sk->sport;
state_cache_3.c:17874:		    dcont->daddr = scont->daddr;
state_cache_3.c:17875:		    dcont->dest = scont->dest;;
state_cache_3.c:17876:		    dcont->tokenCounterBase = scont->tokenCounterBase;
state_cache_3.c:17877:		    dcont->num_packets = 0;;
state_cache_3.c:17887:		    dcont->continuationType = scont->continuationType;
state_cache_3.c:17888:		    dcont->seq = scont->seq;
state_cache_3.c:17889:		    dcont->clientState = scont->clientState;
state_cache_3.c:17890:		    dcont->parent = scont->parent;
state_cache_3.c:17893:		    dcont->clientTimestamp = scont->clientTimestamp;
state_cache_3.c:17894:		    dcont->state = scont->state;
state_cache_3.c:17895:		    dcont->firstChild = scont->firstChild;
state_cache_3.c:17896:		    dcont->firstLoss = scont->firstLoss;
state_cache_3.c:17897:		    dcont->firstBootstrapSeq = scont->firstBootstrapSeq;
state_cache_3.c:17898:		    dcont->startCwnd = scont->startCwnd;
state_cache_3.c:17899:		    dcont->ssthresh = scont->ssthresh;
state_cache_3.c:17900:		    dcont->TCPBase = scont->TCPBase;
state_cache_3.c:17901:		    dcont->daddr = scont->daddr;
state_cache_3.c:17902:		    dcont->dest = scont->dest;;
state_cache_3.c:17903:		    dcont->tokenCounterBase = scont->tokenCounterBase;
state_cache_3.c:17904:		    dcont->num_packets = 0;;
state_cache_3.c:17920:			 __constant_memcpy ((dcont->mac), (scont->mac),
state_cache_3.c:17921:					    (16)) : __memcpy ((dcont->mac),
state_cache_3.c:17922:							      (scont->mac),
state_cache_3.c:17926:		    dcont->continuationType = scont->continuationType;
state_cache_3.c:17927:		    dcont->seq = ntohl (scont->seq);;
state_cache_3.c:17928:		    dcont->clientState = scont->clientState;
state_cache_3.c:17929:		    dcont->parent = scont->parent;
state_cache_3.c:17930:		    dcont->rawTimestamp = scont->timestamp;
state_cache_3.c:17931:		    dcont->timestamp = ntohl (scont->timestamp);
state_cache_3.c:17932:		    dcont->rawMrtt = scont->mrtt;
state_cache_3.c:17933:		    dcont->mrtt = ntohl (scont->rawMrtt);;
state_cache_3.c:17934:		    dcont->clientTimestamp = scont->clientTimestamp;
state_cache_3.c:17935:		    dcont->state = scont->state;
state_cache_3.c:17936:		    dcont->firstChild = scont->firstChild;
state_cache_3.c:17937:		    dcont->firstLoss = ntohl (scont->firstLoss);;
state_cache_3.c:17938:		    dcont->firstBootstrapSeq =
state_cache_3.c:17939:		      ntohl (scont->firstBootstrapSeq);;
state_cache_3.c:17940:		    dcont->startCwnd = ntohl (scont->startCwnd);;
state_cache_3.c:17941:		    dcont->ssthresh = ntohl (scont->ssthresh);;
state_cache_3.c:17942:		    dcont->TCPBase = ntohl (scont->TCPBase);;
state_cache_3.c:17944:			((!(((skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
state_cache_3.c:17945:			    && !((skb->sk)->tp_pinfo.af_tcp.
state_cache_3.c:17946:				 trickles_opt & (skb->sk)->tp_pinfo.af_tcp.
state_cache_3.c:17949:			dcont->saddr = skb->nh.iph->daddr;
state_cache_3.c:17950:			dcont->daddr = skb->nh.iph->saddr;
state_cache_3.c:17951:			dcont->source = skb->h.th->dest;
state_cache_3.c:17952:			dcont->dest = skb->h.th->source;
state_cache_3.c:17954:		    dcont->tokenCounterBase = scont->tokenCounterBase;
state_cache_3.c:17955:		    dcont->num_packets = 0;
state_cache_3.c:17956:		    dcont->numChildrenReceived = 0;
state_cache_3.c:17957:		    dcont->parentMSK = ((void *) 0);;
state_cache_3.c:17967:		    for (i = 0; i < (((cont) + 1)->num_packets); i++)
state_cache_3.c:17969:			total += (((cont) + 1)->packets)[i].len;
state_cache_3.c:17993:		    rval->prev = rval->next = ((void *) 0);
state_cache_3.c:17994:		    rval->list = ((void *) 0);
state_cache_3.c:17997:			(rval + i)->ucont_len = 0;
state_cache_3.c:17998:			(rval + i)->ucont_data = ((void *) 0);
state_cache_3.c:17999:			(rval + i)->input_len = 0;
state_cache_3.c:18000:			(rval + i)->input = ((void *) 0);
state_cache_3.c:18001:			(rval + i)->mark = 0;
state_cache_3.c:18002:			(rval + i)->simulated = 0;
state_cache_3.c:18004:		    rval->sk = ((void *) 0);
state_cache_3.c:18035:		    rval->prev = rval->next = ((void *) 0);
state_cache_3.c:18036:		    rval->list = ((void *) 0);
state_cache_3.c:18038:		     ((int) ((struct cminisock *) 0)->
state_cache_3.c:18044:								   *) 0)->
state_cache_3.c:18047:				 ((int) ((struct cminisock *) 0)->
state_cache_3.c:18051:			(rval + i)->ucont_len = 0;
state_cache_3.c:18052:			(rval + i)->ucont_data = ((void *) 0);
state_cache_3.c:18053:			(rval + i)->input_len = 0;
state_cache_3.c:18054:			(rval + i)->input = ((void *) 0);
state_cache_3.c:18055:			(rval + i)->mark = 0;
state_cache_3.c:18056:			(rval + i)->simulated = 0;
state_cache_3.c:18057:			(rval + i)->num_packets = 0;
state_cache_3.c:18058:			(rval + i)->actualCwnd = 0;
state_cache_3.c:18067:		    if (cont->list)
state_cache_3.c:18082:			if ((cont + i)->ucont_data)
state_cache_3.c:18083:			  kfree ((cont + i)->ucont_data);
state_cache_3.c:18084:			if ((cont + i)->input)
state_cache_3.c:18085:			  kfree ((cont + i)->input);
state_cache_3.c:18094:		    dproof->numSacks = sproof->numSacks;
state_cache_3.c:18095:		    for (i = 0; i < sproof->numSacks; i++)
state_cache_3.c:18097:			dproof->sacks[i].left =
state_cache_3.c:18098:			  ntohl (sproof->sacks[i].left);;
state_cache_3.c:18099:			dproof->sacks[i].right =
state_cache_3.c:18100:			  ntohl (sproof->sacks[i].right);;
state_cache_3.c:18101:			dproof->sacks[i].nonceSummary =
state_cache_3.c:18102:			  sproof->sacks[i].nonceSummary;
state_cache_3.c:18110:		      length - sizeof (struct WireUC_Continuation);
state_cache_3.c:18120:		    rval->prev = rval->next = ((void *) 0);
state_cache_3.c:18121:		    rval->list = ((void *) 0);
state_cache_3.c:18122:		    rval->seq = ntohl (scont->seq);
state_cache_3.c:18123:		    rval->validStart = ntohl (scont->validStart);
state_cache_3.c:18124:		    rval->validEnd = ntohl (scont->validEnd);
state_cache_3.c:18125:		    rval->fields = scont->fields;
state_cache_3.c:18126:		    rval->dataLen = dataLen;
state_cache_3.c:18127:		    rval->kernel.obsoleteAt = rval->validEnd;
state_cache_3.c:18129:		     __constant_memcpy ((rval->kernel.data), (scont->data),
state_cache_3.c:18130:					(dataLen)) : __memcpy ((rval->kernel.
state_cache_3.c:18132:							       (scont->data),
state_cache_3.c:18143:		    int dataLen = scont->dataLen;
state_cache_3.c:18144:		    dcont->seq = htonl (scont->seq);
state_cache_3.c:18145:		    dcont->validStart = htonl (scont->validStart);
state_cache_3.c:18146:		    dcont->validEnd = htonl (scont->validEnd);
state_cache_3.c:18147:		    dcont->fields = scont->fields;
state_cache_3.c:18149:		     __constant_memcpy ((dcont->data), (scont->kernel.data),
state_cache_3.c:18150:					(dataLen)) : __memcpy ((dcont->data),
state_cache_3.c:18151:							       (scont->kernel.
state_cache_3.c:18174:		    completeResp->fields |= (0x01);
state_cache_3.c:18179:		    int dataLen = scont->dataLen;
state_cache_3.c:18189:		    rval->prev = rval->next = ((void *) 0);
state_cache_3.c:18190:		    rval->list = ((void *) 0);
state_cache_3.c:18192:		     __constant_memcpy ((rval->kernel.data),
state_cache_3.c:18193:					(scont->kernel.data),
state_cache_3.c:18194:					(dataLen)) : __memcpy ((rval->kernel.
state_cache_3.c:18196:							       (scont->kernel.
state_cache_3.c:18234:		    return -1;
state_cache_3.c:18290:		    return -1;
state_cache_3.c:18296:		    wireContinuation->fields = 0;
state_cache_3.c:18302:		    char *rval = wireContinuation->data;
state_cache_3.c:18303:		    if (wireContinuation->fields & (0x01))
state_cache_3.c:18318:		    if (wireContinuation->fields & ~((0x01)))
state_cache_3.c:18341:		    resp->type = type;
state_cache_3.c:18342:		    resp->error = error;
state_cache_3.c:18343:		    resp->len = htons ((short) len);
state_cache_3.c:18360:		    incompleteResp->ack_seq = htonl (ack_seq);
state_cache_3.c:18361:		    incompleteResp->newCont.validStart = htonl (validStart);
state_cache_3.c:18379:		    completeResp->ack_seq = htonl (ack_seq);
state_cache_3.c:18380:		    completeResp->newCont.seq = htonl (seq);
state_cache_3.c:18381:		    completeResp->newCont.validStart = htonl (validStart);
state_cache_3.c:18382:		    completeResp->newCont.validEnd = htonl (validEnd);
state_cache_3.c:18383:		    completeResp->newCont.fields = 0;
state_cache_3.c:18402:		    newContinuationResp->newCont.seq = htonl (seq);
state_cache_3.c:18403:		    newContinuationResp->newCont.validStart =
state_cache_3.c:18405:		    newContinuationResp->newCont.validEnd = htonl (validEnd);
state_cache_3.c:18406:		    newContinuationResp->newCont.fields = 0;
state_cache_3.c:18412:		    printk ("seq=[%d]\n", ucont->seq);
state_cache_3.c:18413:		    printk ("valid=[%d-%d] [%d-%d]\n", ucont->validStart,
state_cache_3.c:18414:			    ucont->validEnd, htonl (ucont->validStart),
state_cache_3.c:18415:			    htonl (ucont->validEnd));
state_cache_3.c:18416:		    printk ("cvalid=[%d-%d] [%d-%d]\n",
state_cache_3.c:18417:			    ucont->clientValidStart, ucont->clientValidEnd,
state_cache_3.c:18418:			    htonl (ucont->clientValidStart),
state_cache_3.c:18419:			    htonl (ucont->clientValidEnd));
state_cache_3.c:18432:		    chunk->byteNum = htonl (byteNum);
state_cache_3.c:18433:		    chunk->type = RCHUNK_DATA;
state_cache_3.c:18434:		    chunk->chunkLen =
state_cache_3.c:18436:		    return (struct DataChunk *) (chunk->data + chunkLen);
state_cache_3.c:18444:		    phchunk->type = RCHUNK_PUSH_HINT;
state_cache_3.c:18445:		    phchunk->chunkLen = htons (sizeof (struct PushHintChunk));
state_cache_3.c:18446:		    phchunk->start = htonl (start);
state_cache_3.c:18447:		    phchunk->end = htonl (end);
state_cache_3.c:18465:		    ctx->packetNum = 0;
state_cache_3.c:18466:		    ctx->packetPos = 0;
state_cache_3.c:18467:		    ctx->outputPos = ctx->outputStart = dest;
state_cache_3.c:18468:		    ctx->packets = packets;
state_cache_3.c:18469:		    ctx->numPackets = numPackets;
state_cache_3.c:18477:		    for (i = 0; i < ctx->numPackets; i++)
state_cache_3.c:18479:			printk ("Packet [%d] = %d\n", i, ctx->packets[i].len);
state_cache_3.c:18488:		       ctx->packetNum, ctx->packetPos, ctx->outputPos,
state_cache_3.c:18489:		       ctx->numPackets, ctx->packets);
state_cache_3.c:18496:		    if (ctx->packetNum >= ctx->numPackets)
state_cache_3.c:18500:		    return ctx->packets[ctx->packetNum].len - ctx->packetPos;
state_cache_3.c:18507:		      return ctx->outputPos;
state_cache_3.c:18510:			if (ctx->packetNum >= ctx->numPackets)
state_cache_3.c:18516:		    if (!(ctx->packetNum <= ctx->numPackets))
state_cache_3.c:18518:			if (!(ctx->packetNum <= ctx->numPackets))
state_cache_3.c:18521:				    "ctx->packetNum <= ctx->numPackets"
state_cache_3.c:18526:			printk ("%d !<= %d\n", ctx->packetNum,
state_cache_3.c:18527:				ctx->numPackets);
state_cache_3.c:18535:			if (!(numBytes <= ctx->packets[ctx->packetNum].len))
state_cache_3.c:18538:				    "numBytes <= ctx->packets[ctx->packetNum].len"
state_cache_3.c:18543:			ctx->outputPos +=
state_cache_3.c:18544:			  ctx->packets[ctx->packetNum].len - ctx->packetPos;
state_cache_3.c:18545:			ctx->packetPos = 0;
state_cache_3.c:18546:			ctx->packetNum++;
state_cache_3.c:18548:		    temp = ctx->outputPos;
state_cache_3.c:18549:		    ctx->packetPos += numBytes;
state_cache_3.c:18550:		    ctx->outputPos += numBytes;
state_cache_3.c:18553:			if (ctx->packetNum >= ctx->numPackets)
state_cache_3.c:18559:		    if (!(ctx->packetPos <= ctx->packets[ctx->packetNum].len))
state_cache_3.c:18562:				"ctx->packetPos <= ctx->packets[ctx->packetNum].len"
state_cache_3.c:18567:		    if (ctx->packetPos == ctx->packets[ctx->packetNum].len)
state_cache_3.c:18569:			ctx->packetPos = 0;
state_cache_3.c:18570:			ctx->packetNum++;
state_cache_3.c:18581:		    char *currpos = ctx->outputPos;
state_cache_3.c:18616:			return -1;
state_cache_3.c:18627:		    while ((char *) (chunk + 1) - start < len)
state_cache_3.c:18630:			  ntohs ((chunk)->chunkLen) -
state_cache_3.c:18635:			      printk ("bad length chunk(%d) -- ", len);
state_cache_3.c:18646:				     ntohs ((chunk)->chunkLen)));
state_cache_3.c:18653:			    return -1;
state_cache_3.c:18656:		    if ((char *) chunk - start > len)
state_cache_3.c:18659:				(char *) chunk - start, len);
state_cache_3.c:18660:			return -chunknum - 1;
state_cache_3.c:18673:		    if (!(gctx->packetNum <= gctx->numPackets))
state_cache_3.c:18676:				"gctx->packetNum <= gctx->numPackets"
state_cache_3.c:18683:		    int outputLen = gctx->outputPos - gctx->outputStart;
state_cache_3.c:18684:		    char *buf = gctx->outputStart;
state_cache_3.c:18690:			(entry->prev == ((void *) 0)
state_cache_3.c:18691:			 && entry->next == ((void *) 0)
state_cache_3.c:18692:			 && entry->list == ((void *) 0)))
state_cache_3.c:18695:				"entry->prev == NULL && entry->next == NULL && entry->list == NULL"
state_cache_3.c:18700:		    freeClientSide_Continuation (entry->cont);
state_cache_3.c:18712:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
state_cache_3.c:18713:		    tp->trickles_opt = 0;
state_cache_3.c:18714:		    tp->mac_changed = 0;
state_cache_3.c:18718:			  ((sizeof (tp->cminisock_api_config))) ?
state_cache_3.c:18719:			  __constant_c_and_count_memset (((&tp->
state_cache_3.c:18725:							   (tp->
state_cache_3.c:18728:			  __constant_c_memset (((&tp->cminisock_api_config)),
state_cache_3.c:18732:						 (tp->
state_cache_3.c:18735:			  ((sizeof (tp->cminisock_api_config))) ?
state_cache_3.c:18736:			  __memset_generic ((((&tp->cminisock_api_config))),
state_cache_3.c:18739:					       (tp->
state_cache_3.c:18741:			  __memset_generic (((&tp->cminisock_api_config)),
state_cache_3.c:18744:					      (tp->cminisock_api_config))))));
state_cache_3.c:18745:		      init_head (&tp->cminisock_api_config.msk_freelist);
state_cache_3.c:18746:		      tp->cminisock_api_config.cfg.ctl = ((void *) 0);
state_cache_3.c:18747:		      tp->cminisock_api_config.event_lock = (rwlock_t)
state_cache_3.c:18751:		    tp->t.malloc_initialized = 0;
state_cache_3.c:18752:		    tp->t.heapbytesize = 0;
state_cache_3.c:18753:		    tp->t.heapbytesallocated = 0;
state_cache_3.c:18756:			tp->t.fragblocks[i] = 0;
state_cache_3.c:18757:			tp->t.fraghead[i].next = tp->t.fraghead[i].prev =
state_cache_3.c:18760:		    tp->t.clientStateCounter = 0;
state_cache_3.c:18761:		    tp->t.state = 1;
state_cache_3.c:18762:		    tp->t.A = 0;
state_cache_3.c:18763:		    tp->t.D = 0;
state_cache_3.c:18764:		    tp->t.RTO = 0;
state_cache_3.c:18765:		    tp->t.timerState = 0;
state_cache_3.c:18766:		    tp->t.rcv_nxt = 0;
state_cache_3.c:18767:		    tp->t.previous_base = 0;
state_cache_3.c:18768:		    skb_queue_head_init (&tp->t.ofo_queue);
state_cache_3.c:18769:		    tp->t.ack_prev = ((void *) 0);
state_cache_3.c:18770:		    tp->t.ack_last = 0;
state_cache_3.c:18771:		    tp->t.oo_count = 0;
state_cache_3.c:18772:		    tp->t.in_flight = 0;
state_cache_3.c:18773:		    tp->t.standardProof.numSacks = 0;
state_cache_3.c:18774:		    tp->t.altProof.numSacks = 0;
state_cache_3.c:18775:		    tp->t.dprev = tp->t.dnext = ((void *) 0);
state_cache_3.c:18776:		    tp->t.dbg_skb = ((void *) 0);
state_cache_3.c:18777:		    init_head (&tp->t.cont_list);
state_cache_3.c:18778:		    init_timer (&tp->t.slowstart_timer);
state_cache_3.c:18779:		    tp->t.request_rcv_nxt = 0;
state_cache_3.c:18780:		    tp->t.request_snd_nxt = 0;
state_cache_3.c:18781:		    init_head (&tp->t.request_ofo_queue);
state_cache_3.c:18782:		    skb_queue_head_init (&tp->t.data_ofo_queue);
state_cache_3.c:18783:		    init_head (&tp->t.sentRequests);
state_cache_3.c:18784:		    init_head (&tp->t.queuedRequests);
state_cache_3.c:18785:		    init_head (&tp->t.dataRequestMap);
state_cache_3.c:18786:		    init_head (&tp->t.missingDataMap);
state_cache_3.c:18787:		    tp->t.byteReqNext = 0;
state_cache_3.c:18788:		    tp->t.byteReqHint = ((void *) 0);
state_cache_3.c:18789:		    tp->t.conversionState = (1);
state_cache_3.c:18790:		    tp->t.snd_una = tp->t.write_seq = 0;
state_cache_3.c:18791:		    tp->t.snd_end = 0;
state_cache_3.c:18792:		    skb_queue_head_init (&tp->t.requestBytes);
state_cache_3.c:18793:		    tp->t.newIncompleteRequest = ((void *) 0);
state_cache_3.c:18794:		    tp->t.prevConvCont = ((void *) 0);
state_cache_3.c:18795:		    init_head (&tp->t.ucontList);
state_cache_3.c:18796:		    init_head (&tp->t.depNodeList);
state_cache_3.c:18797:		    tp->t.nonceCTX = ((void *) 0);
state_cache_3.c:18798:		    skb_queue_head_init (&tp->t.prequeueOverflow);
state_cache_3.c:18799:		    skb_queue_head_init (&tp->t.sendAckOverflow);
state_cache_3.c:18800:		    skb_queue_head_init (&tp->t.recycleList);
state_cache_3.c:18801:		    tp->t.responseMSK = ((void *) 0);
state_cache_3.c:18802:		    init_head (&tp->t.responseList);
state_cache_3.c:18803:		    tp->t.responseCount = 0;
state_cache_3.c:18804:		    tp->t.events = ((void *) 0);
state_cache_3.c:18805:		    tp->drop_rate = 0;
state_cache_3.c:18806:		    tp->instrumentation = 0;
state_cache_3.c:18810:		    msk->num_packets = 0;
state_cache_3.c:18811:		    msk->ucont_len = 0;
state_cache_3.c:18812:		    msk->ucont_data = ((void *) 0);
state_cache_3.c:18813:		    msk->input_len = 0;
state_cache_3.c:18814:		    msk->input = ((void *) 0);
state_cache_3.c:18815:		    msk->packets = ((void *) 0);
state_cache_3.c:18816:		    msk->refCnt = 1;
state_cache_3.c:18817:		    msk->cacheRecycleIndex = -1;
state_cache_3.c:18818:		    msk->serverSK = ((void *) 0);
state_cache_3.c:18819:		    msk->pmsk = ((void *) 0);
state_cache_3.c:18820:		    msk->isStatic = 0;
state_cache_3.c:18824:		    pmsk->num_packets = 0;
state_cache_3.c:18825:		    pmsk->ucont_len = 0;
state_cache_3.c:18826:		    pmsk->ucont_data = ((void *) 0);
state_cache_3.c:18827:		    pmsk->input_len = 0;
state_cache_3.c:18828:		    pmsk->input = ((void *) 0);
state_cache_3.c:18829:		    pmsk->packets = ((void *) 0);
state_cache_3.c:18830:		    pmsk->refCnt = 1;
state_cache_3.c:18841:		    msk->num_packets = 0;
state_cache_3.c:18842:		    msk->packets = ((void *) 0);
state_cache_3.c:18843:		    msk->ucont_len = 0;
state_cache_3.c:18844:		    msk->ucont_data = ((void *) 0);
state_cache_3.c:18845:		    msk->input_len = 0;
state_cache_3.c:18846:		    msk->input = ((void *) 0);
state_cache_3.c:18851:		    if (!(msk->num_packets == 0))
state_cache_3.c:18853:			printk ("KERNEL: assertion (" "msk->num_packets == 0"
state_cache_3.c:18867:			(((msk->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
state_cache_3.c:18868:			 && !((msk->sk)->tp_pinfo.af_tcp.
state_cache_3.c:18869:			      trickles_opt & (msk->sk)->tp_pinfo.af_tcp.
state_cache_3.c:18872:			msk->packets =
state_cache_3.c:18873:			  tmalloc (msk->sk,
state_cache_3.c:18876:			if (msk->packets == ((void *) 0))
state_cache_3.c:18890:			    msk->packets = packets[0];
state_cache_3.c:18894:			    msk->packets = ((void *) 0);
state_cache_3.c:18903:		    msk->num_packets = numPackets;
state_cache_3.c:18908:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
state_cache_3.c:18910:		      &tp->cminisock_api_config.msk_freelist;
state_cache_3.c:18911:		    struct cminisock *curr = (struct cminisock *) head->next;
state_cache_3.c:18913:			   && curr->ctl == ALLOC_PROCESSING)
state_cache_3.c:18915:			curr = curr->next;
state_cache_3.c:18922:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
state_cache_3.c:18924:		      &tp->cminisock_api_config.pmsk_freelist;
state_cache_3.c:18926:		      (struct cminisock *) tp->cminisock_api_config.
state_cache_3.c:18928:		    if ((((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
state_cache_3.c:18929:			 && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
state_cache_3.c:18944:			   pcurr->ctl == ALLOC_PROCESSING)
state_cache_3.c:18946:			pcurr = pcurr->next;
state_cache_3.c:18955:		    rval->ctl = ALLOC_PENDING;
state_cache_3.c:18963:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
state_cache_3.c:18965:		      &tp->cminisock_api_config.msk_freelist;
state_cache_3.c:18967:		      (struct cminisock *) tp->cminisock_api_config.
state_cache_3.c:18970:			(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
state_cache_3.c:18971:			 && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
state_cache_3.c:18975:			       curr->ctl == ALLOC_PROCESSING)
state_cache_3.c:18977:			    curr = curr->next;
state_cache_3.c:18986:			rval->ctl = ALLOC_PENDING;
state_cache_3.c:18990:			if (tp->t.responseCount == 0)
state_cache_3.c:18992:			    rval = tp->t.responseMSK;
state_cache_3.c:18993:			    rval->list = ((void *) 0);
state_cache_3.c:18994:			    rval->next = rval->prev = ((void *) 0);
state_cache_3.c:19006:			    rval->next = rval->prev = ((void *) 0);
state_cache_3.c:19007:			    rval->list = ((void *) 0);
state_cache_3.c:19008:			    insert_tail (&tp->t.responseList,
state_cache_3.c:19011:			tp->t.responseCount++;
state_cache_3.c:19012:			rval->sk = sk;
state_cache_3.c:19013:			rval->ctl = ALLOC_PENDING;
state_cache_3.c:19020:		    msk->refCnt++;
state_cache_3.c:19044:		    rval->refCnt = 1;
state_cache_3.c:19045:		    rval->isStatic = 0;
state_cache_3.c:19067:		      rval->refCnt = 1;
state_cache_3.c:19068:		      rval->isStatic = 0;
state_cache_3.c:19082:			skb->next = ((void *) 0);
state_cache_3.c:19083:			skb->prev = ((void *) 0);
state_cache_3.c:19084:			skb->list = ((void *) 0);
state_cache_3.c:19085:			skb->sk = ((void *) 0);
state_cache_3.c:19086:			skb->stamp.tv_sec = 0;
state_cache_3.c:19087:			skb->dev = ((void *) 0);
state_cache_3.c:19088:			skb->real_dev = ((void *) 0);
state_cache_3.c:19089:			skb->dst = ((void *) 0);
state_cache_3.c:19091:			 ? (__builtin_constant_p ((sizeof (skb->cb))) ?
state_cache_3.c:19092:			    __constant_c_and_count_memset (((skb->cb)),
state_cache_3.c:19097:							     (skb->
state_cache_3.c:19099:			    __constant_c_memset (((skb->cb)),
state_cache_3.c:19102:						 ((sizeof (skb->cb)))))
state_cache_3.c:19103:			 : (__builtin_constant_p ((sizeof (skb->cb))) ?
state_cache_3.c:19104:			    __memset_generic ((((skb->cb))), (((0))),
state_cache_3.c:19105:					      (((sizeof (skb->cb))))) :
state_cache_3.c:19106:			    __memset_generic (((skb->cb)), ((0)),
state_cache_3.c:19107:					      ((sizeof (skb->cb))))));
state_cache_3.c:19108:			skb->pkt_type = 0;
state_cache_3.c:19109:			skb->ip_summed = 0;
state_cache_3.c:19110:			skb->priority = 0;
state_cache_3.c:19111:			skb->security = 0;
state_cache_3.c:19112:			skb->destructor = ((void *) 0);
state_cache_3.c:19113:			skb->nfmark = skb->nfcache = 0;
state_cache_3.c:19114:			skb->nfct = ((void *) 0);
state_cache_3.c:19115:			skb->tc_index = 0;
state_cache_3.c:19121:			struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_3.c:19123:			  ((struct skb_shared_info *) ((skb)->end))->
state_cache_3.c:19125:			  tp->t.recycleList.qlen >= (1000), r2 =
state_cache_3.c:19126:			  skb->truesize - sizeof (struct sk_buff) <
state_cache_3.c:19136:				     r0, r1, r2, skb->truesize,
state_cache_3.c:19145:			skb->tail = skb->data = skb->head;
state_cache_3.c:19146:			skb->len = 0;
state_cache_3.c:19147:			skb->cloned = 0;
state_cache_3.c:19148:			skb->data_len = 0;
state_cache_3.c:19149:			(((&skb->users)->counter) = (1));
state_cache_3.c:19151:			   (((struct skb_shared_info *) ((skb)->end))->
state_cache_3.c:19152:			    dataref))->counter) = (1));
state_cache_3.c:19153:			((struct skb_shared_info *) ((skb)->end))->nr_frags =
state_cache_3.c:19155:			((struct skb_shared_info *) ((skb)->end))->frag_list =
state_cache_3.c:19157:			__skb_queue_tail (&tp->t.recycleList, skb);
state_cache_3.c:19161:			struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
state_cache_3.c:19163:			  __skb_dequeue_tail (&tp->t.recycleList);
state_cache_3.c:19379:			      a = a - b;
state_cache_3.c:19380:			      a = a - c;
state_cache_3.c:19382:			      b = b - c;
state_cache_3.c:19383:			      b = b - a;
state_cache_3.c:19385:			      c = c - a;
state_cache_3.c:19386:			      c = c - b;
state_cache_3.c:19388:			      a = a - b;
state_cache_3.c:19389:			      a = a - c;
state_cache_3.c:19391:			      b = b - c;
state_cache_3.c:19392:			      b = b - a;
state_cache_3.c:19394:			      c = c - a;
state_cache_3.c:19395:			      c = c - b;
state_cache_3.c:19397:			      a = a - b;
state_cache_3.c:19398:			      a = a - c;
state_cache_3.c:19400:			      b = b - c;
state_cache_3.c:19401:			      b = b - a;
state_cache_3.c:19403:			      c = c - a;
state_cache_3.c:19404:			      c = c - b;
state_cache_3.c:19408:			    len = len - 12;
state_cache_3.c:19437:			  a = a - b;
state_cache_3.c:19438:			  a = a - c;
state_cache_3.c:19440:			  b = b - c;
state_cache_3.c:19441:			  b = b - a;
state_cache_3.c:19443:			  c = c - a;
state_cache_3.c:19444:			  c = c - b;
state_cache_3.c:19446:			  a = a - b;
state_cache_3.c:19447:			  a = a - c;
state_cache_3.c:19449:			  b = b - c;
state_cache_3.c:19450:			  b = b - a;
state_cache_3.c:19452:			  c = c - a;
state_cache_3.c:19453:			  c = c - b;
state_cache_3.c:19455:			  a = a - b;
state_cache_3.c:19456:			  a = a - c;
state_cache_3.c:19458:			  b = b - c;
state_cache_3.c:19459:			  b = b - a;
state_cache_3.c:19461:			  c = c - a;
state_cache_3.c:19462:			  c = c - b;
state_cache_3.c:19472:			int runStart = -1;
state_cache_3.c:19488:				    printk ("[%d-%d]: ", runStart, i - 1);
state_cache_3.c:19512:			key.seq = cmsk->msk->seq;
state_cache_3.c:19519:			return hash ((u1 *) & key->seq, sizeof (key->seq), 0);
state_cache_3.c:19530:			return k0->seq == k1->seq;
state_cache_3.c:19536:			if (cmsk->msk == ((void *) 0))
state_cache_3.c:19553:			    msk_release (cmsk->msk->serverSK, cmsk->msk);
state_cache_3.c:19555:			cmsk->msk = ((void *) 0);
state_cache_3.c:19590:			  (struct ParsedPMinisock_cell *) cache->buckets
state_cache_3.c:19592:			  (struct ParsedPMinisock_cell *) (cache->buckets +
state_cache_3.c:19609:			cache->count = 0;
state_cache_3.c:19610:			cache->numBuckets = (2048);
state_cache_3.c:19611:			cache->maxCount = (2048);
state_cache_3.c:19612:			cache->hitCount = 0;
state_cache_3.c:19613:			cache->total = 0;
state_cache_3.c:19614:			cache->cellMem = 0;
state_cache_3.c:19615:			cache->maxCellMem = 0;
state_cache_3.c:19616:			cache->linkCount = 0;
state_cache_3.c:19617:			cache->lookupCount = 0;
state_cache_3.c:19619:			for (i = 0; i < cache->numBuckets; i++)
state_cache_3.c:19622:			      &cache->buckets[i];
state_cache_3.c:19623:			    *(int *) &(bucket)->fastCell.elem = 0;
state_cache_3.c:19632:			for (i = 0; i < cache->numBuckets; i++)
state_cache_3.c:19635:			      &cache->buckets[i];
state_cache_3.c:19636:			    if ((*(int *) &(bucket)->fastCell.elem != 0))
state_cache_3.c:19638:				pminisock_evict (&bucket->fastCell.elem);
state_cache_3.c:19639:				ParsedPMinisock_deleteCell (&bucket->
state_cache_3.c:19657:			(cache->hitCount >= 0 && cache->total >= 0
state_cache_3.c:19658:			 && cache->hitCount <= cache->total) || (((
state_cache_3.c:19671:			for (i = 0; i < cache->numBuckets; i++)
state_cache_3.c:19674:			      &cache->buckets[i];
state_cache_3.c:19675:			    if ((*(int *) &(bucket)->fastCell.elem != 0))
state_cache_3.c:19678:				  &bucket->fastCell;
state_cache_3.c:19679:				((pminisock_hash (&cell->key) %
state_cache_3.c:19695:			    if (!(lookupCount == cache->count))
state_cache_3.c:19698:					"lookupCount == cache->count",
state_cache_3.c:19707:			    if (!(cache->count <= cache->maxCount))
state_cache_3.c:19710:					"cache->count <= cache->maxCount",
state_cache_3.c:19723:			cache->hitCount = 0;
state_cache_3.c:19724:			cache->total = 0;
state_cache_3.c:19735:			cache->lookupCount++;
state_cache_3.c:19736:			if ((*(int *) &(bucket)->fastCell.elem != 0))
state_cache_3.c:19739:			      &bucket->fastCell;
state_cache_3.c:19741:				(key, ((void *) 0), &cell->key, &cell->elem))
state_cache_3.c:19755:			  &cache->buckets[pminisock_hash (key) %
state_cache_3.c:19756:					  cache->numBuckets];
state_cache_3.c:19758:			if (!(*(int *) &(bucket)->fastCell.elem != 0))
state_cache_3.c:19760:			    cell = &bucket->fastCell;
state_cache_3.c:19764:			    cell = &bucket->fastCell;
state_cache_3.c:19765:			    pminisock_evict (&cell->elem);
state_cache_3.c:19768:			cache->count++;
state_cache_3.c:19769:			cell->key = *key;
state_cache_3.c:19782:			cell->elem = *elem;
state_cache_3.c:19796:			  &cache->buckets[pminisock_hash (key) %
state_cache_3.c:19797:					  cache->numBuckets];
state_cache_3.c:19808:			    cache->hitCount++;
state_cache_3.c:19810:			cache->total++;
state_cache_3.c:19822:			    *result = cell->elem;
state_cache_3.c:19854:							      -
state_cache_3.c:19858:								  *) 0)->
state_cache_3.c:19860:			*(int *) &(bucket)->fastCell.elem = 0;
state_cache_3.c:19873:			    struct pminisock *msk = cell->elem.msk;
state_cache_3.c:19875:			    if (!(msk->saddr == iph->daddr &&
state_cache_3.c:19876:				  msk->source == th->dest &&
state_cache_3.c:19877:				  msk->daddr == iph->saddr &&
state_cache_3.c:19878:				  msk->dest == th->source))
state_cache_3.c:19900:			key.seq = msk->seq;
state_cache_3.c:19906:			    cell->elem.msk = msk;
state_cache_3.c:19925:			return seqnoToKey (msk->hdr.seq);
state_cache_3.c:19959:			return map->key;
state_cache_3.c:20008:			  (struct Continuation_cell *) cache->buckets
state_cache_3.c:20010:			  (struct Continuation_cell *) (cache->buckets +
state_cache_3.c:20027:			cache->count = 0;
state_cache_3.c:20028:			cache->numBuckets = (2048);
state_cache_3.c:20029:			cache->maxCount = (2048);
state_cache_3.c:20030:			cache->hitCount = 0;
state_cache_3.c:20031:			cache->total = 0;
state_cache_3.c:20032:			cache->cellMem = 0;
state_cache_3.c:20033:			cache->maxCellMem = 0;
state_cache_3.c:20034:			cache->linkCount = 0;
state_cache_3.c:20035:			cache->lookupCount = 0;
state_cache_3.c:20037:			for (i = 0; i < cache->numBuckets; i++)
state_cache_3.c:20040:			      &cache->buckets[i];
state_cache_3.c:20041:			    *(int *) &(bucket)->fastCell.elem = 0;
state_cache_3.c:20050:			for (i = 0; i < cache->numBuckets; i++)
state_cache_3.c:20053:			      &cache->buckets[i];
state_cache_3.c:20054:			    if ((*(int *) &(bucket)->fastCell.elem != 0))
state_cache_3.c:20056:				CachedWireContinuation_evict (&bucket->
state_cache_3.c:20058:				Continuation_deleteCell (&bucket->fastCell);
state_cache_3.c:20075:			(cache->hitCount >= 0 && cache->total >= 0
state_cache_3.c:20076:			 && cache->hitCount <= cache->total) || (((
state_cache_3.c:20089:			for (i = 0; i < cache->numBuckets; i++)
state_cache_3.c:20092:			      &cache->buckets[i];
state_cache_3.c:20093:			    if ((*(int *) &(bucket)->fastCell.elem != 0))
state_cache_3.c:20096:				  &bucket->fastCell;
state_cache_3.c:20097:				((CachedWireContinuation_hash (&cell->key) %
state_cache_3.c:20103:										cell->
state_cache_3.c:20106:										(&cell->
state_cache_3.c:20109:										(&cell->
state_cache_3.c:20129:			    if (!(lookupCount == cache->count))
state_cache_3.c:20132:					"lookupCount == cache->count",
state_cache_3.c:20141:			    if (!(cache->count <= cache->maxCount))
state_cache_3.c:20144:					"cache->count <= cache->maxCount",
state_cache_3.c:20157:			cache->hitCount = 0;
state_cache_3.c:20158:			cache->total = 0;
state_cache_3.c:20168:			cache->lookupCount++;
state_cache_3.c:20169:			if ((*(int *) &(bucket)->fastCell.elem != 0))
state_cache_3.c:20172:			      &bucket->fastCell;
state_cache_3.c:20174:				(key, ((void *) 0), &cell->key, &cell->elem))
state_cache_3.c:20188:			  &cache->buckets[CachedWireContinuation_hash (key) %
state_cache_3.c:20189:					  cache->numBuckets];
state_cache_3.c:20191:			if (!(*(int *) &(bucket)->fastCell.elem != 0))
state_cache_3.c:20193:			    cell = &bucket->fastCell;
state_cache_3.c:20197:			    cell = &bucket->fastCell;
state_cache_3.c:20198:			    CachedWireContinuation_evict (&cell->elem);
state_cache_3.c:20201:			cache->count++;
state_cache_3.c:20202:			cell->key = *key;
state_cache_3.c:20216:			cell->elem = *elem;
state_cache_3.c:20229:			  &cache->buckets[CachedWireContinuation_hash (key) %
state_cache_3.c:20230:					  cache->numBuckets];
state_cache_3.c:20241:			    cache->hitCount++;
state_cache_3.c:20243:			cache->total++;
state_cache_3.c:20256:			    *result = cell->elem;
state_cache_3.c:20287:			  ((struct Continuation_bucket *) (((char *) cell) -
state_cache_3.c:20291:							       *) 0)->
state_cache_3.c:20293:			*(int *) &(bucket)->fastCell.elem = 0;
state_cache_3.c:20327:			return cell >= (struct NonceKey_cell *) cache->buckets
state_cache_3.c:20329:			  (struct NonceKey_cell *) (cache->buckets + (32));
state_cache_3.c:20341:			cache->count = 0;
state_cache_3.c:20342:			cache->numBuckets = (32);
state_cache_3.c:20343:			cache->maxCount = (100);
state_cache_3.c:20344:			cache->hitCount = 0;
state_cache_3.c:20345:			cache->total = 0;
state_cache_3.c:20346:			cache->cellMem = 0;
state_cache_3.c:20347:			cache->maxCellMem = 0;
state_cache_3.c:20348:			cache->linkCount = 0;
state_cache_3.c:20349:			cache->lookupCount = 0;
state_cache_3.c:20351:			for (i = 0; i < cache->numBuckets; i++)
state_cache_3.c:20354:			      &cache->buckets[i];
state_cache_3.c:20355:			    *(int *) &(bucket)->fastCell.elem = 0;
state_cache_3.c:20391:				for (i = 0; i < cache->numBuckets; i++)
state_cache_3.c:20394:				      &cache->buckets[i];
state_cache_3.c:20395:				    if ((*(int *) &(bucket)->fastCell.elem !=
state_cache_3.c:20398:					nonce_evict (&bucket->fastCell.elem);
state_cache_3.c:20399:					NonceKey_deleteCell (&bucket->
state_cache_3.c:20447:					(cache->hitCount >= 0
state_cache_3.c:20448:					 && cache->total >= 0
state_cache_3.c:20449:					 && cache->hitCount <= cache->total)
state_cache_3.c:20459:					     i < cache->numBuckets; i++)
state_cache_3.c:20462:					      &cache->buckets[i];
state_cache_3.c:20463:					    if ((*(int *) &(bucket)->fastCell.
state_cache_3.c:20467:						  &bucket->fastCell;
state_cache_3.c:20468:						((nonce_hash (&cell->key) %
state_cache_3.c:20488:						(lookupCount == cache->count))
state_cache_3.c:20492:						   "lookupCount == cache->count",
state_cache_3.c:20502:						(cache->count <=
state_cache_3.c:20503:						 cache->maxCount))
state_cache_3.c:20507:						   "cache->count <= cache->maxCount",
state_cache_3.c:20520:					cache->hitCount = 0;
state_cache_3.c:20521:					cache->total = 0;
state_cache_3.c:20531:					cache->lookupCount++;
state_cache_3.c:20532:					if ((*(int *) &(bucket)->fastCell.
state_cache_3.c:20536:					      &bucket->fastCell;
state_cache_3.c:20539:						 &cell->key, &cell->elem))
state_cache_3.c:20552:					  &cache->buckets[nonce_hash (key) %
state_cache_3.c:20553:							  cache->numBuckets];
state_cache_3.c:20557:					    (*(int *) &(bucket)->fastCell.
state_cache_3.c:20560:					    cell = &bucket->fastCell;
state_cache_3.c:20564:					    cell = &bucket->fastCell;
state_cache_3.c:20565:					    nonce_evict (&cell->elem);
state_cache_3.c:20568:					cache->count++;
state_cache_3.c:20569:					cell->key = *key;
state_cache_3.c:20612:					      cell->elem = *elem;
state_cache_3.c:20656:							&cache->
state_cache_3.c:20659:								cache->
state_cache_3.c:20709:								cache->
state_cache_3.c:20712:							    cache->total++;
state_cache_3.c:20731:								    cell->
state_cache_3.c:20858:										((struct NonceKey_bucket *) (((char *) cell) - ((char *) &((struct NonceKey_bucket *) 0)->fastCell)));
state_cache_3.c:20859:									      *(int *) &(bucket)->fastCell.elem = 0;
state_cache_3.c:20879:										 -
state_cache_3.c:20926:										&c->
state_cache_3.c:20928:									      phdr->
state_cache_3.c:20931:										dcont->
state_cache_3.c:20933:									      phdr->
state_cache_3.c:20936:										dcont->
state_cache_3.c:20938:									      phdr->
state_cache_3.c:20941:										dcont->
state_cache_3.c:20947:									      phdr->
state_cache_3.c:20950:										scont->
state_cache_3.c:20952:									      phdr->
state_cache_3.c:20955:										scont->
state_cache_3.c:20957:									      phdr->
state_cache_3.c:20960:										scont->
state_cache_3.c:20962:									      phdr->
state_cache_3.c:20965:										scont->
state_cache_3.c:20967:									      (__builtin_constant_p ((((__u8 *) (((WireContinuation *) 0) + 1) - (__u8 *) ((WireContinuation *) 0)->hmac_start))) ? __constant_memcpy ((c->copy_start), (dcont->hmac_start), ((((__u8 *) (((WireContinuation *) 0) + 1) - (__u8 *) ((WireContinuation *) 0)->hmac_start)))) : __memcpy ((c->copy_start), (dcont->hmac_start), ((((__u8 *) (((WireContinuation *) 0) + 1) - (__u8 *) ((WireContinuation *) 0)->hmac_start)))));
state_cache_3.c:20989:										&c->
state_cache_3.c:20991:									      if (phdr->seq == w->seq && phdr->type == w->continuationType && phdr->first == w->firstChild && phdr->serverAddr == iph->daddr && phdr->serverPort == th->dest && phdr->clientAddr == iph->saddr && phdr->clientPort == th->source && w->tokenCounterBase == c->tokenCounterBase)
state_cache_3.c:20993:										  (__builtin_constant_p ((((__u8 *) (((WireContinuation *) 0) + 1) - (__u8 *) ((WireContinuation *) 0)->hmac_start))) ? __constant_memcpy ((w->hmac_start), (c->copy_start), ((((__u8 *) (((WireContinuation *) 0) + 1) - (__u8 *) ((WireContinuation *) 0)->hmac_start)))) : __memcpy ((w->hmac_start), (c->copy_start), ((((__u8 *) (((WireContinuation *) 0) + 1) - (__u8 *) ((WireContinuation *) 0)->hmac_start)))));
state_cache_3.c:21016:										(w->
state_cache_3.c:21018:										 c->
state_cache_3.c:21020:										 (((__u8 *) (((WireContinuation *) 0) + 1) - (__u8 *) ((WireContinuation *) 0)->hmac_start)));
state_cache_3.c:21038:										(cont->
state_cache_3.c:21045:										  if (!WireContinuation_checkAndCopyOut (cont, &cell->elem, iph, th))
state_cache_3.c:21077:										(wcont->
state_cache_3.c:21088:										    (&cell->
state_cache.c:66:	key.sk = cmsk->msk->serverSK;
state_cache.c:68:	key.seq = cmsk->pmsk->seq;
state_cache.c:73:	return hash((u1 *)&key->seq, sizeof(key->seq), 0);
state_cache.c:81:		k0->sk == k1->sk &&
state_cache.c:83:		k0->seq == k1->seq;
state_cache.c:94:	if(cmsk->pmsk == NULL) {
state_cache.c:97:		BUG_TRAP(cmsk->pmsk->refCnt >= 1);
state_cache.c:98:		pmsk_release(sk, cmsk->pmsk);
state_cache.c:101:	cmsk->pmsk = NULL;
state_cache.c:115:#define VERIFY_HASH() ( (pminisock_hash(&cell->key) % ParsedPMinisock_cache.numBuckets) == i ) || ( ERROR("pminisock hash index integrity") && RETURN(0) )
state_cache.c:141:		if(CACHE_COMPARISON && (WireContinuation_inOutComp(cont, &cell->elem) != 0)) {
state_cache.c:143:			byte_diff(cont->hmac_start, cell->elem.copy_start, 
state_cache.c:146:		if(cont->tokenCounterBase != cell->elem.tokenCounterBase) {
state_cache.c:147:			printk("Continuation (%d) hit, but %lld != %lld\n", cell->key, 
state_cache.c:148:			       cont->tokenCounterBase, cell->elem.tokenCounterBase);
state_cache.c:153:		struct pminisock *pmsk = cell->elem.pmsk;
state_cache.c:154:		BUG_TRAP(pmsk->refCnt == 1);
state_cache.c:157:		     pmsk->daddr == iph->saddr &&
state_cache.c:158:		     pmsk->dest == th->source)) {
state_cache.c:178:	BUG_TRAP(msk->refCnt >= 1);
state_cache.c:181:	key.sk = msk->serverSK;
state_cache.c:183:	key.seq = pmsk->seq;
state_cache.c:188:		cell->elem.pmsk = pmsk;
state_cache.c:201:// Old pre-parse cache code (low level, lower performance)
state_cache.c:211:	return seqnoToKey(msk->hdr.seq);
state_cache.c:234:	return map->key;
state_cache.c:263:	( (CachedWireContinuation_hash(&cell->key) % Continuation_cache.numBuckets) == i ) || \
state_cache.c:264:	( ERROR("hash index integrity %X %X, %d %d", cell->key,		\
state_cache.c:265:		CachedWireContinuation_hash(&cell->key),			\
state_cache.c:266:		CachedWireContinuation_hash(&cell->key) % Continuation_cache.numBuckets, \
state_cache.c:287:#define VERIFY_HASH() ( (nonce_hash(&cell->key) % NonceKey_cache.numBuckets) == i ) || ( ERROR("hash index integrity") && RETURN(0) )
state_cache.c:305:	       (char*)&ParsedPMinisock_cache.buckets[1] -
state_cache.c:333:// Side-effect: Continuation is removed from the continuation cache
state_cache.c:339:	PseudoHeader *phdr = &c->hdr;
state_cache.c:342:	memcpy(c->copy_start, dcont->hmac_start, WIRECONT_MAC_LEN);
state_cache.c:349:	PseudoHeader *phdr = &c->hdr;
state_cache.c:350:	if(phdr->seq == w->seq && // seqno match is already verified
state_cache.c:351:	   phdr->type == w->continuationType &&
state_cache.c:352:	   phdr->first == w->firstChild &&
state_cache.c:353:	   phdr->serverAddr == iph->daddr &&
state_cache.c:354:	   phdr->serverPort == th->dest &&
state_cache.c:355:	   phdr->clientAddr == iph->saddr &&
state_cache.c:356:	   phdr->clientPort == th->source &&
state_cache.c:357:	   w->tokenCounterBase == c->tokenCounterBase) {
state_cache.c:358:		memcpy(w->hmac_start, c->copy_start, WIRECONT_MAC_LEN);
state_cache.c:368:	return memcmp(w->hmac_start, c->copy_start, WIRECONT_MAC_LEN);
state_cache.c:373:	CachedWireContinuationKey key = seqnoToKey(cont->seq);
state_cache.c:377:		if(CACHE_COMPARISON && (WireContinuation_inOutComp(cont, &cell->elem) != 0)) {
state_cache.c:379:			byte_diff(cont->hmac_start, cell->elem.copy_start, 
state_cache.c:382:		if(cont->tokenCounterBase != cell->elem.tokenCounterBase) {
state_cache.c:383:			printk("Continuation (%d) hit, but %lld != %lld\n", cell->key, 
state_cache.c:384:			       cont->tokenCounterBase, cell->elem.tokenCounterBase);
state_cache.c:388:		if(!WireContinuation_checkAndCopyOut(cont, &cell->elem, iph, th)) {
state_cache.c:404:	//printk("Continuation (%d) missed\n", cont->seq);
state_cache.c:409:	CachedWireContinuationKey key = seqnoToKey(wcont->seq);
state_cache.c:412:		WireContinuation_copyIn(&cell->elem, wcont, scont);
state_cache.c:421:// USER LEVEL SELF-TEST
state_cache.c:462:	// base functionality test -- insertion, deletion
state_cache.c:509:					expected--;
state_cache.c:512:			PRINT_STATS(Continuation -- after steady insertion, 
state_cache.c:538:	PRINT_STATS(Continuation -- after big insertion, 
state_cache.c:545:	// kernel-like workload (simulate the order of operations
syncookies.c:25: * This table has to be sorted and terminated with (__u16)-1.
syncookies.c:30:	64 - 1,
syncookies.c:31:	256 - 1,	
syncookies.c:32:	512 - 1,
syncookies.c:33:	536 - 1,
syncookies.c:34:	1024 - 1,	
syncookies.c:35:	1440 - 1,
syncookies.c:36:	1460 - 1,
syncookies.c:37:	4312 - 1,
syncookies.c:38:	(__u16)-1
syncookies.c:40:/* The number doesn't include the -1 terminator */
syncookies.c:41:#define NUM_MSS (sizeof(msstab)/sizeof(msstab[0]) - 1)
syncookies.c:53:	sk->tp_pinfo.af_tcp.last_synq_overflow = jiffies;
syncookies.c:62:	return secure_tcp_syn_cookie(skb->nh.iph->saddr, skb->nh.iph->daddr,
syncookies.c:63:				     skb->h.th->source, skb->h.th->dest,
syncookies.c:64:				     ntohl(skb->h.th->seq),
syncookies.c:84:	seq = ntohl(skb->h.th->seq)-1; 
syncookies.c:86:				      skb->nh.iph->saddr, skb->nh.iph->daddr,
syncookies.c:87:				      skb->h.th->source, skb->h.th->dest,
syncookies.c:99:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
syncookies.c:102:	child = tp->af_specific->syn_recv_sock(sk, skb, req, dst);
syncookies.c:114:	__u32 cookie = ntohl(skb->h.th->ack_seq) - 1; 
syncookies.c:121:	if (!sysctl_tcp_syncookies || !skb->h.th->ack)
syncookies.c:124:  	if (time_after(jiffies, sk->tp_pinfo.af_tcp.last_synq_overflow + TCP_TIMEOUT_INIT) ||
syncookies.c:137:	req->rcv_isn		= htonl(skb->h.th->seq) - 1;
syncookies.c:138:	req->snt_isn		= cookie; 
syncookies.c:139:	req->mss		= mss;
syncookies.c:140: 	req->rmt_port		= skb->h.th->source;
syncookies.c:141:	req->af.v4_req.loc_addr = skb->nh.iph->daddr;
syncookies.c:142:	req->af.v4_req.rmt_addr = skb->nh.iph->saddr;
syncookies.c:143:	req->class		= &or_ipv4; /* for savety */
syncookies.c:144:	req->af.v4_req.opt	= NULL;
syncookies.c:149:	if (opt && opt->optlen) {
syncookies.c:150:		int opt_size = sizeof(struct ip_options) + opt->optlen;
syncookies.c:152:		req->af.v4_req.opt = kmalloc(opt_size, GFP_ATOMIC);
syncookies.c:153:		if (req->af.v4_req.opt) {
syncookies.c:154:			if (ip_options_echo(req->af.v4_req.opt, skb)) {
syncookies.c:155:				kfree(req->af.v4_req.opt);
syncookies.c:156:				req->af.v4_req.opt = NULL;
syncookies.c:161:	req->snd_wscale = req->rcv_wscale = req->tstamp_ok = 0;
syncookies.c:162:	req->wscale_ok	= req->sack_ok = 0; 
syncookies.c:163:	req->expires	= 0UL; 
syncookies.c:164:	req->retrans	= 0; 
syncookies.c:174:			    opt->srr ? opt->faddr : req->af.v4_req.rmt_addr,
syncookies.c:175:			    req->af.v4_req.loc_addr,
syncookies.c:183:	req->window_clamp = rt->u.dst.window;  
syncookies.c:184:	tcp_select_initial_window(tcp_full_space(sk), req->mss,
syncookies.c:185:				  &req->rcv_wnd, &req->window_clamp, 
syncookies.c:188:	req->rcv_wscale	  = rcv_wscale; 
syncookies.c:190:	ret = get_cookie_sock(sk, skb, req, &rt->u.dst);
sysctl_net_ipv4.c:91:		return -EINVAL;
sysctl_net_ipv4.c:93:		return -EFAULT; 
tcp.c:13: *		Corey Minyard <wf-rch!minyard@relay.EU.net>
tcp.c:14: *		Florian La Roche, <flla@stud.uni-sb.de>
tcp.c:26: *					sk->inuse=1 and was trying to connect
tcp.c:52: *		Alan Cox	:	sk->keepopen now seems to work
tcp.c:54: *		Alan Cox	:	Fixed assorted sk->rqueue->next errors
tcp.c:64: *		Alan Cox	:	FIN with no memory -> CRASH
tcp.c:114: *		Alan Cox	:	Changed the semantics of sk->socket to
tcp.c:165: *		Matt Day	:	poll()->select() match BSD precisely on error
tcp.c:167: *		Marc Tamsky	:	Various sk->prot->retransmits and
tcp.c:168: *					sk->retransmits misupdating fixed.
tcp.c:173: *		Alan Cox	:	Look up device on a retransmit - routes may
tcp.c:218: *				waiting for final ack in three-way handshake.
tcp.c:288:#define TCP_PAGES(amt) (((amt)+TCP_MEM_QUANTUM-1)/TCP_MEM_QUANTUM)
tcp.c:294:	sk->forward_alloc += amt*TCP_MEM_QUANTUM;
tcp.c:315:		if (atomic_read(&sk->rmem_alloc) < sysctl_tcp_rmem[0])
tcp.c:318:		if (sk->wmem_queued < sysctl_tcp_wmem[0])
tcp.c:324:	    * TCP_PAGES(sk->wmem_queued+atomic_read(&sk->rmem_alloc)+
tcp.c:325:			sk->forward_alloc))
tcp.c:336:		if (sk->wmem_queued+size >= sk->sndbuf)
tcp.c:341:	sk->forward_alloc -= amt*TCP_MEM_QUANTUM;
tcp.c:348:	if (sk->forward_alloc >= TCP_MEM_QUANTUM) {
tcp.c:349:		atomic_sub(sk->forward_alloc/TCP_MEM_QUANTUM, &tcp_memory_allocated);
tcp.c:350:		sk->forward_alloc &= (TCP_MEM_QUANTUM-1);
tcp.c:359:	struct sock *sk = skb->sk;
tcp.c:361:	atomic_sub(skb->truesize, &sk->rmem_alloc);
tcp.c:362:	sk->forward_alloc += skb->truesize;
tcp.c:370:	return sk->tp_pinfo.af_tcp.accept_queue ? (POLLIN | POLLRDNORM) : 0;
tcp.c:383:	struct sock *sk = sock->sk;
tcp.c:384:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp.c:386:	poll_wait(file, sk->sleep, wait);
tcp.c:387:	if (sk->state == TCP_LISTEN) {
tcp.c:388:		if((tp->trickles_opt & TCP_TRICKLES_ENABLE)) {
tcp.c:394:	if (sk->state == TCP_LISTEN)
tcp.c:403:	if (sk->err)
tcp.c:417:	 * Check-me.
tcp.c:422:	 * in state CLOSE_WAIT. One solution is evident --- to set POLLHUP
tcp.c:428:	 * why PULLHUP is incompatible with POLLOUT.	--ANK
tcp.c:431:	 * blocking on fresh not-connected or disconnected socket. --ANK
tcp.c:433:	if (sk->shutdown == SHUTDOWN_MASK || sk->state == TCP_CLOSE)
tcp.c:435:	if (sk->shutdown & RCV_SHUTDOWN)
tcp.c:439:	if ((1 << sk->state) & ~(TCPF_SYN_SENT|TCPF_SYN_RECV)) {
tcp.c:441:		 * escape above sk->state, we can be illegally awaken
tcp.c:443:		if ((tp->rcv_nxt != tp->copied_seq) &&
tcp.c:444:		    (tp->urg_seq != tp->copied_seq ||
tcp.c:445:		     tp->rcv_nxt != tp->copied_seq+1 ||
tcp.c:446:		     sk->urginline || !tp->urg_data))
tcp.c:449:		if (!(sk->shutdown & SEND_SHUTDOWN)) {
tcp.c:453:				set_bit(SOCK_ASYNC_NOSPACE, &sk->socket->flags);
tcp.c:454:				set_bit(SOCK_NOSPACE, &sk->socket->flags);
tcp.c:464:			if(tp->trickles_opt & TCP_TRICKLES_ENABLE) {
tcp.c:471:		if (tp->urg_data & TCP_URG_VALID)
tcp.c:482:	struct socket *sock = sk->socket;
tcp.c:485:		clear_bit(SOCK_NOSPACE, &sock->flags);
tcp.c:487:		if (sk->sleep && waitqueue_active(sk->sleep))
tcp.c:488:			wake_up_interruptible(sk->sleep);
tcp.c:490:		if (sock->fasync_list && !(sk->shutdown&SEND_SHUTDOWN))
tcp.c:497:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp.c:502:		if (sk->state == TCP_LISTEN)
tcp.c:503:			return(-EINVAL);
tcp.c:506:		if ((1<<sk->state) & (TCPF_SYN_SENT|TCPF_SYN_RECV))
tcp.c:508:		else if (sk->urginline || !tp->urg_data ||
tcp.c:509:			 before(tp->urg_seq,tp->copied_seq) ||
tcp.c:510:			 !before(tp->urg_seq,tp->rcv_nxt)) {
tcp.c:511:			answ = tp->rcv_nxt - tp->copied_seq;
tcp.c:514:			if (answ && !skb_queue_empty(&sk->receive_queue))
tcp.c:515:				answ -= ((struct sk_buff*)sk->receive_queue.prev)->h.th->fin;
tcp.c:517:			answ = tp->urg_seq - tp->copied_seq;
tcp.c:522:			answ = tp->urg_data && tp->urg_seq == tp->copied_seq;
tcp.c:526:		if (sk->state == TCP_LISTEN)
tcp.c:527:			return(-EINVAL);
tcp.c:529:		if ((1<<sk->state) & (TCPF_SYN_SENT|TCPF_SYN_RECV))
tcp.c:532:			answ = tp->write_seq - tp->snd_una;
tcp.c:535:		return(-ENOIOCTLCMD);
tcp.c:544:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp.c:547:	sk->max_ack_backlog = 0;
tcp.c:548:	sk->ack_backlog = 0;
tcp.c:549:	tp->accept_queue = tp->accept_queue_tail = NULL;
tcp.c:550:	tp->syn_wait_lock = RW_LOCK_UNLOCKED;
tcp.c:555:		return -ENOMEM;
tcp.c:558:	for (lopt->max_qlen_log = 6; ; lopt->max_qlen_log++)
tcp.c:559:		if ((1<<lopt->max_qlen_log) >= sysctl_max_syn_backlog)
tcp.c:561:	get_random_bytes(&lopt->hash_rnd, 4);
tcp.c:563:	write_lock_bh(&tp->syn_wait_lock);
tcp.c:564:	tp->listen_opt = lopt;
tcp.c:565:	write_unlock_bh(&tp->syn_wait_lock);
tcp.c:572:	sk->state = TCP_LISTEN;
tcp.c:573:	if (sk->prot->get_port(sk, sk->num) == 0) {
tcp.c:574:		sk->sport = htons(sk->num);
tcp.c:577:		sk->prot->hash(sk);
tcp.c:582:	sk->state = TCP_CLOSE;
tcp.c:583:	write_lock_bh(&tp->syn_wait_lock);
tcp.c:584:	tp->listen_opt = NULL;
tcp.c:585:	write_unlock_bh(&tp->syn_wait_lock);
tcp.c:587:	return -EADDRINUSE;
tcp.c:597:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp.c:598:	struct tcp_listen_opt *lopt = tp->listen_opt;
tcp.c:599:	struct open_request *acc_req = tp->accept_queue;
tcp.c:606:	write_lock_bh(&tp->syn_wait_lock);
tcp.c:607:	tp->listen_opt =NULL;
tcp.c:608:	write_unlock_bh(&tp->syn_wait_lock);
tcp.c:609:	tp->accept_queue = tp->accept_queue_tail = NULL;
tcp.c:611:	if (lopt->qlen) {
tcp.c:613:			while ((req = lopt->syn_table[i]) != NULL) {
tcp.c:614:				lopt->syn_table[i] = req->dl_next;
tcp.c:615:				lopt->qlen--;
tcp.c:619:		 * (and enter FIN-WAIT-1, it is normal close)
tcp.c:624:		 * of the variants now.			--ANK
tcp.c:629:	BUG_TRAP(lopt->qlen == 0);
tcp.c:634:		struct sock *child = req->sk;
tcp.c:636:		acc_req = req->dl_next;
tcp.c:640:		BUG_TRAP(child->lock.users==0);
tcp.c:658:	BUG_TRAP(sk->ack_backlog == 0);
tcp.c:671:	while((1 << sk->state) & ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT)) {
tcp.c:672:		if(sk->err)
tcp.c:674:		if((1 << sk->state) &
tcp.c:676:			return -EPIPE;
tcp.c:678:			return -EAGAIN;
tcp.c:683:		add_wait_queue(sk->sleep, &wait);
tcp.c:684:		sk->tp_pinfo.af_tcp.write_pending++;
tcp.c:691:		remove_wait_queue(sk->sleep, &wait);
tcp.c:692:		sk->tp_pinfo.af_tcp.write_pending--;
tcp.c:699:	return sk->wmem_queued < sk->sndbuf;
tcp.c:715:	add_wait_queue(sk->sleep, &wait);
tcp.c:717:		set_bit(SOCK_ASYNC_NOSPACE, &sk->socket->flags);
tcp.c:721:		if (sk->err || (sk->shutdown & SEND_SHUTDOWN))
tcp.c:727:		clear_bit(SOCK_ASYNC_NOSPACE, &sk->socket->flags);
tcp.c:731:		set_bit(SOCK_NOSPACE, &sk->socket->flags);
tcp.c:732:		sk->tp_pinfo.af_tcp.write_pending++;
tcp.c:737:		sk->tp_pinfo.af_tcp.write_pending--;
tcp.c:740:			vm_wait -= current_timeo;
tcp.c:743:			    (current_timeo -= vm_wait) < 0)
tcp.c:750:	current->state = TASK_RUNNING;
tcp.c:751:	remove_wait_queue(sk->sleep, &wait);
tcp.c:755:	err = -EPIPE;
tcp.c:758:	err = -EAGAIN;
tcp.c:771:		skb_frag_t *frag = &skb_shinfo(skb)->frags[i-1];
tcp.c:772:		return page == frag->page &&
tcp.c:773:			off == frag->page_offset+frag->size;
tcp.c:781:	skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
tcp.c:782:	frag->page = page;
tcp.c:783:	frag->page_offset = off;
tcp.c:784:	frag->size = size;
tcp.c:785:	skb_shinfo(skb)->nr_frags = i+1;
tcp.c:790:	TCP_SKB_CB(skb)->flags |= TCPCB_FLAG_PSH;
tcp.c:791:	tp->pushed_seq = tp->write_seq;
tcp.c:796:	return after(tp->write_seq, tp->pushed_seq + (tp->max_window>>1));
tcp.c:802:	skb->csum = 0;
tcp.c:803:	TCP_SKB_CB(skb)->seq = tp->write_seq;
tcp.c:804:	TCP_SKB_CB(skb)->end_seq = tp->write_seq;
tcp.c:805:	TCP_SKB_CB(skb)->flags = TCPCB_FLAG_ACK;
tcp.c:806:	TCP_SKB_CB(skb)->sacked = 0;
tcp.c:807:	__skb_queue_tail(&sk->write_queue, skb);
tcp.c:809:	if (tp->send_head == NULL)
tcp.c:810:		tp->send_head = skb;
tcp.c:817:		tp->urg_mode = 1;
tcp.c:818:		tp->snd_up = tp->write_seq;
tcp.c:819:		TCP_SKB_CB(skb)->sacked |= TCPCB_URG;
tcp.c:826:	if (tp->send_head) {
tcp.c:827:		struct sk_buff *skb = sk->write_queue.prev;
tcp.c:837:	if (err == -EPIPE)
tcp.c:838:		err = sock_error(sk) ? : -EPIPE;
tcp.c:839:	if (err == -EPIPE && !(flags&MSG_NOSIGNAL))
tcp.c:846:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp.c:853:	if ((1 << sk->state) & ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT))
tcp.c:857:	clear_bit(SOCK_ASYNC_NOSPACE, &sk->socket->flags);
tcp.c:862:	err = -EPIPE;
tcp.c:863:	if (sk->err || (sk->shutdown & SEND_SHUTDOWN))
tcp.c:867:		struct sk_buff *skb = sk->write_queue.prev;
tcp.c:873:		size = min_t(size_t, psize, PAGE_SIZE-offset);
tcp.c:875:		if (tp->send_head==NULL || (copy = mss_now - skb->len) <= 0) {
tcp.c:880:			skb = tcp_alloc_pskb(sk, 0, tp->mss_cache, sk->allocation);
tcp.c:891:		i = skb_shinfo(skb)->nr_frags;
tcp.c:893:			skb_shinfo(skb)->frags[i-1].size += copy;
tcp.c:902:		skb->len += copy;
tcp.c:903:		skb->data_len += copy;
tcp.c:904:		skb->ip_summed = CHECKSUM_HW;
tcp.c:905:		tp->write_seq += copy;
tcp.c:906:		TCP_SKB_CB(skb)->end_seq += copy;
tcp.c:909:			TCP_SKB_CB(skb)->flags &= ~TCPCB_FLAG_PSH;
tcp.c:913:		if (!(psize -= copy))
tcp.c:916:		if (skb->len != mss_now || (flags&MSG_OOB))
tcp.c:922:		} else if (skb == tp->send_head)
tcp.c:927:		set_bit(SOCK_NOSPACE, &sk->socket->flags);
tcp.c:940:		tcp_push(sk, tp, flags, mss_now, tp->nonagle);
tcp.c:953:	struct sock *sk = sock->sk;
tcp.c:957:	if (!(sk->route_caps & NETIF_F_SG) || 
tcp.c:958:	    !(sk->route_caps & TCP_ZC_CSUM_FLAGS))
tcp.c:971:#define TCP_PAGE(sk)	(sk->tp_pinfo.af_tcp.sndmsg_page)
tcp.c:972:#define TCP_OFF(sk)	(sk->tp_pinfo.af_tcp.sndmsg_off)
tcp.c:984:		if (skb->ip_summed == CHECKSUM_NONE)
tcp.c:985:			skb->csum = csum_block_add(skb->csum, csum, skb->len);
tcp.c:986:		skb->len += copy;
tcp.c:987:		skb->data_len += copy;
tcp.c:988:		skb->truesize += copy;
tcp.c:989:		sk->wmem_queued += copy;
tcp.c:990:		sk->forward_alloc -= copy;
tcp.c:1000:	int off = skb->len;
tcp.c:1005:		skb->csum = csum_block_add(skb->csum, csum, off);
tcp.c:1010:	return -EFAULT;
tcp.c:1015:	int tmp = tp->mss_cache;
tcp.c:1017:	if (sk->route_caps&NETIF_F_SG) {
tcp.c:1020:		if (tmp >= pgbreak && tmp <= pgbreak + (MAX_SKB_FRAGS-1)*PAGE_SIZE)
tcp.c:1036:	tp = &(sk->tp_pinfo.af_tcp);
tcp.c:1041:	flags = msg->msg_flags;
tcp.c:1045:	if ((1 << sk->state) & ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT))
tcp.c:1050:	clear_bit(SOCK_ASYNC_NOSPACE, &sk->socket->flags);
tcp.c:1055:	iovlen = msg->msg_iovlen;
tcp.c:1056:	iov = msg->msg_iov;
tcp.c:1059:	err = -EPIPE;
tcp.c:1060:	if (sk->err || (sk->shutdown&SEND_SHUTDOWN))
tcp.c:1063:	while (--iovlen >= 0) {
tcp.c:1064:		int seglen=iov->iov_len;
tcp.c:1065:		unsigned char * from=iov->iov_base;
tcp.c:1072:			skb = sk->write_queue.prev;
tcp.c:1074:			if (tp->send_head == NULL ||
tcp.c:1075:			    (copy = mss_now - skb->len) <= 0) {
tcp.c:1084:				skb = tcp_alloc_pskb(sk, select_size(sk, tp), 0, sk->allocation);
tcp.c:1105:				int i = skb_shinfo(skb)->nr_frags;
tcp.c:1113:					   (i == 0 && !(sk->route_caps&NETIF_F_SG))) {
tcp.c:1115:					 * do this because interface is non-SG,
tcp.c:1124:					off = (off+L1_CACHE_BYTES-1)&~(L1_CACHE_BYTES-1);
tcp.c:1138:				if (copy > PAGE_SIZE-off)
tcp.c:1139:					copy = PAGE_SIZE-off;
tcp.c:1156:					skb_shinfo(skb)->frags[i-1].size += copy;
tcp.c:1171:				TCP_SKB_CB(skb)->flags &= ~TCPCB_FLAG_PSH;
tcp.c:1173:			tp->write_seq += copy;
tcp.c:1174:			TCP_SKB_CB(skb)->end_seq += copy;
tcp.c:1178:			if ((seglen -= copy) == 0 && iovlen == 0)
tcp.c:1181:			if (skb->len != mss_now || (flags&MSG_OOB))
tcp.c:1187:			} else if (skb == tp->send_head)
tcp.c:1192:			set_bit(SOCK_NOSPACE, &sk->socket->flags);
tcp.c:1206:		tcp_push(sk, tp, flags, mss_now, tp->nonagle);
tcp.c:1212:	if (skb->len == 0) {
tcp.c:1213:		if (tp->send_head == skb)
tcp.c:1214:			tp->send_head = NULL;
tcp.c:1215:		__skb_unlink(skb, skb->list);
tcp.c:1238:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp.c:1241:	if (sk->urginline || !tp->urg_data || tp->urg_data == TCP_URG_READ)
tcp.c:1242:		return -EINVAL;	/* Yes this is right ! */
tcp.c:1244:	if (sk->state==TCP_CLOSE && !sk->done)
tcp.c:1245:		return -ENOTCONN;
tcp.c:1247:	if (tp->urg_data & TCP_URG_VALID) {
tcp.c:1249:		char c = tp->urg_data;
tcp.c:1252:			tp->urg_data = TCP_URG_READ;
tcp.c:1255:		msg->msg_flags|=MSG_OOB;
tcp.c:1259:				err = memcpy_toiovec(msg->msg_iov, &c, 1);
tcp.c:1262:			msg->msg_flags|=MSG_TRUNC;
tcp.c:1264:		return err ? -EFAULT : len;
tcp.c:1267:	if (sk->state == TCP_CLOSE || (sk->shutdown & RCV_SHUTDOWN))
tcp.c:1274:	 * Mike <pall@rz.uni-karlsruhe.de>
tcp.c:1276:	return -EAGAIN;
tcp.c:1287:	__skb_unlink(skb, &sk->receive_queue);
tcp.c:1299:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp.c:1303:	struct sk_buff *skb = skb_peek(&sk->receive_queue);
tcp.c:1305:	BUG_TRAP(skb==NULL || before(tp->copied_seq, TCP_SKB_CB(skb)->end_seq));
tcp.c:1308:	if(tp->trickles_opt & TCP_TRICKLES_ENABLE) {
tcp.c:1317:			if (tp->ack.blocked
tcp.c:1318:			    /* Once-per-two-segments ACK was not sent by tcp_input.c */
tcp.c:1319:			    || tp->rcv_nxt - tp->rcv_wup > tp->ack.rcv_mss
tcp.c:1327:				(tp->ack.pending&TCP_ACK_PUSHED) &&
tcp.c:1328:				!tp->ack.pingpong &&
tcp.c:1329:				atomic_read(&sk->rmem_alloc) == 0)) {
tcp.c:1333:		/* We send an ACK if we can now advertise a non-zero window
tcp.c:1339:		if(copied > 0 && !time_to_ack && !(sk->shutdown&RCV_SHUTDOWN)) {
tcp.c:1343:			if (2*rcv_window_now <= tp->window_clamp) {
tcp.c:1360:/* Now socket state including sk->err is changed only under lock,
tcp.c:1370:	add_wait_queue(sk->sleep, &wait);
tcp.c:1374:	set_bit(SOCK_ASYNC_WAITDATA, &sk->socket->flags);
tcp.c:1377:	if (skb_queue_empty(&sk->receive_queue))
tcp.c:1381:	clear_bit(SOCK_ASYNC_WAITDATA, &sk->socket->flags);
tcp.c:1383:	remove_wait_queue(sk->sleep, &wait);
tcp.c:1391:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp.c:1393:	net_statistics[smp_processor_id()*2+1].TCPPrequeued += skb_queue_len(&tp->ucopy.prequeue);
tcp.c:1397:	while ((skb = __skb_dequeue(&tp->ucopy.prequeue)) != NULL)
tcp.c:1398:		sk->backlog_rcv(sk, skb);
tcp.c:1402:	tp->ucopy.memory = 0;
tcp.c:1411:	skb_queue_walk(&sk->receive_queue, skb) {
tcp.c:1412:		offset = seq - TCP_SKB_CB(skb)->seq;
tcp.c:1413:		if (skb->h.th->syn)
tcp.c:1414:			offset--;
tcp.c:1415:		if (offset < skb->len || skb->h.th->fin) {
tcp.c:1428: *	- It is assumed that the socket was locked by the caller.
tcp.c:1429: *	- The routine does not block.
tcp.c:1430: *	- At present, there is no support for reading OOB data
tcp.c:1438:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp.c:1439:	u32 seq = tp->copied_seq;
tcp.c:1443:	if (sk->state == TCP_LISTEN)
tcp.c:1444:		return -ENOTCONN;
tcp.c:1446:		if (offset < skb->len) {
tcp.c:1449:			len = skb->len - offset;
tcp.c:1451:			if (tp->urg_data) {
tcp.c:1452:				u32 urg_offset = tp->urg_seq - seq;
tcp.c:1464:			if (offset != skb->len)
tcp.c:1467:		if (skb->h.th->fin) {
tcp.c:1473:		if (!desc->count)
tcp.c:1476:	tp->copied_seq = seq;
tcp.c:1487: *	tricks with *seq access order and skb->users are not required.
tcp.c:1494:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp.c:1508:	err = -ENOTCONN;
tcp.c:1509:	if (sk->state == TCP_LISTEN)
tcp.c:1518:	seq = &tp->copied_seq;
tcp.c:1520:		peek_seq = tp->copied_seq;
tcp.c:1531:		if (tp->urg_data && tp->urg_seq == *seq) {
tcp.c:1535:				copied = timeo ? sock_intr_errno(timeo) : -EAGAIN;
tcp.c:1542:		skb = skb_peek(&sk->receive_queue);
tcp.c:1550:			if (before(*seq, TCP_SKB_CB(skb)->seq)) {
tcp.c:1552:				       *seq, TCP_SKB_CB(skb)->seq);
tcp.c:1555:			offset = *seq - TCP_SKB_CB(skb)->seq;
tcp.c:1556:			if (skb->h.th->syn)
tcp.c:1557:				offset--;
tcp.c:1558:			if (offset < skb->len)
tcp.c:1560:			if (skb->h.th->fin)
tcp.c:1563:			skb = skb->next;
tcp.c:1564:		} while (skb != (struct sk_buff *)&sk->receive_queue);
tcp.c:1568:		if (copied >= target && sk->backlog.tail == NULL)
tcp.c:1572:			if (sk->err ||
tcp.c:1573:			    sk->state == TCP_CLOSE ||
tcp.c:1574:			    (sk->shutdown & RCV_SHUTDOWN) ||
tcp.c:1580:			if (sk->done)
tcp.c:1583:			if (sk->err) {
tcp.c:1588:			if (sk->shutdown & RCV_SHUTDOWN)
tcp.c:1591:			if (sk->state == TCP_CLOSE) {
tcp.c:1592:				if (!sk->done) {
tcp.c:1596:					copied = -ENOTCONN;
tcp.c:1603:				copied = -EAGAIN;
tcp.c:1615:		if (tp->ucopy.task == user_recv) {
tcp.c:1619:				tp->ucopy.task = user_recv;
tcp.c:1620:				tp->ucopy.iov = msg->msg_iov;
tcp.c:1623:			tp->ucopy.len = len;
tcp.c:1625:			BUG_TRAP(tp->copied_seq == tp->rcv_nxt || (flags&(MSG_PEEK|MSG_TRUNC)));
tcp.c:1647:			 * Shortly, algorithm is clear --- to process all
tcp.c:1653:			if (skb_queue_len(&tp->ucopy.prequeue))
tcp.c:1672:			if ((chunk = len - tp->ucopy.len) != 0) {
tcp.c:1674:				len -= chunk;
tcp.c:1678:			if (tp->rcv_nxt == tp->copied_seq &&
tcp.c:1679:			    skb_queue_len(&tp->ucopy.prequeue)) {
tcp.c:1683:				if ((chunk = len - tp->ucopy.len) != 0) {
tcp.c:1685:					len -= chunk;
tcp.c:1690:		if ((flags & MSG_PEEK) && peek_seq != tp->copied_seq) {
tcp.c:1693:				       current->comm, current->pid);
tcp.c:1694:			peek_seq = tp->copied_seq;
tcp.c:1700:		used = skb->len - offset;
tcp.c:1705:		if (tp->urg_data) {
tcp.c:1706:			u32 urg_offset = tp->urg_seq - *seq;
tcp.c:1709:					if (!sk->urginline) {
tcp.c:1712:						used--;
tcp.c:1722:			err = skb_copy_datagram_iovec(skb, offset, msg->msg_iov, used);
tcp.c:1726:					copied = -EFAULT;
tcp.c:1733:		len -= used;
tcp.c:1736:		if (tp->urg_data && after(tp->copied_seq,tp->urg_seq)) {
tcp.c:1737:			tp->urg_data = 0;
tcp.c:1740:		if (used + offset < skb->len)
tcp.c:1743:		if (skb->h.th->fin)
tcp.c:1758:		if (skb_queue_len(&tp->ucopy.prequeue)) {
tcp.c:1761:			tp->ucopy.len = copied > 0 ? len : 0;
tcp.c:1765:			if (copied > 0 && (chunk = len - tp->ucopy.len) != 0) {
tcp.c:1767:				len -= chunk;
tcp.c:1772:		tp->ucopy.task = NULL;
tcp.c:1773:		tp->ucopy.len = 0;
tcp.c:1777:	 * on connected socket. I was just happy when found this 8) --ANK
tcp.c:1822:	int next = (int) new_state[sk->state];
tcp.c:1832: *	that we don't receive shut down or set sk->dead.
tcp.c:1845:	if ((1 << sk->state) &
tcp.c:1860:	return ((1 << sk->state) & (TCPF_FIN_WAIT1|TCPF_CLOSING|TCPF_LAST_ACK));
tcp.c:1866:	__skb_queue_purge(&sk->receive_queue);
tcp.c:1869:	__skb_queue_purge(&sk->error_queue);
tcp.c:1872:	BUG_TRAP(skb_queue_empty(&sk->write_queue));
tcp.c:1877:	BUG_TRAP(sk->wmem_queued == 0);
tcp.c:1878:	BUG_TRAP(sk->forward_alloc == 0);
tcp.c:1894:	BUG_TRAP(sk->state==TCP_CLOSE);
tcp.c:1895:	BUG_TRAP(sk->dead);
tcp.c:1898:	BUG_TRAP(sk->pprev==NULL);
tcp.c:1900:	/* If it has not 0 sk->num, it must be bound */
tcp.c:1901:	BUG_TRAP(!sk->num || sk->prev!=NULL);
tcp.c:1904:	if (sk->zapped) {
tcp.c:1908:	sk->zapped = 1;
tcp.c:1911:	sk->prot->destroy(sk);
tcp.c:1916:	if (atomic_read(&sk->refcnt) != 1) {
tcp.c:1917:		printk(KERN_DEBUG "Destruction TCP %p delayed, c=%d\n", sk, atomic_read(&sk->refcnt));
tcp.c:1931:	sk->shutdown = SHUTDOWN_MASK;
tcp.c:1933:	if(sk->state == TCP_LISTEN) {
tcp.c:1943:	 *  descriptor close, not protocol-sourced closes, because the
tcp.c:1946:	while((skb=__skb_dequeue(&sk->receive_queue))!=NULL) {
tcp.c:1947:		u32 len = TCP_SKB_CB(skb)->end_seq - TCP_SKB_CB(skb)->seq - skb->h.th->fin;
tcp.c:1954:	/* As outlined in draft-ietf-tcpimpl-prob-03.txt, section
tcp.c:1959:	 * for the client to advertise a zero window, then kill -9
tcp.c:1968:	} else if (sk->linger && sk->lingertime==0) {
tcp.c:1970:		sk->prot->disconnect(sk, 0);
tcp.c:1977:		/* RED-PEN. Formally speaking, we have broken TCP state
tcp.c:1980:		 * TCP_ESTABLISHED -> TCP_FIN_WAIT1
tcp.c:1981:		 * TCP_SYN_RECV	-> TCP_FIN_WAIT1 (forget it, it's impossible)
tcp.c:1982:		 * TCP_CLOSE_WAIT -> TCP_LAST_ACK
tcp.c:1988:		 * if Linux state is FIN-WAIT-1, but FIN is still not sent.
tcp.c:1991:		 * we enter time-wait state, when it is not required really
tcp.c:1996:		 * 						--ANK
tcp.c:2005:		add_wait_queue(sk->sleep, &wait);
tcp.c:2016:		tsk->state = TASK_RUNNING;
tcp.c:2017:		remove_wait_queue(sk->sleep, &wait);
tcp.c:2030:	BUG_TRAP(sk->lock.users==0);
tcp.c:2039:	 *	our end. If they send after that then tough - BUT: long enough
tcp.c:2040:	 *	that we won't make the old 4*rto = almost no time - whoops
tcp.c:2046:	 *	linger2	option.					--ANK
tcp.c:2049:	if (sk->state == TCP_FIN_WAIT2) {
tcp.c:2050:		struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp.c:2051:		if (tp->linger2 < 0) {
tcp.c:2067:	if (sk->state != TCP_CLOSE) {
tcp.c:2070:		    (sk->wmem_queued > SOCK_MIN_SNDBUF &&
tcp.c:2081:	if (sk->state == TCP_CLOSE)
tcp.c:2102:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tcp.c:2106:	old_state = sk->state;
tcp.c:2114:		   (tp->snd_nxt != tp->write_seq &&
tcp.c:2120:		sk->err = ECONNRESET;
tcp.c:2122:		sk->err = ECONNRESET;
tcp.c:2125:	__skb_queue_purge(&sk->receive_queue);
tcp.c:2127:  	__skb_queue_purge(&tp->out_of_order_queue);
tcp.c:2129:	sk->dport = 0;
tcp.c:2131:	if (!(sk->userlocks&SOCK_BINDADDR_LOCK)) {
tcp.c:2132:		sk->rcv_saddr = 0;
tcp.c:2133:		sk->saddr = 0;
tcp.c:2135:		memset(&sk->net_pinfo.af_inet6.saddr, 0, 16);
tcp.c:2136:		memset(&sk->net_pinfo.af_inet6.rcv_saddr, 0, 16);
tcp.c:2140:	sk->shutdown = 0;
tcp.c:2141:	sk->done = 0;
tcp.c:2142:	tp->srtt = 0;
tcp.c:2143:	if ((tp->write_seq += tp->max_window+2) == 0)
tcp.c:2144:		tp->write_seq = 1;
tcp.c:2145:	tp->backoff = 0;
tcp.c:2146:	tp->snd_cwnd = 2;
tcp.c:2147:	tp->probes_out = 0;
tcp.c:2148:	tp->packets_out = 0;
tcp.c:2149:	tp->snd_ssthresh = 0x7fffffff;
tcp.c:2150:	tp->snd_cwnd_cnt = 0;
tcp.c:2151:	tp->ca_state = TCP_CA_Open;
tcp.c:2154:	tp->send_head = NULL;
tcp.c:2155:	tp->saw_tstamp = 0;
tcp.c:2159:	BUG_TRAP(!sk->num || sk->prev);
tcp.c:2161:	sk->error_report(sk);
tcp.c:2175:	 * True wake-one mechanism for incoming connections: only
tcp.c:2181:	 * after any current non-exclusive waiters, and we know that
tcp.c:2182:	 * it will always _stay_ after any new non-exclusive waiters
tcp.c:2183:	 * because all non-exclusive waiters are added at the
tcp.c:2184:	 * beginning of the wait-queue. As such, it's ok to "drop"
tcp.c:2186:	 * having to remove and re-insert us on the wait queue.
tcp.c:2188:	add_wait_queue_exclusive(sk->sleep, &wait);
tcp.c:2190:		current->state = TASK_INTERRUPTIBLE;
tcp.c:2192:		if (sk->tp_pinfo.af_tcp.accept_queue == NULL)
tcp.c:2196:		if (sk->tp_pinfo.af_tcp.accept_queue)
tcp.c:2198:		err = -EINVAL;
tcp.c:2199:		if (sk->state != TCP_LISTEN)
tcp.c:2204:		err = -EAGAIN;
tcp.c:2208:	current->state = TASK_RUNNING;
tcp.c:2209:	remove_wait_queue(sk->sleep, &wait);
tcp.c:2219:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tcp.c:2229:	error = -EINVAL;
tcp.c:2230:	if (sk->state != TCP_LISTEN)
tcp.c:2234:	if (!tp->accept_queue) {
tcp.c:2238:		error = -EAGAIN;
tcp.c:2247:	req = tp->accept_queue;
tcp.c:2248:	if ((tp->accept_queue = req->dl_next) == NULL)
tcp.c:2249:		tp->accept_queue_tail = NULL;
tcp.c:2251: 	newsk = req->sk;
tcp.c:2254:	BUG_TRAP(newsk->state != TCP_SYN_RECV);
tcp.c:2271:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp.c:2276:		return tp->af_specific->setsockopt(sk, level, optname, 
tcp.c:2280:		return -EINVAL;
tcp.c:2283:		return -EFAULT;
tcp.c:2294:			err = -EINVAL;
tcp.c:2297:		tp->user_mss = val;
tcp.c:2304:		if (tp->nonagle == 2) {
tcp.c:2305:			err = -EINVAL;
tcp.c:2308:		tp->nonagle = (val == 0) ? 0 : 1;
tcp.c:2314:		/* When set indicates to always queue non-full frames.
tcp.c:2325:		if (tp->nonagle == 1) {
tcp.c:2326:			err = -EINVAL;
tcp.c:2330:			tp->nonagle = 2;
tcp.c:2332:			tp->nonagle = 0;
tcp.c:2340:			err = -EINVAL;
tcp.c:2342:			tp->keepalive_time = val * HZ;
tcp.c:2343:			if (sk->keepopen && !((1<<sk->state)&(TCPF_CLOSE|TCPF_LISTEN))) {
tcp.c:2344:				__u32 elapsed = tcp_time_stamp - tp->rcv_tstamp;
tcp.c:2345:				if (tp->keepalive_time > elapsed)
tcp.c:2346:					elapsed = tp->keepalive_time - elapsed;
tcp.c:2355:			err = -EINVAL;
tcp.c:2357:			tp->keepalive_intvl = val * HZ;
tcp.c:2361:			err = -EINVAL;
tcp.c:2363:			tp->keepalive_probes = val;
tcp.c:2367:			err = -EINVAL;
tcp.c:2369:			tp->syn_retries = val;
tcp.c:2374:			tp->linger2 = -1;
tcp.c:2376:			tp->linger2 = 0;
tcp.c:2378:			tp->linger2 = val*HZ;
tcp.c:2382:		tp->defer_accept = 0;
tcp.c:2385:			while (tp->defer_accept < 32 && val > ((TCP_TIMEOUT_INIT/HZ)<<tp->defer_accept))
tcp.c:2386:				tp->defer_accept++;
tcp.c:2387:			tp->defer_accept++;
tcp.c:2393:			if (sk->state != TCP_CLOSE) {
tcp.c:2394:				err = -EINVAL;
tcp.c:2397:			tp->window_clamp = 0;
tcp.c:2399:			tp->window_clamp = val<SOCK_MIN_RCVBUF/2 ?
tcp.c:2406:			tp->ack.pingpong = 1;
tcp.c:2408:			tp->ack.pingpong = 0;
tcp.c:2409:			if ((1<<sk->state)&(TCPF_ESTABLISHED|TCPF_CLOSE_WAIT) &&
tcp.c:2411:				tp->ack.pending |= TCP_ACK_PUSHED;
tcp.c:2414:					tp->ack.pingpong = 1;
tcp.c:2420:		if(sk->state != TCP_CLOSE || tp->trickles_opt != 0) {
tcp.c:2421:			err = -EINVAL;
tcp.c:2427:		if(!((tp->trickles_opt & TCP_TRICKLES_ENABLE) && sk->state == TCP_LISTEN)) {
tcp.c:2428:			printk("setsockopt: CMINISOCK configuration attempted, but either TRICKLES not enabled, or sk->state != TCP_LISTEN\n");
tcp.c:2429:			err = -EINVAL;
tcp.c:2439:		tp->drop_rate = val;
tcp.c:2442:		tp->instrumentation = val;
tcp.c:2446:		err = -ENOPROTOOPT;
tcp.c:2456:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp.c:2460:		return tp->af_specific->getsockopt(sk, level, optname,
tcp.c:2464:		return -EFAULT;
tcp.c:2469:		return -EINVAL;
tcp.c:2473:		val = tp->mss_cache;
tcp.c:2474:		if (val == 0 && ((1<<sk->state)&(TCPF_CLOSE|TCPF_LISTEN)))
tcp.c:2475:			val = tp->user_mss;
tcp.c:2478:		val = (tp->nonagle == 1);
tcp.c:2481:		val = (tp->nonagle == 2);
tcp.c:2484:		val = (tp->keepalive_time ? : sysctl_tcp_keepalive_time)/HZ;
tcp.c:2487:		val = (tp->keepalive_intvl ? : sysctl_tcp_keepalive_intvl)/HZ;
tcp.c:2490:		val = tp->keepalive_probes ? : sysctl_tcp_keepalive_probes;
tcp.c:2493:		val = tp->syn_retries ? : sysctl_tcp_syn_retries;
tcp.c:2496:		val = tp->linger2;
tcp.c:2501:		val = tp->defer_accept == 0 ? 0 : ((TCP_TIMEOUT_INIT/HZ)<<(tp->defer_accept-1));
tcp.c:2504:		val = tp->window_clamp;
tcp.c:2512:			return -EFAULT;
tcp.c:2513:		info.tcpi_state = sk->state;
tcp.c:2514:		info.tcpi_ca_state = tp->ca_state;
tcp.c:2515:		info.tcpi_retransmits = tp->retransmits;
tcp.c:2516:		info.tcpi_probes = tp->probes_out;
tcp.c:2517:		info.tcpi_backoff = tp->backoff;
tcp.c:2519:		if (tp->tstamp_ok)
tcp.c:2521:		if (tp->sack_ok)
tcp.c:2523:		if (tp->wscale_ok) {
tcp.c:2525:			info.tcpi_snd_wscale = tp->snd_wscale;
tcp.c:2526:			info.tcpi_rcv_wscale = tp->rcv_wscale;
tcp.c:2531:		if (tp->ecn_flags&TCP_ECN_OK)
tcp.c:2534:		info.tcpi_rto = (1000000*tp->rto)/HZ;
tcp.c:2535:		info.tcpi_ato = (1000000*tp->ack.ato)/HZ;
tcp.c:2536:		info.tcpi_snd_mss = tp->mss_cache;
tcp.c:2537:		info.tcpi_rcv_mss = tp->ack.rcv_mss;
tcp.c:2539:		info.tcpi_unacked = tp->packets_out;
tcp.c:2540:		info.tcpi_sacked = tp->sacked_out;
tcp.c:2541:		info.tcpi_lost = tp->lost_out;
tcp.c:2542:		info.tcpi_retrans = tp->retrans_out;
tcp.c:2543:		info.tcpi_fackets = tp->fackets_out;
tcp.c:2545:		info.tcpi_last_data_sent = ((now - tp->lsndtime)*1000)/HZ;
tcp.c:2547:		info.tcpi_last_data_recv = ((now - tp->ack.lrcvtime)*1000)/HZ;
tcp.c:2548:		info.tcpi_last_ack_recv = ((now - tp->rcv_tstamp)*1000)/HZ;
tcp.c:2550:		info.tcpi_pmtu = tp->pmtu_cookie;
tcp.c:2551:		info.tcpi_rcv_ssthresh = tp->rcv_ssthresh;
tcp.c:2552:		info.tcpi_rtt = ((1000000*tp->srtt)/HZ)>>3;
tcp.c:2553:		info.tcpi_rttvar = ((1000000*tp->mdev)/HZ)>>2;
tcp.c:2554:		info.tcpi_snd_ssthresh = tp->snd_ssthresh;
tcp.c:2555:		info.tcpi_snd_cwnd = tp->snd_cwnd;
tcp.c:2556:		info.tcpi_advmss = tp->advmss;
tcp.c:2557:		info.tcpi_reordering = tp->reordering;
tcp.c:2561:			return -EFAULT;
tcp.c:2563:			return -EFAULT;
tcp.c:2567:		val = !tp->ack.pingpong;
tcp.c:2570:		val = tp->trickles_opt;
tcp.c:2573:		if(!((tp->trickles_opt & TCP_TRICKLES_ENABLE) && sk->state == TCP_LISTEN)) {
tcp.c:2574:			return -EINVAL;
tcp.c:2580: 		val = tp->mac_changed;
tcp.c:2583:		if(tp->trickles_opt & TCP_TRICKLES_ENABLE) {
tcp.c:2586:		return -ENOPROTOOPT;
tcp.c:2590:  		return -EFAULT;
tcp.c:2592:		return -EFAULT;
tcp.c:2606:	if(sizeof(struct tcp_skb_cb) > sizeof(skb->cb))
tcp.c:2608:					   sizeof(skb->cb));
tcp.c:2637:		goal = num_physpages >> (21 - PAGE_SHIFT);
tcp.c:2639:		goal = num_physpages >> (23 - PAGE_SHIFT);
tcp.c:2647:		while (tcp_ehash_size & (tcp_ehash_size-1))
tcp.c:2648:			tcp_ehash_size--;
tcp.c:2651:	} while (tcp_ehash == NULL && --order > 0);
tcp.c:2667:	} while (tcp_bhash == NULL && --order >= 0);
tcp.c:2683:		sysctl_tcp_max_orphans = 4096<<(order-4);
tcp.c:2686:		sysctl_local_port_range[0] = 1024*(3-order);
tcp.c:2687:		sysctl_tcp_max_tw_buckets >>= (3-order);
tcp.c:2688:		sysctl_tcp_max_orphans >>= (3-order);
tcp.c:2691:	tcp_port_rover = sysctl_local_port_range[0] - 1;
tcp.c:2696:	if (sysctl_tcp_mem[2] - sysctl_tcp_mem[1] > 512)
tcp.c:2697:		sysctl_tcp_mem[1] = sysctl_tcp_mem[2] - 512;
tcp.c:2698:	if (sysctl_tcp_mem[1] - sysctl_tcp_mem[0] > 512)
tcp.c:2699:		sysctl_tcp_mem[0] = sysctl_tcp_mem[1] - 512;
tcp_diag.c:40:   rta->rta_type = attrtype;                \
tcp_diag.c:41:   rta->rta_len = rtalen;                   \
tcp_diag.c:47:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tcp_diag.c:52:	unsigned char	 *b = skb->tail;
tcp_diag.c:56:	if (sk->state != TCP_TIME_WAIT) {
tcp_diag.c:57:		if (ext & (1<<(TCPDIAG_MEMINFO-1)))
tcp_diag.c:59:		if (ext & (1<<(TCPDIAG_INFO-1)))
tcp_diag.c:62:	r->tcpdiag_family = sk->family;
tcp_diag.c:63:	r->tcpdiag_state = sk->state;
tcp_diag.c:64:	r->tcpdiag_timer = 0;
tcp_diag.c:65:	r->tcpdiag_retrans = 0;
tcp_diag.c:67:	r->id.tcpdiag_sport = sk->sport;
tcp_diag.c:68:	r->id.tcpdiag_dport = sk->dport;
tcp_diag.c:69:	r->id.tcpdiag_src[0] = sk->rcv_saddr;
tcp_diag.c:70:	r->id.tcpdiag_dst[0] = sk->daddr;
tcp_diag.c:71:	r->id.tcpdiag_if = sk->bound_dev_if;
tcp_diag.c:72:	r->id.tcpdiag_cookie[0] = (u32)(unsigned long)sk;
tcp_diag.c:73:	r->id.tcpdiag_cookie[1] = (u32)(((unsigned long)sk >> 31) >> 1);
tcp_diag.c:75:	if (r->tcpdiag_state == TCP_TIME_WAIT) {
tcp_diag.c:77:		long tmo = tw->ttd - jiffies;
tcp_diag.c:81:		r->tcpdiag_state = tw->substate;
tcp_diag.c:82:		r->tcpdiag_timer = 3;
tcp_diag.c:83:		r->tcpdiag_expires = (tmo*1000+HZ-1)/HZ;
tcp_diag.c:84:		r->tcpdiag_rqueue = 0;
tcp_diag.c:85:		r->tcpdiag_wqueue = 0;
tcp_diag.c:86:		r->tcpdiag_uid = 0;
tcp_diag.c:87:		r->tcpdiag_inode = 0;
tcp_diag.c:89:		if (r->tcpdiag_family == AF_INET6) {
tcp_diag.c:90:			memcpy(r->id.tcpdiag_src, &tw->v6_rcv_saddr, 16);
tcp_diag.c:91:			memcpy(r->id.tcpdiag_dst, &tw->v6_daddr, 16);
tcp_diag.c:94:		nlh->nlmsg_len = skb->tail - b;
tcp_diag.c:95:		return skb->len;
tcp_diag.c:99:	if (r->tcpdiag_family == AF_INET6) {
tcp_diag.c:100:		memcpy(r->id.tcpdiag_src, &sk->net_pinfo.af_inet6.rcv_saddr, 16);
tcp_diag.c:101:		memcpy(r->id.tcpdiag_dst, &sk->net_pinfo.af_inet6.daddr, 16);
tcp_diag.c:105:#define EXPIRES_IN_MS(tmo)  ((tmo-jiffies)*1000+HZ-1)/HZ
tcp_diag.c:107:	if (tp->pending == TCP_TIME_RETRANS) {
tcp_diag.c:108:		r->tcpdiag_timer = 1;
tcp_diag.c:109:		r->tcpdiag_retrans = tp->retransmits;
tcp_diag.c:110:		r->tcpdiag_expires = EXPIRES_IN_MS(tp->timeout);
tcp_diag.c:111:	} else if (tp->pending == TCP_TIME_PROBE0) {
tcp_diag.c:112:		r->tcpdiag_timer = 4;
tcp_diag.c:113:		r->tcpdiag_retrans = tp->probes_out;
tcp_diag.c:114:		r->tcpdiag_expires = EXPIRES_IN_MS(tp->timeout);
tcp_diag.c:115:	} else if (timer_pending(&sk->timer)) {
tcp_diag.c:116:		r->tcpdiag_timer = 2;
tcp_diag.c:117:		r->tcpdiag_retrans = tp->probes_out;
tcp_diag.c:118:		r->tcpdiag_expires = EXPIRES_IN_MS(sk->timer.expires);
tcp_diag.c:120:		r->tcpdiag_timer = 0;
tcp_diag.c:121:		r->tcpdiag_expires = 0;
tcp_diag.c:125:	r->tcpdiag_rqueue = tp->rcv_nxt - tp->copied_seq;
tcp_diag.c:126:	r->tcpdiag_wqueue = tp->write_seq - tp->snd_una;
tcp_diag.c:127:	r->tcpdiag_uid = sock_i_uid(sk);
tcp_diag.c:128:	r->tcpdiag_inode = sock_i_ino(sk);
tcp_diag.c:131:		minfo->tcpdiag_rmem = atomic_read(&sk->rmem_alloc);
tcp_diag.c:132:		minfo->tcpdiag_wmem = sk->wmem_queued;
tcp_diag.c:133:		minfo->tcpdiag_fmem = sk->forward_alloc;
tcp_diag.c:134:		minfo->tcpdiag_tmem = atomic_read(&sk->wmem_alloc);
tcp_diag.c:140:		info->tcpi_state = sk->state;
tcp_diag.c:141:		info->tcpi_ca_state = tp->ca_state;
tcp_diag.c:142:		info->tcpi_retransmits = tp->retransmits;
tcp_diag.c:143:		info->tcpi_probes = tp->probes_out;
tcp_diag.c:144:		info->tcpi_backoff = tp->backoff;
tcp_diag.c:145:		info->tcpi_options = 0;
tcp_diag.c:146:		if (tp->tstamp_ok)
tcp_diag.c:147:			info->tcpi_options |= TCPI_OPT_TIMESTAMPS;
tcp_diag.c:148:		if (tp->sack_ok)
tcp_diag.c:149:			info->tcpi_options |= TCPI_OPT_SACK;
tcp_diag.c:150:		if (tp->wscale_ok) {
tcp_diag.c:151:			info->tcpi_options |= TCPI_OPT_WSCALE;
tcp_diag.c:152:			info->tcpi_snd_wscale = tp->snd_wscale;
tcp_diag.c:153:			info->tcpi_rcv_wscale = tp->rcv_wscale;
tcp_diag.c:155:			info->tcpi_snd_wscale = 0;
tcp_diag.c:156:			info->tcpi_rcv_wscale = 0;
tcp_diag.c:159:		if (tp->ecn_flags&TCP_ECN_OK)
tcp_diag.c:160:			info->tcpi_options |= TCPI_OPT_ECN;
tcp_diag.c:163:		info->tcpi_rto = (1000000*tp->rto)/HZ;
tcp_diag.c:164:		info->tcpi_ato = (1000000*tp->ack.ato)/HZ;
tcp_diag.c:165:		info->tcpi_snd_mss = tp->mss_cache;
tcp_diag.c:166:		info->tcpi_rcv_mss = tp->ack.rcv_mss;
tcp_diag.c:168:		info->tcpi_unacked = tp->packets_out;
tcp_diag.c:169:		info->tcpi_sacked = tp->sacked_out;
tcp_diag.c:170:		info->tcpi_lost = tp->lost_out;
tcp_diag.c:171:		info->tcpi_retrans = tp->retrans_out;
tcp_diag.c:172:		info->tcpi_fackets = tp->fackets_out;
tcp_diag.c:174:		info->tcpi_last_data_sent = ((now - tp->lsndtime)*1000)/HZ;
tcp_diag.c:175:		info->tcpi_last_ack_sent = 0;
tcp_diag.c:176:		info->tcpi_last_data_recv = ((now - tp->ack.lrcvtime)*1000)/HZ;
tcp_diag.c:177:		info->tcpi_last_ack_recv = ((now - tp->rcv_tstamp)*1000)/HZ;
tcp_diag.c:179:		info->tcpi_pmtu = tp->pmtu_cookie;
tcp_diag.c:180:		info->tcpi_rcv_ssthresh = tp->rcv_ssthresh;
tcp_diag.c:181:		info->tcpi_rtt = ((1000000*tp->srtt)/HZ)>>3;
tcp_diag.c:182:		info->tcpi_rttvar = ((1000000*tp->mdev)/HZ)>>2;
tcp_diag.c:183:		info->tcpi_snd_ssthresh = tp->snd_ssthresh;
tcp_diag.c:184:		info->tcpi_snd_cwnd = tp->snd_cwnd;
tcp_diag.c:185:		info->tcpi_advmss = tp->advmss;
tcp_diag.c:186:		info->tcpi_reordering = tp->reordering;
tcp_diag.c:189:	nlh->nlmsg_len = skb->tail - b;
tcp_diag.c:190:	return skb->len;
tcp_diag.c:193:	skb_trim(skb, b - skb->data);
tcp_diag.c:194:	return -1;
tcp_diag.c:211:	if (req->tcpdiag_family == AF_INET) {
tcp_diag.c:212:		sk = tcp_v4_lookup(req->id.tcpdiag_dst[0], req->id.tcpdiag_dport,
tcp_diag.c:213:				   req->id.tcpdiag_src[0], req->id.tcpdiag_sport,
tcp_diag.c:214:				   req->id.tcpdiag_if);
tcp_diag.c:217:	else if (req->tcpdiag_family == AF_INET6) {
tcp_diag.c:218:		sk = tcp_v6_lookup((struct in6_addr*)req->id.tcpdiag_dst, req->id.tcpdiag_dport,
tcp_diag.c:219:				   (struct in6_addr*)req->id.tcpdiag_src, req->id.tcpdiag_sport,
tcp_diag.c:220:				   req->id.tcpdiag_if);
tcp_diag.c:224:		return -EINVAL;
tcp_diag.c:228:		return -ENOENT;
tcp_diag.c:230:	err = -ESTALE;
tcp_diag.c:231:	if ((req->id.tcpdiag_cookie[0] != TCPDIAG_NOCOOKIE ||
tcp_diag.c:232:	     req->id.tcpdiag_cookie[1] != TCPDIAG_NOCOOKIE) &&
tcp_diag.c:233:	    ((u32)(unsigned long)sk != req->id.tcpdiag_cookie[0] ||
tcp_diag.c:234:	     (u32)((((unsigned long)sk) >> 31) >> 1) != req->id.tcpdiag_cookie[1]))
tcp_diag.c:237:	err = -ENOMEM;
tcp_diag.c:244:	if (tcpdiag_fill(rep, sk, req->tcpdiag_ext,
tcp_diag.c:246:			 nlh->nlmsg_seq) <= 0)
tcp_diag.c:255:		if (sk->state == TCP_TIME_WAIT)
tcp_diag.c:280:		mask = htonl((0xffffffff) << (32 - bits));
tcp_diag.c:296:		switch (op->code) {
tcp_diag.c:303:			yes = (sk->num >= op[1].no);
tcp_diag.c:306:			yes = (sk->num <= op[1].no);
tcp_diag.c:309:			yes = (ntohs(sk->dport) >= op[1].no);
tcp_diag.c:312:			yes = (ntohs(sk->dport) <= op[1].no);
tcp_diag.c:315:			yes = !(sk->userlocks&SOCK_BINDPORT_LOCK);
tcp_diag.c:323:			if (cond->port != -1 &&
tcp_diag.c:324:			    cond->port != (op->code == TCPDIAG_BC_S_COND ? sk->num : ntohs(sk->dport))) {
tcp_diag.c:329:			if (cond->prefix_len == 0)
tcp_diag.c:333:			if (sk->family == AF_INET6) {
tcp_diag.c:334:				if (op->code == TCPDIAG_BC_S_COND)
tcp_diag.c:335:					addr = (u32*)&sk->net_pinfo.af_inet6.rcv_saddr;
tcp_diag.c:337:					addr = (u32*)&sk->net_pinfo.af_inet6.daddr;
tcp_diag.c:341:				if (op->code == TCPDIAG_BC_S_COND)
tcp_diag.c:342:					addr = &sk->rcv_saddr;
tcp_diag.c:344:					addr = &sk->daddr;
tcp_diag.c:347:			if (bitstring_match(addr, cond->addr, cond->prefix_len))
tcp_diag.c:349:			if (sk->family == AF_INET6 && cond->family == AF_INET) {
tcp_diag.c:352:				    bitstring_match(addr+3, cond->addr, cond->prefix_len))
tcp_diag.c:361:			len -= op->yes;
tcp_diag.c:362:			bc += op->yes;
tcp_diag.c:364:			len -= op->no;
tcp_diag.c:365:			bc += op->no;
tcp_diag.c:380:		if (op->yes < 4)
tcp_diag.c:382:		len -= op->yes;
tcp_diag.c:383:		bc  += op->yes;
tcp_diag.c:396://printk("BC: %d %d %d {%d} / %d\n", op->code, op->yes, op->no, op[1].no, len);
tcp_diag.c:397:		switch (op->code) {
tcp_diag.c:405:			if (op->yes < 4 || op->yes > len+4)
tcp_diag.c:406:				return -EINVAL;
tcp_diag.c:408:			if (op->no < 4 || op->no > len+4)
tcp_diag.c:409:				return -EINVAL;
tcp_diag.c:410:			if (op->no < len &&
tcp_diag.c:411:			    !valid_cc(bytecode, bytecode_len, len-op->no))
tcp_diag.c:412:				return -EINVAL;
tcp_diag.c:415:			if (op->yes < 4 || op->yes > len+4)
tcp_diag.c:416:				return -EINVAL;
tcp_diag.c:419:			return -EINVAL;
tcp_diag.c:421:		bc += op->yes;
tcp_diag.c:422:		len -= op->yes;
tcp_diag.c:424:	return len == 0 ? 0 : -EINVAL;
tcp_diag.c:432:	struct tcpdiagreq *r = NLMSG_DATA(cb->nlh);
tcp_diag.c:435:	if (cb->nlh->nlmsg_len > 4+NLMSG_SPACE(sizeof(struct tcpdiagreq)))
tcp_diag.c:438:	s_i = cb->args[1];
tcp_diag.c:439:	s_num = num = cb->args[2];
tcp_diag.c:441:	if (cb->args[0] == 0) {
tcp_diag.c:442:		if (!(r->tcpdiag_states&(TCPF_LISTEN|TCPF_SYN_RECV)))
tcp_diag.c:453:			     sk = sk->next, num++) {
tcp_diag.c:456:				if (!(r->tcpdiag_states&TCPF_LISTEN) ||
tcp_diag.c:457:				    r->id.tcpdiag_dport)
tcp_diag.c:459:				if (r->id.tcpdiag_sport != sk->sport && r->id.tcpdiag_sport)
tcp_diag.c:463:				if (tcpdiag_fill(skb, sk, r->tcpdiag_ext,
tcp_diag.c:464:						 NETLINK_CB(cb->skb).pid,
tcp_diag.c:465:						 cb->nlh->nlmsg_seq) <= 0) {
tcp_diag.c:473:		cb->args[0] = 1;
tcp_diag.c:477:	if (!(r->tcpdiag_states&~(TCPF_LISTEN|TCPF_SYN_RECV)))
tcp_diag.c:478:		return skb->len;
tcp_diag.c:487:		read_lock_bh(&head->lock);
tcp_diag.c:489:		for (sk = head->chain, num = 0;
tcp_diag.c:491:		     sk = sk->next, num++) {
tcp_diag.c:494:			if (!(r->tcpdiag_states&(1<<sk->state)))
tcp_diag.c:496:			if (r->id.tcpdiag_sport != sk->sport && r->id.tcpdiag_sport)
tcp_diag.c:498:			if (r->id.tcpdiag_dport != sk->dport && r->id.tcpdiag_dport)
tcp_diag.c:502:			if (tcpdiag_fill(skb, sk, r->tcpdiag_ext,
tcp_diag.c:503:					 NETLINK_CB(cb->skb).pid,
tcp_diag.c:504:					 cb->nlh->nlmsg_seq) <= 0) {
tcp_diag.c:505:				read_unlock_bh(&head->lock);
tcp_diag.c:510:		if (r->tcpdiag_states&TCPF_TIME_WAIT) {
tcp_diag.c:513:			     sk = sk->next, num++) {
tcp_diag.c:516:				if (!(r->tcpdiag_states&(1<<sk->zapped)))
tcp_diag.c:518:				if (r->id.tcpdiag_sport != sk->sport && r->id.tcpdiag_sport)
tcp_diag.c:520:				if (r->id.tcpdiag_dport != sk->dport && r->id.tcpdiag_dport)
tcp_diag.c:524:				if (tcpdiag_fill(skb, sk, r->tcpdiag_ext,
tcp_diag.c:525:						 NETLINK_CB(cb->skb).pid,
tcp_diag.c:526:						 cb->nlh->nlmsg_seq) <= 0) {
tcp_diag.c:527:					read_unlock_bh(&head->lock);
tcp_diag.c:532:		read_unlock_bh(&head->lock);
tcp_diag.c:536:	cb->args[1] = i;
tcp_diag.c:537:	cb->args[2] = num;
tcp_diag.c:538:	return skb->len;
tcp_diag.c:550:	if (!(nlh->nlmsg_flags&NLM_F_REQUEST))
tcp_diag.c:553:	if (nlh->nlmsg_type != TCPDIAG_GETSOCK)
tcp_diag.c:556:	if (NLMSG_LENGTH(sizeof(struct tcpdiagreq)) > skb->len)
tcp_diag.c:559:	if (nlh->nlmsg_flags&NLM_F_DUMP) {
tcp_diag.c:560:		if (nlh->nlmsg_len > 4 + NLMSG_SPACE(sizeof(struct tcpdiagreq))) {
tcp_diag.c:562:			if (rta->rta_type != TCPDIAG_REQ_BYTECODE ||
tcp_diag.c:563:			    rta->rta_len < 8 ||
tcp_diag.c:564:			    rta->rta_len > nlh->nlmsg_len - NLMSG_SPACE(sizeof(struct tcpdiagreq)))
tcp_diag.c:577:	return -EINVAL;
tcp_diag.c:586:	if (skb->len >= NLMSG_SPACE(0)) {
tcp_diag.c:587:		nlh = (struct nlmsghdr *)skb->data;
tcp_diag.c:588:		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
tcp_diag.c:591:		if (err || nlh->nlmsg_flags & NLM_F_ACK) 
tcp_diag.c:600:	while ((skb = skb_dequeue(&sk->receive_queue)) != NULL) {
tcp_input.c:13: *		Corey Minyard <wf-rch!minyard@relay.EU.net>
tcp_input.c:14: *		Florian La Roche, <flla@stud.uni-sb.de>
tcp_input.c:63: *		Pasi Sarolahti:		F-RTO for dealing with spurious RTOs
tcp_input.c:112:#define IsReno(tp) ((tp)->sack_ok == 0)
tcp_input.c:113:#define IsFack(tp) ((tp)->sack_ok & 2)
tcp_input.c:114:#define IsDSack(tp) ((tp)->sack_ok & 4)
tcp_input.c:125:	lss = tp->ack.last_seg_size; 
tcp_input.c:126:	tp->ack.last_seg_size = 0; 
tcp_input.c:128:	/* skb->len may jitter because of SACKs, even if peer
tcp_input.c:129:	 * sends good full-sized frames.
tcp_input.c:131:	len = skb->len;
tcp_input.c:132:	if (len >= tp->ack.rcv_mss) {
tcp_input.c:133:		tp->ack.rcv_mss = len;
tcp_input.c:140:		len += skb->data - skb->h.raw;
tcp_input.c:145:		     * to handle super-low mtu links fairly.
tcp_input.c:148:		     !(tcp_flag_word(skb->h.th)&TCP_REMNANT))) {
tcp_input.c:153:			len -= tp->tcp_header_len;
tcp_input.c:154:			tp->ack.last_seg_size = len;
tcp_input.c:156:				tp->ack.rcv_mss = len;
tcp_input.c:160:		tp->ack.pending |= TCP_ACK_PUSHED;
tcp_input.c:166:	unsigned quickacks = tp->rcv_wnd/(2*tp->ack.rcv_mss);
tcp_input.c:170:	if (quickacks > tp->ack.quick)
tcp_input.c:171:		tp->ack.quick = min(quickacks, TCP_MAX_QUICKACKS);
tcp_input.c:177:	tp->ack.pingpong = 0;
tcp_input.c:178:	tp->ack.ato = TCP_ATO_MIN;
tcp_input.c:187:	return (tp->ack.quick && !tp->ack.pingpong);
tcp_input.c:192: * 1. Tuning sk->sndbuf, when connection enters established state.
tcp_input.c:197:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:198:	int sndmem = tp->mss_clamp+MAX_TCP_HEADER+16+sizeof(struct sk_buff);
tcp_input.c:200:	if (sk->sndbuf < 3*sndmem)
tcp_input.c:201:		sk->sndbuf = min(3*sndmem, sysctl_tcp_wmem[2]);
tcp_input.c:207: * forward and advertised in receiver window (tp->rcv_wnd) and
tcp_input.c:211: * tcp_full_space(), in this case tcp_full_space() - window_clamp
tcp_input.c:219: * - to enforce header prediction at sender, even when application
tcp_input.c:221: * - to prevent pruning of receive queue because of misprediction
tcp_input.c:234:	int truesize = tcp_win_from_space(skb->truesize)/2;
tcp_input.c:237:	while (tp->rcv_ssthresh <= window) {
tcp_input.c:238:		if (truesize <= skb->len)
tcp_input.c:239:			return 2*tp->ack.rcv_mss;
tcp_input.c:251:	if (tp->rcv_ssthresh < tp->window_clamp &&
tcp_input.c:252:	    (int)tp->rcv_ssthresh < tcp_space(sk) &&
tcp_input.c:259:		if (tcp_win_from_space(skb->truesize) <= skb->len)
tcp_input.c:260:			incr = 2*tp->advmss;
tcp_input.c:265:			tp->rcv_ssthresh = min(tp->rcv_ssthresh + incr, tp->window_clamp);
tcp_input.c:266:			tp->ack.quick |= 1;
tcp_input.c:275:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:276:	int rcvmem = tp->advmss+MAX_TCP_HEADER+16+sizeof(struct sk_buff);
tcp_input.c:278:	/* Try to select rcvbuf so that 4 mss-sized segments
tcp_input.c:282:	while (tcp_win_from_space(rcvmem) < tp->advmss)
tcp_input.c:284:	if (sk->rcvbuf < 4*rcvmem)
tcp_input.c:285:		sk->rcvbuf = min(4*rcvmem, sysctl_tcp_rmem[2]);
tcp_input.c:293:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:296:	if (!(sk->userlocks&SOCK_RCVBUF_LOCK))
tcp_input.c:298:	if (!(sk->userlocks&SOCK_SNDBUF_LOCK))
tcp_input.c:303:	if (tp->window_clamp >= maxwin) {
tcp_input.c:304:		tp->window_clamp = maxwin;
tcp_input.c:306:		if (sysctl_tcp_app_win && maxwin>4*tp->advmss)
tcp_input.c:307:			tp->window_clamp = max(maxwin-(maxwin>>sysctl_tcp_app_win), 4*tp->advmss);
tcp_input.c:312:	    tp->window_clamp > 2*tp->advmss &&
tcp_input.c:313:	    tp->window_clamp + tp->advmss > maxwin)
tcp_input.c:314:		tp->window_clamp = max(2*tp->advmss, maxwin-tp->advmss);
tcp_input.c:316:	tp->rcv_ssthresh = min(tp->rcv_ssthresh, tp->window_clamp);
tcp_input.c:317:	tp->snd_cwnd_stamp = tcp_time_stamp;
tcp_input.c:324:	unsigned int app_win = tp->rcv_nxt - tp->copied_seq;
tcp_input.c:327:	tp->ack.quick = 0;
tcp_input.c:329:	skb_queue_walk(&tp->out_of_order_queue, skb) {
tcp_input.c:330:		ofo_win += skb->len;
tcp_input.c:337:		if (sk->rcvbuf < sysctl_tcp_rmem[2] &&
tcp_input.c:338:		    !(sk->userlocks&SOCK_RCVBUF_LOCK) &&
tcp_input.c:341:			sk->rcvbuf = min(atomic_read(&sk->rmem_alloc), sysctl_tcp_rmem[2]);
tcp_input.c:343:	if (atomic_read(&sk->rmem_alloc) > sk->rcvbuf) {
tcp_input.c:345:		if (atomic_read(&sk->rmem_alloc) >= 2*sk->rcvbuf)
tcp_input.c:347:		if (app_win > tp->ack.rcv_mss)
tcp_input.c:348:			app_win -= tp->ack.rcv_mss;
tcp_input.c:349:		app_win = max(app_win, 2U*tp->advmss);
tcp_input.c:352:			tp->window_clamp = min(tp->window_clamp, app_win);
tcp_input.c:353:		tp->rcv_ssthresh = min(tp->window_clamp, 2U*tp->advmss);
tcp_input.c:358: * behavior of the tp->ato delayed ack timeout interval.  When a
tcp_input.c:365: * queue.  -DaveM
tcp_input.c:377:	if (!tp->ack.ato) {
tcp_input.c:382:		tp->ack.ato = TCP_ATO_MIN;
tcp_input.c:384:		int m = now - tp->ack.lrcvtime;
tcp_input.c:388:			tp->ack.ato = (tp->ack.ato>>1) + TCP_ATO_MIN/2;
tcp_input.c:389:		} else if (m < tp->ack.ato) {
tcp_input.c:390:			tp->ack.ato = (tp->ack.ato>>1) + m;
tcp_input.c:391:			if (tp->ack.ato > tp->rto)
tcp_input.c:392:				tp->ack.ato = tp->rto;
tcp_input.c:393:		} else if (m > tp->rto) {
tcp_input.c:401:	tp->ack.lrcvtime = now;
tcp_input.c:405:	if (skb->len >= 128)
tcp_input.c:416: * it up into three procedures. -- erics
tcp_input.c:441:	if (tp->srtt != 0) {
tcp_input.c:442:		m -= (tp->srtt >> 3);	/* m is now error in rtt est */
tcp_input.c:443:		tp->srtt += m;		/* rtt = 7/8 rtt + 1/8 new */
tcp_input.c:445:			m = -m;		/* m is now abs(error) */
tcp_input.c:446:			m -= (tp->mdev >> 2);   /* similar update on mdev */
tcp_input.c:458:			m -= (tp->mdev >> 2);   /* similar update on mdev */
tcp_input.c:460:		tp->mdev += m;	    	/* mdev = 3/4 mdev + 1/4 new */
tcp_input.c:461:		if (tp->mdev > tp->mdev_max) {
tcp_input.c:462:			tp->mdev_max = tp->mdev;
tcp_input.c:463:			if (tp->mdev_max > tp->rttvar)
tcp_input.c:464:				tp->rttvar = tp->mdev_max;
tcp_input.c:466:		if (after(tp->snd_una, tp->rtt_seq)) {
tcp_input.c:467:			if (tp->mdev_max < tp->rttvar)
tcp_input.c:468:				tp->rttvar -= (tp->rttvar-tp->mdev_max)>>2;
tcp_input.c:469:			tp->rtt_seq = tp->snd_nxt;
tcp_input.c:470:			tp->mdev_max = TCP_RTO_MIN;
tcp_input.c:474:		tp->srtt = m<<3;	/* take the measured time to be rtt */
tcp_input.c:475:		tp->mdev = m<<1;	/* make sure rto = 3*rtt */
tcp_input.c:476:		tp->mdev_max = tp->rttvar = max(tp->mdev, TCP_RTO_MIN);
tcp_input.c:477:		tp->rtt_seq = tp->snd_nxt;
tcp_input.c:480:	tcp_westwood_update_rtt(tp, tp->srtt >> 3);
tcp_input.c:495:	 *    is invisible. Actually, Linux-2.4 also generates erratic
tcp_input.c:499:	tp->rto = (tp->srtt >> 3) + tp->rttvar;
tcp_input.c:502:	tp->rto = (tp->srtt >> 3);
tcp_input.c:517:	if (tp->rto > TCP_RTO_MAX)
tcp_input.c:518:		tp->rto = TCP_RTO_MAX;
tcp_input.c:523:   i.e. when it enters TIME-WAIT or goes from LAST-ACK to CLOSE.
tcp_input.c:527:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:532:	if (dst && (dst->flags&DST_HOST)) {
tcp_input.c:535:		if (tp->backoff || !tp->srtt) {
tcp_input.c:540:			if (!(dst->mxlock&(1<<RTAX_RTT)))
tcp_input.c:541:				dst->rtt = 0;
tcp_input.c:545:		m = dst->rtt - tp->srtt;
tcp_input.c:551:		if (!(dst->mxlock&(1<<RTAX_RTT))) {
tcp_input.c:553:				dst->rtt = tp->srtt;
tcp_input.c:555:				dst->rtt -= (m>>3);
tcp_input.c:558:		if (!(dst->mxlock&(1<<RTAX_RTTVAR))) {
tcp_input.c:560:				m = -m;
tcp_input.c:564:			if (m < tp->mdev)
tcp_input.c:565:				m = tp->mdev;
tcp_input.c:567:			if (m >= dst->rttvar)
tcp_input.c:568:				dst->rttvar = m;
tcp_input.c:570:				dst->rttvar -= (dst->rttvar - m)>>2;
tcp_input.c:573:		if (tp->snd_ssthresh >= 0xFFFF) {
tcp_input.c:575:			if (dst->ssthresh &&
tcp_input.c:576:			    !(dst->mxlock&(1<<RTAX_SSTHRESH)) &&
tcp_input.c:577:			    (tp->snd_cwnd>>1) > dst->ssthresh)
tcp_input.c:578:				dst->ssthresh = (tp->snd_cwnd>>1);
tcp_input.c:579:			if (!(dst->mxlock&(1<<RTAX_CWND)) &&
tcp_input.c:580:			    tp->snd_cwnd > dst->cwnd)
tcp_input.c:581:				dst->cwnd = tp->snd_cwnd;
tcp_input.c:582:		} else if (tp->snd_cwnd > tp->snd_ssthresh &&
tcp_input.c:583:			   tp->ca_state == TCP_CA_Open) {
tcp_input.c:585:			if (!(dst->mxlock&(1<<RTAX_SSTHRESH)))
tcp_input.c:586:				dst->ssthresh = max(tp->snd_cwnd>>1, tp->snd_ssthresh);
tcp_input.c:587:			if (!(dst->mxlock&(1<<RTAX_CWND)))
tcp_input.c:588:				dst->cwnd = (dst->cwnd + tp->snd_cwnd)>>1;
tcp_input.c:590:			/* Else slow start did not finish, cwnd is non-sense,
tcp_input.c:593:			if (!(dst->mxlock&(1<<RTAX_CWND)))
tcp_input.c:594:				dst->cwnd = (dst->cwnd + tp->snd_ssthresh)>>1;
tcp_input.c:595:			if (dst->ssthresh &&
tcp_input.c:596:			    !(dst->mxlock&(1<<RTAX_SSTHRESH)) &&
tcp_input.c:597:			    tp->snd_ssthresh > dst->ssthresh)
tcp_input.c:598:				dst->ssthresh = tp->snd_ssthresh;
tcp_input.c:601:		if (!(dst->mxlock&(1<<RTAX_REORDERING))) {
tcp_input.c:602:			if (dst->reordering < tp->reordering &&
tcp_input.c:603:			    tp->reordering != sysctl_tcp_reordering)
tcp_input.c:604:				dst->reordering = tp->reordering;
tcp_input.c:618:	if (tp->mss_cache > 1460)
tcp_input.c:621:	cwnd = (tp->mss_cache > 1095) ? 3 : 4;
tcp_input.c:623:	if (!tp->srtt || (tp->snd_ssthresh >= 0xFFFF && tp->srtt > ((HZ/50)<<3)))
tcp_input.c:625:	else if (cwnd > tp->snd_ssthresh)
tcp_input.c:626:		cwnd = tp->snd_ssthresh;
tcp_input.c:628:	return min_t(__u32, cwnd, tp->snd_cwnd_clamp);
tcp_input.c:635:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:643:	if (dst->mxlock&(1<<RTAX_CWND))
tcp_input.c:644:		tp->snd_cwnd_clamp = dst->cwnd;
tcp_input.c:645:	if (dst->ssthresh) {
tcp_input.c:646:		tp->snd_ssthresh = dst->ssthresh;
tcp_input.c:647:		if (tp->snd_ssthresh > tp->snd_cwnd_clamp)
tcp_input.c:648:			tp->snd_ssthresh = tp->snd_cwnd_clamp;
tcp_input.c:650:	if (dst->reordering && tp->reordering != dst->reordering) {
tcp_input.c:651:		tp->sack_ok &= ~2;
tcp_input.c:652:		tp->reordering = dst->reordering;
tcp_input.c:655:	if (dst->rtt == 0)
tcp_input.c:658:	if (!tp->srtt && dst->rtt < (TCP_TIMEOUT_INIT<<3))
tcp_input.c:661:	/* Initial rtt is determined from SYN,SYN-ACK.
tcp_input.c:663:	 * less than real one. Use per-dst memory
tcp_input.c:675:	if (dst->rtt > tp->srtt)
tcp_input.c:676:		tp->srtt = dst->rtt;
tcp_input.c:677:	if (dst->rttvar > tp->mdev) {
tcp_input.c:678:		tp->mdev = dst->rttvar;
tcp_input.c:679:		tp->mdev_max = tp->rttvar = max(tp->mdev, TCP_RTO_MIN);
tcp_input.c:683:	if (tp->rto < TCP_TIMEOUT_INIT && !tp->saw_tstamp)
tcp_input.c:685:	tp->snd_cwnd = tcp_init_cwnd(tp);
tcp_input.c:686:	tp->snd_cwnd_stamp = tcp_time_stamp;
tcp_input.c:694:	if (!tp->saw_tstamp && tp->srtt) {
tcp_input.c:695:		tp->srtt = 0;
tcp_input.c:696:		tp->mdev = tp->mdev_max = tp->rttvar = TCP_TIMEOUT_INIT;
tcp_input.c:697:		tp->rto = TCP_TIMEOUT_INIT;
tcp_input.c:703:	if (metric > tp->reordering) {
tcp_input.c:704:		tp->reordering = min(TCP_MAX_REORDERING, metric);
tcp_input.c:717:		       tp->sack_ok, tp->ca_state,
tcp_input.c:718:		       tp->reordering, tp->fackets_out, tp->sacked_out,
tcp_input.c:719:		       tp->undo_marker ? tp->undo_retrans : 0);
tcp_input.c:722:		tp->sack_ok &= ~2;
tcp_input.c:734: * 0	1		- orig segment is in flight.
tcp_input.c:735: * S	0		- nothing flies, orig reached receiver.
tcp_input.c:736: * L	0		- nothing flies, orig lost by net.
tcp_input.c:737: * R	2		- both orig and retransmit are in flight.
tcp_input.c:738: * L|R	1		- orig is lost, retransmit is in flight.
tcp_input.c:739: * S|R  1		- orig reached receiver, retrans is still in flight.
tcp_input.c:741: *  but it is equivalent to plain S and code short-curcuits it to S.
tcp_input.c:742: *  L|S is logically invalid, it would mean -1 packet in flight 8))
tcp_input.c:755: * 4. D-SACK added new rule: D-SACK changes any tag to S.
tcp_input.c:762: * --------------------
tcp_input.c:767: *    ever retransmitted -> reordering. Alas, we cannot use it
tcp_input.c:769: * 2. The last flaw is solved with D-SACK. D-SACK arrives
tcp_input.c:770: *    for retransmitted and already SACKed segment -> reordering..
tcp_input.c:777:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:778:	unsigned char *ptr = ack_skb->h.raw + TCP_SKB_CB(ack_skb)->sacked;
tcp_input.c:780:	int num_sacks = (ptr[1] - TCPOLEN_SACK_BASE)>>3;
tcp_input.c:781:	int reord = tp->packets_out;
tcp_input.c:787:	if (!tp->sacked_out)
tcp_input.c:788:		tp->fackets_out = 0;
tcp_input.c:789:	prior_fackets = tp->fackets_out;
tcp_input.c:793:		__u32 start_seq = ntohl(sp->start_seq);
tcp_input.c:794:		__u32 end_seq = ntohl(sp->end_seq);
tcp_input.c:798:		/* Check for D-SACK. */
tcp_input.c:800:			u32 ack = TCP_SKB_CB(ack_skb)->ack_seq;
tcp_input.c:804:				tp->sack_ok |= 4;
tcp_input.c:810:				tp->sack_ok |= 4;
tcp_input.c:814:			/* D-SACK for already forgotten data...
tcp_input.c:818:			    after(end_seq, tp->undo_marker))
tcp_input.c:819:				tp->undo_retrans--;
tcp_input.c:825:			if (before(ack, prior_snd_una-tp->max_window))
tcp_input.c:830:		if (after(end_seq, tp->high_seq))
tcp_input.c:834:			u8 sacked = TCP_SKB_CB(skb)->sacked;
tcp_input.c:838:			 * we can short-circuit the walk early.
tcp_input.c:840:			if(!before(TCP_SKB_CB(skb)->seq, end_seq))
tcp_input.c:845:			in_sack = !after(start_seq, TCP_SKB_CB(skb)->seq) &&
tcp_input.c:846:				!before(end_seq, TCP_SKB_CB(skb)->end_seq);
tcp_input.c:848:			/* Account D-SACK for retransmitted packet. */
tcp_input.c:851:			    after(TCP_SKB_CB(skb)->end_seq, tp->undo_marker))
tcp_input.c:852:				tp->undo_retrans--;
tcp_input.c:855:			if (!after(TCP_SKB_CB(skb)->end_seq, tp->snd_una)) {
tcp_input.c:872:			    after(end_seq, TCP_SKB_CB(skb)->ack_seq) &&
tcp_input.c:886:						TCP_SKB_CB(skb)->sacked &= ~(TCPCB_LOST|TCPCB_SACKED_RETRANS);
tcp_input.c:887:						tp->lost_out--;
tcp_input.c:888:						tp->retrans_out--;
tcp_input.c:899:						TCP_SKB_CB(skb)->sacked &= ~TCPCB_LOST;
tcp_input.c:900:						tp->lost_out--;
tcp_input.c:904:				TCP_SKB_CB(skb)->sacked |= TCPCB_SACKED_ACKED;
tcp_input.c:906:				tp->sacked_out++;
tcp_input.c:908:				if (fack_count > tp->fackets_out)
tcp_input.c:909:					tp->fackets_out = fack_count;
tcp_input.c:915:			/* D-SACK. We can detect redundant retransmission
tcp_input.c:921:			    (TCP_SKB_CB(skb)->sacked&TCPCB_SACKED_RETRANS)) {
tcp_input.c:922:				TCP_SKB_CB(skb)->sacked &= ~TCPCB_SACKED_RETRANS;
tcp_input.c:923:				tp->retrans_out--;
tcp_input.c:934:	if (lost_retrans && tp->ca_state == TCP_CA_Recovery) {
tcp_input.c:938:			if (after(TCP_SKB_CB(skb)->seq, lost_retrans))
tcp_input.c:940:			if (!after(TCP_SKB_CB(skb)->end_seq, tp->snd_una))
tcp_input.c:942:			if ((TCP_SKB_CB(skb)->sacked&TCPCB_SACKED_RETRANS) &&
tcp_input.c:943:			    after(lost_retrans, TCP_SKB_CB(skb)->ack_seq) &&
tcp_input.c:945:			     !before(lost_retrans, TCP_SKB_CB(skb)->ack_seq+tp->reordering*tp->mss_cache))) {
tcp_input.c:946:				TCP_SKB_CB(skb)->sacked &= ~TCPCB_SACKED_RETRANS;
tcp_input.c:947:				tp->retrans_out--;
tcp_input.c:949:				if (!(TCP_SKB_CB(skb)->sacked&(TCPCB_LOST|TCPCB_SACKED_ACKED))) {
tcp_input.c:950:					tp->lost_out++;
tcp_input.c:951:					TCP_SKB_CB(skb)->sacked |= TCPCB_LOST;
tcp_input.c:959:	tp->left_out = tp->sacked_out + tp->lost_out;
tcp_input.c:961:	if (reord < tp->fackets_out && tp->ca_state != TCP_CA_Loss)
tcp_input.c:962:		tcp_update_reordering(tp, (tp->fackets_out+1)-reord, 0);
tcp_input.c:965:	BUG_TRAP((int)tp->sacked_out >= 0);
tcp_input.c:966:	BUG_TRAP((int)tp->lost_out >= 0);
tcp_input.c:967:	BUG_TRAP((int)tp->retrans_out >= 0);
tcp_input.c:979:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tcp_input.c:982:	tp->frto_counter = 1;
tcp_input.c:984:	if (tp->ca_state <= TCP_CA_Disorder ||
tcp_input.c:985:            tp->snd_una == tp->high_seq ||
tcp_input.c:986:            (tp->ca_state == TCP_CA_Loss && !tp->retransmits)) {
tcp_input.c:987:		tp->prior_ssthresh = tcp_current_ssthresh(tp);
tcp_input.c:988:		tp->snd_ssthresh = tcp_recalc_ssthresh(tp);
tcp_input.c:996:	tp->retrans_out = 0;
tcp_input.c:997:	tp->undo_marker = tp->snd_una;
tcp_input.c:998:	tp->undo_retrans = 0;
tcp_input.c:1001:		TCP_SKB_CB(skb)->sacked &= ~TCPCB_RETRANS;
tcp_input.c:1005:	tp->ca_state = TCP_CA_Open;
tcp_input.c:1006:	tp->frto_highmark = tp->snd_nxt;
tcp_input.c:1009:/* Enter Loss state after F-RTO was applied. Dupack arrived after RTO,
tcp_input.c:1011: * i.e. mark everything lost and do go-back-N retransmission.
tcp_input.c:1015:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tcp_input.c:1019:	tp->sacked_out = 0;
tcp_input.c:1020:	tp->lost_out = 0;
tcp_input.c:1021:	tp->fackets_out = 0;
tcp_input.c:1025:		TCP_SKB_CB(skb)->sacked &= ~TCPCB_LOST;
tcp_input.c:1026:		if (!(TCP_SKB_CB(skb)->sacked&TCPCB_SACKED_ACKED)) {
tcp_input.c:1031:			if(!after(TCP_SKB_CB(skb)->end_seq,
tcp_input.c:1032:				   tp->frto_highmark)) {
tcp_input.c:1033:				TCP_SKB_CB(skb)->sacked |= TCPCB_LOST;
tcp_input.c:1034:				tp->lost_out++;
tcp_input.c:1037:			tp->sacked_out++;
tcp_input.c:1038:			tp->fackets_out = cnt;
tcp_input.c:1043:	tp->snd_cwnd = tp->frto_counter + tcp_packets_in_flight(tp)+1;
tcp_input.c:1044:	tp->snd_cwnd_cnt = 0;
tcp_input.c:1045:	tp->snd_cwnd_stamp = tcp_time_stamp;
tcp_input.c:1046:	tp->undo_marker = 0;
tcp_input.c:1047:	tp->frto_counter = 0;
tcp_input.c:1049:	tp->reordering = min_t(unsigned int, tp->reordering,
tcp_input.c:1051:	tp->ca_state = TCP_CA_Loss;
tcp_input.c:1052:	tp->high_seq = tp->frto_highmark;
tcp_input.c:1058:	tp->left_out = 0;
tcp_input.c:1059:	tp->retrans_out = 0;
tcp_input.c:1061:	tp->fackets_out = 0;
tcp_input.c:1062:	tp->sacked_out = 0;
tcp_input.c:1063:	tp->lost_out = 0;
tcp_input.c:1065:	tp->undo_marker = 0;
tcp_input.c:1066:	tp->undo_retrans = 0;
tcp_input.c:1075:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tcp_input.c:1080:	if (tp->ca_state <= TCP_CA_Disorder ||
tcp_input.c:1081:	    tp->snd_una == tp->high_seq ||
tcp_input.c:1082:	    (tp->ca_state == TCP_CA_Loss && !tp->retransmits)) {
tcp_input.c:1083:		tp->prior_ssthresh = tcp_current_ssthresh(tp);
tcp_input.c:1086:			tp->snd_ssthresh = tcp_recalc_ssthresh(tp);
tcp_input.c:1088:	tp->snd_cwnd = 1;
tcp_input.c:1089:	tp->snd_cwnd_cnt = 0;
tcp_input.c:1090:	tp->snd_cwnd_stamp = tcp_time_stamp;
tcp_input.c:1097:		tp->undo_marker = tp->snd_una;
tcp_input.c:1101:		if (TCP_SKB_CB(skb)->sacked&TCPCB_RETRANS)
tcp_input.c:1102:			tp->undo_marker = 0;
tcp_input.c:1103:		TCP_SKB_CB(skb)->sacked &= (~TCPCB_TAGBITS)|TCPCB_SACKED_ACKED;
tcp_input.c:1104:		if (!(TCP_SKB_CB(skb)->sacked&TCPCB_SACKED_ACKED) || how) {
tcp_input.c:1105:			TCP_SKB_CB(skb)->sacked &= ~TCPCB_SACKED_ACKED;
tcp_input.c:1106:			TCP_SKB_CB(skb)->sacked |= TCPCB_LOST;
tcp_input.c:1107:			tp->lost_out++;
tcp_input.c:1109:			tp->sacked_out++;
tcp_input.c:1110:			tp->fackets_out = cnt;
tcp_input.c:1115:	tp->reordering = min_t(unsigned int, tp->reordering, sysctl_tcp_reordering);
tcp_input.c:1116:	tp->ca_state = TCP_CA_Loss;
tcp_input.c:1117:	tp->high_seq = tp->snd_nxt;
tcp_input.c:1131:	if ((skb = skb_peek(&sk->write_queue)) != NULL &&
tcp_input.c:1132:	    (TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_ACKED)) {
tcp_input.c:1136:		tp->retransmits++;
tcp_input.c:1137:		tcp_retransmit_skb(sk, skb_peek(&sk->write_queue));
tcp_input.c:1138:		tcp_reset_xmit_timer(sk, TCP_TIME_RETRANS, tp->rto);
tcp_input.c:1146:	return IsReno(tp) ? tp->sacked_out+1 : tp->fackets_out;
tcp_input.c:1151:	return (tcp_time_stamp - TCP_SKB_CB(skb)->when > tp->rto);
tcp_input.c:1156:	return tp->packets_out && tcp_skb_timedout(tp, skb_peek(&sk->write_queue));
tcp_input.c:1160: * --------------------------------------
tcp_input.c:1169: * "Recovery"	CWND was reduced, we are fast-retransmitting.
tcp_input.c:1173: * - each incoming ACK, if state is not "Open"
tcp_input.c:1174: * - when arrived ACK is unusual, namely:
tcp_input.c:1181: *	in_flight = packets_out - left_out + retrans_out
tcp_input.c:1183: *	packets_out is SND.NXT-SND.UNA counted in packets.
tcp_input.c:1212: *		lost_out = fackets_out - sacked_out and left_out = fackets_out.
tcp_input.c:1240: * timestamps and D-SACKs. When we detect that some segments were
tcp_input.c:1256:	if (tp->lost_out)
tcp_input.c:1259:	/* Not-A-Trick#2 : Classic rule... */
tcp_input.c:1260:	if (tcp_fackets_out(tp) > tp->reordering)
tcp_input.c:1272:	if (tp->packets_out <= tp->reordering &&
tcp_input.c:1273:	    tp->sacked_out >= max_t(__u32, tp->packets_out/2, sysctl_tcp_reordering) &&
tcp_input.c:1292:	holes = max(tp->lost_out, 1U);
tcp_input.c:1293:	holes = min(holes, tp->packets_out);
tcp_input.c:1295:	if (tp->sacked_out + holes > tp->packets_out) {
tcp_input.c:1296:		tp->sacked_out = tp->packets_out - holes;
tcp_input.c:1297:		tcp_update_reordering(tp, tp->packets_out+addend, 0);
tcp_input.c:1305:	++tp->sacked_out;
tcp_input.c:1316:		if (acked-1 >= tp->sacked_out)
tcp_input.c:1317:			tp->sacked_out = 0;
tcp_input.c:1319:			tp->sacked_out -= acked-1;
tcp_input.c:1327:	tp->sacked_out = 0;
tcp_input.c:1328:	tp->left_out = tp->lost_out;
tcp_input.c:1338:	BUG_TRAP(cnt <= tp->packets_out);
tcp_input.c:1341:		if (--cnt < 0 || after(TCP_SKB_CB(skb)->end_seq, high_seq))
tcp_input.c:1343:		if (!(TCP_SKB_CB(skb)->sacked&TCPCB_TAGBITS)) {
tcp_input.c:1344:			TCP_SKB_CB(skb)->sacked |= TCPCB_LOST;
tcp_input.c:1345:			tp->lost_out++;
tcp_input.c:1356:		int lost = tp->fackets_out - tp->reordering;
tcp_input.c:1359:		tcp_mark_head_lost(sk, tp, lost, tp->high_seq);
tcp_input.c:1361:		tcp_mark_head_lost(sk, tp, 1, tp->high_seq);
tcp_input.c:1374:			    !(TCP_SKB_CB(skb)->sacked&TCPCB_TAGBITS)) {
tcp_input.c:1375:				TCP_SKB_CB(skb)->sacked |= TCPCB_LOST;
tcp_input.c:1376:				tp->lost_out++;
tcp_input.c:1388:	tp->snd_cwnd = min(tp->snd_cwnd,
tcp_input.c:1390:	tp->snd_cwnd_stamp = tcp_time_stamp;
tcp_input.c:1397:	int decr = tp->snd_cwnd_cnt + 1;
tcp_input.c:1410:		limit = tp->snd_ssthresh/2;
tcp_input.c:1412:	tp->snd_cwnd_cnt = decr&1;
tcp_input.c:1415:	if (decr && tp->snd_cwnd > limit)
tcp_input.c:1416:		tp->snd_cwnd -= decr;
tcp_input.c:1418:	tp->snd_cwnd = min(tp->snd_cwnd, tcp_packets_in_flight(tp)+1);
tcp_input.c:1419:	tp->snd_cwnd_stamp = tcp_time_stamp;
tcp_input.c:1427:	return !tp->retrans_stamp ||
tcp_input.c:1428:		(tp->saw_tstamp && tp->rcv_tsecr &&
tcp_input.c:1429:		 (__s32)(tp->rcv_tsecr - tp->retrans_stamp) < 0);
tcp_input.c:1439:	       NIPQUAD(sk->daddr), ntohs(sk->dport),
tcp_input.c:1440:	       tp->snd_cwnd, tp->left_out,
tcp_input.c:1441:	       tp->snd_ssthresh, tp->prior_ssthresh, tp->packets_out);
tcp_input.c:1449:	if (tp->prior_ssthresh) {
tcp_input.c:1450:		tp->snd_cwnd = max(tp->snd_cwnd, tp->snd_ssthresh<<1);
tcp_input.c:1452:		if (undo && tp->prior_ssthresh > tp->snd_ssthresh) {
tcp_input.c:1453:			tp->snd_ssthresh = tp->prior_ssthresh;
tcp_input.c:1457:		tp->snd_cwnd = max(tp->snd_cwnd, tp->snd_ssthresh);
tcp_input.c:1460:	tp->snd_cwnd_stamp = tcp_time_stamp;
tcp_input.c:1465:	return tp->undo_marker &&
tcp_input.c:1466:		(!tp->undo_retrans || tcp_packet_delayed(tp));
tcp_input.c:1476:		DBGUNDO(sk, tp, tp->ca_state == TCP_CA_Loss ? "loss" : "retrans");
tcp_input.c:1478:		if (tp->ca_state == TCP_CA_Loss)
tcp_input.c:1482:		tp->undo_marker = 0;
tcp_input.c:1484:	if (tp->snd_una == tp->high_seq && IsReno(tp)) {
tcp_input.c:1491:	tp->ca_state = TCP_CA_Open;
tcp_input.c:1495:/* Try to undo cwnd reduction, because D-SACKs acked all retransmitted data */
tcp_input.c:1498:	if (tp->undo_marker && !tp->undo_retrans) {
tcp_input.c:1499:		DBGUNDO(sk, tp, "D-SACK");
tcp_input.c:1501:		tp->undo_marker = 0;
tcp_input.c:1511:	int failed = IsReno(tp) || tp->fackets_out>tp->reordering;
tcp_input.c:1517:		if (tp->retrans_out == 0)
tcp_input.c:1518:			tp->retrans_stamp = 0;
tcp_input.c:1541:			TCP_SKB_CB(skb)->sacked &= ~TCPCB_LOST;
tcp_input.c:1544:		tp->lost_out = 0;
tcp_input.c:1545:		tp->left_out = tp->sacked_out;
tcp_input.c:1548:		tp->retransmits = 0;
tcp_input.c:1549:		tp->undo_marker = 0;
tcp_input.c:1551:			tp->ca_state = TCP_CA_Open;
tcp_input.c:1560:		tp->snd_cwnd = min(tp->snd_cwnd, tp->snd_ssthresh);
tcp_input.c:1561:	tp->snd_cwnd_stamp = tcp_time_stamp;
tcp_input.c:1566:	tp->left_out = tp->sacked_out;
tcp_input.c:1568:	if (tp->retrans_out == 0)
tcp_input.c:1569:		tp->retrans_stamp = 0;
tcp_input.c:1574:	if (tp->ca_state != TCP_CA_CWR) {
tcp_input.c:1577:		if (tp->left_out ||
tcp_input.c:1578:		    tp->retrans_out ||
tcp_input.c:1579:		    tp->undo_marker)
tcp_input.c:1582:		if (tp->ca_state != state) {
tcp_input.c:1583:			tp->ca_state = state;
tcp_input.c:1584:			tp->high_seq = tp->snd_nxt;
tcp_input.c:1592:/* Process an event, which can update packets-in-flight not trivially.
tcp_input.c:1607:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:1608:	int is_dupack = (tp->snd_una == prior_snd_una && !(flag&FLAG_NOT_DUP));
tcp_input.c:1612:	if (!tp->packets_out)
tcp_input.c:1613:		tp->sacked_out = 0;
tcp_input.c:1615:	if (tp->sacked_out == 0)
tcp_input.c:1616:		tp->fackets_out = 0;
tcp_input.c:1621:		tp->prior_ssthresh = 0;
tcp_input.c:1624:	if (tp->sacked_out && tcp_check_sack_reneging(sk, tp))
tcp_input.c:1629:	    before(tp->snd_una, tp->high_seq) &&
tcp_input.c:1630:	    tp->ca_state != TCP_CA_Open &&
tcp_input.c:1631:	    tp->fackets_out > tp->reordering) {
tcp_input.c:1632:		tcp_mark_head_lost(sk, tp, tp->fackets_out-tp->reordering, tp->high_seq);
tcp_input.c:1641:	if (tp->ca_state == TCP_CA_Open) {
tcp_input.c:1643:			BUG_TRAP(tp->retrans_out == 0);
tcp_input.c:1644:		tp->retrans_stamp = 0;
tcp_input.c:1645:	} else if (!before(tp->snd_una, tp->high_seq)) {
tcp_input.c:1646:		switch (tp->ca_state) {
tcp_input.c:1648:			tp->retransmits = 0;
tcp_input.c:1656:			if (tp->snd_una != tp->high_seq) {
tcp_input.c:1658:				tp->ca_state = TCP_CA_Open;
tcp_input.c:1664:			if (!tp->undo_marker ||
tcp_input.c:1667:			    IsReno(tp) || tp->snd_una != tp->high_seq) {
tcp_input.c:1668:				tp->undo_marker = 0;
tcp_input.c:1669:				tp->ca_state = TCP_CA_Open;
tcp_input.c:1684:	switch (tp->ca_state) {
tcp_input.c:1686:		if (prior_snd_una == tp->snd_una) {
tcp_input.c:1690:			int acked = prior_packets - tp->packets_out;
tcp_input.c:1698:			tp->retransmits = 0;
tcp_input.c:1704:		if (tp->ca_state != TCP_CA_Open)
tcp_input.c:1709:			if (tp->snd_una != prior_snd_una)
tcp_input.c:1715:		if (tp->ca_state == TCP_CA_Disorder)
tcp_input.c:1730:		tp->high_seq = tp->snd_nxt;
tcp_input.c:1731:		tp->prior_ssthresh = 0;
tcp_input.c:1732:		tp->undo_marker = tp->snd_una;
tcp_input.c:1733:		tp->undo_retrans = tp->retrans_out;
tcp_input.c:1735:		if (tp->ca_state < TCP_CA_CWR) {
tcp_input.c:1737:				tp->prior_ssthresh = tcp_current_ssthresh(tp);
tcp_input.c:1738:			tp->snd_ssthresh = tcp_recalc_ssthresh(tp);
tcp_input.c:1742:		tp->snd_cwnd_cnt = 0;
tcp_input.c:1743:		tp->ca_state = TCP_CA_Recovery;
tcp_input.c:1752:/* Read draft-ietf-tcplw-high-performance before mucking
tcp_input.c:1764:	 * See draft-ietf-tcplw-high-performance-00, section 3.3.
tcp_input.c:1772:	 * in window is lost... Voila.	 			--ANK (010210)
tcp_input.c:1774:	seq_rtt = tcp_time_stamp - tp->rcv_tsecr;
tcp_input.c:1777:	tp->backoff = 0;
tcp_input.c:1786:	 * backoff for rto until we get a non-retransmitted
tcp_input.c:1797:	tp->backoff = 0;
tcp_input.c:1805:	if (tp->saw_tstamp && tp->rcv_tsecr)
tcp_input.c:1816:        if (tp->snd_cwnd <= tp->snd_ssthresh) {
tcp_input.c:1818:		if (tp->snd_cwnd < tp->snd_cwnd_clamp)
tcp_input.c:1819:			tp->snd_cwnd++;
tcp_input.c:1822:		 * In theory this is tp->snd_cwnd += 1 / tp->snd_cwnd
tcp_input.c:1824:		if (tp->snd_cwnd_cnt >= tp->snd_cwnd) {
tcp_input.c:1825:			if (tp->snd_cwnd < tp->snd_cwnd_clamp)
tcp_input.c:1826:				tp->snd_cwnd++;
tcp_input.c:1827:			tp->snd_cwnd_cnt=0;
tcp_input.c:1829:			tp->snd_cwnd_cnt++;
tcp_input.c:1831:	tp->snd_cwnd_stamp = tcp_time_stamp;
tcp_input.c:1840:	if (tp->packets_out==0) {
tcp_input.c:1843:		tcp_reset_xmit_timer(sk, TCP_TIME_RETRANS, tp->rto);
tcp_input.c:1850:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:1854:	__s32 seq_rtt = -1;
tcp_input.c:1856:	while((skb=skb_peek(&sk->write_queue)) && (skb != tp->send_head)) {
tcp_input.c:1858:		__u8 sacked = scb->sacked;
tcp_input.c:1864:		if (after(scb->end_seq, tp->snd_una))
tcp_input.c:1874:		if(!(scb->flags & TCPCB_FLAG_SYN)) {
tcp_input.c:1878:			tp->retrans_stamp = 0;
tcp_input.c:1884:					tp->retrans_out--;
tcp_input.c:1886:				seq_rtt = -1;
tcp_input.c:1888:				seq_rtt = now - scb->when;
tcp_input.c:1890:				tp->sacked_out--;
tcp_input.c:1892:				tp->lost_out--;
tcp_input.c:1894:				if (tp->urg_mode &&
tcp_input.c:1895:				    !before(scb->end_seq, tp->snd_up))
tcp_input.c:1896:					tp->urg_mode = 0;
tcp_input.c:1899:			seq_rtt = now - scb->when;
tcp_input.c:1900:		if(tp->fackets_out)
tcp_input.c:1901:			tp->fackets_out--;
tcp_input.c:1902:		tp->packets_out--;
tcp_input.c:1903:		__skb_unlink(skb, skb->list);
tcp_input.c:1913:	BUG_TRAP((int)tp->sacked_out >= 0);
tcp_input.c:1914:	BUG_TRAP((int)tp->lost_out >= 0);
tcp_input.c:1915:	BUG_TRAP((int)tp->retrans_out >= 0);
tcp_input.c:1916:	if (tp->packets_out==0 && tp->sack_ok) {
tcp_input.c:1917:		if (tp->lost_out) {
tcp_input.c:1918:			printk(KERN_DEBUG "Leak l=%u %d\n", tp->lost_out, tp->ca_state);
tcp_input.c:1919:			tp->lost_out = 0;
tcp_input.c:1921:		if (tp->sacked_out) {
tcp_input.c:1922:			printk(KERN_DEBUG "Leak s=%u %d\n", tp->sacked_out, tp->ca_state);
tcp_input.c:1923:			tp->sacked_out = 0;
tcp_input.c:1925:		if (tp->retrans_out) {
tcp_input.c:1926:			printk(KERN_DEBUG "Leak r=%u %d\n", tp->retrans_out, tp->ca_state);
tcp_input.c:1927:			tp->retrans_out = 0;
tcp_input.c:1936:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:1940:	if (!after(TCP_SKB_CB(tp->send_head)->end_seq, tp->snd_una + tp->snd_wnd)) {
tcp_input.c:1941:		tp->backoff = 0;
tcp_input.c:1948:				     min(tp->rto << tp->backoff, TCP_RTO_MAX));
tcp_input.c:1955:		tp->ca_state != TCP_CA_Open);
tcp_input.c:1960:	return (!(flag & FLAG_ECE) || tp->snd_cwnd < tp->snd_ssthresh) &&
tcp_input.c:1961:		!((1<<tp->ca_state)&(TCPF_CA_Recovery|TCPF_CA_CWR));
tcp_input.c:1970:	return (after(ack, tp->snd_una) ||
tcp_input.c:1971:		after(ack_seq, tp->snd_wl1) ||
tcp_input.c:1972:		(ack_seq == tp->snd_wl1 && nwin > tp->snd_wnd));
tcp_input.c:1977: * Window update algorithm, described in RFC793/RFC1122 (used in linux-2.2
tcp_input.c:1984:	u32 nwin = ntohs(skb->h.th->window);
tcp_input.c:1986:	if (likely(!skb->h.th->syn))
tcp_input.c:1987:		nwin <<= tp->snd_wscale;
tcp_input.c:1993:		if (tp->snd_wnd != nwin) {
tcp_input.c:1994:			tp->snd_wnd = nwin;
tcp_input.c:2001:			if (nwin > tp->max_window) {
tcp_input.c:2002:				tp->max_window = nwin;
tcp_input.c:2003:				tcp_sync_mss(sk, tp->pmtu_cookie);
tcp_input.c:2008:	tp->snd_una = ack;
tcp_input.c:2015:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tcp_input.c:2019:	if (tp->snd_una == prior_snd_una ||
tcp_input.c:2020:	    !before(tp->snd_una, tp->frto_highmark)) {
tcp_input.c:2022:		 * go-back-N slow start
tcp_input.c:2028:	if (tp->frto_counter == 1) {
tcp_input.c:2032:		tp->snd_cwnd = tcp_packets_in_flight(tp) + 2;
tcp_input.c:2038:		tp->snd_cwnd = min(tp->snd_cwnd, tp->snd_ssthresh);
tcp_input.c:2042:	/* F-RTO affects on two new ACKs following RTO.
tcp_input.c:2045:	tp->frto_counter = (tp->frto_counter + 1) % 3;
tcp_input.c:2054: * Low-pass filter. Implemented using constant coeffients.
tcp_input.c:2064:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:2066:	tp->westwood.bw_ns_est =
tcp_input.c:2067:		westwood_do_filter(tp->westwood.bw_ns_est, 
tcp_input.c:2068:				   tp->westwood.bk / delta);
tcp_input.c:2069:	tp->westwood.bw_est =
tcp_input.c:2070:		westwood_do_filter(tp->westwood.bw_est,
tcp_input.c:2071:				   tp->westwood.bw_ns_est);
tcp_input.c:2081:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:2082:	__u32 rttmin = tp->westwood.rtt_min;
tcp_input.c:2084:	if (tp->westwood.rtt == 0)
tcp_input.c:2087:	if (tp->westwood.rtt < tp->westwood.rtt_min || !rttmin)
tcp_input.c:2088:		rttmin = tp->westwood.rtt;
tcp_input.c:2100:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:2102:	return ((tp->snd_una) - (tp->westwood.snd_una));
tcp_input.c:2116:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:2121:	left_bound = tp->westwood.rtt_win_sx;
tcp_input.c:2122:	rtt = max(tp->westwood.rtt, (__u32)TCP_WESTWOOD_RTT_MIN);
tcp_input.c:2125:	 * A RTT-window has passed. Be careful since if RTT is less than
tcp_input.c:2147:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:2148:	__u32 delta = now - tp->westwood.rtt_win_sx;
tcp_input.c:2153:	if (tp->westwood.rtt)
tcp_input.c:2156:	tp->westwood.bk = 0;
tcp_input.c:2157:	tp->westwood.rtt_win_sx = tcp_time_stamp;
tcp_input.c:2175:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:2179:	tp->westwood.bk += westwood_acked(sk);
tcp_input.c:2180:	tp->westwood.snd_una = tp->snd_una;
tcp_input.c:2181:	tp->westwood.rtt_min = westwood_update_rttmin(sk);
tcp_input.c:2193:	return ((__u32)(tp->mss_cache));
tcp_input.c:2203:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:2205:	tp->westwood.accounted += westwood_mss(tp);
tcp_input.c:2206:	tp->westwood.cumul_ack = westwood_mss(tp);
tcp_input.c:2211:	return ((tp->westwood.cumul_ack) > westwood_mss(tp));
tcp_input.c:2216:	tp->westwood.accounted -= tp->westwood.cumul_ack;
tcp_input.c:2217:	tp->westwood.cumul_ack = westwood_mss(tp);
tcp_input.c:2222:	tp->westwood.cumul_ack -= tp->westwood.accounted;
tcp_input.c:2223:	tp->westwood.accounted = 0;
tcp_input.c:2234:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:2236:	tp->westwood.cumul_ack = westwood_acked(sk);
tcp_input.c:2239:	 * tp->snd_una.
tcp_input.c:2241:	if (!(tp->westwood.cumul_ack))
tcp_input.c:2246:		if ((tp->westwood.accounted) >= (tp->westwood.cumul_ack))
tcp_input.c:2252:	tp->westwood.snd_una = tp->snd_una;
tcp_input.c:2254:	return tp->westwood.cumul_ack;
tcp_input.c:2266:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:2270:	tp->westwood.bk += westwood_acked_count(sk);
tcp_input.c:2271:	tp->westwood.rtt_min = westwood_update_rttmin(sk);
tcp_input.c:2279:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:2280:	u32 prior_snd_una = tp->snd_una;
tcp_input.c:2281:	u32 ack_seq = TCP_SKB_CB(skb)->seq;
tcp_input.c:2282:	u32 ack = TCP_SKB_CB(skb)->ack_seq;
tcp_input.c:2290:	if (after(ack, tp->snd_nxt))
tcp_input.c:2302:		tp->snd_una = ack;
tcp_input.c:2308:		if (ack_seq != TCP_SKB_CB(skb)->end_seq)
tcp_input.c:2315:		if (TCP_SKB_CB(skb)->sacked)
tcp_input.c:2318:		if (TCP_ECN_rcv_ecn_echo(tp, skb->h.th))
tcp_input.c:2327:	sk->err_soft = 0;
tcp_input.c:2328:	tp->rcv_tstamp = tcp_time_stamp;
tcp_input.c:2329:	if ((prior_packets = tp->packets_out) == 0)
tcp_input.c:2337:	if (tp->frto_counter)
tcp_input.c:2342:		if ((flag&FLAG_DATA_ACKED) && prior_in_flight >= tp->snd_cwnd &&
tcp_input.c:2347:		if ((flag&FLAG_DATA_ACKED) && prior_in_flight >= tp->snd_cwnd)
tcp_input.c:2352:		dst_confirm(sk->dst_cache);
tcp_input.c:2357:	tp->probes_out = 0;
tcp_input.c:2363:	if (tp->send_head)
tcp_input.c:2368:	if (TCP_SKB_CB(skb)->sacked)
tcp_input.c:2372:	SOCK_DEBUG(sk, "Ack %u out of %u:%u\n", ack, tp->snd_una, tp->snd_nxt);
tcp_input.c:2384:	struct tcphdr *th = skb->h.th;
tcp_input.c:2385:	int length=(th->doff*4)-sizeof(struct tcphdr);
tcp_input.c:2388:	tp->saw_tstamp = 0;
tcp_input.c:2398:				length--;
tcp_input.c:2408:					if(opsize==TCPOLEN_MSS && th->syn && !estab) {
tcp_input.c:2411:							if (tp->user_mss && tp->user_mss < in_mss)
tcp_input.c:2412:								in_mss = tp->user_mss;
tcp_input.c:2413:							tp->mss_clamp = in_mss;
tcp_input.c:2418:					if(opsize==TCPOLEN_WINDOW && th->syn && !estab)
tcp_input.c:2420:							tp->wscale_ok = 1;
tcp_input.c:2421:							tp->snd_wscale = *(__u8 *)ptr;
tcp_input.c:2422:							if(tp->snd_wscale > 14) {
tcp_input.c:2426:									       tp->snd_wscale);
tcp_input.c:2427:								tp->snd_wscale = 14;
tcp_input.c:2433:						if ((estab && tp->tstamp_ok) ||
tcp_input.c:2435:							tp->saw_tstamp = 1;
tcp_input.c:2436:							tp->rcv_tsval = ntohl(*(__u32 *)ptr);
tcp_input.c:2437:							tp->rcv_tsecr = ntohl(*(__u32 *)(ptr+4));
tcp_input.c:2442:					if(opsize==TCPOLEN_SACK_PERM && th->syn && !estab) {
tcp_input.c:2444:							tp->sack_ok = 1;
tcp_input.c:2452:					   !((opsize - TCPOLEN_SACK_BASE) % TCPOLEN_SACK_PERBLOCK) &&
tcp_input.c:2453:					   tp->sack_ok) {
tcp_input.c:2454:						TCP_SKB_CB(skb)->sacked = (ptr - 2) - (unsigned char *)th;
tcp_input.c:2457:	  			ptr+=opsize-2;
tcp_input.c:2458:	  			length-=opsize;
tcp_input.c:2468:	if (th->doff == sizeof(struct tcphdr)>>2) {
tcp_input.c:2469:		tp->saw_tstamp = 0;
tcp_input.c:2471:	} else if (tp->tstamp_ok &&
tcp_input.c:2472:		   th->doff == (sizeof(struct tcphdr)>>2)+(TCPOLEN_TSTAMP_ALIGNED>>2)) {
tcp_input.c:2476:			tp->saw_tstamp = 1;
tcp_input.c:2478:			tp->rcv_tsval = ntohl(*ptr);
tcp_input.c:2480:			tp->rcv_tsecr = ntohl(*ptr);
tcp_input.c:2491:	tp->ts_recent = tp->rcv_tsval;
tcp_input.c:2492:	tp->ts_recent_stamp = xtime.tv_sec;
tcp_input.c:2498:	if (tp->saw_tstamp && !after(seq, tp->rcv_wup)) {
tcp_input.c:2501:		 * for pure ACK frames.  -DaveM
tcp_input.c:2506:		if((s32)(tp->rcv_tsval - tp->ts_recent) >= 0 ||
tcp_input.c:2507:		   xtime.tv_sec >= tp->ts_recent_stamp + TCP_PAWS_24DAYS)
tcp_input.c:2512:/* Sorry, PAWS as specified is broken wrt. pure-ACKs -DaveM
tcp_input.c:2537:	struct tcphdr *th = skb->h.th;
tcp_input.c:2538:	u32 seq = TCP_SKB_CB(skb)->seq;
tcp_input.c:2539:	u32 ack = TCP_SKB_CB(skb)->ack_seq;
tcp_input.c:2542:		(th->ack && seq == TCP_SKB_CB(skb)->end_seq && seq == tp->rcv_nxt) &&
tcp_input.c:2545:		ack == tp->snd_una &&
tcp_input.c:2548:		!tcp_may_update_window(tp, ack, seq, ntohs(th->window)<<tp->snd_wscale) &&
tcp_input.c:2551:		(s32)(tp->ts_recent - tp->rcv_tsval) <= (tp->rto*1024)/HZ);
tcp_input.c:2556:	return ((s32)(tp->ts_recent - tp->rcv_tsval) > TCP_PAWS_WINDOW &&
tcp_input.c:2557:		xtime.tv_sec < tp->ts_recent_stamp + TCP_PAWS_24DAYS &&
tcp_input.c:2576:	return	!before(end_seq, tp->rcv_wup) &&
tcp_input.c:2577:		!after(seq, tp->rcv_nxt + tcp_receive_window(tp));
tcp_input.c:2584:	switch (sk->state) {
tcp_input.c:2586:			sk->err = ECONNREFUSED;
tcp_input.c:2589:			sk->err = EPIPE;
tcp_input.c:2594:			sk->err = ECONNRESET;
tcp_input.c:2597:	if (!sk->dead)
tcp_input.c:2598:		sk->error_report(sk);
tcp_input.c:2608: *	If we are ESTABLISHED, a received fin moves us to CLOSE-WAIT
tcp_input.c:2609: *	(and thence onto LAST-ACK and finally, CLOSE, we never enter
tcp_input.c:2610: *	TIME-WAIT)
tcp_input.c:2612: *	If we are in FINWAIT-1, a received FIN indicates simultaneous
tcp_input.c:2613: *	close and we go into CLOSING (and later onto TIME-WAIT)
tcp_input.c:2615: *	If we are in FINWAIT-2, a received FIN moves us to TIME-WAIT.
tcp_input.c:2619:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:2623:	sk->shutdown |= RCV_SHUTDOWN;
tcp_input.c:2624:	sk->done = 1;
tcp_input.c:2626:	switch(sk->state) {
tcp_input.c:2631:			tp->ack.pingpong = 1;
tcp_input.c:2641:			/* RFC793: Remain in the LAST-ACK state. */
tcp_input.c:2653:			/* Received a FIN -- send ACK and enter TIME_WAIT. */
tcp_input.c:2661:			printk("tcp_fin: Impossible, sk->state=%d\n", sk->state);
tcp_input.c:2665:	/* It _is_ possible, that we have something out-of-order _after_ FIN.
tcp_input.c:2668:	__skb_queue_purge(&tp->out_of_order_queue);
tcp_input.c:2669:	if (tp->sack_ok)
tcp_input.c:2673:	if (!sk->dead) {
tcp_input.c:2674:		sk->state_change(sk);
tcp_input.c:2677:		if (sk->shutdown == SHUTDOWN_MASK || sk->state == TCP_CLOSE)
tcp_input.c:2687:	if (!after(seq, sp->end_seq) && !after(sp->start_seq, end_seq)) {
tcp_input.c:2688:		if (before(seq, sp->start_seq))
tcp_input.c:2689:			sp->start_seq = seq;
tcp_input.c:2690:		if (after(end_seq, sp->end_seq))
tcp_input.c:2691:			sp->end_seq = end_seq;
tcp_input.c:2699:	if (tp->sack_ok && sysctl_tcp_dsack) {
tcp_input.c:2700:		if (before(seq, tp->rcv_nxt))
tcp_input.c:2705:		tp->dsack = 1;
tcp_input.c:2706:		tp->duplicate_sack[0].start_seq = seq;
tcp_input.c:2707:		tp->duplicate_sack[0].end_seq = end_seq;
tcp_input.c:2708:		tp->eff_sacks = min(tp->num_sacks+1, 4-tp->tstamp_ok);
tcp_input.c:2714:	if (!tp->dsack)
tcp_input.c:2717:		tcp_sack_extend(tp->duplicate_sack, seq, end_seq);
tcp_input.c:2722:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:2724:	if (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&
tcp_input.c:2725:	    before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt)) {
tcp_input.c:2729:		if (tp->sack_ok && sysctl_tcp_dsack) {
tcp_input.c:2730:			u32 end_seq = TCP_SKB_CB(skb)->end_seq;
tcp_input.c:2732:			if (after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt))
tcp_input.c:2733:				end_seq = tp->rcv_nxt;
tcp_input.c:2734:			tcp_dsack_set(tp, TCP_SKB_CB(skb)->seq, end_seq);
tcp_input.c:2741:/* These routines update the SACK block as out-of-order packets arrive or
tcp_input.c:2742: * in-order packets close up the sequence space.
tcp_input.c:2747:	struct tcp_sack_block *sp = &tp->selective_acks[0];
tcp_input.c:2753:	for (this_sack = 1; this_sack < tp->num_sacks; ) {
tcp_input.c:2754:		if (tcp_sack_extend(sp, swalk->start_seq, swalk->end_seq)) {
tcp_input.c:2760:			tp->num_sacks--;
tcp_input.c:2761:			tp->eff_sacks = min(tp->num_sacks+tp->dsack, 4-tp->tstamp_ok);
tcp_input.c:2762:			for(i=this_sack; i < tp->num_sacks; i++)
tcp_input.c:2774:	tmp = sack1->start_seq;
tcp_input.c:2775:	sack1->start_seq = sack2->start_seq;
tcp_input.c:2776:	sack2->start_seq = tmp;
tcp_input.c:2778:	tmp = sack1->end_seq;
tcp_input.c:2779:	sack1->end_seq = sack2->end_seq;
tcp_input.c:2780:	sack2->end_seq = tmp;
tcp_input.c:2785:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:2786:	struct tcp_sack_block *sp = &tp->selective_acks[0];
tcp_input.c:2787:	int cur_sacks = tp->num_sacks;
tcp_input.c:2796:			for (; this_sack>0; this_sack--, sp--)
tcp_input.c:2797:				tcp_sack_swap(sp, sp-1);
tcp_input.c:2811:		this_sack--;
tcp_input.c:2812:		tp->num_sacks--;
tcp_input.c:2813:		sp--;
tcp_input.c:2815:	for(; this_sack > 0; this_sack--, sp--)
tcp_input.c:2816:		*sp = *(sp-1);
tcp_input.c:2820:	sp->start_seq = seq;
tcp_input.c:2821:	sp->end_seq = end_seq;
tcp_input.c:2822:	tp->num_sacks++;
tcp_input.c:2823:	tp->eff_sacks = min(tp->num_sacks+tp->dsack, 4-tp->tstamp_ok);
tcp_input.c:2830:	struct tcp_sack_block *sp = &tp->selective_acks[0];
tcp_input.c:2831:	int num_sacks = tp->num_sacks;
tcp_input.c:2835:	if (skb_queue_len(&tp->out_of_order_queue) == 0) {
tcp_input.c:2836:		tp->num_sacks = 0;
tcp_input.c:2837:		tp->eff_sacks = tp->dsack;
tcp_input.c:2843:		if (!before(tp->rcv_nxt, sp->start_seq)) {
tcp_input.c:2847:			BUG_TRAP(!before(tp->rcv_nxt, sp->end_seq));
tcp_input.c:2851:				tp->selective_acks[i-1] = tp->selective_acks[i];
tcp_input.c:2852:			num_sacks--;
tcp_input.c:2858:	if (num_sacks != tp->num_sacks) {
tcp_input.c:2859:		tp->num_sacks = num_sacks;
tcp_input.c:2860:		tp->eff_sacks = min(tp->num_sacks+tp->dsack, 4-tp->tstamp_ok);
tcp_input.c:2869:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:2870:	__u32 dsack_high = tp->rcv_nxt;
tcp_input.c:2873:	while ((skb = skb_peek(&tp->out_of_order_queue)) != NULL) {
tcp_input.c:2874:		if (after(TCP_SKB_CB(skb)->seq, tp->rcv_nxt))
tcp_input.c:2877:		if (before(TCP_SKB_CB(skb)->seq, dsack_high)) {
tcp_input.c:2879:			if (before(TCP_SKB_CB(skb)->end_seq, dsack_high))
tcp_input.c:2880:				dsack_high = TCP_SKB_CB(skb)->end_seq;
tcp_input.c:2881:			tcp_dsack_extend(tp, TCP_SKB_CB(skb)->seq, dsack);
tcp_input.c:2884:		if (!after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt)) {
tcp_input.c:2886:			__skb_unlink(skb, skb->list);
tcp_input.c:2890:		SOCK_DEBUG(sk, "ofo requeuing : rcv_next %X seq %X - %X\n",
tcp_input.c:2891:			   tp->rcv_nxt, TCP_SKB_CB(skb)->seq,
tcp_input.c:2892:			   TCP_SKB_CB(skb)->end_seq);
tcp_input.c:2894:		__skb_unlink(skb, skb->list);
tcp_input.c:2895:		__skb_queue_tail(&sk->receive_queue, skb);
tcp_input.c:2896:		tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq;
tcp_input.c:2897:		if(skb->h.th->fin)
tcp_input.c:2898:			tcp_fin(skb, sk, skb->h.th);
tcp_input.c:2904:	return (int)skb->truesize <= sk->forward_alloc ||
tcp_input.c:2905:		tcp_mem_schedule(sk, skb->truesize, 1);
tcp_input.c:2912:	struct tcphdr *th = skb->h.th;
tcp_input.c:2913:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:2914:	int eaten = -1;
tcp_input.c:2916:	if (TCP_SKB_CB(skb)->seq == TCP_SKB_CB(skb)->end_seq)
tcp_input.c:2919:	th = skb->h.th;
tcp_input.c:2920:	__skb_pull(skb, th->doff*4);
tcp_input.c:2924:	if (tp->dsack) {
tcp_input.c:2925:		tp->dsack = 0;
tcp_input.c:2926:		tp->eff_sacks = min_t(unsigned int, tp->num_sacks, 4-tp->tstamp_ok);
tcp_input.c:2933:	if (TCP_SKB_CB(skb)->seq == tp->rcv_nxt) {
tcp_input.c:2938:		if (tp->ucopy.task == current &&
tcp_input.c:2939:		    tp->copied_seq == tp->rcv_nxt &&
tcp_input.c:2940:		    tp->ucopy.len &&
tcp_input.c:2941:		    sk->lock.users &&
tcp_input.c:2942:		    !tp->urg_data) {
tcp_input.c:2943:			int chunk = min_t(unsigned int, skb->len, tp->ucopy.len);
tcp_input.c:2948:			if (!skb_copy_datagram_iovec(skb, 0, tp->ucopy.iov, chunk)) {
tcp_input.c:2949:				tp->ucopy.len -= chunk;
tcp_input.c:2950:				tp->copied_seq += chunk;
tcp_input.c:2951:				eaten = (chunk == skb->len && !th->fin);
tcp_input.c:2959:			    (atomic_read(&sk->rmem_alloc) > sk->rcvbuf ||
tcp_input.c:2965:			__skb_queue_tail(&sk->receive_queue, skb);
tcp_input.c:2967:		tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq;
tcp_input.c:2968:		if(skb->len)
tcp_input.c:2970:		if(th->fin)
tcp_input.c:2973:		if (skb_queue_len(&tp->out_of_order_queue)) {
tcp_input.c:2979:			if (skb_queue_len(&tp->out_of_order_queue) == 0)
tcp_input.c:2980:				tp->ack.pingpong = 0;
tcp_input.c:2983:		if(tp->num_sacks)
tcp_input.c:2990:		} else if (!sk->dead)
tcp_input.c:2991:			sk->data_ready(sk, 0);
tcp_input.c:2995:	if (!after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt)) {
tcp_input.c:2998:		tcp_dsack_set(tp, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq);
tcp_input.c:3009:	if (!before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt+tcp_receive_window(tp)))
tcp_input.c:3014:	if (before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt)) {
tcp_input.c:3016:		SOCK_DEBUG(sk, "partial packet: rcv_next %X seq %X - %X\n",
tcp_input.c:3017:			   tp->rcv_nxt, TCP_SKB_CB(skb)->seq,
tcp_input.c:3018:			   TCP_SKB_CB(skb)->end_seq);
tcp_input.c:3020:		tcp_dsack_set(tp, TCP_SKB_CB(skb)->seq, tp->rcv_nxt);
tcp_input.c:3023:		 * remembering D-SACK for its head made in previous line.
tcp_input.c:3032:	if (atomic_read(&sk->rmem_alloc) > sk->rcvbuf ||
tcp_input.c:3039:	tp->pred_flags = 0;
tcp_input.c:3042:	SOCK_DEBUG(sk, "out of order segment: rcv_next %X seq %X - %X\n",
tcp_input.c:3043:		   tp->rcv_nxt, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq);
tcp_input.c:3047:	if (skb_peek(&tp->out_of_order_queue) == NULL) {
tcp_input.c:3049:		if(tp->sack_ok) {
tcp_input.c:3050:			tp->num_sacks = 1;
tcp_input.c:3051:			tp->dsack = 0;
tcp_input.c:3052:			tp->eff_sacks = 1;
tcp_input.c:3053:			tp->selective_acks[0].start_seq = TCP_SKB_CB(skb)->seq;
tcp_input.c:3054:			tp->selective_acks[0].end_seq = TCP_SKB_CB(skb)->end_seq;
tcp_input.c:3056:		__skb_queue_head(&tp->out_of_order_queue,skb);
tcp_input.c:3058:		struct sk_buff *skb1=tp->out_of_order_queue.prev;
tcp_input.c:3059:		u32 seq = TCP_SKB_CB(skb)->seq;
tcp_input.c:3060:		u32 end_seq = TCP_SKB_CB(skb)->end_seq;
tcp_input.c:3062:		if (seq == TCP_SKB_CB(skb1)->end_seq) {
tcp_input.c:3065:			if (tp->num_sacks == 0 ||
tcp_input.c:3066:			    tp->selective_acks[0].end_seq != seq)
tcp_input.c:3070:			tp->selective_acks[0].end_seq = end_seq;
tcp_input.c:3076:			if (!after(TCP_SKB_CB(skb1)->seq, seq))
tcp_input.c:3078:		} while ((skb1=skb1->prev) != (struct sk_buff*)&tp->out_of_order_queue);
tcp_input.c:3081:		if (skb1 != (struct sk_buff*)&tp->out_of_order_queue &&
tcp_input.c:3082:		    before(seq, TCP_SKB_CB(skb1)->end_seq)) {
tcp_input.c:3083:			if (!after(end_seq, TCP_SKB_CB(skb1)->end_seq)) {
tcp_input.c:3089:			if (after(seq, TCP_SKB_CB(skb1)->seq)) {
tcp_input.c:3091:				tcp_dsack_set(tp, seq, TCP_SKB_CB(skb1)->end_seq);
tcp_input.c:3093:				skb1 = skb1->prev;
tcp_input.c:3096:		__skb_insert(skb, skb1, skb1->next, &tp->out_of_order_queue);
tcp_input.c:3099:		while ((skb1 = skb->next) != (struct sk_buff*)&tp->out_of_order_queue &&
tcp_input.c:3100:		       after(end_seq, TCP_SKB_CB(skb1)->seq)) {
tcp_input.c:3101:		       if (before(end_seq, TCP_SKB_CB(skb1)->end_seq)) {
tcp_input.c:3102:			       tcp_dsack_extend(tp, TCP_SKB_CB(skb1)->seq, end_seq);
tcp_input.c:3105:		       __skb_unlink(skb1, skb1->list);
tcp_input.c:3106:		       tcp_dsack_extend(tp, TCP_SKB_CB(skb1)->seq, TCP_SKB_CB(skb1)->end_seq);
tcp_input.c:3111:		if (tp->sack_ok)
tcp_input.c:3131:		if (!before(start, TCP_SKB_CB(skb)->end_seq)) {
tcp_input.c:3132:			struct sk_buff *next = skb->next;
tcp_input.c:3133:			__skb_unlink(skb, skb->list);
tcp_input.c:3141:		 * - not SYN/FIN and
tcp_input.c:3142:		 * - bloated or contains data before "start" or
tcp_input.c:3145:		if (!skb->h.th->syn && !skb->h.th->fin &&
tcp_input.c:3146:		    (tcp_win_from_space(skb->truesize) > skb->len ||
tcp_input.c:3147:		     before(TCP_SKB_CB(skb)->seq, start) ||
tcp_input.c:3148:		     (skb->next != tail &&
tcp_input.c:3149:		      TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb->next)->seq)))
tcp_input.c:3153:		start = TCP_SKB_CB(skb)->end_seq;
tcp_input.c:3154:		skb = skb->next;
tcp_input.c:3156:	if (skb == tail || skb->h.th->syn || skb->h.th->fin)
tcp_input.c:3162:		int copy = (PAGE_SIZE - sizeof(struct sk_buff) -
tcp_input.c:3163:			    sizeof(struct skb_shared_info) - header - 31)&~15;
tcp_input.c:3168:		if (end-start < copy)
tcp_input.c:3169:			copy = end-start;
tcp_input.c:3174:		memcpy(nskb->head, skb->head, header);
tcp_input.c:3175:		nskb->nh.raw = nskb->head + (skb->nh.raw-skb->head);
tcp_input.c:3176:		nskb->h.raw = nskb->head + (skb->h.raw-skb->head);
tcp_input.c:3177:		nskb->mac.raw = nskb->head + (skb->mac.raw-skb->head);
tcp_input.c:3178:		memcpy(nskb->cb, skb->cb, sizeof(skb->cb));
tcp_input.c:3179:		TCP_SKB_CB(nskb)->seq = TCP_SKB_CB(nskb)->end_seq = start;
tcp_input.c:3180:		__skb_insert(nskb, skb->prev, skb, skb->list);
tcp_input.c:3185:			int offset = start - TCP_SKB_CB(skb)->seq;
tcp_input.c:3186:			int size = TCP_SKB_CB(skb)->end_seq - start;
tcp_input.c:3193:				TCP_SKB_CB(nskb)->end_seq += size;
tcp_input.c:3194:				copy -= size;
tcp_input.c:3197:			if (!before(start, TCP_SKB_CB(skb)->end_seq)) {
tcp_input.c:3198:				struct sk_buff *next = skb->next;
tcp_input.c:3199:				__skb_unlink(skb, skb->list);
tcp_input.c:3203:				if (skb == tail || skb->h.th->syn || skb->h.th->fin)
tcp_input.c:3215:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:3216:	struct sk_buff *skb = skb_peek(&tp->out_of_order_queue);
tcp_input.c:3223:	start = TCP_SKB_CB(skb)->seq;
tcp_input.c:3224:	end = TCP_SKB_CB(skb)->end_seq;
tcp_input.c:3228:		skb = skb->next;
tcp_input.c:3232:		if (skb == (struct sk_buff *)&tp->out_of_order_queue ||
tcp_input.c:3233:		    after(TCP_SKB_CB(skb)->seq, end) ||
tcp_input.c:3234:		    before(TCP_SKB_CB(skb)->end_seq, start)) {
tcp_input.c:3237:			if (skb == (struct sk_buff *)&tp->out_of_order_queue)
tcp_input.c:3240:			start = TCP_SKB_CB(skb)->seq;
tcp_input.c:3241:			end = TCP_SKB_CB(skb)->end_seq;
tcp_input.c:3243:			if (before(TCP_SKB_CB(skb)->seq, start))
tcp_input.c:3244:				start = TCP_SKB_CB(skb)->seq;
tcp_input.c:3245:			if (after(TCP_SKB_CB(skb)->end_seq, end))
tcp_input.c:3246:				end = TCP_SKB_CB(skb)->end_seq;
tcp_input.c:3260:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp; 
tcp_input.c:3262:	SOCK_DEBUG(sk, "prune_queue: c=%x\n", tp->copied_seq);
tcp_input.c:3266:	if (atomic_read(&sk->rmem_alloc) >= sk->rcvbuf)
tcp_input.c:3269:		tp->rcv_ssthresh = min(tp->rcv_ssthresh, 4U*tp->advmss);
tcp_input.c:3272:	tcp_collapse(sk, sk->receive_queue.next,
tcp_input.c:3273:		     (struct sk_buff*)&sk->receive_queue,
tcp_input.c:3274:		     tp->copied_seq, tp->rcv_nxt);
tcp_input.c:3277:	if (atomic_read(&sk->rmem_alloc) <= sk->rcvbuf)
tcp_input.c:3284:	if (skb_queue_len(&tp->out_of_order_queue)) {
tcp_input.c:3285:		net_statistics[smp_processor_id()*2].OfoPruned += skb_queue_len(&tp->out_of_order_queue);
tcp_input.c:3286:		__skb_queue_purge(&tp->out_of_order_queue);
tcp_input.c:3293:		if(tp->sack_ok)
tcp_input.c:3298:	if(atomic_read(&sk->rmem_alloc) <= sk->rcvbuf)
tcp_input.c:3308:	tp->pred_flags = 0;
tcp_input.c:3309:	return -1;
tcp_input.c:3319:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:3321:	if (tp->ca_state == TCP_CA_Open &&
tcp_input.c:3322:	    sk->socket && !test_bit(SOCK_NOSPACE, &sk->socket->flags)) {
tcp_input.c:3324:		u32 win_used = max(tp->snd_cwnd_used, 2U);
tcp_input.c:3325:		if (win_used < tp->snd_cwnd) {
tcp_input.c:3326:			tp->snd_ssthresh = tcp_current_ssthresh(tp);
tcp_input.c:3327:			tp->snd_cwnd = (tp->snd_cwnd+win_used)>>1;
tcp_input.c:3329:		tp->snd_cwnd_used = 0;
tcp_input.c:3331:	tp->snd_cwnd_stamp = tcp_time_stamp;
tcp_input.c:3336: * we remember this event in flag tp->queue_shrunk and wake up socket
tcp_input.c:3341:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:3343:	if (tp->packets_out < tp->snd_cwnd &&
tcp_input.c:3344:	    !(sk->userlocks&SOCK_SNDBUF_LOCK) &&
tcp_input.c:3349:		sndmem = tp->mss_clamp+MAX_TCP_HEADER+16+sizeof(struct sk_buff);
tcp_input.c:3350:		demanded = max_t(unsigned int, tp->snd_cwnd, tp->reordering+1);
tcp_input.c:3352:		if (sndmem > sk->sndbuf)
tcp_input.c:3353:			sk->sndbuf = min(sndmem, sysctl_tcp_wmem[2]);
tcp_input.c:3354:		tp->snd_cwnd_stamp = tcp_time_stamp;
tcp_input.c:3357:	sk->write_space(sk);
tcp_input.c:3362:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:3364:	if (tp->queue_shrunk) {
tcp_input.c:3365:		tp->queue_shrunk = 0;
tcp_input.c:3366:		if (sk->socket && test_bit(SOCK_NOSPACE, &sk->socket->flags))
tcp_input.c:3373:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:3375:	if (after(TCP_SKB_CB(skb)->end_seq, tp->snd_una + tp->snd_wnd) ||
tcp_input.c:3376:	    tcp_packets_in_flight(tp) >= tp->snd_cwnd ||
tcp_input.c:3377:	    tcp_write_xmit(sk, tp->nonagle))
tcp_input.c:3383:	struct sk_buff *skb = sk->tp_pinfo.af_tcp.send_head;
tcp_input.c:3395:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:3398:	if (((tp->rcv_nxt - tp->rcv_wup) > tp->ack.rcv_mss
tcp_input.c:3402:	     && __tcp_select_window(sk) >= tp->rcv_wnd) ||
tcp_input.c:3407:	     skb_peek(&tp->out_of_order_queue) != NULL)) {
tcp_input.c:3418:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:3430: *	place. We handle URGent data wrong. We have to - as
tcp_input.c:3438:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:3439:	u32 ptr = ntohs(th->urg_ptr);
tcp_input.c:3442:		ptr--;
tcp_input.c:3443:	ptr += ntohl(th->seq);
tcp_input.c:3446:	if (after(tp->copied_seq, ptr))
tcp_input.c:3459:	if (before(ptr, tp->rcv_nxt))
tcp_input.c:3463:	if (tp->urg_data && !after(ptr, tp->urg_seq))
tcp_input.c:3467:	if (sk->proc != 0) {
tcp_input.c:3468:		if (sk->proc > 0)
tcp_input.c:3469:			kill_proc(sk->proc, SIGURG, 1);
tcp_input.c:3471:			kill_pg(-sk->proc, SIGURG, 1);
tcp_input.c:3477:	 * tp->copied_seq since we would read the last urgent byte again
tcp_input.c:3490:	if (tp->urg_seq == tp->copied_seq && tp->urg_data &&
tcp_input.c:3491:	    !sk->urginline &&
tcp_input.c:3492:	    tp->copied_seq != tp->rcv_nxt) {
tcp_input.c:3493:		struct sk_buff *skb = skb_peek(&sk->receive_queue);
tcp_input.c:3494:		tp->copied_seq++;
tcp_input.c:3495:		if (skb && !before(tp->copied_seq, TCP_SKB_CB(skb)->end_seq)) {
tcp_input.c:3496:			__skb_unlink(skb, skb->list);
tcp_input.c:3501:	tp->urg_data = TCP_URG_NOTYET;
tcp_input.c:3502:	tp->urg_seq = ptr;
tcp_input.c:3505:	tp->pred_flags = 0;
tcp_input.c:3511:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:3513:	/* Check if we get a new urgent pointer - normally not. */
tcp_input.c:3514:	if (th->urg)
tcp_input.c:3517:	/* Do we wait for any urgent data? - normally not... */
tcp_input.c:3518:	if (tp->urg_data == TCP_URG_NOTYET) {
tcp_input.c:3519:		u32 ptr = tp->urg_seq - ntohl(th->seq) + (th->doff*4) - th->syn;
tcp_input.c:3522:		if (ptr < skb->len) {
tcp_input.c:3526:			tp->urg_data = TCP_URG_VALID | tmp;
tcp_input.c:3527:			if (!sk->dead)
tcp_input.c:3528:				sk->data_ready(sk,0);
tcp_input.c:3535:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:3536:	int chunk = skb->len - hlen;
tcp_input.c:3540:	if (skb->ip_summed==CHECKSUM_UNNECESSARY)
tcp_input.c:3541:		err = skb_copy_datagram_iovec(skb, hlen, tp->ucopy.iov, chunk);
tcp_input.c:3543:		err = skb_copy_and_csum_datagram_iovec(skb, hlen, tp->ucopy.iov);
tcp_input.c:3546:		tp->ucopy.len -= chunk;
tcp_input.c:3547:		tp->copied_seq += chunk;
tcp_input.c:3558:	if (sk->lock.users) {
tcp_input.c:3571:	return skb->ip_summed != CHECKSUM_UNNECESSARY &&
tcp_input.c:3580: *	- A zero window was announced from us - zero window probing
tcp_input.c:3582: *	- Out of order segments arrived.
tcp_input.c:3583: *	- Urgent data is expected.
tcp_input.c:3584: *	- There is no buffer space left
tcp_input.c:3585: *	- Unexpected TCP flags/window values/header lengths are received
tcp_input.c:3587: *	- Data is sent in both directions. Fast path only supports pure senders
tcp_input.c:3590: *	- Unexpected TCP option.
tcp_input.c:3601:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:3618:	tp->saw_tstamp = 0;
tcp_input.c:3622:	 *	'S' will always be tp->tcp_header_len >> 2
tcp_input.c:3629:	if ((tcp_flag_word(th) & TCP_HP_BITS) == tp->pred_flags &&
tcp_input.c:3630:		TCP_SKB_CB(skb)->seq == tp->rcv_nxt) {
tcp_input.c:3631:		int tcp_header_len = tp->tcp_header_len;
tcp_input.c:3634:		 * is automatically equal to th->doff*4 due to pred_flags
tcp_input.c:3647:			tp->saw_tstamp = 1;
tcp_input.c:3649:			tp->rcv_tsval = ntohl(*ptr);
tcp_input.c:3651:			tp->rcv_tsecr = ntohl(*ptr);
tcp_input.c:3654:			if ((s32)(tp->rcv_tsval - tp->ts_recent) < 0)
tcp_input.c:3673:				    tp->rcv_nxt == tp->rcv_wup)
tcp_input.c:3689:			if (tp->ucopy.task == current &&
tcp_input.c:3690:			    tp->copied_seq == tp->rcv_nxt &&
tcp_input.c:3691:			    len - tcp_header_len <= tp->ucopy.len &&
tcp_input.c:3692:			    sk->lock.users) {
tcp_input.c:3703:					    tp->rcv_nxt == tp->rcv_wup)
tcp_input.c:3707:					tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq;
tcp_input.c:3722:				    tp->rcv_nxt == tp->rcv_wup)
tcp_input.c:3725:				if ((int)skb->truesize > sk->forward_alloc)
tcp_input.c:3732:				__skb_queue_tail(&sk->receive_queue, skb);
tcp_input.c:3734:				tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq;
tcp_input.c:3739:			if (TCP_SKB_CB(skb)->ack_seq != tp->snd_una) {
tcp_input.c:3761:				sk->data_ready(sk, 0);
tcp_input.c:3767:	if (len < (th->doff<<2) || tcp_checksum_complete_user(sk, skb))
tcp_input.c:3773:	if (tcp_fast_parse_options(skb, th, tp) && tp->saw_tstamp &&
tcp_input.c:3775:		if (!th->rst) {
tcp_input.c:3791:	if (!tcp_sequence(tp, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq)) {
tcp_input.c:3792:		/* RFC793, page 37: "In all states except SYN-SENT, all reset
tcp_input.c:3793:		 * (RST) segments are validated by checking their SEQ-fields."
tcp_input.c:3798:		if (!th->rst)
tcp_input.c:3803:	if(th->rst) {
tcp_input.c:3808:	tcp_replace_ts_recent(tp, TCP_SKB_CB(skb)->seq);
tcp_input.c:3810:	if (th->syn && !before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt)) {
tcp_input.c:3818:	if(th->ack)
tcp_input.c:3842:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:3843:	int saved_clamp = tp->mss_clamp;
tcp_input.c:3847:	if (th->ack) {
tcp_input.c:3849:		 * "If the state is SYN-SENT then
tcp_input.c:3856:		 *  We do not send data with SYN, so that RFC-correct
tcp_input.c:3859:		if (TCP_SKB_CB(skb)->ack_seq != tp->snd_nxt)
tcp_input.c:3862:		if (tp->saw_tstamp && tp->rcv_tsecr &&
tcp_input.c:3863:		    !between(tp->rcv_tsecr, tp->retrans_stamp, tcp_time_stamp)) {
tcp_input.c:3876:		if (th->rst) {
tcp_input.c:3886:		 *                                        --ANK(990513)
tcp_input.c:3888:		if (!th->syn)
tcp_input.c:3900:		tp->snd_wl1 = TCP_SKB_CB(skb)->seq;
tcp_input.c:3906:		tp->rcv_nxt = TCP_SKB_CB(skb)->seq+1;
tcp_input.c:3907:		tp->rcv_wup = TCP_SKB_CB(skb)->seq+1;
tcp_input.c:3912:		tp->snd_wnd = ntohs(th->window);
tcp_input.c:3913:		tcp_init_wl(tp, TCP_SKB_CB(skb)->ack_seq, TCP_SKB_CB(skb)->seq);
tcp_input.c:3915:		if (tp->wscale_ok == 0) {
tcp_input.c:3916:			tp->snd_wscale = tp->rcv_wscale = 0;
tcp_input.c:3917:			tp->window_clamp = min(tp->window_clamp, 65535U);
tcp_input.c:3920:		if (tp->saw_tstamp) {
tcp_input.c:3921:			tp->tstamp_ok = 1;
tcp_input.c:3922:			tp->tcp_header_len =
tcp_input.c:3924:			tp->advmss -= TCPOLEN_TSTAMP_ALIGNED;
tcp_input.c:3927:			tp->tcp_header_len = sizeof(struct tcphdr);
tcp_input.c:3930:		if (tp->sack_ok && sysctl_tcp_fack)
tcp_input.c:3931:			tp->sack_ok |= 2;
tcp_input.c:3933:		tcp_sync_mss(sk, tp->pmtu_cookie);
tcp_input.c:3938:		if (sk->keepopen)
tcp_input.c:3941:		if (tp->snd_wscale == 0)
tcp_input.c:3942:			__tcp_fast_path_on(tp, tp->snd_wnd);
tcp_input.c:3944:			tp->pred_flags = 0;
tcp_input.c:3947:		 * Change state from SYN-SENT only after copied_seq
tcp_input.c:3949:		tp->copied_seq = tp->rcv_nxt;
tcp_input.c:3953:		if(!sk->dead) {
tcp_input.c:3954:			sk->state_change(sk);
tcp_input.c:3958:		if (tp->write_pending || tp->defer_accept || tp->ack.pingpong) {
tcp_input.c:3964:			 * to stand against the temptation 8)     --ANK
tcp_input.c:3967:			tp->ack.lrcvtime = tcp_time_stamp;
tcp_input.c:3968:			tp->ack.ato = TCP_ATO_MIN;
tcp_input.c:3979:		return -1;
tcp_input.c:3984:	if (th->rst) {
tcp_input.c:3995:	if (tp->ts_recent_stamp && tp->saw_tstamp && tcp_paws_check(tp, 0))
tcp_input.c:3998:	if (th->syn) {
tcp_input.c:4005:		if (tp->saw_tstamp) {
tcp_input.c:4006:			tp->tstamp_ok = 1;
tcp_input.c:4008:			tp->tcp_header_len =
tcp_input.c:4011:			tp->tcp_header_len = sizeof(struct tcphdr);
tcp_input.c:4014:		tp->rcv_nxt = TCP_SKB_CB(skb)->seq + 1;
tcp_input.c:4015:		tp->rcv_wup = TCP_SKB_CB(skb)->seq + 1;
tcp_input.c:4020:		tp->snd_wnd = ntohs(th->window);
tcp_input.c:4021:		tp->snd_wl1 = TCP_SKB_CB(skb)->seq;
tcp_input.c:4022:		tp->max_window = tp->snd_wnd;
tcp_input.c:4024:		tcp_sync_mss(sk, tp->pmtu_cookie);
tcp_input.c:4040:		return -1;
tcp_input.c:4051:	tp->mss_clamp = saved_clamp;
tcp_input.c:4056:	tp->mss_clamp = saved_clamp;
tcp_input.c:4070:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_input.c:4073:	tp->saw_tstamp = 0;
tcp_input.c:4075:	switch (sk->state) {
tcp_input.c:4080:		if(th->ack)
tcp_input.c:4083:		if(th->rst)
tcp_input.c:4086:		if(th->syn) {
tcp_input.c:4087:			if(tp->af_specific->conn_request(sk, skb) < 0)
tcp_input.c:4126:	if (tcp_fast_parse_options(skb, th, tp) && tp->saw_tstamp &&
tcp_input.c:4128:		if (!th->rst) {
tcp_input.c:4137:	if (!tcp_sequence(tp, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq)) {
tcp_input.c:4138:		if (!th->rst)
tcp_input.c:4144:	if(th->rst) {
tcp_input.c:4149:	tcp_replace_ts_recent(tp, TCP_SKB_CB(skb)->seq);
tcp_input.c:4157:	if (th->syn && !before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt)) {
tcp_input.c:4164:	if (th->ack) {
tcp_input.c:4167:		switch(sk->state) {
tcp_input.c:4170:				tp->copied_seq = tp->rcv_nxt;
tcp_input.c:4173:				sk->state_change(sk);
tcp_input.c:4177:				 * are not waked up, because sk->sleep == NULL
tcp_input.c:4178:				 * and sk->socket == NULL.
tcp_input.c:4180:				if (sk->socket) {
tcp_input.c:4184:				tp->snd_una = TCP_SKB_CB(skb)->ack_seq;
tcp_input.c:4185:				tp->snd_wnd = ntohs(th->window) << tp->snd_wscale;
tcp_input.c:4186:				tcp_init_wl(tp, TCP_SKB_CB(skb)->ack_seq, TCP_SKB_CB(skb)->seq);
tcp_input.c:4192:				if (tp->saw_tstamp && tp->rcv_tsecr && !tp->srtt)
tcp_input.c:4195:				if (tp->tstamp_ok)
tcp_input.c:4196:					tp->advmss -= TCPOLEN_TSTAMP_ALIGNED;
tcp_input.c:4208:			if (tp->snd_una == tp->write_seq) {
tcp_input.c:4210:				sk->shutdown |= SEND_SHUTDOWN;
tcp_input.c:4211:				dst_confirm(sk->dst_cache);
tcp_input.c:4213:				if (!sk->dead) {
tcp_input.c:4215:					sk->state_change(sk);
tcp_input.c:4219:					if (tp->linger2 < 0 ||
tcp_input.c:4220:					    (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&
tcp_input.c:4221:					     after(TCP_SKB_CB(skb)->end_seq - th->fin, tp->rcv_nxt))) {
tcp_input.c:4229:						tcp_reset_keepalive_timer(sk, tmo - TCP_TIMEWAIT_LEN);
tcp_input.c:4230:					} else if (th->fin || sk->lock.users) {
tcp_input.c:4247:			if (tp->snd_una == tp->write_seq) {
tcp_input.c:4254:			if (tp->snd_una == tp->write_seq) {
tcp_input.c:4268:	switch (sk->state) {
tcp_input.c:4272:		if (!before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt))
tcp_input.c:4280:		if (sk->shutdown & RCV_SHUTDOWN) {
tcp_input.c:4281:			if (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&
tcp_input.c:4282:			    after(TCP_SKB_CB(skb)->end_seq - th->fin, tp->rcv_nxt)) {
tcp_input.c:4295:	/* tcp_data could move socket to TIME-WAIT */
tcp_input.c:4296:	if (sk->state != TCP_CLOSE) {
tcp_ipv4.c:89: * ALL members must be initialised to prevent gcc-2.7.2.3 miscompilation
tcp_ipv4.c:106: * For high-usage systems, use sysctl to change this to
tcp_ipv4.c:107: * 32768-61000
tcp_ipv4.c:110:int tcp_port_rover = (1024 - 1);
tcp_ipv4.c:118:	return h & (tcp_ehash_size - 1);
tcp_ipv4.c:123:	__u32 laddr = sk->rcv_saddr;
tcp_ipv4.c:124:	__u16 lport = sk->num;
tcp_ipv4.c:125:	__u32 faddr = sk->daddr;
tcp_ipv4.c:126:	__u16 fport = sk->dport;
tcp_ipv4.c:141:		tb->port = snum;
tcp_ipv4.c:142:		tb->fastreuse = 0;
tcp_ipv4.c:143:		tb->owners = NULL;
tcp_ipv4.c:144:		if((tb->next = head->chain) != NULL)
tcp_ipv4.c:145:			tb->next->pprev = &tb->next;
tcp_ipv4.c:146:		head->chain = tb;
tcp_ipv4.c:147:		tb->pprev = &head->chain;
tcp_ipv4.c:155:	struct tcp_bind_hashbucket *head = &tcp_bhash[tcp_bhashfn(child->num)];
tcp_ipv4.c:158:	spin_lock(&head->lock);
tcp_ipv4.c:159:	tb = (struct tcp_bind_bucket *)sk->prev;
tcp_ipv4.c:160:	if ((child->bind_next = tb->owners) != NULL)
tcp_ipv4.c:161:		tb->owners->bind_pprev = &child->bind_next;
tcp_ipv4.c:162:	tb->owners = child;
tcp_ipv4.c:163:	child->bind_pprev = &tb->owners;
tcp_ipv4.c:164:	child->prev = (struct sock *) tb;
tcp_ipv4.c:165:	spin_unlock(&head->lock);
tcp_ipv4.c:177:	sk->num = snum;
tcp_ipv4.c:178:	if ((sk->bind_next = tb->owners) != NULL)
tcp_ipv4.c:179:		tb->owners->bind_pprev = &sk->bind_next;
tcp_ipv4.c:180:	tb->owners = sk;
tcp_ipv4.c:181:	sk->bind_pprev = &tb->owners;
tcp_ipv4.c:182:	sk->prev = (struct sock *) tb;
tcp_ipv4.c:187:	struct sock *sk2 = tb->owners;
tcp_ipv4.c:188:	int sk_reuse = sk->reuse;
tcp_ipv4.c:190:	for( ; sk2 != NULL; sk2 = sk2->bind_next) {
tcp_ipv4.c:192:		    sk2->reuse <= 1 &&
tcp_ipv4.c:194:		    (!sk->bound_dev_if ||
tcp_ipv4.c:195:		     !sk2->bound_dev_if ||
tcp_ipv4.c:196:		     sk->bound_dev_if == sk2->bound_dev_if)) {
tcp_ipv4.c:198:			    !sk2->reuse	||
tcp_ipv4.c:199:			    sk2->state == TCP_LISTEN) {
tcp_ipv4.c:200:				if (!sk2->rcv_saddr	||
tcp_ipv4.c:201:				    !sk->rcv_saddr	||
tcp_ipv4.c:202:				    (sk2->rcv_saddr == sk->rcv_saddr))
tcp_ipv4.c:223:		int remaining = (high - low) + 1;
tcp_ipv4.c:232:			spin_lock(&head->lock);
tcp_ipv4.c:233:			for (tb = head->chain; tb; tb = tb->next)
tcp_ipv4.c:234:				if (tb->port == rover)
tcp_ipv4.c:238:			spin_unlock(&head->lock);
tcp_ipv4.c:239:		} while (--remaining > 0);
tcp_ipv4.c:249:		 * non-NULL and we hold it's mutex.
tcp_ipv4.c:255:		spin_lock(&head->lock);
tcp_ipv4.c:256:		for (tb = head->chain; tb != NULL; tb = tb->next)
tcp_ipv4.c:257:			if (tb->port == snum)
tcp_ipv4.c:260:	if (tb != NULL && tb->owners != NULL) {
tcp_ipv4.c:261:		if (sk->reuse > 1)
tcp_ipv4.c:263:		if (tb->fastreuse > 0 && sk->reuse != 0 && sk->state != TCP_LISTEN) {
tcp_ipv4.c:275:	if (tb->owners == NULL) {
tcp_ipv4.c:276:		if (sk->reuse && sk->state != TCP_LISTEN)
tcp_ipv4.c:277:			tb->fastreuse = 1;
tcp_ipv4.c:279:			tb->fastreuse = 0;
tcp_ipv4.c:280:	} else if (tb->fastreuse &&
tcp_ipv4.c:281:		   ((sk->reuse == 0) || (sk->state == TCP_LISTEN)))
tcp_ipv4.c:282:		tb->fastreuse = 0;
tcp_ipv4.c:284:	if (sk->prev == NULL)
tcp_ipv4.c:286:	BUG_TRAP(sk->prev == (struct sock *) tb);
tcp_ipv4.c:290:	spin_unlock(&head->lock);
tcp_ipv4.c:301:	struct tcp_bind_hashbucket *head = &tcp_bhash[tcp_bhashfn(sk->num)];
tcp_ipv4.c:304:	spin_lock(&head->lock);
tcp_ipv4.c:305:	tb = (struct tcp_bind_bucket *) sk->prev;
tcp_ipv4.c:306:	if (sk->bind_next)
tcp_ipv4.c:307:		sk->bind_next->bind_pprev = sk->bind_pprev;
tcp_ipv4.c:308:	*(sk->bind_pprev) = sk->bind_next;
tcp_ipv4.c:309:	sk->prev = NULL;
tcp_ipv4.c:310:	sk->num = 0;
tcp_ipv4.c:311:	if (tb->owners == NULL) {
tcp_ipv4.c:312:		if (tb->next)
tcp_ipv4.c:313:			tb->next->pprev = tb->pprev;
tcp_ipv4.c:314:		*(tb->pprev) = tb->next;
tcp_ipv4.c:317:	spin_unlock(&head->lock);
tcp_ipv4.c:361:	BUG_TRAP(sk->pprev==NULL);
tcp_ipv4.c:362:	if(listen_possible && sk->state == TCP_LISTEN) {
tcp_ipv4.c:367:		skp = &tcp_ehash[(sk->hashent = tcp_sk_hashfn(sk))].chain;
tcp_ipv4.c:368:		lock = &tcp_ehash[sk->hashent].lock;
tcp_ipv4.c:371:	if((sk->next = *skp) != NULL)
tcp_ipv4.c:372:		(*skp)->pprev = &sk->next;
tcp_ipv4.c:374:	sk->pprev = skp;
tcp_ipv4.c:375:	sock_prot_inc_use(sk->prot);
tcp_ipv4.c:377:	if (listen_possible && sk->state == TCP_LISTEN)
tcp_ipv4.c:383:	if (sk->state != TCP_CLOSE) {
tcp_ipv4.c:394:	if (!sk->pprev)
tcp_ipv4.c:397:	if (sk->state == TCP_LISTEN) {
tcp_ipv4.c:402:		struct tcp_ehash_bucket *head = &tcp_ehash[sk->hashent];
tcp_ipv4.c:403:		lock = &head->lock;
tcp_ipv4.c:404:		write_lock_bh(&head->lock);
tcp_ipv4.c:407:	if(sk->pprev) {
tcp_ipv4.c:408:		if(sk->next)
tcp_ipv4.c:409:			sk->next->pprev = sk->pprev;
tcp_ipv4.c:410:		*sk->pprev = sk->next;
tcp_ipv4.c:411:		sk->pprev = NULL;
tcp_ipv4.c:412:		sock_prot_dec_use(sk->prot);
tcp_ipv4.c:417:	if (sk->state == TCP_LISTEN)
tcp_ipv4.c:432:	hiscore=-1;
tcp_ipv4.c:433:	for(; sk; sk = sk->next) {
tcp_ipv4.c:434:		if(sk->num == hnum && !ipv6_only_sock(sk)) {
tcp_ipv4.c:435:			__u32 rcv_saddr = sk->rcv_saddr;
tcp_ipv4.c:438:			score = sk->family == PF_INET ? 1 : 0;
tcp_ipv4.c:447:			if (sk->bound_dev_if) {
tcp_ipv4.c:448:				if (sk->bound_dev_if != dif)
tcp_ipv4.c:471:		if (sk->num == hnum &&
tcp_ipv4.c:472:		    sk->next == NULL &&
tcp_ipv4.c:473:		    (!sk->rcv_saddr || sk->rcv_saddr == daddr) &&
tcp_ipv4.c:474:		    (sk->family == PF_INET || !ipv6_only_sock(sk)) &&
tcp_ipv4.c:475:		    !sk->bound_dev_if)
tcp_ipv4.c:488: * we need not check it for TCP lookups anymore, thanks Alexey. -DaveM
tcp_ipv4.c:507:	read_lock(&head->lock);
tcp_ipv4.c:508:	for(sk = head->chain; sk; sk = sk->next) {
tcp_ipv4.c:514:	for(sk = (head + tcp_ehash_size)->chain; sk; sk = sk->next)
tcp_ipv4.c:517:	read_unlock(&head->lock);
tcp_ipv4.c:523:	read_unlock(&head->lock);
tcp_ipv4.c:553:	return secure_tcp_sequence_number(skb->nh.iph->daddr,
tcp_ipv4.c:554:					  skb->nh.iph->saddr,
tcp_ipv4.c:555:					  skb->h.th->dest,
tcp_ipv4.c:556:					  skb->h.th->source);
tcp_ipv4.c:563:	u32 daddr = sk->rcv_saddr;
tcp_ipv4.c:564:	u32 saddr = sk->daddr;
tcp_ipv4.c:565:	int dif = sk->bound_dev_if;
tcp_ipv4.c:567:	__u32 ports = TCP_COMBINED_PORTS(sk->dport, lport);
tcp_ipv4.c:568:	int hash = tcp_hashfn(daddr, lport, saddr, sk->dport);
tcp_ipv4.c:573:	write_lock(&head->lock);
tcp_ipv4.c:575:	/* Check TIME-WAIT sockets first. */
tcp_ipv4.c:576:	for(skp = &(head + tcp_ehash_size)->chain; (sk2=*skp) != NULL;
tcp_ipv4.c:577:	    skp = &sk2->next) {
tcp_ipv4.c:581:			struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_ipv4.c:597:			if (tw->ts_recent_stamp &&
tcp_ipv4.c:599:				      xtime.tv_sec - tw->ts_recent_stamp > 1))) {
tcp_ipv4.c:600:				if ((tp->write_seq = tw->snd_nxt+65535+2) == 0)
tcp_ipv4.c:601:					tp->write_seq = 1;
tcp_ipv4.c:602:				tp->ts_recent = tw->ts_recent;
tcp_ipv4.c:603:				tp->ts_recent_stamp = tw->ts_recent_stamp;
tcp_ipv4.c:605:				skp = &head->chain;
tcp_ipv4.c:614:	for(skp = &head->chain; (sk2=*skp)!=NULL; skp = &sk2->next) {
tcp_ipv4.c:622:	sk->num = lport;
tcp_ipv4.c:623:	sk->sport = htons(lport);
tcp_ipv4.c:624:	BUG_TRAP(sk->pprev==NULL);
tcp_ipv4.c:625:	if ((sk->next = *skp) != NULL)
tcp_ipv4.c:626:		(*skp)->pprev = &sk->next;
tcp_ipv4.c:629:	sk->pprev = skp;
tcp_ipv4.c:630:	sk->hashent = hash;
tcp_ipv4.c:631:	sock_prot_inc_use(sk->prot);
tcp_ipv4.c:632:	write_unlock(&head->lock);
tcp_ipv4.c:638:		/* Silly. Should hash-dance instead... */
tcp_ipv4.c:649:	write_unlock(&head->lock);
tcp_ipv4.c:650:	return -EADDRNOTAVAIL;
tcp_ipv4.c:658:	unsigned short snum = sk->num;
tcp_ipv4.c:666:		int remaining = (high - low) + 1;
tcp_ipv4.c:692:			spin_lock(&head->lock);		
tcp_ipv4.c:698:			for (tb = head->chain; tb; tb = tb->next) {
tcp_ipv4.c:699:				if (tb->port == rover) {
tcp_ipv4.c:700:					BUG_TRAP(tb->owners != NULL);
tcp_ipv4.c:701:					if (tb->fastreuse >= 0)
tcp_ipv4.c:711:				spin_unlock(&head->lock);
tcp_ipv4.c:714:			tb->fastreuse = -1;
tcp_ipv4.c:718:			spin_unlock(&head->lock);
tcp_ipv4.c:719:		} while (--remaining > 0);
tcp_ipv4.c:725:		return -EADDRNOTAVAIL;
tcp_ipv4.c:733:		if (!sk->pprev) {
tcp_ipv4.c:734:			sk->sport = htons(rover);
tcp_ipv4.c:737:		spin_unlock(&head->lock);
tcp_ipv4.c:750:	tb  = (struct tcp_bind_bucket *)sk->prev;
tcp_ipv4.c:751:	spin_lock_bh(&head->lock);
tcp_ipv4.c:752:	if (tb->owners == sk && sk->bind_next == NULL) {
tcp_ipv4.c:754:		spin_unlock_bh(&head->lock);
tcp_ipv4.c:758:		spin_unlock(&head->lock);
tcp_ipv4.c:769:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_ipv4.c:777:		return(-EINVAL);
tcp_ipv4.c:779:	if (usin->sin_family != AF_INET)
tcp_ipv4.c:780:		return(-EAFNOSUPPORT);
tcp_ipv4.c:782:	nexthop = daddr = usin->sin_addr.s_addr;
tcp_ipv4.c:783:	if (sk->protinfo.af_inet.opt && sk->protinfo.af_inet.opt->srr) {
tcp_ipv4.c:785:			return -EINVAL;
tcp_ipv4.c:786:		nexthop = sk->protinfo.af_inet.opt->faddr;
tcp_ipv4.c:789:	tmp = ip_route_connect(&rt, nexthop, sk->saddr,
tcp_ipv4.c:790:			       RT_CONN_FLAGS(sk), sk->bound_dev_if);
tcp_ipv4.c:794:	if (rt->rt_flags&(RTCF_MULTICAST|RTCF_BROADCAST)) {
tcp_ipv4.c:796:		return -ENETUNREACH;
tcp_ipv4.c:799:	__sk_dst_set(sk, &rt->u.dst);
tcp_ipv4.c:800:	sk->route_caps = rt->u.dst.dev->features;
tcp_ipv4.c:802:	if (!sk->protinfo.af_inet.opt || !sk->protinfo.af_inet.opt->srr)
tcp_ipv4.c:803:		daddr = rt->rt_dst;
tcp_ipv4.c:805:	if (!sk->saddr)
tcp_ipv4.c:806:		sk->saddr = rt->rt_src;
tcp_ipv4.c:807:	sk->rcv_saddr = sk->saddr;
tcp_ipv4.c:809:	if (tp->ts_recent_stamp && sk->daddr != daddr) {
tcp_ipv4.c:811:		tp->ts_recent = 0;
tcp_ipv4.c:812:		tp->ts_recent_stamp = 0;
tcp_ipv4.c:813:		tp->write_seq = 0;
tcp_ipv4.c:817:	    !tp->ts_recent_stamp &&
tcp_ipv4.c:818:	    rt->rt_dst == daddr) {
tcp_ipv4.c:822:		 * the destination in peer table, when entering state TIME-WAIT
tcp_ipv4.c:826:		if (peer && peer->tcp_ts_stamp + TCP_PAWS_MSL >= xtime.tv_sec) {
tcp_ipv4.c:827:			tp->ts_recent_stamp = peer->tcp_ts_stamp;
tcp_ipv4.c:828:			tp->ts_recent = peer->tcp_ts;
tcp_ipv4.c:832:	sk->dport = usin->sin_port;
tcp_ipv4.c:833:	sk->daddr = daddr;
tcp_ipv4.c:835:	tp->ext_header_len = 0;
tcp_ipv4.c:836:	if (sk->protinfo.af_inet.opt)
tcp_ipv4.c:837:		tp->ext_header_len = sk->protinfo.af_inet.opt->optlen;
tcp_ipv4.c:839:	tp->mss_clamp = 536;
tcp_ipv4.c:842:	 * However we set state to SYN-SENT and not releasing socket
tcp_ipv4.c:851:	if (!tp->write_seq)
tcp_ipv4.c:852:		tp->write_seq = secure_tcp_sequence_number(sk->saddr, sk->daddr,
tcp_ipv4.c:853:							   sk->sport, usin->sin_port);
tcp_ipv4.c:855:	sk->protinfo.af_inet.id = tp->write_seq^jiffies;
tcp_ipv4.c:866:	sk->route_caps = 0;
tcp_ipv4.c:867:	sk->dport = 0;
tcp_ipv4.c:873:	return ((struct rtable*)skb->dst)->rt_iif;
tcp_ipv4.c:878:	return (jhash_2words(raddr, (u32) rport, rnd) & (TCP_SYNQ_HSIZE - 1));
tcp_ipv4.c:886:	struct tcp_listen_opt *lopt = tp->listen_opt;
tcp_ipv4.c:889:	for (prev = &lopt->syn_table[tcp_v4_synq_hash(raddr, rport, lopt->hash_rnd)];
tcp_ipv4.c:891:	     prev = &req->dl_next) {
tcp_ipv4.c:892:		if (req->rmt_port == rport &&
tcp_ipv4.c:893:		    req->af.v4_req.rmt_addr == raddr &&
tcp_ipv4.c:894:		    req->af.v4_req.loc_addr == laddr &&
tcp_ipv4.c:895:		    TCP_INET_FAMILY(req->class->family)) {
tcp_ipv4.c:896:			BUG_TRAP(req->sk == NULL);
tcp_ipv4.c:907:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tcp_ipv4.c:908:	struct tcp_listen_opt *lopt = tp->listen_opt;
tcp_ipv4.c:909:	u32 h = tcp_v4_synq_hash(req->af.v4_req.rmt_addr, req->rmt_port, lopt->hash_rnd);
tcp_ipv4.c:911:	req->expires = jiffies + TCP_TIMEOUT_INIT;
tcp_ipv4.c:912:	req->retrans = 0;
tcp_ipv4.c:913:	req->sk = NULL;
tcp_ipv4.c:914:	req->dl_next = lopt->syn_table[h];
tcp_ipv4.c:916:	write_lock(&tp->syn_wait_lock);
tcp_ipv4.c:917:	lopt->syn_table[h] = req;
tcp_ipv4.c:918:	write_unlock(&tp->syn_wait_lock);
tcp_ipv4.c:930:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tcp_ipv4.c:932:	/* We are not interested in TCP_LISTEN and open_requests (SYN-ACKs
tcp_ipv4.c:936:	if (sk->state == TCP_LISTEN)
tcp_ipv4.c:953:	if (mtu < dst->pmtu && ip_dont_fragment(sk, dst))
tcp_ipv4.c:954:		sk->err_soft = EMSGSIZE;
tcp_ipv4.c:956:	if (sk->protinfo.af_inet.pmtudisc != IP_PMTUDISC_DONT &&
tcp_ipv4.c:957:	    tp->pmtu_cookie > dst->pmtu) {
tcp_ipv4.c:958:		tcp_sync_mss(sk, dst->pmtu);
tcp_ipv4.c:987:	struct iphdr *iph = (struct iphdr*)skb->data;
tcp_ipv4.c:988:	struct tcphdr *th = (struct tcphdr*)(skb->data+(iph->ihl<<2));
tcp_ipv4.c:990:	int type = skb->h.icmph->type;
tcp_ipv4.c:991:	int code = skb->h.icmph->code;
tcp_ipv4.c:996:	if (skb->len < (iph->ihl << 2) + 8) {
tcp_ipv4.c:1001:	sk = tcp_v4_lookup(iph->daddr, th->dest, iph->saddr, th->source, tcp_v4_iif(skb));
tcp_ipv4.c:1006:	if (sk->state == TCP_TIME_WAIT) {
tcp_ipv4.c:1015:	if (sk->lock.users != 0)
tcp_ipv4.c:1018:	if (sk->state == TCP_CLOSE)
tcp_ipv4.c:1021:	tp = &sk->tp_pinfo.af_tcp;
tcp_ipv4.c:1022:	seq = ntohl(th->seq);
tcp_ipv4.c:1023:	if (sk->state != TCP_LISTEN && !between(seq, tp->snd_una, tp->snd_nxt)) {
tcp_ipv4.c:1033:		if (sk->lock.users == 0)
tcp_ipv4.c:1044:			if (sk->lock.users == 0)
tcp_ipv4.c:1058:	switch (sk->state) {
tcp_ipv4.c:1061:		if (sk->lock.users != 0)
tcp_ipv4.c:1065:					th->dest,
tcp_ipv4.c:1066:					iph->daddr, iph->saddr); 
tcp_ipv4.c:1073:		BUG_TRAP(req->sk == NULL);
tcp_ipv4.c:1075:		if (seq != req->snt_isn) {
tcp_ipv4.c:1093:		if (sk->lock.users == 0) {
tcp_ipv4.c:1095:			sk->err = err;
tcp_ipv4.c:1097:			sk->error_report(sk);
tcp_ipv4.c:1101:			sk->err_soft = err;
tcp_ipv4.c:1119:	 *							--ANK (980905)
tcp_ipv4.c:1122:	if (sk->lock.users == 0 && sk->protinfo.af_inet.recverr) {
tcp_ipv4.c:1123:		sk->err = err;
tcp_ipv4.c:1124:		sk->error_report(sk);
tcp_ipv4.c:1126:		sk->err_soft = err;
tcp_ipv4.c:1138:	if (skb->ip_summed == CHECKSUM_HW) {
tcp_ipv4.c:1139:		th->check = ~tcp_v4_check(th, len, sk->saddr, sk->daddr, 0);
tcp_ipv4.c:1140:		skb->csum = offsetof(struct tcphdr, check);
tcp_ipv4.c:1142:		th->check = tcp_v4_check(th, len, sk->saddr, sk->daddr,
tcp_ipv4.c:1143:					 csum_partial((char *)th, th->doff<<2, skb->csum));
tcp_ipv4.c:1162:	struct tcphdr *th = skb->h.th;
tcp_ipv4.c:1167:	if (th->rst)
tcp_ipv4.c:1170:	if (((struct rtable*)skb->dst)->rt_type != RTN_LOCAL)
tcp_ipv4.c:1175:	rth.dest = th->source;
tcp_ipv4.c:1176:	rth.source = th->dest; 
tcp_ipv4.c:1180:	if (th->ack) {
tcp_ipv4.c:1181:		rth.seq = th->ack_seq;
tcp_ipv4.c:1184:		rth.ack_seq = htonl(ntohl(th->seq) + th->syn + th->fin
tcp_ipv4.c:1185:				    + skb->len - (th->doff<<2));
tcp_ipv4.c:1191:	arg.csum = csum_tcpudp_nofold(skb->nh.iph->daddr, 
tcp_ipv4.c:1192:				      skb->nh.iph->saddr, /*XXX*/
tcp_ipv4.c:1199:	tcp_socket->sk->protinfo.af_inet.ttl = sysctl_ip_default_ttl;
tcp_ipv4.c:1200:	ip_send_reply(tcp_socket->sk, skb, &arg, sizeof rth);
tcp_ipv4.c:1206:/* The code following below sending ACKs in SYN-RECV and TIME-WAIT states
tcp_ipv4.c:1212:	struct tcphdr *th = skb->h.th;
tcp_ipv4.c:1236:	rep.th.dest = th->source;
tcp_ipv4.c:1237:	rep.th.source = th->dest; 
tcp_ipv4.c:1244:	arg.csum = csum_tcpudp_nofold(skb->nh.iph->daddr, 
tcp_ipv4.c:1245:				      skb->nh.iph->saddr, /*XXX*/
tcp_ipv4.c:1251:	ip_send_reply(tcp_socket->sk, skb, &arg, arg.iov[0].iov_len);
tcp_ipv4.c:1260:	tcp_v4_send_ack(skb, tw->snd_nxt, tw->rcv_nxt,
tcp_ipv4.c:1261:			tw->rcv_wnd>>tw->rcv_wscale, tw->ts_recent);
tcp_ipv4.c:1268:	tcp_v4_send_ack(skb, req->snt_isn+1, req->rcv_isn+1, req->rcv_wnd,
tcp_ipv4.c:1269:			req->ts_recent);
tcp_ipv4.c:1277:	opt = req->af.v4_req.opt;
tcp_ipv4.c:1278:	if(ip_route_output(&rt, ((opt && opt->srr) ?
tcp_ipv4.c:1279:				 opt->faddr :
tcp_ipv4.c:1280:				 req->af.v4_req.rmt_addr),
tcp_ipv4.c:1281:			   req->af.v4_req.loc_addr,
tcp_ipv4.c:1282:			   RT_CONN_FLAGS(sk), sk->bound_dev_if)) {
tcp_ipv4.c:1286:	if (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway) {
tcp_ipv4.c:1291:	return &rt->u.dst;
tcp_ipv4.c:1295: *	Send a SYN-ACK after having received an ACK. 
tcp_ipv4.c:1302:	int err = -1;
tcp_ipv4.c:1313:		struct tcphdr *th = skb->h.th;
tcp_ipv4.c:1315:		th->check = tcp_v4_check(th, skb->len,
tcp_ipv4.c:1316:					 req->af.v4_req.loc_addr, req->af.v4_req.rmt_addr,
tcp_ipv4.c:1317:					 csum_partial((char *)th, skb->len, skb->csum));
tcp_ipv4.c:1319:		err = ip_build_and_send_pkt(skb, sk, req->af.v4_req.loc_addr,
tcp_ipv4.c:1320:					    req->af.v4_req.rmt_addr, req->af.v4_req.opt);
tcp_ipv4.c:1335:	if (req->af.v4_req.opt)
tcp_ipv4.c:1336:		kfree(req->af.v4_req.opt);
tcp_ipv4.c:1343:	if (jiffies - warntime > HZ*60) {
tcp_ipv4.c:1347:		       ntohs(skb->h.th->dest));
tcp_ipv4.c:1357:	struct ip_options *opt = &(IPCB(skb)->opt);
tcp_ipv4.c:1360:	if (opt && opt->optlen) {
tcp_ipv4.c:1400:	__u32 saddr = skb->nh.iph->saddr;
tcp_ipv4.c:1401:	__u32 daddr = skb->nh.iph->daddr;
tcp_ipv4.c:1402:	__u32 isn = TCP_SKB_CB(skb)->when;
tcp_ipv4.c:1411:	if (((struct rtable *)skb->dst)->rt_flags & 
tcp_ipv4.c:1442:	tp.user_mss = sk->tp_pinfo.af_tcp.user_mss;
tcp_ipv4.c:1464:	req->af.v4_req.loc_addr = daddr;
tcp_ipv4.c:1465:	req->af.v4_req.rmt_addr = saddr;
tcp_ipv4.c:1466:	req->af.v4_req.opt = tcp_v4_save_options(sk, skb);
tcp_ipv4.c:1467:	req->class = &or_ipv4;
tcp_ipv4.c:1469:		TCP_ECN_create_request(req, skb->h.th);
tcp_ipv4.c:1475:		isn = cookie_v4_init_sequence(sk, skb, &req->mss);
tcp_ipv4.c:1481:		 * state TIME-WAIT, and check against it before
tcp_ipv4.c:1492:		    peer->v4daddr == saddr) {
tcp_ipv4.c:1493:			if (xtime.tv_sec < peer->tcp_ts_stamp + TCP_PAWS_MSL &&
tcp_ipv4.c:1494:			    (s32)(peer->tcp_ts - req->ts_recent) > TCP_PAWS_WINDOW) {
tcp_ipv4.c:1502:			 (sysctl_max_syn_backlog - tcp_synq_len(sk)
tcp_ipv4.c:1504:			 (!peer || !peer->tcp_ts_stamp) &&
tcp_ipv4.c:1505:			 (!dst || !dst->rtt)) {
tcp_ipv4.c:1514:					NIPQUAD(saddr), ntohs(skb->h.th->source)));
tcp_ipv4.c:1521:	req->snt_isn = isn;
tcp_ipv4.c:1542: * The three way handshake has completed - we got a valid synack - 
tcp_ipv4.c:1563:	newsk->dst_cache = dst;
tcp_ipv4.c:1564:	newsk->route_caps = dst->dev->features;
tcp_ipv4.c:1566:	newtp = &(newsk->tp_pinfo.af_tcp);
tcp_ipv4.c:1567:	newsk->daddr = req->af.v4_req.rmt_addr;
tcp_ipv4.c:1568:	newsk->saddr = req->af.v4_req.loc_addr;
tcp_ipv4.c:1569:	newsk->rcv_saddr = req->af.v4_req.loc_addr;
tcp_ipv4.c:1570:	newsk->protinfo.af_inet.opt = req->af.v4_req.opt;
tcp_ipv4.c:1571:	req->af.v4_req.opt = NULL;
tcp_ipv4.c:1572:	newsk->protinfo.af_inet.mc_index = tcp_v4_iif(skb);
tcp_ipv4.c:1573:	newsk->protinfo.af_inet.mc_ttl = skb->nh.iph->ttl;
tcp_ipv4.c:1574:	newtp->ext_header_len = 0;
tcp_ipv4.c:1575:	if (newsk->protinfo.af_inet.opt)
tcp_ipv4.c:1576:		newtp->ext_header_len = newsk->protinfo.af_inet.opt->optlen;
tcp_ipv4.c:1577:	newsk->protinfo.af_inet.id = newtp->write_seq^jiffies;
tcp_ipv4.c:1579:	tcp_sync_mss(newsk, dst->pmtu);
tcp_ipv4.c:1580:	newtp->advmss = dst->advmss;
tcp_ipv4.c:1599:	struct tcphdr *th = skb->h.th;
tcp_ipv4.c:1600:	struct iphdr *iph = skb->nh.iph;
tcp_ipv4.c:1601:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_ipv4.c:1606:				th->source,
tcp_ipv4.c:1607:				iph->saddr, iph->daddr);
tcp_ipv4.c:1611:	nsk = __tcp_v4_lookup_established(skb->nh.iph->saddr,
tcp_ipv4.c:1612:					  th->source,
tcp_ipv4.c:1613:					  skb->nh.iph->daddr,
tcp_ipv4.c:1614:					  ntohs(th->dest),
tcp_ipv4.c:1618:		if (nsk->state != TCP_TIME_WAIT) {
tcp_ipv4.c:1627:	if (!th->rst && !th->syn && th->ack)
tcp_ipv4.c:1628:		sk = cookie_v4_check(sk, skb, &(IPCB(skb)->opt));
tcp_ipv4.c:1635:	if (skb->ip_summed == CHECKSUM_HW) {
tcp_ipv4.c:1636:		skb->ip_summed = CHECKSUM_UNNECESSARY;
tcp_ipv4.c:1637:		if (!tcp_v4_check(skb->h.th,skb->len,skb->nh.iph->saddr,
tcp_ipv4.c:1638:				  skb->nh.iph->daddr,skb->csum))
tcp_ipv4.c:1642:		skb->ip_summed = CHECKSUM_NONE;
tcp_ipv4.c:1644:	if (skb->len <= 76) {
tcp_ipv4.c:1645:		if (tcp_v4_check(skb->h.th,skb->len,skb->nh.iph->saddr,
tcp_ipv4.c:1646:				 skb->nh.iph->daddr,
tcp_ipv4.c:1647:				 skb_checksum(skb, 0, skb->len, 0)))
tcp_ipv4.c:1648:			return -1;
tcp_ipv4.c:1649:		skb->ip_summed = CHECKSUM_UNNECESSARY;
tcp_ipv4.c:1651:		skb->csum = ~tcp_v4_check(skb->h.th,skb->len,skb->nh.iph->saddr,
tcp_ipv4.c:1652:					  skb->nh.iph->daddr,0);
tcp_ipv4.c:1662: * We have a potential double-lock case here, so even when
tcp_ipv4.c:1671:	if((sk->tp_pinfo.af_tcp.drop_rate > 0) && 
tcp_ipv4.c:1672:	   (mwc_rand() % 1000 < sk->tp_pinfo.af_tcp.drop_rate)) {
tcp_ipv4.c:1676:	if(sk->tp_pinfo.af_tcp.trickles_opt & TCP_TRICKLES_ENABLE) {
tcp_ipv4.c:1682:	if (sk->state == TCP_ESTABLISHED) { /* Fast path */
tcp_ipv4.c:1684:		if (tcp_rcv_established(sk, skb, skb->h.th, skb->len))
tcp_ipv4.c:1690:	if (skb->len < (skb->h.th->doff<<2) || tcp_checksum_complete(skb))
tcp_ipv4.c:1693:	if (sk->state == TCP_LISTEN) { 
tcp_ipv4.c:1706:	if (tcp_rcv_state_process(sk, skb, skb->h.th, skb->len))
tcp_ipv4.c:1737:	if (skb->pkt_type!=PACKET_HOST)
tcp_ipv4.c:1746:	th = skb->h.th;
tcp_ipv4.c:1748:	if (th->doff < sizeof(struct tcphdr)/4)
tcp_ipv4.c:1750:	if (!pskb_may_pull(skb, th->doff*4))
tcp_ipv4.c:1755:	 * provided case of th->doff==0 is elimineted.
tcp_ipv4.c:1757:	if ((skb->ip_summed != CHECKSUM_UNNECESSARY &&
tcp_ipv4.c:1761:	th = skb->h.th;
tcp_ipv4.c:1762:	TCP_SKB_CB(skb)->seq = ntohl(th->seq);
tcp_ipv4.c:1763:	TCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +
tcp_ipv4.c:1764:				    skb->len - th->doff*4);
tcp_ipv4.c:1765:	TCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);
tcp_ipv4.c:1766:	TCP_SKB_CB(skb)->when = 0;
tcp_ipv4.c:1767:	TCP_SKB_CB(skb)->flags = skb->nh.iph->tos;
tcp_ipv4.c:1768:	TCP_SKB_CB(skb)->sacked = 0;
tcp_ipv4.c:1770:	sk = __tcp_v4_lookup(skb->nh.iph->saddr, th->source,
tcp_ipv4.c:1771:			     skb->nh.iph->daddr, ntohs(th->dest), tcp_v4_iif(skb));
tcp_ipv4.c:1780:	if (sk->state == TCP_TIME_WAIT)
tcp_ipv4.c:1786:	skb->dev = NULL;
tcp_ipv4.c:1791:	LOG_ACK(sk, TCP_SKB_CB(skb)->ack_seq);
tcp_ipv4.c:1792:	if (!sk->lock.users) {
tcp_ipv4.c:1804:	if (skb->len < (th->doff<<2) || tcp_checksum_complete(skb)) {
tcp_ipv4.c:1821:	if (skb->len < (th->doff<<2) || tcp_checksum_complete(skb)) {
tcp_ipv4.c:1827:					  skb, th, skb->len)) {
tcp_ipv4.c:1832:		sk2 = tcp_v4_lookup_listener(skb->nh.iph->daddr, ntohs(th->dest), tcp_v4_iif(skb));
tcp_ipv4.c:1852:/* With per-bucket locks this operation is not-atomic, so that
tcp_ipv4.c:1857:	sk->prot->unhash(sk);
tcp_ipv4.c:1858:	sk->prot->hash(sk);
tcp_ipv4.c:1865:	__u32 old_saddr = sk->saddr;
tcp_ipv4.c:1867:	__u32 daddr = sk->daddr;
tcp_ipv4.c:1869:	if(sk->protinfo.af_inet.opt && sk->protinfo.af_inet.opt->srr)
tcp_ipv4.c:1870:		daddr = sk->protinfo.af_inet.opt->faddr;
tcp_ipv4.c:1874:			       RT_TOS(sk->protinfo.af_inet.tos)|sk->localroute,
tcp_ipv4.c:1875:			       sk->bound_dev_if);
tcp_ipv4.c:1879:	__sk_dst_set(sk, &rt->u.dst);
tcp_ipv4.c:1880:	sk->route_caps = rt->u.dst.dev->features;
tcp_ipv4.c:1882:	new_saddr = rt->rt_src;
tcp_ipv4.c:1888:		printk(KERN_INFO "tcp_v4_rebuild_header(): shifting sk->saddr "
tcp_ipv4.c:1894:	sk->saddr = new_saddr;
tcp_ipv4.c:1895:	sk->rcv_saddr = new_saddr;
tcp_ipv4.c:1899:	 * XXX it has entered the hashes. -DaveM
tcp_ipv4.c:1919:	daddr = sk->daddr;
tcp_ipv4.c:1920:	if(sk->protinfo.af_inet.opt && sk->protinfo.af_inet.opt->srr)
tcp_ipv4.c:1921:		daddr = sk->protinfo.af_inet.opt->faddr;
tcp_ipv4.c:1923:	err = ip_route_output(&rt, daddr, sk->saddr,
tcp_ipv4.c:1924:			      RT_CONN_FLAGS(sk), sk->bound_dev_if);
tcp_ipv4.c:1926:		__sk_dst_set(sk, &rt->u.dst);
tcp_ipv4.c:1927:		sk->route_caps = rt->u.dst.dev->features;
tcp_ipv4.c:1932:	sk->route_caps = 0;
tcp_ipv4.c:1935:	    sk->state != TCP_SYN_SENT ||
tcp_ipv4.c:1936:	    (sk->userlocks & SOCK_BINDADDR_LOCK) ||
tcp_ipv4.c:1938:		sk->err_soft=-err;
tcp_ipv4.c:1947:	sin->sin_family		= AF_INET;
tcp_ipv4.c:1948:	sin->sin_addr.s_addr	= sk->daddr;
tcp_ipv4.c:1949:	sin->sin_port		= sk->dport;
tcp_ipv4.c:1960:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tcp_ipv4.c:1965:	if (rt == NULL || rt->rt_dst != sk->daddr) {
tcp_ipv4.c:1966:		peer = inet_getpeer(sk->daddr, 1);
tcp_ipv4.c:1969:		if (rt->peer == NULL)
tcp_ipv4.c:1971:		peer = rt->peer;
tcp_ipv4.c:1975:		if ((s32)(peer->tcp_ts - tp->ts_recent) <= 0 ||
tcp_ipv4.c:1976:		    (peer->tcp_ts_stamp + TCP_PAWS_MSL < xtime.tv_sec &&
tcp_ipv4.c:1977:		     peer->tcp_ts_stamp <= tp->ts_recent_stamp)) {
tcp_ipv4.c:1978:			peer->tcp_ts_stamp = tp->ts_recent_stamp;
tcp_ipv4.c:1979:			peer->tcp_ts = tp->ts_recent;
tcp_ipv4.c:1993:	peer = inet_getpeer(tw->daddr, 1);
tcp_ipv4.c:1996:		if ((s32)(peer->tcp_ts - tw->ts_recent) <= 0 ||
tcp_ipv4.c:1997:		    (peer->tcp_ts_stamp + TCP_PAWS_MSL < xtime.tv_sec &&
tcp_ipv4.c:1998:		     peer->tcp_ts_stamp <= tw->ts_recent_stamp)) {
tcp_ipv4.c:1999:			peer->tcp_ts_stamp = tw->ts_recent_stamp;
tcp_ipv4.c:2000:			peer->tcp_ts = tw->ts_recent;
tcp_ipv4.c:2029:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_ipv4.c:2031:	skb_queue_head_init(&tp->out_of_order_queue);
tcp_ipv4.c:2035:	tp->rto  = TCP_TIMEOUT_INIT;
tcp_ipv4.c:2036:	tp->mdev = TCP_TIMEOUT_INIT;
tcp_ipv4.c:2039:	 * initial SYN frame in their delayed-ACK and congestion control
tcp_ipv4.c:2041:	 * efficiently to them.  -DaveM
tcp_ipv4.c:2043:	tp->snd_cwnd = 2;
tcp_ipv4.c:2045:	/* See draft-stevens-tcpca-spec-01 for discussion of the
tcp_ipv4.c:2048:	tp->snd_ssthresh = 0x7fffffff;	/* Infinity */
tcp_ipv4.c:2049:	tp->snd_cwnd_clamp = ~0;
tcp_ipv4.c:2050:	tp->mss_cache = 536;
tcp_ipv4.c:2052:	tp->reordering = sysctl_tcp_reordering;
tcp_ipv4.c:2056:	sk->state = TCP_CLOSE;
tcp_ipv4.c:2058:	sk->write_space = tcp_write_space;
tcp_ipv4.c:2059:	sk->use_write_queue = 1;
tcp_ipv4.c:2061:	sk->tp_pinfo.af_tcp.af_specific = &ipv4_specific;
tcp_ipv4.c:2063:	sk->sndbuf = sysctl_tcp_wmem[1];
tcp_ipv4.c:2064:	sk->rcvbuf = sysctl_tcp_rmem[1];
tcp_ipv4.c:2073:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_ipv4.c:2081:  	__skb_queue_purge(&tp->out_of_order_queue);
tcp_ipv4.c:2084:	__skb_queue_purge(&tp->ucopy.prequeue);
tcp_ipv4.c:2087:	if(sk->prev != NULL)
tcp_ipv4.c:2091:	if (tp->sndmsg_page != NULL)
tcp_ipv4.c:2092:		__free_page(tp->sndmsg_page);
tcp_ipv4.c:2103:	int ttd = req->expires - jiffies;
tcp_ipv4.c:2108:		req->af.v4_req.loc_addr,
tcp_ipv4.c:2109:		ntohs(sk->sport),
tcp_ipv4.c:2110:		req->af.v4_req.rmt_addr,
tcp_ipv4.c:2111:		ntohs(req->rmt_port),
tcp_ipv4.c:2116:		req->retrans,
tcp_ipv4.c:2120:		atomic_read(&sk->refcnt),
tcp_ipv4.c:2131:	struct tcp_opt *tp = &sp->tp_pinfo.af_tcp;
tcp_ipv4.c:2133:	dest  = sp->daddr;
tcp_ipv4.c:2134:	src   = sp->rcv_saddr;
tcp_ipv4.c:2135:	destp = ntohs(sp->dport);
tcp_ipv4.c:2136:	srcp  = ntohs(sp->sport);
tcp_ipv4.c:2137:	if (tp->pending == TCP_TIME_RETRANS) {
tcp_ipv4.c:2139:		timer_expires	= tp->timeout;
tcp_ipv4.c:2140:	} else if (tp->pending == TCP_TIME_PROBE0) {
tcp_ipv4.c:2142:		timer_expires	= tp->timeout;
tcp_ipv4.c:2143:	} else if (timer_pending(&sp->timer)) {
tcp_ipv4.c:2145:		timer_expires	= sp->timer.expires;
tcp_ipv4.c:2153:		i, src, srcp, dest, destp, sp->state, 
tcp_ipv4.c:2154:		tp->write_seq-tp->snd_una, tp->rcv_nxt-tp->copied_seq,
tcp_ipv4.c:2155:		timer_active, timer_expires-jiffies,
tcp_ipv4.c:2156:		tp->retransmits,
tcp_ipv4.c:2158:		tp->probes_out,
tcp_ipv4.c:2160:		atomic_read(&sp->refcnt), sp,
tcp_ipv4.c:2161:		tp->rto, tp->ack.ato, (tp->ack.quick<<1)|tp->ack.pingpong,
tcp_ipv4.c:2162:		tp->snd_cwnd, tp->snd_ssthresh>=0xFFFF?-1:tp->snd_ssthresh
tcp_ipv4.c:2170:	int ttd = tw->ttd - jiffies;
tcp_ipv4.c:2175:	dest  = tw->daddr;
tcp_ipv4.c:2176:	src   = tw->rcv_saddr;
tcp_ipv4.c:2177:	destp = ntohs(tw->dport);
tcp_ipv4.c:2178:	srcp  = ntohs(tw->sport);
tcp_ipv4.c:2182:		i, src, srcp, dest, destp, tw->substate, 0, 0,
tcp_ipv4.c:2184:		atomic_read(&tw->refcnt), tw);
tcp_ipv4.c:2196:		len += sprintf(buffer, "%-*s\n", TMPSZ-1,
tcp_ipv4.c:2198:			       "rx_queue tr tm->when retrnsmt   uid  timeout inode");
tcp_ipv4.c:2209:		for (sk = tcp_listening_hash[i]; sk; sk = sk->next, num++) {
tcp_ipv4.c:2212:			struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_ipv4.c:2214:			if (!TCP_INET_FAMILY(sk->family))
tcp_ipv4.c:2220:				len += sprintf(buffer+len, "%-*s\n", TMPSZ-1, tmpbuf);
tcp_ipv4.c:2229:			read_lock_bh(&tp->syn_wait_lock);
tcp_ipv4.c:2230:			lopt = tp->listen_opt;
tcp_ipv4.c:2231:			if (lopt && lopt->qlen != 0) {
tcp_ipv4.c:2233:					for (req = lopt->syn_table[k]; req; req = req->dl_next, num++) {
tcp_ipv4.c:2234:						if (!TCP_INET_FAMILY(req->class->family))
tcp_ipv4.c:2241:						len += sprintf(buffer+len, "%-*s\n", TMPSZ-1, tmpbuf);
tcp_ipv4.c:2243:							read_unlock_bh(&tp->syn_wait_lock);
tcp_ipv4.c:2250:			read_unlock_bh(&tp->syn_wait_lock);
tcp_ipv4.c:2265:		read_lock(&head->lock);
tcp_ipv4.c:2266:		for(sk = head->chain; sk; sk = sk->next, num++) {
tcp_ipv4.c:2267:			if (!TCP_INET_FAMILY(sk->family))
tcp_ipv4.c:2273:			len += sprintf(buffer+len, "%-*s\n", TMPSZ-1, tmpbuf);
tcp_ipv4.c:2275:				read_unlock(&head->lock);
tcp_ipv4.c:2281:		     tw = (struct tcp_tw_bucket *)tw->next, num++) {
tcp_ipv4.c:2282:			if (!TCP_INET_FAMILY(tw->family))
tcp_ipv4.c:2288:			len += sprintf(buffer+len, "%-*s\n", TMPSZ-1, tmpbuf);
tcp_ipv4.c:2290:				read_unlock(&head->lock);
tcp_ipv4.c:2294:		read_unlock(&head->lock);
tcp_ipv4.c:2301:	begin = len - (pos - offset);
tcp_ipv4.c:2303:	len -= begin;
tcp_ipv4.c:2344:	tcp_socket->inode = &tcp_inode;
tcp_ipv4.c:2345:	tcp_socket->state = SS_UNCONNECTED;
tcp_ipv4.c:2346:	tcp_socket->type=SOCK_RAW;
tcp_ipv4.c:2348:	if ((err=ops->create(tcp_socket, IPPROTO_TCP))<0)
tcp_ipv4.c:2350:	tcp_socket->sk->allocation=GFP_ATOMIC;
tcp_ipv4.c:2351:	tcp_socket->sk->protinfo.af_inet.ttl = MAXTTL;
tcp_ipv4.c:2357:	tcp_socket->sk->prot->unhash(tcp_socket->sk);
tcp_minisocks.c:13: *		Corey Minyard <wf-rch!minyard@relay.EU.net>
tcp_minisocks.c:14: *		Florian La Roche, <flla@stud.uni-sb.de>
tcp_minisocks.c:52:/* New-style handling of TIME_WAIT sockets. */
tcp_minisocks.c:65:	ehead = &tcp_ehash[tw->hashent];
tcp_minisocks.c:66:	write_lock(&ehead->lock);
tcp_minisocks.c:67:	if (!tw->pprev) {
tcp_minisocks.c:68:		write_unlock(&ehead->lock);
tcp_minisocks.c:71:	if(tw->next)
tcp_minisocks.c:72:		tw->next->pprev = tw->pprev;
tcp_minisocks.c:73:	*(tw->pprev) = tw->next;
tcp_minisocks.c:74:	tw->pprev = NULL;
tcp_minisocks.c:75:	write_unlock(&ehead->lock);
tcp_minisocks.c:78:	bhead = &tcp_bhash[tcp_bhashfn(tw->num)];
tcp_minisocks.c:79:	spin_lock(&bhead->lock);
tcp_minisocks.c:80:	tb = tw->tb;
tcp_minisocks.c:81:	if(tw->bind_next)
tcp_minisocks.c:82:		tw->bind_next->bind_pprev = tw->bind_pprev;
tcp_minisocks.c:83:	*(tw->bind_pprev) = tw->bind_next;
tcp_minisocks.c:84:	tw->tb = NULL;
tcp_minisocks.c:85:	if (tb->owners == NULL) {
tcp_minisocks.c:86:		if (tb->next)
tcp_minisocks.c:87:			tb->next->pprev = tb->pprev;
tcp_minisocks.c:88:		*(tb->pprev) = tb->next;
tcp_minisocks.c:91:	spin_unlock(&bhead->lock);
tcp_minisocks.c:94:	if (atomic_read(&tw->refcnt) != 1) {
tcp_minisocks.c:95:		printk(KERN_DEBUG "tw_bucket %p refcnt=%d\n", tw, atomic_read(&tw->refcnt));
tcp_minisocks.c:102: * * Main purpose of TIME-WAIT state is to close connection gracefully,
tcp_minisocks.c:103: *   when one of ends sits in LAST-ACK or CLOSING retransmitting FIN
tcp_minisocks.c:105: * * What is TIME-WAIT timeout? It is associated with maximal packet
tcp_minisocks.c:111: * * When TIME-WAIT socket receives RST, it means that another end
tcp_minisocks.c:112: *   finally closed and we are allowed to kill TIME-WAIT too.
tcp_minisocks.c:113: * * Second purpose of TIME-WAIT is catching old duplicate segments.
tcp_minisocks.c:114: *   Well, certainly it is pure paranoia, but if we load TIME-WAIT
tcp_minisocks.c:115: *   with this semantics, we MUST NOT kill TIME-WAIT state with RSTs.
tcp_minisocks.c:117: *   (f.e. based on PAWS), we could truncate TIME-WAIT to several RTOs.
tcp_minisocks.c:123: * NOTE. With recycling (and later with fin-wait-2) TW bucket
tcp_minisocks.c:127: * to avoid misread sequence numbers, states etc.  --ANK
tcp_minisocks.c:137:	if (th->doff > (sizeof(struct tcphdr)>>2) && tw->ts_recent_stamp) {
tcp_minisocks.c:141:			tp.ts_recent = tw->ts_recent;
tcp_minisocks.c:142:			tp.ts_recent_stamp = tw->ts_recent_stamp;
tcp_minisocks.c:143:			paws_reject = tcp_paws_check(&tp, th->rst);
tcp_minisocks.c:147:	if (tw->substate == TCP_FIN_WAIT2) {
tcp_minisocks.c:152:		    !tcp_in_window(TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq,
tcp_minisocks.c:153:				   tw->rcv_nxt, tw->rcv_nxt + tw->rcv_wnd))
tcp_minisocks.c:156:		if (th->rst)
tcp_minisocks.c:159:		if (th->syn && !before(TCP_SKB_CB(skb)->seq, tw->rcv_nxt))
tcp_minisocks.c:163:		if (!after(TCP_SKB_CB(skb)->end_seq, tw->rcv_nxt) ||
tcp_minisocks.c:164:		    TCP_SKB_CB(skb)->end_seq == TCP_SKB_CB(skb)->seq) {
tcp_minisocks.c:169:		/* New data or FIN. If new data arrive after half-duplex close,
tcp_minisocks.c:172:		if (!th->fin || TCP_SKB_CB(skb)->end_seq != tw->rcv_nxt+1) {
tcp_minisocks.c:180:		/* FIN arrived, enter true time-wait state. */
tcp_minisocks.c:181:		tw->substate = TCP_TIME_WAIT;
tcp_minisocks.c:182:		tw->rcv_nxt = TCP_SKB_CB(skb)->end_seq;
tcp_minisocks.c:184:			tw->ts_recent_stamp = xtime.tv_sec;
tcp_minisocks.c:185:			tw->ts_recent = tp.rcv_tsval;
tcp_minisocks.c:192:		 * a big problem in practice. --ANK */
tcp_minisocks.c:193:		if (tw->family == AF_INET &&
tcp_minisocks.c:194:		    sysctl_tcp_tw_recycle && tw->ts_recent_stamp &&
tcp_minisocks.c:196:			tcp_tw_schedule(tw, tw->timeout);
tcp_minisocks.c:203:	 *	Now real TIME-WAIT state.
tcp_minisocks.c:206:	 *	"When a connection is [...] on TIME-WAIT state [...]
tcp_minisocks.c:215:	 *	(2)  returns to TIME-WAIT state if the SYN turns out 
tcp_minisocks.c:220:	    (TCP_SKB_CB(skb)->seq == tw->rcv_nxt &&
tcp_minisocks.c:221:	     (TCP_SKB_CB(skb)->seq == TCP_SKB_CB(skb)->end_seq || th->rst))) {
tcp_minisocks.c:224:		if (th->rst) {
tcp_minisocks.c:240:			tw->ts_recent = tp.rcv_tsval;
tcp_minisocks.c:241:			tw->ts_recent_stamp = xtime.tv_sec;
tcp_minisocks.c:259:	   RED-PEN: we violate main RFC requirement, if this SYN will appear
tcp_minisocks.c:260:	   old duplicate (i.e. we receive RST in reply to SYN-ACK),
tcp_minisocks.c:261:	   we must return socket to time-wait state. It is not good,
tcp_minisocks.c:265:	if (th->syn && !th->rst && !th->ack && !paws_reject &&
tcp_minisocks.c:266:	    (after(TCP_SKB_CB(skb)->seq, tw->rcv_nxt) ||
tcp_minisocks.c:267:	     (tp.saw_tstamp && (s32)(tw->ts_recent - tp.rcv_tsval) < 0))) {
tcp_minisocks.c:268:		u32 isn = tw->snd_nxt+65535+2;
tcp_minisocks.c:271:		TCP_SKB_CB(skb)->when = isn;
tcp_minisocks.c:278:	if(!th->rst) {
tcp_minisocks.c:285:		if (paws_reject || th->ack)
tcp_minisocks.c:304:	struct tcp_ehash_bucket *ehead = &tcp_ehash[sk->hashent];
tcp_minisocks.c:309:	   Note, that any socket with sk->num!=0 MUST be bound in binding
tcp_minisocks.c:312:	bhead = &tcp_bhash[tcp_bhashfn(sk->num)];
tcp_minisocks.c:313:	spin_lock(&bhead->lock);
tcp_minisocks.c:314:	tw->tb = (struct tcp_bind_bucket *)sk->prev;
tcp_minisocks.c:315:	BUG_TRAP(sk->prev!=NULL);
tcp_minisocks.c:316:	if ((tw->bind_next = tw->tb->owners) != NULL)
tcp_minisocks.c:317:		tw->tb->owners->bind_pprev = &tw->bind_next;
tcp_minisocks.c:318:	tw->tb->owners = (struct sock*)tw;
tcp_minisocks.c:319:	tw->bind_pprev = &tw->tb->owners;
tcp_minisocks.c:320:	spin_unlock(&bhead->lock);
tcp_minisocks.c:322:	write_lock(&ehead->lock);
tcp_minisocks.c:325:	if (sk->pprev) {
tcp_minisocks.c:326:		if(sk->next)
tcp_minisocks.c:327:			sk->next->pprev = sk->pprev;
tcp_minisocks.c:328:		*sk->pprev = sk->next;
tcp_minisocks.c:329:		sk->pprev = NULL;
tcp_minisocks.c:330:		sock_prot_dec_use(sk->prot);
tcp_minisocks.c:334:	head = &(ehead + tcp_ehash_size)->chain;
tcp_minisocks.c:336:	if((sktw->next = *head) != NULL)
tcp_minisocks.c:337:		(*head)->pprev = &sktw->next;
tcp_minisocks.c:339:	sktw->pprev = head;
tcp_minisocks.c:340:	atomic_inc(&tw->refcnt);
tcp_minisocks.c:342:	write_unlock(&ehead->lock);
tcp_minisocks.c:346: * Move a socket to time-wait or dead fin-wait-2 state.
tcp_minisocks.c:351:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_minisocks.c:354:	if (sysctl_tcp_tw_recycle && tp->ts_recent_stamp)
tcp_minisocks.c:355:		recycle_ok = tp->af_specific->remember_stamp(sk);
tcp_minisocks.c:361:		int rto = (tp->rto<<2) - (tp->rto>>1);
tcp_minisocks.c:364:		tw->daddr	= sk->daddr;
tcp_minisocks.c:365:		tw->rcv_saddr	= sk->rcv_saddr;
tcp_minisocks.c:366:		tw->bound_dev_if= sk->bound_dev_if;
tcp_minisocks.c:367:		tw->num		= sk->num;
tcp_minisocks.c:368:		tw->state	= TCP_TIME_WAIT;
tcp_minisocks.c:369:		tw->substate	= state;
tcp_minisocks.c:370:		tw->sport	= sk->sport;
tcp_minisocks.c:371:		tw->dport	= sk->dport;
tcp_minisocks.c:372:		tw->family	= sk->family;
tcp_minisocks.c:373:		tw->reuse	= sk->reuse;
tcp_minisocks.c:374:		tw->rcv_wscale	= tp->rcv_wscale;
tcp_minisocks.c:375:		atomic_set(&tw->refcnt, 1);
tcp_minisocks.c:377:		tw->hashent	= sk->hashent;
tcp_minisocks.c:378:		tw->rcv_nxt	= tp->rcv_nxt;
tcp_minisocks.c:379:		tw->snd_nxt	= tp->snd_nxt;
tcp_minisocks.c:380:		tw->rcv_wnd	= tcp_receive_window(tp);
tcp_minisocks.c:381:		tw->ts_recent	= tp->ts_recent;
tcp_minisocks.c:382:		tw->ts_recent_stamp= tp->ts_recent_stamp;
tcp_minisocks.c:383:		tw->pprev_death = NULL;
tcp_minisocks.c:386:		if(tw->family == PF_INET6) {
tcp_minisocks.c:387:			memcpy(&tw->v6_daddr,
tcp_minisocks.c:388:			       &sk->net_pinfo.af_inet6.daddr,
tcp_minisocks.c:390:			memcpy(&tw->v6_rcv_saddr,
tcp_minisocks.c:391:			       &sk->net_pinfo.af_inet6.rcv_saddr,
tcp_minisocks.c:403:			tw->timeout = rto;
tcp_minisocks.c:405:			tw->timeout = TCP_TIMEWAIT_LEN;
tcp_minisocks.c:415:		 * non-graceful socket closings.
tcp_minisocks.c:451:		tcp_tw_death_row[tcp_tw_death_row_slot] = tw->next_death;
tcp_minisocks.c:452:		if (tw->next_death)
tcp_minisocks.c:453:			tw->next_death->pprev_death = tw->pprev_death;
tcp_minisocks.c:454:		tw->pprev_death = NULL;
tcp_minisocks.c:465:		((tcp_tw_death_row_slot + 1) & (TCP_TWKILL_SLOTS - 1));
tcp_minisocks.c:467:	if ((tcp_tw_count -= killed) != 0)
tcp_minisocks.c:480:/* This is for handling early-kills of TIME_WAIT sockets. */
tcp_minisocks.c:484:	if (tw->pprev_death) {
tcp_minisocks.c:485:		if(tw->next_death)
tcp_minisocks.c:486:			tw->next_death->pprev_death = tw->pprev_death;
tcp_minisocks.c:487:		*tw->pprev_death = tw->next_death;
tcp_minisocks.c:488:		tw->pprev_death = NULL;
tcp_minisocks.c:490:		if (--tcp_tw_count == 0)
tcp_minisocks.c:496:/* Short-time timewait calendar */
tcp_minisocks.c:498:static int tcp_twcal_hand = -1;
tcp_minisocks.c:513:	 * RATIONALE: if FIN arrived and we entered TIME-WAIT state,
tcp_minisocks.c:517:	 * time to detect the loss is about RTO*(2^N - 1) with exponential
tcp_minisocks.c:533:	slot = (timeo + (1<<TCP_TW_RECYCLE_TICK) - 1) >> TCP_TW_RECYCLE_TICK;
tcp_minisocks.c:538:	if (tw->pprev_death) {
tcp_minisocks.c:539:		if(tw->next_death)
tcp_minisocks.c:540:			tw->next_death->pprev_death = tw->pprev_death;
tcp_minisocks.c:541:		*tw->pprev_death = tw->next_death;
tcp_minisocks.c:542:		tw->pprev_death = NULL;
tcp_minisocks.c:543:		tcp_tw_count--;
tcp_minisocks.c:545:		atomic_inc(&tw->refcnt);
tcp_minisocks.c:550:			slot = TCP_TWKILL_SLOTS-1;
tcp_minisocks.c:552:			slot = (timeo + TCP_TWKILL_PERIOD-1) / TCP_TWKILL_PERIOD;
tcp_minisocks.c:554:				slot = TCP_TWKILL_SLOTS-1;
tcp_minisocks.c:556:		tw->ttd = jiffies + timeo;
tcp_minisocks.c:557:		slot = (tcp_tw_death_row_slot + slot) & (TCP_TWKILL_SLOTS - 1);
tcp_minisocks.c:560:		tw->ttd = jiffies + (slot<<TCP_TW_RECYCLE_TICK);
tcp_minisocks.c:568:			if ((long)(tcp_twcal_timer.expires - jiffies) > (slot<<TCP_TW_RECYCLE_TICK))
tcp_minisocks.c:570:			slot = (tcp_twcal_hand + slot)&(TCP_TW_RECYCLE_SLOTS-1);
tcp_minisocks.c:575:	if((tw->next_death = *tpp) != NULL)
tcp_minisocks.c:576:		(*tpp)->pprev_death = &tw->next_death;
tcp_minisocks.c:578:	tw->pprev_death = tpp;
tcp_minisocks.c:601:		if ((long)(j - now) <= 0) {
tcp_minisocks.c:605:				tcp_twcal_row[slot] = tw->next_death;
tcp_minisocks.c:606:				tw->pprev_death = NULL;
tcp_minisocks.c:625:		slot = (slot+1)&(TCP_TW_RECYCLE_SLOTS-1);
tcp_minisocks.c:627:	tcp_twcal_hand = -1;
tcp_minisocks.c:630:	if ((tcp_tw_count -= killed) == 0)
tcp_minisocks.c:640: * a lot of code duplication between IPv4/IPv6 SYN recv processing. -DaveM
tcp_minisocks.c:656:		newsk->state = TCP_SYN_RECV;
tcp_minisocks.c:659:		newsk->pprev = NULL;
tcp_minisocks.c:660:		newsk->prev = NULL;
tcp_minisocks.c:663:		newsk->dport = req->rmt_port;
tcp_minisocks.c:668:		newsk->dst_lock	= RW_LOCK_UNLOCKED;
tcp_minisocks.c:669:		atomic_set(&newsk->rmem_alloc, 0);
tcp_minisocks.c:670:		skb_queue_head_init(&newsk->receive_queue);
tcp_minisocks.c:671:		atomic_set(&newsk->wmem_alloc, 0);
tcp_minisocks.c:672:		skb_queue_head_init(&newsk->write_queue);
tcp_minisocks.c:673:		atomic_set(&newsk->omem_alloc, 0);
tcp_minisocks.c:674:		newsk->wmem_queued = 0;
tcp_minisocks.c:675:		newsk->forward_alloc = 0;
tcp_minisocks.c:677:		newsk->done = 0;
tcp_minisocks.c:678:		newsk->userlocks = sk->userlocks & ~SOCK_BINDPORT_LOCK;
tcp_minisocks.c:679:		newsk->proc = 0;
tcp_minisocks.c:680:		newsk->backlog.head = newsk->backlog.tail = NULL;
tcp_minisocks.c:681:		newsk->callback_lock = RW_LOCK_UNLOCKED;
tcp_minisocks.c:682:		skb_queue_head_init(&newsk->error_queue);
tcp_minisocks.c:683:		newsk->write_space = tcp_write_space;
tcp_minisocks.c:687:		if ((filter = newsk->filter) != NULL)
tcp_minisocks.c:692:		newtp = &(newsk->tp_pinfo.af_tcp);
tcp_minisocks.c:693:		newtp->pred_flags = 0;
tcp_minisocks.c:694:		newtp->rcv_nxt = req->rcv_isn + 1;
tcp_minisocks.c:695:		newtp->snd_nxt = req->snt_isn + 1;
tcp_minisocks.c:696:		newtp->snd_una = req->snt_isn + 1;
tcp_minisocks.c:697:		newtp->snd_sml = req->snt_isn + 1;
tcp_minisocks.c:701:		tcp_init_wl(newtp, req->snt_isn, req->rcv_isn);
tcp_minisocks.c:703:		newtp->retransmits = 0;
tcp_minisocks.c:704:		newtp->backoff = 0;
tcp_minisocks.c:705:		newtp->srtt = 0;
tcp_minisocks.c:706:		newtp->mdev = TCP_TIMEOUT_INIT;
tcp_minisocks.c:707:		newtp->rto = TCP_TIMEOUT_INIT;
tcp_minisocks.c:709:		newtp->packets_out = 0;
tcp_minisocks.c:710:		newtp->left_out = 0;
tcp_minisocks.c:711:		newtp->retrans_out = 0;
tcp_minisocks.c:712:		newtp->sacked_out = 0;
tcp_minisocks.c:713:		newtp->fackets_out = 0;
tcp_minisocks.c:714:		newtp->snd_ssthresh = 0x7fffffff;
tcp_minisocks.c:717:		 * initial SYN frame in their delayed-ACK and congestion control
tcp_minisocks.c:719:		 * efficiently to them.  -DaveM
tcp_minisocks.c:721:		newtp->snd_cwnd = 2;
tcp_minisocks.c:722:		newtp->snd_cwnd_cnt = 0;
tcp_minisocks.c:724:		newtp->frto_counter = 0;
tcp_minisocks.c:725:		newtp->frto_highmark = 0;
tcp_minisocks.c:727:		newtp->ca_state = TCP_CA_Open;
tcp_minisocks.c:729:		skb_queue_head_init(&newtp->out_of_order_queue);
tcp_minisocks.c:730:		newtp->send_head = NULL;
tcp_minisocks.c:731:		newtp->rcv_wup = req->rcv_isn + 1;
tcp_minisocks.c:732:		newtp->write_seq = req->snt_isn + 1;
tcp_minisocks.c:733:		newtp->pushed_seq = newtp->write_seq;
tcp_minisocks.c:734:		newtp->copied_seq = req->rcv_isn + 1;
tcp_minisocks.c:736:		newtp->saw_tstamp = 0;
tcp_minisocks.c:738:		newtp->dsack = 0;
tcp_minisocks.c:739:		newtp->eff_sacks = 0;
tcp_minisocks.c:741:		newtp->probes_out = 0;
tcp_minisocks.c:742:		newtp->num_sacks = 0;
tcp_minisocks.c:743:		newtp->urg_data = 0;
tcp_minisocks.c:744:		newtp->listen_opt = NULL;
tcp_minisocks.c:745:		newtp->accept_queue = newtp->accept_queue_tail = NULL;
tcp_minisocks.c:747:		memset(&newtp->syn_wait_lock, 0, sizeof(newtp->syn_wait_lock));
tcp_minisocks.c:750:		newsk->err = 0;
tcp_minisocks.c:751:		newsk->priority = 0;
tcp_minisocks.c:752:		atomic_set(&newsk->refcnt, 2);
tcp_minisocks.c:758:		if (newsk->keepopen)
tcp_minisocks.c:760:		newsk->socket = NULL;
tcp_minisocks.c:761:		newsk->sleep = NULL;
tcp_minisocks.c:763:		newtp->tstamp_ok = req->tstamp_ok;
tcp_minisocks.c:764:		if((newtp->sack_ok = req->sack_ok) != 0) {
tcp_minisocks.c:766:				newtp->sack_ok |= 2;
tcp_minisocks.c:768:		newtp->window_clamp = req->window_clamp;
tcp_minisocks.c:769:		newtp->rcv_ssthresh = req->rcv_wnd;
tcp_minisocks.c:770:		newtp->rcv_wnd = req->rcv_wnd;
tcp_minisocks.c:771:		newtp->wscale_ok = req->wscale_ok;
tcp_minisocks.c:772:		if (newtp->wscale_ok) {
tcp_minisocks.c:773:			newtp->snd_wscale = req->snd_wscale;
tcp_minisocks.c:774:			newtp->rcv_wscale = req->rcv_wscale;
tcp_minisocks.c:776:			newtp->snd_wscale = newtp->rcv_wscale = 0;
tcp_minisocks.c:777:			newtp->window_clamp = min(newtp->window_clamp, 65535U);
tcp_minisocks.c:779:		newtp->snd_wnd = ntohs(skb->h.th->window) << newtp->snd_wscale;
tcp_minisocks.c:780:		newtp->max_window = newtp->snd_wnd;
tcp_minisocks.c:782:		if (newtp->tstamp_ok) {
tcp_minisocks.c:783:			newtp->ts_recent = req->ts_recent;
tcp_minisocks.c:784:			newtp->ts_recent_stamp = xtime.tv_sec;
tcp_minisocks.c:785:			newtp->tcp_header_len = sizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED;
tcp_minisocks.c:787:			newtp->ts_recent_stamp = 0;
tcp_minisocks.c:788:			newtp->tcp_header_len = sizeof(struct tcphdr);
tcp_minisocks.c:790:		if (skb->len >= TCP_MIN_RCVMSS+newtp->tcp_header_len)
tcp_minisocks.c:791:			newtp->ack.last_seg_size = skb->len-newtp->tcp_header_len;
tcp_minisocks.c:792:		newtp->mss_clamp = req->mss;
tcp_minisocks.c:809:	struct tcphdr *th = skb->h.th;
tcp_minisocks.c:810:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_minisocks.c:817:	if (th->doff > (sizeof(struct tcphdr)>>2)) {
tcp_minisocks.c:821:			ttp.ts_recent = req->ts_recent;
tcp_minisocks.c:826:			ttp.ts_recent_stamp = xtime.tv_sec - ((TCP_TIMEOUT_INIT/HZ)<<req->retrans);
tcp_minisocks.c:827:			paws_reject = tcp_paws_check(&ttp, th->rst);
tcp_minisocks.c:832:	if (TCP_SKB_CB(skb)->seq == req->rcv_isn &&
tcp_minisocks.c:844:		 *  describe SYN-RECV state. All the description
tcp_minisocks.c:849:		 * Enforce "SYN-ACK" according to figure 8, figure 6
tcp_minisocks.c:852:		req->class->rtx_syn_ack(sk, req, NULL);
tcp_minisocks.c:857:	   for state SYN-RECEIVED of RFC793.
tcp_minisocks.c:876:	   send sequence number of seven :-)
tcp_minisocks.c:885:	   If tp->defer_accept, we silently drop this bare ACK.  Otherwise,
tcp_minisocks.c:887:	   accept the new incoming connection and try to talk to each other. 8-)
tcp_minisocks.c:902:	/* RFC793 page 36: "If the connection is in any non-synchronized state ...
tcp_minisocks.c:910:	    (TCP_SKB_CB(skb)->ack_seq != req->snt_isn+1))
tcp_minisocks.c:920:	if (paws_reject || !tcp_in_window(TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq,
tcp_minisocks.c:921:					  req->rcv_isn+1, req->rcv_isn+1+req->rcv_wnd)) {
tcp_minisocks.c:924:			req->class->send_ack(skb, req);
tcp_minisocks.c:932:	if (ttp.saw_tstamp && !after(TCP_SKB_CB(skb)->seq, req->rcv_isn+1))
tcp_minisocks.c:933:		req->ts_recent = ttp.rcv_tsval;
tcp_minisocks.c:935:	if (TCP_SKB_CB(skb)->seq == req->rcv_isn) {
tcp_minisocks.c:937:		   at req->rcv_isn+1. */
tcp_minisocks.c:954:	if (tp->defer_accept && TCP_SKB_CB(skb)->end_seq == req->rcv_isn+1) {
tcp_minisocks.c:955:		req->acked = 1;
tcp_minisocks.c:965:	child = tp->af_specific->syn_recv_sock(sk, skb, req, NULL);
tcp_minisocks.c:977:		req->acked = 1;
tcp_minisocks.c:984:		req->class->send_reset(skb);
tcp_minisocks.c:1000:	int state = child->state;
tcp_minisocks.c:1002:	if (child->lock.users == 0) {
tcp_minisocks.c:1003:		ret = tcp_rcv_state_process(child, skb, skb->h.th, skb->len);
tcp_minisocks.c:1006:		if (state == TCP_SYN_RECV && child->state != state)
tcp_minisocks.c:1007:			parent->data_ready(parent, 0);
tcp_output.c:13: *		Corey Minyard <wf-rch!minyard@relay.EU.net>
tcp_output.c:14: *		Florian La Roche, <flla@stud.uni-sb.de>
tcp_output.c:34: *		Cacophonix Gaul :	draft-minshall-nagle-01
tcp_output.c:52:	tp->send_head = skb->next;
tcp_output.c:53:	if (tp->send_head == (struct sk_buff *) &sk->write_queue)
tcp_output.c:54:		tp->send_head = NULL;
tcp_output.c:55:	tp->snd_nxt = TCP_SKB_CB(skb)->end_seq;
tcp_output.c:56:	if (tp->packets_out++ == 0)
tcp_output.c:57:		tcp_reset_xmit_timer(sk, TCP_TIME_RETRANS, tp->rto);
tcp_output.c:62: * Using SND.UNA we will fail to open window, SND.NXT is out of window. :-(
tcp_output.c:68:	if (!before(tp->snd_una+tp->snd_wnd, tp->snd_nxt))
tcp_output.c:69:		return tp->snd_nxt;
tcp_output.c:71:		return tp->snd_una+tp->snd_wnd;
tcp_output.c:75: * RFC1122, RFC1063, draft-ietf-tcpimpl-pmtud-01 state that:
tcp_output.c:78: * 2. Ideally, it is maximal possible segment size i.e. 65535-40.
tcp_output.c:90:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_output.c:92:	int mss = tp->advmss;
tcp_output.c:94:	if (dst && dst->advmss < mss) {
tcp_output.c:95:		mss = dst->advmss;
tcp_output.c:96:		tp->advmss = mss;
tcp_output.c:106:	s32 delta = tcp_time_stamp - tp->lsndtime;
tcp_output.c:108:	u32 cwnd = tp->snd_cwnd;
tcp_output.c:110:	tp->snd_ssthresh = tcp_current_ssthresh(tp);
tcp_output.c:113:	while ((delta -= tp->rto) > 0 && cwnd > restart_cwnd)
tcp_output.c:115:	tp->snd_cwnd = max(cwnd, restart_cwnd);
tcp_output.c:116:	tp->snd_cwnd_stamp = tcp_time_stamp;
tcp_output.c:117:	tp->snd_cwnd_used = 0;
tcp_output.c:124:	if (!tp->packets_out && (s32)(now - tp->lsndtime) > tp->rto)
tcp_output.c:127:	tp->lsndtime = now;
tcp_output.c:132:	if ((u32)(now - tp->ack.lrcvtime) < tp->ack.ato)
tcp_output.c:133:		tp->ack.pingpong = 1;
tcp_output.c:138:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_output.c:146: * value can be stuffed directly into th->window for an outgoing
tcp_output.c:151:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_output.c:160:		 * window in time.  --DaveM
tcp_output.c:166:	tp->rcv_wnd = new_win;
tcp_output.c:167:	tp->rcv_wup = tp->rcv_nxt;
tcp_output.c:170:	new_win >>= tp->rcv_wscale;
tcp_output.c:174:		tp->pred_flags = 0;
tcp_output.c:194:		struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_output.c:196:		int tcp_header_size = tp->tcp_header_len;
tcp_output.c:206:		if (tcb->flags & TCPCB_FLAG_SYN) {
tcp_output.c:221:		} else if (tp->eff_sacks) {
tcp_output.c:223:			 * 2 32-bit sequence numbers for each SACK block.
tcp_output.c:226:					    (tp->eff_sacks * TCPOLEN_SACK_PERBLOCK));
tcp_output.c:229:		skb->h.th = th;
tcp_output.c:233:		th->source		= sk->sport;
tcp_output.c:234:		th->dest		= sk->dport;
tcp_output.c:235:		th->seq			= htonl(tcb->seq);
tcp_output.c:236:		th->ack_seq		= htonl(tp->rcv_nxt);
tcp_output.c:237:		*(((__u16 *)th) + 6)	= htons(((tcp_header_size >> 2) << 12) | tcb->flags);
tcp_output.c:238:		if (tcb->flags & TCPCB_FLAG_SYN) {
tcp_output.c:242:			th->window	= htons(tp->rcv_wnd);
tcp_output.c:244:			th->window	= htons(tcp_select_window(sk));
tcp_output.c:246:		th->check		= 0;
tcp_output.c:247:		th->urg_ptr		= 0;
tcp_output.c:249:		if (tp->urg_mode &&
tcp_output.c:250:		    between(tp->snd_up, tcb->seq+1, tcb->seq+0xFFFF)) {
tcp_output.c:251:			th->urg_ptr		= htons(tp->snd_up-tcb->seq);
tcp_output.c:252:			th->urg			= 1;
tcp_output.c:255:		if (tcb->flags & TCPCB_FLAG_SYN) {
tcp_output.c:261:					      tp->rcv_wscale,
tcp_output.c:262:					      tcb->when,
tcp_output.c:263:		      			      tp->ts_recent);
tcp_output.c:266:						     tp, tcb->when);
tcp_output.c:270:		tp->af_specific->send_check(sk, th, skb->len, skb);
tcp_output.c:272:		if (tcb->flags & TCPCB_FLAG_ACK)
tcp_output.c:275:		if (skb->len != tcp_header_size)
tcp_output.c:280:		LOG_CWND(sk, tcb->seq);
tcp_output.c:281:		err = tp->af_specific->queue_xmit(skb, 0);
tcp_output.c:295:	return -ENOBUFS;
tcp_output.c:310:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_output.c:313:	tp->write_seq = TCP_SKB_CB(skb)->end_seq;
tcp_output.c:314:	__skb_queue_tail(&sk->write_queue, skb);
tcp_output.c:317:	if (!force_queue && tp->send_head == NULL && tcp_snd_test(tp, skb, cur_mss, tp->nonagle)) {
tcp_output.c:319:		TCP_SKB_CB(skb)->when = tcp_time_stamp;
tcp_output.c:320:		if (tcp_transmit_skb(sk, skb_clone(skb, sk->allocation)) == 0) {
tcp_output.c:321:			tp->snd_nxt = TCP_SKB_CB(skb)->end_seq;
tcp_output.c:323:			if (tp->packets_out++ == 0)
tcp_output.c:324:				tcp_reset_xmit_timer(sk, TCP_TIME_RETRANS, tp->rto);
tcp_output.c:329:	if (tp->send_head == NULL)
tcp_output.c:330:		tp->send_head = skb;
tcp_output.c:338:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_output.c:339:	struct sk_buff *skb = tp->send_head;
tcp_output.c:343:		TCP_SKB_CB(skb)->when = tcp_time_stamp;
tcp_output.c:344:		if (tcp_transmit_skb(sk, skb_clone(skb, sk->allocation)) == 0) {
tcp_output.c:345:			tp->send_head = NULL;
tcp_output.c:346:			tp->snd_nxt = TCP_SKB_CB(skb)->end_seq;
tcp_output.c:347:			if (tp->packets_out++ == 0)
tcp_output.c:348:				tcp_reset_xmit_timer(sk, TCP_TIME_RETRANS, tp->rto);
tcp_output.c:359:	int pos = skb->len - skb->data_len;
tcp_output.c:363:		memcpy(skb_put(skb1, pos-len), skb->data + len, pos-len);
tcp_output.c:366:		for (i = 0; i < skb_shinfo(skb)->nr_frags; i++)
tcp_output.c:367:			skb_shinfo(skb1)->frags[i] = skb_shinfo(skb)->frags[i];
tcp_output.c:369:		skb_shinfo(skb1)->nr_frags = skb_shinfo(skb)->nr_frags;
tcp_output.c:370:		skb_shinfo(skb)->nr_frags = 0;
tcp_output.c:372:		skb1->data_len = skb->data_len;
tcp_output.c:373:		skb1->len += skb1->data_len;
tcp_output.c:374:		skb->data_len = 0;
tcp_output.c:375:		skb->len = len;
tcp_output.c:376:		skb->tail = skb->data+len;
tcp_output.c:379:		int nfrags = skb_shinfo(skb)->nr_frags;
tcp_output.c:383:		skb_shinfo(skb)->nr_frags = 0;
tcp_output.c:384:		skb1->len = skb1->data_len = skb->len - len;
tcp_output.c:385:		skb->len = len;
tcp_output.c:386:		skb->data_len = len - pos;
tcp_output.c:389:			int size = skb_shinfo(skb)->frags[i].size;
tcp_output.c:391:				skb_shinfo(skb1)->frags[k] = skb_shinfo(skb)->frags[i];
tcp_output.c:402:					get_page(skb_shinfo(skb)->frags[i].page);
tcp_output.c:403:					skb_shinfo(skb1)->frags[0].page_offset += (len-pos);
tcp_output.c:404:					skb_shinfo(skb1)->frags[0].size -= (len-pos);
tcp_output.c:405:					skb_shinfo(skb)->frags[i].size = len-pos;
tcp_output.c:406:					skb_shinfo(skb)->nr_frags++;
tcp_output.c:410:				skb_shinfo(skb)->nr_frags++;
tcp_output.c:414:		skb_shinfo(skb1)->nr_frags = k;
tcp_output.c:425:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tcp_output.c:427:	int nsize = skb->len - len;
tcp_output.c:433:		return -ENOMEM;
tcp_output.c:438:		return -ENOMEM; /* We'll just try again later. */
tcp_output.c:442:	TCP_SKB_CB(buff)->seq = TCP_SKB_CB(skb)->seq + len;
tcp_output.c:443:	TCP_SKB_CB(buff)->end_seq = TCP_SKB_CB(skb)->end_seq;
tcp_output.c:444:	TCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(buff)->seq;
tcp_output.c:447:	flags = TCP_SKB_CB(skb)->flags;
tcp_output.c:448:	TCP_SKB_CB(skb)->flags = flags & ~(TCPCB_FLAG_FIN|TCPCB_FLAG_PSH);
tcp_output.c:449:	TCP_SKB_CB(buff)->flags = flags;
tcp_output.c:450:	TCP_SKB_CB(buff)->sacked = TCP_SKB_CB(skb)->sacked&(TCPCB_LOST|TCPCB_EVER_RETRANS|TCPCB_AT_TAIL);
tcp_output.c:451:	if (TCP_SKB_CB(buff)->sacked&TCPCB_LOST) {
tcp_output.c:452:		tp->lost_out++;
tcp_output.c:453:		tp->left_out++;
tcp_output.c:455:	TCP_SKB_CB(skb)->sacked &= ~TCPCB_AT_TAIL;
tcp_output.c:457:	if (!skb_shinfo(skb)->nr_frags && skb->ip_summed != CHECKSUM_HW) {
tcp_output.c:459:		buff->csum = csum_partial_copy_nocheck(skb->data + len, skb_put(buff, nsize),
tcp_output.c:464:		skb->csum = csum_block_sub(skb->csum, buff->csum, len);
tcp_output.c:466:		skb->ip_summed = CHECKSUM_HW;
tcp_output.c:470:	buff->ip_summed = skb->ip_summed;
tcp_output.c:473:	 * skbs, which it never sent before. --ANK
tcp_output.c:475:	TCP_SKB_CB(buff)->when = TCP_SKB_CB(skb)->when;
tcp_output.c:485:   tp->user_mss is mss set by user by TCP_MAXSEG. It does NOT counts
tcp_output.c:488:   tp->mss_clamp is mss negotiated at connection setup.
tcp_output.c:492:   tp->pmtu_cookie is last pmtu, seen by this function.
tcp_output.c:494:   tp->mss_cache is current effective sending mss, including
tcp_output.c:497:   tp->mss_clamp.
tcp_output.c:502:   NOTE2. tp->pmtu_cookie and tp->mss_cache are READ ONLY outside
tcp_output.c:503:   this function.			--ANK (980731)
tcp_output.c:508:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tcp_output.c:512:	   It is MMS_S - sizeof(tcphdr) of rfc1122
tcp_output.c:515:	mss_now = pmtu - tp->af_specific->net_header_len - sizeof(struct tcphdr);
tcp_output.c:518:	if (mss_now > tp->mss_clamp)
tcp_output.c:519:		mss_now = tp->mss_clamp;
tcp_output.c:522:	mss_now -= tp->ext_header_len;
tcp_output.c:529:	mss_now -= tp->tcp_header_len - sizeof(struct tcphdr);
tcp_output.c:532:	if (tp->max_window && mss_now > (tp->max_window>>1))
tcp_output.c:533:		mss_now = max((tp->max_window>>1), 68U - tp->tcp_header_len);
tcp_output.c:536:	tp->pmtu_cookie = pmtu;
tcp_output.c:537:	tp->mss_cache = mss_now;
tcp_output.c:551:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_output.c:558:	if(sk->state != TCP_CLOSE) {
tcp_output.c:565:		 * IP options mid-stream.  Silly to do, but cover it.
tcp_output.c:569:		while((skb = tp->send_head) &&
tcp_output.c:571:			if (skb->len > mss_now) {
tcp_output.c:576:			TCP_SKB_CB(skb)->when = tcp_time_stamp;
tcp_output.c:590:		return !tp->packets_out && tp->send_head;
tcp_output.c:604: *  RCV.BUFF - RCV.USER - RCV.WINDOW >= min(1/2 RCV.BUFF, MSS)"
tcp_output.c:610: * since header prediction assumes th->window stays fixed.
tcp_output.c:612: * Strictly speaking, keeping th->window fixed violates the receiver
tcp_output.c:649:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tcp_output.c:654:	 * fluctuations.  --SAW  1998/11/1
tcp_output.c:656:	int mss = tp->ack.rcv_mss;
tcp_output.c:658:	int full_space = min_t(int, tp->window_clamp, tcp_full_space(sk));
tcp_output.c:665:		tp->ack.quick = 0;
tcp_output.c:668:			tp->rcv_ssthresh = min(tp->rcv_ssthresh, 4U*tp->advmss);
tcp_output.c:674:	if (free_space > tp->rcv_ssthresh)
tcp_output.c:675:		free_space = tp->rcv_ssthresh;
tcp_output.c:685:	window = tp->rcv_wnd;
tcp_output.c:686:	if (window <= free_space - mss || window > free_space)
tcp_output.c:695:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tcp_output.c:696:	struct sk_buff *next_skb = skb->next;
tcp_output.c:702:		int skb_size = skb->len, next_skb_size = next_skb->len;
tcp_output.c:703:		u16 flags = TCP_SKB_CB(skb)->flags;
tcp_output.c:706:		if(TCP_SKB_CB(next_skb)->sacked & TCPCB_SACKED_ACKED)
tcp_output.c:710:		if (after(TCP_SKB_CB(next_skb)->end_seq, tp->snd_una+tp->snd_wnd))
tcp_output.c:722:		__skb_unlink(next_skb, next_skb->list);
tcp_output.c:724:		memcpy(skb_put(skb, next_skb_size), next_skb->data, next_skb_size);
tcp_output.c:726:		if (next_skb->ip_summed == CHECKSUM_HW)
tcp_output.c:727:			skb->ip_summed = CHECKSUM_HW;
tcp_output.c:729:		if (skb->ip_summed != CHECKSUM_HW)
tcp_output.c:730:			skb->csum = csum_block_add(skb->csum, next_skb->csum, skb_size);
tcp_output.c:733:		TCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(next_skb)->end_seq;
tcp_output.c:736:		flags |= TCP_SKB_CB(next_skb)->flags; /* This moves PSH/FIN etc. over */
tcp_output.c:737:		TCP_SKB_CB(skb)->flags = flags;
tcp_output.c:742:		TCP_SKB_CB(skb)->sacked |= TCP_SKB_CB(next_skb)->sacked&(TCPCB_EVER_RETRANS|TCPCB_AT_TAIL);
tcp_output.c:743:		if (TCP_SKB_CB(next_skb)->sacked&TCPCB_SACKED_RETRANS)
tcp_output.c:744:			tp->retrans_out--;
tcp_output.c:745:		if (TCP_SKB_CB(next_skb)->sacked&TCPCB_LOST) {
tcp_output.c:746:			tp->lost_out--;
tcp_output.c:747:			tp->left_out--;
tcp_output.c:750:		if (!tp->sack_ok && tp->sacked_out) {
tcp_output.c:751:			tp->sacked_out--;
tcp_output.c:752:			tp->left_out--;
tcp_output.c:758:		if (tp->fackets_out)
tcp_output.c:759:			tp->fackets_out--;
tcp_output.c:761:		tp->packets_out--;
tcp_output.c:771:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_output.c:777:		if (skb->len > mss && 
tcp_output.c:778:		    !(TCP_SKB_CB(skb)->sacked&TCPCB_SACKED_ACKED)) {
tcp_output.c:779:			if (TCP_SKB_CB(skb)->sacked&TCPCB_SACKED_RETRANS) {
tcp_output.c:780:				TCP_SKB_CB(skb)->sacked &= ~TCPCB_SACKED_RETRANS;
tcp_output.c:781:				tp->retrans_out--;
tcp_output.c:783:			if (!(TCP_SKB_CB(skb)->sacked&TCPCB_LOST)) {
tcp_output.c:784:				TCP_SKB_CB(skb)->sacked |= TCPCB_LOST;
tcp_output.c:785:				tp->lost_out++;
tcp_output.c:801:	if (tp->ca_state != TCP_CA_Loss) {
tcp_output.c:802:		tp->high_seq = tp->snd_nxt;
tcp_output.c:803:		tp->snd_ssthresh = tcp_current_ssthresh(tp);
tcp_output.c:804:		tp->prior_ssthresh = 0;
tcp_output.c:805:		tp->undo_marker = 0;
tcp_output.c:806:		tp->ca_state = TCP_CA_Loss;
tcp_output.c:812: * state updates are done by the caller.  Returns non-zero if an
tcp_output.c:817:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_output.c:824:	if (atomic_read(&sk->wmem_alloc) > min(sk->wmem_queued+(sk->wmem_queued>>2),sk->sndbuf))
tcp_output.c:825:		return -EAGAIN;
tcp_output.c:832:	if (!before(TCP_SKB_CB(skb)->seq, tp->snd_una+tp->snd_wnd)
tcp_output.c:833:	    && TCP_SKB_CB(skb)->seq != tp->snd_una)
tcp_output.c:834:		return -EAGAIN;
tcp_output.c:836:	if(skb->len > cur_mss) {
tcp_output.c:838:			return -ENOMEM; /* We'll try again later. */
tcp_output.c:841:		tp->packets_out++;
tcp_output.c:845:	if(!(TCP_SKB_CB(skb)->flags & TCPCB_FLAG_SYN) &&
tcp_output.c:846:	   (skb->len < (cur_mss >> 1)) &&
tcp_output.c:847:	   (skb->next != tp->send_head) &&
tcp_output.c:848:	   (skb->next != (struct sk_buff *)&sk->write_queue) &&
tcp_output.c:849:	   (skb_shinfo(skb)->nr_frags == 0 && skb_shinfo(skb->next)->nr_frags == 0) &&
tcp_output.c:853:	if(tp->af_specific->rebuild_header(sk))
tcp_output.c:854:		return -EHOSTUNREACH; /* Routing failure or similar. */
tcp_output.c:860:	if(skb->len > 0 &&
tcp_output.c:861:	   (TCP_SKB_CB(skb)->flags & TCPCB_FLAG_FIN) &&
tcp_output.c:862:	   tp->snd_una == (TCP_SKB_CB(skb)->end_seq - 1)) {
tcp_output.c:864:			TCP_SKB_CB(skb)->seq = TCP_SKB_CB(skb)->end_seq - 1;
tcp_output.c:865:			skb->ip_summed = CHECKSUM_NONE;
tcp_output.c:866:			skb->csum = 0;
tcp_output.c:873:	TCP_SKB_CB(skb)->when = tcp_time_stamp;
tcp_output.c:884:		if (TCP_SKB_CB(skb)->sacked&TCPCB_SACKED_RETRANS) {
tcp_output.c:889:		TCP_SKB_CB(skb)->sacked |= TCPCB_RETRANS;
tcp_output.c:890:		tp->retrans_out++;
tcp_output.c:893:		if (!tp->retrans_stamp)
tcp_output.c:894:			tp->retrans_stamp = TCP_SKB_CB(skb)->when;
tcp_output.c:896:		tp->undo_retrans++;
tcp_output.c:901:		TCP_SKB_CB(skb)->ack_seq = tp->snd_nxt;
tcp_output.c:916:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_output.c:918:	int packet_cnt = tp->lost_out;
tcp_output.c:923:			__u8 sacked = TCP_SKB_CB(skb)->sacked;
tcp_output.c:925:			if (tcp_packets_in_flight(tp) >= tp->snd_cwnd)
tcp_output.c:932:					if (tp->ca_state != TCP_CA_Loss)
tcp_output.c:937:					if (skb == skb_peek(&sk->write_queue))
tcp_output.c:938:						tcp_reset_xmit_timer(sk, TCP_TIME_RETRANS, tp->rto);
tcp_output.c:941:				if (--packet_cnt <= 0)
tcp_output.c:950:	if (tp->ca_state != TCP_CA_Recovery)
tcp_output.c:954:	if (!tp->sack_ok)
tcp_output.c:970:		if(++packet_cnt > tp->fackets_out)
tcp_output.c:973:		if (tcp_packets_in_flight(tp) >= tp->snd_cwnd)
tcp_output.c:976:		if(TCP_SKB_CB(skb)->sacked & TCPCB_TAGBITS)
tcp_output.c:983:		if (skb == skb_peek(&sk->write_queue))
tcp_output.c:984:			tcp_reset_xmit_timer(sk, TCP_TIME_RETRANS, tp->rto);
tcp_output.c:996:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);	
tcp_output.c:997:	struct sk_buff *skb = skb_peek_tail(&sk->write_queue);
tcp_output.c:1006:	if(tp->send_head != NULL) {
tcp_output.c:1007:		TCP_SKB_CB(skb)->flags |= TCPCB_FLAG_FIN;
tcp_output.c:1008:		TCP_SKB_CB(skb)->end_seq++;
tcp_output.c:1009:		tp->write_seq++;
tcp_output.c:1021:		skb->csum = 0;
tcp_output.c:1022:		TCP_SKB_CB(skb)->flags = (TCPCB_FLAG_ACK | TCPCB_FLAG_FIN);
tcp_output.c:1023:		TCP_SKB_CB(skb)->sacked = 0;
tcp_output.c:1026:		TCP_SKB_CB(skb)->seq = tp->write_seq;
tcp_output.c:1027:		TCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(skb)->seq + 1;
tcp_output.c:1036: * by draft-ietf-tcpimpl-prob-03.txt section 3.10.  -DaveM
tcp_output.c:1040:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_output.c:1052:	skb->csum = 0;
tcp_output.c:1053:	TCP_SKB_CB(skb)->flags = (TCPCB_FLAG_ACK | TCPCB_FLAG_RST);
tcp_output.c:1054:	TCP_SKB_CB(skb)->sacked = 0;
tcp_output.c:1057:	TCP_SKB_CB(skb)->seq = tcp_acceptable_seq(sk, tp);
tcp_output.c:1058:	TCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(skb)->seq;
tcp_output.c:1059:	TCP_SKB_CB(skb)->when = tcp_time_stamp;
tcp_output.c:1073:	skb = skb_peek(&sk->write_queue);
tcp_output.c:1074:	if (skb == NULL || !(TCP_SKB_CB(skb)->flags&TCPCB_FLAG_SYN)) {
tcp_output.c:1076:		return -EFAULT;
tcp_output.c:1078:	if (!(TCP_SKB_CB(skb)->flags&TCPCB_FLAG_ACK)) {
tcp_output.c:1082:				return -ENOMEM;
tcp_output.c:1083:			__skb_unlink(skb, &sk->write_queue);
tcp_output.c:1084:			__skb_queue_head(&sk->write_queue, nskb);
tcp_output.c:1090:		TCP_SKB_CB(skb)->flags |= TCPCB_FLAG_ACK;
tcp_output.c:1091:		TCP_ECN_send_synack(&sk->tp_pinfo.af_tcp, skb);
tcp_output.c:1093:	TCP_SKB_CB(skb)->when = tcp_time_stamp;
tcp_output.c:1098: * Prepare a SYN-ACK.
tcp_output.c:1103:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_output.c:1115:	skb->dst = dst_clone(dst);
tcp_output.c:1118:			   (req->tstamp_ok ? TCPOLEN_TSTAMP_ALIGNED : 0) +
tcp_output.c:1119:			   (req->wscale_ok ? TCPOLEN_WSCALE_ALIGNED : 0) +
tcp_output.c:1121:			   ((req->sack_ok && !req->tstamp_ok) ? TCPOLEN_SACKPERM_ALIGNED : 0));
tcp_output.c:1122:	skb->h.th = th = (struct tcphdr *) skb_push(skb, tcp_header_size);
tcp_output.c:1125:	th->syn = 1;
tcp_output.c:1126:	th->ack = 1;
tcp_output.c:1128:	th->source = sk->sport;
tcp_output.c:1129:	th->dest = req->rmt_port;
tcp_output.c:1130:	TCP_SKB_CB(skb)->seq = req->snt_isn;
tcp_output.c:1131:	TCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(skb)->seq + 1;
tcp_output.c:1132:	th->seq = htonl(TCP_SKB_CB(skb)->seq);
tcp_output.c:1133:	th->ack_seq = htonl(req->rcv_isn + 1);
tcp_output.c:1134:	if (req->rcv_wnd == 0) { /* ignored for retransmitted syns */
tcp_output.c:1137:		req->window_clamp = tp->window_clamp ? : dst->window;
tcp_output.c:1140:			dst->advmss - (req->tstamp_ok ? TCPOLEN_TSTAMP_ALIGNED : 0),
tcp_output.c:1141:			&req->rcv_wnd,
tcp_output.c:1142:			&req->window_clamp,
tcp_output.c:1143:			req->wscale_ok,
tcp_output.c:1145:		req->rcv_wscale = rcv_wscale; 
tcp_output.c:1149:	th->window = htons(req->rcv_wnd);
tcp_output.c:1151:	TCP_SKB_CB(skb)->when = tcp_time_stamp;
tcp_output.c:1152:	tcp_syn_build_options((__u32 *)(th + 1), dst->advmss, req->tstamp_ok,
tcp_output.c:1153:			      req->sack_ok, req->wscale_ok, req->rcv_wscale,
tcp_output.c:1154:			      TCP_SKB_CB(skb)->when,
tcp_output.c:1155:			      req->ts_recent);
tcp_output.c:1157:	skb->csum = 0;
tcp_output.c:1158:	th->doff = (tcp_header_size >> 2);
tcp_output.c:1169:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_output.c:1174:	tp->tcp_header_len = sizeof(struct tcphdr) +
tcp_output.c:1178:	if (tp->user_mss)
tcp_output.c:1179:		tp->mss_clamp = tp->user_mss;
tcp_output.c:1180:	tp->max_window = 0;
tcp_output.c:1181:	tcp_sync_mss(sk, dst->pmtu);
tcp_output.c:1183:	if (!tp->window_clamp)
tcp_output.c:1184:		tp->window_clamp = dst->window;
tcp_output.c:1185:	tp->advmss = dst->advmss;
tcp_output.c:1189:				  tp->advmss - (tp->ts_recent_stamp ? tp->tcp_header_len - sizeof(struct tcphdr) : 0),
tcp_output.c:1190:				  &tp->rcv_wnd,
tcp_output.c:1191:				  &tp->window_clamp,
tcp_output.c:1193:				  &tp->rcv_wscale);
tcp_output.c:1195:	tp->rcv_ssthresh = tp->rcv_wnd;
tcp_output.c:1197:	sk->err = 0;
tcp_output.c:1198:	sk->done = 0;
tcp_output.c:1199:	tp->snd_wnd = 0;
tcp_output.c:1200:	tcp_init_wl(tp, tp->write_seq, 0);
tcp_output.c:1201:	tp->snd_una = tp->write_seq;
tcp_output.c:1202:	tp->snd_sml = tp->write_seq;
tcp_output.c:1203:	tp->rcv_nxt = 0;
tcp_output.c:1204:	tp->rcv_wup = 0;
tcp_output.c:1205:	tp->copied_seq = 0;
tcp_output.c:1207:	tp->rto = TCP_TIMEOUT_INIT;
tcp_output.c:1208:	tp->retransmits = 0;
tcp_output.c:1217:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_output.c:1223:#if 1 // 10/03 -- add piggybacked data on SYN 
tcp_output.c:1224:	if((tp->trickles_opt & TCP_TRICKLES_ENABLE) &&
tcp_output.c:1225:	   (tp->trickles_opt & TCP_TRICKLES_SYNDATA)) {
tcp_output.c:1228:		buff = alloc_skb(ETHERNET_MTU, sk->allocation);
tcp_output.c:1230:		buff = alloc_skb(MAX_TCP_HEADER + 15, sk->allocation);
tcp_output.c:1234:		return -ENOBUFS;
tcp_output.c:1239:	TCP_SKB_CB(buff)->flags = TCPCB_FLAG_SYN;
tcp_output.c:1241:	TCP_SKB_CB(buff)->sacked = 0;
tcp_output.c:1242:	buff->csum = 0;
tcp_output.c:1243:	TCP_SKB_CB(buff)->seq = tp->write_seq++;
tcp_output.c:1244:	TCP_SKB_CB(buff)->end_seq = tp->write_seq;
tcp_output.c:1245:	tp->snd_nxt = tp->write_seq;
tcp_output.c:1246:	tp->pushed_seq = tp->write_seq;
tcp_output.c:1255:	TCP_SKB_CB(buff)->when = tcp_time_stamp;
tcp_output.c:1256:	tp->retrans_stamp = TCP_SKB_CB(buff)->when;
tcp_output.c:1257:	__skb_queue_tail(&sk->write_queue, buff);
tcp_output.c:1259:	tp->packets_out++;
tcp_output.c:1264:	tcp_reset_xmit_timer(sk, TCP_TIME_RETRANS, tp->rto);
tcp_output.c:1274:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tcp_output.c:1275:	int ato = tp->ack.ato;
tcp_output.c:1281:		if (tp->ack.pingpong || (tp->ack.pending&TCP_ACK_PUSHED))
tcp_output.c:1287:		 * Do not use tp->rto here, use results of rtt measurements
tcp_output.c:1290:		if (tp->srtt) {
tcp_output.c:1291:			int rtt = max(tp->srtt>>3, TCP_DELACK_MIN);
tcp_output.c:1304:	if (tp->ack.pending&TCP_ACK_TIMER) {
tcp_output.c:1308:		if (tp->ack.blocked || time_before_eq(tp->ack.timeout, jiffies+(ato>>2))) {
tcp_output.c:1313:		if (!time_before(timeout, tp->ack.timeout))
tcp_output.c:1314:			timeout = tp->ack.timeout;
tcp_output.c:1316:	tp->ack.pending |= TCP_ACK_SCHED|TCP_ACK_TIMER;
tcp_output.c:1317:	tp->ack.timeout = timeout;
tcp_output.c:1318:	if (!mod_timer(&tp->delack_timer, timeout))
tcp_output.c:1326:	if(sk->state != TCP_CLOSE) {
tcp_output.c:1327:		struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_output.c:1337:			tp->ack.ato = TCP_ATO_MIN;
tcp_output.c:1344:		buff->csum = 0;
tcp_output.c:1345:		TCP_SKB_CB(buff)->flags = TCPCB_FLAG_ACK;
tcp_output.c:1346:		TCP_SKB_CB(buff)->sacked = 0;
tcp_output.c:1349:		TCP_SKB_CB(buff)->seq = TCP_SKB_CB(buff)->end_seq = tcp_acceptable_seq(sk, tp);
tcp_output.c:1350:		TCP_SKB_CB(buff)->when = tcp_time_stamp;
tcp_output.c:1362: * Current solution: to send TWO zero-length segments in urgent mode:
tcp_output.c:1364: * out-of-date with SND.UNA-1 to probe window.
tcp_output.c:1368:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_output.c:1374:		return -1;
tcp_output.c:1378:	skb->csum = 0;
tcp_output.c:1379:	TCP_SKB_CB(skb)->flags = TCPCB_FLAG_ACK;
tcp_output.c:1380:	TCP_SKB_CB(skb)->sacked = urgent;
tcp_output.c:1386:	TCP_SKB_CB(skb)->seq = urgent ? tp->snd_una : tp->snd_una - 1;
tcp_output.c:1387:	TCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(skb)->seq;
tcp_output.c:1388:	TCP_SKB_CB(skb)->when = tcp_time_stamp;
tcp_output.c:1394:	if (sk->state != TCP_CLOSE) {
tcp_output.c:1395:		struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_output.c:1398:		if ((skb = tp->send_head) != NULL &&
tcp_output.c:1399:		    before(TCP_SKB_CB(skb)->seq, tp->snd_una+tp->snd_wnd)) {
tcp_output.c:1402:			int seg_size = tp->snd_una+tp->snd_wnd-TCP_SKB_CB(skb)->seq;
tcp_output.c:1404:			if (before(tp->pushed_seq, TCP_SKB_CB(skb)->end_seq))
tcp_output.c:1405:				tp->pushed_seq = TCP_SKB_CB(skb)->end_seq;
tcp_output.c:1411:			if (seg_size < TCP_SKB_CB(skb)->end_seq - TCP_SKB_CB(skb)->seq ||
tcp_output.c:1412:			    skb->len > mss) {
tcp_output.c:1414:				TCP_SKB_CB(skb)->flags |= TCPCB_FLAG_PSH;
tcp_output.c:1416:					return -1;
tcp_output.c:1418:			TCP_SKB_CB(skb)->flags |= TCPCB_FLAG_PSH;
tcp_output.c:1419:			TCP_SKB_CB(skb)->when = tcp_time_stamp;
tcp_output.c:1426:			if (tp->urg_mode &&
tcp_output.c:1427:			    between(tp->snd_up, tp->snd_una+1, tp->snd_una+0xFFFF))
tcp_output.c:1432:	return -1;
tcp_output.c:1440:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_output.c:1445:	if (tp->packets_out || !tp->send_head) {
tcp_output.c:1447:		tp->probes_out = 0;
tcp_output.c:1448:		tp->backoff = 0;
tcp_output.c:1453:		if (tp->backoff < sysctl_tcp_retries2)
tcp_output.c:1454:			tp->backoff++;
tcp_output.c:1455:		tp->probes_out++;
tcp_output.c:1457:				      min(tp->rto << tp->backoff, TCP_RTO_MAX));
tcp_output.c:1465:		if (!tp->probes_out)
tcp_output.c:1466:			tp->probes_out=1;
tcp_output.c:1468:				      min(tp->rto << tp->backoff, TCP_RESOURCE_PROBE_INTERVAL));
tcp_timer.c:13: *		Corey Minyard <wf-rch!minyard@relay.EU.net>
tcp_timer.c:14: *		Florian La Roche, <flla@stud.uni-sb.de>
tcp_timer.c:48:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tcp_timer.c:50:	init_timer(&tp->retransmit_timer);
tcp_timer.c:51:	tp->retransmit_timer.function=&tcp_write_timer;
tcp_timer.c:52:	tp->retransmit_timer.data = (unsigned long) sk;
tcp_timer.c:53:	tp->pending = 0;
tcp_timer.c:55:	init_timer(&tp->delack_timer);
tcp_timer.c:56:	tp->delack_timer.function=&tcp_delack_timer;
tcp_timer.c:57:	tp->delack_timer.data = (unsigned long) sk;
tcp_timer.c:58:	tp->ack.pending = 0;
tcp_timer.c:60:	init_timer(&sk->timer);
tcp_timer.c:61:	sk->timer.function=&tcp_keepalive_timer;
tcp_timer.c:62:	sk->timer.data = (unsigned long) sk;
tcp_timer.c:67:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tcp_timer.c:69:	tp->pending = 0;
tcp_timer.c:70:	if (timer_pending(&tp->retransmit_timer) &&
tcp_timer.c:71:	    del_timer(&tp->retransmit_timer))
tcp_timer.c:74:	tp->ack.pending = 0;
tcp_timer.c:75:	tp->ack.blocked = 0;
tcp_timer.c:76:	if (timer_pending(&tp->delack_timer) &&
tcp_timer.c:77:	    del_timer(&tp->delack_timer))
tcp_timer.c:80:	if(timer_pending(&sk->timer) && del_timer(&sk->timer))
tcp_timer.c:86:	sk->err = sk->err_soft ? : ETIMEDOUT;
tcp_timer.c:87:	sk->error_report(sk);
tcp_timer.c:106:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_timer.c:111:	if ((s32)(tcp_time_stamp - tp->lsndtime) > 2*TCP_RTO_MAX || !do_reset)
tcp_timer.c:115:	if (sk->err_soft)
tcp_timer.c:119:	    (sk->wmem_queued > SOCK_MIN_SNDBUF &&
tcp_timer.c:126:		if ((s32)(tcp_time_stamp - tp->lsndtime) <= TCP_TIMEWAIT_LEN ||
tcp_timer.c:128:		    (!tp->snd_wnd && !tp->packets_out))
tcp_timer.c:145:	if (sk->err_soft && !alive)
tcp_timer.c:159:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_timer.c:162:	if ((1<<sk->state)&(TCPF_SYN_SENT|TCPF_SYN_RECV)) {
tcp_timer.c:163:		if (tp->retransmits)
tcp_timer.c:164:			dst_negative_advice(&sk->dst_cache);
tcp_timer.c:165:		retry_until = tp->syn_retries ? : sysctl_tcp_syn_retries;
tcp_timer.c:167:		if (tp->retransmits >= sysctl_tcp_retries1) {
tcp_timer.c:168:			/* NOTE. draft-ietf-tcpimpl-pmtud-01.txt requires pmtu black
tcp_timer.c:169:			   hole detection. :-(
tcp_timer.c:177:   are often caused by over-zealous security administrators who block
tcp_timer.c:180:   upper-layer protocols.  The safest web site in the world is worthless
tcp_timer.c:185:                           Golden words :-).
tcp_timer.c:188:			dst_negative_advice(&sk->dst_cache);
tcp_timer.c:192:		if (sk->dead) {
tcp_timer.c:193:			int alive = (tp->rto < TCP_RTO_MAX);
tcp_timer.c:197:			if (tcp_out_of_resources(sk, alive || tp->retransmits < retry_until))
tcp_timer.c:202:	if (tp->retransmits >= retry_until) {
tcp_timer.c:213:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_timer.c:216:	if (sk->lock.users) {
tcp_timer.c:218:		tp->ack.blocked = 1;
tcp_timer.c:220:		if (!mod_timer(&tp->delack_timer, jiffies + TCP_DELACK_MIN))
tcp_timer.c:227:	if (sk->state == TCP_CLOSE || !(tp->ack.pending&TCP_ACK_TIMER))
tcp_timer.c:230:	if ((long)(tp->ack.timeout - jiffies) > 0) {
tcp_timer.c:231:		if (!mod_timer(&tp->delack_timer, tp->ack.timeout))
tcp_timer.c:235:	tp->ack.pending &= ~TCP_ACK_TIMER;
tcp_timer.c:237:	if (skb_queue_len(&tp->ucopy.prequeue)) {
tcp_timer.c:240:		net_statistics[smp_processor_id()*2].TCPSchedulerFailed += skb_queue_len(&tp->ucopy.prequeue);
tcp_timer.c:242:		while ((skb = __skb_dequeue(&tp->ucopy.prequeue)) != NULL)
tcp_timer.c:243:			sk->backlog_rcv(sk, skb);
tcp_timer.c:245:		tp->ucopy.memory = 0;
tcp_timer.c:249:		if (!tp->ack.pingpong) {
tcp_timer.c:251:			tp->ack.ato = min(tp->ack.ato << 1, tp->rto);
tcp_timer.c:256:			tp->ack.pingpong = 0;
tcp_timer.c:257:			tp->ack.ato = TCP_ATO_MIN;
tcp_timer.c:274:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tcp_timer.c:277:	if (tp->packets_out || !tp->send_head) {
tcp_timer.c:278:		tp->probes_out = 0;
tcp_timer.c:284:	 * It doesn't AFAIK, because we kill the retransmit timer -AK
tcp_timer.c:295:	 * and probe timeout in one bottle.				--ANK
tcp_timer.c:299:	if (sk->dead) {
tcp_timer.c:300:		int alive = ((tp->rto<<tp->backoff) < TCP_RTO_MAX);
tcp_timer.c:304:		if (tcp_out_of_resources(sk, alive || tp->probes_out <= max_probes))
tcp_timer.c:308:	if (tp->probes_out > max_probes) {
tcp_timer.c:322:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tcp_timer.c:324:	if (tp->packets_out == 0)
tcp_timer.c:327:	BUG_TRAP(!skb_queue_empty(&sk->write_queue));
tcp_timer.c:330:	if (tp->snd_wnd == 0 && !sk->dead &&
tcp_timer.c:331:	    !((1<<sk->state)&(TCPF_SYN_SENT|TCPF_SYN_RECV))) {
tcp_timer.c:340:			       NIPQUAD(sk->daddr), htons(sk->dport), sk->num,
tcp_timer.c:341:			       tp->snd_una, tp->snd_nxt);
tcp_timer.c:343:		if (tcp_time_stamp - tp->rcv_tstamp > TCP_RTO_MAX) {
tcp_timer.c:348:		tcp_retransmit_skb(sk, skb_peek(&sk->write_queue));
tcp_timer.c:356:	if (tp->retransmits == 0) {
tcp_timer.c:357:		if (tp->ca_state == TCP_CA_Disorder || tp->ca_state == TCP_CA_Recovery) {
tcp_timer.c:358:			if (tp->sack_ok) {
tcp_timer.c:359:				if (tp->ca_state == TCP_CA_Recovery)
tcp_timer.c:364:				if (tp->ca_state == TCP_CA_Recovery)
tcp_timer.c:369:		} else if (tp->ca_state == TCP_CA_Loss) {
tcp_timer.c:382:	if (tcp_retransmit_skb(sk, skb_peek(&sk->write_queue)) > 0) {
tcp_timer.c:386:		if (!tp->retransmits)
tcp_timer.c:387:			tp->retransmits=1;
tcp_timer.c:389:				     min(tp->rto, TCP_RESOURCE_PROBE_INTERVAL));
tcp_timer.c:408:	tp->backoff++;
tcp_timer.c:409:	tp->retransmits++;
tcp_timer.c:412:	tp->rto = min(tp->rto << 1, TCP_RTO_MAX);
tcp_timer.c:413:	tcp_reset_xmit_timer(sk, TCP_TIME_RETRANS, tp->rto);
tcp_timer.c:414:	if (tp->retransmits > sysctl_tcp_retries1)
tcp_timer.c:423:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tcp_timer.c:427:	if (sk->lock.users) {
tcp_timer.c:429:		if (!mod_timer(&tp->retransmit_timer, jiffies + (HZ/20)))
tcp_timer.c:434:	if (sk->state == TCP_CLOSE || !tp->pending)
tcp_timer.c:437:	if ((long)(tp->timeout - jiffies) > 0) {
tcp_timer.c:438:		if (!mod_timer(&tp->retransmit_timer, tp->timeout))
tcp_timer.c:443:	event = tp->pending;
tcp_timer.c:444:	tp->pending = 0;
tcp_timer.c:469:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
tcp_timer.c:470:	struct tcp_listen_opt *lopt = tp->listen_opt;
tcp_timer.c:471:	int max_retries = tp->syn_retries ? : sysctl_tcp_synack_retries;
tcp_timer.c:477:	if (lopt == NULL || lopt->qlen == 0)
tcp_timer.c:497:	if (lopt->qlen>>(lopt->max_qlen_log-1)) {
tcp_timer.c:498:		int young = (lopt->qlen_young<<1);
tcp_timer.c:501:			if (lopt->qlen < young)
tcp_timer.c:503:			thresh--;
tcp_timer.c:508:	if (tp->defer_accept)
tcp_timer.c:509:		max_retries = tp->defer_accept;
tcp_timer.c:512:	i = lopt->clock_hand;
tcp_timer.c:515:		reqp=&lopt->syn_table[i];
tcp_timer.c:517:			if ((long)(now - req->expires) >= 0) {
tcp_timer.c:518:				if ((req->retrans < thresh ||
tcp_timer.c:519:				     (req->acked && req->retrans < max_retries))
tcp_timer.c:520:				    && !req->class->rtx_syn_ack(sk, req, NULL)) {
tcp_timer.c:523:					if (req->retrans++ == 0)
tcp_timer.c:524:						lopt->qlen_young--;
tcp_timer.c:525:					timeo = min((TCP_TIMEOUT_INIT << req->retrans),
tcp_timer.c:527:					req->expires = now + timeo;
tcp_timer.c:528:					reqp = &req->dl_next;
tcp_timer.c:533:				write_lock(&tp->syn_wait_lock);
tcp_timer.c:534:				*reqp = req->dl_next;
tcp_timer.c:535:				write_unlock(&tp->syn_wait_lock);
tcp_timer.c:536:				lopt->qlen--;
tcp_timer.c:537:				if (req->retrans == 0)
tcp_timer.c:538:					lopt->qlen_young--;
tcp_timer.c:542:			reqp = &req->dl_next;
tcp_timer.c:545:		i = (i+1)&(TCP_SYNQ_HSIZE-1);
tcp_timer.c:547:	} while (--budget > 0);
tcp_timer.c:549:	lopt->clock_hand = i;
tcp_timer.c:551:	if (lopt->qlen)
tcp_timer.c:557:	if (timer_pending(&sk->timer) && del_timer (&sk->timer))
tcp_timer.c:563:	if (!mod_timer(&sk->timer, jiffies+len))
tcp_timer.c:569:	if ((1<<sk->state)&(TCPF_CLOSE|TCPF_LISTEN))
tcp_timer.c:572:	if (val && !sk->keepopen)
tcp_timer.c:573:		tcp_reset_keepalive_timer(sk, keepalive_time_when(&sk->tp_pinfo.af_tcp));
tcp_timer.c:582:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tcp_timer.c:587:	if (sk->lock.users) {
tcp_timer.c:593:	if (sk->state == TCP_LISTEN) {
tcp_timer.c:598:	if (sk->state == TCP_FIN_WAIT2 && sk->dead) {
tcp_timer.c:599:		if (tp->linger2 >= 0) {
tcp_timer.c:600:			int tmo = tcp_fin_time(tp) - TCP_TIMEWAIT_LEN;
tcp_timer.c:611:	if (!sk->keepopen || sk->state == TCP_CLOSE)
tcp_timer.c:617:	if (tp->packets_out || tp->send_head)
tcp_timer.c:620:	elapsed = tcp_time_stamp - tp->rcv_tstamp;
tcp_timer.c:623:		if ((!tp->keepalive_probes && tp->probes_out >= sysctl_tcp_keepalive_probes) ||
tcp_timer.c:624:		     (tp->keepalive_probes && tp->probes_out >= tp->keepalive_probes)) {
tcp_timer.c:630:			tp->probes_out++;
tcp_timer.c:639:		/* It is tp->rcv_tstamp + keepalive_time_when(tp) */
tcp_timer.c:640:		elapsed = keepalive_time_when(tp) - elapsed;
tmalloc.c:2:/* malloc.c - C standard library routine.
tmalloc.c:30:    struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tmalloc.c:31:    if(tp->t.heapbytesallocated + size > tp->t.heapbytesize) {
tmalloc.c:38:    result = (char*)tp->cminisock_api_config.cfg.ctl->heap_base;
tmalloc.c:40:    result = (char*)tp->t.heap_absolute_base;
tmalloc.c:42:    result = (char*)result + tp->t.heapbytesallocated;
tmalloc.c:43:    tp->t.heapbytesallocated += size;
tmalloc.c:59:    adj = (unsigned int) ((char *) result - (char *) NULL) % BLOCKSIZE;
tmalloc.c:61:	(*_morecore)(sk,adj = BLOCKSIZE - adj);
tmalloc.c:71:    struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tmalloc.c:72:    tp->t.heapsize = tp->t.heapbytesize / BLOCKSIZE;
tmalloc.c:73:    tp->t.heapinfo = align(sk, tp->t.heapsize * sizeof (union heap_info));
tmalloc.c:74:    if (!tp->t.heapinfo)
tmalloc.c:76:    memset(tp->t.heapinfo, 0, tp->t.heapsize * sizeof (union heap_info));
tmalloc.c:77:    tp->t.heapinfo[0].free.size = 0;
tmalloc.c:78:    tp->t.heapinfo[0].free.next = tp->t.heapinfo[0].free.prev = 0;
tmalloc.c:79:    tp->t.heapindex = 0;
tmalloc.c:80:    tp->t.heapbase = (char *) tp->t.heapinfo;
tmalloc.c:81:    tp->t.malloc_initialized = 1;
tmalloc.c:90:    struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tmalloc.c:100:    if (BLOCK(sk,(char *) result + size) > tp->t.heapsize) {
tmalloc.c:101:	newsize = tp->t.heapsize;
tmalloc.c:106:	    (*_morecore)(sk,-size);
tmalloc.c:110:	memcpy(newinfo, tp->t.heapinfo, tp->t.heapsize * sizeof (union heap_info));
tmalloc.c:111:	oldinfo = tp->t.heapinfo;
tmalloc.c:114:	    = BLOCKIFY(tp->t.heapsize * sizeof (union heap_info));
tmalloc.c:115:	tp->t.heapinfo = newinfo;
tmalloc.c:117:	tp->t.heapsize = newsize;
tmalloc.c:119:    tp->t.heaplimit = BLOCK(sk,(char *) result + size);
tmalloc.c:128:    struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tmalloc.c:137:    if (!tp->t.malloc_initialized && !initialize_malloc(sk))
tmalloc.c:150:	--size;
tmalloc.c:156:	if ((next = tp->t.fraghead[log].next) != 0) {
tmalloc.c:161:	    next->prev->next = next->next;
tmalloc.c:162:	    if (next->next)
tmalloc.c:163:		next->next->prev = next->prev;
tmalloc.c:165:	    if (--tp->t.heapinfo[block].busy.info.frag.nfree)
tmalloc.c:166:		tp->t.heapinfo[block].busy.info.frag.first
tmalloc.c:167:		    = (unsigned int) ((char *) next->next - (char *) NULL)
tmalloc.c:175:	    ++tp->t.fragblocks[log];
tmalloc.c:180:		next->next = tp->t.fraghead[log].next;
tmalloc.c:181:		next->prev = &tp->t.fraghead[log];
tmalloc.c:182:		next->prev->next = next;
tmalloc.c:183:		if (next->next)
tmalloc.c:184:		    next->next->prev = next;
tmalloc.c:189:	    tp->t.heapinfo[block].busy.type = log;
tmalloc.c:190:	    tp->t.heapinfo[block].busy.info.frag.nfree = i - 1;
tmalloc.c:191:	    tp->t.heapinfo[block].busy.info.frag.first = i - 1;
tmalloc.c:199:	start = block = tp->t.heapindex;
tmalloc.c:200:	while (tp->t.heapinfo[block].free.size < blocks) {
tmalloc.c:201:	    block = tp->t.heapinfo[block].free.next;
tmalloc.c:206:		block = tp->t.heapinfo[0].free.prev;
tmalloc.c:207:		lastblocks = tp->t.heapinfo[block].free.size;
tmalloc.c:208:		if (tp->t.heaplimit && block + lastblocks == tp->t.heaplimit
tmalloc.c:210:		    && morecore(sk,(blocks - lastblocks) * BLOCKSIZE)) {
tmalloc.c:214:		    block = tp->t.heapinfo[0].free.prev;
tmalloc.c:215:		    tp->t.heapinfo[block].free.size += blocks - lastblocks;
tmalloc.c:222:		tp->t.heapinfo[block].busy.type = 0;
tmalloc.c:223:		tp->t.heapinfo[block].busy.info.size = blocks;
tmalloc.c:235:	if (tp->t.heapinfo[block].free.size > blocks) {
tmalloc.c:238:	    tp->t.heapinfo[block + blocks].free.size
tmalloc.c:239:		= tp->t.heapinfo[block].free.size - blocks;
tmalloc.c:240:	    tp->t.heapinfo[block + blocks].free.next
tmalloc.c:241:		= tp->t.heapinfo[block].free.next;
tmalloc.c:242:	    tp->t.heapinfo[block + blocks].free.prev
tmalloc.c:243:		= tp->t.heapinfo[block].free.prev;
tmalloc.c:244:	    tp->t.heapinfo[tp->t.heapinfo[block].free.prev].free.next
tmalloc.c:245:		= tp->t.heapinfo[tp->t.heapinfo[block].free.next].free.prev
tmalloc.c:246:		    = tp->t.heapindex = block + blocks;
tmalloc.c:250:	    tp->t.heapinfo[tp->t.heapinfo[block].free.next].free.prev
tmalloc.c:251:		= tp->t.heapinfo[block].free.prev;
tmalloc.c:252:	    tp->t.heapinfo[tp->t.heapinfo[block].free.prev].free.next
tmalloc.c:253:		= tp->t.heapindex = tp->t.heapinfo[block].free.next;
tmalloc.c:256:	tp->t.heapinfo[block].busy.type = 0;
tmalloc.c:257:	tp->t.heapinfo[block].busy.info.size = blocks;
tmalloc.c:271:    struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
tmalloc.c:285:    switch (type = tp->t.heapinfo[block].busy.type) {
tmalloc.c:290:	i = tp->t.heapindex;
tmalloc.c:293:		i = tp->t.heapinfo[i].free.prev;
tmalloc.c:296:		i = tp->t.heapinfo[i].free.next;
tmalloc.c:298:	    i = tp->t.heapinfo[i].free.prev;
tmalloc.c:302:	if (block == i + tp->t.heapinfo[i].free.size) {
tmalloc.c:304:	    tp->t.heapinfo[i].free.size += tp->t.heapinfo[block].busy.info.size;
tmalloc.c:308:	    tp->t.heapinfo[block].free.size = tp->t.heapinfo[block].busy.info.size;
tmalloc.c:309:	    tp->t.heapinfo[block].free.next = tp->t.heapinfo[i].free.next;
tmalloc.c:310:	    tp->t.heapinfo[block].free.prev = i;
tmalloc.c:311:	    tp->t.heapinfo[i].free.next = block;
tmalloc.c:312:	    tp->t.heapinfo[tp->t.heapinfo[block].free.next].free.prev = block;
tmalloc.c:318:	if (block + tp->t.heapinfo[block].free.size == tp->t.heapinfo[block].free.next) {
tmalloc.c:319:	    tp->t.heapinfo[block].free.size
tmalloc.c:320:		+= tp->t.heapinfo[tp->t.heapinfo[block].free.next].free.size;
tmalloc.c:321:	    tp->t.heapinfo[block].free.next
tmalloc.c:322:		= tp->t.heapinfo[tp->t.heapinfo[block].free.next].free.next;
tmalloc.c:323:	    tp->t.heapinfo[tp->t.heapinfo[block].free.next].free.prev = block;
tmalloc.c:327:	blocks = tp->t.heapinfo[block].free.size;
tmalloc.c:328:	if (blocks >= FINAL_FREE_BLOCKS && block + blocks == tp->t.heaplimit
tmalloc.c:330:	    tp->t.heaplimit -= blocks;
tmalloc.c:331:	    (*_morecore)(sk,-blocks * BLOCKSIZE);
tmalloc.c:332:	    tp->t.heapinfo[tp->t.heapinfo[block].free.prev].free.next
tmalloc.c:333:		= tp->t.heapinfo[block].free.next;
tmalloc.c:334:	    tp->t.heapinfo[tp->t.heapinfo[block].free.next].free.prev
tmalloc.c:335:		= tp->t.heapinfo[block].free.prev;
tmalloc.c:336:	    block = tp->t.heapinfo[block].free.prev;
tmalloc.c:340:	tp->t.heapindex = block;
tmalloc.c:346:				+ (tp->t.heapinfo[block].busy.info.frag.first
tmalloc.c:349:	if (tp->t.heapinfo[block].busy.info.frag.nfree == (BLOCKSIZE >> type) - 1
tmalloc.c:350:	&& tp->t.fragblocks[type] > 1) {
tmalloc.c:353:	    --tp->t.fragblocks[type];
tmalloc.c:355:		next = next->next;
tmalloc.c:356:	    prev->prev->next = next;
tmalloc.c:358:		next->prev = prev->prev;
tmalloc.c:359:	    tp->t.heapinfo[block].busy.type = 0;
tmalloc.c:360:	    tp->t.heapinfo[block].busy.info.size = 1;
tmalloc.c:362:	} else if (tp->t.heapinfo[block].busy.info.frag.nfree) {
tmalloc.c:367:	    next->next = prev->next;
tmalloc.c:368:	    next->prev = prev;
tmalloc.c:369:	    prev->next = next;
tmalloc.c:370:	    if (next->next)
tmalloc.c:371:		next->next->prev = next;
tmalloc.c:372:	    ++tp->t.heapinfo[block].busy.info.frag.nfree;
tmalloc.c:378:	    tp->t.heapinfo[block].busy.info.frag.nfree = 1;
tmalloc.c:379:	    tp->t.heapinfo[block].busy.info.frag.first
tmalloc.c:380:		= (unsigned int) ((char *) ptr - (char *) NULL) % BLOCKSIZE
tmalloc.c:382:	    prev->next = tp->t.fraghead[type].next;
tmalloc.c:383:	    prev->prev = &tp->t.fraghead[type];
tmalloc.c:384:	    prev->prev->next = prev;
tmalloc.c:385:	    if (prev->next)
tmalloc.c:386:		prev->next->prev = prev;
trickles.c:37:#include "trickles-int.h"
trickles.c:38:#include "memdump-util.h"
trickles.c:39:#include "math-util.h"
trickles.c:50:	printk("inserted [%d-%d] into missing data map at %d\n", (START), (END), __LINE__)
trickles.c:55:	RECORD_MISSINGDATAMAP_INSERTION_HELPER((REQ)->start, (REQ)->end)
trickles.c:63:			printk(" - ");
trickles.c:110:	({ struct tcp_opt *_tp = &(SK)->tp_pinfo.af_tcp;	\
trickles.c:111:		hist_addPoint(&a_histogram, _tp->t.A);		\
trickles.c:112:		hist_addPoint(&d_histogram, _tp->t.D);		\
trickles.c:116:	({ struct tcp_opt *_tp = &(SK)->tp_pinfo.af_tcp;	\
trickles.c:117:		hist_addPoint(&timeout_histogram, _tp->t.RTO);		\
trickles.c:134:	return skb->tail + amt <= skb->end;
trickles.c:164:	atomic_add(skb->end - skb->head,&ofoBufSize);
trickles.c:169:	atomic_sub(skb->end - skb->head,&ofoBufSize);
trickles.c:184:#define MARK_PC(CONT) (CONT)->mark |= (__LINE__) << 18
trickles.c:196:	if(req->type == MREQ_CONVERSION && ) {
trickles.c:207:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:211:	if(msk->list != &tp->t.cont_list) {
trickles.c:214:	alloc_head_walk(&tp->t.cont_list, ptr) {
trickles.c:230:	int pos = tp->t.aphistpos;
trickles.c:231:	if(tp->t.ack_prev != 0) {
trickles.c:232:		tp->t.aphist[pos] = *tp->t.ack_prev;
trickles.c:234:		memset(&tp->t.aphist[pos], 0xff, sizeof(tp->t.aphist[pos]));
trickles.c:236:	tp->t.aphist[pos].mark |= (lineno & 0x3fff) << 2;
trickles.c:238:	tp->t.aphistpos = pos;
trickles.c:266:// Based on code from asm-i386/xor.h
trickles.c:269:	if (!(current->flags & PF_USEDFPU)) {				\
trickles.c:277:	if (!(current->flags & PF_USEDFPU)) {				\
trickles.c:291:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:294:	tp->t.dnext = htp->t.dnext;
trickles.c:295:	htp->t.dnext = sk;
trickles.c:296:	tp->t.dprev = &trickles_sockets_head;
trickles.c:297:	tp->t.dnext->tp_pinfo.af_tcp.t.dprev = sk;
trickles.c:302:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:303:	if(tp->t.dprev == NULL) {
trickles.c:304:		BUG_TRAP(tp->t.dnext != NULL);
trickles.c:309:	BUG_TRAP(tp->t.dprev->tp_pinfo.af_tcp.t.dnext == sk);
trickles.c:310:	BUG_TRAP(tp->t.dnext->tp_pinfo.af_tcp.t.dprev == sk);
trickles.c:311:	tp->t.dprev->tp_pinfo.af_tcp.t.dnext = tp->t.dnext;
trickles.c:312:	tp->t.dnext->tp_pinfo.af_tcp.t.dprev = tp->t.dprev;
trickles.c:314:	tp->t.dprev = tp->t.dnext = NULL;
trickles.c:320:	((TCP_SKB_CB(SKB)->seq <= (SEQ)) && (TCP_SKB_CB(SKB)->end_seq > (SEQ)))
trickles.c:323:	if(TCP_SKB_CB(skb)->cont) {
trickles.c:324:		// 0810 - used to be a straight kfree
trickles.c:325:		freeClientSide_Continuation(TCP_SKB_CB(skb)->cont);
trickles.c:328:	for(i=0; i < TCP_SKB_CB(skb)->numDataChunks-1; i++) {
trickles.c:336:	if(TCP_SKB_CB(skb)->chunksOverflow != NULL) {
trickles.c:337:		kfree(TCP_SKB_CB(skb)->chunksOverflow);
trickles.c:356:	       gUpdateSincePollTotal / gUpdateSincePollCount : -1,
trickles.c:423:   struct tcp_opt *_tp = &_sk->tp_pinfo.af_tcp;				\
trickles.c:424:   printk("%p: %s tcp rcv_nxt = %d byteRcvNxt = %d t.rcv_nxt = %d\n", _sk, (S), _tp->rcv_nxt, _tp->t.byteRcvNxt, _tp->t.rcv_nxt); })
trickles.c:437:  memset(ctx->key, 0, HMAC_BLOCKSIZE);
trickles.c:438:  memcpy(ctx->key, key, len);
trickles.c:444:    pad[i]=0x36^ctx->key[i];
trickles.c:445:  DIGEST_Init(&ctx->in_ctx);
trickles.c:446:  DIGEST_Update(&ctx->in_ctx, pad, HMAC_BLOCKSIZE);
trickles.c:449:    pad[i]=0x5c^ctx->key[i];
trickles.c:450:  DIGEST_Init(&ctx->out_ctx);
trickles.c:451:  DIGEST_Update(&ctx->out_ctx, pad, HMAC_BLOCKSIZE);
trickles.c:455:  ctx->digest_ctx = ctx->in_ctx;
trickles.c:456:  ctx->len = 0;
trickles.c:460:  DIGEST_Update(&ctx->digest_ctx, data, len);
trickles.c:461:  ctx->len += len;
trickles.c:467:  DIGEST_Final(buf, &ctx->digest_ctx);
trickles.c:468:  ctx->digest_ctx = ctx->out_ctx;
trickles.c:469:  DIGEST_Update(&ctx->digest_ctx, buf, HMACLEN);
trickles.c:470:  DIGEST_Final(output, &ctx->digest_ctx);
trickles.c:478:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles.c:481:		HMAC_CTX *ctx = tp->t.hmacCTX;
trickles.c:483:		phdr->serverAddr = 0;
trickles.c:487:		hmac_update(ctx, (char*)cont->hmac_start, WIRECONT_MAC_LEN);
trickles.c:492:		hexdump_helper((char*)cont->hmac_start,
trickles.c:502:		hmac_sha(tp->t.hmacKey, HMACLEN,
trickles.c:503:			 (char*)cont->hmac_start - HMAC_PHEADER_LEN, WIRECONT_MAC_LEN,
trickles.c:516:	__u64 oldNum = -1;
trickles.c:541:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles.c:544:		return generateCryptoRangeNonceHelper(tp->t.nonceCTX, seqNumLeft, seqNumRight);
trickles.c:566:		nonce_out = prevCtx->prevBlock;
trickles.c:567:		if(prevCtx->new) {
trickles.c:568:			prevCtx->prevNumber = number;
trickles.c:569:			prevCtx->new = 0;
trickles.c:570:		} else if(prevCtx->prevNumber == number) {
trickles.c:573:			prevCtx->prevNumber = number;
trickles.c:581:	if(offset == NUM_NONCES_PER_BLOCK-1) {
trickles.c:587:			prevCtx->prevNumber = number;
trickles.c:597:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles.c:601:		return generateCryptoSingleNonceHelper(tp->t.nonceCTX, seqNum, prevCtx);
trickles.c:614:	if(skb->ip_summed == CHECKSUM_HW) {
trickles.c:615:		skb->ip_summed = CHECKSUM_UNNECESSARY;
trickles.c:616:		if(!tcp_v4_check(skb->h.th, skb->len, skb->nh.iph->saddr, skb->nh.iph->daddr,
trickles.c:617:				 skb->csum))
trickles.c:620:		return -1;
trickles.c:622:        if (sk->lock.users) {
trickles.c:636:        return skb->ip_summed != CHECKSUM_UNNECESSARY &&
trickles.c:646:	numRxBytes += in_skb->h.th->doff * 4 + in_skb->len;
trickles.c:648:	numRxBytes += in_skb->len - TCP_SKB_CB(in_skb)->numDataChunks * sizeof(struct DataChunk);
trickles.c:649:	int overhead = TCP_SKB_CB(in_skb)->numDataChunks * sizeof(struct DataChunk) + in_skb->data - in_skb->head;
trickles.c:651:		printk("len = %d overhead = %d (%d)\n", in_skb->len, overhead, TCP_SKB_CB(in_skb)->numDataChunks);
trickles.c:658:	TCP_SKB_CB(skb)->cont = NULL;
trickles.c:659:	TCP_SKB_CB(skb)->numDataChunks = 0;
trickles.c:660:	TCP_SKB_CB(skb)->chunksOverflow = NULL;
trickles.c:661:	TCP_SKB_CB(skb)->seq = -1;
trickles.c:662:	TCP_SKB_CB(skb)->end_seq = -1;
trickles.c:668:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:673:	__skb_pull(in_skb, in_skb->h.th->doff * 4);
trickles.c:675:	in_skb->ip_summed = CHECKSUM_UNNECESSARY;
trickles.c:676:	in_skb->sk = sk;
trickles.c:678:	if(sk->tp_pinfo.af_tcp.trickles_opt & TCP_TRICKLES_RSERVER) {
trickles.c:683:		LOG_PACKET(sk, -in_skb->h.th->ack_seq);
trickles.c:685:		       ((pre_skb = __skb_dequeue(&tp->t.prequeueOverflow))
trickles.c:689:			if(result == 0 || result == -EINVAL) {
trickles.c:692:				BUG_TRAP(result == -ENOMEM);
trickles.c:694:				__skb_queue_head(&tp->t.prequeueOverflow, pre_skb);
trickles.c:695:				__skb_queue_tail(&tp->t.prequeueOverflow, in_skb);
trickles.c:703:			if(tp->t.prequeueOverflow.qlen < 20000) {
trickles.c:704:				__skb_queue_tail(&tp->t.prequeueOverflow, in_skb);
trickles.c:707:				return -1;
trickles.c:713:		       ((in_skb = __skb_dequeue(&tp->ucopy.prequeue))
trickles.c:719:			if(result == 0 || result == -EINVAL) {
trickles.c:722:				BUG_TRAP(result == -ENOMEM);
trickles.c:724:				__skb_queue_tail(&tp->ucopy.prequeue, in_skb);
trickles.c:735:		//LOG_PACKET(sk, -in_skb->h.th->ack_seq);
trickles.c:745:	return -1;
trickles.c:764:During slow start, the old data request mappings are cleared. However, not all request packets were actually lost. So already requested data will be re-requested again during slow start.
trickles.c:789:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:792:	if(tp->t.state == TRICKLES_CLIENT_SYNACK) {
trickles.c:808:	if(!mod_timer(&tp->t.slowstart_timer, expiration)) {
trickles.c:819:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:823:	record_delay(tp->t.RTO);
trickles.c:828:	//printk("slow start timer -2\n");
trickles.c:830:		printk("Slow start timer @ %lu, total = %d, numDataRequestMappings = %d, numContinuations = %d, numConversionRequests = %d, numContinuationRequests = %d, tp->copied_seq/rcv_nxt = %u/%u, tp->t.byteRcvNxt = %d, tp->t.rcv_nxt = %u, sk = %p", jiffies, gNumSlowstart, numDataRequestMappings, numContinuations, numConversionRequests, numContinuationRequests, tp->copied_seq, tp->rcv_nxt, tp->t.byteRcvNxt, tp->t.rcv_nxt, sk);
trickles.c:834:	tp->t.in_flight = 0;
trickles.c:837:	if (sk->state == TCP_CLOSE)
trickles.c:841:	int haveRequests = !empty(&tp->t.sentRequests) || !empty(&tp->t.queuedRequests);
trickles.c:842:	//printk("Slow start timer(%p), snd_una = %d, write_seq = %d\n", sk, tp->t.snd_una, tp->t.write_seq);
trickles.c:850:		       tp->t.timerState & TRICKLES_ENABLE_DATA_TIMEOUT,
trickles.c:851:		       findUCContinuation(sk, tp->t.byteReqNext, tp->t.byteReqNext),
trickles.c:855:		if((tp->t.timerState & TRICKLES_ENABLE_DATA_TIMEOUT)
trickles.c:856:		   || findUCContinuation(sk, tp->t.byteReqNext, tp->t.byteReqNext)
trickles.c:859:#ifdef STRICT_BUFFER_CHECK // 0419 - fixing extraneous slowstarts with blocked client
trickles.c:862:			int haveRcvBuf = tp->rcv_nxt < tp->copied_seq + sk->rcvbuf;
trickles.c:864:			       haveRcvBuf, tp->rcv_nxt < tp->copied_seq + sk->rcvbuf);
trickles.c:866:			   !empty(&tp->t.sentRequests) ||   // requests we can use
trickles.c:867:			   !empty(&tp->t.queuedRequests) || //  "" ""
trickles.c:869:			    findUCContinuation(sk, tp->t.byteRcvNxt, tp->t.byteRcvNxt))) {
trickles.c:874:			//printk("test a = %d %d %d(%d,%d)\n", !IS_SEND_UCONTREQ_STATE(tp), haveRequests, findUCContinuation(sk, tp->rcv_nxt, tp->rcv_nxt), tp->rcv_nxt, tp->rcv_nxt);
trickles.c:877:			   findUCContinuation(sk, tp->t.byteRcvNxt, tp->t.byteRcvNxt)) {
trickles.c:882:					printk("Timing out @ %lu (%d times) sk = %p tp->{rcv_nxt, byteRcvNxt, window} = %u/%u/%u\n", jiffies, gNumSlowstart, sk, tp->rcv_nxt, tp->t.byteRcvNxt, tp->copied_seq- tp->rcv_nxt);
trickles.c:883:					printk("rtt = %u, total = %d, numDataRequestMappings = %d, numContinuations = %d, numConversionRequests = %d, numContinuationRequests = %d, tp->rcv_nxt = %u, tp->t.byteRcvNxt = %d tp->t.rcv_nxt = %u, sk = %p\n", tp->t.A, gNumSlowstart, numDataRequestMappings, numContinuations, numConversionRequests, numContinuationRequests, tp->rcv_nxt, tp->t.byteRcvNxt, tp->t.rcv_nxt, sk);
trickles.c:885:					printk("ContList Length = %d  Cont OFO queue length %d Data OFO queue length %d\n", tp->t.cont_list.len, tp->t.ofo_queue.qlen, tp->t.data_ofo_queue.qlen);
trickles.c:895:				if(tp->t.conversionState == CONVERSION_IDLE) {
trickles.c:899:					tp->t.timerState |= TRICKLES_NEED_SLOWSTART;
trickles.c:901:					tp->t.timerState &= ~TRICKLES_ENABLE_DATA_TIMEOUT;
trickles.c:913:		if(haveRequests || ((tp->t.timerState & TRICKLES_ENABLE_DATA_TIMEOUT) &&
trickles.c:914:				    findUCContinuation(sk, tp->t.byteReqNext, tp->t.byteReqNext))) {
trickles.c:920:			resetClientTimer(sk); // 0504 - back off timer if no progress made
trickles.c:927:	//printk("slow start timer -1\n");
trickles.c:934:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:940:#if 1 // 10/04 -- duplicated earlier in initialization sequence to allow piggybacked data on synack
trickles.c:942:	tp->t.slowstart_timer.function = &slow_start_timer;
trickles.c:943:	tp->t.slowstart_timer.data = (long)sk;
trickles.c:955:	for(i=0; i < proof->numSacks; i++) {
trickles.c:956:		if(Sack_contains(&proof->sacks[i], seq)) {
trickles.c:960:	if(i == proof->numSacks) {
trickles.c:962:		proof->numSacks = 0;
trickles.c:965:	for(j=0; j < proof->numSacks - i; j++) {
trickles.c:966:		proof->sacks[j] = proof->sacks[i + j];
trickles.c:968:	proof->numSacks = proof->numSacks - i;
trickles.c:972://#define CURR_CONT(X) ((CONTINUATION_TYPE *)((X)->tp_pinfo.af_tcp.t.ack_curr ? (X)->tp_pinfo.af_tcp.t.ack_curr : (X)->tp_pinfo.af_tcp.t.ack_prev))
trickles.c:976:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:984:	switch(tp->t.state) {
trickles.c:989:			tp->t.state = TRICKLES_CLIENT_SLOWSTART;
trickles.c:991:			tp->t.clientStateCounter++;
trickles.c:992:			tp->t.request_snd_nxt++;
trickles.c:993:			tp->t.request_rcv_nxt = tp->t.request_snd_nxt;
trickles.c:997:				AckProof_dump(&tp->t.altProof);
trickles.c:999:			tp->t.state = TRICKLES_CLIENT_RECOVERY;
trickles.c:1001:			tp->t.clientStateCounter++;
trickles.c:1006:			tp->t.state = TRICKLES_CLIENT_SLOWSTART;
trickles.c:1010:			tp->t.clientStateCounter++;
trickles.c:1011:			tp->t.request_snd_nxt++;
trickles.c:1012:			tp->t.request_rcv_nxt = tp->t.request_snd_nxt;
trickles.c:1017:				AckProof_dump(&tp->t.altProof);
trickles.c:1030:		tp->t.clientStateCounter++;
trickles.c:1031:		tp->t.request_snd_nxt++;
trickles.c:1032:		tp->t.request_rcv_nxt = tp->t.request_snd_nxt;
trickles.c:1041:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:1046:	if(tp->t.previous_base > cont->TCPBase) {
trickles.c:1047:		printk("previous base > cont->TCPBase. clientstate %d clientstatecounter %d\n", cont->clientState, tp->t.clientStateCounter);
trickles.c:1049:	for(cont_curs = (CONTINUATION_TYPE*)tp->t.cont_list.prev;
trickles.c:1050:	    cont_curs != (CONTINUATION_TYPE*)&tp->t.cont_list;
trickles.c:1051:	    cont_curs=cont_curs->prev) {
trickles.c:1052:		if(cont_curs->seq < cont->seq)
trickles.c:1055:	if(cont_curs->next != (CONTINUATION_TYPE*)&tp->t.cont_list &&
trickles.c:1056:	   cont_curs->next->seq == cont->seq) {
trickles.c:1057:		CONTINUATION_TYPE *dup = cont_curs->next;
trickles.c:1058:		if(NEWER(cont->clientState, dup->clientState)) {
trickles.c:1067:			if(tp->t.ack_prev == dup)
trickles.c:1070:				printk("Got rid of old cont %u\n", dup->seq);
trickles.c:1077:			if(tp->t.ack_prev == cont)
trickles.c:1080:				printk("Got rid of new cont %u\n", cont->seq);
trickles.c:1085:	/* create copy for transport-level acking and processing */
trickles.c:1092:	newCont->mark |= 0x2;
trickles.c:1094:	// don't need user-level data while performing transport-level processing
trickles.c:1095:	newCont->ucont_data = NULL;
trickles.c:1096:	newCont->input = NULL;
trickles.c:1098:	insert((struct alloc_head*)newCont, (struct alloc_head*)cont_curs, (struct alloc_head*)cont_curs->next);
trickles.c:1099:	if(replaceAckPrev || tp->t.ack_prev == cont) {
trickles.c:1100:		tp->t.ack_prev = newCont;
trickles.c:1101:		INTEGRITY_CHECK(sk, tp->t.ack_prev);
trickles.c:1104:	if(!(!tp->t.ack_prev || tp->t.ack_prev->next)) {
trickles.c:1106:		BUG_TRAP((!tp->t.ack_prev || tp->t.ack_prev->next));
trickles.c:1113:int breakpoint_seq = -1;
trickles.c:1119:	switch(req->type) {
trickles.c:1128:		newContReq->conts = kmalloc(sizeof(newContReq->conts[0]) * newContReq->numConts, GFP_ATOMIC);
trickles.c:1129:		if(newContReq->conts == NULL) {
trickles.c:1134:		memcpy(newContReq->conts, contReq->conts, sizeof(contReq->conts[0]) * contReq->numConts);
trickles.c:1153:	rval->prev = rval->next = NULL;
trickles.c:1154:	rval->list = NULL;
trickles.c:1160:	BUG_TRAP(req->allocated);
trickles.c:1161:	req->allocated = 0;
trickles.c:1163:	switch(req->type) {
trickles.c:1167:		kfree(contReq->conts);
trickles.c:1168:		numContinuationRequests--;
trickles.c:1174:		if(convReq->incomplete) {
trickles.c:1175:			kfree(convReq->incompletePred);
trickles.c:1177:			UC_CONTINUATION_TRYFREE(convReq->completePred);
trickles.c:1179:		numConversionRequests--;
trickles.c:1185:	BUG_TRAP(!req->list);
trickles.c:1195:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:1197:	for(skb = tp->t.requestBytes.next; skb != (struct sk_buff*)&tp->t.requestBytes; skb = skb->next) {
trickles.c:1198:		if(TCP_SKB_CB(skb)->end_seq <= tp->t.snd_una) {
trickles.c:1200:			skb = skb->prev;
trickles.c:1201:			__skb_unlink(clean, &tp->t.requestBytes);
trickles.c:1209:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:1213:	BUG_TRAP(tp->t.write_seq - tp->t.snd_una > 0);
trickles.c:1219:	for(skb = tp->t.requestBytes.next; skb != (struct sk_buff*)&tp->t.requestBytes; skb = skb->next) {
trickles.c:1220:		if(TCP_SKB_CB(skb)->end_seq <= tp->t.snd_una) {
trickles.c:1222:			skb = skb->prev;
trickles.c:1223:			__skb_unlink(clean, &tp->t.requestBytes);
trickles.c:1225:		} else if(SKB_CONTAINS(skb, tp->t.snd_una)) {
trickles.c:1237:				      tp->t.prevConvCont,
trickles.c:1240:				      tp->t.snd_una);
trickles.c:1241:	printk("%p: init complete conversion request: %d-%d\n", sk, tp->t.snd_una, TCP_SKB_CB(skb)->end_seq);
trickles.c:1242:	//printk("0: start = %d %d\n", tp->t.snd_una, req->start);
trickles.c:1248:		for(curr = (struct Request*)tp->t.queuedRequests.next; 
trickles.c:1249:		    (struct alloc_head_list *) curr != &tp->t.queuedRequests;
trickles.c:1252:			curr = curr->next;
trickles.c:1254:			if(clean->type == MREQ_CONVERSION) {
trickles.c:1257:				printk("found conversion: %d-%d\n", creq->start, creq->end);
trickles.c:1258:				if(intersect_range(creq->start, creq->end, 
trickles.c:1259:						   req->start, req->end)) {
trickles.c:1260:					BUG_TRAP(creq->start <= req->start && 
trickles.c:1261:						 creq->end <= req->end);
trickles.c:1262:					printk("freeing request %d-%d\n", creq->start ,creq->end);
trickles.c:1276:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:1277:	struct ConversionRequest *req = tp->t.newIncompleteRequest;
trickles.c:1284:	BUG_TRAP(req->incomplete);
trickles.c:1286:	for(skb = tp->t.requestBytes.next; skb != (struct sk_buff*)&tp->t.requestBytes; skb = skb->next) {
trickles.c:1287:		if(TCP_SKB_CB(skb)->end_seq <= tp->t.snd_una) {
trickles.c:1289:			skb = skb->prev;
trickles.c:1290:			__skb_unlink(clean, &tp->t.requestBytes);
trickles.c:1292:		} else if(SKB_CONTAINS(skb, tp->t.snd_una)) {
trickles.c:1302:	tp->t.newIncompleteRequest = NULL;
trickles.c:1304:	req->data = skb;
trickles.c:1305:	req->offset = tp->t.snd_una - TCP_SKB_CB(skb)->seq;
trickles.c:1306:	req->start = TCP_SKB_CB(skb)->seq + req->offset;
trickles.c:1308:	printk("1: start = %d\n", req->start);
trickles.c:1310:	req->end = req->start;
trickles.c:1318:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:1324:	unsigned ackSeq = ntohl(incompleteResp->ack_seq);
trickles.c:1325:	int bytesConsumed = tp->t.snd_una;
trickles.c:1333:	if(ackSeq > tp->t.snd_una) {
trickles.c:1334:		tp->t.snd_una = ackSeq;
trickles.c:1335:		if(tp->t.snd_una > tp->t.write_seq) {
trickles.c:1336:			printk("BUG! after byte position update, snd_una %d > write_seq %d !\n", tp->t.snd_una, tp->t.write_seq);
trickles.c:1337:			tp->t.snd_una = tp->t.write_seq;
trickles.c:1338:			return -1;
trickles.c:1341:	bytesConsumed = tp->t.snd_una - bytesConsumed;
trickles.c:1344:	   tp->t.snd_end - tp->t.snd_una >= TRICKLES_MSS) {
trickles.c:1346:		return -1;
trickles.c:1349:	for(skb = tp->t.requestBytes.next; skb != (struct sk_buff*)&tp->t.requestBytes; skb = skb->next) {
trickles.c:1350:		if(TCP_SKB_CB(skb)->end_seq <= tp->t.snd_una) {
trickles.c:1352:			skb = skb->prev;
trickles.c:1353:			__skb_unlink(clean, &tp->t.requestBytes);
trickles.c:1356:		if(SKB_CONTAINS(skb, tp->t.snd_una)) {
trickles.c:1364:		return -1;
trickles.c:1366:	predLength = responseLen - ((char*)&incompleteResp->newCont - (char*)incompleteResp);
trickles.c:1367:	pred = kmalloc_dup(&incompleteResp->newCont, predLength, GFP_ATOMIC);
trickles.c:1371:		return -1;
trickles.c:1375:		BUG_TRAP(tp->t.newIncompleteRequest == NULL);
trickles.c:1376:		tp->t.conversionState = CONVERSION_WAITFORUSER;
trickles.c:1377:		tp->t.newIncompleteRequest = newConvReq;
trickles.c:1381:						NULL, -1);
trickles.c:1384:		BUG_TRAP(tp->t.newIncompleteRequest == NULL);
trickles.c:1385:		tp->t.conversionState = CONVERSION_WAITFORSERVER;
trickles.c:1386:		tp->t.newIncompleteRequest = NULL;
trickles.c:1391:						tp->t.snd_una - TCP_SKB_CB(skb)->seq);
trickles.c:1408:		newStart = newDep->start;
trickles.c:1410:		newStart = MAX(left->end, newDep->start);
trickles.c:1412:		next = left->next;
trickles.c:1415:		newEnd = newDep->end;
trickles.c:1417:		newEnd = MIN(newDep->end, right->start);
trickles.c:1418:		prev = right->prev;
trickles.c:1424:			if(newDep->start >= right->start) {
trickles.c:1426:				return -1;
trickles.c:1430:			return -1;
trickles.c:1435:			if(newDep->end <= left->end) {
trickles.c:1437:				return -1;
trickles.c:1441:			return -1;
trickles.c:1446:		return -1;
trickles.c:1451:		return -1;
trickles.c:1458:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:1461:	BUG_TRAP(newCont->validEnd >= tp->t.byteRcvNxt);
trickles.c:1464:	alloc_head_reverse_walk(&tp->t.ucontList, insertPos) {
trickles.c:1466:		if(insertPos->clientValidStart < newCont->validStart) break;
trickles.c:1468:	newCont->clientValidStart = newCont->validStart;
trickles.c:1469:	newCont->clientValidEnd = newCont->validEnd;
trickles.c:1473:	struct alloc_head_list *insertionList = &tp->t.ucontList;
trickles.c:1475:	       (struct alloc_head*)insertPos, (struct alloc_head*)insertPos->next);
trickles.c:1481:		finger = (struct UC_Continuation*) finger->next;
trickles.c:1483:	unsigned lastByte = newCont->clientValidEnd;
trickles.c:1484:	for(; (struct alloc_head_list*)finger->next != insertionList; finger = nextCont) {
trickles.c:1485:		nextCont = (struct UC_Continuation *)finger->next;
trickles.c:1486:		unsigned start = MAX(finger->clientValidStart, nextCont->clientValidStart),
trickles.c:1487:			end = MIN(finger->clientValidEnd, nextCont->clientValidEnd);
trickles.c:1491:			struct alloc_head *iPrev = finger->prev;
trickles.c:1493:			struct alloc_head *iNext = nextCont->next;
trickles.c:1496:			if(finger->seq > nextCont->seq) {
trickles.c:1503:			if(older->clientValidStart < start) {
trickles.c:1507:			if(older->clientValidEnd > end) {
trickles.c:1512:						return -1;
trickles.c:1514:#if 0 // 0707 -- unclear ???
trickles.c:1515:					right->prev = right->next = NULL;
trickles.c:1516:					right->list = NULL;
trickles.c:1531:				if(left->list)
trickles.c:1533:				left->clientValidEnd = start;
trickles.c:1536:				if(middle->list)
trickles.c:1541:				if(right->list)
trickles.c:1543:				right->clientValidStart = end;
trickles.c:1560:				while((struct alloc_head*)finger->next != iNext) {
trickles.c:1562:					   (struct alloc_head_list*)finger->next != insertionList) {
trickles.c:1563:						BUG_TRAP(finger->clientValidEnd <=
trickles.c:1564:							 ((struct UC_Continuation*)finger->next)->clientValidStart);
trickles.c:1566:					finger = (struct UC_Continuation*)finger->next;
trickles.c:1569:			nextCont = (struct UC_Continuation*)iPrev0; // XXX iNext->prev is a more efficient resumption point
trickles.c:1586:	   tp->t.request_rcv_nxt updated
trickles.c:1590:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:1591:	struct alloc_head_list *list_heads[] = {&tp->t.sentRequests,
trickles.c:1592:						&tp->t.queuedRequests};
trickles.c:1599:			if(matchID != parent_req->seq) {
trickles.c:1602:			if(parent_req->type != matchType) {
trickles.c:1616:			if(!(parent_req->numChildren == 0 ||
trickles.c:1617:			     numSiblings == parent_req->numChildren)) {
trickles.c:1621:			if(parent_req->childrenMask & positionMask) {
trickles.c:1625:			parent_req->numChildren = numSiblings;
trickles.c:1626:			if(parent_req->numChildren == 0) {
trickles.c:1630:			parent_req->childrenMask |= positionMask;
trickles.c:1631:			allMask = (unsigned)(1 << parent_req->numChildren) - 1;
trickles.c:1633:			if((parent_req->childrenMask & allMask) == allMask) {
trickles.c:1635:				switch(parent_req->type) {
trickles.c:1642:					BUG_TRAP(parent_req->seq == tp->t.request_rcv_nxt);
trickles.c:1643:					tp->t.request_rcv_nxt++;
trickles.c:1645:					parent_req = (struct Request *)clean->prev;
trickles.c:1646:					//printk("removed %u-%u\n", clean->start, clean->end);
trickles.c:1668:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:1671:	alloc_head_walk(&tp->t.ucontList, ucont) {
trickles.c:1672:		if(ucont->kernel.obsoleteAt <= tp->t.byteRcvNxt) {
trickles.c:1675:			printk("Removed continuation c=%d o=%d [%d-%d] [%d-%d]\n",
trickles.c:1676:			       count, clean->kernel.obsoleteAt,
trickles.c:1677:			       clean->validStart, clean->validEnd,
trickles.c:1678:			       clean->clientValidStart, clean->clientValidEnd);
trickles.c:1680:			ucont = (struct UC_Continuation*)ucont->prev;
trickles.c:1689:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:1692:	alloc_head_walk(&tp->t.depNodeList, depNode) {
trickles.c:1693:		struct UC_DependencyNode *prev = (struct UC_DependencyNode*)depNode->prev;
trickles.c:1702:	unsigned realEnd  = UC_Continuation_actualEnd(map->ucont);
trickles.c:1703:	if(realEnd < map->end) {
trickles.c:1704:		printk("fixing up %d=>%d\n", map->end, realEnd);
trickles.c:1705:		map->end = realEnd;
trickles.c:1711:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:1715:		&tp->t.dataRequestMap,
trickles.c:1716:		&tp->t.missingDataMap};
trickles.c:1724:		for(dataReqMap = (struct DataRequestMapping *)currList->next;
trickles.c:1728:			nextDataReqMap = dataReqMap->next;
trickles.c:1730:			if(dataReqMap->end <= tp->t.byteRcvNxt) {
trickles.c:1733:				// XXX - with this algorithm, reordering inflates rtt (timing is updated when the packet can be delivered in-order, not when it is first received)
trickles.c:1735:				if(1 /* || dataReqMap->transportResponseSeqStart <= transportSeq &&
trickles.c:1736:					transportSeq < dataReqMap->transportResponseSeqEnd */) {
trickles.c:1738:					tp->t.A = (FIXEDRTT);
trickles.c:1747:								printk("HZ=%d delta %lu, new rtt %d %d/8\n", HZ, jiffies - dataReqMap->timestamp, tp->t.A >> 3, tp->t.A & 0x7);
trickles.c:1759:			if(!freed && dataReqMap->sent &&
trickles.c:1760:			   !dataReqMap->completed && // hint
trickles.c:1761:			   tp->t.rcv_nxt >= dataReqMap->transportResponseSeqEnd) {
trickles.c:1762:				//printk("tp->t.rcv_nxt = %u dataReqMap->transportResponseSeqEnd = %d\n", tp->t.rcv_nxt, dataReqMap->transportResponseSeqEnd);
trickles.c:1764:				// If tp->t.rcv_nxt >= transportSeqEnd, then the server may not have sent us the full request.
trickles.c:1768:				struct alloc_head *prevMap = (struct alloc_head*) dataReqMap->prev,
trickles.c:1769:					*nextMap = (struct alloc_head*)dataReqMap->next;
trickles.c:1771:				int lastEnd = MAX(dataReqMap->start, tp->t.byteRcvNxt);
trickles.c:1772:				struct sk_buff *finger = tp->t.ofo_queue.next;
trickles.c:1776:				skb_queue_walk(&tp->t.data_ofo_queue, finger) {
trickles.c:1778:					int minSeq = MAX(TCP_SKB_CB(finger)->seq, dataReqMap->start);
trickles.c:1779:					int maxSeq = MIN(TCP_SKB_CB(finger)->end_seq, dataReqMap->end);
trickles.c:1780:					if(maxSeq >= dataReqMap->end) {
trickles.c:1791:							printk("Inserted %d-%d\n", lastEnd, minSeq);
trickles.c:1798:				if(lastEnd < dataReqMap->end) {
trickles.c:1800:						myEnd = dataReqMap->end;
trickles.c:1807:						printk("Inserted %d-%d\n", myStart, myEnd);
trickles.c:1813:						printk("Inserted %d-%d\n", myStart, myEnd);
trickles.c:1819:						dataReqMap->completed = 1;
trickles.c:1831:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:1833:	BUG_TRAP(cont->seq <= tp->t.rcv_nxt);
trickles.c:1834:#define UPTODATE(CONT) ((CONT)->clientState == tp->t.clientStateCounter)
trickles.c:1836:	if(cont->continuationType == CONTTYPE_MINIMAL) {
trickles.c:1840:	switch(tp->t.state) {
trickles.c:1842:		if(cont->firstChild)
trickles.c:1843:			tp->t.in_flight = MAX(0, tp->t.in_flight - 1);
trickles.c:1846:		if(cont->state == CONT_BOOTSTRAP &&
trickles.c:1858:		if(UPTODATE(cont) && cont->seq == cont->TCPBase) {
trickles.c:1861:			__u32 prev_seq = tp->t.ack_prev->TCPBase; // 0501 cleanup
trickles.c:1863:				printk("client_rcv: exit recovery or slow start : seq = %u oldBase = %u newBase = %u startCwnd = %u\n", cont->seq,
trickles.c:1864:				       prev_seq, cont->TCPBase, cont->startCwnd);
trickles.c:1866:			tp->t.standardProof.numSacks = 0;
trickles.c:1867:			AckProof_update(sk, &tp->t.standardProof, cont);
trickles.c:1868:			for(cont_curs = (CONTINUATION_TYPE*)tp->t.cont_list.next;
trickles.c:1869:			    cont_curs != (CONTINUATION_TYPE*)&tp->t.cont_list;
trickles.c:1871:				next = (CONTINUATION_TYPE*)cont_curs->next;
trickles.c:1873:				// 0424 - tighten up conditions to detect inconsistent states
trickles.c:1875:				if(((tp->t.state == TRICKLES_CLIENT_SLOWSTART && UPTODATE(cont_curs)) ||
trickles.c:1876:				    ((tp->t.state == TRICKLES_CLIENT_RECOVERY) && cont_curs->seq >= cont->TCPBase))) {
trickles.c:1878:				if(UPTODATE(cont_curs) && cont_curs->TCPBase >= cont->TCPBase) {
trickles.c:1879:					BUG_TRAP(cont_curs->TCPBase >= cont->TCPBase);
trickles.c:1880:					AckProof_update(sk, &tp->t.standardProof, cont_curs);
trickles.c:1883:					// XXX 0426 - Additional violation situations are possible if requestSlowStart fails because it cannot find a continuation that can be used for the slow start request
trickles.c:1884:					if(!(cont_curs->clientState == tp->t.clientStateCounter-2 /* recovery followed by slow start */ ||
trickles.c:1885:					     cont_curs->clientState == tp->t.clientStateCounter-1 /* recovery */||
trickles.c:1886:					     cont_curs->clientState == tp->t.clientStateCounter)) {
trickles.c:1889:							       sk, cont_curs->clientState, tp->t.clientStateCounter);
trickles.c:1905:			/* only up-to-date continuations in cont_list now */
trickles.c:1906:			tp->t.altProof = tp->t.standardProof;
trickles.c:1909:			AckProof_dump(&tp->t.standardProof);
trickles.c:1911:			AckProof_dump(&tp->t.altProof);
trickles.c:1913:			BUG_TRAP(tp->t.standardProof.sacks[0].left <= cont->TCPBase);
trickles.c:1914:			BUG_TRAP(tp->t.altProof.sacks[0].left <= cont->TCPBase);
trickles.c:1916:			tp->t.previous_base = cont->TCPBase;
trickles.c:1918:				printk("new cwnd: %d ssthresh: %d seq: %d base: %d\n", cont->startCwnd, cont->ssthresh, cont->seq, cont->TCPBase);
trickles.c:1921:				switch(tp->t.state) {
trickles.c:1939:			appendTricklesLossEvent(sk, MIN(cont->startCwnd, EVENT_CWND_MAX),
trickles.c:1940:						EVENT_EXTRA_RECV, tp->t.state);
trickles.c:1942:			tp->t.state = TRICKLES_CLIENT_NORMAL;
trickles.c:1943:			tp->t.oo_count = 0;
trickles.c:1944:			tp->t.in_flight = 0;
trickles.c:1946:			tp->t.timerState = TRICKLES_ENABLE_DATA_TIMEOUT;
trickles.c:1950:			tp->t.ack_prev = NULL;
trickles.c:1951:			tp->t.ack_last = cont->seq;
trickles.c:1952:			//0501 - called twice when recovering
trickles.c:1960:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:1963:	CONTINUATION_TYPE *cont = ofo_entry->cont;
trickles.c:1970:	 * UC-level updates
trickles.c:1976:	// 0505 - allow multiple continuations per packet
trickles.c:1977:	//printk("%p @ ucont_len = %d\n", cont->ucont_data, cont->ucont_len);
trickles.c:1979:	    ucont_position < cont->ucont_len;
trickles.c:1980:	    ucont_position += ntohs(hdr->len)) {
trickles.c:1982:		void *ucont_start = cont->ucont_data + ucont_position;
trickles.c:1984:		int ucont_len = ntohs(hdr->len);
trickles.c:1992:		switch((enum UC_Type)hdr->type) {
trickles.c:2002:			switch(tp->t.conversionState) {
trickles.c:2031:			switch(tp->t.conversionState) {
trickles.c:2035:				ucont = unmarshallUC_Continuation(&completeResp->newCont,
trickles.c:2036:								  ucont_len - ((char*)&completeResp->newCont - (char*)ucont_start));
trickles.c:2043:				atomic_set(&newConvCont->refcnt, 1);
trickles.c:2049:				if(tp->t.prevConvCont) {
trickles.c:2053:					UC_Continuation_dump(tp->t.prevConvCont);
trickles.c:2055:					UC_CONTINUATION_TRYFREE(tp->t.prevConvCont);
trickles.c:2063:				tp->t.prevConvCont = newConvCont;
trickles.c:2065:				ackSeq = ntohl(completeResp->ack_seq);
trickles.c:2066:				if(ackSeq > tp->t.snd_una) {
trickles.c:2067:					tp->t.snd_una = ackSeq;
trickles.c:2068:					//printk("snd_una = %d\n", tp->t.snd_una);
trickles.c:2069:					if(tp->t.snd_una > tp->t.write_seq) {
trickles.c:2070:						printk("Error! snd_una %d > tp->t.write_seq %d while processing CompleteConversion\n", tp->t.snd_una, tp->t.write_seq);
trickles.c:2071:						tp->t.snd_una = tp->t.write_seq;
trickles.c:2081:				printk("ackseq = %d snd_una = %d write_seq = %d\n", ackSeq, tp->t.snd_una, tp->t.write_seq);
trickles.c:2089:					kfree(tp->t.prevConvCont);
trickles.c:2090:					tp->t.prevConvCont = NULL;
trickles.c:2094:				if(tp->t.write_seq - tp->t.snd_una > 0) {
trickles.c:2096:					tp->t.conversionState = CONVERSION_WAITFORSERVER;
trickles.c:2097:#if 0 // 0426 - do not push out requests in interrupt context, since the requests will be sent automatically
trickles.c:2103:					tp->t.conversionState = CONVERSION_IDLE;
trickles.c:2104:					//printk("update client state set conversion state to IDLE: %d\n", tp->t.conversionState);
trickles.c:2131:			ucont =	unmarshallUC_Continuation(&updateResp->newCont,
trickles.c:2132:							  ucont_len - ((char*)&updateResp->newCont - (char*)ucont_start));
trickles.c:2154:			ucont = unmarshallUC_Continuation(&newContResp->newCont,
trickles.c:2155:							  ucont_len - ((char*)&newContResp->newCont - (char*)ucont_start));
trickles.c:2176:		if(ofo_entry->isSynack) {
trickles.c:2178:			tp->t.request_rcv_nxt = 1;
trickles.c:2179:			tp->t.request_snd_nxt = 1;
trickles.c:2183:			switch(hdr->type) {
trickles.c:2188:				start = -1;
trickles.c:2189:				end = -1;
trickles.c:2194:				start = addedUCont->validStart;
trickles.c:2195:				end = addedUCont->validEnd;
trickles.c:2197:				updateParent(sk, type, ofo_entry->parent,
trickles.c:2198:					     ofo_entry->numSiblings, ofo_entry->position,
trickles.c:2228:	int skb_len = in_skb->len;
trickles.c:2229:	int skb_seq = -1;
trickles.c:2231:	int dropline = -1;
trickles.c:2232:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:2238:	TCP_SKB_CB(in_skb)->cont = cont;
trickles.c:2239:	if(TCP_SKB_CB(in_skb)->cont == NULL) {
trickles.c:2246:		printk("Received packet during recovery %d\n", tp->t.clientStateCounter);
trickles.c:2267:	cont->mark |= 0x1;
trickles.c:2274:		int copyLen = in_skb->tail - in_skb->head;
trickles.c:2279:		memcpy(copy->head, in_skb->head, copyLen);
trickles.c:2280:		skb_reserve(copy, in_skb->data - in_skb->head);
trickles.c:2281:		copy->h.th = (struct tcphdr*)(copy->head + ((char*)in_skb->h.th - (char*)in_skb->head));
trickles.c:2282:		copy->nh.iph = (struct iphdr*)(copy->head + ((char*)in_skb->nh.iph - (char*)in_skb->head));
trickles.c:2283:		skb_put(copy, in_skb->len);
trickles.c:2284:		BUG_TRAP(copy->len == in_skb->len);
trickles.c:2285:		copy->sk = in_skb->sk;
trickles.c:2289:		TCP_SKB_CB(in_skb)->cont = cont;
trickles.c:2303:	tresp_hdr = (WireTrickleResponse *)in_skb->data;
trickles.c:2304:	/* 0429 - hash compression support */
trickles.c:2306:	if(tresp_hdr->cont.continuationType & CONTTYPE_HASHCOMPRESSED) {
trickles.c:2317:		struct WireContinuation *wcont = &tresp_hdr->cont;
trickles.c:2319:		tresp_hdr->cont.continuationType &= ~CONTTYPE_HASHCOMPRESSED;
trickles.c:2320:		fullType = tresp_hdr->cont.continuationType == CONTTYPE_FULL1 ||
trickles.c:2321:			tresp_hdr->cont.continuationType == CONTTYPE_FULL2;
trickles.c:2323:			 tresp_hdr->cont.continuationType == CONTTYPE_MINIMAL);
trickles.c:2326:		alloc_head_reverse_walk(&tp->t.cont_list, finger) {
trickles.c:2327:			if(wcont->hash.parentSeq  == (typeof(wcont->hash.parentSeq)) finger->seq &&
trickles.c:2328:			   wcont->hash.clientState == (typeof(wcont->hash.clientState)) finger->clientState) {
trickles.c:2332:		if(finger == (CONTINUATION_TYPE *)&tp->t.cont_list) {
trickles.c:2338:		// 0430 - numSiblings is from UC level; there is no similar field for Transport level
trickles.c:2339:		//BUG_TRAP(tresp_hdr->numSiblings == simulationOutput->num_packets);
trickles.c:2341:		BUG_TRAP(finger->simulated);
trickles.c:2342:		BUG_TRAP(wcont->hash.position < simulationOutput->num_packets);
trickles.c:2345:		marshallContinuationServerCopyMAC(sk, wc_scratch, simulationOutput, wcont->hash.position);
trickles.c:2347:		//LOG_PACKET_CONT(in_skb, in_skb->h.th->ack_seq, cont);
trickles.c:2350:		cont->timestamp = ntohl(wcont->hash.timestamp);
trickles.c:2351:		cont->mrtt = cont->rawMrtt = ntohs(wcont->hash.mrtt);
trickles.c:2352:		cont->parentMSK = finger;
trickles.c:2355:			memcpy(cont->mac, wcont->hash.mac, HMACLEN);
trickles.c:2373:		switch(tresp_hdr->cont.continuationType) {
trickles.c:2376:			//printk("minimal continuation, length = %d(%d)\n", in_skb->len, in_skb->data - in_skb->head);
trickles.c:2386:			//printk("full continuation, length = %d(%d)\n", in_skb->len, in_skb->data - in_skb->head);
trickles.c:2392:			cont->continuationType = tresp_hdr->cont.continuationType;
trickles.c:2393:			cont->seq = ntohl(tresp_hdr->cont.seq);
trickles.c:2394:			cont->clientState = tresp_hdr->cont.clientState;
trickles.c:2395:			cont->clientTimestamp = tresp_hdr->cont.clientTimestamp;
trickles.c:2396:			cont->parent = tresp_hdr->cont.parent;
trickles.c:2398:			unmarshallContinuationClient(in_skb, cont, &tresp_hdr->cont);
trickles.c:2400:		skb_seq = cont->seq;
trickles.c:2401:		LOG_PACKET_CONT(sk, in_skb->h.th->ack_seq, cont);
trickles.c:2403:	if(!noCont && (cont->seq > tp->t.rcv_nxt + 1000000 ||
trickles.c:2404:		       cont->TCPBase > tp->t.rcv_nxt + 1000000)) {
trickles.c:2406:			printk("Warning: client received bogus sequence number (%u) or TCPBase (%u)\n", cont->seq, cont->TCPBase);
trickles.c:2408:	TCP_SKB_CB(in_skb)->numSiblings = tresp_hdr->numSiblings;
trickles.c:2409:	TCP_SKB_CB(in_skb)->position = tresp_hdr->position;
trickles.c:2411:	ucont_len = ntohs(tresp_hdr->ucont_len);
trickles.c:2412:	//printk("tresp_hdr->ucont_len = %d\n", ucont_len);
trickles.c:2413:	char *ucont_start = ucont_in = in_skb->data;
trickles.c:2415:	cont->mark = SKBLIST;
trickles.c:2419:	cont->ucont_len = ucont_len;
trickles.c:2421:	cont->cum_nonce = tresp_hdr->nonce;
trickles.c:2422:	cont->next = cont->prev = NULL;
trickles.c:2428:		printk("client_rcv: could not pull ucont (ucont_len = %d, skb_len = %d)\n", (int)ucont_len, in_skb->len);
trickles.c:2432:		cont->ucont_data = kmalloc(ucont_len, GFP_ATOMIC);
trickles.c:2433:		if(cont->ucont_data == NULL) {
trickles.c:2438:		memcpy(cont->ucont_data, ucont_in, ucont_len);
trickles.c:2441:	//printk("cont->ucont_data = %p, cont->ucont_len = %d\n", cont->ucont_data, cont->ucont_len);
trickles.c:2443:	TCP_SKB_CB(in_skb)->trickle_seq = cont->seq;
trickles.c:2444:	TCP_SKB_CB(in_skb)->clientState = cont->clientState;
trickles.c:2448:		printk("Recovery packet client state counter = %d, socket counter = %d\n", cont->clientState, tp->t.clientStateCounter);
trickles.c:2450:	if(cont->seq < tp->t.rcv_nxt) {
trickles.c:2452:			printk("Client_rcv: Useless old packet cont.seq = %u < rcv_nxt = %u; dropping\n", cont->seq, tp->t.rcv_nxt);
trickles.c:2457:	if(sk->state != TCP_ESTABLISHED) {
trickles.c:2458:		if(!(in_skb->h.th->syn && in_skb->h.th->ack) )
trickles.c:2463:		sk->state = TCP_ESTABLISHED;
trickles.c:2464:		tp->rcv_nxt = 0;
trickles.c:2465:		tp->rcv_wup = 0;
trickles.c:2466:		tp->copied_seq = 0;
trickles.c:2468:		tp->t.rcv_nxt = cont->seq;
trickles.c:2469:		tp->t.byteRcvNxt = 0;
trickles.c:2470:		tp->t.byteSkipHintAmount = 0;
trickles.c:2471:		tp->t.previous_base = cont->TCPBase;
trickles.c:2472:		tp->t.state = TRICKLES_CLIENT_NORMAL;
trickles.c:2475:		tp->t.ack_prev = NULL;
trickles.c:2476:		tp->t.ack_last = cont->seq + 1;
trickles.c:2477:		tp->t.A = 0;
trickles.c:2478:		tp->t.D = 0;
trickles.c:2479:		tp->t.RTO = INITIAL_RTO;
trickles.c:2481:		tp->t.timerState = TRICKLES_ENABLE_DATA_TIMEOUT;
trickles.c:2486:		if(!sk->dead) {
trickles.c:2487:			sk->state_change(sk);
trickles.c:2490:		tp->t.clientStateCounter = cont->clientState;
trickles.c:2491:		cont->parent = tp->t.request_rcv_nxt;
trickles.c:2492:	} else if(tp->t.state == TRICKLES_CLIENT_SYNACK &&
trickles.c:2493:		  !in_skb->h.th->syn && in_skb->h.th->ack) {
trickles.c:2494:		tp->t.state = TRICKLES_CLIENT_NORMAL;
trickles.c:2499:	// Must initialize in_skb->parent here, since
trickles.c:2500:	// cont->parent is initialized in SYN/ACK processing
trickles.c:2501:	TCP_SKB_CB(in_skb)->parent = cont->parent;
trickles.c:2506:	       cont.seq, tp->t.rcv_nxt, tp->t.ack_seq, tp->t.ack_last);
trickles.c:2515:	 * ofo_queue - inserted during initial packet receipt, removed when dequeued, handed off to userspace, freed when duplicate arrives
trickles.c:2516:	 * cont_list - inserted during initial packet receipt (not reordering), and freed during acking. NEVER freed during ofo_queue walk!!!
trickles.c:2522:	if(!(((tp->t.state == TRICKLES_CLIENT_NORMAL || tp->t.state == TRICKLES_CLIENT_SLOWSTART) &&
trickles.c:2523:	      cont->clientState == tp->t.clientStateCounter) ||
trickles.c:2524:	     (tp->t.state == TRICKLES_CLIENT_RECOVERY &&
trickles.c:2525:	      (cont->clientState == tp->t.clientStateCounter || cont->clientState == tp->t.clientStateCounter-1)))) {
trickles.c:2527:			printk("%d %d client state did not match, packet seq = %u state = %u, clientstate = %u\n", (int) jiffies, tp->t.state, cont->seq, cont->clientState, tp->t.clientStateCounter);
trickles.c:2531:	if(!AckProof_update(sk, &tp->t.altProof, cont)) {
trickles.c:2538:	if(tp->t.ack_prev == NULL || cont->seq > tp->t.ack_prev->seq) {
trickles.c:2541:		if(!AckProof_update(sk, &tp->t.standardProof, cont) &&
trickles.c:2542:		   // 0419: need this test since tp->t.standardProof can be in bad states during recovery and slowstart
trickles.c:2543:		   tp->t.state == TRICKLES_CLIENT_NORMAL) {
trickles.c:2558:	cur_seq = cont->seq; // save value since cont might be deallocated soon
trickles.c:2563:	tp->t.A = FIXEDRTT;
trickles.c:2564:	tp->t.RTO = (tp->t.A >> 3) * TIMEOUT_MULTIPLIER;
trickles.c:2567:		int delta = jiffies - cont->clientTimestamp;
trickles.c:2574:			if(tp->t.A == 0) {
trickles.c:2575:				tp->t.A = (delta) << 3;
trickles.c:2577:				tp->t.D = tp->t.A >> 1;
trickles.c:2579:				int Err = (delta << 3) - tp->t.A; // units of jiffies/8
trickles.c:2582:				tp->t.A += (Err >> 3);
trickles.c:2583:				//effect is D += 1/4 (Err - D)
trickles.c:2584:				tp->t.D += ((iabs(Err) - tp->t.D) >> 2);
trickles.c:2585:				tp->t.RTO = VJ90RTO8(sk);
trickles.c:2599:	if(cont->seq == tp->t.rcv_nxt) {
trickles.c:2603:		unsigned seq = cont->seq;
trickles.c:2618:			   AckProof_checkRange(&tp->t.altProof, tp->t.rcv_nxt, tp->t.rcv_nxt) == BADRANGE) {
trickles.c:2621:			tp->t.rcv_nxt++;
trickles.c:2624:				printk("rcv nxt now %d ack_last = %d\n", tp->t.rcv_nxt, tp->t.ack_last);
trickles.c:2626:			skb = skb_peek(&tp->t.ofo_queue);
trickles.c:2628:			if(!skb || TCP_SKB_CB(skb)->trickle_seq != tp->t.rcv_nxt) {
trickles.c:2633:			__skb_dequeue(&tp->t.ofo_queue);
trickles.c:2641:				printk("%u closed gap of %d, ack_last = %u\n", seq, closedGap, tp->t.ack_last);
trickles.c:2644:				printk("%u in order, ack_last = %u\n", seq, tp->t.ack_last);
trickles.c:2649:		//printk("seq = %d, rcv_nxt = %d\n", cont->seq, tp->t.rcv_nxt);
trickles.c:2651:		if(skb_peek(&tp->t.ofo_queue) == NULL) {
trickles.c:2653:				printk("  client: %u inserted at ofo head\n", TCP_SKB_CB(in_skb)->trickle_seq);
trickles.c:2657:			__skb_queue_head(&tp->t.ofo_queue, in_skb);
trickles.c:2662:			struct sk_buff *skb = tp->t.ofo_queue.prev;
trickles.c:2664:				if(TCP_SKB_CB(skb)->trickle_seq < TCP_SKB_CB(in_skb)->trickle_seq)
trickles.c:2666:			} while((struct sk_buff_head*)(skb=skb->prev) != &tp->t.ofo_queue);
trickles.c:2668:			if((struct sk_buff_head*)skb->next != &tp->t.ofo_queue &&
trickles.c:2669:			   TCP_SKB_CB(skb->next)->trickle_seq == TCP_SKB_CB(in_skb)->trickle_seq) {
trickles.c:2671:				struct sk_buff *next = skb->next;
trickles.c:2672:				if(NEWER(TCP_SKB_CB(in_skb)->clientState, TCP_SKB_CB(next)->clientState)) {
trickles.c:2675:						printk("Got rid of old skb %u\n", TCP_SKB_CB(next)->trickle_seq);
trickles.c:2676:					__skb_unlink(next, &tp->t.ofo_queue);
trickles.c:2680:						printk("Got rid of new skb %u\n", TCP_SKB_CB(in_skb)->trickle_seq);
trickles.c:2686:				printk("  client: inserted %u after %u, before %u\n", TCP_SKB_CB(in_skb)->trickle_seq, TCP_SKB_CB(skb)->trickle_seq, TCP_SKB_CB(skb->next)->trickle_seq);
trickles.c:2691:			__skb_insert(in_skb, skb, skb->next, &tp->t.ofo_queue);
trickles.c:2704:	switch(tp->t.state) {
trickles.c:2717:				printk("  client: no ackable found, rcv_nxt = %u\n", tp->t.rcv_nxt);
trickles.c:2719:			if(cur_seq > tp->t.ack_last) {
trickles.c:2720:				tp->t.oo_count++;
trickles.c:2721:#if 1 // 0714 - try different out of order thresholds
trickles.c:2722:				if(tp->t.oo_count >= OO_THRESHOLD) {
trickles.c:2724:				if(tp->t.oo_count >= min(OO_THRESHOLD, max(tp->t.sentRequests.len / 4, 3))) {
trickles.c:2727:					int old_last = tp->t.ack_last;
trickles.c:2735:					tp->t.oo_count = 0;
trickles.c:2738:					printk("entering recovery @ ack_last = %d seq = %d\n", tp->t.ack_last, cur_seq);
trickles.c:2744:					BUG_TRAP(tp->t.ack_last >= old_last);
trickles.c:2746:					if(skip_skb->prev != (struct sk_buff*)&tp->t.ofo_queue) {
trickles.c:2747:						first_seq = TCP_SKB_CB(skip_skb->prev)->trickle_seq + 1;
trickles.c:2749:						first_seq = tp->t.rcv_nxt;
trickles.c:2751:					BUG_TRAP(first_seq < TCP_SKB_CB(skip_skb)->trickle_seq);
trickles.c:2754:						    dataReqMap = (struct DataRequestMapping*)tp->t.dataRequestMap.next,
trickles.c:2755:						    req = (struct Request *)tp->t.sentRequests.next;
trickles.c:2756:					    seq < TCP_SKB_CB(skip_skb)->trickle_seq;
trickles.c:2759:						while(dataReqMap != (struct DataRequestMapping*) &tp->t.dataRequestMap &&
trickles.c:2760:						      dataReqMap->transportResponseSeqEnd <= seq) {
trickles.c:2761:							dataReqMap = dataReqMap->next;
trickles.c:2763:						if(dataReqMap != (struct DataRequestMapping*)&tp->t.dataRequestMap &&
trickles.c:2764:						   dataReqMap->transportResponseSeqStart <= seq &&
trickles.c:2765:						   seq < dataReqMap->transportResponseSeqEnd) {
trickles.c:2766:							struct DataRequestMapping *next = dataReqMap->next;
trickles.c:2771:								insert_tail(&tp->t.missingDataMap,
trickles.c:2778:						while(req != (struct Request *)&tp->t.sentRequests &&
trickles.c:2779:						      req->transportResponseSeqEnd <= seq) {
trickles.c:2780:							req = (struct Request*)req->next;
trickles.c:2782:						if(req != (struct Request *)&tp->t.sentRequests &&
trickles.c:2783:						   req->transportResponseSeqStart <= seq &&
trickles.c:2784:						   seq < req->transportResponseSeqEnd) {
trickles.c:2785:							struct Request *next = (struct Request*)req->next;
trickles.c:2790:							insert_head(&tp->t.queuedRequests, (struct alloc_head*)req);
trickles.c:2809:			//printk("  client: after findackables: ack_seq = %d ack_last = %d\n", tp->t.ack_seq, tp->t.ack_last);
trickles.c:2830:	// 0901 -- Scrape out the last bit of performane from the dropped packets
trickles.c:2834:	TCP_SKB_CB(in_skb)->dbg = __LINE__;
trickles.c:2846:		printk("state = %d seq = %d ", cont->state, cont->seq);
trickles.c:2853:	if(cont != NULL && (tp->t.ack_prev == cont)) {
trickles.c:2871:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:2872:	CONTINUATION_TYPE *cont = tp->t.ack_prev;
trickles.c:2888:		printk("trickles_send_ack " #LABEL " - seq = %d\n", cont != NULL ? cont->seq : -1); \
trickles.c:2894:		cont = (CONTINUATION_TYPE *)&tp->t.cont_list;
trickles.c:2904:		cont = cont->next;
trickles.c:2913:		if(cont == (CONTINUATION_TYPE*)&tp->t.cont_list ||
trickles.c:2914:		   cont->seq >= tp->t.ack_last) {
trickles.c:2931:			if(cont->state == CONT_BOOTSTRAP) {
trickles.c:2932:				printk("bootstrap ack: %u\n", cont->seq);
trickles.c:2937:		tp->t.ack_prev = cont;
trickles.c:2938:		INTEGRITY_CHECK(sk, tp->t.ack_prev);
trickles.c:2940:		if(!(!tp->t.ack_prev || tp->t.ack_prev->next)) {
trickles.c:2942:			BUG_TRAP(!tp->t.ack_prev || tp->t.ack_prev->next);
trickles.c:2946:		if(tp->t.state == TRICKLES_CLIENT_NORMAL) {
trickles.c:2947:			CONTINUATION_TYPE *clean = (CONTINUATION_TYPE*)tp->t.cont_list.next;
trickles.c:2949:			while(clean != (CONTINUATION_TYPE*)&tp->t.cont_list) {
trickles.c:2951:				clean = clean->next;
trickles.c:2956:				   prev->numChildrenReceived < prev->numTransportChildren ||
trickles.c:2958:				   prev->seq >= tp->t.ack_prev->seq ||
trickles.c:2959:				   prev->seq >= tp->t.rcv_nxt /* ||
trickles.c:2960:								 prev->seq >= tp->t.previous_base */) {
trickles.c:2962:					printk("skipped continued deallocation (list len = %d): prev->seq (%d) >= tp->t.ack_prev->seq (%d), prev->seq (%d) >= tp->t.rcv_nxt (%d)\n",
trickles.c:2963:					       tp->t.cont_list.len,
trickles.c:2964:					       prev->seq, tp->t.ack_prev->seq,
trickles.c:2965:					       prev->seq, tp->t.rcv_nxt);
trickles.c:2971:				BUG_TRAP(prev != tp->t.ack_prev);
trickles.c:2975:				if(tp->t.ack_prev == prev) {
trickles.c:2979:					printk("freeing %d, rcv_nxt=%d, previous_base = %d\n", prev->seq, tp->t.rcv_nxt, tp->t.previous_base);
trickles.c:2985:		tp->t.in_flight++;
trickles.c:2998:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:3003:	tp->t.timerState |= TRICKLES_ENABLE_DATA_TIMEOUT;
trickles.c:3004:	if((tp->t.timerState & TRICKLES_NEED_SLOWSTART)) {
trickles.c:3009:			printk("user_ack_impl requestslowstart %p state = %d\n", sk, tp->t.timerState);
trickles.c:3013:		//printk("pre user triggering sendackimpl = %d,%d\n", tp->t.ack_last, tp->t.rcv_nxt);
trickles.c:3015:		//printk("user triggering sendackimpl = %d,%d,%d\n", numAcks, tp->t.ack_last, tp->t.rcv_nxt);
trickles.c:3022:		tp->t.timerState &= ~TRICKLES_NEED_USERACK;
trickles.c:3032:	sk->shutdown |= RCV_SHUTDOWN;
trickles.c:3033:	sk->done = 0;
trickles.c:3034:	sk->err = EPIPE;
trickles.c:3037:	sk->state_change(sk);
trickles.c:3039:	if (sk->shutdown == SHUTDOWN_MASK || sk->state == TCP_CLOSE)
trickles.c:3048:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles.c:3049:	int chunk = skb->len - hlen;
trickles.c:3053:	if (skb->ip_summed==CHECKSUM_UNNECESSARY)
trickles.c:3054:		err = skb_copy_datagram_iovec(skb, hlen, tp->ucopy.iov, chunk);
trickles.c:3056:		err = skb_copy_and_csum_datagram_iovec(skb, hlen, tp->ucopy.iov);
trickles.c:3059:		tp->ucopy.len -= chunk;
trickles.c:3060:		tp->copied_seq += chunk;
trickles.c:3075:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:3076:	int len = skb->len;
trickles.c:3077:	int direct_copy = tp->ucopy.task == current &&
trickles.c:3078:	    tp->copied_seq == tp->rcv_nxt &&
trickles.c:3079:	    len <= tp->ucopy.len &&
trickles.c:3080:	    sk->lock.users;
trickles.c:3091:	skb->h.th->syn = 0;
trickles.c:3092:	if(!(tp->trickles_opt & TCP_TRICKLES_BUFFERDISCARD)) {
trickles.c:3093:		if(TCP_SKB_CB(skb)->seq != tp->rcv_nxt) {
trickles.c:3094:			printk("start sequence not at rcv nxt: %d %d\n", TCP_SKB_CB(skb)->seq, tp->rcv_nxt);
trickles.c:3102:				tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq;
trickles.c:3113:			if(TCP_SKB_CB(skb)->cont) {
trickles.c:3114:				freeClientSide_Continuation(TCP_SKB_CB(skb)->cont);
trickles.c:3115:				TCP_SKB_CB(skb)->cont = NULL;
trickles.c:3117:			__skb_queue_tail(&sk->receive_queue, skb);
trickles.c:3120:			if(atomic_read(&skb_shinfo(skb)->dataref) > 2) {
trickles.c:3124:			tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq;
trickles.c:3126:			if(tp->rcv_nxt > (sk->rcvbuf + tp->copied_seq + (sk->rcvbuf >> 2))) {
trickles.c:3128:					printk("exceeded constraint on rcvbuf by %d\n", tp->rcv_nxt - (sk->rcvbuf + tp->copied_seq));
trickles.c:3133:		gNumReceivedBytes += TCP_SKB_CB(skb)->end_seq - tp->rcv_nxt;
trickles.c:3134:		tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq;
trickles.c:3135:		SKBStat_update(&gReceivedSKBStat, skb, skb->data - skb->head);
trickles.c:3136:		if(atomic_read(&skb->users) > 1) {
trickles.c:3137:			printk("Buffer discarding %p, refcnt = %d\n", skb, atomic_read(&skb->users));
trickles.c:3142:	if((int)tp->rcv_nxt < 0) {
trickles.c:3143:		printk("rcv_nxt = %d\n", tp->rcv_nxt);
trickles.c:3148:	if(tp->t.byteReqNext < tp->t.byteRcvNxt) {
trickles.c:3149:		tp->t.byteReqNext = tp->t.byteRcvNxt;
trickles.c:3154:	if(skb->h.th->fin) {
trickles.c:3162:		sk->data_ready(sk, 0);
trickles.c:3177:	TCP_SKB_CB(newSkb)->cont = copyClientSide_Continuation(TCP_SKB_CB(newSkb)->cont, GFP_ATOMIC); \
trickles.c:3178:	if(TCP_SKB_CB(newSkb)->cont == NULL) {				\
trickles.c:3192:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:3193:	CONTINUATION_TYPE *cont = TCP_SKB_CB(skb)->cont;
trickles.c:3194:	TCP_SKB_CB(skb)->cont = NULL;
trickles.c:3195:	unsigned transportSeq = cont->seq;
trickles.c:3208:		alloc_head_reverse_walk(&tp->t.cont_list, cont) {
trickles.c:3209:			if(cont->seq == tp->t.rcv_nxt) {
trickles.c:3213:				if(cont->parentMSK) {
trickles.c:3214:					cont->parentMSK->numChildrenReceived++;
trickles.c:3229:	  (cont->ucont_len > 0 && skb->len > 0) ||
trickles.c:3230:	   TCP_SKB_CB(skb)->parent >= tp->t.request_rcv_nxt;
trickles.c:3233:		int isSynack = skb->h.th->syn && skb->h.th->ack;
trickles.c:3236:					    TCP_SKB_CB(skb)->parent,
trickles.c:3237:					    TCP_SKB_CB(skb)->numSiblings,
trickles.c:3238:					    TCP_SKB_CB(skb)->position);
trickles.c:3248:	   level sequence numbers and UC-level request numbers is
trickles.c:3252:	// 0810 was cont->ucont_len instead of tcp_cb->cont->ucont_len
trickles.c:3254:	TCP_SKB_CB(skb)->dbg = __LINE__;
trickles.c:3261:		int overhead = skb->tail - skb->head;
trickles.c:3278:		removeObsoleteDataRequestMaps(sk, transportSeq);  // moved out of data-only path, so that it executes unconditionally
trickles.c:3283:	removeObsoleteDataRequestMaps(sk, transportSeq);  // moved out of data-only path, so that it executes unconditionally
trickles.c:3299:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:3300:	struct alloc_head_list *skiplist = &tp->t.skipList;
trickles.c:3301:	unsigned rcvnxt = tp->t.byteRcvNxt;
trickles.c:3305:	struct SkipCell *head = (struct SkipCell *)skiplist->next;
trickles.c:3306:	if(rcvnxt == head->start) {
trickles.c:3317:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:3318:	struct alloc_head_list *skiplist = &tp->t.skipList;
trickles.c:3320:	struct SkipCell *head = (struct SkipCell *)skiplist->next;
trickles.c:3322:	unsigned target = head->end;
trickles.c:3323:	unsigned skippedAmount = target - tp->t.byteRcvNxt;
trickles.c:3324:	tp->t.byteRcvNxt = target;
trickles.c:3325:	tp->t.byteSkipHintAmount -= skippedAmount;
trickles.c:3326:	BUG_TRAP(tp->t.byteSkipHintAmount >= 0);
trickles.c:3339:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:3341:	// Check for non-data chunk
trickles.c:3342:	struct ResponseChunk *rchunk = (struct ResponseChunk *)outerSKB->data;
trickles.c:3343:	if(outerSKB->len == 0) {
trickles.c:3344:		//printk("%d: len == 0, rcv_nxt = %d, syn = %d ack = %d\n", (int)jiffies, tp->rcv_nxt, outerSKB->h.th->syn, outerSKB->h.th->ack);
trickles.c:3345:		return -1;
trickles.c:3347:	if(outerSKB->len < sizeof(*rchunk)) {
trickles.c:3351:		return -1;
trickles.c:3353:	if(!IS_VALID_CHUNKTYPE(rchunk->type)) {
trickles.c:3355:			printk("Invalid chunktype %d\n", rchunk->type);
trickles.c:3357:		return -1;
trickles.c:3359:	if(rchunk->type == RCHUNK_PUSH_HINT) {
trickles.c:3362:		int chunk_len = ntohs(phchunk->chunkLen);
trickles.c:3366:		int start = ntohl(phchunk->start),
trickles.c:3367:			end = ntohl(phchunk->end);
trickles.c:3368:		printk("Hint is [%d-%d]\n", start, end);
trickles.c:3369:		if(start <= tp->t.byteReqNext && tp->t.byteReqNext < end) {
trickles.c:3370:			printk("Adjusting byteReqNext: %d => %d\n", tp->t.byteReqNext, end);
trickles.c:3371:			tp->t.byteReqNext = end;
trickles.c:3379:		int overhead = TCP_SKB_CB(outerSKB)->numDataChunks * sizeof(struct DataChunk) + outerSKB->data - outerSKB->head;
trickles.c:3382:		for(fragnum = 0; fragnum < TCP_SKB_CB(outerSKB)->numDataChunks;
trickles.c:3389:			       TCP_SKB_CB(skb)->numDataChunks,
trickles.c:3390:			       TCP_SKB_CB(skb)->byteNum,
trickles.c:3391:			       TCP_SKB_CB(skb)->byteNum + skb->len);
trickles.c:3394:#if 0 // 0901 -- after factoring out thies function, this sanity check can no longer be performed
trickles.c:3395:			if(!(IMPLIES(tp->t.ack_prev != NULL, tp->t.ack_prev != cont))) {
trickles.c:3396:				BUG_TRAP(IMPLIES(tp->t.ack_prev != NULL, tp->t.ack_prev != cont));
trickles.c:3397:				printk("tp->t.ack_prev->list = %p\n", tp->t.ack_prev->list);
trickles.c:3402:			if(skb->len == 0) {
trickles.c:3411:			if(TCP_SKB_CB(skb)->byteNum > tp->t.byteRcvNxt) {
trickles.c:3416:				TCP_SKB_CB(skb)->seq = TCP_SKB_CB(skb)->byteNum;
trickles.c:3417:				TCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(skb)->seq + skb->len;
trickles.c:3418:				//printk("end_seq = %d\n", TCP_SKB_CB(skb)->end_seq);
trickles.c:3419:				if(skb_peek(&tp->t.data_ofo_queue)) {
trickles.c:3420:					finger = tp->t.data_ofo_queue.prev;
trickles.c:3424:						if(TCP_SKB_CB(finger)->seq < TCP_SKB_CB(skb)->seq)
trickles.c:3426:					} while((struct sk_buff_head*)(finger=finger->prev) != &tp->t.data_ofo_queue);
trickles.c:3428:					finger = (struct sk_buff *)&tp->t.data_ofo_queue;
trickles.c:3430:				next = finger->next;
trickles.c:3431:				if(finger != (struct sk_buff*)&tp->t.data_ofo_queue) {
trickles.c:3432:					int slack = TCP_SKB_CB(finger)->end_seq - TCP_SKB_CB(skb)->seq;
trickles.c:3434:						if(slack >= skb->len) {
trickles.c:3435:							RECORD_OVERLAP(0, skb->len);
trickles.c:3447:							TCP_SKB_CB(skb)->seq += slack;
trickles.c:3455:				if(next != (struct sk_buff*)&tp->t.data_ofo_queue) {
trickles.c:3456:					int slack = TCP_SKB_CB(skb)->end_seq - TCP_SKB_CB(next)->seq;
trickles.c:3458:						if(slack >= next->len) {
trickles.c:3459:							RECORD_OVERLAP(2, next->len);
trickles.c:3461:							__skb_unlink(next, &tp->t.data_ofo_queue);
trickles.c:3462:							if(tp->t.byteReqHint == next)
trickles.c:3463:								tp->t.byteReqHint = NULL;
trickles.c:3472:							TCP_SKB_CB(next)->seq += slack;
trickles.c:3480:				__skb_insert(skb, finger, finger->next, &tp->t.data_ofo_queue);
trickles.c:3485:			if(TCP_SKB_CB(skb)->byteNum < tp->t.byteRcvNxt) {
trickles.c:3486:				int slack = tp->t.byteRcvNxt - TCP_SKB_CB(skb)->byteNum;
trickles.c:3487:				if(slack >= skb->len) {
trickles.c:3489:						printk("ByteNum < tp->t.byteRcvNxt and no overlap; discarding\n");
trickles.c:3490:					RECORD_OVERLAP(6,skb->len);
trickles.c:3497:					TCP_SKB_CB(skb)->byteNum += slack;
trickles.c:3500:			if(skb->len == 0) {
trickles.c:3505:			BUG_TRAP(TCP_SKB_CB(skb)->byteNum == tp->t.byteRcvNxt);
trickles.c:3506:			TCP_SKB_CB(skb)->seq = tp->t.byteRcvNxt;
trickles.c:3507:			TCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(skb)->seq + skb->len;
trickles.c:3508:			//printk("end_seq = %d\n", TCP_SKB_CB(skb)->end_seq);
trickles.c:3516:				BUG_TRAP(skb->len > 0);
trickles.c:3518:				// at this point, tcb->seq and ->end_seq are in tp->rcv_nxt units
trickles.c:3519:				if(TCP_SKB_CB(skb)->seq == 9998936) {
trickles.c:3522:				TCP_SKB_CB(skb)->seq = tp->rcv_nxt;
trickles.c:3523:				TCP_SKB_CB(skb)->end_seq = 
trickles.c:3524:					TCP_SKB_CB(skb)->seq + skb->len;
trickles.c:3527:				tp->t.byteRcvNxt += skb->len;
trickles.c:3532:				if(tp->t.byteReqHint == skb)
trickles.c:3533:					tp->t.byteReqHint = NULL;
trickles.c:3535:				while((skb = skb_peek(&tp->t.data_ofo_queue))) {
trickles.c:3536:					if(TCP_SKB_CB(skb)->seq > tp->t.byteRcvNxt) {
trickles.c:3539:					__skb_unlink(skb, &tp->t.data_ofo_queue);
trickles.c:3540:					if(tp->t.byteReqHint == skb)
trickles.c:3541:						tp->t.byteReqHint = NULL;
trickles.c:3543:					if(TCP_SKB_CB(skb)->end_seq <= tp->t.byteRcvNxt) {
trickles.c:3545:							printk("IN SEQUENCE WHOLE PACKET REMOVED: %d\n", skb->len);
trickles.c:3546:						RECORD_OVERLAP(7,skb->len);
trickles.c:3549:						int slack = tp->t.byteRcvNxt - TCP_SKB_CB(skb)->seq;
trickles.c:3552:						TCP_SKB_CB(skb)->seq += slack;
trickles.c:3553:						BUG_TRAP(TCP_SKB_CB(skb)->seq == tp->t.byteRcvNxt &&
trickles.c:3554:							 skb->len > 0);
trickles.c:3567:			// 0505 - moved to common code path
trickles.c:3573:		return -1;
trickles.c:3586:			printk("Bad data len (%d), ignoring for data purposes @ chunkno = %d lineno = %d %d-%d\n",
trickles.c:3587:			       in_skb->h.th->ack_seq, chunkNum, TCP_SKB_CB(in_skb)->dbg,
trickles.c:3588:			       in_skb->data - in_skb->head, in_skb->tail - in_skb->head);
trickles.c:3598:	//printk("Chunk(%d) at %d, %d %d\n", ntohs(currChunk->chunkLen), (char*)curr_skb->data - ucont_start,  (char*) (currChunk+1) - ucont_start, origTail - ucont_start);
trickles.c:3599:	curr_skb->data = currChunk->data;
trickles.c:3600:	curr_skb->tail = curr_skb->data + dataLen;
trickles.c:3601:	curr_skb->len = dataLen;
trickles.c:3602:	TCP_SKB_CB(curr_skb)->byteNum =
trickles.c:3603:		htonl(currChunk->byteNum);
trickles.c:3604:	TCP_SKB_CB(curr_skb)->toSkip = 0;
trickles.c:3605:	TCP_SKB_CB(curr_skb)->skipPosition = 0xffffffff;
trickles.c:3612:	struct sock *sk = in_skb->sk;
trickles.c:3613:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:3615:		in_skb->data, *prevChunk = NULL;
trickles.c:3616:	char *origTail = in_skb->tail;
trickles.c:3617:	char *origDataStart = in_skb->data;
trickles.c:3618:	int origLen = in_skb->len;
trickles.c:3619:	//BUG_TRAP(currChunk->type == RCHUNK_DATA);
trickles.c:3622:			printk("currChunk->type = %d, len = %d\n", currChunk->type, ntohs(currChunk->chunkLen));
trickles.c:3626:	TCP_SKB_CB(in_skb)->numDataChunks = 0;
trickles.c:3630:		in_skb->data = in_skb->tail;
trickles.c:3631:		in_skb->len = 0;
trickles.c:3632:		TCP_SKB_CB(in_skb)->numDataChunks = 0;
trickles.c:3643:			switch(currChunk->type) {
trickles.c:3653:				unsigned byteNum = ntohl(dc->byteNum);
trickles.c:3655:				if(dc->flags & DCHUNK_FIN) {
trickles.c:3656:					unsigned finByte = byteNum + curr_skb->len;
trickles.c:3667:					TCP_SKB_CB(curr_skb)->toSkip = 1;
trickles.c:3668:					TCP_SKB_CB(curr_skb)->skipPosition = 
trickles.c:3669:						cont->validEnd;
trickles.c:3672:					insert_tail(&tp->t.contFINList, 
trickles.c:3684:				unsigned len = ntohl(sc->len);
trickles.c:3685:				unsigned byteNum = ntohl(sc->byteNum);
trickles.c:3698:				unsigned hintPosition = ntohl(shc->byteNum);
trickles.c:3706:					SkipCell_new(hintPosition, cont->validEnd);
trickles.c:3724:			       curr_skb, TCP_SKB_CB(curr_skb)->numDataChunks);
trickles.c:3734:		if((char*)(currChunk-1) >= origTail) {
trickles.c:3735:			int dumpLen = (char*)origTail - (char*)currChunk;
trickles.c:3739:				       prevChunk != NULL ? 0xdeadbeef : // prevChunk->chunkID :
trickles.c:3741:			       -1,
trickles.c:3742:			       in_skb->h.th->ack_seq, chunkNum, origLen, (char*)currChunk - origDataStart);
trickles.c:3745:		TCP_SKB_CB(in_skb)->numDataChunks = chunkNum;
trickles.c:3747:		//printk("%p: NumDataChunks = %d\n", in_skb, TCP_SKB_CB(in_skb)->numDataChunks);
trickles.c:3751:	//printk("in_skb: byteNum = %d, len = %d\n", TCP_SKB_CB(in_skb)->byteNum, in_skb->len);
trickles.c:3754:	return TCP_SKB_CB(in_skb)->numDataChunks;
trickles.c:3756:	return -1;
trickles.c:3763:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:3766:	if(ofo_entry->parent == TRANSPORT_OR_DATA_ONLY_REQNUM) {
trickles.c:3769:		return -1;
trickles.c:3771:	BUG_TRAP(ofo_entry->parent != TRANSPORT_ONLY_REQNUM);
trickles.c:3774:	if(ofo_entry->parent == tp->t.request_rcv_nxt) {
trickles.c:3776:			// process formerly out of order continuations that are now in-order
trickles.c:3777:			CONTINUATION_TYPE *cont = ofo_entry->cont;
trickles.c:3782:			//printk("post update, ucontlist = %d\n", tp->t.ucontList.len);
trickles.c:3784:			// deallocation of skb->cont must occur after references in the above block
trickles.c:3785:			BUG_TRAP(tp->t.ack_prev != cont); // 0429 track down corruption error
trickles.c:3788:			if(empty(&tp->t.request_ofo_queue)) {
trickles.c:3791:			ofo_entry = (struct RequestOFOEntry *)tp->t.request_ofo_queue.next;
trickles.c:3792:			if(ofo_entry->parent != tp->t.request_rcv_nxt) {
trickles.c:3802:		BUG_TRAP(ofo_entry->parent > tp->t.request_rcv_nxt);
trickles.c:3803:		if(empty(&tp->t.request_ofo_queue)) {
trickles.c:3804:			insert_head((struct alloc_head_list*)&tp->t.request_ofo_queue,
trickles.c:3807:			finger = (struct RequestOFOEntry *)tp->t.request_ofo_queue.prev;
trickles.c:3809:				if(finger->parent < ofo_entry->parent)
trickles.c:3811:			} while((struct alloc_head_list*)(finger=finger->prev) != &tp->t.request_ofo_queue);
trickles.c:3812:			if(finger->next != (struct RequestOFOEntry*)&tp->t.request_ofo_queue) {
trickles.c:3813:				if( ((struct RequestOFOEntry*)finger->next)->parent == ofo_entry->parent) {
trickles.c:3819:					  finger->next)->parent >
trickles.c:3820:					 ofo_entry->parent);
trickles.c:3824:			       (struct alloc_head*)finger->next);
trickles.c:3835:	__u32 seq = cont->seq;
trickles.c:3836:	int *numSacks = &ackProof->numSacks;
trickles.c:3837:	Sack *sacks = ackProof->sacks;
trickles.c:3838:	for(i=0; i < *numSacks && (seq >= sacks[i].left || seq == sacks[i].left - 1); i++) {
trickles.c:3840:		if(seq == sacks[i].left - 1) {
trickles.c:3842:			sacks[i].nonceSummary ^= cont->cum_nonce;
trickles.c:3843:			if(i > 0 && sacks[i-1].right == sacks[i].left - 1) {
trickles.c:3847:				sacks[i-1].right = sacks[i].right;
trickles.c:3848:				sacks[i-1].nonceSummary ^= sacks[i].nonceSummary;
trickles.c:3850:					sacks[j - 1] = sacks[j];
trickles.c:3852:				(*numSacks)--;
trickles.c:3857:			sacks[i].nonceSummary ^= cont->cum_nonce;
trickles.c:3858:			if(i + 1 < *numSacks && sacks[i].right == sacks[i+1].left - 1) {
trickles.c:3863:					sacks[j - 1] = sacks[j];
trickles.c:3865:				(*numSacks)--;
trickles.c:3878:	/* seq is between i-1 and i; shift upwards all sacks i and up */
trickles.c:3879:	for(j=MIN(*numSacks, MAX_KERNEL_SACKS-1); j > i; j--) {
trickles.c:3880:		sacks[j] = sacks[j-1];
trickles.c:3883:	sacks[i].nonceSummary = cont->cum_nonce;
trickles.c:3886:	BUG_TRAP(i == *numSacks-1 || (sacks[i].right != sacks[i+1].left - 1 &&
trickles.c:3888:	BUG_TRAP(i == 0 || (sacks[i-1].right != sacks[i].left - 1 &&
trickles.c:3889:			    sacks[i-1].right < sacks[i].left));
trickles.c:3897:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:3899:	struct sk_buff *skb = skb_peek(&tp->t.ofo_queue);
trickles.c:3901:	// 0419 special case - if ack_curr is set (due to recovery), we've already made progress in finding an ackable continuation
trickles.c:3903:	// 0501 - don't call findAckable when exiting recovery
trickles.c:3904:	if(tp->t.ack_prev == NULL && tp->t.cont_list.len >= 1) {
trickles.c:3910:	if(tp->t.ack_last < tp->t.rcv_nxt) {
trickles.c:3911:		tp->t.ack_last = tp->t.rcv_nxt;
trickles.c:3916:			while((struct sk_buff_head*)skb != &tp->t.ofo_queue &&
trickles.c:3917:			      TCP_SKB_CB(skb)->trickle_seq < tp->t.ack_last) {
trickles.c:3918:				skb = skb->next;
trickles.c:3920:			if((struct sk_buff_head*)skb == &tp->t.ofo_queue) return 0 /* no progress*/;
trickles.c:3922:				printk("ack_last skipped over gap: %u - %u\n",
trickles.c:3923:				       (struct sk_buff_head*)skb->prev != &tp->t.ofo_queue ?
trickles.c:3924:				       TCP_SKB_CB(skb->prev)->trickle_seq :
trickles.c:3925:				       tp->t.rcv_nxt - 1, TCP_SKB_CB(skb)->trickle_seq);
trickles.c:3926:			tp->t.ack_last = TCP_SKB_CB(skb)->trickle_seq + 1;
trickles.c:3930:		while((struct sk_buff_head*)skb != &tp->t.ofo_queue &&
trickles.c:3931:		      TCP_SKB_CB(skb)->trickle_seq <= tp->t.ack_last) {
trickles.c:3932:			if(tp->t.ack_last == TCP_SKB_CB(skb)->trickle_seq) {
trickles.c:3933:				tp->t.ack_last++;
trickles.c:3936:			skb = skb->next;
trickles.c:3948:	 struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:3949:	 struct UC_Continuation *ucont = (struct UC_Continuation*)tp->t.ucontList.next,
trickles.c:3954:	 while(ucont != (struct UC_Continuation *)&tp->t.ucontList) {
trickles.c:3955:		 if(ucont->validStart <= start) {
trickles.c:3956:			 if(end <= ucont->validEnd) {
trickles.c:3964:			 } else if(ucont->validEnd > candidate->validEnd) {
trickles.c:3969:		 ucont = (struct UC_Continuation*)ucont->next;
trickles.c:3974:	 while(ucont != (struct UC_Continuation *)&tp->t.ucontList) {
trickles.c:3976:		 printk("Considering %p: [%d-%d]\n", ucont,
trickles.c:3977:			ucont->validStart, ucont->validEnd);
trickles.c:3979:		 int overlapStart = MAX(ucont->validStart, start);
trickles.c:3980:		 int overlapEnd = MIN(ucont->validEnd, end);
trickles.c:3982:		 int curr_overlapSize = overlapEnd - overlapStart;
trickles.c:4015:		 ucont = (struct UC_Continuation*)ucont->next;
trickles.c:4019:	 printk("uc_continuation: [%d-%d] ", start, end);
trickles.c:4028:	 printk("%p [%d-%d]\n", candidate, candidate->validStart,
trickles.c:4029:		candidate->validEnd);
trickles.c:4036:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:4041:	tp->t.responseMSK = cont;
trickles.c:4042:	tp->t.responseCount = 0;
trickles.c:4044:	BUG_TRAP(tp->t.responseList.len == 0);
trickles.c:4045:	init_head(&tp->t.responseList);
trickles.c:4047:	result->h.th = NULL;
trickles.c:4048:	result->nh.iph = NULL;
trickles.c:4053:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:4055:	if(tp->t.responseCount >= 1) {
trickles.c:4058:		BUG_TRAP(simCont == tp->t.responseMSK);
trickles.c:4059:		for(i=0; i < simCont->num_packets; i++) {
trickles.c:4060:			totalDataLen += simCont->packets[i].len;
trickles.c:4061:			simCont->packets[i].contType &= ~CONTTYPE_HASHCOMPRESSED;
trickles.c:4064:#if 0 // 0822 -- use packets directly rather than minresponselen
trickles.c:4065:		destCont->minResponseLen = totalDataLen;
trickles.c:4067:		destCont->minResponseLen = MAX(0, destCont->minResponseLen - MIN_RESPONSELEN_ADJ_HACK);
trickles.c:4070:		destCont->minResponseLen += 200;
trickles.c:4073:		destCont->firstTransportChild = simCont->packets[0].seq;
trickles.c:4074:		destCont->numTransportChildren = simCont->num_packets;
trickles.c:4078:		destCont->minResponseLen = 0;
trickles.c:4080:		destCont->firstTransportChild = 0;
trickles.c:4081:		destCont->numTransportChildren = 0;
trickles.c:4082:		destCont->mark = -1;
trickles.c:4084:	finger = (CONTINUATION_TYPE*)tp->t.responseList.next;
trickles.c:4085:	while(finger != (CONTINUATION_TYPE*)&tp->t.responseList) {
trickles.c:4086:		printk("responseListlen = %d\n", tp->t.responseList.len);
trickles.c:4087:		printk("finger=%p (%p  %p)\n", finger, finger->prev, finger->next);
trickles.c:4089:		finger = finger->next;
trickles.c:4095:	destCont->simulated = 1;
trickles.c:4100:	cont->source = sk->sport;
trickles.c:4101:	cont->dest = sk->dport;
trickles.c:4102:	//printk("%d %d\n", cont->source, cont->dest);
trickles.c:4104:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:4106:		printk("recovery simulation of seq = %d, rcvnxt = %d\n", cont->seq, tp->t.rcv_nxt);
trickles.c:4116:	if(rval == -EINVAL) {
trickles.c:4131:		struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:4132:		tp->snd_cwnd = cont->actualCwnd;
trickles.c:4133:		tp->snd_ssthresh = cont->ssthresh;
trickles.c:4144:#define OUT_FREE (-1)
trickles.c:4145:#define OUT_FREE_IGNORE (-2)
trickles.c:4146:#define OUT_NODATAREQUEST (-3)
trickles.c:4184:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:4189:	while((skb=__skb_dequeue(&tp->t.sendAckOverflow))) {
trickles.c:4190:		BUG_TRAP(skb->sk == sk);
trickles.c:4191:		skb->sk = sk;
trickles.c:4192:		if((res = tp->af_specific->queue_xmit(skb, 0)) != 0) {
trickles.c:4197:			__skb_queue_head(&tp->t.sendAckOverflow, skb);
trickles.c:4212:	short windowValue = -1;
trickles.c:4225:	if(cont->state == CONT_BOOTSTRAP ||
trickles.c:4227:		proof = &tp->t.altProof;
trickles.c:4233:		proof = &tp->t.standardProof;
trickles.c:4237:	wreq = (WireTrickleRequest *)skb_put(skb, sizeof(WireTrickleRequest) + proof->numSacks * sizeof(WireSack));
trickles.c:4238:	//printk("sendackhelper - req: %p\n", &req->cont);
trickles.c:4240:	wreq->type = type;
trickles.c:4241:	wreq->ucont_len = 0; // hack to make input to simulation well-formed
trickles.c:4245:	__u32 oldClientTimestamp = cont->clientTimestamp ;
trickles.c:4246:	__u32 oldClientState = cont->clientState;
trickles.c:4247:	cont->clientTimestamp = jiffies;
trickles.c:4248:	cont->clientState = tp->t.clientStateCounter;
trickles.c:4249:	marshallContinuationClient(sk,&wreq->cont,cont, -1);
trickles.c:4252:	cont->numChildrenReceived = 0;
trickles.c:4255:	cont->clientTimestamp = oldClientTimestamp;
trickles.c:4256:	cont->clientState = oldClientState;
trickles.c:4259:	marshallAckProof(&wreq->ackProof, proof);
trickles.c:4264:	((SK)->tp_pinfo.af_tcp.t.byteReqNext < (SK)->tp_pinfo.af_tcp.t.byteRcvNxt + (SK)->tp_pinfo.af_tcp.t.byteSkipHintAmount + (SK)->rcvbuf)
trickles.c:4280:			   !empty(&tp->t.missingDataMap)) {
trickles.c:4298:				if(tp->rcv_nxt > tp->copied_seq) { // only safe if user_ack will reset this bit later
trickles.c:4300:					tp->t.timerState &= ~TRICKLES_ENABLE_DATA_TIMEOUT;
trickles.c:4313:		wreq->ucont_len = htons(0);
trickles.c:4314:		wreq->cont.parent = TRANSPORT_ONLY_REQNUM;
trickles.c:4331:	if(tp->t.eventsPos == 0) {
trickles.c:4334:		struct TricklesLossEvent *lastEvent = &tp->t.events[tp->t.eventsPos - 1];
trickles.c:4335:		if(tp->t.state != lastEvent->state) {
trickles.c:4337:			appendTricklesLossEvent(sk, MIN((cont+1)->mark, EVENT_CWND_MAX),
trickles.c:4338:						EVENT_EXTRA_SEND, tp->t.state);
trickles.c:4339:		}  else if(jiffies - lastEvent->time >= HZ) {
trickles.c:4341:			appendTricklesLossEvent(sk, MIN(tp->t.cont_list.len, EVENT_CWND_MAX),
trickles.c:4342:						EVENT_EXTRA_SAMPLE0, tp->t.state);
trickles.c:4343:			appendTricklesLossEvent(sk, MIN((cont+1)->mark, EVENT_CWND_MAX),
trickles.c:4344:						EVENT_EXTRA_SAMPLE1, tp->t.state);
trickles.c:4348:	skb->csum = 0;
trickles.c:4349:	skb->ip_summed = CHECKSUM_HW;
trickles.c:4350:	skb->sk = sk;
trickles.c:4353:	skb->h.th = th;
trickles.c:4354:	th->source = sk->sport;
trickles.c:4355:	th->dest = sk->dport;
trickles.c:4360:		th->seq = cont->ucont_offset;
trickles.c:4362:		th->seq = -2;
trickles.c:4365:		th->seq = -1;
trickles.c:4371:	th->doff = tcp_header_size >> 2;
trickles.c:4372:	//th->ack = htonl(cont->seq);
trickles.c:4375:	th->window = htons(windowValue);
trickles.c:4376:	th->check = 0;
trickles.c:4377:	th->urg_ptr = 0;
trickles.c:4381:	th->ack = 1;
trickles.c:4382:	th->syn = 0;
trickles.c:4383:	th->fin = 0;
trickles.c:4384:	th->rst = 0;
trickles.c:4386:	th->seq = ENCODE_SIMULATION_RESULT(cont);
trickles.c:4387:	th->ack_seq = packetID;
trickles.c:4392:	trickles_checksum(skb, skb->len);
trickles.c:4397:	if((res = tp->af_specific->queue_xmit(skb, 0)) != 0) {
trickles.c:4405:		__skb_queue_tail(&tp->t.sendAckOverflow, skb);
trickles.c:4410:		//LOG_PACKET_CONT(sk, -1, cont);
trickles.c:4414:	skb->nh.iph = (struct iphdr*)skb_push(skb, sizeof(struct iphdr));
trickles.c:4415:	skb->nh.iph->daddr = sk->daddr;
trickles.c:4416:	skb->nh.iph->saddr = sk->saddr;
trickles.c:4447:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:4454:	   MUST occur after skb is initialized with transport-level fields!
trickles.c:4466:	struct Request *mreq = (struct Request*)tp->t.queuedRequests.next;
trickles.c:4469:	insert_tail(&tp->t.sentRequests, (struct alloc_head*)mreq);
trickles.c:4470:	mreq->transport_seq = cont->seq;
trickles.c:4471:	if(mreq->isNew) {
trickles.c:4472:		mreq->seq = tp->t.request_snd_nxt;
trickles.c:4473:		tp->t.request_snd_nxt = tp->t.request_snd_nxt + 1; // sequence number is the identifier to match during scoreboard management
trickles.c:4474:		mreq->isNew = 0;
trickles.c:4477:	wreq->cont.parent = mreq->seq;
trickles.c:4480:	switch(mreq->type) {
trickles.c:4489:		if(tp->t.snd_una <= convReq->start) {
trickles.c:4490:			input_skb = convReq->data;
trickles.c:4491:			copyOffset = convReq->offset;
trickles.c:4492:			if(convReq->start != TCP_SKB_CB(input_skb)->seq + copyOffset) {
trickles.c:4496:			if(tp->t.snd_una == tp->t.write_seq) {
trickles.c:4501:			// find input skb corresponding to current snd_una, and adjust convReq->input_skb accordingly
trickles.c:4502:			input_skb = tp->t.requestBytes.next;
trickles.c:4503:			while((struct sk_buff_head *)input_skb != &tp->t.requestBytes) {
trickles.c:4504:				if(TCP_SKB_CB(input_skb)->seq <= tp->t.snd_una &&
trickles.c:4505:				   tp->t.snd_una < TCP_SKB_CB(input_skb)->end_seq) {
trickles.c:4510:			if((struct sk_buff_head *)input_skb == &tp->t.requestBytes) {
trickles.c:4514:			convReq->data = input_skb;
trickles.c:4515:			convReq->start = tp->t.snd_una;
trickles.c:4516:			convReq->offset = copyOffset = convReq->start - TCP_SKB_CB(input_skb)->seq;
trickles.c:4517:			printk("2: start = %d, offset = %d\n", convReq->start, copyOffset);
trickles.c:4518:			convReq->end = tp->t.write_seq;
trickles.c:4520:			BUG_TRAP(convReq->offset >= 0);
trickles.c:4521:			BUG_TRAP(convReq->end > convReq->start);
trickles.c:4527:		if(convReq->incomplete) {
trickles.c:4535:			contLen = convReq->predLength;
trickles.c:4536:			skb_put(skb, contLen - sizeof(wInConvReq->predCont));
trickles.c:4537:			memcpy(&wInConvReq->predCont, convReq->incompletePred, contLen);
trickles.c:4538:			wInConvReq->type = UC_INCOMPLETE;
trickles.c:4539:			outContLen = (char*)skb_put(skb, 0) - (char*)wInConvReq;
trickles.c:4541:			wInConvReq->len = wlen;
trickles.c:4542:			wInConvReq->seq =
trickles.c:4543:				htonl(TCP_SKB_CB(input_skb)->seq + copyOffset);
trickles.c:4550:			contLen = marshallUC_Continuation(&wConvReq->predCont,
trickles.c:4551:							  convReq->completePred);
trickles.c:4552:			printk("generating complete request from "); UC_Continuation_dump(convReq->completePred);
trickles.c:4553:			if(tp->t.prevConvCont) { printk("prev is "); UC_Continuation_dump(tp->t.prevConvCont); };
trickles.c:4555:			skb_put(skb, contLen - sizeof(wConvReq->predCont));
trickles.c:4556:			wConvReq->type = UC_COMPLETE;
trickles.c:4557:			outContLen = (char*)skb_put(skb, 0) - (char*)wConvReq;
trickles.c:4559:			wConvReq->len = wlen;
trickles.c:4560:			wConvReq->seq =
trickles.c:4561:				htonl(TCP_SKB_CB(input_skb)->seq + copyOffset);
trickles.c:4568:		wreq->ucont_len = wlen;
trickles.c:4570:		copyLen = MIN(TRICKLES_MSS - outContLen, tp->t.write_seq - convReq->start);
trickles.c:4574:		convReq->end = convReq->start + copyLen;
trickles.c:4577:		tp->t.snd_end = convReq->end;
trickles.c:4582:			printk("ReqType = %d CopyLen == 0\n", mreq->type);
trickles.c:4585:			unsigned pieceLen = MIN(input_skb->len - copyOffset, copyLen);
trickles.c:4586:			memcpy(skb_put(skb, pieceLen), input_skb->data + copyOffset, pieceLen);
trickles.c:4588:			copyLen -= pieceLen;
trickles.c:4589:			input_skb = input_skb->next;
trickles.c:4604:		unsigned numContinuations = updateReq->numConts;
trickles.c:4608:		wUpdateReq->newStart = htonl(updateReq->start);
trickles.c:4609:		wUpdateReq->newEnd = htonl(updateReq->end);
trickles.c:4610:		wUpdateReq->numContinuations = (__u8)numContinuations;
trickles.c:4615:			contLen = marshallUC_Continuation((struct WireUC_Continuation*)skb_put(skb, 0), updateReq->conts[i]);
trickles.c:4621:		wUpdateReq->type = UC_UPDATE;
trickles.c:4622:		wUpdateReq->len = htons((short)(sizeof(*wUpdateReq) + totalLen));
trickles.c:4623:		wreq->ucont_len = wUpdateReq->len;
trickles.c:4631:	mreq->transportResponseSeqStart = cont->firstTransportChild;
trickles.c:4632:	mreq->transportResponseSeqEnd =
trickles.c:4633:		mreq->transportResponseSeqStart + cont->numTransportChildren;
trickles.c:4661:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:4673:	   MUST occur after skb is initialized with transport-level fields!
trickles.c:4692:#if 0 // 0822 obsolete due to packet-oriented handling
trickles.c:4693:	if(cont->minResponseLen < USEFULNESS_THRESHOLD) {
trickles.c:4694:		BUG_TRAP(cont->minResponseLen == 0);
trickles.c:4695:		//printk("minResponseLen = %d\n", cont->minResponseLen);
trickles.c:4700:	unsigned tseq_start = cont->firstTransportChild,
trickles.c:4701:		tseq_end = tseq_start + cont->numTransportChildren;
trickles.c:4702:	BUG_TRAP(tseq_start != -1 && tseq_end != -1);
trickles.c:4705:	if(cont->minResponseLen <= 0) {
trickles.c:4706:		printk("simulation responseLen: %d\n", cont->minResponseLen);
trickles.c:4711:	wreq->cont.parent = DATA_ONLY_REQNUM;
trickles.c:4712:	wDataReq->type = UC_DATA;
trickles.c:4713:	wDataReq->len = -1;
trickles.c:4726:	if(!(maxResponseLen <= cont->minResponseLen)) {
trickles.c:4727:		BUG_TRAP(maxResponseLen <= cont->minResponseLen);
trickles.c:4728:		printk("0: %d < %d\n", maxResponseLen, cont->minResponseLen);
trickles.c:4734:		//printk("0: request used %d, %d left\n", cont->minResponseLen - maxResponseLen, maxResponseLen);
trickles.c:4748:			tp->t.timerState |= TRICKLES_NEED_USERACK;
trickles.c:4754:			printk("1: request used %d, %d left (%d,%d)\n", cont->minResponseLen - maxResponseLen, maxResponseLen,
trickles.c:4766:	numMissingRequests = -1;
trickles.c:4771:	if(maxResponseLen > cont->minResponseLen) {
trickles.c:4772:		printk("1(bug): %d < %d\n", maxResponseLen, cont->minResponseLen);
trickles.c:4778:	wDataReq->numRequestRanges = numRequests;
trickles.c:4781:		WIREUC_DATAREQUEST_SIZE(wDataReq->numRequestRanges);
trickles.c:4782:	wDataReq->len = htons(wDataReqLen);
trickles.c:4785:	if(wDataReq->numRequestRanges) {
trickles.c:4799:		wreq->ucont_len = htons(outContLen);
trickles.c:4800:		BUG_TRAP(dreq_ucont->validStart <= dreq_ucont->validEnd);
trickles.c:4804:			BUG_TRAP(ntohl(wucont->validStart) <= ntohl(wucont->validEnd));
trickles.c:4807:			cont->ucont_offset = (char*)ptr - (char*)wreq;
trickles.c:4809:			//printk("ucont offset = %d\n", cont->ucont_offset);
trickles.c:4815:			printk("no recovery data request -- ucontlist len = %d, num response packets = %d\n", tp->t.ucontList.len, SIMULATION_NUM_PACKETS(cont));
trickles.c:4835:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:4837:	 finger = (struct DataRequestMapping*)tp->t.dataRequestMap.prev;
trickles.c:4839:	 insert_tail(&tp->t.dataRequestMap, (struct alloc_head*)dataReqMap);
trickles.c:4841:	 dataReqMap->sent = 1;
trickles.c:4842:	 BUG_TRAP(dataReqMap->start < dataReqMap->end);
trickles.c:4844:	 //printk("Added data request [%d-%d]\n", dataReqMap->start, dataReqMap->end);
trickles.c:4845:	 if(finger != (struct DataRequestMapping *)&tp->t.dataRequestMap) {
trickles.c:4846:		 if(finger->transportResponseSeqEnd > tseq_start) {
trickles.c:4848:				 printk("WARNING: Out of order continuation transportResponseSeqEnd received (%u %u). Either server or client is buggy\n", finger->transportResponseSeqEnd, tseq_start);
trickles.c:4854:		 return -1;
trickles.c:4858:	 range->start = htonl(dataReqMap->start);
trickles.c:4859:	 range->end = htonl(dataReqMap->end);
trickles.c:4860:	 //printk("Added request %d-%d\n", dataReqMap->start, dataReqMap->end);
trickles.c:4880:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:4889:	      !empty(&tp->t.missingDataMap)) {
trickles.c:4895:		// simulate server-side response to this request
trickles.c:4910:			tp->t.missingDataMap.next;
trickles.c:4911:		struct UC_Continuation *ucont = dataReqMap->ucont;
trickles.c:4914:		int oldStart = dataReqMap->start;
trickles.c:4915:		dataReqMap->start = MIN(MAX(dataReqMap->start, tp->t.byteRcvNxt), dataReqMap->end);
trickles.c:4916:		if(oldStart != dataReqMap->start) {
trickles.c:4919:				       oldStart, dataReqMap->start, dataReqMap->end);
trickles.c:4933:		if(dataReqMap->end - dataReqMap->start > maxLen) {
trickles.c:4934:			unsigned newStart = dataReqMap->start + maxLen;
trickles.c:4936:				newDataRequestMapping(ucont, -1, -1, newStart, dataReqMap->end);
trickles.c:4942:			dataReqMap->end = newStart;
trickles.c:4944:			insert_tail(&tp->t.missingDataMap,
trickles.c:4947:		int actualLen = dataReqMap->end - dataReqMap->start;
trickles.c:4958:		dataReqMap->transportResponseSeqStart = tseq_start;
trickles.c:4959:		dataReqMap->transportResponseSeqEnd = tseq_end;
trickles.c:4961:		//printk("missing dataRequest = [%d,%d]\n", dataReqMap->start, dataReqMap->end);
trickles.c:4980:		       !empty(&tp->t.missingDataMap));
trickles.c:5001:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:5039:		 if(tp->t.byteReqHint) {
trickles.c:5040:			 finger = tp->t.byteReqHint;
trickles.c:5042:			 finger = tp->t.data_ofo_queue.next;
trickles.c:5045:		 while(finger != (struct sk_buff*)&tp->t.data_ofo_queue) {
trickles.c:5046:			 if(SKB_CONTAINS(finger, tp->t.byteReqNext)) {
trickles.c:5047:				 tp->t.byteReqNext = TCP_SKB_CB(finger)->end_seq;
trickles.c:5048:				 if(finger->next != (struct sk_buff*)&tp->t.data_ofo_queue) {
trickles.c:5049:					 gapLen = TCP_SKB_CB(finger->next)->seq - tp->t.byteReqNext;
trickles.c:5051:			 } else if(TCP_SKB_CB(finger)->seq > tp->t.byteReqNext) {
trickles.c:5054:			 finger = finger->next;
trickles.c:5059:		 if(finger != (struct sk_buff *)&tp->t.data_ofo_queue) {
trickles.c:5060:			 tp->t.byteReqHint = finger;
trickles.c:5062:			 tp->t.byteReqHint = NULL;
trickles.c:5069:			 start = tp->t.byteReqNext;
trickles.c:5076:			 printk("skipped from %d to %d\n", tp->t.byteReqNext, 
trickles.c:5077:				ucont->validEnd);
trickles.c:5078:			 unsigned skipAmount = ucont->validEnd - tp->t.byteReqNext;
trickles.c:5079:			 tp->t.byteReqNext = ucont->validEnd;
trickles.c:5080:			 tp->t.byteSkipHintAmount += skipAmount;
trickles.c:5108:		tp->t.byteReqNext = end =
trickles.c:5110:		 int actualLen = end - start;
trickles.c:5112:		 tp->t.byteReqHint = NULL;
trickles.c:5154:			 printk("OrigData: No requests generated %d %d reason = %d top = %d bottom = %d canSendMoreCount = %d noMoreSpaceCount = %d canSendMoreCount - noMoreSpaceCount = %d outOfWindow = %d\n",
trickles.c:5160:				canSendMoreCount - noMoreSpaceCount,
trickles.c:5175:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:5176:	CONTINUATION_TYPE *msk = (CONTINUATION_TYPE *)tp->t.cont_list.next;
trickles.c:5180:	if(msk != (CONTINUATION_TYPE*)&tp->t.cont_list) {
trickles.c:5181:		printk("%d-%d", ((CONTINUATION_TYPE *)tp->t.cont_list.next)->seq,
trickles.c:5182:		       ((CONTINUATION_TYPE *)tp->t.cont_list.prev)->seq);
trickles.c:5185:	alloc_head_walk(&tp->t.cont_list, msk) {
trickles.c:5186:		printk("%d, ", msk->seq);
trickles.c:5193:	//printk("requestSlowStart -- entry\n");
trickles.c:5194:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles.c:5199:	__u32 left, right, lastRcv = tp->t.rcv_nxt - 1;
trickles.c:5202:	tp->t.timerState &= ~TRICKLES_NEED_SLOWSTART;
trickles.c:5204:		printk("  client: slow start acking %u, tp->rcv_nxt = %u, tp->t.byteRcvNxt = %u, tp->copied_seq = %u\n", tp->t.rcv_nxt - 1, tp->rcv_nxt, tp->t.byteRcvNxt, tp->copied_seq);
trickles.c:5207:	right = AckProof_findRight(&tp->t.altProof, lastRcv);
trickles.c:5208:	left = AckProof_findLeft(&tp->t.altProof, lastRcv);
trickles.c:5211:		BUG_TRAP(right != tp->t.rcv_nxt - 1);
trickles.c:5212:		printk("right (%u) != tp->t.rcv_nxt - 1 (%u)\n", right, tp->t.rcv_nxt - 1);
trickles.c:5213:		AckProof_dump(&tp->t.altProof;
trickles.c:5219:			AckProof_dump(&tp->t.altProof);
trickles.c:5222:	alloc_head_reverse_walk(&tp->t.cont_list, curr_cont) {
trickles.c:5223:		if(left <= curr_cont->TCPBase && curr_cont->TCPBase <= right) {
trickles.c:5228:		if(left > curr_cont->TCPBase) leftViolation++;
trickles.c:5229:		if(right < curr_cont->TCPBase) rightViolation++;
trickles.c:5230:		if(curr_cont->TCPBase > tp->t.previous_base) {
trickles.c:5240:				printk("%p: Could not find acceptable msk in requestSlowStart, contlist len = %d, left violations %d, right violations %d\n", sk, tp->t.cont_list.len, leftViolation, rightViolation);
trickles.c:5244:	  printk("using cont %u, base = %u, left = %u right = %u\n", msk->seq, msk->TCPBase, left, right);
trickles.c:5245:	BUG_TRAP(msk != (CONTINUATION_TYPE*)&tp->t.cont_list);
trickles.c:5246:	skb = tp->t.ofo_queue.next;
trickles.c:5249:	while(skb != (struct sk_buff*)&tp->t.ofo_queue) {
trickles.c:5251:		skb = skb->next;
trickles.c:5252:		__skb_unlink(prev, &tp->t.ofo_queue);
trickles.c:5255:		TCP_SKB_CB(skb)->dbg = __LINE__;
trickles.c:5266:		BUG_TRAP(TCP_SKB_CB(prev)->cont->list == NULL); // 0430 tracking down corruption bug
trickles.c:5267:		MARK_PC(TCP_SKB_CB(prev)->cont);
trickles.c:5270:	clean = (CONTINUATION_TYPE*)tp->t.cont_list.next;
trickles.c:5271:	while(clean != (CONTINUATION_TYPE*)&tp->t.cont_list) {
trickles.c:5273:		clean = clean->next;
trickles.c:5285:	for(mreq = (struct Request*)tp->t.sentRequests.prev;
trickles.c:5286:	    mreq != (struct Request*)&tp->t.sentRequests;
trickles.c:5288:		prev = (struct Request*)mreq->prev;
trickles.c:5293:		BUG_TRAP(!mreq->isNew);
trickles.c:5297:		insert_head(&tp->t.queuedRequests, (struct alloc_head*)mreq);
trickles.c:5303:			&tp->t.dataRequestMap,
trickles.c:5304:			&tp->t.missingDataMap};
trickles.c:5307:			for(dataReq = (struct DataRequestMapping *)currList->next;
trickles.c:5310:				nextDataReq = dataReq->next;
trickles.c:5316:		tp->t.byteReqNext = tp->t.byteRcvNxt;
trickles.c:5317:		tp->t.byteReqHint = NULL;
trickles.c:5320:	tp->t.ack_prev = msk;
trickles.c:5321:	INTEGRITY_CHECK(sk, tp->t.ack_prev);
trickles.c:5324:	tp->t.ack_last = tp->t.ack_prev->seq + 1;
trickles.c:5325:	if(!(!tp->t.ack_prev || tp->t.ack_prev->next)) {
trickles.c:5327:		BUG_TRAP(!tp->t.ack_prev || tp->t.ack_prev->next);
trickles.c:5332:	while((skb = __skb_dequeue(&tp->t.sendAckOverflow))) {
trickles.c:5337:	appendTricklesLossEvent(sk, MIN(tp->t.ack_prev->startCwnd, EVENT_CWND_MAX),
trickles.c:5338:				-3, tp->t.state);
trickles.c:5340:	//printk("requestSlowStart -- calling sendAck\n");
trickles.c:5341:	sendAckHelper(sk,tp->t.ack_prev,TREQ_SLOWSTART);
trickles.c:5353:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles.c:5354:	if(timer_pending(&tp->t.slowstart_timer)) {
trickles.c:5356:		if(del_timer(&tp->t.slowstart_timer)) {
trickles.c:5374:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles.c:5375:	struct alloc_head_list *lists[] = {&tp->t.sentRequests, &tp->t.queuedRequests};
trickles.c:5376:	struct alloc_head_list *dataRequestLists[] = {&tp->t.dataRequestMap, &tp->t.missingDataMap};
trickles.c:5389:	if(!(tp->trickles_opt & TCP_TRICKLES_ENABLE)) {
trickles.c:5396:		schedule_work((struct work_struct *)(tp->cminisock_api_config.cfg.ctl + 1));
trickles.c:5404:	while((skb=__skb_dequeue(&tp->t.ofo_queue))!=NULL) {
trickles.c:5405:		if(TCP_SKB_CB(skb)->cont)
trickles.c:5406:			MARK_PC(TCP_SKB_CB(skb)->cont);
trickles.c:5411:	while(!empty(&tp->t.request_ofo_queue)) {
trickles.c:5413:			tp->t.request_ofo_queue.next;
trickles.c:5414:		BUG_TRAP(entry != (struct RequestOFOEntry *)&tp->t.request_ofo_queue);
trickles.c:5419:	while((skb=__skb_dequeue(&tp->t.data_ofo_queue))!=NULL) {
trickles.c:5423:		if(atomic_read(&skb_shinfo(skb)->dataref) > 2) {
trickles.c:5427:			while(atomic_read(&skb_shinfo(skb)->dataref) >= 2) {
trickles.c:5438:	while((skb=__skb_dequeue(&tp->t.prequeueOverflow))) {
trickles.c:5442:	while((skb=__skb_dequeue(&tp->t.sendAckOverflow))) {
trickles.c:5446:	while((skb=__skb_dequeue(&tp->t.recycleList))) {
trickles.c:5452:	cont = (CONTINUATION_TYPE *)tp->t.cont_list.next;
trickles.c:5456:		printk("conts cleaned: %d\n", cleanNum += tp->t.cont_list.len);
trickles.c:5460:	while(cont != (CONTINUATION_TYPE*)&tp->t.cont_list) {
trickles.c:5462:		cont = cont->next;
trickles.c:5471:		for(req = (struct Request*)list->next; req != (struct Request*)list;) {
trickles.c:5473:			req = (struct Request*)req->next;
trickles.c:5482:		for(mapping  = (struct DataRequestMapping*)list->next;
trickles.c:5485:			mapping = mapping->next;
trickles.c:5491:	if(tp->t.newIncompleteRequest) {
trickles.c:5492:		freeRequest((struct Request*)tp->t.newIncompleteRequest);
trickles.c:5493:		tp->t.newIncompleteRequest = NULL;
trickles.c:5495:	if(tp->t.prevConvCont) {
trickles.c:5497:		kfree(tp->t.prevConvCont);
trickles.c:5498:		tp->t.prevConvCont = NULL;
trickles.c:5501:	for(ucont = (struct UC_Continuation*)tp->t.ucontList.next;
trickles.c:5502:	    ucont != (struct UC_Continuation*)&tp->t.ucontList;) {
trickles.c:5504:		ucont = (struct UC_Continuation*)ucont->next;
trickles.c:5507:	for(depNode = (struct UC_DependencyNode*)tp->t.depNodeList.next;
trickles.c:5508:	    depNode != (struct UC_DependencyNode*)&tp->t.depNodeList;) {
trickles.c:5510:		depNode = (struct UC_DependencyNode*)depNode->next;
trickles.c:5511:		vector_free(&depNode->depLinks);
trickles.c:5516:	for(sc = (struct SkipCell *) tp->t.skipList.next;
trickles.c:5517:	    sc != (struct SkipCell *) &tp->t.skipList;	) {
trickles.c:5519:		sc = (struct SkipCell *) sc->next;
trickles.c:5526:	if((tp->trickles_opt & TCP_TRICKLES_ENABLE) &&
trickles.c:5527:	   (tp->trickles_opt & TCP_TRICKLES_RSERVER) &&
trickles.c:5529:		struct trickles_mmap_ctl *ctl = (struct trickles_mmap_ctl *)&tp->cminisock_api_config.cfg.ctl;
trickles.c:5530:		struct cminisock *msk = (struct cminisock *)ctl->minisock_base;
trickles.c:5531:		while((char*)msk <= (char*)ctl->ro_base + MINISOCK_LEN(ctl->ro_len)) {
trickles.c:5540:	if(tp->t.hmacCTX) {
trickles.c:5541:		kfree(tp->t.hmacCTX);
trickles.c:5542:		tp->t.hmacCTX = NULL;
trickles.c:5545:	if(tp->t.nonceCTX) {
trickles.c:5546:		kfree(tp->t.nonceCTX);
trickles.c:5547:		tp->t.nonceCTX = NULL;
trickles.c:5558:	if((tp->trickles_opt & TCP_TRICKLES_ENABLE) && !(tp->trickles_opt & TCP_TRICKLES_RSERVER)) {
trickles.c:5561:		BUG_TRAP(tp->t.dnext == NULL);
trickles.c:5566:	if(tp->t.events != NULL) {
trickles.c:5569:		newEntry->next = newEntry->prev = NULL;
trickles.c:5570:		newEntry->list = NULL;
trickles.c:5571:		newEntry->addr = sk->daddr;
trickles.c:5572:		newEntry->port = sk->dport;
trickles.c:5573:		newEntry->rcv_nxt = tp->rcv_nxt;
trickles.c:5574:		newEntry->t_rcv_nxt = tp->t.rcv_nxt;
trickles.c:5576:		newEntry->events = tp->t.events;
trickles.c:5577:		newEntry->size = tp->t.eventsSize;
trickles.c:5578:		newEntry->returnedEvents = 0;
trickles.c:5579:		newEntry->sentAmount = 0;
trickles.c:5583:	if(sk->prev) {
trickles.c:5586:	if(sk->bind_next) {
trickles.c:5589:	gNumUncopiedBytes += tp->rcv_nxt - tp->copied_seq;
trickles.c:5606:	sysctl_trickles_mss = 1374 - 16;
trickles.c:5607:	//sysctl_trickles_mss = 1374 - 32;
trickles.c:5738:	printk("Warning: Disabled server-side recovery mode's out of memory errors\n");
trickles.c:5837:			printk("Range nonce 1-%d 0x%0X\n", i,
trickles.c:5841:		printk("Nonces 1-%d: ", TAR_MAX);
trickles.c:5884:	printk("MIN_RESPONSELEN_ADJUP_TEST -- performance will be horrible\n");
trickles.c:5888:	printk("Rtt will include server-side user time\n");
trickles.c:5890:	printk("Rtt will NOT include server-side user time\n");
trickles.c:5965:		sk = sk->tp_pinfo.af_tcp.t.dnext;
trickles.c:5986:		logEntry = (struct TricklesProcLogEntry*)logEntry->prev;
trickles.c:5988:		kfree(clean->events);
trickles.c:5994:		cwndLogEntry = (struct TricklesCwndProcLogEntry*)cwndLogEntry->prev;
trickles-driver.c:1:#include "trickles-int.h"
trickles-driver.c:27:#define CONT_MGMT0 (0) // original algorithm - use one large continuation for DATUMLEN
trickles-driver.c:28:#define CONT_MGMT1 (1) // test0 - split DATUMLEN into 10 continuations, all sent at beginning 
trickles-driver.c:29:#define CONT_MGMT2 (2) // test1 - split DATUMLEN into 10 continuations, all sent at beginning
trickles-driver.c:30:   // However, server rejects continuations 5-9
trickles-driver.c:32:#define CONT_MGMT3 (3) // test2 - send DATUMLEN incrementally
trickles-driver.c:38://int continuationSubstyle = 2; // 0 = "nice", 1 = "annoying" (e.g., introduce extra overlaps), 2 = "really annoying - annoying + permute delivery order
trickles-driver.c:39:int continuationSubstyle = 2; // 0 = "nice", 1 = "annoying" (e.g., introduce extra overlaps), 2 = "really annoying - annoying + permute delivery order
trickles-driver.c:47:  skb_pull(skb, skb->h.th->doff*4);
trickles-driver.c:51:  sendto(udpsock, skb->data, skb->len, 0, &peer, sizeof(struct sockaddr_in));
trickles-driver.c:57:skb_pull(skb, skb->h.th->doff*4);
trickles-driver.c:66:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-driver.c:69:	sk->state = 0;
trickles-driver.c:70:	sk->dead = 0;
trickles-driver.c:71:	sk->state_change = state_change;
trickles-driver.c:72:	sk->rcvbuf = 100000000;
trickles-driver.c:73:	sk->sndbuf = 10000000;
trickles-driver.c:74:	sk->saddr = sk->daddr = 0;
trickles-driver.c:76:	tp->trickles_opt = 1;
trickles-driver.c:77:	// Use kernel code to initialize trickles-specific fields
trickles-driver.c:79:	init_timer(&tp->t.slowstart_timer);
trickles-driver.c:81:	tp->t.heapbytesize = USER_HEAP_SIZE * PAGE_SIZE;
trickles-driver.c:82:	tp->t.heap_absolute_base = kmalloc(tp->t.heapbytesize, GFP_KERNEL);
trickles-driver.c:89:		tp->t.hmacCTX = kmalloc(sizeof(*tp->t.hmacCTX), GFP_KERNEL);
trickles-driver.c:90:		if(tp->t.hmacCTX == NULL) {
trickles-driver.c:91:			error = -ENOMEM;
trickles-driver.c:94:		hmac_setup(tp->t.hmacCTX, hmac_key, HMAC_KEYLEN);
trickles-driver.c:97:		memcpy(tp->t.hmacKey, hmac_key, HMAC_KEYLEN);
trickles-driver.c:103:		tp->t.nonceCTX = kmalloc(sizeof(*tp->t.nonceCTX), GFP_KERNEL);
trickles-driver.c:104:		if(tp->t.nonceCTX == NULL) {
trickles-driver.c:105:			error = -ENOMEM;
trickles-driver.c:108:		aes_encrypt_key(nonce_key, NONCE_KEYLEN, tp->t.nonceCTX);
trickles-driver.c:117:  synpkt = alloc_skb(MAX_TCP_HEADER, -1);
trickles-driver.c:119:  synpkt->nh.iph = (struct iphdr*)synpkt->data;
trickles-driver.c:121:  synpkt->h.th = (struct tcphdr*)synpkt->data;
trickles-driver.c:123:  synpkt->h.th->syn = 1;
trickles-driver.c:124:  synpkt->h.th->ack = 0;
trickles-driver.c:125:  synpkt->h.th->fin = 0;
trickles-driver.c:126:  synpkt->h.th->rst = 0;
trickles-driver.c:127:  synpkt->h.th->doff = sizeof(struct tcphdr) / 4;
trickles-driver.c:144:  unsigned lastSent = -1;
trickles-driver.c:154:  for(i=FULLLEN-1; i >= 0; i--) {
trickles-driver.c:162:    int copyLen = min(sizeof(buf[i]), strlen(fullBuf) - position);
trickles-driver.c:186:    if(lastSent == -1 || currCopiedSeq - lastSent >= DATUMLEN) {
trickles-driver.c:204:	    //	    if(counter > 10000 && (counter % 1000 == 1  || counter % 1000 == 3 || counter < 11000 && ntohl(skb->h.th->seq) == 12643) || /* counter % 100 == 12  */ 0 || client_rcv_impl(&client, skb)) 
trickles-driver.c:210:		    struct WireTrickleResponse *tresp_hdr = (struct WireTrickleResponse*)skb->data;
trickles-driver.c:211:		    skb->sk = &client;
trickles-driver.c:212:		    printk("dropped packet with sequence number %d\n", ntohl(tresp_hdr->cont.seq));
trickles-driver.c:223:    if(client.tp_pinfo.af_tcp.rcv_nxt - client.tp_pinfo.af_tcp.copied_seq > 0 &&
trickles-driver.c:224:       (client.tp_pinfo.af_tcp.rcv_nxt - client.tp_pinfo.af_tcp.copied_seq > DATUMLEN / 2 || client.tp_pinfo.af_tcp.rcv_nxt % DATUMLEN == 0)) {
trickles-driver.c:227:	    printk("rcv_nxt = %d, t.rcv_nxt = %d, ContList length = %d\n", ctp->rcv_nxt, ctp->t.rcv_nxt, ctp->t.cont_list.len);
trickles-driver.c:235:	    } else if(count > 1 && time(NULL) - lastSlowstartTime >= 1) {
trickles-driver.c:269:  if(bind(udpsock, &addr, sizeof(addr)) == -1) {
trickles-driver.c:271:    exit(-1);
trickles-driver.c:292:	    memcpy(skb->data, buf, numBytes);
trickles-driver.c:293:	    skb->h.th = skb->data;
trickles-driver.c:294:	    skb->nh.iph = ((struct iphdr*)skb->h.th)-1;
trickles-driver.c:295:	    skb->nh.iph->saddr = addr.sin_addr.s_addr;
trickles-driver.c:299:	    skb->nh.iph->daddr = INADDR_LOOPBACK;
trickles-driver.c:301:	    //	    if(counter > 10000 && (counter % 1000 == 1  || counter % 1000 == 3 || counter < 11000 && ntohl(skb->h.th->seq) == 12643) || /* counter % 100 == 12  */ 0 || client_rcv_impl(&client, skb)) 
trickles-driver.c:321:	    } else if(count > 1 && time(NULL) - lastSlowstartTime >= 1) {
trickles-driver.c:351:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-driver.c:352:	if(TCP_SKB_CB(skb)->seq == tp->rcv_nxt) {
trickles-driver.c:353:		tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq;
trickles-driver.c:357:	//printk("DataQueue seq %u\n", TCP_SKB_CB(skb)->seq);
trickles-driver.c:377:	return (predConvCont->count >= 0) &&
trickles-driver.c:379:		(predConvContLen - sizeof(*predConvCont)) % sizeof(int) == 0;
trickles-driver.c:384:	int numNewValues = 0, maxNumValues = (TRICKLES_MSS-200) / sizeof(int);
trickles-driver.c:389:	char *input = msk->input;
trickles-driver.c:390:	unsigned input_len = msk->input_len;
trickles-driver.c:391:	int first = predConvCont->count == 0;
trickles-driver.c:420:					(predConvContLen - sizeof(struct ParseContinuation)) / sizeof(int);
trickles-driver.c:424:					validStart = predConvCont->nextStart;
trickles-driver.c:429:					validStart = predConvCont->nextStart;
trickles-driver.c:435:					exit(-1);
trickles-driver.c:449:				newConvCont = WireUC_getDataStart(&completeResponse->newCont);
trickles-driver.c:451:				newConvCont->nextStart = validStart + NUMCHUNKS * CHUNKSIZE;
trickles-driver.c:453:					newConvCont->sum += predConvCont->values[i];
trickles-driver.c:456:					newConvCont->sum += newValues[i];
trickles-driver.c:458:				newConvCont->oldCount = newConvCont->count + numNewValues;
trickles-driver.c:459:				newConvCont->count = 0;
trickles-driver.c:460:				tail = (char*)completeResponse + ntohs(completeResponse->len);
trickles-driver.c:483:							chunkStart -= 100;
trickles-driver.c:486:							chunkEnd = MIN(chunkEnd + 100, newConvCont->nextStart);
trickles-driver.c:491:						pCont = WireUC_getDataStart(&newResponse->newCont);
trickles-driver.c:493:						tail += ntohs(newResponse->len);
trickles-driver.c:500:					exit(-1);
trickles-driver.c:523:		memcpy(incompleteResponse->newCont.data, (char*)predConvCont, predConvContLen);
trickles-driver.c:524:		tail = response + ntohs(((struct WireUC_RespHeader*)response)->len);
trickles-driver.c:530:		struct ParseContinuation *newConvCont = (struct ParseContinuation *)incompleteResponse->newCont.data;
trickles-driver.c:532:		int numOldValues = (predConvContLen - sizeof(struct ParseContinuation)) / sizeof(int);
trickles-driver.c:536:				newConvCont->sum += predConvCont->values[j];
trickles-driver.c:539:				newConvCont->sum += newValues[j];
trickles-driver.c:541:			newConvCont->count += numNewValues;
trickles-driver.c:545:				newConvCont->values[j] = predConvCont->values[j];
trickles-driver.c:548:				newConvCont->values[numOldValues + j] = newValues[j];
trickles-driver.c:550:			newConvCont->count += numNewValues;
trickles-driver.c:560:		tail = response + ntohs(((struct WireUC_RespHeader*)response)->len);
trickles-driver.c:564:		int ucont_len = tail - response;
trickles-driver.c:565:		setPacketUCont(&msk->packets[0], (char*)response, 
trickles-driver.c:580:	struct sk_buff **skbs = kmalloc(sizeof(struct sk_buff *) * msk->num_packets, GFP_ATOMIC);
trickles-driver.c:585:	if(SIMULATION_MODE(msk->sk)) {
trickles-driver.c:588:	msk->tag = event;
trickles-driver.c:592:		struct WireUC_DataRequest *dataReq = msk->ucont_data;
trickles-driver.c:597:			byteNum = ntohl(dataReq->start);
trickles-driver.c:598:			len = ntohl(dataReq->end) - byteNum;
trickles-driver.c:600:		for(i=0; i < msk->num_packets; i++) {
trickles-driver.c:603:			int copyLen = MIN(len, msk->packets[i].len);
trickles-driver.c:605:			while(testptr - testbuf < copyLen) {
trickles-driver.c:612:			msk->packets[i].byteNum = byteNum;
trickles-driver.c:614:			len -= copyLen;
trickles-driver.c:619:	free_trickles_msk(msk->sk,msk);
trickles-driver.c:620:	free_trickles_msk_finish(msk->sk,msk);
trickles-driver.c:623:	if(msk->ucont_len == 0) {
trickles-driver.c:641:			initConvCont = WireUC_getDataStart(&completeResponse->newCont);
trickles-driver.c:642:			initConvCont->nextStart = 0;
trickles-driver.c:643:			initConvCont->count = 0;
trickles-driver.c:644:			initConvCont->sum = 0;
trickles-driver.c:645:			responseLen = ntohs(((struct WireUC_RespHeader*)response)->len);
trickles-driver.c:646:			setPacketUCont(&msk->packets[0], (char*)response, 
trickles-driver.c:649:			for(i=0; i < msk->num_packets; i++) {
trickles-driver.c:651:				skb_reserve(skb, MAX_TCP_HEADER + MAX_TRICKLES_SERVER_HDR_LEN + msk->packets[i].ucontLen);
trickles-driver.c:657:	hdr = (struct WireUC_ReqHeader *)msk->ucont_data;
trickles-driver.c:658:	if(msk->ucont_len > 0) {
trickles-driver.c:659:		if(msk->ucont_len < sizeof(*hdr)) {
trickles-driver.c:670:		switch((enum UC_Type)hdr->type) {
trickles-driver.c:672:			int predConvContLen = msk->ucont_len - sizeof(struct WireUC_CVT_IncompleteRequest);
trickles-driver.c:677:				(struct ParseContinuation *)incompleteRequest->predCont.data;
trickles-driver.c:681:				printk("UC_INCOMPLETE response generation - out of memory\n");
trickles-driver.c:684:			if(msk->ucont_len < sizeof(struct WireUC_CVT_IncompleteRequest)) {
trickles-driver.c:685:				printk("UC_INCOMPLETE response generation - ucont too short\n");
trickles-driver.c:696:			parseInput(msk, htonl(incompleteRequest->seq), incompleteRequest->predCont.validStart, predConvCont, predConvContLen, response);
trickles-driver.c:703:			struct ParseContinuation *predConvCont = (struct ParseContinuation*)completeRequest->predCont.data;
trickles-driver.c:706:			predConvContLen = msk->ucont_len - sizeof(struct WireUC_CVT_CompleteRequest);
trickles-driver.c:708:				printk("UC_COMPLETE response generation - out of memory\n");
trickles-driver.c:711:			if(msk->ucont_len < sizeof(struct WireUC_CVT_CompleteRequest)) {
trickles-driver.c:712:				printk("UC_COMPLETE response generation - ucont too short\n");
trickles-driver.c:724:			parseInput(msk, htonl(completeRequest->seq), completeRequest->predCont.validStart, predConvCont, predConvContLen, response);
trickles-driver.c:733:			struct WireUC_Continuation *predCont = (struct WireUC_Continuation *)dataReq->data;
trickles-driver.c:734:			struct ParseContinuation *predConvCont = (struct ParseContinuation *)predCont->data;
trickles-driver.c:736:			unsigned oldStart = ntohl(predCont->validStart),
trickles-driver.c:737:				oldEnd = ntohl(predCont->validEnd);
trickles-driver.c:738:			if(msk->ucont_len < sizeof(struct WireUC_DataRequest) + 
trickles-driver.c:744:			start = ntohl(dataReq->start);
trickles-driver.c:745:			end = ntohl(dataReq->end);
trickles-driver.c:755:			len = end - start;
trickles-driver.c:756:			predSeq = ntohl(predCont->seq);
trickles-driver.c:758:			//printk("offset %d\n", start - oldStart);
trickles-driver.c:763:					if(oldStart < DATUMLEN / 2 - 200 && start == oldStart) {
trickles-driver.c:766:					if(oldStart < DATUMLEN / 2 - 200 && start < oldStart + TRICKLES_MSS) {
trickles-driver.c:775:						chunkStart = parseCont.nextStart - DATUMLEN + 
trickles-driver.c:779:							chunkStart -= 200;
trickles-driver.c:784:						printk("Pushing new continuation seq %d [%d-%d]\n", 
trickles-driver.c:785:						       ntohl(newResponse->newCont.seq), 
trickles-driver.c:786:						       ntohl(newResponse->newCont.validStart), 
trickles-driver.c:787:						       ntohl(newResponse->newCont.validEnd));
trickles-driver.c:788:						pCont = WireUC_getDataStart(&newResponse->newCont);
trickles-driver.c:790:						ucont_len = ntohs(newResponse->len);
trickles-driver.c:792:						setPacketUCont(&msk->packets[0], (char*)response, 
trickles-driver.c:796:						for(i=0; i < msk->num_packets; i++) {
trickles-driver.c:797:							totalLen += msk->packets[i].len;
trickles-driver.c:801:							len = totalLen - ucont_len;
trickles-driver.c:822:	for(i=0; i < msk->num_packets; i++) {
trickles-driver.c:825:		skb_reserve(skb, MAX_TCP_HEADER + MAX_TRICKLES_SERVER_HDR_LEN + msk->packets[i].ucontLen);
trickles-driver.c:828:			int realLen = (len > TRICKLES_MSS ? len - TRICKLES_MSS : len);
trickles-driver.c:831:				//printk("DoUpcall - Kept %d-%d, Pruned %d-%d\n", byteNum,  byteNum + realLen, byteNum + realLen, byteNum + len);
trickles-driver.c:838:			char *outPtr = skb->data;
trickles-driver.c:839:			int chunkLen, copyLen = MIN(len, msk->packets[i].len);
trickles-driver.c:842:			while((char*)outPtr - (char*)skb->data < copyLen) {
trickles-driver.c:848:			int realCopyLen = (copyLen > TRICKLES_MSS ? copyLen - TRICKLES_MSS : copyLen);
trickles-driver.c:851:				//printk("DoUpcall - Kept %d-%d, Pruned %d-%d\n", byteNum,  byteNum + realCopyLen, byteNum + realCopyLen, byteNum + copyLen);
trickles-driver.c:857:			msk->packets[i].byteNum = byteNum;
trickles-driver.c:859:			len -= copyLen;
trickles-driver.c:863:				msk->packets[i].position = i;
trickles-driver.c:865:				msk->packets[i].position = INVALID_POSITION;
trickles-driver.c:868:			msk->packets[i].numSiblings = 1;
trickles-driver.c:869:			msk->packets[i].position = (i==0 ? 0 : INVALID_POSITION);
trickles-driver.c:872:	for(i=0; i < msk->num_packets; i++) {
trickles-driver.c:874:			msk->packets[i].numSiblings = numSiblings;
trickles-driver.c:879:	free_trickles_msk(msk->sk,msk);
trickles-driver.c:880:	free_trickles_msk_finish(msk->sk,msk);
trickles-server_1.c:1:# 1 "trickles-server.c"
trickles-server_1.c:2:# 1 "<built-in>"
trickles-server_1.c:4:# 1 "trickles-server.c"
trickles-server_1.c:5:# 1 "trickles-int.h" 1
trickles-server_1.c:21:# 1 "/usr/lib/gcc-lib/i386-redhat-linux/3.2.3/include/stdarg.h" 1 3
trickles-server_1.c:22:# 43 "/usr/lib/gcc-lib/i386-redhat-linux/3.2.3/include/stdarg.h" 3
trickles-server_1.c:24:# 110 "/usr/lib/gcc-lib/i386-redhat-linux/3.2.3/include/stdarg.h" 3
trickles-server_1.c:419:        char _f[20-2*sizeof(long)-sizeof(int)];
trickles-server_1.c:706:# 1 "/home/ashieh/current/include/linux/kgdb-asserts.h" 1
trickles-server_1.c:721:        size = (size-1) >> (12 -1);
trickles-server_1.c:722:        order = -1;
trickles-server_1.c:994:        return ((unsigned long *)t->esp)[3];
trickles-server_1.c:1065:        next->prev = new;
trickles-server_1.c:1066:        new->next = next;
trickles-server_1.c:1067:        new->prev = prev;
trickles-server_1.c:1068:        prev->next = new;
trickles-server_1.c:1073:        __list_add(new, head, head->next);
trickles-server_1.c:1078:        __list_add(new, head->prev, head);
trickles-server_1.c:1083:        next->prev = prev;
trickles-server_1.c:1084:        prev->next = next;
trickles-server_1.c:1094:        __list_del(entry->prev, entry->next);
trickles-server_1.c:1095:        entry->next = (void *) 0;
trickles-server_1.c:1096:        entry->prev = (void *) 0;
trickles-server_1.c:1105:        __list_del(entry->prev, entry->next);
trickles-server_1.c:1106:        do { (entry)->next = (entry); (entry)->prev = (entry); } while (0);
trickles-server_1.c:1116:        __list_del(list->prev, list->next);
trickles-server_1.c:1128:        __list_del(list->prev, list->next);
trickles-server_1.c:1138:        return head->next == head;
trickles-server_1.c:1144:        struct list_head *first = list->next;
trickles-server_1.c:1145:        struct list_head *last = list->prev;
trickles-server_1.c:1146:        struct list_head *at = head->next;
trickles-server_1.c:1148:        first->prev = head;
trickles-server_1.c:1149:        head->next = first;
trickles-server_1.c:1151:        last->next = at;
trickles-server_1.c:1152:        at->prev = last;
trickles-server_1.c:1171:                do { (list)->next = (list); (list)->prev = (list); } while (0);
trickles-server_1.c:1388:                "movl $-1,%%eax\n\t"
trickles-server_1.c:1392:                "xorl -4(%%edi),%%eax\n\t"
trickles-server_1.c:1424:                if (set < (32 - bit))
trickles-server_1.c:1426:                set = 32 - bit;
trickles-server_1.c:1432:        res = find_first_zero_bit (p, size - 32 * (p - (unsigned long *) addr));
trickles-server_1.c:1456:                "movl $-1,%0\n"
trickles-server_1.c:1627:        q->lock = (spinlock_t) { };
trickles-server_1.c:1628:        do { (&q->task_list)->next = (&q->task_list); (&q->task_list)->prev = (&q->task_list); } while (0);
trickles-server_1.c:1641:        q->flags = 0;
trickles-server_1.c:1642:        q->task = p;
trickles-server_1.c:1656:        return !list_empty(&q->task_list);
trickles-server_1.c:1662:        list_add(&new->task_list, &head->task_list);
trickles-server_1.c:1672:        list_add_tail(&new->task_list, &head->task_list);
trickles-server_1.c:1683:        list_del(&old->task_list);
trickles-server_1.c:1724:        char __data[128 - sizeof(unsigned short)];
trickles-server_1.c:1793:        __ptr = (struct cmsghdr*)(((unsigned char *) __cmsg) + ( ((__cmsg->cmsg_len)+sizeof(long)-1) & ~(sizeof(long)-1) ));
trickles-server_1.c:1794:        if ((unsigned long)((char*)(__ptr+1) - (char *) __ctl) > __size)
trickles-server_1.c:1802:        return __cmsg_nxthdr(__msg->msg_control, __msg->msg_controllen, __cmsg);
trickles-server_1.c:1935:        return (((unsigned int) ((dev) >> 8))<<8) | ((unsigned int) ((dev) & ((1U << 8) - 1)));
trickles-server_1.c:1970:                :"=m" (v->counter)
trickles-server_1.c:1971:                :"ir" (i), "m" (v->counter));
trickles-server_1.c:1978:                :"=m" (v->counter)
trickles-server_1.c:1979:                :"ir" (i), "m" (v->counter));
trickles-server_1.c:1988:                :"=m" (v->counter), "=qm" (c)
trickles-server_1.c:1989:                :"ir" (i), "m" (v->counter) : "memory");
trickles-server_1.c:1997:                :"=m" (v->counter)
trickles-server_1.c:1998:                :"m" (v->counter));
trickles-server_1.c:2005:                :"=m" (v->counter)
trickles-server_1.c:2006:                :"m" (v->counter));
trickles-server_1.c:2015:                :"=m" (v->counter), "=qm" (c)
trickles-server_1.c:2016:                :"m" (v->counter) : "memory");
trickles-server_1.c:2026:                :"=m" (v->counter), "=qm" (c)
trickles-server_1.c:2027:                :"m" (v->counter) : "memory");
trickles-server_1.c:2037:                :"=m" (v->counter), "=qm" (c)
trickles-server_1.c:2038:                :"ir" (i), "m" (v->counter) : "memory");
trickles-server_1.c:2081:# 1 "/home/ashieh/current/include/linux/kgdb-defs.h" 1
trickles-server_1.c:2224:                atomic_inc(&mnt->mnt_count);
trickles-server_1.c:2233:                if (atomic_dec_and_test(&mnt->mnt_count))
trickles-server_1.c:2274:        while (len--)
trickles-server_1.c:2315:        list_del(&dentry->d_hash);
trickles-server_1.c:2316:        do { (&dentry->d_hash)->next = (&dentry->d_hash); (&dentry->d_hash)->prev = (&dentry->d_hash); } while (0);
trickles-server_1.c:2322:        return d->d_name.name != d->d_iname;
trickles-server_1.c:2388:                if (!((&dentry->d_count)->counter))
trickles-server_1.c:2390:                atomic_inc(&dentry->d_count);
trickles-server_1.c:2399:        return list_empty(&dentry->d_hash);
trickles-server_1.c:2406:        return dentry->d_mounted;
trickles-server_1.c:2657:        "leal -1(%%esi),%0\n"
trickles-server_1.c:2785:         "1" (n-1+(const char *)src),
trickles-server_1.c:2786:         "2" (n-1+(char *)dest)
trickles-server_1.c:2853:        "cmpl $-1,%1\n\t"
trickles-server_1.c:2986:        sem->count = 0x00000000;
trickles-server_1.c:2988:        do { (&sem->wait_list)->next = (&sem->wait_list); (&sem->wait_list)->prev = (&sem->wait_list); } while (0);
trickles-server_1.c:3014:                : "+m"(sem->count)
trickles-server_1.c:3036:                : "+m"(sem->count), "=&a"(result), "=&r"(tmp)
trickles-server_1.c:3049:        tmp = ((-0x00010000) + 0x00000001);
trickles-server_1.c:3064:                : "+d"(tmp), "+m"(sem->count)
trickles-server_1.c:3074:        signed long ret = ((__typeof__(*(&sem->count)))__cmpxchg((&sem->count),(unsigned long)(0x00000000), (unsigned long)(((-0x00010000) + 0x00000001)),sizeof(*(&sem->count))));
trickles-server_1.c:3087:        __s32 tmp = -0x00000001;
trickles-server_1.c:3103:                : "+m"(sem->count), "+d"(tmp)
trickles-server_1.c:3129:                : "+m"(sem->count)
trickles-server_1.c:3130:                : "a"(sem), "i"(-((-0x00010000) + 0x00000001))
trickles-server_1.c:3141:                :"=m"(sem->count)
trickles-server_1.c:3142:                :"ir"(delta), "m"(sem->count));
trickles-server_1.c:3154:                : "+r"(tmp), "=m"(sem->count)
trickles-server_1.c:3155:                : "r"(sem), "m"(sem->count)
trickles-server_1.c:3241:        (((&sem->count)->counter) = (val));
trickles-server_1.c:3242:        sem->sleepers = 0;
trickles-server_1.c:3243:        init_waitqueue_head(&sem->wait);
trickles-server_1.c:3289:                :"=m" (sem->count)
trickles-server_1.c:3316:                :"=a" (result), "=m" (sem->count)
trickles-server_1.c:3344:                :"=a" (result), "=m" (sem->count)
trickles-server_1.c:3371:                :"=m" (sem->count)
trickles-server_1.c:3378:        return ((&sem->count)->counter);
trickles-server_1.c:4012:        unsigned long sec = value->tv_sec;
trickles-server_1.c:4013:        long nsec = value->tv_nsec;
trickles-server_1.c:4015:        if (sec >= (((~0UL >> 1)-1) / 100))
trickles-server_1.c:4016:                return ((~0UL >> 1)-1);
trickles-server_1.c:4017:        nsec += 1000000000L / 100 - 1;
trickles-server_1.c:4025:        value->tv_nsec = (jiffies % 100) * (1000000000L / 100);
trickles-server_1.c:4026:        value->tv_sec = jiffies / 100;
trickles-server_1.c:4034:        if (0 >= (int) (mon -= 2)) {
trickles-server_1.c:4036:                year -= 1;
trickles-server_1.c:4040:                (unsigned long) (year/4 - year/100 + year/400 + 367*mon/12 + day) +
trickles-server_1.c:4041:                        year*365 - 719499
trickles-server_1.c:4214:        if (fid->Vnode == 0xfffffffe || fid->Vnode == 0xffffffff)
trickles-server_1.c:4215:                return ((fid->Volume << 20) | (fid->Unique & 0xfffff));
trickles-server_1.c:4217:                return (fid->Unique + (fid->Vnode<<10) + (fid->Volume<<20));
trickles-server_1.c:5215:        info->dqi_flags |= 0x10000;
trickles-server_1.c:5315:                        return dqopt->flags & 0x01;
trickles-server_1.c:5317:                        return dqopt->flags & 0x02;
trickles-server_1.c:5482:        inode->i_blocks += bytes >> 9;
trickles-server_1.c:5484:        inode->i_bytes += bytes;
trickles-server_1.c:5485:        if (inode->i_bytes >= 512) {
trickles-server_1.c:5486:                inode->i_blocks++;
trickles-server_1.c:5487:                inode->i_bytes -= 512;
trickles-server_1.c:5493:        inode->i_blocks -= bytes >> 9;
trickles-server_1.c:5495:        if (inode->i_bytes < bytes) {
trickles-server_1.c:5496:                inode->i_blocks--;
trickles-server_1.c:5497:                inode->i_bytes += 512;
trickles-server_1.c:5499:        inode->i_bytes -= bytes;
trickles-server_1.c:5504:        return (((loff_t)inode->i_blocks) << 9) + inode->i_bytes;
trickles-server_1.c:5509:        inode->i_blocks = bytes >> 9;
trickles-server_1.c:5510:        inode->i_bytes = bytes & 511;
trickles-server_1.c:5729:        timer->list.next = timer->list.prev = ((void *)0);
trickles-server_1.c:5734:        return timer->list.next != ((void *)0);
trickles-server_1.c:6590:        __s8 fs_fsmnt[512 - 212];
trickles-server_1.c:6825:        down(&(server->sem));
trickles-server_1.c:6831:        up(&(server->sem));
trickles-server_1.c:7018:        if (!test_and_set_bit(0,&bh_pointer->sync)) {
trickles-server_1.c:7021:                list_add_tail(&bh_pointer->list, bh_list);
trickles-server_1.c:7592:        return ((server->conn_status & 0x11) == 0);
trickles-server_1.c:7597:        server->conn_status |= 0x01;
trickles-server_1.c:7639:        x->done = 0;
trickles-server_1.c:7640:        init_waitqueue_head(&x->wait);
trickles-server_1.c:7925:        if ((((inode)->i_sb->s_flags & (64)) && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
trickles-server_1.c:7934:        if (inode->i_flock && (((inode)->i_sb->s_flags & (64)) && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
trickles-server_1.c:7943:        if (inode->i_flock && (((inode)->i_sb->s_flags & (64)) && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
trickles-server_1.c:7946:                        size < inode->i_size ? size : inode->i_size,
trickles-server_1.c:7947:                        (size < inode->i_size ? inode->i_size - size
trickles-server_1.c:7948:                         : size - inode->i_size)
trickles-server_1.c:7955:        if (inode->i_flock)
trickles-server_1.c:8034:        atomic_inc(&(bh)->b_count);
trickles-server_1.c:8040:        atomic_dec(&bh->b_count);
trickles-server_1.c:8049:                set_bit(BH_Uptodate, &bh->b_state);
trickles-server_1.c:8051:                clear_bit(BH_Uptodate, &bh->b_state);
trickles-server_1.c:8063:        if (test_and_clear_bit(BH_Dirty, &(bh)->b_state))
trickles-server_1.c:8075:        buffer_insert_list(bh, &inode->i_dirty_buffers);
trickles-server_1.c:8080:        buffer_insert_list(bh, &inode->i_dirty_data_buffers);
trickles-server_1.c:8085:        return test_and_set_bit(BH_Dirty, &bh->b_state);
trickles-server_1.c:8091:                set_bit(BH_Async, &bh->b_state);
trickles-server_1.c:8093:                clear_bit(BH_Async, &bh->b_state);
trickles-server_1.c:8098:        set_bit(BH_Attached, &bh->b_state);
trickles-server_1.c:8103:        clear_bit(BH_Attached, &bh->b_state);
trickles-server_1.c:8108:        return (__builtin_constant_p(BH_Attached) ? constant_test_bit((BH_Attached),(&bh->b_state)) : variable_test_bit((BH_Attached),(&bh->b_state)));
trickles-server_1.c:8123:        bh->b_end_io(bh, 0);
trickles-server_1.c:8157:        return fsync_buffers_list(&inode->i_dirty_buffers);
trickles-server_1.c:8161:        return fsync_buffers_list(&inode->i_dirty_data_buffers);
trickles-server_1.c:8177:        atomic_dec(&inode->i_writecount);
trickles-server_1.c:8182:                atomic_inc(&file->f_dentry->d_inode->i_writecount);
trickles-server_1.c:8207:        return (unsigned long)ptr > (unsigned long)-1000L;
trickles-server_1.c:8257:        if (inode && (inode->i_state & 64)) {
trickles-server_1.c:8261:                if (sb->s_op->read_inode2)
trickles-server_1.c:8262:                        sb->s_op->read_inode2(inode, opaque);
trickles-server_1.c:8264:                        sb->s_op->read_inode(inode);
trickles-server_1.c:8275:        if (inode && (inode->i_state & 64)) {
trickles-server_1.c:8276:                sb->s_op->read_inode(inode);
trickles-server_1.c:8319:        return bread(sb->s_dev, block, sb->s_blocksize);
trickles-server_1.c:8323:        return getblk(sb->s_dev, block, sb->s_blocksize);
trickles-server_1.c:8327:        return get_hash_table(sb->s_dev, block, sb->s_blocksize);
trickles-server_1.c:8437:        struct dentry *dir = dget(dentry->d_parent);
trickles-server_1.c:8439:        down(&dir->d_inode->i_sem);
trickles-server_1.c:8445:        return dget(dentry->d_parent);
trickles-server_1.c:8450:        up(&dir->d_inode->i_sem);
trickles-server_1.c:8522:        double_down(&d1->d_inode->i_sem, &d2->d_inode->i_sem);
trickles-server_1.c:8527:        double_up(&d1->d_inode->i_sem,&d2->d_inode->i_sem);
trickles-server_1.c:8750:        node->rb_parent = parent;
trickles-server_1.c:8751:        node->rb_color = 0;
trickles-server_1.c:8752:        node->rb_left = node->rb_right = ((void *)0);
trickles-server_1.c:9335:        __asm__("btsl %1,%0" : "=m"(*set) : "Ir"(_sig - 1) : "cc");
trickles-server_1.c:9340:        __asm__("btrl %1,%0" : "=m"(*set) : "Ir"(_sig - 1) : "cc");
trickles-server_1.c:9345:        unsigned long sig = _sig - 1;
trickles-server_1.c:9346:        return 1 & (set->sig[sig / 32] >> (sig % 32));
trickles-server_1.c:9353:                : "=r"(ret) : "m"(*set), "Ir"(_sig-1) : "cc");
trickles-server_1.c:9385:                int _pad[((128/sizeof(int)) - 3)];
trickles-server_1.c:9433:                int _pad[((64/sizeof(int)) - 3)];
trickles-server_1.c:9450:        if (from->si_code < 0)
trickles-server_1.c:9454:                (__builtin_constant_p(3*sizeof(int) + sizeof(from->_sifields._sigchld)) ? __constant_memcpy((to),(from),(3*sizeof(int) + sizeof(from->_sifields._sigchld))) : __memcpy((to),(from),(3*sizeof(int) + sizeof(from->_sifields._sigchld))));
trickles-server_1.c:9475:static inline void sigorsets(sigset_t *r, const sigset_t *a, const sigset_t *b) { unsigned long a0, a1, a2, a3, b0, b1, b2, b3; unsigned long i; for (i = 0; i < (64 / 32)/4; ++i) { a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; a3 = a->sig[4*i+3]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; b3 = b->sig[4*i+3]; r->sig[4*i+0] = ((a0) | (b0)); r->sig[4*i+1] = ((a1) | (b1)); r->sig[4*i+2] = ((a2) | (b2)); r->sig[4*i+3] = ((a3) | (b3)); } switch ((64 / 32) % 4) { case 3: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; r->sig[4*i+0] = ((a0) | (b0)); r->sig[4*i+1] = ((a1) | (b1)); r->sig[4*i+2] = ((a2) | (b2)); break; case 2: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; r->sig[4*i+0] = ((a0) | (b0)); r->sig[4*i+1] = ((a1) | (b1)); break; case 1: a0 = a->sig[4*i+0]; b0 = b->sig[4*i+0]; r->sig[4*i+0] = ((a0) | (b0)); break; } }
trickles-server_1.c:9478:static inline void sigandsets(sigset_t *r, const sigset_t *a, const sigset_t *b) { unsigned long a0, a1, a2, a3, b0, b1, b2, b3; unsigned long i; for (i = 0; i < (64 / 32)/4; ++i) { a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; a3 = a->sig[4*i+3]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; b3 = b->sig[4*i+3]; r->sig[4*i+0] = ((a0) & (b0)); r->sig[4*i+1] = ((a1) & (b1)); r->sig[4*i+2] = ((a2) & (b2)); r->sig[4*i+3] = ((a3) & (b3)); } switch ((64 / 32) % 4) { case 3: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; r->sig[4*i+0] = ((a0) & (b0)); r->sig[4*i+1] = ((a1) & (b1)); r->sig[4*i+2] = ((a2) & (b2)); break; case 2: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; r->sig[4*i+0] = ((a0) & (b0)); r->sig[4*i+1] = ((a1) & (b1)); break; case 1: a0 = a->sig[4*i+0]; b0 = b->sig[4*i+0]; r->sig[4*i+0] = ((a0) & (b0)); break; } }
trickles-server_1.c:9481:static inline void signandsets(sigset_t *r, const sigset_t *a, const sigset_t *b) { unsigned long a0, a1, a2, a3, b0, b1, b2, b3; unsigned long i; for (i = 0; i < (64 / 32)/4; ++i) { a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; a3 = a->sig[4*i+3]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; b3 = b->sig[4*i+3]; r->sig[4*i+0] = ((a0) & ~(b0)); r->sig[4*i+1] = ((a1) & ~(b1)); r->sig[4*i+2] = ((a2) & ~(b2)); r->sig[4*i+3] = ((a3) & ~(b3)); } switch ((64 / 32) % 4) { case 3: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; r->sig[4*i+0] = ((a0) & ~(b0)); r->sig[4*i+1] = ((a1) & ~(b1)); r->sig[4*i+2] = ((a2) & ~(b2)); break; case 2: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; r->sig[4*i+0] = ((a0) & ~(b0)); r->sig[4*i+1] = ((a1) & ~(b1)); break; case 1: a0 = a->sig[4*i+0]; b0 = b->sig[4*i+0]; r->sig[4*i+0] = ((a0) & ~(b0)); break; } }
trickles-server_1.c:9483:static inline void signotset(sigset_t *set) { unsigned long i; for (i = 0; i < (64 / 32)/4; ++i) { set->sig[4*i+0] = (~(set->sig[4*i+0])); set->sig[4*i+1] = (~(set->sig[4*i+1])); set->sig[4*i+2] = (~(set->sig[4*i+2])); set->sig[4*i+3] = (~(set->sig[4*i+3])); } switch ((64 / 32) % 4) { case 3: set->sig[4*i+2] = (~(set->sig[4*i+2])); case 2: set->sig[4*i+1] = (~(set->sig[4*i+1])); case 1: set->sig[4*i+0] = (~(set->sig[4*i+0])); } }
trickles-server_1.c:9494:        case 2: set->sig[1] = 0;
trickles-server_1.c:9495:        case 1: set->sig[0] = 0;
trickles-server_1.c:9504:                (__builtin_constant_p(-1) ? (__builtin_constant_p((sizeof(sigset_t))) ? __constant_c_and_count_memset(((set)),((0x01010101UL*(unsigned char)(-1))),((sizeof(sigset_t)))) : __constant_c_memset(((set)),((0x01010101UL*(unsigned char)(-1))),((sizeof(sigset_t))))) : (__builtin_constant_p((sizeof(sigset_t))) ? __memset_generic((((set))),(((-1))),(((sizeof(sigset_t))))) : __memset_generic(((set)),((-1)),((sizeof(sigset_t))))));
trickles-server_1.c:9506:        case 2: set->sig[1] = -1;
trickles-server_1.c:9507:        case 1: set->sig[0] = -1;
trickles-server_1.c:9518:        set->sig[0] |= mask;
trickles-server_1.c:9523:        set->sig[0] &= ~mask;
trickles-server_1.c:9528:        return (set->sig[0] & mask) != 0;
trickles-server_1.c:9533:        set->sig[0] = mask;
trickles-server_1.c:9536:                (__builtin_constant_p(0) ? (__builtin_constant_p((sizeof(long)*((64 / 32)-1))) ? __constant_c_and_count_memset(((&set->sig[1])),((0x01010101UL*(unsigned char)(0))),((sizeof(long)*((64 / 32)-1)))) : __constant_c_memset(((&set->sig[1])),((0x01010101UL*(unsigned char)(0))),((sizeof(long)*((64 / 32)-1))))) : (__builtin_constant_p((sizeof(long)*((64 / 32)-1))) ? __memset_generic((((&set->sig[1]))),(((0))),(((sizeof(long)*((64 / 32)-1))))) : __memset_generic(((&set->sig[1])),((0)),((sizeof(long)*((64 / 32)-1))))));
trickles-server_1.c:9538:        case 2: set->sig[1] = 0;
trickles-server_1.c:9545:        set->sig[0] = ~mask;
trickles-server_1.c:9548:                (__builtin_constant_p(-1) ? (__builtin_constant_p((sizeof(long)*((64 / 32)-1))) ? __constant_c_and_count_memset(((&set->sig[1])),((0x01010101UL*(unsigned char)(-1))),((sizeof(long)*((64 / 32)-1)))) : __constant_c_memset(((&set->sig[1])),((0x01010101UL*(unsigned char)(-1))),((sizeof(long)*((64 / 32)-1))))) : (__builtin_constant_p((sizeof(long)*((64 / 32)-1))) ? __memset_generic((((&set->sig[1]))),(((-1))),(((sizeof(long)*((64 / 32)-1))))) : __memset_generic(((&set->sig[1])),((-1)),((sizeof(long)*((64 / 32)-1))))));
trickles-server_1.c:9550:        case 2: set->sig[1] = -1;
trickles-server_1.c:9559:        sigemptyset(&sig->signal);
trickles-server_1.c:9560:        sig->head = ((void *)0);
trickles-server_1.c:9561:        sig->tail = &sig->head;
trickles-server_1.c:9601:        (void)(&fs->lock);
trickles-server_1.c:9602:        old_root = fs->root;
trickles-server_1.c:9603:        old_rootmnt = fs->rootmnt;
trickles-server_1.c:9604:        fs->rootmnt = mntget(mnt);
trickles-server_1.c:9605:        fs->root = dget(dentry);
trickles-server_1.c:9624:        (void)(&fs->lock);
trickles-server_1.c:9625:        old_pwd = fs->pwd;
trickles-server_1.c:9626:        old_pwdmnt = fs->pwdmnt;
trickles-server_1.c:9627:        fs->pwdmnt = mntget(mnt);
trickles-server_1.c:9628:        fs->pwd = dget(dentry);
trickles-server_1.c:9942:        struct task_struct **htable = &pidhash[((((p->pid) >> 8) ^ (p->pid)) & ((4096 >> 2) - 1))];
trickles-server_1.c:9944:        if((p->pidhash_next = *htable) != ((void *)0))
trickles-server_1.c:9945:                (*htable)->pidhash_pprev = &p->pidhash_next;
trickles-server_1.c:9947:        p->pidhash_pprev = htable;
trickles-server_1.c:9952:        if(p->pidhash_next)
trickles-server_1.c:9953:                p->pidhash_next->pidhash_pprev = p->pidhash_pprev;
trickles-server_1.c:9954:        *p->pidhash_pprev = p->pidhash_next;
trickles-server_1.c:9959:        struct task_struct *p, **htable = &pidhash[((((pid) >> 8) ^ (pid)) & ((4096 >> 2) - 1))];
trickles-server_1.c:9961:        for(p = *htable; p && p->pid != pid; p = p->pidhash_next)
trickles-server_1.c:9971:        tsk->processor = cpu;
trickles-server_1.c:9972:        tsk->cpus_runnable = 1UL << cpu;
trickles-server_1.c:9977:        tsk->cpus_runnable = ~0UL;
trickles-server_1.c:10051:        return (p->sigpending != 0);
trickles-server_1.c:10065:                for (i = (64 / 32), ready = 0; --i >= 0 ;)
trickles-server_1.c:10066:                        ready |= signal->sig[i] &~ blocked->sig[i];
trickles-server_1.c:10069:        case 4: ready = signal->sig[3] &~ blocked->sig[3];
trickles-server_1.c:10070:                ready |= signal->sig[2] &~ blocked->sig[2];
trickles-server_1.c:10071:                ready |= signal->sig[1] &~ blocked->sig[1];
trickles-server_1.c:10072:                ready |= signal->sig[0] &~ blocked->sig[0];
trickles-server_1.c:10075:        case 2: ready = signal->sig[1] &~ blocked->sig[1];
trickles-server_1.c:10076:                ready |= signal->sig[0] &~ blocked->sig[0];
trickles-server_1.c:10079:        case 1: ready = signal->sig[0] &~ blocked->sig[0];
trickles-server_1.c:10090:        t->sigpending = has_pending_signals(&t->pending.signal, &t->blocked);
trickles-server_1.c:10097:        return (sp - get_current()->sas_ss_sp < get_current()->sas_ss_size);
trickles-server_1.c:10102:        return (get_current()->sas_ss_size == 0 ? 2
trickles-server_1.c:10113:        if (!( (1 << (0 +1)) & 0x00000000 ? (1 << (0)) & 0x00000000 : (1 << (0)) & securebits ) && get_current()->euid == 0) {
trickles-server_1.c:10114:                get_current()->flags |= 0x00000100;
trickles-server_1.c:10122:        if (!( (1 << (0 +1)) & 0x00000000 ? (1 << (0)) & 0x00000000 : (1 << (0)) & securebits ) && get_current()->fsuid == 0) {
trickles-server_1.c:10123:                get_current()->flags |= 0x00000100;
trickles-server_1.c:10138:        if (((get_current()->cap_effective) & (1 << (cap))))
trickles-server_1.c:10143:                get_current()->flags |= 0x00000100;
trickles-server_1.c:10161:        if (atomic_dec_and_test(&mm->mm_count))
trickles-server_1.c:10203:        nr_running--;
trickles-server_1.c:10204:        p->sleep_time = jiffies;
trickles-server_1.c:10205:        list_del(&p->run_list);
trickles-server_1.c:10206:        p->run_list.next = ((void *)0);
trickles-server_1.c:10211:        return (p->run_list.next != ((void *)0));
trickles-server_1.c:10219:        nr_threads--;
trickles-server_1.c:10221:        do { (p)->next_task->prev_task = (p)->prev_task; (p)->prev_task->next_task = (p)->next_task; if ((p)->p_osptr) (p)->p_osptr->p_ysptr = (p)->p_ysptr; if ((p)->p_ysptr) (p)->p_ysptr->p_osptr = (p)->p_osptr; else (p)->p_pptr->p_cptr = (p)->p_osptr; } while (0);
trickles-server_1.c:10222:        list_del(&p->thread_group);
trickles-server_1.c:10229:        (void)(&p->alloc_lock);
trickles-server_1.c:10244:        (void)(&get_current()->fs->lock);
trickles-server_1.c:10245:        rootmnt = mntget(get_current()->fs->rootmnt);
trickles-server_1.c:10246:        root = dget(get_current()->fs->root);
trickles-server_1.c:10258:        return (__builtin_expect((get_current()->need_resched),0));
trickles-server_1.c:10383:        pg_data_t *pgdat = zone->zone_pgdat;
trickles-server_1.c:10385:        if (zone - pgdat->node_zones < 3 - 1)
trickles-server_1.c:10388:        else if (pgdat->node_next) {
trickles-server_1.c:10389:                pgdat = pgdat->node_next;
trickles-server_1.c:10390:                zone = pgdat->node_zones;
trickles-server_1.c:10402:                char reserved[(1UL << 12) - 10];
trickles-server_1.c:10566:        return (new < 3) ? -1 : 0;
trickles-server_1.c:10832:        FIX_IO_APIC_BASE_END = FIX_IO_APIC_BASE_0 + 8 -1,
trickles-server_1.c:10838:        FIX_BTMAP_BEGIN = FIX_BTMAP_END + 16 - 1,
trickles-server_1.c:10858:        return ((0xffffe000UL) - ((idx) << 12));
trickles-server_1.c:10874:# 1 "/home/ashieh/current/include/asm/pgtable-2level.h" 1
trickles-server_1.c:10875:# 32 "/home/ashieh/current/include/asm/pgtable-2level.h"
trickles-server_1.c:10879:# 55 "/home/ashieh/current/include/asm/pgtable-2level.h"
trickles-server_1.c:10912:        pte.pte_low &= ((~((1UL << 12)-1)) | 0x020 | 0x040);
trickles-server_1.c:10996:        return zone_table[page->flags >> (32 - 8)];
trickles-server_1.c:11001:        page->flags &= ~(~0UL << (32 - 8));
trickles-server_1.c:11002:        page->flags |= zone_num << (32 - 8);
trickles-server_1.c:11116:        return ((&(page)->count)->counter) - !!page->buffers == 1;
trickles-server_1.c:11143:        unsigned long ret = -22;
trickles-server_1.c:11144:        if ((offset + (((len)+(1UL << 12)-1)&(~((1UL << 12)-1)))) < offset)
trickles-server_1.c:11146:        if (!(offset & ~(~((1UL << 12)-1))))
trickles-server_1.c:11147:                ret = do_mmap_pgoff(get_current()->mm, file, addr, len, prot, flag,
trickles-server_1.c:11159:        prev->vm_next = vma->vm_next;
trickles-server_1.c:11160:        rb_erase(&vma->vm_rb, &mm->mm_rb);
trickles-server_1.c:11161:        if (mm->mmap_cache == vma)
trickles-server_1.c:11162:                mm->mmap_cache = prev;
trickles-server_1.c:11167:        if (!vma->vm_file && vma->vm_flags == vm_flags)
trickles-server_1.c:11186:        if (get_current()->flags & 0x00004000)
trickles-server_1.c:11203:        address &= (~((1UL << 12)-1));
trickles-server_1.c:11204:        (void)(&vma->vm_mm->page_table_lock);
trickles-server_1.c:11205:        grow = (vma->vm_start - address) >> 12;
trickles-server_1.c:11206:        if (vma->vm_end - address > get_current()->rlim[3].rlim_cur ||
trickles-server_1.c:11207:            ((vma->vm_mm->total_vm + grow) << 12) > get_current()->rlim[9].rlim_cur) {
trickles-server_1.c:11209:                return -12;
trickles-server_1.c:11211:        vma->vm_start = address;
trickles-server_1.c:11212:        vma->vm_pgoff -= grow;
trickles-server_1.c:11213:        vma->vm_mm->total_vm += grow;
trickles-server_1.c:11214:        if (vma->vm_flags & 0x00002000)
trickles-server_1.c:11215:                vma->vm_mm->locked_vm += grow;
trickles-server_1.c:11231:        if (vma && end_addr <= vma->vm_start)
trickles-server_1.c:11253:                (__builtin_constant_p((1024 - ((((unsigned long)(0xC0000000)))/(1UL << 22))) * sizeof(pgd_t)) ? __constant_memcpy((pgd + ((((unsigned long)(0xC0000000)))/(1UL << 22))),(swapper_pg_dir + ((((unsigned long)(0xC0000000)))/(1UL << 22))),((1024 - ((((unsigned long)(0xC0000000)))/(1UL << 22))) * sizeof(pgd_t))) : __memcpy((pgd + ((((unsigned long)(0xC0000000)))/(1UL << 22))),(swapper_pg_dir + ((((unsigned long)(0xC0000000)))/(1UL << 22))),((1024 - ((((unsigned long)(0xC0000000)))/(1UL << 22))) * sizeof(pgd_t))));
trickles-server_1.c:11269:                (boot_cpu_data.pgtable_cache_sz)--;
trickles-server_1.c:11313:                (boot_cpu_data.pgtable_cache_sz)--;
trickles-server_1.c:11334:        if (mm == get_current()->active_mm)
trickles-server_1.c:11341:        if (vma->vm_mm == get_current()->active_mm)
trickles-server_1.c:11348:        if (mm == get_current()->active_mm)
trickles-server_1.c:11361:static inline void *kmap(struct page *page) { return ((void *)((unsigned long)((((page) - page_zone(page)->zone_mem_map) << 12) + page_zone(page)->zone_start_paddr)+((unsigned long)(0xC0000000)))); }
trickles-server_1.c:11613:        return (list->next == (struct sk_buff *) list);
trickles-server_1.c:11618:        atomic_inc(&skb->users);
trickles-server_1.c:11624:        if (((&skb->users)->counter) == 1 || atomic_dec_and_test(&skb->users))
trickles-server_1.c:11631:        if (((&skb->users)->counter) == 1 || atomic_dec_and_test(&skb->users))
trickles-server_1.c:11637:        return skb->cloned && ((&((struct skb_shared_info *)((skb)->end))->dataref)->counter) != 1;
trickles-server_1.c:11642:        return (((&skb->users)->counter) != 1);
trickles-server_1.c:11668:        struct sk_buff *list = ((struct sk_buff *)list_)->next;
trickles-server_1.c:11676:        struct sk_buff *list = ((struct sk_buff *)list_)->prev;
trickles-server_1.c:11684:        return(list_->qlen);
trickles-server_1.c:11690:        list->prev = (struct sk_buff *)list;
trickles-server_1.c:11691:        list->next = (struct sk_buff *)list;
trickles-server_1.c:11692:        list->qlen = 0;
trickles-server_1.c:11699:        newsk->list = list;
trickles-server_1.c:11700:        list->qlen++;
trickles-server_1.c:11702:        next = prev->next;
trickles-server_1.c:11703:        newsk->next = next;
trickles-server_1.c:11704:        newsk->prev = prev;
trickles-server_1.c:11705:        next->prev = newsk;
trickles-server_1.c:11706:        prev->next = newsk;
trickles-server_1.c:11713:        do { do { __asm__ __volatile__("pushfl ; popl %0":"=g" (flags): ); __asm__ __volatile__("cli": : :"memory"); } while(0);; (void)(&list->lock); } while (0);
trickles-server_1.c:11722:        newsk->list = list;
trickles-server_1.c:11723:        list->qlen++;
trickles-server_1.c:11725:        prev = next->prev;
trickles-server_1.c:11726:        newsk->next = next;
trickles-server_1.c:11727:        newsk->prev = prev;
trickles-server_1.c:11728:        next->prev = newsk;
trickles-server_1.c:11729:        prev->next = newsk;
trickles-server_1.c:11736:        do { do { __asm__ __volatile__("pushfl ; popl %0":"=g" (flags): ); __asm__ __volatile__("cli": : :"memory"); } while(0);; (void)(&list->lock); } while (0);
trickles-server_1.c:11746:        next = prev->next;
trickles-server_1.c:11750:                next = next->next;
trickles-server_1.c:11751:                list->qlen--;
trickles-server_1.c:11752:                next->prev = prev;
trickles-server_1.c:11753:                prev->next = next;
trickles-server_1.c:11754:                result->next = ((void *)0);
trickles-server_1.c:11755:                result->prev = ((void *)0);
trickles-server_1.c:11756:                result->list = ((void *)0);
trickles-server_1.c:11766:        do { do { __asm__ __volatile__("pushfl ; popl %0":"=g" (flags): ); __asm__ __volatile__("cli": : :"memory"); } while(0);; (void)(&list->lock); } while (0);
trickles-server_1.c:11780:        newsk->next = next;
trickles-server_1.c:11781:        newsk->prev = prev;
trickles-server_1.c:11782:        next->prev = newsk;
trickles-server_1.c:11783:        prev->next = newsk;
trickles-server_1.c:11784:        newsk->list = list;
trickles-server_1.c:11785:        list->qlen++;
trickles-server_1.c:11792:        do { do { __asm__ __volatile__("pushfl ; popl %0":"=g" (flags): ); __asm__ __volatile__("cli": : :"memory"); } while(0);; (void)(&old->list->lock); } while (0);
trickles-server_1.c:11793:        __skb_insert(newsk, old->prev, old, old->list);
trickles-server_1.c:11803:        __skb_insert(newsk, old, old->next, old->list);
trickles-server_1.c:11810:        do { do { __asm__ __volatile__("pushfl ; popl %0":"=g" (flags): ); __asm__ __volatile__("cli": : :"memory"); } while(0);; (void)(&old->list->lock); } while (0);
trickles-server_1.c:11824:        list->qlen--;
trickles-server_1.c:11825:        next = skb->next;
trickles-server_1.c:11826:        prev = skb->prev;
trickles-server_1.c:11827:        skb->next = ((void *)0);
trickles-server_1.c:11828:        skb->prev = ((void *)0);
trickles-server_1.c:11829:        skb->list = ((void *)0);
trickles-server_1.c:11830:        next->prev = prev;
trickles-server_1.c:11831:        prev->next = next;
trickles-server_1.c:11836:        struct sk_buff_head *list = skb->list;
trickles-server_1.c:11841:                do { do { __asm__ __volatile__("pushfl ; popl %0":"=g" (flags): ); __asm__ __volatile__("cli": : :"memory"); } while(0);; (void)(&list->lock); } while (0);
trickles-server_1.c:11842:                if(skb->list == list)
trickles-server_1.c:11843:                        __skb_unlink(skb, skb->list);
trickles-server_1.c:11861:        do { do { __asm__ __volatile__("pushfl ; popl %0":"=g" (flags): ); __asm__ __volatile__("cli": : :"memory"); } while(0);; (void)(&list->lock); } while (0);
trickles-server_1.c:11869:        return skb->data_len;
trickles-server_1.c:11874:        return skb->len - skb->data_len;
trickles-server_1.c:11879:        unsigned char *tmp=skb->tail;
trickles-server_1.c:11881:        skb->tail+=len;
trickles-server_1.c:11882:        skb->len+=len;
trickles-server_1.c:11888:        unsigned char *tmp=skb->tail;
trickles-server_1.c:11890:        skb->tail+=len;
trickles-server_1.c:11891:        skb->len+=len;
trickles-server_1.c:11892:        if(skb->tail>skb->end) {
trickles-server_1.c:11900:        skb->data-=len;
trickles-server_1.c:11901:        skb->len+=len;
trickles-server_1.c:11902:        return skb->data;
trickles-server_1.c:11907:        skb->data-=len;
trickles-server_1.c:11908:        skb->len+=len;
trickles-server_1.c:11909:        if(skb->data<skb->head) {
trickles-server_1.c:11912:        return skb->data;
trickles-server_1.c:11917:        skb->len-=len;
trickles-server_1.c:11918:        if (skb->len < skb->data_len)
trickles-server_1.c:11920:        return skb->data+=len;
trickles-server_1.c:11925:        if (len > skb->len)
trickles-server_1.c:11935:            __pskb_pull_tail(skb, len-skb_headlen(skb)) == ((void *)0))
trickles-server_1.c:11937:        skb->len -= len;
trickles-server_1.c:11938:        return skb->data += len;
trickles-server_1.c:11943:        if (len > skb->len)
trickles-server_1.c:11952:        if (len > skb->len)
trickles-server_1.c:11954:        return (__pskb_pull_tail(skb, len-skb_headlen(skb)) != ((void *)0));
trickles-server_1.c:11959:        return skb->data-skb->head;
trickles-server_1.c:11964:        return skb_is_nonlinear(skb) ? 0 : skb->end-skb->tail;
trickles-server_1.c:11969:        skb->data+=len;
trickles-server_1.c:11970:        skb->tail+=len;
trickles-server_1.c:11977:        if (!skb->data_len) {
trickles-server_1.c:11978:                skb->len = len;
trickles-server_1.c:11979:                skb->tail = skb->data+len;
trickles-server_1.c:11987:        if (skb->len > len) {
trickles-server_1.c:11995:        if (!skb->data_len) {
trickles-server_1.c:11996:                skb->len = len;
trickles-server_1.c:11997:                skb->tail = skb->data+len;
trickles-server_1.c:12006:        if (len < skb->len)
trickles-server_1.c:12013:        if (skb->destructor)
trickles-server_1.c:12014:                skb->destructor(skb);
trickles-server_1.c:12015:        skb->destructor = ((void *)0);
trickles-server_1.c:12016:        skb->sk = ((void *)0);
trickles-server_1.c:12054:        int delta = (headroom > 16 ? headroom : 16) - skb_headroom(skb);
trickles-server_1.c:12066:        unsigned int size = skb->len;
trickles-server_1.c:12069:        return skb_pad(skb, len-size);
trickles-server_1.c:12082:        return kmap(frag->page);
trickles-server_1.c:12119:        if (nfct && atomic_dec_and_test(&nfct->master->use))
trickles-server_1.c:12120:                nfct->master->destroy(nfct->master);
trickles-server_1.c:12126:                atomic_inc(&nfct->master->use);
trickles-server_1.c:12150:# 6 "trickles-int.h" 2
trickles-server_1.c:12177:        return (({ unsigned long flag,sum; asm("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0" :"=&r" (flag), "=r" (sum) :"1" (addr),"g" ((int)(size)),"g" (get_current()->addr_limit.seg)); flag; }) == 0) ? 0 : -14;
trickles-server_1.c:12224:        if ((({ unsigned long flag,sum; asm("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0" :"=&r" (flag), "=r" (sum) :"1" (to),"g" ((int)(n)),"g" (get_current()->addr_limit.seg)); flag; }) == 0))
trickles-server_1.c:12232:        if ((({ unsigned long flag,sum; asm("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0" :"=&r" (flag), "=r" (sum) :"1" (from),"g" ((int)(n)),"g" (get_current()->addr_limit.seg)); flag; }) == 0))
trickles-server_1.c:12278:        pt->error = 0;
trickles-server_1.c:12279:        pt->table = ((void *)0);
trickles-server_1.c:12296:        nr = ((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long));
trickles-server_1.c:12301:                        error = -14;
trickles-server_1.c:12312:                (__builtin_constant_p(((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long))) ? __constant_copy_to_user_nocheck((ufdset),(fdset),(((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)))) : __generic_copy_to_user_nocheck((ufdset),(fdset),(((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)))));
trickles-server_1.c:12318:        (__builtin_constant_p(0) ? (__builtin_constant_p((((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)))) ? __constant_c_and_count_memset(((fdset)),((0x01010101UL*(unsigned char)(0))),((((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long))))) : __constant_c_memset(((fdset)),((0x01010101UL*(unsigned char)(0))),((((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)))))) : (__builtin_constant_p((((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)))) ? __memset_generic((((fdset))),(((0))),(((((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)))))) : __memset_generic(((fdset)),((0)),((((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)))))));
trickles-server_1.c:12432:  unsigned char __pad[16 - sizeof(short int) -
trickles-server_1.c:12433:                        sizeof(unsigned short int) - sizeof(struct in_addr)];
trickles-server_1.c:12899:        unsigned long hh_data[(((32)+(16 -1))&~(16 - 1)) / sizeof(long)];
trickles-server_1.c:13251:        eip -= (unsigned long) &_stext;
trickles-server_1.c:13258:        if (eip > prof_len-1)
trickles-server_1.c:13259:                eip = prof_len-1;
trickles-server_1.c:13348:        if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
trickles-server_1.c:13356:        if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
trickles-server_1.c:13363:        atomic_inc(&t->count);
trickles-server_1.c:13377:        atomic_dec(&t->count);
trickles-server_1.c:13383:        atomic_dec(&t->count);
trickles-server_1.c:13486:        if (!test_and_set_bit(__LINK_STATE_SCHED, &dev->state)) {
trickles-server_1.c:13491:                dev->next_sched = softnet_data[cpu].output_queue;
trickles-server_1.c:13500:        if (!(__builtin_constant_p(__LINK_STATE_XOFF) ? constant_test_bit((__LINK_STATE_XOFF),(&dev->state)) : variable_test_bit((__LINK_STATE_XOFF),(&dev->state))))
trickles-server_1.c:13506:        clear_bit(__LINK_STATE_XOFF, &dev->state);
trickles-server_1.c:13511:        if (test_and_clear_bit(__LINK_STATE_XOFF, &dev->state))
trickles-server_1.c:13517:        set_bit(__LINK_STATE_XOFF, &dev->state);
trickles-server_1.c:13522:        return (__builtin_constant_p(__LINK_STATE_XOFF) ? constant_test_bit((__LINK_STATE_XOFF),(&dev->state)) : variable_test_bit((__LINK_STATE_XOFF),(&dev->state)));
trickles-server_1.c:13527:        return (__builtin_constant_p(__LINK_STATE_START) ? constant_test_bit((__LINK_STATE_START),(&dev->state)) : variable_test_bit((__LINK_STATE_START),(&dev->state)));
trickles-server_1.c:13536:        if (atomic_dec_and_test(&skb->users)) {
trickles-server_1.c:13541:                skb->next = softnet_data[cpu].completion_queue;
trickles-server_1.c:13592:        if (atomic_dec_and_test(&dev->refcnt))
trickles-server_1.c:13598:        return !(__builtin_constant_p(__LINK_STATE_NOCARRIER) ? constant_test_bit((__LINK_STATE_NOCARRIER),(&dev->state)) : variable_test_bit((__LINK_STATE_NOCARRIER),(&dev->state)));
trickles-server_1.c:13605:        clear_bit(__LINK_STATE_NOCARRIER, &dev->state);
trickles-server_1.c:13612:        set_bit(__LINK_STATE_NOCARRIER, &dev->state);
trickles-server_1.c:13618:        return (__builtin_constant_p(__LINK_STATE_PRESENT) ? constant_test_bit((__LINK_STATE_PRESENT),(&dev->state)) : variable_test_bit((__LINK_STATE_PRESENT),(&dev->state)));
trickles-server_1.c:13623:        if (test_and_clear_bit(__LINK_STATE_PRESENT, &dev->state) &&
trickles-server_1.c:13631:        if (!test_and_set_bit(__LINK_STATE_PRESENT, &dev->state) &&
trickles-server_1.c:13664:                !test_and_set_bit(__LINK_STATE_RX_SCHED, &dev->state);
trickles-server_1.c:13677:        atomic_inc(&(dev)->refcnt);
trickles-server_1.c:13678:        list_add_tail(&dev->poll_list, &softnet_data[cpu].poll_list);
trickles-server_1.c:13679:        if (dev->quota < 0)
trickles-server_1.c:13680:                dev->quota += dev->weight;
trickles-server_1.c:13682:                dev->quota = dev->weight;
trickles-server_1.c:13704:                dev->quota += undo;
trickles-server_1.c:13707:                list_add_tail(&dev->poll_list, &softnet_data[cpu].poll_list);
trickles-server_1.c:13725:        if (!(__builtin_constant_p(__LINK_STATE_RX_SCHED) ? constant_test_bit((__LINK_STATE_RX_SCHED),(&dev->state)) : variable_test_bit((__LINK_STATE_RX_SCHED),(&dev->state)))) do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0);
trickles-server_1.c:13726:        list_del(&dev->poll_list);
trickles-server_1.c:13728:        clear_bit(__LINK_STATE_RX_SCHED, &dev->state);
trickles-server_1.c:13734:        while (test_and_set_bit(__LINK_STATE_RX_SCHED, &dev->state)) {
trickles-server_1.c:13736:                get_current()->state = 1;
trickles-server_1.c:13743:        clear_bit(__LINK_STATE_RX_SCHED, &dev->state);
trickles-server_1.c:13751:        if (!(__builtin_constant_p(__LINK_STATE_RX_SCHED) ? constant_test_bit((__LINK_STATE_RX_SCHED),(&dev->state)) : variable_test_bit((__LINK_STATE_RX_SCHED),(&dev->state)))) do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0);
trickles-server_1.c:13752:        list_del(&dev->poll_list);
trickles-server_1.c:13754:        clear_bit(__LINK_STATE_RX_SCHED, &dev->state);
trickles-server_1.c:13759:        do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&dev->xmit_lock); } while (0);
trickles-server_1.c:13761:        do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0);
trickles-server_1.c:14107:        return fp->len*sizeof(struct sock_filter) + sizeof(*fp);
trickles-server_1.c:14170:        unsigned char ha[(8 +sizeof(unsigned long)-1)&~(sizeof(unsigned long)-1)];
trickles-server_1.c:14278:        if (atomic_dec_and_test(&neigh->refcnt))
trickles-server_1.c:14285:                atomic_inc(&neigh->refcnt);
trickles-server_1.c:14294:                neigh->confirmed = jiffies;
trickles-server_1.c:14299:        return neigh->nud_state&(0x80|0x40|0x02);
trickles-server_1.c:14304:        return neigh->nud_state&(0x80|0x40|0x02|0x10|0x04|0x08);
trickles-server_1.c:14309:        neigh->used = jiffies;
trickles-server_1.c:14310:        if (!(neigh->nud_state&((0x80|0x40|0x02)|0x08|0x10)))
trickles-server_1.c:14408:        atomic_inc(&dst->__refcnt);
trickles-server_1.c:14415:                atomic_inc(&dst->__refcnt);
trickles-server_1.c:14423:                atomic_dec(&dst->__refcnt);
trickles-server_1.c:14433:        if (dst->obsolete > 1)
trickles-server_1.c:14435:        if (!((&dst->__refcnt)->counter)) {
trickles-server_1.c:14445:                neigh_confirm(dst->neighbour);
trickles-server_1.c:14451:        if (dst && dst->ops->negative_advice)
trickles-server_1.c:14452:                *dst_p = dst->ops->negative_advice(dst);
trickles-server_1.c:14457:        struct dst_entry * dst = skb->dst;
trickles-server_1.c:14458:        if (dst && dst->ops && dst->ops->link_failure)
trickles-server_1.c:14459:                dst->ops->link_failure(skb);
trickles-server_1.c:14469:        if (dst->expires == 0 || (long)(dst->expires - expires) > 0)
trickles-server_1.c:14470:                dst->expires = expires;
trickles-server_1.c:14561:        head->next = head->prev = ((void *)0);
trickles-server_1.c:14573:        for (elem = (typeof(elem))(list)->next; (elem != (typeof(elem))(list)); elem=(typeof(elem))elem->next) {
trickles-server_1.c:14584:        dlist->next = dlist->prev = (struct list_link*)dlist;
trickles-server_1.c:14588:        if(head->next == elem ) {
trickles-server_1.c:14592:        elem->next = head->next;
trickles-server_1.c:14593:        head->next->prev = elem;
trickles-server_1.c:14595:        elem->prev = (struct list_link *)head;
trickles-server_1.c:14596:        head->next = elem;
trickles-server_1.c:14600:        if(head->prev == elem ) {
trickles-server_1.c:14604:        elem->next = (struct list_link *)head;
trickles-server_1.c:14605:        elem->prev = head->prev;
trickles-server_1.c:14606:        head->prev->next = elem;
trickles-server_1.c:14607:        head->prev = elem;
trickles-server_1.c:14611:        if(head->prev == elem ) {
trickles-server_1.c:14615:        elem->next = (struct list_link *)head;
trickles-server_1.c:14616:        elem->prev = head->prev;
trickles-server_1.c:14618:        head->prev->next = elem;
trickles-server_1.c:14619:        head->prev = elem;
trickles-server_1.c:14623:        elem->next->prev = elem->prev;
trickles-server_1.c:14624:        elem->prev->next = elem->next;
trickles-server_1.c:14625:        elem->prev = elem->next = ((void *)0);
trickles-server_1.c:14629:        return (struct dlist *)list->next == list;
trickles-server_1.c:14683:        vec->num = 0;
trickles-server_1.c:14684:        vec->size = initSize;
trickles-server_1.c:14685:        vec->elems = kmalloc(vec->size * sizeof(vec->elems[0]), (0x20));
trickles-server_1.c:14686:        if(vec->elems == ((void *)0)) {
trickles-server_1.c:14693:        kfree(vec->elems);
trickles-server_1.c:14697:        if(vec->num == vec->size) {
trickles-server_1.c:14699:                vec->size *= 2;
trickles-server_1.c:14700:                newElems = kmalloc(vec->size * sizeof(newElems[0]), (0x20));
trickles-server_1.c:14708:        vec->elems[vec->num++] = newElem;
trickles-server_1.c:14718:        return head->next == (struct alloc_head*)head;
trickles-server_1.c:14722:        head->next = head->prev = (struct alloc_head*)head;
trickles-server_1.c:14723:        head->list = head;
trickles-server_1.c:14724:        head->len = 0;
trickles-server_1.c:14733:        if(head->next == elem ) {
trickles-server_1.c:14737:        elem->next = head->next;
trickles-server_1.c:14738:        head->next->prev = elem;
trickles-server_1.c:14740:        elem->prev = (struct alloc_head*)head;
trickles-server_1.c:14741:        head->next = elem;
trickles-server_1.c:14743:        elem->list = head;
trickles-server_1.c:14744:        head->len++;
trickles-server_1.c:14753:        if(head->prev == elem ) {
trickles-server_1.c:14758:        elem->next = (struct alloc_head*)head;
trickles-server_1.c:14760:        elem->prev = head->prev;
trickles-server_1.c:14762:        head->prev->next = elem;
trickles-server_1.c:14764:        elem->list = head;
trickles-server_1.c:14765:        head->prev = elem;
trickles-server_1.c:14766:        head->len++;
trickles-server_1.c:14775:        if(head->prev == elem ) {
trickles-server_1.c:14780:        elem->next = (struct alloc_head*)head;
trickles-server_1.c:14781:        elem->prev = head->prev;
trickles-server_1.c:14785:        head->prev->next = elem;
trickles-server_1.c:14787:        elem->next = (struct alloc_head*)head;
trickles-server_1.c:14789:        elem->list = head;
trickles-server_1.c:14790:        head->prev = elem;
trickles-server_1.c:14791:        head->len++;
trickles-server_1.c:14801:        elem->next->prev = elem->prev;
trickles-server_1.c:14802:        elem->prev->next = elem->next;
trickles-server_1.c:14803:        elem->prev = elem->next = ((void *)0);
trickles-server_1.c:14805:        elem->list->len--;
trickles-server_1.c:14806:        elem->list = ((void *)0);
trickles-server_1.c:14811:        if(!(elem->next == ((void *)0) && elem->prev == ((void *)0))) do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0);
trickles-server_1.c:14812:        elem->next = prev->next;
trickles-server_1.c:14813:        prev->next = elem;
trickles-server_1.c:14815:        elem->prev = prev;
trickles-server_1.c:14816:        next->prev = elem;
trickles-server_1.c:14818:        elem->list = prev->list;
trickles-server_1.c:14819:        elem->list->len++;
trickles-server_1.c:14863:  pkt->nonce = -1;
trickles-server_1.c:14864:  pkt->seq = seq;
trickles-server_1.c:14866:  pkt->len = len;
trickles-server_1.c:14867:  pkt->type = type;
trickles-server_1.c:14868:  pkt->contType = contType;
trickles-server_1.c:14869:  pkt->minResponseLen = minResponseLen;
trickles-server_1.c:14870:  pkt->firstTransportChild = firstTransportChild;
trickles-server_1.c:14871:  pkt->numTransportChildren = numTransportChildren;
trickles-server_1.c:14872:  pkt->ucontLen = 0;
trickles-server_1.c:14873:  pkt->ucontData = ((void *)0);
trickles-server_1.c:14874:  pkt->numSiblings = -1;
trickles-server_1.c:14875:  pkt->position = (0xff);
trickles-server_1.c:14880:        if(len > packet->len + packet->ucontLen) {
trickles-server_1.c:14882:                       (int) len, packet->len, packet->ucontLen);
trickles-server_1.c:14885:        if(packet->ucontData) {
trickles-server_1.c:14886:                kfree(packet->ucontData);
trickles-server_1.c:14887:                packet->len += packet->ucontLen;
trickles-server_1.c:14888:                packet->ucontLen = 0;
trickles-server_1.c:14890:        packet->ucontData = buf;
trickles-server_1.c:14891:        packet->ucontLen = len;
trickles-server_1.c:14892:        packet->len -= packet->ucontLen;
trickles-server_1.c:15303:        int size = ((len)+( ((sizeof(struct nlmsghdr))+4 -1) & ~(4 -1) ));
trickles-server_1.c:15305:        nlh = (struct nlmsghdr*)skb_put(skb, ( ((size)+4 -1) & ~(4 -1) ));
trickles-server_1.c:15306:        nlh->nlmsg_type = type;
trickles-server_1.c:15307:        nlh->nlmsg_len = size;
trickles-server_1.c:15308:        nlh->nlmsg_flags = 0;
trickles-server_1.c:15309:        nlh->nlmsg_pid = pid;
trickles-server_1.c:15310:        nlh->nlmsg_seq = seq;
trickles-server_1.c:15591:        return len > rta->rta_len || __builtin_memcmp(((void*)(((char*)(rta)) + (( ((sizeof(struct rtattr))+4 -1) & ~(4 -1) ) + (0)))), str, len);
trickles-server_1.c:15788:        printk("PHChunk %p = { type = %d, chunkLen = %d, range=[%d-%d] }\n",
trickles-server_1.c:15789:               phchunk, phchunk->type, ntohs(phchunk->chunkLen),
trickles-server_1.c:15790:               ntohl(phchunk->start), ntohl(phchunk->end));
trickles-server_1.c:15825:        return (d->type == RCHUNK_DATA ||
trickles-server_1.c:15826:                d->type == RCHUNK_SKIP ||
trickles-server_1.c:15827:                d->type == RCHUNK_FINHINT);
trickles-server_1.c:15833:        switch(d->type) {
trickles-server_1.c:15835:                if (!((c1 = !(d->flags & ~0x1)))) { printk("KERNEL: assertion (" "(c1 = !(d->flags & ~DCHUNK_FIN))" ") failed at " "/home/ashieh/current/include/net/trickles_packet.h" "(%d)\n", 286); };
trickles-server_1.c:15839:                if (!((c1 = (d->flags == 0)))) { printk("KERNEL: assertion (" "(c1 = (d->flags == 0))" ") failed at " "/home/ashieh/current/include/net/trickles_packet.h" "(%d)\n", 290); };
trickles-server_1.c:16677:                u8 __pad[(1 << ((5))) - sizeof(int)];
trickles-server_1.c:16684:        prot->stats[0].inuse++;
trickles-server_1.c:16689:        prot->stats[0].inuse--;
trickles-server_1.c:16784:        if (sk->filter) {
trickles-server_1.c:16788:                        (void)(&((sk)->lock.slock));
trickles-server_1.c:16790:                filter = sk->filter;
trickles-server_1.c:16792:                        int pkt_len = sk_run_filter(skb, filter->insns,
trickles-server_1.c:16793:                                                    filter->len);
trickles-server_1.c:16795:                                err = -1;
trickles-server_1.c:16810:        atomic_sub(size, &sk->omem_alloc);
trickles-server_1.c:16812:        if (atomic_dec_and_test(&fp->refcnt))
trickles-server_1.c:16818:        atomic_inc(&fp->refcnt);
trickles-server_1.c:16819:        atomic_add(sk_filter_len(fp), &sk->omem_alloc);
trickles-server_1.c:16824:        atomic_inc(&sk->refcnt);
trickles-server_1.c:16832:        atomic_dec(&sk->refcnt);
trickles-server_1.c:16838:        if (atomic_dec_and_test(&sk->refcnt))
trickles-server_1.c:16844:        do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&sk->callback_lock); } while (0);
trickles-server_1.c:16845:        sk->dead = 1;
trickles-server_1.c:16846:        sk->socket = ((void *)0);
trickles-server_1.c:16847:        sk->sleep = ((void *)0);
trickles-server_1.c:16848:        do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0);
trickles-server_1.c:16853:        do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&sk->callback_lock); } while (0);
trickles-server_1.c:16854:        sk->sleep = &parent->wait;
trickles-server_1.c:16855:        parent->sk = sk;
trickles-server_1.c:16856:        sk->socket = parent;
trickles-server_1.c:16857:        do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0);
trickles-server_1.c:16864:        (void)(&sk->callback_lock);
trickles-server_1.c:16865:        uid = sk->socket ? sk->socket->inode->i_uid : 0;
trickles-server_1.c:16874:        (void)(&sk->callback_lock);
trickles-server_1.c:16875:        ino = sk->socket ? sk->socket->inode->i_ino : 0;
trickles-server_1.c:16883:        return sk->dst_cache;
trickles-server_1.c:16891:        (void)(&sk->dst_lock);
trickles-server_1.c:16892:        dst = sk->dst_cache;
trickles-server_1.c:16904:        old_dst = sk->dst_cache;
trickles-server_1.c:16905:        sk->dst_cache = dst;
trickles-server_1.c:16912:        (void)(&sk->dst_lock);
trickles-server_1.c:16922:        old_dst = sk->dst_cache;
trickles-server_1.c:16923:        sk->dst_cache = ((void *)0);
trickles-server_1.c:16930:        (void)(&sk->dst_lock);
trickles-server_1.c:16938:        struct dst_entry *dst = sk->dst_cache;
trickles-server_1.c:16940:        if (dst && dst->obsolete && dst->ops->check(dst, cookie) == ((void *)0)) {
trickles-server_1.c:16941:                sk->dst_cache = ((void *)0);
trickles-server_1.c:16953:        if (dst && dst->obsolete && dst->ops->check(dst, cookie) == ((void *)0)) {
trickles-server_1.c:16964:        skb->sk = sk;
trickles-server_1.c:16965:        skb->destructor = sock_wfree;
trickles-server_1.c:16966:        atomic_add(skb->truesize, &sk->wmem_alloc);
trickles-server_1.c:16971:        skb->sk = sk;
trickles-server_1.c:16972:        skb->destructor = sock_rfree;
trickles-server_1.c:16973:        atomic_add(skb->truesize, &sk->rmem_alloc);
trickles-server_1.c:16984:        if (((&sk->rmem_alloc)->counter) + skb->truesize >= (unsigned)sk->rcvbuf) {
trickles-server_1.c:16985:                err = -12;
trickles-server_1.c:16997:        skb->dev = ((void *)0);
trickles-server_1.c:17005:        skb_len = skb->len;
trickles-server_1.c:17007:        skb_queue_tail(&sk->receive_queue, skb);
trickles-server_1.c:17008:        if (!sk->dead)
trickles-server_1.c:17009:                sk->data_ready(sk,skb_len);
trickles-server_1.c:17019:        if (((&sk->rmem_alloc)->counter) + skb->truesize >= (unsigned)sk->rcvbuf)
trickles-server_1.c:17020:                return -12;
trickles-server_1.c:17022:        skb_queue_tail(&sk->error_queue,skb);
trickles-server_1.c:17023:        if (!sk->dead)
trickles-server_1.c:17024:                sk->data_ready(sk,skb->len);
trickles-server_1.c:17034:        int err=((__typeof__(*(&sk->err)))__xchg((unsigned long)(0),(&sk->err),sizeof(*(&sk->err))));
trickles-server_1.c:17035:        return -err;
trickles-server_1.c:17042:        if (!(sk->shutdown & 2)) {
trickles-server_1.c:17043:                amt = sk->sndbuf - ((&sk->wmem_alloc)->counter);
trickles-server_1.c:17052:        if (sk->socket && sk->socket->fasync_list)
trickles-server_1.c:17053:                sock_wake_async(sk->socket, how, band);
trickles-server_1.c:17064:        return ((&sk->wmem_alloc)->counter) < (sk->sndbuf / 2);
trickles-server_1.c:17074:        return noblock ? 0 : sk->rcvtimeo;
trickles-server_1.c:17079:        return noblock ? 0 : sk->sndtimeo;
trickles-server_1.c:17084:        return (waitall ? len : ({ int __x = (sk->rcvlowat); int __y = (len); __x < __y ? __x: __y; })) ? : 1;
trickles-server_1.c:17092:        return timeo == ((long)(~0UL>>1)) ? -512 : -4;
trickles-server_1.c:17098:        if (sk->rcvtstamp)
trickles-server_1.c:17099:                put_cmsg(msg, 1, 29, sizeof(skb->stamp), &skb->stamp);
trickles-server_1.c:17101:                sk->stamp = skb->stamp;
trickles-server_1.c:17197:        return !((addr^ifa->ifa_address)&ifa->ifa_mask);
trickles-server_1.c:17223:        in_dev = dev->ip_ptr;
trickles-server_1.c:17225:                atomic_inc(&in_dev->refcnt);
trickles-server_1.c:17233:        return (struct in_device*)dev->ip_ptr;
trickles-server_1.c:17241:        if (atomic_dec_and_test(&idev->refcnt))
trickles-server_1.c:17253:                return htonl(~((1<<(32-logmask))-1));
trickles-server_1.c:17261:        return 32 - ffz(~mask);
trickles-server_1.c:17296:        if (atomic_dec_and_test(&p->refcnt)) {
trickles-server_1.c:17297:                p->unused_prevp = inet_peer_unused_tailp;
trickles-server_1.c:17298:                p->unused_next = ((void *)0);
trickles-server_1.c:17300:                inet_peer_unused_tailp = &p->unused_next;
trickles-server_1.c:17301:                p->dtime = jiffies;
trickles-server_1.c:17303:        do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0);
trickles-server_1.c:17313:        id = p->ip_id_count++;
trickles-server_1.c:17314:        do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0);
trickles-server_1.c:17449:                dst_release(&rt->u.dst);
trickles-server_1.c:17467:        dst = (*rp)->rt_dst;
trickles-server_1.c:17468:        src = (*rp)->rt_src;
trickles-server_1.c:17478:        if (rt->peer)
trickles-server_1.c:17479:                return rt->peer;
trickles-server_1.c:17482:        return rt->peer;
trickles-server_1.c:17924:        if (skb->len > skb->dst->pmtu)
trickles-server_1.c:17935:        u32 check = iph->check;
trickles-server_1.c:17937:        iph->check = check + (check>=0xFFFF);
trickles-server_1.c:17938:        return --iph->ttl;
trickles-server_1.c:17944:        return (sk->protinfo.af_inet.pmtudisc == 2 ||
trickles-server_1.c:17945:                (sk->protinfo.af_inet.pmtudisc == 1 &&
trickles-server_1.c:17946:                 !(dst->mxlock&(1<<RTAX_MTU))));
trickles-server_1.c:17953:        if (iph->frag_off&((__u16)( (((__u16)((0x4000)) & (__u16)0x00ffU) << 8) | (((__u16)((0x4000)) & (__u16)0xff00U) >> 8) ))) {
trickles-server_1.c:17959:                iph->id = ((sk && sk->daddr) ? htons(sk->protinfo.af_inet.id++) : 0);
trickles-server_1.c:18172:        if ((({ unsigned long flag,sum; asm("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0" :"=&r" (flag), "=r" (sum) :"1" (dst),"g" ((int)(len)),"g" (get_current()->addr_limit.seg)); flag; }) == 0))
trickles-server_1.c:18176:                *err_ptr = -14;
trickles-server_1.c:18178:        return -1;
trickles-server_1.c:18190:                *err_ptr = -14;
trickles-server_1.c:18287:        return (lport & ((tcp_hashinfo.__tcp_bhash_size) - 1));
trickles-server_1.c:18339:        if (atomic_dec_and_test(&tw->refcnt)) {
trickles-server_1.c:18356:        return num & (32 - 1);
trickles-server_1.c:18361:        return tcp_lhashfn(sk->num);
trickles-server_1.c:18457:        req->class->destructor(req);
trickles-server_1.c:18510:        return (__s32)(seq1-seq2) < 0;
trickles-server_1.c:18515:        return (__s32)(seq2-seq1) < 0;
trickles-server_1.c:18522:        return seq3 - seq2 >= seq1 - seq2;
trickles-server_1.c:18575:        tp->ack.pending |= TCP_ACK_SCHED;
trickles-server_1.c:18580:        return tp->ack.pending&TCP_ACK_SCHED;
trickles-server_1.c:18585:        if (tp->ack.quick && --tp->ack.quick == 0) {
trickles-server_1.c:18587:                tp->ack.ato = ((unsigned)(100/25));
trickles-server_1.c:18595:        (__builtin_constant_p(0) ? (__builtin_constant_p((sizeof(tp->ack))) ? __constant_c_and_count_memset(((&tp->ack)),((0x01010101UL*(unsigned char)(0))),((sizeof(tp->ack)))) : __constant_c_memset(((&tp->ack)),((0x01010101UL*(unsigned char)(0))),((sizeof(tp->ack))))) : (__builtin_constant_p((sizeof(tp->ack))) ? __memset_generic((((&tp->ack))),(((0))),(((sizeof(tp->ack))))) : __memset_generic(((&tp->ack)),((0)),((sizeof(tp->ack))))));
trickles-server_1.c:18600:        tp->tstamp_ok = tp->sack_ok = tp->wscale_ok = tp->snd_wscale = 0;
trickles-server_1.c:18743:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_1.c:18748:                tp->pending = 0;
trickles-server_1.c:18757:                tp->ack.blocked = 0;
trickles-server_1.c:18758:                tp->ack.pending = 0;
trickles-server_1.c:18778:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_1.c:18790:                tp->pending = what;
trickles-server_1.c:18791:                tp->timeout = jiffies+when;
trickles-server_1.c:18792:                if (!mod_timer(&tp->retransmit_timer, tp->timeout))
trickles-server_1.c:18797:                tp->ack.pending |= TCP_ACK_TIMER;
trickles-server_1.c:18798:                tp->ack.timeout = jiffies+when;
trickles-server_1.c:18799:                if (!mod_timer(&tp->delack_timer, tp->ack.timeout))
trickles-server_1.c:18814:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_1.c:18816:        int mss_now = tp->mss_cache;
trickles-server_1.c:18818:        if (dst && dst->pmtu != tp->pmtu_cookie)
trickles-server_1.c:18819:                mss_now = tcp_sync_mss(sk, dst->pmtu);
trickles-server_1.c:18821:        if (tp->eff_sacks)
trickles-server_1.c:18822:                mss_now -= (4 +
trickles-server_1.c:18823:                            (tp->eff_sacks * 8));
trickles-server_1.c:18829:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_1.c:18830:        unsigned int hint = ({ const typeof(tp->advmss) _x = (tp->advmss); const typeof(tp->mss_cache) _y = (tp->mss_cache); (void) (&_x == &_y); _x < _y ? _x : _y; });
trickles-server_1.c:18832:        hint = ({ const typeof(hint) _x = (hint); const typeof(tp->rcv_wnd/2) _y = (tp->rcv_wnd/2); (void) (&_x == &_y); _x < _y ? _x : _y; });
trickles-server_1.c:18836:        tp->ack.rcv_mss = hint;
trickles-server_1.c:18841:        tp->pred_flags = htonl((tp->tcp_header_len << 26) |
trickles-server_1.c:18848:        __tcp_fast_path_on(tp, tp->snd_wnd>>tp->snd_wscale);
trickles-server_1.c:18853:        if (skb_queue_len(&tp->out_of_order_queue) == 0 &&
trickles-server_1.c:18854:            tp->rcv_wnd &&
trickles-server_1.c:18855:            ((&sk->rmem_alloc)->counter) < sk->rcvbuf &&
trickles-server_1.c:18856:            !tp->urg_data)
trickles-server_1.c:18866:        s32 win = tp->rcv_wup + tp->rcv_wnd - tp->rcv_nxt;
trickles-server_1.c:18947:        u32 check = iph->check;
trickles-server_1.c:18949:        iph->check = check + (check>=0xFFFF);
trickles-server_1.c:18950:        iph->tos |= 1;
trickles-server_1.c:18970:        if (tp->ecn_flags&1)
trickles-server_1.c:18971:                tp->ecn_flags |= 2;
trickles-server_1.c:18980:        ((struct tcp_skb_cb *)&((skb)->cb[0]))->flags &= ~0x80;
trickles-server_1.c:18981:        if (!(tp->ecn_flags&1))
trickles-server_1.c:18982:                ((struct tcp_skb_cb *)&((skb)->cb[0]))->flags &= ~0x40;
trickles-server_1.c:18988:        tp->ecn_flags = 0;
trickles-server_1.c:18990:                ((struct tcp_skb_cb *)&((skb)->cb[0]))->flags |= 0x40|0x80;
trickles-server_1.c:18991:                tp->ecn_flags = 1;
trickles-server_1.c:18998:        if (req->ecn_ok)
trickles-server_1.c:18999:                th->ece = 1;
trickles-server_1.c:19005:        if (tp->ecn_flags & 1) {
trickles-server_1.c:19007:                if (skb->len != tcp_header_len &&
trickles-server_1.c:19008:                    !before(((struct tcp_skb_cb *)&((skb)->cb[0]))->seq, tp->snd_nxt)) {
trickles-server_1.c:19009:                        do { (sk)->protinfo.af_inet.tos |= 2; } while (0);
trickles-server_1.c:19010:                        if (tp->ecn_flags&2) {
trickles-server_1.c:19011:                                tp->ecn_flags &= ~2;
trickles-server_1.c:19012:                                skb->h.th->cwr = 1;
trickles-server_1.c:19016:                        do { (sk)->protinfo.af_inet.tos &= ~3; } while (0);
trickles-server_1.c:19018:                if (tp->ecn_flags & 4)
trickles-server_1.c:19019:                        skb->h.th->ece = 1;
trickles-server_1.c:19028:        if (skb->h.th->cwr)
trickles-server_1.c:19029:                tp->ecn_flags &= ~4;
trickles-server_1.c:19035:        tp->ecn_flags &= ~4;
trickles-server_1.c:19041:        if (tp->ecn_flags&1) {
trickles-server_1.c:19042:                if (INET_ECN_is_ce(((struct tcp_skb_cb *)&((skb)->cb[0]))->flags))
trickles-server_1.c:19043:                        tp->ecn_flags |= 4;
trickles-server_1.c:19047:                else if (!INET_ECN_is_capable((((struct tcp_skb_cb *)&((skb)->cb[0]))->flags)))
trickles-server_1.c:19055:        if ((tp->ecn_flags&1) && (!th->ece || th->cwr))
trickles-server_1.c:19056:                tp->ecn_flags &= ~1;
trickles-server_1.c:19062:        if ((tp->ecn_flags&1) && (!th->ece || !th->cwr))
trickles-server_1.c:19063:                tp->ecn_flags &= ~1;
trickles-server_1.c:19069:        if (th->ece && !th->syn && (tp->ecn_flags&1))
trickles-server_1.c:19077:        tp->ecn_flags = req->ecn_ok ? 1 : 0;
trickles-server_1.c:19083:        if (sysctl_tcp_ecn && th->ece && th->cwr)
trickles-server_1.c:19084:                req->ecn_ok = 1;
trickles-server_1.c:19094:        return sk->wmem_queued/2;
trickles-server_1.c:19099:        return sk->sndbuf - sk->wmem_queued;
trickles-server_1.c:19104:        return tp->packets_out - tp->left_out + tp->retrans_out;
trickles-server_1.c:19114:        return ({ const typeof(tp->snd_cwnd >> 1U) _x = (tp->snd_cwnd >> 1U); const typeof(2U) _y = (2U); (void) (&_x == &_y); _x > _y ? _x : _y; });
trickles-server_1.c:19123:        if ((1<<tp->ca_state)&((1<<TCP_CA_CWR)|(1<<TCP_CA_Recovery)))
trickles-server_1.c:19124:                return tp->snd_ssthresh;
trickles-server_1.c:19126:                return ({ const typeof(tp->snd_ssthresh) _x = (tp->snd_ssthresh); const typeof(((tp->snd_cwnd >> 1) + (tp->snd_cwnd >> 2))) _y = (((tp->snd_cwnd >> 1) + (tp->snd_cwnd >> 2))); (void) (&_x == &_y); _x > _y ? _x : _y; });
trickles-server_1.c:19133:        if (tp->sack_ok && tp->sacked_out >= tp->packets_out - tp->lost_out)
trickles-server_1.c:19134:                tp->sacked_out = tp->packets_out - tp->lost_out;
trickles-server_1.c:19135:        tp->left_out = tp->sacked_out + tp->lost_out;
trickles-server_1.c:19144:        if (tp->packets_out >= tp->snd_cwnd) {
trickles-server_1.c:19146:                tp->snd_cwnd_used = 0;
trickles-server_1.c:19147:                tp->snd_cwnd_stamp = ((__u32)(jiffies));
trickles-server_1.c:19150:                if (tp->packets_out > tp->snd_cwnd_used)
trickles-server_1.c:19151:                        tp->snd_cwnd_used = tp->packets_out;
trickles-server_1.c:19153:                if ((s32)(((__u32)(jiffies)) - tp->snd_cwnd_stamp) >= tp->rto)
trickles-server_1.c:19161:        tp->undo_marker = 0;
trickles-server_1.c:19162:        tp->snd_ssthresh = tcp_recalc_ssthresh(tp);
trickles-server_1.c:19163:        tp->snd_cwnd = ({ const typeof(tp->snd_cwnd) _x = (tp->snd_cwnd); const typeof(tcp_packets_in_flight(tp) + 1U) _y = (tcp_packets_in_flight(tp) + 1U); (void) (&_x == &_y); _x < _y ? _x : _y; });
trickles-server_1.c:19165:        tp->snd_cwnd_cnt = 0;
trickles-server_1.c:19166:        tp->high_seq = tp->snd_nxt;
trickles-server_1.c:19167:        tp->snd_cwnd_stamp = ((__u32)(jiffies));
trickles-server_1.c:19173:        tp->prior_ssthresh = 0;
trickles-server_1.c:19174:        if (tp->ca_state < TCP_CA_CWR) {
trickles-server_1.c:19176:                tp->ca_state = TCP_CA_CWR;
trickles-server_1.c:19192:        return after(tp->snd_sml,tp->snd_una) &&
trickles-server_1.c:19193:                !after(tp->snd_sml, tp->snd_nxt);
trickles-server_1.c:19198:        if (skb->len < mss)
trickles-server_1.c:19199:                tp->snd_sml = ((struct tcp_skb_cb *)&((skb)->cb[0]))->end_seq;
trickles-server_1.c:19205:        return (skb->len < mss_now &&
trickles-server_1.c:19206:                !(((struct tcp_skb_cb *)&((skb)->cb[0]))->flags & 0x01) &&
trickles-server_1.c:19209:                  tp->packets_out &&
trickles-server_1.c:19220:        return ((nonagle==1 || tp->urg_mode
trickles-server_1.c:19222:                ((tcp_packets_in_flight(tp) < tp->snd_cwnd) ||
trickles-server_1.c:19223:                 (((struct tcp_skb_cb *)&((skb)->cb[0]))->flags & 0x01)) &&
trickles-server_1.c:19224:                !after(((struct tcp_skb_cb *)&((skb)->cb[0]))->end_seq, tp->snd_una + tp->snd_wnd));
trickles-server_1.c:19229:        if (!tp->packets_out && !tp->pending)
trickles-server_1.c:19230:                tcp_reset_xmit_timer(sk, 3, tp->rto);
trickles-server_1.c:19235:        return (skb->next == (struct sk_buff*)&sk->write_queue);
trickles-server_1.c:19247:        struct sk_buff *skb = tp->send_head;
trickles-server_1.c:19262:        __tcp_push_pending_frames(sk, tp, tcp_current_mss(sk), tp->nonagle);
trickles-server_1.c:19267:        struct sk_buff *skb = tp->send_head;
trickles-server_1.c:19271:                             tcp_skb_is_last(sk, skb) ? 1 : tp->nonagle));
trickles-server_1.c:19276:        tp->snd_wl1 = seq;
trickles-server_1.c:19281:        tp->snd_wl1 = seq;
trickles-server_1.c:19299:        return (unsigned short)csum_fold(skb_checksum(skb, 0, skb->len, skb->csum));
trickles-server_1.c:19304:        return skb->ip_summed != 2 &&
trickles-server_1.c:19312:        tp->ucopy.task = ((void *)0);
trickles-server_1.c:19313:        tp->ucopy.len = 0;
trickles-server_1.c:19314:        tp->ucopy.memory = 0;
trickles-server_1.c:19315:        skb_queue_head_init(&tp->ucopy.prequeue);
trickles-server_1.c:19320:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_1.c:19322:        if (!sysctl_tcp_low_latency && tp->ucopy.task) {
trickles-server_1.c:19323:                __skb_queue_tail(&tp->ucopy.prequeue, skb);
trickles-server_1.c:19324:                tp->ucopy.memory += skb->truesize;
trickles-server_1.c:19325:                if (tp->ucopy.memory > sk->rcvbuf) {
trickles-server_1.c:19328:                        if (sk->lock.users)
trickles-server_1.c:19331:                        while ((skb1 = __skb_dequeue(&tp->ucopy.prequeue)) != ((void *)0)) {
trickles-server_1.c:19332:                                sk->backlog_rcv(sk, skb1);
trickles-server_1.c:19336:                        tp->ucopy.memory = 0;
trickles-server_1.c:19337:                } else if (skb_queue_len(&tp->ucopy.prequeue) == 1) {
trickles-server_1.c:19338:                        __wake_up((sk->sleep),1, 1);
trickles-server_1.c:19349:        int oldstate = sk->state;
trickles-server_1.c:19361:                sk->prot->unhash(sk);
trickles-server_1.c:19362:                if (sk->prev && !(sk->userlocks&8))
trickles-server_1.c:19367:                        tcp_statistics[0*2+!(((void)((0)), irq_stat[0].__local_bh_count) != 0)].TcpCurrEstab--;
trickles-server_1.c:19373:        sk->state = state;
trickles-server_1.c:19385:        sk->shutdown = 3;
trickles-server_1.c:19387:        if (!sk->dead)
trickles-server_1.c:19388:                sk->state_change(sk);
trickles-server_1.c:19395:        tp->dsack = 0;
trickles-server_1.c:19396:        tp->eff_sacks = 0;
trickles-server_1.c:19397:        tp->num_sacks = 0;
trickles-server_1.c:19402:        if (tp->tstamp_ok) {
trickles-server_1.c:19408:                *ptr++ = htonl(tp->ts_recent);
trickles-server_1.c:19410:        if (tp->eff_sacks) {
trickles-server_1.c:19411:                struct tcp_sack_block *sp = tp->dsack ? tp->duplicate_sack : tp->selective_acks;
trickles-server_1.c:19414:                *ptr++ = ((__u32)( (((__u32)(((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) & (__u32)0x000000ffUL) << 24) | (((__u32)(((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) & (__u32)0x0000ff00UL) << 8) | (((__u32)(((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) & (__u32)0xff000000UL) >> 24) ));
trickles-server_1.c:19419:                for(this_sack = 0; this_sack < tp->eff_sacks; this_sack++) {
trickles-server_1.c:19423:                if (tp->dsack) {
trickles-server_1.c:19424:                        tp->dsack = 0;
trickles-server_1.c:19425:                        tp->eff_sacks--;
trickles-server_1.c:19488:                    space - ({ const typeof((space>>sysctl_tcp_app_win)) _x = ((space>>sysctl_tcp_app_win)); const typeof(mss>>*rcv_wscale) _y = (mss>>*rcv_wscale); (void) (&_x == &_y); _x > _y ? _x : _y; }) < 65536/2)
trickles-server_1.c:19489:                        (*rcv_wscale)--;
trickles-server_1.c:19512:                (space>>(-sysctl_tcp_adv_win_scale)) :
trickles-server_1.c:19513:                space - (space>>sysctl_tcp_adv_win_scale);
trickles-server_1.c:19519:        return tcp_win_from_space(sk->rcvbuf - ((&sk->rmem_alloc)->counter));
trickles-server_1.c:19524:        return tcp_win_from_space(sk->rcvbuf);
trickles-server_1.c:19529:        sk->ack_backlog--;
trickles-server_1.c:19534:        sk->ack_backlog++;
trickles-server_1.c:19539:        return sk->ack_backlog > sk->max_ack_backlog;
trickles-server_1.c:19545:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_1.c:19547:        req->sk = child;
trickles-server_1.c:19550:        if (!tp->accept_queue_tail) {
trickles-server_1.c:19551:                tp->accept_queue = req;
trickles-server_1.c:19553:                tp->accept_queue_tail->dl_next = req;
trickles-server_1.c:19555:        tp->accept_queue_tail = req;
trickles-server_1.c:19556:        req->dl_next = ((void *)0);
trickles-server_1.c:19572:        struct tcp_listen_opt *lopt = sk->tp_pinfo.af_tcp.listen_opt;
trickles-server_1.c:19574:        if (--lopt->qlen == 0)
trickles-server_1.c:19576:        if (req->retrans == 0)
trickles-server_1.c:19577:                lopt->qlen_young--;
trickles-server_1.c:19582:        struct tcp_listen_opt *lopt = sk->tp_pinfo.af_tcp.listen_opt;
trickles-server_1.c:19584:        if (lopt->qlen++ == 0)
trickles-server_1.c:19586:        lopt->qlen_young++;
trickles-server_1.c:19591:        return sk->tp_pinfo.af_tcp.listen_opt->qlen;
trickles-server_1.c:19596:        return sk->tp_pinfo.af_tcp.listen_opt->qlen_young;
trickles-server_1.c:19601:        return tcp_synq_len(sk)>>sk->tp_pinfo.af_tcp.listen_opt->max_qlen_log;
trickles-server_1.c:19607:        (void)(&tp->syn_wait_lock);
trickles-server_1.c:19608:        *prev = req->dl_next;
trickles-server_1.c:19615:        tcp_synq_unlink(&sk->tp_pinfo.af_tcp, req, prev);
trickles-server_1.c:19624:        req->rcv_wnd = 0;
trickles-server_1.c:19625:        req->rcv_isn = ((struct tcp_skb_cb *)&((skb)->cb[0]))->seq;
trickles-server_1.c:19626:        req->mss = tp->mss_clamp;
trickles-server_1.c:19627:        req->ts_recent = tp->saw_tstamp ? tp->rcv_tsval : 0;
trickles-server_1.c:19628:        req->tstamp_ok = tp->tstamp_ok;
trickles-server_1.c:19629:        req->sack_ok = tp->sack_ok;
trickles-server_1.c:19630:        req->snd_wscale = tp->snd_wscale;
trickles-server_1.c:19631:        req->wscale_ok = tp->wscale_ok;
trickles-server_1.c:19632:        req->acked = 0;
trickles-server_1.c:19633:        req->ecn_ok = 0;
trickles-server_1.c:19634:        req->rmt_port = skb->h.th->source;
trickles-server_1.c:19641:        sk->tp_pinfo.af_tcp.queue_shrunk = 1;
trickles-server_1.c:19642:        sk->wmem_queued -= skb->truesize;
trickles-server_1.c:19643:        sk->forward_alloc += skb->truesize;
trickles-server_1.c:19649:        sk->wmem_queued += skb->truesize;
trickles-server_1.c:19650:        sk->forward_alloc -= skb->truesize;
trickles-server_1.c:19658:        if (sk->forward_alloc >= ((int)(1UL << 12)))
trickles-server_1.c:19672:        if (!(sk->userlocks&1)) {
trickles-server_1.c:19673:                sk->sndbuf = ({ const typeof(sk->sndbuf) _x = (sk->sndbuf); const typeof(sk->wmem_queued/2) _y = (sk->wmem_queued/2); (void) (&_x == &_y); _x < _y ? _x : _y; });
trickles-server_1.c:19674:                sk->sndbuf = ({ const typeof(sk->sndbuf) _x = (sk->sndbuf); const typeof(2048) _y = (2048); (void) (&_x == &_y); _x > _y ? _x : _y; });
trickles-server_1.c:19683:                skb->truesize += mem;
trickles-server_1.c:19684:                if (sk->forward_alloc >= (int)skb->truesize ||
trickles-server_1.c:19685:                    tcp_mem_schedule(sk, skb->truesize, 0)) {
trickles-server_1.c:19704:        if (sk->forward_alloc >= (int)(1UL << 12) ||
trickles-server_1.c:19706:                struct page *page = alloc_pages(sk->allocation, 0);
trickles-server_1.c:19719:        while ((skb = __skb_dequeue(&sk->write_queue)) != ((void *)0))
trickles-server_1.c:19728:        skb->sk = sk;
trickles-server_1.c:19729:        skb->destructor = tcp_rfree;
trickles-server_1.c:19730:        atomic_add(skb->truesize, &sk->rmem_alloc);
trickles-server_1.c:19731:        sk->forward_alloc -= skb->truesize;
trickles-server_1.c:19757:        return tp->keepalive_intvl ? : sysctl_tcp_keepalive_intvl;
trickles-server_1.c:19762:        return tp->keepalive_time ? : sysctl_tcp_keepalive_time;
trickles-server_1.c:19767:        int fin_timeout = tp->linger2 ? : sysctl_tcp_fin_timeout;
trickles-server_1.c:19769:        if (fin_timeout < (tp->rto<<2) - (tp->rto>>1))
trickles-server_1.c:19770:                fin_timeout = (tp->rto<<2) - (tp->rto>>1);
trickles-server_1.c:19777:        if ((s32)(tp->rcv_tsval - tp->ts_recent) >= 0)
trickles-server_1.c:19779:        if (xtime.tv_sec >= tp->ts_recent_stamp + (60 * 60 * 24 * 24))
trickles-server_1.c:19782:        if (rst && xtime.tv_sec >= tp->ts_recent_stamp + 60)
trickles-server_1.c:19791:        const struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_1.c:19797:        return (sysctl_tcp_frto && tp->send_head &&
trickles-server_1.c:19798:                !after(((struct tcp_skb_cb *)&((tp->send_head)->cb[0]))->end_seq,
trickles-server_1.c:19799:                       tp->snd_una + tp->snd_wnd));
trickles-server_1.c:19808:        ((tcp_statistics)[2*0 +1].TcpMaxConn += -1);
trickles-server_1.c:19820:                tp->westwood.rtt = rtt_seq;
trickles-server_1.c:19828:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-server_1.c:19830:        tp->westwood.bw_ns_est = 0;
trickles-server_1.c:19831:        tp->westwood.bw_est = 0;
trickles-server_1.c:19832:        tp->westwood.accounted = 0;
trickles-server_1.c:19833:        tp->westwood.cumul_ack = 0;
trickles-server_1.c:19834:        tp->westwood.rtt_win_sx = ((__u32)(jiffies));
trickles-server_1.c:19835:        tp->westwood.rtt = 20*100;
trickles-server_1.c:19836:        tp->westwood.rtt_min = 20*100;
trickles-server_1.c:19837:        tp->westwood.snd_una = tp->snd_una;
trickles-server_1.c:19859:        return (__u32) ((tp->westwood.bw_est) * (tp->westwood.rtt_min) /
trickles-server_1.c:19860:                        (__u32) (tp->mss_cache));
trickles-server_1.c:19882:                tp->snd_ssthresh = ssthresh;
trickles-server_1.c:19898:                tp->snd_cwnd = cwnd;
trickles-server_1.c:19911:                        tp->snd_ssthresh = tp->snd_cwnd;
trickles-server_1.c:19934:# 1 "/home/ashieh/current/include/net/trickles-crypto.h" 1
trickles-server_1.c:19954:# 6 "/home/ashieh/current/include/net/trickles-crypto.h" 2
trickles-server_1.c:20032:# 13 "/home/ashieh/current/include/net/trickles-crypto.h" 2
trickles-server_1.c:20184:        struct sock *sk = skb->sk;
trickles-server_1.c:20189:        if(skb->ip_summed == 1) {
trickles-server_1.c:20191:                skb->h.th->check = 0;
trickles-server_1.c:20192:                skb->h.th->check = ~tcp_v4_check(skb->h.th, skb->len, sk->saddr, sk->daddr,
trickles-server_1.c:20194:                skb->csum = ((size_t) &((struct tcphdr *)0)->check);
trickles-server_1.c:20196:                skb->h.th->check = 0;
trickles-server_1.c:20197:                skb->h.th->check = tcp_v4_check(skb->h.th, skb->len, sk->saddr, sk->daddr,
trickles-server_1.c:20198:                                         csum_partial((char*)skb->h.th, headerLen, skb->csum));
trickles-server_1.c:20223:  POISONEDRANGE = -1,
trickles-server_1.c:20274:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_1.c:20275:        if (!(dataReq->list == ((void *)0))) { printk("KERNEL: assertion (" "dataReq->list == NULL" ") failed at " "/home/ashieh/current/include/net/trickles_client.h" "(%d)\n", 47); };
trickles-server_1.c:20276:        dataReq->completed = 0;
trickles-server_1.c:20277:        dataReq->sent = 0;
trickles-server_1.c:20280:        dataReq->transportResponseSeqStart = (4294967295U);
trickles-server_1.c:20281:        dataReq->transportResponseSeqEnd = (4294967295U);
trickles-server_1.c:20282:        dataReq->timestamp = (4294967295U);
trickles-server_1.c:20283:        dataReq->start = newStart;
trickles-server_1.c:20284:        dataReq->end = newEnd;
trickles-server_1.c:20285:        insert_tail(&tp->t.missingDataMap, (struct alloc_head*)dataReq);
trickles-server_1.c:20312:        newMapping->next = newMapping->prev = ((void *)0);
trickles-server_1.c:20313:        newMapping->list = ((void *)0);
trickles-server_1.c:20315:        newMapping->completed = 0;
trickles-server_1.c:20316:        newMapping->ucont = ucont;
trickles-server_1.c:20317:        newMapping->transportResponseSeqStart = tseq_start;
trickles-server_1.c:20318:        newMapping->transportResponseSeqEnd = tseq_end;
trickles-server_1.c:20319:        newMapping->sent = 0;
trickles-server_1.c:20320:        newMapping->start = start;
trickles-server_1.c:20321:        newMapping->end = end;
trickles-server_1.c:20323:        newMapping->timestamp = jiffies;
trickles-server_1.c:20331:        numDataRequestMappings--;
trickles-server_1.c:20352:        req->numChildren = 0;
trickles-server_1.c:20353:        req->childrenMask = 0;
trickles-server_1.c:20354:        req->transport_seq = -1;
trickles-server_1.c:20355:        req->seq = -1;
trickles-server_1.c:20356:        req->isNew = 1;
trickles-server_1.c:20361:        req->type = type;
trickles-server_1.c:20362:        req->prev = req->next = ((void *)0);
trickles-server_1.c:20363:        req->list = ((void *)0);
trickles-server_1.c:20365:        req->start = req->end = -1;
trickles-server_1.c:20366:        req->allocated = 1;
trickles-server_1.c:20372:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_1.c:20373:        insert_tail(&tp->t.queuedRequests, (struct alloc_head*)req);
trickles-server_1.c:20374:        tp->t.timerState |= (0x1);
trickles-server_1.c:20401:        req->incomplete = 0;
trickles-server_1.c:20402:        req->completePred = pred;
trickles-server_1.c:20403:        atomic_inc(&req->completePred->refcnt);
trickles-server_1.c:20405:        if(((&req->completePred->refcnt)->counter) < 2) {
trickles-server_1.c:20409:        req->data = data;
trickles-server_1.c:20410:        req->start = start;
trickles-server_1.c:20411:        req->offset = req->start - ((struct tcp_skb_cb *)&((data)->cb[0]))->seq;
trickles-server_1.c:20416:        req->incomplete = 1;
trickles-server_1.c:20417:        req->incompletePred = pred;
trickles-server_1.c:20418:        req->predLength = predLength;
trickles-server_1.c:20419:        req->data = data;
trickles-server_1.c:20420:        req->offset = offset;
trickles-server_1.c:20437:        req->start = start;
trickles-server_1.c:20438:        req->end = end;
trickles-server_1.c:20439:        req->numConts = numConts;
trickles-server_1.c:20440:        req->conts = kmalloc(sizeof(struct UC_Continuation*) * numConts, (0x20));
trickles-server_1.c:20444:                return -1;
trickles-server_1.c:20455:        newReq->conts = kmalloc(sizeof(struct UC_Continuation*) * newReq->numConts, (0x20));
trickles-server_1.c:20456:        if(newReq->conts == ((void *)0)) {
trickles-server_1.c:20460:        (__builtin_constant_p(sizeof(struct UC_Continuation*) * newReq->numConts) ? __constant_memcpy((newReq->conts),(src->conts),(sizeof(struct UC_Continuation*) * newReq->numConts)) : __memcpy((newReq->conts),(src->conts),(sizeof(struct UC_Continuation*) * newReq->numConts)));
trickles-server_1.c:20485:        rval->prev = rval->next = ((void *)0);
trickles-server_1.c:20486:        rval->list = ((void *)0);
trickles-server_1.c:20488:        rval->cont = cont;
trickles-server_1.c:20489:        rval->isSynack = isSynack;
trickles-server_1.c:20490:        rval->parent = parent;
trickles-server_1.c:20491:        rval->numSiblings = numSiblings;
trickles-server_1.c:20492:        rval->position = position;
trickles-server_1.c:20534:static inline void marshallContinuationServer(struct sock *sk, WireContinuation *dcont, const struct cminisock *scont, int pktNum) { dcont->clientState = scont->clientState; dcont->parent = scont->parent; if(1) { ({ (dcont)->seq = htonl((scont)->packets[pktNum].seq); (dcont)->continuationType = (scont)->packets[pktNum].contType; if((scont)->packets[pktNum].type & (0x80)) { (dcont)->firstChild = 1; } else { (dcont)->firstChild = 0; } static const int stateConversionMap[] = { 0, 1, 2 }; int conversionOffset = (scont)->packets[pktNum].type & (0x3); if(conversionOffset >= (3)) { do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } (dcont)->state = stateConversionMap[conversionOffset]; }); dcont->timestamp = htonl(scont->timestamp); dcont->clientTimestamp = scont->clientTimestamp; dcont->mrtt = htonl(scont->mrtt); } else { dcont->seq = htonl(scont->seq); dcont->continuationType = scont->continuationType; dcont->firstChild = scont->firstChild; dcont->state = scont->state; dcont->timestamp = scont->rawTimestamp; dcont->clientTimestamp = scont->clientTimestamp; dcont->mrtt = scont->rawMrtt; } dcont->firstLoss = htonl(scont->firstLoss); dcont->firstBootstrapSeq = htonl(scont->firstBootstrapSeq); dcont->startCwnd = htonl(scont->startCwnd); dcont->ssthresh = htonl(scont->ssthresh); dcont->TCPBase = htonl(scont->TCPBase); dcont->tokenCounterBase = scont->tokenCounterBase; do { PseudoHeader hdr, *phdr = &hdr; phdr->seq = dcont->seq; phdr->type = dcont->continuationType; phdr->first = dcont->firstChild ? 1 : 0; phdr->serverAddr = scont->saddr; phdr->serverPort = scont->source; phdr->clientAddr = scont->daddr; phdr->clientPort = scont->dest; computeMAC(sk, phdr, dcont, dcont->mac); } while(0); }
trickles-server_1.c:20535:static inline void marshallContinuationServerCopyMAC(struct sock *sk, WireContinuation *dcont, const struct cminisock *scont, int pktNum) { dcont->clientState = scont->clientState; dcont->parent = scont->parent; if(1) { ({ (dcont)->seq = htonl((scont)->packets[pktNum].seq); (dcont)->continuationType = (scont)->packets[pktNum].contType; if((scont)->packets[pktNum].type & (0x80)) { (dcont)->firstChild = 1; } else { (dcont)->firstChild = 0; } static const int stateConversionMap[] = { 0, 1, 2 }; int conversionOffset = (scont)->packets[pktNum].type & (0x3); if(conversionOffset >= (3)) { do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } (dcont)->state = stateConversionMap[conversionOffset]; }); dcont->timestamp = htonl(scont->timestamp); dcont->clientTimestamp = scont->clientTimestamp; dcont->mrtt = htonl(scont->mrtt); } else { dcont->seq = htonl(scont->seq); dcont->continuationType = scont->continuationType; dcont->firstChild = scont->firstChild; dcont->state = scont->state; dcont->timestamp = scont->rawTimestamp; dcont->clientTimestamp = scont->clientTimestamp; dcont->mrtt = scont->rawMrtt; } dcont->firstLoss = htonl(scont->firstLoss); dcont->firstBootstrapSeq = htonl(scont->firstBootstrapSeq); dcont->startCwnd = htonl(scont->startCwnd); dcont->ssthresh = htonl(scont->ssthresh); dcont->TCPBase = htonl(scont->TCPBase); dcont->tokenCounterBase = scont->tokenCounterBase; do{ (__builtin_constant_p(16) ? __constant_memcpy((dcont->mac),(scont->mac),(16)) : __memcpy((dcont->mac),(scont->mac),(16))); } while(0); }
trickles-server_1.c:20536:static inline void marshallContinuationClient(struct sock *sk, WireContinuation *dcont, const struct cminisock *scont, int pktNum) { dcont->clientState = scont->clientState; dcont->parent = scont->parent; if(0) { ({ (dcont)->seq = htonl((scont)->packets[pktNum].seq); (dcont)->continuationType = (scont)->packets[pktNum].contType; if((scont)->packets[pktNum].type & (0x80)) { (dcont)->firstChild = 1; } else { (dcont)->firstChild = 0; } static const int stateConversionMap[] = { 0, 1, 2 }; int conversionOffset = (scont)->packets[pktNum].type & (0x3); if(conversionOffset >= (3)) { do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } (dcont)->state = stateConversionMap[conversionOffset]; }); dcont->timestamp = htonl(scont->timestamp); dcont->clientTimestamp = scont->clientTimestamp; dcont->mrtt = htonl(scont->mrtt); } else { dcont->seq = htonl(scont->seq); dcont->continuationType = scont->continuationType; dcont->firstChild = scont->firstChild; dcont->state = scont->state; dcont->timestamp = scont->rawTimestamp; dcont->clientTimestamp = scont->clientTimestamp; dcont->mrtt = scont->rawMrtt; } dcont->firstLoss = htonl(scont->firstLoss); dcont->firstBootstrapSeq = htonl(scont->firstBootstrapSeq); dcont->startCwnd = htonl(scont->startCwnd); dcont->ssthresh = htonl(scont->ssthresh); dcont->TCPBase = htonl(scont->TCPBase); dcont->tokenCounterBase = scont->tokenCounterBase; do{ (__builtin_constant_p(16) ? __constant_memcpy((dcont->mac),(scont->mac),(16)) : __memcpy((dcont->mac),(scont->mac),(16))); } while(0); }
trickles-server_1.c:20545:  dproof->numSacks = ({ typeof(sproof->numSacks) Z = (typeof(sproof->numSacks))(64); ({ const typeof(sproof->numSacks) _x = (sproof->numSacks); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y; }); });
trickles-server_1.c:20546:  for(i=0; i < dproof->numSacks; i++) {
trickles-server_1.c:20547:    dproof->sacks[i].left = htonl(sproof->sacks[i].left);;
trickles-server_1.c:20548:    dproof->sacks[i].right = htonl(sproof->sacks[i].right);;
trickles-server_1.c:20549:    dproof->sacks[i].nonceSummary = sproof->sacks[i].nonceSummary;
trickles-server_1.c:20560:static inline int unmarshallContinuationServerMSK(struct sk_buff *skb, struct cminisock *dcont, const WireContinuation *scont) { do { if(__builtin_expect((!(((skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((skb->sk)->tp_pinfo.af_tcp.trickles_opt & (skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))),0)) { char mac[16]; PseudoHeader hdr, *phdr = &hdr; phdr->seq = scont->seq; phdr->type = scont->continuationType; phdr->first = scont->firstChild; phdr->serverAddr = skb->nh.iph->daddr; phdr->serverPort = skb->h.th->dest; phdr->clientAddr = skb->nh.iph->saddr; phdr->clientPort = skb->h.th->source; computeMAC(skb->sk, phdr, scont, mac); if(__builtin_memcmp(mac, scont->mac, 16)) { printk("failed hmac comparison\n"); return 0; } } } while(0);; dcont->continuationType = scont->continuationType; dcont->seq = ntohl(scont->seq);; dcont->clientState = scont->clientState; dcont->parent = scont->parent; dcont->rawTimestamp = scont->timestamp; dcont->timestamp = ntohl(scont->timestamp); dcont->rawMrtt = scont->mrtt; dcont->mrtt = ntohl(scont->mrtt);; dcont->clientTimestamp = scont->clientTimestamp; dcont->state = scont->state; dcont->firstChild = scont->firstChild; dcont->firstLoss = ntohl(scont->firstLoss);; dcont->firstBootstrapSeq = ntohl(scont->firstBootstrapSeq);; dcont->startCwnd = ntohl(scont->startCwnd);; dcont->ssthresh = ntohl(scont->ssthresh);; dcont->TCPBase = ntohl(scont->TCPBase);; if(__builtin_expect((!(((skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((skb->sk)->tp_pinfo.af_tcp.trickles_opt & (skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))),0)) { dcont->saddr = skb->nh.iph->daddr; dcont->daddr = skb->nh.iph->saddr; dcont->source = skb->h.th->dest; dcont->dest = skb->h.th->source; }; dcont->tokenCounterBase = scont->tokenCounterBase; dcont->num_packets = 0; dcont->numChildrenReceived = 0; dcont->parentMSK = ((void *)0);; return 1; };
trickles-server_1.c:20567:static inline int unmarshallContinuationServerPMSK(struct sk_buff *skb, struct pminisock *dcont, const WireContinuation *scont) { do { if(__builtin_expect((!(((skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((skb->sk)->tp_pinfo.af_tcp.trickles_opt & (skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))),0)) { char mac[16]; PseudoHeader hdr, *phdr = &hdr; phdr->seq = scont->seq; phdr->type = scont->continuationType; phdr->first = scont->firstChild; phdr->serverAddr = skb->nh.iph->daddr; phdr->serverPort = skb->h.th->dest; phdr->clientAddr = skb->nh.iph->saddr; phdr->clientPort = skb->h.th->source; computeMAC(skb->sk, phdr, scont, mac); if(__builtin_memcmp(mac, scont->mac, 16)) { printk("failed hmac comparison\n"); return 0; } } } while(0);; dcont->continuationType = scont->continuationType; dcont->seq = ntohl(scont->seq);; dcont->clientState = scont->clientState; dcont->parent = scont->parent; dcont->rawTimestamp = scont->timestamp; dcont->rawMrtt = scont->mrtt;; dcont->clientTimestamp = scont->clientTimestamp; dcont->state = scont->state; dcont->firstChild = scont->firstChild; dcont->firstLoss = ntohl(scont->firstLoss);; dcont->firstBootstrapSeq = ntohl(scont->firstBootstrapSeq);; dcont->startCwnd = ntohl(scont->startCwnd);; dcont->ssthresh = ntohl(scont->ssthresh);; dcont->TCPBase = ntohl(scont->TCPBase);; dcont->daddr = skb->nh.iph->saddr; dcont->dest = skb->h.th->source;; dcont->tokenCounterBase = scont->tokenCounterBase; dcont->num_packets = 0;; return 1; };
trickles-server_1.c:20574:static inline int unmarshallContinuationServerPMSK2MSK(struct sock *sk, struct cminisock *dcont, struct pminisock *scont) { ; dcont->continuationType = scont->continuationType; dcont->seq = scont->seq; dcont->clientState = scont->clientState; dcont->parent = scont->parent; dcont->rawTimestamp = scont->rawTimestamp; dcont->timestamp = ntohl(scont->rawTimestamp); dcont->rawMrtt = scont->rawMrtt; dcont->mrtt = ntohl(scont->rawMrtt);; dcont->clientTimestamp = scont->clientTimestamp; dcont->state = scont->state; dcont->firstChild = scont->firstChild; dcont->firstLoss = scont->firstLoss; dcont->firstBootstrapSeq = scont->firstBootstrapSeq; dcont->startCwnd = scont->startCwnd; dcont->ssthresh = scont->ssthresh; dcont->TCPBase = scont->TCPBase; dcont->saddr = sk->saddr; dcont->source = sk->sport; dcont->daddr = scont->daddr; dcont->dest = scont->dest;; dcont->tokenCounterBase = scont->tokenCounterBase; dcont->num_packets = 0; ; dcont->pmsk = scont; dcont->num_packets = scont->num_packets; dcont->ucont_data = scont->ucont_data; dcont->ucont_len = scont->ucont_len; dcont->input = scont->input; dcont->input_len = scont->input_len; dcont->packets = scont->packets;; return 1; };
trickles-server_1.c:20581:static inline int unmarshallContinuationServerMSK2PMSK(struct sock *sk, struct pminisock *dcont, struct cminisock *scont) { ; dcont->continuationType = scont->continuationType; dcont->seq = scont->seq; dcont->clientState = scont->clientState; dcont->parent = scont->parent; dcont->rawTimestamp = scont->rawTimestamp; dcont->rawMrtt = scont->rawMrtt;; dcont->clientTimestamp = scont->clientTimestamp; dcont->state = scont->state; dcont->firstChild = scont->firstChild; dcont->firstLoss = scont->firstLoss; dcont->firstBootstrapSeq = scont->firstBootstrapSeq; dcont->startCwnd = scont->startCwnd; dcont->ssthresh = scont->ssthresh; dcont->TCPBase = scont->TCPBase; dcont->daddr = scont->daddr; dcont->dest = scont->dest;; dcont->tokenCounterBase = scont->tokenCounterBase; dcont->num_packets = 0; ; dcont->num_packets = scont->num_packets; dcont->ucont_data = scont->ucont_data; dcont->ucont_len = scont->ucont_len; dcont->input = scont->input; dcont->input_len = scont->input_len; dcont->packets = scont->packets;; return 1; };
trickles-server_1.c:20588:static inline int unmarshallContinuationClient(struct sk_buff *skb, struct cminisock *dcont, const WireContinuation *scont) { do { (__builtin_constant_p(16) ? __constant_memcpy((dcont->mac),(scont->mac),(16)) : __memcpy((dcont->mac),(scont->mac),(16))); } while(0); dcont->continuationType = scont->continuationType; dcont->seq = ntohl(scont->seq);; dcont->clientState = scont->clientState; dcont->parent = scont->parent; dcont->rawTimestamp = scont->timestamp; dcont->timestamp = ntohl(scont->timestamp); dcont->rawMrtt = scont->mrtt; dcont->mrtt = ntohl(scont->mrtt);; dcont->clientTimestamp = scont->clientTimestamp; dcont->state = scont->state; dcont->firstChild = scont->firstChild; dcont->firstLoss = ntohl(scont->firstLoss);; dcont->firstBootstrapSeq = ntohl(scont->firstBootstrapSeq);; dcont->startCwnd = ntohl(scont->startCwnd);; dcont->ssthresh = ntohl(scont->ssthresh);; dcont->TCPBase = ntohl(scont->TCPBase);; if(__builtin_expect((!(((skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((skb->sk)->tp_pinfo.af_tcp.trickles_opt & (skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))),0)) { dcont->saddr = skb->nh.iph->daddr; dcont->daddr = skb->nh.iph->saddr; dcont->source = skb->h.th->dest; dcont->dest = skb->h.th->source; }; dcont->tokenCounterBase = scont->tokenCounterBase; dcont->num_packets = 0; dcont->numChildrenReceived = 0; dcont->parentMSK = ((void *)0);; return 1; };
trickles-server_1.c:20605:        for(i=0; i < (((cont)+1)->num_packets); i++) {
trickles-server_1.c:20606:                total += (((cont)+1)->packets)[i].len;
trickles-server_1.c:20642:  rval->prev = rval->next = ((void *)0);
trickles-server_1.c:20643:  rval->list = ((void *)0);
trickles-server_1.c:20649:          (rval+i)->ucont_len = 0;
trickles-server_1.c:20650:          (rval+i)->ucont_data = ((void *)0);
trickles-server_1.c:20651:          (rval+i)->input_len = 0;
trickles-server_1.c:20652:          (rval+i)->input = ((void *)0);
trickles-server_1.c:20654:          (rval+i)->mark = 0;
trickles-server_1.c:20655:          (rval+i)->simulated = 0;
trickles-server_1.c:20657:  rval->sk = ((void *)0);
trickles-server_1.c:20682:  rval->prev = rval->next = ((void *)0);
trickles-server_1.c:20683:  rval->list = ((void *)0);
trickles-server_1.c:20685:  (__builtin_constant_p((int)((struct cminisock *)0)->clientside_copy_end) ? __constant_memcpy((rval),(cont),((int)((struct cminisock *)0)->clientside_copy_end)) : __memcpy((rval),(cont),((int)((struct cminisock *)0)->clientside_copy_end)));
trickles-server_1.c:20688:          (rval+i)->ucont_len = 0;
trickles-server_1.c:20689:          (rval+i)->ucont_data = ((void *)0);
trickles-server_1.c:20691:          (rval+i)->input_len = 0;
trickles-server_1.c:20692:          (rval+i)->input = ((void *)0);
trickles-server_1.c:20694:          (rval+i)->mark = 0;
trickles-server_1.c:20695:          (rval+i)->simulated = 0;
trickles-server_1.c:20696:          (rval+i)->num_packets = 0;
trickles-server_1.c:20697:          (rval+i)->actualCwnd = 0;
trickles-server_1.c:20708:  if(cont->list) {
trickles-server_1.c:20713:    if((cont+i)->ucont_data)
trickles-server_1.c:20714:      kfree((cont+i)->ucont_data);
trickles-server_1.c:20715:    if((cont+i)->input)
trickles-server_1.c:20716:      kfree((cont+i)->input);
trickles-server_1.c:20729:        cell->start = start;
trickles-server_1.c:20730:        cell->end = end;
trickles-server_1.c:20740:         printk("cell[%d-%d] ", cell->start, cell->end);
trickles-server_1.c:20744:        unsigned left = ({ typeof(c0->start) Z = (typeof(c0->start))(start); ({ const typeof(c0->start) _x = (c0->start); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x > _y ? _x : _y; }); });
trickles-server_1.c:20745:        unsigned right = ({ typeof(c0->end) Z = (typeof(c0->end))(end); ({ const typeof(c0->end) _x = (c0->end); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y; }); });
trickles-server_1.c:20750:        return SkipCell_intersectRange(c0, c1->start, c1->end);
trickles-server_1.c:20754:        return c0-> start == c1->start && c0->end == c1->end;
trickles-server_1.c:20758:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_1.c:20759:        struct alloc_head_list *list = &tp->t.skipList;
trickles-server_1.c:20766:                struct SkipCell *next = (struct SkipCell *) list->next;
trickles-server_1.c:20767:                if(cell->end <= next->start) {
trickles-server_1.c:20772:                        for (next = (typeof(next))(list)->next; (next != (typeof(next))(list)); next=(typeof(next))next->next) {
trickles-server_1.c:20775:                                        if(prev->end <= cell->start &&
trickles-server_1.c:20776:                                           cell->end <= next->start) {
trickles-server_1.c:20781:                                        if(cell->start >= next->start) {
trickles-server_1.c:20794:                if((prev->end <= cell->start &&
trickles-server_1.c:20831:  dproof->numSacks = sproof->numSacks;
trickles-server_1.c:20832:  for(i=0; i < sproof->numSacks; i++) {
trickles-server_1.c:20833:    dproof->sacks[i].left = ntohl(sproof->sacks[i].left);;
trickles-server_1.c:20834:    dproof->sacks[i].right = ntohl(sproof->sacks[i].right);;
trickles-server_1.c:20835:    dproof->sacks[i].nonceSummary = sproof->sacks[i].nonceSummary;
trickles-server_1.c:20842:  unsigned dataLen = length - sizeof(struct WireUC_Continuation);
trickles-server_1.c:20849:  rval->prev = rval->next = ((void *)0);
trickles-server_1.c:20850:  rval->list = ((void *)0);
trickles-server_1.c:20852:  rval->seq = ntohl(scont->seq);
trickles-server_1.c:20853:  rval->validStart = ntohl(scont->validStart);
trickles-server_1.c:20854:  rval->validEnd = ntohl(scont->validEnd);
trickles-server_1.c:20856:  rval->FIN_received = 0;
trickles-server_1.c:20857:  rval->FINHint = 0;
trickles-server_1.c:20858:  rval->FINHintPosition = 0xffffffff;
trickles-server_1.c:20860:  rval->fields = scont->fields;
trickles-server_1.c:20861:  rval->dataLen = dataLen;
trickles-server_1.c:20862:  rval->kernel.obsoleteAt = rval->validEnd;
trickles-server_1.c:20863:  (__builtin_constant_p(dataLen) ? __constant_memcpy((rval->kernel.data),(scont->data),(dataLen)) : __memcpy((rval->kernel.data),(scont->data),(dataLen)));
trickles-server_1.c:20869:        cont->FIN_received = 1;
trickles-server_1.c:20870:        cont->FINHint = 1;
trickles-server_1.c:20871:        cont->FINHintPosition = finPosition;
trickles-server_1.c:20872:        if (!(finPosition <= cont->kernel.obsoleteAt)) { printk("KERNEL: assertion (" "finPosition <= cont->kernel.obsoleteAt" ") failed at " "/home/ashieh/current/include/net/trickles_packet_helpers.h" "(%d)\n", 659); };
trickles-server_1.c:20874:               cont->kernel.obsoleteAt, finPosition);
trickles-server_1.c:20875:        cont->kernel.obsoleteAt = finPosition;
trickles-server_1.c:20880:        if(cont->FINHint) {
trickles-server_1.c:20883:        if(!cont->FIN_received) {
trickles-server_1.c:20884:                cont->FINHint = 1;
trickles-server_1.c:20885:                cont->FINHintPosition = finHintPosition;
trickles-server_1.c:20892:        if(cont->FINHint) {
trickles-server_1.c:20893:                if (!(cont->FINHintPosition <= cont->validEnd)) { printk("KERNEL: assertion (" "cont->FINHintPosition <= cont->validEnd" ") failed at " "/home/ashieh/current/include/net/trickles_packet_helpers.h" "(%d)\n", 680); };
trickles-server_1.c:20894:                return cont->FINHintPosition;
trickles-server_1.c:20896:                return cont->validEnd;
trickles-server_1.c:20901:        if(cont->FIN_received) {
trickles-server_1.c:20902:                return cont->FINHintPosition;
trickles-server_1.c:20904:                return cont->validEnd;
trickles-server_1.c:20910:        if (!(cont->validStart <= position && position < cont->validEnd)) { printk("KERNEL: assertion (" "cont->validStart <= position && position < cont->validEnd" ") failed at " "/home/ashieh/current/include/net/trickles_packet_helpers.h" "(%d)\n", 697); };
trickles-server_1.c:20912:                position < cont->validEnd;
trickles-server_1.c:20916:  int dataLen = scont->dataLen;
trickles-server_1.c:20917:  dcont->seq = htonl(scont->seq);
trickles-server_1.c:20918:  dcont->validStart = htonl(scont->validStart);
trickles-server_1.c:20919:  dcont->validEnd = htonl(scont->validEnd);
trickles-server_1.c:20920:  dcont->fields = scont->fields;
trickles-server_1.c:20921:  (__builtin_constant_p(dataLen) ? __constant_memcpy((dcont->data),(scont->kernel.data),(dataLen)) : __memcpy((dcont->data),(scont->kernel.data),(dataLen)));
trickles-server_1.c:20928:  completeResp->fields |= (0x01);
trickles-server_1.c:20935:  int dataLen = scont->dataLen;
trickles-server_1.c:20942:  rval->prev = rval->next = ((void *)0);
trickles-server_1.c:20943:  rval->list = ((void *)0);
trickles-server_1.c:20945:  (__builtin_constant_p(dataLen) ? __constant_memcpy((rval->kernel.data),(scont->kernel.data),(dataLen)) : __memcpy((rval->kernel.data),(scont->kernel.data),(dataLen)));
trickles-server_1.c:20961:  return -1;
trickles-server_1.c:20985:  return -1;
trickles-server_1.c:20994:  wireContinuation->fields = 0;
trickles-server_1.c:20998:  char *rval = wireContinuation->data;
trickles-server_1.c:21000:  if(wireContinuation->fields & (0x01)) {
trickles-server_1.c:21004:  if(wireContinuation->fields & ~((0x01))) {
trickles-server_1.c:21014:  resp->type = type;
trickles-server_1.c:21015:  resp->error = error;
trickles-server_1.c:21016:  resp->len = htons((short)len);
trickles-server_1.c:21024:  incompleteResp->ack_seq = htonl(ack_seq);
trickles-server_1.c:21025:  incompleteResp->newCont.validStart = htonl(validStart);
trickles-server_1.c:21033:  completeResp->ack_seq = htonl(ack_seq);
trickles-server_1.c:21034:  completeResp->newCont.seq = htonl(seq);
trickles-server_1.c:21035:  completeResp->newCont.validStart = htonl(validStart);
trickles-server_1.c:21036:  completeResp->newCont.validEnd = htonl(validEnd);
trickles-server_1.c:21037:  completeResp->newCont.fields = 0;
trickles-server_1.c:21045:        newContinuationResp->newCont.seq = htonl(seq);
trickles-server_1.c:21046:        newContinuationResp->newCont.validStart = htonl(validStart);
trickles-server_1.c:21047:        newContinuationResp->newCont.validEnd = htonl(validEnd);
trickles-server_1.c:21048:        newContinuationResp->newCont.fields = 0;
trickles-server_1.c:21053:         printk("{ seq=[%d]\n", ucont->seq);
trickles-server_1.c:21054:         printk("valid=[%d-%d] [%d-%d]\n", ucont->validStart, ucont->validEnd,
trickles-server_1.c:21055:                htonl(ucont->validStart), htonl(ucont->validEnd));
trickles-server_1.c:21056:         printk("cvalid=[%d-%d] [%d-%d] }\n", ucont->clientValidStart, ucont->clientValidEnd,
trickles-server_1.c:21057:                htonl(ucont->clientValidStart), htonl(ucont->clientValidEnd));
trickles-server_1.c:21064:        chunk->byteNum = htonl(byteNum);
trickles-server_1.c:21065:        chunk->type = RCHUNK_DATA;
trickles-server_1.c:21066:        chunk->flags = 0;
trickles-server_1.c:21067:        chunk->chunkLen = htons(chunkLen + sizeof(struct DataChunk));
trickles-server_1.c:21069:        return (struct DataChunk *) (chunk->data + chunkLen);
trickles-server_1.c:21076:        schunk->type = RCHUNK_SKIP;
trickles-server_1.c:21077:        chunk->flags = 0;
trickles-server_1.c:21078:        schunk->chunkLen = htons(len = sizeof(struct SkipChunk));
trickles-server_1.c:21079:        schunk->byteNum = htonl(byteNum);
trickles-server_1.c:21080:        schunk->len = htonl(skipLen);
trickles-server_1.c:21088:        shchunk->type = RCHUNK_FINHINT;
trickles-server_1.c:21089:        chunk->flags = 0;
trickles-server_1.c:21090:        shchunk->chunkLen = htons(len = sizeof(struct FINHintChunk));
trickles-server_1.c:21091:        shchunk->byteNum = htonl(byteNum);
trickles-server_1.c:21092:        shchunk->len = htonl(skipLen);
trickles-server_1.c:21099:        phchunk->type = RCHUNK_PUSH_HINT;
trickles-server_1.c:21100:        chunk->flags = 0;
trickles-server_1.c:21101:        phchunk->chunkLen = htons(sizeof(struct PushHintChunk));
trickles-server_1.c:21102:        phchunk->start = htonl(start);
trickles-server_1.c:21103:        phchunk->end = htonl(end);
trickles-server_1.c:21124:        ctx->packetNum = 0;
trickles-server_1.c:21125:        ctx->packetPos = 0;
trickles-server_1.c:21126:        ctx->outputPos = ctx->outputStart = dest;
trickles-server_1.c:21127:        ctx->packets = packets;
trickles-server_1.c:21128:        ctx->numPackets = numPackets;
trickles-server_1.c:21134:        for(i=0; i < ctx->numPackets; i++) {
trickles-server_1.c:21135:                printk("Packet [%d] = %d\n", i, ctx->packets[i].len);
trickles-server_1.c:21142:               ctx->packetNum, ctx->packetPos, ctx->outputPos, ctx->numPackets, ctx->packets);
trickles-server_1.c:21147:        if(ctx->packetNum >= ctx->numPackets) {
trickles-server_1.c:21150:        return ctx->packets[ctx->packetNum].len - ctx->packetPos;
trickles-server_1.c:21156:        if(numBytes == 0) return ctx->outputPos;
trickles-server_1.c:21158:        do { if(ctx->packetNum >= ctx->numPackets) { return ((void *)0); } } while(0);
trickles-server_1.c:21160:        if(!(ctx->packetNum <= ctx->numPackets)) {
trickles-server_1.c:21161:                if (!(ctx->packetNum <= ctx->numPackets)) { printk("KERNEL: assertion (" "ctx->packetNum <= ctx->numPackets" ") failed at " "/home/ashieh/current/include/net/trickles_packet_helpers.h" "(%d)\n", 1040); };
trickles-server_1.c:21162:                printk("%d !<= %d\n", ctx->packetNum, ctx->numPackets);
trickles-server_1.c:21170:                if (!(numBytes <= ctx->packets[ctx->packetNum].len)) { printk("KERNEL: assertion (" "numBytes <= ctx->packets[ctx->packetNum].len" ") failed at " "/home/ashieh/current/include/net/trickles_packet_helpers.h" "(%d)\n", 1049); };
trickles-server_1.c:21171:                ctx->outputPos += ctx->packets[ctx->packetNum].len - ctx->packetPos;
trickles-server_1.c:21172:                ctx->packetPos = 0;
trickles-server_1.c:21173:                ctx->packetNum++;
trickles-server_1.c:21175:        temp = ctx->outputPos;
trickles-server_1.c:21176:        ctx->packetPos += numBytes;
trickles-server_1.c:21177:        ctx->outputPos += numBytes;
trickles-server_1.c:21179:        do { if(ctx->packetNum >= ctx->numPackets) { return ((void *)0); } } while(0);
trickles-server_1.c:21181:        if (!(ctx->packetPos <= ctx->packets[ctx->packetNum].len)) { printk("KERNEL: assertion (" "ctx->packetPos <= ctx->packets[ctx->packetNum].len" ") failed at " "/home/ashieh/current/include/net/trickles_packet_helpers.h" "(%d)\n", 1060); };
trickles-server_1.c:21183:        if(ctx->packetPos == ctx->packets[ctx->packetNum].len) {
trickles-server_1.c:21184:                ctx->packetPos = 0;
trickles-server_1.c:21185:                ctx->packetNum++;
trickles-server_1.c:21194:        char *currpos = ctx->outputPos;
trickles-server_1.c:21220:        char *currpos = ctx->outputPos;
trickles-server_1.c:21246:                return -1;
trickles-server_1.c:21258:        while((char*)(chunk+1) - start < len) {
trickles-server_1.c:21259:                int len = ntohs((chunk)->chunkLen) - sizeof(struct DataChunk);
trickles-server_1.c:21262:                                printk("bad length chunk(%d) -- ", len);
trickles-server_1.c:21270:                chunk = ((void*)((char*)(chunk) + ntohs((chunk)->chunkLen)));
trickles-server_1.c:21276:                        return -1;
trickles-server_1.c:21279:        if((char*)chunk - start > len) {
trickles-server_1.c:21280:                printk("data chunk validation failed, %d > %d\n", (char*)chunk-start, len);
trickles-server_1.c:21281:                return -chunknum - 1;
trickles-server_1.c:21293:        if (!(gctx->packetNum <= gctx->numPackets)) { printk("KERNEL: assertion (" "gctx->packetNum <= gctx->numPackets" ") failed at " "/home/ashieh/current/include/net/trickles_packet_helpers.h" "(%d)\n", 1172); };
trickles-server_1.c:21298:        int outputLen = gctx->outputPos - gctx->outputStart;
trickles-server_1.c:21299:        char *buf = gctx->outputStart;
trickles-server_1.c:21306:        if (!(entry->prev == ((void *)0) && entry->next == ((void *)0) && entry->list == ((void *)0))) { printk("KERNEL: assertion (" "entry->prev == NULL && entry->next == NULL && entry->list == NULL" ") failed at " "/home/ashieh/current/include/net/trickles_client.h" "(%d)\n", 296); };
trickles-server_1.c:21308:        freeClientSide_Continuation(entry->cont);
trickles-server_1.c:21321:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-server_1.c:21322:        tp->trickles_opt = 0;
trickles-server_1.c:21323:        tp->mac_changed = 0;
trickles-server_1.c:21327:                (__builtin_constant_p(0) ? (__builtin_constant_p((sizeof(tp->cminisock_api_config))) ? __constant_c_and_count_memset(((&tp->cminisock_api_config)),((0x01010101UL*(unsigned char)(0))),((sizeof(tp->cminisock_api_config)))) : __constant_c_memset(((&tp->cminisock_api_config)),((0x01010101UL*(unsigned char)(0))),((sizeof(tp->cminisock_api_config))))) : (__builtin_constant_p((sizeof(tp->cminisock_api_config))) ? __memset_generic((((&tp->cminisock_api_config))),(((0))),(((sizeof(tp->cminisock_api_config))))) : __memset_generic(((&tp->cminisock_api_config)),((0)),((sizeof(tp->cminisock_api_config))))));
trickles-server_1.c:21328:                init_head(&tp->cminisock_api_config.msk_freelist);
trickles-server_1.c:21330:                tp->cminisock_api_config.cfg.ctl = ((void *)0);
trickles-server_1.c:21332:                tp->cminisock_api_config.event_lock = (rwlock_t) { };
trickles-server_1.c:21335:        tp->t.malloc_initialized = 0;
trickles-server_1.c:21337:        tp->t.heapbytesize = 0;
trickles-server_1.c:21338:        tp->t.heapbytesallocated = 0;
trickles-server_1.c:21341:                tp->t.fragblocks[i] = 0;
trickles-server_1.c:21342:                tp->t.fraghead[i].next = tp->t.fraghead[i].prev = ((void *)0);
trickles-server_1.c:21345:        tp->t.clientStateCounter = 0;
trickles-server_1.c:21346:        tp->t.state = 1;
trickles-server_1.c:21347:        tp->t.A = 0;
trickles-server_1.c:21348:        tp->t.D = 0;
trickles-server_1.c:21349:        tp->t.RTO = 0;
trickles-server_1.c:21350:        tp->t.timerState = 0;
trickles-server_1.c:21351:        tp->t.rcv_nxt = 0;
trickles-server_1.c:21352:        tp->t.previous_base = 0;
trickles-server_1.c:21353:        skb_queue_head_init(&tp->t.ofo_queue);
trickles-server_1.c:21355:        tp->t.ack_prev = ((void *)0);
trickles-server_1.c:21357:        tp->t.ack_last = 0;
trickles-server_1.c:21358:        tp->t.oo_count = 0;
trickles-server_1.c:21359:        tp->t.in_flight = 0;
trickles-server_1.c:21361:        tp->t.standardProof.numSacks = 0;
trickles-server_1.c:21362:        tp->t.altProof.numSacks = 0;
trickles-server_1.c:21365:        tp->t.dprev = tp->t.dnext = ((void *)0);
trickles-server_1.c:21366:        tp->t.dbg_skb = ((void *)0);
trickles-server_1.c:21367:        init_head(&tp->t.cont_list);
trickles-server_1.c:21369:        init_timer(&tp->t.slowstart_timer);
trickles-server_1.c:21373:        tp->t.request_rcv_nxt = 0;
trickles-server_1.c:21374:        tp->t.request_snd_nxt = 0;
trickles-server_1.c:21375:        init_head(&tp->t.request_ofo_queue);
trickles-server_1.c:21376:        skb_queue_head_init(&tp->t.data_ofo_queue);
trickles-server_1.c:21377:        init_head(&tp->t.sentRequests);
trickles-server_1.c:21378:        init_head(&tp->t.queuedRequests);
trickles-server_1.c:21380:        init_head(&tp->t.dataRequestMap);
trickles-server_1.c:21381:        init_head(&tp->t.missingDataMap);
trickles-server_1.c:21382:        init_head(&tp->t.skipList);
trickles-server_1.c:21384:        tp->t.byteReqNext = 0;
trickles-server_1.c:21385:        tp->t.byteReqHint = ((void *)0);
trickles-server_1.c:21386:        tp->t.byteRcvNxt = 0;
trickles-server_1.c:21390:        tp->t.conversionState = (1);
trickles-server_1.c:21391:        tp->t.snd_una = tp->t.write_seq = 0;
trickles-server_1.c:21392:        tp->t.snd_end = 0;
trickles-server_1.c:21393:        skb_queue_head_init(&tp->t.requestBytes);
trickles-server_1.c:21394:        tp->t.newIncompleteRequest = ((void *)0);
trickles-server_1.c:21395:        tp->t.prevConvCont = ((void *)0);
trickles-server_1.c:21397:        init_head(&tp->t.ucontList);
trickles-server_1.c:21398:        init_head(&tp->t.depNodeList);
trickles-server_1.c:21404:        tp->t.nonceCTX = ((void *)0);
trickles-server_1.c:21405:        skb_queue_head_init(&tp->t.prequeueOverflow);
trickles-server_1.c:21406:        skb_queue_head_init(&tp->t.sendAckOverflow);
trickles-server_1.c:21407:        skb_queue_head_init(&tp->t.recycleList);
trickles-server_1.c:21409:        tp->t.responseMSK = ((void *)0);
trickles-server_1.c:21410:        init_head(&tp->t.responseList);
trickles-server_1.c:21411:        tp->t.responseCount = 0;
trickles-server_1.c:21413:        tp->t.events = ((void *)0);
trickles-server_1.c:21414:        tp->drop_rate = 0;
trickles-server_1.c:21415:        tp->instrumentation = 0;
trickles-server_1.c:21532:        msk->num_packets = 0;
trickles-server_1.c:21533:        msk->ucont_len = 0;
trickles-server_1.c:21534:        msk->ucont_data = ((void *)0);
trickles-server_1.c:21535:        msk->input_len = 0;
trickles-server_1.c:21536:        msk->input = ((void *)0);
trickles-server_1.c:21537:        msk->packets = ((void *)0);
trickles-server_1.c:21539:        msk->refCnt = 1;
trickles-server_1.c:21541:        msk->cacheRecycleIndex = -1;
trickles-server_1.c:21542:        msk->serverSK = ((void *)0);
trickles-server_1.c:21543:        msk->pmsk = ((void *)0);
trickles-server_1.c:21544:        msk->isStatic = 0;
trickles-server_1.c:21549:        msk->isStatic = 1;
trickles-server_1.c:21550:        msk->prev = msk->next = ((void *)0);
trickles-server_1.c:21551:        msk->ctl = ALLOC_PENDING;
trickles-server_1.c:21555:        pmsk->num_packets = 0;
trickles-server_1.c:21556:        pmsk->ucont_len = 0;
trickles-server_1.c:21557:        pmsk->ucont_data = ((void *)0);
trickles-server_1.c:21558:        pmsk->input_len = 0;
trickles-server_1.c:21559:        pmsk->input = ((void *)0);
trickles-server_1.c:21560:        pmsk->packets = ((void *)0);
trickles-server_1.c:21561:        pmsk->refCnt = 1;
trickles-server_1.c:21562:        pmsk->cacheRecycleIndex = -1;
trickles-server_1.c:21574:        if(msk->num_packets > 0) {
trickles-server_1.c:21575:                printk("msk packets is %d\n", msk->num_packets);
trickles-server_1.c:21577:        if (!(msk->num_packets == 0)) { printk("KERNEL: assertion (" "msk->num_packets == 0" ") failed at " "/home/ashieh/current/include/net/trickles_minisock_functions.h" "(%d)\n", 53); };
trickles-server_1.c:21581:        if(!(((msk->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((msk->sk)->tp_pinfo.af_tcp.trickles_opt & (msk->sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) {
trickles-server_1.c:21582:                msk->packets = tmalloc(msk->sk, sizeof(struct cminisock_packet) * numPackets);
trickles-server_1.c:21586:                if(msk->packets == ((void *)0)) {
trickles-server_1.c:21595:                        msk->packets = packets[0];
trickles-server_1.c:21597:                        msk->packets = ((void *)0);
trickles-server_1.c:21604:        msk->num_packets = numPackets;
trickles-server_1.c:21610:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-server_1.c:21611:        struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
trickles-server_1.c:21613:                (struct cminisock *)head->next;
trickles-server_1.c:21614:        while((struct alloc_head_list*)curr != head && curr->ctl == ALLOC_PROCESSING) {
trickles-server_1.c:21616:                curr = curr->next;
trickles-server_1.c:21622:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-server_1.c:21623:        struct list_link *phead = (struct list_link *)&tp->cminisock_api_config.pmsk_freelist;
trickles-server_1.c:21625:                tp->cminisock_api_config.pmsk_freelist.next;
trickles-server_1.c:21627:        if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) {
trickles-server_1.c:21629:                      pcurr->ctl == ALLOC_PROCESSING) {
trickles-server_1.c:21631:                        pcurr = pcurr->next;
trickles-server_1.c:21646:        rval->ctl = ALLOC_PENDING;
trickles-server_1.c:21654:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-server_1.c:21655:        struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
trickles-server_1.c:21657:                tp->cminisock_api_config.msk_freelist.next;
trickles-server_1.c:21659:        if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) {
trickles-server_1.c:21661:                      curr->ctl == ALLOC_PROCESSING) {
trickles-server_1.c:21663:                        curr = curr->next;
trickles-server_1.c:21674:                rval->ctl = ALLOC_PENDING;
trickles-server_1.c:21676:                if(tp->t.responseCount == 0) {
trickles-server_1.c:21677:                        rval = tp->t.responseMSK;
trickles-server_1.c:21678:                        rval->list = ((void *)0);
trickles-server_1.c:21679:                        rval->next = rval->prev = ((void *)0);
trickles-server_1.c:21686:                        rval->next = rval->prev = ((void *)0);
trickles-server_1.c:21687:                        rval->list = ((void *)0);
trickles-server_1.c:21688:                        insert_tail(&tp->t.responseList, (struct alloc_head*)rval);
trickles-server_1.c:21690:                tp->t.responseCount++;
trickles-server_1.c:21692:                rval->sk = sk;
trickles-server_1.c:21693:                rval->ctl = ALLOC_PENDING;
trickles-server_1.c:21709:static inline void msk_hold(struct cminisock *msk) { msk->refCnt++; } static struct cminisock *shallow_copy_msk(struct sock *sk, struct cminisock *pmsk) { struct cminisock *rval = alloc_trickles_msk(sk); struct alloc_head_list head; if(rval == ((void *)0)) { struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp); printk("out of memory while shallow copying msk\n"); printk("list len is %d\n", tp->cminisock_api_config.msk_freelist.len); return ((void *)0); } head = *(struct alloc_head_list *)rval; *rval = *pmsk; *(struct alloc_head_list *)rval = head; rval->refCnt = 1; rval->isStatic = 0; return rval; } static struct cminisock *copy_msk(struct sock *sk, struct cminisock *pmsk) { struct cminisock *rval = shallow_copy_msk(sk, pmsk); if(rval == ((void *)0)) { printk("out of memory while copying msk\n"); return ((void *)0); } rval->num_packets = 0; rval->packets = ((void *)0); rval->pmsk = ((void *)0); if(rval->ucont_len > 0) { rval->ucont_data = tmalloc(sk,rval->ucont_len); if(rval->ucont_data == ((void *)0)) { printk("out of tmalloc memory while copying msk (len = %d)\n", rval->ucont_len); free_trickles_msk(sk,rval); free_trickles_msk_finish(sk,rval); return ((void *)0); } } else { rval->ucont_data = ((void *)0); } if(rval->input_len > 0) { rval->input = tmalloc(sk,rval->input_len); if(rval->input == ((void *)0)) { printk("out of tmalloc memory while copying msk (%s len = %d)\n", "msk", rval->input_len); tfree(sk,rval->ucont_data); free_trickles_msk(sk,rval); free_trickles_msk_finish(sk,rval); return ((void *)0); } } else { rval->input = ((void *)0); } if(rval->ucont_data) (__builtin_constant_p(rval->ucont_len) ? __constant_memcpy((rval->ucont_data),(pmsk->ucont_data),(rval->ucont_len)) : __memcpy((rval->ucont_data),(pmsk->ucont_data),(rval->ucont_len))); if(rval->input) (__builtin_constant_p(rval->input_len) ? __constant_memcpy((rval->input),(pmsk->input),(rval->input_len)) : __memcpy((rval->input),(pmsk->input),(rval->input_len))); return rval; } static void free_trickles_msk(struct sock *sk, struct cminisock *msk) { if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) { if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) { printk("double free\n"); do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } if(msk->ctl == ALLOC_READY && msk->prev != ((void *)0)) { unlink((struct alloc_head*)msk); } msk->ctl = ALLOC_PROCESSING; } } static void free_msk(struct sock *sk, struct cminisock *msk) { int i; for(i=0; i < msk->num_packets; i++) { if(msk->packets[i].ucontData != ((void *)0)) { kfree(msk->packets[i].ucontData); } } if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8)) && msk->packets) { tfree(sk,msk->packets); msk->packets = ((void *)0); } msk->num_packets = 0; if(msk->ucont_data != ((void *)0)) { tfree(sk,msk->ucont_data); msk->ucont_data = ((void *)0); } msk->ucont_len = 0; if(msk->input != ((void *)0)) { tfree(sk,msk->input); msk->input = ((void *)0); } msk->input_len = 0; } static void msk_release(struct sock *sk, struct cminisock *msk) { msk->refCnt--; if (!(msk->refCnt <= 3)) { printk("KERNEL: assertion (" "msk->refCnt <= 3" ") failed at " "/home/ashieh/current/include/net/trickles_minisock_functions.h" "(%d)\n", 381); }; if(msk->refCnt == 0) { struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp); struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist; free_msk(sk,msk); if(!msk->isStatic) { if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) { insert_head((head), (struct alloc_head *)(msk)); msk->ctl = ALLOC_FREE; } else { if(msk != tp->t.responseMSK) { unlink((struct alloc_head*)msk); kfree(msk); } tp->t.responseCount--; } } } else { } if(msk->pmsk != ((void *)0)) { struct pminisock *pmsk = msk->pmsk; free_trickles_pmsk(sk, pmsk); free_trickles_pmsk_finish(sk, pmsk); }; } static void free_trickles_msk_finish(struct sock *sk, struct cminisock *msk) { if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) { if(msk->ctl != ALLOC_PROCESSING && msk->ctl != ALLOC_HALFFREE) { printk("(free_trickles_msk_finish %s) without corresponding free_trickles_msk: msk->ctl = %d\n", "msk", msk->ctl); do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } } msk_release(sk,msk); } static inline void msk_clear_fields(struct cminisock *msk) { msk->num_packets = 0; msk->packets = ((void *)0); msk->ucont_len = 0; msk->ucont_data = ((void *)0); msk->input_len = 0; msk->input = ((void *)0); };
trickles-server_1.c:21711:static inline void pmsk_hold(struct pminisock *msk) { msk->refCnt++; } static struct pminisock *shallow_copy_pmsk(struct sock *sk, struct pminisock *pmsk) { struct pminisock *rval = alloc_trickles_pmsk(sk); struct list_link head; if(rval == ((void *)0)) { struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp); printk("out of memory while shallow copying msk\n"); ; return ((void *)0); } head = *(struct list_link *)rval; *rval = *pmsk; *(struct list_link *)rval = head; rval->refCnt = 1; return rval; } static struct pminisock *copy_pmsk(struct sock *sk, struct pminisock *pmsk) { struct pminisock *rval = shallow_copy_pmsk(sk, pmsk); if(rval == ((void *)0)) { printk("out of memory while copying msk\n"); return ((void *)0); } rval->num_packets = 0; rval->packets = ((void *)0); if(rval->ucont_len > 0) { rval->ucont_data = tmalloc(sk,rval->ucont_len); if(rval->ucont_data == ((void *)0)) { printk("out of tmalloc memory while copying msk (len = %d)\n", rval->ucont_len); free_trickles_pmsk(sk,rval); free_trickles_pmsk_finish(sk,rval); return ((void *)0); } } else { rval->ucont_data = ((void *)0); } if(rval->input_len > 0) { rval->input = tmalloc(sk,rval->input_len); if(rval->input == ((void *)0)) { printk("out of tmalloc memory while copying msk (%s len = %d)\n", "pmsk", rval->input_len); tfree(sk,rval->ucont_data); free_trickles_pmsk(sk,rval); free_trickles_pmsk_finish(sk,rval); return ((void *)0); } } else { rval->input = ((void *)0); } if(rval->ucont_data) (__builtin_constant_p(rval->ucont_len) ? __constant_memcpy((rval->ucont_data),(pmsk->ucont_data),(rval->ucont_len)) : __memcpy((rval->ucont_data),(pmsk->ucont_data),(rval->ucont_len))); if(rval->input) (__builtin_constant_p(rval->input_len) ? __constant_memcpy((rval->input),(pmsk->input),(rval->input_len)) : __memcpy((rval->input),(pmsk->input),(rval->input_len))); return rval; } static void free_trickles_pmsk(struct sock *sk, struct pminisock *msk) { if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) { if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) { printk("double free\n"); do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } if(msk->ctl == ALLOC_READY && msk->prev != ((void *)0)) { dlist_unlink((struct list_link*)(msk)); } msk->ctl = ALLOC_PROCESSING; } } static void free_pmsk(struct sock *sk, struct pminisock *msk) { int i; for(i=0; i < msk->num_packets; i++) { if(msk->packets[i].ucontData != ((void *)0)) { kfree(msk->packets[i].ucontData); } } if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8)) && msk->packets) { tfree(sk,msk->packets); msk->packets = ((void *)0); } msk->num_packets = 0; if(msk->ucont_data != ((void *)0)) { tfree(sk,msk->ucont_data); msk->ucont_data = ((void *)0); } msk->ucont_len = 0; if(msk->input != ((void *)0)) { tfree(sk,msk->input); msk->input = ((void *)0); } msk->input_len = 0; } static void pmsk_release(struct sock *sk, struct pminisock *msk) { msk->refCnt--; if (!(msk->refCnt <= 3)) { printk("KERNEL: assertion (" "msk->refCnt <= 3" ") failed at " "/home/ashieh/current/include/net/trickles_minisock_functions.h" "(%d)\n", 392); }; if(msk->refCnt == 0) { struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp); struct dlist *head = &tp->cminisock_api_config.pmsk_freelist; free_pmsk(sk,msk); if(!!(msk >= (struct pminisock *)tp->cminisock_api_config.cfg.ctl->pminisock_base && (msk+1) <= (struct pminisock *)tp->cminisock_api_config.cfg.ctl->pminisock_limit)) { if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) { dlist_insert_head(head, (struct list_link*)(msk)); msk->ctl = ALLOC_FREE; } else { ; } } } else { } ; } static void free_trickles_pmsk_finish(struct sock *sk, struct pminisock *msk) { if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) { if(msk->ctl != ALLOC_PROCESSING && msk->ctl != ALLOC_HALFFREE) { printk("(free_trickles_msk_finish %s) without corresponding free_trickles_msk: msk->ctl = %d\n", "pmsk", msk->ctl); do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } } pmsk_release(sk,msk); } static inline void pmsk_clear_fields(struct pminisock *msk) { msk->num_packets = 0; msk->packets = ((void *)0); msk->ucont_len = 0; msk->ucont_data = ((void *)0); msk->input_len = 0; msk->input = ((void *)0); };
trickles-server_1.c:21723:        skb->next = ((void *)0);
trickles-server_1.c:21724:        skb->prev = ((void *)0);
trickles-server_1.c:21725:        skb->list = ((void *)0);
trickles-server_1.c:21726:        skb->sk = ((void *)0);
trickles-server_1.c:21727:        skb->stamp.tv_sec=0;
trickles-server_1.c:21728:        skb->dev = ((void *)0);
trickles-server_1.c:21729:        skb->real_dev = ((void *)0);
trickles-server_1.c:21730:        skb->dst = ((void *)0);
trickles-server_1.c:21731:        (__builtin_constant_p(0) ? (__builtin_constant_p((sizeof(skb->cb))) ? __constant_c_and_count_memset(((skb->cb)),((0x01010101UL*(unsigned char)(0))),((sizeof(skb->cb)))) : __constant_c_memset(((skb->cb)),((0x01010101UL*(unsigned char)(0))),((sizeof(skb->cb))))) : (__builtin_constant_p((sizeof(skb->cb))) ? __memset_generic((((skb->cb))),(((0))),(((sizeof(skb->cb))))) : __memset_generic(((skb->cb)),((0)),((sizeof(skb->cb))))));
trickles-server_1.c:21732:        skb->pkt_type = 0;
trickles-server_1.c:21733:        skb->ip_summed = 0;
trickles-server_1.c:21734:        skb->priority = 0;
trickles-server_1.c:21735:        skb->security = 0;
trickles-server_1.c:21736:        skb->destructor = ((void *)0);
trickles-server_1.c:21739:        skb->nfmark = skb->nfcache = 0;
trickles-server_1.c:21740:        skb->nfct = ((void *)0);
trickles-server_1.c:21746:        skb->tc_index = 0;
trickles-server_1.c:21752:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_1.c:21753:        int r0 = ((struct skb_shared_info *)((skb)->end))->nr_frags != 0,
trickles-server_1.c:21754:                r1 = tp->t.recycleList.qlen >= (1000),
trickles-server_1.c:21755:                r2 = skb->truesize - sizeof(struct sk_buff) < ((128 + 32) + (sizeof(WireTrickleResponse)) + (sysctl_trickles_mss));
trickles-server_1.c:21759:                                printk("Unsuitable for recycling %d %d %d truesize = %d skblen = %d\n", r0, r1, r2, skb->truesize, ((128 + 32) + (sizeof(WireTrickleResponse)) + (sysctl_trickles_mss)));
trickles-server_1.c:21767:        skb->tail = skb->data = skb->head;
trickles-server_1.c:21768:        skb->len = 0;
trickles-server_1.c:21769:        skb->cloned = 0;
trickles-server_1.c:21770:        skb->data_len =0;
trickles-server_1.c:21772:        (((&skb->users)->counter) = (1));
trickles-server_1.c:21773:        (((&(((struct skb_shared_info *)((skb)->end))->dataref))->counter) = (1));
trickles-server_1.c:21774:        ((struct skb_shared_info *)((skb)->end))->nr_frags = 0;
trickles-server_1.c:21775:        ((struct skb_shared_info *)((skb)->end))->frag_list = ((void *)0);
trickles-server_1.c:21777:        __skb_queue_tail(&tp->t.recycleList, skb);
trickles-server_1.c:21786:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_1.c:21788:        struct sk_buff *skb = __skb_dequeue_tail(&tp->t.recycleList);
trickles-server_1.c:21793:# 7 "trickles-int.h" 2
trickles-server_1.c:21902:"kernel_version=" "2.4.26-gdb-trickles";
trickles-server_1.c:21903:# 14 "trickles-int.h" 2
trickles-server_1.c:21905:# 15 "trickles-int.h" 2
trickles-server_1.c:21960:# 16 "trickles-int.h" 2
trickles-server_1.c:21967:# 17 "trickles-int.h" 2
trickles-server_1.c:21981:        struct files_struct *files = get_current()->files;
trickles-server_1.c:21983:        (void)(&files->file_lock);
trickles-server_1.c:21984:        res = (__extension__ ({ unsigned char __result; __asm__ __volatile__("btl %1,%2 ; setb %0" :"=q" (__result) :"r" ((int) (fd)), "m" (*(__kernel_fd_set *) (files->close_on_exec))); __result; }));
trickles-server_1.c:21991:        struct files_struct *files = get_current()->files;
trickles-server_1.c:21992:        (void)(&files->file_lock);
trickles-server_1.c:21994:                __asm__ __volatile__("btsl %1,%0": "=m" (*(__kernel_fd_set *) (files->close_on_exec)):"r" ((int) (fd)));
trickles-server_1.c:21996:                __asm__ __volatile__("btrl %1,%0": "=m" (*(__kernel_fd_set *) (files->close_on_exec)):"r" ((int) (fd)));
trickles-server_1.c:22004:        if (fd < files->max_fds)
trickles-server_1.c:22005:                file = files->fd[fd];
trickles-server_1.c:22015:        struct files_struct *files = get_current()->files;
trickles-server_1.c:22017:        if (fd < files->max_fds)
trickles-server_1.c:22018:                file = files->fd[fd];
trickles-server_1.c:22028:        __asm__ __volatile__("btrl %1,%0": "=m" (*(__kernel_fd_set *) (files->open_fds)):"r" ((int) (fd)));
trickles-server_1.c:22029:        if (fd < files->next_fd)
trickles-server_1.c:22030:                files->next_fd = fd;
trickles-server_1.c:22035:        struct files_struct *files = get_current()->files;
trickles-server_1.c:22037:        (void)(&files->file_lock);
trickles-server_1.c:22044:# 18 "trickles-int.h" 2
trickles-server_1.c:22087:# 20 "trickles-int.h" 2
trickles-server_1.c:22099:                c -= 'A'-'a';
trickles-server_1.c:22106:                c -= 'a'-'A';
trickles-server_1.c:22109:# 25 "trickles-int.h" 2
trickles-server_1.c:22119:# 27 "trickles-int.h" 2
trickles-server_1.c:22120:# 40 "trickles-int.h"
trickles-server_1.c:22122:# 41 "trickles-int.h" 2
trickles-server_1.c:22126:# 2 "trickles-server.c" 2
trickles-server_1.c:22128:# 1 "memdump-util.h" 1
trickles-server_1.c:22143:                                printk("- ");
trickles-server_1.c:22158:# 4 "trickles-server.c" 2
trickles-server_1.c:22186:      { a=a-b; a=a-c; a=a^(c>>13); b=b-c; b=b-a; b=b^(a<<8); c=c-a; c=c-b; c=c^(b>>13); a=a-b; a=a-c; a=a^(c>>12); b=b-c; b=b-a; b=b^(a<<16); c=c-a; c=c-b; c=c^(b>>5); a=a-b; a=a-c; a=a^(c>>3); b=b-c; b=b-a; b=b^(a<<10); c=c-a; c=c-b; c=c^(b>>15); };
trickles-server_1.c:22187:      k = k+12; len = len-12;
trickles-server_1.c:22208:   { a=a-b; a=a-c; a=a^(c>>13); b=b-c; b=b-a; b=b^(a<<8); c=c-a; c=c-b; c=c^(b>>13); a=a-b; a=a-c; a=a^(c>>12); b=b-c; b=b-a; b=b^(a<<16); c=c-a; c=c-b; c=c^(b>>5); a=a-b; a=a-c; a=a^(c>>3); b=b-c; b=b-a; b=b^(a<<10); c=c-a; c=c-b; c=c^(b>>15); };
trickles-server_1.c:22216:        int runStart = -1;
trickles-server_1.c:22226:                                printk("[%d-%d]: ", runStart, i - 1);
trickles-server_1.c:22241:        for (elem = (typeof(elem))(list)->next; (elem != (typeof(elem))(list)); elem=(typeof(elem))elem->next) {
trickles-server_1.c:22242:                do { if(!(elem->list == list)) { printk("(%s) failed at %s:%s():%d\n", "elem->list == list", "cache_util.h", __PRETTY_FUNCTION__, 135); return 0; } } while(0);
trickles-server_1.c:22245:        do { if(!(count == list->len)) { printk("(%s) failed at %s:%s():%d\n", "count == list->len", "cache_util.h", __PRETTY_FUNCTION__, 138); return 0; } } while(0);
trickles-server_1.c:22248:# 6 "trickles-server.c" 2
trickles-server_1.c:22251:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-server_1.c:22252:        printk("At %d: %X:%d => %X:%d\n", lineno, sk->saddr, (int)ntohs(sk->sport), sk->daddr, (int)ntohs(sk->dport));
trickles-server_1.c:22270:# 35 "trickles-server.c"
trickles-server_1.c:22282:# 58 "trickles-server.c"
trickles-server_1.c:22288:    val -= 0x40000000;
trickles-server_1.c:22290:# 73 "trickles-server.c"
trickles-server_1.c:22291:  temp = (g << (15)) + (1 << ((15) * 2 - 2)); if (val >= temp) { g += 1 << ((15)-1); val -= temp; }
trickles-server_1.c:22292:  temp = (g << (14)) + (1 << ((14) * 2 - 2)); if (val >= temp) { g += 1 << ((14)-1); val -= temp; }
trickles-server_1.c:22293:  temp = (g << (13)) + (1 << ((13) * 2 - 2)); if (val >= temp) { g += 1 << ((13)-1); val -= temp; }
trickles-server_1.c:22294:  temp = (g << (12)) + (1 << ((12) * 2 - 2)); if (val >= temp) { g += 1 << ((12)-1); val -= temp; }
trickles-server_1.c:22295:  temp = (g << (11)) + (1 << ((11) * 2 - 2)); if (val >= temp) { g += 1 << ((11)-1); val -= temp; }
trickles-server_1.c:22296:  temp = (g << (10)) + (1 << ((10) * 2 - 2)); if (val >= temp) { g += 1 << ((10)-1); val -= temp; }
trickles-server_1.c:22297:  temp = (g << (9)) + (1 << ((9) * 2 - 2)); if (val >= temp) { g += 1 << ((9)-1); val -= temp; }
trickles-server_1.c:22298:  temp = (g << (8)) + (1 << ((8) * 2 - 2)); if (val >= temp) { g += 1 << ((8)-1); val -= temp; }
trickles-server_1.c:22299:  temp = (g << (7)) + (1 << ((7) * 2 - 2)); if (val >= temp) { g += 1 << ((7)-1); val -= temp; }
trickles-server_1.c:22300:  temp = (g << (6)) + (1 << ((6) * 2 - 2)); if (val >= temp) { g += 1 << ((6)-1); val -= temp; }
trickles-server_1.c:22301:  temp = (g << (5)) + (1 << ((5) * 2 - 2)); if (val >= temp) { g += 1 << ((5)-1); val -= temp; }
trickles-server_1.c:22302:  temp = (g << (4)) + (1 << ((4) * 2 - 2)); if (val >= temp) { g += 1 << ((4)-1); val -= temp; }
trickles-server_1.c:22303:  temp = (g << (3)) + (1 << ((3) * 2 - 2)); if (val >= temp) { g += 1 << ((3)-1); val -= temp; }
trickles-server_1.c:22304:  temp = (g << (2)) + (1 << ((2) * 2 - 2)); if (val >= temp) { g += 1 << ((2)-1); val -= temp; }
trickles-server_1.c:22312:# 118 "trickles-server.c"
trickles-server_1.c:22314:  int res, hint = -1;
trickles-server_1.c:22316:  unsigned startCwnd = cont->startCwnd;
trickles-server_1.c:22317:  unsigned ssthresh = ({ typeof(({ typeof(cont->ssthresh) Z = (typeof(cont->ssthresh))(startCwnd); ({ const typeof(cont->ssthresh) _x = (cont->ssthresh); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x > _y ? _x : _y; }); })) Z = (typeof(({ typeof(cont->ssthresh) Z = (typeof(cont->ssthresh))(startCwnd); ({ const typeof(cont->ssthresh) _x = (cont->ssthresh); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x > _y ? _x : _y; }); })))(((1<<13)-1)); ({ const typeof(({ typeof(cont->ssthresh) Z = (typeof(cont->ssthresh))(startCwnd); ({ const typeof(cont->ssthresh) _x = (cont->ssthresh); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x > _y ? _x : _y; }); })) _x = (({ typeof(cont->ssthresh) Z = (typeof(cont->ssthresh))(startCwnd); ({ const typeof(cont->ssthresh) _x = (cont->ssthresh); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x > _y ? _x : _y; }); })); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y; }); });
trickles-server_1.c:22318:  unsigned TCPBase = cont->TCPBase;
trickles-server_1.c:22319:  unsigned additiveStart = (ssthresh - startCwnd + TCPBase) + ssthresh;
trickles-server_1.c:22322:  seq = TCPBase + (seq - TCPBase) * 1/2;
trickles-server_1.c:22328:    res = -1;
trickles-server_1.c:22331:# 145 "trickles-server.c"
trickles-server_1.c:22332:  if(seq < ssthresh - startCwnd + TCPBase) {
trickles-server_1.c:22333:    res = startCwnd + (seq - TCPBase);
trickles-server_1.c:22334:  } else if(ssthresh - startCwnd + TCPBase <= seq &&
trickles-server_1.c:22342:          int offset = seq - additiveStart;
trickles-server_1.c:22346:          cwnd = (((-1 << ((1) - 1)) + mborg_isqrt4((1 << (2*(1) - 2)) - ((-((int)(ssthresh) * ((int)(ssthresh) + 1)) - 2 * (((int)seq) - (TCPBase))) << (2*(1))))) >> (1));
trickles-server_1.c:22351:          cwnd = (({ typeof((cwnd)) Z = (typeof((cwnd)))(((1<<13)-1)); ({ const typeof((cwnd)) _x = ((cwnd)); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y; }); }));
trickles-server_1.c:22352:          position = (cwnd*(cwnd+1)-ssthresh*(ssthresh+1)) / 2;
trickles-server_1.c:22353:          if(cwnd == ((1<<13)-1)) {
trickles-server_1.c:22355:                  hint = - 1;
trickles-server_1.c:22358:                          int cwnd_1 = (({ typeof((cwnd + 1)) Z = (typeof((cwnd + 1)))(((1<<13)-1)); ({ const typeof((cwnd + 1)) _x = ((cwnd + 1)); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y; }); })),
trickles-server_1.c:22359:                                  cwnd_2 = (({ typeof((cwnd + 2)) Z = (typeof((cwnd + 2)))(((1<<13)-1)); ({ const typeof((cwnd + 2)) _x = ((cwnd + 2)); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y; }); }));
trickles-server_1.c:22373:                          if(offset > position - cwnd) {
trickles-server_1.c:22377:                                  if(!(offset > position - cwnd - (cwnd - 1))) {
trickles-server_1.c:22382:                                  if((cwnd - 1) < ssthresh) {
trickles-server_1.c:22391:                                  res = cwnd - 1;
trickles-server_1.c:22392:                                  hint = additiveStart + position - cwnd;
trickles-server_1.c:22396:# 293 "trickles-server.c"
trickles-server_1.c:22400:  if(res > ((1<<13)-1))
trickles-server_1.c:22401:          res = ((1<<13)-1);
trickles-server_1.c:22403:    *hintResult = (hint >= 0) ? hint : -1;
trickles-server_1.c:22404:  ((struct cminisock*)cont)->mark = res;
trickles-server_1.c:22413:  if(sack->left > sack->right) {
trickles-server_1.c:22418:    __u32 genNonce = generateRangeNonce(cont->sk, sack->left, sack->right);
trickles-server_1.c:22419:    if(genNonce != sack->nonceSummary) {
trickles-server_1.c:22425:        printk("nonce check failed for [%d-%d] = 0x%0X != 0x%0X\n",
trickles-server_1.c:22426:               sack->left, sack->right, genNonce, sack->nonceSummary);
trickles-server_1.c:22441:  return sack->left <= seq && seq <= sack->right;
trickles-server_1.c:22445:  return right->left - left->right - 1;
trickles-server_1.c:22459:  struct cminisock *cont = proof->cont;
trickles-server_1.c:22460:  Sack *sacks = proof->sacks;
trickles-server_1.c:22461:  int numSacks = proof->numSacks;
trickles-server_1.c:22465:     sacks[0].left > cont->TCPBase) {
trickles-server_1.c:22467:                  printk("Zero sacks (%d), too many sacks, or start (%u) > TCPBase (%u) [seq = %u]\n", numSacks, sacks[0].left, cont->TCPBase, cont->seq);
trickles-server_1.c:22474:    if(i > 0 && sacks[i].left <= sacks[i-1].right) {
trickles-server_1.c:22483:  int i, numSacks = proof->numSacks;
trickles-server_1.c:22484:  Sack *sacks = proof->sacks;
trickles-server_1.c:22486:    if(!Sack_adjacent(&sacks[i-1], &sacks[i])) {
trickles-server_1.c:22487:      return sacks[i-1].right + 1;
trickles-server_1.c:22491:  return -1;
trickles-server_1.c:22498:  Sack *sacks = proof->sacks;
trickles-server_1.c:22501:  for(i=0; i < proof->numSacks; i++) {
trickles-server_1.c:22510:  if(i == proof->numSacks) {
trickles-server_1.c:22520:  Sack *sacks = proof->sacks;
trickles-server_1.c:22523:  for(i=0; i < proof->numSacks; i++) {
trickles-server_1.c:22532:          return cursor - 1;
trickles-server_1.c:22534:          return start - 1;
trickles-server_1.c:22541:  Sack *sacks = proof->sacks;
trickles-server_1.c:22544:  for(i=proof->numSacks - 1; i >= 0; i--) {
trickles-server_1.c:22549:      cursor = sacks[i].left - 1;
trickles-server_1.c:22564:        printk("proof(%d) = ", proof->numSacks);
trickles-server_1.c:22565:        for(i = 0; i < proof->numSacks; i++) {
trickles-server_1.c:22566:                printk("[%d-%d]", proof->sacks[i].left, proof->sacks[i].right);
trickles-server_1.c:22573:        WireTrickleRequest *req = (WireTrickleRequest*)skb->data;
trickles-server_1.c:22587:                        printk("SKB too short for WireTrickleRequest, len = %d\n", skb->len);
trickles-server_1.c:22595:        sacks_len = req->ackProof.numSacks * sizeof(WireSack);
trickles-server_1.c:22599:        if(!(req->ackProof.numSacks <= 64 &&
trickles-server_1.c:22607:        ucont_len = ntohs(req->ucont_len);
trickles-server_1.c:22613:        if(!(((serverSK)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((serverSK)->tp_pinfo.af_tcp.trickles_opt & (serverSK)->tp_pinfo.af_tcp.trickles_opt & 0x8))) {
trickles-server_1.c:22628:                        (__builtin_constant_p(ucont_len) ? __constant_memcpy((ucont_data),(pkt_ucont_data = (char*)skb->data),(ucont_len)) : __memcpy((ucont_data),(pkt_ucont_data = (char*)skb->data),(ucont_len)));
trickles-server_1.c:22640:        if (!(skb->len >= 0)) { printk("KERNEL: assertion (" "skb->len >= 0" ") failed at " "trickles-server.c" "(%d)\n", 536); };
trickles-server_1.c:22641:        if(!(((serverSK)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((serverSK)->tp_pinfo.af_tcp.trickles_opt & (serverSK)->tp_pinfo.af_tcp.trickles_opt & 0x8))) {
trickles-server_1.c:22643:                input_len = skb->len;
trickles-server_1.c:22657:                        (__builtin_constant_p(input_len) ? __constant_memcpy((input),((char*)skb->data),(input_len)) : __memcpy((input),((char*)skb->data),(input_len)));
trickles-server_1.c:22667:# 574 "trickles-server.c"
trickles-server_1.c:22668:        __u32 seqno = ntohl(req->cont.seq);
trickles-server_1.c:22672:        if(!(((serverSK)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((serverSK)->tp_pinfo.af_tcp.trickles_opt & (serverSK)->tp_pinfo.af_tcp.trickles_opt & 0x8)) &&
trickles-server_1.c:22676:                                        skb->nh.iph, skb->h.th)) != ((void *)0)) {
trickles-server_1.c:22678:                        struct WireContinuation *scont = &req->cont;
trickles-server_1.c:22683:                        msk->sk = msk->serverSK = serverSK;
trickles-server_1.c:22685:                        msk->pmsk = packed_msk = lookup;
trickles-server_1.c:22688:                        msk->seq = ntohl(scont->seq);
trickles-server_1.c:22689:                        msk->firstChild = packed_msk->firstChild =
trickles-server_1.c:22690:                                scont->firstChild;
trickles-server_1.c:22691:                        msk->clientState = packed_msk->clientState =
trickles-server_1.c:22692:                                scont->clientState;
trickles-server_1.c:22693:                        msk->parent = packed_msk->parent =
trickles-server_1.c:22694:                                scont->parent;
trickles-server_1.c:22695:                        msk->clientTimestamp = packed_msk->clientTimestamp =
trickles-server_1.c:22696:                                scont->clientTimestamp;
trickles-server_1.c:22698:                        if (!(msk->saddr == skb->nh.iph->daddr && msk->daddr == skb->nh.iph->saddr && msk->source == skb->h.th->dest && msk->dest == skb->h.th->source)) { printk("KERNEL: assertion (" "msk->saddr == skb->nh.iph->daddr && msk->daddr == skb->nh.iph->saddr && msk->source == skb->h.th->dest && msk->dest == skb->h.th->source" ") failed at " "trickles-server.c" "(%d)\n", 607); };
trickles-server_1.c:22703:                        if (!(msk->ctl == ALLOC_PENDING)) { printk("KERNEL: assertion (" "msk->ctl == ALLOC_PENDING" ") failed at " "trickles-server.c" "(%d)\n", 609); };
trickles-server_1.c:22705:                        msk->ucont_len = ucont_len; msk->ucont_data = ucont_data; ucont_data = ((void *)0); msk->input_len = input_len; msk->input = input; input = ((void *)0);;
trickles-server_1.c:22715:                if(!(((serverSK)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((serverSK)->tp_pinfo.af_tcp.trickles_opt & (serverSK)->tp_pinfo.af_tcp.trickles_opt & 0x8))) {
trickles-server_1.c:22720:                skb->sk = msk->sk = msk->serverSK = serverSK;
trickles-server_1.c:22726:                msk->pmsk = packed_msk;
trickles-server_1.c:22727:                if(!unmarshallContinuationServerMSK(skb, msk, &req->cont)) {
trickles-server_1.c:22733:                msk->ucont_len = ucont_len; msk->ucont_data = ucont_data; ucont_data = ((void *)0); msk->input_len = input_len; msk->input = input; input = ((void *)0);;
trickles-server_1.c:22760:        if(!(((msk->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((msk->sk)->tp_pinfo.af_tcp.trickles_opt & (msk->sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) {
trickles-server_1.c:22761:                msk->saddr = skb->nh.iph->daddr;
trickles-server_1.c:22762:                msk->source = skb->h.th->dest;
trickles-server_1.c:22764:                msk->daddr = skb->nh.iph->saddr;
trickles-server_1.c:22765:                msk->dest = skb->h.th->source;
trickles-server_1.c:22773:        if(!(((msk->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((msk->sk)->tp_pinfo.af_tcp.trickles_opt & (msk->sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) {
trickles-server_1.c:22777:                for(i=0; i < msk->num_packets; i++) {
trickles-server_1.c:22778:                        msk->packets[i].nonce = generateSingleNonce(msk->sk, msk->packets[i].seq, &ctx);
trickles-server_1.c:22779:                        msk->packets[i].ucontLen = 0;
trickles-server_1.c:22780:                        msk->packets[i].ucontData = ((void *)0);
trickles-server_1.c:22789:# 706 "trickles-server.c"
trickles-server_1.c:22792:                unmarshallContinuationServerMSK2PMSK(msk->sk, msk->pmsk, msk);
trickles-server_1.c:22798:                queue_upcall_pmsk_prealloc(msk->sk,event,msk->pmsk);
trickles-server_1.c:22799:                queue_upcall_pmsk(event,msk->pmsk);
trickles-server_1.c:22802:                struct cminisock *copy = shallow_copy_msk(msk->serverSK, msk);
trickles-server_1.c:22805:                        free_trickles_msk(msk->serverSK, msk);
trickles-server_1.c:22806:                        free_trickles_msk_finish(msk->serverSK, msk);
trickles-server_1.c:22809:                queue_upcall_msk_prealloc(msk->sk,event,copy);
trickles-server_1.c:22813:                queue_upcall_deliver(msk->sk);
trickles-server_1.c:22820:                msk->ucont_len = 0;
trickles-server_1.c:22823:                msk->clientState = 0;
trickles-server_1.c:22824:                msk->mrtt = 0;
trickles-server_1.c:22827:                msk->firstLoss = 0x1055;
trickles-server_1.c:22828:                msk->firstBootstrapSeq = 0xb007;
trickles-server_1.c:22830:                msk->ssthresh = 0x3fff;
trickles-server_1.c:22832:        msk->TCPBase = seqno;
trickles-server_1.c:22835:                return -12;
trickles-server_1.c:22841:                makePacket(&msk->packets[i], seq, 1, (sysctl_trickles_mss),
trickles-server_1.c:22843:                           1 * (sysctl_trickles_mss), -1, 1);
trickles-server_1.c:22846:        msk->num_packets = num_packets;
trickles-server_1.c:22854:        int rval = -22;
trickles-server_1.c:22855:        struct tcphdr *ith = in_skb->h.th;
trickles-server_1.c:22856:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-server_1.c:22859:        if(0 && !(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) {
trickles-server_1.c:22869:        if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8)) && !((tp)->cminisock_api_config.cfg.mmap_base != ((void *)0) && (tp)->cminisock_api_config.cfg.ctl != ((void *)0))) {
trickles-server_1.c:22873:# 803 "trickles-server.c"
trickles-server_1.c:22875:        if((((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) {
trickles-server_1.c:22878:        if(ith->syn) {
trickles-server_1.c:22879:                if((((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) { msk = alloc_trickles_msk(sk); } else { msk = ({ struct cminisock *__msk = &cpu_msk[0]; msk_initStatic(__msk); __msk; }); } msk->serverSK = sk; msk->sk = sk; in_skb->sk = sk; pre_init_sock(msk,in_skb);;
trickles-server_1.c:22885:                if(ith->ack) {
trickles-server_1.c:22890:                msk->tokenCounterBase = tp->bigTokenCounter;
trickles-server_1.c:22891:                tp->bigTokenCounter += ((__u64) 1) << 32;
trickles-server_1.c:22895:                msk->input_len = in_skb->len;
trickles-server_1.c:22897:                if(msk->input_len > 0) {
trickles-server_1.c:22899:                        msk->input = tmalloc(in_skb->sk, msk->input_len);
trickles-server_1.c:22901:                        if(msk->input == ((void *)0)) {
trickles-server_1.c:22903:                                        printk("Could not allocate memory for SYN, len = %d\n", msk->input_len);
trickles-server_1.c:22907:                        (__builtin_constant_p(msk->input_len) ? __constant_memcpy((msk->input),((char*)in_skb->data),(msk->input_len)) : __memcpy((msk->input),((char*)in_skb->data),(msk->input_len)));
trickles-server_1.c:22908:                        num_packets = msk->startCwnd = (3);
trickles-server_1.c:22911:                        msk->input = ((void *)0);
trickles-server_1.c:22913:                        do { (msk)->startCwnd = 0; } while(0);
trickles-server_1.c:22915:                msk->pmsk = alloc_trickles_pmsk(sk);
trickles-server_1.c:22916:                if(msk->pmsk == ((void *)0)) {
trickles-server_1.c:22923:        } else if(ith->fin) {
trickles-server_1.c:22930:        } else if(ith->rst) {
trickles-server_1.c:22945:        if(rval != -12) {
trickles-server_1.c:22953:# 897 "trickles-server.c"
trickles-server_1.c:22957:  int rval = -22;
trickles-server_1.c:22970:      return -22;
trickles-server_1.c:22972:      if (!(error == 12)) { printk("KERNEL: assertion (" "error == ENOMEM" ") failed at " "trickles-server.c" "(%d)\n", 915); };
trickles-server_1.c:22973:      return -12;
trickles-server_1.c:22980:          return -12;
trickles-server_1.c:22992:  cont->executionTrace = 0;
trickles-server_1.c:22995:  if(!(((cont->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((cont->sk)->tp_pinfo.af_tcp.trickles_opt & (cont->sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) {
trickles-server_1.c:22996:          cont->ack_seq = skb->h.th->ack_seq;
trickles-server_1.c:23002:          cont->dbg_timestamp = jiffies;
trickles-server_1.c:23008:  unmarshallAckProof(&ackProof, &treq_hdr->ackProof);
trickles-server_1.c:23012:  if(!(((cont->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((cont->sk)->tp_pinfo.af_tcp.trickles_opt & (cont->sk)->tp_pinfo.af_tcp.trickles_opt & 0x8)) && !AckProof_validate(&ackProof)) {
trickles-server_1.c:23014:    if((((skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((skb->sk)->tp_pinfo.af_tcp.trickles_opt & (skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x8)) && debugSimulation)
trickles-server_1.c:23016:    return -22;
trickles-server_1.c:23022:    printk("Server processing: %u\n", cont->seq);
trickles-server_1.c:23028:  rangeCheck = AckProof_checkRange(&ackProof, cont->TCPBase, cont->seq);
trickles-server_1.c:23032:  switch((enum TrickleRequestType)treq_hdr->type) {
trickles-server_1.c:23035:    cont->mrtt -= cont->mrtt >> 3;
trickles-server_1.c:23036:    cont->mrtt += jiffies - cont->timestamp;
trickles-server_1.c:23039:    (cont)->timestamp = jiffies;
trickles-server_1.c:23043:    switch(cont->state) {
trickles-server_1.c:23052:# 1007 "trickles-server.c"
trickles-server_1.c:23060:          printk("  Bad or poisoned Range (ack # %u)\n", cont->seq);
trickles-server_1.c:23086:        if(!(AckProof_checkRange(&ackProof, cont->TCPBase, cont->firstLoss-1) == NORMALRANGE
trickles-server_1.c:23087:             && AckProof_checkRange(&ackProof, cont->firstBootstrapSeq, cont->seq) == NORMALRANGE)) {
trickles-server_1.c:23094:        cont->TCPBase = cont->firstBootstrapSeq;
trickles-server_1.c:23096:          printk("Bootstrap: TCPBase = %u CWND = %u SSTHRESH = %u\n", cont->TCPBase, cont->startCwnd, cont->ssthresh);
trickles-server_1.c:23112:        return -22;
trickles-server_1.c:23120:    cont->mrtt = (jiffies - cont->timestamp) << 3;
trickles-server_1.c:23123:    (cont)->timestamp = jiffies;
trickles-server_1.c:23130:    seq = AckProof_findRight(&ackProof, cont->TCPBase);
trickles-server_1.c:23131:    if(seq < cont->TCPBase) {
trickles-server_1.c:23132:            printk("  SlowStart: seq < cont->TCPBase\n");
trickles-server_1.c:23133:            return -22;
trickles-server_1.c:23166:        struct cminisock_packet *packet = &msk->packets[packet_num];
trickles-server_1.c:23167:        int ucontLen = packet->ucontLen;
trickles-server_1.c:23168:        int origSkbLen = skb->len;
trickles-server_1.c:23169:# 1163 "trickles-server.c"
trickles-server_1.c:23170:        sk = skb->sk = msk->sk;
trickles-server_1.c:23180:        if (!(ucontLen >= 0)) { printk("KERNEL: assertion (" "ucontLen >= 0" ") failed at " "trickles-server.c" "(%d)\n", 1173); };
trickles-server_1.c:23182:                if(packet->ucontData != ((void *)0)) {
trickles-server_1.c:23183:                        (__builtin_constant_p(ucontLen) ? __constant_memcpy((skb_push(skb, ucontLen)),(packet->ucontData),(ucontLen)) : __memcpy((skb_push(skb, ucontLen)),(packet->ucontData),(ucontLen)));
trickles-server_1.c:23190:        if(packet->contType & (0x80)) {
trickles-server_1.c:23192:# 1220 "trickles-server.c"
trickles-server_1.c:23198:                switch(packet->contType) {
trickles-server_1.c:23200:                        resp_hdr = (WireTrickleResponse*)skb_push(skb, (sizeof(WireTrickleResponse) - ((sizeof(struct WireContinuation)) - ((int)(((struct WireContinuation*)0)->minimalContinuationEnd)))));
trickles-server_1.c:23201:                        resp_hdr->cont.seq = htonl(packet->seq);
trickles-server_1.c:23202:                        resp_hdr->cont.continuationType = (0);
trickles-server_1.c:23203:                        resp_hdr->cont.clientState = msk->clientState;
trickles-server_1.c:23204:                        resp_hdr->cont.parent = msk->parent;
trickles-server_1.c:23205:                        resp_hdr->cont.clientTimestamp = msk->clientTimestamp;
trickles-server_1.c:23211:                        marshallContinuationServer(sk, &resp_hdr->cont, msk, packet_num);
trickles-server_1.c:23212:# 1251 "trickles-server.c"
trickles-server_1.c:23214:                                if(((msk->pmsk)->cacheRecycleIndex >= 0)) {
trickles-server_1.c:23215:                                        pminisock_cache_child(msk->serverSK, msk,
trickles-server_1.c:23216:                                                              msk->pmsk, packet_num, (0x1) | (0x2));
trickles-server_1.c:23219:                                        msk->pmsk->cacheRecycleIndex = msk->cacheRecycleIndex = packet_num;
trickles-server_1.c:23220:                                        if (!(packet_num == msk->pmsk->cacheRecycleIndex)) { printk("KERNEL: assertion (" "packet_num == msk->pmsk->cacheRecycleIndex" ") failed at " "trickles-server.c" "(%d)\n", 1258); };
trickles-server_1.c:23229:        resp_hdr->nonce = packet->nonce;
trickles-server_1.c:23231:        resp_hdr->ucont_len = htons((short)ucontLen);
trickles-server_1.c:23233:        resp_hdr->numSiblings = packet->numSiblings;
trickles-server_1.c:23234:        resp_hdr->position = packet->position;
trickles-server_1.c:23243:        skb->h.th = th;
trickles-server_1.c:23244:        th->source = sk->sport;
trickles-server_1.c:23245:        th->dest = msk->dest;
trickles-server_1.c:23247:        th->seq = htonl(msk->seq);
trickles-server_1.c:23254:                                      msk->daddr, msk->dest, packet->seq,
trickles-server_1.c:23256:                                      msk->startCwnd, msk->mark , msk->ssthresh,
trickles-server_1.c:23257:                                      msk->mrtt, msk->mrtt);
trickles-server_1.c:23259:        th->ack_seq = packetID;
trickles-server_1.c:23264:        th->doff = tcp_header_size >> 2;
trickles-server_1.c:23265:        th->res1= 0;
trickles-server_1.c:23266:        th->cwr = 0;
trickles-server_1.c:23267:        th->ece = 0;
trickles-server_1.c:23268:        th->urg = 0;
trickles-server_1.c:23270:        th->ack = 1;
trickles-server_1.c:23271:        th->psh = 0;
trickles-server_1.c:23272:        th->rst = 0;
trickles-server_1.c:23273:        th->syn = 0;
trickles-server_1.c:23274:        th->fin = 0;
trickles-server_1.c:23277:        th->window = 0;
trickles-server_1.c:23278:        th->check = 0;
trickles-server_1.c:23279:        th->urg_ptr = 0;
trickles-server_1.c:23282:                                ((__u16)(sizeof(WireTrickleResponse) + msk->ucont_len)));
trickles-server_1.c:23284:        switch(msk->tag) {
trickles-server_1.c:23287:                        th->syn = 1;
trickles-server_1.c:23288:                        th->ack = 1;
trickles-server_1.c:23296:                th->fin = 1;
trickles-server_1.c:23300:                th->ack = 1;
trickles-server_1.c:23307:        numTxBytes += skb->len;
trickles-server_1.c:23309:        if (!(sk->protocol == IPPROTO_TCP)) { printk("KERNEL: assertion (" "sk->protocol == IPPROTO_TCP" ") failed at " "trickles-server.c" "(%d)\n", 1347); };
trickles-server_1.c:23314:        trickles_checksum(skb, skb->len - origSkbLen);
trickles-server_1.c:23315:        err = af->queue_xmit(skb, 0);
trickles-server_1.c:23318:# 1371 "trickles-server.c"
trickles-server_1.c:23320:# 1392 "trickles-server.c"
trickles-server_1.c:23322:# 1431 "trickles-server.c"
trickles-server_1.c:23329:    (((*cont)->continuationType) == (2) ? ((*cont)->seq) - 1 : ((*cont)->seq)), firstResponseSeq;
trickles-server_1.c:23336:  if(((*cont)->startCwnd == 0)) {
trickles-server_1.c:23338:          (*cont)->startCwnd = (3);
trickles-server_1.c:23339:          return doInitialCwnd(*cont, event, (*cont)->seq + 1, (*cont)->startCwnd);
trickles-server_1.c:23342:  (*cont)->executionTrace = 1;
trickles-server_1.c:23349:  prevCwnd = (first_ack_seq == (*cont)->TCPBase) ?
trickles-server_1.c:23350:    (*cont)->startCwnd :
trickles-server_1.c:23351:    AckTCPCwnd(first_ack_seq - 1, (*cont), &hint);
trickles-server_1.c:23355:  currCwnd = AckTCPCwndScalar((*cont)->seq, (*cont));
trickles-server_1.c:23359:  (*cont)->actualCwnd = currCwnd;
trickles-server_1.c:23363:  numOutput = ({ typeof(0) Z = (typeof(0))(currCwnd - (int)prevCwnd); ({ const typeof(0) _x = (0); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x > _y ? _x : _y; }); });
trickles-server_1.c:23365:  switch((*cont)->continuationType) {
trickles-server_1.c:23379:            (({ printk("Error in acktcpcwnd base = %d %d=>%d %d=>%d\n" "\n", (*cont)->TCPBase, first_ack_seq - 1, prevCwnd, (*cont)->seq, currCwnd); 1; }));
trickles-server_1.c:23384:    free_trickles_msk((*cont)->sk,*cont);
trickles-server_1.c:23385:    free_trickles_msk_finish((*cont)->sk,*cont);
trickles-server_1.c:23386:    return -22;
trickles-server_1.c:23393:    printk("bug in cwnd generation: ack_seq = %u-%u, TCPBase = %u, "
trickles-server_1.c:23395:           first_ack_seq, (*cont)->seq, (*cont)->TCPBase,
trickles-server_1.c:23396:           (*cont)->startCwnd, numOutput);
trickles-server_1.c:23398:    free_trickles_msk((*cont)->sk,(*cont));
trickles-server_1.c:23399:    free_trickles_msk_finish((*cont)->sk,(*cont));
trickles-server_1.c:23400:    return -22;
trickles-server_1.c:23410:    free_trickles_msk((*cont)->sk,(*cont));
trickles-server_1.c:23411:    free_trickles_msk_finish((*cont)->sk,(*cont));
trickles-server_1.c:23412:    return -12;
trickles-server_1.c:23416:    int thisMSS, nextResponseLen = 0, firstChild = -1,
trickles-server_1.c:23417:      numChildren = -1, contType;
trickles-server_1.c:23419:      if((*cont)->state == CONT_BOOTSTRAP) {
trickles-server_1.c:23424:    offset = seq - (*cont)->TCPBase;
trickles-server_1.c:23425:# 1548 "trickles-server.c"
trickles-server_1.c:23427:# 1565 "trickles-server.c"
trickles-server_1.c:23434:            thisMSS = ((sysctl_trickles_mss) + sizeof(struct WireContinuation) - (int)((struct WireContinuation*)0)->minimalContinuationEnd);
trickles-server_1.c:23437:            thisMSS = -1;
trickles-server_1.c:23442:    makePacket(&(*cont)->packets[numPackets], seq, 0xdeadbeef, thisMSS, (first ? (0x80) : 0) | (0), contType, nextResponseLen,
trickles-server_1.c:23449:  (*cont)->num_packets = numPackets;
trickles-server_1.c:23450:  if (!(numPackets <= numOutput)) { printk("KERNEL: assertion (" "numPackets <= numOutput" ") failed at " "trickles-server.c" "(%d)\n", 1587); };
trickles-server_1.c:23466:    return end - start + 1;
trickles-server_1.c:23471:# 1616 "trickles-server.c"
trickles-server_1.c:23474:        if (!(!((*cont)->startCwnd == 0))) { printk("KERNEL: assertion (" "!IS_DEFERRED_INITIALCWND(*cont)" ") failed at " "trickles-server.c" "(%d)\n", 1618); };
trickles-server_1.c:23477:  Sack *sacks = ackProof->sacks;
trickles-server_1.c:23494:  (*cont)->executionTrace = 2;
trickles-server_1.c:23500:          free_trickles_msk((*cont)->sk,(*cont));
trickles-server_1.c:23501:          free_trickles_msk_finish((*cont)->sk,(*cont));
trickles-server_1.c:23502:          return -22;
trickles-server_1.c:23504:  (*cont)->state = CONT_RECOVERY;
trickles-server_1.c:23505:  (*cont)->firstLoss = AckProof_firstLoss(ackProof);
trickles-server_1.c:23506:  switch(((((*cont)->firstLoss - (*cont)->TCPBase) < (8)) ? (1) : (((((*cont)->firstLoss - (*cont)->TCPBase)) % 2 == 0) ? (2) : (0)))) {
trickles-server_1.c:23509:    origCwndPred = AckTCPCwndScalar(AckProof_firstLoss(ackProof)-1, (*cont));
trickles-server_1.c:23513:    origCwndPred = AckTCPCwndScalar(AckProof_firstLoss(ackProof)-2, (*cont));
trickles-server_1.c:23514:    adj = -1;
trickles-server_1.c:23519:    free_trickles_msk((*cont)->sk,(*cont));
trickles-server_1.c:23520:    free_trickles_msk_finish((*cont)->sk,(*cont));
trickles-server_1.c:23521:    return -22;
trickles-server_1.c:23523:  lastRegularPacket = ((*cont)->firstLoss - 1 + adj) + origCwndPred;
trickles-server_1.c:23524:  (*cont)->num_packets = 0;
trickles-server_1.c:23532:  (*cont)->actualCwnd = newCwnd;
trickles-server_1.c:23536:  (*cont)->TCPBase = (*cont)->firstBootstrapSeq = lastRegularPacket + 1;
trickles-server_1.c:23537:  (*cont)->startCwnd = newCwnd;
trickles-server_1.c:23542:    (*cont)->ssthresh /= 2;
trickles-server_1.c:23544:    (*cont)->ssthresh = newCwnd;
trickles-server_1.c:23547:  bootstrapStart = lastRegularPacket - newCwnd;
trickles-server_1.c:23548:  bootstrapEnd = bootstrapStart + newCwnd - 1;
trickles-server_1.c:23555:  for(i=0; i < ackProof->numSacks; i++) {
trickles-server_1.c:23557:    if(i > 0 && !Sack_adjacent(&sacks[i-1], &sacks[i])) {
trickles-server_1.c:23558:      gaplen = Sack_gapLen(&sacks[i-1], &sacks[i]);
trickles-server_1.c:23562:        intersect(bootstrapStart, sacks[i].left-1,
trickles-server_1.c:23563:                  bootstrapEnd, sacks[i-1].right+1);
trickles-server_1.c:23565:    if(Sack_contains(&ackProof->sacks[i], (*cont)->seq)) {
trickles-server_1.c:23566:      if(((*cont)->seq == sacks[i].left ||
trickles-server_1.c:23567:          ((*cont)->continuationType == (2) && (*cont)->seq - 1 == sacks[i].left))
trickles-server_1.c:23571:        gapLeft = ackProof->sacks[i-1].right + 1,
trickles-server_1.c:23572:          gapRight = ackProof->sacks[i].left - 1;
trickles-server_1.c:23587:    numPacketsAllocated += (gapRight - gapLeft) + 1;
trickles-server_1.c:23592:      numPacketsAllocated += (end - start) + 1;
trickles-server_1.c:23597:    bootstrapIntersectStart = ({ typeof((((*cont)->continuationType) == (2) ? ((*cont)->seq) - 1 : ((*cont)->seq))) Z = (typeof((((*cont)->continuationType) == (2) ? ((*cont)->seq) - 1 : ((*cont)->seq))))(bootstrapStart); ({ const typeof((((*cont)->continuationType) == (2) ? ((*cont)->seq) - 1 : ((*cont)->seq))) _x = ((((*cont)->continuationType) == (2) ? ((*cont)->seq) - 1 : ((*cont)->seq))); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x > _y ? _x : _y; }); });
trickles-server_1.c:23599:    bootstrapIntersectLast = ({ typeof((*cont)->seq) Z = (typeof((*cont)->seq))(bootstrapEnd); ({ const typeof((*cont)->seq) _x = ((*cont)->seq); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y; }); });
trickles-server_1.c:23603:        bootstrapIntersectLast - bootstrapIntersectStart + 1;
trickles-server_1.c:23607:    free_trickles_msk((*cont)->sk,(*cont));
trickles-server_1.c:23608:    free_trickles_msk_finish((*cont)->sk,(*cont));
trickles-server_1.c:23613:    free_trickles_msk((*cont)->sk,(*cont));
trickles-server_1.c:23614:    free_trickles_msk_finish((*cont)->sk,(*cont));
trickles-server_1.c:23616:    return -12;
trickles-server_1.c:23622:      printk("  Bootstrap [%d - %d], newCwnd %d\n", bootstrapStart, bootstrapEnd, newCwnd);
trickles-server_1.c:23626:    if(gapRight - gapLeft > 20) {
trickles-server_1.c:23628:          free_trickles_msk((*cont)->sk,(*cont));
trickles-server_1.c:23629:          free_trickles_msk_finish((*cont)->sk,(*cont));
trickles-server_1.c:23631:                  printk("recovery gapsize too big - %d\n", gapRight - gapLeft);
trickles-server_1.c:23632:          return -22;
trickles-server_1.c:23639:      makePacket(&(*cont)->packets[numPackets], seq, 0xdeadbeef, ((sysctl_trickles_mss) + sizeof(struct WireContinuation) - (int)((struct WireContinuation*)0)->minimalContinuationEnd), (1), (0), ((sysctl_trickles_mss) + sizeof(struct WireContinuation) - (int)((struct WireContinuation*)0)->minimalContinuationEnd),
trickles-server_1.c:23640:                         -1, -1);
trickles-server_1.c:23646:        __u32 bootstrap_seq = lastRegularPacket + 1 + (seq - bootstrapStart);
trickles-server_1.c:23655:        if(bootstrap_seq == (*cont)->TCPBase) {
trickles-server_1.c:23657:                firstChild = bootstrap_seq + (*cont)->startCwnd;
trickles-server_1.c:23660:                prevCwnd = AckTCPCwndScalar(bootstrap_seq - 1, *cont);
trickles-server_1.c:23663:                numChildren = currCwnd - prevCwnd + 1;
trickles-server_1.c:23667:        makePacket(&(*cont)->packets[numPackets],
trickles-server_1.c:23683:  if (!((*cont)->continuationType == (1) || (*cont)->continuationType == (2))) { printk("KERNEL: assertion (" "(*cont)->continuationType == CONTTYPE_FULL1 || (*cont)->continuationType == CONTTYPE_FULL2" ") failed at " "trickles-server.c" "(%d)\n", 1828); };
trickles-server_1.c:23690:    __u32 seq = lastRegularPacket + 1 + (ack_seq - bootstrapStart);
trickles-server_1.c:23698:    if(seq == (*cont)->TCPBase) {
trickles-server_1.c:23700:      firstChild = seq + (*cont)->startCwnd;
trickles-server_1.c:23703:      prevCwnd = AckTCPCwndScalar(seq - 1, *cont);
trickles-server_1.c:23706:      numChildren = currCwnd - prevCwnd + 1;
trickles-server_1.c:23710:    makePacket(&(*cont)->packets[numPackets], seq, 0xdeadbeef, (sysctl_trickles_mss) ,
trickles-server_1.c:23718:  (*cont)->num_packets = numPackets;
trickles-server_1.c:23721:    if (!(numPacketsSendable <= numPacketsAllocated)) { printk("KERNEL: assertion (" "numPacketsSendable <= numPacketsAllocated" ") failed at " "trickles-server.c" "(%d)\n", 1865); };
trickles-server_1.c:23738:        if((*cont)->startCwnd == 0) {
trickles-server_1.c:23739:                (*cont)->startCwnd = 1;
trickles-server_1.c:23741:  (*cont)->executionTrace = 3;
trickles-server_1.c:23743:  int right = AckProof_findRight(ackProof, (*cont)->TCPBase);
trickles-server_1.c:23746:  (*cont)->actualCwnd = effCwnd;
trickles-server_1.c:23754:    (*cont)->ssthresh = effCwnd / 2;
trickles-server_1.c:23756:    (*cont)->ssthresh /= 2;
trickles-server_1.c:23760:  (*cont)->TCPBase = newBase;
trickles-server_1.c:23761:  (*cont)->startCwnd = (2);
trickles-server_1.c:23763:  (*cont)->actualCwnd = (*cont)->startCwnd;
trickles-server_1.c:23766:  if(!alloc_msk_packets((*cont), (*cont)->startCwnd)) {
trickles-server_1.c:23767:          free_trickles_msk((*cont)->sk, (*cont));
trickles-server_1.c:23768:          free_trickles_msk_finish((*cont)->sk, (*cont));
trickles-server_1.c:23769:          return -12;
trickles-server_1.c:23771:  (*cont)->num_packets = (*cont)->startCwnd;
trickles-server_1.c:23773:  for(i=0; i < (*cont)->num_packets; i++) {
trickles-server_1.c:23782:          makePacket(&(*cont)->packets[i], (*cont)->TCPBase + i, 0xdeadbeef, len,
trickles-server_1.c:23784:                     0, -1, -1);
trickles-server_1.c:23786:# 1955 "trickles-server.c"
trickles-server_1.c:23788:          printk("slow start step TCPBase - %u seq - %u\n", (*cont)->TCPBase,
trickles-server_1.c:23789:                 (*cont)->packets[0].seq);
trickles-server_1.c:23814:        if (!(newPmsk->refCnt == 1)) { printk("KERNEL: assertion (" "newPmsk->refCnt == 1" ") failed at " "trickles-server.c" "(%d)\n", 1982); };
trickles-server_1.c:23817:                        newPmsk->ctl = ALLOC_PENDING;
trickles-server_1.c:23819:                if (!(newPmsk->ctl == ALLOC_PENDING)) { printk("KERNEL: assertion (" "newPmsk->ctl == ALLOC_PENDING" ") failed at " "trickles-server.c" "(%d)\n", 1987); };
trickles-server_1.c:23822:                ({ (newPmsk)->seq = ((pmsk)->packets[packet_number].seq); (newPmsk)->continuationType = (pmsk)->packets[packet_number].contType; if((pmsk)->packets[packet_number].type & (0x80)) { (newPmsk)->firstChild = 1; } else { (newPmsk)->firstChild = 0; } static const int stateConversionMap[] = { 0, 1, 2 }; int conversionOffset = (pmsk)->packets[packet_number].type & (0x3); if(conversionOffset >= (3)) { do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } (newPmsk)->state = stateConversionMap[conversionOffset]; });
trickles-server_1.c:23826:                newPmsk->rawTimestamp = htonl(msk->timestamp);
trickles-server_1.c:23827:                newPmsk->rawMrtt = htonl(msk->mrtt);
trickles-server_1.c:23828:                newPmsk->num_packets = 0;
trickles-server_1.c:23838:                        if (!(newPmsk->refCnt == 1)) { printk("KERNEL: assertion (" "newPmsk->refCnt == 1" ") failed at " "trickles-server.c" "(%d)\n", 2006); };
trickles-server_1.c:23843:                        if (!(newPmsk->refCnt == 0)) { printk("KERNEL: assertion (" "newPmsk->refCnt == 0" ") failed at " "trickles-server.c" "(%d)\n", 2011); };
trickles-server_2.c:518:  char _f[20 - 2 * sizeof (long) - sizeof (int)];
trickles-server_2.c:847:  size = (size - 1) >> (12 - 1);
trickles-server_2.c:848:  order = -1;
trickles-server_2.c:1123:  return ((unsigned long *) t->esp)[3];
trickles-server_2.c:1206:  next->prev = new;
trickles-server_2.c:1207:  new->next = next;
trickles-server_2.c:1208:  new->prev = prev;
trickles-server_2.c:1209:  prev->next = new;
trickles-server_2.c:1216:  __list_add (new, head, head->next);
trickles-server_2.c:1223:  __list_add (new, head->prev, head);
trickles-server_2.c:1230:  next->prev = prev;
trickles-server_2.c:1231:  prev->next = next;
trickles-server_2.c:1242:  __list_del (entry->prev, entry->next);
trickles-server_2.c:1243:  entry->next = (void *) 0;
trickles-server_2.c:1244:  entry->prev = (void *) 0;
trickles-server_2.c:1254:  __list_del (entry->prev, entry->next);
trickles-server_2.c:1257:      (entry)->next = (entry);
trickles-server_2.c:1258:      (entry)->prev = (entry);
trickles-server_2.c:1271:  __list_del (list->prev, list->next);
trickles-server_2.c:1283:  __list_del (list->prev, list->next);
trickles-server_2.c:1294:  return head->next == head;
trickles-server_2.c:1300:  struct list_head *first = list->next;
trickles-server_2.c:1301:  struct list_head *last = list->prev;
trickles-server_2.c:1302:  struct list_head *at = head->next;
trickles-server_2.c:1304:  first->prev = head;
trickles-server_2.c:1305:  head->next = first;
trickles-server_2.c:1307:  last->next = at;
trickles-server_2.c:1308:  at->prev = last;
trickles-server_2.c:1332:	  (list)->next = (list);
trickles-server_2.c:1333:	  (list)->prev = (list);
trickles-server_2.c:1567:  __asm__ __volatile__ ("movl $-1,%%eax\n\t"
trickles-server_2.c:1571:			"xorl -4(%%edi),%%eax\n\t"
trickles-server_2.c:1602:      if (set < (32 - bit))
trickles-server_2.c:1604:      set = 32 - bit;
trickles-server_2.c:1610:  res = find_first_zero_bit (p, size - 32 * (p - (unsigned long *) addr));
trickles-server_2.c:1633:__asm__ ("bsfl %1,%0\n\t" "jnz 1f\n\t" "movl $-1,%0\n" "1:": "=r" (r):"rm" (x));
trickles-server_2.c:1798:  q->lock = (spinlock_t)
trickles-server_2.c:1803:      (&q->task_list)->next = (&q->task_list);
trickles-server_2.c:1804:      (&q->task_list)->prev = (&q->task_list);
trickles-server_2.c:1820:  q->flags = 0;
trickles-server_2.c:1821:  q->task = p;
trickles-server_2.c:1836:  return !list_empty (&q->task_list);
trickles-server_2.c:1843:  list_add (&new->task_list, &head->task_list);
trickles-server_2.c:1853:  list_add_tail (&new->task_list, &head->task_list);
trickles-server_2.c:1864:  list_del (&old->task_list);
trickles-server_2.c:1908:  char __data[128 - sizeof (unsigned short)];
trickles-server_2.c:1983:			(((__cmsg->cmsg_len) + sizeof (long) -
trickles-server_2.c:1984:			  1) & ~(sizeof (long) - 1)));
trickles-server_2.c:1985:  if ((unsigned long) ((char *) (__ptr + 1) - (char *) __ctl) > __size)
trickles-server_2.c:1994:  return __cmsg_nxthdr (__msg->msg_control, __msg->msg_controllen, __cmsg);
trickles-server_2.c:2141:    ((unsigned int) ((dev) & ((1U << 8) - 1)));
trickles-server_2.c:2180:  __asm__ __volatile__ ("" "addl %1,%0":"=m" (v->counter):"ir" (i),
trickles-server_2.c:2181:			"m" (v->counter));
trickles-server_2.c:2188:  __asm__ __volatile__ ("" "subl %1,%0":"=m" (v->counter):"ir" (i),
trickles-server_2.c:2189:			"m" (v->counter));
trickles-server_2.c:2198:  __asm__ __volatile__ ("" "subl %2,%0; sete %1":"=m" (v->counter),
trickles-server_2.c:2199:			"=qm" (c):"ir" (i), "m" (v->counter):"memory");
trickles-server_2.c:2207:  __asm__ __volatile__ ("" "incl %0":"=m" (v->counter):"m" (v->counter));
trickles-server_2.c:2214:  __asm__ __volatile__ ("" "decl %0":"=m" (v->counter):"m" (v->counter));
trickles-server_2.c:2223:  __asm__ __volatile__ ("" "decl %0; sete %1":"=m" (v->counter),
trickles-server_2.c:2224:			"=qm" (c):"m" (v->counter):"memory");
trickles-server_2.c:2234:  __asm__ __volatile__ ("" "incl %0; sete %1":"=m" (v->counter),
trickles-server_2.c:2235:			"=qm" (c):"m" (v->counter):"memory");
trickles-server_2.c:2245:  __asm__ __volatile__ ("" "addl %2,%0; sets %1":"=m" (v->counter),
trickles-server_2.c:2246:			"=qm" (c):"ir" (i), "m" (v->counter):"memory");
trickles-server_2.c:2436:    atomic_inc (&mnt->mnt_count);
trickles-server_2.c:2447:      if (atomic_dec_and_test (&mnt->mnt_count))
trickles-server_2.c:2494:  while (len--)
trickles-server_2.c:2538:  list_del (&dentry->d_hash);
trickles-server_2.c:2541:      (&dentry->d_hash)->next = (&dentry->d_hash);
trickles-server_2.c:2542:      (&dentry->d_hash)->prev = (&dentry->d_hash);
trickles-server_2.c:2554:  return d->d_name.name != d->d_iname;
trickles-server_2.c:2623:      if (!((&dentry->d_count)->counter))
trickles-server_2.c:2625:      atomic_inc (&dentry->d_count);
trickles-server_2.c:2635:  return list_empty (&dentry->d_hash);
trickles-server_2.c:2643:  return dentry->d_mounted;
trickles-server_2.c:2892:			"leal -1(%%esi),%0\n"
trickles-server_2.c:3021:__asm__ __volatile__ ("std\n\t" "rep\n\t" "movsb\n\t" "cld": "=&c" (d0), "=&S" (d1), "=&D" (d2): "0" (n), "1" (n - 1 + (const char *) src), "2" (n - 1 + (char *) dest):"memory");
trickles-server_2.c:3084:			"cmpl $-1,%1\n\t"
trickles-server_2.c:3234:  sem->count = 0x00000000;
trickles-server_2.c:3241:      (&sem->wait_list)->next = (&sem->wait_list);
trickles-server_2.c:3242:      (&sem->wait_list)->prev = (&sem->wait_list);
trickles-server_2.c:3267:			"# ending down_read\n\t":"+m" (sem->
trickles-server_2.c:3288:			"# ending __down_read_trylock\n\t":"+m" (sem->
trickles-server_2.c:3303:  tmp = ((-0x00010000) + 0x00000001);
trickles-server_2.c:3315:			"+m" (sem->count):"a" (sem):"memory", "cc");
trickles-server_2.c:3325:    ((__typeof__ (*(&sem->count)))
trickles-server_2.c:3326:     __cmpxchg ((&sem->count), (unsigned long) (0x00000000),
trickles-server_2.c:3327:		(unsigned long) (((-0x00010000) + 0x00000001)),
trickles-server_2.c:3328:		sizeof (*(&sem->count))));
trickles-server_2.c:3342:  __s32 tmp = -0x00000001;
trickles-server_2.c:3353:			"# ending __up_read\n":"+m" (sem->count),
trickles-server_2.c:3374:			"# ending __up_write\n":"+m" (sem->count):"a" (sem),
trickles-server_2.c:3375:			"i" (-((-0x00010000) + 0x00000001)):"memory", "cc",
trickles-server_2.c:3385:  __asm__ __volatile__ ("" "addl %1,%0":"=m" (sem->count):"ir" (delta),
trickles-server_2.c:3386:			"m" (sem->count));
trickles-server_2.c:3398:			"=m" (sem->count):"r" (sem),
trickles-server_2.c:3399:			"m" (sem->count):"memory");
trickles-server_2.c:3494:  (((&sem->count)->counter) = (val));
trickles-server_2.c:3495:  sem->sleepers = 0;
trickles-server_2.c:3496:  init_waitqueue_head (&sem->wait);
trickles-server_2.c:3550:			".previous\n\t":"=m" (sem->count):"c" (sem):"memory");
trickles-server_2.c:3576:			"=m" (sem->count):"c" (sem):"memory");
trickles-server_2.c:3602:			"=m" (sem->count):"c" (sem):"memory");
trickles-server_2.c:3625:			".previous\n\t" ".subsection 0\n":"=m" (sem->
trickles-server_2.c:3633:  return ((&sem->count)->counter);
trickles-server_2.c:4299:  unsigned long sec = value->tv_sec;
trickles-server_2.c:4300:  long nsec = value->tv_nsec;
trickles-server_2.c:4302:  if (sec >= (((~0UL >> 1) - 1) / 100))
trickles-server_2.c:4303:    return ((~0UL >> 1) - 1);
trickles-server_2.c:4304:  nsec += 1000000000L / 100 - 1;
trickles-server_2.c:4312:  value->tv_nsec = (jiffies % 100) * (1000000000L / 100);
trickles-server_2.c:4313:  value->tv_sec = jiffies / 100;
trickles-server_2.c:4322:  if (0 >= (int) (mon -= 2))
trickles-server_2.c:4325:      year -= 1;
trickles-server_2.c:4328:  return ((((unsigned long) (year / 4 - year / 100 + year / 400 +
trickles-server_2.c:4329:			     367 * mon / 12 + day) + year * 365 -
trickles-server_2.c:4517:  if (fid->Vnode == 0xfffffffe || fid->Vnode == 0xffffffff)
trickles-server_2.c:4518:    return ((fid->Volume << 20) | (fid->Unique & 0xfffff));
trickles-server_2.c:4520:    return (fid->Unique + (fid->Vnode << 10) + (fid->Volume << 20));
trickles-server_2.c:5620:  info->dqi_flags |= 0x10000;
trickles-server_2.c:5732:      return dqopt->flags & 0x01;
trickles-server_2.c:5734:      return dqopt->flags & 0x02;
trickles-server_2.c:5907:  inode->i_blocks += bytes >> 9;
trickles-server_2.c:5909:  inode->i_bytes += bytes;
trickles-server_2.c:5910:  if (inode->i_bytes >= 512)
trickles-server_2.c:5912:      inode->i_blocks++;
trickles-server_2.c:5913:      inode->i_bytes -= 512;
trickles-server_2.c:5920:  inode->i_blocks -= bytes >> 9;
trickles-server_2.c:5922:  if (inode->i_bytes < bytes)
trickles-server_2.c:5924:      inode->i_blocks--;
trickles-server_2.c:5925:      inode->i_bytes += 512;
trickles-server_2.c:5927:  inode->i_bytes -= bytes;
trickles-server_2.c:5933:  return (((loff_t) inode->i_blocks) << 9) + inode->i_bytes;
trickles-server_2.c:5939:  inode->i_blocks = bytes >> 9;
trickles-server_2.c:5940:  inode->i_bytes = bytes & 511;
trickles-server_2.c:6171:  timer->list.next = timer->list.prev = ((void *) 0);
trickles-server_2.c:6177:  return timer->list.next != ((void *) 0);
trickles-server_2.c:7079:  __s8 fs_fsmnt[512 - 212];
trickles-server_2.c:7331:  down (&(server->sem));
trickles-server_2.c:7337:  up (&(server->sem));
trickles-server_2.c:7535:  if (!test_and_set_bit (0, &bh_pointer->sync))
trickles-server_2.c:7549:      list_add_tail (&bh_pointer->list, bh_list);
trickles-server_2.c:8155:  return ((server->conn_status & 0x11) == 0);
trickles-server_2.c:8161:  server->conn_status |= 0x01;
trickles-server_2.c:8207:  x->done = 0;
trickles-server_2.c:8208:  init_waitqueue_head (&x->wait);
trickles-server_2.c:8515:  if ((((inode)->i_sb->s_flags & (64))
trickles-server_2.c:8516:       && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
trickles-server_2.c:8525:  if (inode->i_flock
trickles-server_2.c:8526:      && (((inode)->i_sb->s_flags & (64))
trickles-server_2.c:8527:	  && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
trickles-server_2.c:8535:  if (inode->i_flock
trickles-server_2.c:8536:      && (((inode)->i_sb->s_flags & (64))
trickles-server_2.c:8537:	  && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
trickles-server_2.c:8539:				 size < inode->i_size ? size : inode->i_size,
trickles-server_2.c:8541:				  inode->i_size ? inode->i_size -
trickles-server_2.c:8542:				  size : size - inode->i_size));
trickles-server_2.c:8549:  if (inode->i_flock)
trickles-server_2.c:8636:  atomic_inc (&(bh)->b_count);
trickles-server_2.c:8643:  atomic_dec (&bh->b_count);
trickles-server_2.c:8653:    set_bit (BH_Uptodate, &bh->b_state);
trickles-server_2.c:8655:    clear_bit (BH_Uptodate, &bh->b_state);
trickles-server_2.c:8669:  if (test_and_clear_bit (BH_Dirty, &(bh)->b_state))
trickles-server_2.c:8686:  buffer_insert_list (bh, &inode->i_dirty_buffers);
trickles-server_2.c:8692:  buffer_insert_list (bh, &inode->i_dirty_data_buffers);
trickles-server_2.c:8698:  return test_and_set_bit (BH_Dirty, &bh->b_state);
trickles-server_2.c:8705:    set_bit (BH_Async, &bh->b_state);
trickles-server_2.c:8707:    clear_bit (BH_Async, &bh->b_state);
trickles-server_2.c:8713:  set_bit (BH_Attached, &bh->b_state);
trickles-server_2.c:8719:  clear_bit (BH_Attached, &bh->b_state);
trickles-server_2.c:8727:			     (&bh->
trickles-server_2.c:8729:							     (&bh->b_state)));
trickles-server_2.c:8745:  bh->b_end_io (bh, 0);
trickles-server_2.c:8781:  return fsync_buffers_list (&inode->i_dirty_buffers);
trickles-server_2.c:8786:  return fsync_buffers_list (&inode->i_dirty_data_buffers);
trickles-server_2.c:8803:  atomic_dec (&inode->i_writecount);
trickles-server_2.c:8809:    atomic_inc (&file->f_dentry->d_inode->i_writecount);
trickles-server_2.c:8837:  return (unsigned long) ptr > (unsigned long) -1000L;
trickles-server_2.c:8897:  if (inode && (inode->i_state & 64))
trickles-server_2.c:8902:      if (sb->s_op->read_inode2)
trickles-server_2.c:8903:	sb->s_op->read_inode2 (inode, opaque);
trickles-server_2.c:8905:	sb->s_op->read_inode (inode);
trickles-server_2.c:8917:  if (inode && (inode->i_state & 64))
trickles-server_2.c:8919:      sb->s_op->read_inode (inode);
trickles-server_2.c:8966:  return bread (sb->s_dev, block, sb->s_blocksize);
trickles-server_2.c:8971:  return getblk (sb->s_dev, block, sb->s_blocksize);
trickles-server_2.c:8976:  return get_hash_table (sb->s_dev, block, sb->s_blocksize);
trickles-server_2.c:9101:  struct dentry *dir = dget (dentry->d_parent);
trickles-server_2.c:9103:  down (&dir->d_inode->i_sem);
trickles-server_2.c:9110:  return dget (dentry->d_parent);
trickles-server_2.c:9116:  up (&dir->d_inode->i_sem);
trickles-server_2.c:9208:  double_down (&d1->d_inode->i_sem, &d2->d_inode->i_sem);
trickles-server_2.c:9214:  double_up (&d1->d_inode->i_sem, &d2->d_inode->i_sem);
trickles-server_2.c:9461:  node->rb_parent = parent;
trickles-server_2.c:9462:  node->rb_color = 0;
trickles-server_2.c:9463:  node->rb_left = node->rb_right = ((void *) 0);
trickles-server_2.c:10097:__asm__ ("btsl %1,%0": "=m" (*set): "Ir" (_sig - 1):"cc");
trickles-server_2.c:10103:__asm__ ("btrl %1,%0": "=m" (*set): "Ir" (_sig - 1):"cc");
trickles-server_2.c:10109:  unsigned long sig = _sig - 1;
trickles-server_2.c:10110:  return 1 & (set->sig[sig / 32] >> (sig % 32));
trickles-server_2.c:10117:__asm__ ("btl %2,%1\n\tsbbl %0,%0": "=r" (ret): "m" (*set), "Ir" (_sig - 1):"cc");
trickles-server_2.c:10155:    int _pad[((128 / sizeof (int)) - 3)];
trickles-server_2.c:10211:    int _pad[((64 / sizeof (int)) - 3)];
trickles-server_2.c:10230:  if (from->si_code < 0)
trickles-server_2.c:10240:      sizeof (from->_sifields._sigchld)) ? __constant_memcpy ((to), (from),
trickles-server_2.c:10243:							       sizeof (from->
trickles-server_2.c:10247:		 (3 * sizeof (int) + sizeof (from->_sifields._sigchld))));
trickles-server_2.c:10277:      a0 = a->sig[4 * i + 0];
trickles-server_2.c:10278:      a1 = a->sig[4 * i + 1];
trickles-server_2.c:10279:      a2 = a->sig[4 * i + 2];
trickles-server_2.c:10280:      a3 = a->sig[4 * i + 3];
trickles-server_2.c:10281:      b0 = b->sig[4 * i + 0];
trickles-server_2.c:10282:      b1 = b->sig[4 * i + 1];
trickles-server_2.c:10283:      b2 = b->sig[4 * i + 2];
trickles-server_2.c:10284:      b3 = b->sig[4 * i + 3];
trickles-server_2.c:10285:      r->sig[4 * i + 0] = ((a0) | (b0));
trickles-server_2.c:10286:      r->sig[4 * i + 1] = ((a1) | (b1));
trickles-server_2.c:10287:      r->sig[4 * i + 2] = ((a2) | (b2));
trickles-server_2.c:10288:      r->sig[4 * i + 3] = ((a3) | (b3));
trickles-server_2.c:10293:      a0 = a->sig[4 * i + 0];
trickles-server_2.c:10294:      a1 = a->sig[4 * i + 1];
trickles-server_2.c:10295:      a2 = a->sig[4 * i + 2];
trickles-server_2.c:10296:      b0 = b->sig[4 * i + 0];
trickles-server_2.c:10297:      b1 = b->sig[4 * i + 1];
trickles-server_2.c:10298:      b2 = b->sig[4 * i + 2];
trickles-server_2.c:10299:      r->sig[4 * i + 0] = ((a0) | (b0));
trickles-server_2.c:10300:      r->sig[4 * i + 1] = ((a1) | (b1));
trickles-server_2.c:10301:      r->sig[4 * i + 2] = ((a2) | (b2));
trickles-server_2.c:10304:      a0 = a->sig[4 * i + 0];
trickles-server_2.c:10305:      a1 = a->sig[4 * i + 1];
trickles-server_2.c:10306:      b0 = b->sig[4 * i + 0];
trickles-server_2.c:10307:      b1 = b->sig[4 * i + 1];
trickles-server_2.c:10308:      r->sig[4 * i + 0] = ((a0) | (b0));
trickles-server_2.c:10309:      r->sig[4 * i + 1] = ((a1) | (b1));
trickles-server_2.c:10312:      a0 = a->sig[4 * i + 0];
trickles-server_2.c:10313:      b0 = b->sig[4 * i + 0];
trickles-server_2.c:10314:      r->sig[4 * i + 0] = ((a0) | (b0));
trickles-server_2.c:10327:      a0 = a->sig[4 * i + 0];
trickles-server_2.c:10328:      a1 = a->sig[4 * i + 1];
trickles-server_2.c:10329:      a2 = a->sig[4 * i + 2];
trickles-server_2.c:10330:      a3 = a->sig[4 * i + 3];
trickles-server_2.c:10331:      b0 = b->sig[4 * i + 0];
trickles-server_2.c:10332:      b1 = b->sig[4 * i + 1];
trickles-server_2.c:10333:      b2 = b->sig[4 * i + 2];
trickles-server_2.c:10334:      b3 = b->sig[4 * i + 3];
trickles-server_2.c:10335:      r->sig[4 * i + 0] = ((a0) & (b0));
trickles-server_2.c:10336:      r->sig[4 * i + 1] = ((a1) & (b1));
trickles-server_2.c:10337:      r->sig[4 * i + 2] = ((a2) & (b2));
trickles-server_2.c:10338:      r->sig[4 * i + 3] = ((a3) & (b3));
trickles-server_2.c:10343:      a0 = a->sig[4 * i + 0];
trickles-server_2.c:10344:      a1 = a->sig[4 * i + 1];
trickles-server_2.c:10345:      a2 = a->sig[4 * i + 2];
trickles-server_2.c:10346:      b0 = b->sig[4 * i + 0];
trickles-server_2.c:10347:      b1 = b->sig[4 * i + 1];
trickles-server_2.c:10348:      b2 = b->sig[4 * i + 2];
trickles-server_2.c:10349:      r->sig[4 * i + 0] = ((a0) & (b0));
trickles-server_2.c:10350:      r->sig[4 * i + 1] = ((a1) & (b1));
trickles-server_2.c:10351:      r->sig[4 * i + 2] = ((a2) & (b2));
trickles-server_2.c:10354:      a0 = a->sig[4 * i + 0];
trickles-server_2.c:10355:      a1 = a->sig[4 * i + 1];
trickles-server_2.c:10356:      b0 = b->sig[4 * i + 0];
trickles-server_2.c:10357:      b1 = b->sig[4 * i + 1];
trickles-server_2.c:10358:      r->sig[4 * i + 0] = ((a0) & (b0));
trickles-server_2.c:10359:      r->sig[4 * i + 1] = ((a1) & (b1));
trickles-server_2.c:10362:      a0 = a->sig[4 * i + 0];
trickles-server_2.c:10363:      b0 = b->sig[4 * i + 0];
trickles-server_2.c:10364:      r->sig[4 * i + 0] = ((a0) & (b0));
trickles-server_2.c:10377:      a0 = a->sig[4 * i + 0];
trickles-server_2.c:10378:      a1 = a->sig[4 * i + 1];
trickles-server_2.c:10379:      a2 = a->sig[4 * i + 2];
trickles-server_2.c:10380:      a3 = a->sig[4 * i + 3];
trickles-server_2.c:10381:      b0 = b->sig[4 * i + 0];
trickles-server_2.c:10382:      b1 = b->sig[4 * i + 1];
trickles-server_2.c:10383:      b2 = b->sig[4 * i + 2];
trickles-server_2.c:10384:      b3 = b->sig[4 * i + 3];
trickles-server_2.c:10385:      r->sig[4 * i + 0] = ((a0) & ~(b0));
trickles-server_2.c:10386:      r->sig[4 * i + 1] = ((a1) & ~(b1));
trickles-server_2.c:10387:      r->sig[4 * i + 2] = ((a2) & ~(b2));
trickles-server_2.c:10388:      r->sig[4 * i + 3] = ((a3) & ~(b3));
trickles-server_2.c:10393:      a0 = a->sig[4 * i + 0];
trickles-server_2.c:10394:      a1 = a->sig[4 * i + 1];
trickles-server_2.c:10395:      a2 = a->sig[4 * i + 2];
trickles-server_2.c:10396:      b0 = b->sig[4 * i + 0];
trickles-server_2.c:10397:      b1 = b->sig[4 * i + 1];
trickles-server_2.c:10398:      b2 = b->sig[4 * i + 2];
trickles-server_2.c:10399:      r->sig[4 * i + 0] = ((a0) & ~(b0));
trickles-server_2.c:10400:      r->sig[4 * i + 1] = ((a1) & ~(b1));
trickles-server_2.c:10401:      r->sig[4 * i + 2] = ((a2) & ~(b2));
trickles-server_2.c:10404:      a0 = a->sig[4 * i + 0];
trickles-server_2.c:10405:      a1 = a->sig[4 * i + 1];
trickles-server_2.c:10406:      b0 = b->sig[4 * i + 0];
trickles-server_2.c:10407:      b1 = b->sig[4 * i + 1];
trickles-server_2.c:10408:      r->sig[4 * i + 0] = ((a0) & ~(b0));
trickles-server_2.c:10409:      r->sig[4 * i + 1] = ((a1) & ~(b1));
trickles-server_2.c:10412:      a0 = a->sig[4 * i + 0];
trickles-server_2.c:10413:      b0 = b->sig[4 * i + 0];
trickles-server_2.c:10414:      r->sig[4 * i + 0] = ((a0) & ~(b0));
trickles-server_2.c:10426:      set->sig[4 * i + 0] = (~(set->sig[4 * i + 0]));
trickles-server_2.c:10427:      set->sig[4 * i + 1] = (~(set->sig[4 * i + 1]));
trickles-server_2.c:10428:      set->sig[4 * i + 2] = (~(set->sig[4 * i + 2]));
trickles-server_2.c:10429:      set->sig[4 * i + 3] = (~(set->sig[4 * i + 3]));
trickles-server_2.c:10434:      set->sig[4 * i + 2] = (~(set->sig[4 * i + 2]));
trickles-server_2.c:10436:      set->sig[4 * i + 1] = (~(set->sig[4 * i + 1]));
trickles-server_2.c:10438:      set->sig[4 * i + 0] = (~(set->sig[4 * i + 0]));
trickles-server_2.c:10466:      set->sig[1] = 0;
trickles-server_2.c:10468:      set->sig[0] = 0;
trickles-server_2.c:10479:      (__builtin_constant_p (-1)
trickles-server_2.c:10483:					   (unsigned char) (-1))),
trickles-server_2.c:10486:			       ((0x01010101UL * (unsigned char) (-1))),
trickles-server_2.c:10489:	  __memset_generic ((((set))), (((-1))),
trickles-server_2.c:10491:	  __memset_generic (((set)), ((-1)), ((sizeof (sigset_t))))));
trickles-server_2.c:10494:      set->sig[1] = -1;
trickles-server_2.c:10496:      set->sig[0] = -1;
trickles-server_2.c:10508:  set->sig[0] |= mask;
trickles-server_2.c:10514:  set->sig[0] &= ~mask;
trickles-server_2.c:10520:  return (set->sig[0] & mask) != 0;
trickles-server_2.c:10526:  set->sig[0] = mask;
trickles-server_2.c:10531:       ? (__builtin_constant_p ((sizeof (long) * ((64 / 32) - 1))) ?
trickles-server_2.c:10532:	  __constant_c_and_count_memset (((&set->sig[1])),
trickles-server_2.c:10536:					   ((64 / 32) -
trickles-server_2.c:10538:	  __constant_c_memset (((&set->sig[1])),
trickles-server_2.c:10541:				 ((64 / 32) -
trickles-server_2.c:10543:       : (__builtin_constant_p ((sizeof (long) * ((64 / 32) - 1))) ?
trickles-server_2.c:10544:	  __memset_generic ((((&set->sig[1]))), (((0))),
trickles-server_2.c:10546:			       ((64 / 32) -
trickles-server_2.c:10547:				1))))) : __memset_generic (((&set->sig[1])),
trickles-server_2.c:10550:							     ((64 / 32) -
trickles-server_2.c:10554:      set->sig[1] = 0;
trickles-server_2.c:10562:  set->sig[0] = ~mask;
trickles-server_2.c:10566:      (__builtin_constant_p (-1)
trickles-server_2.c:10567:       ? (__builtin_constant_p ((sizeof (long) * ((64 / 32) - 1))) ?
trickles-server_2.c:10568:	  __constant_c_and_count_memset (((&set->sig[1])),
trickles-server_2.c:10570:					   (unsigned char) (-1))),
trickles-server_2.c:10572:					   ((64 / 32) -
trickles-server_2.c:10574:	  __constant_c_memset (((&set->sig[1])),
trickles-server_2.c:10575:			       ((0x01010101UL * (unsigned char) (-1))),
trickles-server_2.c:10577:				 ((64 / 32) -
trickles-server_2.c:10579:       : (__builtin_constant_p ((sizeof (long) * ((64 / 32) - 1))) ?
trickles-server_2.c:10580:	  __memset_generic ((((&set->sig[1]))), (((-1))),
trickles-server_2.c:10582:			       ((64 / 32) -
trickles-server_2.c:10583:				1))))) : __memset_generic (((&set->sig[1])),
trickles-server_2.c:10584:							   ((-1)),
trickles-server_2.c:10586:							     ((64 / 32) -
trickles-server_2.c:10590:      set->sig[1] = -1;
trickles-server_2.c:10600:  sigemptyset (&sig->signal);
trickles-server_2.c:10601:  sig->head = ((void *) 0);
trickles-server_2.c:10602:  sig->tail = &sig->head;
trickles-server_2.c:10643:  (void) (&fs->lock);
trickles-server_2.c:10644:  old_root = fs->root;
trickles-server_2.c:10645:  old_rootmnt = fs->rootmnt;
trickles-server_2.c:10646:  fs->rootmnt = mntget (mnt);
trickles-server_2.c:10647:  fs->root = dget (dentry);
trickles-server_2.c:10669:  (void) (&fs->lock);
trickles-server_2.c:10670:  old_pwd = fs->pwd;
trickles-server_2.c:10671:  old_pwdmnt = fs->pwdmnt;
trickles-server_2.c:10672:  fs->pwdmnt = mntget (mnt);
trickles-server_2.c:10673:  fs->pwd = dget (dentry);
trickles-server_2.c:11183:    &pidhash[((((p->pid) >> 8) ^ (p->pid)) & ((4096 >> 2) - 1))];
trickles-server_2.c:11185:  if ((p->pidhash_next = *htable) != ((void *) 0))
trickles-server_2.c:11186:    (*htable)->pidhash_pprev = &p->pidhash_next;
trickles-server_2.c:11188:  p->pidhash_pprev = htable;
trickles-server_2.c:11194:  if (p->pidhash_next)
trickles-server_2.c:11195:    p->pidhash_next->pidhash_pprev = p->pidhash_pprev;
trickles-server_2.c:11196:  *p->pidhash_pprev = p->pidhash_next;
trickles-server_2.c:11203:    &pidhash[((((pid) >> 8) ^ (pid)) & ((4096 >> 2) - 1))];
trickles-server_2.c:11205:  for (p = *htable; p && p->pid != pid; p = p->pidhash_next)
trickles-server_2.c:11216:  tsk->processor = cpu;
trickles-server_2.c:11217:  tsk->cpus_runnable = 1UL << cpu;
trickles-server_2.c:11223:  tsk->cpus_runnable = ~0UL;
trickles-server_2.c:11333:  return (p->sigpending != 0);
trickles-server_2.c:11349:      for (i = (64 / 32), ready = 0; --i >= 0;)
trickles-server_2.c:11350:	ready |= signal->sig[i] & ~blocked->sig[i];
trickles-server_2.c:11354:      ready = signal->sig[3] & ~blocked->sig[3];
trickles-server_2.c:11355:      ready |= signal->sig[2] & ~blocked->sig[2];
trickles-server_2.c:11356:      ready |= signal->sig[1] & ~blocked->sig[1];
trickles-server_2.c:11357:      ready |= signal->sig[0] & ~blocked->sig[0];
trickles-server_2.c:11361:      ready = signal->sig[1] & ~blocked->sig[1];
trickles-server_2.c:11362:      ready |= signal->sig[0] & ~blocked->sig[0];
trickles-server_2.c:11366:      ready = signal->sig[0] & ~blocked->sig[0];
trickles-server_2.c:11378:  t->sigpending = has_pending_signals (&t->pending.signal, &t->blocked);
trickles-server_2.c:11386:  return (sp - get_current ()->sas_ss_sp < get_current ()->sas_ss_size);
trickles-server_2.c:11392:  return (get_current ()->sas_ss_size == 0 ? 2 : on_sig_stack (sp) ? 1 : 0);
trickles-server_2.c:11405:       securebits) && get_current ()->euid == 0)
trickles-server_2.c:11407:      get_current ()->flags |= 0x00000100;
trickles-server_2.c:11418:       securebits) && get_current ()->fsuid == 0)
trickles-server_2.c:11420:      get_current ()->flags |= 0x00000100;
trickles-server_2.c:11436:  if (((get_current ()->cap_effective) & (1 << (cap))))
trickles-server_2.c:11441:      get_current ()->flags |= 0x00000100;
trickles-server_2.c:11461:  if (atomic_dec_and_test (&mm->mm_count))
trickles-server_2.c:11511:  nr_running--;
trickles-server_2.c:11512:  p->sleep_time = jiffies;
trickles-server_2.c:11513:  list_del (&p->run_list);
trickles-server_2.c:11514:  p->run_list.next = ((void *) 0);
trickles-server_2.c:11520:  return (p->run_list.next != ((void *) 0));
trickles-server_2.c:11534:  nr_threads--;
trickles-server_2.c:11538:      (p)->next_task->prev_task = (p)->prev_task;
trickles-server_2.c:11539:      (p)->prev_task->next_task = (p)->next_task;
trickles-server_2.c:11540:      if ((p)->p_osptr)
trickles-server_2.c:11541:	(p)->p_osptr->p_ysptr = (p)->p_ysptr;
trickles-server_2.c:11542:      if ((p)->p_ysptr)
trickles-server_2.c:11543:	(p)->p_ysptr->p_osptr = (p)->p_osptr;
trickles-server_2.c:11545:	(p)->p_pptr->p_cptr = (p)->p_osptr;
trickles-server_2.c:11548:  list_del (&p->thread_group);
trickles-server_2.c:11564:  (void) (&p->alloc_lock);
trickles-server_2.c:11583:  (void) (&get_current ()->fs->lock);
trickles-server_2.c:11584:  rootmnt = mntget (get_current ()->fs->rootmnt);
trickles-server_2.c:11585:  root = dget (get_current ()->fs->root);
trickles-server_2.c:11604:  return (__builtin_expect ((get_current ()->need_resched), 0));
trickles-server_2.c:11741:  pg_data_t *pgdat = zone->zone_pgdat;
trickles-server_2.c:11743:  if (zone - pgdat->node_zones < 3 - 1)
trickles-server_2.c:11746:  else if (pgdat->node_next)
trickles-server_2.c:11748:      pgdat = pgdat->node_next;
trickles-server_2.c:11749:      zone = pgdat->node_zones;
trickles-server_2.c:11764:    char reserved[(1UL << 12) - 10];
trickles-server_2.c:11955:  return (new < 3) ? -1 : 0;
trickles-server_2.c:12280:  FIX_IO_APIC_BASE_END = FIX_IO_APIC_BASE_0 + 8 - 1,
trickles-server_2.c:12286:  FIX_BTMAP_BEGIN = FIX_BTMAP_END + 16 - 1,
trickles-server_2.c:12307:  return ((0xffffe000UL) - ((idx) << 12));
trickles-server_2.c:12465:  pte.pte_low &= ((~((1UL << 12) - 1)) | 0x020 | 0x040);
trickles-server_2.c:12555:  return zone_table[page->flags >> (32 - 8)];
trickles-server_2.c:12561:  page->flags &= ~(~0UL << (32 - 8));
trickles-server_2.c:12562:  page->flags |= zone_num << (32 - 8);
trickles-server_2.c:12706:  return ((&(page)->count)->counter) - !!page->buffers == 1;
trickles-server_2.c:12737:  unsigned long ret = -22;
trickles-server_2.c:12738:  if ((offset + (((len) + (1UL << 12) - 1) & (~((1UL << 12) - 1)))) < offset)
trickles-server_2.c:12740:  if (!(offset & ~(~((1UL << 12) - 1))))
trickles-server_2.c:12741:    ret = do_mmap_pgoff (get_current ()->mm, file, addr, len, prot, flag,
trickles-server_2.c:12755:  prev->vm_next = vma->vm_next;
trickles-server_2.c:12756:  rb_erase (&vma->vm_rb, &mm->mm_rb);
trickles-server_2.c:12757:  if (mm->mmap_cache == vma)
trickles-server_2.c:12758:    mm->mmap_cache = prev;
trickles-server_2.c:12764:  if (!vma->vm_file && vma->vm_flags == vm_flags)
trickles-server_2.c:12786:  if (get_current ()->flags & 0x00004000)
trickles-server_2.c:12804:  address &= (~((1UL << 12) - 1));
trickles-server_2.c:12805:  (void) (&vma->vm_mm->page_table_lock);
trickles-server_2.c:12806:  grow = (vma->vm_start - address) >> 12;
trickles-server_2.c:12807:  if (vma->vm_end - address > get_current ()->rlim[3].rlim_cur ||
trickles-server_2.c:12808:      ((vma->vm_mm->total_vm + grow) << 12) >
trickles-server_2.c:12809:      get_current ()->rlim[9].rlim_cur)
trickles-server_2.c:12815:      return -12;
trickles-server_2.c:12817:  vma->vm_start = address;
trickles-server_2.c:12818:  vma->vm_pgoff -= grow;
trickles-server_2.c:12819:  vma->vm_mm->total_vm += grow;
trickles-server_2.c:12820:  if (vma->vm_flags & 0x00002000)
trickles-server_2.c:12821:    vma->vm_mm->locked_vm += grow;
trickles-server_2.c:12844:  if (vma && end_addr <= vma->vm_start)
trickles-server_2.c:12900:       ((1024 -
trickles-server_2.c:12910:					     ((1024 -
trickles-server_2.c:12918:		 ((1024 -
trickles-server_2.c:12938:      (boot_cpu_data.pgtable_cache_sz)--;
trickles-server_2.c:12998:      (boot_cpu_data.pgtable_cache_sz)--;
trickles-server_2.c:13023:  if (mm == get_current ()->active_mm)
trickles-server_2.c:13037:  if (vma->vm_mm == get_current ()->active_mm)
trickles-server_2.c:13044:  if (mm == get_current ()->active_mm)
trickles-server_2.c:13076:		long) ((((page) - page_zone (page)->zone_mem_map) << 12) +
trickles-server_2.c:13077:		       page_zone (page)->zone_start_paddr) +
trickles-server_2.c:13415:  return (list->next == (struct sk_buff *) list);
trickles-server_2.c:13422:  atomic_inc (&skb->users);
trickles-server_2.c:13430:  if (((&skb->users)->counter) == 1 || atomic_dec_and_test (&skb->users))
trickles-server_2.c:13438:  if (((&skb->users)->counter) == 1 || atomic_dec_and_test (&skb->users))
trickles-server_2.c:13446:  return skb->cloned
trickles-server_2.c:13447:    && ((&((struct skb_shared_info *) ((skb)->end))->dataref)->counter) != 1;
trickles-server_2.c:13454:  return (((&skb->users)->counter) != 1);
trickles-server_2.c:13487:  struct sk_buff *list = ((struct sk_buff *) list_)->next;
trickles-server_2.c:13497:  struct sk_buff *list = ((struct sk_buff *) list_)->prev;
trickles-server_2.c:13507:  return (list_->qlen);
trickles-server_2.c:13517:  list->prev = (struct sk_buff *) list;
trickles-server_2.c:13518:  list->next = (struct sk_buff *) list;
trickles-server_2.c:13519:  list->qlen = 0;
trickles-server_2.c:13528:  newsk->list = list;
trickles-server_2.c:13529:  list->qlen++;
trickles-server_2.c:13531:  next = prev->next;
trickles-server_2.c:13532:  newsk->next = next;
trickles-server_2.c:13533:  newsk->prev = prev;
trickles-server_2.c:13534:  next->prev = newsk;
trickles-server_2.c:13535:  prev->next = newsk;
trickles-server_2.c:13552:      (void) (&list->lock);
trickles-server_2.c:13573:  newsk->list = list;
trickles-server_2.c:13574:  list->qlen++;
trickles-server_2.c:13576:  prev = next->prev;
trickles-server_2.c:13577:  newsk->next = next;
trickles-server_2.c:13578:  newsk->prev = prev;
trickles-server_2.c:13579:  next->prev = newsk;
trickles-server_2.c:13580:  prev->next = newsk;
trickles-server_2.c:13597:      (void) (&list->lock);
trickles-server_2.c:13619:  next = prev->next;
trickles-server_2.c:13624:      next = next->next;
trickles-server_2.c:13625:      list->qlen--;
trickles-server_2.c:13626:      next->prev = prev;
trickles-server_2.c:13627:      prev->next = next;
trickles-server_2.c:13628:      result->next = ((void *) 0);
trickles-server_2.c:13629:      result->prev = ((void *) 0);
trickles-server_2.c:13630:      result->list = ((void *) 0);
trickles-server_2.c:13650:      (void) (&list->lock);
trickles-server_2.c:13675:  newsk->next = next;
trickles-server_2.c:13676:  newsk->prev = prev;
trickles-server_2.c:13677:  next->prev = newsk;
trickles-server_2.c:13678:  prev->next = newsk;
trickles-server_2.c:13679:  newsk->list = list;
trickles-server_2.c:13680:  list->qlen++;
trickles-server_2.c:13697:      (void) (&old->list->lock);
trickles-server_2.c:13700:  __skb_insert (newsk, old->prev, old, old->list);
trickles-server_2.c:13719:  __skb_insert (newsk, old, old->next, old->list);
trickles-server_2.c:13736:      (void) (&old->list->lock);
trickles-server_2.c:13761:  list->qlen--;
trickles-server_2.c:13762:  next = skb->next;
trickles-server_2.c:13763:  prev = skb->prev;
trickles-server_2.c:13764:  skb->next = ((void *) 0);
trickles-server_2.c:13765:  skb->prev = ((void *) 0);
trickles-server_2.c:13766:  skb->list = ((void *) 0);
trickles-server_2.c:13767:  next->prev = prev;
trickles-server_2.c:13768:  prev->next = next;
trickles-server_2.c:13775:  struct sk_buff_head *list = skb->list;
trickles-server_2.c:13789:	  (void) (&list->lock);
trickles-server_2.c:13792:      if (skb->list == list)
trickles-server_2.c:13793:	__skb_unlink (skb, skb->list);
trickles-server_2.c:13832:      (void) (&list->lock);
trickles-server_2.c:13851:  return skb->data_len;
trickles-server_2.c:13857:  return skb->len - skb->data_len;
trickles-server_2.c:13864:  unsigned char *tmp = skb->tail;
trickles-server_2.c:13871:  skb->tail += len;
trickles-server_2.c:13872:  skb->len += len;
trickles-server_2.c:13880:  unsigned char *tmp = skb->tail;
trickles-server_2.c:13887:  skb->tail += len;
trickles-server_2.c:13888:  skb->len += len;
trickles-server_2.c:13889:  if (skb->tail > skb->end)
trickles-server_2.c:13904:  skb->data -= len;
trickles-server_2.c:13905:  skb->len += len;
trickles-server_2.c:13906:  return skb->data;
trickles-server_2.c:13913:  skb->data -= len;
trickles-server_2.c:13914:  skb->len += len;
trickles-server_2.c:13915:  if (skb->data < skb->head)
trickles-server_2.c:13924:  return skb->data;
trickles-server_2.c:13930:  skb->len -= len;
trickles-server_2.c:13931:  if (skb->len < skb->data_len)
trickles-server_2.c:13933:  return skb->data += len;
trickles-server_2.c:13940:  if (len > skb->len)
trickles-server_2.c:13951:      __pskb_pull_tail (skb, len - skb_headlen (skb)) == ((void *) 0))
trickles-server_2.c:13953:  skb->len -= len;
trickles-server_2.c:13954:  return skb->data += len;
trickles-server_2.c:13960:  if (len > skb->len)
trickles-server_2.c:13970:  if (len > skb->len)
trickles-server_2.c:13972:  return (__pskb_pull_tail (skb, len - skb_headlen (skb)) != ((void *) 0));
trickles-server_2.c:13979:  return skb->data - skb->head;
trickles-server_2.c:13986:  return skb_is_nonlinear (skb) ? 0 : skb->end - skb->tail;
trickles-server_2.c:13993:  skb->data += len;
trickles-server_2.c:13994:  skb->tail += len;
trickles-server_2.c:14002:  if (!skb->data_len)
trickles-server_2.c:14004:      skb->len = len;
trickles-server_2.c:14005:      skb->tail = skb->data + len;
trickles-server_2.c:14017:  if (skb->len > len)
trickles-server_2.c:14027:  if (!skb->data_len)
trickles-server_2.c:14029:      skb->len = len;
trickles-server_2.c:14030:      skb->tail = skb->data + len;
trickles-server_2.c:14042:  if (len < skb->len)
trickles-server_2.c:14051:  if (skb->destructor)
trickles-server_2.c:14052:    skb->destructor (skb);
trickles-server_2.c:14053:  skb->destructor = ((void *) 0);
trickles-server_2.c:14054:  skb->sk = ((void *) 0);
trickles-server_2.c:14101:  int delta = (headroom > 16 ? headroom : 16) - skb_headroom (skb);
trickles-server_2.c:14115:  unsigned int size = skb->len;
trickles-server_2.c:14118:  return skb_pad (skb, len - size);
trickles-server_2.c:14133:  return kmap (frag->page);
trickles-server_2.c:14184:  if (nfct && atomic_dec_and_test (&nfct->master->use))
trickles-server_2.c:14185:    nfct->master->destroy (nfct->master);
trickles-server_2.c:14191:    atomic_inc (&nfct->master->use);
trickles-server_2.c:14253:		 "g" (get_current ()->addr_limit.
trickles-server_2.c:14256:	    }) == 0) ? 0 : -14;
trickles-server_2.c:14354:unsigned long flag, sum; asm ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag), "=r" (sum):"1" (to), "g" ((int) (n)), "g" (get_current ()->addr_limit.seg));
trickles-server_2.c:14385:unsigned long flag, sum; asm ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag), "=r" (sum):"1" (from), "g" ((int) (n)), "g" (get_current ()->addr_limit.seg));
trickles-server_2.c:14502:  pt->error = 0;
trickles-server_2.c:14503:  pt->table = ((void *) 0);
trickles-server_2.c:14522:    ((((nr) + (8 * sizeof (long)) -
trickles-server_2.c:14533:	error = -14;
trickles-server_2.c:14550:     (((((nr) + (8 * sizeof (long)) -
trickles-server_2.c:14556:							      -
trickles-server_2.c:14562:				     (((((nr) + (8 * sizeof (long)) -
trickles-server_2.c:14572:      ((((((nr) + (8 * sizeof (long)) -
trickles-server_2.c:14581:								 (long)) -
trickles-server_2.c:14589:			   ((((((nr) + (8 * sizeof (long)) -
trickles-server_2.c:14593:      ((((((nr) + (8 * sizeof (long)) -
trickles-server_2.c:14597:						    (8 * sizeof (long)) -
trickles-server_2.c:14602:			((((((nr) + (8 * sizeof (long)) -
trickles-server_2.c:14722:  unsigned char __pad[16 - sizeof (short int) -
trickles-server_2.c:14723:		      sizeof (unsigned short int) - sizeof (struct in_addr)];
trickles-server_2.c:15250:  unsigned long hh_data[(((32) + (16 - 1)) & ~(16 - 1)) / sizeof (long)];
trickles-server_2.c:15596:  eip -= (unsigned long) &_stext;
trickles-server_2.c:15603:  if (eip > prof_len - 1)
trickles-server_2.c:15604:    eip = prof_len - 1;
trickles-server_2.c:15716:  if (!test_and_set_bit (TASKLET_STATE_SCHED, &t->state))
trickles-server_2.c:15726:  if (!test_and_set_bit (TASKLET_STATE_SCHED, &t->state))
trickles-server_2.c:15734:  atomic_inc (&t->count);
trickles-server_2.c:15753:  atomic_dec (&t->count);
trickles-server_2.c:15760:  atomic_dec (&t->count);
trickles-server_2.c:15869:  if (!test_and_set_bit (__LINK_STATE_SCHED, &dev->state))
trickles-server_2.c:15880:      dev->next_sched = softnet_data[cpu].output_queue;
trickles-server_2.c:15893:			  (&dev->
trickles-server_2.c:15895:							(&dev->state))))
trickles-server_2.c:15902:  clear_bit (__LINK_STATE_XOFF, &dev->state);
trickles-server_2.c:15908:  if (test_and_clear_bit (__LINK_STATE_XOFF, &dev->state))
trickles-server_2.c:15915:  set_bit (__LINK_STATE_XOFF, &dev->state);
trickles-server_2.c:15923:			     (&dev->
trickles-server_2.c:15925:	  variable_test_bit ((__LINK_STATE_XOFF), (&dev->state)));
trickles-server_2.c:15933:			     (&dev->
trickles-server_2.c:15935:	  variable_test_bit ((__LINK_STATE_START), (&dev->state)));
trickles-server_2.c:15945:  if (atomic_dec_and_test (&skb->users))
trickles-server_2.c:15956:      skb->next = softnet_data[cpu].completion_queue;
trickles-server_2.c:16011:  if (atomic_dec_and_test (&dev->refcnt))
trickles-server_2.c:16021:			      (&dev->
trickles-server_2.c:16023:	   variable_test_bit ((__LINK_STATE_NOCARRIER), (&dev->state)));
trickles-server_2.c:16031:  clear_bit (__LINK_STATE_NOCARRIER, &dev->state);
trickles-server_2.c:16039:  set_bit (__LINK_STATE_NOCARRIER, &dev->state);
trickles-server_2.c:16048:			     (&dev->
trickles-server_2.c:16050:	  variable_test_bit ((__LINK_STATE_PRESENT), (&dev->state)));
trickles-server_2.c:16056:  if (test_and_clear_bit (__LINK_STATE_PRESENT, &dev->state) &&
trickles-server_2.c:16066:  if (!test_and_set_bit (__LINK_STATE_PRESENT, &dev->state) &&
trickles-server_2.c:16102:    !test_and_set_bit (__LINK_STATE_RX_SCHED, &dev->state);
trickles-server_2.c:16121:  atomic_inc (&(dev)->refcnt);
trickles-server_2.c:16122:  list_add_tail (&dev->poll_list, &softnet_data[cpu].poll_list);
trickles-server_2.c:16123:  if (dev->quota < 0)
trickles-server_2.c:16124:    dev->quota += dev->weight;
trickles-server_2.c:16126:    dev->quota = dev->weight;
trickles-server_2.c:16156:      dev->quota += undo;
trickles-server_2.c:16164:      list_add_tail (&dev->poll_list, &softnet_data[cpu].poll_list);
trickles-server_2.c:16196:			  (&dev->
trickles-server_2.c:16198:       variable_test_bit ((__LINK_STATE_RX_SCHED), (&dev->state))))
trickles-server_2.c:16209:  list_del (&dev->poll_list);
trickles-server_2.c:16211:  clear_bit (__LINK_STATE_RX_SCHED, &dev->state);
trickles-server_2.c:16218:  while (test_and_set_bit (__LINK_STATE_RX_SCHED, &dev->state))
trickles-server_2.c:16221:      get_current ()->state = 1;
trickles-server_2.c:16229:  clear_bit (__LINK_STATE_RX_SCHED, &dev->state);
trickles-server_2.c:16241:			  (&dev->
trickles-server_2.c:16243:       variable_test_bit ((__LINK_STATE_RX_SCHED), (&dev->state))))
trickles-server_2.c:16254:  list_del (&dev->poll_list);
trickles-server_2.c:16256:  clear_bit (__LINK_STATE_RX_SCHED, &dev->state);
trickles-server_2.c:16270:      (void) (&dev->xmit_lock);
trickles-server_2.c:16284:	  if (!--*ptr)
trickles-server_2.c:16285:	    __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;"
trickles-server_2.c:16658:  return fp->len * sizeof (struct sock_filter) + sizeof (*fp);
trickles-server_2.c:16723:  unsigned char ha[(8 + sizeof (unsigned long) - 1) &
trickles-server_2.c:16724:		   ~(sizeof (unsigned long) - 1)];
trickles-server_2.c:16842:  if (atomic_dec_and_test (&neigh->refcnt))
trickles-server_2.c:16850:    atomic_inc (&neigh->refcnt);
trickles-server_2.c:16860:    neigh->confirmed = jiffies;
trickles-server_2.c:16866:  return neigh->nud_state & (0x80 | 0x40 | 0x02);
trickles-server_2.c:16872:  return neigh->nud_state & (0x80 | 0x40 | 0x02 | 0x10 | 0x04 | 0x08);
trickles-server_2.c:16878:  neigh->used = jiffies;
trickles-server_2.c:16879:  if (!(neigh->nud_state & ((0x80 | 0x40 | 0x02) | 0x08 | 0x10)))
trickles-server_2.c:16979:  atomic_inc (&dst->__refcnt);
trickles-server_2.c:16986:    atomic_inc (&dst->__refcnt);
trickles-server_2.c:16994:    atomic_dec (&dst->__refcnt);
trickles-server_2.c:17004:  if (dst->obsolete > 1)
trickles-server_2.c:17006:  if (!((&dst->__refcnt)->counter))
trickles-server_2.c:17018:    neigh_confirm (dst->neighbour);
trickles-server_2.c:17025:  if (dst && dst->ops->negative_advice)
trickles-server_2.c:17026:    *dst_p = dst->ops->negative_advice (dst);
trickles-server_2.c:17032:  struct dst_entry *dst = skb->dst;
trickles-server_2.c:17033:  if (dst && dst->ops && dst->ops->link_failure)
trickles-server_2.c:17034:    dst->ops->link_failure (skb);
trickles-server_2.c:17045:  if (dst->expires == 0 || (long) (dst->expires - expires) > 0)
trickles-server_2.c:17046:    dst->expires = expires;
trickles-server_2.c:17144:  head->next = head->prev = ((void *) 0);
trickles-server_2.c:17158:  for (elem = (typeof (elem)) (list)->next; (elem != (typeof (elem)) (list));
trickles-server_2.c:17159:       elem = (typeof (elem)) elem->next)
trickles-server_2.c:17174:  dlist->next = dlist->prev = (struct list_link *) dlist;
trickles-server_2.c:17180:  if (head->next == elem)
trickles-server_2.c:17194:  elem->next = head->next;
trickles-server_2.c:17195:  head->next->prev = elem;
trickles-server_2.c:17197:  elem->prev = (struct list_link *) head;
trickles-server_2.c:17198:  head->next = elem;
trickles-server_2.c:17204:  if (head->prev == elem)
trickles-server_2.c:17218:  elem->next = (struct list_link *) head;
trickles-server_2.c:17219:  elem->prev = head->prev;
trickles-server_2.c:17220:  head->prev->next = elem;
trickles-server_2.c:17221:  head->prev = elem;
trickles-server_2.c:17227:  if (head->prev == elem)
trickles-server_2.c:17241:  elem->next = (struct list_link *) head;
trickles-server_2.c:17242:  elem->prev = head->prev;
trickles-server_2.c:17244:  head->prev->next = elem;
trickles-server_2.c:17245:  head->prev = elem;
trickles-server_2.c:17251:  elem->next->prev = elem->prev;
trickles-server_2.c:17252:  elem->prev->next = elem->next;
trickles-server_2.c:17253:  elem->prev = elem->next = ((void *) 0);
trickles-server_2.c:17259:  return (struct dlist *) list->next == list;
trickles-server_2.c:17321:  vec->num = 0;
trickles-server_2.c:17322:  vec->size = initSize;
trickles-server_2.c:17323:  vec->elems = kmalloc (vec->size * sizeof (vec->elems[0]), (0x20));
trickles-server_2.c:17324:  if (vec->elems == ((void *) 0))
trickles-server_2.c:17334:  kfree (vec->elems);
trickles-server_2.c:17340:  if (vec->num == vec->size)
trickles-server_2.c:17343:      vec->size *= 2;
trickles-server_2.c:17344:      newElems = kmalloc (vec->size * sizeof (newElems[0]), (0x20));
trickles-server_2.c:17362:  vec->elems[vec->num++] = newElem;
trickles-server_2.c:17374:  return head->next == (struct alloc_head *) head;
trickles-server_2.c:17380:  head->next = head->prev = (struct alloc_head *) head;
trickles-server_2.c:17381:  head->list = head;
trickles-server_2.c:17382:  head->len = 0;
trickles-server_2.c:17394:  if (head->next == elem)
trickles-server_2.c:17408:  elem->next = head->next;
trickles-server_2.c:17409:  head->next->prev = elem;
trickles-server_2.c:17411:  elem->prev = (struct alloc_head *) head;
trickles-server_2.c:17412:  head->next = elem;
trickles-server_2.c:17414:  elem->list = head;
trickles-server_2.c:17415:  head->len++;
trickles-server_2.c:17426:  if (head->prev == elem)
trickles-server_2.c:17441:  elem->next = (struct alloc_head *) head;
trickles-server_2.c:17443:  elem->prev = head->prev;
trickles-server_2.c:17445:  head->prev->next = elem;
trickles-server_2.c:17447:  elem->list = head;
trickles-server_2.c:17448:  head->prev = elem;
trickles-server_2.c:17449:  head->len++;
trickles-server_2.c:17460:  if (head->prev == elem)
trickles-server_2.c:17475:  elem->next = (struct alloc_head *) head;
trickles-server_2.c:17476:  elem->prev = head->prev;
trickles-server_2.c:17480:  head->prev->next = elem;
trickles-server_2.c:17482:  elem->next = (struct alloc_head *) head;
trickles-server_2.c:17484:  elem->list = head;
trickles-server_2.c:17485:  head->prev = elem;
trickles-server_2.c:17486:  head->len++;
trickles-server_2.c:17498:  elem->next->prev = elem->prev;
trickles-server_2.c:17499:  elem->prev->next = elem->next;
trickles-server_2.c:17500:  elem->prev = elem->next = ((void *) 0);
trickles-server_2.c:17502:  elem->list->len--;
trickles-server_2.c:17503:  elem->list = ((void *) 0);
trickles-server_2.c:17511:  if (!(elem->next == ((void *) 0) && elem->prev == ((void *) 0)))
trickles-server_2.c:17522:  elem->next = prev->next;
trickles-server_2.c:17523:  prev->next = elem;
trickles-server_2.c:17525:  elem->prev = prev;
trickles-server_2.c:17526:  next->prev = elem;
trickles-server_2.c:17528:  elem->list = prev->list;
trickles-server_2.c:17529:  elem->list->len++;
trickles-server_2.c:17576:  pkt->nonce = -1;
trickles-server_2.c:17577:  pkt->seq = seq;
trickles-server_2.c:17579:  pkt->len = len;
trickles-server_2.c:17580:  pkt->type = type;
trickles-server_2.c:17581:  pkt->contType = contType;
trickles-server_2.c:17582:  pkt->minResponseLen = minResponseLen;
trickles-server_2.c:17583:  pkt->firstTransportChild = firstTransportChild;
trickles-server_2.c:17584:  pkt->numTransportChildren = numTransportChildren;
trickles-server_2.c:17585:  pkt->ucontLen = 0;
trickles-server_2.c:17586:  pkt->ucontData = ((void *) 0);
trickles-server_2.c:17587:  pkt->numSiblings = -1;
trickles-server_2.c:17588:  pkt->position = (0xff);
trickles-server_2.c:17595:  if (len > packet->len + packet->ucontLen)
trickles-server_2.c:17598:	      (int) len, packet->len, packet->ucontLen);
trickles-server_2.c:17601:  if (packet->ucontData)
trickles-server_2.c:17603:      kfree (packet->ucontData);
trickles-server_2.c:17604:      packet->len += packet->ucontLen;
trickles-server_2.c:17605:      packet->ucontLen = 0;
trickles-server_2.c:17607:  packet->ucontData = buf;
trickles-server_2.c:17608:  packet->ucontLen = len;
trickles-server_2.c:17609:  packet->len -= packet->ucontLen;
trickles-server_2.c:18037:  int size = ((len) + (((sizeof (struct nlmsghdr)) + 4 - 1) & ~(4 - 1)));
trickles-server_2.c:18039:  nlh = (struct nlmsghdr *) skb_put (skb, (((size) + 4 - 1) & ~(4 - 1)));
trickles-server_2.c:18040:  nlh->nlmsg_type = type;
trickles-server_2.c:18041:  nlh->nlmsg_len = size;
trickles-server_2.c:18042:  nlh->nlmsg_flags = 0;
trickles-server_2.c:18043:  nlh->nlmsg_pid = pid;
trickles-server_2.c:18044:  nlh->nlmsg_seq = seq;
trickles-server_2.c:18327:  return len > rta->rta_len
trickles-server_2.c:18330:				 ((((sizeof (struct rtattr)) + 4 - 1) & ~(4 -
trickles-server_2.c:18569:  printk ("PHChunk %p = { type = %d, chunkLen = %d, range=[%d-%d] }\n",
trickles-server_2.c:18570:	  phchunk, phchunk->type, ntohs (phchunk->chunkLen),
trickles-server_2.c:18571:	  ntohl (phchunk->start), ntohl (phchunk->end));
trickles-server_2.c:18617:  return (d->type == RCHUNK_DATA ||
trickles-server_2.c:18618:	  d->type == RCHUNK_SKIP || d->type == RCHUNK_FINHINT);
trickles-server_2.c:18631:  switch (d->type)
trickles-server_2.c:18634:      if (!((c1 = !(d->flags & ~0x1))))
trickles-server_2.c:18636:	  printk ("KERNEL: assertion (" "(c1 = !(d->flags & ~DCHUNK_FIN))"
trickles-server_2.c:18644:      if (!((c1 = (d->flags == 0))))
trickles-server_2.c:18646:	  printk ("KERNEL: assertion (" "(c1 = (d->flags == 0))"
trickles-server_2.c:19536:    u8 __pad[(1 << ((5))) - sizeof (int)];
trickles-server_2.c:19544:  prot->stats[0].inuse++;
trickles-server_2.c:19550:  prot->stats[0].inuse--;
trickles-server_2.c:19630:  if (sk->filter)
trickles-server_2.c:19635:	(void) (&((sk)->lock.slock));
trickles-server_2.c:19637:      filter = sk->filter;
trickles-server_2.c:19640:	  int pkt_len = sk_run_filter (skb, filter->insns,
trickles-server_2.c:19641:				       filter->len);
trickles-server_2.c:19643:	    err = -1;
trickles-server_2.c:19663:  atomic_sub (size, &sk->omem_alloc);
trickles-server_2.c:19665:  if (atomic_dec_and_test (&fp->refcnt))
trickles-server_2.c:19672:  atomic_inc (&fp->refcnt);
trickles-server_2.c:19673:  atomic_add (sk_filter_len (fp), &sk->omem_alloc);
trickles-server_2.c:19680:  atomic_inc (&sk->refcnt);
trickles-server_2.c:19689:  atomic_dec (&sk->refcnt);
trickles-server_2.c:19696:  if (atomic_dec_and_test (&sk->refcnt))
trickles-server_2.c:19712:      (void) (&sk->callback_lock);
trickles-server_2.c:19715:  sk->dead = 1;
trickles-server_2.c:19716:  sk->socket = ((void *) 0);
trickles-server_2.c:19717:  sk->sleep = ((void *) 0);
trickles-server_2.c:19728:	  if (!--*ptr)
trickles-server_2.c:19729:	    __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;"
trickles-server_2.c:19755:      (void) (&sk->callback_lock);
trickles-server_2.c:19758:  sk->sleep = &parent->wait;
trickles-server_2.c:19759:  parent->sk = sk;
trickles-server_2.c:19760:  sk->socket = parent;
trickles-server_2.c:19771:	  if (!--*ptr)
trickles-server_2.c:19772:	    __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;"
trickles-server_2.c:19792:  (void) (&sk->callback_lock);
trickles-server_2.c:19793:  uid = sk->socket ? sk->socket->inode->i_uid : 0;
trickles-server_2.c:19806:  (void) (&sk->callback_lock);
trickles-server_2.c:19807:  ino = sk->socket ? sk->socket->inode->i_ino : 0;
trickles-server_2.c:19818:  return sk->dst_cache;
trickles-server_2.c:19826:  (void) (&sk->dst_lock);
trickles-server_2.c:19827:  dst = sk->dst_cache;
trickles-server_2.c:19842:  old_dst = sk->dst_cache;
trickles-server_2.c:19843:  sk->dst_cache = dst;
trickles-server_2.c:19850:  (void) (&sk->dst_lock);
trickles-server_2.c:19863:  old_dst = sk->dst_cache;
trickles-server_2.c:19864:  sk->dst_cache = ((void *) 0);
trickles-server_2.c:19871:  (void) (&sk->dst_lock);
trickles-server_2.c:19882:  struct dst_entry *dst = sk->dst_cache;
trickles-server_2.c:19884:  if (dst && dst->obsolete && dst->ops->check (dst, cookie) == ((void *) 0))
trickles-server_2.c:19886:      sk->dst_cache = ((void *) 0);
trickles-server_2.c:19898:  if (dst && dst->obsolete && dst->ops->check (dst, cookie) == ((void *) 0))
trickles-server_2.c:19912:  skb->sk = sk;
trickles-server_2.c:19913:  skb->destructor = sock_wfree;
trickles-server_2.c:19914:  atomic_add (skb->truesize, &sk->wmem_alloc);
trickles-server_2.c:19920:  skb->sk = sk;
trickles-server_2.c:19921:  skb->destructor = sock_rfree;
trickles-server_2.c:19922:  atomic_add (skb->truesize, &sk->rmem_alloc);
trickles-server_2.c:19934:  if (((&sk->rmem_alloc)->counter) + skb->truesize >= (unsigned) sk->rcvbuf)
trickles-server_2.c:19936:      err = -12;
trickles-server_2.c:19948:  skb->dev = ((void *) 0);
trickles-server_2.c:19956:  skb_len = skb->len;
trickles-server_2.c:19958:  skb_queue_tail (&sk->receive_queue, skb);
trickles-server_2.c:19959:  if (!sk->dead)
trickles-server_2.c:19960:    sk->data_ready (sk, skb_len);
trickles-server_2.c:19971:  if (((&sk->rmem_alloc)->counter) + skb->truesize >= (unsigned) sk->rcvbuf)
trickles-server_2.c:19972:    return -12;
trickles-server_2.c:19974:  skb_queue_tail (&sk->error_queue, skb);
trickles-server_2.c:19975:  if (!sk->dead)
trickles-server_2.c:19976:    sk->data_ready (sk, skb->len);
trickles-server_2.c:19988:    ((__typeof__ (*(&sk->err)))
trickles-server_2.c:19989:     __xchg ((unsigned long) (0), (&sk->err), sizeof (*(&sk->err))));
trickles-server_2.c:19990:  return -err;
trickles-server_2.c:19998:  if (!(sk->shutdown & 2))
trickles-server_2.c:20000:      amt = sk->sndbuf - ((&sk->wmem_alloc)->counter);
trickles-server_2.c:20010:  if (sk->socket && sk->socket->fasync_list)
trickles-server_2.c:20011:    sock_wake_async (sk->socket, how, band);
trickles-server_2.c:20023:  return ((&sk->wmem_alloc)->counter) < (sk->sndbuf / 2);
trickles-server_2.c:20037:  return noblock ? 0 : sk->rcvtimeo;
trickles-server_2.c:20043:  return noblock ? 0 : sk->sndtimeo;
trickles-server_2.c:20051:			    int __x = (sk->rcvlowat);
trickles-server_2.c:20063:  return timeo == ((long) (~0UL >> 1)) ? -512 : -4;
trickles-server_2.c:20069:  if (sk->rcvtstamp)
trickles-server_2.c:20070:    put_cmsg (msg, 1, 29, sizeof (skb->stamp), &skb->stamp);
trickles-server_2.c:20072:    sk->stamp = skb->stamp;
trickles-server_2.c:20173:  return !((addr ^ ifa->ifa_address) & ifa->ifa_mask);
trickles-server_2.c:20201:  in_dev = dev->ip_ptr;
trickles-server_2.c:20203:    atomic_inc (&in_dev->refcnt);
trickles-server_2.c:20214:  return (struct in_device *) dev->ip_ptr;
trickles-server_2.c:20222:  if (atomic_dec_and_test (&idev->refcnt))
trickles-server_2.c:20235:    return htonl (~((1 << (32 - logmask)) - 1));
trickles-server_2.c:20244:  return 32 - ffz (~mask);
trickles-server_2.c:20291:  if (atomic_dec_and_test (&p->refcnt))
trickles-server_2.c:20293:      p->unused_prevp = inet_peer_unused_tailp;
trickles-server_2.c:20294:      p->unused_next = ((void *) 0);
trickles-server_2.c:20296:      inet_peer_unused_tailp = &p->unused_next;
trickles-server_2.c:20297:      p->dtime = jiffies;
trickles-server_2.c:20309:	  if (!--*ptr)
trickles-server_2.c:20310:	    __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;"
trickles-server_2.c:20343:  id = p->ip_id_count++;
trickles-server_2.c:20354:	  if (!--*ptr)
trickles-server_2.c:20355:	    __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;"
trickles-server_2.c:20506:    dst_release (&rt->u.dst);
trickles-server_2.c:20526:  dst = (*rp)->rt_dst;
trickles-server_2.c:20527:  src = (*rp)->rt_src;
trickles-server_2.c:20538:  if (rt->peer)
trickles-server_2.c:20539:    return rt->peer;
trickles-server_2.c:20542:  return rt->peer;
trickles-server_2.c:20991:  if (skb->len > skb->dst->pmtu)
trickles-server_2.c:21002:  u32 check = iph->check;
trickles-server_2.c:21007:  iph->check = check + (check >= 0xFFFF);
trickles-server_2.c:21008:  return --iph->ttl;
trickles-server_2.c:21014:  return (sk->protinfo.af_inet.pmtudisc == 2 ||
trickles-server_2.c:21015:	  (sk->protinfo.af_inet.pmtudisc == 1 &&
trickles-server_2.c:21016:	   !(dst->mxlock & (1 << RTAX_MTU))));
trickles-server_2.c:21024:  if (iph->
trickles-server_2.c:21035:      iph->id = ((sk && sk->daddr) ? htons (sk->protinfo.af_inet.id++) : 0);
trickles-server_2.c:21241:unsigned long flag, sum; asm ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag), "=r" (sum):"1" (dst), "g" ((int) (len)), "g" (get_current ()->addr_limit.seg));
trickles-server_2.c:21248:    *err_ptr = -14;
trickles-server_2.c:21250:  return -1;
trickles-server_2.c:21263:    *err_ptr = -14;
trickles-server_2.c:21370:  return (lport & ((tcp_hashinfo.__tcp_bhash_size) - 1));
trickles-server_2.c:21422:  if (atomic_dec_and_test (&tw->refcnt))
trickles-server_2.c:21441:  return num & (32 - 1);
trickles-server_2.c:21447:  return tcp_lhashfn (sk->num);
trickles-server_2.c:21545:  req->class->destructor (req);
trickles-server_2.c:21590:  return (__s32) (seq1 - seq2) < 0;
trickles-server_2.c:21596:  return (__s32) (seq2 - seq1) < 0;
trickles-server_2.c:21604:  return seq3 - seq2 >= seq1 - seq2;
trickles-server_2.c:21655:  tp->ack.pending |= TCP_ACK_SCHED;
trickles-server_2.c:21661:  return tp->ack.pending & TCP_ACK_SCHED;
trickles-server_2.c:21667:  if (tp->ack.quick && --tp->ack.quick == 0)
trickles-server_2.c:21670:      tp->ack.ato = ((unsigned) (100 / 25));
trickles-server_2.c:21680:   ? (__builtin_constant_p ((sizeof (tp->ack))) ?
trickles-server_2.c:21681:      __constant_c_and_count_memset (((&tp->ack)),
trickles-server_2.c:21683:				     ((sizeof (tp->ack)))) :
trickles-server_2.c:21684:      __constant_c_memset (((&tp->ack)),
trickles-server_2.c:21686:			   ((sizeof (tp->ack)))))
trickles-server_2.c:21687:   : (__builtin_constant_p ((sizeof (tp->ack))) ?
trickles-server_2.c:21688:      __memset_generic ((((&tp->ack))), (((0))),
trickles-server_2.c:21689:			(((sizeof (tp->ack))))) :
trickles-server_2.c:21690:      __memset_generic (((&tp->ack)), ((0)), ((sizeof (tp->ack))))));
trickles-server_2.c:21696:  tp->tstamp_ok = tp->sack_ok = tp->wscale_ok = tp->snd_wscale = 0;
trickles-server_2.c:21833:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_2.c:21839:      tp->pending = 0;
trickles-server_2.c:21848:      tp->ack.blocked = 0;
trickles-server_2.c:21849:      tp->ack.pending = 0;
trickles-server_2.c:21870:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_2.c:21890:      tp->pending = what;
trickles-server_2.c:21891:      tp->timeout = jiffies + when;
trickles-server_2.c:21892:      if (!mod_timer (&tp->retransmit_timer, tp->timeout))
trickles-server_2.c:21897:      tp->ack.pending |= TCP_ACK_TIMER;
trickles-server_2.c:21898:      tp->ack.timeout = jiffies + when;
trickles-server_2.c:21899:      if (!mod_timer (&tp->delack_timer, tp->ack.timeout))
trickles-server_2.c:21915:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_2.c:21917:  int mss_now = tp->mss_cache;
trickles-server_2.c:21919:  if (dst && dst->pmtu != tp->pmtu_cookie)
trickles-server_2.c:21920:    mss_now = tcp_sync_mss (sk, dst->pmtu);
trickles-server_2.c:21922:  if (tp->eff_sacks)
trickles-server_2.c:21923:    mss_now -= (4 + (tp->eff_sacks * 8));
trickles-server_2.c:21931:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_2.c:21932:  unsigned int hint = ({ const typeof (tp->advmss) _x = (tp->advmss);
trickles-server_2.c:21933:		       const typeof (tp->mss_cache) _y = (tp->mss_cache);
trickles-server_2.c:21941:	   const typeof (tp->rcv_wnd / 2) _y = (tp->rcv_wnd / 2);
trickles-server_2.c:21960:  tp->ack.rcv_mss = hint;
trickles-server_2.c:21966:  tp->pred_flags = htonl ((tp->tcp_header_len << 26) |
trickles-server_2.c:21973:  __tcp_fast_path_on (tp, tp->snd_wnd >> tp->snd_wscale);
trickles-server_2.c:21979:  if (skb_queue_len (&tp->out_of_order_queue) == 0 &&
trickles-server_2.c:21980:      tp->rcv_wnd &&
trickles-server_2.c:21981:      ((&sk->rmem_alloc)->counter) < sk->rcvbuf && !tp->urg_data)
trickles-server_2.c:21992:  s32 win = tp->rcv_wup + tp->rcv_wnd - tp->rcv_nxt;
trickles-server_2.c:22081:  u32 check = iph->check;
trickles-server_2.c:22086:  iph->check = check + (check >= 0xFFFF);
trickles-server_2.c:22087:  iph->tos |= 1;
trickles-server_2.c:22109:  if (tp->ecn_flags & 1)
trickles-server_2.c:22110:    tp->ecn_flags |= 2;
trickles-server_2.c:22119:  ((struct tcp_skb_cb *) &((skb)->cb[0]))->flags &= ~0x80;
trickles-server_2.c:22120:  if (!(tp->ecn_flags & 1))
trickles-server_2.c:22121:    ((struct tcp_skb_cb *) &((skb)->cb[0]))->flags &= ~0x40;
trickles-server_2.c:22127:  tp->ecn_flags = 0;
trickles-server_2.c:22130:      ((struct tcp_skb_cb *) &((skb)->cb[0]))->flags |= 0x40 | 0x80;
trickles-server_2.c:22131:      tp->ecn_flags = 1;
trickles-server_2.c:22138:  if (req->ecn_ok)
trickles-server_2.c:22139:    th->ece = 1;
trickles-server_2.c:22146:  if (tp->ecn_flags & 1)
trickles-server_2.c:22149:      if (skb->len != tcp_header_len &&
trickles-server_2.c:22150:	  !before (((struct tcp_skb_cb *) &((skb)->cb[0]))->seq, tp->snd_nxt))
trickles-server_2.c:22154:	      (sk)->protinfo.af_inet.tos |= 2;
trickles-server_2.c:22157:	  if (tp->ecn_flags & 2)
trickles-server_2.c:22159:	      tp->ecn_flags &= ~2;
trickles-server_2.c:22160:	      skb->h.th->cwr = 1;
trickles-server_2.c:22168:	      (sk)->protinfo.af_inet.tos &= ~3;
trickles-server_2.c:22172:      if (tp->ecn_flags & 4)
trickles-server_2.c:22173:	skb->h.th->ece = 1;
trickles-server_2.c:22182:  if (skb->h.th->cwr)
trickles-server_2.c:22183:    tp->ecn_flags &= ~4;
trickles-server_2.c:22189:  tp->ecn_flags &= ~4;
trickles-server_2.c:22195:  if (tp->ecn_flags & 1)
trickles-server_2.c:22197:      if (INET_ECN_is_ce (((struct tcp_skb_cb *) &((skb)->cb[0]))->flags))
trickles-server_2.c:22198:	tp->ecn_flags |= 4;
trickles-server_2.c:22204:	    ((((struct tcp_skb_cb *) &((skb)->cb[0]))->flags)))
trickles-server_2.c:22212:  if ((tp->ecn_flags & 1) && (!th->ece || th->cwr))
trickles-server_2.c:22213:    tp->ecn_flags &= ~1;
trickles-server_2.c:22219:  if ((tp->ecn_flags & 1) && (!th->ece || !th->cwr))
trickles-server_2.c:22220:    tp->ecn_flags &= ~1;
trickles-server_2.c:22226:  if (th->ece && !th->syn && (tp->ecn_flags & 1))
trickles-server_2.c:22234:  tp->ecn_flags = req->ecn_ok ? 1 : 0;
trickles-server_2.c:22240:  if (sysctl_tcp_ecn && th->ece && th->cwr)
trickles-server_2.c:22241:    req->ecn_ok = 1;
trickles-server_2.c:22253:  return sk->wmem_queued / 2;
trickles-server_2.c:22259:  return sk->sndbuf - sk->wmem_queued;
trickles-server_2.c:22266:  return tp->packets_out - tp->left_out + tp->retrans_out;
trickles-server_2.c:22279:	   const typeof (tp->snd_cwnd >> 1U) _x = (tp->snd_cwnd >> 1U);
trickles-server_2.c:22293:  if ((1 << tp->ca_state) & ((1 << TCP_CA_CWR) | (1 << TCP_CA_Recovery)))
trickles-server_2.c:22294:    return tp->snd_ssthresh;
trickles-server_2.c:22298:	     const typeof (tp->snd_ssthresh) _x = (tp->snd_ssthresh);
trickles-server_2.c:22299:	     const typeof (((tp->snd_cwnd >> 1) + (tp->snd_cwnd >> 2))) _y =
trickles-server_2.c:22300:	     (((tp->snd_cwnd >> 1) + (tp->snd_cwnd >> 2)));
trickles-server_2.c:22311:  if (tp->sack_ok && tp->sacked_out >= tp->packets_out - tp->lost_out)
trickles-server_2.c:22312:    tp->sacked_out = tp->packets_out - tp->lost_out;
trickles-server_2.c:22313:  tp->left_out = tp->sacked_out + tp->lost_out;
trickles-server_2.c:22323:  if (tp->packets_out >= tp->snd_cwnd)
trickles-server_2.c:22326:      tp->snd_cwnd_used = 0;
trickles-server_2.c:22327:      tp->snd_cwnd_stamp = ((__u32) (jiffies));
trickles-server_2.c:22332:      if (tp->packets_out > tp->snd_cwnd_used)
trickles-server_2.c:22333:	tp->snd_cwnd_used = tp->packets_out;
trickles-server_2.c:22335:      if ((s32) (((__u32) (jiffies)) - tp->snd_cwnd_stamp) >= tp->rto)
trickles-server_2.c:22344:  tp->undo_marker = 0;
trickles-server_2.c:22345:  tp->snd_ssthresh = tcp_recalc_ssthresh (tp);
trickles-server_2.c:22346:  tp->snd_cwnd = (
trickles-server_2.c:22348:		   const typeof (tp->snd_cwnd) _x = (tp->snd_cwnd);
trickles-server_2.c:22355:  tp->snd_cwnd_cnt = 0;
trickles-server_2.c:22356:  tp->high_seq = tp->snd_nxt;
trickles-server_2.c:22357:  tp->snd_cwnd_stamp = ((__u32) (jiffies));
trickles-server_2.c:22364:  tp->prior_ssthresh = 0;
trickles-server_2.c:22365:  if (tp->ca_state < TCP_CA_CWR)
trickles-server_2.c:22368:      tp->ca_state = TCP_CA_CWR;
trickles-server_2.c:22386:  return after (tp->snd_sml, tp->snd_una) &&
trickles-server_2.c:22387:    !after (tp->snd_sml, tp->snd_nxt);
trickles-server_2.c:22393:  if (skb->len < mss)
trickles-server_2.c:22394:    tp->snd_sml = ((struct tcp_skb_cb *) &((skb)->cb[0]))->end_seq;
trickles-server_2.c:22402:  return (skb->len < mss_now &&
trickles-server_2.c:22403:	  !(((struct tcp_skb_cb *) &((skb)->cb[0]))->flags & 0x01) &&
trickles-server_2.c:22405:	   (!nonagle && tp->packets_out && tcp_minshall_check (tp))));
trickles-server_2.c:22416:  return ((nonagle == 1 || tp->urg_mode
trickles-server_2.c:22418:	  ((tcp_packets_in_flight (tp) < tp->snd_cwnd) ||
trickles-server_2.c:22419:	   (((struct tcp_skb_cb *) &((skb)->cb[0]))->flags & 0x01)) &&
trickles-server_2.c:22420:	  !after (((struct tcp_skb_cb *) &((skb)->cb[0]))->end_seq,
trickles-server_2.c:22421:		  tp->snd_una + tp->snd_wnd));
trickles-server_2.c:22427:  if (!tp->packets_out && !tp->pending)
trickles-server_2.c:22428:    tcp_reset_xmit_timer (sk, 3, tp->rto);
trickles-server_2.c:22434:  return (skb->next == (struct sk_buff *) &sk->write_queue);
trickles-server_2.c:22445:  struct sk_buff *skb = tp->send_head;
trickles-server_2.c:22461:  __tcp_push_pending_frames (sk, tp, tcp_current_mss (sk), tp->nonagle);
trickles-server_2.c:22467:  struct sk_buff *skb = tp->send_head;
trickles-server_2.c:22471:			tcp_skb_is_last (sk, skb) ? 1 : tp->nonagle));
trickles-server_2.c:22477:  tp->snd_wl1 = seq;
trickles-server_2.c:22483:  tp->snd_wl1 = seq;
trickles-server_2.c:22503:    csum_fold (skb_checksum (skb, 0, skb->len, skb->csum));
trickles-server_2.c:22509:  return skb->ip_summed != 2 && __tcp_checksum_complete (skb);
trickles-server_2.c:22517:  tp->ucopy.task = ((void *) 0);
trickles-server_2.c:22518:  tp->ucopy.len = 0;
trickles-server_2.c:22519:  tp->ucopy.memory = 0;
trickles-server_2.c:22520:  skb_queue_head_init (&tp->ucopy.prequeue);
trickles-server_2.c:22527:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_2.c:22529:  if (!sysctl_tcp_low_latency && tp->ucopy.task)
trickles-server_2.c:22531:      __skb_queue_tail (&tp->ucopy.prequeue, skb);
trickles-server_2.c:22532:      tp->ucopy.memory += skb->truesize;
trickles-server_2.c:22533:      if (tp->ucopy.memory > sk->rcvbuf)
trickles-server_2.c:22537:	  if (sk->lock.users)
trickles-server_2.c:22540:	  while ((skb1 = __skb_dequeue (&tp->ucopy.prequeue)) != ((void *) 0))
trickles-server_2.c:22542:	      sk->backlog_rcv (sk, skb1);
trickles-server_2.c:22546:	  tp->ucopy.memory = 0;
trickles-server_2.c:22548:      else if (skb_queue_len (&tp->ucopy.prequeue) == 1)
trickles-server_2.c:22550:	  __wake_up ((sk->sleep), 1, 1);
trickles-server_2.c:22563:  int oldstate = sk->state;
trickles-server_2.c:22582:      sk->prot->unhash (sk);
trickles-server_2.c:22583:      if (sk->prev && !(sk->userlocks & 8))
trickles-server_2.c:22590:			  irq_stat[0].__local_bh_count) != 0)].TcpCurrEstab--;
trickles-server_2.c:22596:  sk->state = state;
trickles-server_2.c:22609:  sk->shutdown = 3;
trickles-server_2.c:22611:  if (!sk->dead)
trickles-server_2.c:22612:    sk->state_change (sk);
trickles-server_2.c:22620:  tp->dsack = 0;
trickles-server_2.c:22621:  tp->eff_sacks = 0;
trickles-server_2.c:22622:  tp->num_sacks = 0;
trickles-server_2.c:22628:  if (tp->tstamp_ok)
trickles-server_2.c:22644:      *ptr++ = htonl (tp->ts_recent);
trickles-server_2.c:22646:  if (tp->eff_sacks)
trickles-server_2.c:22649:	tp->dsack ? tp->duplicate_sack : tp->selective_acks;
trickles-server_2.c:22655:	    (((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) &
trickles-server_2.c:22658:	    (((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) &
trickles-server_2.c:22661:	    (((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) &
trickles-server_2.c:22664:	    (((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) &
trickles-server_2.c:22670:      for (this_sack = 0; this_sack < tp->eff_sacks; this_sack++)
trickles-server_2.c:22675:      if (tp->dsack)
trickles-server_2.c:22677:	  tp->dsack = 0;
trickles-server_2.c:22678:	  tp->eff_sacks--;
trickles-server_2.c:22786:      if (*rcv_wscale && sysctl_tcp_app_win && space >= mss && space - (
trickles-server_2.c:22791:	(*rcv_wscale)--;
trickles-server_2.c:22823:    (space >> (-sysctl_tcp_adv_win_scale)) :
trickles-server_2.c:22824:    space - (space >> sysctl_tcp_adv_win_scale);
trickles-server_2.c:22831:  return tcp_win_from_space (sk->rcvbuf - ((&sk->rmem_alloc)->counter));
trickles-server_2.c:22837:  return tcp_win_from_space (sk->rcvbuf);
trickles-server_2.c:22843:  sk->ack_backlog--;
trickles-server_2.c:22849:  sk->ack_backlog++;
trickles-server_2.c:22855:  return sk->ack_backlog > sk->max_ack_backlog;
trickles-server_2.c:22862:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_2.c:22864:  req->sk = child;
trickles-server_2.c:22867:  if (!tp->accept_queue_tail)
trickles-server_2.c:22869:      tp->accept_queue = req;
trickles-server_2.c:22873:      tp->accept_queue_tail->dl_next = req;
trickles-server_2.c:22875:  tp->accept_queue_tail = req;
trickles-server_2.c:22876:  req->dl_next = ((void *) 0);
trickles-server_2.c:22892:  struct tcp_listen_opt *lopt = sk->tp_pinfo.af_tcp.listen_opt;
trickles-server_2.c:22894:  if (--lopt->qlen == 0)
trickles-server_2.c:22896:  if (req->retrans == 0)
trickles-server_2.c:22897:    lopt->qlen_young--;
trickles-server_2.c:22903:  struct tcp_listen_opt *lopt = sk->tp_pinfo.af_tcp.listen_opt;
trickles-server_2.c:22905:  if (lopt->qlen++ == 0)
trickles-server_2.c:22907:  lopt->qlen_young++;
trickles-server_2.c:22913:  return sk->tp_pinfo.af_tcp.listen_opt->qlen;
trickles-server_2.c:22919:  return sk->tp_pinfo.af_tcp.listen_opt->qlen_young;
trickles-server_2.c:22925:  return tcp_synq_len (sk) >> sk->tp_pinfo.af_tcp.listen_opt->max_qlen_log;
trickles-server_2.c:22932:  (void) (&tp->syn_wait_lock);
trickles-server_2.c:22933:  *prev = req->dl_next;
trickles-server_2.c:22944:  tcp_synq_unlink (&sk->tp_pinfo.af_tcp, req, prev);
trickles-server_2.c:22953:  req->rcv_wnd = 0;
trickles-server_2.c:22954:  req->rcv_isn = ((struct tcp_skb_cb *) &((skb)->cb[0]))->seq;
trickles-server_2.c:22955:  req->mss = tp->mss_clamp;
trickles-server_2.c:22956:  req->ts_recent = tp->saw_tstamp ? tp->rcv_tsval : 0;
trickles-server_2.c:22957:  req->tstamp_ok = tp->tstamp_ok;
trickles-server_2.c:22958:  req->sack_ok = tp->sack_ok;
trickles-server_2.c:22959:  req->snd_wscale = tp->snd_wscale;
trickles-server_2.c:22960:  req->wscale_ok = tp->wscale_ok;
trickles-server_2.c:22961:  req->acked = 0;
trickles-server_2.c:22962:  req->ecn_ok = 0;
trickles-server_2.c:22963:  req->rmt_port = skb->h.th->source;
trickles-server_2.c:22971:  sk->tp_pinfo.af_tcp.queue_shrunk = 1;
trickles-server_2.c:22972:  sk->wmem_queued -= skb->truesize;
trickles-server_2.c:22973:  sk->forward_alloc += skb->truesize;
trickles-server_2.c:22980:  sk->wmem_queued += skb->truesize;
trickles-server_2.c:22981:  sk->forward_alloc -= skb->truesize;
trickles-server_2.c:22990:  if (sk->forward_alloc >= ((int) (1UL << 12)))
trickles-server_2.c:23010:  if (!(sk->userlocks & 1))
trickles-server_2.c:23012:      sk->sndbuf = (
trickles-server_2.c:23014:		     const typeof (sk->sndbuf) _x = (sk->sndbuf);
trickles-server_2.c:23015:		     const typeof (sk->wmem_queued / 2) _y =
trickles-server_2.c:23016:		     (sk->wmem_queued / 2);
trickles-server_2.c:23020:      sk->sndbuf = (
trickles-server_2.c:23022:		     const typeof (sk->sndbuf) _x = (sk->sndbuf);
trickles-server_2.c:23037:      skb->truesize += mem;
trickles-server_2.c:23038:      if (sk->forward_alloc >= (int) skb->truesize ||
trickles-server_2.c:23039:	  tcp_mem_schedule (sk, skb->truesize, 0))
trickles-server_2.c:23063:  if (sk->forward_alloc >= (int) (1UL << 12) ||
trickles-server_2.c:23066:      struct page *page = alloc_pages (sk->allocation, 0);
trickles-server_2.c:23080:  while ((skb = __skb_dequeue (&sk->write_queue)) != ((void *) 0))
trickles-server_2.c:23090:  skb->sk = sk;
trickles-server_2.c:23091:  skb->destructor = tcp_rfree;
trickles-server_2.c:23092:  atomic_add (skb->truesize, &sk->rmem_alloc);
trickles-server_2.c:23093:  sk->forward_alloc -= skb->truesize;
trickles-server_2.c:23125:  return tp->keepalive_intvl ? : sysctl_tcp_keepalive_intvl;
trickles-server_2.c:23131:  return tp->keepalive_time ? : sysctl_tcp_keepalive_time;
trickles-server_2.c:23137:  int fin_timeout = tp->linger2 ? : sysctl_tcp_fin_timeout;
trickles-server_2.c:23139:  if (fin_timeout < (tp->rto << 2) - (tp->rto >> 1))
trickles-server_2.c:23140:    fin_timeout = (tp->rto << 2) - (tp->rto >> 1);
trickles-server_2.c:23148:  if ((s32) (tp->rcv_tsval - tp->ts_recent) >= 0)
trickles-server_2.c:23150:  if (xtime.tv_sec >= tp->ts_recent_stamp + (60 * 60 * 24 * 24))
trickles-server_2.c:23153:  if (rst && xtime.tv_sec >= tp->ts_recent_stamp + 60)
trickles-server_2.c:23163:  const struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_2.c:23169:  return (sysctl_tcp_frto && tp->send_head &&
trickles-server_2.c:23170:	  !after (((struct tcp_skb_cb *) &((tp->send_head)->cb[0]))->end_seq,
trickles-server_2.c:23171:		  tp->snd_una + tp->snd_wnd));
trickles-server_2.c:23183:  ((tcp_statistics)[2 * 0 + 1].TcpMaxConn += -1);
trickles-server_2.c:23196:    tp->westwood.rtt = rtt_seq;
trickles-server_2.c:23205:  struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-server_2.c:23207:  tp->westwood.bw_ns_est = 0;
trickles-server_2.c:23208:  tp->westwood.bw_est = 0;
trickles-server_2.c:23209:  tp->westwood.accounted = 0;
trickles-server_2.c:23210:  tp->westwood.cumul_ack = 0;
trickles-server_2.c:23211:  tp->westwood.rtt_win_sx = ((__u32) (jiffies));
trickles-server_2.c:23212:  tp->westwood.rtt = 20 * 100;
trickles-server_2.c:23213:  tp->westwood.rtt_min = 20 * 100;
trickles-server_2.c:23214:  tp->westwood.snd_una = tp->snd_una;
trickles-server_2.c:23240:  return (__u32) ((tp->westwood.bw_est) * (tp->westwood.rtt_min) /
trickles-server_2.c:23241:		  (__u32) (tp->mss_cache));
trickles-server_2.c:23274:      tp->snd_ssthresh = ssthresh;
trickles-server_2.c:23292:      tp->snd_cwnd = cwnd;
trickles-server_2.c:23308:	  tp->snd_ssthresh = tp->snd_cwnd;
trickles-server_2.c:23597:  struct sock *sk = skb->sk;
trickles-server_2.c:23602:  if (skb->ip_summed == 1)
trickles-server_2.c:23605:      skb->h.th->check = 0;
trickles-server_2.c:23606:      skb->h.th->check =
trickles-server_2.c:23607:	~tcp_v4_check (skb->h.th, skb->len, sk->saddr, sk->daddr, 0);
trickles-server_2.c:23608:      skb->csum = ((size_t) & ((struct tcphdr *) 0)->check);
trickles-server_2.c:23612:      skb->h.th->check = 0;
trickles-server_2.c:23613:      skb->h.th->check =
trickles-server_2.c:23614:	tcp_v4_check (skb->h.th, skb->len, sk->saddr, sk->daddr,
trickles-server_2.c:23615:		      csum_partial ((char *) skb->h.th, headerLen,
trickles-server_2.c:23616:				    skb->csum));
trickles-server_2.c:23646:  POISONEDRANGE = -1,
trickles-server_2.c:23702:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_2.c:23703:  if (!(dataReq->list == ((void *) 0)))
trickles-server_2.c:23705:      printk ("KERNEL: assertion (" "dataReq->list == NULL" ") failed at "
trickles-server_2.c:23709:  dataReq->completed = 0;
trickles-server_2.c:23710:  dataReq->sent = 0;
trickles-server_2.c:23713:  dataReq->transportResponseSeqStart = (4294967295U);
trickles-server_2.c:23714:  dataReq->transportResponseSeqEnd = (4294967295U);
trickles-server_2.c:23715:  dataReq->timestamp = (4294967295U);
trickles-server_2.c:23716:  dataReq->start = newStart;
trickles-server_2.c:23717:  dataReq->end = newEnd;
trickles-server_2.c:23718:  insert_tail (&tp->t.missingDataMap, (struct alloc_head *) dataReq);
trickles-server_2.c:23752:  newMapping->next = newMapping->prev = ((void *) 0);
trickles-server_2.c:23753:  newMapping->list = ((void *) 0);
trickles-server_2.c:23755:  newMapping->completed = 0;
trickles-server_2.c:23756:  newMapping->ucont = ucont;
trickles-server_2.c:23757:  newMapping->transportResponseSeqStart = tseq_start;
trickles-server_2.c:23758:  newMapping->transportResponseSeqEnd = tseq_end;
trickles-server_2.c:23759:  newMapping->sent = 0;
trickles-server_2.c:23760:  newMapping->start = start;
trickles-server_2.c:23761:  newMapping->end = end;
trickles-server_2.c:23763:  newMapping->timestamp = jiffies;
trickles-server_2.c:23773:  numDataRequestMappings--;
trickles-server_2.c:23813:  req->numChildren = 0;
trickles-server_2.c:23814:  req->childrenMask = 0;
trickles-server_2.c:23815:  req->transport_seq = -1;
trickles-server_2.c:23816:  req->seq = -1;
trickles-server_2.c:23817:  req->isNew = 1;
trickles-server_2.c:23824:  req->type = type;
trickles-server_2.c:23825:  req->prev = req->next = ((void *) 0);
trickles-server_2.c:23826:  req->list = ((void *) 0);
trickles-server_2.c:23828:  req->start = req->end = -1;
trickles-server_2.c:23829:  req->allocated = 1;
trickles-server_2.c:23837:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_2.c:23838:  insert_tail (&tp->t.queuedRequests, (struct alloc_head *) req);
trickles-server_2.c:23839:  tp->t.timerState |= (0x1);
trickles-server_2.c:23887:  req->incomplete = 0;
trickles-server_2.c:23888:  req->completePred = pred;
trickles-server_2.c:23889:  atomic_inc (&req->completePred->refcnt);
trickles-server_2.c:23891:  if (((&req->completePred->refcnt)->counter) < 2)
trickles-server_2.c:23896:  req->data = data;
trickles-server_2.c:23897:  req->start = start;
trickles-server_2.c:23898:  req->offset = req->start - ((struct tcp_skb_cb *) &((data)->cb[0]))->seq;
trickles-server_2.c:23908:  req->incomplete = 1;
trickles-server_2.c:23909:  req->incompletePred = pred;
trickles-server_2.c:23910:  req->predLength = predLength;
trickles-server_2.c:23911:  req->data = data;
trickles-server_2.c:23912:  req->offset = offset;
trickles-server_2.c:23948:  req->start = start;
trickles-server_2.c:23949:  req->end = end;
trickles-server_2.c:23950:  req->numConts = numConts;
trickles-server_2.c:23951:  req->conts = kmalloc (sizeof (struct UC_Continuation *) * numConts, (0x20));
trickles-server_2.c:23956:      return -1;
trickles-server_2.c:23971:  newReq->conts =
trickles-server_2.c:23972:    kmalloc (sizeof (struct UC_Continuation *) * newReq->numConts, (0x20));
trickles-server_2.c:23973:  if (newReq->conts == ((void *) 0))
trickles-server_2.c:23978:  (__builtin_constant_p (sizeof (struct UC_Continuation *) * newReq->numConts)
trickles-server_2.c:23979:   ? __constant_memcpy ((newReq->conts), (src->conts),
trickles-server_2.c:23981:			 newReq->numConts)) : __memcpy ((newReq->conts),
trickles-server_2.c:23982:							(src->conts),
trickles-server_2.c:23986:							 newReq->numConts)));
trickles-server_2.c:24015:  rval->prev = rval->next = ((void *) 0);
trickles-server_2.c:24016:  rval->list = ((void *) 0);
trickles-server_2.c:24018:  rval->cont = cont;
trickles-server_2.c:24019:  rval->isSynack = isSynack;
trickles-server_2.c:24020:  rval->parent = parent;
trickles-server_2.c:24021:  rval->numSiblings = numSiblings;
trickles-server_2.c:24022:  rval->position = position;
trickles-server_2.c:24072:  dcont->clientState = scont->clientState;
trickles-server_2.c:24073:  dcont->parent = scont->parent;
trickles-server_2.c:24078:	(dcont)->seq = htonl ((scont)->packets[pktNum].seq);
trickles-server_2.c:24079:	(dcont)->continuationType = (scont)->packets[pktNum].contType;
trickles-server_2.c:24080:	if ((scont)->packets[pktNum].type & (0x80))
trickles-server_2.c:24082:	(dcont)->firstChild = 1;}
trickles-server_2.c:24085:	(dcont)->firstChild = 0;}
trickles-server_2.c:24089:	int conversionOffset = (scont)->packets[pktNum].type & (0x3);
trickles-server_2.c:24099:	(dcont)->state = stateConversionMap[conversionOffset];}
trickles-server_2.c:24101:	  dcont->timestamp = htonl (scont->timestamp);
trickles-server_2.c:24102:	  dcont->clientTimestamp = scont->clientTimestamp;
trickles-server_2.c:24103:	  dcont->mrtt = htonl (scont->mrtt);
trickles-server_2.c:24107:	  dcont->seq = htonl (scont->seq);
trickles-server_2.c:24108:	  dcont->continuationType = scont->continuationType;
trickles-server_2.c:24109:	  dcont->firstChild = scont->firstChild;
trickles-server_2.c:24110:	  dcont->state = scont->state;
trickles-server_2.c:24111:	  dcont->timestamp = scont->rawTimestamp;
trickles-server_2.c:24112:	  dcont->clientTimestamp = scont->clientTimestamp;
trickles-server_2.c:24113:	  dcont->mrtt = scont->rawMrtt;
trickles-server_2.c:24115:	dcont->firstLoss = htonl (scont->firstLoss);
trickles-server_2.c:24116:	dcont->firstBootstrapSeq = htonl (scont->firstBootstrapSeq);
trickles-server_2.c:24117:	dcont->startCwnd = htonl (scont->startCwnd);
trickles-server_2.c:24118:	dcont->ssthresh = htonl (scont->ssthresh);
trickles-server_2.c:24119:	dcont->TCPBase = htonl (scont->TCPBase);
trickles-server_2.c:24120:	dcont->tokenCounterBase = scont->tokenCounterBase;
trickles-server_2.c:24124:	    phdr->seq = dcont->seq;
trickles-server_2.c:24125:	    phdr->type = dcont->continuationType;
trickles-server_2.c:24126:	    phdr->first = dcont->firstChild ? 1 : 0;
trickles-server_2.c:24127:	    phdr->serverAddr = scont->saddr;
trickles-server_2.c:24128:	    phdr->serverPort = scont->source;
trickles-server_2.c:24129:	    phdr->clientAddr = scont->daddr;
trickles-server_2.c:24130:	    phdr->clientPort = scont->dest;
trickles-server_2.c:24131:	    computeMAC (sk, phdr, dcont, dcont->mac);
trickles-server_2.c:24142:	dcont->clientState = scont->clientState;
trickles-server_2.c:24143:	dcont->parent = scont->parent;
trickles-server_2.c:24148:	      (dcont)->seq = htonl ((scont)->packets[pktNum].seq);
trickles-server_2.c:24149:	      (dcont)->continuationType = (scont)->packets[pktNum].contType;
trickles-server_2.c:24150:	      if ((scont)->packets[pktNum].type & (0x80))
trickles-server_2.c:24152:	      (dcont)->firstChild = 1;}
trickles-server_2.c:24155:	      (dcont)->firstChild = 0;}
trickles-server_2.c:24159:	      int conversionOffset = (scont)->packets[pktNum].type & (0x3);
trickles-server_2.c:24169:	      (dcont)->state = stateConversionMap[conversionOffset];}
trickles-server_2.c:24171:		dcont->timestamp = htonl (scont->timestamp);
trickles-server_2.c:24172:		dcont->clientTimestamp = scont->clientTimestamp;
trickles-server_2.c:24173:		dcont->mrtt = htonl (scont->mrtt);
trickles-server_2.c:24177:		dcont->seq = htonl (scont->seq);
trickles-server_2.c:24178:		dcont->continuationType = scont->continuationType;
trickles-server_2.c:24179:		dcont->firstChild = scont->firstChild;
trickles-server_2.c:24180:		dcont->state = scont->state;
trickles-server_2.c:24181:		dcont->timestamp = scont->rawTimestamp;
trickles-server_2.c:24182:		dcont->clientTimestamp = scont->clientTimestamp;
trickles-server_2.c:24183:		dcont->mrtt = scont->rawMrtt;
trickles-server_2.c:24185:	      dcont->firstLoss = htonl (scont->firstLoss);
trickles-server_2.c:24186:	      dcont->firstBootstrapSeq = htonl (scont->firstBootstrapSeq);
trickles-server_2.c:24187:	      dcont->startCwnd = htonl (scont->startCwnd);
trickles-server_2.c:24188:	      dcont->ssthresh = htonl (scont->ssthresh);
trickles-server_2.c:24189:	      dcont->TCPBase = htonl (scont->TCPBase);
trickles-server_2.c:24190:	      dcont->tokenCounterBase = scont->tokenCounterBase;
trickles-server_2.c:24194:		   __constant_memcpy ((dcont->mac), (scont->mac),
trickles-server_2.c:24195:				      (16)) : __memcpy ((dcont->mac),
trickles-server_2.c:24196:							(scont->mac), (16)));
trickles-server_2.c:24207:	      dcont->clientState = scont->clientState;
trickles-server_2.c:24208:	      dcont->parent = scont->parent;
trickles-server_2.c:24213:		    (dcont)->seq = htonl ((scont)->packets[pktNum].seq);
trickles-server_2.c:24214:		    (dcont)->continuationType =
trickles-server_2.c:24215:		    (scont)->packets[pktNum].contType;
trickles-server_2.c:24216:		    if ((scont)->packets[pktNum].type & (0x80))
trickles-server_2.c:24218:		    (dcont)->firstChild = 1;}
trickles-server_2.c:24221:		    (dcont)->firstChild = 0;}
trickles-server_2.c:24226:		    (scont)->packets[pktNum].type & (0x3);
trickles-server_2.c:24236:		    (dcont)->state = stateConversionMap[conversionOffset];}
trickles-server_2.c:24238:		      dcont->timestamp = htonl (scont->timestamp);
trickles-server_2.c:24239:		      dcont->clientTimestamp = scont->clientTimestamp;
trickles-server_2.c:24240:		      dcont->mrtt = htonl (scont->mrtt);
trickles-server_2.c:24244:		      dcont->seq = htonl (scont->seq);
trickles-server_2.c:24245:		      dcont->continuationType = scont->continuationType;
trickles-server_2.c:24246:		      dcont->firstChild = scont->firstChild;
trickles-server_2.c:24247:		      dcont->state = scont->state;
trickles-server_2.c:24248:		      dcont->timestamp = scont->rawTimestamp;
trickles-server_2.c:24249:		      dcont->clientTimestamp = scont->clientTimestamp;
trickles-server_2.c:24250:		      dcont->mrtt = scont->rawMrtt;
trickles-server_2.c:24252:		    dcont->firstLoss = htonl (scont->firstLoss);
trickles-server_2.c:24253:		    dcont->firstBootstrapSeq =
trickles-server_2.c:24254:		      htonl (scont->firstBootstrapSeq);
trickles-server_2.c:24255:		    dcont->startCwnd = htonl (scont->startCwnd);
trickles-server_2.c:24256:		    dcont->ssthresh = htonl (scont->ssthresh);
trickles-server_2.c:24257:		    dcont->TCPBase = htonl (scont->TCPBase);
trickles-server_2.c:24258:		    dcont->tokenCounterBase = scont->tokenCounterBase;
trickles-server_2.c:24262:			 __constant_memcpy ((dcont->mac), (scont->mac),
trickles-server_2.c:24263:					    (16)) : __memcpy ((dcont->mac),
trickles-server_2.c:24264:							      (scont->mac),
trickles-server_2.c:24280:		    dproof->numSacks = (
trickles-server_2.c:24282:					 typeof (sproof->numSacks) Z =
trickles-server_2.c:24283:					 (typeof (sproof->numSacks)) (64);
trickles-server_2.c:24286:					   const typeof (sproof->
trickles-server_2.c:24288:					   (sproof->numSacks);
trickles-server_2.c:24294:		    for (i = 0; i < dproof->numSacks; i++)
trickles-server_2.c:24296:			dproof->sacks[i].left =
trickles-server_2.c:24297:			  htonl (sproof->sacks[i].left);;
trickles-server_2.c:24298:			dproof->sacks[i].right =
trickles-server_2.c:24299:			  htonl (sproof->sacks[i].right);;
trickles-server_2.c:24300:			dproof->sacks[i].nonceSummary =
trickles-server_2.c:24301:			  sproof->sacks[i].nonceSummary;
trickles-server_2.c:24325:			    ((!(((skb->sk)->tp_pinfo.af_tcp.
trickles-server_2.c:24327:				&& !((skb->sk)->tp_pinfo.af_tcp.
trickles-server_2.c:24328:				     trickles_opt & (skb->sk)->tp_pinfo.
trickles-server_2.c:24333:			    phdr->seq = scont->seq;
trickles-server_2.c:24334:			    phdr->type = scont->continuationType;
trickles-server_2.c:24335:			    phdr->first = scont->firstChild;
trickles-server_2.c:24336:			    phdr->serverAddr = skb->nh.iph->daddr;
trickles-server_2.c:24337:			    phdr->serverPort = skb->h.th->dest;
trickles-server_2.c:24338:			    phdr->clientAddr = skb->nh.iph->saddr;
trickles-server_2.c:24339:			    phdr->clientPort = skb->h.th->source;
trickles-server_2.c:24340:			    computeMAC (skb->sk, phdr, scont, mac);
trickles-server_2.c:24341:			    if (__builtin_memcmp (mac, scont->mac, 16))
trickles-server_2.c:24349:		    dcont->continuationType = scont->continuationType;
trickles-server_2.c:24350:		    dcont->seq = ntohl (scont->seq);;
trickles-server_2.c:24351:		    dcont->clientState = scont->clientState;
trickles-server_2.c:24352:		    dcont->parent = scont->parent;
trickles-server_2.c:24353:		    dcont->rawTimestamp = scont->timestamp;
trickles-server_2.c:24354:		    dcont->timestamp = ntohl (scont->timestamp);
trickles-server_2.c:24355:		    dcont->rawMrtt = scont->mrtt;
trickles-server_2.c:24356:		    dcont->mrtt = ntohl (scont->mrtt);;
trickles-server_2.c:24357:		    dcont->clientTimestamp = scont->clientTimestamp;
trickles-server_2.c:24358:		    dcont->state = scont->state;
trickles-server_2.c:24359:		    dcont->firstChild = scont->firstChild;
trickles-server_2.c:24360:		    dcont->firstLoss = ntohl (scont->firstLoss);;
trickles-server_2.c:24361:		    dcont->firstBootstrapSeq =
trickles-server_2.c:24362:		      ntohl (scont->firstBootstrapSeq);;
trickles-server_2.c:24363:		    dcont->startCwnd = ntohl (scont->startCwnd);;
trickles-server_2.c:24364:		    dcont->ssthresh = ntohl (scont->ssthresh);;
trickles-server_2.c:24365:		    dcont->TCPBase = ntohl (scont->TCPBase);;
trickles-server_2.c:24367:			((!(((skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:24368:			    && !((skb->sk)->tp_pinfo.af_tcp.
trickles-server_2.c:24369:				 trickles_opt & (skb->sk)->tp_pinfo.af_tcp.
trickles-server_2.c:24372:			dcont->saddr = skb->nh.iph->daddr;
trickles-server_2.c:24373:			dcont->daddr = skb->nh.iph->saddr;
trickles-server_2.c:24374:			dcont->source = skb->h.th->dest;
trickles-server_2.c:24375:			dcont->dest = skb->h.th->source;
trickles-server_2.c:24377:		    dcont->tokenCounterBase = scont->tokenCounterBase;
trickles-server_2.c:24378:		    dcont->num_packets = 0;
trickles-server_2.c:24379:		    dcont->numChildrenReceived = 0;
trickles-server_2.c:24380:		    dcont->parentMSK = ((void *) 0);;
trickles-server_2.c:24402:			    ((!(((skb->sk)->tp_pinfo.af_tcp.
trickles-server_2.c:24404:				&& !((skb->sk)->tp_pinfo.af_tcp.
trickles-server_2.c:24405:				     trickles_opt & (skb->sk)->tp_pinfo.
trickles-server_2.c:24410:			    phdr->seq = scont->seq;
trickles-server_2.c:24411:			    phdr->type = scont->continuationType;
trickles-server_2.c:24412:			    phdr->first = scont->firstChild;
trickles-server_2.c:24413:			    phdr->serverAddr = skb->nh.iph->daddr;
trickles-server_2.c:24414:			    phdr->serverPort = skb->h.th->dest;
trickles-server_2.c:24415:			    phdr->clientAddr = skb->nh.iph->saddr;
trickles-server_2.c:24416:			    phdr->clientPort = skb->h.th->source;
trickles-server_2.c:24417:			    computeMAC (skb->sk, phdr, scont, mac);
trickles-server_2.c:24418:			    if (__builtin_memcmp (mac, scont->mac, 16))
trickles-server_2.c:24426:		    dcont->continuationType = scont->continuationType;
trickles-server_2.c:24427:		    dcont->seq = ntohl (scont->seq);;
trickles-server_2.c:24428:		    dcont->clientState = scont->clientState;
trickles-server_2.c:24429:		    dcont->parent = scont->parent;
trickles-server_2.c:24430:		    dcont->rawTimestamp = scont->timestamp;
trickles-server_2.c:24431:		    dcont->rawMrtt = scont->mrtt;;
trickles-server_2.c:24432:		    dcont->clientTimestamp = scont->clientTimestamp;
trickles-server_2.c:24433:		    dcont->state = scont->state;
trickles-server_2.c:24434:		    dcont->firstChild = scont->firstChild;
trickles-server_2.c:24435:		    dcont->firstLoss = ntohl (scont->firstLoss);;
trickles-server_2.c:24436:		    dcont->firstBootstrapSeq =
trickles-server_2.c:24437:		      ntohl (scont->firstBootstrapSeq);;
trickles-server_2.c:24438:		    dcont->startCwnd = ntohl (scont->startCwnd);;
trickles-server_2.c:24439:		    dcont->ssthresh = ntohl (scont->ssthresh);;
trickles-server_2.c:24440:		    dcont->TCPBase = ntohl (scont->TCPBase);;
trickles-server_2.c:24441:		    dcont->daddr = skb->nh.iph->saddr;
trickles-server_2.c:24442:		    dcont->dest = skb->h.th->source;;
trickles-server_2.c:24443:		    dcont->tokenCounterBase = scont->tokenCounterBase;
trickles-server_2.c:24444:		    dcont->num_packets = 0;;
trickles-server_2.c:24460:		    dcont->continuationType = scont->continuationType;
trickles-server_2.c:24461:		    dcont->seq = scont->seq;
trickles-server_2.c:24462:		    dcont->clientState = scont->clientState;
trickles-server_2.c:24463:		    dcont->parent = scont->parent;
trickles-server_2.c:24464:		    dcont->rawTimestamp = scont->rawTimestamp;
trickles-server_2.c:24465:		    dcont->timestamp = ntohl (scont->rawTimestamp);
trickles-server_2.c:24466:		    dcont->rawMrtt = scont->rawMrtt;
trickles-server_2.c:24467:		    dcont->mrtt = ntohl (scont->rawMrtt);;
trickles-server_2.c:24468:		    dcont->clientTimestamp = scont->clientTimestamp;
trickles-server_2.c:24469:		    dcont->state = scont->state;
trickles-server_2.c:24470:		    dcont->firstChild = scont->firstChild;
trickles-server_2.c:24471:		    dcont->firstLoss = scont->firstLoss;
trickles-server_2.c:24472:		    dcont->firstBootstrapSeq = scont->firstBootstrapSeq;
trickles-server_2.c:24473:		    dcont->startCwnd = scont->startCwnd;
trickles-server_2.c:24474:		    dcont->ssthresh = scont->ssthresh;
trickles-server_2.c:24475:		    dcont->TCPBase = scont->TCPBase;
trickles-server_2.c:24476:		    dcont->saddr = sk->saddr;
trickles-server_2.c:24477:		    dcont->source = sk->sport;
trickles-server_2.c:24478:		    dcont->daddr = scont->daddr;
trickles-server_2.c:24479:		    dcont->dest = scont->dest;;
trickles-server_2.c:24480:		    dcont->tokenCounterBase = scont->tokenCounterBase;
trickles-server_2.c:24481:		    dcont->num_packets = 0;;
trickles-server_2.c:24482:		    dcont->pmsk = scont;
trickles-server_2.c:24483:		    dcont->num_packets = scont->num_packets;
trickles-server_2.c:24484:		    dcont->ucont_data = scont->ucont_data;
trickles-server_2.c:24485:		    dcont->ucont_len = scont->ucont_len;
trickles-server_2.c:24486:		    dcont->input = scont->input;
trickles-server_2.c:24487:		    dcont->input_len = scont->input_len;
trickles-server_2.c:24488:		    dcont->packets = scont->packets;;
trickles-server_2.c:24504:		    dcont->continuationType = scont->continuationType;
trickles-server_2.c:24505:		    dcont->seq = scont->seq;
trickles-server_2.c:24506:		    dcont->clientState = scont->clientState;
trickles-server_2.c:24507:		    dcont->parent = scont->parent;
trickles-server_2.c:24508:		    dcont->rawTimestamp = scont->rawTimestamp;
trickles-server_2.c:24509:		    dcont->rawMrtt = scont->rawMrtt;;
trickles-server_2.c:24510:		    dcont->clientTimestamp = scont->clientTimestamp;
trickles-server_2.c:24511:		    dcont->state = scont->state;
trickles-server_2.c:24512:		    dcont->firstChild = scont->firstChild;
trickles-server_2.c:24513:		    dcont->firstLoss = scont->firstLoss;
trickles-server_2.c:24514:		    dcont->firstBootstrapSeq = scont->firstBootstrapSeq;
trickles-server_2.c:24515:		    dcont->startCwnd = scont->startCwnd;
trickles-server_2.c:24516:		    dcont->ssthresh = scont->ssthresh;
trickles-server_2.c:24517:		    dcont->TCPBase = scont->TCPBase;
trickles-server_2.c:24518:		    dcont->daddr = scont->daddr;
trickles-server_2.c:24519:		    dcont->dest = scont->dest;;
trickles-server_2.c:24520:		    dcont->tokenCounterBase = scont->tokenCounterBase;
trickles-server_2.c:24521:		    dcont->num_packets = 0;;
trickles-server_2.c:24522:		    dcont->num_packets = scont->num_packets;
trickles-server_2.c:24523:		    dcont->ucont_data = scont->ucont_data;
trickles-server_2.c:24524:		    dcont->ucont_len = scont->ucont_len;
trickles-server_2.c:24525:		    dcont->input = scont->input;
trickles-server_2.c:24526:		    dcont->input_len = scont->input_len;
trickles-server_2.c:24527:		    dcont->packets = scont->packets;;
trickles-server_2.c:24549:			 __constant_memcpy ((dcont->mac), (scont->mac),
trickles-server_2.c:24550:					    (16)) : __memcpy ((dcont->mac),
trickles-server_2.c:24551:							      (scont->mac),
trickles-server_2.c:24555:		    dcont->continuationType = scont->continuationType;
trickles-server_2.c:24556:		    dcont->seq = ntohl (scont->seq);;
trickles-server_2.c:24557:		    dcont->clientState = scont->clientState;
trickles-server_2.c:24558:		    dcont->parent = scont->parent;
trickles-server_2.c:24559:		    dcont->rawTimestamp = scont->timestamp;
trickles-server_2.c:24560:		    dcont->timestamp = ntohl (scont->timestamp);
trickles-server_2.c:24561:		    dcont->rawMrtt = scont->mrtt;
trickles-server_2.c:24562:		    dcont->mrtt = ntohl (scont->mrtt);;
trickles-server_2.c:24563:		    dcont->clientTimestamp = scont->clientTimestamp;
trickles-server_2.c:24564:		    dcont->state = scont->state;
trickles-server_2.c:24565:		    dcont->firstChild = scont->firstChild;
trickles-server_2.c:24566:		    dcont->firstLoss = ntohl (scont->firstLoss);;
trickles-server_2.c:24567:		    dcont->firstBootstrapSeq =
trickles-server_2.c:24568:		      ntohl (scont->firstBootstrapSeq);;
trickles-server_2.c:24569:		    dcont->startCwnd = ntohl (scont->startCwnd);;
trickles-server_2.c:24570:		    dcont->ssthresh = ntohl (scont->ssthresh);;
trickles-server_2.c:24571:		    dcont->TCPBase = ntohl (scont->TCPBase);;
trickles-server_2.c:24573:			((!(((skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:24574:			    && !((skb->sk)->tp_pinfo.af_tcp.
trickles-server_2.c:24575:				 trickles_opt & (skb->sk)->tp_pinfo.af_tcp.
trickles-server_2.c:24578:			dcont->saddr = skb->nh.iph->daddr;
trickles-server_2.c:24579:			dcont->daddr = skb->nh.iph->saddr;
trickles-server_2.c:24580:			dcont->source = skb->h.th->dest;
trickles-server_2.c:24581:			dcont->dest = skb->h.th->source;
trickles-server_2.c:24583:		    dcont->tokenCounterBase = scont->tokenCounterBase;
trickles-server_2.c:24584:		    dcont->num_packets = 0;
trickles-server_2.c:24585:		    dcont->numChildrenReceived = 0;
trickles-server_2.c:24586:		    dcont->parentMSK = ((void *) 0);;
trickles-server_2.c:24607:		    for (i = 0; i < (((cont) + 1)->num_packets); i++)
trickles-server_2.c:24609:			total += (((cont) + 1)->packets)[i].len;
trickles-server_2.c:24654:		    rval->prev = rval->next = ((void *) 0);
trickles-server_2.c:24655:		    rval->list = ((void *) 0);
trickles-server_2.c:24662:			(rval + i)->ucont_len = 0;
trickles-server_2.c:24663:			(rval + i)->ucont_data = ((void *) 0);
trickles-server_2.c:24664:			(rval + i)->input_len = 0;
trickles-server_2.c:24665:			(rval + i)->input = ((void *) 0);
trickles-server_2.c:24667:			(rval + i)->mark = 0;
trickles-server_2.c:24668:			(rval + i)->simulated = 0;
trickles-server_2.c:24670:		    rval->sk = ((void *) 0);
trickles-server_2.c:24707:		    rval->prev = rval->next = ((void *) 0);
trickles-server_2.c:24708:		    rval->list = ((void *) 0);
trickles-server_2.c:24711:		     ((int) ((struct cminisock *) 0)->
trickles-server_2.c:24717:								   *) 0)->
trickles-server_2.c:24720:				 ((int) ((struct cminisock *) 0)->
trickles-server_2.c:24725:			(rval + i)->ucont_len = 0;
trickles-server_2.c:24726:			(rval + i)->ucont_data = ((void *) 0);
trickles-server_2.c:24728:			(rval + i)->input_len = 0;
trickles-server_2.c:24729:			(rval + i)->input = ((void *) 0);
trickles-server_2.c:24731:			(rval + i)->mark = 0;
trickles-server_2.c:24732:			(rval + i)->simulated = 0;
trickles-server_2.c:24733:			(rval + i)->num_packets = 0;
trickles-server_2.c:24734:			(rval + i)->actualCwnd = 0;
trickles-server_2.c:24748:		    if (cont->list)
trickles-server_2.c:24764:			if ((cont + i)->ucont_data)
trickles-server_2.c:24765:			  kfree ((cont + i)->ucont_data);
trickles-server_2.c:24766:			if ((cont + i)->input)
trickles-server_2.c:24767:			  kfree ((cont + i)->input);
trickles-server_2.c:24782:		    cell->start = start;
trickles-server_2.c:24783:		    cell->end = end;
trickles-server_2.c:24794:		    printk ("cell[%d-%d] ", cell->start, cell->end);
trickles-server_2.c:24801:		    unsigned left = ({ typeof (c0->start) Z =
trickles-server_2.c:24802:				     (typeof (c0->start)) (start);
trickles-server_2.c:24805:				       const typeof (c0->start) _x =
trickles-server_2.c:24806:				       (c0->start);
trickles-server_2.c:24812:		    unsigned right = ({ typeof (c0->end) Z =
trickles-server_2.c:24813:				      (typeof (c0->end)) (end);
trickles-server_2.c:24816:					const typeof (c0->end) _x = (c0->end);
trickles-server_2.c:24828:		    return SkipCell_intersectRange (c0, c1->start, c1->end);
trickles-server_2.c:24834:		    return c0->start == c1->start && c0->end == c1->end;
trickles-server_2.c:24840:		    struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_2.c:24841:		    struct alloc_head_list *list = &tp->t.skipList;
trickles-server_2.c:24852:			  (struct SkipCell *) list->next;
trickles-server_2.c:24853:			if (cell->end <= next->start)
trickles-server_2.c:24868:			    for (next = (typeof (next)) (list)->next;
trickles-server_2.c:24870:				 next = (typeof (next)) next->next)
trickles-server_2.c:24875:				    if (prev->end <= cell->start &&
trickles-server_2.c:24876:					cell->end <= next->start)
trickles-server_2.c:24882:				    if (cell->start >= next->start)
trickles-server_2.c:24910:			if ((prev->end <= cell->start &&
trickles-server_2.c:24992:		    dproof->numSacks = sproof->numSacks;
trickles-server_2.c:24993:		    for (i = 0; i < sproof->numSacks; i++)
trickles-server_2.c:24995:			dproof->sacks[i].left =
trickles-server_2.c:24996:			  ntohl (sproof->sacks[i].left);;
trickles-server_2.c:24997:			dproof->sacks[i].right =
trickles-server_2.c:24998:			  ntohl (sproof->sacks[i].right);;
trickles-server_2.c:24999:			dproof->sacks[i].nonceSummary =
trickles-server_2.c:25000:			  sproof->sacks[i].nonceSummary;
trickles-server_2.c:25011:		      length - sizeof (struct WireUC_Continuation);
trickles-server_2.c:25022:		    rval->prev = rval->next = ((void *) 0);
trickles-server_2.c:25023:		    rval->list = ((void *) 0);
trickles-server_2.c:25025:		    rval->seq = ntohl (scont->seq);
trickles-server_2.c:25026:		    rval->validStart = ntohl (scont->validStart);
trickles-server_2.c:25027:		    rval->validEnd = ntohl (scont->validEnd);
trickles-server_2.c:25029:		    rval->FIN_received = 0;
trickles-server_2.c:25030:		    rval->FINHint = 0;
trickles-server_2.c:25031:		    rval->FINHintPosition = 0xffffffff;
trickles-server_2.c:25033:		    rval->fields = scont->fields;
trickles-server_2.c:25034:		    rval->dataLen = dataLen;
trickles-server_2.c:25035:		    rval->kernel.obsoleteAt = rval->validEnd;
trickles-server_2.c:25037:		     __constant_memcpy ((rval->kernel.data), (scont->data),
trickles-server_2.c:25038:					(dataLen)) : __memcpy ((rval->kernel.
trickles-server_2.c:25040:							       (scont->data),
trickles-server_2.c:25049:		    cont->FIN_received = 1;
trickles-server_2.c:25050:		    cont->FINHint = 1;
trickles-server_2.c:25051:		    cont->FINHintPosition = finPosition;
trickles-server_2.c:25052:		    if (!(finPosition <= cont->kernel.obsoleteAt))
trickles-server_2.c:25055:				"finPosition <= cont->kernel.obsoleteAt"
trickles-server_2.c:25061:			    cont->kernel.obsoleteAt, finPosition);
trickles-server_2.c:25062:		    cont->kernel.obsoleteAt = finPosition;
trickles-server_2.c:25069:		    if (cont->FINHint)
trickles-server_2.c:25074:		    if (!cont->FIN_received)
trickles-server_2.c:25076:			cont->FINHint = 1;
trickles-server_2.c:25077:			cont->FINHintPosition = finHintPosition;
trickles-server_2.c:25089:		    if (cont->FINHint)
trickles-server_2.c:25091:			if (!(cont->FINHintPosition <= cont->validEnd))
trickles-server_2.c:25094:				    "cont->FINHintPosition <= cont->validEnd"
trickles-server_2.c:25099:			return cont->FINHintPosition;
trickles-server_2.c:25103:			return cont->validEnd;
trickles-server_2.c:25111:		    if (cont->FIN_received)
trickles-server_2.c:25113:			return cont->FINHintPosition;
trickles-server_2.c:25117:			return cont->validEnd;
trickles-server_2.c:25126:			(cont->validStart <= position
trickles-server_2.c:25127:			 && position < cont->validEnd))
trickles-server_2.c:25130:				"cont->validStart <= position && position < cont->validEnd"
trickles-server_2.c:25136:		      position < cont->validEnd;
trickles-server_2.c:25146:		    int dataLen = scont->dataLen;
trickles-server_2.c:25147:		    dcont->seq = htonl (scont->seq);
trickles-server_2.c:25148:		    dcont->validStart = htonl (scont->validStart);
trickles-server_2.c:25149:		    dcont->validEnd = htonl (scont->validEnd);
trickles-server_2.c:25150:		    dcont->fields = scont->fields;
trickles-server_2.c:25152:		     __constant_memcpy ((dcont->data), (scont->kernel.data),
trickles-server_2.c:25153:					(dataLen)) : __memcpy ((dcont->data),
trickles-server_2.c:25154:							       (scont->kernel.
trickles-server_2.c:25178:		    completeResp->fields |= (0x01);
trickles-server_2.c:25187:		    int dataLen = scont->dataLen;
trickles-server_2.c:25197:		    rval->prev = rval->next = ((void *) 0);
trickles-server_2.c:25198:		    rval->list = ((void *) 0);
trickles-server_2.c:25201:		     __constant_memcpy ((rval->kernel.data),
trickles-server_2.c:25202:					(scont->kernel.data),
trickles-server_2.c:25203:					(dataLen)) : __memcpy ((rval->kernel.
trickles-server_2.c:25205:							       (scont->kernel.
trickles-server_2.c:25248:		    return -1;
trickles-server_2.c:25313:		    return -1;
trickles-server_2.c:25324:		    wireContinuation->fields = 0;
trickles-server_2.c:25331:		    char *rval = wireContinuation->data;
trickles-server_2.c:25333:		    if (wireContinuation->fields & (0x01))
trickles-server_2.c:25348:		    if (wireContinuation->fields & ~((0x01)))
trickles-server_2.c:25374:		    resp->type = type;
trickles-server_2.c:25375:		    resp->error = error;
trickles-server_2.c:25376:		    resp->len = htons ((short) len);
trickles-server_2.c:25394:		    incompleteResp->ack_seq = htonl (ack_seq);
trickles-server_2.c:25395:		    incompleteResp->newCont.validStart = htonl (validStart);
trickles-server_2.c:25414:		    completeResp->ack_seq = htonl (ack_seq);
trickles-server_2.c:25415:		    completeResp->newCont.seq = htonl (seq);
trickles-server_2.c:25416:		    completeResp->newCont.validStart = htonl (validStart);
trickles-server_2.c:25417:		    completeResp->newCont.validEnd = htonl (validEnd);
trickles-server_2.c:25418:		    completeResp->newCont.fields = 0;
trickles-server_2.c:25438:		    newContinuationResp->newCont.seq = htonl (seq);
trickles-server_2.c:25439:		    newContinuationResp->newCont.validStart =
trickles-server_2.c:25441:		    newContinuationResp->newCont.validEnd = htonl (validEnd);
trickles-server_2.c:25442:		    newContinuationResp->newCont.fields = 0;
trickles-server_2.c:25450:		    printk ("{ seq=[%d]\n", ucont->seq);
trickles-server_2.c:25451:		    printk ("valid=[%d-%d] [%d-%d]\n", ucont->validStart,
trickles-server_2.c:25452:			    ucont->validEnd, htonl (ucont->validStart),
trickles-server_2.c:25453:			    htonl (ucont->validEnd));
trickles-server_2.c:25454:		    printk ("cvalid=[%d-%d] [%d-%d] }\n",
trickles-server_2.c:25455:			    ucont->clientValidStart, ucont->clientValidEnd,
trickles-server_2.c:25456:			    htonl (ucont->clientValidStart),
trickles-server_2.c:25457:			    htonl (ucont->clientValidEnd));
trickles-server_2.c:25472:		    chunk->byteNum = htonl (byteNum);
trickles-server_2.c:25473:		    chunk->type = RCHUNK_DATA;
trickles-server_2.c:25474:		    chunk->flags = 0;
trickles-server_2.c:25475:		    chunk->chunkLen =
trickles-server_2.c:25478:		    return (struct DataChunk *) (chunk->data + chunkLen);
trickles-server_2.c:25487:		    schunk->type = RCHUNK_SKIP;
trickles-server_2.c:25488:		    chunk->flags = 0;
trickles-server_2.c:25489:		    schunk->chunkLen = htons (len =
trickles-server_2.c:25491:		    schunk->byteNum = htonl (byteNum);
trickles-server_2.c:25492:		    schunk->len = htonl (skipLen);
trickles-server_2.c:25503:		    shchunk->type = RCHUNK_FINHINT;
trickles-server_2.c:25504:		    chunk->flags = 0;
trickles-server_2.c:25505:		    shchunk->chunkLen = htons (len =
trickles-server_2.c:25507:		    shchunk->byteNum = htonl (byteNum);
trickles-server_2.c:25508:		    shchunk->len = htonl (skipLen);
trickles-server_2.c:25518:		    phchunk->type = RCHUNK_PUSH_HINT;
trickles-server_2.c:25519:		    chunk->flags = 0;
trickles-server_2.c:25520:		    phchunk->chunkLen = htons (sizeof (struct PushHintChunk));
trickles-server_2.c:25521:		    phchunk->start = htonl (start);
trickles-server_2.c:25522:		    phchunk->end = htonl (end);
trickles-server_2.c:25547:		    ctx->packetNum = 0;
trickles-server_2.c:25548:		    ctx->packetPos = 0;
trickles-server_2.c:25549:		    ctx->outputPos = ctx->outputStart = dest;
trickles-server_2.c:25550:		    ctx->packets = packets;
trickles-server_2.c:25551:		    ctx->numPackets = numPackets;
trickles-server_2.c:25560:		    for (i = 0; i < ctx->numPackets; i++)
trickles-server_2.c:25562:			printk ("Packet [%d] = %d\n", i, ctx->packets[i].len);
trickles-server_2.c:25572:		       ctx->packetNum, ctx->packetPos, ctx->outputPos,
trickles-server_2.c:25573:		       ctx->numPackets, ctx->packets);
trickles-server_2.c:25581:		    if (ctx->packetNum >= ctx->numPackets)
trickles-server_2.c:25585:		    return ctx->packets[ctx->packetNum].len - ctx->packetPos;
trickles-server_2.c:25594:		      return ctx->outputPos;
trickles-server_2.c:25598:			if (ctx->packetNum >= ctx->numPackets)
trickles-server_2.c:25605:		    if (!(ctx->packetNum <= ctx->numPackets))
trickles-server_2.c:25607:			if (!(ctx->packetNum <= ctx->numPackets))
trickles-server_2.c:25610:				    "ctx->packetNum <= ctx->numPackets"
trickles-server_2.c:25615:			printk ("%d !<= %d\n", ctx->packetNum,
trickles-server_2.c:25616:				ctx->numPackets);
trickles-server_2.c:25627:			if (!(numBytes <= ctx->packets[ctx->packetNum].len))
trickles-server_2.c:25630:				    "numBytes <= ctx->packets[ctx->packetNum].len"
trickles-server_2.c:25635:			ctx->outputPos +=
trickles-server_2.c:25636:			  ctx->packets[ctx->packetNum].len - ctx->packetPos;
trickles-server_2.c:25637:			ctx->packetPos = 0;
trickles-server_2.c:25638:			ctx->packetNum++;
trickles-server_2.c:25640:		    temp = ctx->outputPos;
trickles-server_2.c:25641:		    ctx->packetPos += numBytes;
trickles-server_2.c:25642:		    ctx->outputPos += numBytes;
trickles-server_2.c:25646:			if (ctx->packetNum >= ctx->numPackets)
trickles-server_2.c:25653:		    if (!(ctx->packetPos <= ctx->packets[ctx->packetNum].len))
trickles-server_2.c:25656:				"ctx->packetPos <= ctx->packets[ctx->packetNum].len"
trickles-server_2.c:25662:		    if (ctx->packetPos == ctx->packets[ctx->packetNum].len)
trickles-server_2.c:25664:			ctx->packetPos = 0;
trickles-server_2.c:25665:			ctx->packetNum++;
trickles-server_2.c:25681:		    char *currpos = ctx->outputPos;
trickles-server_2.c:25719:		    char *currpos = ctx->outputPos;
trickles-server_2.c:25760:			return -1;
trickles-server_2.c:25774:		    while ((char *) (chunk + 1) - start < len)
trickles-server_2.c:25777:			  ntohs ((chunk)->chunkLen) -
trickles-server_2.c:25782:			      printk ("bad length chunk(%d) -- ", len);
trickles-server_2.c:25794:				     ntohs ((chunk)->chunkLen)));
trickles-server_2.c:25803:			    return -1;
trickles-server_2.c:25806:		    if ((char *) chunk - start > len)
trickles-server_2.c:25809:				(char *) chunk - start, len);
trickles-server_2.c:25810:			return -chunknum - 1;
trickles-server_2.c:25826:		    if (!(gctx->packetNum <= gctx->numPackets))
trickles-server_2.c:25829:				"gctx->packetNum <= gctx->numPackets"
trickles-server_2.c:25838:		    int outputLen = gctx->outputPos - gctx->outputStart;
trickles-server_2.c:25839:		    char *buf = gctx->outputStart;
trickles-server_2.c:25848:			(entry->prev == ((void *) 0)
trickles-server_2.c:25849:			 && entry->next == ((void *) 0)
trickles-server_2.c:25850:			 && entry->list == ((void *) 0)))
trickles-server_2.c:25853:				"entry->prev == NULL && entry->next == NULL && entry->list == NULL"
trickles-server_2.c:25859:		    freeClientSide_Continuation (entry->cont);
trickles-server_2.c:25875:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-server_2.c:25876:		    tp->trickles_opt = 0;
trickles-server_2.c:25877:		    tp->mac_changed = 0;
trickles-server_2.c:25883:			  ((sizeof (tp->cminisock_api_config))) ?
trickles-server_2.c:25884:			  __constant_c_and_count_memset (((&tp->
trickles-server_2.c:25890:							   (tp->
trickles-server_2.c:25893:			  __constant_c_memset (((&tp->cminisock_api_config)),
trickles-server_2.c:25897:						 (tp->
trickles-server_2.c:25900:			  ((sizeof (tp->cminisock_api_config))) ?
trickles-server_2.c:25901:			  __memset_generic ((((&tp->cminisock_api_config))),
trickles-server_2.c:25904:					       (tp->
trickles-server_2.c:25906:			  __memset_generic (((&tp->cminisock_api_config)),
trickles-server_2.c:25909:					      (tp->cminisock_api_config))))));
trickles-server_2.c:25910:		      init_head (&tp->cminisock_api_config.msk_freelist);
trickles-server_2.c:25912:		      tp->cminisock_api_config.cfg.ctl = ((void *) 0);
trickles-server_2.c:25914:		      tp->cminisock_api_config.event_lock = (rwlock_t)
trickles-server_2.c:25919:		    tp->t.malloc_initialized = 0;
trickles-server_2.c:25921:		    tp->t.heapbytesize = 0;
trickles-server_2.c:25922:		    tp->t.heapbytesallocated = 0;
trickles-server_2.c:25926:			tp->t.fragblocks[i] = 0;
trickles-server_2.c:25927:			tp->t.fraghead[i].next = tp->t.fraghead[i].prev =
trickles-server_2.c:25931:		    tp->t.clientStateCounter = 0;
trickles-server_2.c:25932:		    tp->t.state = 1;
trickles-server_2.c:25933:		    tp->t.A = 0;
trickles-server_2.c:25934:		    tp->t.D = 0;
trickles-server_2.c:25935:		    tp->t.RTO = 0;
trickles-server_2.c:25936:		    tp->t.timerState = 0;
trickles-server_2.c:25937:		    tp->t.rcv_nxt = 0;
trickles-server_2.c:25938:		    tp->t.previous_base = 0;
trickles-server_2.c:25939:		    skb_queue_head_init (&tp->t.ofo_queue);
trickles-server_2.c:25941:		    tp->t.ack_prev = ((void *) 0);
trickles-server_2.c:25943:		    tp->t.ack_last = 0;
trickles-server_2.c:25944:		    tp->t.oo_count = 0;
trickles-server_2.c:25945:		    tp->t.in_flight = 0;
trickles-server_2.c:25947:		    tp->t.standardProof.numSacks = 0;
trickles-server_2.c:25948:		    tp->t.altProof.numSacks = 0;
trickles-server_2.c:25951:		    tp->t.dprev = tp->t.dnext = ((void *) 0);
trickles-server_2.c:25952:		    tp->t.dbg_skb = ((void *) 0);
trickles-server_2.c:25953:		    init_head (&tp->t.cont_list);
trickles-server_2.c:25955:		    init_timer (&tp->t.slowstart_timer);
trickles-server_2.c:25959:		    tp->t.request_rcv_nxt = 0;
trickles-server_2.c:25960:		    tp->t.request_snd_nxt = 0;
trickles-server_2.c:25961:		    init_head (&tp->t.request_ofo_queue);
trickles-server_2.c:25962:		    skb_queue_head_init (&tp->t.data_ofo_queue);
trickles-server_2.c:25963:		    init_head (&tp->t.sentRequests);
trickles-server_2.c:25964:		    init_head (&tp->t.queuedRequests);
trickles-server_2.c:25966:		    init_head (&tp->t.dataRequestMap);
trickles-server_2.c:25967:		    init_head (&tp->t.missingDataMap);
trickles-server_2.c:25968:		    init_head (&tp->t.skipList);
trickles-server_2.c:25970:		    tp->t.byteReqNext = 0;
trickles-server_2.c:25971:		    tp->t.byteReqHint = ((void *) 0);
trickles-server_2.c:25972:		    tp->t.byteRcvNxt = 0;
trickles-server_2.c:25976:		    tp->t.conversionState = (1);
trickles-server_2.c:25977:		    tp->t.snd_una = tp->t.write_seq = 0;
trickles-server_2.c:25978:		    tp->t.snd_end = 0;
trickles-server_2.c:25979:		    skb_queue_head_init (&tp->t.requestBytes);
trickles-server_2.c:25980:		    tp->t.newIncompleteRequest = ((void *) 0);
trickles-server_2.c:25981:		    tp->t.prevConvCont = ((void *) 0);
trickles-server_2.c:25983:		    init_head (&tp->t.ucontList);
trickles-server_2.c:25984:		    init_head (&tp->t.depNodeList);
trickles-server_2.c:25990:		    tp->t.nonceCTX = ((void *) 0);
trickles-server_2.c:25991:		    skb_queue_head_init (&tp->t.prequeueOverflow);
trickles-server_2.c:25992:		    skb_queue_head_init (&tp->t.sendAckOverflow);
trickles-server_2.c:25993:		    skb_queue_head_init (&tp->t.recycleList);
trickles-server_2.c:25995:		    tp->t.responseMSK = ((void *) 0);
trickles-server_2.c:25996:		    init_head (&tp->t.responseList);
trickles-server_2.c:25997:		    tp->t.responseCount = 0;
trickles-server_2.c:25999:		    tp->t.events = ((void *) 0);
trickles-server_2.c:26000:		    tp->drop_rate = 0;
trickles-server_2.c:26001:		    tp->instrumentation = 0;
trickles-server_2.c:26219:		    msk->num_packets = 0;
trickles-server_2.c:26220:		    msk->ucont_len = 0;
trickles-server_2.c:26221:		    msk->ucont_data = ((void *) 0);
trickles-server_2.c:26222:		    msk->input_len = 0;
trickles-server_2.c:26223:		    msk->input = ((void *) 0);
trickles-server_2.c:26224:		    msk->packets = ((void *) 0);
trickles-server_2.c:26226:		    msk->refCnt = 1;
trickles-server_2.c:26228:		    msk->cacheRecycleIndex = -1;
trickles-server_2.c:26229:		    msk->serverSK = ((void *) 0);
trickles-server_2.c:26230:		    msk->pmsk = ((void *) 0);
trickles-server_2.c:26231:		    msk->isStatic = 0;
trickles-server_2.c:26237:		    msk->isStatic = 1;
trickles-server_2.c:26238:		    msk->prev = msk->next = ((void *) 0);
trickles-server_2.c:26239:		    msk->ctl = ALLOC_PENDING;
trickles-server_2.c:26244:		    pmsk->num_packets = 0;
trickles-server_2.c:26245:		    pmsk->ucont_len = 0;
trickles-server_2.c:26246:		    pmsk->ucont_data = ((void *) 0);
trickles-server_2.c:26247:		    pmsk->input_len = 0;
trickles-server_2.c:26248:		    pmsk->input = ((void *) 0);
trickles-server_2.c:26249:		    pmsk->packets = ((void *) 0);
trickles-server_2.c:26250:		    pmsk->refCnt = 1;
trickles-server_2.c:26251:		    pmsk->cacheRecycleIndex = -1;
trickles-server_2.c:26268:		    if (msk->num_packets > 0)
trickles-server_2.c:26270:			printk ("msk packets is %d\n", msk->num_packets);
trickles-server_2.c:26272:		    if (!(msk->num_packets == 0))
trickles-server_2.c:26274:			printk ("KERNEL: assertion (" "msk->num_packets == 0"
trickles-server_2.c:26289:			(((msk->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:26290:			 && !((msk->sk)->tp_pinfo.af_tcp.
trickles-server_2.c:26291:			      trickles_opt & (msk->sk)->tp_pinfo.af_tcp.
trickles-server_2.c:26294:			msk->packets =
trickles-server_2.c:26295:			  tmalloc (msk->sk,
trickles-server_2.c:26301:			if (msk->packets == ((void *) 0))
trickles-server_2.c:26316:			    msk->packets = packets[0];
trickles-server_2.c:26320:			    msk->packets = ((void *) 0);
trickles-server_2.c:26329:		    msk->num_packets = numPackets;
trickles-server_2.c:26335:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-server_2.c:26337:		      &tp->cminisock_api_config.msk_freelist;
trickles-server_2.c:26338:		    struct cminisock *curr = (struct cminisock *) head->next;
trickles-server_2.c:26340:			   && curr->ctl == ALLOC_PROCESSING)
trickles-server_2.c:26343:			curr = curr->next;
trickles-server_2.c:26351:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-server_2.c:26353:		      (struct list_link *) &tp->cminisock_api_config.
trickles-server_2.c:26356:		      (struct pminisock *) tp->cminisock_api_config.
trickles-server_2.c:26360:			(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:26361:			 && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
trickles-server_2.c:26365:			       pcurr->ctl == ALLOC_PROCESSING)
trickles-server_2.c:26368:			    pcurr = pcurr->next;
trickles-server_2.c:26386:		    rval->ctl = ALLOC_PENDING;
trickles-server_2.c:26397:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-server_2.c:26399:		      &tp->cminisock_api_config.msk_freelist;
trickles-server_2.c:26401:		      (struct cminisock *) tp->cminisock_api_config.
trickles-server_2.c:26405:			(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:26406:			 && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
trickles-server_2.c:26410:			       curr->ctl == ALLOC_PROCESSING)
trickles-server_2.c:26413:			    curr = curr->next;
trickles-server_2.c:26425:			rval->ctl = ALLOC_PENDING;
trickles-server_2.c:26429:			if (tp->t.responseCount == 0)
trickles-server_2.c:26431:			    rval = tp->t.responseMSK;
trickles-server_2.c:26432:			    rval->list = ((void *) 0);
trickles-server_2.c:26433:			    rval->next = rval->prev = ((void *) 0);
trickles-server_2.c:26445:			    rval->next = rval->prev = ((void *) 0);
trickles-server_2.c:26446:			    rval->list = ((void *) 0);
trickles-server_2.c:26447:			    insert_tail (&tp->t.responseList,
trickles-server_2.c:26450:			tp->t.responseCount++;
trickles-server_2.c:26452:			rval->sk = sk;
trickles-server_2.c:26453:			rval->ctl = ALLOC_PENDING;
trickles-server_2.c:26477:		    msk->refCnt++;
trickles-server_2.c:26488:			struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-server_2.c:26491:				tp->cminisock_api_config.msk_freelist.len);
trickles-server_2.c:26497:		    rval->refCnt = 1;
trickles-server_2.c:26498:		    rval->isStatic = 0;
trickles-server_2.c:26510:		    rval->num_packets = 0;
trickles-server_2.c:26511:		    rval->packets = ((void *) 0);
trickles-server_2.c:26512:		    rval->pmsk = ((void *) 0);
trickles-server_2.c:26513:		    if (rval->ucont_len > 0)
trickles-server_2.c:26515:			rval->ucont_data = tmalloc (sk, rval->ucont_len);
trickles-server_2.c:26516:			if (rval->ucont_data == ((void *) 0))
trickles-server_2.c:26520:			       rval->ucont_len);
trickles-server_2.c:26528:			rval->ucont_data = ((void *) 0);
trickles-server_2.c:26529:		    } if (rval->input_len > 0)
trickles-server_2.c:26531:			rval->input = tmalloc (sk, rval->input_len);
trickles-server_2.c:26532:			if (rval->input == ((void *) 0))
trickles-server_2.c:26536:			       "msk", rval->input_len);
trickles-server_2.c:26537:			    tfree (sk, rval->ucont_data);
trickles-server_2.c:26545:			rval->input = ((void *) 0);
trickles-server_2.c:26546:		    } if (rval->ucont_data)
trickles-server_2.c:26547:		      (__builtin_constant_p (rval->ucont_len) ?
trickles-server_2.c:26548:		       __constant_memcpy ((rval->ucont_data),
trickles-server_2.c:26549:					  (pmsk->ucont_data),
trickles-server_2.c:26550:					  (rval->
trickles-server_2.c:26551:					   ucont_len)) : __memcpy ((rval->
trickles-server_2.c:26553:								   (pmsk->
trickles-server_2.c:26555:								   (rval->
trickles-server_2.c:26557:		    if (rval->input)
trickles-server_2.c:26558:		      (__builtin_constant_p (rval->input_len) ?
trickles-server_2.c:26559:		       __constant_memcpy ((rval->input), (pmsk->input),
trickles-server_2.c:26560:					  (rval->
trickles-server_2.c:26561:					   input_len)) : __memcpy ((rval->
trickles-server_2.c:26563:								   (pmsk->
trickles-server_2.c:26565:								   (rval->
trickles-server_2.c:26573:			(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:26574:			 && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
trickles-server_2.c:26577:			if (msk->ctl == ALLOC_FREE
trickles-server_2.c:26578:			    || msk->ctl == ALLOC_PROCESSING)
trickles-server_2.c:26593:			if (msk->ctl == ALLOC_READY
trickles-server_2.c:26594:			    && msk->prev != ((void *) 0))
trickles-server_2.c:26598:			msk->ctl = ALLOC_PROCESSING;
trickles-server_2.c:26604:		    for (i = 0; i < msk->num_packets; i++)
trickles-server_2.c:26606:			if (msk->packets[i].ucontData != ((void *) 0))
trickles-server_2.c:26608:			    kfree (msk->packets[i].ucontData);
trickles-server_2.c:26612:			    (((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:26613:			       && !((sk)->tp_pinfo.af_tcp.
trickles-server_2.c:26614:				      trickles_opt & (sk)->tp_pinfo.af_tcp.
trickles-server_2.c:26615:				      trickles_opt & 0x8)) && msk->packets)
trickles-server_2.c:26617:			tfree (sk, msk->packets);
trickles-server_2.c:26618:			msk->packets = ((void *) 0);
trickles-server_2.c:26620:		    msk->num_packets = 0;
trickles-server_2.c:26621:		    if (msk->ucont_data != ((void *) 0))
trickles-server_2.c:26623:			tfree (sk, msk->ucont_data);
trickles-server_2.c:26624:			msk->ucont_data = ((void *) 0);
trickles-server_2.c:26626:		    msk->ucont_len = 0;
trickles-server_2.c:26627:		    if (msk->input != ((void *) 0))
trickles-server_2.c:26629:			tfree (sk, msk->input);
trickles-server_2.c:26630:			msk->input = ((void *) 0);
trickles-server_2.c:26632:		    msk->input_len = 0;
trickles-server_2.c:26636:		    msk->refCnt--;
trickles-server_2.c:26637:		    if (!(msk->refCnt <= 3))
trickles-server_2.c:26639:			printk ("KERNEL: assertion (" "msk->refCnt <= 3"
trickles-server_2.c:26644:		    if (msk->refCnt == 0)
trickles-server_2.c:26646:			struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-server_2.c:26648:			  &tp->cminisock_api_config.msk_freelist;
trickles-server_2.c:26650:			if (!msk->isStatic)
trickles-server_2.c:26653:				(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:26654:				 && !((sk)->tp_pinfo.af_tcp.
trickles-server_2.c:26655:				      trickles_opt & (sk)->tp_pinfo.af_tcp.
trickles-server_2.c:26660:				msk->ctl = ALLOC_FREE;
trickles-server_2.c:26664:				if (msk != tp->t.responseMSK)
trickles-server_2.c:26669:				tp->t.responseCount--;
trickles-server_2.c:26675:		    if (msk->pmsk != ((void *) 0))
trickles-server_2.c:26677:			struct pminisock *pmsk = msk->pmsk;
trickles-server_2.c:26686:			(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:26687:			 && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
trickles-server_2.c:26690:			if (msk->ctl != ALLOC_PROCESSING
trickles-server_2.c:26691:			    && msk->ctl != ALLOC_HALFFREE)
trickles-server_2.c:26694:			      ("(free_trickles_msk_finish %s) without corresponding free_trickles_msk: msk->ctl = %d\n",
trickles-server_2.c:26695:			       "msk", msk->ctl);
trickles-server_2.c:26713:		    msk->num_packets = 0;
trickles-server_2.c:26714:		    msk->packets = ((void *) 0);
trickles-server_2.c:26715:		    msk->ucont_len = 0;
trickles-server_2.c:26716:		    msk->ucont_data = ((void *) 0);
trickles-server_2.c:26717:		    msk->input_len = 0;
trickles-server_2.c:26718:		    msk->input = ((void *) 0);
trickles-server_2.c:26723:		    msk->refCnt++;
trickles-server_2.c:26734:			struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-server_2.c:26741:		    rval->refCnt = 1;
trickles-server_2.c:26753:		    rval->num_packets = 0;
trickles-server_2.c:26754:		    rval->packets = ((void *) 0);
trickles-server_2.c:26755:		    if (rval->ucont_len > 0)
trickles-server_2.c:26757:			rval->ucont_data = tmalloc (sk, rval->ucont_len);
trickles-server_2.c:26758:			if (rval->ucont_data == ((void *) 0))
trickles-server_2.c:26762:			       rval->ucont_len);
trickles-server_2.c:26770:			rval->ucont_data = ((void *) 0);
trickles-server_2.c:26771:		    } if (rval->input_len > 0)
trickles-server_2.c:26773:			rval->input = tmalloc (sk, rval->input_len);
trickles-server_2.c:26774:			if (rval->input == ((void *) 0))
trickles-server_2.c:26778:			       "pmsk", rval->input_len);
trickles-server_2.c:26779:			    tfree (sk, rval->ucont_data);
trickles-server_2.c:26787:			rval->input = ((void *) 0);
trickles-server_2.c:26788:		    } if (rval->ucont_data)
trickles-server_2.c:26789:		      (__builtin_constant_p (rval->ucont_len) ?
trickles-server_2.c:26790:		       __constant_memcpy ((rval->ucont_data),
trickles-server_2.c:26791:					  (pmsk->ucont_data),
trickles-server_2.c:26792:					  (rval->
trickles-server_2.c:26793:					   ucont_len)) : __memcpy ((rval->
trickles-server_2.c:26795:								   (pmsk->
trickles-server_2.c:26797:								   (rval->
trickles-server_2.c:26799:		    if (rval->input)
trickles-server_2.c:26800:		      (__builtin_constant_p (rval->input_len) ?
trickles-server_2.c:26801:		       __constant_memcpy ((rval->input), (pmsk->input),
trickles-server_2.c:26802:					  (rval->
trickles-server_2.c:26803:					   input_len)) : __memcpy ((rval->
trickles-server_2.c:26805:								   (pmsk->
trickles-server_2.c:26807:								   (rval->
trickles-server_2.c:26815:			(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:26816:			 && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
trickles-server_2.c:26819:			if (msk->ctl == ALLOC_FREE
trickles-server_2.c:26820:			    || msk->ctl == ALLOC_PROCESSING)
trickles-server_2.c:26835:			if (msk->ctl == ALLOC_READY
trickles-server_2.c:26836:			    && msk->prev != ((void *) 0))
trickles-server_2.c:26840:			msk->ctl = ALLOC_PROCESSING;
trickles-server_2.c:26846:		    for (i = 0; i < msk->num_packets; i++)
trickles-server_2.c:26848:			if (msk->packets[i].ucontData != ((void *) 0))
trickles-server_2.c:26850:			    kfree (msk->packets[i].ucontData);
trickles-server_2.c:26854:			    (((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:26855:			       && !((sk)->tp_pinfo.af_tcp.
trickles-server_2.c:26856:				      trickles_opt & (sk)->tp_pinfo.af_tcp.
trickles-server_2.c:26857:				      trickles_opt & 0x8)) && msk->packets)
trickles-server_2.c:26859:			tfree (sk, msk->packets);
trickles-server_2.c:26860:			msk->packets = ((void *) 0);
trickles-server_2.c:26862:		    msk->num_packets = 0;
trickles-server_2.c:26863:		    if (msk->ucont_data != ((void *) 0))
trickles-server_2.c:26865:			tfree (sk, msk->ucont_data);
trickles-server_2.c:26866:			msk->ucont_data = ((void *) 0);
trickles-server_2.c:26868:		    msk->ucont_len = 0;
trickles-server_2.c:26869:		    if (msk->input != ((void *) 0))
trickles-server_2.c:26871:			tfree (sk, msk->input);
trickles-server_2.c:26872:			msk->input = ((void *) 0);
trickles-server_2.c:26874:		    msk->input_len = 0;
trickles-server_2.c:26878:		    msk->refCnt--;
trickles-server_2.c:26879:		    if (!(msk->refCnt <= 3))
trickles-server_2.c:26881:			printk ("KERNEL: assertion (" "msk->refCnt <= 3"
trickles-server_2.c:26886:		    if (msk->refCnt == 0)
trickles-server_2.c:26888:			struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-server_2.c:26890:			  &tp->cminisock_api_config.pmsk_freelist;
trickles-server_2.c:26894:			     (struct pminisock *) tp->cminisock_api_config.
trickles-server_2.c:26895:			     cfg.ctl->pminisock_base
trickles-server_2.c:26897:			     (struct pminisock *) tp->cminisock_api_config.
trickles-server_2.c:26898:			     cfg.ctl->pminisock_limit))
trickles-server_2.c:26901:				(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:26902:				 && !((sk)->tp_pinfo.af_tcp.
trickles-server_2.c:26903:				      trickles_opt & (sk)->tp_pinfo.af_tcp.
trickles-server_2.c:26909:				msk->ctl = ALLOC_FREE;
trickles-server_2.c:26925:			(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:26926:			 && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
trickles-server_2.c:26929:			if (msk->ctl != ALLOC_PROCESSING
trickles-server_2.c:26930:			    && msk->ctl != ALLOC_HALFFREE)
trickles-server_2.c:26933:			      ("(free_trickles_msk_finish %s) without corresponding free_trickles_msk: msk->ctl = %d\n",
trickles-server_2.c:26934:			       "pmsk", msk->ctl);
trickles-server_2.c:26952:		    msk->num_packets = 0;
trickles-server_2.c:26953:		    msk->packets = ((void *) 0);
trickles-server_2.c:26954:		    msk->ucont_len = 0;
trickles-server_2.c:26955:		    msk->ucont_data = ((void *) 0);
trickles-server_2.c:26956:		    msk->input_len = 0;
trickles-server_2.c:26957:		    msk->input = ((void *) 0);
trickles-server_2.c:26972:		    skb->next = ((void *) 0);
trickles-server_2.c:26973:		    skb->prev = ((void *) 0);
trickles-server_2.c:26974:		    skb->list = ((void *) 0);
trickles-server_2.c:26975:		    skb->sk = ((void *) 0);
trickles-server_2.c:26976:		    skb->stamp.tv_sec = 0;
trickles-server_2.c:26977:		    skb->dev = ((void *) 0);
trickles-server_2.c:26978:		    skb->real_dev = ((void *) 0);
trickles-server_2.c:26979:		    skb->dst = ((void *) 0);
trickles-server_2.c:26981:		     ? (__builtin_constant_p ((sizeof (skb->cb))) ?
trickles-server_2.c:26982:			__constant_c_and_count_memset (((skb->cb)),
trickles-server_2.c:26986:						       ((sizeof (skb->cb)))) :
trickles-server_2.c:26987:			__constant_c_memset (((skb->cb)),
trickles-server_2.c:26990:					     ((sizeof (skb->cb)))))
trickles-server_2.c:26991:		     : (__builtin_constant_p ((sizeof (skb->cb))) ?
trickles-server_2.c:26992:			__memset_generic ((((skb->cb))), (((0))),
trickles-server_2.c:26993:					  (((sizeof (skb->cb))))) :
trickles-server_2.c:26994:			__memset_generic (((skb->cb)), ((0)),
trickles-server_2.c:26995:					  ((sizeof (skb->cb))))));
trickles-server_2.c:26996:		    skb->pkt_type = 0;
trickles-server_2.c:26997:		    skb->ip_summed = 0;
trickles-server_2.c:26998:		    skb->priority = 0;
trickles-server_2.c:26999:		    skb->security = 0;
trickles-server_2.c:27000:		    skb->destructor = ((void *) 0);
trickles-server_2.c:27003:		    skb->nfmark = skb->nfcache = 0;
trickles-server_2.c:27004:		    skb->nfct = ((void *) 0);
trickles-server_2.c:27010:		    skb->tc_index = 0;
trickles-server_2.c:27018:		    struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_2.c:27020:		      ((struct skb_shared_info *) ((skb)->end))->nr_frags !=
trickles-server_2.c:27021:		      0, r1 = tp->t.recycleList.qlen >= (1000), r2 =
trickles-server_2.c:27022:		      skb->truesize - sizeof (struct sk_buff) <
trickles-server_2.c:27032:				 r0, r1, r2, skb->truesize,
trickles-server_2.c:27043:		    skb->tail = skb->data = skb->head;
trickles-server_2.c:27044:		    skb->len = 0;
trickles-server_2.c:27045:		    skb->cloned = 0;
trickles-server_2.c:27046:		    skb->data_len = 0;
trickles-server_2.c:27048:		    (((&skb->users)->counter) = (1));
trickles-server_2.c:27050:		       (((struct skb_shared_info *) ((skb)->end))->dataref))->
trickles-server_2.c:27052:		    ((struct skb_shared_info *) ((skb)->end))->nr_frags = 0;
trickles-server_2.c:27053:		    ((struct skb_shared_info *) ((skb)->end))->frag_list =
trickles-server_2.c:27056:		    __skb_queue_tail (&tp->t.recycleList, skb);
trickles-server_2.c:27066:		    struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-server_2.c:27069:		      __skb_dequeue_tail (&tp->t.recycleList);
trickles-server_2.c:27188:		    "kernel_version=" "2.4.26-gdb-trickles";
trickles-server_2.c:27293:		    struct files_struct *files = get_current ()->files;
trickles-server_2.c:27295:		    (void) (&files->file_lock);
trickles-server_2.c:27301:								   *) (files->
trickles-server_2.c:27315:		    struct files_struct *files = get_current ()->files;
trickles-server_2.c:27316:		    (void) (&files->file_lock);
trickles-server_2.c:27321:				       (files->
trickles-server_2.c:27324:		  __asm__ __volatile__ ("btrl %1,%0": "=m" (*(__kernel_fd_set *) (files->close_on_exec)):"r" ((int)
trickles-server_2.c:27338:		    if (fd < files->max_fds)
trickles-server_2.c:27339:		      file = files->fd[fd];
trickles-server_2.c:27349:		    struct files_struct *files = get_current ()->files;
trickles-server_2.c:27351:		    if (fd < files->max_fds)
trickles-server_2.c:27352:		      file = files->fd[fd];
trickles-server_2.c:27366:				     (files->open_fds)):"r" ((int) (fd)));
trickles-server_2.c:27367:		    if (fd < files->next_fd)
trickles-server_2.c:27368:		      files->next_fd = fd;
trickles-server_2.c:27373:		    struct files_struct *files = get_current ()->files;
trickles-server_2.c:27375:		    (void) (&files->file_lock);
trickles-server_2.c:27449:		      c -= 'A' - 'a';
trickles-server_2.c:27456:		      c -= 'a' - 'A';
trickles-server_2.c:27501:				printk ("- ");
trickles-server_2.c:27548:			  a = a - b;
trickles-server_2.c:27549:			  a = a - c;
trickles-server_2.c:27551:			  b = b - c;
trickles-server_2.c:27552:			  b = b - a;
trickles-server_2.c:27554:			  c = c - a;
trickles-server_2.c:27555:			  c = c - b;
trickles-server_2.c:27557:			  a = a - b;
trickles-server_2.c:27558:			  a = a - c;
trickles-server_2.c:27560:			  b = b - c;
trickles-server_2.c:27561:			  b = b - a;
trickles-server_2.c:27563:			  c = c - a;
trickles-server_2.c:27564:			  c = c - b;
trickles-server_2.c:27566:			  a = a - b;
trickles-server_2.c:27567:			  a = a - c;
trickles-server_2.c:27569:			  b = b - c;
trickles-server_2.c:27570:			  b = b - a;
trickles-server_2.c:27572:			  c = c - a;
trickles-server_2.c:27573:			  c = c - b;
trickles-server_2.c:27577:			len = len - 12;
trickles-server_2.c:27610:		      a = a - b;
trickles-server_2.c:27611:		      a = a - c;
trickles-server_2.c:27613:		      b = b - c;
trickles-server_2.c:27614:		      b = b - a;
trickles-server_2.c:27616:		      c = c - a;
trickles-server_2.c:27617:		      c = c - b;
trickles-server_2.c:27619:		      a = a - b;
trickles-server_2.c:27620:		      a = a - c;
trickles-server_2.c:27622:		      b = b - c;
trickles-server_2.c:27623:		      b = b - a;
trickles-server_2.c:27625:		      c = c - a;
trickles-server_2.c:27626:		      c = c - b;
trickles-server_2.c:27628:		      a = a - b;
trickles-server_2.c:27629:		      a = a - c;
trickles-server_2.c:27631:		      b = b - c;
trickles-server_2.c:27632:		      b = b - a;
trickles-server_2.c:27634:		      c = c - a;
trickles-server_2.c:27635:		      c = c - b;
trickles-server_2.c:27647:		    int runStart = -1;
trickles-server_2.c:27663:				printk ("[%d-%d]: ", runStart, i - 1);
trickles-server_2.c:27682:		    for (elem = (typeof (elem)) (list)->next;
trickles-server_2.c:27684:			 elem = (typeof (elem)) elem->next)
trickles-server_2.c:27688:			    if (!(elem->list == list))
trickles-server_2.c:27691:					"elem->list == list", "cache_util.h",
trickles-server_2.c:27701:			if (!(count == list->len))
trickles-server_2.c:27704:				    "count == list->len", "cache_util.h",
trickles-server_2.c:27716:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-server_2.c:27717:		    printk ("At %d: %X:%d => %X:%d\n", lineno, sk->saddr,
trickles-server_2.c:27718:			    (int) ntohs (sk->sport), sk->daddr,
trickles-server_2.c:27719:			    (int) ntohs (sk->dport));
trickles-server_2.c:27765:			val -= 0x40000000;
trickles-server_2.c:27768:		    temp = (g << (15)) + (1 << ((15) * 2 - 2));
trickles-server_2.c:27771:			g += 1 << ((15) - 1);
trickles-server_2.c:27772:			val -= temp;
trickles-server_2.c:27774:		    temp = (g << (14)) + (1 << ((14) * 2 - 2));
trickles-server_2.c:27777:			g += 1 << ((14) - 1);
trickles-server_2.c:27778:			val -= temp;
trickles-server_2.c:27780:		    temp = (g << (13)) + (1 << ((13) * 2 - 2));
trickles-server_2.c:27783:			g += 1 << ((13) - 1);
trickles-server_2.c:27784:			val -= temp;
trickles-server_2.c:27786:		    temp = (g << (12)) + (1 << ((12) * 2 - 2));
trickles-server_2.c:27789:			g += 1 << ((12) - 1);
trickles-server_2.c:27790:			val -= temp;
trickles-server_2.c:27792:		    temp = (g << (11)) + (1 << ((11) * 2 - 2));
trickles-server_2.c:27795:			g += 1 << ((11) - 1);
trickles-server_2.c:27796:			val -= temp;
trickles-server_2.c:27798:		    temp = (g << (10)) + (1 << ((10) * 2 - 2));
trickles-server_2.c:27801:			g += 1 << ((10) - 1);
trickles-server_2.c:27802:			val -= temp;
trickles-server_2.c:27804:		    temp = (g << (9)) + (1 << ((9) * 2 - 2));
trickles-server_2.c:27807:			g += 1 << ((9) - 1);
trickles-server_2.c:27808:			val -= temp;
trickles-server_2.c:27810:		    temp = (g << (8)) + (1 << ((8) * 2 - 2));
trickles-server_2.c:27813:			g += 1 << ((8) - 1);
trickles-server_2.c:27814:			val -= temp;
trickles-server_2.c:27816:		    temp = (g << (7)) + (1 << ((7) * 2 - 2));
trickles-server_2.c:27819:			g += 1 << ((7) - 1);
trickles-server_2.c:27820:			val -= temp;
trickles-server_2.c:27822:		    temp = (g << (6)) + (1 << ((6) * 2 - 2));
trickles-server_2.c:27825:			g += 1 << ((6) - 1);
trickles-server_2.c:27826:			val -= temp;
trickles-server_2.c:27828:		    temp = (g << (5)) + (1 << ((5) * 2 - 2));
trickles-server_2.c:27831:			g += 1 << ((5) - 1);
trickles-server_2.c:27832:			val -= temp;
trickles-server_2.c:27834:		    temp = (g << (4)) + (1 << ((4) * 2 - 2));
trickles-server_2.c:27837:			g += 1 << ((4) - 1);
trickles-server_2.c:27838:			val -= temp;
trickles-server_2.c:27840:		    temp = (g << (3)) + (1 << ((3) * 2 - 2));
trickles-server_2.c:27843:			g += 1 << ((3) - 1);
trickles-server_2.c:27844:			val -= temp;
trickles-server_2.c:27846:		    temp = (g << (2)) + (1 << ((2) * 2 - 2));
trickles-server_2.c:27849:			g += 1 << ((2) - 1);
trickles-server_2.c:27850:			val -= temp;
trickles-server_2.c:27864:		    int res, hint = -1;
trickles-server_2.c:27866:		    unsigned startCwnd = cont->startCwnd;
trickles-server_2.c:27869:		       typeof (({typeof (cont->ssthresh) Z =
trickles-server_2.c:27870:				 (typeof (cont->ssthresh)) (startCwnd);
trickles-server_2.c:27873:				   const typeof (cont->ssthresh) _x =
trickles-server_2.c:27874:				   (cont->ssthresh);
trickles-server_2.c:27881:						    typeof (cont->
trickles-server_2.c:27883:						    (typeof (cont->ssthresh))
trickles-server_2.c:27887:						      const typeof (cont->
trickles-server_2.c:27889:						      _x = (cont->ssthresh);
trickles-server_2.c:27895:						    }))) (((1 << 13) - 1));
trickles-server_2.c:27900:						 typeof (cont->ssthresh) Z =
trickles-server_2.c:27901:						 (typeof (cont->ssthresh))
trickles-server_2.c:27905:						   const typeof (cont->
trickles-server_2.c:27907:						   = (cont->ssthresh);
trickles-server_2.c:27914:							     typeof (cont->
trickles-server_2.c:27918:							      (cont->
trickles-server_2.c:27924:							       typeof (cont->
trickles-server_2.c:27927:							       (cont->
trickles-server_2.c:27943:		       unsigned TCPBase = cont->TCPBase;
trickles-server_2.c:27945:		       (ssthresh - startCwnd + TCPBase) + ssthresh;
trickles-server_2.c:27946:		       seq = TCPBase + (seq - TCPBase) * 1 / 2;
trickles-server_2.c:27954:						  )); res = -1; goto done;}
trickles-server_2.c:27956:		       if (seq < ssthresh - startCwnd + TCPBase)
trickles-server_2.c:27958:		       res = startCwnd + (seq - TCPBase);}
trickles-server_2.c:27960:		       if (ssthresh - startCwnd + TCPBase <= seq &&
trickles-server_2.c:27970:		       int offset = seq - additiveStart;
trickles-server_2.c:27973:		       (((-1 << ((1) - 1)) +
trickles-server_2.c:27974:			 mborg_isqrt4 ((1 << (2 * (1) - 2)) -
trickles-server_2.c:27975:				       ((-
trickles-server_2.c:27977:					  ((int) (ssthresh) + 1)) -
trickles-server_2.c:27978:					 2 * (((int) seq) -
trickles-server_2.c:27984:					    (typeof ((cwnd))) (((1 << 13) -
trickles-server_2.c:27989:									 ((cwnd)) _x = ((cwnd)); const typeof (Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y;});})); position = (cwnd * (cwnd + 1) - ssthresh * (ssthresh + 1)) / 2; if (cwnd == ((1 << 13) - 1))
trickles-server_2.c:27991:		       res = cwnd; hint = -1;}
trickles-server_2.c:27999:				       (typeof ((cwnd + 1))) (((1 << 13) -
trickles-server_2.c:28028:							(((1 << 13) - 1)); (
trickles-server_2.c:28049:		       if (offset > position - cwnd)
trickles-server_2.c:28054:		       if (!(offset > position - cwnd - (cwnd - 1)))
trickles-server_2.c:28060:		       if ((cwnd - 1) < ssthresh)
trickles-server_2.c:28070:		       res = cwnd - 1; hint = additiveStart + position - cwnd;}
trickles-server_2.c:28077:		       if (res > ((1 << 13) - 1))
trickles-server_2.c:28078:		       res = ((1 << 13) - 1);
trickles-server_2.c:28080:		       * hintResult = (hint >= 0) ? hint : -1;
trickles-server_2.c:28081:		       ((struct cminisock *) cont)->mark = res; return res;}
trickles-server_2.c:28091:		       if (sack->left > sack->right)
trickles-server_2.c:28098:		       generateRangeNonce (cont->sk, sack->left, sack->right);
trickles-server_2.c:28099:		       if (genNonce != sack->nonceSummary)
trickles-server_2.c:28108:		       ("nonce check failed for [%d-%d] = 0x%0X != 0x%0X\n",
trickles-server_2.c:28109:			sack->left, sack->right, genNonce,
trickles-server_2.c:28110:			sack->nonceSummary);}
trickles-server_2.c:28122:		       return sack->left <= seq && seq <= sack->right;}
trickles-server_2.c:28126:		       return right->left - left->right - 1;}
trickles-server_2.c:28140:		       struct cminisock * cont = proof->cont;
trickles-server_2.c:28141:		       Sack * sacks = proof->sacks;
trickles-server_2.c:28142:		       int numSacks = proof->numSacks;
trickles-server_2.c:28144:			   sacks[0].left > cont->TCPBase)
trickles-server_2.c:28149:			numSacks, sacks[0].left, cont->TCPBase, cont->seq);
trickles-server_2.c:28156:		       if (i > 0 && sacks[i].left <= sacks[i - 1].right)
trickles-server_2.c:28165:		       int i, numSacks = proof->numSacks;
trickles-server_2.c:28166:		       Sack * sacks = proof->sacks;
trickles-server_2.c:28169:		       if (!Sack_adjacent (&sacks[i - 1], &sacks[i]))
trickles-server_2.c:28171:		       return sacks[i - 1].right + 1;}
trickles-server_2.c:28176:			)); return -1;}
trickles-server_2.c:28186:		       Sack * sacks = proof->sacks;
trickles-server_2.c:28187:		       cursor = left; for (i = 0; i < proof->numSacks; i++)
trickles-server_2.c:28196:		       if (i == proof->numSacks)
trickles-server_2.c:28206:		       Sack * sacks = proof->sacks;
trickles-server_2.c:28207:		       cursor = start; for (i = 0; i < proof->numSacks; i++)
trickles-server_2.c:28216:		       if (cursor > start) return cursor - 1;
trickles-server_2.c:28218:		       return start - 1;}
trickles-server_2.c:28225:		       Sack * sacks = proof->sacks;
trickles-server_2.c:28227:		       for (i = proof->numSacks - 1; i >= 0; i--)
trickles-server_2.c:28234:		       cursor = sacks[i].left - 1;}
trickles-server_2.c:28256:		       printk ("proof(%d) = ", proof->numSacks);
trickles-server_2.c:28257:		       for (i = 0; i < proof->numSacks; i++)
trickles-server_2.c:28259:		       printk ("[%d-%d]", proof->sacks[i].left,
trickles-server_2.c:28260:			       proof->sacks[i].right);}
trickles-server_2.c:28271:		       (WireTrickleRequest *) skb->data;
trickles-server_2.c:28288:			skb->len);}
trickles-server_2.c:28293:		       sacks_len = req->ackProof.numSacks * sizeof (WireSack);
trickles-server_2.c:28294:		       if (!(req->ackProof.numSacks <= 64 &&
trickles-server_2.c:28301:		       ucont_len = ntohs (req->ucont_len);
trickles-server_2.c:28309:			   (((serverSK)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:28310:			    && !((serverSK)->tp_pinfo.af_tcp.
trickles-server_2.c:28311:				 trickles_opt & (serverSK)->tp_pinfo.af_tcp.
trickles-server_2.c:28329:					    (char *) skb->data),
trickles-server_2.c:28333:				   (char *) skb->data), (ucont_len)));
trickles-server_2.c:28343:		       if (!(skb->len >= 0))
trickles-server_2.c:28345:		       printk ("KERNEL: assertion (" "skb->len >= 0"
trickles-server_2.c:28346:			       ") failed at " "trickles-server.c" "(%d)\n",
trickles-server_2.c:28349:			   (((serverSK)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:28350:			    && !((serverSK)->tp_pinfo.af_tcp.
trickles-server_2.c:28351:				 trickles_opt & (serverSK)->tp_pinfo.af_tcp.
trickles-server_2.c:28354:		       ; input_len = skb->len; if (input_len > 0)
trickles-server_2.c:28366:			__constant_memcpy ((input), ((char *) skb->data),
trickles-server_2.c:28369:								     skb->
trickles-server_2.c:28380:		       __u32 seqno = ntohl (req->cont.seq); if ((0))
trickles-server_2.c:28384:			   (((serverSK)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:28385:			    && !((serverSK)->tp_pinfo.af_tcp.
trickles-server_2.c:28386:				 trickles_opt & (serverSK)->tp_pinfo.af_tcp.
trickles-server_2.c:28392:						       skb->nh.iph,
trickles-server_2.c:28393:						       skb->h.th)) !=
trickles-server_2.c:28397:		       struct WireContinuation * scont = &req->cont;
trickles-server_2.c:28398:		       msk->sk = msk->serverSK = serverSK;
trickles-server_2.c:28401:		       msk->pmsk = packed_msk = lookup;
trickles-server_2.c:28402:		       msk->seq = ntohl (scont->seq);
trickles-server_2.c:28403:		       msk->firstChild = packed_msk->firstChild =
trickles-server_2.c:28404:		       scont->firstChild;
trickles-server_2.c:28405:		       msk->clientState = packed_msk->clientState =
trickles-server_2.c:28406:		       scont->clientState;
trickles-server_2.c:28407:		       msk->parent = packed_msk->parent = scont->parent;
trickles-server_2.c:28408:		       msk->clientTimestamp = packed_msk->clientTimestamp =
trickles-server_2.c:28409:		       scont->clientTimestamp;
trickles-server_2.c:28411:			   (msk->saddr == skb->nh.iph->daddr
trickles-server_2.c:28412:			    && msk->daddr == skb->nh.iph->saddr
trickles-server_2.c:28413:			    && msk->source == skb->h.th->dest
trickles-server_2.c:28414:			    && msk->dest == skb->h.th->source))
trickles-server_2.c:28417:			       "msk->saddr == skb->nh.iph->daddr && msk->daddr == skb->nh.iph->saddr && msk->source == skb->h.th->dest && msk->dest == skb->h.th->source"
trickles-server_2.c:28418:			       ") failed at " "trickles-server.c" "(%d)\n",
trickles-server_2.c:28419:			       607);}; if (!(msk->ctl == ALLOC_PENDING))
trickles-server_2.c:28422:			       "msk->ctl == ALLOC_PENDING" ") failed at "
trickles-server_2.c:28423:			       "trickles-server.c" "(%d)\n", 609);};
trickles-server_2.c:28424:		       msk->ucont_len = ucont_len;
trickles-server_2.c:28425:		       msk->ucont_data = ucont_data;
trickles-server_2.c:28426:		       ucont_data = ((void *) 0); msk->input_len = input_len;
trickles-server_2.c:28427:		       msk->input = input; input = ((void *) 0);;}
trickles-server_2.c:28437:			   (((serverSK)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:28438:			    && !((serverSK)->tp_pinfo.af_tcp.
trickles-server_2.c:28439:				 trickles_opt & (serverSK)->tp_pinfo.af_tcp.
trickles-server_2.c:28449:		       skb->sk = msk->sk = msk->serverSK = serverSK;
trickles-server_2.c:28455:		       msk->pmsk = packed_msk;
trickles-server_2.c:28457:			   (skb, msk, &req->cont))
trickles-server_2.c:28461:		       msk->ucont_len = ucont_len;
trickles-server_2.c:28462:		       msk->ucont_data = ucont_data;
trickles-server_2.c:28463:		       ucont_data = ((void *) 0); msk->input_len = input_len;
trickles-server_2.c:28464:		       msk->input = input; input = ((void *) 0);;}
trickles-server_2.c:28484:			   (((msk->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:28485:			    && !((msk->sk)->tp_pinfo.af_tcp.
trickles-server_2.c:28486:				 trickles_opt & (msk->sk)->tp_pinfo.af_tcp.
trickles-server_2.c:28489:		       msk->saddr = skb->nh.iph->daddr;
trickles-server_2.c:28490:		       msk->source = skb->h.th->dest;
trickles-server_2.c:28491:		       msk->daddr = skb->nh.iph->saddr;
trickles-server_2.c:28492:		       msk->dest = skb->h.th->source;}
trickles-server_2.c:28502:			   (((msk->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:28503:			    && !((msk->sk)->tp_pinfo.af_tcp.
trickles-server_2.c:28504:				 trickles_opt & (msk->sk)->tp_pinfo.af_tcp.
trickles-server_2.c:28508:		       ctx.new = 1; for (i = 0; i < msk->num_packets; i++)
trickles-server_2.c:28510:		       msk->packets[i].nonce =
trickles-server_2.c:28511:		       generateSingleNonce (msk->sk, msk->packets[i].seq,
trickles-server_2.c:28513:		       msk->packets[i].ucontLen = 0;
trickles-server_2.c:28514:		       msk->packets[i].ucontData = ((void *) 0);
trickles-server_2.c:28518:		       unmarshallContinuationServerMSK2PMSK (msk->sk,
trickles-server_2.c:28519:							     msk->pmsk, msk);
trickles-server_2.c:28520:		       queue_upcall_pmsk_prealloc (msk->sk, event, msk->pmsk);
trickles-server_2.c:28521:		       queue_upcall_pmsk (event, msk->pmsk);
trickles-server_2.c:28523:		       shallow_copy_msk (msk->serverSK, msk);
trickles-server_2.c:28527:		       free_trickles_msk (msk->serverSK, msk);
trickles-server_2.c:28528:		       free_trickles_msk_finish (msk->serverSK, msk); return;}
trickles-server_2.c:28529:		       queue_upcall_msk_prealloc (msk->sk, event, copy);
trickles-server_2.c:28531:		       queue_upcall_deliver (msk->sk);}
trickles-server_2.c:28543:		       msk->ucont_len = 0;
trickles-server_2.c:28544:		       msk->clientState = 0;
trickles-server_2.c:28545:		       msk->mrtt = 0;
trickles-server_2.c:28546:		       msk->firstLoss = 0x1055;
trickles-server_2.c:28547:		       msk->firstBootstrapSeq = 0xb007;
trickles-server_2.c:28548:		       msk->ssthresh = 0x3fff;}
trickles-server_2.c:28549:		       msk->TCPBase = seqno;
trickles-server_2.c:28552:		       return -12;}
trickles-server_2.c:28556:		       makePacket (&msk->packets[i], seq, 1,
trickles-server_2.c:28559:				   1 * (sysctl_trickles_mss), -1, 1);
trickles-server_2.c:28561:		       msk->num_packets = num_packets; DoUpcall (msk, tag);
trickles-server_2.c:28568:		       int rval = -22;
trickles-server_2.c:28569:		       struct tcphdr * ith = in_skb->h.th;
trickles-server_2.c:28570:		       struct tcp_opt * tp = &(sk->tp_pinfo.af_tcp);
trickles-server_2.c:28573:			   && !(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:28574:				&& !((sk)->tp_pinfo.af_tcp.
trickles-server_2.c:28575:				     trickles_opt & (sk)->tp_pinfo.af_tcp.
trickles-server_2.c:28583:			   (((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:28584:			    && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
trickles-server_2.c:28586:			   && !((tp)->cminisock_api_config.cfg.mmap_base !=
trickles-server_2.c:28588:				&& (tp)->cminisock_api_config.cfg.ctl !=
trickles-server_2.c:28594:		       if ((((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:28595:			    && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
trickles-server_2.c:28599:		       if (ith->syn)
trickles-server_2.c:28601:		       if ((((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:28602:			    && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
trickles-server_2.c:28612:			       __msk;});} msk->serverSK = sk; msk->sk = sk;
trickles-server_2.c:28613:		       in_skb->sk = sk; pre_init_sock (msk, in_skb);;
trickles-server_2.c:28614:		       __u32 firstSeq; if (ith->ack)
trickles-server_2.c:28619:		       msk->tokenCounterBase = tp->bigTokenCounter;
trickles-server_2.c:28620:		       tp->bigTokenCounter += ((__u64) 1) << 32;
trickles-server_2.c:28621:		       int num_packets; msk->input_len = in_skb->len;
trickles-server_2.c:28622:		       if (msk->input_len > 0)
trickles-server_2.c:28625:		       msk->input = tmalloc (in_skb->sk, msk->input_len);
trickles-server_2.c:28626:		       if (msk->input == ((void *) 0))
trickles-server_2.c:28632:			msk->input_len);}
trickles-server_2.c:28634:		       (__builtin_constant_p (msk->input_len) ?
trickles-server_2.c:28635:			__constant_memcpy ((msk->input),
trickles-server_2.c:28636:					   ((char *) in_skb->data),
trickles-server_2.c:28637:					   (msk->
trickles-server_2.c:28638:					    input_len)) : __memcpy ((msk->
trickles-server_2.c:28641:								     in_skb->
trickles-server_2.c:28643:								    (msk->
trickles-server_2.c:28645:		       num_packets = msk->startCwnd = (3);}
trickles-server_2.c:28649:		       msk->input = ((void *) 0); num_packets = 1;
trickles-server_2.c:28652:		       (msk)->startCwnd = 0;}
trickles-server_2.c:28654:		       msk->pmsk = alloc_trickles_pmsk (sk);
trickles-server_2.c:28655:		       if (msk->pmsk == ((void *) 0))
trickles-server_2.c:28663:		       if (ith->fin)
trickles-server_2.c:28672:		       if (ith->rst)
trickles-server_2.c:28684:		       if (rval != -12)
trickles-server_2.c:28698:		       int rval = -22;
trickles-server_2.c:28712:		       return -22;}
trickles-server_2.c:28718:			       ") failed at " "trickles-server.c" "(%d)\n",
trickles-server_2.c:28719:			       915);}; return -12;}
trickles-server_2.c:28724:		       if ((0)) printk ("out of memory\n"); return -12;}
trickles-server_2.c:28727:		       cont->executionTrace = 0;
trickles-server_2.c:28729:			   (((cont->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:28730:			    && !((cont->sk)->tp_pinfo.af_tcp.
trickles-server_2.c:28731:				 trickles_opt & (cont->sk)->tp_pinfo.af_tcp.
trickles-server_2.c:28734:		       cont->ack_seq = skb->h.th->ack_seq;
trickles-server_2.c:28735:		       cont->dbg_timestamp = jiffies;}
trickles-server_2.c:28739:		       unmarshallAckProof (&ackProof, &treq_hdr->ackProof);;
trickles-server_2.c:28742:			   (((cont->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:28743:			    && !((cont->sk)->tp_pinfo.af_tcp.
trickles-server_2.c:28744:				 trickles_opt & (cont->sk)->tp_pinfo.af_tcp.
trickles-server_2.c:28749:		       if ((((skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-server_2.c:28750:			    && !((skb->sk)->tp_pinfo.af_tcp.
trickles-server_2.c:28751:				 trickles_opt & (skb->sk)->tp_pinfo.af_tcp.
trickles-server_2.c:28754:		       printk ("ackproof validation failed\n"); return -22;}
trickles-server_2.c:28758:		       printk ("Server processing: %u\n", cont->seq);
trickles-server_2.c:28764:		       AckProof_checkRange (&ackProof, cont->TCPBase,
trickles-server_2.c:28765:					    cont->seq);;
trickles-server_2.c:28766:		       switch ((enum TrickleRequestType) treq_hdr->type)
trickles-server_2.c:28771:		       cont->mrtt -= cont->mrtt >> 3;
trickles-server_2.c:28772:		       cont->mrtt += jiffies - cont->timestamp;
trickles-server_2.c:28773:		       (cont)->timestamp = jiffies;; switch (cont->state)
trickles-server_2.c:28789:			       cont->seq); AckProof_dump (&ackProof);}
trickles-server_2.c:28809:			    (&ackProof, cont->TCPBase,
trickles-server_2.c:28810:			     cont->firstLoss - 1) == NORMALRANGE
trickles-server_2.c:28812:						    cont->firstBootstrapSeq,
trickles-server_2.c:28813:						    cont->seq) ==
trickles-server_2.c:28823:if (serverDebugLevel >= 1) printk ("  Normal Range\n"); cont->TCPBase = cont->firstBootstrapSeq; if (serverDebugLevel >= 1) printk ("Bootstrap: TCPBase = %u CWND = %u SSTHRESH = %u\n", cont->TCPBase, cont->startCwnd, cont->ssthresh);; rval = DoNormalStep (&cont, &ackProof, event); break; case BADRANGE:
trickles-server_2.c:28830:		       printk ("  unknown state\n"); return -22;}
trickles-server_2.c:28836:		       cont->mrtt = (jiffies - cont->timestamp) << 3;
trickles-server_2.c:28837:		       (cont)->timestamp = jiffies; if (serverDebugLevel >= 1)
trickles-server_2.c:28841:		       seq = AckProof_findRight (&ackProof, cont->TCPBase);
trickles-server_2.c:28842:		       if (seq < cont->TCPBase)
trickles-server_2.c:28844:		       printk ("  SlowStart: seq < cont->TCPBase\n");
trickles-server_2.c:28845:		       return -22;}
trickles-server_2.c:28868:		       &msk->packets[packet_num];
trickles-server_2.c:28869:		       int ucontLen = packet->ucontLen;
trickles-server_2.c:28870:		       int origSkbLen = skb->len;
trickles-server_2.c:28872:		       sk = skb->sk = msk->sk;
trickles-server_2.c:28878:			       ") failed at " "trickles-server.c" "(%d)\n",
trickles-server_2.c:28881:		       if (packet->ucontData != ((void *) 0))
trickles-server_2.c:28885:					   (packet->ucontData),
trickles-server_2.c:28888:				  (packet->ucontData), (ucontLen)));}
trickles-server_2.c:28895:		       if (packet->contType & (0x80))
trickles-server_2.c:28911:		       switch (packet->contType)
trickles-server_2.c:28914:resp_hdr = (WireTrickleResponse *) skb_push (skb, (sizeof (WireTrickleResponse) - ((sizeof (struct WireContinuation)) - ((int) (((struct WireContinuation *) 0)->minimalContinuationEnd))))); resp_hdr->cont.seq = htonl (packet->seq); resp_hdr->cont.continuationType = (0); resp_hdr->cont.clientState = msk->clientState; resp_hdr->cont.parent = msk->parent; resp_hdr->cont.clientTimestamp = msk->clientTimestamp; break; case (1):
trickles-server_2.c:28921:		       marshallContinuationServer (sk, &resp_hdr->cont, msk,
trickles-server_2.c:28926:		       if (((msk->pmsk)->cacheRecycleIndex >= 0))
trickles-server_2.c:28928:		       pminisock_cache_child (msk->serverSK, msk,
trickles-server_2.c:28929:					      msk->pmsk, packet_num,
trickles-server_2.c:28934:		       msk->pmsk->cacheRecycleIndex = msk->cacheRecycleIndex =
trickles-server_2.c:28936:		       if (!(packet_num == msk->pmsk->cacheRecycleIndex))
trickles-server_2.c:28939:			       "packet_num == msk->pmsk->cacheRecycleIndex"
trickles-server_2.c:28940:			       ") failed at " "trickles-server.c" "(%d)\n",
trickles-server_2.c:28953:		       resp_hdr->nonce = packet->nonce;
trickles-server_2.c:28954:		       resp_hdr->ucont_len = htons ((short) ucontLen);
trickles-server_2.c:28955:		       resp_hdr->numSiblings = packet->numSiblings;
trickles-server_2.c:28956:		       resp_hdr->position = packet->position;
trickles-server_2.c:28959:		       skb->h.th = th;
trickles-server_2.c:28960:		       th->source = sk->sport;
trickles-server_2.c:28961:		       th->dest = msk->dest;
trickles-server_2.c:28962:		       th->seq = htonl (msk->seq);
trickles-server_2.c:28966:					      msk->daddr, msk->dest,
trickles-server_2.c:28967:					      packet->seq, gSendPacketNumber,
trickles-server_2.c:28968:					      msk->startCwnd, msk->mark,
trickles-server_2.c:28969:					      msk->ssthresh, msk->mrtt,
trickles-server_2.c:28970:					      msk->mrtt);}
trickles-server_2.c:28971:		       th->ack_seq = packetID; packetID++;
trickles-server_2.c:28972:		       th->doff = tcp_header_size >> 2; th->res1 = 0;
trickles-server_2.c:28973:		       th->cwr = 0; th->ece = 0; th->urg = 0; th->ack = 1;
trickles-server_2.c:28974:		       th->psh = 0; th->rst = 0; th->syn = 0; th->fin = 0;
trickles-server_2.c:28975:		       th->window = 0; th->check = 0; th->urg_ptr = 0;
trickles-server_2.c:28980:				msk->ucont_len))); switch (msk->tag)
trickles-server_2.c:28985:		       th->syn = 1; th->ack = 1;}
trickles-server_2.c:28991:printk ("sending fin\n"); th->fin = 1; break; case ACK:
trickles-server_2.c:28993:th->ack = 1; break; default:
trickles-server_2.c:28997:		       numTxBytes += skb->len;
trickles-server_2.c:28998:		       if (!(sk->protocol == IPPROTO_TCP))
trickles-server_2.c:29001:			       "sk->protocol == IPPROTO_TCP" ") failed at "
trickles-server_2.c:29002:			       "trickles-server.c" "(%d)\n", 1347);};
trickles-server_2.c:29003:		       trickles_checksum (skb, skb->len - origSkbLen);
trickles-server_2.c:29004:		       err = af->queue_xmit (skb, 0); return err;}
trickles-server_2.c:29020:		       (((*cont)->continuationType) ==
trickles-server_2.c:29021:			(2) ? ((*cont)->seq) - 1 : ((*cont)->seq)),
trickles-server_2.c:29025:		       if (((*cont)->startCwnd == 0))
trickles-server_2.c:29028:		       (*cont)->startCwnd = (3);
trickles-server_2.c:29029:		       return doInitialCwnd (*cont, event, (*cont)->seq + 1,
trickles-server_2.c:29030:					     (*cont)->startCwnd);}
trickles-server_2.c:29032:		       (*cont)->executionTrace = 1;;;;;
trickles-server_2.c:29033:		       prevCwnd = (first_ack_seq == (*cont)->TCPBase) ?
trickles-server_2.c:29034:		       (*cont)->startCwnd :
trickles-server_2.c:29035:		       AckTCPCwnd (first_ack_seq - 1, (*cont), &hint);;
trickles-server_2.c:29036:		       currCwnd = AckTCPCwndScalar ((*cont)->seq, (*cont));
trickles-server_2.c:29037:		       (*cont)->actualCwnd = currCwnd;; numOutput = (
trickles-server_2.c:29045:									    -
trickles-server_2.c:29073:		       switch ((*cont)->continuationType)
trickles-server_2.c:29095:			   "\n", (*cont)->TCPBase, first_ack_seq - 1,
trickles-server_2.c:29096:			   prevCwnd, (*cont)->seq, currCwnd); 1;}
trickles-server_2.c:29098:		       free_trickles_msk ((*cont)->sk, *cont);
trickles-server_2.c:29099:		       free_trickles_msk_finish ((*cont)->sk, *cont);
trickles-server_2.c:29100:		       return -22;}
trickles-server_2.c:29110:		       ("bug in cwnd generation: ack_seq = %u-%u, TCPBase = %u, "
trickles-server_2.c:29112:			(*cont)->seq, (*cont)->TCPBase, (*cont)->startCwnd,
trickles-server_2.c:29113:			numOutput); free_trickles_msk ((*cont)->sk, (*cont));
trickles-server_2.c:29114:		       free_trickles_msk_finish ((*cont)->sk, (*cont));
trickles-server_2.c:29115:		       return -22;}
trickles-server_2.c:29120:		       free_trickles_msk ((*cont)->sk, (*cont));
trickles-server_2.c:29121:		       free_trickles_msk_finish ((*cont)->sk, (*cont));
trickles-server_2.c:29122:		       return -12;}
trickles-server_2.c:29126:		       int thisMSS, nextResponseLen = 0, firstChild = -1,
trickles-server_2.c:29127:		       numChildren = -1, contType; if (serverDebugLevel >= 1)
trickles-server_2.c:29129:		       if ((*cont)->state == CONT_BOOTSTRAP)
trickles-server_2.c:29134:		       offset = seq - (*cont)->TCPBase;
trickles-server_2.c:29145:thisMSS = ((sysctl_trickles_mss) + sizeof (struct WireContinuation) - (int) ((struct WireContinuation *) 0)->minimalContinuationEnd); break; default:
trickles-server_2.c:29146:		       thisMSS = -1;
trickles-server_2.c:29156:		       makePacket (&(*cont)->packets[numPackets], seq,
trickles-server_2.c:29161:		       (*cont)->num_packets = numPackets;
trickles-server_2.c:29165:			       ") failed at " "trickles-server.c" "(%d)\n",
trickles-server_2.c:29217:		       return end - start + 1;}
trickles-server_2.c:29228:		       if (!(!((*cont)->startCwnd == 0)))
trickles-server_2.c:29232:			       ") failed at " "trickles-server.c" "(%d)\n",
trickles-server_2.c:29233:			       1618);}; int i; Sack * sacks = ackProof->sacks;
trickles-server_2.c:29245:		       (*cont)->executionTrace = 2;
trickles-server_2.c:29252:		       free_trickles_msk ((*cont)->sk, (*cont));
trickles-server_2.c:29253:		       free_trickles_msk_finish ((*cont)->sk, (*cont));
trickles-server_2.c:29254:		       return -22;}
trickles-server_2.c:29255:		       (*cont)->state = CONT_RECOVERY;
trickles-server_2.c:29256:		       (*cont)->firstLoss = AckProof_firstLoss (ackProof);
trickles-server_2.c:29257:		       switch (((((*cont)->firstLoss - (*cont)->TCPBase) <
trickles-server_2.c:29259:				: (((((*cont)->firstLoss -
trickles-server_2.c:29260:				      (*cont)->TCPBase)) % 2 ==
trickles-server_2.c:29265:origCwndPred = AckTCPCwndScalar (AckProof_firstLoss (ackProof) - 1, (*cont)); adj = 0; break; case (2):
trickles-server_2.c:29267:		       AckTCPCwndScalar (AckProof_firstLoss (ackProof) - 2,
trickles-server_2.c:29268:					 (*cont)); adj = -1; break;}
trickles-server_2.c:29272:		       free_trickles_msk ((*cont)->sk, (*cont));
trickles-server_2.c:29273:		       free_trickles_msk_finish ((*cont)->sk, (*cont));
trickles-server_2.c:29274:		       return -22;}
trickles-server_2.c:29276:		       ((*cont)->firstLoss - 1 + adj) + origCwndPred;
trickles-server_2.c:29277:		       (*cont)->num_packets = 0; newCwnd = origCwnd / 2;
trickles-server_2.c:29278:		       (*cont)->actualCwnd = newCwnd;
trickles-server_2.c:29279:		       (*cont)->TCPBase = (*cont)->firstBootstrapSeq =
trickles-server_2.c:29280:		       lastRegularPacket + 1; (*cont)->startCwnd = newCwnd;
trickles-server_2.c:29281:		       if (newCwnd == 0) (*cont)->ssthresh /= 2;
trickles-server_2.c:29283:		       (*cont)->ssthresh = newCwnd;
trickles-server_2.c:29284:		       bootstrapStart = lastRegularPacket - newCwnd;
trickles-server_2.c:29285:		       bootstrapEnd = bootstrapStart + newCwnd - 1;
trickles-server_2.c:29286:		       for (i = 0; i < ackProof->numSacks; i++)
trickles-server_2.c:29289:		       if (i > 0 && !Sack_adjacent (&sacks[i - 1], &sacks[i]))
trickles-server_2.c:29291:		       gaplen = Sack_gapLen (&sacks[i - 1], &sacks[i]);
trickles-server_2.c:29295:		       intersect (bootstrapStart, sacks[i].left - 1,
trickles-server_2.c:29296:				  bootstrapEnd, sacks[i - 1].right + 1);}
trickles-server_2.c:29297:		       if (Sack_contains (&ackProof->sacks[i], (*cont)->seq))
trickles-server_2.c:29299:		       if (((*cont)->seq == sacks[i].left ||
trickles-server_2.c:29300:			    ((*cont)->continuationType == (2)
trickles-server_2.c:29301:			     && (*cont)->seq - 1 == sacks[i].left))
trickles-server_2.c:29306:		       gapLeft = ackProof->sacks[i - 1].right + 1,
trickles-server_2.c:29307:		       gapRight = ackProof->sacks[i].left - 1;}
trickles-server_2.c:29320:		       numPacketsAllocated += (gapRight - gapLeft) + 1;
trickles-server_2.c:29375:		       numPacketsAllocated += (end - start) + 1;}
trickles-server_2.c:29381:						   typeof ((((*cont)->
trickles-server_2.c:29384:							    (2) ? ((*cont)->
trickles-server_2.c:29385:								   seq) -
trickles-server_2.c:29386:							    1 : ((*cont)->
trickles-server_2.c:29389:						    ((((*cont)->
trickles-server_2.c:29391:						      (2) ? ((*cont)->seq) -
trickles-server_2.c:29392:						      1 : ((*cont)->
trickles-server_2.c:29398:										    ((((*cont)->continuationType) == (2) ? ((*cont)->seq) - 1 : ((*cont)->seq))) _x = ((((*cont)->continuationType) == (2) ? ((*cont)->seq) - 1 : ((*cont)->seq))); const typeof (Z) _y = (Z); (void) (&_x == &_y); _x > _y ? _x : _y;});}); bootstrapIntersectLast = (
trickles-server_2.c:29401:																																											  ((*cont)->seq) Z = (typeof ((*cont)->seq)) (bootstrapEnd); (
trickles-server_2.c:29405:																																																			((*cont)->seq) _x = ((*cont)->seq); const typeof (Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y;});}); if (bootstrapIntersectStart <= bootstrapIntersectLast)
trickles-server_2.c:29408:		       bootstrapIntersectLast - bootstrapIntersectStart + 1;}
trickles-server_2.c:29412:		       free_trickles_msk ((*cont)->sk, (*cont));
trickles-server_2.c:29413:		       free_trickles_msk_finish ((*cont)->sk, (*cont));
trickles-server_2.c:29417:		       free_trickles_msk ((*cont)->sk, (*cont));
trickles-server_2.c:29418:		       free_trickles_msk_finish ((*cont)->sk, (*cont));
trickles-server_2.c:29419:		       printk ("recovery nomem\n"); return -12;}
trickles-server_2.c:29425:		       printk ("  Bootstrap [%d - %d], newCwnd %d\n",
trickles-server_2.c:29429:		       if (gapRight - gapLeft > 20)
trickles-server_2.c:29432:		       free_trickles_msk ((*cont)->sk, (*cont));
trickles-server_2.c:29433:		       free_trickles_msk_finish ((*cont)->sk, (*cont));
trickles-server_2.c:29435:		       printk ("recovery gapsize too big - %d\n",
trickles-server_2.c:29436:			       gapRight - gapLeft); return -22;}
trickles-server_2.c:29444:		       makePacket (&(*cont)->packets[numPackets], seq,
trickles-server_2.c:29447:				    sizeof (struct WireContinuation) -
trickles-server_2.c:29448:				    (int) ((struct WireContinuation *) 0)->
trickles-server_2.c:29451:				    sizeof (struct WireContinuation) -
trickles-server_2.c:29452:				    (int) ((struct WireContinuation *) 0)->
trickles-server_2.c:29453:				    minimalContinuationEnd), -1, -1);
trickles-server_2.c:29459:		       lastRegularPacket + 1 + (seq - bootstrapStart);
trickles-server_2.c:29470:		       if (bootstrap_seq == (*cont)->TCPBase)
trickles-server_2.c:29473:		       firstChild = bootstrap_seq + (*cont)->startCwnd;
trickles-server_2.c:29477:		       prevCwnd = AckTCPCwndScalar (bootstrap_seq - 1, *cont);
trickles-server_2.c:29480:		       numChildren = currCwnd - prevCwnd + 1;}
trickles-server_2.c:29483:		       makePacket (&(*cont)->packets[numPackets],
trickles-server_2.c:29501:			   ((*cont)->continuationType == (1)
trickles-server_2.c:29502:			    || (*cont)->continuationType == (2)))
trickles-server_2.c:29505:			       "(*cont)->continuationType == CONTTYPE_FULL1 || (*cont)->continuationType == CONTTYPE_FULL2"
trickles-server_2.c:29506:			       ") failed at " "trickles-server.c" "(%d)\n",
trickles-server_2.c:29514:		       lastRegularPacket + 1 + (ack_seq - bootstrapStart);
trickles-server_2.c:29519:		       if (seq == (*cont)->TCPBase)
trickles-server_2.c:29522:		       firstChild = seq + (*cont)->startCwnd; numChildren = 1;}
trickles-server_2.c:29525:		       prevCwnd = AckTCPCwndScalar (seq - 1, *cont);
trickles-server_2.c:29528:		       numChildren = currCwnd - prevCwnd + 1;}
trickles-server_2.c:29531:		       makePacket (&(*cont)->packets[numPackets], seq,
trickles-server_2.c:29540:		       (*cont)->num_packets = numPackets;
trickles-server_2.c:29549:			       ") failed at " "trickles-server.c" "(%d)\n",
trickles-server_2.c:29561:		       if ((*cont)->startCwnd == 0)
trickles-server_2.c:29563:		       (*cont)->startCwnd = 1;}
trickles-server_2.c:29564:		       (*cont)->executionTrace = 3;
trickles-server_2.c:29566:		       AckProof_findRight (ackProof, (*cont)->TCPBase);
trickles-server_2.c:29568:		       (*cont)->actualCwnd = effCwnd;; if (effCwnd >= 2)
trickles-server_2.c:29570:		       (*cont)->ssthresh = effCwnd / 2;}
trickles-server_2.c:29573:		       (*cont)->ssthresh /= 2;}
trickles-server_2.c:29576:		       (*cont)->TCPBase = newBase;
trickles-server_2.c:29577:		       (*cont)->startCwnd = (2);
trickles-server_2.c:29578:		       (*cont)->actualCwnd = (*cont)->startCwnd;
trickles-server_2.c:29579:		       if (!alloc_msk_packets ((*cont), (*cont)->startCwnd))
trickles-server_2.c:29581:		       free_trickles_msk ((*cont)->sk, (*cont));
trickles-server_2.c:29582:		       free_trickles_msk_finish ((*cont)->sk, (*cont));
trickles-server_2.c:29583:		       return -12;}
trickles-server_2.c:29584:		       (*cont)->num_packets = (*cont)->startCwnd;
trickles-server_2.c:29585:		       int i; for (i = 0; i < (*cont)->num_packets; i++)
trickles-server_2.c:29594:		       makePacket (&(*cont)->packets[i], (*cont)->TCPBase + i,
trickles-server_2.c:29596:				   (i == 0 ? (0x80) : 0) | (0), type, 0, -1,
trickles-server_2.c:29597:				   -1);}
trickles-server_2.c:29600:		       printk ("slow start step TCPBase - %u seq - %u\n",
trickles-server_2.c:29601:			       (*cont)->TCPBase, (*cont)->packets[0].seq);;;
trickles-server_2.c:29625:		       if (!(newPmsk->refCnt == 1))
trickles-server_2.c:29627:		       printk ("KERNEL: assertion (" "newPmsk->refCnt == 1"
trickles-server_2.c:29628:			       ") failed at " "trickles-server.c" "(%d)\n",
trickles-server_2.c:29633:		       newPmsk->ctl = ALLOC_PENDING;}
trickles-server_2.c:29634:		       if (!(newPmsk->ctl == ALLOC_PENDING))
trickles-server_2.c:29637:			       "newPmsk->ctl == ALLOC_PENDING" ") failed at "
trickles-server_2.c:29638:			       "trickles-server.c" "(%d)\n", 1987);}; (
trickles-server_2.c:29640:									  (newPmsk)->seq = ((pmsk)->packets[packet_number].seq); (newPmsk)->continuationType = (pmsk)->packets[packet_number].contType; if ((pmsk)->packets[packet_number].type & (0x80))
trickles-server_2.c:29642:									  (newPmsk)->firstChild = 1;}
trickles-server_2.c:29645:									  (newPmsk)->firstChild = 0;}
trickles-server_2.c:29658:									  (pmsk)->
trickles-server_2.c:29682:									  (newPmsk)->state = stateConversionMap[conversionOffset];}
trickles-server_2.c:29684:		       newPmsk->rawTimestamp = htonl (msk->timestamp);
trickles-server_2.c:29685:		       newPmsk->rawMrtt = htonl (msk->mrtt);
trickles-server_2.c:29686:		       newPmsk->num_packets = 0; if (flags & (0x2))
trickles-server_2.c:29695:		       if (!(newPmsk->refCnt == 1))
trickles-server_2.c:29697:		       printk ("KERNEL: assertion (" "newPmsk->refCnt == 1"
trickles-server_2.c:29698:			       ") failed at " "trickles-server.c" "(%d)\n",
trickles-server_2.c:29704:		       if (!(newPmsk->refCnt == 0))
trickles-server_2.c:29706:		       printk ("KERNEL: assertion (" "newPmsk->refCnt == 0"
trickles-server_2.c:29707:			       ") failed at " "trickles-server.c" "(%d)\n",
trickles-server.c:1:#include "trickles-int.h"
trickles-server.c:3:#include "memdump-util.h"
trickles-server.c:8:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-server.c:9:	printk("At %d: %X:%d => %X:%d\n", lineno, sk->saddr, (int)ntohs(sk->sport), sk->daddr, (int)ntohs(sk->dport));
trickles-server.c:54:#define QUAD(SIGN,a,b,c) (-(b) SIGN sqrtf((b) * (b) - 4*(a)*(c))) / (2 * a)
trickles-server.c:56:   QUAD(+, 1.0/2.0, 1.0/2.0, -((int)(SSTHRESH) * ((int)(SSTHRESH) + 1)) / 2.0 - (SEQ) + (TCPBASE));
trickles-server.c:63:    val -= 0x40000000;
trickles-server.c:67:  temp = (g << (s)) + (1 << ((s) * 2 - 2));   \
trickles-server.c:69:    g += 1 << ((s)-1);                        \
trickles-server.c:70:    val -= temp;                              \
trickles-server.c:95:#define QUAD(SIGN,a,b,c) (-(b) SIGN mborg_isqrt4((b) * (b) - 4*(a)*(c))) / (2 * a)
trickles-server.c:101: * .(PREC) (since the scaling factor is taken to ^-0.5)
trickles-server.c:104:      - (1/2) + sqrt((1/2)^2 - 4*1/2*(-(ssthresh*(ssthresh+1)/2 - *(seq - TCPBase))))
trickles-server.c:109:	(((-1 << (PREC - 1)) + mborg_isqrt4((1 << (2*PREC - 2)) - ((-((int)(ssthresh) * ((int)(ssthresh) + 1)) - 2 * (((int)seq) - (TCPBase))) << (2*PREC)))) >> PREC)
trickles-server.c:112:#define MAX_CWND ((1<<13)-1)
trickles-server.c:115:// TODO: Investigate using -msoftfloat, or saving/restoring FPU state
trickles-server.c:119:  int res, hint = -1;
trickles-server.c:121:  unsigned startCwnd = cont->startCwnd;
trickles-server.c:122:  unsigned ssthresh = MIN(MAX(cont->ssthresh, startCwnd), MAX_CWND);
trickles-server.c:123:  unsigned TCPBase = cont->TCPBase;
trickles-server.c:124:  unsigned additiveStart = (ssthresh - startCwnd + TCPBase) + ssthresh;
trickles-server.c:127:  seq = TCPBase + (seq - TCPBase) * ACKTCP_CWND_SPEED_HACK;
trickles-server.c:133:    res = -1;
trickles-server.c:139:  if(seq - TCPBase > MAX_CWND * MAX_CWND) {
trickles-server.c:141:	  res = -1;
trickles-server.c:145:  if(seq < ssthresh - startCwnd + TCPBase) {
trickles-server.c:146:    res = startCwnd + (seq - TCPBase);
trickles-server.c:147:  } else if(ssthresh - startCwnd + TCPBase <= seq &&
trickles-server.c:151:	  /* result is solution to x(x+1)-ssthresh(ssthresh+1)
trickles-server.c:152:                                   --------------------------- - N
trickles-server.c:154:	  //int offset = seq - TCPBase;
trickles-server.c:155:	  int offset = seq - additiveStart;
trickles-server.c:158:	  //double a = 1.0/2.0, b = 1.0/2.0, c = -((int)ssthresh * ((int)ssthresh + 1)) / 2.0 - seq + TCPBase;
trickles-server.c:161:	  //val = 1/4 - (-((int)(ssthresh) * ((int)(ssthresh) + 1)) - 2 * (((int)seq) - (TCPBase)))
trickles-server.c:165:	  position = (cwnd*(cwnd+1)-ssthresh*(ssthresh+1)) / 2;
trickles-server.c:168:		  hint = - 1;
trickles-server.c:186:			  if(offset > position - cwnd) {
trickles-server.c:190:				  if(!(offset > position - cwnd - (cwnd - 1))) {
trickles-server.c:195:				  if((cwnd - 1) < ssthresh) {
trickles-server.c:202:				  BUG_TRAP(cwnd - 1 >= 1);
trickles-server.c:204:				  res = cwnd - 1;
trickles-server.c:205:				  hint = additiveStart + position - cwnd;
trickles-server.c:210:	  // Fixed point Newton's method to solve (cwnd*(cwnd+1) - ssthresh*(ssthresh+)) / 2 = 
trickles-server.c:218:	  if(offset >= (MAX_CWND * (MAX_CWND + 1) - ssthresh*(ssthresh+1)) / 2) {
trickles-server.c:224:	     x_{k+1} = x_k - f(x_k)/f'(x_k) */
trickles-server.c:235:		  printk("f(x_%d) * 2 = %d (%d %d %d) ", i, (x * (x + (1 << FRAC)) - (((int)ssthresh * ((int)ssthresh + 1) + 2 * offset) << (2 * FRAC))) >> (2 * FRAC), x * (x + (1 << FRAC)), (((int)ssthresh * ((int)ssthresh + 1) + 2 * offset)) << (2 * FRAC), (x * (x + (1 << FRAC)) - (((int)ssthresh * ((int)ssthresh + 1) + 2 * offset) << (2 * FRAC))));
trickles-server.c:237:		  printk("f/f' = %d ", ((x * (x + (1 << FRAC)) - (((int)ssthresh * ((int)ssthresh + 1) + 2 * offset) << (2 * FRAC))) /
trickles-server.c:241:		  position = (cwnd*(cwnd+1)-ssthresh*(ssthresh+1)) / 2;
trickles-server.c:242:		  if(offset - position >= 0 && 
trickles-server.c:243:		     offset - position < cwnd + 1) {
trickles-server.c:249:			    printk("%d iterations - result = %d\n", i, cwnd);
trickles-server.c:254:		  } else if(position - offset > 0 &&
trickles-server.c:255:			    position - offset < cwnd) {
trickles-server.c:261:			    printk("%d iterations - result = %d\n", i, cwnd);
trickles-server.c:267:		  xupdate = (x - 
trickles-server.c:268:		       ((x * (x + (1 << FRAC)) - (((int)ssthresh * ((int)ssthresh + 1) + 2 * offset) << (2 * FRAC))) /
trickles-server.c:272:			  int sign0 = ((int)ssthresh * ((int)ssthresh + 1) + 2 * offset) > 0 ? 1 : -1,
trickles-server.c:273:				  sign1 = (2 * x + (1 << FRAC)) > 0 ? 1 : -1;
trickles-server.c:274:			  x -= (sign0 * sign1) << FRAC;
trickles-server.c:281:		 (x * (x + (1 << FRAC)) - (((int)ssthresh * ((int)ssthresh + 1) + 2 * offset) << (2 * FRAC))) >> (2 * FRAC), 
trickles-server.c:289:	  res = (-(1 << (FRAC-1)) + x) >> FRAC;
trickles-server.c:299:    *hintResult = (hint >= 0) ? hint : -1;
trickles-server.c:300:  ((CONTINUATION_TYPE*)cont)->mark = res; // tricklesLossEvent gets cwnd size from here
trickles-server.c:309:  if(sack->left > sack->right) {
trickles-server.c:314:    __u32 genNonce = generateRangeNonce(cont->sk, sack->left, sack->right);
trickles-server.c:315:    if(genNonce != sack->nonceSummary) {
trickles-server.c:316:#ifdef DISABLE_NONCE_FAIL // 0715 - this was old code used force side effect from generateRangeNonce() without actually performing nonce check
trickles-server.c:321:	printk("nonce check failed for [%d-%d] = 0x%0X != 0x%0X\n", 
trickles-server.c:322:	       sack->left, sack->right, genNonce, sack->nonceSummary);
trickles-server.c:337:  return sack->left <= seq && seq <= sack->right;
trickles-server.c:341:  return right->left - left->right - 1;
trickles-server.c:355:  CONTINUATION_TYPE *cont = proof->cont;
trickles-server.c:356:  Sack *sacks = proof->sacks;
trickles-server.c:357:  int numSacks = proof->numSacks;
trickles-server.c:361:     sacks[0].left > cont->TCPBase) {
trickles-server.c:363:		  printk("Zero sacks (%d), too many sacks, or start (%u) > TCPBase (%u) [seq = %u]\n", numSacks, sacks[0].left, cont->TCPBase, cont->seq);
trickles-server.c:370:    if(i > 0 && sacks[i].left <= sacks[i-1].right) {
trickles-server.c:379:  int i, numSacks = proof->numSacks;
trickles-server.c:380:  Sack *sacks = proof->sacks;
trickles-server.c:382:    if(!Sack_adjacent(&sacks[i-1], &sacks[i])) {
trickles-server.c:383:      return sacks[i-1].right + 1;
trickles-server.c:387:  return -1;
trickles-server.c:394:  Sack *sacks = proof->sacks;
trickles-server.c:397:  for(i=0; i < proof->numSacks; i++) {
trickles-server.c:406:  if(i == proof->numSacks) {
trickles-server.c:416:  Sack *sacks = proof->sacks;
trickles-server.c:419:  for(i=0; i < proof->numSacks; i++) {
trickles-server.c:428:	  return cursor - 1;
trickles-server.c:430:	  return start - 1; // error condition
trickles-server.c:437:  Sack *sacks = proof->sacks;
trickles-server.c:440:  for(i=proof->numSacks - 1; i >= 0; i--) {
trickles-server.c:445:      cursor = sacks[i].left - 1;
trickles-server.c:460:	printk("proof(%d) = ", proof->numSacks);
trickles-server.c:461:	for(i = 0; i < proof->numSacks; i++) {
trickles-server.c:462:		printk("[%d-%d]", proof->sacks[i].left, proof->sacks[i].right);
trickles-server.c:469:	WireTrickleRequest *req = (WireTrickleRequest*)skb->data;
trickles-server.c:483:			printk("SKB too short for WireTrickleRequest, len = %d\n", skb->len);
trickles-server.c:491:	sacks_len = req->ackProof.numSacks * sizeof(WireSack);
trickles-server.c:495:	if(!(req->ackProof.numSacks <= MAXSACKS &&
trickles-server.c:503:	ucont_len = ntohs(req->ucont_len);
trickles-server.c:524:			memcpy(ucont_data, pkt_ucont_data = (char*)skb->data, ucont_len);
trickles-server.c:536:	BUG_TRAP(skb->len >= 0);
trickles-server.c:539:		input_len = skb->len;
trickles-server.c:540:		//printk("input len = %d @ %d\n", msk->input_len, (char*)&msk->input_len - (char*)msk);
trickles-server.c:553:			memcpy(input, (char*)skb->data, input_len);
trickles-server.c:565:	msk->ucont_len = ucont_len;		\
trickles-server.c:566:	msk->ucont_data = ucont_data;		\
trickles-server.c:569:	msk->input_len = input_len;		\
trickles-server.c:570:	msk->input = input;			\
trickles-server.c:574:	__u32 seqno = ntohl(req->cont.seq);
trickles-server.c:582:					skb->nh.iph, skb->h.th)) != NULL) {
trickles-server.c:584:			struct WireContinuation *scont = &req->cont;
trickles-server.c:589:			msk->sk = msk->serverSK = serverSK;
trickles-server.c:591:			msk->pmsk = packed_msk = lookup;
trickles-server.c:593:			// these fields need to be copied from the client-speciifed cont, since they are modified at the client
trickles-server.c:594:			msk->seq = ntohl(scont->seq);
trickles-server.c:595:			msk->firstChild = packed_msk->firstChild = 
trickles-server.c:596:				scont->firstChild;
trickles-server.c:597:			msk->clientState = packed_msk->clientState = 
trickles-server.c:598:				scont->clientState;
trickles-server.c:599:			msk->parent = packed_msk->parent = 
trickles-server.c:600:				scont->parent;
trickles-server.c:601:			msk->clientTimestamp = packed_msk->clientTimestamp = 
trickles-server.c:602:				scont->clientTimestamp;
trickles-server.c:604:			BUG_TRAP(msk->saddr == skb->nh.iph->daddr &&
trickles-server.c:605:				 msk->daddr == skb->nh.iph->saddr &&
trickles-server.c:606:				 msk->source == skb->h.th->dest &&
trickles-server.c:607:				 msk->dest == skb->h.th->source);
trickles-server.c:609:			BUG_TRAP(msk->ctl == ALLOC_PENDING);
trickles-server.c:626:		skb->sk = msk->sk = msk->serverSK = serverSK;
trickles-server.c:632:		msk->pmsk = packed_msk;
trickles-server.c:633:		if(!unmarshallContinuationServerMSK(skb, msk, &req->cont)) {
trickles-server.c:643:	//printk("msk->input_len = %d\n", msk->input_len);
trickles-server.c:666:	if(!SIMULATION_MODE(msk->sk)) {
trickles-server.c:667:		msk->saddr = skb->nh.iph->daddr;
trickles-server.c:668:		msk->source = skb->h.th->dest;
trickles-server.c:670:		msk->daddr = skb->nh.iph->saddr;
trickles-server.c:671:		msk->dest = skb->h.th->source;
trickles-server.c:679:	if(!SIMULATION_MODE(msk->sk)) {
trickles-server.c:682:		//printk("packets base = %p\n", msk->packets);
trickles-server.c:683:		for(i=0; i < msk->num_packets; i++) {
trickles-server.c:684:			msk->packets[i].nonce = generateSingleNonce(msk->sk, msk->packets[i].seq, &ctx);
trickles-server.c:685:			msk->packets[i].ucontLen = 0;
trickles-server.c:686:			msk->packets[i].ucontData = NULL;
trickles-server.c:688:			responseLen += msk->packets[i].len;
trickles-server.c:693:			//printk("packet[%d].len = %x (%p)\n", i, msk->packets[i].len, &msk->packets[i].len);
trickles-server.c:696:		EQ_TEST(msk->simulationLen, responseLen);
trickles-server.c:697:		EQ_TEST(msk->simulationNumPackets, 
trickles-server.c:698:			msk->num_packets);
trickles-server.c:701:		       msk->simulationLen, responseLen,
trickles-server.c:702:		       msk->simulationNumPackets, msk->num_packets);
trickles-server.c:708:		unmarshallContinuationServerMSK2PMSK(msk->sk, msk->pmsk, msk);
trickles-server.c:711:		       msk->pmsk->num_packets, msk->num_packets);
trickles-server.c:714:		queue_upcall_pmsk_prealloc(msk->sk,event,msk->pmsk);
trickles-server.c:715:		queue_upcall_pmsk(event,msk->pmsk);
trickles-server.c:718:		struct cminisock *copy = shallow_copy_msk(msk->serverSK, msk);
trickles-server.c:721:			free_trickles_msk(msk->serverSK, msk);
trickles-server.c:722:			free_trickles_msk_finish(msk->serverSK, msk);
trickles-server.c:725:		queue_upcall_msk_prealloc(msk->sk,event,copy);
trickles-server.c:727:		// printk("upcall seq is %d\n", msk->seq);
trickles-server.c:729:		queue_upcall_deliver(msk->sk);
trickles-server.c:736:		msk->ucont_len = 0;
trickles-server.c:737:		//printk("syn processing input_len = %d\n", msk->input_len);
trickles-server.c:739:		msk->clientState = 0;
trickles-server.c:740:		msk->mrtt = 0;
trickles-server.c:743:		msk->firstLoss = 0x1055;
trickles-server.c:744:		msk->firstBootstrapSeq = 0xb007;
trickles-server.c:746:		msk->ssthresh = 0x3fff; // small enough to prevent overflow when squaring
trickles-server.c:748:	msk->TCPBase = seqno;
trickles-server.c:751:		return -ENOMEM;
trickles-server.c:757:		makePacket(&msk->packets[i], seq, 1, TRICKLES_MSS, 
trickles-server.c:759:			   1 * TRICKLES_MSS,  -1, 1);
trickles-server.c:762:	msk->num_packets = num_packets;
trickles-server.c:763:	//printk("msk (%p) num packets in syn is %d\n", msk, msk->num_packets);
trickles-server.c:770:	int rval = -EINVAL;
trickles-server.c:771:	struct tcphdr *ith = in_skb->h.th;
trickles-server.c:772:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-server.c:797:	msk->serverSK = sk;						\
trickles-server.c:798:	msk->sk = sk;							\
trickles-server.c:799:	in_skb->sk = sk;						\
trickles-server.c:807:	if(ith->syn) {
trickles-server.c:814:		if(ith->ack) {
trickles-server.c:819:		msk->tokenCounterBase = tp->bigTokenCounter;
trickles-server.c:820:		tp->bigTokenCounter += ((__u64) 1)  << 32;
trickles-server.c:824:		msk->input_len = in_skb->len;
trickles-server.c:825:		//printk("msk->input_len = %d\n", msk->input_len);
trickles-server.c:826:		if(msk->input_len > 0) {
trickles-server.c:828:			msk->input = tmalloc(in_skb->sk, msk->input_len);
trickles-server.c:829:			// printk("allocated piggy input to %p\n", msk->input);
trickles-server.c:830:			if(msk->input == NULL) {
trickles-server.c:832:					printk("Could not allocate memory for SYN, len = %d\n", msk->input_len);
trickles-server.c:836:			memcpy(msk->input, (char*)in_skb->data, msk->input_len);
trickles-server.c:837:			num_packets = msk->startCwnd = INITIAL_CWND;
trickles-server.c:840:			msk->input = NULL;
trickles-server.c:844:		msk->pmsk = alloc_trickles_pmsk(sk);
trickles-server.c:845:		if(msk->pmsk == NULL) {
trickles-server.c:852:	} else if(ith->fin) {
trickles-server.c:859:	} else if(ith->rst) {
trickles-server.c:874:	if(rval != -ENOMEM) {
trickles-server.c:885:#define SIMULATIONMODE_PRINT() if(SIMULATION_MODE(skb->sk)) /*printk("simulation mode : %d\n", simPrintCount++)*/ 
trickles-server.c:892:#define DUMP_INPUTLEN()   printk("cont input len = %d @ %s:%d\n", (*cont)->input_len, __FILE__, __LINE__)
trickles-server.c:900:  int rval = -EINVAL;
trickles-server.c:913:      return -EINVAL;
trickles-server.c:916:      return -ENOMEM;
trickles-server.c:923:	  return -ENOMEM;
trickles-server.c:935:  cont->executionTrace = 0;
trickles-server.c:938:  if(!SIMULATION_MODE(cont->sk)) {
trickles-server.c:939:	  cont->ack_seq = skb->h.th->ack_seq;
trickles-server.c:941:	DECODE_SIMULATION_RESULT(skb->h.th->seq,
trickles-server.c:942:				 &cont->simulationLen,
trickles-server.c:943:				 &cont->simulationNumPackets);
trickles-server.c:945:	  cont->dbg_timestamp = jiffies;
trickles-server.c:951:  unmarshallAckProof(&ackProof, &treq_hdr->ackProof);
trickles-server.c:955:  if(!SIMULATION_MODE(cont->sk) && !AckProof_validate(&ackProof)) {
trickles-server.c:957:    if(SIMULATION_MODE(skb->sk)  && debugSimulation)
trickles-server.c:959:    return -EINVAL;
trickles-server.c:965:    printk("Server processing: %u\n", cont->seq);
trickles-server.c:971:  rangeCheck = AckProof_checkRange(&ackProof, cont->TCPBase, cont->seq);
trickles-server.c:974:  //printk("RequestType %d\n", treq_hdr->type);
trickles-server.c:975:  switch((enum TrickleRequestType)treq_hdr->type) {
trickles-server.c:978:    cont->mrtt -= cont->mrtt >> 3;
trickles-server.c:979:    cont->mrtt += jiffies - cont->timestamp;
trickles-server.c:986:    switch(cont->state) {
trickles-server.c:997:	if(!SIMULATION_MODE(skb->sk) &&					\
trickles-server.c:998:           cont->seq - cont->TCPBase >= STOMP_CONNECTIONS) {	\
trickles-server.c:1000:		  printk("Stomping connection from %X:%d\n", (*cont)->daddr, (*cont)->dest); \
trickles-server.c:1002:	  return -EINVAL;							\
trickles-server.c:1014:	  printk("  Bad or poisoned Range (ack # %u)\n", cont->seq);
trickles-server.c:1040:	if(!(AckProof_checkRange(&ackProof, cont->TCPBase, cont->firstLoss-1) == NORMALRANGE
trickles-server.c:1041:	     && AckProof_checkRange(&ackProof, cont->firstBootstrapSeq, cont->seq) == NORMALRANGE)) {
trickles-server.c:1048:	cont->TCPBase = cont->firstBootstrapSeq;
trickles-server.c:1050:	  printk("Bootstrap: TCPBase = %u CWND = %u SSTHRESH = %u\n", cont->TCPBase, cont->startCwnd, cont->ssthresh);
trickles-server.c:1066:	return -EINVAL;
trickles-server.c:1074:    cont->mrtt = (jiffies - cont->timestamp) << 3;
trickles-server.c:1084:    seq = AckProof_findRight(&ackProof, cont->TCPBase);
trickles-server.c:1085:    if(seq < cont->TCPBase) {
trickles-server.c:1086:	    printk("  SlowStart: seq < cont->TCPBase\n");
trickles-server.c:1087:	    return -EINVAL;
trickles-server.c:1102:	// dump_sk(msk->sk, __LINE__);
trickles-server.c:1120:	struct cminisock_packet *packet = &msk->packets[packet_num];
trickles-server.c:1121:	int ucontLen = packet->ucontLen;
trickles-server.c:1122:	int origSkbLen = skb->len;
trickles-server.c:1127:	static int lastChunkID = -999;
trickles-server.c:1128:	if(dbgBadChunk && ucontLen == 0 && skb->len >= sizeof(struct DataChunk)) {
trickles-server.c:1129:		struct DataChunk *chunk = (struct DataChunk*)skb->data;
trickles-server.c:1131:		if(dataLen > skb->len) {
trickles-server.c:1134:			       packet_num, skb->len, packetID, 
trickles-server.c:1136:			       chunk->chunkID, 
trickles-server.c:1138:			       -1,
trickles-server.c:1142:			printk("skb_len = %d type = %d\n", skb->len, packet->type);
trickles-server.c:1143:			//hexdump(chunk, (char*)skb->tail - (char*)chunk);
trickles-server.c:1145:		//printk("Packet %d(%d : id=%d) Chunk ID %d => length %d\n", packet_num, skb->len, packetID, /* chunk->chunkID */ -1, dataLen);
trickles-server.c:1148:		lastChunkID = chunk->chunkID;
trickles-server.c:1156:		int inferred_type = msk->tag;
trickles-server.c:1157:		printk("Packet id=%d: no output, len = %d, inferred_type = %d\n", packetID, skb->len, inferred_type);
trickles-server.c:1163:	sk = skb->sk = msk->sk;
trickles-server.c:1165:	//printk("msk_transmit_skb: skb len(%d) stcp len(%d)\n", skb->len, tcb->stcp_len);
trickles-server.c:1169:	msk->timestamp = jiffies;
trickles-server.c:1175:		if(packet->ucontData != NULL) {
trickles-server.c:1177:			       packet->ucontData, ucontLen);
trickles-server.c:1183:	if(packet->contType & CONTTYPE_HASHCOMPRESSED) {
trickles-server.c:1192:		wcont = &resp_hdr->cont;
trickles-server.c:1195:		packet->contType &= ~CONTTYPE_HASHCOMPRESSED;
trickles-server.c:1196:		fullType = packet->contType == CONTTYPE_FULL1 ||
trickles-server.c:1197:			packet->contType == CONTTYPE_FULL2;
trickles-server.c:1199:			 packet->contType == CONTTYPE_MINIMAL);
trickles-server.c:1201:		packet->contType |= CONTTYPE_HASHCOMPRESSED;
trickles-server.c:1203:		wcont->continuationType = packet->contType;
trickles-server.c:1204:		wcont->hash.timestamp = htonl(msk->timestamp);
trickles-server.c:1205:		wcont->hash.mrtt = htonl(msk->mrtt);
trickles-server.c:1206:		wcont->hash.parentSeq = msk->seq;
trickles-server.c:1207:		wcont->hash.clientState = msk->clientState;
trickles-server.c:1208:		wcont->hash.position = packet_num;
trickles-server.c:1213:			packet->contType &= ~CONTTYPE_HASHCOMPRESSED;
trickles-server.c:1215:			packet->contType |= CONTTYPE_HASHCOMPRESSED;
trickles-server.c:1217:			memcpy(wcont->hash.mac, wc_scratch->mac, HMACLEN);
trickles-server.c:1224:		//printk("%d:msk_transmit_skb(%d), %d\n", (int)jiffies, skb->len, packet->seq);
trickles-server.c:1225:		switch(packet->contType) {
trickles-server.c:1228:			resp_hdr->cont.seq = htonl(packet->seq);
trickles-server.c:1229:			resp_hdr->cont.continuationType = CONTTYPE_MINIMAL;
trickles-server.c:1230:			resp_hdr->cont.clientState = msk->clientState;
trickles-server.c:1231:			resp_hdr->cont.parent = msk->parent;
trickles-server.c:1232:			resp_hdr->cont.clientTimestamp = msk->clientTimestamp;
trickles-server.c:1238:			marshallContinuationServer(sk, &resp_hdr->cont, msk, packet_num);
trickles-server.c:1239:			// printk("sent seq %d\n", ntohl(resp_hdr->cont.seq));
trickles-server.c:1252:				if(HAS_VALID_CACHERECYCLEINDEX(msk->pmsk)) {
trickles-server.c:1253:					pminisock_cache_child(msk->serverSK, msk, 
trickles-server.c:1254:							      msk->pmsk, packet_num, CACHE_CHILD_COPY | CACHE_CHILD_CLEAR);
trickles-server.c:1257:					msk->pmsk->cacheRecycleIndex = msk->cacheRecycleIndex = packet_num;
trickles-server.c:1258:					BUG_TRAP(packet_num == msk->pmsk->cacheRecycleIndex);
trickles-server.c:1267:	resp_hdr->nonce = packet->nonce;
trickles-server.c:1269:	resp_hdr->ucont_len = htons((short)ucontLen);
trickles-server.c:1270:	//printk("resphdr->ucont_len = %d\n", resp_hdr->ucont_len);
trickles-server.c:1271:	resp_hdr->numSiblings = packet->numSiblings;
trickles-server.c:1272:	resp_hdr->position = packet->position;
trickles-server.c:1277:	//printk("transmit_skb - resp_hdr: %p, ucont_len\n", &resp_hdr->cont, ntohs(resp_hdr->ucont_len));
trickles-server.c:1281:	skb->h.th = th;
trickles-server.c:1282:	th->source = sk->sport;
trickles-server.c:1283:	th->dest = msk->dest;
trickles-server.c:1285:	th->seq = htonl(msk->seq);
trickles-server.c:1287:	// 0615 - mark each packet with a unique identifier so we know exactly how many packets were sent
trickles-server.c:1292:				      msk->daddr, msk->dest, packet->seq,
trickles-server.c:1294:				      msk->startCwnd, msk->mark /* effCwnd */, msk->ssthresh,
trickles-server.c:1295:				      msk->mrtt, msk->mrtt);
trickles-server.c:1297:	th->ack_seq = packetID;
trickles-server.c:1298:	//LOG_PACKET(sk, th->ack_seq);
trickles-server.c:1302:	th->doff = tcp_header_size >> 2;
trickles-server.c:1303:	th->res1= 0;
trickles-server.c:1304:	th->cwr = 0;
trickles-server.c:1305:	th->ece = 0;
trickles-server.c:1306:	th->urg = 0;
trickles-server.c:1308:	th->ack = 1;
trickles-server.c:1309:	th->psh = 0;
trickles-server.c:1310:	th->rst = 0;
trickles-server.c:1311:	th->syn = 0;
trickles-server.c:1312:	th->fin = 0;
trickles-server.c:1315:	th->window = 0;
trickles-server.c:1316:	th->check = 0;
trickles-server.c:1317:	th->urg_ptr = 0;
trickles-server.c:1320:				((__u16)(sizeof(WireTrickleResponse) + msk->ucont_len)));
trickles-server.c:1322:	switch(msk->tag) {
trickles-server.c:1325:			th->syn = 1; // send syn/ack
trickles-server.c:1326:			th->ack = 1;
trickles-server.c:1334:		th->fin = 1;
trickles-server.c:1338:		th->ack = 1;
trickles-server.c:1345:	numTxBytes += skb->len;
trickles-server.c:1347:	BUG_TRAP(sk->protocol == IPPROTO_TCP);
trickles-server.c:1350:	dump_sk(skb->sk, __LINE__);
trickles-server.c:1352:	trickles_checksum(skb, skb->len - origSkbLen);
trickles-server.c:1353:	err = af->queue_xmit(skb, 0);
trickles-server.c:1374:	unsigned seq = cont->seq;
trickles-server.c:1375:	if(seq - cont->TCPBase > MAX_CWND * MAX_CWND) {
trickles-server.c:1378:		__u32 right = AckProof_findRight(ackProof, cont->TCPBase),
trickles-server.c:1379:			newSeq = cont->TCPBase + MAX_CWND * MAX_CWND;
trickles-server.c:1380:		BUG_TRAP(right >= cont->TCPBase);
trickles-server.c:1387:		cont->startCwnd = cwnd;
trickles-server.c:1388:		cont->TCPBase = newSeq;
trickles-server.c:1398:	if(*hint != -1) {
trickles-server.c:1402:			int delta = seq  - *hint, ticks = 0;
trickles-server.c:1404:			if(currCwnd < cont->ssthresh) {
trickles-server.c:1405:				currCwnd = CLAMP(MIN(cont->ssthresh, 
trickles-server.c:1407:				delta -= currCwnd - prevCwnd;
trickles-server.c:1411:				BUG_TRAP(currCwnd >= cont->ssthresh);
trickles-server.c:1412:				delta -= currCwnd;
trickles-server.c:1415:			if(currCwnd < cont->ssthresh) {
trickles-server.c:1418:				*hint = seq + (-delta);
trickles-server.c:1423:		currCwnd = AckTCPCwndScalar(cont->seq, cont);
trickles-server.c:1430:    ((CONTTYPE) == CONTTYPE_FULL2 ? (SEQ) - 1 : (SEQ))
trickles-server.c:1437:    FIRST_ACKSEQ((*cont)->continuationType, 
trickles-server.c:1438:		 (*cont)->seq), firstResponseSeq;
trickles-server.c:1446:	  (*cont)->startCwnd = INITIAL_CWND;
trickles-server.c:1447:	  return doInitialCwnd(*cont, event, (*cont)->seq + 1, (*cont)->startCwnd);
trickles-server.c:1450:  (*cont)->executionTrace = 1;
trickles-server.c:1457:  prevCwnd = (first_ack_seq == (*cont)->TCPBase) ? 
trickles-server.c:1458:    (*cont)->startCwnd : 
trickles-server.c:1459:    AckTCPCwnd(first_ack_seq - 1, (*cont), &hint);
trickles-server.c:1463:  currCwnd = AckTCPCwndScalar((*cont)->seq, (*cont));
trickles-server.c:1465:  currCwnd = AckTCPHint(prevCwnd, &hint, (*cont)->seq, (*cont));
trickles-server.c:1467:  (*cont)->actualCwnd = currCwnd;
trickles-server.c:1469:  //printk("prevCwnd: %u currCwnd: %u - ", prevCwnd, currCwnd);
trickles-server.c:1471:  numOutput = MAX(0, currCwnd - (int)prevCwnd);
trickles-server.c:1473:  switch((*cont)->continuationType) {
trickles-server.c:1488:		  (*cont)->TCPBase,
trickles-server.c:1489:		  first_ack_seq - 1, prevCwnd, 
trickles-server.c:1490:		  (*cont)->seq, currCwnd);
trickles-server.c:1492:    free_trickles_msk((*cont)->sk,*cont);
trickles-server.c:1493:    free_trickles_msk_finish((*cont)->sk,*cont);
trickles-server.c:1494:    return -EINVAL;
trickles-server.c:1501:    printk("bug in cwnd generation: ack_seq = %u-%u, TCPBase = %u, "
trickles-server.c:1503:	   first_ack_seq, (*cont)->seq, (*cont)->TCPBase, 
trickles-server.c:1504:	   (*cont)->startCwnd, numOutput);
trickles-server.c:1506:    free_trickles_msk((*cont)->sk,(*cont));
trickles-server.c:1507:    free_trickles_msk_finish((*cont)->sk,(*cont));
trickles-server.c:1508:    return -EINVAL;
trickles-server.c:1518:    free_trickles_msk((*cont)->sk,(*cont));
trickles-server.c:1519:    free_trickles_msk_finish((*cont)->sk,(*cont));
trickles-server.c:1520:    return -ENOMEM;
trickles-server.c:1524:    int thisMSS, nextResponseLen = 0, firstChild = -1, 
trickles-server.c:1525:      numChildren = -1, contType;
trickles-server.c:1527:      if((*cont)->state == CONT_BOOTSTRAP) {
trickles-server.c:1532:    offset = seq - (*cont)->TCPBase;
trickles-server.c:1534:#if 1 // 0901 -- switch to minimal continuation as soon as possible. Was <= 8
trickles-server.c:1542:#define CONTTYPE(OFFSET) (((OFFSET) - SLOWSTART_CWND < 8) ? CONTTYPE_FULL1 : \
trickles-server.c:1543:			  ((((OFFSET) - SLOWSTART_CWND) % 2 == 0) ? CONTTYPE_FULL2 : \
trickles-server.c:1560:	    thisMSS = -1;
trickles-server.c:1574:	    thisMSS = -1;
trickles-server.c:1579:    makePacket(&(*cont)->packets[numPackets], seq, 0xdeadbeef, thisMSS, (first ? PTYPE_FIRST : 0) | PACKET_NORMAL, contType, nextResponseLen,
trickles-server.c:1586:  (*cont)->num_packets = numPackets;
trickles-server.c:1603:    return end - start + 1;
trickles-server.c:1621:  Sack *sacks = ackProof->sacks;
trickles-server.c:1638:  (*cont)->executionTrace = 2;
trickles-server.c:1644:	  free_trickles_msk((*cont)->sk,(*cont));
trickles-server.c:1645:	  free_trickles_msk_finish((*cont)->sk,(*cont));
trickles-server.c:1646:	  return -EINVAL;
trickles-server.c:1648:  (*cont)->state = CONT_RECOVERY;
trickles-server.c:1649:  (*cont)->firstLoss = AckProof_firstLoss(ackProof);
trickles-server.c:1650:  switch(CONTTYPE((*cont)->firstLoss - (*cont)->TCPBase)) {
trickles-server.c:1651:  case CONTTYPE_FULL1: // fall-through
trickles-server.c:1653:    origCwndPred = AckTCPCwndScalar(AckProof_firstLoss(ackProof)-1, (*cont));
trickles-server.c:1657:    origCwndPred = AckTCPCwndScalar(AckProof_firstLoss(ackProof)-2, (*cont));
trickles-server.c:1658:    adj = -1;
trickles-server.c:1663:    free_trickles_msk((*cont)->sk,(*cont));
trickles-server.c:1664:    free_trickles_msk_finish((*cont)->sk,(*cont));
trickles-server.c:1665:    return -EINVAL;
trickles-server.c:1667:  lastRegularPacket =  ((*cont)->firstLoss - 1 + adj) + origCwndPred;
trickles-server.c:1668:  (*cont)->num_packets = 0;
trickles-server.c:1676:  (*cont)->actualCwnd = newCwnd;
trickles-server.c:1680:  (*cont)->TCPBase = (*cont)->firstBootstrapSeq = lastRegularPacket + 1;
trickles-server.c:1681:  (*cont)->startCwnd = newCwnd;
trickles-server.c:1683:  (*cont)->ssthresh = newCwnd;
trickles-server.c:1686:    (*cont)->ssthresh /= MULT_FACTOR;
trickles-server.c:1688:    (*cont)->ssthresh = newCwnd;
trickles-server.c:1691:  bootstrapStart = lastRegularPacket - newCwnd;
trickles-server.c:1692:  bootstrapEnd = bootstrapStart + newCwnd - 1;
trickles-server.c:1699:  for(i=0; i < ackProof->numSacks; i++) {
trickles-server.c:1701:    if(i > 0 && !Sack_adjacent(&sacks[i-1], &sacks[i])) {
trickles-server.c:1702:      gaplen = Sack_gapLen(&sacks[i-1], &sacks[i]);
trickles-server.c:1706:	intersect(bootstrapStart, sacks[i].left-1,
trickles-server.c:1707:		  bootstrapEnd, sacks[i-1].right+1);
trickles-server.c:1709:    if(Sack_contains(&ackProof->sacks[i], (*cont)->seq)) {
trickles-server.c:1710:      if(((*cont)->seq == sacks[i].left || 
trickles-server.c:1711:	  ((*cont)->continuationType == CONTTYPE_FULL2 && (*cont)->seq - 1 == sacks[i].left))
trickles-server.c:1715:	gapLeft = ackProof->sacks[i-1].right + 1,
trickles-server.c:1716:	  gapRight = ackProof->sacks[i].left - 1;
trickles-server.c:1731:    numPacketsAllocated += (gapRight - gapLeft) + 1; // range is inclusive
trickles-server.c:1736:      numPacketsAllocated += (end - start) + 1; // range is inclusive
trickles-server.c:1741:    bootstrapIntersectStart = MAX(FIRST_ACKSEQ((*cont)->continuationType, (*cont)->seq),
trickles-server.c:1743:    bootstrapIntersectLast = MIN((*cont)->seq,
trickles-server.c:1747:	bootstrapIntersectLast - bootstrapIntersectStart + 1; // range is inclusive
trickles-server.c:1751:    free_trickles_msk((*cont)->sk,(*cont));
trickles-server.c:1752:    free_trickles_msk_finish((*cont)->sk,(*cont));
trickles-server.c:1757:    free_trickles_msk((*cont)->sk,(*cont));
trickles-server.c:1758:    free_trickles_msk_finish((*cont)->sk,(*cont));
trickles-server.c:1760:    return -ENOMEM;
trickles-server.c:1766:      printk("  Bootstrap [%d - %d], newCwnd %d\n", bootstrapStart, bootstrapEnd, newCwnd);
trickles-server.c:1770:    if(gapRight - gapLeft > MAX_GAPSIZE) {
trickles-server.c:1771:          //printk("recoveryStep: gap too large (%u-%u)\n", gapLeft, gapRight);
trickles-server.c:1772:	  free_trickles_msk((*cont)->sk,(*cont));
trickles-server.c:1773:	  free_trickles_msk_finish((*cont)->sk,(*cont));
trickles-server.c:1775:		  printk("recovery gapsize too big - %d\n", gapRight -  gapLeft);
trickles-server.c:1776:	  return -EINVAL;
trickles-server.c:1783:      makePacket(&(*cont)->packets[numPackets], seq, 0xdeadbeef, CONTTYPE_MINIMAL_MSS, PACKET_RETRANS, CONTTYPE_MINIMAL, CONTTYPE_MINIMAL_MSS, 
trickles-server.c:1784:			 -1, -1);
trickles-server.c:1790:	__u32 bootstrap_seq = lastRegularPacket + 1 + (seq - bootstrapStart);
trickles-server.c:1799:	if(bootstrap_seq == (*cont)->TCPBase) {
trickles-server.c:1801:		firstChild = bootstrap_seq + (*cont)->startCwnd;
trickles-server.c:1804:		prevCwnd = AckTCPCwndScalar(bootstrap_seq - 1, *cont);
trickles-server.c:1807:		numChildren = currCwnd - prevCwnd + 1;
trickles-server.c:1811:	makePacket(&(*cont)->packets[numPackets],
trickles-server.c:1827:  BUG_TRAP((*cont)->continuationType == CONTTYPE_FULL1 ||
trickles-server.c:1828:	   (*cont)->continuationType == CONTTYPE_FULL2);
trickles-server.c:1834:    __u32 seq = lastRegularPacket + 1 + (ack_seq - bootstrapStart);
trickles-server.c:1842:    if(seq == (*cont)->TCPBase) {
trickles-server.c:1844:      firstChild = seq + (*cont)->startCwnd;
trickles-server.c:1847:      prevCwnd = AckTCPCwndScalar(seq - 1, *cont);
trickles-server.c:1850:      numChildren = currCwnd - prevCwnd + 1;
trickles-server.c:1854:    makePacket(&(*cont)->packets[numPackets], seq, 0xdeadbeef, CONTTYPE_FULL_MSS /* len */ , 
trickles-server.c:1862:  (*cont)->num_packets = numPackets;
trickles-server.c:1882:	if((*cont)->startCwnd == 0) {
trickles-server.c:1883:		(*cont)->startCwnd = 1;
trickles-server.c:1885:  (*cont)->executionTrace = 3;
trickles-server.c:1887:  int right = AckProof_findRight(ackProof, (*cont)->TCPBase);
trickles-server.c:1890:  (*cont)->actualCwnd = effCwnd;
trickles-server.c:1895:  (*cont)->ssthresh = effCwnd / MULT_FACTOR;
trickles-server.c:1898:    (*cont)->ssthresh = effCwnd / MULT_FACTOR;
trickles-server.c:1900:    (*cont)->ssthresh /= 2;
trickles-server.c:1904:  (*cont)->TCPBase = newBase;
trickles-server.c:1905:  (*cont)->startCwnd = SLOWSTART_CWND;
trickles-server.c:1907:  (*cont)->actualCwnd = (*cont)->startCwnd;
trickles-server.c:1910:  if(!alloc_msk_packets((*cont), (*cont)->startCwnd)) {
trickles-server.c:1911:	  free_trickles_msk((*cont)->sk, (*cont));
trickles-server.c:1912:	  free_trickles_msk_finish((*cont)->sk, (*cont));
trickles-server.c:1913:	  return -ENOMEM;
trickles-server.c:1915:  (*cont)->num_packets = (*cont)->startCwnd;
trickles-server.c:1917:  for(i=0; i < (*cont)->num_packets; i++) {
trickles-server.c:1926:	  makePacket(&(*cont)->packets[i], (*cont)->TCPBase + i, 0xdeadbeef, len,
trickles-server.c:1928:		     0,  -1, -1);
trickles-server.c:1933:	  free_trickles_msk((*cont)->sk, (*cont));
trickles-server.c:1934:	  free_trickles_msk_finish((*cont)->sk, (*cont));
trickles-server.c:1935:	  return -ENOMEM;
trickles-server.c:1937:  makePacket(&(*cont)->packets[0], (*cont)->TCPBase, 0xdeadbeef, CONTTYPE_FULL_MSS /* len */,
trickles-server.c:1939:	     CONTTYPE_FULL_MSS, (*cont)->TCPBase + 1, 1);
trickles-server.c:1942:	  free_trickles_msk((*cont)->sk, (*cont));
trickles-server.c:1943:	  free_trickles_msk_finish((*cont)->sk, (*cont));
trickles-server.c:1944:	  return -ENOMEM;
trickles-server.c:1946:  makePacket(&(*cont)->packets[0], (*cont)->TCPBase, 0xdeadbeef, CONTTYPE_FULL_MSS /* len */,
trickles-server.c:1948:	     CONTTYPE_FULL_MSS, (*cont)->TCPBase + 1, 1);
trickles-server.c:1949:  makePacket(&(*cont)->packets[1], (*cont)->TCPBase, 0xdeadbeef, CONTTYPE_FULL_MSS  /* len */,
trickles-server.c:1951:	     CONTTYPE_FULL_MSS, (*cont)->TCPBase + 2, 1);
trickles-server.c:1956:	  printk("slow start step TCPBase - %u seq - %u\n", (*cont)->TCPBase, 
trickles-server.c:1957:		 (*cont)->packets[0].seq);
trickles-server.c:1982:	BUG_TRAP(newPmsk->refCnt == 1);
trickles-server.c:1985:			newPmsk->ctl = ALLOC_PENDING;
trickles-server.c:1987:		BUG_TRAP(newPmsk->ctl == ALLOC_PENDING);
trickles-server.c:1994:		newPmsk->rawTimestamp = htonl(msk->timestamp);
trickles-server.c:1995:		newPmsk->rawMrtt = htonl(msk->mrtt);
trickles-server.c:1996:		newPmsk->num_packets = 0;
trickles-server.c:2002:		// printk("inserted %u\n", newPmsk->seq);
trickles-server.c:2006:			BUG_TRAP(newPmsk->refCnt == 1);
trickles-server.c:2007:			//printk("new(%d) newPmsk->refCnt[2] = %d\n", new, newPmsk->refCnt);
trickles-server.c:2011:			BUG_TRAP(newPmsk->refCnt == 0);
trickles_shared.c:32:int cminisock_config_pipe_default(struct sock *sk, char *optdata, int optlen, int direction) { return -EINVAL; }
trickles_shared.c:34:int trickles_sendv_default(int fd, struct cminisock *msk, struct tiovec *tiov, int tiovlen) { return -EINVAL; }
trickles_shared.c:36:int trickles_send_default(int fd, struct cminisock *msk, char *buf, int len) { return -EINVAL; }
trickles_shared.c:38:int trickles_sendfilev_default(int fd, struct cminisock *msk, struct fiovec *fiov, int fiovlen) { return -EINVAL; }
trickles_shared.c:40:int trickles_mmap_default(struct file *file, struct socket *sock, struct vm_area_struct *vma) { return -ENODEV; }
trickles_shared.c:48:int trickles_sendmsg_default(struct sock *sk, struct msghdr *msg, int size) { return -EINVAL; }
trickles_shared.c:50:int trickles_setucont_default(int fd, struct cminisock *msk, int packetNum, char *ucont, unsigned ucont_len) { return -EINVAL; }
trickles_shared.c:52:int trickles_getsockopt_default(struct sock *sk, int level, int optname, char *optval, int *optlen) { return -EINVAL; }
trickles_shared.c:63:	return -EINVAL;
trickles_shared.c:67:	return -EINVAL;
trickles_shared.c:126:	return -EINVAL;
trickles_shared.c:145:#include "rand-util.h"
trickles-userapi_1.c:1:# 1 "trickles-userapi.c"
trickles-userapi_1.c:2:# 1 "<built-in>"
trickles-userapi_1.c:4:# 1 "trickles-userapi.c"
trickles-userapi_1.c:8:# 1 "trickles-int.h" 1
trickles-userapi_1.c:24:# 1 "/usr/lib/gcc-lib/i386-redhat-linux/3.2.3/include/stdarg.h" 1 3
trickles-userapi_1.c:25:# 43 "/usr/lib/gcc-lib/i386-redhat-linux/3.2.3/include/stdarg.h" 3
trickles-userapi_1.c:27:# 110 "/usr/lib/gcc-lib/i386-redhat-linux/3.2.3/include/stdarg.h" 3
trickles-userapi_1.c:422:        char _f[20-2*sizeof(long)-sizeof(int)];
trickles-userapi_1.c:709:# 1 "/home/ashieh/current/include/linux/kgdb-asserts.h" 1
trickles-userapi_1.c:724:        size = (size-1) >> (12 -1);
trickles-userapi_1.c:725:        order = -1;
trickles-userapi_1.c:997:        return ((unsigned long *)t->esp)[3];
trickles-userapi_1.c:1068:        next->prev = new;
trickles-userapi_1.c:1069:        new->next = next;
trickles-userapi_1.c:1070:        new->prev = prev;
trickles-userapi_1.c:1071:        prev->next = new;
trickles-userapi_1.c:1076:        __list_add(new, head, head->next);
trickles-userapi_1.c:1081:        __list_add(new, head->prev, head);
trickles-userapi_1.c:1086:        next->prev = prev;
trickles-userapi_1.c:1087:        prev->next = next;
trickles-userapi_1.c:1097:        __list_del(entry->prev, entry->next);
trickles-userapi_1.c:1098:        entry->next = (void *) 0;
trickles-userapi_1.c:1099:        entry->prev = (void *) 0;
trickles-userapi_1.c:1108:        __list_del(entry->prev, entry->next);
trickles-userapi_1.c:1109:        do { (entry)->next = (entry); (entry)->prev = (entry); } while (0);
trickles-userapi_1.c:1119:        __list_del(list->prev, list->next);
trickles-userapi_1.c:1131:        __list_del(list->prev, list->next);
trickles-userapi_1.c:1141:        return head->next == head;
trickles-userapi_1.c:1147:        struct list_head *first = list->next;
trickles-userapi_1.c:1148:        struct list_head *last = list->prev;
trickles-userapi_1.c:1149:        struct list_head *at = head->next;
trickles-userapi_1.c:1151:        first->prev = head;
trickles-userapi_1.c:1152:        head->next = first;
trickles-userapi_1.c:1154:        last->next = at;
trickles-userapi_1.c:1155:        at->prev = last;
trickles-userapi_1.c:1174:                do { (list)->next = (list); (list)->prev = (list); } while (0);
trickles-userapi_1.c:1391:                "movl $-1,%%eax\n\t"
trickles-userapi_1.c:1395:                "xorl -4(%%edi),%%eax\n\t"
trickles-userapi_1.c:1427:                if (set < (32 - bit))
trickles-userapi_1.c:1429:                set = 32 - bit;
trickles-userapi_1.c:1435:        res = find_first_zero_bit (p, size - 32 * (p - (unsigned long *) addr));
trickles-userapi_1.c:1459:                "movl $-1,%0\n"
trickles-userapi_1.c:1630:        q->lock = (spinlock_t) { };
trickles-userapi_1.c:1631:        do { (&q->task_list)->next = (&q->task_list); (&q->task_list)->prev = (&q->task_list); } while (0);
trickles-userapi_1.c:1644:        q->flags = 0;
trickles-userapi_1.c:1645:        q->task = p;
trickles-userapi_1.c:1659:        return !list_empty(&q->task_list);
trickles-userapi_1.c:1665:        list_add(&new->task_list, &head->task_list);
trickles-userapi_1.c:1675:        list_add_tail(&new->task_list, &head->task_list);
trickles-userapi_1.c:1686:        list_del(&old->task_list);
trickles-userapi_1.c:1727:        char __data[128 - sizeof(unsigned short)];
trickles-userapi_1.c:1796:        __ptr = (struct cmsghdr*)(((unsigned char *) __cmsg) + ( ((__cmsg->cmsg_len)+sizeof(long)-1) & ~(sizeof(long)-1) ));
trickles-userapi_1.c:1797:        if ((unsigned long)((char*)(__ptr+1) - (char *) __ctl) > __size)
trickles-userapi_1.c:1805:        return __cmsg_nxthdr(__msg->msg_control, __msg->msg_controllen, __cmsg);
trickles-userapi_1.c:1938:        return (((unsigned int) ((dev) >> 8))<<8) | ((unsigned int) ((dev) & ((1U << 8) - 1)));
trickles-userapi_1.c:1973:                :"=m" (v->counter)
trickles-userapi_1.c:1974:                :"ir" (i), "m" (v->counter));
trickles-userapi_1.c:1981:                :"=m" (v->counter)
trickles-userapi_1.c:1982:                :"ir" (i), "m" (v->counter));
trickles-userapi_1.c:1991:                :"=m" (v->counter), "=qm" (c)
trickles-userapi_1.c:1992:                :"ir" (i), "m" (v->counter) : "memory");
trickles-userapi_1.c:2000:                :"=m" (v->counter)
trickles-userapi_1.c:2001:                :"m" (v->counter));
trickles-userapi_1.c:2008:                :"=m" (v->counter)
trickles-userapi_1.c:2009:                :"m" (v->counter));
trickles-userapi_1.c:2018:                :"=m" (v->counter), "=qm" (c)
trickles-userapi_1.c:2019:                :"m" (v->counter) : "memory");
trickles-userapi_1.c:2029:                :"=m" (v->counter), "=qm" (c)
trickles-userapi_1.c:2030:                :"m" (v->counter) : "memory");
trickles-userapi_1.c:2040:                :"=m" (v->counter), "=qm" (c)
trickles-userapi_1.c:2041:                :"ir" (i), "m" (v->counter) : "memory");
trickles-userapi_1.c:2084:# 1 "/home/ashieh/current/include/linux/kgdb-defs.h" 1
trickles-userapi_1.c:2227:                atomic_inc(&mnt->mnt_count);
trickles-userapi_1.c:2236:                if (atomic_dec_and_test(&mnt->mnt_count))
trickles-userapi_1.c:2277:        while (len--)
trickles-userapi_1.c:2318:        list_del(&dentry->d_hash);
trickles-userapi_1.c:2319:        do { (&dentry->d_hash)->next = (&dentry->d_hash); (&dentry->d_hash)->prev = (&dentry->d_hash); } while (0);
trickles-userapi_1.c:2325:        return d->d_name.name != d->d_iname;
trickles-userapi_1.c:2391:                if (!((&dentry->d_count)->counter))
trickles-userapi_1.c:2393:                atomic_inc(&dentry->d_count);
trickles-userapi_1.c:2402:        return list_empty(&dentry->d_hash);
trickles-userapi_1.c:2409:        return dentry->d_mounted;
trickles-userapi_1.c:2660:        "leal -1(%%esi),%0\n"
trickles-userapi_1.c:2788:         "1" (n-1+(const char *)src),
trickles-userapi_1.c:2789:         "2" (n-1+(char *)dest)
trickles-userapi_1.c:2856:        "cmpl $-1,%1\n\t"
trickles-userapi_1.c:2989:        sem->count = 0x00000000;
trickles-userapi_1.c:2991:        do { (&sem->wait_list)->next = (&sem->wait_list); (&sem->wait_list)->prev = (&sem->wait_list); } while (0);
trickles-userapi_1.c:3017:                : "+m"(sem->count)
trickles-userapi_1.c:3039:                : "+m"(sem->count), "=&a"(result), "=&r"(tmp)
trickles-userapi_1.c:3052:        tmp = ((-0x00010000) + 0x00000001);
trickles-userapi_1.c:3067:                : "+d"(tmp), "+m"(sem->count)
trickles-userapi_1.c:3077:        signed long ret = ((__typeof__(*(&sem->count)))__cmpxchg((&sem->count),(unsigned long)(0x00000000), (unsigned long)(((-0x00010000) + 0x00000001)),sizeof(*(&sem->count))));
trickles-userapi_1.c:3090:        __s32 tmp = -0x00000001;
trickles-userapi_1.c:3106:                : "+m"(sem->count), "+d"(tmp)
trickles-userapi_1.c:3132:                : "+m"(sem->count)
trickles-userapi_1.c:3133:                : "a"(sem), "i"(-((-0x00010000) + 0x00000001))
trickles-userapi_1.c:3144:                :"=m"(sem->count)
trickles-userapi_1.c:3145:                :"ir"(delta), "m"(sem->count));
trickles-userapi_1.c:3157:                : "+r"(tmp), "=m"(sem->count)
trickles-userapi_1.c:3158:                : "r"(sem), "m"(sem->count)
trickles-userapi_1.c:3244:        (((&sem->count)->counter) = (val));
trickles-userapi_1.c:3245:        sem->sleepers = 0;
trickles-userapi_1.c:3246:        init_waitqueue_head(&sem->wait);
trickles-userapi_1.c:3292:                :"=m" (sem->count)
trickles-userapi_1.c:3319:                :"=a" (result), "=m" (sem->count)
trickles-userapi_1.c:3347:                :"=a" (result), "=m" (sem->count)
trickles-userapi_1.c:3374:                :"=m" (sem->count)
trickles-userapi_1.c:3381:        return ((&sem->count)->counter);
trickles-userapi_1.c:4015:        unsigned long sec = value->tv_sec;
trickles-userapi_1.c:4016:        long nsec = value->tv_nsec;
trickles-userapi_1.c:4018:        if (sec >= (((~0UL >> 1)-1) / 100))
trickles-userapi_1.c:4019:                return ((~0UL >> 1)-1);
trickles-userapi_1.c:4020:        nsec += 1000000000L / 100 - 1;
trickles-userapi_1.c:4028:        value->tv_nsec = (jiffies % 100) * (1000000000L / 100);
trickles-userapi_1.c:4029:        value->tv_sec = jiffies / 100;
trickles-userapi_1.c:4037:        if (0 >= (int) (mon -= 2)) {
trickles-userapi_1.c:4039:                year -= 1;
trickles-userapi_1.c:4043:                (unsigned long) (year/4 - year/100 + year/400 + 367*mon/12 + day) +
trickles-userapi_1.c:4044:                        year*365 - 719499
trickles-userapi_1.c:4217:        if (fid->Vnode == 0xfffffffe || fid->Vnode == 0xffffffff)
trickles-userapi_1.c:4218:                return ((fid->Volume << 20) | (fid->Unique & 0xfffff));
trickles-userapi_1.c:4220:                return (fid->Unique + (fid->Vnode<<10) + (fid->Volume<<20));
trickles-userapi_1.c:5218:        info->dqi_flags |= 0x10000;
trickles-userapi_1.c:5318:                        return dqopt->flags & 0x01;
trickles-userapi_1.c:5320:                        return dqopt->flags & 0x02;
trickles-userapi_1.c:5485:        inode->i_blocks += bytes >> 9;
trickles-userapi_1.c:5487:        inode->i_bytes += bytes;
trickles-userapi_1.c:5488:        if (inode->i_bytes >= 512) {
trickles-userapi_1.c:5489:                inode->i_blocks++;
trickles-userapi_1.c:5490:                inode->i_bytes -= 512;
trickles-userapi_1.c:5496:        inode->i_blocks -= bytes >> 9;
trickles-userapi_1.c:5498:        if (inode->i_bytes < bytes) {
trickles-userapi_1.c:5499:                inode->i_blocks--;
trickles-userapi_1.c:5500:                inode->i_bytes += 512;
trickles-userapi_1.c:5502:        inode->i_bytes -= bytes;
trickles-userapi_1.c:5507:        return (((loff_t)inode->i_blocks) << 9) + inode->i_bytes;
trickles-userapi_1.c:5512:        inode->i_blocks = bytes >> 9;
trickles-userapi_1.c:5513:        inode->i_bytes = bytes & 511;
trickles-userapi_1.c:5732:        timer->list.next = timer->list.prev = ((void *)0);
trickles-userapi_1.c:5737:        return timer->list.next != ((void *)0);
trickles-userapi_1.c:6593:        __s8 fs_fsmnt[512 - 212];
trickles-userapi_1.c:6828:        down(&(server->sem));
trickles-userapi_1.c:6834:        up(&(server->sem));
trickles-userapi_1.c:7021:        if (!test_and_set_bit(0,&bh_pointer->sync)) {
trickles-userapi_1.c:7024:                list_add_tail(&bh_pointer->list, bh_list);
trickles-userapi_1.c:7595:        return ((server->conn_status & 0x11) == 0);
trickles-userapi_1.c:7600:        server->conn_status |= 0x01;
trickles-userapi_1.c:7642:        x->done = 0;
trickles-userapi_1.c:7643:        init_waitqueue_head(&x->wait);
trickles-userapi_1.c:7928:        if ((((inode)->i_sb->s_flags & (64)) && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
trickles-userapi_1.c:7937:        if (inode->i_flock && (((inode)->i_sb->s_flags & (64)) && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
trickles-userapi_1.c:7946:        if (inode->i_flock && (((inode)->i_sb->s_flags & (64)) && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
trickles-userapi_1.c:7949:                        size < inode->i_size ? size : inode->i_size,
trickles-userapi_1.c:7950:                        (size < inode->i_size ? inode->i_size - size
trickles-userapi_1.c:7951:                         : size - inode->i_size)
trickles-userapi_1.c:7958:        if (inode->i_flock)
trickles-userapi_1.c:8037:        atomic_inc(&(bh)->b_count);
trickles-userapi_1.c:8043:        atomic_dec(&bh->b_count);
trickles-userapi_1.c:8052:                set_bit(BH_Uptodate, &bh->b_state);
trickles-userapi_1.c:8054:                clear_bit(BH_Uptodate, &bh->b_state);
trickles-userapi_1.c:8066:        if (test_and_clear_bit(BH_Dirty, &(bh)->b_state))
trickles-userapi_1.c:8078:        buffer_insert_list(bh, &inode->i_dirty_buffers);
trickles-userapi_1.c:8083:        buffer_insert_list(bh, &inode->i_dirty_data_buffers);
trickles-userapi_1.c:8088:        return test_and_set_bit(BH_Dirty, &bh->b_state);
trickles-userapi_1.c:8094:                set_bit(BH_Async, &bh->b_state);
trickles-userapi_1.c:8096:                clear_bit(BH_Async, &bh->b_state);
trickles-userapi_1.c:8101:        set_bit(BH_Attached, &bh->b_state);
trickles-userapi_1.c:8106:        clear_bit(BH_Attached, &bh->b_state);
trickles-userapi_1.c:8111:        return (__builtin_constant_p(BH_Attached) ? constant_test_bit((BH_Attached),(&bh->b_state)) : variable_test_bit((BH_Attached),(&bh->b_state)));
trickles-userapi_1.c:8126:        bh->b_end_io(bh, 0);
trickles-userapi_1.c:8160:        return fsync_buffers_list(&inode->i_dirty_buffers);
trickles-userapi_1.c:8164:        return fsync_buffers_list(&inode->i_dirty_data_buffers);
trickles-userapi_1.c:8180:        atomic_dec(&inode->i_writecount);
trickles-userapi_1.c:8185:                atomic_inc(&file->f_dentry->d_inode->i_writecount);
trickles-userapi_1.c:8210:        return (unsigned long)ptr > (unsigned long)-1000L;
trickles-userapi_1.c:8260:        if (inode && (inode->i_state & 64)) {
trickles-userapi_1.c:8264:                if (sb->s_op->read_inode2)
trickles-userapi_1.c:8265:                        sb->s_op->read_inode2(inode, opaque);
trickles-userapi_1.c:8267:                        sb->s_op->read_inode(inode);
trickles-userapi_1.c:8278:        if (inode && (inode->i_state & 64)) {
trickles-userapi_1.c:8279:                sb->s_op->read_inode(inode);
trickles-userapi_1.c:8322:        return bread(sb->s_dev, block, sb->s_blocksize);
trickles-userapi_1.c:8326:        return getblk(sb->s_dev, block, sb->s_blocksize);
trickles-userapi_1.c:8330:        return get_hash_table(sb->s_dev, block, sb->s_blocksize);
trickles-userapi_1.c:8440:        struct dentry *dir = dget(dentry->d_parent);
trickles-userapi_1.c:8442:        down(&dir->d_inode->i_sem);
trickles-userapi_1.c:8448:        return dget(dentry->d_parent);
trickles-userapi_1.c:8453:        up(&dir->d_inode->i_sem);
trickles-userapi_1.c:8525:        double_down(&d1->d_inode->i_sem, &d2->d_inode->i_sem);
trickles-userapi_1.c:8530:        double_up(&d1->d_inode->i_sem,&d2->d_inode->i_sem);
trickles-userapi_1.c:8753:        node->rb_parent = parent;
trickles-userapi_1.c:8754:        node->rb_color = 0;
trickles-userapi_1.c:8755:        node->rb_left = node->rb_right = ((void *)0);
trickles-userapi_1.c:9338:        __asm__("btsl %1,%0" : "=m"(*set) : "Ir"(_sig - 1) : "cc");
trickles-userapi_1.c:9343:        __asm__("btrl %1,%0" : "=m"(*set) : "Ir"(_sig - 1) : "cc");
trickles-userapi_1.c:9348:        unsigned long sig = _sig - 1;
trickles-userapi_1.c:9349:        return 1 & (set->sig[sig / 32] >> (sig % 32));
trickles-userapi_1.c:9356:                : "=r"(ret) : "m"(*set), "Ir"(_sig-1) : "cc");
trickles-userapi_1.c:9388:                int _pad[((128/sizeof(int)) - 3)];
trickles-userapi_1.c:9436:                int _pad[((64/sizeof(int)) - 3)];
trickles-userapi_1.c:9453:        if (from->si_code < 0)
trickles-userapi_1.c:9457:                (__builtin_constant_p(3*sizeof(int) + sizeof(from->_sifields._sigchld)) ? __constant_memcpy((to),(from),(3*sizeof(int) + sizeof(from->_sifields._sigchld))) : __memcpy((to),(from),(3*sizeof(int) + sizeof(from->_sifields._sigchld))));
trickles-userapi_1.c:9478:static inline void sigorsets(sigset_t *r, const sigset_t *a, const sigset_t *b) { unsigned long a0, a1, a2, a3, b0, b1, b2, b3; unsigned long i; for (i = 0; i < (64 / 32)/4; ++i) { a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; a3 = a->sig[4*i+3]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; b3 = b->sig[4*i+3]; r->sig[4*i+0] = ((a0) | (b0)); r->sig[4*i+1] = ((a1) | (b1)); r->sig[4*i+2] = ((a2) | (b2)); r->sig[4*i+3] = ((a3) | (b3)); } switch ((64 / 32) % 4) { case 3: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; r->sig[4*i+0] = ((a0) | (b0)); r->sig[4*i+1] = ((a1) | (b1)); r->sig[4*i+2] = ((a2) | (b2)); break; case 2: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; r->sig[4*i+0] = ((a0) | (b0)); r->sig[4*i+1] = ((a1) | (b1)); break; case 1: a0 = a->sig[4*i+0]; b0 = b->sig[4*i+0]; r->sig[4*i+0] = ((a0) | (b0)); break; } }
trickles-userapi_1.c:9481:static inline void sigandsets(sigset_t *r, const sigset_t *a, const sigset_t *b) { unsigned long a0, a1, a2, a3, b0, b1, b2, b3; unsigned long i; for (i = 0; i < (64 / 32)/4; ++i) { a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; a3 = a->sig[4*i+3]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; b3 = b->sig[4*i+3]; r->sig[4*i+0] = ((a0) & (b0)); r->sig[4*i+1] = ((a1) & (b1)); r->sig[4*i+2] = ((a2) & (b2)); r->sig[4*i+3] = ((a3) & (b3)); } switch ((64 / 32) % 4) { case 3: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; r->sig[4*i+0] = ((a0) & (b0)); r->sig[4*i+1] = ((a1) & (b1)); r->sig[4*i+2] = ((a2) & (b2)); break; case 2: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; r->sig[4*i+0] = ((a0) & (b0)); r->sig[4*i+1] = ((a1) & (b1)); break; case 1: a0 = a->sig[4*i+0]; b0 = b->sig[4*i+0]; r->sig[4*i+0] = ((a0) & (b0)); break; } }
trickles-userapi_1.c:9484:static inline void signandsets(sigset_t *r, const sigset_t *a, const sigset_t *b) { unsigned long a0, a1, a2, a3, b0, b1, b2, b3; unsigned long i; for (i = 0; i < (64 / 32)/4; ++i) { a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; a3 = a->sig[4*i+3]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; b3 = b->sig[4*i+3]; r->sig[4*i+0] = ((a0) & ~(b0)); r->sig[4*i+1] = ((a1) & ~(b1)); r->sig[4*i+2] = ((a2) & ~(b2)); r->sig[4*i+3] = ((a3) & ~(b3)); } switch ((64 / 32) % 4) { case 3: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; r->sig[4*i+0] = ((a0) & ~(b0)); r->sig[4*i+1] = ((a1) & ~(b1)); r->sig[4*i+2] = ((a2) & ~(b2)); break; case 2: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; r->sig[4*i+0] = ((a0) & ~(b0)); r->sig[4*i+1] = ((a1) & ~(b1)); break; case 1: a0 = a->sig[4*i+0]; b0 = b->sig[4*i+0]; r->sig[4*i+0] = ((a0) & ~(b0)); break; } }
trickles-userapi_1.c:9486:static inline void signotset(sigset_t *set) { unsigned long i; for (i = 0; i < (64 / 32)/4; ++i) { set->sig[4*i+0] = (~(set->sig[4*i+0])); set->sig[4*i+1] = (~(set->sig[4*i+1])); set->sig[4*i+2] = (~(set->sig[4*i+2])); set->sig[4*i+3] = (~(set->sig[4*i+3])); } switch ((64 / 32) % 4) { case 3: set->sig[4*i+2] = (~(set->sig[4*i+2])); case 2: set->sig[4*i+1] = (~(set->sig[4*i+1])); case 1: set->sig[4*i+0] = (~(set->sig[4*i+0])); } }
trickles-userapi_1.c:9497:        case 2: set->sig[1] = 0;
trickles-userapi_1.c:9498:        case 1: set->sig[0] = 0;
trickles-userapi_1.c:9507:                (__builtin_constant_p(-1) ? (__builtin_constant_p((sizeof(sigset_t))) ? __constant_c_and_count_memset(((set)),((0x01010101UL*(unsigned char)(-1))),((sizeof(sigset_t)))) : __constant_c_memset(((set)),((0x01010101UL*(unsigned char)(-1))),((sizeof(sigset_t))))) : (__builtin_constant_p((sizeof(sigset_t))) ? __memset_generic((((set))),(((-1))),(((sizeof(sigset_t))))) : __memset_generic(((set)),((-1)),((sizeof(sigset_t))))));
trickles-userapi_1.c:9509:        case 2: set->sig[1] = -1;
trickles-userapi_1.c:9510:        case 1: set->sig[0] = -1;
trickles-userapi_1.c:9521:        set->sig[0] |= mask;
trickles-userapi_1.c:9526:        set->sig[0] &= ~mask;
trickles-userapi_1.c:9531:        return (set->sig[0] & mask) != 0;
trickles-userapi_1.c:9536:        set->sig[0] = mask;
trickles-userapi_1.c:9539:                (__builtin_constant_p(0) ? (__builtin_constant_p((sizeof(long)*((64 / 32)-1))) ? __constant_c_and_count_memset(((&set->sig[1])),((0x01010101UL*(unsigned char)(0))),((sizeof(long)*((64 / 32)-1)))) : __constant_c_memset(((&set->sig[1])),((0x01010101UL*(unsigned char)(0))),((sizeof(long)*((64 / 32)-1))))) : (__builtin_constant_p((sizeof(long)*((64 / 32)-1))) ? __memset_generic((((&set->sig[1]))),(((0))),(((sizeof(long)*((64 / 32)-1))))) : __memset_generic(((&set->sig[1])),((0)),((sizeof(long)*((64 / 32)-1))))));
trickles-userapi_1.c:9541:        case 2: set->sig[1] = 0;
trickles-userapi_1.c:9548:        set->sig[0] = ~mask;
trickles-userapi_1.c:9551:                (__builtin_constant_p(-1) ? (__builtin_constant_p((sizeof(long)*((64 / 32)-1))) ? __constant_c_and_count_memset(((&set->sig[1])),((0x01010101UL*(unsigned char)(-1))),((sizeof(long)*((64 / 32)-1)))) : __constant_c_memset(((&set->sig[1])),((0x01010101UL*(unsigned char)(-1))),((sizeof(long)*((64 / 32)-1))))) : (__builtin_constant_p((sizeof(long)*((64 / 32)-1))) ? __memset_generic((((&set->sig[1]))),(((-1))),(((sizeof(long)*((64 / 32)-1))))) : __memset_generic(((&set->sig[1])),((-1)),((sizeof(long)*((64 / 32)-1))))));
trickles-userapi_1.c:9553:        case 2: set->sig[1] = -1;
trickles-userapi_1.c:9562:        sigemptyset(&sig->signal);
trickles-userapi_1.c:9563:        sig->head = ((void *)0);
trickles-userapi_1.c:9564:        sig->tail = &sig->head;
trickles-userapi_1.c:9604:        (void)(&fs->lock);
trickles-userapi_1.c:9605:        old_root = fs->root;
trickles-userapi_1.c:9606:        old_rootmnt = fs->rootmnt;
trickles-userapi_1.c:9607:        fs->rootmnt = mntget(mnt);
trickles-userapi_1.c:9608:        fs->root = dget(dentry);
trickles-userapi_1.c:9627:        (void)(&fs->lock);
trickles-userapi_1.c:9628:        old_pwd = fs->pwd;
trickles-userapi_1.c:9629:        old_pwdmnt = fs->pwdmnt;
trickles-userapi_1.c:9630:        fs->pwdmnt = mntget(mnt);
trickles-userapi_1.c:9631:        fs->pwd = dget(dentry);
trickles-userapi_1.c:9945:        struct task_struct **htable = &pidhash[((((p->pid) >> 8) ^ (p->pid)) & ((4096 >> 2) - 1))];
trickles-userapi_1.c:9947:        if((p->pidhash_next = *htable) != ((void *)0))
trickles-userapi_1.c:9948:                (*htable)->pidhash_pprev = &p->pidhash_next;
trickles-userapi_1.c:9950:        p->pidhash_pprev = htable;
trickles-userapi_1.c:9955:        if(p->pidhash_next)
trickles-userapi_1.c:9956:                p->pidhash_next->pidhash_pprev = p->pidhash_pprev;
trickles-userapi_1.c:9957:        *p->pidhash_pprev = p->pidhash_next;
trickles-userapi_1.c:9962:        struct task_struct *p, **htable = &pidhash[((((pid) >> 8) ^ (pid)) & ((4096 >> 2) - 1))];
trickles-userapi_1.c:9964:        for(p = *htable; p && p->pid != pid; p = p->pidhash_next)
trickles-userapi_1.c:9974:        tsk->processor = cpu;
trickles-userapi_1.c:9975:        tsk->cpus_runnable = 1UL << cpu;
trickles-userapi_1.c:9980:        tsk->cpus_runnable = ~0UL;
trickles-userapi_1.c:10054:        return (p->sigpending != 0);
trickles-userapi_1.c:10068:                for (i = (64 / 32), ready = 0; --i >= 0 ;)
trickles-userapi_1.c:10069:                        ready |= signal->sig[i] &~ blocked->sig[i];
trickles-userapi_1.c:10072:        case 4: ready = signal->sig[3] &~ blocked->sig[3];
trickles-userapi_1.c:10073:                ready |= signal->sig[2] &~ blocked->sig[2];
trickles-userapi_1.c:10074:                ready |= signal->sig[1] &~ blocked->sig[1];
trickles-userapi_1.c:10075:                ready |= signal->sig[0] &~ blocked->sig[0];
trickles-userapi_1.c:10078:        case 2: ready = signal->sig[1] &~ blocked->sig[1];
trickles-userapi_1.c:10079:                ready |= signal->sig[0] &~ blocked->sig[0];
trickles-userapi_1.c:10082:        case 1: ready = signal->sig[0] &~ blocked->sig[0];
trickles-userapi_1.c:10093:        t->sigpending = has_pending_signals(&t->pending.signal, &t->blocked);
trickles-userapi_1.c:10100:        return (sp - get_current()->sas_ss_sp < get_current()->sas_ss_size);
trickles-userapi_1.c:10105:        return (get_current()->sas_ss_size == 0 ? 2
trickles-userapi_1.c:10116:        if (!( (1 << (0 +1)) & 0x00000000 ? (1 << (0)) & 0x00000000 : (1 << (0)) & securebits ) && get_current()->euid == 0) {
trickles-userapi_1.c:10117:                get_current()->flags |= 0x00000100;
trickles-userapi_1.c:10125:        if (!( (1 << (0 +1)) & 0x00000000 ? (1 << (0)) & 0x00000000 : (1 << (0)) & securebits ) && get_current()->fsuid == 0) {
trickles-userapi_1.c:10126:                get_current()->flags |= 0x00000100;
trickles-userapi_1.c:10141:        if (((get_current()->cap_effective) & (1 << (cap))))
trickles-userapi_1.c:10146:                get_current()->flags |= 0x00000100;
trickles-userapi_1.c:10164:        if (atomic_dec_and_test(&mm->mm_count))
trickles-userapi_1.c:10206:        nr_running--;
trickles-userapi_1.c:10207:        p->sleep_time = jiffies;
trickles-userapi_1.c:10208:        list_del(&p->run_list);
trickles-userapi_1.c:10209:        p->run_list.next = ((void *)0);
trickles-userapi_1.c:10214:        return (p->run_list.next != ((void *)0));
trickles-userapi_1.c:10222:        nr_threads--;
trickles-userapi_1.c:10224:        do { (p)->next_task->prev_task = (p)->prev_task; (p)->prev_task->next_task = (p)->next_task; if ((p)->p_osptr) (p)->p_osptr->p_ysptr = (p)->p_ysptr; if ((p)->p_ysptr) (p)->p_ysptr->p_osptr = (p)->p_osptr; else (p)->p_pptr->p_cptr = (p)->p_osptr; } while (0);
trickles-userapi_1.c:10225:        list_del(&p->thread_group);
trickles-userapi_1.c:10232:        (void)(&p->alloc_lock);
trickles-userapi_1.c:10247:        (void)(&get_current()->fs->lock);
trickles-userapi_1.c:10248:        rootmnt = mntget(get_current()->fs->rootmnt);
trickles-userapi_1.c:10249:        root = dget(get_current()->fs->root);
trickles-userapi_1.c:10261:        return (__builtin_expect((get_current()->need_resched),0));
trickles-userapi_1.c:10386:        pg_data_t *pgdat = zone->zone_pgdat;
trickles-userapi_1.c:10388:        if (zone - pgdat->node_zones < 3 - 1)
trickles-userapi_1.c:10391:        else if (pgdat->node_next) {
trickles-userapi_1.c:10392:                pgdat = pgdat->node_next;
trickles-userapi_1.c:10393:                zone = pgdat->node_zones;
trickles-userapi_1.c:10405:                char reserved[(1UL << 12) - 10];
trickles-userapi_1.c:10569:        return (new < 3) ? -1 : 0;
trickles-userapi_1.c:10835:        FIX_IO_APIC_BASE_END = FIX_IO_APIC_BASE_0 + 8 -1,
trickles-userapi_1.c:10841:        FIX_BTMAP_BEGIN = FIX_BTMAP_END + 16 - 1,
trickles-userapi_1.c:10861:        return ((0xffffe000UL) - ((idx) << 12));
trickles-userapi_1.c:10877:# 1 "/home/ashieh/current/include/asm/pgtable-2level.h" 1
trickles-userapi_1.c:10878:# 32 "/home/ashieh/current/include/asm/pgtable-2level.h"
trickles-userapi_1.c:10882:# 55 "/home/ashieh/current/include/asm/pgtable-2level.h"
trickles-userapi_1.c:10915:        pte.pte_low &= ((~((1UL << 12)-1)) | 0x020 | 0x040);
trickles-userapi_1.c:10999:        return zone_table[page->flags >> (32 - 8)];
trickles-userapi_1.c:11004:        page->flags &= ~(~0UL << (32 - 8));
trickles-userapi_1.c:11005:        page->flags |= zone_num << (32 - 8);
trickles-userapi_1.c:11119:        return ((&(page)->count)->counter) - !!page->buffers == 1;
trickles-userapi_1.c:11146:        unsigned long ret = -22;
trickles-userapi_1.c:11147:        if ((offset + (((len)+(1UL << 12)-1)&(~((1UL << 12)-1)))) < offset)
trickles-userapi_1.c:11149:        if (!(offset & ~(~((1UL << 12)-1))))
trickles-userapi_1.c:11150:                ret = do_mmap_pgoff(get_current()->mm, file, addr, len, prot, flag,
trickles-userapi_1.c:11162:        prev->vm_next = vma->vm_next;
trickles-userapi_1.c:11163:        rb_erase(&vma->vm_rb, &mm->mm_rb);
trickles-userapi_1.c:11164:        if (mm->mmap_cache == vma)
trickles-userapi_1.c:11165:                mm->mmap_cache = prev;
trickles-userapi_1.c:11170:        if (!vma->vm_file && vma->vm_flags == vm_flags)
trickles-userapi_1.c:11189:        if (get_current()->flags & 0x00004000)
trickles-userapi_1.c:11206:        address &= (~((1UL << 12)-1));
trickles-userapi_1.c:11207:        (void)(&vma->vm_mm->page_table_lock);
trickles-userapi_1.c:11208:        grow = (vma->vm_start - address) >> 12;
trickles-userapi_1.c:11209:        if (vma->vm_end - address > get_current()->rlim[3].rlim_cur ||
trickles-userapi_1.c:11210:            ((vma->vm_mm->total_vm + grow) << 12) > get_current()->rlim[9].rlim_cur) {
trickles-userapi_1.c:11212:                return -12;
trickles-userapi_1.c:11214:        vma->vm_start = address;
trickles-userapi_1.c:11215:        vma->vm_pgoff -= grow;
trickles-userapi_1.c:11216:        vma->vm_mm->total_vm += grow;
trickles-userapi_1.c:11217:        if (vma->vm_flags & 0x00002000)
trickles-userapi_1.c:11218:                vma->vm_mm->locked_vm += grow;
trickles-userapi_1.c:11234:        if (vma && end_addr <= vma->vm_start)
trickles-userapi_1.c:11256:                (__builtin_constant_p((1024 - ((((unsigned long)(0xC0000000)))/(1UL << 22))) * sizeof(pgd_t)) ? __constant_memcpy((pgd + ((((unsigned long)(0xC0000000)))/(1UL << 22))),(swapper_pg_dir + ((((unsigned long)(0xC0000000)))/(1UL << 22))),((1024 - ((((unsigned long)(0xC0000000)))/(1UL << 22))) * sizeof(pgd_t))) : __memcpy((pgd + ((((unsigned long)(0xC0000000)))/(1UL << 22))),(swapper_pg_dir + ((((unsigned long)(0xC0000000)))/(1UL << 22))),((1024 - ((((unsigned long)(0xC0000000)))/(1UL << 22))) * sizeof(pgd_t))));
trickles-userapi_1.c:11272:                (boot_cpu_data.pgtable_cache_sz)--;
trickles-userapi_1.c:11316:                (boot_cpu_data.pgtable_cache_sz)--;
trickles-userapi_1.c:11337:        if (mm == get_current()->active_mm)
trickles-userapi_1.c:11344:        if (vma->vm_mm == get_current()->active_mm)
trickles-userapi_1.c:11351:        if (mm == get_current()->active_mm)
trickles-userapi_1.c:11364:static inline void *kmap(struct page *page) { return ((void *)((unsigned long)((((page) - page_zone(page)->zone_mem_map) << 12) + page_zone(page)->zone_start_paddr)+((unsigned long)(0xC0000000)))); }
trickles-userapi_1.c:11616:        return (list->next == (struct sk_buff *) list);
trickles-userapi_1.c:11621:        atomic_inc(&skb->users);
trickles-userapi_1.c:11627:        if (((&skb->users)->counter) == 1 || atomic_dec_and_test(&skb->users))
trickles-userapi_1.c:11634:        if (((&skb->users)->counter) == 1 || atomic_dec_and_test(&skb->users))
trickles-userapi_1.c:11640:        return skb->cloned && ((&((struct skb_shared_info *)((skb)->end))->dataref)->counter) != 1;
trickles-userapi_1.c:11645:        return (((&skb->users)->counter) != 1);
trickles-userapi_1.c:11671:        struct sk_buff *list = ((struct sk_buff *)list_)->next;
trickles-userapi_1.c:11679:        struct sk_buff *list = ((struct sk_buff *)list_)->prev;
trickles-userapi_1.c:11687:        return(list_->qlen);
trickles-userapi_1.c:11693:        list->prev = (struct sk_buff *)list;
trickles-userapi_1.c:11694:        list->next = (struct sk_buff *)list;
trickles-userapi_1.c:11695:        list->qlen = 0;
trickles-userapi_1.c:11702:        newsk->list = list;
trickles-userapi_1.c:11703:        list->qlen++;
trickles-userapi_1.c:11705:        next = prev->next;
trickles-userapi_1.c:11706:        newsk->next = next;
trickles-userapi_1.c:11707:        newsk->prev = prev;
trickles-userapi_1.c:11708:        next->prev = newsk;
trickles-userapi_1.c:11709:        prev->next = newsk;
trickles-userapi_1.c:11716:        do { do { __asm__ __volatile__("pushfl ; popl %0":"=g" (flags): ); __asm__ __volatile__("cli": : :"memory"); } while(0);; (void)(&list->lock); } while (0);
trickles-userapi_1.c:11725:        newsk->list = list;
trickles-userapi_1.c:11726:        list->qlen++;
trickles-userapi_1.c:11728:        prev = next->prev;
trickles-userapi_1.c:11729:        newsk->next = next;
trickles-userapi_1.c:11730:        newsk->prev = prev;
trickles-userapi_1.c:11731:        next->prev = newsk;
trickles-userapi_1.c:11732:        prev->next = newsk;
trickles-userapi_1.c:11739:        do { do { __asm__ __volatile__("pushfl ; popl %0":"=g" (flags): ); __asm__ __volatile__("cli": : :"memory"); } while(0);; (void)(&list->lock); } while (0);
trickles-userapi_1.c:11749:        next = prev->next;
trickles-userapi_1.c:11753:                next = next->next;
trickles-userapi_1.c:11754:                list->qlen--;
trickles-userapi_1.c:11755:                next->prev = prev;
trickles-userapi_1.c:11756:                prev->next = next;
trickles-userapi_1.c:11757:                result->next = ((void *)0);
trickles-userapi_1.c:11758:                result->prev = ((void *)0);
trickles-userapi_1.c:11759:                result->list = ((void *)0);
trickles-userapi_1.c:11769:        do { do { __asm__ __volatile__("pushfl ; popl %0":"=g" (flags): ); __asm__ __volatile__("cli": : :"memory"); } while(0);; (void)(&list->lock); } while (0);
trickles-userapi_1.c:11783:        newsk->next = next;
trickles-userapi_1.c:11784:        newsk->prev = prev;
trickles-userapi_1.c:11785:        next->prev = newsk;
trickles-userapi_1.c:11786:        prev->next = newsk;
trickles-userapi_1.c:11787:        newsk->list = list;
trickles-userapi_1.c:11788:        list->qlen++;
trickles-userapi_1.c:11795:        do { do { __asm__ __volatile__("pushfl ; popl %0":"=g" (flags): ); __asm__ __volatile__("cli": : :"memory"); } while(0);; (void)(&old->list->lock); } while (0);
trickles-userapi_1.c:11796:        __skb_insert(newsk, old->prev, old, old->list);
trickles-userapi_1.c:11806:        __skb_insert(newsk, old, old->next, old->list);
trickles-userapi_1.c:11813:        do { do { __asm__ __volatile__("pushfl ; popl %0":"=g" (flags): ); __asm__ __volatile__("cli": : :"memory"); } while(0);; (void)(&old->list->lock); } while (0);
trickles-userapi_1.c:11827:        list->qlen--;
trickles-userapi_1.c:11828:        next = skb->next;
trickles-userapi_1.c:11829:        prev = skb->prev;
trickles-userapi_1.c:11830:        skb->next = ((void *)0);
trickles-userapi_1.c:11831:        skb->prev = ((void *)0);
trickles-userapi_1.c:11832:        skb->list = ((void *)0);
trickles-userapi_1.c:11833:        next->prev = prev;
trickles-userapi_1.c:11834:        prev->next = next;
trickles-userapi_1.c:11839:        struct sk_buff_head *list = skb->list;
trickles-userapi_1.c:11844:                do { do { __asm__ __volatile__("pushfl ; popl %0":"=g" (flags): ); __asm__ __volatile__("cli": : :"memory"); } while(0);; (void)(&list->lock); } while (0);
trickles-userapi_1.c:11845:                if(skb->list == list)
trickles-userapi_1.c:11846:                        __skb_unlink(skb, skb->list);
trickles-userapi_1.c:11864:        do { do { __asm__ __volatile__("pushfl ; popl %0":"=g" (flags): ); __asm__ __volatile__("cli": : :"memory"); } while(0);; (void)(&list->lock); } while (0);
trickles-userapi_1.c:11872:        return skb->data_len;
trickles-userapi_1.c:11877:        return skb->len - skb->data_len;
trickles-userapi_1.c:11882:        unsigned char *tmp=skb->tail;
trickles-userapi_1.c:11884:        skb->tail+=len;
trickles-userapi_1.c:11885:        skb->len+=len;
trickles-userapi_1.c:11891:        unsigned char *tmp=skb->tail;
trickles-userapi_1.c:11893:        skb->tail+=len;
trickles-userapi_1.c:11894:        skb->len+=len;
trickles-userapi_1.c:11895:        if(skb->tail>skb->end) {
trickles-userapi_1.c:11903:        skb->data-=len;
trickles-userapi_1.c:11904:        skb->len+=len;
trickles-userapi_1.c:11905:        return skb->data;
trickles-userapi_1.c:11910:        skb->data-=len;
trickles-userapi_1.c:11911:        skb->len+=len;
trickles-userapi_1.c:11912:        if(skb->data<skb->head) {
trickles-userapi_1.c:11915:        return skb->data;
trickles-userapi_1.c:11920:        skb->len-=len;
trickles-userapi_1.c:11921:        if (skb->len < skb->data_len)
trickles-userapi_1.c:11923:        return skb->data+=len;
trickles-userapi_1.c:11928:        if (len > skb->len)
trickles-userapi_1.c:11938:            __pskb_pull_tail(skb, len-skb_headlen(skb)) == ((void *)0))
trickles-userapi_1.c:11940:        skb->len -= len;
trickles-userapi_1.c:11941:        return skb->data += len;
trickles-userapi_1.c:11946:        if (len > skb->len)
trickles-userapi_1.c:11955:        if (len > skb->len)
trickles-userapi_1.c:11957:        return (__pskb_pull_tail(skb, len-skb_headlen(skb)) != ((void *)0));
trickles-userapi_1.c:11962:        return skb->data-skb->head;
trickles-userapi_1.c:11967:        return skb_is_nonlinear(skb) ? 0 : skb->end-skb->tail;
trickles-userapi_1.c:11972:        skb->data+=len;
trickles-userapi_1.c:11973:        skb->tail+=len;
trickles-userapi_1.c:11980:        if (!skb->data_len) {
trickles-userapi_1.c:11981:                skb->len = len;
trickles-userapi_1.c:11982:                skb->tail = skb->data+len;
trickles-userapi_1.c:11990:        if (skb->len > len) {
trickles-userapi_1.c:11998:        if (!skb->data_len) {
trickles-userapi_1.c:11999:                skb->len = len;
trickles-userapi_1.c:12000:                skb->tail = skb->data+len;
trickles-userapi_1.c:12009:        if (len < skb->len)
trickles-userapi_1.c:12016:        if (skb->destructor)
trickles-userapi_1.c:12017:                skb->destructor(skb);
trickles-userapi_1.c:12018:        skb->destructor = ((void *)0);
trickles-userapi_1.c:12019:        skb->sk = ((void *)0);
trickles-userapi_1.c:12057:        int delta = (headroom > 16 ? headroom : 16) - skb_headroom(skb);
trickles-userapi_1.c:12069:        unsigned int size = skb->len;
trickles-userapi_1.c:12072:        return skb_pad(skb, len-size);
trickles-userapi_1.c:12085:        return kmap(frag->page);
trickles-userapi_1.c:12122:        if (nfct && atomic_dec_and_test(&nfct->master->use))
trickles-userapi_1.c:12123:                nfct->master->destroy(nfct->master);
trickles-userapi_1.c:12129:                atomic_inc(&nfct->master->use);
trickles-userapi_1.c:12153:# 6 "trickles-int.h" 2
trickles-userapi_1.c:12180:        return (({ unsigned long flag,sum; asm("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0" :"=&r" (flag), "=r" (sum) :"1" (addr),"g" ((int)(size)),"g" (get_current()->addr_limit.seg)); flag; }) == 0) ? 0 : -14;
trickles-userapi_1.c:12227:        if ((({ unsigned long flag,sum; asm("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0" :"=&r" (flag), "=r" (sum) :"1" (to),"g" ((int)(n)),"g" (get_current()->addr_limit.seg)); flag; }) == 0))
trickles-userapi_1.c:12235:        if ((({ unsigned long flag,sum; asm("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0" :"=&r" (flag), "=r" (sum) :"1" (from),"g" ((int)(n)),"g" (get_current()->addr_limit.seg)); flag; }) == 0))
trickles-userapi_1.c:12281:        pt->error = 0;
trickles-userapi_1.c:12282:        pt->table = ((void *)0);
trickles-userapi_1.c:12299:        nr = ((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long));
trickles-userapi_1.c:12304:                        error = -14;
trickles-userapi_1.c:12315:                (__builtin_constant_p(((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long))) ? __constant_copy_to_user_nocheck((ufdset),(fdset),(((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)))) : __generic_copy_to_user_nocheck((ufdset),(fdset),(((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)))));
trickles-userapi_1.c:12321:        (__builtin_constant_p(0) ? (__builtin_constant_p((((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)))) ? __constant_c_and_count_memset(((fdset)),((0x01010101UL*(unsigned char)(0))),((((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long))))) : __constant_c_memset(((fdset)),((0x01010101UL*(unsigned char)(0))),((((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)))))) : (__builtin_constant_p((((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)))) ? __memset_generic((((fdset))),(((0))),(((((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)))))) : __memset_generic(((fdset)),((0)),((((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)))))));
trickles-userapi_1.c:12435:  unsigned char __pad[16 - sizeof(short int) -
trickles-userapi_1.c:12436:                        sizeof(unsigned short int) - sizeof(struct in_addr)];
trickles-userapi_1.c:12902:        unsigned long hh_data[(((32)+(16 -1))&~(16 - 1)) / sizeof(long)];
trickles-userapi_1.c:13254:        eip -= (unsigned long) &_stext;
trickles-userapi_1.c:13261:        if (eip > prof_len-1)
trickles-userapi_1.c:13262:                eip = prof_len-1;
trickles-userapi_1.c:13351:        if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
trickles-userapi_1.c:13359:        if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
trickles-userapi_1.c:13366:        atomic_inc(&t->count);
trickles-userapi_1.c:13380:        atomic_dec(&t->count);
trickles-userapi_1.c:13386:        atomic_dec(&t->count);
trickles-userapi_1.c:13489:        if (!test_and_set_bit(__LINK_STATE_SCHED, &dev->state)) {
trickles-userapi_1.c:13494:                dev->next_sched = softnet_data[cpu].output_queue;
trickles-userapi_1.c:13503:        if (!(__builtin_constant_p(__LINK_STATE_XOFF) ? constant_test_bit((__LINK_STATE_XOFF),(&dev->state)) : variable_test_bit((__LINK_STATE_XOFF),(&dev->state))))
trickles-userapi_1.c:13509:        clear_bit(__LINK_STATE_XOFF, &dev->state);
trickles-userapi_1.c:13514:        if (test_and_clear_bit(__LINK_STATE_XOFF, &dev->state))
trickles-userapi_1.c:13520:        set_bit(__LINK_STATE_XOFF, &dev->state);
trickles-userapi_1.c:13525:        return (__builtin_constant_p(__LINK_STATE_XOFF) ? constant_test_bit((__LINK_STATE_XOFF),(&dev->state)) : variable_test_bit((__LINK_STATE_XOFF),(&dev->state)));
trickles-userapi_1.c:13530:        return (__builtin_constant_p(__LINK_STATE_START) ? constant_test_bit((__LINK_STATE_START),(&dev->state)) : variable_test_bit((__LINK_STATE_START),(&dev->state)));
trickles-userapi_1.c:13539:        if (atomic_dec_and_test(&skb->users)) {
trickles-userapi_1.c:13544:                skb->next = softnet_data[cpu].completion_queue;
trickles-userapi_1.c:13595:        if (atomic_dec_and_test(&dev->refcnt))
trickles-userapi_1.c:13601:        return !(__builtin_constant_p(__LINK_STATE_NOCARRIER) ? constant_test_bit((__LINK_STATE_NOCARRIER),(&dev->state)) : variable_test_bit((__LINK_STATE_NOCARRIER),(&dev->state)));
trickles-userapi_1.c:13608:        clear_bit(__LINK_STATE_NOCARRIER, &dev->state);
trickles-userapi_1.c:13615:        set_bit(__LINK_STATE_NOCARRIER, &dev->state);
trickles-userapi_1.c:13621:        return (__builtin_constant_p(__LINK_STATE_PRESENT) ? constant_test_bit((__LINK_STATE_PRESENT),(&dev->state)) : variable_test_bit((__LINK_STATE_PRESENT),(&dev->state)));
trickles-userapi_1.c:13626:        if (test_and_clear_bit(__LINK_STATE_PRESENT, &dev->state) &&
trickles-userapi_1.c:13634:        if (!test_and_set_bit(__LINK_STATE_PRESENT, &dev->state) &&
trickles-userapi_1.c:13667:                !test_and_set_bit(__LINK_STATE_RX_SCHED, &dev->state);
trickles-userapi_1.c:13680:        atomic_inc(&(dev)->refcnt);
trickles-userapi_1.c:13681:        list_add_tail(&dev->poll_list, &softnet_data[cpu].poll_list);
trickles-userapi_1.c:13682:        if (dev->quota < 0)
trickles-userapi_1.c:13683:                dev->quota += dev->weight;
trickles-userapi_1.c:13685:                dev->quota = dev->weight;
trickles-userapi_1.c:13707:                dev->quota += undo;
trickles-userapi_1.c:13710:                list_add_tail(&dev->poll_list, &softnet_data[cpu].poll_list);
trickles-userapi_1.c:13728:        if (!(__builtin_constant_p(__LINK_STATE_RX_SCHED) ? constant_test_bit((__LINK_STATE_RX_SCHED),(&dev->state)) : variable_test_bit((__LINK_STATE_RX_SCHED),(&dev->state)))) do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0);
trickles-userapi_1.c:13729:        list_del(&dev->poll_list);
trickles-userapi_1.c:13731:        clear_bit(__LINK_STATE_RX_SCHED, &dev->state);
trickles-userapi_1.c:13737:        while (test_and_set_bit(__LINK_STATE_RX_SCHED, &dev->state)) {
trickles-userapi_1.c:13739:                get_current()->state = 1;
trickles-userapi_1.c:13746:        clear_bit(__LINK_STATE_RX_SCHED, &dev->state);
trickles-userapi_1.c:13754:        if (!(__builtin_constant_p(__LINK_STATE_RX_SCHED) ? constant_test_bit((__LINK_STATE_RX_SCHED),(&dev->state)) : variable_test_bit((__LINK_STATE_RX_SCHED),(&dev->state)))) do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0);
trickles-userapi_1.c:13755:        list_del(&dev->poll_list);
trickles-userapi_1.c:13757:        clear_bit(__LINK_STATE_RX_SCHED, &dev->state);
trickles-userapi_1.c:13762:        do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&dev->xmit_lock); } while (0);
trickles-userapi_1.c:13764:        do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0);
trickles-userapi_1.c:14110:        return fp->len*sizeof(struct sock_filter) + sizeof(*fp);
trickles-userapi_1.c:14173:        unsigned char ha[(8 +sizeof(unsigned long)-1)&~(sizeof(unsigned long)-1)];
trickles-userapi_1.c:14281:        if (atomic_dec_and_test(&neigh->refcnt))
trickles-userapi_1.c:14288:                atomic_inc(&neigh->refcnt);
trickles-userapi_1.c:14297:                neigh->confirmed = jiffies;
trickles-userapi_1.c:14302:        return neigh->nud_state&(0x80|0x40|0x02);
trickles-userapi_1.c:14307:        return neigh->nud_state&(0x80|0x40|0x02|0x10|0x04|0x08);
trickles-userapi_1.c:14312:        neigh->used = jiffies;
trickles-userapi_1.c:14313:        if (!(neigh->nud_state&((0x80|0x40|0x02)|0x08|0x10)))
trickles-userapi_1.c:14411:        atomic_inc(&dst->__refcnt);
trickles-userapi_1.c:14418:                atomic_inc(&dst->__refcnt);
trickles-userapi_1.c:14426:                atomic_dec(&dst->__refcnt);
trickles-userapi_1.c:14436:        if (dst->obsolete > 1)
trickles-userapi_1.c:14438:        if (!((&dst->__refcnt)->counter)) {
trickles-userapi_1.c:14448:                neigh_confirm(dst->neighbour);
trickles-userapi_1.c:14454:        if (dst && dst->ops->negative_advice)
trickles-userapi_1.c:14455:                *dst_p = dst->ops->negative_advice(dst);
trickles-userapi_1.c:14460:        struct dst_entry * dst = skb->dst;
trickles-userapi_1.c:14461:        if (dst && dst->ops && dst->ops->link_failure)
trickles-userapi_1.c:14462:                dst->ops->link_failure(skb);
trickles-userapi_1.c:14472:        if (dst->expires == 0 || (long)(dst->expires - expires) > 0)
trickles-userapi_1.c:14473:                dst->expires = expires;
trickles-userapi_1.c:14564:        head->next = head->prev = ((void *)0);
trickles-userapi_1.c:14576:        for (elem = (typeof(elem))(list)->next; (elem != (typeof(elem))(list)); elem=(typeof(elem))elem->next) {
trickles-userapi_1.c:14587:        dlist->next = dlist->prev = (struct list_link*)dlist;
trickles-userapi_1.c:14591:        if(head->next == elem ) {
trickles-userapi_1.c:14595:        elem->next = head->next;
trickles-userapi_1.c:14596:        head->next->prev = elem;
trickles-userapi_1.c:14598:        elem->prev = (struct list_link *)head;
trickles-userapi_1.c:14599:        head->next = elem;
trickles-userapi_1.c:14603:        if(head->prev == elem ) {
trickles-userapi_1.c:14607:        elem->next = (struct list_link *)head;
trickles-userapi_1.c:14608:        elem->prev = head->prev;
trickles-userapi_1.c:14609:        head->prev->next = elem;
trickles-userapi_1.c:14610:        head->prev = elem;
trickles-userapi_1.c:14614:        if(head->prev == elem ) {
trickles-userapi_1.c:14618:        elem->next = (struct list_link *)head;
trickles-userapi_1.c:14619:        elem->prev = head->prev;
trickles-userapi_1.c:14621:        head->prev->next = elem;
trickles-userapi_1.c:14622:        head->prev = elem;
trickles-userapi_1.c:14626:        elem->next->prev = elem->prev;
trickles-userapi_1.c:14627:        elem->prev->next = elem->next;
trickles-userapi_1.c:14628:        elem->prev = elem->next = ((void *)0);
trickles-userapi_1.c:14632:        return (struct dlist *)list->next == list;
trickles-userapi_1.c:14686:        vec->num = 0;
trickles-userapi_1.c:14687:        vec->size = initSize;
trickles-userapi_1.c:14688:        vec->elems = kmalloc(vec->size * sizeof(vec->elems[0]), (0x20));
trickles-userapi_1.c:14689:        if(vec->elems == ((void *)0)) {
trickles-userapi_1.c:14696:        kfree(vec->elems);
trickles-userapi_1.c:14700:        if(vec->num == vec->size) {
trickles-userapi_1.c:14702:                vec->size *= 2;
trickles-userapi_1.c:14703:                newElems = kmalloc(vec->size * sizeof(newElems[0]), (0x20));
trickles-userapi_1.c:14711:        vec->elems[vec->num++] = newElem;
trickles-userapi_1.c:14721:        return head->next == (struct alloc_head*)head;
trickles-userapi_1.c:14725:        head->next = head->prev = (struct alloc_head*)head;
trickles-userapi_1.c:14726:        head->list = head;
trickles-userapi_1.c:14727:        head->len = 0;
trickles-userapi_1.c:14736:        if(head->next == elem ) {
trickles-userapi_1.c:14740:        elem->next = head->next;
trickles-userapi_1.c:14741:        head->next->prev = elem;
trickles-userapi_1.c:14743:        elem->prev = (struct alloc_head*)head;
trickles-userapi_1.c:14744:        head->next = elem;
trickles-userapi_1.c:14746:        elem->list = head;
trickles-userapi_1.c:14747:        head->len++;
trickles-userapi_1.c:14756:        if(head->prev == elem ) {
trickles-userapi_1.c:14761:        elem->next = (struct alloc_head*)head;
trickles-userapi_1.c:14763:        elem->prev = head->prev;
trickles-userapi_1.c:14765:        head->prev->next = elem;
trickles-userapi_1.c:14767:        elem->list = head;
trickles-userapi_1.c:14768:        head->prev = elem;
trickles-userapi_1.c:14769:        head->len++;
trickles-userapi_1.c:14778:        if(head->prev == elem ) {
trickles-userapi_1.c:14783:        elem->next = (struct alloc_head*)head;
trickles-userapi_1.c:14784:        elem->prev = head->prev;
trickles-userapi_1.c:14788:        head->prev->next = elem;
trickles-userapi_1.c:14790:        elem->next = (struct alloc_head*)head;
trickles-userapi_1.c:14792:        elem->list = head;
trickles-userapi_1.c:14793:        head->prev = elem;
trickles-userapi_1.c:14794:        head->len++;
trickles-userapi_1.c:14804:        elem->next->prev = elem->prev;
trickles-userapi_1.c:14805:        elem->prev->next = elem->next;
trickles-userapi_1.c:14806:        elem->prev = elem->next = ((void *)0);
trickles-userapi_1.c:14808:        elem->list->len--;
trickles-userapi_1.c:14809:        elem->list = ((void *)0);
trickles-userapi_1.c:14814:        if(!(elem->next == ((void *)0) && elem->prev == ((void *)0))) do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0);
trickles-userapi_1.c:14815:        elem->next = prev->next;
trickles-userapi_1.c:14816:        prev->next = elem;
trickles-userapi_1.c:14818:        elem->prev = prev;
trickles-userapi_1.c:14819:        next->prev = elem;
trickles-userapi_1.c:14821:        elem->list = prev->list;
trickles-userapi_1.c:14822:        elem->list->len++;
trickles-userapi_1.c:14866:  pkt->nonce = -1;
trickles-userapi_1.c:14867:  pkt->seq = seq;
trickles-userapi_1.c:14869:  pkt->len = len;
trickles-userapi_1.c:14870:  pkt->type = type;
trickles-userapi_1.c:14871:  pkt->contType = contType;
trickles-userapi_1.c:14872:  pkt->minResponseLen = minResponseLen;
trickles-userapi_1.c:14873:  pkt->firstTransportChild = firstTransportChild;
trickles-userapi_1.c:14874:  pkt->numTransportChildren = numTransportChildren;
trickles-userapi_1.c:14875:  pkt->ucontLen = 0;
trickles-userapi_1.c:14876:  pkt->ucontData = ((void *)0);
trickles-userapi_1.c:14877:  pkt->numSiblings = -1;
trickles-userapi_1.c:14878:  pkt->position = (0xff);
trickles-userapi_1.c:14883:        if(len > packet->len + packet->ucontLen) {
trickles-userapi_1.c:14885:                       (int) len, packet->len, packet->ucontLen);
trickles-userapi_1.c:14888:        if(packet->ucontData) {
trickles-userapi_1.c:14889:                kfree(packet->ucontData);
trickles-userapi_1.c:14890:                packet->len += packet->ucontLen;
trickles-userapi_1.c:14891:                packet->ucontLen = 0;
trickles-userapi_1.c:14893:        packet->ucontData = buf;
trickles-userapi_1.c:14894:        packet->ucontLen = len;
trickles-userapi_1.c:14895:        packet->len -= packet->ucontLen;
trickles-userapi_1.c:15379:        printk("PHChunk %p = { type = %d, chunkLen = %d, range=[%d-%d] }\n",
trickles-userapi_1.c:15380:               phchunk, phchunk->type, ntohs(phchunk->chunkLen),
trickles-userapi_1.c:15381:               ntohl(phchunk->start), ntohl(phchunk->end));
trickles-userapi_1.c:16205:                u8 __pad[(1 << ((5))) - sizeof(int)];
trickles-userapi_1.c:16212:        prot->stats[0].inuse++;
trickles-userapi_1.c:16217:        prot->stats[0].inuse--;
trickles-userapi_1.c:16312:        if (sk->filter) {
trickles-userapi_1.c:16316:                        (void)(&((sk)->lock.slock));
trickles-userapi_1.c:16318:                filter = sk->filter;
trickles-userapi_1.c:16320:                        int pkt_len = sk_run_filter(skb, filter->insns,
trickles-userapi_1.c:16321:                                                    filter->len);
trickles-userapi_1.c:16323:                                err = -1;
trickles-userapi_1.c:16338:        atomic_sub(size, &sk->omem_alloc);
trickles-userapi_1.c:16340:        if (atomic_dec_and_test(&fp->refcnt))
trickles-userapi_1.c:16346:        atomic_inc(&fp->refcnt);
trickles-userapi_1.c:16347:        atomic_add(sk_filter_len(fp), &sk->omem_alloc);
trickles-userapi_1.c:16352:        atomic_inc(&sk->refcnt);
trickles-userapi_1.c:16360:        atomic_dec(&sk->refcnt);
trickles-userapi_1.c:16366:        if (atomic_dec_and_test(&sk->refcnt))
trickles-userapi_1.c:16372:        do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&sk->callback_lock); } while (0);
trickles-userapi_1.c:16373:        sk->dead = 1;
trickles-userapi_1.c:16374:        sk->socket = ((void *)0);
trickles-userapi_1.c:16375:        sk->sleep = ((void *)0);
trickles-userapi_1.c:16376:        do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0);
trickles-userapi_1.c:16381:        do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&sk->callback_lock); } while (0);
trickles-userapi_1.c:16382:        sk->sleep = &parent->wait;
trickles-userapi_1.c:16383:        parent->sk = sk;
trickles-userapi_1.c:16384:        sk->socket = parent;
trickles-userapi_1.c:16385:        do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0);
trickles-userapi_1.c:16392:        (void)(&sk->callback_lock);
trickles-userapi_1.c:16393:        uid = sk->socket ? sk->socket->inode->i_uid : 0;
trickles-userapi_1.c:16402:        (void)(&sk->callback_lock);
trickles-userapi_1.c:16403:        ino = sk->socket ? sk->socket->inode->i_ino : 0;
trickles-userapi_1.c:16411:        return sk->dst_cache;
trickles-userapi_1.c:16419:        (void)(&sk->dst_lock);
trickles-userapi_1.c:16420:        dst = sk->dst_cache;
trickles-userapi_1.c:16432:        old_dst = sk->dst_cache;
trickles-userapi_1.c:16433:        sk->dst_cache = dst;
trickles-userapi_1.c:16440:        (void)(&sk->dst_lock);
trickles-userapi_1.c:16450:        old_dst = sk->dst_cache;
trickles-userapi_1.c:16451:        sk->dst_cache = ((void *)0);
trickles-userapi_1.c:16458:        (void)(&sk->dst_lock);
trickles-userapi_1.c:16466:        struct dst_entry *dst = sk->dst_cache;
trickles-userapi_1.c:16468:        if (dst && dst->obsolete && dst->ops->check(dst, cookie) == ((void *)0)) {
trickles-userapi_1.c:16469:                sk->dst_cache = ((void *)0);
trickles-userapi_1.c:16481:        if (dst && dst->obsolete && dst->ops->check(dst, cookie) == ((void *)0)) {
trickles-userapi_1.c:16492:        skb->sk = sk;
trickles-userapi_1.c:16493:        skb->destructor = sock_wfree;
trickles-userapi_1.c:16494:        atomic_add(skb->truesize, &sk->wmem_alloc);
trickles-userapi_1.c:16499:        skb->sk = sk;
trickles-userapi_1.c:16500:        skb->destructor = sock_rfree;
trickles-userapi_1.c:16501:        atomic_add(skb->truesize, &sk->rmem_alloc);
trickles-userapi_1.c:16512:        if (((&sk->rmem_alloc)->counter) + skb->truesize >= (unsigned)sk->rcvbuf) {
trickles-userapi_1.c:16513:                err = -12;
trickles-userapi_1.c:16525:        skb->dev = ((void *)0);
trickles-userapi_1.c:16533:        skb_len = skb->len;
trickles-userapi_1.c:16535:        skb_queue_tail(&sk->receive_queue, skb);
trickles-userapi_1.c:16536:        if (!sk->dead)
trickles-userapi_1.c:16537:                sk->data_ready(sk,skb_len);
trickles-userapi_1.c:16547:        if (((&sk->rmem_alloc)->counter) + skb->truesize >= (unsigned)sk->rcvbuf)
trickles-userapi_1.c:16548:                return -12;
trickles-userapi_1.c:16550:        skb_queue_tail(&sk->error_queue,skb);
trickles-userapi_1.c:16551:        if (!sk->dead)
trickles-userapi_1.c:16552:                sk->data_ready(sk,skb->len);
trickles-userapi_1.c:16562:        int err=((__typeof__(*(&sk->err)))__xchg((unsigned long)(0),(&sk->err),sizeof(*(&sk->err))));
trickles-userapi_1.c:16563:        return -err;
trickles-userapi_1.c:16570:        if (!(sk->shutdown & 2)) {
trickles-userapi_1.c:16571:                amt = sk->sndbuf - ((&sk->wmem_alloc)->counter);
trickles-userapi_1.c:16580:        if (sk->socket && sk->socket->fasync_list)
trickles-userapi_1.c:16581:                sock_wake_async(sk->socket, how, band);
trickles-userapi_1.c:16592:        return ((&sk->wmem_alloc)->counter) < (sk->sndbuf / 2);
trickles-userapi_1.c:16602:        return noblock ? 0 : sk->rcvtimeo;
trickles-userapi_1.c:16607:        return noblock ? 0 : sk->sndtimeo;
trickles-userapi_1.c:16612:        return (waitall ? len : ({ int __x = (sk->rcvlowat); int __y = (len); __x < __y ? __x: __y; })) ? : 1;
trickles-userapi_1.c:16620:        return timeo == ((long)(~0UL>>1)) ? -512 : -4;
trickles-userapi_1.c:16626:        if (sk->rcvtstamp)
trickles-userapi_1.c:16627:                put_cmsg(msg, 1, 29, sizeof(skb->stamp), &skb->stamp);
trickles-userapi_1.c:16629:                sk->stamp = skb->stamp;
trickles-userapi_1.c:16725:        return !((addr^ifa->ifa_address)&ifa->ifa_mask);
trickles-userapi_1.c:16751:        in_dev = dev->ip_ptr;
trickles-userapi_1.c:16753:                atomic_inc(&in_dev->refcnt);
trickles-userapi_1.c:16761:        return (struct in_device*)dev->ip_ptr;
trickles-userapi_1.c:16769:        if (atomic_dec_and_test(&idev->refcnt))
trickles-userapi_1.c:16781:                return htonl(~((1<<(32-logmask))-1));
trickles-userapi_1.c:16789:        return 32 - ffz(~mask);
trickles-userapi_1.c:16824:        if (atomic_dec_and_test(&p->refcnt)) {
trickles-userapi_1.c:16825:                p->unused_prevp = inet_peer_unused_tailp;
trickles-userapi_1.c:16826:                p->unused_next = ((void *)0);
trickles-userapi_1.c:16828:                inet_peer_unused_tailp = &p->unused_next;
trickles-userapi_1.c:16829:                p->dtime = jiffies;
trickles-userapi_1.c:16831:        do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0);
trickles-userapi_1.c:16841:        id = p->ip_id_count++;
trickles-userapi_1.c:16842:        do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0);
trickles-userapi_1.c:16927:        int size = ((len)+( ((sizeof(struct nlmsghdr))+4 -1) & ~(4 -1) ));
trickles-userapi_1.c:16929:        nlh = (struct nlmsghdr*)skb_put(skb, ( ((size)+4 -1) & ~(4 -1) ));
trickles-userapi_1.c:16930:        nlh->nlmsg_type = type;
trickles-userapi_1.c:16931:        nlh->nlmsg_len = size;
trickles-userapi_1.c:16932:        nlh->nlmsg_flags = 0;
trickles-userapi_1.c:16933:        nlh->nlmsg_pid = pid;
trickles-userapi_1.c:16934:        nlh->nlmsg_seq = seq;
trickles-userapi_1.c:17215:        return len > rta->rta_len || __builtin_memcmp(((void*)(((char*)(rta)) + (( ((sizeof(struct rtattr))+4 -1) & ~(4 -1) ) + (0)))), str, len);
trickles-userapi_1.c:17376:                dst_release(&rt->u.dst);
trickles-userapi_1.c:17394:        dst = (*rp)->rt_dst;
trickles-userapi_1.c:17395:        src = (*rp)->rt_src;
trickles-userapi_1.c:17405:        if (rt->peer)
trickles-userapi_1.c:17406:                return rt->peer;
trickles-userapi_1.c:17409:        return rt->peer;
trickles-userapi_1.c:17851:        if (skb->len > skb->dst->pmtu)
trickles-userapi_1.c:17862:        u32 check = iph->check;
trickles-userapi_1.c:17864:        iph->check = check + (check>=0xFFFF);
trickles-userapi_1.c:17865:        return --iph->ttl;
trickles-userapi_1.c:17871:        return (sk->protinfo.af_inet.pmtudisc == 2 ||
trickles-userapi_1.c:17872:                (sk->protinfo.af_inet.pmtudisc == 1 &&
trickles-userapi_1.c:17873:                 !(dst->mxlock&(1<<RTAX_MTU))));
trickles-userapi_1.c:17880:        if (iph->frag_off&((__u16)( (((__u16)((0x4000)) & (__u16)0x00ffU) << 8) | (((__u16)((0x4000)) & (__u16)0xff00U) >> 8) ))) {
trickles-userapi_1.c:17886:                iph->id = ((sk && sk->daddr) ? htons(sk->protinfo.af_inet.id++) : 0);
trickles-userapi_1.c:18099:        if ((({ unsigned long flag,sum; asm("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0" :"=&r" (flag), "=r" (sum) :"1" (dst),"g" ((int)(len)),"g" (get_current()->addr_limit.seg)); flag; }) == 0))
trickles-userapi_1.c:18103:                *err_ptr = -14;
trickles-userapi_1.c:18105:        return -1;
trickles-userapi_1.c:18117:                *err_ptr = -14;
trickles-userapi_1.c:18214:        return (lport & ((tcp_hashinfo.__tcp_bhash_size) - 1));
trickles-userapi_1.c:18266:        if (atomic_dec_and_test(&tw->refcnt)) {
trickles-userapi_1.c:18283:        return num & (32 - 1);
trickles-userapi_1.c:18288:        return tcp_lhashfn(sk->num);
trickles-userapi_1.c:18384:        req->class->destructor(req);
trickles-userapi_1.c:18437:        return (__s32)(seq1-seq2) < 0;
trickles-userapi_1.c:18442:        return (__s32)(seq2-seq1) < 0;
trickles-userapi_1.c:18449:        return seq3 - seq2 >= seq1 - seq2;
trickles-userapi_1.c:18502:        tp->ack.pending |= TCP_ACK_SCHED;
trickles-userapi_1.c:18507:        return tp->ack.pending&TCP_ACK_SCHED;
trickles-userapi_1.c:18512:        if (tp->ack.quick && --tp->ack.quick == 0) {
trickles-userapi_1.c:18514:                tp->ack.ato = ((unsigned)(100/25));
trickles-userapi_1.c:18522:        (__builtin_constant_p(0) ? (__builtin_constant_p((sizeof(tp->ack))) ? __constant_c_and_count_memset(((&tp->ack)),((0x01010101UL*(unsigned char)(0))),((sizeof(tp->ack)))) : __constant_c_memset(((&tp->ack)),((0x01010101UL*(unsigned char)(0))),((sizeof(tp->ack))))) : (__builtin_constant_p((sizeof(tp->ack))) ? __memset_generic((((&tp->ack))),(((0))),(((sizeof(tp->ack))))) : __memset_generic(((&tp->ack)),((0)),((sizeof(tp->ack))))));
trickles-userapi_1.c:18527:        tp->tstamp_ok = tp->sack_ok = tp->wscale_ok = tp->snd_wscale = 0;
trickles-userapi_1.c:18670:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_1.c:18675:                tp->pending = 0;
trickles-userapi_1.c:18684:                tp->ack.blocked = 0;
trickles-userapi_1.c:18685:                tp->ack.pending = 0;
trickles-userapi_1.c:18705:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_1.c:18717:                tp->pending = what;
trickles-userapi_1.c:18718:                tp->timeout = jiffies+when;
trickles-userapi_1.c:18719:                if (!mod_timer(&tp->retransmit_timer, tp->timeout))
trickles-userapi_1.c:18724:                tp->ack.pending |= TCP_ACK_TIMER;
trickles-userapi_1.c:18725:                tp->ack.timeout = jiffies+when;
trickles-userapi_1.c:18726:                if (!mod_timer(&tp->delack_timer, tp->ack.timeout))
trickles-userapi_1.c:18741:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_1.c:18743:        int mss_now = tp->mss_cache;
trickles-userapi_1.c:18745:        if (dst && dst->pmtu != tp->pmtu_cookie)
trickles-userapi_1.c:18746:                mss_now = tcp_sync_mss(sk, dst->pmtu);
trickles-userapi_1.c:18748:        if (tp->eff_sacks)
trickles-userapi_1.c:18749:                mss_now -= (4 +
trickles-userapi_1.c:18750:                            (tp->eff_sacks * 8));
trickles-userapi_1.c:18756:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_1.c:18757:        unsigned int hint = ({ const typeof(tp->advmss) _x = (tp->advmss); const typeof(tp->mss_cache) _y = (tp->mss_cache); (void) (&_x == &_y); _x < _y ? _x : _y; });
trickles-userapi_1.c:18759:        hint = ({ const typeof(hint) _x = (hint); const typeof(tp->rcv_wnd/2) _y = (tp->rcv_wnd/2); (void) (&_x == &_y); _x < _y ? _x : _y; });
trickles-userapi_1.c:18763:        tp->ack.rcv_mss = hint;
trickles-userapi_1.c:18768:        tp->pred_flags = htonl((tp->tcp_header_len << 26) |
trickles-userapi_1.c:18775:        __tcp_fast_path_on(tp, tp->snd_wnd>>tp->snd_wscale);
trickles-userapi_1.c:18780:        if (skb_queue_len(&tp->out_of_order_queue) == 0 &&
trickles-userapi_1.c:18781:            tp->rcv_wnd &&
trickles-userapi_1.c:18782:            ((&sk->rmem_alloc)->counter) < sk->rcvbuf &&
trickles-userapi_1.c:18783:            !tp->urg_data)
trickles-userapi_1.c:18793:        s32 win = tp->rcv_wup + tp->rcv_wnd - tp->rcv_nxt;
trickles-userapi_1.c:18872:        u32 check = iph->check;
trickles-userapi_1.c:18874:        iph->check = check + (check>=0xFFFF);
trickles-userapi_1.c:18875:        iph->tos |= 1;
trickles-userapi_1.c:18895:        if (tp->ecn_flags&1)
trickles-userapi_1.c:18896:                tp->ecn_flags |= 2;
trickles-userapi_1.c:18905:        ((struct tcp_skb_cb *)&((skb)->cb[0]))->flags &= ~0x80;
trickles-userapi_1.c:18906:        if (!(tp->ecn_flags&1))
trickles-userapi_1.c:18907:                ((struct tcp_skb_cb *)&((skb)->cb[0]))->flags &= ~0x40;
trickles-userapi_1.c:18913:        tp->ecn_flags = 0;
trickles-userapi_1.c:18915:                ((struct tcp_skb_cb *)&((skb)->cb[0]))->flags |= 0x40|0x80;
trickles-userapi_1.c:18916:                tp->ecn_flags = 1;
trickles-userapi_1.c:18923:        if (req->ecn_ok)
trickles-userapi_1.c:18924:                th->ece = 1;
trickles-userapi_1.c:18930:        if (tp->ecn_flags & 1) {
trickles-userapi_1.c:18932:                if (skb->len != tcp_header_len &&
trickles-userapi_1.c:18933:                    !before(((struct tcp_skb_cb *)&((skb)->cb[0]))->seq, tp->snd_nxt)) {
trickles-userapi_1.c:18934:                        do { (sk)->protinfo.af_inet.tos |= 2; } while (0);
trickles-userapi_1.c:18935:                        if (tp->ecn_flags&2) {
trickles-userapi_1.c:18936:                                tp->ecn_flags &= ~2;
trickles-userapi_1.c:18937:                                skb->h.th->cwr = 1;
trickles-userapi_1.c:18941:                        do { (sk)->protinfo.af_inet.tos &= ~3; } while (0);
trickles-userapi_1.c:18943:                if (tp->ecn_flags & 4)
trickles-userapi_1.c:18944:                        skb->h.th->ece = 1;
trickles-userapi_1.c:18953:        if (skb->h.th->cwr)
trickles-userapi_1.c:18954:                tp->ecn_flags &= ~4;
trickles-userapi_1.c:18960:        tp->ecn_flags &= ~4;
trickles-userapi_1.c:18966:        if (tp->ecn_flags&1) {
trickles-userapi_1.c:18967:                if (INET_ECN_is_ce(((struct tcp_skb_cb *)&((skb)->cb[0]))->flags))
trickles-userapi_1.c:18968:                        tp->ecn_flags |= 4;
trickles-userapi_1.c:18972:                else if (!INET_ECN_is_capable((((struct tcp_skb_cb *)&((skb)->cb[0]))->flags)))
trickles-userapi_1.c:18980:        if ((tp->ecn_flags&1) && (!th->ece || th->cwr))
trickles-userapi_1.c:18981:                tp->ecn_flags &= ~1;
trickles-userapi_1.c:18987:        if ((tp->ecn_flags&1) && (!th->ece || !th->cwr))
trickles-userapi_1.c:18988:                tp->ecn_flags &= ~1;
trickles-userapi_1.c:18994:        if (th->ece && !th->syn && (tp->ecn_flags&1))
trickles-userapi_1.c:19002:        tp->ecn_flags = req->ecn_ok ? 1 : 0;
trickles-userapi_1.c:19008:        if (sysctl_tcp_ecn && th->ece && th->cwr)
trickles-userapi_1.c:19009:                req->ecn_ok = 1;
trickles-userapi_1.c:19019:        return sk->wmem_queued/2;
trickles-userapi_1.c:19024:        return sk->sndbuf - sk->wmem_queued;
trickles-userapi_1.c:19029:        return tp->packets_out - tp->left_out + tp->retrans_out;
trickles-userapi_1.c:19039:        return ({ const typeof(tp->snd_cwnd >> 1U) _x = (tp->snd_cwnd >> 1U); const typeof(2U) _y = (2U); (void) (&_x == &_y); _x > _y ? _x : _y; });
trickles-userapi_1.c:19048:        if ((1<<tp->ca_state)&((1<<TCP_CA_CWR)|(1<<TCP_CA_Recovery)))
trickles-userapi_1.c:19049:                return tp->snd_ssthresh;
trickles-userapi_1.c:19051:                return ({ const typeof(tp->snd_ssthresh) _x = (tp->snd_ssthresh); const typeof(((tp->snd_cwnd >> 1) + (tp->snd_cwnd >> 2))) _y = (((tp->snd_cwnd >> 1) + (tp->snd_cwnd >> 2))); (void) (&_x == &_y); _x > _y ? _x : _y; });
trickles-userapi_1.c:19058:        if (tp->sack_ok && tp->sacked_out >= tp->packets_out - tp->lost_out)
trickles-userapi_1.c:19059:                tp->sacked_out = tp->packets_out - tp->lost_out;
trickles-userapi_1.c:19060:        tp->left_out = tp->sacked_out + tp->lost_out;
trickles-userapi_1.c:19069:        if (tp->packets_out >= tp->snd_cwnd) {
trickles-userapi_1.c:19071:                tp->snd_cwnd_used = 0;
trickles-userapi_1.c:19072:                tp->snd_cwnd_stamp = ((__u32)(jiffies));
trickles-userapi_1.c:19075:                if (tp->packets_out > tp->snd_cwnd_used)
trickles-userapi_1.c:19076:                        tp->snd_cwnd_used = tp->packets_out;
trickles-userapi_1.c:19078:                if ((s32)(((__u32)(jiffies)) - tp->snd_cwnd_stamp) >= tp->rto)
trickles-userapi_1.c:19086:        tp->undo_marker = 0;
trickles-userapi_1.c:19087:        tp->snd_ssthresh = tcp_recalc_ssthresh(tp);
trickles-userapi_1.c:19088:        tp->snd_cwnd = ({ const typeof(tp->snd_cwnd) _x = (tp->snd_cwnd); const typeof(tcp_packets_in_flight(tp) + 1U) _y = (tcp_packets_in_flight(tp) + 1U); (void) (&_x == &_y); _x < _y ? _x : _y; });
trickles-userapi_1.c:19090:        tp->snd_cwnd_cnt = 0;
trickles-userapi_1.c:19091:        tp->high_seq = tp->snd_nxt;
trickles-userapi_1.c:19092:        tp->snd_cwnd_stamp = ((__u32)(jiffies));
trickles-userapi_1.c:19098:        tp->prior_ssthresh = 0;
trickles-userapi_1.c:19099:        if (tp->ca_state < TCP_CA_CWR) {
trickles-userapi_1.c:19101:                tp->ca_state = TCP_CA_CWR;
trickles-userapi_1.c:19117:        return after(tp->snd_sml,tp->snd_una) &&
trickles-userapi_1.c:19118:                !after(tp->snd_sml, tp->snd_nxt);
trickles-userapi_1.c:19123:        if (skb->len < mss)
trickles-userapi_1.c:19124:                tp->snd_sml = ((struct tcp_skb_cb *)&((skb)->cb[0]))->end_seq;
trickles-userapi_1.c:19130:        return (skb->len < mss_now &&
trickles-userapi_1.c:19131:                !(((struct tcp_skb_cb *)&((skb)->cb[0]))->flags & 0x01) &&
trickles-userapi_1.c:19134:                  tp->packets_out &&
trickles-userapi_1.c:19145:        return ((nonagle==1 || tp->urg_mode
trickles-userapi_1.c:19147:                ((tcp_packets_in_flight(tp) < tp->snd_cwnd) ||
trickles-userapi_1.c:19148:                 (((struct tcp_skb_cb *)&((skb)->cb[0]))->flags & 0x01)) &&
trickles-userapi_1.c:19149:                !after(((struct tcp_skb_cb *)&((skb)->cb[0]))->end_seq, tp->snd_una + tp->snd_wnd));
trickles-userapi_1.c:19154:        if (!tp->packets_out && !tp->pending)
trickles-userapi_1.c:19155:                tcp_reset_xmit_timer(sk, 3, tp->rto);
trickles-userapi_1.c:19160:        return (skb->next == (struct sk_buff*)&sk->write_queue);
trickles-userapi_1.c:19172:        struct sk_buff *skb = tp->send_head;
trickles-userapi_1.c:19187:        __tcp_push_pending_frames(sk, tp, tcp_current_mss(sk), tp->nonagle);
trickles-userapi_1.c:19192:        struct sk_buff *skb = tp->send_head;
trickles-userapi_1.c:19196:                             tcp_skb_is_last(sk, skb) ? 1 : tp->nonagle));
trickles-userapi_1.c:19201:        tp->snd_wl1 = seq;
trickles-userapi_1.c:19206:        tp->snd_wl1 = seq;
trickles-userapi_1.c:19224:        return (unsigned short)csum_fold(skb_checksum(skb, 0, skb->len, skb->csum));
trickles-userapi_1.c:19229:        return skb->ip_summed != 2 &&
trickles-userapi_1.c:19237:        tp->ucopy.task = ((void *)0);
trickles-userapi_1.c:19238:        tp->ucopy.len = 0;
trickles-userapi_1.c:19239:        tp->ucopy.memory = 0;
trickles-userapi_1.c:19240:        skb_queue_head_init(&tp->ucopy.prequeue);
trickles-userapi_1.c:19245:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_1.c:19247:        if (!sysctl_tcp_low_latency && tp->ucopy.task) {
trickles-userapi_1.c:19248:                __skb_queue_tail(&tp->ucopy.prequeue, skb);
trickles-userapi_1.c:19249:                tp->ucopy.memory += skb->truesize;
trickles-userapi_1.c:19250:                if (tp->ucopy.memory > sk->rcvbuf) {
trickles-userapi_1.c:19253:                        if (sk->lock.users)
trickles-userapi_1.c:19256:                        while ((skb1 = __skb_dequeue(&tp->ucopy.prequeue)) != ((void *)0)) {
trickles-userapi_1.c:19257:                                sk->backlog_rcv(sk, skb1);
trickles-userapi_1.c:19261:                        tp->ucopy.memory = 0;
trickles-userapi_1.c:19262:                } else if (skb_queue_len(&tp->ucopy.prequeue) == 1) {
trickles-userapi_1.c:19263:                        __wake_up((sk->sleep),1, 1);
trickles-userapi_1.c:19274:        int oldstate = sk->state;
trickles-userapi_1.c:19286:                sk->prot->unhash(sk);
trickles-userapi_1.c:19287:                if (sk->prev && !(sk->userlocks&8))
trickles-userapi_1.c:19292:                        tcp_statistics[0*2+!(((void)((0)), irq_stat[0].__local_bh_count) != 0)].TcpCurrEstab--;
trickles-userapi_1.c:19298:        sk->state = state;
trickles-userapi_1.c:19310:        sk->shutdown = 3;
trickles-userapi_1.c:19312:        if (!sk->dead)
trickles-userapi_1.c:19313:                sk->state_change(sk);
trickles-userapi_1.c:19320:        tp->dsack = 0;
trickles-userapi_1.c:19321:        tp->eff_sacks = 0;
trickles-userapi_1.c:19322:        tp->num_sacks = 0;
trickles-userapi_1.c:19327:        if (tp->tstamp_ok) {
trickles-userapi_1.c:19333:                *ptr++ = htonl(tp->ts_recent);
trickles-userapi_1.c:19335:        if (tp->eff_sacks) {
trickles-userapi_1.c:19336:                struct tcp_sack_block *sp = tp->dsack ? tp->duplicate_sack : tp->selective_acks;
trickles-userapi_1.c:19339:                *ptr++ = ((__u32)( (((__u32)(((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) & (__u32)0x000000ffUL) << 24) | (((__u32)(((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) & (__u32)0x0000ff00UL) << 8) | (((__u32)(((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) & (__u32)0xff000000UL) >> 24) ));
trickles-userapi_1.c:19344:                for(this_sack = 0; this_sack < tp->eff_sacks; this_sack++) {
trickles-userapi_1.c:19348:                if (tp->dsack) {
trickles-userapi_1.c:19349:                        tp->dsack = 0;
trickles-userapi_1.c:19350:                        tp->eff_sacks--;
trickles-userapi_1.c:19413:                    space - ({ const typeof((space>>sysctl_tcp_app_win)) _x = ((space>>sysctl_tcp_app_win)); const typeof(mss>>*rcv_wscale) _y = (mss>>*rcv_wscale); (void) (&_x == &_y); _x > _y ? _x : _y; }) < 65536/2)
trickles-userapi_1.c:19414:                        (*rcv_wscale)--;
trickles-userapi_1.c:19437:                (space>>(-sysctl_tcp_adv_win_scale)) :
trickles-userapi_1.c:19438:                space - (space>>sysctl_tcp_adv_win_scale);
trickles-userapi_1.c:19444:        return tcp_win_from_space(sk->rcvbuf - ((&sk->rmem_alloc)->counter));
trickles-userapi_1.c:19449:        return tcp_win_from_space(sk->rcvbuf);
trickles-userapi_1.c:19454:        sk->ack_backlog--;
trickles-userapi_1.c:19459:        sk->ack_backlog++;
trickles-userapi_1.c:19464:        return sk->ack_backlog > sk->max_ack_backlog;
trickles-userapi_1.c:19470:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_1.c:19472:        req->sk = child;
trickles-userapi_1.c:19475:        if (!tp->accept_queue_tail) {
trickles-userapi_1.c:19476:                tp->accept_queue = req;
trickles-userapi_1.c:19478:                tp->accept_queue_tail->dl_next = req;
trickles-userapi_1.c:19480:        tp->accept_queue_tail = req;
trickles-userapi_1.c:19481:        req->dl_next = ((void *)0);
trickles-userapi_1.c:19497:        struct tcp_listen_opt *lopt = sk->tp_pinfo.af_tcp.listen_opt;
trickles-userapi_1.c:19499:        if (--lopt->qlen == 0)
trickles-userapi_1.c:19501:        if (req->retrans == 0)
trickles-userapi_1.c:19502:                lopt->qlen_young--;
trickles-userapi_1.c:19507:        struct tcp_listen_opt *lopt = sk->tp_pinfo.af_tcp.listen_opt;
trickles-userapi_1.c:19509:        if (lopt->qlen++ == 0)
trickles-userapi_1.c:19511:        lopt->qlen_young++;
trickles-userapi_1.c:19516:        return sk->tp_pinfo.af_tcp.listen_opt->qlen;
trickles-userapi_1.c:19521:        return sk->tp_pinfo.af_tcp.listen_opt->qlen_young;
trickles-userapi_1.c:19526:        return tcp_synq_len(sk)>>sk->tp_pinfo.af_tcp.listen_opt->max_qlen_log;
trickles-userapi_1.c:19532:        (void)(&tp->syn_wait_lock);
trickles-userapi_1.c:19533:        *prev = req->dl_next;
trickles-userapi_1.c:19540:        tcp_synq_unlink(&sk->tp_pinfo.af_tcp, req, prev);
trickles-userapi_1.c:19549:        req->rcv_wnd = 0;
trickles-userapi_1.c:19550:        req->rcv_isn = ((struct tcp_skb_cb *)&((skb)->cb[0]))->seq;
trickles-userapi_1.c:19551:        req->mss = tp->mss_clamp;
trickles-userapi_1.c:19552:        req->ts_recent = tp->saw_tstamp ? tp->rcv_tsval : 0;
trickles-userapi_1.c:19553:        req->tstamp_ok = tp->tstamp_ok;
trickles-userapi_1.c:19554:        req->sack_ok = tp->sack_ok;
trickles-userapi_1.c:19555:        req->snd_wscale = tp->snd_wscale;
trickles-userapi_1.c:19556:        req->wscale_ok = tp->wscale_ok;
trickles-userapi_1.c:19557:        req->acked = 0;
trickles-userapi_1.c:19558:        req->ecn_ok = 0;
trickles-userapi_1.c:19559:        req->rmt_port = skb->h.th->source;
trickles-userapi_1.c:19566:        sk->tp_pinfo.af_tcp.queue_shrunk = 1;
trickles-userapi_1.c:19567:        sk->wmem_queued -= skb->truesize;
trickles-userapi_1.c:19568:        sk->forward_alloc += skb->truesize;
trickles-userapi_1.c:19574:        sk->wmem_queued += skb->truesize;
trickles-userapi_1.c:19575:        sk->forward_alloc -= skb->truesize;
trickles-userapi_1.c:19583:        if (sk->forward_alloc >= ((int)(1UL << 12)))
trickles-userapi_1.c:19597:        if (!(sk->userlocks&1)) {
trickles-userapi_1.c:19598:                sk->sndbuf = ({ const typeof(sk->sndbuf) _x = (sk->sndbuf); const typeof(sk->wmem_queued/2) _y = (sk->wmem_queued/2); (void) (&_x == &_y); _x < _y ? _x : _y; });
trickles-userapi_1.c:19599:                sk->sndbuf = ({ const typeof(sk->sndbuf) _x = (sk->sndbuf); const typeof(2048) _y = (2048); (void) (&_x == &_y); _x > _y ? _x : _y; });
trickles-userapi_1.c:19608:                skb->truesize += mem;
trickles-userapi_1.c:19609:                if (sk->forward_alloc >= (int)skb->truesize ||
trickles-userapi_1.c:19610:                    tcp_mem_schedule(sk, skb->truesize, 0)) {
trickles-userapi_1.c:19629:        if (sk->forward_alloc >= (int)(1UL << 12) ||
trickles-userapi_1.c:19631:                struct page *page = alloc_pages(sk->allocation, 0);
trickles-userapi_1.c:19644:        while ((skb = __skb_dequeue(&sk->write_queue)) != ((void *)0))
trickles-userapi_1.c:19653:        skb->sk = sk;
trickles-userapi_1.c:19654:        skb->destructor = tcp_rfree;
trickles-userapi_1.c:19655:        atomic_add(skb->truesize, &sk->rmem_alloc);
trickles-userapi_1.c:19656:        sk->forward_alloc -= skb->truesize;
trickles-userapi_1.c:19682:        return tp->keepalive_intvl ? : sysctl_tcp_keepalive_intvl;
trickles-userapi_1.c:19687:        return tp->keepalive_time ? : sysctl_tcp_keepalive_time;
trickles-userapi_1.c:19692:        int fin_timeout = tp->linger2 ? : sysctl_tcp_fin_timeout;
trickles-userapi_1.c:19694:        if (fin_timeout < (tp->rto<<2) - (tp->rto>>1))
trickles-userapi_1.c:19695:                fin_timeout = (tp->rto<<2) - (tp->rto>>1);
trickles-userapi_1.c:19702:        if ((s32)(tp->rcv_tsval - tp->ts_recent) >= 0)
trickles-userapi_1.c:19704:        if (xtime.tv_sec >= tp->ts_recent_stamp + (60 * 60 * 24 * 24))
trickles-userapi_1.c:19707:        if (rst && xtime.tv_sec >= tp->ts_recent_stamp + 60)
trickles-userapi_1.c:19716:        const struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_1.c:19722:        return (sysctl_tcp_frto && tp->send_head &&
trickles-userapi_1.c:19723:                !after(((struct tcp_skb_cb *)&((tp->send_head)->cb[0]))->end_seq,
trickles-userapi_1.c:19724:                       tp->snd_una + tp->snd_wnd));
trickles-userapi_1.c:19733:        ((tcp_statistics)[2*0 +1].TcpMaxConn += -1);
trickles-userapi_1.c:19745:                tp->westwood.rtt = rtt_seq;
trickles-userapi_1.c:19753:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:19755:        tp->westwood.bw_ns_est = 0;
trickles-userapi_1.c:19756:        tp->westwood.bw_est = 0;
trickles-userapi_1.c:19757:        tp->westwood.accounted = 0;
trickles-userapi_1.c:19758:        tp->westwood.cumul_ack = 0;
trickles-userapi_1.c:19759:        tp->westwood.rtt_win_sx = ((__u32)(jiffies));
trickles-userapi_1.c:19760:        tp->westwood.rtt = 20*100;
trickles-userapi_1.c:19761:        tp->westwood.rtt_min = 20*100;
trickles-userapi_1.c:19762:        tp->westwood.snd_una = tp->snd_una;
trickles-userapi_1.c:19784:        return (__u32) ((tp->westwood.bw_est) * (tp->westwood.rtt_min) /
trickles-userapi_1.c:19785:                        (__u32) (tp->mss_cache));
trickles-userapi_1.c:19807:                tp->snd_ssthresh = ssthresh;
trickles-userapi_1.c:19823:                tp->snd_cwnd = cwnd;
trickles-userapi_1.c:19836:                        tp->snd_ssthresh = tp->snd_cwnd;
trickles-userapi_1.c:19859:# 1 "/home/ashieh/current/include/net/trickles-crypto.h" 1
trickles-userapi_1.c:19879:# 6 "/home/ashieh/current/include/net/trickles-crypto.h" 2
trickles-userapi_1.c:19957:# 13 "/home/ashieh/current/include/net/trickles-crypto.h" 2
trickles-userapi_1.c:20109:        struct sock *sk = skb->sk;
trickles-userapi_1.c:20110:        if(skb->ip_summed == 1) {
trickles-userapi_1.c:20111:                skb->h.th->check = 0;
trickles-userapi_1.c:20112:                skb->h.th->check = ~tcp_v4_check(skb->h.th, skb->len, sk->saddr, sk->daddr,
trickles-userapi_1.c:20114:                skb->csum = ((size_t) &((struct tcphdr *)0)->check);
trickles-userapi_1.c:20116:                skb->h.th->check = 0;
trickles-userapi_1.c:20117:                skb->h.th->check = tcp_v4_check(skb->h.th, skb->len, sk->saddr, sk->daddr,
trickles-userapi_1.c:20118:                                         csum_partial((char*)skb->h.th, headerLen, skb->csum));
trickles-userapi_1.c:20143:  POISONEDRANGE = -1,
trickles-userapi_1.c:20194:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_1.c:20195:        if (!(dataReq->list == ((void *)0))) { printk("KERNEL: assertion (" "dataReq->list == NULL" ") failed at " "/home/ashieh/current/include/net/trickles_client.h" "(%d)\n", 47); };
trickles-userapi_1.c:20196:        dataReq->completed = 0;
trickles-userapi_1.c:20197:        dataReq->sent = 0;
trickles-userapi_1.c:20199:        dataReq->transportResponseSeqStart = (4294967295U);
trickles-userapi_1.c:20200:        dataReq->transportResponseSeqEnd = (4294967295U);
trickles-userapi_1.c:20201:        dataReq->timestamp = (4294967295U);
trickles-userapi_1.c:20202:        dataReq->start = newStart;
trickles-userapi_1.c:20203:        dataReq->end = newEnd;
trickles-userapi_1.c:20204:        insert_tail(&tp->t.missingDataMap, (struct alloc_head*)dataReq);
trickles-userapi_1.c:20231:        newMapping->next = newMapping->prev = ((void *)0);
trickles-userapi_1.c:20232:        newMapping->list = ((void *)0);
trickles-userapi_1.c:20234:        newMapping->completed = 0;
trickles-userapi_1.c:20235:        newMapping->ucont = ucont;
trickles-userapi_1.c:20236:        newMapping->transportResponseSeqStart = tseq_start;
trickles-userapi_1.c:20237:        newMapping->transportResponseSeqEnd = tseq_end;
trickles-userapi_1.c:20238:        newMapping->sent = 0;
trickles-userapi_1.c:20239:        newMapping->start = start;
trickles-userapi_1.c:20240:        newMapping->end = end;
trickles-userapi_1.c:20242:        newMapping->timestamp = jiffies;
trickles-userapi_1.c:20250:        numDataRequestMappings--;
trickles-userapi_1.c:20271:        req->numChildren = 0;
trickles-userapi_1.c:20272:        req->childrenMask = 0;
trickles-userapi_1.c:20273:        req->transport_seq = -1;
trickles-userapi_1.c:20274:        req->seq = -1;
trickles-userapi_1.c:20275:        req->isNew = 1;
trickles-userapi_1.c:20280:        req->type = type;
trickles-userapi_1.c:20281:        req->prev = req->next = ((void *)0);
trickles-userapi_1.c:20282:        req->list = ((void *)0);
trickles-userapi_1.c:20284:        req->start = req->end = -1;
trickles-userapi_1.c:20285:        req->allocated = 1;
trickles-userapi_1.c:20291:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_1.c:20292:        insert_tail(&tp->t.queuedRequests, (struct alloc_head*)req);
trickles-userapi_1.c:20293:        tp->t.timerState |= (0x1);
trickles-userapi_1.c:20320:        req->incomplete = 0;
trickles-userapi_1.c:20321:        req->completePred = pred;
trickles-userapi_1.c:20322:        atomic_inc(&req->completePred->refcnt);
trickles-userapi_1.c:20324:        if(((&req->completePred->refcnt)->counter) < 2) {
trickles-userapi_1.c:20328:        req->data = data;
trickles-userapi_1.c:20329:        req->start = start;
trickles-userapi_1.c:20330:        req->offset = req->start - ((struct tcp_skb_cb *)&((data)->cb[0]))->seq;
trickles-userapi_1.c:20335:        req->incomplete = 1;
trickles-userapi_1.c:20336:        req->incompletePred = pred;
trickles-userapi_1.c:20337:        req->predLength = predLength;
trickles-userapi_1.c:20338:        req->data = data;
trickles-userapi_1.c:20339:        req->offset = offset;
trickles-userapi_1.c:20356:        req->start = start;
trickles-userapi_1.c:20357:        req->end = end;
trickles-userapi_1.c:20358:        req->numConts = numConts;
trickles-userapi_1.c:20359:        req->conts = kmalloc(sizeof(struct UC_Continuation*) * numConts, (0x20));
trickles-userapi_1.c:20363:                return -1;
trickles-userapi_1.c:20374:        newReq->conts = kmalloc(sizeof(struct UC_Continuation*) * newReq->numConts, (0x20));
trickles-userapi_1.c:20375:        if(newReq->conts == ((void *)0)) {
trickles-userapi_1.c:20379:        (__builtin_constant_p(sizeof(struct UC_Continuation*) * newReq->numConts) ? __constant_memcpy((newReq->conts),(src->conts),(sizeof(struct UC_Continuation*) * newReq->numConts)) : __memcpy((newReq->conts),(src->conts),(sizeof(struct UC_Continuation*) * newReq->numConts)));
trickles-userapi_1.c:20404:        rval->prev = rval->next = ((void *)0);
trickles-userapi_1.c:20405:        rval->list = ((void *)0);
trickles-userapi_1.c:20407:        rval->cont = cont;
trickles-userapi_1.c:20408:        rval->isSynack = isSynack;
trickles-userapi_1.c:20409:        rval->parent = parent;
trickles-userapi_1.c:20410:        rval->numSiblings = numSiblings;
trickles-userapi_1.c:20411:        rval->position = position;
trickles-userapi_1.c:20451:static inline void marshallContinuationServer(struct sock *sk, WireContinuation *dcont, const struct cminisock *scont, int pktNum) { dcont->clientState = scont->clientState; dcont->parent = scont->parent; if(1) { ({ (dcont)->seq = htonl((scont)->packets[pktNum].seq); (dcont)->continuationType = (scont)->packets[pktNum].contType; if((scont)->packets[pktNum].type & (0x80)) { (dcont)->firstChild = 1; } else { (dcont)->firstChild = 0; } static const int stateConversionMap[] = { 0, 1, 2 }; int conversionOffset = (scont)->packets[pktNum].type & (0x3); if(conversionOffset >= (3)) { do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } (dcont)->state = stateConversionMap[conversionOffset]; }); dcont->timestamp = htonl(scont->timestamp); dcont->clientTimestamp = scont->clientTimestamp; dcont->mrtt = htonl(scont->mrtt); } else { dcont->seq = htonl(scont->seq); dcont->continuationType = scont->continuationType; dcont->firstChild = scont->firstChild; dcont->state = scont->state; dcont->timestamp = scont->rawTimestamp; dcont->clientTimestamp = scont->clientTimestamp; dcont->mrtt = scont->rawMrtt; } dcont->firstLoss = htonl(scont->firstLoss); dcont->firstBootstrapSeq = htonl(scont->firstBootstrapSeq); dcont->startCwnd = htonl(scont->startCwnd); dcont->ssthresh = htonl(scont->ssthresh); dcont->TCPBase = htonl(scont->TCPBase); dcont->tokenCounterBase = scont->tokenCounterBase; do { PseudoHeader hdr, *phdr = &hdr; phdr->seq = dcont->seq; phdr->type = dcont->continuationType; phdr->first = dcont->firstChild ? 1 : 0; phdr->serverAddr = scont->saddr; phdr->serverPort = scont->source; phdr->clientAddr = scont->daddr; phdr->clientPort = scont->dest; computeMAC(sk, phdr, dcont, dcont->mac); } while(0); }
trickles-userapi_1.c:20452:static inline void marshallContinuationServerCopyMAC(struct sock *sk, WireContinuation *dcont, const struct cminisock *scont, int pktNum) { dcont->clientState = scont->clientState; dcont->parent = scont->parent; if(1) { ({ (dcont)->seq = htonl((scont)->packets[pktNum].seq); (dcont)->continuationType = (scont)->packets[pktNum].contType; if((scont)->packets[pktNum].type & (0x80)) { (dcont)->firstChild = 1; } else { (dcont)->firstChild = 0; } static const int stateConversionMap[] = { 0, 1, 2 }; int conversionOffset = (scont)->packets[pktNum].type & (0x3); if(conversionOffset >= (3)) { do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } (dcont)->state = stateConversionMap[conversionOffset]; }); dcont->timestamp = htonl(scont->timestamp); dcont->clientTimestamp = scont->clientTimestamp; dcont->mrtt = htonl(scont->mrtt); } else { dcont->seq = htonl(scont->seq); dcont->continuationType = scont->continuationType; dcont->firstChild = scont->firstChild; dcont->state = scont->state; dcont->timestamp = scont->rawTimestamp; dcont->clientTimestamp = scont->clientTimestamp; dcont->mrtt = scont->rawMrtt; } dcont->firstLoss = htonl(scont->firstLoss); dcont->firstBootstrapSeq = htonl(scont->firstBootstrapSeq); dcont->startCwnd = htonl(scont->startCwnd); dcont->ssthresh = htonl(scont->ssthresh); dcont->TCPBase = htonl(scont->TCPBase); dcont->tokenCounterBase = scont->tokenCounterBase; do{ (__builtin_constant_p(16) ? __constant_memcpy((dcont->mac),(scont->mac),(16)) : __memcpy((dcont->mac),(scont->mac),(16))); } while(0); }
trickles-userapi_1.c:20453:static inline void marshallContinuationClient(struct sock *sk, WireContinuation *dcont, const struct cminisock *scont, int pktNum) { dcont->clientState = scont->clientState; dcont->parent = scont->parent; if(0) { ({ (dcont)->seq = htonl((scont)->packets[pktNum].seq); (dcont)->continuationType = (scont)->packets[pktNum].contType; if((scont)->packets[pktNum].type & (0x80)) { (dcont)->firstChild = 1; } else { (dcont)->firstChild = 0; } static const int stateConversionMap[] = { 0, 1, 2 }; int conversionOffset = (scont)->packets[pktNum].type & (0x3); if(conversionOffset >= (3)) { do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } (dcont)->state = stateConversionMap[conversionOffset]; }); dcont->timestamp = htonl(scont->timestamp); dcont->clientTimestamp = scont->clientTimestamp; dcont->mrtt = htonl(scont->mrtt); } else { dcont->seq = htonl(scont->seq); dcont->continuationType = scont->continuationType; dcont->firstChild = scont->firstChild; dcont->state = scont->state; dcont->timestamp = scont->rawTimestamp; dcont->clientTimestamp = scont->clientTimestamp; dcont->mrtt = scont->rawMrtt; } dcont->firstLoss = htonl(scont->firstLoss); dcont->firstBootstrapSeq = htonl(scont->firstBootstrapSeq); dcont->startCwnd = htonl(scont->startCwnd); dcont->ssthresh = htonl(scont->ssthresh); dcont->TCPBase = htonl(scont->TCPBase); dcont->tokenCounterBase = scont->tokenCounterBase; do{ (__builtin_constant_p(16) ? __constant_memcpy((dcont->mac),(scont->mac),(16)) : __memcpy((dcont->mac),(scont->mac),(16))); } while(0); }
trickles-userapi_1.c:20462:  dproof->numSacks = ({ typeof(sproof->numSacks) Z = (typeof(sproof->numSacks))(64); ({ const typeof(sproof->numSacks) _x = (sproof->numSacks); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y; }); });
trickles-userapi_1.c:20463:  for(i=0; i < dproof->numSacks; i++) {
trickles-userapi_1.c:20464:    dproof->sacks[i].left = htonl(sproof->sacks[i].left);;
trickles-userapi_1.c:20465:    dproof->sacks[i].right = htonl(sproof->sacks[i].right);;
trickles-userapi_1.c:20466:    dproof->sacks[i].nonceSummary = sproof->sacks[i].nonceSummary;
trickles-userapi_1.c:20477:static inline int unmarshallContinuationServerMSK(struct sk_buff *skb, struct cminisock *dcont, const WireContinuation *scont) { do { if(__builtin_expect((!(((skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((skb->sk)->tp_pinfo.af_tcp.trickles_opt & (skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))),0)) { char mac[16]; PseudoHeader hdr, *phdr = &hdr; phdr->seq = scont->seq; phdr->type = scont->continuationType; phdr->first = scont->firstChild; phdr->serverAddr = skb->nh.iph->daddr; phdr->serverPort = skb->h.th->dest; phdr->clientAddr = skb->nh.iph->saddr; phdr->clientPort = skb->h.th->source; computeMAC(skb->sk, phdr, scont, mac); if(__builtin_memcmp(mac, scont->mac, 16)) { printk("failed hmac comparison\n"); return 0; } } } while(0);; dcont->continuationType = scont->continuationType; dcont->seq = ntohl(scont->seq);; dcont->clientState = scont->clientState; dcont->parent = scont->parent; dcont->rawTimestamp = scont->timestamp; dcont->timestamp = ntohl(scont->timestamp); dcont->rawMrtt = scont->mrtt; dcont->mrtt = ntohl(scont->mrtt);; dcont->clientTimestamp = scont->clientTimestamp; dcont->state = scont->state; dcont->firstChild = scont->firstChild; dcont->firstLoss = ntohl(scont->firstLoss);; dcont->firstBootstrapSeq = ntohl(scont->firstBootstrapSeq);; dcont->startCwnd = ntohl(scont->startCwnd);; dcont->ssthresh = ntohl(scont->ssthresh);; dcont->TCPBase = ntohl(scont->TCPBase);; if(__builtin_expect((!(((skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((skb->sk)->tp_pinfo.af_tcp.trickles_opt & (skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))),0)) { dcont->saddr = skb->nh.iph->daddr; dcont->daddr = skb->nh.iph->saddr; dcont->source = skb->h.th->dest; dcont->dest = skb->h.th->source; }; dcont->tokenCounterBase = scont->tokenCounterBase; dcont->num_packets = 0; dcont->numChildrenReceived = 0; dcont->parentMSK = ((void *)0);; return 1; };
trickles-userapi_1.c:20484:static inline int unmarshallContinuationServerPMSK(struct sk_buff *skb, struct pminisock *dcont, const WireContinuation *scont) { do { if(__builtin_expect((!(((skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((skb->sk)->tp_pinfo.af_tcp.trickles_opt & (skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))),0)) { char mac[16]; PseudoHeader hdr, *phdr = &hdr; phdr->seq = scont->seq; phdr->type = scont->continuationType; phdr->first = scont->firstChild; phdr->serverAddr = skb->nh.iph->daddr; phdr->serverPort = skb->h.th->dest; phdr->clientAddr = skb->nh.iph->saddr; phdr->clientPort = skb->h.th->source; computeMAC(skb->sk, phdr, scont, mac); if(__builtin_memcmp(mac, scont->mac, 16)) { printk("failed hmac comparison\n"); return 0; } } } while(0);; dcont->continuationType = scont->continuationType; dcont->seq = ntohl(scont->seq);; dcont->clientState = scont->clientState; dcont->parent = scont->parent; dcont->rawTimestamp = scont->timestamp; dcont->rawMrtt = scont->mrtt;; dcont->clientTimestamp = scont->clientTimestamp; dcont->state = scont->state; dcont->firstChild = scont->firstChild; dcont->firstLoss = ntohl(scont->firstLoss);; dcont->firstBootstrapSeq = ntohl(scont->firstBootstrapSeq);; dcont->startCwnd = ntohl(scont->startCwnd);; dcont->ssthresh = ntohl(scont->ssthresh);; dcont->TCPBase = ntohl(scont->TCPBase);; dcont->daddr = skb->nh.iph->saddr; dcont->dest = skb->h.th->source;; dcont->tokenCounterBase = scont->tokenCounterBase; dcont->num_packets = 0;; return 1; };
trickles-userapi_1.c:20491:static inline int unmarshallContinuationServerPMSK2MSK(struct sock *sk, struct cminisock *dcont, struct pminisock *scont) { ; dcont->continuationType = scont->continuationType; dcont->seq = scont->seq; dcont->clientState = scont->clientState; dcont->parent = scont->parent; dcont->rawTimestamp = scont->rawTimestamp; dcont->timestamp = ntohl(scont->rawTimestamp); dcont->rawMrtt = scont->rawMrtt; dcont->mrtt = ntohl(scont->rawMrtt);; dcont->clientTimestamp = scont->clientTimestamp; dcont->state = scont->state; dcont->firstChild = scont->firstChild; dcont->firstLoss = scont->firstLoss; dcont->firstBootstrapSeq = scont->firstBootstrapSeq; dcont->startCwnd = scont->startCwnd; dcont->ssthresh = scont->ssthresh; dcont->TCPBase = scont->TCPBase; dcont->saddr = sk->saddr; dcont->source = sk->sport; dcont->daddr = scont->daddr; dcont->dest = scont->dest;; dcont->tokenCounterBase = scont->tokenCounterBase; dcont->num_packets = 0; ; dcont->pmsk = scont;; return 1; };
trickles-userapi_1.c:20498:static inline int unmarshallContinuationServerMSK2PMSK(struct sock *sk, struct pminisock *dcont, struct cminisock *scont) { ; dcont->continuationType = scont->continuationType; dcont->seq = scont->seq; dcont->clientState = scont->clientState; dcont->parent = scont->parent; dcont->rawTimestamp = scont->rawTimestamp; dcont->rawMrtt = scont->rawMrtt;; dcont->clientTimestamp = scont->clientTimestamp; dcont->state = scont->state; dcont->firstChild = scont->firstChild; dcont->firstLoss = scont->firstLoss; dcont->firstBootstrapSeq = scont->firstBootstrapSeq; dcont->startCwnd = scont->startCwnd; dcont->ssthresh = scont->ssthresh; dcont->TCPBase = scont->TCPBase; dcont->daddr = scont->daddr; dcont->dest = scont->dest;; dcont->tokenCounterBase = scont->tokenCounterBase; dcont->num_packets = 0; ; dcont->num_packets = scont->num_packets; dcont->ucont_data = scont->ucont_data; dcont->ucont_len = scont->ucont_len; dcont->input = scont->input; dcont->input_len = scont->input_len; dcont->packets = scont->packets;; return 1; };
trickles-userapi_1.c:20505:static inline int unmarshallContinuationClient(struct sk_buff *skb, struct cminisock *dcont, const WireContinuation *scont) { do { (__builtin_constant_p(16) ? __constant_memcpy((dcont->mac),(scont->mac),(16)) : __memcpy((dcont->mac),(scont->mac),(16))); } while(0); dcont->continuationType = scont->continuationType; dcont->seq = ntohl(scont->seq);; dcont->clientState = scont->clientState; dcont->parent = scont->parent; dcont->rawTimestamp = scont->timestamp; dcont->timestamp = ntohl(scont->timestamp); dcont->rawMrtt = scont->mrtt; dcont->mrtt = ntohl(scont->mrtt);; dcont->clientTimestamp = scont->clientTimestamp; dcont->state = scont->state; dcont->firstChild = scont->firstChild; dcont->firstLoss = ntohl(scont->firstLoss);; dcont->firstBootstrapSeq = ntohl(scont->firstBootstrapSeq);; dcont->startCwnd = ntohl(scont->startCwnd);; dcont->ssthresh = ntohl(scont->ssthresh);; dcont->TCPBase = ntohl(scont->TCPBase);; if(__builtin_expect((!(((skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((skb->sk)->tp_pinfo.af_tcp.trickles_opt & (skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))),0)) { dcont->saddr = skb->nh.iph->daddr; dcont->daddr = skb->nh.iph->saddr; dcont->source = skb->h.th->dest; dcont->dest = skb->h.th->source; }; dcont->tokenCounterBase = scont->tokenCounterBase; dcont->num_packets = 0; dcont->numChildrenReceived = 0; dcont->parentMSK = ((void *)0);; return 1; };
trickles-userapi_1.c:20522:        for(i=0; i < (((cont)+1)->num_packets); i++) {
trickles-userapi_1.c:20523:                total += (((cont)+1)->packets)[i].len;
trickles-userapi_1.c:20559:  rval->prev = rval->next = ((void *)0);
trickles-userapi_1.c:20560:  rval->list = ((void *)0);
trickles-userapi_1.c:20566:          (rval+i)->ucont_len = 0;
trickles-userapi_1.c:20567:          (rval+i)->ucont_data = ((void *)0);
trickles-userapi_1.c:20568:          (rval+i)->input_len = 0;
trickles-userapi_1.c:20569:          (rval+i)->input = ((void *)0);
trickles-userapi_1.c:20571:          (rval+i)->mark = 0;
trickles-userapi_1.c:20572:          (rval+i)->simulated = 0;
trickles-userapi_1.c:20574:  rval->sk = ((void *)0);
trickles-userapi_1.c:20599:  rval->prev = rval->next = ((void *)0);
trickles-userapi_1.c:20600:  rval->list = ((void *)0);
trickles-userapi_1.c:20602:  (__builtin_constant_p((int)((struct cminisock *)0)->clientside_copy_end) ? __constant_memcpy((rval),(cont),((int)((struct cminisock *)0)->clientside_copy_end)) : __memcpy((rval),(cont),((int)((struct cminisock *)0)->clientside_copy_end)));
trickles-userapi_1.c:20605:          (rval+i)->ucont_len = 0;
trickles-userapi_1.c:20606:          (rval+i)->ucont_data = ((void *)0);
trickles-userapi_1.c:20608:          (rval+i)->input_len = 0;
trickles-userapi_1.c:20609:          (rval+i)->input = ((void *)0);
trickles-userapi_1.c:20611:          (rval+i)->mark = 0;
trickles-userapi_1.c:20612:          (rval+i)->simulated = 0;
trickles-userapi_1.c:20613:          (rval+i)->num_packets = 0;
trickles-userapi_1.c:20614:          (rval+i)->actualCwnd = 0;
trickles-userapi_1.c:20625:  if(cont->list) {
trickles-userapi_1.c:20630:    if((cont+i)->ucont_data)
trickles-userapi_1.c:20631:      kfree((cont+i)->ucont_data);
trickles-userapi_1.c:20632:    if((cont+i)->input)
trickles-userapi_1.c:20633:      kfree((cont+i)->input);
trickles-userapi_1.c:20646:  dproof->numSacks = sproof->numSacks;
trickles-userapi_1.c:20647:  for(i=0; i < sproof->numSacks; i++) {
trickles-userapi_1.c:20648:    dproof->sacks[i].left = ntohl(sproof->sacks[i].left);;
trickles-userapi_1.c:20649:    dproof->sacks[i].right = ntohl(sproof->sacks[i].right);;
trickles-userapi_1.c:20650:    dproof->sacks[i].nonceSummary = sproof->sacks[i].nonceSummary;
trickles-userapi_1.c:20657:  unsigned dataLen = length - sizeof(struct WireUC_Continuation);
trickles-userapi_1.c:20664:  rval->prev = rval->next = ((void *)0);
trickles-userapi_1.c:20665:  rval->list = ((void *)0);
trickles-userapi_1.c:20667:  rval->seq = ntohl(scont->seq);
trickles-userapi_1.c:20668:  rval->validStart = ntohl(scont->validStart);
trickles-userapi_1.c:20669:  rval->validEnd = ntohl(scont->validEnd);
trickles-userapi_1.c:20670:  rval->fields = scont->fields;
trickles-userapi_1.c:20671:  rval->dataLen = dataLen;
trickles-userapi_1.c:20672:  rval->kernel.obsoleteAt = rval->validEnd;
trickles-userapi_1.c:20673:  (__builtin_constant_p(dataLen) ? __constant_memcpy((rval->kernel.data),(scont->data),(dataLen)) : __memcpy((rval->kernel.data),(scont->data),(dataLen)));
trickles-userapi_1.c:20678:  int dataLen = scont->dataLen;
trickles-userapi_1.c:20679:  dcont->seq = htonl(scont->seq);
trickles-userapi_1.c:20680:  dcont->validStart = htonl(scont->validStart);
trickles-userapi_1.c:20681:  dcont->validEnd = htonl(scont->validEnd);
trickles-userapi_1.c:20682:  dcont->fields = scont->fields;
trickles-userapi_1.c:20683:  (__builtin_constant_p(dataLen) ? __constant_memcpy((dcont->data),(scont->kernel.data),(dataLen)) : __memcpy((dcont->data),(scont->kernel.data),(dataLen)));
trickles-userapi_1.c:20690:  completeResp->fields |= (0x01);
trickles-userapi_1.c:20697:  int dataLen = scont->dataLen;
trickles-userapi_1.c:20704:  rval->prev = rval->next = ((void *)0);
trickles-userapi_1.c:20705:  rval->list = ((void *)0);
trickles-userapi_1.c:20707:  (__builtin_constant_p(dataLen) ? __constant_memcpy((rval->kernel.data),(scont->kernel.data),(dataLen)) : __memcpy((rval->kernel.data),(scont->kernel.data),(dataLen)));
trickles-userapi_1.c:20723:  return -1;
trickles-userapi_1.c:20747:  return -1;
trickles-userapi_1.c:20756:  wireContinuation->fields = 0;
trickles-userapi_1.c:20760:  char *rval = wireContinuation->data;
trickles-userapi_1.c:20762:  if(wireContinuation->fields & (0x01)) {
trickles-userapi_1.c:20766:  if(wireContinuation->fields & ~((0x01))) {
trickles-userapi_1.c:20776:  resp->type = type;
trickles-userapi_1.c:20777:  resp->error = error;
trickles-userapi_1.c:20778:  resp->len = htons((short)len);
trickles-userapi_1.c:20786:  incompleteResp->ack_seq = htonl(ack_seq);
trickles-userapi_1.c:20787:  incompleteResp->newCont.validStart = htonl(validStart);
trickles-userapi_1.c:20795:  completeResp->ack_seq = htonl(ack_seq);
trickles-userapi_1.c:20796:  completeResp->newCont.seq = htonl(seq);
trickles-userapi_1.c:20797:  completeResp->newCont.validStart = htonl(validStart);
trickles-userapi_1.c:20798:  completeResp->newCont.validEnd = htonl(validEnd);
trickles-userapi_1.c:20799:  completeResp->newCont.fields = 0;
trickles-userapi_1.c:20807:        newContinuationResp->newCont.seq = htonl(seq);
trickles-userapi_1.c:20808:        newContinuationResp->newCont.validStart = htonl(validStart);
trickles-userapi_1.c:20809:        newContinuationResp->newCont.validEnd = htonl(validEnd);
trickles-userapi_1.c:20810:        newContinuationResp->newCont.fields = 0;
trickles-userapi_1.c:20815:         printk("seq=[%d]\n", ucont->seq);
trickles-userapi_1.c:20816:         printk("valid=[%d-%d] [%d-%d]\n", ucont->validStart, ucont->validEnd,
trickles-userapi_1.c:20817:                htonl(ucont->validStart), htonl(ucont->validEnd));
trickles-userapi_1.c:20818:         printk("cvalid=[%d-%d] [%d-%d]\n", ucont->clientValidStart, ucont->clientValidEnd,
trickles-userapi_1.c:20819:                htonl(ucont->clientValidStart), htonl(ucont->clientValidEnd));
trickles-userapi_1.c:20826:        chunk->byteNum = htonl(byteNum);
trickles-userapi_1.c:20827:        chunk->type = RCHUNK_DATA;
trickles-userapi_1.c:20828:        chunk->chunkLen = htons(chunkLen + sizeof(struct DataChunk));
trickles-userapi_1.c:20830:        return (struct DataChunk *) (chunk->data + chunkLen);
trickles-userapi_1.c:20836:        phchunk->type = RCHUNK_PUSH_HINT;
trickles-userapi_1.c:20837:        phchunk->chunkLen = htons(sizeof(struct PushHintChunk));
trickles-userapi_1.c:20838:        phchunk->start = htonl(start);
trickles-userapi_1.c:20839:        phchunk->end = htonl(end);
trickles-userapi_1.c:20860:        ctx->packetNum = 0;
trickles-userapi_1.c:20861:        ctx->packetPos = 0;
trickles-userapi_1.c:20862:        ctx->outputPos = ctx->outputStart = dest;
trickles-userapi_1.c:20863:        ctx->packets = packets;
trickles-userapi_1.c:20864:        ctx->numPackets = numPackets;
trickles-userapi_1.c:20870:        for(i=0; i < ctx->numPackets; i++) {
trickles-userapi_1.c:20871:                printk("Packet [%d] = %d\n", i, ctx->packets[i].len);
trickles-userapi_1.c:20878:               ctx->packetNum, ctx->packetPos, ctx->outputPos, ctx->numPackets, ctx->packets);
trickles-userapi_1.c:20883:        if(ctx->packetNum >= ctx->numPackets) {
trickles-userapi_1.c:20886:        return ctx->packets[ctx->packetNum].len - ctx->packetPos;
trickles-userapi_1.c:20892:        if(numBytes == 0) return ctx->outputPos;
trickles-userapi_1.c:20894:        do { if(ctx->packetNum >= ctx->numPackets) { return ((void *)0); } } while(0);
trickles-userapi_1.c:20896:        if(!(ctx->packetNum <= ctx->numPackets)) {
trickles-userapi_1.c:20897:                if (!(ctx->packetNum <= ctx->numPackets)) { printk("KERNEL: assertion (" "ctx->packetNum <= ctx->numPackets" ") failed at " "/home/ashieh/current/include/net/trickles_packet_helpers.h" "(%d)\n", 851); };
trickles-userapi_1.c:20898:                printk("%d !<= %d\n", ctx->packetNum, ctx->numPackets);
trickles-userapi_1.c:20906:                if (!(numBytes <= ctx->packets[ctx->packetNum].len)) { printk("KERNEL: assertion (" "numBytes <= ctx->packets[ctx->packetNum].len" ") failed at " "/home/ashieh/current/include/net/trickles_packet_helpers.h" "(%d)\n", 860); };
trickles-userapi_1.c:20907:                ctx->outputPos += ctx->packets[ctx->packetNum].len - ctx->packetPos;
trickles-userapi_1.c:20908:                ctx->packetPos = 0;
trickles-userapi_1.c:20909:                ctx->packetNum++;
trickles-userapi_1.c:20911:        temp = ctx->outputPos;
trickles-userapi_1.c:20912:        ctx->packetPos += numBytes;
trickles-userapi_1.c:20913:        ctx->outputPos += numBytes;
trickles-userapi_1.c:20915:        do { if(ctx->packetNum >= ctx->numPackets) { return ((void *)0); } } while(0);
trickles-userapi_1.c:20917:        if (!(ctx->packetPos <= ctx->packets[ctx->packetNum].len)) { printk("KERNEL: assertion (" "ctx->packetPos <= ctx->packets[ctx->packetNum].len" ") failed at " "/home/ashieh/current/include/net/trickles_packet_helpers.h" "(%d)\n", 871); };
trickles-userapi_1.c:20919:        if(ctx->packetPos == ctx->packets[ctx->packetNum].len) {
trickles-userapi_1.c:20920:                ctx->packetPos = 0;
trickles-userapi_1.c:20921:                ctx->packetNum++;
trickles-userapi_1.c:20930:        char *currpos = ctx->outputPos;
trickles-userapi_1.c:20956:                return -1;
trickles-userapi_1.c:20968:        while((char*)(chunk+1) - start < len) {
trickles-userapi_1.c:20969:                int len = ntohs((chunk)->chunkLen) - sizeof(struct DataChunk);
trickles-userapi_1.c:20972:                                printk("bad length chunk(%d) -- ", len);
trickles-userapi_1.c:20980:                chunk = ((void*)((char*)(chunk) + ntohs((chunk)->chunkLen)));
trickles-userapi_1.c:20986:                        return -1;
trickles-userapi_1.c:20989:        if((char*)chunk - start > len) {
trickles-userapi_1.c:20990:                printk("data chunk validation failed, %d > %d\n", (char*)chunk-start, len);
trickles-userapi_1.c:20991:                return -chunknum - 1;
trickles-userapi_1.c:21003:        if (!(gctx->packetNum <= gctx->numPackets)) { printk("KERNEL: assertion (" "gctx->packetNum <= gctx->numPackets" ") failed at " "/home/ashieh/current/include/net/trickles_packet_helpers.h" "(%d)\n", 957); };
trickles-userapi_1.c:21008:        int outputLen = gctx->outputPos - gctx->outputStart;
trickles-userapi_1.c:21009:        char *buf = gctx->outputStart;
trickles-userapi_1.c:21016:        if (!(entry->prev == ((void *)0) && entry->next == ((void *)0) && entry->list == ((void *)0))) { printk("KERNEL: assertion (" "entry->prev == NULL && entry->next == NULL && entry->list == NULL" ") failed at " "/home/ashieh/current/include/net/trickles_client.h" "(%d)\n", 295); };
trickles-userapi_1.c:21018:        freeClientSide_Continuation(entry->cont);
trickles-userapi_1.c:21031:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:21032:        tp->trickles_opt = 0;
trickles-userapi_1.c:21033:        tp->mac_changed = 0;
trickles-userapi_1.c:21037:                (__builtin_constant_p(0) ? (__builtin_constant_p((sizeof(tp->cminisock_api_config))) ? __constant_c_and_count_memset(((&tp->cminisock_api_config)),((0x01010101UL*(unsigned char)(0))),((sizeof(tp->cminisock_api_config)))) : __constant_c_memset(((&tp->cminisock_api_config)),((0x01010101UL*(unsigned char)(0))),((sizeof(tp->cminisock_api_config))))) : (__builtin_constant_p((sizeof(tp->cminisock_api_config))) ? __memset_generic((((&tp->cminisock_api_config))),(((0))),(((sizeof(tp->cminisock_api_config))))) : __memset_generic(((&tp->cminisock_api_config)),((0)),((sizeof(tp->cminisock_api_config))))));
trickles-userapi_1.c:21038:                init_head(&tp->cminisock_api_config.msk_freelist);
trickles-userapi_1.c:21040:                tp->cminisock_api_config.cfg.ctl = ((void *)0);
trickles-userapi_1.c:21042:                tp->cminisock_api_config.event_lock = (rwlock_t) { };
trickles-userapi_1.c:21045:        tp->t.malloc_initialized = 0;
trickles-userapi_1.c:21047:        tp->t.heapbytesize = 0;
trickles-userapi_1.c:21048:        tp->t.heapbytesallocated = 0;
trickles-userapi_1.c:21051:                tp->t.fragblocks[i] = 0;
trickles-userapi_1.c:21052:                tp->t.fraghead[i].next = tp->t.fraghead[i].prev = ((void *)0);
trickles-userapi_1.c:21055:        tp->t.clientStateCounter = 0;
trickles-userapi_1.c:21056:        tp->t.state = 1;
trickles-userapi_1.c:21057:        tp->t.A = 0;
trickles-userapi_1.c:21058:        tp->t.D = 0;
trickles-userapi_1.c:21059:        tp->t.RTO = 0;
trickles-userapi_1.c:21060:        tp->t.timerState = 0;
trickles-userapi_1.c:21061:        tp->t.rcv_nxt = 0;
trickles-userapi_1.c:21062:        tp->t.previous_base = 0;
trickles-userapi_1.c:21063:        skb_queue_head_init(&tp->t.ofo_queue);
trickles-userapi_1.c:21065:        tp->t.ack_prev = ((void *)0);
trickles-userapi_1.c:21067:        tp->t.ack_last = 0;
trickles-userapi_1.c:21068:        tp->t.oo_count = 0;
trickles-userapi_1.c:21069:        tp->t.in_flight = 0;
trickles-userapi_1.c:21071:        tp->t.standardProof.numSacks = 0;
trickles-userapi_1.c:21072:        tp->t.altProof.numSacks = 0;
trickles-userapi_1.c:21075:        tp->t.dprev = tp->t.dnext = ((void *)0);
trickles-userapi_1.c:21076:        tp->t.dbg_skb = ((void *)0);
trickles-userapi_1.c:21077:        init_head(&tp->t.cont_list);
trickles-userapi_1.c:21079:        init_timer(&tp->t.slowstart_timer);
trickles-userapi_1.c:21083:        tp->t.request_rcv_nxt = 0;
trickles-userapi_1.c:21084:        tp->t.request_snd_nxt = 0;
trickles-userapi_1.c:21085:        init_head(&tp->t.request_ofo_queue);
trickles-userapi_1.c:21086:        skb_queue_head_init(&tp->t.data_ofo_queue);
trickles-userapi_1.c:21087:        init_head(&tp->t.sentRequests);
trickles-userapi_1.c:21088:        init_head(&tp->t.queuedRequests);
trickles-userapi_1.c:21090:        init_head(&tp->t.dataRequestMap);
trickles-userapi_1.c:21091:        init_head(&tp->t.missingDataMap);
trickles-userapi_1.c:21093:        tp->t.byteReqNext = 0;
trickles-userapi_1.c:21094:        tp->t.byteReqHint = ((void *)0);
trickles-userapi_1.c:21098:        tp->t.conversionState = (1);
trickles-userapi_1.c:21099:        tp->t.snd_una = tp->t.write_seq = 0;
trickles-userapi_1.c:21100:        tp->t.snd_end = 0;
trickles-userapi_1.c:21101:        skb_queue_head_init(&tp->t.requestBytes);
trickles-userapi_1.c:21102:        tp->t.newIncompleteRequest = ((void *)0);
trickles-userapi_1.c:21103:        tp->t.prevConvCont = ((void *)0);
trickles-userapi_1.c:21105:        init_head(&tp->t.ucontList);
trickles-userapi_1.c:21106:        init_head(&tp->t.depNodeList);
trickles-userapi_1.c:21112:        tp->t.nonceCTX = ((void *)0);
trickles-userapi_1.c:21113:        skb_queue_head_init(&tp->t.prequeueOverflow);
trickles-userapi_1.c:21114:        skb_queue_head_init(&tp->t.sendAckOverflow);
trickles-userapi_1.c:21115:        skb_queue_head_init(&tp->t.recycleList);
trickles-userapi_1.c:21117:        tp->t.responseMSK = ((void *)0);
trickles-userapi_1.c:21118:        init_head(&tp->t.responseList);
trickles-userapi_1.c:21119:        tp->t.responseCount = 0;
trickles-userapi_1.c:21121:        tp->t.events = ((void *)0);
trickles-userapi_1.c:21122:        tp->drop_rate = 0;
trickles-userapi_1.c:21123:        tp->instrumentation = 0;
trickles-userapi_1.c:21238:        msk->num_packets = 0;
trickles-userapi_1.c:21239:        msk->ucont_len = 0;
trickles-userapi_1.c:21240:        msk->ucont_data = ((void *)0);
trickles-userapi_1.c:21241:        msk->input_len = 0;
trickles-userapi_1.c:21242:        msk->input = ((void *)0);
trickles-userapi_1.c:21243:        msk->packets = ((void *)0);
trickles-userapi_1.c:21245:        msk->refCnt = 1;
trickles-userapi_1.c:21247:        msk->cacheRecycleIndex = -1;
trickles-userapi_1.c:21248:        msk->serverSK = ((void *)0);
trickles-userapi_1.c:21249:        msk->pmsk = ((void *)0);
trickles-userapi_1.c:21250:        msk->isStatic = 0;
trickles-userapi_1.c:21255:        msk->isStatic = 1;
trickles-userapi_1.c:21256:        msk->prev = msk->next = ((void *)0);
trickles-userapi_1.c:21257:        msk->ctl = ALLOC_PENDING;
trickles-userapi_1.c:21261:        pmsk->num_packets = 0;
trickles-userapi_1.c:21262:        pmsk->ucont_len = 0;
trickles-userapi_1.c:21263:        pmsk->ucont_data = ((void *)0);
trickles-userapi_1.c:21264:        pmsk->input_len = 0;
trickles-userapi_1.c:21265:        pmsk->input = ((void *)0);
trickles-userapi_1.c:21266:        pmsk->packets = ((void *)0);
trickles-userapi_1.c:21267:        pmsk->refCnt = 1;
trickles-userapi_1.c:21268:        pmsk->cacheRecycleIndex = -1;
trickles-userapi_1.c:21280:        if(msk->num_packets > 0) {
trickles-userapi_1.c:21281:                printk("msk packets is %d\n", msk->num_packets);
trickles-userapi_1.c:21283:        if (!(msk->num_packets == 0)) { printk("KERNEL: assertion (" "msk->num_packets == 0" ") failed at " "/home/ashieh/current/include/net/trickles_minisock_functions.h" "(%d)\n", 53); };
trickles-userapi_1.c:21287:        if(!(((msk->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((msk->sk)->tp_pinfo.af_tcp.trickles_opt & (msk->sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) {
trickles-userapi_1.c:21288:                msk->packets = tmalloc(msk->sk, sizeof(struct cminisock_packet) * numPackets);
trickles-userapi_1.c:21292:                if(msk->packets == ((void *)0)) {
trickles-userapi_1.c:21301:                        msk->packets = packets[0];
trickles-userapi_1.c:21303:                        msk->packets = ((void *)0);
trickles-userapi_1.c:21310:        msk->num_packets = numPackets;
trickles-userapi_1.c:21316:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:21317:        struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
trickles-userapi_1.c:21319:                (struct cminisock *)head->next;
trickles-userapi_1.c:21320:        while((struct alloc_head_list*)curr != head && curr->ctl == ALLOC_PROCESSING) {
trickles-userapi_1.c:21322:                curr = curr->next;
trickles-userapi_1.c:21328:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:21329:        struct list_link *phead = (struct list_link *)&tp->cminisock_api_config.pmsk_freelist;
trickles-userapi_1.c:21331:                tp->cminisock_api_config.pmsk_freelist.next;
trickles-userapi_1.c:21333:        if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) {
trickles-userapi_1.c:21335:                      pcurr->ctl == ALLOC_PROCESSING) {
trickles-userapi_1.c:21337:                        pcurr = pcurr->next;
trickles-userapi_1.c:21352:        rval->ctl = ALLOC_PENDING;
trickles-userapi_1.c:21360:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:21361:        struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
trickles-userapi_1.c:21363:                tp->cminisock_api_config.msk_freelist.next;
trickles-userapi_1.c:21365:        if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) {
trickles-userapi_1.c:21367:                      curr->ctl == ALLOC_PROCESSING) {
trickles-userapi_1.c:21369:                        curr = curr->next;
trickles-userapi_1.c:21380:                rval->ctl = ALLOC_PENDING;
trickles-userapi_1.c:21382:                if(tp->t.responseCount == 0) {
trickles-userapi_1.c:21383:                        rval = tp->t.responseMSK;
trickles-userapi_1.c:21384:                        rval->list = ((void *)0);
trickles-userapi_1.c:21385:                        rval->next = rval->prev = ((void *)0);
trickles-userapi_1.c:21392:                        rval->next = rval->prev = ((void *)0);
trickles-userapi_1.c:21393:                        rval->list = ((void *)0);
trickles-userapi_1.c:21394:                        insert_tail(&tp->t.responseList, (struct alloc_head*)rval);
trickles-userapi_1.c:21396:                tp->t.responseCount++;
trickles-userapi_1.c:21398:                rval->sk = sk;
trickles-userapi_1.c:21399:                rval->ctl = ALLOC_PENDING;
trickles-userapi_1.c:21415:static inline void msk_hold(struct cminisock *msk) { msk->refCnt++; } static struct cminisock *shallow_copy_msk(struct sock *sk, struct cminisock *pmsk) { struct cminisock *rval = alloc_trickles_msk(sk); struct alloc_head_list head; if(rval == ((void *)0)) { struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp); printk("out of memory while shallow copying msk\n"); printk("list len is %d\n", tp->cminisock_api_config.msk_freelist.len); return ((void *)0); } head = *(struct alloc_head_list *)rval; *rval = *pmsk; *(struct alloc_head_list *)rval = head; rval->refCnt = 1; rval->isStatic = 0; return rval; } static struct cminisock *copy_msk(struct sock *sk, struct cminisock *pmsk) { struct cminisock *rval = shallow_copy_msk(sk, pmsk); if(rval == ((void *)0)) { printk("out of memory while copying msk\n"); return ((void *)0); } rval->num_packets = 0; rval->packets = ((void *)0); rval->pmsk = ((void *)0); if(rval->ucont_len > 0) { rval->ucont_data = tmalloc(sk,rval->ucont_len); if(rval->ucont_data == ((void *)0)) { printk("out of tmalloc memory while copying msk (len = %d)\n", rval->ucont_len); free_trickles_msk(sk,rval); free_trickles_msk_finish(sk,rval); return ((void *)0); } } else { rval->ucont_data = ((void *)0); } if(rval->input_len > 0) { rval->input = tmalloc(sk,rval->input_len); if(rval->input == ((void *)0)) { printk("out of tmalloc memory while copying msk (%s len = %d)\n", "msk", rval->input_len); tfree(sk,rval->ucont_data); free_trickles_msk(sk,rval); free_trickles_msk_finish(sk,rval); return ((void *)0); } } else { rval->input = ((void *)0); } if(rval->ucont_data) (__builtin_constant_p(rval->ucont_len) ? __constant_memcpy((rval->ucont_data),(pmsk->ucont_data),(rval->ucont_len)) : __memcpy((rval->ucont_data),(pmsk->ucont_data),(rval->ucont_len))); if(rval->input) (__builtin_constant_p(rval->input_len) ? __constant_memcpy((rval->input),(pmsk->input),(rval->input_len)) : __memcpy((rval->input),(pmsk->input),(rval->input_len))); return rval; } static void free_trickles_msk(struct sock *sk, struct cminisock *msk) { if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) { if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) { printk("double free\n"); do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } if(msk->ctl == ALLOC_READY && msk->prev != ((void *)0)) { unlink((struct alloc_head*)msk); } msk->ctl = ALLOC_PROCESSING; } } static void free_msk(struct sock *sk, struct cminisock *msk) { int i; for(i=0; i < msk->num_packets; i++) { if(msk->packets[i].ucontData != ((void *)0)) { kfree(msk->packets[i].ucontData); } } if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8)) && msk->packets) { tfree(sk,msk->packets); msk->packets = ((void *)0); } msk->num_packets = 0; if(msk->ucont_data != ((void *)0)) { tfree(sk,msk->ucont_data); msk->ucont_data = ((void *)0); } msk->ucont_len = 0; if(msk->input != ((void *)0)) { tfree(sk,msk->input); msk->input = ((void *)0); } msk->input_len = 0; } static void msk_release(struct sock *sk, struct cminisock *msk) { msk->refCnt--; if (!(msk->refCnt <= 3)) { printk("KERNEL: assertion (" "msk->refCnt <= 3" ") failed at " "/home/ashieh/current/include/net/trickles_minisock_functions.h" "(%d)\n", 381); }; if(msk->refCnt == 0) { struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp); struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist; free_msk(sk,msk); if(!msk->isStatic) { if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) { insert_head((head), (struct alloc_head *)(msk)); msk->ctl = ALLOC_FREE; } else { if(msk != tp->t.responseMSK) { unlink((struct alloc_head*)msk); kfree(msk); } tp->t.responseCount--; } } } else { } if(msk->pmsk != ((void *)0)) { struct pminisock *pmsk = msk->pmsk; free_trickles_pmsk(sk, pmsk); free_trickles_pmsk_finish(sk, pmsk); }; } static void free_trickles_msk_finish(struct sock *sk, struct cminisock *msk) { if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) { if(msk->ctl != ALLOC_PROCESSING && msk->ctl != ALLOC_HALFFREE) { printk("(free_trickles_msk_finish %s) without corresponding free_trickles_msk: msk->ctl = %d\n", "msk", msk->ctl); do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } } msk_release(sk,msk); } static inline void msk_clear_fields(struct cminisock *msk) { msk->num_packets = 0; msk->packets = ((void *)0); msk->ucont_len = 0; msk->ucont_data = ((void *)0); msk->input_len = 0; msk->input = ((void *)0); };
trickles-userapi_1.c:21417:static inline void pmsk_hold(struct pminisock *msk) { msk->refCnt++; } static struct pminisock *shallow_copy_pmsk(struct sock *sk, struct pminisock *pmsk) { struct pminisock *rval = alloc_trickles_pmsk(sk); struct list_link head; if(rval == ((void *)0)) { struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp); printk("out of memory while shallow copying msk\n"); ; return ((void *)0); } head = *(struct list_link *)rval; *rval = *pmsk; *(struct list_link *)rval = head; rval->refCnt = 1; return rval; } static struct pminisock *copy_pmsk(struct sock *sk, struct pminisock *pmsk) { struct pminisock *rval = shallow_copy_pmsk(sk, pmsk); if(rval == ((void *)0)) { printk("out of memory while copying msk\n"); return ((void *)0); } rval->num_packets = 0; rval->packets = ((void *)0); if(rval->ucont_len > 0) { rval->ucont_data = tmalloc(sk,rval->ucont_len); if(rval->ucont_data == ((void *)0)) { printk("out of tmalloc memory while copying msk (len = %d)\n", rval->ucont_len); free_trickles_pmsk(sk,rval); free_trickles_pmsk_finish(sk,rval); return ((void *)0); } } else { rval->ucont_data = ((void *)0); } if(rval->input_len > 0) { rval->input = tmalloc(sk,rval->input_len); if(rval->input == ((void *)0)) { printk("out of tmalloc memory while copying msk (%s len = %d)\n", "pmsk", rval->input_len); tfree(sk,rval->ucont_data); free_trickles_pmsk(sk,rval); free_trickles_pmsk_finish(sk,rval); return ((void *)0); } } else { rval->input = ((void *)0); } if(rval->ucont_data) (__builtin_constant_p(rval->ucont_len) ? __constant_memcpy((rval->ucont_data),(pmsk->ucont_data),(rval->ucont_len)) : __memcpy((rval->ucont_data),(pmsk->ucont_data),(rval->ucont_len))); if(rval->input) (__builtin_constant_p(rval->input_len) ? __constant_memcpy((rval->input),(pmsk->input),(rval->input_len)) : __memcpy((rval->input),(pmsk->input),(rval->input_len))); return rval; } static void free_trickles_pmsk(struct sock *sk, struct pminisock *msk) { if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) { if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) { printk("double free\n"); do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } if(msk->ctl == ALLOC_READY && msk->prev != ((void *)0)) { dlist_unlink((struct list_link*)(msk)); } msk->ctl = ALLOC_PROCESSING; } } static void free_pmsk(struct sock *sk, struct pminisock *msk) { int i; for(i=0; i < msk->num_packets; i++) { if(msk->packets[i].ucontData != ((void *)0)) { kfree(msk->packets[i].ucontData); } } if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8)) && msk->packets) { tfree(sk,msk->packets); msk->packets = ((void *)0); } msk->num_packets = 0; if(msk->ucont_data != ((void *)0)) { tfree(sk,msk->ucont_data); msk->ucont_data = ((void *)0); } msk->ucont_len = 0; if(msk->input != ((void *)0)) { tfree(sk,msk->input); msk->input = ((void *)0); } msk->input_len = 0; } static void pmsk_release(struct sock *sk, struct pminisock *msk) { msk->refCnt--; if (!(msk->refCnt <= 3)) { printk("KERNEL: assertion (" "msk->refCnt <= 3" ") failed at " "/home/ashieh/current/include/net/trickles_minisock_functions.h" "(%d)\n", 392); }; if(msk->refCnt == 0) { struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp); struct dlist *head = &tp->cminisock_api_config.pmsk_freelist; free_pmsk(sk,msk); if(!!(msk >= (struct pminisock *)tp->cminisock_api_config.cfg.ctl->pminisock_base && (msk+1) <= (struct pminisock *)tp->cminisock_api_config.cfg.ctl->pminisock_limit)) { if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) { dlist_insert_head(head, (struct list_link*)(msk)); msk->ctl = ALLOC_FREE; } else { ; } } } else { } ; } static void free_trickles_pmsk_finish(struct sock *sk, struct pminisock *msk) { if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->tp_pinfo.af_tcp.trickles_opt & 0x8))) { if(msk->ctl != ALLOC_PROCESSING && msk->ctl != ALLOC_HALFFREE) { printk("(free_trickles_msk_finish %s) without corresponding free_trickles_msk: msk->ctl = %d\n", "pmsk", msk->ctl); do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } } pmsk_release(sk,msk); } static inline void pmsk_clear_fields(struct pminisock *msk) { msk->num_packets = 0; msk->packets = ((void *)0); msk->ucont_len = 0; msk->ucont_data = ((void *)0); msk->input_len = 0; msk->input = ((void *)0); };
trickles-userapi_1.c:21429:        skb->next = ((void *)0);
trickles-userapi_1.c:21430:        skb->prev = ((void *)0);
trickles-userapi_1.c:21431:        skb->list = ((void *)0);
trickles-userapi_1.c:21432:        skb->sk = ((void *)0);
trickles-userapi_1.c:21433:        skb->stamp.tv_sec=0;
trickles-userapi_1.c:21434:        skb->dev = ((void *)0);
trickles-userapi_1.c:21435:        skb->real_dev = ((void *)0);
trickles-userapi_1.c:21436:        skb->dst = ((void *)0);
trickles-userapi_1.c:21437:        (__builtin_constant_p(0) ? (__builtin_constant_p((sizeof(skb->cb))) ? __constant_c_and_count_memset(((skb->cb)),((0x01010101UL*(unsigned char)(0))),((sizeof(skb->cb)))) : __constant_c_memset(((skb->cb)),((0x01010101UL*(unsigned char)(0))),((sizeof(skb->cb))))) : (__builtin_constant_p((sizeof(skb->cb))) ? __memset_generic((((skb->cb))),(((0))),(((sizeof(skb->cb))))) : __memset_generic(((skb->cb)),((0)),((sizeof(skb->cb))))));
trickles-userapi_1.c:21438:        skb->pkt_type = 0;
trickles-userapi_1.c:21439:        skb->ip_summed = 0;
trickles-userapi_1.c:21440:        skb->priority = 0;
trickles-userapi_1.c:21441:        skb->security = 0;
trickles-userapi_1.c:21442:        skb->destructor = ((void *)0);
trickles-userapi_1.c:21445:        skb->nfmark = skb->nfcache = 0;
trickles-userapi_1.c:21446:        skb->nfct = ((void *)0);
trickles-userapi_1.c:21452:        skb->tc_index = 0;
trickles-userapi_1.c:21458:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_1.c:21459:        int r0 = ((struct skb_shared_info *)((skb)->end))->nr_frags != 0,
trickles-userapi_1.c:21460:                r1 = tp->t.recycleList.qlen >= (1000),
trickles-userapi_1.c:21461:                r2 = skb->truesize - sizeof(struct sk_buff) < ((128 + 32) + (sizeof(WireTrickleResponse)) + (sysctl_trickles_mss));
trickles-userapi_1.c:21465:                                printk("Unsuitable for recycling %d %d %d truesize = %d skblen = %d\n", r0, r1, r2, skb->truesize, ((128 + 32) + (sizeof(WireTrickleResponse)) + (sysctl_trickles_mss)));
trickles-userapi_1.c:21473:        skb->tail = skb->data = skb->head;
trickles-userapi_1.c:21474:        skb->len = 0;
trickles-userapi_1.c:21475:        skb->cloned = 0;
trickles-userapi_1.c:21476:        skb->data_len =0;
trickles-userapi_1.c:21478:        (((&skb->users)->counter) = (1));
trickles-userapi_1.c:21479:        (((&(((struct skb_shared_info *)((skb)->end))->dataref))->counter) = (1));
trickles-userapi_1.c:21480:        ((struct skb_shared_info *)((skb)->end))->nr_frags = 0;
trickles-userapi_1.c:21481:        ((struct skb_shared_info *)((skb)->end))->frag_list = ((void *)0);
trickles-userapi_1.c:21483:        __skb_queue_tail(&tp->t.recycleList, skb);
trickles-userapi_1.c:21492:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_1.c:21494:        struct sk_buff *skb = __skb_dequeue_tail(&tp->t.recycleList);
trickles-userapi_1.c:21499:# 7 "trickles-int.h" 2
trickles-userapi_1.c:21608:"kernel_version=" "2.4.26-gdb-trickles";
trickles-userapi_1.c:21609:# 14 "trickles-int.h" 2
trickles-userapi_1.c:21611:# 15 "trickles-int.h" 2
trickles-userapi_1.c:21666:# 16 "trickles-int.h" 2
trickles-userapi_1.c:21673:# 17 "trickles-int.h" 2
trickles-userapi_1.c:21687:        struct files_struct *files = get_current()->files;
trickles-userapi_1.c:21689:        (void)(&files->file_lock);
trickles-userapi_1.c:21690:        res = (__extension__ ({ unsigned char __result; __asm__ __volatile__("btl %1,%2 ; setb %0" :"=q" (__result) :"r" ((int) (fd)), "m" (*(__kernel_fd_set *) (files->close_on_exec))); __result; }));
trickles-userapi_1.c:21697:        struct files_struct *files = get_current()->files;
trickles-userapi_1.c:21698:        (void)(&files->file_lock);
trickles-userapi_1.c:21700:                __asm__ __volatile__("btsl %1,%0": "=m" (*(__kernel_fd_set *) (files->close_on_exec)):"r" ((int) (fd)));
trickles-userapi_1.c:21702:                __asm__ __volatile__("btrl %1,%0": "=m" (*(__kernel_fd_set *) (files->close_on_exec)):"r" ((int) (fd)));
trickles-userapi_1.c:21710:        if (fd < files->max_fds)
trickles-userapi_1.c:21711:                file = files->fd[fd];
trickles-userapi_1.c:21721:        struct files_struct *files = get_current()->files;
trickles-userapi_1.c:21723:        if (fd < files->max_fds)
trickles-userapi_1.c:21724:                file = files->fd[fd];
trickles-userapi_1.c:21734:        __asm__ __volatile__("btrl %1,%0": "=m" (*(__kernel_fd_set *) (files->open_fds)):"r" ((int) (fd)));
trickles-userapi_1.c:21735:        if (fd < files->next_fd)
trickles-userapi_1.c:21736:                files->next_fd = fd;
trickles-userapi_1.c:21741:        struct files_struct *files = get_current()->files;
trickles-userapi_1.c:21743:        (void)(&files->file_lock);
trickles-userapi_1.c:21750:# 18 "trickles-int.h" 2
trickles-userapi_1.c:21793:# 20 "trickles-int.h" 2
trickles-userapi_1.c:21805:                c -= 'A'-'a';
trickles-userapi_1.c:21812:                c -= 'a'-'A';
trickles-userapi_1.c:21815:# 25 "trickles-int.h" 2
trickles-userapi_1.c:21825:# 27 "trickles-int.h" 2
trickles-userapi_1.c:21826:# 40 "trickles-int.h"
trickles-userapi_1.c:21828:# 41 "trickles-int.h" 2
trickles-userapi_1.c:21832:# 5 "trickles-userapi.c" 2
trickles-userapi_1.c:21833:# 1 "memdump-util.h" 1
trickles-userapi_1.c:21848:                                printk("- ");
trickles-userapi_1.c:21863:# 6 "trickles-userapi.c" 2
trickles-userapi_1.c:21864:# 22 "trickles-userapi.c"
trickles-userapi_1.c:21868:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:21869:        struct cminisock *rval = &tp->t.api_msk;
trickles-userapi_1.c:21876:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:21877:        printk("   tp->rcv_nxt = %d\n", tp->rcv_nxt);
trickles-userapi_1.c:21878:        printk("   Recv queue len = %d\n", sk->receive_queue.qlen);
trickles-userapi_1.c:21879:        printk("   Trickles state = %d\n", tp->t.state);
trickles-userapi_1.c:21880:        ({ struct tcp_opt *tp = &sk->tp_pinfo.af_tcp; printk("A = %d, D = %d, RTO = %d", tp->t.A, tp->t.D, tp->t.RTO); });
trickles-userapi_1.c:21881:        printk("   Ofo_queue len = %d\n", tp->t.ofo_queue.qlen);
trickles-userapi_1.c:21882:        printk("   data_ofo_queue len = %d\n", tp->t.data_ofo_queue.qlen);
trickles-userapi_1.c:21883:        printk("   request_ofo_queue len = %d\n", tp->t.request_ofo_queue.len);
trickles-userapi_1.c:21891:        while((char*)(chunk+1) - ptr < len && chunknum < 5) {
trickles-userapi_1.c:21892:                printk("Chunk %d(%d) - %d @ %d\n", chunknum,
trickles-userapi_1.c:21896:                       -1,
trickles-userapi_1.c:21898:                       ntohs((chunk)->chunkLen) - sizeof(struct DataChunk),
trickles-userapi_1.c:21899:                       (char*)chunk->data - ptr);
trickles-userapi_1.c:21900:                chunk = ((void*)((char*)(chunk) + ntohs((chunk)->chunkLen)));
trickles-userapi_1.c:21910:        skb_frag_t *frag = &((struct skb_shared_info *)((skb)->end))->frags[i];
trickles-userapi_1.c:21911:        frag->page = page;
trickles-userapi_1.c:21912:        frag->page_offset = off;
trickles-userapi_1.c:21913:        frag->size = size;
trickles-userapi_1.c:21914:        ((struct skb_shared_info *)((skb)->end))->nr_frags = i+1;
trickles-userapi_1.c:21924:        int off = skb->len;
trickles-userapi_1.c:21930:                skb->csum = csum_block_add(skb->csum, csum, off);
trickles-userapi_1.c:21931:# 107 "trickles-userapi.c"
trickles-userapi_1.c:21936:        return -14;
trickles-userapi_1.c:21942:        msk->sk = sk;
trickles-userapi_1.c:21943:        msk->sk->dst_cache = ((void *)0);
trickles-userapi_1.c:21944:        msk->sk->protinfo.af_inet.opt = ((void *)0);
trickles-userapi_1.c:21945:        msk->sk->protinfo.af_inet.ttl = 255;
trickles-userapi_1.c:21946:        msk->sk->protocol = IPPROTO_TCP;
trickles-userapi_1.c:21947:        msk->sk->protinfo.af_inet.tos = 0;
trickles-userapi_1.c:21948:        msk->sk->tp_pinfo.af_tcp.trickles_opt = 0;
trickles-userapi_1.c:21949:        msk->sk->localroute = 0;
trickles-userapi_1.c:21951:                msk->sk->protinfo.af_inet.pmtudisc = 0;
trickles-userapi_1.c:21953:                msk->sk->protinfo.af_inet.pmtudisc = 1;
trickles-userapi_1.c:21955:        msk->sk->bound_dev_if = 0;
trickles-userapi_1.c:21957:        msk->sk->saddr = msk->saddr;
trickles-userapi_1.c:21958:        msk->sk->sport = msk->source;
trickles-userapi_1.c:21959:        msk->sk->daddr = msk->daddr;
trickles-userapi_1.c:21960:        msk->sk->dport = msk->dest;
trickles-userapi_1.c:21974:        pgd = ((&init_mm)->pgd+((va >> 22) & (1024 -1)));
trickles-userapi_1.c:21985:                  ptep = ((pte_t *) ((unsigned long) ((void *)((unsigned long)(((*(pmd)).pmd) & (~((1UL << 12)-1)))+((unsigned long)(0xC0000000))))) + ((va >> 12) & (1024 - 1)));
trickles-userapi_1.c:21991:                        ret = (unsigned long)((void *)((unsigned long)(((((mem_map+((unsigned long)(((pte).pte_low >> 12))))) - page_zone((mem_map+((unsigned long)(((pte).pte_low >> 12)))))->zone_mem_map) << 12) + page_zone((mem_map+((unsigned long)(((pte).pte_low >> 12)))))->zone_start_paddr)+((unsigned long)(0xC0000000))));
trickles-userapi_1.c:21993:                        ret |= (va & ((1UL << 12) -1));
trickles-userapi_1.c:21999:# 214 "trickles-userapi.c"
trickles-userapi_1.c:22000:inline void queue_upcall_msk_prealloc(struct sock *sk, enum cminisock_event_tag tag, struct cminisock *msk) { struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp); switch(tag) { case SYN: case RST: case FIN: case ACK: insert_tail_mb(&tp->cminisock_api_config.cfg.ctl->msk_eventlist, (struct alloc_head *)msk);; break; default: printk("Unsupported tag for preallocation\n"); } } inline void queue_upcall_msk(enum cminisock_event_tag tag, struct cminisock *msk) { msk->tag = tag; switch(tag) { case SYN: case RST: case FIN: case ACK: msk->ctl = ALLOC_READY; if(userapi_pkt_spew) { int i; for(i=0; i < msk->num_packets; i++) { printk("upcall pkts[%d]: %u-%u\n", i, msk->packets[i].seq, msk->packets[i].seq + msk->packets[i].len); } } break; default: printk("queue_upcall_msk (%s): invalid tag\n", "msk"); } };
trickles-userapi_1.c:22002:inline void queue_upcall_pmsk_prealloc(struct sock *sk, enum cminisock_event_tag tag, struct pminisock *msk) { struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp); switch(tag) { case SYN: case RST: case FIN: case ACK: dlist_insert_tail_mb(&tp->cminisock_api_config.cfg.ctl->pmsk_eventlist, (struct list_link *)msk);; break; default: printk("Unsupported tag for preallocation\n"); } } inline void queue_upcall_pmsk(enum cminisock_event_tag tag, struct pminisock *msk) { msk->tag = tag; switch(tag) { case SYN: case RST: case FIN: case ACK: msk->ctl = ALLOC_READY; if(userapi_pkt_spew) { int i; for(i=0; i < msk->num_packets; i++) { printk("upcall pkts[%d]: %u-%u\n", i, msk->packets[i].seq, msk->packets[i].seq + msk->packets[i].len); } } break; default: printk("queue_upcall_msk (%s): invalid tag\n", "pmsk"); } };
trickles-userapi_1.c:22007:        __wake_up((sk->sleep),1, 1);
trickles-userapi_1.c:22008:        if (!sk->dead) {
trickles-userapi_1.c:22010:                sk->data_ready(sk, 0);
trickles-userapi_1.c:22012:        atomic_inc(&sk->tp_pinfo.af_tcp.cminisock_api_config.cfg.ctl->update_since_poll);
trickles-userapi_1.c:22026:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:22028:        net_statistics[0*2+1].TCPPrequeued += skb_queue_len(&tp->ucopy.prequeue);
trickles-userapi_1.c:22032:        while ((skb = __skb_dequeue(&tp->ucopy.prequeue)) != ((void *)0))
trickles-userapi_1.c:22033:                sk->backlog_rcv(sk, skb);
trickles-userapi_1.c:22034:        do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0);
trickles-userapi_1.c:22037:        tp->ucopy.memory = 0;
trickles-userapi_1.c:22041:# 341 "trickles-userapi.c"
trickles-userapi_1.c:22043:static inline int trickles_do_sendmsg_tiov (struct sock *sk, struct cminisock *msk, void *vec, int veclen) { if(!msk->isStatic) { printk("msk must be static\n"); do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } int rval = 0; struct sock dummysk; struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp), *dummy_tp = &(dummysk.tp_pinfo.af_tcp); struct sk_buff *skb; dummy_tp->trickles_opt = tp->trickles_opt; dummy_tp->t.hmacCTX = tp->t.hmacCTX; dummy_tp->t.nonceCTX = tp->t.nonceCTX; init_sock(msk, &dummysk); msk->serverSK = sk; { static int last; if(msk->seqnum != last+1) { } last = msk->seqnum; } if(msk->tag == SYN || msk->tag == ACK || msk->tag == FIN) { tiov_handler(sk,msk,vec,veclen); } else { struct tcp_skb_cb *tcb; skb = recycle(sk); if(skb == ((void *)0)) { skb = alloc_skb(((128 + 32) + (sizeof(WireTrickleResponse)) + (sysctl_trickles_mss)), (0x20 | 0x10 | 0x40 | 0x80 | 0x100)); } if(skb == ((void *)0)) { printk("could not allocate skb\n"); goto out; } tcb = ((struct tcp_skb_cb *)&((skb)->cb[0])); skb->csum = 0; skb->ip_summed = 1; skb_reserve(skb, (128 + 32) + (sizeof(WireTrickleResponse)) + (sysctl_trickles_mss)); switch(msk->tag) { case SYN: do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); break; case RST: kfree_skb(skb); goto out; default: kfree_skb(skb); if (!(0)) { printk("KERNEL: assertion (" "0" ") failed at " "trickles-userapi.c" "(%d)\n", 342); }; goto out; } int i; for(i=0; i < msk->num_packets; i++) { struct sk_buff *skb1 = skb_clone(skb, (0x20)); skb1->csum = 0; skb1->ip_summed = 1; msk_transmit_skb(msk, skb1, i); msk->tag = ACK; } kfree_skb(skb); } out:; struct pminisock *pmsk = msk->pmsk; if(sysctl_trickles_Continuation_enable && ((msk)->cacheRecycleIndex >= 0)) { pmsk_hold(pmsk); pminisock_cache_child(sk, msk, pmsk, pmsk->cacheRecycleIndex, 0); free_trickles_pmsk_finish(sk,pmsk); msk_free_fields(sk, msk); } else { free_trickles_pmsk_finish(sk,pmsk); } return rval; };
trickles-userapi_1.c:22045:static inline int trickles_do_sendmsg_fiov (struct sock *sk, struct cminisock *msk, void *vec, int veclen) { if(!msk->isStatic) { printk("msk must be static\n"); do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } int rval = 0; struct sock dummysk; struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp), *dummy_tp = &(dummysk.tp_pinfo.af_tcp); struct sk_buff *skb; dummy_tp->trickles_opt = tp->trickles_opt; dummy_tp->t.hmacCTX = tp->t.hmacCTX; dummy_tp->t.nonceCTX = tp->t.nonceCTX; init_sock(msk, &dummysk); msk->serverSK = sk; { static int last; if(msk->seqnum != last+1) { } last = msk->seqnum; } if(msk->tag == SYN || msk->tag == ACK || msk->tag == FIN) { fiov_handler(sk,msk,vec,veclen); } else { struct tcp_skb_cb *tcb; skb = recycle(sk); if(skb == ((void *)0)) { skb = alloc_skb(((128 + 32) + (sizeof(WireTrickleResponse)) + (sysctl_trickles_mss)), (0x20 | 0x10 | 0x40 | 0x80 | 0x100)); } if(skb == ((void *)0)) { printk("could not allocate skb\n"); goto out; } tcb = ((struct tcp_skb_cb *)&((skb)->cb[0])); skb->csum = 0; skb->ip_summed = 1; skb_reserve(skb, (128 + 32) + (sizeof(WireTrickleResponse)) + (sysctl_trickles_mss)); switch(msk->tag) { case SYN: do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); break; case RST: kfree_skb(skb); goto out; default: kfree_skb(skb); if (!(0)) { printk("KERNEL: assertion (" "0" ") failed at " "trickles-userapi.c" "(%d)\n", 344); }; goto out; } int i; for(i=0; i < msk->num_packets; i++) { struct sk_buff *skb1 = skb_clone(skb, (0x20)); skb1->csum = 0; skb1->ip_summed = 1; msk_transmit_skb(msk, skb1, i); msk->tag = ACK; } kfree_skb(skb); } out:; struct pminisock *pmsk = msk->pmsk; if(sysctl_trickles_Continuation_enable && ((msk)->cacheRecycleIndex >= 0)) { pmsk_hold(pmsk); pminisock_cache_child(sk, msk, pmsk, pmsk->cacheRecycleIndex, 0); free_trickles_pmsk_finish(sk,pmsk); msk_free_fields(sk, msk); } else { free_trickles_pmsk_finish(sk,pmsk); } return rval; };
trickles-userapi_1.c:22046:# 424 "trickles-userapi.c"
trickles-userapi_1.c:22053:# 439 "trickles-userapi.c"
trickles-userapi_1.c:22059:        struct cminisock_packet *pkts = msk->packets;
trickles-userapi_1.c:22069:        for(i=numUCChildPackets; i < msk->num_packets; i++) {
trickles-userapi_1.c:22075:        for(i=0; i < msk->num_packets; i++) {
trickles-userapi_1.c:22091:        for(i = numDataPackets; i < msk->num_packets; i++) {
trickles-userapi_1.c:22112:                skb->csum = 0;
trickles-userapi_1.c:22129:        if(msk->num_packets > (4)) {
trickles-userapi_1.c:22130:                skbs = kmalloc(sizeof(struct sk_buff *) * msk->num_packets, ( 0x10 | 0x40 | 0x80 | 0x100));
trickles-userapi_1.c:22132:                if (!(msk->num_packets >= 0)) { printk("KERNEL: assertion (" "msk->num_packets >= 0" ") failed at " "trickles-userapi.c" "(%d)\n", 517); };
trickles-userapi_1.c:22140:        pkts = msk->packets;
trickles-userapi_1.c:22145:        for(i=0; i < msk->num_packets; i++) {
trickles-userapi_1.c:22146:                maxLen += msk->packets[i].len;
trickles-userapi_1.c:22152:                if(msk->dbg_mark == (50)) {
trickles-userapi_1.c:22156:                        printk("%lud:mark(%d) Short by %d (%d - %d) count=(%d,%d)\n", jiffies, msk->dbg_mark, maxLen - totallen,
trickles-userapi_1.c:22158:                        printk("%p short by input_len = %d\n", msk, msk->input_len);
trickles-userapi_1.c:22169:        for(i=0; i < msk->num_packets; i++) {
trickles-userapi_1.c:22188:                skb->csum = 0;
trickles-userapi_1.c:22189:                skb->ip_summed = 1;
trickles-userapi_1.c:22191:                        int amt = ({ typeof(pkt_remain) Z = (typeof(pkt_remain))(tiov[tiov_pos].iov_len - tiov_offs); ({ const typeof(pkt_remain) _x = (pkt_remain); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y; }); });
trickles-userapi_1.c:22200:                                       src, amt, msk->state, msk->seq, msk->TCPBase, msk->seq - msk->TCPBase);
trickles-userapi_1.c:22206:                        totallen -= amt;
trickles-userapi_1.c:22207:                        pkt_remain -= amt;
trickles-userapi_1.c:22215:                if (!(pkt_remain == 0)) { printk("KERNEL: assertion (" "pkt_remain == 0" ") failed at " "trickles-userapi.c" "(%d)\n", 600); };
trickles-userapi_1.c:22218:                        printk("sending pkts[%d] %u-%u\n", i, pkts[i].seq, pkts[i].seq + pkts[i].len);
trickles-userapi_1.c:22223:                   tiov[tiovlen-1].iov_base == (void*)-1 && tiov[tiovlen-1].iov_len == 0) {
trickles-userapi_1.c:22225:                        msk->tag = FIN;
trickles-userapi_1.c:22242:                               totallen, msk->executionTrace);
trickles-userapi_1.c:22270:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->lock.users != 0) __lock_sock(sk); (sk)->lock.users = 1; do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:22271:        sk->shutdown = 3;
trickles-userapi_1.c:22274:        while((skb=__skb_dequeue(&sk->receive_queue))!=((void *)0)) {
trickles-userapi_1.c:22275:                u32 len = ((struct tcp_skb_cb *)&((skb)->cb[0]))->end_seq - ((struct tcp_skb_cb *)&((skb)->cb[0]))->seq - skb->h.th->fin;
trickles-userapi_1.c:22284:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:22287:        (void)(&((sk)->lock.slock));
trickles-userapi_1.c:22294:        do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0);
trickles-userapi_1.c:22296:# 707 "trickles-userapi.c"
trickles-userapi_1.c:22300:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:22302:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:22303:        (void)(&((sk)->lock.slock));
trickles-userapi_1.c:22304:        if(!(tp->trickles_opt & 0x1) &&
trickles-userapi_1.c:22307:                        tp->t.testseq = 1;
trickles-userapi_1.c:22308:                        sk->prot = &trickles_prot;
trickles-userapi_1.c:22311:                        sk->prot = &trickles_client_prot;
trickles-userapi_1.c:22319:# 743 "trickles-userapi.c"
trickles-userapi_1.c:22320:                        tp->t.slowstart_timer.function = &slow_start_timer;
trickles-userapi_1.c:22321:                        tp->t.slowstart_timer.data = (long)sk;
trickles-userapi_1.c:22324:        tp->trickles_opt = val;
trickles-userapi_1.c:22326:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->lock.users != 0) __lock_sock(sk); (sk)->lock.users = 1; do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:22327:        do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0);
trickles-userapi_1.c:22338:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:22341:        int tiovlen = msg->msg_iovlen;
trickles-userapi_1.c:22342:        int rval = -22;
trickles-userapi_1.c:22344:        struct tiovec *tiov = (struct tiovec *)msg->msg_iov;
trickles-userapi_1.c:22345:        struct cminisock_cmd *cmd = msg->msg_name;
trickles-userapi_1.c:22347:        if(sizeof(*cmd) != msg->msg_namelen || (int)cmd->magic != (0xbaadd33d)) {
trickles-userapi_1.c:22348:                return -22;
trickles-userapi_1.c:22351:        if(cmd->cmd == STARTRCV) {
trickles-userapi_1.c:22353:                return -22;
trickles-userapi_1.c:22355:        if(!((tp)->cminisock_api_config.cfg.mmap_base != ((void *)0))) {
trickles-userapi_1.c:22356:                return -22;
trickles-userapi_1.c:22358:        if(cmd->cmd == POLL) {
trickles-userapi_1.c:22360:                do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->lock.users != 0) __lock_sock(sk); (sk)->lock.users = 1; do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:22361:                if (skb_queue_len(&tp->ucopy.prequeue)) {
trickles-userapi_1.c:22365:                do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:22370:        msk = cmd->socket;
trickles-userapi_1.c:22373:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->lock.users != 0) __lock_sock(sk); (sk)->lock.users = 1; do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:22374:        if(!((tp)->cminisock_api_config.cfg.mmap_base != ((void *)0))) {
trickles-userapi_1.c:22376:                rval = -22;
trickles-userapi_1.c:22377:                do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:22381:        if(!({ struct tcp_opt *_tp = &((sk)->tp_pinfo.af_tcp); (((((char*)((msk)) - (char*)((_tp)->cminisock_api_config.cfg.ctl->minisock_base)) % sizeof(struct cminisock)) == 0) && (((void*)((struct cminisock *)((msk)))) >= ((void*)((_tp)->cminisock_api_config.cfg.ctl->minisock_base)) && ((void*)((struct cminisock *)((msk)) + 1)) <= ((_tp)->cminisock_api_config.cfg.ctl->minisock_limit))) && (((msk))->ctl == ALLOC_READY || ((msk))->ctl == ALLOC_HALFFREE); })) { printk("bad minisocket %d %d\n", !(((((char*)(msk) - (char*)((tp)->cminisock_api_config.cfg.ctl->minisock_base)) % sizeof(struct cminisock)) == 0) && (((void*)((struct cminisock *)(msk))) >= ((void*)((tp)->cminisock_api_config.cfg.ctl->minisock_base)) && ((void*)((struct cminisock *)(msk) + 1)) <= ((tp)->cminisock_api_config.cfg.ctl->minisock_limit))), !(((msk)->ctl == ALLOC_READY || (msk)->ctl == ALLOC_HALFFREE))); rval = -22; do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0); goto out; }
trickles-userapi_1.c:22389:        pmsk = msk->pmsk;
trickles-userapi_1.c:22393:        (msk)->pmsk = ((void *)0); msk_clear_fields((msk)); free_trickles_msk_finish((sk),(msk));;;
trickles-userapi_1.c:22395:        if(cmd->cmd == DROP) {
trickles-userapi_1.c:22398:                (msk)->pmsk = ((void *)0); msk_clear_fields((msk)); free_trickles_msk_finish((sk),(msk));;;
trickles-userapi_1.c:22403:        if(cmd->cmd != PROCESS) {
trickles-userapi_1.c:22408:                (msk)->pmsk = ((void *)0); msk_clear_fields((msk)); free_trickles_msk_finish((sk),(msk));;;
trickles-userapi_1.c:22418:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:22425:# 856 "trickles-userapi.c"
trickles-userapi_1.c:22432:                do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:22433:                interruptible_sleep_on_timeout(sk->sleep, timeout);
trickles-userapi_1.c:22434:                do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->lock.users != 0) __lock_sock(sk); (sk)->lock.users = 1; do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:22439:                        printk("timeout expired %d\n", jiffies - in_time);
trickles-userapi_1.c:22440:                        err = -11;
trickles-userapi_1.c:22451:    struct sock *sk = sock->sk;
trickles-userapi_1.c:22452:    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:22456:    if(((tp)->cminisock_api_config.cfg.mmap_base != ((void *)0))) {
trickles-userapi_1.c:22457:            int poll_value = ((&tp->cminisock_api_config.cfg.ctl->update_since_poll)->counter);
trickles-userapi_1.c:22458:            if((!(tp->trickles_opt & 0x80) && !dlist_empty(&tp->cminisock_api_config.cfg.ctl->pmsk_eventlist)) ||
trickles-userapi_1.c:22459:               ((tp->trickles_opt & 0x80) &&
trickles-userapi_1.c:22461:                !dlist_empty(&tp->cminisock_api_config.cfg.ctl->pmsk_eventlist))) {
trickles-userapi_1.c:22465:                    atomic_sub(poll_value, &tp->cminisock_api_config.cfg.ctl->update_since_poll);
trickles-userapi_1.c:22485:        struct trickles_kconfig *api_config = (struct trickles_kconfig*)area->vm_private_data;
trickles-userapi_1.c:22488:        void *base = api_config->cfg.ctl->ro_base;
trickles-userapi_1.c:22489:        offset = address - (unsigned long)area->vm_start;
trickles-userapi_1.c:22490:        if(offset >= api_config->cfg.ctl->ro_len) {
trickles-userapi_1.c:22494:        page = (mem_map + (((unsigned long)(virt_to_kseg((char *)base + offset))-((unsigned long)(0xC0000000))) >> 12));
trickles-userapi_1.c:22496:                atomic_inc(&(page)->count);
trickles-userapi_1.c:22507:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:22521:                while(tp->cminisock_api_config.pending_delivery) {
trickles-userapi_1.c:22524:                        do { (get_current())->state = (1); } while (0);
trickles-userapi_1.c:22526:                        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:22528:                        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->lock.users != 0) __lock_sock(sk); (sk)->lock.users = 1; do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:22531:                do { (get_current())->state = (0); } while (0);
trickles-userapi_1.c:22535:                        error = -22;
trickles-userapi_1.c:22541:                        error = -14;
trickles-userapi_1.c:22547:                        error = -22;
trickles-userapi_1.c:22554:                        error = -12;
trickles-userapi_1.c:22561:                if (!(sizeof(*ctl) + sizeof(struct tq_struct) < (1UL << 12))) { printk("KERNEL: assertion (" "sizeof(*ctl) + sizeof(struct work_struct) < PAGE_SIZE" ") failed at " "trickles-userapi.c" "(%d)\n", 991); };
trickles-userapi_1.c:22562:                ctl->ro_base = new_config.mmap_base;
trickles-userapi_1.c:22563:                ctl->ro_len = (((mmap_len / 4)+(1UL << 12)-1)&(~((1UL << 12)-1)));
trickles-userapi_1.c:22564:                ctl->ro_offs = (char*)ctl->ro_base - (char*)new_config.mmap_base;
trickles-userapi_1.c:22565:                ctl->rw_base = (__u8*)ctl->ro_base + ctl->ro_len;
trickles-userapi_1.c:22566:                ctl->rw_len = (((mmap_len - ((char*)ctl->rw_base - (char*)new_config.mmap_base))+(1UL << 12)-1)&(~((1UL << 12)-1))) - (1UL << 12);
trickles-userapi_1.c:22567:                ctl->rw_offs = (char*)ctl->rw_base - (char*)new_config.mmap_base;
trickles-userapi_1.c:22568:                (((&ctl->update_since_poll)->counter) = (0));
trickles-userapi_1.c:22569:                do { do { (&((struct tq_struct *)(ctl+1))->list)->next = (&((struct tq_struct *)(ctl+1))->list); (&((struct tq_struct *)(ctl+1))->list)->prev = (&((struct tq_struct *)(ctl+1))->list); } while (0); ((struct tq_struct *)(ctl+1))->sync = 0; do { (((struct tq_struct *)(ctl+1)))->routine = (vfree_helper); (((struct tq_struct *)(ctl+1)))->data = (new_config.mmap_base); } while (0); } while (0);
trickles-userapi_1.c:22570:                if (!(ctl->rw_len > 0)) { printk("KERNEL: assertion (" "ctl->rw_len > 0" ") failed at " "trickles-userapi.c" "(%d)\n", 1000); };
trickles-userapi_1.c:22571:                if (!(ctl->ro_len > 0)) { printk("KERNEL: assertion (" "ctl->ro_len > 0" ") failed at " "trickles-userapi.c" "(%d)\n", 1001); };
trickles-userapi_1.c:22572:                if (!((char*)ctl->ro_base < (char*)new_config.mmap_base + mmap_len)) { printk("KERNEL: assertion (" "(char*)ctl->ro_base < (char*)new_config.mmap_base + mmap_len" ") failed at " "trickles-userapi.c" "(%d)\n", 1002); };
trickles-userapi_1.c:22574:                init_head(&ctl->msk_eventlist);
trickles-userapi_1.c:22576:                tp->cminisock_api_config.cfg = new_config;
trickles-userapi_1.c:22580:                head = &tp->cminisock_api_config.msk_freelist;
trickles-userapi_1.c:22583:                msk = (struct cminisock *)((char*)ctl->ro_base + (1UL << 12));
trickles-userapi_1.c:22584:                ctl->minisock_base = msk;
trickles-userapi_1.c:22585:                ctl->minisock_offs = (char*)ctl->minisock_base - (char*)new_config.mmap_base;
trickles-userapi_1.c:22587:                minisock_len = ((ctl->ro_len) / 4);
trickles-userapi_1.c:22588:                ctl->minisock_limit = (char*)ctl->minisock_base + minisock_len;
trickles-userapi_1.c:22589:                if (!(minisock_len > 0)) { printk("KERNEL: assertion (" "minisock_len > 0" ") failed at " "trickles-userapi.c" "(%d)\n", 1019); };
trickles-userapi_1.c:22590:                while((char*)(msk + 1) <= (char*)ctl->minisock_limit) {
trickles-userapi_1.c:22592:                        msk->ctl = ALLOC_FREE;
trickles-userapi_1.c:22593:                        msk->prev = msk->next = ((void *)0);
trickles-userapi_1.c:22594:                        msk->list = ((void *)0);
trickles-userapi_1.c:22601:                int pminisock_len = ((ctl->ro_len) / 4);
trickles-userapi_1.c:22602:                ctl->pminisock_base = ((typeof(ctl->minisock_limit))(char*)(ctl->minisock_limit) + (1 - ((int)ctl->minisock_limit) % 1) % 1);
trickles-userapi_1.c:22603:                struct pminisock *pmsk = ctl->pminisock_base;
trickles-userapi_1.c:22604:                struct dlist *phead = &tp->cminisock_api_config.pmsk_freelist;
trickles-userapi_1.c:22606:                dlist_init(&ctl->pmsk_eventlist);
trickles-userapi_1.c:22609:                ctl->pminisock_limit = (char*)ctl->pminisock_base + pminisock_len;
trickles-userapi_1.c:22610:                while((char*)(pmsk+1) <= (char*)ctl->pminisock_limit) {
trickles-userapi_1.c:22612:                        pmsk->prev = pmsk->next = ((void *)0);
trickles-userapi_1.c:22613:                        pmsk->ctl = ALLOC_FREE;
trickles-userapi_1.c:22621:                ctl->heap_base = ((typeof(ctl->pminisock_limit))(char*)(ctl->pminisock_limit) + (1 - ((int)ctl->pminisock_limit) % 1) % 1);
trickles-userapi_1.c:22622:                tp->t.heapbytesize = ctl->ro_len - pminisock_len;
trickles-userapi_1.c:22627:                        error = -22;
trickles-userapi_1.c:22642:                        tp->t.hmacCTX = kmalloc(sizeof(*tp->t.hmacCTX), (0x20 | 0x10 | 0x40 | 0x80 | 0x100));
trickles-userapi_1.c:22643:                        if(tp->t.hmacCTX == ((void *)0)) {
trickles-userapi_1.c:22645:                                error = -12;
trickles-userapi_1.c:22648:                        hmac_setup(tp->t.hmacCTX, hmac_key, (16));
trickles-userapi_1.c:22661:                        tp->t.nonceCTX = kmalloc(sizeof(*tp->t.nonceCTX), (0x20 | 0x10 | 0x40 | 0x80 | 0x100));
trickles-userapi_1.c:22662:                        if(tp->t.nonceCTX == ((void *)0)) {
trickles-userapi_1.c:22664:                                error = -12;
trickles-userapi_1.c:22667:                        aes_encrypt_key(nonce_key, (16), tp->t.nonceCTX);
trickles-userapi_1.c:22675:                        return -14;
trickles-userapi_1.c:22677:                error = (__builtin_constant_p(sizeof(tp->cminisock_api_config.cfg)) ? __constant_copy_to_user((optdata),(&tp->cminisock_api_config.cfg),(sizeof(tp->cminisock_api_config.cfg))) : __generic_copy_to_user((optdata),(&tp->cminisock_api_config.cfg),(sizeof(tp->cminisock_api_config.cfg))));
trickles-userapi_1.c:22680:                        return -22;
trickles-userapi_1.c:22682:                if(({ long __pu_err = -14; __typeof__(*(((int*)optlen))) *__pu_addr = (((int*)optlen)); if ((({ unsigned long flag,sum; asm("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0" :"=&r" (flag), "=r" (sum) :"1" (__pu_addr),"g" ((int)(sizeof(*((int*)optlen)))),"g" (get_current()->addr_limit.seg)); flag; }) == 0)) do { __pu_err = 0; switch ((sizeof(*((int*)optlen)))) { case 1: __asm__ __volatile__( "1:	mov""b"" %""b""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "iq" (((__typeof__(*((int*)optlen)))(len))), "m"((*(struct __large_struct *)(__pu_addr))), "i"(-14), "0"(__pu_err)); break; case 2: __asm__ __volatile__( "1:	mov""w"" %""w""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*((int*)optlen)))(len))), "m"((*(struct __large_struct *)(__pu_addr))), "i"(-14), "0"(__pu_err)); break; case 4: __asm__ __volatile__( "1:	mov""l"" %""""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*((int*)optlen)))(len))), "m"((*(struct __large_struct *)(__pu_addr))), "i"(-14), "0"(__pu_err)); break; case 8: __asm__ __volatile__( "1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous" : "=r"(__pu_err) : "A" (((__typeof__(*((int*)optlen)))(len))), "r" (__pu_addr), "i"(-14), "0"(__pu_err)); break; default: __put_user_bad(); } } while (0); __pu_err; })) {
trickles-userapi_1.c:22684:                        return -14;
trickles-userapi_1.c:22701:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:22704:                return -22;
trickles-userapi_1.c:22709:                rval = tp->snd_wnd;
trickles-userapi_1.c:22713:                rval = tp->snd_ssthresh;
trickles-userapi_1.c:22724:                return -92;
trickles-userapi_1.c:22727:                return -14;
trickles-userapi_1.c:22730:                return -14;
trickles-userapi_1.c:22732:        if(({ long __pu_err = -14; __typeof__(*((optlen))) *__pu_addr = ((optlen)); if ((({ unsigned long flag,sum; asm("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0" :"=&r" (flag), "=r" (sum) :"1" (__pu_addr),"g" ((int)(sizeof(*(optlen)))),"g" (get_current()->addr_limit.seg)); flag; }) == 0)) do { __pu_err = 0; switch ((sizeof(*(optlen)))) { case 1: __asm__ __volatile__( "1:	mov""b"" %""b""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "iq" (((__typeof__(*(optlen)))(outputLen))), "m"((*(struct __large_struct *)(__pu_addr))), "i"(-14), "0"(__pu_err)); break; case 2: __asm__ __volatile__( "1:	mov""w"" %""w""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(optlen)))(outputLen))), "m"((*(struct __large_struct *)(__pu_addr))), "i"(-14), "0"(__pu_err)); break; case 4: __asm__ __volatile__( "1:	mov""l"" %""""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(optlen)))(outputLen))), "m"((*(struct __large_struct *)(__pu_addr))), "i"(-14), "0"(__pu_err)); break; case 8: __asm__ __volatile__( "1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous" : "=r"(__pu_err) : "A" (((__typeof__(*(optlen)))(outputLen))), "r" (__pu_addr), "i"(-14), "0"(__pu_err)); break; default: __put_user_bad(); } } while (0); __pu_err; })) {
trickles-userapi_1.c:22733:                return -14;
trickles-userapi_1.c:22735:        if(({ long __pu_err = -14; __typeof__(*((optval))) *__pu_addr = ((optval)); if ((({ unsigned long flag,sum; asm("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0" :"=&r" (flag), "=r" (sum) :"1" (__pu_addr),"g" ((int)(sizeof(*(optval)))),"g" (get_current()->addr_limit.seg)); flag; }) == 0)) do { __pu_err = 0; switch ((sizeof(*(optval)))) { case 1: __asm__ __volatile__( "1:	mov""b"" %""b""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "iq" (((__typeof__(*(optval)))(rval))), "m"((*(struct __large_struct *)(__pu_addr))), "i"(-14), "0"(__pu_err)); break; case 2: __asm__ __volatile__( "1:	mov""w"" %""w""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(optval)))(rval))), "m"((*(struct __large_struct *)(__pu_addr))), "i"(-14), "0"(__pu_err)); break; case 4: __asm__ __volatile__( "1:	mov""l"" %""""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(optval)))(rval))), "m"((*(struct __large_struct *)(__pu_addr))), "i"(-14), "0"(__pu_err)); break; case 8: __asm__ __volatile__( "1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous" : "=r"(__pu_err) : "A" (((__typeof__(*(optval)))(rval))), "r" (__pu_addr), "i"(-14), "0"(__pu_err)); break; default: __put_user_bad(); } } while (0); __pu_err; })) {
trickles-userapi_1.c:22736:                return -14;
trickles-userapi_1.c:22743:        fput(sock->file);
trickles-userapi_1.c:22762:        err = -22;
trickles-userapi_1.c:22766:        err = -12;
trickles-userapi_1.c:22773:                err = -14;
trickles-userapi_1.c:22785:        sk = sock->sk;
trickles-userapi_1.c:22786:        tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:22788:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->lock.users != 0) __lock_sock(sk); (sk)->lock.users = 1; do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:22789:        if(!((tp)->cminisock_api_config.cfg.mmap_base != ((void *)0))) {
trickles-userapi_1.c:22791:                err = -22;
trickles-userapi_1.c:22792:                do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:22795:        if(!({ struct tcp_opt *_tp = &((sk)->tp_pinfo.af_tcp); (((((char*)((msk)) - (char*)((_tp)->cminisock_api_config.cfg.ctl->minisock_base)) % sizeof(struct cminisock)) == 0) && (((void*)((struct cminisock *)((msk)))) >= ((void*)((_tp)->cminisock_api_config.cfg.ctl->minisock_base)) && ((void*)((struct cminisock *)((msk)) + 1)) <= ((_tp)->cminisock_api_config.cfg.ctl->minisock_limit))) && (((msk))->ctl == ALLOC_READY || ((msk))->ctl == ALLOC_HALFFREE); })) { printk("bad minisocket %d %d\n", !(((((char*)(msk) - (char*)((tp)->cminisock_api_config.cfg.ctl->minisock_base)) % sizeof(struct cminisock)) == 0) && (((void*)((struct cminisock *)(msk))) >= ((void*)((tp)->cminisock_api_config.cfg.ctl->minisock_base)) && ((void*)((struct cminisock *)(msk) + 1)) <= ((tp)->cminisock_api_config.cfg.ctl->minisock_limit))), !(((msk)->ctl == ALLOC_READY || (msk)->ctl == ALLOC_HALFFREE))); err = -22; do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0); goto out_put; }
trickles-userapi_1.c:22796:# 1234 "trickles-userapi.c"
trickles-userapi_1.c:22797:        pmsk = msk->pmsk;
trickles-userapi_1.c:22801:        (msk)->pmsk = ((void *)0); msk_clear_fields((msk)); free_trickles_msk_finish((sk),(msk));;;
trickles-userapi_1.c:22808:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:22822:        unsigned long count = desc->count;
trickles-userapi_1.c:22823:        struct sk_buff *skb = (struct sk_buff *) desc->buf;
trickles-userapi_1.c:22824:        int i = ((struct skb_shared_info *)((skb)->end))->nr_frags;
trickles-userapi_1.c:22831:                written = -22;
trickles-userapi_1.c:22833:                atomic_inc(&(page)->count);
trickles-userapi_1.c:22836:                skb->len += size;
trickles-userapi_1.c:22837:                skb->data_len += size;
trickles-userapi_1.c:22840:                desc->error = written;
trickles-userapi_1.c:22843:        desc->count = count - written;
trickles-userapi_1.c:22844:        desc->written += written;
trickles-userapi_1.c:22858:        retval = -9;
trickles-userapi_1.c:22862:        if (!(in_file->f_mode & 1))
trickles-userapi_1.c:22864:        retval = -22;
trickles-userapi_1.c:22865:        in_inode = in_file->f_dentry->d_inode;
trickles-userapi_1.c:22868:        if (!in_inode->i_mapping->a_ops->readpage)
trickles-userapi_1.c:22870:        retval = locks_verify_area(1, in_inode, in_file, in_file->f_pos, count);
trickles-userapi_1.c:22904:                kmalloc(sizeof(struct sk_buff *) * msk->num_packets, ( 0x10 | 0x40 | 0x80 | 0x100)),
trickles-userapi_1.c:22910:        pkts = msk->packets;
trickles-userapi_1.c:22915:        for(i=0; i < msk->num_packets; i++) {
trickles-userapi_1.c:22935:                skb->csum = 0;
trickles-userapi_1.c:22936:                skb->ip_summed = 1;
trickles-userapi_1.c:22938:                        int amt = ({ typeof(pkt_remain) Z = (typeof(pkt_remain))(fiov[fiov_pos].len - fiov_offs); ({ const typeof(pkt_remain) _x = (pkt_remain); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y; }); });
trickles-userapi_1.c:22942:                        if(fiov[fiov_pos].fd == -2) {
trickles-userapi_1.c:22955:                                        printk("error while csum/copy, base = %p amt = %d pkt_type = %d\n", src, amt, msk->packets[i].type);
trickles-userapi_1.c:22957:                                        rval = -22;
trickles-userapi_1.c:22982:                        totallen -= amt;
trickles-userapi_1.c:22983:                        pkt_remain -= amt;
trickles-userapi_1.c:22991:                if (!(pkt_remain == 0)) { printk("KERNEL: assertion (" "pkt_remain == 0" ") failed at " "trickles-userapi.c" "(%d)\n", 1428); };
trickles-userapi_1.c:22994:                        printk("sending pkts[%d] %u-%u\n", i, pkts[i].seq, pkts[i].seq + pkts[i].len);
trickles-userapi_1.c:22998:                   fiov[fiovlen-1].offset == 0 && fiov[fiovlen-1].len == 0) {
trickles-userapi_1.c:22999:                        msk->tag = FIN;
trickles-userapi_1.c:23025:        err = -22;
trickles-userapi_1.c:23031:                err = -12;
trickles-userapi_1.c:23038:                        err = -14;
trickles-userapi_1.c:23051:        sk = sock->sk;
trickles-userapi_1.c:23052:        tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:23054:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->lock.users != 0) __lock_sock(sk); (sk)->lock.users = 1; do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23055:        if(!((tp)->cminisock_api_config.cfg.mmap_base != ((void *)0))) {
trickles-userapi_1.c:23057:                do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23058:                err = -22;
trickles-userapi_1.c:23061:        if(!({ struct tcp_opt *_tp = &((sk)->tp_pinfo.af_tcp); (((((char*)((msk)) - (char*)((_tp)->cminisock_api_config.cfg.ctl->minisock_base)) % sizeof(struct cminisock)) == 0) && (((void*)((struct cminisock *)((msk)))) >= ((void*)((_tp)->cminisock_api_config.cfg.ctl->minisock_base)) && ((void*)((struct cminisock *)((msk)) + 1)) <= ((_tp)->cminisock_api_config.cfg.ctl->minisock_limit))) && (((msk))->ctl == ALLOC_READY || ((msk))->ctl == ALLOC_HALFFREE); })) { printk("bad minisocket %d %d\n", !(((((char*)(msk) - (char*)((tp)->cminisock_api_config.cfg.ctl->minisock_base)) % sizeof(struct cminisock)) == 0) && (((void*)((struct cminisock *)(msk))) >= ((void*)((tp)->cminisock_api_config.cfg.ctl->minisock_base)) && ((void*)((struct cminisock *)(msk) + 1)) <= ((tp)->cminisock_api_config.cfg.ctl->minisock_limit))), !(((msk)->ctl == ALLOC_READY || (msk)->ctl == ALLOC_HALFFREE))); err = -22; do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0); goto out_put; }
trickles-userapi_1.c:23062:# 1507 "trickles-userapi.c"
trickles-userapi_1.c:23063:        pmsk = msk->pmsk;
trickles-userapi_1.c:23067:        (msk)->pmsk = ((void *)0); msk_clear_fields((msk)); free_trickles_msk_finish((sk),(msk));;;
trickles-userapi_1.c:23074:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23102:        sk = sock->sk;
trickles-userapi_1.c:23103:        tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:23105:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->lock.users != 0) __lock_sock(sk); (sk)->lock.users = 1; do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23106:        if(!((tp)->cminisock_api_config.cfg.mmap_base != ((void *)0))) {
trickles-userapi_1.c:23108:                do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23109:                err = -22;
trickles-userapi_1.c:23112:        if(!({ struct tcp_opt *_tp = &((sk)->tp_pinfo.af_tcp); (((((char*)((msk)) - (char*)((_tp)->cminisock_api_config.cfg.ctl->minisock_base)) % sizeof(struct cminisock)) == 0) && (((void*)((struct cminisock *)((msk)))) >= ((void*)((_tp)->cminisock_api_config.cfg.ctl->minisock_base)) && ((void*)((struct cminisock *)((msk)) + 1)) <= ((_tp)->cminisock_api_config.cfg.ctl->minisock_limit))) && (((msk))->ctl == ALLOC_READY || ((msk))->ctl == ALLOC_HALFFREE); })) { printk("bad minisocket %d\n", !(((((char*)(msk) - (char*)((tp)->cminisock_api_config.cfg.ctl->minisock_base)) % sizeof(struct cminisock)) == 0) && (((void*)((struct cminisock *)(msk))) >= ((void*)((tp)->cminisock_api_config.cfg.ctl->minisock_base)) && ((void*)((struct cminisock *)(msk) + 1)) <= ((tp)->cminisock_api_config.cfg.ctl->minisock_limit)))); err = -22; do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0); goto out_put; }
trickles-userapi_1.c:23113:# 1565 "trickles-userapi.c"
trickles-userapi_1.c:23114:        pmsk = msk->pmsk;
trickles-userapi_1.c:23119:        if(iov.iov_len == -1) {
trickles-userapi_1.c:23121:                (msk)->pmsk = ((void *)0); msk_clear_fields((msk)); free_trickles_msk_finish((sk),(msk));;;
trickles-userapi_1.c:23123:        } else if(iov.iov_len == -2) {
trickles-userapi_1.c:23124:                if(pmsk->ctl != ALLOC_HALFFREE) {
trickles-userapi_1.c:23125:                        pmsk->ctl = ALLOC_HALFFREE;
trickles-userapi_1.c:23131:                        err = -22;
trickles-userapi_1.c:23133:                if(msk->ctl != ALLOC_HALFFREE) { msk->ctl = ALLOC_HALFFREE; err = 0; } else { printk("already half freed\n"); err = -22; }
trickles-userapi_1.c:23134:# 1595 "trickles-userapi.c"
trickles-userapi_1.c:23135:        } else if(iov.iov_len == -3) {
trickles-userapi_1.c:23136:                pmsk->tag = FIN;
trickles-userapi_1.c:23137:                msk->tag = FIN;
trickles-userapi_1.c:23142:                (msk)->pmsk = ((void *)0); msk_clear_fields((msk)); free_trickles_msk_finish((sk),(msk));;;
trickles-userapi_1.c:23150:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23158:        struct sock *sk = sock->sk;
trickles-userapi_1.c:23159:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:23161:        if(!((tp)->cminisock_api_config.cfg.mmap_base != ((void *)0))) {
trickles-userapi_1.c:23163:                return -22;
trickles-userapi_1.c:23166:        vma->vm_ops = &trickles_vm_ops;
trickles-userapi_1.c:23167:        vma->vm_private_data = &tp->cminisock_api_config;
trickles-userapi_1.c:23187:        sk = sock->sk;
trickles-userapi_1.c:23188:        tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:23190:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->lock.users != 0) __lock_sock(sk); (sk)->lock.users = 1; do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23191:        if(!((tp)->cminisock_api_config.cfg.mmap_base != ((void *)0))) {
trickles-userapi_1.c:23193:                do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23194:                err = -22;
trickles-userapi_1.c:23197:        if(!({ struct tcp_opt *_tp = &((sk)->tp_pinfo.af_tcp); (((((char*)((msk_compat)) - (char*)((_tp)->cminisock_api_config.cfg.ctl->minisock_base)) % sizeof(struct cminisock)) == 0) && (((void*)((struct cminisock *)((msk_compat)))) >= ((void*)((_tp)->cminisock_api_config.cfg.ctl->minisock_base)) && ((void*)((struct cminisock *)((msk_compat)) + 1)) <= ((_tp)->cminisock_api_config.cfg.ctl->minisock_limit))) && (((msk_compat))->ctl == ALLOC_READY || ((msk_compat))->ctl == ALLOC_HALFFREE); })) { printk("bad minisocket %d %d\n", !(((((char*)(msk_compat) - (char*)((tp)->cminisock_api_config.cfg.ctl->minisock_base)) % sizeof(struct cminisock)) == 0) && (((void*)((struct cminisock *)(msk_compat))) >= ((void*)((tp)->cminisock_api_config.cfg.ctl->minisock_base)) && ((void*)((struct cminisock *)(msk_compat) + 1)) <= ((tp)->cminisock_api_config.cfg.ctl->minisock_limit))), !(((msk_compat)->ctl == ALLOC_READY || (msk_compat)->ctl == ALLOC_HALFFREE))); err = -22; do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0); goto out_put; }
trickles-userapi_1.c:23198:# 1666 "trickles-userapi.c"
trickles-userapi_1.c:23199:        pmsk = msk_compat->pmsk;
trickles-userapi_1.c:23201:               pmsk->num_packets, msk_compat->num_packets);
trickles-userapi_1.c:23203:        if(pkt_num < 0 || pkt_num >= pmsk->num_packets) {
trickles-userapi_1.c:23205:                err = -22;
trickles-userapi_1.c:23206:                do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23213:                        err = -12;
trickles-userapi_1.c:23214:                        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23219:                        err = -14;
trickles-userapi_1.c:23220:                        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23226:        if (!(pkt_num < pmsk->num_packets)) { printk("KERNEL: assertion (" "pkt_num < pmsk->num_packets" ") failed at " "trickles-userapi.c" "(%d)\n", 1693); };
trickles-userapi_1.c:23227:        setPacketUCont(&pmsk->packets[pkt_num], buf, ucont_len);
trickles-userapi_1.c:23229:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23236:# 1713 "trickles-userapi.c"
trickles-userapi_1.c:23238:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_1.c:23239:        return tp->t.write_seq - tp->t.snd_una < sk->sndbuf;
trickles-userapi_1.c:23257:        add_wait_queue(sk->sleep, &wait);
trickles-userapi_1.c:23259:                set_bit(0, &sk->socket->flags);
trickles-userapi_1.c:23261:                do { get_current()->state = (1); __asm__ __volatile__("": : :"memory"); } while (0);
trickles-userapi_1.c:23263:                if (sk->err || (sk->shutdown & 2))
trickles-userapi_1.c:23269:                clear_bit(0, &sk->socket->flags);
trickles-userapi_1.c:23273:                set_bit(2, &sk->socket->flags);
trickles-userapi_1.c:23274:                do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23277:                do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->lock.users != 0) __lock_sock(sk); (sk)->lock.users = 1; do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23280:                        vm_wait -= current_timeo;
trickles-userapi_1.c:23283:                            (current_timeo -= vm_wait) < 0)
trickles-userapi_1.c:23290:        get_current()->state = 0;
trickles-userapi_1.c:23291:        remove_wait_queue(sk->sleep, &wait);
trickles-userapi_1.c:23295:        err = -32;
trickles-userapi_1.c:23298:        err = -11;
trickles-userapi_1.c:23318:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_1.c:23319:        iov = msg->msg_iov;
trickles-userapi_1.c:23320:        iovlen = msg->msg_iovlen;
trickles-userapi_1.c:23326:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->lock.users != 0) __lock_sock(sk); (sk)->lock.users = 1; do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23338:                                        tp->t.write_seq += skb->len;
trickles-userapi_1.c:23339:                                        ((struct tcp_skb_cb *)&((skb)->cb[0]))->end_seq = tp->t.write_seq;
trickles-userapi_1.c:23340:                                        __skb_queue_tail(&tp->t.requestBytes, skb);
trickles-userapi_1.c:23342:                                if(!((sk)->tp_pinfo.af_tcp.t.write_seq < (sk)->tp_pinfo.af_tcp.t.snd_una + (sk)->sndbuf)) {
trickles-userapi_1.c:23348:                                if (!(tp->t.write_seq - tp->t.snd_una <= sk->sndbuf)) { printk("KERNEL: assertion (" "tp->t.write_seq - tp->t.snd_una <= sk->sndbuf" ") failed at " "trickles-userapi.c" "(%d)\n", 1824); };
trickles-userapi_1.c:23349:                                skb_spaceleft = ({ typeof(sk->sndbuf - (tp->t.write_seq - tp->t.snd_una)) Z = (typeof(sk->sndbuf - (tp->t.write_seq - tp->t.snd_una)))(totalLen - position); ({ const typeof(sk->sndbuf - (tp->t.write_seq - tp->t.snd_una)) _x = (sk->sndbuf - (tp->t.write_seq - tp->t.snd_una)); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y; }); });
trickles-userapi_1.c:23356:                                ((struct tcp_skb_cb *)&((skb)->cb[0]))->seq = tp->t.write_seq;
trickles-userapi_1.c:23358:                        copyLen = ({ typeof(iov[i].iov_len - iov_position) Z = (typeof(iov[i].iov_len - iov_position))(skb_spaceleft); ({ const typeof(iov[i].iov_len - iov_position) _x = (iov[i].iov_len - iov_position); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y; }); });
trickles-userapi_1.c:23362:                                result = -14;
trickles-userapi_1.c:23365:                        skb_spaceleft -= copyLen;
trickles-userapi_1.c:23370:        if (!(skb_spaceleft == 0)) { printk("KERNEL: assertion (" "skb_spaceleft == 0" ") failed at " "trickles-userapi.c" "(%d)\n", 1846); };
trickles-userapi_1.c:23373:                tp->t.write_seq += skb->len;
trickles-userapi_1.c:23374:                ((struct tcp_skb_cb *)&((skb)->cb[0]))->end_seq = tp->t.write_seq;
trickles-userapi_1.c:23375:                __skb_queue_tail(&tp->t.requestBytes, skb);
trickles-userapi_1.c:23378:        if(tp->t.write_seq - tp->t.snd_una > 0) {
trickles-userapi_1.c:23379:                switch(tp->t.conversionState) {
trickles-userapi_1.c:23382:                        tp->t.conversionState = (1);
trickles-userapi_1.c:23388:                        tp->t.conversionState = (1);
trickles-userapi_1.c:23404:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23410:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23417:        struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:23418:        int sendBufLen = tp->t.write_seq - tp->t.snd_una;
trickles-userapi_1.c:23422:                        ({ typeof(sendBufLen) Z = (typeof(sendBufLen))((sysctl_trickles_mss) - (128 + 32)); ({ const typeof(sendBufLen) _x = (sendBufLen); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y; }); });
trickles-userapi_1.c:23423:                struct sk_buff *input_skb = tp->t.requestBytes.next;
trickles-userapi_1.c:23426:                        if (!((void*)input_skb != (void*)&tp->t.requestBytes)) { printk("KERNEL: assertion (" "(void*)input_skb != (void*)&tp->t.requestBytes" ") failed at " "trickles-userapi.c" "(%d)\n", 1902); };
trickles-userapi_1.c:23427:                        unsigned pieceLen = ({ typeof(input_skb->len) Z = (typeof(input_skb->len))(copyLen); ({ const typeof(input_skb->len) _x = (input_skb->len); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y; }); });
trickles-userapi_1.c:23429:                                *src = input_skb->data;
trickles-userapi_1.c:23437:                        copyLen -= pieceLen;
trickles-userapi_1.c:23438:                        input_skb = input_skb->next;
trickles-userapi_1.c:23440:                skb->csum = csum;
trickles-userapi_1.c:23451:        add_wait_queue(sk->sleep, &wait);
trickles-userapi_1.c:23453:        do { get_current()->state = (1); } while (0);
trickles-userapi_1.c:23455:        set_bit(1, &sk->socket->flags);
trickles-userapi_1.c:23456:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23458:        if (skb_queue_empty(&sk->receive_queue))
trickles-userapi_1.c:23461:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->lock.users != 0) __lock_sock(sk); (sk)->lock.users = 1; do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23462:        clear_bit(1, &sk->socket->flags);
trickles-userapi_1.c:23464:        remove_wait_queue(sk->sleep, &wait);
trickles-userapi_1.c:23465:        do { get_current()->state = (0); } while (0);
trickles-userapi_1.c:23472:        struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_1.c:23477:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->lock.users != 0) __lock_sock(sk); (sk)->lock.users = 1; do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23478:        if(!(tp->trickles_opt & 0x10)) {
trickles-userapi_1.c:23485:                tp->trickles_opt |= 0x10;
trickles-userapi_1.c:23488:        if(!(tp->trickles_opt & 0x40)) {
trickles-userapi_1.c:23490:                do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23498:        result = -107;
trickles-userapi_1.c:23501:                result = -22;
trickles-userapi_1.c:23509:                if(tp->rcv_nxt - tp->copied_seq >= target) {
trickles-userapi_1.c:23510:                        result = ({ typeof(len) Z = (typeof(len))(tp->rcv_nxt - tp->copied_seq); ({ const typeof(len) _x = (len); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y; }); });
trickles-userapi_1.c:23511:                        tp->copied_seq += result;
trickles-userapi_1.c:23516:                        result = ({ typeof(target) Z = (typeof(target))(tp->rcv_nxt - tp->copied_seq); ({ const typeof(target) _x = (target); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y; }); });
trickles-userapi_1.c:23517:                        tp->copied_seq += result;
trickles-userapi_1.c:23525:                if(tp->rcv_nxt - tp->copied_seq == 0) {
trickles-userapi_1.c:23527:                        if (sk->done)
trickles-userapi_1.c:23530:                        if (sk->err) {
trickles-userapi_1.c:23535:                        if (sk->shutdown & 1)
trickles-userapi_1.c:23538:                        if (sk->state == TCP_CLOSE) {
trickles-userapi_1.c:23539:                                if (!sk->done) {
trickles-userapi_1.c:23543:                                        result = -107;
trickles-userapi_1.c:23550:                                result = -11;
trickles-userapi_1.c:23557:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23562:        printk("tiov_base = %p\ntiov_len = %d", tiov->iov_base, tiov->iov_len);
trickles-userapi_1.c:23566:        printk("msk = %p, num =  %d\n", mskd->msk, mskd->tiov_num);
trickles-userapi_1.c:23567:        dump_tiov(mskd->tiov);
trickles-userapi_1.c:23583:                err = -22;
trickles-userapi_1.c:23591:        sk = sock->sk;
trickles-userapi_1.c:23592:        tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:23602:                err = -14;
trickles-userapi_1.c:23608:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->lock.users != 0) __lock_sock(sk); (sk)->lock.users = 1; do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23611:                struct cminisock *msk = curr_desc->msk;
trickles-userapi_1.c:23614:                if(!({ struct tcp_opt *_tp = &((sk)->tp_pinfo.af_tcp); (((((char*)((msk)) - (char*)((_tp)->cminisock_api_config.cfg.ctl->minisock_base)) % sizeof(struct cminisock)) == 0) && (((void*)((struct cminisock *)((msk)))) >= ((void*)((_tp)->cminisock_api_config.cfg.ctl->minisock_base)) && ((void*)((struct cminisock *)((msk)) + 1)) <= ((_tp)->cminisock_api_config.cfg.ctl->minisock_limit))) && (((msk))->ctl == ALLOC_READY || ((msk))->ctl == ALLOC_HALFFREE); })) {
trickles-userapi_1.c:23616:                               !(((((char*)(msk) - (char*)((tp)->cminisock_api_config.cfg.ctl->minisock_base)) % sizeof(struct cminisock)) == 0) && (((void*)((struct cminisock *)(msk))) >= ((void*)((tp)->cminisock_api_config.cfg.ctl->minisock_base)) && ((void*)((struct cminisock *)(msk) + 1)) <= ((tp)->cminisock_api_config.cfg.ctl->minisock_limit))), !(((msk)->ctl == ALLOC_READY || (msk)->ctl == ALLOC_HALFFREE)),
trickles-userapi_1.c:23618:                        err = -22;
trickles-userapi_1.c:23621:                pmsk = msk->pmsk;
trickles-userapi_1.c:23623:                (msk)->pmsk = ((void *)0); msk_clear_fields((msk)); free_trickles_msk_finish((sk),(msk));;;
trickles-userapi_1.c:23625:                msk->dbg_mark = curr_desc->dbg_mark;
trickles-userapi_1.c:23631:                trickles_do_sendmsg_tiov(sk, api_msk, curr_desc->tiov, curr_desc->tiov_num);
trickles-userapi_1.c:23632:                curr_desc = ({ (struct mskdesc*)(&((struct mskdesc *)curr_desc)->tiov[((struct mskdesc *)curr_desc)->tiov_num]); });
trickles-userapi_1.c:23643:        if(tp->trickles_opt & 0x100) {
trickles-userapi_1.c:23649:                        err = -11;
trickles-userapi_1.c:23653:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:23665:# 2159 "trickles-userapi.c"
trickles-userapi_1.c:23673:    for (logEntry = (typeof(logEntry))(&tricklesProcLogHead)->next; (logEntry != (typeof(logEntry))(&tricklesProcLogHead)); logEntry=(typeof(logEntry))logEntry->next) {
trickles-userapi_1.c:23675:            int first = logEntry->returnedEvents == 0;
trickles-userapi_1.c:23678:                    for(i=logEntry->returnedEvents; i < logEntry->size; i++) {
trickles-userapi_1.c:23679:                            if(logEntry->events[i].valid)
trickles-userapi_1.c:23683:                            htonl(logEntry->addr), htons(logEntry->port),
trickles-userapi_1.c:23684:                            logEntry->rcv_nxt, logEntry->t_rcv_nxt, count);
trickles-userapi_1.c:23687:            for(i=logEntry->returnedEvents; i < logEntry->size; i++) {
trickles-userapi_1.c:23688:                    struct TricklesLossEvent *event = &logEntry->events[i];
trickles-userapi_1.c:23692:                    if(!event->valid) continue;
trickles-userapi_1.c:23694:                    switch(event->extra) {
trickles-userapi_1.c:23708:                            sprintf(locationBuf, "(bad location %d)", event->extra);
trickles-userapi_1.c:23711:                    switch(event->state) {
trickles-userapi_1.c:23728:                            (int)event->cwnd, state, event->time);
trickles-userapi_1.c:23733:                    temp += logEntry->sentAmount;
trickles-userapi_1.c:23734:                    int copyLen = ({ typeof(({ typeof((int)strlen(temp)) Z = (typeof((int)strlen(temp)))(count - pos); ({ const typeof((int)strlen(temp)) _x = ((int)strlen(temp)); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y; }); })) Z = (typeof(({ typeof((int)strlen(temp)) Z = (typeof((int)strlen(temp)))(count - pos); ({ const typeof((int)strlen(temp)) _x = ((int)strlen(temp)); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y; }); })))(0); ({ const typeof(({ typeof((int)strlen(temp)) Z = (typeof((int)strlen(temp)))(count - pos); ({ const typeof((int)strlen(temp)) _x = ((int)strlen(temp)); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y; }); })) _x = (({ typeof((int)strlen(temp)) Z = (typeof((int)strlen(temp)))(count - pos); ({ const typeof((int)strlen(temp)) _x = ((int)strlen(temp)); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y; }); })); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x > _y ? _x : _y; }); });
trickles-userapi_1.c:23741:                            logEntry->returnedEvents++;
trickles-userapi_1.c:23742:                            logEntry->sentAmount = 0;
trickles-userapi_1.c:23744:                            logEntry->sentAmount += copyLen;
trickles-userapi_1.c:23746:                            if (!(pos == count)) { printk("KERNEL: assertion (" "pos == count" ") failed at " "trickles-userapi.c" "(%d)\n", 2239); };
trickles-userapi_1.c:23750:            if(done && (i == logEntry->size)) {
trickles-userapi_1.c:23752:                    logEntry = (struct TricklesProcLogEntry *)logEntry->prev;
trickles-userapi_1.c:23754:                    kfree(clean->events);
trickles-userapi_1.c:23764:    do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0);
trickles-userapi_1.c:23779:        bb->dest = buffer;
trickles-userapi_1.c:23780:        bb->len = len;
trickles-userapi_1.c:23781:        bb->curPos = 0;
trickles-userapi_1.c:23787:        int prevPos = bb->curPos;
trickles-userapi_1.c:23789:        bb->curPos = ({ typeof(prevPos+len) Z = (typeof(prevPos+len))(bb->len); ({ const typeof(prevPos+len) _x = (prevPos+len); const typeof(Z) _y = (Z); (void) (&_x == &_y); _x < _y ? _x : _y; }); });
trickles-userapi_1.c:23790:        copyLen = bb->curPos - prevPos;
trickles-userapi_1.c:23792:        (__builtin_constant_p(copyLen) ? __constant_memcpy((bb->dest + prevPos),(data),(copyLen)) : __memcpy((bb->dest + prevPos),(data),(copyLen)));
trickles-userapi_1.c:23801:# 2328 "trickles-userapi.c"
trickles-userapi_1.c:23817:    for (logEntry = (typeof(logEntry))(&tricklesCwndProcLogHead)->next; (logEntry != (typeof(logEntry))(&tricklesCwndProcLogHead)); logEntry=(typeof(logEntry))logEntry->next) {
trickles-userapi_1.c:23823:                    switch(logEntry->type) {
trickles-userapi_1.c:23825:                            sprintf(tempbuf, "pkt - %d:%d = %d/%d/%d @ %d s %d us %d rtt0 %d rtt1\n",
trickles-userapi_1.c:23826:                                    logEntry->seq, logEntry->ack_seq,
trickles-userapi_1.c:23827:                                    logEntry->startCwnd, logEntry->effCwnd, logEntry->ssthresh,
trickles-userapi_1.c:23828:                                    logEntry->s, logEntry->us,
trickles-userapi_1.c:23829:                                    logEntry->rtt,
trickles-userapi_1.c:23830:                                    logEntry->srtt);
trickles-userapi_1.c:23833:                            sprintf(tempbuf, "cont - %d:%d = %d/%d/%d TCPBase: %d @ %d s %d us rtt1: %d \n",
trickles-userapi_1.c:23834:                                    logEntry->seq, logEntry->ack_seq,
trickles-userapi_1.c:23835:                                    logEntry->startCwnd, logEntry->effCwnd, logEntry->ssthresh,
trickles-userapi_1.c:23836:                                    logEntry->rtt,
trickles-userapi_1.c:23837:                                    logEntry->s, logEntry->us,
trickles-userapi_1.c:23838:                                    logEntry->srtt);
trickles-userapi_1.c:23841:                            int eventtype = logEntry->seq;
trickles-userapi_1.c:23868:                            sprintf(tempbuf, "%s:%d(%d-%d) = %d/%d/%d TCPBase: %d @ %d s %d us\n", eventTypeStr, logEntry->ack_seq,
trickles-userapi_1.c:23869:                                    logEntry->addr, logEntry->port,
trickles-userapi_1.c:23870:                                    logEntry->startCwnd, logEntry->effCwnd, logEntry->ssthresh,
trickles-userapi_1.c:23871:                                    logEntry->rtt,
trickles-userapi_1.c:23872:                                    logEntry->s, logEntry->us);
trickles-userapi_1.c:23880:                    char *src = tempbuf + logEntry->sentAmount;
trickles-userapi_1.c:23882:                    logEntry->sentAmount = real_wrlen;
trickles-userapi_1.c:23890:                            logEntry = (struct TricklesCwndProcLogEntry*)logEntry->prev;
trickles-userapi_1.c:23905:    do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0);
trickles-userapi_1.c:23917:# 2443 "trickles-userapi.c" 2
trickles-userapi_1.c:23927:        return lbb->start + lbb->limit;
trickles-userapi_1.c:23932:        return lbb->curr - lbb->start;
trickles-userapi_1.c:23937:        return lbb->curr;
trickles-userapi_1.c:23942:        return lbb->curr + len - lbb->start <= lbb->limit;
trickles-userapi_1.c:23948:        rval = lbb->curr;
trickles-userapi_1.c:23953:        lbb->curr += len;
trickles-userapi_1.c:23964:# 2444 "trickles-userapi.c" 2
trickles-userapi_1.c:23975:# 2508 "trickles-userapi.c"
trickles-userapi_1.c:23976:static inline void copy_patch_hmac_update_in(struct HMAC_CTX *hmac_ctx, void *user_addr, void *kernel_addr, int len, void (*const generator)(const void *const context, int num, struct patch_desc *patch), const void *const gen_ctx, int numDescs) { const int in=1, out=2; int i; int lastOffset = 0; if((in == out)) { for(i=0; i < numDescs; i++) { struct patch_desc patch; generator(gen_ctx, i, &patch); if(patch.offset < lastOffset) { do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } int hmacStart = lastOffset; int hmacEnd = patch.offset; (__builtin_constant_p(hmacEnd - hmacStart) ? __constant_copy_to_user_nocheck((user_addr + hmacStart),(kernel_addr + hmacStart),(hmacEnd - hmacStart)) : __generic_copy_to_user_nocheck((user_addr + hmacStart),(kernel_addr + hmacStart),(hmacEnd - hmacStart))); hmac_update(hmac_ctx, (char*)kernel_addr + hmacStart, hmacEnd - hmacStart); int zero = 0; if (!(patch.width <= sizeof(zero))) { printk("KERNEL: assertion (" "patch.width <= sizeof(zero)" ") failed at " "trickles-userapi.c" "(%d)\n", 2508); }; (__builtin_constant_p(patch.width) ? __constant_copy_to_user_nocheck((user_addr + patch.offset),(&zero),(patch.width)) : __generic_copy_to_user_nocheck((user_addr + patch.offset),(&zero),(patch.width))); hmac_update(hmac_ctx, &zero, patch.width); lastOffset = patch.offset + patch.width; } } else { (__builtin_constant_p(len) ? __constant_copy_from_user_nocheck((kernel_addr),(user_addr),(len)) : __generic_copy_from_user_nocheck((kernel_addr),(user_addr),(len))); for(i=0; i < numDescs; i++) { int zero = 0; struct patch_desc patch; generator(gen_ctx, i, &patch); if(patch.offset < lastOffset) { do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } if (!(patch.offset + patch.width <= len)) { printk("KERNEL: assertion (" "patch.offset + patch.width <= len" ") failed at " "trickles-userapi.c" "(%d)\n", 2508); }; if (!(__builtin_memcmp(kernel_addr + patch.offset, &zero, patch.width) == 0)) { printk("KERNEL: assertion (" "memcmp(kernel_addr + patch.offset, &zero, patch.width) == 0" ") failed at " "trickles-userapi.c" "(%d)\n", 2508); }; (__builtin_constant_p(0) ? (__builtin_constant_p((patch.width)) ? __constant_c_and_count_memset(((kernel_addr + patch.offset)),((0x01010101UL*(unsigned char)(0))),((patch.width))) : __constant_c_memset(((kernel_addr + patch.offset)),((0x01010101UL*(unsigned char)(0))),((patch.width)))) : (__builtin_constant_p((patch.width)) ? __memset_generic((((kernel_addr + patch.offset))),(((0))),(((patch.width)))) : __memset_generic(((kernel_addr + patch.offset)),((0)),((patch.width))))); } } if (!(len >= lastOffset)) { printk("KERNEL: assertion (" "len >= lastOffset" ") failed at " "trickles-userapi.c" "(%d)\n", 2508); }; (__builtin_constant_p(len - lastOffset) ? __constant_copy_to_user_nocheck((user_addr + lastOffset),(kernel_addr + lastOffset),(len - lastOffset)) : __generic_copy_to_user_nocheck((user_addr + lastOffset),(kernel_addr + lastOffset),(len - lastOffset))); if((in == out)) { hmac_update(hmac_ctx, (char*)kernel_addr + lastOffset, len - lastOffset); } };
trickles-userapi_1.c:23977:static inline void copy_patch_hmac_update_out(struct HMAC_CTX *hmac_ctx, void *user_addr, void *kernel_addr, int len, void (*const generator)(const void *const context, int num, struct patch_desc *patch), const void *const gen_ctx, int numDescs) { const int in=1, out=2; int i; int lastOffset = 0; if((out == out)) { for(i=0; i < numDescs; i++) { struct patch_desc patch; generator(gen_ctx, i, &patch); if(patch.offset < lastOffset) { do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } int hmacStart = lastOffset; int hmacEnd = patch.offset; (__builtin_constant_p(hmacEnd - hmacStart) ? __constant_copy_to_user_nocheck((user_addr + hmacStart),(kernel_addr + hmacStart),(hmacEnd - hmacStart)) : __generic_copy_to_user_nocheck((user_addr + hmacStart),(kernel_addr + hmacStart),(hmacEnd - hmacStart))); hmac_update(hmac_ctx, (char*)kernel_addr + hmacStart, hmacEnd - hmacStart); int zero = 0; if (!(patch.width <= sizeof(zero))) { printk("KERNEL: assertion (" "patch.width <= sizeof(zero)" ") failed at " "trickles-userapi.c" "(%d)\n", 2509); }; (__builtin_constant_p(patch.width) ? __constant_copy_to_user_nocheck((user_addr + patch.offset),(&zero),(patch.width)) : __generic_copy_to_user_nocheck((user_addr + patch.offset),(&zero),(patch.width))); hmac_update(hmac_ctx, &zero, patch.width); lastOffset = patch.offset + patch.width; } } else { (__builtin_constant_p(len) ? __constant_copy_from_user_nocheck((kernel_addr),(user_addr),(len)) : __generic_copy_from_user_nocheck((kernel_addr),(user_addr),(len))); for(i=0; i < numDescs; i++) { int zero = 0; struct patch_desc patch; generator(gen_ctx, i, &patch); if(patch.offset < lastOffset) { do { if (!(0)) { printk("kgdb assertion failed: %s\n", "BUG"); show_stack(((void *)0)); breakpoint(); } } while (0); } if (!(patch.offset + patch.width <= len)) { printk("KERNEL: assertion (" "patch.offset + patch.width <= len" ") failed at " "trickles-userapi.c" "(%d)\n", 2509); }; if (!(__builtin_memcmp(kernel_addr + patch.offset, &zero, patch.width) == 0)) { printk("KERNEL: assertion (" "memcmp(kernel_addr + patch.offset, &zero, patch.width) == 0" ") failed at " "trickles-userapi.c" "(%d)\n", 2509); }; (__builtin_constant_p(0) ? (__builtin_constant_p((patch.width)) ? __constant_c_and_count_memset(((kernel_addr + patch.offset)),((0x01010101UL*(unsigned char)(0))),((patch.width))) : __constant_c_memset(((kernel_addr + patch.offset)),((0x01010101UL*(unsigned char)(0))),((patch.width)))) : (__builtin_constant_p((patch.width)) ? __memset_generic((((kernel_addr + patch.offset))),(((0))),(((patch.width)))) : __memset_generic(((kernel_addr + patch.offset)),((0)),((patch.width))))); } } if (!(len >= lastOffset)) { printk("KERNEL: assertion (" "len >= lastOffset" ") failed at " "trickles-userapi.c" "(%d)\n", 2509); }; (__builtin_constant_p(len - lastOffset) ? __constant_copy_to_user_nocheck((user_addr + lastOffset),(kernel_addr + lastOffset),(len - lastOffset)) : __generic_copy_to_user_nocheck((user_addr + lastOffset),(kernel_addr + lastOffset),(len - lastOffset))); if((out == out)) { hmac_update(hmac_ctx, (char*)kernel_addr + lastOffset, len - lastOffset); } };
trickles-userapi_1.c:23985:        patch->offset = num * sizeof(struct cminisock_packet) +
trickles-userapi_1.c:23986:                (((char *)&((struct cminisock_packet*)0)->ucontData) - (char*)((void *)0));
trickles-userapi_1.c:23987:        patch->width = (sizeof(((struct cminisock_packet*)0)->ucontData));
trickles-userapi_1.c:23998:        ctx->numDeferrals = 0;
trickles-userapi_1.c:23999:        ctx->next = ((void *)0);
trickles-userapi_1.c:24003:        if(ctx->next != ((void *)0)) {
trickles-userapi_1.c:24004:                DeferralContext_free(ctx->next);
trickles-userapi_1.c:24010:        while(ctx->next != ((void *)0)) {
trickles-userapi_1.c:24011:                if (!(ctx->numDeferrals == (16))) { printk("KERNEL: assertion (" "ctx->numDeferrals == MAX_NUM_DEFERRALS_PER_CONTEXT" ") failed at " "trickles-userapi.c" "(%d)\n", 2543); };
trickles-userapi_1.c:24012:                ctx = ctx->next;
trickles-userapi_1.c:24014:        if(ctx->numDeferrals == (16)) {
trickles-userapi_1.c:24015:                ctx->next = kmalloc(sizeof(struct DeferralContext), (0x20 | 0x10 | 0x40 | 0x80 | 0x100));
trickles-userapi_1.c:24016:                if(ctx->next == ((void *)0)) {
trickles-userapi_1.c:24018:                        return -1;
trickles-userapi_1.c:24020:                ctx = ctx->next;
trickles-userapi_1.c:24022:        ctx->data[ctx->numDeferrals++] = value;
trickles-userapi_1.c:24029:# 2575 "trickles-userapi.c"
trickles-userapi_1.c:24047:# 2753 "trickles-userapi.c"
trickles-userapi_1.c:24048:static __attribute__((always_inline)) int convertMSK_in(struct sock *sk, struct HMAC_CTX *hmac_ctx, struct cminisock *msk, struct linear_bounded_buffer *lbb, int *count) { const int in = 1, out = 2; int i, err = 0; int startLen = lbb_get_offset(lbb); struct DeferralContext deferral_ctx; DeferralContext_init(&deferral_ctx); int desc_len = -1; if((in == out)) { desc_len = sizeof(struct extract_mskdesc_out); ; desc_len += msk->ucont_len; ; desc_len += msk->input_len; ; desc_len += msk->num_packets * sizeof(struct cminisock_packet); ; for(i=0; i < msk->num_packets; i++) { desc_len += msk->packets[i].ucontLen; ; } } int *len = (int*)lbb_reserve(lbb, sizeof(int)); char *currStart = (char*)len; struct cminisock *user_msk = (struct cminisock *) lbb_reserve(lbb, sizeof(*msk)); if(currStart == ((void *)0) || user_msk == ((void *)0)) { printk("in" ": Result overflow on currStart or output_msk\n"); err = (-1); goto convert_error; } if((in == out)) { ({ long __pu_err; do { __pu_err = 0; switch ((sizeof(*(len)))) { case 1: __asm__ __volatile__( "1:	mov""b"" %""b""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "iq" (((__typeof__(*(len)))(desc_len))), "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__pu_err)); break; case 2: __asm__ __volatile__( "1:	mov""w"" %""w""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(len)))(desc_len))), "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__pu_err)); break; case 4: __asm__ __volatile__( "1:	mov""l"" %""""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(len)))(desc_len))), "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__pu_err)); break; case 8: __asm__ __volatile__( "1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous" : "=r"(__pu_err) : "A" (((__typeof__(*(len)))(desc_len))), "r" (((len))), "i"(-14), "0"(__pu_err)); break; default: __put_user_bad(); } } while (0); __pu_err; }); hmac_update(hmac_ctx, &desc_len, sizeof(desc_len)); } else { ({ long __gu_err, __gu_val; do { __gu_err = 0; switch ((sizeof(*(len)))) { case 1: __asm__ __volatile__( "1:	mov""b"" %2,%""b""1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor""b"" %""b""1,%""b""1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__gu_err), "=q" (__gu_val) : "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__gu_err)); break; case 2: __asm__ __volatile__( "1:	mov""w"" %2,%""w""1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor""w"" %""w""1,%""w""1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__gu_err), "=r" (__gu_val) : "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__gu_err)); break; case 4: __asm__ __volatile__( "1:	mov""l"" %2,%""""1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor""l"" %""""1,%""""1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__gu_err), "=r" (__gu_val) : "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__gu_err)); break; default: (__gu_val) = __get_user_bad(); } } while (0); ((desc_len)) = (__typeof__(*((len))))__gu_val; __gu_err; }); } const struct patch_desc const mskPatchArray[] = { {offset: (((char *)&((struct cminisock*)0)->sk) - (char*)((void *)0)), width: (sizeof(((struct cminisock*)0)->sk)) }, {offset: (((char *)&((struct cminisock*)0)->ucont_data) - (char*)((void *)0)), width: (sizeof(((struct cminisock*)0)->ucont_data)) }, {offset: (((char *)&((struct cminisock*)0)->input) - (char*)((void *)0)), width: (sizeof(((struct cminisock*)0)->input)) }, {offset: (((char *)&((struct cminisock*)0)->packets) - (char*)((void *)0)), width: (sizeof(((struct cminisock*)0)->packets)) } }; ; copy_patch_hmac_update_in(hmac_ctx, user_msk, msk, sizeof(*msk), arrayPatchGenerator, mskPatchArray, (sizeof(mskPatchArray) / sizeof(mskPatchArray[0]))); ({ if((msk->ucont_len) == 0) { } else { int _len = (msk->ucont_len); char *_dest_name = "user_" "msk->ucont_data"; void *_tempdest = lbb_reserve(lbb, _len); if(_tempdest == ((void *)0)) { printk("result overflow - %s\n", _dest_name); err = (-1); goto convert_error; } if(tmalloc_helperin != ((void *)0)) { void *alloc_ptr = tmalloc_helperin(sk, msk->ucont_len); if(alloc_ptr == ((void *)0)) { printk("Out of memory (""tmalloc_helper" "in" ") during copy_patch_hmac\n"); err = (-1); goto convert_error; } msk->ucont_data = alloc_ptr; } copy_patch_hmac_update_in(hmac_ctx, _tempdest, (msk->ucont_data), _len, ((void *)0), ((void *)0), 0); if((in == out)) ({ long __pu_err; do { __pu_err = 0; switch ((sizeof(*(&((struct cminisock*)_tempdest)->ucont_data)))) { case 1: __asm__ __volatile__( "1:	mov""b"" %""b""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "iq" (((__typeof__(*(&((struct cminisock*)_tempdest)->ucont_data)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock*)_tempdest)->ucont_data))))), "i"(-14), "0"(__pu_err)); break; case 2: __asm__ __volatile__( "1:	mov""w"" %""w""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(&((struct cminisock*)_tempdest)->ucont_data)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock*)_tempdest)->ucont_data))))), "i"(-14), "0"(__pu_err)); break; case 4: __asm__ __volatile__( "1:	mov""l"" %""""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(&((struct cminisock*)_tempdest)->ucont_data)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock*)_tempdest)->ucont_data))))), "i"(-14), "0"(__pu_err)); break; case 8: __asm__ __volatile__( "1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous" : "=r"(__pu_err) : "A" (((__typeof__(*(&((struct cminisock*)_tempdest)->ucont_data)))((char*)_tempdest - currStart))), "r" (((&((struct cminisock*)_tempdest)->ucont_data))), "i"(-14), "0"(__pu_err)); break; default: __put_user_bad(); } } while (0); __pu_err; }); } }); ; ({ if((msk->input_len) == 0) { } else { int _len = (msk->input_len); char *_dest_name = "user_" "msk->input"; void *_tempdest = lbb_reserve(lbb, _len); if(_tempdest == ((void *)0)) { printk("result overflow - %s\n", _dest_name); err = (-1); goto convert_error; } if(tmalloc_helperin != ((void *)0)) { void *alloc_ptr = tmalloc_helperin(sk, msk->input_len); if(alloc_ptr == ((void *)0)) { printk("Out of memory (""tmalloc_helper" "in" ") during copy_patch_hmac\n"); err = (-1); goto convert_error; } msk->input = alloc_ptr; } copy_patch_hmac_update_in(hmac_ctx, _tempdest, (msk->input), _len, ((void *)0), ((void *)0), 0); if((in == out)) ({ long __pu_err; do { __pu_err = 0; switch ((sizeof(*(&((struct cminisock*)_tempdest)->input)))) { case 1: __asm__ __volatile__( "1:	mov""b"" %""b""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "iq" (((__typeof__(*(&((struct cminisock*)_tempdest)->input)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock*)_tempdest)->input))))), "i"(-14), "0"(__pu_err)); break; case 2: __asm__ __volatile__( "1:	mov""w"" %""w""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(&((struct cminisock*)_tempdest)->input)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock*)_tempdest)->input))))), "i"(-14), "0"(__pu_err)); break; case 4: __asm__ __volatile__( "1:	mov""l"" %""""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(&((struct cminisock*)_tempdest)->input)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock*)_tempdest)->input))))), "i"(-14), "0"(__pu_err)); break; case 8: __asm__ __volatile__( "1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous" : "=r"(__pu_err) : "A" (((__typeof__(*(&((struct cminisock*)_tempdest)->input)))((char*)_tempdest - currStart))), "r" (((&((struct cminisock*)_tempdest)->input))), "i"(-14), "0"(__pu_err)); break; default: __put_user_bad(); } } while (0); __pu_err; }); } }); ; int packets_len = msk->num_packets * sizeof(struct cminisock_packet); ({ if((packets_len) == 0) { } else { int _len = (packets_len); char *_dest_name = "user_" "msk->packets"; void *_tempdest = lbb_reserve(lbb, _len); if(_tempdest == ((void *)0)) { printk("result overflow - %s\n", _dest_name); err = (-1); goto convert_error; } if(tmalloc_helperin != ((void *)0)) { void *alloc_ptr = tmalloc_helperin(sk, packets_len); if(alloc_ptr == ((void *)0)) { printk("Out of memory (""tmalloc_helper" "in" ") during copy_patch_hmac\n"); err = (-1); goto convert_error; } msk->packets = alloc_ptr; } copy_patch_hmac_update_in(hmac_ctx, _tempdest, (msk->packets), _len, packetPatchGenerator, ((void *)0), msk->num_packets); if((in == out)) ({ long __pu_err; do { __pu_err = 0; switch ((sizeof(*(&((struct cminisock*)_tempdest)->packets)))) { case 1: __asm__ __volatile__( "1:	mov""b"" %""b""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "iq" (((__typeof__(*(&((struct cminisock*)_tempdest)->packets)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock*)_tempdest)->packets))))), "i"(-14), "0"(__pu_err)); break; case 2: __asm__ __volatile__( "1:	mov""w"" %""w""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(&((struct cminisock*)_tempdest)->packets)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock*)_tempdest)->packets))))), "i"(-14), "0"(__pu_err)); break; case 4: __asm__ __volatile__( "1:	mov""l"" %""""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(&((struct cminisock*)_tempdest)->packets)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock*)_tempdest)->packets))))), "i"(-14), "0"(__pu_err)); break; case 8: __asm__ __volatile__( "1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous" : "=r"(__pu_err) : "A" (((__typeof__(*(&((struct cminisock*)_tempdest)->packets)))((char*)_tempdest - currStart))), "r" (((&((struct cminisock*)_tempdest)->packets))), "i"(-14), "0"(__pu_err)); break; default: __put_user_bad(); } } while (0); __pu_err; }); } }); ; for(i=0; i < msk->num_packets; i++) { ({ if((msk->packets[i].ucontLen) == 0) { } else { int _len = (msk->packets[i].ucontLen); char *_dest_name = "user_" "msk->packets[i].ucontData"; void *_tempdest = lbb_reserve(lbb, _len); if(_tempdest == ((void *)0)) { printk("result overflow - %s\n", _dest_name); err = (-1); goto convert_error; } if(kmalloc_helperin != ((void *)0)) { void *alloc_ptr = kmalloc_helperin(sk, msk->packets[i].ucontLen); if(alloc_ptr == ((void *)0)) { printk("Out of memory (""kmalloc_helper" "in" ") during copy_patch_hmac\n"); err = (-1); goto convert_error; } msk->packets[i].ucontData = alloc_ptr; } copy_patch_hmac_update_in(hmac_ctx, _tempdest, (msk->packets[i].ucontData), _len, ((void *)0), ((void *)0), 0); if((in == out)) ({ long __pu_err; do { __pu_err = 0; switch ((sizeof(*(&((struct cminisock_packet*)_tempdest)->ucontData)))) { case 1: __asm__ __volatile__( "1:	mov""b"" %""b""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "iq" (((__typeof__(*(&((struct cminisock_packet*)_tempdest)->ucontData)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock_packet*)_tempdest)->ucontData))))), "i"(-14), "0"(__pu_err)); break; case 2: __asm__ __volatile__( "1:	mov""w"" %""w""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(&((struct cminisock_packet*)_tempdest)->ucontData)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock_packet*)_tempdest)->ucontData))))), "i"(-14), "0"(__pu_err)); break; case 4: __asm__ __volatile__( "1:	mov""l"" %""""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(&((struct cminisock_packet*)_tempdest)->ucontData)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock_packet*)_tempdest)->ucontData))))), "i"(-14), "0"(__pu_err)); break; case 8: __asm__ __volatile__( "1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous" : "=r"(__pu_err) : "A" (((__typeof__(*(&((struct cminisock_packet*)_tempdest)->ucontData)))((char*)_tempdest - currStart))), "r" (((&((struct cminisock_packet*)_tempdest)->ucontData))), "i"(-14), "0"(__pu_err)); break; default: __put_user_bad(); } } while (0); __pu_err; }); } }); ; } if((in == out)) { int check_len = lbb_get_offset(lbb) - startLen; if(!(desc_len == check_len)) { if (!(desc_len == check_len)) { printk("KERNEL: assertion (" "desc_len == check_len" ") failed at " "trickles-userapi.c" "(%d)\n", 2753); }; printk("%d %d\n", desc_len, check_len); } ({ long __pu_err; do { __pu_err = 0; switch ((sizeof(*(len)))) { case 1: __asm__ __volatile__( "1:	mov""b"" %""b""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "iq" (((__typeof__(*(len)))(check_len))), "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__pu_err)); break; case 2: __asm__ __volatile__( "1:	mov""w"" %""w""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(len)))(check_len))), "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__pu_err)); break; case 4: __asm__ __volatile__( "1:	mov""l"" %""""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(len)))(check_len))), "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__pu_err)); break; case 8: __asm__ __volatile__( "1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous" : "=r"(__pu_err) : "A" (((__typeof__(*(len)))(check_len))), "r" (((len))), "i"(-14), "0"(__pu_err)); break; default: __put_user_bad(); } } while (0); __pu_err; }); } else { int actual_len = lbb_get_offset(lbb) - startLen; int desc_len1; ({ long __gu_err, __gu_val; do { __gu_err = 0; switch ((sizeof(*(len)))) { case 1: __asm__ __volatile__( "1:	mov""b"" %2,%""b""1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor""b"" %""b""1,%""b""1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__gu_err), "=q" (__gu_val) : "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__gu_err)); break; case 2: __asm__ __volatile__( "1:	mov""w"" %2,%""w""1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor""w"" %""w""1,%""w""1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__gu_err), "=r" (__gu_val) : "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__gu_err)); break; case 4: __asm__ __volatile__( "1:	mov""l"" %2,%""""1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor""l"" %""""1,%""""1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__gu_err), "=r" (__gu_val) : "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__gu_err)); break; default: (__gu_val) = __get_user_bad(); } } while (0); ((desc_len1)) = (__typeof__(*((len))))__gu_val; __gu_err; }); if (!(desc_len1 == desc_len)) { printk("KERNEL: assertion (" "desc_len1 == desc_len" ") failed at " "trickles-userapi.c" "(%d)\n", 2753); }; if(!(desc_len == actual_len)) { if (!(desc_len == actual_len)) { printk("KERNEL: assertion (" "desc_len == actual_len" ") failed at " "trickles-userapi.c" "(%d)\n", 2753); }; printk("%d %d\n", desc_len, actual_len); } } (*count)++; if(0) { convert_error: if(deferral_ctx.next != ((void *)0)) DeferralContext_free(deferral_ctx.next); return -22; } return 0; };
trickles-userapi_1.c:24049:static __attribute__((always_inline)) int convertMSK_out(struct sock *sk, struct HMAC_CTX *hmac_ctx, struct cminisock *msk, struct linear_bounded_buffer *lbb, int *count) { const int in = 1, out = 2; int i, err = 0; int startLen = lbb_get_offset(lbb); struct DeferralContext deferral_ctx; DeferralContext_init(&deferral_ctx); int desc_len = -1; if((out == out)) { desc_len = sizeof(struct extract_mskdesc_out); ; desc_len += msk->ucont_len; ; desc_len += msk->input_len; ; desc_len += msk->num_packets * sizeof(struct cminisock_packet); ; for(i=0; i < msk->num_packets; i++) { desc_len += msk->packets[i].ucontLen; ; } } int *len = (int*)lbb_reserve(lbb, sizeof(int)); char *currStart = (char*)len; struct cminisock *user_msk = (struct cminisock *) lbb_reserve(lbb, sizeof(*msk)); if(currStart == ((void *)0) || user_msk == ((void *)0)) { printk("out" ": Result overflow on currStart or output_msk\n"); err = (-1); goto convert_error; } if((out == out)) { ({ long __pu_err; do { __pu_err = 0; switch ((sizeof(*(len)))) { case 1: __asm__ __volatile__( "1:	mov""b"" %""b""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "iq" (((__typeof__(*(len)))(desc_len))), "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__pu_err)); break; case 2: __asm__ __volatile__( "1:	mov""w"" %""w""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(len)))(desc_len))), "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__pu_err)); break; case 4: __asm__ __volatile__( "1:	mov""l"" %""""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(len)))(desc_len))), "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__pu_err)); break; case 8: __asm__ __volatile__( "1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous" : "=r"(__pu_err) : "A" (((__typeof__(*(len)))(desc_len))), "r" (((len))), "i"(-14), "0"(__pu_err)); break; default: __put_user_bad(); } } while (0); __pu_err; }); hmac_update(hmac_ctx, &desc_len, sizeof(desc_len)); } else { ({ long __gu_err, __gu_val; do { __gu_err = 0; switch ((sizeof(*(len)))) { case 1: __asm__ __volatile__( "1:	mov""b"" %2,%""b""1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor""b"" %""b""1,%""b""1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__gu_err), "=q" (__gu_val) : "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__gu_err)); break; case 2: __asm__ __volatile__( "1:	mov""w"" %2,%""w""1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor""w"" %""w""1,%""w""1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__gu_err), "=r" (__gu_val) : "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__gu_err)); break; case 4: __asm__ __volatile__( "1:	mov""l"" %2,%""""1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor""l"" %""""1,%""""1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__gu_err), "=r" (__gu_val) : "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__gu_err)); break; default: (__gu_val) = __get_user_bad(); } } while (0); ((desc_len)) = (__typeof__(*((len))))__gu_val; __gu_err; }); } const struct patch_desc const mskPatchArray[] = { {offset: (((char *)&((struct cminisock*)0)->sk) - (char*)((void *)0)), width: (sizeof(((struct cminisock*)0)->sk)) }, {offset: (((char *)&((struct cminisock*)0)->ucont_data) - (char*)((void *)0)), width: (sizeof(((struct cminisock*)0)->ucont_data)) }, {offset: (((char *)&((struct cminisock*)0)->input) - (char*)((void *)0)), width: (sizeof(((struct cminisock*)0)->input)) }, {offset: (((char *)&((struct cminisock*)0)->packets) - (char*)((void *)0)), width: (sizeof(((struct cminisock*)0)->packets)) } }; ; copy_patch_hmac_update_out(hmac_ctx, user_msk, msk, sizeof(*msk), arrayPatchGenerator, mskPatchArray, (sizeof(mskPatchArray) / sizeof(mskPatchArray[0]))); ({ if((msk->ucont_len) == 0) { } else { int _len = (msk->ucont_len); char *_dest_name = "user_" "msk->ucont_data"; void *_tempdest = lbb_reserve(lbb, _len); if(_tempdest == ((void *)0)) { printk("result overflow - %s\n", _dest_name); err = (-1); goto convert_error; } if(tmalloc_helperout != ((void *)0)) { void *alloc_ptr = tmalloc_helperout(sk, msk->ucont_len); if(alloc_ptr == ((void *)0)) { printk("Out of memory (""tmalloc_helper" "out" ") during copy_patch_hmac\n"); err = (-1); goto convert_error; } msk->ucont_data = alloc_ptr; } copy_patch_hmac_update_out(hmac_ctx, _tempdest, (msk->ucont_data), _len, ((void *)0), ((void *)0), 0); if((out == out)) ({ long __pu_err; do { __pu_err = 0; switch ((sizeof(*(&((struct cminisock*)_tempdest)->ucont_data)))) { case 1: __asm__ __volatile__( "1:	mov""b"" %""b""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "iq" (((__typeof__(*(&((struct cminisock*)_tempdest)->ucont_data)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock*)_tempdest)->ucont_data))))), "i"(-14), "0"(__pu_err)); break; case 2: __asm__ __volatile__( "1:	mov""w"" %""w""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(&((struct cminisock*)_tempdest)->ucont_data)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock*)_tempdest)->ucont_data))))), "i"(-14), "0"(__pu_err)); break; case 4: __asm__ __volatile__( "1:	mov""l"" %""""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(&((struct cminisock*)_tempdest)->ucont_data)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock*)_tempdest)->ucont_data))))), "i"(-14), "0"(__pu_err)); break; case 8: __asm__ __volatile__( "1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous" : "=r"(__pu_err) : "A" (((__typeof__(*(&((struct cminisock*)_tempdest)->ucont_data)))((char*)_tempdest - currStart))), "r" (((&((struct cminisock*)_tempdest)->ucont_data))), "i"(-14), "0"(__pu_err)); break; default: __put_user_bad(); } } while (0); __pu_err; }); } }); ; ({ if((msk->input_len) == 0) { } else { int _len = (msk->input_len); char *_dest_name = "user_" "msk->input"; void *_tempdest = lbb_reserve(lbb, _len); if(_tempdest == ((void *)0)) { printk("result overflow - %s\n", _dest_name); err = (-1); goto convert_error; } if(tmalloc_helperout != ((void *)0)) { void *alloc_ptr = tmalloc_helperout(sk, msk->input_len); if(alloc_ptr == ((void *)0)) { printk("Out of memory (""tmalloc_helper" "out" ") during copy_patch_hmac\n"); err = (-1); goto convert_error; } msk->input = alloc_ptr; } copy_patch_hmac_update_out(hmac_ctx, _tempdest, (msk->input), _len, ((void *)0), ((void *)0), 0); if((out == out)) ({ long __pu_err; do { __pu_err = 0; switch ((sizeof(*(&((struct cminisock*)_tempdest)->input)))) { case 1: __asm__ __volatile__( "1:	mov""b"" %""b""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "iq" (((__typeof__(*(&((struct cminisock*)_tempdest)->input)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock*)_tempdest)->input))))), "i"(-14), "0"(__pu_err)); break; case 2: __asm__ __volatile__( "1:	mov""w"" %""w""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(&((struct cminisock*)_tempdest)->input)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock*)_tempdest)->input))))), "i"(-14), "0"(__pu_err)); break; case 4: __asm__ __volatile__( "1:	mov""l"" %""""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(&((struct cminisock*)_tempdest)->input)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock*)_tempdest)->input))))), "i"(-14), "0"(__pu_err)); break; case 8: __asm__ __volatile__( "1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous" : "=r"(__pu_err) : "A" (((__typeof__(*(&((struct cminisock*)_tempdest)->input)))((char*)_tempdest - currStart))), "r" (((&((struct cminisock*)_tempdest)->input))), "i"(-14), "0"(__pu_err)); break; default: __put_user_bad(); } } while (0); __pu_err; }); } }); ; int packets_len = msk->num_packets * sizeof(struct cminisock_packet); ({ if((packets_len) == 0) { } else { int _len = (packets_len); char *_dest_name = "user_" "msk->packets"; void *_tempdest = lbb_reserve(lbb, _len); if(_tempdest == ((void *)0)) { printk("result overflow - %s\n", _dest_name); err = (-1); goto convert_error; } if(tmalloc_helperout != ((void *)0)) { void *alloc_ptr = tmalloc_helperout(sk, packets_len); if(alloc_ptr == ((void *)0)) { printk("Out of memory (""tmalloc_helper" "out" ") during copy_patch_hmac\n"); err = (-1); goto convert_error; } msk->packets = alloc_ptr; } copy_patch_hmac_update_out(hmac_ctx, _tempdest, (msk->packets), _len, packetPatchGenerator, ((void *)0), msk->num_packets); if((out == out)) ({ long __pu_err; do { __pu_err = 0; switch ((sizeof(*(&((struct cminisock*)_tempdest)->packets)))) { case 1: __asm__ __volatile__( "1:	mov""b"" %""b""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "iq" (((__typeof__(*(&((struct cminisock*)_tempdest)->packets)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock*)_tempdest)->packets))))), "i"(-14), "0"(__pu_err)); break; case 2: __asm__ __volatile__( "1:	mov""w"" %""w""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(&((struct cminisock*)_tempdest)->packets)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock*)_tempdest)->packets))))), "i"(-14), "0"(__pu_err)); break; case 4: __asm__ __volatile__( "1:	mov""l"" %""""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(&((struct cminisock*)_tempdest)->packets)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock*)_tempdest)->packets))))), "i"(-14), "0"(__pu_err)); break; case 8: __asm__ __volatile__( "1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous" : "=r"(__pu_err) : "A" (((__typeof__(*(&((struct cminisock*)_tempdest)->packets)))((char*)_tempdest - currStart))), "r" (((&((struct cminisock*)_tempdest)->packets))), "i"(-14), "0"(__pu_err)); break; default: __put_user_bad(); } } while (0); __pu_err; }); } }); ; for(i=0; i < msk->num_packets; i++) { ({ if((msk->packets[i].ucontLen) == 0) { } else { int _len = (msk->packets[i].ucontLen); char *_dest_name = "user_" "msk->packets[i].ucontData"; void *_tempdest = lbb_reserve(lbb, _len); if(_tempdest == ((void *)0)) { printk("result overflow - %s\n", _dest_name); err = (-1); goto convert_error; } if(kmalloc_helperout != ((void *)0)) { void *alloc_ptr = kmalloc_helperout(sk, msk->packets[i].ucontLen); if(alloc_ptr == ((void *)0)) { printk("Out of memory (""kmalloc_helper" "out" ") during copy_patch_hmac\n"); err = (-1); goto convert_error; } msk->packets[i].ucontData = alloc_ptr; } copy_patch_hmac_update_out(hmac_ctx, _tempdest, (msk->packets[i].ucontData), _len, ((void *)0), ((void *)0), 0); if((out == out)) ({ long __pu_err; do { __pu_err = 0; switch ((sizeof(*(&((struct cminisock_packet*)_tempdest)->ucontData)))) { case 1: __asm__ __volatile__( "1:	mov""b"" %""b""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "iq" (((__typeof__(*(&((struct cminisock_packet*)_tempdest)->ucontData)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock_packet*)_tempdest)->ucontData))))), "i"(-14), "0"(__pu_err)); break; case 2: __asm__ __volatile__( "1:	mov""w"" %""w""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(&((struct cminisock_packet*)_tempdest)->ucontData)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock_packet*)_tempdest)->ucontData))))), "i"(-14), "0"(__pu_err)); break; case 4: __asm__ __volatile__( "1:	mov""l"" %""""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(&((struct cminisock_packet*)_tempdest)->ucontData)))((char*)_tempdest - currStart))), "m"((*(struct __large_struct *)(((&((struct cminisock_packet*)_tempdest)->ucontData))))), "i"(-14), "0"(__pu_err)); break; case 8: __asm__ __volatile__( "1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous" : "=r"(__pu_err) : "A" (((__typeof__(*(&((struct cminisock_packet*)_tempdest)->ucontData)))((char*)_tempdest - currStart))), "r" (((&((struct cminisock_packet*)_tempdest)->ucontData))), "i"(-14), "0"(__pu_err)); break; default: __put_user_bad(); } } while (0); __pu_err; }); } }); ; } if((out == out)) { int check_len = lbb_get_offset(lbb) - startLen; if(!(desc_len == check_len)) { if (!(desc_len == check_len)) { printk("KERNEL: assertion (" "desc_len == check_len" ") failed at " "trickles-userapi.c" "(%d)\n", 2754); }; printk("%d %d\n", desc_len, check_len); } ({ long __pu_err; do { __pu_err = 0; switch ((sizeof(*(len)))) { case 1: __asm__ __volatile__( "1:	mov""b"" %""b""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "iq" (((__typeof__(*(len)))(check_len))), "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__pu_err)); break; case 2: __asm__ __volatile__( "1:	mov""w"" %""w""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(len)))(check_len))), "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__pu_err)); break; case 4: __asm__ __volatile__( "1:	mov""l"" %""""1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__pu_err) : "ir" (((__typeof__(*(len)))(check_len))), "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__pu_err)); break; case 8: __asm__ __volatile__( "1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous" : "=r"(__pu_err) : "A" (((__typeof__(*(len)))(check_len))), "r" (((len))), "i"(-14), "0"(__pu_err)); break; default: __put_user_bad(); } } while (0); __pu_err; }); } else { int actual_len = lbb_get_offset(lbb) - startLen; int desc_len1; ({ long __gu_err, __gu_val; do { __gu_err = 0; switch ((sizeof(*(len)))) { case 1: __asm__ __volatile__( "1:	mov""b"" %2,%""b""1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor""b"" %""b""1,%""b""1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__gu_err), "=q" (__gu_val) : "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__gu_err)); break; case 2: __asm__ __volatile__( "1:	mov""w"" %2,%""w""1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor""w"" %""w""1,%""w""1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__gu_err), "=r" (__gu_val) : "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__gu_err)); break; case 4: __asm__ __volatile__( "1:	mov""l"" %2,%""""1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor""l"" %""""1,%""""1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__gu_err), "=r" (__gu_val) : "m"((*(struct __large_struct *)(((len))))), "i"(-14), "0"(__gu_err)); break; default: (__gu_val) = __get_user_bad(); } } while (0); ((desc_len1)) = (__typeof__(*((len))))__gu_val; __gu_err; }); if (!(desc_len1 == desc_len)) { printk("KERNEL: assertion (" "desc_len1 == desc_len" ") failed at " "trickles-userapi.c" "(%d)\n", 2754); }; if(!(desc_len == actual_len)) { if (!(desc_len == actual_len)) { printk("KERNEL: assertion (" "desc_len == actual_len" ") failed at " "trickles-userapi.c" "(%d)\n", 2754); }; printk("%d %d\n", desc_len, actual_len); } } (*count)++; if(0) { convert_error: if(deferral_ctx.next != ((void *)0)) DeferralContext_free(deferral_ctx.next); return -22; } return 0; };
trickles-userapi_1.c:24060:        msk->ctl = ALLOC_READY;
trickles-userapi_1.c:24064:# 2791 "trickles-userapi.c"
trickles-userapi_1.c:24083:                err = -22;
trickles-userapi_1.c:24091:        sk = sock->sk;
trickles-userapi_1.c:24093:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->lock.users != 0) __lock_sock(sk); (sk)->lock.users = 1; do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:24095:        if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && ((sk)->state == TCP_LISTEN))) {
trickles-userapi_1.c:24097:                err = -22;
trickles-userapi_1.c:24101:        tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:24104:        int origFreeLen = tp->cminisock_api_config.msk_freelist.len;
trickles-userapi_1.c:24106:        if(!(({ unsigned long flag,sum; asm("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0" :"=&r" (flag), "=r" (sum) :"1" (descbuf),"g" ((int)(descbuf_len)),"g" (get_current()->addr_limit.seg)); flag; }) == 0)) {
trickles-userapi_1.c:24108:                err = -14;
trickles-userapi_1.c:24111:        if(!(({ unsigned long flag,sum; asm("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0" :"=&r" (flag), "=r" (sum) :"1" (dest),"g" ((int)(*destLen)),"g" (get_current()->addr_limit.seg)); flag; }) == 0)) {
trickles-userapi_1.c:24113:                err = -14;
trickles-userapi_1.c:24129:        struct HMAC_CTX hmac_ctx = *tp->t.hmacCTX;
trickles-userapi_1.c:24138:        while((char*)currentInputDesc - (char*) descbuf < descbuf_len) {
trickles-userapi_1.c:24145:                if(!({ struct tcp_opt *_tp = &((sk)->tp_pinfo.af_tcp); (((((char*)((msk)) - (char*)((_tp)->cminisock_api_config.cfg.ctl->minisock_base)) % sizeof(struct cminisock)) == 0) && (((void*)((struct cminisock *)((msk)))) >= ((void*)((_tp)->cminisock_api_config.cfg.ctl->minisock_base)) && ((void*)((struct cminisock *)((msk)) + 1)) <= ((_tp)->cminisock_api_config.cfg.ctl->minisock_limit))) && (((msk))->ctl == ALLOC_READY || ((msk))->ctl == ALLOC_HALFFREE); })) {
trickles-userapi_1.c:24146:                        printk("Invalid msk in descbuf list, %d %d\n", (((((char*)((msk)) - (char*)((tp)->cminisock_api_config.cfg.ctl->minisock_base)) % sizeof(struct cminisock)) == 0) && (((void*)((struct cminisock *)((msk)))) >= ((void*)((tp)->cminisock_api_config.cfg.ctl->minisock_base)) && ((void*)((struct cminisock *)((msk)) + 1)) <= ((tp)->cminisock_api_config.cfg.ctl->minisock_limit))), (((((char*)((msk)) - (char*)((tp)->cminisock_api_config.cfg.ctl->minisock_base)) % sizeof(struct cminisock)) == 0) && (((void*)((struct cminisock *)((msk)))) >= ((void*)((tp)->cminisock_api_config.cfg.ctl->minisock_base)) && ((void*)((struct cminisock *)((msk)) + 1)) <= ((tp)->cminisock_api_config.cfg.ctl->minisock_limit))) && (((msk))->ctl == ALLOC_READY || ((msk))->ctl == ALLOC_HALFFREE));
trickles-userapi_1.c:24147:                        err = -22;
trickles-userapi_1.c:24150:                if(msk->ctl != ALLOC_READY) {
trickles-userapi_1.c:24152:                        err = -22;
trickles-userapi_1.c:24159:                                if(err == (-1)) {
trickles-userapi_1.c:24168:                                if (!(err == (-2))) { printk("KERNEL: assertion (" "err == MSK_ERROR" ") failed at " "trickles-userapi.c" "(%d)\n", 2894); };
trickles-userapi_1.c:24169:                                if(err == (-2)) {
trickles-userapi_1.c:24177:                        msk->ctl = ALLOC_HALFFREE;
trickles-userapi_1.c:24180:                        if(msk->ctl != ALLOC_HALFFREE) {
trickles-userapi_1.c:24181:                                printk("Dealloc called on an msk that is not half-freed\n");
trickles-userapi_1.c:24182:                                err = -22;
trickles-userapi_1.c:24194:        (__builtin_constant_p(16) ? __constant_copy_to_user_nocheck((outputCollection->hmac),(hmac),(16)) : __generic_copy_to_user_nocheck((outputCollection->hmac),(hmac),(16)));
trickles-userapi_1.c:24195:        outputCollection->len = *destLen = lbb.curr - lbb.start;
trickles-userapi_1.c:24201:        printk("Starting instant self-test\n");
trickles-userapi_1.c:24210:        if (!(lbb_get_offset(&lbb) == 0)) { printk("KERNEL: assertion (" "lbb_get_offset(&lbb) == 0" ") failed at " "trickles-userapi.c" "(%d)\n", 2936); };
trickles-userapi_1.c:24214:        struct HMAC_CTX test_hmac_ctx = *tp->t.hmacCTX;
trickles-userapi_1.c:24219:        int hmac_len = lbb_get_end(&lbb) - lbb_get_pos(&lbb);
trickles-userapi_1.c:24229:# 2965 "trickles-userapi.c"
trickles-userapi_1.c:24241:                        if (!(toFree != (struct cminisock*)&new_msk_list)) { printk("KERNEL: assertion (" "toFree != (struct cminisock*)&new_msk_list" ") failed at " "trickles-userapi.c" "(%d)\n", 2976); };
trickles-userapi_1.c:24250:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:24254:                printk("FreeLoop(%d %d) After extract free list length %d=>%d\n", hitFreeLoop, err, origFreeLen, tp->cminisock_api_config.msk_freelist.len);
trickles-userapi_1.c:24259:# 3010 "trickles-userapi.c"
trickles-userapi_1.c:24267:        int err = -1;
trickles-userapi_1.c:24273:                err = -22;
trickles-userapi_1.c:24279:                err = -22;
trickles-userapi_1.c:24283:        sk = sock->sk;
trickles-userapi_1.c:24284:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->lock.users != 0) __lock_sock(sk); (sk)->lock.users = 1; do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:24286:        if(!(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && ((sk)->state == TCP_LISTEN))) {
trickles-userapi_1.c:24288:                err = -22;
trickles-userapi_1.c:24292:        tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:24293:        int origFreeLen = tp->cminisock_api_config.msk_freelist.len;
trickles-userapi_1.c:24297:        if(!(({ unsigned long flag,sum; asm("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0" :"=&r" (flag), "=r" (sum) :"1" (descbuf),"g" ((int)(descbuf_len)),"g" (get_current()->addr_limit.seg)); flag; }) == 0)) {
trickles-userapi_1.c:24299:                err = -14;
trickles-userapi_1.c:24308:                int remaining = descbuf_len - (inputPosition - (char*)descbuf);
trickles-userapi_1.c:24316:                do { if((inputCollection) == ((void *)0)) { printk("install_event -- descbuf too short for " "inputCollection" "\n"); err = -22; goto out_put; } } while(0);
trickles-userapi_1.c:24318:                if (!(&inputCollection->descs[0] == lbb_get_pos(&lbb))) { printk("KERNEL: assertion (" "&inputCollection->descs[0] == lbb_get_pos(&lbb)" ") failed at " "trickles-userapi.c" "(%d)\n", 3068); };
trickles-userapi_1.c:24323:                ({ long __gu_err, __gu_val; do { __gu_err = 0; switch ((sizeof(*(&inputCollection->len)))) { case 1: __asm__ __volatile__( "1:	mov""b"" %2,%""b""1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor""b"" %""b""1,%""b""1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__gu_err), "=q" (__gu_val) : "m"((*(struct __large_struct *)(((&inputCollection->len))))), "i"(-14), "0"(__gu_err)); break; case 2: __asm__ __volatile__( "1:	mov""w"" %2,%""w""1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor""w"" %""w""1,%""w""1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__gu_err), "=r" (__gu_val) : "m"((*(struct __large_struct *)(((&inputCollection->len))))), "i"(-14), "0"(__gu_err)); break; case 4: __asm__ __volatile__( "1:	mov""l"" %2,%""""1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor""l"" %""""1,%""""1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous" : "=r"(__gu_err), "=r" (__gu_val) : "m"((*(struct __large_struct *)(((&inputCollection->len))))), "i"(-14), "0"(__gu_err)); break; default: (__gu_val) = __get_user_bad(); } } while (0); ((collectionLen)) = (__typeof__(*((&inputCollection->len))))__gu_val; __gu_err; });
trickles-userapi_1.c:24326:                        err = -22;
trickles-userapi_1.c:24335:                (__builtin_constant_p(16) ? __constant_copy_from_user_nocheck((input_hmac),(inputCollection->hmac),(16)) : __generic_copy_from_user_nocheck((input_hmac),(inputCollection->hmac),(16)));
trickles-userapi_1.c:24337:                struct HMAC_CTX hmac_ctx = *tp->t.hmacCTX;
trickles-userapi_1.c:24340:                int hmac_len = lbb_get_end(&lbb) - lbb_get_pos(&lbb);
trickles-userapi_1.c:24349:                        err = -22;
trickles-userapi_1.c:24354:                        err = -22;
trickles-userapi_1.c:24359:                if (!(inputPosition == lbb_get_pos(&lbb))) { printk("KERNEL: assertion (" "inputPosition == lbb_get_pos(&lbb)" ") failed at " "trickles-userapi.c" "(%d)\n", 3109); };
trickles-userapi_1.c:24367:                if (!(relink != (struct cminisock*)&new_msk_list)) { printk("KERNEL: assertion (" "relink != (struct cminisock*)&new_msk_list" ") failed at " "trickles-userapi.c" "(%d)\n", 3117); };
trickles-userapi_1.c:24370:                relink->sk = sk;
trickles-userapi_1.c:24371:                if (!(({ struct tcp_opt *_tp = &((sk)->tp_pinfo.af_tcp); (((((char*)((relink)) - (char*)((_tp)->cminisock_api_config.cfg.ctl->minisock_base)) % sizeof(struct cminisock)) == 0) && (((void*)((struct cminisock *)((relink)))) >= ((void*)((_tp)->cminisock_api_config.cfg.ctl->minisock_base)) && ((void*)((struct cminisock *)((relink)) + 1)) <= ((_tp)->cminisock_api_config.cfg.ctl->minisock_limit))) && (((relink))->ctl == ALLOC_READY || ((relink))->ctl == ALLOC_HALFFREE); }))) { printk("KERNEL: assertion (" "IS_VALID_MSK(sk, relink)" ") failed at " "trickles-userapi.c" "(%d)\n", 3121); };
trickles-userapi_1.c:24372:                switch(relink->ctl) {
trickles-userapi_1.c:24374:                        insert_tail(&tp->cminisock_api_config.cfg.ctl->msk_eventlist, (struct alloc_head *)relink);
trickles-userapi_1.c:24383:                        printk("Unhandled ctl state %d in installed event\n", relink->ctl);
trickles-userapi_1.c:24386:                        err = -22;
trickles-userapi_1.c:24389:                if(!((relink)->list == &(tp)->cminisock_api_config.msk_freelist || (relink)->list == &(tp)->cminisock_api_config.cfg.ctl->msk_eventlist)) {
trickles-userapi_1.c:24390:                        printk("Relink Msk %p not on valid list (list = %p)\n", relink, relink->list);
trickles-userapi_1.c:24395:        do { do { do { ((void)((0)), irq_stat[0].__local_bh_count)++; __asm__ __volatile__("": : :"memory"); } while (0); (void)(&((sk)->lock.slock)); } while (0); if ((sk)->backlog.tail != ((void *)0)) __release_sock(sk); (sk)->lock.users = 0; if (waitqueue_active(&((sk)->lock.wq))) __wake_up((&((sk)->lock.wq)),2 | 1, 1); do { do { } while(0); do { unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__("": : :"memory"); if (!--*ptr) __asm__ __volatile__ ( "cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t" : : "r" (ptr), "i" (do_softirq) ); } while (0); } while (0); } while(0);
trickles-userapi_1.c:24404:                                if (!(toFree != (struct cminisock*)&new_msk_list)) { printk("KERNEL: assertion (" "toFree != (struct cminisock*)&new_msk_list" ") failed at " "trickles-userapi.c" "(%d)\n", 3154); };
trickles-userapi_1.c:24406:                                if(toFree->list != &new_msk_list) {
trickles-userapi_1.c:24412:                                if (!(toFree->list == &tp->cminisock_api_config.msk_freelist)) { printk("KERNEL: assertion (" "toFree->list == &tp->cminisock_api_config.msk_freelist" ") failed at " "trickles-userapi.c" "(%d)\n", 3162); };
trickles-userapi_1.c:24415:                printk("Free list length %d\n", tp->cminisock_api_config.msk_freelist.len);
trickles-userapi_1.c:24416:                printk("After insert free list length %d=>%d\n", origFreeLen, tp->cminisock_api_config.msk_freelist.len);
trickles-userapi_1.c:24438:                        err = -12;
trickles-userapi_1.c:24444:                        msk->prev = ((void *)0);
trickles-userapi_1.c:24445:                        msk->next = ((void *)0);
trickles-userapi_1.c:24446:                        msk->list = ((void *)0);
trickles-userapi_1.c:24450:                        err = -22;
trickles-userapi_1.c:24453:                msk->prev = ((void *)0);
trickles-userapi_1.c:24454:                msk->next = ((void *)0);
trickles-userapi_1.c:24455:                msk->list = ((void *)0);
trickles-userapi_1.c:24461:        if (!(actual_end <= desc_end)) { printk("KERNEL: assertion (" "actual_end <= desc_end" ") failed at " "trickles-userapi.c" "(%d)\n", 3211); };
trickles-userapi_1.c:24473:        if((((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1) && ((sk)->state == TCP_LISTEN))) {
trickles-userapi_1.c:24474:                struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_1.c:24475:                struct trickles_mmap_ctl *ctl = tp->cminisock_api_config.cfg.ctl;
trickles-userapi_1.c:24478:                void *freeList = &tp->cminisock_api_config.msk_freelist;
trickles-userapi_1.c:24479:                void *eventList = &ctl->msk_eventlist;
trickles-userapi_1.c:24480:                for(msk = ctl->minisock_base; (void*)(msk+1) < (void*)ctl->minisock_limit; msk++) {
trickles-userapi_1.c:24483:                        if(msk->list == freeList) {
trickles-userapi_1.c:24485:                        } else if(msk->list == eventList) {
trickles-userapi_1.c:24491:                        switch(msk->ctl) {
trickles-userapi_1.c:24500:                                       listName, msk->list);
trickles-userapi_2.c:521:  char _f[20 - 2 * sizeof (long) - sizeof (int)];
trickles-userapi_2.c:850:  size = (size - 1) >> (12 - 1);
trickles-userapi_2.c:851:  order = -1;
trickles-userapi_2.c:1126:  return ((unsigned long *) t->esp)[3];
trickles-userapi_2.c:1209:  next->prev = new;
trickles-userapi_2.c:1210:  new->next = next;
trickles-userapi_2.c:1211:  new->prev = prev;
trickles-userapi_2.c:1212:  prev->next = new;
trickles-userapi_2.c:1219:  __list_add (new, head, head->next);
trickles-userapi_2.c:1226:  __list_add (new, head->prev, head);
trickles-userapi_2.c:1233:  next->prev = prev;
trickles-userapi_2.c:1234:  prev->next = next;
trickles-userapi_2.c:1245:  __list_del (entry->prev, entry->next);
trickles-userapi_2.c:1246:  entry->next = (void *) 0;
trickles-userapi_2.c:1247:  entry->prev = (void *) 0;
trickles-userapi_2.c:1257:  __list_del (entry->prev, entry->next);
trickles-userapi_2.c:1260:      (entry)->next = (entry);
trickles-userapi_2.c:1261:      (entry)->prev = (entry);
trickles-userapi_2.c:1274:  __list_del (list->prev, list->next);
trickles-userapi_2.c:1286:  __list_del (list->prev, list->next);
trickles-userapi_2.c:1297:  return head->next == head;
trickles-userapi_2.c:1303:  struct list_head *first = list->next;
trickles-userapi_2.c:1304:  struct list_head *last = list->prev;
trickles-userapi_2.c:1305:  struct list_head *at = head->next;
trickles-userapi_2.c:1307:  first->prev = head;
trickles-userapi_2.c:1308:  head->next = first;
trickles-userapi_2.c:1310:  last->next = at;
trickles-userapi_2.c:1311:  at->prev = last;
trickles-userapi_2.c:1335:	  (list)->next = (list);
trickles-userapi_2.c:1336:	  (list)->prev = (list);
trickles-userapi_2.c:1570:  __asm__ __volatile__ ("movl $-1,%%eax\n\t"
trickles-userapi_2.c:1574:			"xorl -4(%%edi),%%eax\n\t"
trickles-userapi_2.c:1605:      if (set < (32 - bit))
trickles-userapi_2.c:1607:      set = 32 - bit;
trickles-userapi_2.c:1613:  res = find_first_zero_bit (p, size - 32 * (p - (unsigned long *) addr));
trickles-userapi_2.c:1636:__asm__ ("bsfl %1,%0\n\t" "jnz 1f\n\t" "movl $-1,%0\n" "1:": "=r" (r):"rm" (x));
trickles-userapi_2.c:1801:  q->lock = (spinlock_t)
trickles-userapi_2.c:1806:      (&q->task_list)->next = (&q->task_list);
trickles-userapi_2.c:1807:      (&q->task_list)->prev = (&q->task_list);
trickles-userapi_2.c:1823:  q->flags = 0;
trickles-userapi_2.c:1824:  q->task = p;
trickles-userapi_2.c:1839:  return !list_empty (&q->task_list);
trickles-userapi_2.c:1846:  list_add (&new->task_list, &head->task_list);
trickles-userapi_2.c:1856:  list_add_tail (&new->task_list, &head->task_list);
trickles-userapi_2.c:1867:  list_del (&old->task_list);
trickles-userapi_2.c:1911:  char __data[128 - sizeof (unsigned short)];
trickles-userapi_2.c:1986:			(((__cmsg->cmsg_len) + sizeof (long) -
trickles-userapi_2.c:1987:			  1) & ~(sizeof (long) - 1)));
trickles-userapi_2.c:1988:  if ((unsigned long) ((char *) (__ptr + 1) - (char *) __ctl) > __size)
trickles-userapi_2.c:1997:  return __cmsg_nxthdr (__msg->msg_control, __msg->msg_controllen, __cmsg);
trickles-userapi_2.c:2144:    ((unsigned int) ((dev) & ((1U << 8) - 1)));
trickles-userapi_2.c:2183:  __asm__ __volatile__ ("" "addl %1,%0":"=m" (v->counter):"ir" (i),
trickles-userapi_2.c:2184:			"m" (v->counter));
trickles-userapi_2.c:2191:  __asm__ __volatile__ ("" "subl %1,%0":"=m" (v->counter):"ir" (i),
trickles-userapi_2.c:2192:			"m" (v->counter));
trickles-userapi_2.c:2201:  __asm__ __volatile__ ("" "subl %2,%0; sete %1":"=m" (v->counter),
trickles-userapi_2.c:2202:			"=qm" (c):"ir" (i), "m" (v->counter):"memory");
trickles-userapi_2.c:2210:  __asm__ __volatile__ ("" "incl %0":"=m" (v->counter):"m" (v->counter));
trickles-userapi_2.c:2217:  __asm__ __volatile__ ("" "decl %0":"=m" (v->counter):"m" (v->counter));
trickles-userapi_2.c:2226:  __asm__ __volatile__ ("" "decl %0; sete %1":"=m" (v->counter),
trickles-userapi_2.c:2227:			"=qm" (c):"m" (v->counter):"memory");
trickles-userapi_2.c:2237:  __asm__ __volatile__ ("" "incl %0; sete %1":"=m" (v->counter),
trickles-userapi_2.c:2238:			"=qm" (c):"m" (v->counter):"memory");
trickles-userapi_2.c:2248:  __asm__ __volatile__ ("" "addl %2,%0; sets %1":"=m" (v->counter),
trickles-userapi_2.c:2249:			"=qm" (c):"ir" (i), "m" (v->counter):"memory");
trickles-userapi_2.c:2439:    atomic_inc (&mnt->mnt_count);
trickles-userapi_2.c:2450:      if (atomic_dec_and_test (&mnt->mnt_count))
trickles-userapi_2.c:2497:  while (len--)
trickles-userapi_2.c:2541:  list_del (&dentry->d_hash);
trickles-userapi_2.c:2544:      (&dentry->d_hash)->next = (&dentry->d_hash);
trickles-userapi_2.c:2545:      (&dentry->d_hash)->prev = (&dentry->d_hash);
trickles-userapi_2.c:2557:  return d->d_name.name != d->d_iname;
trickles-userapi_2.c:2626:      if (!((&dentry->d_count)->counter))
trickles-userapi_2.c:2628:      atomic_inc (&dentry->d_count);
trickles-userapi_2.c:2638:  return list_empty (&dentry->d_hash);
trickles-userapi_2.c:2646:  return dentry->d_mounted;
trickles-userapi_2.c:2895:			"leal -1(%%esi),%0\n"
trickles-userapi_2.c:3024:__asm__ __volatile__ ("std\n\t" "rep\n\t" "movsb\n\t" "cld": "=&c" (d0), "=&S" (d1), "=&D" (d2): "0" (n), "1" (n - 1 + (const char *) src), "2" (n - 1 + (char *) dest):"memory");
trickles-userapi_2.c:3087:			"cmpl $-1,%1\n\t"
trickles-userapi_2.c:3237:  sem->count = 0x00000000;
trickles-userapi_2.c:3244:      (&sem->wait_list)->next = (&sem->wait_list);
trickles-userapi_2.c:3245:      (&sem->wait_list)->prev = (&sem->wait_list);
trickles-userapi_2.c:3270:			"# ending down_read\n\t":"+m" (sem->
trickles-userapi_2.c:3291:			"# ending __down_read_trylock\n\t":"+m" (sem->
trickles-userapi_2.c:3306:  tmp = ((-0x00010000) + 0x00000001);
trickles-userapi_2.c:3318:			"+m" (sem->count):"a" (sem):"memory", "cc");
trickles-userapi_2.c:3328:    ((__typeof__ (*(&sem->count)))
trickles-userapi_2.c:3329:     __cmpxchg ((&sem->count), (unsigned long) (0x00000000),
trickles-userapi_2.c:3330:		(unsigned long) (((-0x00010000) + 0x00000001)),
trickles-userapi_2.c:3331:		sizeof (*(&sem->count))));
trickles-userapi_2.c:3345:  __s32 tmp = -0x00000001;
trickles-userapi_2.c:3356:			"# ending __up_read\n":"+m" (sem->count),
trickles-userapi_2.c:3377:			"# ending __up_write\n":"+m" (sem->count):"a" (sem),
trickles-userapi_2.c:3378:			"i" (-((-0x00010000) + 0x00000001)):"memory", "cc",
trickles-userapi_2.c:3388:  __asm__ __volatile__ ("" "addl %1,%0":"=m" (sem->count):"ir" (delta),
trickles-userapi_2.c:3389:			"m" (sem->count));
trickles-userapi_2.c:3401:			"=m" (sem->count):"r" (sem),
trickles-userapi_2.c:3402:			"m" (sem->count):"memory");
trickles-userapi_2.c:3497:  (((&sem->count)->counter) = (val));
trickles-userapi_2.c:3498:  sem->sleepers = 0;
trickles-userapi_2.c:3499:  init_waitqueue_head (&sem->wait);
trickles-userapi_2.c:3553:			".previous\n\t":"=m" (sem->count):"c" (sem):"memory");
trickles-userapi_2.c:3579:			"=m" (sem->count):"c" (sem):"memory");
trickles-userapi_2.c:3605:			"=m" (sem->count):"c" (sem):"memory");
trickles-userapi_2.c:3628:			".previous\n\t" ".subsection 0\n":"=m" (sem->
trickles-userapi_2.c:3636:  return ((&sem->count)->counter);
trickles-userapi_2.c:4302:  unsigned long sec = value->tv_sec;
trickles-userapi_2.c:4303:  long nsec = value->tv_nsec;
trickles-userapi_2.c:4305:  if (sec >= (((~0UL >> 1) - 1) / 100))
trickles-userapi_2.c:4306:    return ((~0UL >> 1) - 1);
trickles-userapi_2.c:4307:  nsec += 1000000000L / 100 - 1;
trickles-userapi_2.c:4315:  value->tv_nsec = (jiffies % 100) * (1000000000L / 100);
trickles-userapi_2.c:4316:  value->tv_sec = jiffies / 100;
trickles-userapi_2.c:4325:  if (0 >= (int) (mon -= 2))
trickles-userapi_2.c:4328:      year -= 1;
trickles-userapi_2.c:4331:  return ((((unsigned long) (year / 4 - year / 100 + year / 400 +
trickles-userapi_2.c:4332:			     367 * mon / 12 + day) + year * 365 -
trickles-userapi_2.c:4520:  if (fid->Vnode == 0xfffffffe || fid->Vnode == 0xffffffff)
trickles-userapi_2.c:4521:    return ((fid->Volume << 20) | (fid->Unique & 0xfffff));
trickles-userapi_2.c:4523:    return (fid->Unique + (fid->Vnode << 10) + (fid->Volume << 20));
trickles-userapi_2.c:5623:  info->dqi_flags |= 0x10000;
trickles-userapi_2.c:5735:      return dqopt->flags & 0x01;
trickles-userapi_2.c:5737:      return dqopt->flags & 0x02;
trickles-userapi_2.c:5910:  inode->i_blocks += bytes >> 9;
trickles-userapi_2.c:5912:  inode->i_bytes += bytes;
trickles-userapi_2.c:5913:  if (inode->i_bytes >= 512)
trickles-userapi_2.c:5915:      inode->i_blocks++;
trickles-userapi_2.c:5916:      inode->i_bytes -= 512;
trickles-userapi_2.c:5923:  inode->i_blocks -= bytes >> 9;
trickles-userapi_2.c:5925:  if (inode->i_bytes < bytes)
trickles-userapi_2.c:5927:      inode->i_blocks--;
trickles-userapi_2.c:5928:      inode->i_bytes += 512;
trickles-userapi_2.c:5930:  inode->i_bytes -= bytes;
trickles-userapi_2.c:5936:  return (((loff_t) inode->i_blocks) << 9) + inode->i_bytes;
trickles-userapi_2.c:5942:  inode->i_blocks = bytes >> 9;
trickles-userapi_2.c:5943:  inode->i_bytes = bytes & 511;
trickles-userapi_2.c:6174:  timer->list.next = timer->list.prev = ((void *) 0);
trickles-userapi_2.c:6180:  return timer->list.next != ((void *) 0);
trickles-userapi_2.c:7082:  __s8 fs_fsmnt[512 - 212];
trickles-userapi_2.c:7334:  down (&(server->sem));
trickles-userapi_2.c:7340:  up (&(server->sem));
trickles-userapi_2.c:7538:  if (!test_and_set_bit (0, &bh_pointer->sync))
trickles-userapi_2.c:7552:      list_add_tail (&bh_pointer->list, bh_list);
trickles-userapi_2.c:8158:  return ((server->conn_status & 0x11) == 0);
trickles-userapi_2.c:8164:  server->conn_status |= 0x01;
trickles-userapi_2.c:8210:  x->done = 0;
trickles-userapi_2.c:8211:  init_waitqueue_head (&x->wait);
trickles-userapi_2.c:8518:  if ((((inode)->i_sb->s_flags & (64))
trickles-userapi_2.c:8519:       && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
trickles-userapi_2.c:8528:  if (inode->i_flock
trickles-userapi_2.c:8529:      && (((inode)->i_sb->s_flags & (64))
trickles-userapi_2.c:8530:	  && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
trickles-userapi_2.c:8538:  if (inode->i_flock
trickles-userapi_2.c:8539:      && (((inode)->i_sb->s_flags & (64))
trickles-userapi_2.c:8540:	  && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
trickles-userapi_2.c:8542:				 size < inode->i_size ? size : inode->i_size,
trickles-userapi_2.c:8544:				  inode->i_size ? inode->i_size -
trickles-userapi_2.c:8545:				  size : size - inode->i_size));
trickles-userapi_2.c:8552:  if (inode->i_flock)
trickles-userapi_2.c:8639:  atomic_inc (&(bh)->b_count);
trickles-userapi_2.c:8646:  atomic_dec (&bh->b_count);
trickles-userapi_2.c:8656:    set_bit (BH_Uptodate, &bh->b_state);
trickles-userapi_2.c:8658:    clear_bit (BH_Uptodate, &bh->b_state);
trickles-userapi_2.c:8672:  if (test_and_clear_bit (BH_Dirty, &(bh)->b_state))
trickles-userapi_2.c:8689:  buffer_insert_list (bh, &inode->i_dirty_buffers);
trickles-userapi_2.c:8695:  buffer_insert_list (bh, &inode->i_dirty_data_buffers);
trickles-userapi_2.c:8701:  return test_and_set_bit (BH_Dirty, &bh->b_state);
trickles-userapi_2.c:8708:    set_bit (BH_Async, &bh->b_state);
trickles-userapi_2.c:8710:    clear_bit (BH_Async, &bh->b_state);
trickles-userapi_2.c:8716:  set_bit (BH_Attached, &bh->b_state);
trickles-userapi_2.c:8722:  clear_bit (BH_Attached, &bh->b_state);
trickles-userapi_2.c:8730:			     (&bh->
trickles-userapi_2.c:8732:							     (&bh->b_state)));
trickles-userapi_2.c:8748:  bh->b_end_io (bh, 0);
trickles-userapi_2.c:8784:  return fsync_buffers_list (&inode->i_dirty_buffers);
trickles-userapi_2.c:8789:  return fsync_buffers_list (&inode->i_dirty_data_buffers);
trickles-userapi_2.c:8806:  atomic_dec (&inode->i_writecount);
trickles-userapi_2.c:8812:    atomic_inc (&file->f_dentry->d_inode->i_writecount);
trickles-userapi_2.c:8840:  return (unsigned long) ptr > (unsigned long) -1000L;
trickles-userapi_2.c:8900:  if (inode && (inode->i_state & 64))
trickles-userapi_2.c:8905:      if (sb->s_op->read_inode2)
trickles-userapi_2.c:8906:	sb->s_op->read_inode2 (inode, opaque);
trickles-userapi_2.c:8908:	sb->s_op->read_inode (inode);
trickles-userapi_2.c:8920:  if (inode && (inode->i_state & 64))
trickles-userapi_2.c:8922:      sb->s_op->read_inode (inode);
trickles-userapi_2.c:8969:  return bread (sb->s_dev, block, sb->s_blocksize);
trickles-userapi_2.c:8974:  return getblk (sb->s_dev, block, sb->s_blocksize);
trickles-userapi_2.c:8979:  return get_hash_table (sb->s_dev, block, sb->s_blocksize);
trickles-userapi_2.c:9104:  struct dentry *dir = dget (dentry->d_parent);
trickles-userapi_2.c:9106:  down (&dir->d_inode->i_sem);
trickles-userapi_2.c:9113:  return dget (dentry->d_parent);
trickles-userapi_2.c:9119:  up (&dir->d_inode->i_sem);
trickles-userapi_2.c:9211:  double_down (&d1->d_inode->i_sem, &d2->d_inode->i_sem);
trickles-userapi_2.c:9217:  double_up (&d1->d_inode->i_sem, &d2->d_inode->i_sem);
trickles-userapi_2.c:9464:  node->rb_parent = parent;
trickles-userapi_2.c:9465:  node->rb_color = 0;
trickles-userapi_2.c:9466:  node->rb_left = node->rb_right = ((void *) 0);
trickles-userapi_2.c:10100:__asm__ ("btsl %1,%0": "=m" (*set): "Ir" (_sig - 1):"cc");
trickles-userapi_2.c:10106:__asm__ ("btrl %1,%0": "=m" (*set): "Ir" (_sig - 1):"cc");
trickles-userapi_2.c:10112:  unsigned long sig = _sig - 1;
trickles-userapi_2.c:10113:  return 1 & (set->sig[sig / 32] >> (sig % 32));
trickles-userapi_2.c:10120:__asm__ ("btl %2,%1\n\tsbbl %0,%0": "=r" (ret): "m" (*set), "Ir" (_sig - 1):"cc");
trickles-userapi_2.c:10158:    int _pad[((128 / sizeof (int)) - 3)];
trickles-userapi_2.c:10214:    int _pad[((64 / sizeof (int)) - 3)];
trickles-userapi_2.c:10233:  if (from->si_code < 0)
trickles-userapi_2.c:10243:      sizeof (from->_sifields._sigchld)) ? __constant_memcpy ((to), (from),
trickles-userapi_2.c:10246:							       sizeof (from->
trickles-userapi_2.c:10250:		 (3 * sizeof (int) + sizeof (from->_sifields._sigchld))));
trickles-userapi_2.c:10280:      a0 = a->sig[4 * i + 0];
trickles-userapi_2.c:10281:      a1 = a->sig[4 * i + 1];
trickles-userapi_2.c:10282:      a2 = a->sig[4 * i + 2];
trickles-userapi_2.c:10283:      a3 = a->sig[4 * i + 3];
trickles-userapi_2.c:10284:      b0 = b->sig[4 * i + 0];
trickles-userapi_2.c:10285:      b1 = b->sig[4 * i + 1];
trickles-userapi_2.c:10286:      b2 = b->sig[4 * i + 2];
trickles-userapi_2.c:10287:      b3 = b->sig[4 * i + 3];
trickles-userapi_2.c:10288:      r->sig[4 * i + 0] = ((a0) | (b0));
trickles-userapi_2.c:10289:      r->sig[4 * i + 1] = ((a1) | (b1));
trickles-userapi_2.c:10290:      r->sig[4 * i + 2] = ((a2) | (b2));
trickles-userapi_2.c:10291:      r->sig[4 * i + 3] = ((a3) | (b3));
trickles-userapi_2.c:10296:      a0 = a->sig[4 * i + 0];
trickles-userapi_2.c:10297:      a1 = a->sig[4 * i + 1];
trickles-userapi_2.c:10298:      a2 = a->sig[4 * i + 2];
trickles-userapi_2.c:10299:      b0 = b->sig[4 * i + 0];
trickles-userapi_2.c:10300:      b1 = b->sig[4 * i + 1];
trickles-userapi_2.c:10301:      b2 = b->sig[4 * i + 2];
trickles-userapi_2.c:10302:      r->sig[4 * i + 0] = ((a0) | (b0));
trickles-userapi_2.c:10303:      r->sig[4 * i + 1] = ((a1) | (b1));
trickles-userapi_2.c:10304:      r->sig[4 * i + 2] = ((a2) | (b2));
trickles-userapi_2.c:10307:      a0 = a->sig[4 * i + 0];
trickles-userapi_2.c:10308:      a1 = a->sig[4 * i + 1];
trickles-userapi_2.c:10309:      b0 = b->sig[4 * i + 0];
trickles-userapi_2.c:10310:      b1 = b->sig[4 * i + 1];
trickles-userapi_2.c:10311:      r->sig[4 * i + 0] = ((a0) | (b0));
trickles-userapi_2.c:10312:      r->sig[4 * i + 1] = ((a1) | (b1));
trickles-userapi_2.c:10315:      a0 = a->sig[4 * i + 0];
trickles-userapi_2.c:10316:      b0 = b->sig[4 * i + 0];
trickles-userapi_2.c:10317:      r->sig[4 * i + 0] = ((a0) | (b0));
trickles-userapi_2.c:10330:      a0 = a->sig[4 * i + 0];
trickles-userapi_2.c:10331:      a1 = a->sig[4 * i + 1];
trickles-userapi_2.c:10332:      a2 = a->sig[4 * i + 2];
trickles-userapi_2.c:10333:      a3 = a->sig[4 * i + 3];
trickles-userapi_2.c:10334:      b0 = b->sig[4 * i + 0];
trickles-userapi_2.c:10335:      b1 = b->sig[4 * i + 1];
trickles-userapi_2.c:10336:      b2 = b->sig[4 * i + 2];
trickles-userapi_2.c:10337:      b3 = b->sig[4 * i + 3];
trickles-userapi_2.c:10338:      r->sig[4 * i + 0] = ((a0) & (b0));
trickles-userapi_2.c:10339:      r->sig[4 * i + 1] = ((a1) & (b1));
trickles-userapi_2.c:10340:      r->sig[4 * i + 2] = ((a2) & (b2));
trickles-userapi_2.c:10341:      r->sig[4 * i + 3] = ((a3) & (b3));
trickles-userapi_2.c:10346:      a0 = a->sig[4 * i + 0];
trickles-userapi_2.c:10347:      a1 = a->sig[4 * i + 1];
trickles-userapi_2.c:10348:      a2 = a->sig[4 * i + 2];
trickles-userapi_2.c:10349:      b0 = b->sig[4 * i + 0];
trickles-userapi_2.c:10350:      b1 = b->sig[4 * i + 1];
trickles-userapi_2.c:10351:      b2 = b->sig[4 * i + 2];
trickles-userapi_2.c:10352:      r->sig[4 * i + 0] = ((a0) & (b0));
trickles-userapi_2.c:10353:      r->sig[4 * i + 1] = ((a1) & (b1));
trickles-userapi_2.c:10354:      r->sig[4 * i + 2] = ((a2) & (b2));
trickles-userapi_2.c:10357:      a0 = a->sig[4 * i + 0];
trickles-userapi_2.c:10358:      a1 = a->sig[4 * i + 1];
trickles-userapi_2.c:10359:      b0 = b->sig[4 * i + 0];
trickles-userapi_2.c:10360:      b1 = b->sig[4 * i + 1];
trickles-userapi_2.c:10361:      r->sig[4 * i + 0] = ((a0) & (b0));
trickles-userapi_2.c:10362:      r->sig[4 * i + 1] = ((a1) & (b1));
trickles-userapi_2.c:10365:      a0 = a->sig[4 * i + 0];
trickles-userapi_2.c:10366:      b0 = b->sig[4 * i + 0];
trickles-userapi_2.c:10367:      r->sig[4 * i + 0] = ((a0) & (b0));
trickles-userapi_2.c:10380:      a0 = a->sig[4 * i + 0];
trickles-userapi_2.c:10381:      a1 = a->sig[4 * i + 1];
trickles-userapi_2.c:10382:      a2 = a->sig[4 * i + 2];
trickles-userapi_2.c:10383:      a3 = a->sig[4 * i + 3];
trickles-userapi_2.c:10384:      b0 = b->sig[4 * i + 0];
trickles-userapi_2.c:10385:      b1 = b->sig[4 * i + 1];
trickles-userapi_2.c:10386:      b2 = b->sig[4 * i + 2];
trickles-userapi_2.c:10387:      b3 = b->sig[4 * i + 3];
trickles-userapi_2.c:10388:      r->sig[4 * i + 0] = ((a0) & ~(b0));
trickles-userapi_2.c:10389:      r->sig[4 * i + 1] = ((a1) & ~(b1));
trickles-userapi_2.c:10390:      r->sig[4 * i + 2] = ((a2) & ~(b2));
trickles-userapi_2.c:10391:      r->sig[4 * i + 3] = ((a3) & ~(b3));
trickles-userapi_2.c:10396:      a0 = a->sig[4 * i + 0];
trickles-userapi_2.c:10397:      a1 = a->sig[4 * i + 1];
trickles-userapi_2.c:10398:      a2 = a->sig[4 * i + 2];
trickles-userapi_2.c:10399:      b0 = b->sig[4 * i + 0];
trickles-userapi_2.c:10400:      b1 = b->sig[4 * i + 1];
trickles-userapi_2.c:10401:      b2 = b->sig[4 * i + 2];
trickles-userapi_2.c:10402:      r->sig[4 * i + 0] = ((a0) & ~(b0));
trickles-userapi_2.c:10403:      r->sig[4 * i + 1] = ((a1) & ~(b1));
trickles-userapi_2.c:10404:      r->sig[4 * i + 2] = ((a2) & ~(b2));
trickles-userapi_2.c:10407:      a0 = a->sig[4 * i + 0];
trickles-userapi_2.c:10408:      a1 = a->sig[4 * i + 1];
trickles-userapi_2.c:10409:      b0 = b->sig[4 * i + 0];
trickles-userapi_2.c:10410:      b1 = b->sig[4 * i + 1];
trickles-userapi_2.c:10411:      r->sig[4 * i + 0] = ((a0) & ~(b0));
trickles-userapi_2.c:10412:      r->sig[4 * i + 1] = ((a1) & ~(b1));
trickles-userapi_2.c:10415:      a0 = a->sig[4 * i + 0];
trickles-userapi_2.c:10416:      b0 = b->sig[4 * i + 0];
trickles-userapi_2.c:10417:      r->sig[4 * i + 0] = ((a0) & ~(b0));
trickles-userapi_2.c:10429:      set->sig[4 * i + 0] = (~(set->sig[4 * i + 0]));
trickles-userapi_2.c:10430:      set->sig[4 * i + 1] = (~(set->sig[4 * i + 1]));
trickles-userapi_2.c:10431:      set->sig[4 * i + 2] = (~(set->sig[4 * i + 2]));
trickles-userapi_2.c:10432:      set->sig[4 * i + 3] = (~(set->sig[4 * i + 3]));
trickles-userapi_2.c:10437:      set->sig[4 * i + 2] = (~(set->sig[4 * i + 2]));
trickles-userapi_2.c:10439:      set->sig[4 * i + 1] = (~(set->sig[4 * i + 1]));
trickles-userapi_2.c:10441:      set->sig[4 * i + 0] = (~(set->sig[4 * i + 0]));
trickles-userapi_2.c:10469:      set->sig[1] = 0;
trickles-userapi_2.c:10471:      set->sig[0] = 0;
trickles-userapi_2.c:10482:      (__builtin_constant_p (-1)
trickles-userapi_2.c:10486:					   (unsigned char) (-1))),
trickles-userapi_2.c:10489:			       ((0x01010101UL * (unsigned char) (-1))),
trickles-userapi_2.c:10492:	  __memset_generic ((((set))), (((-1))),
trickles-userapi_2.c:10494:	  __memset_generic (((set)), ((-1)), ((sizeof (sigset_t))))));
trickles-userapi_2.c:10497:      set->sig[1] = -1;
trickles-userapi_2.c:10499:      set->sig[0] = -1;
trickles-userapi_2.c:10511:  set->sig[0] |= mask;
trickles-userapi_2.c:10517:  set->sig[0] &= ~mask;
trickles-userapi_2.c:10523:  return (set->sig[0] & mask) != 0;
trickles-userapi_2.c:10529:  set->sig[0] = mask;
trickles-userapi_2.c:10534:       ? (__builtin_constant_p ((sizeof (long) * ((64 / 32) - 1))) ?
trickles-userapi_2.c:10535:	  __constant_c_and_count_memset (((&set->sig[1])),
trickles-userapi_2.c:10539:					   ((64 / 32) -
trickles-userapi_2.c:10541:	  __constant_c_memset (((&set->sig[1])),
trickles-userapi_2.c:10544:				 ((64 / 32) -
trickles-userapi_2.c:10546:       : (__builtin_constant_p ((sizeof (long) * ((64 / 32) - 1))) ?
trickles-userapi_2.c:10547:	  __memset_generic ((((&set->sig[1]))), (((0))),
trickles-userapi_2.c:10549:			       ((64 / 32) -
trickles-userapi_2.c:10550:				1))))) : __memset_generic (((&set->sig[1])),
trickles-userapi_2.c:10553:							     ((64 / 32) -
trickles-userapi_2.c:10557:      set->sig[1] = 0;
trickles-userapi_2.c:10565:  set->sig[0] = ~mask;
trickles-userapi_2.c:10569:      (__builtin_constant_p (-1)
trickles-userapi_2.c:10570:       ? (__builtin_constant_p ((sizeof (long) * ((64 / 32) - 1))) ?
trickles-userapi_2.c:10571:	  __constant_c_and_count_memset (((&set->sig[1])),
trickles-userapi_2.c:10573:					   (unsigned char) (-1))),
trickles-userapi_2.c:10575:					   ((64 / 32) -
trickles-userapi_2.c:10577:	  __constant_c_memset (((&set->sig[1])),
trickles-userapi_2.c:10578:			       ((0x01010101UL * (unsigned char) (-1))),
trickles-userapi_2.c:10580:				 ((64 / 32) -
trickles-userapi_2.c:10582:       : (__builtin_constant_p ((sizeof (long) * ((64 / 32) - 1))) ?
trickles-userapi_2.c:10583:	  __memset_generic ((((&set->sig[1]))), (((-1))),
trickles-userapi_2.c:10585:			       ((64 / 32) -
trickles-userapi_2.c:10586:				1))))) : __memset_generic (((&set->sig[1])),
trickles-userapi_2.c:10587:							   ((-1)),
trickles-userapi_2.c:10589:							     ((64 / 32) -
trickles-userapi_2.c:10593:      set->sig[1] = -1;
trickles-userapi_2.c:10603:  sigemptyset (&sig->signal);
trickles-userapi_2.c:10604:  sig->head = ((void *) 0);
trickles-userapi_2.c:10605:  sig->tail = &sig->head;
trickles-userapi_2.c:10646:  (void) (&fs->lock);
trickles-userapi_2.c:10647:  old_root = fs->root;
trickles-userapi_2.c:10648:  old_rootmnt = fs->rootmnt;
trickles-userapi_2.c:10649:  fs->rootmnt = mntget (mnt);
trickles-userapi_2.c:10650:  fs->root = dget (dentry);
trickles-userapi_2.c:10672:  (void) (&fs->lock);
trickles-userapi_2.c:10673:  old_pwd = fs->pwd;
trickles-userapi_2.c:10674:  old_pwdmnt = fs->pwdmnt;
trickles-userapi_2.c:10675:  fs->pwdmnt = mntget (mnt);
trickles-userapi_2.c:10676:  fs->pwd = dget (dentry);
trickles-userapi_2.c:11186:    &pidhash[((((p->pid) >> 8) ^ (p->pid)) & ((4096 >> 2) - 1))];
trickles-userapi_2.c:11188:  if ((p->pidhash_next = *htable) != ((void *) 0))
trickles-userapi_2.c:11189:    (*htable)->pidhash_pprev = &p->pidhash_next;
trickles-userapi_2.c:11191:  p->pidhash_pprev = htable;
trickles-userapi_2.c:11197:  if (p->pidhash_next)
trickles-userapi_2.c:11198:    p->pidhash_next->pidhash_pprev = p->pidhash_pprev;
trickles-userapi_2.c:11199:  *p->pidhash_pprev = p->pidhash_next;
trickles-userapi_2.c:11206:    &pidhash[((((pid) >> 8) ^ (pid)) & ((4096 >> 2) - 1))];
trickles-userapi_2.c:11208:  for (p = *htable; p && p->pid != pid; p = p->pidhash_next)
trickles-userapi_2.c:11219:  tsk->processor = cpu;
trickles-userapi_2.c:11220:  tsk->cpus_runnable = 1UL << cpu;
trickles-userapi_2.c:11226:  tsk->cpus_runnable = ~0UL;
trickles-userapi_2.c:11336:  return (p->sigpending != 0);
trickles-userapi_2.c:11352:      for (i = (64 / 32), ready = 0; --i >= 0;)
trickles-userapi_2.c:11353:	ready |= signal->sig[i] & ~blocked->sig[i];
trickles-userapi_2.c:11357:      ready = signal->sig[3] & ~blocked->sig[3];
trickles-userapi_2.c:11358:      ready |= signal->sig[2] & ~blocked->sig[2];
trickles-userapi_2.c:11359:      ready |= signal->sig[1] & ~blocked->sig[1];
trickles-userapi_2.c:11360:      ready |= signal->sig[0] & ~blocked->sig[0];
trickles-userapi_2.c:11364:      ready = signal->sig[1] & ~blocked->sig[1];
trickles-userapi_2.c:11365:      ready |= signal->sig[0] & ~blocked->sig[0];
trickles-userapi_2.c:11369:      ready = signal->sig[0] & ~blocked->sig[0];
trickles-userapi_2.c:11381:  t->sigpending = has_pending_signals (&t->pending.signal, &t->blocked);
trickles-userapi_2.c:11389:  return (sp - get_current ()->sas_ss_sp < get_current ()->sas_ss_size);
trickles-userapi_2.c:11395:  return (get_current ()->sas_ss_size == 0 ? 2 : on_sig_stack (sp) ? 1 : 0);
trickles-userapi_2.c:11408:       securebits) && get_current ()->euid == 0)
trickles-userapi_2.c:11410:      get_current ()->flags |= 0x00000100;
trickles-userapi_2.c:11421:       securebits) && get_current ()->fsuid == 0)
trickles-userapi_2.c:11423:      get_current ()->flags |= 0x00000100;
trickles-userapi_2.c:11439:  if (((get_current ()->cap_effective) & (1 << (cap))))
trickles-userapi_2.c:11444:      get_current ()->flags |= 0x00000100;
trickles-userapi_2.c:11464:  if (atomic_dec_and_test (&mm->mm_count))
trickles-userapi_2.c:11514:  nr_running--;
trickles-userapi_2.c:11515:  p->sleep_time = jiffies;
trickles-userapi_2.c:11516:  list_del (&p->run_list);
trickles-userapi_2.c:11517:  p->run_list.next = ((void *) 0);
trickles-userapi_2.c:11523:  return (p->run_list.next != ((void *) 0));
trickles-userapi_2.c:11537:  nr_threads--;
trickles-userapi_2.c:11541:      (p)->next_task->prev_task = (p)->prev_task;
trickles-userapi_2.c:11542:      (p)->prev_task->next_task = (p)->next_task;
trickles-userapi_2.c:11543:      if ((p)->p_osptr)
trickles-userapi_2.c:11544:	(p)->p_osptr->p_ysptr = (p)->p_ysptr;
trickles-userapi_2.c:11545:      if ((p)->p_ysptr)
trickles-userapi_2.c:11546:	(p)->p_ysptr->p_osptr = (p)->p_osptr;
trickles-userapi_2.c:11548:	(p)->p_pptr->p_cptr = (p)->p_osptr;
trickles-userapi_2.c:11551:  list_del (&p->thread_group);
trickles-userapi_2.c:11567:  (void) (&p->alloc_lock);
trickles-userapi_2.c:11586:  (void) (&get_current ()->fs->lock);
trickles-userapi_2.c:11587:  rootmnt = mntget (get_current ()->fs->rootmnt);
trickles-userapi_2.c:11588:  root = dget (get_current ()->fs->root);
trickles-userapi_2.c:11607:  return (__builtin_expect ((get_current ()->need_resched), 0));
trickles-userapi_2.c:11744:  pg_data_t *pgdat = zone->zone_pgdat;
trickles-userapi_2.c:11746:  if (zone - pgdat->node_zones < 3 - 1)
trickles-userapi_2.c:11749:  else if (pgdat->node_next)
trickles-userapi_2.c:11751:      pgdat = pgdat->node_next;
trickles-userapi_2.c:11752:      zone = pgdat->node_zones;
trickles-userapi_2.c:11767:    char reserved[(1UL << 12) - 10];
trickles-userapi_2.c:11958:  return (new < 3) ? -1 : 0;
trickles-userapi_2.c:12283:  FIX_IO_APIC_BASE_END = FIX_IO_APIC_BASE_0 + 8 - 1,
trickles-userapi_2.c:12289:  FIX_BTMAP_BEGIN = FIX_BTMAP_END + 16 - 1,
trickles-userapi_2.c:12310:  return ((0xffffe000UL) - ((idx) << 12));
trickles-userapi_2.c:12468:  pte.pte_low &= ((~((1UL << 12) - 1)) | 0x020 | 0x040);
trickles-userapi_2.c:12558:  return zone_table[page->flags >> (32 - 8)];
trickles-userapi_2.c:12564:  page->flags &= ~(~0UL << (32 - 8));
trickles-userapi_2.c:12565:  page->flags |= zone_num << (32 - 8);
trickles-userapi_2.c:12709:  return ((&(page)->count)->counter) - !!page->buffers == 1;
trickles-userapi_2.c:12740:  unsigned long ret = -22;
trickles-userapi_2.c:12741:  if ((offset + (((len) + (1UL << 12) - 1) & (~((1UL << 12) - 1)))) < offset)
trickles-userapi_2.c:12743:  if (!(offset & ~(~((1UL << 12) - 1))))
trickles-userapi_2.c:12744:    ret = do_mmap_pgoff (get_current ()->mm, file, addr, len, prot, flag,
trickles-userapi_2.c:12758:  prev->vm_next = vma->vm_next;
trickles-userapi_2.c:12759:  rb_erase (&vma->vm_rb, &mm->mm_rb);
trickles-userapi_2.c:12760:  if (mm->mmap_cache == vma)
trickles-userapi_2.c:12761:    mm->mmap_cache = prev;
trickles-userapi_2.c:12767:  if (!vma->vm_file && vma->vm_flags == vm_flags)
trickles-userapi_2.c:12789:  if (get_current ()->flags & 0x00004000)
trickles-userapi_2.c:12807:  address &= (~((1UL << 12) - 1));
trickles-userapi_2.c:12808:  (void) (&vma->vm_mm->page_table_lock);
trickles-userapi_2.c:12809:  grow = (vma->vm_start - address) >> 12;
trickles-userapi_2.c:12810:  if (vma->vm_end - address > get_current ()->rlim[3].rlim_cur ||
trickles-userapi_2.c:12811:      ((vma->vm_mm->total_vm + grow) << 12) >
trickles-userapi_2.c:12812:      get_current ()->rlim[9].rlim_cur)
trickles-userapi_2.c:12818:      return -12;
trickles-userapi_2.c:12820:  vma->vm_start = address;
trickles-userapi_2.c:12821:  vma->vm_pgoff -= grow;
trickles-userapi_2.c:12822:  vma->vm_mm->total_vm += grow;
trickles-userapi_2.c:12823:  if (vma->vm_flags & 0x00002000)
trickles-userapi_2.c:12824:    vma->vm_mm->locked_vm += grow;
trickles-userapi_2.c:12847:  if (vma && end_addr <= vma->vm_start)
trickles-userapi_2.c:12903:       ((1024 -
trickles-userapi_2.c:12913:					     ((1024 -
trickles-userapi_2.c:12921:		 ((1024 -
trickles-userapi_2.c:12941:      (boot_cpu_data.pgtable_cache_sz)--;
trickles-userapi_2.c:13001:      (boot_cpu_data.pgtable_cache_sz)--;
trickles-userapi_2.c:13026:  if (mm == get_current ()->active_mm)
trickles-userapi_2.c:13040:  if (vma->vm_mm == get_current ()->active_mm)
trickles-userapi_2.c:13047:  if (mm == get_current ()->active_mm)
trickles-userapi_2.c:13079:		long) ((((page) - page_zone (page)->zone_mem_map) << 12) +
trickles-userapi_2.c:13080:		       page_zone (page)->zone_start_paddr) +
trickles-userapi_2.c:13418:  return (list->next == (struct sk_buff *) list);
trickles-userapi_2.c:13425:  atomic_inc (&skb->users);
trickles-userapi_2.c:13433:  if (((&skb->users)->counter) == 1 || atomic_dec_and_test (&skb->users))
trickles-userapi_2.c:13441:  if (((&skb->users)->counter) == 1 || atomic_dec_and_test (&skb->users))
trickles-userapi_2.c:13449:  return skb->cloned
trickles-userapi_2.c:13450:    && ((&((struct skb_shared_info *) ((skb)->end))->dataref)->counter) != 1;
trickles-userapi_2.c:13457:  return (((&skb->users)->counter) != 1);
trickles-userapi_2.c:13490:  struct sk_buff *list = ((struct sk_buff *) list_)->next;
trickles-userapi_2.c:13500:  struct sk_buff *list = ((struct sk_buff *) list_)->prev;
trickles-userapi_2.c:13510:  return (list_->qlen);
trickles-userapi_2.c:13520:  list->prev = (struct sk_buff *) list;
trickles-userapi_2.c:13521:  list->next = (struct sk_buff *) list;
trickles-userapi_2.c:13522:  list->qlen = 0;
trickles-userapi_2.c:13531:  newsk->list = list;
trickles-userapi_2.c:13532:  list->qlen++;
trickles-userapi_2.c:13534:  next = prev->next;
trickles-userapi_2.c:13535:  newsk->next = next;
trickles-userapi_2.c:13536:  newsk->prev = prev;
trickles-userapi_2.c:13537:  next->prev = newsk;
trickles-userapi_2.c:13538:  prev->next = newsk;
trickles-userapi_2.c:13555:      (void) (&list->lock);
trickles-userapi_2.c:13576:  newsk->list = list;
trickles-userapi_2.c:13577:  list->qlen++;
trickles-userapi_2.c:13579:  prev = next->prev;
trickles-userapi_2.c:13580:  newsk->next = next;
trickles-userapi_2.c:13581:  newsk->prev = prev;
trickles-userapi_2.c:13582:  next->prev = newsk;
trickles-userapi_2.c:13583:  prev->next = newsk;
trickles-userapi_2.c:13600:      (void) (&list->lock);
trickles-userapi_2.c:13622:  next = prev->next;
trickles-userapi_2.c:13627:      next = next->next;
trickles-userapi_2.c:13628:      list->qlen--;
trickles-userapi_2.c:13629:      next->prev = prev;
trickles-userapi_2.c:13630:      prev->next = next;
trickles-userapi_2.c:13631:      result->next = ((void *) 0);
trickles-userapi_2.c:13632:      result->prev = ((void *) 0);
trickles-userapi_2.c:13633:      result->list = ((void *) 0);
trickles-userapi_2.c:13653:      (void) (&list->lock);
trickles-userapi_2.c:13678:  newsk->next = next;
trickles-userapi_2.c:13679:  newsk->prev = prev;
trickles-userapi_2.c:13680:  next->prev = newsk;
trickles-userapi_2.c:13681:  prev->next = newsk;
trickles-userapi_2.c:13682:  newsk->list = list;
trickles-userapi_2.c:13683:  list->qlen++;
trickles-userapi_2.c:13700:      (void) (&old->list->lock);
trickles-userapi_2.c:13703:  __skb_insert (newsk, old->prev, old, old->list);
trickles-userapi_2.c:13722:  __skb_insert (newsk, old, old->next, old->list);
trickles-userapi_2.c:13739:      (void) (&old->list->lock);
trickles-userapi_2.c:13764:  list->qlen--;
trickles-userapi_2.c:13765:  next = skb->next;
trickles-userapi_2.c:13766:  prev = skb->prev;
trickles-userapi_2.c:13767:  skb->next = ((void *) 0);
trickles-userapi_2.c:13768:  skb->prev = ((void *) 0);
trickles-userapi_2.c:13769:  skb->list = ((void *) 0);
trickles-userapi_2.c:13770:  next->prev = prev;
trickles-userapi_2.c:13771:  prev->next = next;
trickles-userapi_2.c:13778:  struct sk_buff_head *list = skb->list;
trickles-userapi_2.c:13792:	  (void) (&list->lock);
trickles-userapi_2.c:13795:      if (skb->list == list)
trickles-userapi_2.c:13796:	__skb_unlink (skb, skb->list);
trickles-userapi_2.c:13835:      (void) (&list->lock);
trickles-userapi_2.c:13854:  return skb->data_len;
trickles-userapi_2.c:13860:  return skb->len - skb->data_len;
trickles-userapi_2.c:13867:  unsigned char *tmp = skb->tail;
trickles-userapi_2.c:13874:  skb->tail += len;
trickles-userapi_2.c:13875:  skb->len += len;
trickles-userapi_2.c:13883:  unsigned char *tmp = skb->tail;
trickles-userapi_2.c:13890:  skb->tail += len;
trickles-userapi_2.c:13891:  skb->len += len;
trickles-userapi_2.c:13892:  if (skb->tail > skb->end)
trickles-userapi_2.c:13907:  skb->data -= len;
trickles-userapi_2.c:13908:  skb->len += len;
trickles-userapi_2.c:13909:  return skb->data;
trickles-userapi_2.c:13916:  skb->data -= len;
trickles-userapi_2.c:13917:  skb->len += len;
trickles-userapi_2.c:13918:  if (skb->data < skb->head)
trickles-userapi_2.c:13927:  return skb->data;
trickles-userapi_2.c:13933:  skb->len -= len;
trickles-userapi_2.c:13934:  if (skb->len < skb->data_len)
trickles-userapi_2.c:13936:  return skb->data += len;
trickles-userapi_2.c:13943:  if (len > skb->len)
trickles-userapi_2.c:13954:      __pskb_pull_tail (skb, len - skb_headlen (skb)) == ((void *) 0))
trickles-userapi_2.c:13956:  skb->len -= len;
trickles-userapi_2.c:13957:  return skb->data += len;
trickles-userapi_2.c:13963:  if (len > skb->len)
trickles-userapi_2.c:13973:  if (len > skb->len)
trickles-userapi_2.c:13975:  return (__pskb_pull_tail (skb, len - skb_headlen (skb)) != ((void *) 0));
trickles-userapi_2.c:13982:  return skb->data - skb->head;
trickles-userapi_2.c:13989:  return skb_is_nonlinear (skb) ? 0 : skb->end - skb->tail;
trickles-userapi_2.c:13996:  skb->data += len;
trickles-userapi_2.c:13997:  skb->tail += len;
trickles-userapi_2.c:14005:  if (!skb->data_len)
trickles-userapi_2.c:14007:      skb->len = len;
trickles-userapi_2.c:14008:      skb->tail = skb->data + len;
trickles-userapi_2.c:14020:  if (skb->len > len)
trickles-userapi_2.c:14030:  if (!skb->data_len)
trickles-userapi_2.c:14032:      skb->len = len;
trickles-userapi_2.c:14033:      skb->tail = skb->data + len;
trickles-userapi_2.c:14045:  if (len < skb->len)
trickles-userapi_2.c:14054:  if (skb->destructor)
trickles-userapi_2.c:14055:    skb->destructor (skb);
trickles-userapi_2.c:14056:  skb->destructor = ((void *) 0);
trickles-userapi_2.c:14057:  skb->sk = ((void *) 0);
trickles-userapi_2.c:14104:  int delta = (headroom > 16 ? headroom : 16) - skb_headroom (skb);
trickles-userapi_2.c:14118:  unsigned int size = skb->len;
trickles-userapi_2.c:14121:  return skb_pad (skb, len - size);
trickles-userapi_2.c:14136:  return kmap (frag->page);
trickles-userapi_2.c:14187:  if (nfct && atomic_dec_and_test (&nfct->master->use))
trickles-userapi_2.c:14188:    nfct->master->destroy (nfct->master);
trickles-userapi_2.c:14194:    atomic_inc (&nfct->master->use);
trickles-userapi_2.c:14256:		 "g" (get_current ()->addr_limit.
trickles-userapi_2.c:14259:	    }) == 0) ? 0 : -14;
trickles-userapi_2.c:14357:unsigned long flag, sum; asm ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag), "=r" (sum):"1" (to), "g" ((int) (n)), "g" (get_current ()->addr_limit.seg));
trickles-userapi_2.c:14388:unsigned long flag, sum; asm ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag), "=r" (sum):"1" (from), "g" ((int) (n)), "g" (get_current ()->addr_limit.seg));
trickles-userapi_2.c:14505:  pt->error = 0;
trickles-userapi_2.c:14506:  pt->table = ((void *) 0);
trickles-userapi_2.c:14525:    ((((nr) + (8 * sizeof (long)) -
trickles-userapi_2.c:14536:	error = -14;
trickles-userapi_2.c:14553:     (((((nr) + (8 * sizeof (long)) -
trickles-userapi_2.c:14559:							      -
trickles-userapi_2.c:14565:				     (((((nr) + (8 * sizeof (long)) -
trickles-userapi_2.c:14575:      ((((((nr) + (8 * sizeof (long)) -
trickles-userapi_2.c:14584:								 (long)) -
trickles-userapi_2.c:14592:			   ((((((nr) + (8 * sizeof (long)) -
trickles-userapi_2.c:14596:      ((((((nr) + (8 * sizeof (long)) -
trickles-userapi_2.c:14600:						    (8 * sizeof (long)) -
trickles-userapi_2.c:14605:			((((((nr) + (8 * sizeof (long)) -
trickles-userapi_2.c:14725:  unsigned char __pad[16 - sizeof (short int) -
trickles-userapi_2.c:14726:		      sizeof (unsigned short int) - sizeof (struct in_addr)];
trickles-userapi_2.c:15253:  unsigned long hh_data[(((32) + (16 - 1)) & ~(16 - 1)) / sizeof (long)];
trickles-userapi_2.c:15599:  eip -= (unsigned long) &_stext;
trickles-userapi_2.c:15606:  if (eip > prof_len - 1)
trickles-userapi_2.c:15607:    eip = prof_len - 1;
trickles-userapi_2.c:15719:  if (!test_and_set_bit (TASKLET_STATE_SCHED, &t->state))
trickles-userapi_2.c:15729:  if (!test_and_set_bit (TASKLET_STATE_SCHED, &t->state))
trickles-userapi_2.c:15737:  atomic_inc (&t->count);
trickles-userapi_2.c:15756:  atomic_dec (&t->count);
trickles-userapi_2.c:15763:  atomic_dec (&t->count);
trickles-userapi_2.c:15872:  if (!test_and_set_bit (__LINK_STATE_SCHED, &dev->state))
trickles-userapi_2.c:15883:      dev->next_sched = softnet_data[cpu].output_queue;
trickles-userapi_2.c:15896:			  (&dev->
trickles-userapi_2.c:15898:							(&dev->state))))
trickles-userapi_2.c:15905:  clear_bit (__LINK_STATE_XOFF, &dev->state);
trickles-userapi_2.c:15911:  if (test_and_clear_bit (__LINK_STATE_XOFF, &dev->state))
trickles-userapi_2.c:15918:  set_bit (__LINK_STATE_XOFF, &dev->state);
trickles-userapi_2.c:15926:			     (&dev->
trickles-userapi_2.c:15928:	  variable_test_bit ((__LINK_STATE_XOFF), (&dev->state)));
trickles-userapi_2.c:15936:			     (&dev->
trickles-userapi_2.c:15938:	  variable_test_bit ((__LINK_STATE_START), (&dev->state)));
trickles-userapi_2.c:15948:  if (atomic_dec_and_test (&skb->users))
trickles-userapi_2.c:15959:      skb->next = softnet_data[cpu].completion_queue;
trickles-userapi_2.c:16014:  if (atomic_dec_and_test (&dev->refcnt))
trickles-userapi_2.c:16024:			      (&dev->
trickles-userapi_2.c:16026:	   variable_test_bit ((__LINK_STATE_NOCARRIER), (&dev->state)));
trickles-userapi_2.c:16034:  clear_bit (__LINK_STATE_NOCARRIER, &dev->state);
trickles-userapi_2.c:16042:  set_bit (__LINK_STATE_NOCARRIER, &dev->state);
trickles-userapi_2.c:16051:			     (&dev->
trickles-userapi_2.c:16053:	  variable_test_bit ((__LINK_STATE_PRESENT), (&dev->state)));
trickles-userapi_2.c:16059:  if (test_and_clear_bit (__LINK_STATE_PRESENT, &dev->state) &&
trickles-userapi_2.c:16069:  if (!test_and_set_bit (__LINK_STATE_PRESENT, &dev->state) &&
trickles-userapi_2.c:16105:    !test_and_set_bit (__LINK_STATE_RX_SCHED, &dev->state);
trickles-userapi_2.c:16124:  atomic_inc (&(dev)->refcnt);
trickles-userapi_2.c:16125:  list_add_tail (&dev->poll_list, &softnet_data[cpu].poll_list);
trickles-userapi_2.c:16126:  if (dev->quota < 0)
trickles-userapi_2.c:16127:    dev->quota += dev->weight;
trickles-userapi_2.c:16129:    dev->quota = dev->weight;
trickles-userapi_2.c:16159:      dev->quota += undo;
trickles-userapi_2.c:16167:      list_add_tail (&dev->poll_list, &softnet_data[cpu].poll_list);
trickles-userapi_2.c:16199:			  (&dev->
trickles-userapi_2.c:16201:       variable_test_bit ((__LINK_STATE_RX_SCHED), (&dev->state))))
trickles-userapi_2.c:16212:  list_del (&dev->poll_list);
trickles-userapi_2.c:16214:  clear_bit (__LINK_STATE_RX_SCHED, &dev->state);
trickles-userapi_2.c:16221:  while (test_and_set_bit (__LINK_STATE_RX_SCHED, &dev->state))
trickles-userapi_2.c:16224:      get_current ()->state = 1;
trickles-userapi_2.c:16232:  clear_bit (__LINK_STATE_RX_SCHED, &dev->state);
trickles-userapi_2.c:16244:			  (&dev->
trickles-userapi_2.c:16246:       variable_test_bit ((__LINK_STATE_RX_SCHED), (&dev->state))))
trickles-userapi_2.c:16257:  list_del (&dev->poll_list);
trickles-userapi_2.c:16259:  clear_bit (__LINK_STATE_RX_SCHED, &dev->state);
trickles-userapi_2.c:16273:      (void) (&dev->xmit_lock);
trickles-userapi_2.c:16287:	  if (!--*ptr)
trickles-userapi_2.c:16288:	    __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;"
trickles-userapi_2.c:16661:  return fp->len * sizeof (struct sock_filter) + sizeof (*fp);
trickles-userapi_2.c:16726:  unsigned char ha[(8 + sizeof (unsigned long) - 1) &
trickles-userapi_2.c:16727:		   ~(sizeof (unsigned long) - 1)];
trickles-userapi_2.c:16845:  if (atomic_dec_and_test (&neigh->refcnt))
trickles-userapi_2.c:16853:    atomic_inc (&neigh->refcnt);
trickles-userapi_2.c:16863:    neigh->confirmed = jiffies;
trickles-userapi_2.c:16869:  return neigh->nud_state & (0x80 | 0x40 | 0x02);
trickles-userapi_2.c:16875:  return neigh->nud_state & (0x80 | 0x40 | 0x02 | 0x10 | 0x04 | 0x08);
trickles-userapi_2.c:16881:  neigh->used = jiffies;
trickles-userapi_2.c:16882:  if (!(neigh->nud_state & ((0x80 | 0x40 | 0x02) | 0x08 | 0x10)))
trickles-userapi_2.c:16982:  atomic_inc (&dst->__refcnt);
trickles-userapi_2.c:16989:    atomic_inc (&dst->__refcnt);
trickles-userapi_2.c:16997:    atomic_dec (&dst->__refcnt);
trickles-userapi_2.c:17007:  if (dst->obsolete > 1)
trickles-userapi_2.c:17009:  if (!((&dst->__refcnt)->counter))
trickles-userapi_2.c:17021:    neigh_confirm (dst->neighbour);
trickles-userapi_2.c:17028:  if (dst && dst->ops->negative_advice)
trickles-userapi_2.c:17029:    *dst_p = dst->ops->negative_advice (dst);
trickles-userapi_2.c:17035:  struct dst_entry *dst = skb->dst;
trickles-userapi_2.c:17036:  if (dst && dst->ops && dst->ops->link_failure)
trickles-userapi_2.c:17037:    dst->ops->link_failure (skb);
trickles-userapi_2.c:17048:  if (dst->expires == 0 || (long) (dst->expires - expires) > 0)
trickles-userapi_2.c:17049:    dst->expires = expires;
trickles-userapi_2.c:17147:  head->next = head->prev = ((void *) 0);
trickles-userapi_2.c:17161:  for (elem = (typeof (elem)) (list)->next; (elem != (typeof (elem)) (list));
trickles-userapi_2.c:17162:       elem = (typeof (elem)) elem->next)
trickles-userapi_2.c:17177:  dlist->next = dlist->prev = (struct list_link *) dlist;
trickles-userapi_2.c:17183:  if (head->next == elem)
trickles-userapi_2.c:17197:  elem->next = head->next;
trickles-userapi_2.c:17198:  head->next->prev = elem;
trickles-userapi_2.c:17200:  elem->prev = (struct list_link *) head;
trickles-userapi_2.c:17201:  head->next = elem;
trickles-userapi_2.c:17207:  if (head->prev == elem)
trickles-userapi_2.c:17221:  elem->next = (struct list_link *) head;
trickles-userapi_2.c:17222:  elem->prev = head->prev;
trickles-userapi_2.c:17223:  head->prev->next = elem;
trickles-userapi_2.c:17224:  head->prev = elem;
trickles-userapi_2.c:17230:  if (head->prev == elem)
trickles-userapi_2.c:17244:  elem->next = (struct list_link *) head;
trickles-userapi_2.c:17245:  elem->prev = head->prev;
trickles-userapi_2.c:17247:  head->prev->next = elem;
trickles-userapi_2.c:17248:  head->prev = elem;
trickles-userapi_2.c:17254:  elem->next->prev = elem->prev;
trickles-userapi_2.c:17255:  elem->prev->next = elem->next;
trickles-userapi_2.c:17256:  elem->prev = elem->next = ((void *) 0);
trickles-userapi_2.c:17262:  return (struct dlist *) list->next == list;
trickles-userapi_2.c:17324:  vec->num = 0;
trickles-userapi_2.c:17325:  vec->size = initSize;
trickles-userapi_2.c:17326:  vec->elems = kmalloc (vec->size * sizeof (vec->elems[0]), (0x20));
trickles-userapi_2.c:17327:  if (vec->elems == ((void *) 0))
trickles-userapi_2.c:17337:  kfree (vec->elems);
trickles-userapi_2.c:17343:  if (vec->num == vec->size)
trickles-userapi_2.c:17346:      vec->size *= 2;
trickles-userapi_2.c:17347:      newElems = kmalloc (vec->size * sizeof (newElems[0]), (0x20));
trickles-userapi_2.c:17365:  vec->elems[vec->num++] = newElem;
trickles-userapi_2.c:17377:  return head->next == (struct alloc_head *) head;
trickles-userapi_2.c:17383:  head->next = head->prev = (struct alloc_head *) head;
trickles-userapi_2.c:17384:  head->list = head;
trickles-userapi_2.c:17385:  head->len = 0;
trickles-userapi_2.c:17397:  if (head->next == elem)
trickles-userapi_2.c:17411:  elem->next = head->next;
trickles-userapi_2.c:17412:  head->next->prev = elem;
trickles-userapi_2.c:17414:  elem->prev = (struct alloc_head *) head;
trickles-userapi_2.c:17415:  head->next = elem;
trickles-userapi_2.c:17417:  elem->list = head;
trickles-userapi_2.c:17418:  head->len++;
trickles-userapi_2.c:17429:  if (head->prev == elem)
trickles-userapi_2.c:17444:  elem->next = (struct alloc_head *) head;
trickles-userapi_2.c:17446:  elem->prev = head->prev;
trickles-userapi_2.c:17448:  head->prev->next = elem;
trickles-userapi_2.c:17450:  elem->list = head;
trickles-userapi_2.c:17451:  head->prev = elem;
trickles-userapi_2.c:17452:  head->len++;
trickles-userapi_2.c:17463:  if (head->prev == elem)
trickles-userapi_2.c:17478:  elem->next = (struct alloc_head *) head;
trickles-userapi_2.c:17479:  elem->prev = head->prev;
trickles-userapi_2.c:17483:  head->prev->next = elem;
trickles-userapi_2.c:17485:  elem->next = (struct alloc_head *) head;
trickles-userapi_2.c:17487:  elem->list = head;
trickles-userapi_2.c:17488:  head->prev = elem;
trickles-userapi_2.c:17489:  head->len++;
trickles-userapi_2.c:17501:  elem->next->prev = elem->prev;
trickles-userapi_2.c:17502:  elem->prev->next = elem->next;
trickles-userapi_2.c:17503:  elem->prev = elem->next = ((void *) 0);
trickles-userapi_2.c:17505:  elem->list->len--;
trickles-userapi_2.c:17506:  elem->list = ((void *) 0);
trickles-userapi_2.c:17514:  if (!(elem->next == ((void *) 0) && elem->prev == ((void *) 0)))
trickles-userapi_2.c:17525:  elem->next = prev->next;
trickles-userapi_2.c:17526:  prev->next = elem;
trickles-userapi_2.c:17528:  elem->prev = prev;
trickles-userapi_2.c:17529:  next->prev = elem;
trickles-userapi_2.c:17531:  elem->list = prev->list;
trickles-userapi_2.c:17532:  elem->list->len++;
trickles-userapi_2.c:17579:  pkt->nonce = -1;
trickles-userapi_2.c:17580:  pkt->seq = seq;
trickles-userapi_2.c:17582:  pkt->len = len;
trickles-userapi_2.c:17583:  pkt->type = type;
trickles-userapi_2.c:17584:  pkt->contType = contType;
trickles-userapi_2.c:17585:  pkt->minResponseLen = minResponseLen;
trickles-userapi_2.c:17586:  pkt->firstTransportChild = firstTransportChild;
trickles-userapi_2.c:17587:  pkt->numTransportChildren = numTransportChildren;
trickles-userapi_2.c:17588:  pkt->ucontLen = 0;
trickles-userapi_2.c:17589:  pkt->ucontData = ((void *) 0);
trickles-userapi_2.c:17590:  pkt->numSiblings = -1;
trickles-userapi_2.c:17591:  pkt->position = (0xff);
trickles-userapi_2.c:17598:  if (len > packet->len + packet->ucontLen)
trickles-userapi_2.c:17601:	      (int) len, packet->len, packet->ucontLen);
trickles-userapi_2.c:17604:  if (packet->ucontData)
trickles-userapi_2.c:17606:      kfree (packet->ucontData);
trickles-userapi_2.c:17607:      packet->len += packet->ucontLen;
trickles-userapi_2.c:17608:      packet->ucontLen = 0;
trickles-userapi_2.c:17610:  packet->ucontData = buf;
trickles-userapi_2.c:17611:  packet->ucontLen = len;
trickles-userapi_2.c:17612:  packet->len -= packet->ucontLen;
trickles-userapi_2.c:18142:  printk ("PHChunk %p = { type = %d, chunkLen = %d, range=[%d-%d] }\n",
trickles-userapi_2.c:18143:	  phchunk, phchunk->type, ntohs (phchunk->chunkLen),
trickles-userapi_2.c:18144:	  ntohl (phchunk->start), ntohl (phchunk->end));
trickles-userapi_2.c:19017:    u8 __pad[(1 << ((5))) - sizeof (int)];
trickles-userapi_2.c:19025:  prot->stats[0].inuse++;
trickles-userapi_2.c:19031:  prot->stats[0].inuse--;
trickles-userapi_2.c:19111:  if (sk->filter)
trickles-userapi_2.c:19116:	(void) (&((sk)->lock.slock));
trickles-userapi_2.c:19118:      filter = sk->filter;
trickles-userapi_2.c:19121:	  int pkt_len = sk_run_filter (skb, filter->insns,
trickles-userapi_2.c:19122:				       filter->len);
trickles-userapi_2.c:19124:	    err = -1;
trickles-userapi_2.c:19144:  atomic_sub (size, &sk->omem_alloc);
trickles-userapi_2.c:19146:  if (atomic_dec_and_test (&fp->refcnt))
trickles-userapi_2.c:19153:  atomic_inc (&fp->refcnt);
trickles-userapi_2.c:19154:  atomic_add (sk_filter_len (fp), &sk->omem_alloc);
trickles-userapi_2.c:19161:  atomic_inc (&sk->refcnt);
trickles-userapi_2.c:19170:  atomic_dec (&sk->refcnt);
trickles-userapi_2.c:19177:  if (atomic_dec_and_test (&sk->refcnt))
trickles-userapi_2.c:19193:      (void) (&sk->callback_lock);
trickles-userapi_2.c:19196:  sk->dead = 1;
trickles-userapi_2.c:19197:  sk->socket = ((void *) 0);
trickles-userapi_2.c:19198:  sk->sleep = ((void *) 0);
trickles-userapi_2.c:19209:	  if (!--*ptr)
trickles-userapi_2.c:19210:	    __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;"
trickles-userapi_2.c:19236:      (void) (&sk->callback_lock);
trickles-userapi_2.c:19239:  sk->sleep = &parent->wait;
trickles-userapi_2.c:19240:  parent->sk = sk;
trickles-userapi_2.c:19241:  sk->socket = parent;
trickles-userapi_2.c:19252:	  if (!--*ptr)
trickles-userapi_2.c:19253:	    __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;"
trickles-userapi_2.c:19273:  (void) (&sk->callback_lock);
trickles-userapi_2.c:19274:  uid = sk->socket ? sk->socket->inode->i_uid : 0;
trickles-userapi_2.c:19287:  (void) (&sk->callback_lock);
trickles-userapi_2.c:19288:  ino = sk->socket ? sk->socket->inode->i_ino : 0;
trickles-userapi_2.c:19299:  return sk->dst_cache;
trickles-userapi_2.c:19307:  (void) (&sk->dst_lock);
trickles-userapi_2.c:19308:  dst = sk->dst_cache;
trickles-userapi_2.c:19323:  old_dst = sk->dst_cache;
trickles-userapi_2.c:19324:  sk->dst_cache = dst;
trickles-userapi_2.c:19331:  (void) (&sk->dst_lock);
trickles-userapi_2.c:19344:  old_dst = sk->dst_cache;
trickles-userapi_2.c:19345:  sk->dst_cache = ((void *) 0);
trickles-userapi_2.c:19352:  (void) (&sk->dst_lock);
trickles-userapi_2.c:19363:  struct dst_entry *dst = sk->dst_cache;
trickles-userapi_2.c:19365:  if (dst && dst->obsolete && dst->ops->check (dst, cookie) == ((void *) 0))
trickles-userapi_2.c:19367:      sk->dst_cache = ((void *) 0);
trickles-userapi_2.c:19379:  if (dst && dst->obsolete && dst->ops->check (dst, cookie) == ((void *) 0))
trickles-userapi_2.c:19393:  skb->sk = sk;
trickles-userapi_2.c:19394:  skb->destructor = sock_wfree;
trickles-userapi_2.c:19395:  atomic_add (skb->truesize, &sk->wmem_alloc);
trickles-userapi_2.c:19401:  skb->sk = sk;
trickles-userapi_2.c:19402:  skb->destructor = sock_rfree;
trickles-userapi_2.c:19403:  atomic_add (skb->truesize, &sk->rmem_alloc);
trickles-userapi_2.c:19415:  if (((&sk->rmem_alloc)->counter) + skb->truesize >= (unsigned) sk->rcvbuf)
trickles-userapi_2.c:19417:      err = -12;
trickles-userapi_2.c:19429:  skb->dev = ((void *) 0);
trickles-userapi_2.c:19437:  skb_len = skb->len;
trickles-userapi_2.c:19439:  skb_queue_tail (&sk->receive_queue, skb);
trickles-userapi_2.c:19440:  if (!sk->dead)
trickles-userapi_2.c:19441:    sk->data_ready (sk, skb_len);
trickles-userapi_2.c:19452:  if (((&sk->rmem_alloc)->counter) + skb->truesize >= (unsigned) sk->rcvbuf)
trickles-userapi_2.c:19453:    return -12;
trickles-userapi_2.c:19455:  skb_queue_tail (&sk->error_queue, skb);
trickles-userapi_2.c:19456:  if (!sk->dead)
trickles-userapi_2.c:19457:    sk->data_ready (sk, skb->len);
trickles-userapi_2.c:19469:    ((__typeof__ (*(&sk->err)))
trickles-userapi_2.c:19470:     __xchg ((unsigned long) (0), (&sk->err), sizeof (*(&sk->err))));
trickles-userapi_2.c:19471:  return -err;
trickles-userapi_2.c:19479:  if (!(sk->shutdown & 2))
trickles-userapi_2.c:19481:      amt = sk->sndbuf - ((&sk->wmem_alloc)->counter);
trickles-userapi_2.c:19491:  if (sk->socket && sk->socket->fasync_list)
trickles-userapi_2.c:19492:    sock_wake_async (sk->socket, how, band);
trickles-userapi_2.c:19504:  return ((&sk->wmem_alloc)->counter) < (sk->sndbuf / 2);
trickles-userapi_2.c:19518:  return noblock ? 0 : sk->rcvtimeo;
trickles-userapi_2.c:19524:  return noblock ? 0 : sk->sndtimeo;
trickles-userapi_2.c:19532:			    int __x = (sk->rcvlowat);
trickles-userapi_2.c:19544:  return timeo == ((long) (~0UL >> 1)) ? -512 : -4;
trickles-userapi_2.c:19550:  if (sk->rcvtstamp)
trickles-userapi_2.c:19551:    put_cmsg (msg, 1, 29, sizeof (skb->stamp), &skb->stamp);
trickles-userapi_2.c:19553:    sk->stamp = skb->stamp;
trickles-userapi_2.c:19654:  return !((addr ^ ifa->ifa_address) & ifa->ifa_mask);
trickles-userapi_2.c:19682:  in_dev = dev->ip_ptr;
trickles-userapi_2.c:19684:    atomic_inc (&in_dev->refcnt);
trickles-userapi_2.c:19695:  return (struct in_device *) dev->ip_ptr;
trickles-userapi_2.c:19703:  if (atomic_dec_and_test (&idev->refcnt))
trickles-userapi_2.c:19716:    return htonl (~((1 << (32 - logmask)) - 1));
trickles-userapi_2.c:19725:  return 32 - ffz (~mask);
trickles-userapi_2.c:19772:  if (atomic_dec_and_test (&p->refcnt))
trickles-userapi_2.c:19774:      p->unused_prevp = inet_peer_unused_tailp;
trickles-userapi_2.c:19775:      p->unused_next = ((void *) 0);
trickles-userapi_2.c:19777:      inet_peer_unused_tailp = &p->unused_next;
trickles-userapi_2.c:19778:      p->dtime = jiffies;
trickles-userapi_2.c:19790:	  if (!--*ptr)
trickles-userapi_2.c:19791:	    __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;"
trickles-userapi_2.c:19824:  id = p->ip_id_count++;
trickles-userapi_2.c:19835:	  if (!--*ptr)
trickles-userapi_2.c:19836:	    __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;"
trickles-userapi_2.c:19940:  int size = ((len) + (((sizeof (struct nlmsghdr)) + 4 - 1) & ~(4 - 1)));
trickles-userapi_2.c:19942:  nlh = (struct nlmsghdr *) skb_put (skb, (((size) + 4 - 1) & ~(4 - 1)));
trickles-userapi_2.c:19943:  nlh->nlmsg_type = type;
trickles-userapi_2.c:19944:  nlh->nlmsg_len = size;
trickles-userapi_2.c:19945:  nlh->nlmsg_flags = 0;
trickles-userapi_2.c:19946:  nlh->nlmsg_pid = pid;
trickles-userapi_2.c:19947:  nlh->nlmsg_seq = seq;
trickles-userapi_2.c:20230:  return len > rta->rta_len
trickles-userapi_2.c:20233:				 ((((sizeof (struct rtattr)) + 4 - 1) & ~(4 -
trickles-userapi_2.c:20402:    dst_release (&rt->u.dst);
trickles-userapi_2.c:20422:  dst = (*rp)->rt_dst;
trickles-userapi_2.c:20423:  src = (*rp)->rt_src;
trickles-userapi_2.c:20434:  if (rt->peer)
trickles-userapi_2.c:20435:    return rt->peer;
trickles-userapi_2.c:20438:  return rt->peer;
trickles-userapi_2.c:20887:  if (skb->len > skb->dst->pmtu)
trickles-userapi_2.c:20898:  u32 check = iph->check;
trickles-userapi_2.c:20903:  iph->check = check + (check >= 0xFFFF);
trickles-userapi_2.c:20904:  return --iph->ttl;
trickles-userapi_2.c:20910:  return (sk->protinfo.af_inet.pmtudisc == 2 ||
trickles-userapi_2.c:20911:	  (sk->protinfo.af_inet.pmtudisc == 1 &&
trickles-userapi_2.c:20912:	   !(dst->mxlock & (1 << RTAX_MTU))));
trickles-userapi_2.c:20920:  if (iph->
trickles-userapi_2.c:20931:      iph->id = ((sk && sk->daddr) ? htons (sk->protinfo.af_inet.id++) : 0);
trickles-userapi_2.c:21137:unsigned long flag, sum; asm ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag), "=r" (sum):"1" (dst), "g" ((int) (len)), "g" (get_current ()->addr_limit.seg));
trickles-userapi_2.c:21144:    *err_ptr = -14;
trickles-userapi_2.c:21146:  return -1;
trickles-userapi_2.c:21159:    *err_ptr = -14;
trickles-userapi_2.c:21266:  return (lport & ((tcp_hashinfo.__tcp_bhash_size) - 1));
trickles-userapi_2.c:21318:  if (atomic_dec_and_test (&tw->refcnt))
trickles-userapi_2.c:21337:  return num & (32 - 1);
trickles-userapi_2.c:21343:  return tcp_lhashfn (sk->num);
trickles-userapi_2.c:21441:  req->class->destructor (req);
trickles-userapi_2.c:21486:  return (__s32) (seq1 - seq2) < 0;
trickles-userapi_2.c:21492:  return (__s32) (seq2 - seq1) < 0;
trickles-userapi_2.c:21500:  return seq3 - seq2 >= seq1 - seq2;
trickles-userapi_2.c:21551:  tp->ack.pending |= TCP_ACK_SCHED;
trickles-userapi_2.c:21557:  return tp->ack.pending & TCP_ACK_SCHED;
trickles-userapi_2.c:21563:  if (tp->ack.quick && --tp->ack.quick == 0)
trickles-userapi_2.c:21566:      tp->ack.ato = ((unsigned) (100 / 25));
trickles-userapi_2.c:21576:   ? (__builtin_constant_p ((sizeof (tp->ack))) ?
trickles-userapi_2.c:21577:      __constant_c_and_count_memset (((&tp->ack)),
trickles-userapi_2.c:21579:				     ((sizeof (tp->ack)))) :
trickles-userapi_2.c:21580:      __constant_c_memset (((&tp->ack)),
trickles-userapi_2.c:21582:			   ((sizeof (tp->ack)))))
trickles-userapi_2.c:21583:   : (__builtin_constant_p ((sizeof (tp->ack))) ?
trickles-userapi_2.c:21584:      __memset_generic ((((&tp->ack))), (((0))),
trickles-userapi_2.c:21585:			(((sizeof (tp->ack))))) :
trickles-userapi_2.c:21586:      __memset_generic (((&tp->ack)), ((0)), ((sizeof (tp->ack))))));
trickles-userapi_2.c:21592:  tp->tstamp_ok = tp->sack_ok = tp->wscale_ok = tp->snd_wscale = 0;
trickles-userapi_2.c:21729:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_2.c:21735:      tp->pending = 0;
trickles-userapi_2.c:21744:      tp->ack.blocked = 0;
trickles-userapi_2.c:21745:      tp->ack.pending = 0;
trickles-userapi_2.c:21766:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_2.c:21786:      tp->pending = what;
trickles-userapi_2.c:21787:      tp->timeout = jiffies + when;
trickles-userapi_2.c:21788:      if (!mod_timer (&tp->retransmit_timer, tp->timeout))
trickles-userapi_2.c:21793:      tp->ack.pending |= TCP_ACK_TIMER;
trickles-userapi_2.c:21794:      tp->ack.timeout = jiffies + when;
trickles-userapi_2.c:21795:      if (!mod_timer (&tp->delack_timer, tp->ack.timeout))
trickles-userapi_2.c:21811:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_2.c:21813:  int mss_now = tp->mss_cache;
trickles-userapi_2.c:21815:  if (dst && dst->pmtu != tp->pmtu_cookie)
trickles-userapi_2.c:21816:    mss_now = tcp_sync_mss (sk, dst->pmtu);
trickles-userapi_2.c:21818:  if (tp->eff_sacks)
trickles-userapi_2.c:21819:    mss_now -= (4 + (tp->eff_sacks * 8));
trickles-userapi_2.c:21827:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_2.c:21828:  unsigned int hint = ({ const typeof (tp->advmss) _x = (tp->advmss);
trickles-userapi_2.c:21829:		       const typeof (tp->mss_cache) _y = (tp->mss_cache);
trickles-userapi_2.c:21837:	   const typeof (tp->rcv_wnd / 2) _y = (tp->rcv_wnd / 2);
trickles-userapi_2.c:21856:  tp->ack.rcv_mss = hint;
trickles-userapi_2.c:21862:  tp->pred_flags = htonl ((tp->tcp_header_len << 26) |
trickles-userapi_2.c:21869:  __tcp_fast_path_on (tp, tp->snd_wnd >> tp->snd_wscale);
trickles-userapi_2.c:21875:  if (skb_queue_len (&tp->out_of_order_queue) == 0 &&
trickles-userapi_2.c:21876:      tp->rcv_wnd &&
trickles-userapi_2.c:21877:      ((&sk->rmem_alloc)->counter) < sk->rcvbuf && !tp->urg_data)
trickles-userapi_2.c:21888:  s32 win = tp->rcv_wup + tp->rcv_wnd - tp->rcv_nxt;
trickles-userapi_2.c:21975:  u32 check = iph->check;
trickles-userapi_2.c:21980:  iph->check = check + (check >= 0xFFFF);
trickles-userapi_2.c:21981:  iph->tos |= 1;
trickles-userapi_2.c:22003:  if (tp->ecn_flags & 1)
trickles-userapi_2.c:22004:    tp->ecn_flags |= 2;
trickles-userapi_2.c:22013:  ((struct tcp_skb_cb *) &((skb)->cb[0]))->flags &= ~0x80;
trickles-userapi_2.c:22014:  if (!(tp->ecn_flags & 1))
trickles-userapi_2.c:22015:    ((struct tcp_skb_cb *) &((skb)->cb[0]))->flags &= ~0x40;
trickles-userapi_2.c:22021:  tp->ecn_flags = 0;
trickles-userapi_2.c:22024:      ((struct tcp_skb_cb *) &((skb)->cb[0]))->flags |= 0x40 | 0x80;
trickles-userapi_2.c:22025:      tp->ecn_flags = 1;
trickles-userapi_2.c:22032:  if (req->ecn_ok)
trickles-userapi_2.c:22033:    th->ece = 1;
trickles-userapi_2.c:22040:  if (tp->ecn_flags & 1)
trickles-userapi_2.c:22043:      if (skb->len != tcp_header_len &&
trickles-userapi_2.c:22044:	  !before (((struct tcp_skb_cb *) &((skb)->cb[0]))->seq, tp->snd_nxt))
trickles-userapi_2.c:22048:	      (sk)->protinfo.af_inet.tos |= 2;
trickles-userapi_2.c:22051:	  if (tp->ecn_flags & 2)
trickles-userapi_2.c:22053:	      tp->ecn_flags &= ~2;
trickles-userapi_2.c:22054:	      skb->h.th->cwr = 1;
trickles-userapi_2.c:22062:	      (sk)->protinfo.af_inet.tos &= ~3;
trickles-userapi_2.c:22066:      if (tp->ecn_flags & 4)
trickles-userapi_2.c:22067:	skb->h.th->ece = 1;
trickles-userapi_2.c:22076:  if (skb->h.th->cwr)
trickles-userapi_2.c:22077:    tp->ecn_flags &= ~4;
trickles-userapi_2.c:22083:  tp->ecn_flags &= ~4;
trickles-userapi_2.c:22089:  if (tp->ecn_flags & 1)
trickles-userapi_2.c:22091:      if (INET_ECN_is_ce (((struct tcp_skb_cb *) &((skb)->cb[0]))->flags))
trickles-userapi_2.c:22092:	tp->ecn_flags |= 4;
trickles-userapi_2.c:22098:	    ((((struct tcp_skb_cb *) &((skb)->cb[0]))->flags)))
trickles-userapi_2.c:22106:  if ((tp->ecn_flags & 1) && (!th->ece || th->cwr))
trickles-userapi_2.c:22107:    tp->ecn_flags &= ~1;
trickles-userapi_2.c:22113:  if ((tp->ecn_flags & 1) && (!th->ece || !th->cwr))
trickles-userapi_2.c:22114:    tp->ecn_flags &= ~1;
trickles-userapi_2.c:22120:  if (th->ece && !th->syn && (tp->ecn_flags & 1))
trickles-userapi_2.c:22128:  tp->ecn_flags = req->ecn_ok ? 1 : 0;
trickles-userapi_2.c:22134:  if (sysctl_tcp_ecn && th->ece && th->cwr)
trickles-userapi_2.c:22135:    req->ecn_ok = 1;
trickles-userapi_2.c:22147:  return sk->wmem_queued / 2;
trickles-userapi_2.c:22153:  return sk->sndbuf - sk->wmem_queued;
trickles-userapi_2.c:22160:  return tp->packets_out - tp->left_out + tp->retrans_out;
trickles-userapi_2.c:22173:	   const typeof (tp->snd_cwnd >> 1U) _x = (tp->snd_cwnd >> 1U);
trickles-userapi_2.c:22187:  if ((1 << tp->ca_state) & ((1 << TCP_CA_CWR) | (1 << TCP_CA_Recovery)))
trickles-userapi_2.c:22188:    return tp->snd_ssthresh;
trickles-userapi_2.c:22192:	     const typeof (tp->snd_ssthresh) _x = (tp->snd_ssthresh);
trickles-userapi_2.c:22193:	     const typeof (((tp->snd_cwnd >> 1) + (tp->snd_cwnd >> 2))) _y =
trickles-userapi_2.c:22194:	     (((tp->snd_cwnd >> 1) + (tp->snd_cwnd >> 2)));
trickles-userapi_2.c:22205:  if (tp->sack_ok && tp->sacked_out >= tp->packets_out - tp->lost_out)
trickles-userapi_2.c:22206:    tp->sacked_out = tp->packets_out - tp->lost_out;
trickles-userapi_2.c:22207:  tp->left_out = tp->sacked_out + tp->lost_out;
trickles-userapi_2.c:22217:  if (tp->packets_out >= tp->snd_cwnd)
trickles-userapi_2.c:22220:      tp->snd_cwnd_used = 0;
trickles-userapi_2.c:22221:      tp->snd_cwnd_stamp = ((__u32) (jiffies));
trickles-userapi_2.c:22226:      if (tp->packets_out > tp->snd_cwnd_used)
trickles-userapi_2.c:22227:	tp->snd_cwnd_used = tp->packets_out;
trickles-userapi_2.c:22229:      if ((s32) (((__u32) (jiffies)) - tp->snd_cwnd_stamp) >= tp->rto)
trickles-userapi_2.c:22238:  tp->undo_marker = 0;
trickles-userapi_2.c:22239:  tp->snd_ssthresh = tcp_recalc_ssthresh (tp);
trickles-userapi_2.c:22240:  tp->snd_cwnd = (
trickles-userapi_2.c:22242:		   const typeof (tp->snd_cwnd) _x = (tp->snd_cwnd);
trickles-userapi_2.c:22249:  tp->snd_cwnd_cnt = 0;
trickles-userapi_2.c:22250:  tp->high_seq = tp->snd_nxt;
trickles-userapi_2.c:22251:  tp->snd_cwnd_stamp = ((__u32) (jiffies));
trickles-userapi_2.c:22258:  tp->prior_ssthresh = 0;
trickles-userapi_2.c:22259:  if (tp->ca_state < TCP_CA_CWR)
trickles-userapi_2.c:22262:      tp->ca_state = TCP_CA_CWR;
trickles-userapi_2.c:22280:  return after (tp->snd_sml, tp->snd_una) &&
trickles-userapi_2.c:22281:    !after (tp->snd_sml, tp->snd_nxt);
trickles-userapi_2.c:22287:  if (skb->len < mss)
trickles-userapi_2.c:22288:    tp->snd_sml = ((struct tcp_skb_cb *) &((skb)->cb[0]))->end_seq;
trickles-userapi_2.c:22296:  return (skb->len < mss_now &&
trickles-userapi_2.c:22297:	  !(((struct tcp_skb_cb *) &((skb)->cb[0]))->flags & 0x01) &&
trickles-userapi_2.c:22299:	   (!nonagle && tp->packets_out && tcp_minshall_check (tp))));
trickles-userapi_2.c:22310:  return ((nonagle == 1 || tp->urg_mode
trickles-userapi_2.c:22312:	  ((tcp_packets_in_flight (tp) < tp->snd_cwnd) ||
trickles-userapi_2.c:22313:	   (((struct tcp_skb_cb *) &((skb)->cb[0]))->flags & 0x01)) &&
trickles-userapi_2.c:22314:	  !after (((struct tcp_skb_cb *) &((skb)->cb[0]))->end_seq,
trickles-userapi_2.c:22315:		  tp->snd_una + tp->snd_wnd));
trickles-userapi_2.c:22321:  if (!tp->packets_out && !tp->pending)
trickles-userapi_2.c:22322:    tcp_reset_xmit_timer (sk, 3, tp->rto);
trickles-userapi_2.c:22328:  return (skb->next == (struct sk_buff *) &sk->write_queue);
trickles-userapi_2.c:22339:  struct sk_buff *skb = tp->send_head;
trickles-userapi_2.c:22355:  __tcp_push_pending_frames (sk, tp, tcp_current_mss (sk), tp->nonagle);
trickles-userapi_2.c:22361:  struct sk_buff *skb = tp->send_head;
trickles-userapi_2.c:22365:			tcp_skb_is_last (sk, skb) ? 1 : tp->nonagle));
trickles-userapi_2.c:22371:  tp->snd_wl1 = seq;
trickles-userapi_2.c:22377:  tp->snd_wl1 = seq;
trickles-userapi_2.c:22397:    csum_fold (skb_checksum (skb, 0, skb->len, skb->csum));
trickles-userapi_2.c:22403:  return skb->ip_summed != 2 && __tcp_checksum_complete (skb);
trickles-userapi_2.c:22411:  tp->ucopy.task = ((void *) 0);
trickles-userapi_2.c:22412:  tp->ucopy.len = 0;
trickles-userapi_2.c:22413:  tp->ucopy.memory = 0;
trickles-userapi_2.c:22414:  skb_queue_head_init (&tp->ucopy.prequeue);
trickles-userapi_2.c:22421:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_2.c:22423:  if (!sysctl_tcp_low_latency && tp->ucopy.task)
trickles-userapi_2.c:22425:      __skb_queue_tail (&tp->ucopy.prequeue, skb);
trickles-userapi_2.c:22426:      tp->ucopy.memory += skb->truesize;
trickles-userapi_2.c:22427:      if (tp->ucopy.memory > sk->rcvbuf)
trickles-userapi_2.c:22431:	  if (sk->lock.users)
trickles-userapi_2.c:22434:	  while ((skb1 = __skb_dequeue (&tp->ucopy.prequeue)) != ((void *) 0))
trickles-userapi_2.c:22436:	      sk->backlog_rcv (sk, skb1);
trickles-userapi_2.c:22440:	  tp->ucopy.memory = 0;
trickles-userapi_2.c:22442:      else if (skb_queue_len (&tp->ucopy.prequeue) == 1)
trickles-userapi_2.c:22444:	  __wake_up ((sk->sleep), 1, 1);
trickles-userapi_2.c:22457:  int oldstate = sk->state;
trickles-userapi_2.c:22476:      sk->prot->unhash (sk);
trickles-userapi_2.c:22477:      if (sk->prev && !(sk->userlocks & 8))
trickles-userapi_2.c:22484:			  irq_stat[0].__local_bh_count) != 0)].TcpCurrEstab--;
trickles-userapi_2.c:22490:  sk->state = state;
trickles-userapi_2.c:22503:  sk->shutdown = 3;
trickles-userapi_2.c:22505:  if (!sk->dead)
trickles-userapi_2.c:22506:    sk->state_change (sk);
trickles-userapi_2.c:22514:  tp->dsack = 0;
trickles-userapi_2.c:22515:  tp->eff_sacks = 0;
trickles-userapi_2.c:22516:  tp->num_sacks = 0;
trickles-userapi_2.c:22522:  if (tp->tstamp_ok)
trickles-userapi_2.c:22538:      *ptr++ = htonl (tp->ts_recent);
trickles-userapi_2.c:22540:  if (tp->eff_sacks)
trickles-userapi_2.c:22543:	tp->dsack ? tp->duplicate_sack : tp->selective_acks;
trickles-userapi_2.c:22549:	    (((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) &
trickles-userapi_2.c:22552:	    (((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) &
trickles-userapi_2.c:22555:	    (((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) &
trickles-userapi_2.c:22558:	    (((1 << 24) | (1 << 16) | (5 << 8) | (2 + (tp->eff_sacks * 8)))) &
trickles-userapi_2.c:22564:      for (this_sack = 0; this_sack < tp->eff_sacks; this_sack++)
trickles-userapi_2.c:22569:      if (tp->dsack)
trickles-userapi_2.c:22571:	  tp->dsack = 0;
trickles-userapi_2.c:22572:	  tp->eff_sacks--;
trickles-userapi_2.c:22680:      if (*rcv_wscale && sysctl_tcp_app_win && space >= mss && space - (
trickles-userapi_2.c:22685:	(*rcv_wscale)--;
trickles-userapi_2.c:22717:    (space >> (-sysctl_tcp_adv_win_scale)) :
trickles-userapi_2.c:22718:    space - (space >> sysctl_tcp_adv_win_scale);
trickles-userapi_2.c:22725:  return tcp_win_from_space (sk->rcvbuf - ((&sk->rmem_alloc)->counter));
trickles-userapi_2.c:22731:  return tcp_win_from_space (sk->rcvbuf);
trickles-userapi_2.c:22737:  sk->ack_backlog--;
trickles-userapi_2.c:22743:  sk->ack_backlog++;
trickles-userapi_2.c:22749:  return sk->ack_backlog > sk->max_ack_backlog;
trickles-userapi_2.c:22756:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_2.c:22758:  req->sk = child;
trickles-userapi_2.c:22761:  if (!tp->accept_queue_tail)
trickles-userapi_2.c:22763:      tp->accept_queue = req;
trickles-userapi_2.c:22767:      tp->accept_queue_tail->dl_next = req;
trickles-userapi_2.c:22769:  tp->accept_queue_tail = req;
trickles-userapi_2.c:22770:  req->dl_next = ((void *) 0);
trickles-userapi_2.c:22786:  struct tcp_listen_opt *lopt = sk->tp_pinfo.af_tcp.listen_opt;
trickles-userapi_2.c:22788:  if (--lopt->qlen == 0)
trickles-userapi_2.c:22790:  if (req->retrans == 0)
trickles-userapi_2.c:22791:    lopt->qlen_young--;
trickles-userapi_2.c:22797:  struct tcp_listen_opt *lopt = sk->tp_pinfo.af_tcp.listen_opt;
trickles-userapi_2.c:22799:  if (lopt->qlen++ == 0)
trickles-userapi_2.c:22801:  lopt->qlen_young++;
trickles-userapi_2.c:22807:  return sk->tp_pinfo.af_tcp.listen_opt->qlen;
trickles-userapi_2.c:22813:  return sk->tp_pinfo.af_tcp.listen_opt->qlen_young;
trickles-userapi_2.c:22819:  return tcp_synq_len (sk) >> sk->tp_pinfo.af_tcp.listen_opt->max_qlen_log;
trickles-userapi_2.c:22826:  (void) (&tp->syn_wait_lock);
trickles-userapi_2.c:22827:  *prev = req->dl_next;
trickles-userapi_2.c:22838:  tcp_synq_unlink (&sk->tp_pinfo.af_tcp, req, prev);
trickles-userapi_2.c:22847:  req->rcv_wnd = 0;
trickles-userapi_2.c:22848:  req->rcv_isn = ((struct tcp_skb_cb *) &((skb)->cb[0]))->seq;
trickles-userapi_2.c:22849:  req->mss = tp->mss_clamp;
trickles-userapi_2.c:22850:  req->ts_recent = tp->saw_tstamp ? tp->rcv_tsval : 0;
trickles-userapi_2.c:22851:  req->tstamp_ok = tp->tstamp_ok;
trickles-userapi_2.c:22852:  req->sack_ok = tp->sack_ok;
trickles-userapi_2.c:22853:  req->snd_wscale = tp->snd_wscale;
trickles-userapi_2.c:22854:  req->wscale_ok = tp->wscale_ok;
trickles-userapi_2.c:22855:  req->acked = 0;
trickles-userapi_2.c:22856:  req->ecn_ok = 0;
trickles-userapi_2.c:22857:  req->rmt_port = skb->h.th->source;
trickles-userapi_2.c:22865:  sk->tp_pinfo.af_tcp.queue_shrunk = 1;
trickles-userapi_2.c:22866:  sk->wmem_queued -= skb->truesize;
trickles-userapi_2.c:22867:  sk->forward_alloc += skb->truesize;
trickles-userapi_2.c:22874:  sk->wmem_queued += skb->truesize;
trickles-userapi_2.c:22875:  sk->forward_alloc -= skb->truesize;
trickles-userapi_2.c:22884:  if (sk->forward_alloc >= ((int) (1UL << 12)))
trickles-userapi_2.c:22904:  if (!(sk->userlocks & 1))
trickles-userapi_2.c:22906:      sk->sndbuf = (
trickles-userapi_2.c:22908:		     const typeof (sk->sndbuf) _x = (sk->sndbuf);
trickles-userapi_2.c:22909:		     const typeof (sk->wmem_queued / 2) _y =
trickles-userapi_2.c:22910:		     (sk->wmem_queued / 2);
trickles-userapi_2.c:22914:      sk->sndbuf = (
trickles-userapi_2.c:22916:		     const typeof (sk->sndbuf) _x = (sk->sndbuf);
trickles-userapi_2.c:22931:      skb->truesize += mem;
trickles-userapi_2.c:22932:      if (sk->forward_alloc >= (int) skb->truesize ||
trickles-userapi_2.c:22933:	  tcp_mem_schedule (sk, skb->truesize, 0))
trickles-userapi_2.c:22957:  if (sk->forward_alloc >= (int) (1UL << 12) ||
trickles-userapi_2.c:22960:      struct page *page = alloc_pages (sk->allocation, 0);
trickles-userapi_2.c:22974:  while ((skb = __skb_dequeue (&sk->write_queue)) != ((void *) 0))
trickles-userapi_2.c:22984:  skb->sk = sk;
trickles-userapi_2.c:22985:  skb->destructor = tcp_rfree;
trickles-userapi_2.c:22986:  atomic_add (skb->truesize, &sk->rmem_alloc);
trickles-userapi_2.c:22987:  sk->forward_alloc -= skb->truesize;
trickles-userapi_2.c:23019:  return tp->keepalive_intvl ? : sysctl_tcp_keepalive_intvl;
trickles-userapi_2.c:23025:  return tp->keepalive_time ? : sysctl_tcp_keepalive_time;
trickles-userapi_2.c:23031:  int fin_timeout = tp->linger2 ? : sysctl_tcp_fin_timeout;
trickles-userapi_2.c:23033:  if (fin_timeout < (tp->rto << 2) - (tp->rto >> 1))
trickles-userapi_2.c:23034:    fin_timeout = (tp->rto << 2) - (tp->rto >> 1);
trickles-userapi_2.c:23042:  if ((s32) (tp->rcv_tsval - tp->ts_recent) >= 0)
trickles-userapi_2.c:23044:  if (xtime.tv_sec >= tp->ts_recent_stamp + (60 * 60 * 24 * 24))
trickles-userapi_2.c:23047:  if (rst && xtime.tv_sec >= tp->ts_recent_stamp + 60)
trickles-userapi_2.c:23057:  const struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_2.c:23063:  return (sysctl_tcp_frto && tp->send_head &&
trickles-userapi_2.c:23064:	  !after (((struct tcp_skb_cb *) &((tp->send_head)->cb[0]))->end_seq,
trickles-userapi_2.c:23065:		  tp->snd_una + tp->snd_wnd));
trickles-userapi_2.c:23077:  ((tcp_statistics)[2 * 0 + 1].TcpMaxConn += -1);
trickles-userapi_2.c:23090:    tp->westwood.rtt = rtt_seq;
trickles-userapi_2.c:23099:  struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:23101:  tp->westwood.bw_ns_est = 0;
trickles-userapi_2.c:23102:  tp->westwood.bw_est = 0;
trickles-userapi_2.c:23103:  tp->westwood.accounted = 0;
trickles-userapi_2.c:23104:  tp->westwood.cumul_ack = 0;
trickles-userapi_2.c:23105:  tp->westwood.rtt_win_sx = ((__u32) (jiffies));
trickles-userapi_2.c:23106:  tp->westwood.rtt = 20 * 100;
trickles-userapi_2.c:23107:  tp->westwood.rtt_min = 20 * 100;
trickles-userapi_2.c:23108:  tp->westwood.snd_una = tp->snd_una;
trickles-userapi_2.c:23134:  return (__u32) ((tp->westwood.bw_est) * (tp->westwood.rtt_min) /
trickles-userapi_2.c:23135:		  (__u32) (tp->mss_cache));
trickles-userapi_2.c:23168:      tp->snd_ssthresh = ssthresh;
trickles-userapi_2.c:23186:      tp->snd_cwnd = cwnd;
trickles-userapi_2.c:23202:	  tp->snd_ssthresh = tp->snd_cwnd;
trickles-userapi_2.c:23491:  struct sock *sk = skb->sk;
trickles-userapi_2.c:23492:  if (skb->ip_summed == 1)
trickles-userapi_2.c:23494:      skb->h.th->check = 0;
trickles-userapi_2.c:23495:      skb->h.th->check =
trickles-userapi_2.c:23496:	~tcp_v4_check (skb->h.th, skb->len, sk->saddr, sk->daddr, 0);
trickles-userapi_2.c:23497:      skb->csum = ((size_t) & ((struct tcphdr *) 0)->check);
trickles-userapi_2.c:23501:      skb->h.th->check = 0;
trickles-userapi_2.c:23502:      skb->h.th->check =
trickles-userapi_2.c:23503:	tcp_v4_check (skb->h.th, skb->len, sk->saddr, sk->daddr,
trickles-userapi_2.c:23504:		      csum_partial ((char *) skb->h.th, headerLen,
trickles-userapi_2.c:23505:				    skb->csum));
trickles-userapi_2.c:23535:  POISONEDRANGE = -1,
trickles-userapi_2.c:23591:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_2.c:23592:  if (!(dataReq->list == ((void *) 0)))
trickles-userapi_2.c:23594:      printk ("KERNEL: assertion (" "dataReq->list == NULL" ") failed at "
trickles-userapi_2.c:23598:  dataReq->completed = 0;
trickles-userapi_2.c:23599:  dataReq->sent = 0;
trickles-userapi_2.c:23601:  dataReq->transportResponseSeqStart = (4294967295U);
trickles-userapi_2.c:23602:  dataReq->transportResponseSeqEnd = (4294967295U);
trickles-userapi_2.c:23603:  dataReq->timestamp = (4294967295U);
trickles-userapi_2.c:23604:  dataReq->start = newStart;
trickles-userapi_2.c:23605:  dataReq->end = newEnd;
trickles-userapi_2.c:23606:  insert_tail (&tp->t.missingDataMap, (struct alloc_head *) dataReq);
trickles-userapi_2.c:23640:  newMapping->next = newMapping->prev = ((void *) 0);
trickles-userapi_2.c:23641:  newMapping->list = ((void *) 0);
trickles-userapi_2.c:23643:  newMapping->completed = 0;
trickles-userapi_2.c:23644:  newMapping->ucont = ucont;
trickles-userapi_2.c:23645:  newMapping->transportResponseSeqStart = tseq_start;
trickles-userapi_2.c:23646:  newMapping->transportResponseSeqEnd = tseq_end;
trickles-userapi_2.c:23647:  newMapping->sent = 0;
trickles-userapi_2.c:23648:  newMapping->start = start;
trickles-userapi_2.c:23649:  newMapping->end = end;
trickles-userapi_2.c:23651:  newMapping->timestamp = jiffies;
trickles-userapi_2.c:23661:  numDataRequestMappings--;
trickles-userapi_2.c:23701:  req->numChildren = 0;
trickles-userapi_2.c:23702:  req->childrenMask = 0;
trickles-userapi_2.c:23703:  req->transport_seq = -1;
trickles-userapi_2.c:23704:  req->seq = -1;
trickles-userapi_2.c:23705:  req->isNew = 1;
trickles-userapi_2.c:23712:  req->type = type;
trickles-userapi_2.c:23713:  req->prev = req->next = ((void *) 0);
trickles-userapi_2.c:23714:  req->list = ((void *) 0);
trickles-userapi_2.c:23716:  req->start = req->end = -1;
trickles-userapi_2.c:23717:  req->allocated = 1;
trickles-userapi_2.c:23725:  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_2.c:23726:  insert_tail (&tp->t.queuedRequests, (struct alloc_head *) req);
trickles-userapi_2.c:23727:  tp->t.timerState |= (0x1);
trickles-userapi_2.c:23775:  req->incomplete = 0;
trickles-userapi_2.c:23776:  req->completePred = pred;
trickles-userapi_2.c:23777:  atomic_inc (&req->completePred->refcnt);
trickles-userapi_2.c:23779:  if (((&req->completePred->refcnt)->counter) < 2)
trickles-userapi_2.c:23784:  req->data = data;
trickles-userapi_2.c:23785:  req->start = start;
trickles-userapi_2.c:23786:  req->offset = req->start - ((struct tcp_skb_cb *) &((data)->cb[0]))->seq;
trickles-userapi_2.c:23796:  req->incomplete = 1;
trickles-userapi_2.c:23797:  req->incompletePred = pred;
trickles-userapi_2.c:23798:  req->predLength = predLength;
trickles-userapi_2.c:23799:  req->data = data;
trickles-userapi_2.c:23800:  req->offset = offset;
trickles-userapi_2.c:23836:  req->start = start;
trickles-userapi_2.c:23837:  req->end = end;
trickles-userapi_2.c:23838:  req->numConts = numConts;
trickles-userapi_2.c:23839:  req->conts = kmalloc (sizeof (struct UC_Continuation *) * numConts, (0x20));
trickles-userapi_2.c:23844:      return -1;
trickles-userapi_2.c:23859:  newReq->conts =
trickles-userapi_2.c:23860:    kmalloc (sizeof (struct UC_Continuation *) * newReq->numConts, (0x20));
trickles-userapi_2.c:23861:  if (newReq->conts == ((void *) 0))
trickles-userapi_2.c:23866:  (__builtin_constant_p (sizeof (struct UC_Continuation *) * newReq->numConts)
trickles-userapi_2.c:23867:   ? __constant_memcpy ((newReq->conts), (src->conts),
trickles-userapi_2.c:23869:			 newReq->numConts)) : __memcpy ((newReq->conts),
trickles-userapi_2.c:23870:							(src->conts),
trickles-userapi_2.c:23874:							 newReq->numConts)));
trickles-userapi_2.c:23903:  rval->prev = rval->next = ((void *) 0);
trickles-userapi_2.c:23904:  rval->list = ((void *) 0);
trickles-userapi_2.c:23906:  rval->cont = cont;
trickles-userapi_2.c:23907:  rval->isSynack = isSynack;
trickles-userapi_2.c:23908:  rval->parent = parent;
trickles-userapi_2.c:23909:  rval->numSiblings = numSiblings;
trickles-userapi_2.c:23910:  rval->position = position;
trickles-userapi_2.c:23958:  dcont->clientState = scont->clientState;
trickles-userapi_2.c:23959:  dcont->parent = scont->parent;
trickles-userapi_2.c:23964:	(dcont)->seq = htonl ((scont)->packets[pktNum].seq);
trickles-userapi_2.c:23965:	(dcont)->continuationType = (scont)->packets[pktNum].contType;
trickles-userapi_2.c:23966:	if ((scont)->packets[pktNum].type & (0x80))
trickles-userapi_2.c:23968:	(dcont)->firstChild = 1;}
trickles-userapi_2.c:23971:	(dcont)->firstChild = 0;}
trickles-userapi_2.c:23975:	int conversionOffset = (scont)->packets[pktNum].type & (0x3);
trickles-userapi_2.c:23985:	(dcont)->state = stateConversionMap[conversionOffset];}
trickles-userapi_2.c:23987:	  dcont->timestamp = htonl (scont->timestamp);
trickles-userapi_2.c:23988:	  dcont->clientTimestamp = scont->clientTimestamp;
trickles-userapi_2.c:23989:	  dcont->mrtt = htonl (scont->mrtt);
trickles-userapi_2.c:23993:	  dcont->seq = htonl (scont->seq);
trickles-userapi_2.c:23994:	  dcont->continuationType = scont->continuationType;
trickles-userapi_2.c:23995:	  dcont->firstChild = scont->firstChild;
trickles-userapi_2.c:23996:	  dcont->state = scont->state;
trickles-userapi_2.c:23997:	  dcont->timestamp = scont->rawTimestamp;
trickles-userapi_2.c:23998:	  dcont->clientTimestamp = scont->clientTimestamp;
trickles-userapi_2.c:23999:	  dcont->mrtt = scont->rawMrtt;
trickles-userapi_2.c:24001:	dcont->firstLoss = htonl (scont->firstLoss);
trickles-userapi_2.c:24002:	dcont->firstBootstrapSeq = htonl (scont->firstBootstrapSeq);
trickles-userapi_2.c:24003:	dcont->startCwnd = htonl (scont->startCwnd);
trickles-userapi_2.c:24004:	dcont->ssthresh = htonl (scont->ssthresh);
trickles-userapi_2.c:24005:	dcont->TCPBase = htonl (scont->TCPBase);
trickles-userapi_2.c:24006:	dcont->tokenCounterBase = scont->tokenCounterBase;
trickles-userapi_2.c:24010:	    phdr->seq = dcont->seq;
trickles-userapi_2.c:24011:	    phdr->type = dcont->continuationType;
trickles-userapi_2.c:24012:	    phdr->first = dcont->firstChild ? 1 : 0;
trickles-userapi_2.c:24013:	    phdr->serverAddr = scont->saddr;
trickles-userapi_2.c:24014:	    phdr->serverPort = scont->source;
trickles-userapi_2.c:24015:	    phdr->clientAddr = scont->daddr;
trickles-userapi_2.c:24016:	    phdr->clientPort = scont->dest;
trickles-userapi_2.c:24017:	    computeMAC (sk, phdr, dcont, dcont->mac);
trickles-userapi_2.c:24028:	dcont->clientState = scont->clientState;
trickles-userapi_2.c:24029:	dcont->parent = scont->parent;
trickles-userapi_2.c:24034:	      (dcont)->seq = htonl ((scont)->packets[pktNum].seq);
trickles-userapi_2.c:24035:	      (dcont)->continuationType = (scont)->packets[pktNum].contType;
trickles-userapi_2.c:24036:	      if ((scont)->packets[pktNum].type & (0x80))
trickles-userapi_2.c:24038:	      (dcont)->firstChild = 1;}
trickles-userapi_2.c:24041:	      (dcont)->firstChild = 0;}
trickles-userapi_2.c:24045:	      int conversionOffset = (scont)->packets[pktNum].type & (0x3);
trickles-userapi_2.c:24055:	      (dcont)->state = stateConversionMap[conversionOffset];}
trickles-userapi_2.c:24057:		dcont->timestamp = htonl (scont->timestamp);
trickles-userapi_2.c:24058:		dcont->clientTimestamp = scont->clientTimestamp;
trickles-userapi_2.c:24059:		dcont->mrtt = htonl (scont->mrtt);
trickles-userapi_2.c:24063:		dcont->seq = htonl (scont->seq);
trickles-userapi_2.c:24064:		dcont->continuationType = scont->continuationType;
trickles-userapi_2.c:24065:		dcont->firstChild = scont->firstChild;
trickles-userapi_2.c:24066:		dcont->state = scont->state;
trickles-userapi_2.c:24067:		dcont->timestamp = scont->rawTimestamp;
trickles-userapi_2.c:24068:		dcont->clientTimestamp = scont->clientTimestamp;
trickles-userapi_2.c:24069:		dcont->mrtt = scont->rawMrtt;
trickles-userapi_2.c:24071:	      dcont->firstLoss = htonl (scont->firstLoss);
trickles-userapi_2.c:24072:	      dcont->firstBootstrapSeq = htonl (scont->firstBootstrapSeq);
trickles-userapi_2.c:24073:	      dcont->startCwnd = htonl (scont->startCwnd);
trickles-userapi_2.c:24074:	      dcont->ssthresh = htonl (scont->ssthresh);
trickles-userapi_2.c:24075:	      dcont->TCPBase = htonl (scont->TCPBase);
trickles-userapi_2.c:24076:	      dcont->tokenCounterBase = scont->tokenCounterBase;
trickles-userapi_2.c:24080:		   __constant_memcpy ((dcont->mac), (scont->mac),
trickles-userapi_2.c:24081:				      (16)) : __memcpy ((dcont->mac),
trickles-userapi_2.c:24082:							(scont->mac), (16)));
trickles-userapi_2.c:24093:	      dcont->clientState = scont->clientState;
trickles-userapi_2.c:24094:	      dcont->parent = scont->parent;
trickles-userapi_2.c:24099:		    (dcont)->seq = htonl ((scont)->packets[pktNum].seq);
trickles-userapi_2.c:24100:		    (dcont)->continuationType =
trickles-userapi_2.c:24101:		    (scont)->packets[pktNum].contType;
trickles-userapi_2.c:24102:		    if ((scont)->packets[pktNum].type & (0x80))
trickles-userapi_2.c:24104:		    (dcont)->firstChild = 1;}
trickles-userapi_2.c:24107:		    (dcont)->firstChild = 0;}
trickles-userapi_2.c:24112:		    (scont)->packets[pktNum].type & (0x3);
trickles-userapi_2.c:24122:		    (dcont)->state = stateConversionMap[conversionOffset];}
trickles-userapi_2.c:24124:		      dcont->timestamp = htonl (scont->timestamp);
trickles-userapi_2.c:24125:		      dcont->clientTimestamp = scont->clientTimestamp;
trickles-userapi_2.c:24126:		      dcont->mrtt = htonl (scont->mrtt);
trickles-userapi_2.c:24130:		      dcont->seq = htonl (scont->seq);
trickles-userapi_2.c:24131:		      dcont->continuationType = scont->continuationType;
trickles-userapi_2.c:24132:		      dcont->firstChild = scont->firstChild;
trickles-userapi_2.c:24133:		      dcont->state = scont->state;
trickles-userapi_2.c:24134:		      dcont->timestamp = scont->rawTimestamp;
trickles-userapi_2.c:24135:		      dcont->clientTimestamp = scont->clientTimestamp;
trickles-userapi_2.c:24136:		      dcont->mrtt = scont->rawMrtt;
trickles-userapi_2.c:24138:		    dcont->firstLoss = htonl (scont->firstLoss);
trickles-userapi_2.c:24139:		    dcont->firstBootstrapSeq =
trickles-userapi_2.c:24140:		      htonl (scont->firstBootstrapSeq);
trickles-userapi_2.c:24141:		    dcont->startCwnd = htonl (scont->startCwnd);
trickles-userapi_2.c:24142:		    dcont->ssthresh = htonl (scont->ssthresh);
trickles-userapi_2.c:24143:		    dcont->TCPBase = htonl (scont->TCPBase);
trickles-userapi_2.c:24144:		    dcont->tokenCounterBase = scont->tokenCounterBase;
trickles-userapi_2.c:24148:			 __constant_memcpy ((dcont->mac), (scont->mac),
trickles-userapi_2.c:24149:					    (16)) : __memcpy ((dcont->mac),
trickles-userapi_2.c:24150:							      (scont->mac),
trickles-userapi_2.c:24166:		    dproof->numSacks = (
trickles-userapi_2.c:24168:					 typeof (sproof->numSacks) Z =
trickles-userapi_2.c:24169:					 (typeof (sproof->numSacks)) (64);
trickles-userapi_2.c:24172:					   const typeof (sproof->
trickles-userapi_2.c:24174:					   (sproof->numSacks);
trickles-userapi_2.c:24180:		    for (i = 0; i < dproof->numSacks; i++)
trickles-userapi_2.c:24182:			dproof->sacks[i].left =
trickles-userapi_2.c:24183:			  htonl (sproof->sacks[i].left);;
trickles-userapi_2.c:24184:			dproof->sacks[i].right =
trickles-userapi_2.c:24185:			  htonl (sproof->sacks[i].right);;
trickles-userapi_2.c:24186:			dproof->sacks[i].nonceSummary =
trickles-userapi_2.c:24187:			  sproof->sacks[i].nonceSummary;
trickles-userapi_2.c:24211:			    ((!(((skb->sk)->tp_pinfo.af_tcp.
trickles-userapi_2.c:24213:				&& !((skb->sk)->tp_pinfo.af_tcp.
trickles-userapi_2.c:24214:				     trickles_opt & (skb->sk)->tp_pinfo.
trickles-userapi_2.c:24219:			    phdr->seq = scont->seq;
trickles-userapi_2.c:24220:			    phdr->type = scont->continuationType;
trickles-userapi_2.c:24221:			    phdr->first = scont->firstChild;
trickles-userapi_2.c:24222:			    phdr->serverAddr = skb->nh.iph->daddr;
trickles-userapi_2.c:24223:			    phdr->serverPort = skb->h.th->dest;
trickles-userapi_2.c:24224:			    phdr->clientAddr = skb->nh.iph->saddr;
trickles-userapi_2.c:24225:			    phdr->clientPort = skb->h.th->source;
trickles-userapi_2.c:24226:			    computeMAC (skb->sk, phdr, scont, mac);
trickles-userapi_2.c:24227:			    if (__builtin_memcmp (mac, scont->mac, 16))
trickles-userapi_2.c:24235:		    dcont->continuationType = scont->continuationType;
trickles-userapi_2.c:24236:		    dcont->seq = ntohl (scont->seq);;
trickles-userapi_2.c:24237:		    dcont->clientState = scont->clientState;
trickles-userapi_2.c:24238:		    dcont->parent = scont->parent;
trickles-userapi_2.c:24239:		    dcont->rawTimestamp = scont->timestamp;
trickles-userapi_2.c:24240:		    dcont->timestamp = ntohl (scont->timestamp);
trickles-userapi_2.c:24241:		    dcont->rawMrtt = scont->mrtt;
trickles-userapi_2.c:24242:		    dcont->mrtt = ntohl (scont->mrtt);;
trickles-userapi_2.c:24243:		    dcont->clientTimestamp = scont->clientTimestamp;
trickles-userapi_2.c:24244:		    dcont->state = scont->state;
trickles-userapi_2.c:24245:		    dcont->firstChild = scont->firstChild;
trickles-userapi_2.c:24246:		    dcont->firstLoss = ntohl (scont->firstLoss);;
trickles-userapi_2.c:24247:		    dcont->firstBootstrapSeq =
trickles-userapi_2.c:24248:		      ntohl (scont->firstBootstrapSeq);;
trickles-userapi_2.c:24249:		    dcont->startCwnd = ntohl (scont->startCwnd);;
trickles-userapi_2.c:24250:		    dcont->ssthresh = ntohl (scont->ssthresh);;
trickles-userapi_2.c:24251:		    dcont->TCPBase = ntohl (scont->TCPBase);;
trickles-userapi_2.c:24253:			((!(((skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-userapi_2.c:24254:			    && !((skb->sk)->tp_pinfo.af_tcp.
trickles-userapi_2.c:24255:				 trickles_opt & (skb->sk)->tp_pinfo.af_tcp.
trickles-userapi_2.c:24258:			dcont->saddr = skb->nh.iph->daddr;
trickles-userapi_2.c:24259:			dcont->daddr = skb->nh.iph->saddr;
trickles-userapi_2.c:24260:			dcont->source = skb->h.th->dest;
trickles-userapi_2.c:24261:			dcont->dest = skb->h.th->source;
trickles-userapi_2.c:24263:		    dcont->tokenCounterBase = scont->tokenCounterBase;
trickles-userapi_2.c:24264:		    dcont->num_packets = 0;
trickles-userapi_2.c:24265:		    dcont->numChildrenReceived = 0;
trickles-userapi_2.c:24266:		    dcont->parentMSK = ((void *) 0);;
trickles-userapi_2.c:24288:			    ((!(((skb->sk)->tp_pinfo.af_tcp.
trickles-userapi_2.c:24290:				&& !((skb->sk)->tp_pinfo.af_tcp.
trickles-userapi_2.c:24291:				     trickles_opt & (skb->sk)->tp_pinfo.
trickles-userapi_2.c:24296:			    phdr->seq = scont->seq;
trickles-userapi_2.c:24297:			    phdr->type = scont->continuationType;
trickles-userapi_2.c:24298:			    phdr->first = scont->firstChild;
trickles-userapi_2.c:24299:			    phdr->serverAddr = skb->nh.iph->daddr;
trickles-userapi_2.c:24300:			    phdr->serverPort = skb->h.th->dest;
trickles-userapi_2.c:24301:			    phdr->clientAddr = skb->nh.iph->saddr;
trickles-userapi_2.c:24302:			    phdr->clientPort = skb->h.th->source;
trickles-userapi_2.c:24303:			    computeMAC (skb->sk, phdr, scont, mac);
trickles-userapi_2.c:24304:			    if (__builtin_memcmp (mac, scont->mac, 16))
trickles-userapi_2.c:24312:		    dcont->continuationType = scont->continuationType;
trickles-userapi_2.c:24313:		    dcont->seq = ntohl (scont->seq);;
trickles-userapi_2.c:24314:		    dcont->clientState = scont->clientState;
trickles-userapi_2.c:24315:		    dcont->parent = scont->parent;
trickles-userapi_2.c:24316:		    dcont->rawTimestamp = scont->timestamp;
trickles-userapi_2.c:24317:		    dcont->rawMrtt = scont->mrtt;;
trickles-userapi_2.c:24318:		    dcont->clientTimestamp = scont->clientTimestamp;
trickles-userapi_2.c:24319:		    dcont->state = scont->state;
trickles-userapi_2.c:24320:		    dcont->firstChild = scont->firstChild;
trickles-userapi_2.c:24321:		    dcont->firstLoss = ntohl (scont->firstLoss);;
trickles-userapi_2.c:24322:		    dcont->firstBootstrapSeq =
trickles-userapi_2.c:24323:		      ntohl (scont->firstBootstrapSeq);;
trickles-userapi_2.c:24324:		    dcont->startCwnd = ntohl (scont->startCwnd);;
trickles-userapi_2.c:24325:		    dcont->ssthresh = ntohl (scont->ssthresh);;
trickles-userapi_2.c:24326:		    dcont->TCPBase = ntohl (scont->TCPBase);;
trickles-userapi_2.c:24327:		    dcont->daddr = skb->nh.iph->saddr;
trickles-userapi_2.c:24328:		    dcont->dest = skb->h.th->source;;
trickles-userapi_2.c:24329:		    dcont->tokenCounterBase = scont->tokenCounterBase;
trickles-userapi_2.c:24330:		    dcont->num_packets = 0;;
trickles-userapi_2.c:24346:		    dcont->continuationType = scont->continuationType;
trickles-userapi_2.c:24347:		    dcont->seq = scont->seq;
trickles-userapi_2.c:24348:		    dcont->clientState = scont->clientState;
trickles-userapi_2.c:24349:		    dcont->parent = scont->parent;
trickles-userapi_2.c:24350:		    dcont->rawTimestamp = scont->rawTimestamp;
trickles-userapi_2.c:24351:		    dcont->timestamp = ntohl (scont->rawTimestamp);
trickles-userapi_2.c:24352:		    dcont->rawMrtt = scont->rawMrtt;
trickles-userapi_2.c:24353:		    dcont->mrtt = ntohl (scont->rawMrtt);;
trickles-userapi_2.c:24354:		    dcont->clientTimestamp = scont->clientTimestamp;
trickles-userapi_2.c:24355:		    dcont->state = scont->state;
trickles-userapi_2.c:24356:		    dcont->firstChild = scont->firstChild;
trickles-userapi_2.c:24357:		    dcont->firstLoss = scont->firstLoss;
trickles-userapi_2.c:24358:		    dcont->firstBootstrapSeq = scont->firstBootstrapSeq;
trickles-userapi_2.c:24359:		    dcont->startCwnd = scont->startCwnd;
trickles-userapi_2.c:24360:		    dcont->ssthresh = scont->ssthresh;
trickles-userapi_2.c:24361:		    dcont->TCPBase = scont->TCPBase;
trickles-userapi_2.c:24362:		    dcont->saddr = sk->saddr;
trickles-userapi_2.c:24363:		    dcont->source = sk->sport;
trickles-userapi_2.c:24364:		    dcont->daddr = scont->daddr;
trickles-userapi_2.c:24365:		    dcont->dest = scont->dest;;
trickles-userapi_2.c:24366:		    dcont->tokenCounterBase = scont->tokenCounterBase;
trickles-userapi_2.c:24367:		    dcont->num_packets = 0;;
trickles-userapi_2.c:24368:		    dcont->pmsk = scont;;
trickles-userapi_2.c:24384:		    dcont->continuationType = scont->continuationType;
trickles-userapi_2.c:24385:		    dcont->seq = scont->seq;
trickles-userapi_2.c:24386:		    dcont->clientState = scont->clientState;
trickles-userapi_2.c:24387:		    dcont->parent = scont->parent;
trickles-userapi_2.c:24388:		    dcont->rawTimestamp = scont->rawTimestamp;
trickles-userapi_2.c:24389:		    dcont->rawMrtt = scont->rawMrtt;;
trickles-userapi_2.c:24390:		    dcont->clientTimestamp = scont->clientTimestamp;
trickles-userapi_2.c:24391:		    dcont->state = scont->state;
trickles-userapi_2.c:24392:		    dcont->firstChild = scont->firstChild;
trickles-userapi_2.c:24393:		    dcont->firstLoss = scont->firstLoss;
trickles-userapi_2.c:24394:		    dcont->firstBootstrapSeq = scont->firstBootstrapSeq;
trickles-userapi_2.c:24395:		    dcont->startCwnd = scont->startCwnd;
trickles-userapi_2.c:24396:		    dcont->ssthresh = scont->ssthresh;
trickles-userapi_2.c:24397:		    dcont->TCPBase = scont->TCPBase;
trickles-userapi_2.c:24398:		    dcont->daddr = scont->daddr;
trickles-userapi_2.c:24399:		    dcont->dest = scont->dest;;
trickles-userapi_2.c:24400:		    dcont->tokenCounterBase = scont->tokenCounterBase;
trickles-userapi_2.c:24401:		    dcont->num_packets = 0;;
trickles-userapi_2.c:24402:		    dcont->num_packets = scont->num_packets;
trickles-userapi_2.c:24403:		    dcont->ucont_data = scont->ucont_data;
trickles-userapi_2.c:24404:		    dcont->ucont_len = scont->ucont_len;
trickles-userapi_2.c:24405:		    dcont->input = scont->input;
trickles-userapi_2.c:24406:		    dcont->input_len = scont->input_len;
trickles-userapi_2.c:24407:		    dcont->packets = scont->packets;;
trickles-userapi_2.c:24429:			 __constant_memcpy ((dcont->mac), (scont->mac),
trickles-userapi_2.c:24430:					    (16)) : __memcpy ((dcont->mac),
trickles-userapi_2.c:24431:							      (scont->mac),
trickles-userapi_2.c:24435:		    dcont->continuationType = scont->continuationType;
trickles-userapi_2.c:24436:		    dcont->seq = ntohl (scont->seq);;
trickles-userapi_2.c:24437:		    dcont->clientState = scont->clientState;
trickles-userapi_2.c:24438:		    dcont->parent = scont->parent;
trickles-userapi_2.c:24439:		    dcont->rawTimestamp = scont->timestamp;
trickles-userapi_2.c:24440:		    dcont->timestamp = ntohl (scont->timestamp);
trickles-userapi_2.c:24441:		    dcont->rawMrtt = scont->mrtt;
trickles-userapi_2.c:24442:		    dcont->mrtt = ntohl (scont->mrtt);;
trickles-userapi_2.c:24443:		    dcont->clientTimestamp = scont->clientTimestamp;
trickles-userapi_2.c:24444:		    dcont->state = scont->state;
trickles-userapi_2.c:24445:		    dcont->firstChild = scont->firstChild;
trickles-userapi_2.c:24446:		    dcont->firstLoss = ntohl (scont->firstLoss);;
trickles-userapi_2.c:24447:		    dcont->firstBootstrapSeq =
trickles-userapi_2.c:24448:		      ntohl (scont->firstBootstrapSeq);;
trickles-userapi_2.c:24449:		    dcont->startCwnd = ntohl (scont->startCwnd);;
trickles-userapi_2.c:24450:		    dcont->ssthresh = ntohl (scont->ssthresh);;
trickles-userapi_2.c:24451:		    dcont->TCPBase = ntohl (scont->TCPBase);;
trickles-userapi_2.c:24453:			((!(((skb->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-userapi_2.c:24454:			    && !((skb->sk)->tp_pinfo.af_tcp.
trickles-userapi_2.c:24455:				 trickles_opt & (skb->sk)->tp_pinfo.af_tcp.
trickles-userapi_2.c:24458:			dcont->saddr = skb->nh.iph->daddr;
trickles-userapi_2.c:24459:			dcont->daddr = skb->nh.iph->saddr;
trickles-userapi_2.c:24460:			dcont->source = skb->h.th->dest;
trickles-userapi_2.c:24461:			dcont->dest = skb->h.th->source;
trickles-userapi_2.c:24463:		    dcont->tokenCounterBase = scont->tokenCounterBase;
trickles-userapi_2.c:24464:		    dcont->num_packets = 0;
trickles-userapi_2.c:24465:		    dcont->numChildrenReceived = 0;
trickles-userapi_2.c:24466:		    dcont->parentMSK = ((void *) 0);;
trickles-userapi_2.c:24487:		    for (i = 0; i < (((cont) + 1)->num_packets); i++)
trickles-userapi_2.c:24489:			total += (((cont) + 1)->packets)[i].len;
trickles-userapi_2.c:24534:		    rval->prev = rval->next = ((void *) 0);
trickles-userapi_2.c:24535:		    rval->list = ((void *) 0);
trickles-userapi_2.c:24542:			(rval + i)->ucont_len = 0;
trickles-userapi_2.c:24543:			(rval + i)->ucont_data = ((void *) 0);
trickles-userapi_2.c:24544:			(rval + i)->input_len = 0;
trickles-userapi_2.c:24545:			(rval + i)->input = ((void *) 0);
trickles-userapi_2.c:24547:			(rval + i)->mark = 0;
trickles-userapi_2.c:24548:			(rval + i)->simulated = 0;
trickles-userapi_2.c:24550:		    rval->sk = ((void *) 0);
trickles-userapi_2.c:24587:		    rval->prev = rval->next = ((void *) 0);
trickles-userapi_2.c:24588:		    rval->list = ((void *) 0);
trickles-userapi_2.c:24591:		     ((int) ((struct cminisock *) 0)->
trickles-userapi_2.c:24597:								   *) 0)->
trickles-userapi_2.c:24600:				 ((int) ((struct cminisock *) 0)->
trickles-userapi_2.c:24605:			(rval + i)->ucont_len = 0;
trickles-userapi_2.c:24606:			(rval + i)->ucont_data = ((void *) 0);
trickles-userapi_2.c:24608:			(rval + i)->input_len = 0;
trickles-userapi_2.c:24609:			(rval + i)->input = ((void *) 0);
trickles-userapi_2.c:24611:			(rval + i)->mark = 0;
trickles-userapi_2.c:24612:			(rval + i)->simulated = 0;
trickles-userapi_2.c:24613:			(rval + i)->num_packets = 0;
trickles-userapi_2.c:24614:			(rval + i)->actualCwnd = 0;
trickles-userapi_2.c:24628:		    if (cont->list)
trickles-userapi_2.c:24644:			if ((cont + i)->ucont_data)
trickles-userapi_2.c:24645:			  kfree ((cont + i)->ucont_data);
trickles-userapi_2.c:24646:			if ((cont + i)->input)
trickles-userapi_2.c:24647:			  kfree ((cont + i)->input);
trickles-userapi_2.c:24663:		    dproof->numSacks = sproof->numSacks;
trickles-userapi_2.c:24664:		    for (i = 0; i < sproof->numSacks; i++)
trickles-userapi_2.c:24666:			dproof->sacks[i].left =
trickles-userapi_2.c:24667:			  ntohl (sproof->sacks[i].left);;
trickles-userapi_2.c:24668:			dproof->sacks[i].right =
trickles-userapi_2.c:24669:			  ntohl (sproof->sacks[i].right);;
trickles-userapi_2.c:24670:			dproof->sacks[i].nonceSummary =
trickles-userapi_2.c:24671:			  sproof->sacks[i].nonceSummary;
trickles-userapi_2.c:24682:		      length - sizeof (struct WireUC_Continuation);
trickles-userapi_2.c:24693:		    rval->prev = rval->next = ((void *) 0);
trickles-userapi_2.c:24694:		    rval->list = ((void *) 0);
trickles-userapi_2.c:24696:		    rval->seq = ntohl (scont->seq);
trickles-userapi_2.c:24697:		    rval->validStart = ntohl (scont->validStart);
trickles-userapi_2.c:24698:		    rval->validEnd = ntohl (scont->validEnd);
trickles-userapi_2.c:24699:		    rval->fields = scont->fields;
trickles-userapi_2.c:24700:		    rval->dataLen = dataLen;
trickles-userapi_2.c:24701:		    rval->kernel.obsoleteAt = rval->validEnd;
trickles-userapi_2.c:24703:		     __constant_memcpy ((rval->kernel.data), (scont->data),
trickles-userapi_2.c:24704:					(dataLen)) : __memcpy ((rval->kernel.
trickles-userapi_2.c:24706:							       (scont->data),
trickles-userapi_2.c:24718:		    int dataLen = scont->dataLen;
trickles-userapi_2.c:24719:		    dcont->seq = htonl (scont->seq);
trickles-userapi_2.c:24720:		    dcont->validStart = htonl (scont->validStart);
trickles-userapi_2.c:24721:		    dcont->validEnd = htonl (scont->validEnd);
trickles-userapi_2.c:24722:		    dcont->fields = scont->fields;
trickles-userapi_2.c:24724:		     __constant_memcpy ((dcont->data), (scont->kernel.data),
trickles-userapi_2.c:24725:					(dataLen)) : __memcpy ((dcont->data),
trickles-userapi_2.c:24726:							       (scont->kernel.
trickles-userapi_2.c:24750:		    completeResp->fields |= (0x01);
trickles-userapi_2.c:24759:		    int dataLen = scont->dataLen;
trickles-userapi_2.c:24769:		    rval->prev = rval->next = ((void *) 0);
trickles-userapi_2.c:24770:		    rval->list = ((void *) 0);
trickles-userapi_2.c:24773:		     __constant_memcpy ((rval->kernel.data),
trickles-userapi_2.c:24774:					(scont->kernel.data),
trickles-userapi_2.c:24775:					(dataLen)) : __memcpy ((rval->kernel.
trickles-userapi_2.c:24777:							       (scont->kernel.
trickles-userapi_2.c:24820:		    return -1;
trickles-userapi_2.c:24885:		    return -1;
trickles-userapi_2.c:24896:		    wireContinuation->fields = 0;
trickles-userapi_2.c:24903:		    char *rval = wireContinuation->data;
trickles-userapi_2.c:24905:		    if (wireContinuation->fields & (0x01))
trickles-userapi_2.c:24920:		    if (wireContinuation->fields & ~((0x01)))
trickles-userapi_2.c:24946:		    resp->type = type;
trickles-userapi_2.c:24947:		    resp->error = error;
trickles-userapi_2.c:24948:		    resp->len = htons ((short) len);
trickles-userapi_2.c:24966:		    incompleteResp->ack_seq = htonl (ack_seq);
trickles-userapi_2.c:24967:		    incompleteResp->newCont.validStart = htonl (validStart);
trickles-userapi_2.c:24986:		    completeResp->ack_seq = htonl (ack_seq);
trickles-userapi_2.c:24987:		    completeResp->newCont.seq = htonl (seq);
trickles-userapi_2.c:24988:		    completeResp->newCont.validStart = htonl (validStart);
trickles-userapi_2.c:24989:		    completeResp->newCont.validEnd = htonl (validEnd);
trickles-userapi_2.c:24990:		    completeResp->newCont.fields = 0;
trickles-userapi_2.c:25010:		    newContinuationResp->newCont.seq = htonl (seq);
trickles-userapi_2.c:25011:		    newContinuationResp->newCont.validStart =
trickles-userapi_2.c:25013:		    newContinuationResp->newCont.validEnd = htonl (validEnd);
trickles-userapi_2.c:25014:		    newContinuationResp->newCont.fields = 0;
trickles-userapi_2.c:25022:		    printk ("seq=[%d]\n", ucont->seq);
trickles-userapi_2.c:25023:		    printk ("valid=[%d-%d] [%d-%d]\n", ucont->validStart,
trickles-userapi_2.c:25024:			    ucont->validEnd, htonl (ucont->validStart),
trickles-userapi_2.c:25025:			    htonl (ucont->validEnd));
trickles-userapi_2.c:25026:		    printk ("cvalid=[%d-%d] [%d-%d]\n",
trickles-userapi_2.c:25027:			    ucont->clientValidStart, ucont->clientValidEnd,
trickles-userapi_2.c:25028:			    htonl (ucont->clientValidStart),
trickles-userapi_2.c:25029:			    htonl (ucont->clientValidEnd));
trickles-userapi_2.c:25044:		    chunk->byteNum = htonl (byteNum);
trickles-userapi_2.c:25045:		    chunk->type = RCHUNK_DATA;
trickles-userapi_2.c:25046:		    chunk->chunkLen =
trickles-userapi_2.c:25049:		    return (struct DataChunk *) (chunk->data + chunkLen);
trickles-userapi_2.c:25058:		    phchunk->type = RCHUNK_PUSH_HINT;
trickles-userapi_2.c:25059:		    phchunk->chunkLen = htons (sizeof (struct PushHintChunk));
trickles-userapi_2.c:25060:		    phchunk->start = htonl (start);
trickles-userapi_2.c:25061:		    phchunk->end = htonl (end);
trickles-userapi_2.c:25086:		    ctx->packetNum = 0;
trickles-userapi_2.c:25087:		    ctx->packetPos = 0;
trickles-userapi_2.c:25088:		    ctx->outputPos = ctx->outputStart = dest;
trickles-userapi_2.c:25089:		    ctx->packets = packets;
trickles-userapi_2.c:25090:		    ctx->numPackets = numPackets;
trickles-userapi_2.c:25099:		    for (i = 0; i < ctx->numPackets; i++)
trickles-userapi_2.c:25101:			printk ("Packet [%d] = %d\n", i, ctx->packets[i].len);
trickles-userapi_2.c:25111:		       ctx->packetNum, ctx->packetPos, ctx->outputPos,
trickles-userapi_2.c:25112:		       ctx->numPackets, ctx->packets);
trickles-userapi_2.c:25120:		    if (ctx->packetNum >= ctx->numPackets)
trickles-userapi_2.c:25124:		    return ctx->packets[ctx->packetNum].len - ctx->packetPos;
trickles-userapi_2.c:25133:		      return ctx->outputPos;
trickles-userapi_2.c:25137:			if (ctx->packetNum >= ctx->numPackets)
trickles-userapi_2.c:25144:		    if (!(ctx->packetNum <= ctx->numPackets))
trickles-userapi_2.c:25146:			if (!(ctx->packetNum <= ctx->numPackets))
trickles-userapi_2.c:25149:				    "ctx->packetNum <= ctx->numPackets"
trickles-userapi_2.c:25154:			printk ("%d !<= %d\n", ctx->packetNum,
trickles-userapi_2.c:25155:				ctx->numPackets);
trickles-userapi_2.c:25166:			if (!(numBytes <= ctx->packets[ctx->packetNum].len))
trickles-userapi_2.c:25169:				    "numBytes <= ctx->packets[ctx->packetNum].len"
trickles-userapi_2.c:25174:			ctx->outputPos +=
trickles-userapi_2.c:25175:			  ctx->packets[ctx->packetNum].len - ctx->packetPos;
trickles-userapi_2.c:25176:			ctx->packetPos = 0;
trickles-userapi_2.c:25177:			ctx->packetNum++;
trickles-userapi_2.c:25179:		    temp = ctx->outputPos;
trickles-userapi_2.c:25180:		    ctx->packetPos += numBytes;
trickles-userapi_2.c:25181:		    ctx->outputPos += numBytes;
trickles-userapi_2.c:25185:			if (ctx->packetNum >= ctx->numPackets)
trickles-userapi_2.c:25192:		    if (!(ctx->packetPos <= ctx->packets[ctx->packetNum].len))
trickles-userapi_2.c:25195:				"ctx->packetPos <= ctx->packets[ctx->packetNum].len"
trickles-userapi_2.c:25201:		    if (ctx->packetPos == ctx->packets[ctx->packetNum].len)
trickles-userapi_2.c:25203:			ctx->packetPos = 0;
trickles-userapi_2.c:25204:			ctx->packetNum++;
trickles-userapi_2.c:25218:		    char *currpos = ctx->outputPos;
trickles-userapi_2.c:25259:			return -1;
trickles-userapi_2.c:25273:		    while ((char *) (chunk + 1) - start < len)
trickles-userapi_2.c:25276:			  ntohs ((chunk)->chunkLen) -
trickles-userapi_2.c:25281:			      printk ("bad length chunk(%d) -- ", len);
trickles-userapi_2.c:25293:				     ntohs ((chunk)->chunkLen)));
trickles-userapi_2.c:25302:			    return -1;
trickles-userapi_2.c:25305:		    if ((char *) chunk - start > len)
trickles-userapi_2.c:25308:				(char *) chunk - start, len);
trickles-userapi_2.c:25309:			return -chunknum - 1;
trickles-userapi_2.c:25325:		    if (!(gctx->packetNum <= gctx->numPackets))
trickles-userapi_2.c:25328:				"gctx->packetNum <= gctx->numPackets"
trickles-userapi_2.c:25337:		    int outputLen = gctx->outputPos - gctx->outputStart;
trickles-userapi_2.c:25338:		    char *buf = gctx->outputStart;
trickles-userapi_2.c:25347:			(entry->prev == ((void *) 0)
trickles-userapi_2.c:25348:			 && entry->next == ((void *) 0)
trickles-userapi_2.c:25349:			 && entry->list == ((void *) 0)))
trickles-userapi_2.c:25352:				"entry->prev == NULL && entry->next == NULL && entry->list == NULL"
trickles-userapi_2.c:25358:		    freeClientSide_Continuation (entry->cont);
trickles-userapi_2.c:25374:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:25375:		    tp->trickles_opt = 0;
trickles-userapi_2.c:25376:		    tp->mac_changed = 0;
trickles-userapi_2.c:25382:			  ((sizeof (tp->cminisock_api_config))) ?
trickles-userapi_2.c:25383:			  __constant_c_and_count_memset (((&tp->
trickles-userapi_2.c:25389:							   (tp->
trickles-userapi_2.c:25392:			  __constant_c_memset (((&tp->cminisock_api_config)),
trickles-userapi_2.c:25396:						 (tp->
trickles-userapi_2.c:25399:			  ((sizeof (tp->cminisock_api_config))) ?
trickles-userapi_2.c:25400:			  __memset_generic ((((&tp->cminisock_api_config))),
trickles-userapi_2.c:25403:					       (tp->
trickles-userapi_2.c:25405:			  __memset_generic (((&tp->cminisock_api_config)),
trickles-userapi_2.c:25408:					      (tp->cminisock_api_config))))));
trickles-userapi_2.c:25409:		      init_head (&tp->cminisock_api_config.msk_freelist);
trickles-userapi_2.c:25411:		      tp->cminisock_api_config.cfg.ctl = ((void *) 0);
trickles-userapi_2.c:25413:		      tp->cminisock_api_config.event_lock = (rwlock_t)
trickles-userapi_2.c:25418:		    tp->t.malloc_initialized = 0;
trickles-userapi_2.c:25420:		    tp->t.heapbytesize = 0;
trickles-userapi_2.c:25421:		    tp->t.heapbytesallocated = 0;
trickles-userapi_2.c:25425:			tp->t.fragblocks[i] = 0;
trickles-userapi_2.c:25426:			tp->t.fraghead[i].next = tp->t.fraghead[i].prev =
trickles-userapi_2.c:25430:		    tp->t.clientStateCounter = 0;
trickles-userapi_2.c:25431:		    tp->t.state = 1;
trickles-userapi_2.c:25432:		    tp->t.A = 0;
trickles-userapi_2.c:25433:		    tp->t.D = 0;
trickles-userapi_2.c:25434:		    tp->t.RTO = 0;
trickles-userapi_2.c:25435:		    tp->t.timerState = 0;
trickles-userapi_2.c:25436:		    tp->t.rcv_nxt = 0;
trickles-userapi_2.c:25437:		    tp->t.previous_base = 0;
trickles-userapi_2.c:25438:		    skb_queue_head_init (&tp->t.ofo_queue);
trickles-userapi_2.c:25440:		    tp->t.ack_prev = ((void *) 0);
trickles-userapi_2.c:25442:		    tp->t.ack_last = 0;
trickles-userapi_2.c:25443:		    tp->t.oo_count = 0;
trickles-userapi_2.c:25444:		    tp->t.in_flight = 0;
trickles-userapi_2.c:25446:		    tp->t.standardProof.numSacks = 0;
trickles-userapi_2.c:25447:		    tp->t.altProof.numSacks = 0;
trickles-userapi_2.c:25450:		    tp->t.dprev = tp->t.dnext = ((void *) 0);
trickles-userapi_2.c:25451:		    tp->t.dbg_skb = ((void *) 0);
trickles-userapi_2.c:25452:		    init_head (&tp->t.cont_list);
trickles-userapi_2.c:25454:		    init_timer (&tp->t.slowstart_timer);
trickles-userapi_2.c:25458:		    tp->t.request_rcv_nxt = 0;
trickles-userapi_2.c:25459:		    tp->t.request_snd_nxt = 0;
trickles-userapi_2.c:25460:		    init_head (&tp->t.request_ofo_queue);
trickles-userapi_2.c:25461:		    skb_queue_head_init (&tp->t.data_ofo_queue);
trickles-userapi_2.c:25462:		    init_head (&tp->t.sentRequests);
trickles-userapi_2.c:25463:		    init_head (&tp->t.queuedRequests);
trickles-userapi_2.c:25465:		    init_head (&tp->t.dataRequestMap);
trickles-userapi_2.c:25466:		    init_head (&tp->t.missingDataMap);
trickles-userapi_2.c:25468:		    tp->t.byteReqNext = 0;
trickles-userapi_2.c:25469:		    tp->t.byteReqHint = ((void *) 0);
trickles-userapi_2.c:25473:		    tp->t.conversionState = (1);
trickles-userapi_2.c:25474:		    tp->t.snd_una = tp->t.write_seq = 0;
trickles-userapi_2.c:25475:		    tp->t.snd_end = 0;
trickles-userapi_2.c:25476:		    skb_queue_head_init (&tp->t.requestBytes);
trickles-userapi_2.c:25477:		    tp->t.newIncompleteRequest = ((void *) 0);
trickles-userapi_2.c:25478:		    tp->t.prevConvCont = ((void *) 0);
trickles-userapi_2.c:25480:		    init_head (&tp->t.ucontList);
trickles-userapi_2.c:25481:		    init_head (&tp->t.depNodeList);
trickles-userapi_2.c:25487:		    tp->t.nonceCTX = ((void *) 0);
trickles-userapi_2.c:25488:		    skb_queue_head_init (&tp->t.prequeueOverflow);
trickles-userapi_2.c:25489:		    skb_queue_head_init (&tp->t.sendAckOverflow);
trickles-userapi_2.c:25490:		    skb_queue_head_init (&tp->t.recycleList);
trickles-userapi_2.c:25492:		    tp->t.responseMSK = ((void *) 0);
trickles-userapi_2.c:25493:		    init_head (&tp->t.responseList);
trickles-userapi_2.c:25494:		    tp->t.responseCount = 0;
trickles-userapi_2.c:25496:		    tp->t.events = ((void *) 0);
trickles-userapi_2.c:25497:		    tp->drop_rate = 0;
trickles-userapi_2.c:25498:		    tp->instrumentation = 0;
trickles-userapi_2.c:25714:		    msk->num_packets = 0;
trickles-userapi_2.c:25715:		    msk->ucont_len = 0;
trickles-userapi_2.c:25716:		    msk->ucont_data = ((void *) 0);
trickles-userapi_2.c:25717:		    msk->input_len = 0;
trickles-userapi_2.c:25718:		    msk->input = ((void *) 0);
trickles-userapi_2.c:25719:		    msk->packets = ((void *) 0);
trickles-userapi_2.c:25721:		    msk->refCnt = 1;
trickles-userapi_2.c:25723:		    msk->cacheRecycleIndex = -1;
trickles-userapi_2.c:25724:		    msk->serverSK = ((void *) 0);
trickles-userapi_2.c:25725:		    msk->pmsk = ((void *) 0);
trickles-userapi_2.c:25726:		    msk->isStatic = 0;
trickles-userapi_2.c:25732:		    msk->isStatic = 1;
trickles-userapi_2.c:25733:		    msk->prev = msk->next = ((void *) 0);
trickles-userapi_2.c:25734:		    msk->ctl = ALLOC_PENDING;
trickles-userapi_2.c:25739:		    pmsk->num_packets = 0;
trickles-userapi_2.c:25740:		    pmsk->ucont_len = 0;
trickles-userapi_2.c:25741:		    pmsk->ucont_data = ((void *) 0);
trickles-userapi_2.c:25742:		    pmsk->input_len = 0;
trickles-userapi_2.c:25743:		    pmsk->input = ((void *) 0);
trickles-userapi_2.c:25744:		    pmsk->packets = ((void *) 0);
trickles-userapi_2.c:25745:		    pmsk->refCnt = 1;
trickles-userapi_2.c:25746:		    pmsk->cacheRecycleIndex = -1;
trickles-userapi_2.c:25763:		    if (msk->num_packets > 0)
trickles-userapi_2.c:25765:			printk ("msk packets is %d\n", msk->num_packets);
trickles-userapi_2.c:25767:		    if (!(msk->num_packets == 0))
trickles-userapi_2.c:25769:			printk ("KERNEL: assertion (" "msk->num_packets == 0"
trickles-userapi_2.c:25784:			(((msk->sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-userapi_2.c:25785:			 && !((msk->sk)->tp_pinfo.af_tcp.
trickles-userapi_2.c:25786:			      trickles_opt & (msk->sk)->tp_pinfo.af_tcp.
trickles-userapi_2.c:25789:			msk->packets =
trickles-userapi_2.c:25790:			  tmalloc (msk->sk,
trickles-userapi_2.c:25796:			if (msk->packets == ((void *) 0))
trickles-userapi_2.c:25811:			    msk->packets = packets[0];
trickles-userapi_2.c:25815:			    msk->packets = ((void *) 0);
trickles-userapi_2.c:25824:		    msk->num_packets = numPackets;
trickles-userapi_2.c:25830:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:25832:		      &tp->cminisock_api_config.msk_freelist;
trickles-userapi_2.c:25833:		    struct cminisock *curr = (struct cminisock *) head->next;
trickles-userapi_2.c:25835:			   && curr->ctl == ALLOC_PROCESSING)
trickles-userapi_2.c:25838:			curr = curr->next;
trickles-userapi_2.c:25846:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:25848:		      (struct list_link *) &tp->cminisock_api_config.
trickles-userapi_2.c:25851:		      (struct pminisock *) tp->cminisock_api_config.
trickles-userapi_2.c:25855:			(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-userapi_2.c:25856:			 && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
trickles-userapi_2.c:25860:			       pcurr->ctl == ALLOC_PROCESSING)
trickles-userapi_2.c:25863:			    pcurr = pcurr->next;
trickles-userapi_2.c:25881:		    rval->ctl = ALLOC_PENDING;
trickles-userapi_2.c:25892:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:25894:		      &tp->cminisock_api_config.msk_freelist;
trickles-userapi_2.c:25896:		      (struct cminisock *) tp->cminisock_api_config.
trickles-userapi_2.c:25900:			(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-userapi_2.c:25901:			 && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
trickles-userapi_2.c:25905:			       curr->ctl == ALLOC_PROCESSING)
trickles-userapi_2.c:25908:			    curr = curr->next;
trickles-userapi_2.c:25920:			rval->ctl = ALLOC_PENDING;
trickles-userapi_2.c:25924:			if (tp->t.responseCount == 0)
trickles-userapi_2.c:25926:			    rval = tp->t.responseMSK;
trickles-userapi_2.c:25927:			    rval->list = ((void *) 0);
trickles-userapi_2.c:25928:			    rval->next = rval->prev = ((void *) 0);
trickles-userapi_2.c:25940:			    rval->next = rval->prev = ((void *) 0);
trickles-userapi_2.c:25941:			    rval->list = ((void *) 0);
trickles-userapi_2.c:25942:			    insert_tail (&tp->t.responseList,
trickles-userapi_2.c:25945:			tp->t.responseCount++;
trickles-userapi_2.c:25947:			rval->sk = sk;
trickles-userapi_2.c:25948:			rval->ctl = ALLOC_PENDING;
trickles-userapi_2.c:25972:		    msk->refCnt++;
trickles-userapi_2.c:25983:			struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:25986:				tp->cminisock_api_config.msk_freelist.len);
trickles-userapi_2.c:25992:		    rval->refCnt = 1;
trickles-userapi_2.c:25993:		    rval->isStatic = 0;
trickles-userapi_2.c:26005:		    rval->num_packets = 0;
trickles-userapi_2.c:26006:		    rval->packets = ((void *) 0);
trickles-userapi_2.c:26007:		    rval->pmsk = ((void *) 0);
trickles-userapi_2.c:26008:		    if (rval->ucont_len > 0)
trickles-userapi_2.c:26010:			rval->ucont_data = tmalloc (sk, rval->ucont_len);
trickles-userapi_2.c:26011:			if (rval->ucont_data == ((void *) 0))
trickles-userapi_2.c:26015:			       rval->ucont_len);
trickles-userapi_2.c:26023:			rval->ucont_data = ((void *) 0);
trickles-userapi_2.c:26024:		    } if (rval->input_len > 0)
trickles-userapi_2.c:26026:			rval->input = tmalloc (sk, rval->input_len);
trickles-userapi_2.c:26027:			if (rval->input == ((void *) 0))
trickles-userapi_2.c:26031:			       "msk", rval->input_len);
trickles-userapi_2.c:26032:			    tfree (sk, rval->ucont_data);
trickles-userapi_2.c:26040:			rval->input = ((void *) 0);
trickles-userapi_2.c:26041:		    } if (rval->ucont_data)
trickles-userapi_2.c:26042:		      (__builtin_constant_p (rval->ucont_len) ?
trickles-userapi_2.c:26043:		       __constant_memcpy ((rval->ucont_data),
trickles-userapi_2.c:26044:					  (pmsk->ucont_data),
trickles-userapi_2.c:26045:					  (rval->
trickles-userapi_2.c:26046:					   ucont_len)) : __memcpy ((rval->
trickles-userapi_2.c:26048:								   (pmsk->
trickles-userapi_2.c:26050:								   (rval->
trickles-userapi_2.c:26052:		    if (rval->input)
trickles-userapi_2.c:26053:		      (__builtin_constant_p (rval->input_len) ?
trickles-userapi_2.c:26054:		       __constant_memcpy ((rval->input), (pmsk->input),
trickles-userapi_2.c:26055:					  (rval->
trickles-userapi_2.c:26056:					   input_len)) : __memcpy ((rval->
trickles-userapi_2.c:26058:								   (pmsk->
trickles-userapi_2.c:26060:								   (rval->
trickles-userapi_2.c:26068:			(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-userapi_2.c:26069:			 && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
trickles-userapi_2.c:26072:			if (msk->ctl == ALLOC_FREE
trickles-userapi_2.c:26073:			    || msk->ctl == ALLOC_PROCESSING)
trickles-userapi_2.c:26088:			if (msk->ctl == ALLOC_READY
trickles-userapi_2.c:26089:			    && msk->prev != ((void *) 0))
trickles-userapi_2.c:26093:			msk->ctl = ALLOC_PROCESSING;
trickles-userapi_2.c:26099:		    for (i = 0; i < msk->num_packets; i++)
trickles-userapi_2.c:26101:			if (msk->packets[i].ucontData != ((void *) 0))
trickles-userapi_2.c:26103:			    kfree (msk->packets[i].ucontData);
trickles-userapi_2.c:26107:			    (((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-userapi_2.c:26108:			       && !((sk)->tp_pinfo.af_tcp.
trickles-userapi_2.c:26109:				      trickles_opt & (sk)->tp_pinfo.af_tcp.
trickles-userapi_2.c:26110:				      trickles_opt & 0x8)) && msk->packets)
trickles-userapi_2.c:26112:			tfree (sk, msk->packets);
trickles-userapi_2.c:26113:			msk->packets = ((void *) 0);
trickles-userapi_2.c:26115:		    msk->num_packets = 0;
trickles-userapi_2.c:26116:		    if (msk->ucont_data != ((void *) 0))
trickles-userapi_2.c:26118:			tfree (sk, msk->ucont_data);
trickles-userapi_2.c:26119:			msk->ucont_data = ((void *) 0);
trickles-userapi_2.c:26121:		    msk->ucont_len = 0;
trickles-userapi_2.c:26122:		    if (msk->input != ((void *) 0))
trickles-userapi_2.c:26124:			tfree (sk, msk->input);
trickles-userapi_2.c:26125:			msk->input = ((void *) 0);
trickles-userapi_2.c:26127:		    msk->input_len = 0;
trickles-userapi_2.c:26131:		    msk->refCnt--;
trickles-userapi_2.c:26132:		    if (!(msk->refCnt <= 3))
trickles-userapi_2.c:26134:			printk ("KERNEL: assertion (" "msk->refCnt <= 3"
trickles-userapi_2.c:26139:		    if (msk->refCnt == 0)
trickles-userapi_2.c:26141:			struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:26143:			  &tp->cminisock_api_config.msk_freelist;
trickles-userapi_2.c:26145:			if (!msk->isStatic)
trickles-userapi_2.c:26148:				(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-userapi_2.c:26149:				 && !((sk)->tp_pinfo.af_tcp.
trickles-userapi_2.c:26150:				      trickles_opt & (sk)->tp_pinfo.af_tcp.
trickles-userapi_2.c:26155:				msk->ctl = ALLOC_FREE;
trickles-userapi_2.c:26159:				if (msk != tp->t.responseMSK)
trickles-userapi_2.c:26164:				tp->t.responseCount--;
trickles-userapi_2.c:26170:		    if (msk->pmsk != ((void *) 0))
trickles-userapi_2.c:26172:			struct pminisock *pmsk = msk->pmsk;
trickles-userapi_2.c:26181:			(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-userapi_2.c:26182:			 && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
trickles-userapi_2.c:26185:			if (msk->ctl != ALLOC_PROCESSING
trickles-userapi_2.c:26186:			    && msk->ctl != ALLOC_HALFFREE)
trickles-userapi_2.c:26189:			      ("(free_trickles_msk_finish %s) without corresponding free_trickles_msk: msk->ctl = %d\n",
trickles-userapi_2.c:26190:			       "msk", msk->ctl);
trickles-userapi_2.c:26208:		    msk->num_packets = 0;
trickles-userapi_2.c:26209:		    msk->packets = ((void *) 0);
trickles-userapi_2.c:26210:		    msk->ucont_len = 0;
trickles-userapi_2.c:26211:		    msk->ucont_data = ((void *) 0);
trickles-userapi_2.c:26212:		    msk->input_len = 0;
trickles-userapi_2.c:26213:		    msk->input = ((void *) 0);
trickles-userapi_2.c:26218:		    msk->refCnt++;
trickles-userapi_2.c:26229:			struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:26236:		    rval->refCnt = 1;
trickles-userapi_2.c:26248:		    rval->num_packets = 0;
trickles-userapi_2.c:26249:		    rval->packets = ((void *) 0);
trickles-userapi_2.c:26250:		    if (rval->ucont_len > 0)
trickles-userapi_2.c:26252:			rval->ucont_data = tmalloc (sk, rval->ucont_len);
trickles-userapi_2.c:26253:			if (rval->ucont_data == ((void *) 0))
trickles-userapi_2.c:26257:			       rval->ucont_len);
trickles-userapi_2.c:26265:			rval->ucont_data = ((void *) 0);
trickles-userapi_2.c:26266:		    } if (rval->input_len > 0)
trickles-userapi_2.c:26268:			rval->input = tmalloc (sk, rval->input_len);
trickles-userapi_2.c:26269:			if (rval->input == ((void *) 0))
trickles-userapi_2.c:26273:			       "pmsk", rval->input_len);
trickles-userapi_2.c:26274:			    tfree (sk, rval->ucont_data);
trickles-userapi_2.c:26282:			rval->input = ((void *) 0);
trickles-userapi_2.c:26283:		    } if (rval->ucont_data)
trickles-userapi_2.c:26284:		      (__builtin_constant_p (rval->ucont_len) ?
trickles-userapi_2.c:26285:		       __constant_memcpy ((rval->ucont_data),
trickles-userapi_2.c:26286:					  (pmsk->ucont_data),
trickles-userapi_2.c:26287:					  (rval->
trickles-userapi_2.c:26288:					   ucont_len)) : __memcpy ((rval->
trickles-userapi_2.c:26290:								   (pmsk->
trickles-userapi_2.c:26292:								   (rval->
trickles-userapi_2.c:26294:		    if (rval->input)
trickles-userapi_2.c:26295:		      (__builtin_constant_p (rval->input_len) ?
trickles-userapi_2.c:26296:		       __constant_memcpy ((rval->input), (pmsk->input),
trickles-userapi_2.c:26297:					  (rval->
trickles-userapi_2.c:26298:					   input_len)) : __memcpy ((rval->
trickles-userapi_2.c:26300:								   (pmsk->
trickles-userapi_2.c:26302:								   (rval->
trickles-userapi_2.c:26310:			(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-userapi_2.c:26311:			 && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
trickles-userapi_2.c:26314:			if (msk->ctl == ALLOC_FREE
trickles-userapi_2.c:26315:			    || msk->ctl == ALLOC_PROCESSING)
trickles-userapi_2.c:26330:			if (msk->ctl == ALLOC_READY
trickles-userapi_2.c:26331:			    && msk->prev != ((void *) 0))
trickles-userapi_2.c:26335:			msk->ctl = ALLOC_PROCESSING;
trickles-userapi_2.c:26341:		    for (i = 0; i < msk->num_packets; i++)
trickles-userapi_2.c:26343:			if (msk->packets[i].ucontData != ((void *) 0))
trickles-userapi_2.c:26345:			    kfree (msk->packets[i].ucontData);
trickles-userapi_2.c:26349:			    (((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-userapi_2.c:26350:			       && !((sk)->tp_pinfo.af_tcp.
trickles-userapi_2.c:26351:				      trickles_opt & (sk)->tp_pinfo.af_tcp.
trickles-userapi_2.c:26352:				      trickles_opt & 0x8)) && msk->packets)
trickles-userapi_2.c:26354:			tfree (sk, msk->packets);
trickles-userapi_2.c:26355:			msk->packets = ((void *) 0);
trickles-userapi_2.c:26357:		    msk->num_packets = 0;
trickles-userapi_2.c:26358:		    if (msk->ucont_data != ((void *) 0))
trickles-userapi_2.c:26360:			tfree (sk, msk->ucont_data);
trickles-userapi_2.c:26361:			msk->ucont_data = ((void *) 0);
trickles-userapi_2.c:26363:		    msk->ucont_len = 0;
trickles-userapi_2.c:26364:		    if (msk->input != ((void *) 0))
trickles-userapi_2.c:26366:			tfree (sk, msk->input);
trickles-userapi_2.c:26367:			msk->input = ((void *) 0);
trickles-userapi_2.c:26369:		    msk->input_len = 0;
trickles-userapi_2.c:26373:		    msk->refCnt--;
trickles-userapi_2.c:26374:		    if (!(msk->refCnt <= 3))
trickles-userapi_2.c:26376:			printk ("KERNEL: assertion (" "msk->refCnt <= 3"
trickles-userapi_2.c:26381:		    if (msk->refCnt == 0)
trickles-userapi_2.c:26383:			struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:26385:			  &tp->cminisock_api_config.pmsk_freelist;
trickles-userapi_2.c:26389:			     (struct pminisock *) tp->cminisock_api_config.
trickles-userapi_2.c:26390:			     cfg.ctl->pminisock_base
trickles-userapi_2.c:26392:			     (struct pminisock *) tp->cminisock_api_config.
trickles-userapi_2.c:26393:			     cfg.ctl->pminisock_limit))
trickles-userapi_2.c:26396:				(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-userapi_2.c:26397:				 && !((sk)->tp_pinfo.af_tcp.
trickles-userapi_2.c:26398:				      trickles_opt & (sk)->tp_pinfo.af_tcp.
trickles-userapi_2.c:26404:				msk->ctl = ALLOC_FREE;
trickles-userapi_2.c:26420:			(((sk)->tp_pinfo.af_tcp.trickles_opt & 0x1)
trickles-userapi_2.c:26421:			 && !((sk)->tp_pinfo.af_tcp.trickles_opt & (sk)->
trickles-userapi_2.c:26424:			if (msk->ctl != ALLOC_PROCESSING
trickles-userapi_2.c:26425:			    && msk->ctl != ALLOC_HALFFREE)
trickles-userapi_2.c:26428:			      ("(free_trickles_msk_finish %s) without corresponding free_trickles_msk: msk->ctl = %d\n",
trickles-userapi_2.c:26429:			       "pmsk", msk->ctl);
trickles-userapi_2.c:26447:		    msk->num_packets = 0;
trickles-userapi_2.c:26448:		    msk->packets = ((void *) 0);
trickles-userapi_2.c:26449:		    msk->ucont_len = 0;
trickles-userapi_2.c:26450:		    msk->ucont_data = ((void *) 0);
trickles-userapi_2.c:26451:		    msk->input_len = 0;
trickles-userapi_2.c:26452:		    msk->input = ((void *) 0);
trickles-userapi_2.c:26467:		    skb->next = ((void *) 0);
trickles-userapi_2.c:26468:		    skb->prev = ((void *) 0);
trickles-userapi_2.c:26469:		    skb->list = ((void *) 0);
trickles-userapi_2.c:26470:		    skb->sk = ((void *) 0);
trickles-userapi_2.c:26471:		    skb->stamp.tv_sec = 0;
trickles-userapi_2.c:26472:		    skb->dev = ((void *) 0);
trickles-userapi_2.c:26473:		    skb->real_dev = ((void *) 0);
trickles-userapi_2.c:26474:		    skb->dst = ((void *) 0);
trickles-userapi_2.c:26476:		     ? (__builtin_constant_p ((sizeof (skb->cb))) ?
trickles-userapi_2.c:26477:			__constant_c_and_count_memset (((skb->cb)),
trickles-userapi_2.c:26481:						       ((sizeof (skb->cb)))) :
trickles-userapi_2.c:26482:			__constant_c_memset (((skb->cb)),
trickles-userapi_2.c:26485:					     ((sizeof (skb->cb)))))
trickles-userapi_2.c:26486:		     : (__builtin_constant_p ((sizeof (skb->cb))) ?
trickles-userapi_2.c:26487:			__memset_generic ((((skb->cb))), (((0))),
trickles-userapi_2.c:26488:					  (((sizeof (skb->cb))))) :
trickles-userapi_2.c:26489:			__memset_generic (((skb->cb)), ((0)),
trickles-userapi_2.c:26490:					  ((sizeof (skb->cb))))));
trickles-userapi_2.c:26491:		    skb->pkt_type = 0;
trickles-userapi_2.c:26492:		    skb->ip_summed = 0;
trickles-userapi_2.c:26493:		    skb->priority = 0;
trickles-userapi_2.c:26494:		    skb->security = 0;
trickles-userapi_2.c:26495:		    skb->destructor = ((void *) 0);
trickles-userapi_2.c:26498:		    skb->nfmark = skb->nfcache = 0;
trickles-userapi_2.c:26499:		    skb->nfct = ((void *) 0);
trickles-userapi_2.c:26505:		    skb->tc_index = 0;
trickles-userapi_2.c:26513:		    struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_2.c:26515:		      ((struct skb_shared_info *) ((skb)->end))->nr_frags !=
trickles-userapi_2.c:26516:		      0, r1 = tp->t.recycleList.qlen >= (1000), r2 =
trickles-userapi_2.c:26517:		      skb->truesize - sizeof (struct sk_buff) <
trickles-userapi_2.c:26527:				 r0, r1, r2, skb->truesize,
trickles-userapi_2.c:26538:		    skb->tail = skb->data = skb->head;
trickles-userapi_2.c:26539:		    skb->len = 0;
trickles-userapi_2.c:26540:		    skb->cloned = 0;
trickles-userapi_2.c:26541:		    skb->data_len = 0;
trickles-userapi_2.c:26543:		    (((&skb->users)->counter) = (1));
trickles-userapi_2.c:26545:		       (((struct skb_shared_info *) ((skb)->end))->dataref))->
trickles-userapi_2.c:26547:		    ((struct skb_shared_info *) ((skb)->end))->nr_frags = 0;
trickles-userapi_2.c:26548:		    ((struct skb_shared_info *) ((skb)->end))->frag_list =
trickles-userapi_2.c:26551:		    __skb_queue_tail (&tp->t.recycleList, skb);
trickles-userapi_2.c:26561:		    struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_2.c:26564:		      __skb_dequeue_tail (&tp->t.recycleList);
trickles-userapi_2.c:26683:		    "kernel_version=" "2.4.26-gdb-trickles";
trickles-userapi_2.c:26788:		    struct files_struct *files = get_current ()->files;
trickles-userapi_2.c:26790:		    (void) (&files->file_lock);
trickles-userapi_2.c:26796:								   *) (files->
trickles-userapi_2.c:26810:		    struct files_struct *files = get_current ()->files;
trickles-userapi_2.c:26811:		    (void) (&files->file_lock);
trickles-userapi_2.c:26816:				       (files->
trickles-userapi_2.c:26819:		  __asm__ __volatile__ ("btrl %1,%0": "=m" (*(__kernel_fd_set *) (files->close_on_exec)):"r" ((int)
trickles-userapi_2.c:26833:		    if (fd < files->max_fds)
trickles-userapi_2.c:26834:		      file = files->fd[fd];
trickles-userapi_2.c:26844:		    struct files_struct *files = get_current ()->files;
trickles-userapi_2.c:26846:		    if (fd < files->max_fds)
trickles-userapi_2.c:26847:		      file = files->fd[fd];
trickles-userapi_2.c:26861:				     (files->open_fds)):"r" ((int) (fd)));
trickles-userapi_2.c:26862:		    if (fd < files->next_fd)
trickles-userapi_2.c:26863:		      files->next_fd = fd;
trickles-userapi_2.c:26868:		    struct files_struct *files = get_current ()->files;
trickles-userapi_2.c:26870:		    (void) (&files->file_lock);
trickles-userapi_2.c:26944:		      c -= 'A' - 'a';
trickles-userapi_2.c:26951:		      c -= 'a' - 'A';
trickles-userapi_2.c:26995:				printk ("- ");
trickles-userapi_2.c:27018:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:27019:		    struct cminisock *rval = &tp->t.api_msk;
trickles-userapi_2.c:27026:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:27027:		    printk ("   tp->rcv_nxt = %d\n", tp->rcv_nxt);
trickles-userapi_2.c:27029:			    sk->receive_queue.qlen);
trickles-userapi_2.c:27030:		    printk ("   Trickles state = %d\n", tp->t.state);
trickles-userapi_2.c:27033:		      struct tcp_opt * tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_2.c:27034:		      printk ("A = %d, D = %d, RTO = %d", tp->t.A, tp->t.D,
trickles-userapi_2.c:27035:			      tp->t.RTO);
trickles-userapi_2.c:27037:		    printk ("   Ofo_queue len = %d\n", tp->t.ofo_queue.qlen);
trickles-userapi_2.c:27039:			    tp->t.data_ofo_queue.qlen);
trickles-userapi_2.c:27041:			    tp->t.request_ofo_queue.len);
trickles-userapi_2.c:27049:		    while ((char *) (chunk + 1) - ptr < len && chunknum < 5)
trickles-userapi_2.c:27051:			printk ("Chunk %d(%d) - %d @ %d\n", chunknum,
trickles-userapi_2.c:27052:				-1,
trickles-userapi_2.c:27053:				ntohs ((chunk)->chunkLen) -
trickles-userapi_2.c:27055:				(char *) chunk->data - ptr);
trickles-userapi_2.c:27058:				     ntohs ((chunk)->chunkLen)));
trickles-userapi_2.c:27070:		      &((struct skb_shared_info *) ((skb)->end))->frags[i];
trickles-userapi_2.c:27071:		    frag->page = page;
trickles-userapi_2.c:27072:		    frag->page_offset = off;
trickles-userapi_2.c:27073:		    frag->size = size;
trickles-userapi_2.c:27074:		    ((struct skb_shared_info *) ((skb)->end))->nr_frags =
trickles-userapi_2.c:27085:		    int off = skb->len;
trickles-userapi_2.c:27093:			skb->csum = csum_block_add (skb->csum, csum, off);
trickles-userapi_2.c:27099:		    return -14;
trickles-userapi_2.c:27107:		    msk->sk = sk;
trickles-userapi_2.c:27108:		    msk->sk->dst_cache = ((void *) 0);
trickles-userapi_2.c:27109:		    msk->sk->protinfo.af_inet.opt = ((void *) 0);
trickles-userapi_2.c:27110:		    msk->sk->protinfo.af_inet.ttl = 255;
trickles-userapi_2.c:27111:		    msk->sk->protocol = IPPROTO_TCP;
trickles-userapi_2.c:27112:		    msk->sk->protinfo.af_inet.tos = 0;
trickles-userapi_2.c:27113:		    msk->sk->tp_pinfo.af_tcp.trickles_opt = 0;
trickles-userapi_2.c:27114:		    msk->sk->localroute = 0;
trickles-userapi_2.c:27116:		      msk->sk->protinfo.af_inet.pmtudisc = 0;
trickles-userapi_2.c:27118:		      msk->sk->protinfo.af_inet.pmtudisc = 1;
trickles-userapi_2.c:27120:		    msk->sk->bound_dev_if = 0;
trickles-userapi_2.c:27122:		    msk->sk->saddr = msk->saddr;
trickles-userapi_2.c:27123:		    msk->sk->sport = msk->source;
trickles-userapi_2.c:27124:		    msk->sk->daddr = msk->daddr;
trickles-userapi_2.c:27125:		    msk->sk->dport = msk->dest;
trickles-userapi_2.c:27141:		    pgd = ((&init_mm)->pgd + ((va >> 22) & (1024 - 1)));
trickles-userapi_2.c:27159:							 (~((1UL << 12) - 1)))
trickles-userapi_2.c:27163:			       ((va >> 12) & (1024 - 1)));
trickles-userapi_2.c:27178:								     12))))) -
trickles-userapi_2.c:27180:								     ((unsigned long) (((pte).pte_low >> 12)))))->zone_mem_map) << 12) + page_zone ((mem_map + ((unsigned long) (((pte).pte_low >> 12)))))->zone_start_paddr) + ((unsigned long) (0xC0000000))));
trickles-userapi_2.c:27182:				ret |= (va & ((1UL << 12) - 1));
trickles-userapi_2.c:27196:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:27203:			insert_tail_mb (&tp->cminisock_api_config.cfg.ctl->
trickles-userapi_2.c:27214:		    msk->tag = tag;
trickles-userapi_2.c:27221:			msk->ctl = ALLOC_READY;
trickles-userapi_2.c:27225:			    for (i = 0; i < msk->num_packets; i++)
trickles-userapi_2.c:27227:				printk ("upcall pkts[%d]: %u-%u\n", i,
trickles-userapi_2.c:27228:					msk->packets[i].seq,
trickles-userapi_2.c:27229:					msk->packets[i].seq +
trickles-userapi_2.c:27230:					msk->packets[i].len);
trickles-userapi_2.c:27247:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:27254:			dlist_insert_tail_mb (&tp->cminisock_api_config.cfg.
trickles-userapi_2.c:27255:					      ctl->pmsk_eventlist,
trickles-userapi_2.c:27265:		    msk->tag = tag;
trickles-userapi_2.c:27272:			msk->ctl = ALLOC_READY;
trickles-userapi_2.c:27276:			    for (i = 0; i < msk->num_packets; i++)
trickles-userapi_2.c:27278:				printk ("upcall pkts[%d]: %u-%u\n", i,
trickles-userapi_2.c:27279:					msk->packets[i].seq,
trickles-userapi_2.c:27280:					msk->packets[i].seq +
trickles-userapi_2.c:27281:					msk->packets[i].len);
trickles-userapi_2.c:27294:		    __wake_up ((sk->sleep), 1, 1);
trickles-userapi_2.c:27295:		    if (!sk->dead)
trickles-userapi_2.c:27298:			sk->data_ready (sk, 0);
trickles-userapi_2.c:27300:		    atomic_inc (&sk->tp_pinfo.af_tcp.cminisock_api_config.cfg.
trickles-userapi_2.c:27301:				ctl->update_since_poll);
trickles-userapi_2.c:27316:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:27319:		      skb_queue_len (&tp->ucopy.prequeue);
trickles-userapi_2.c:27329:			    __skb_dequeue (&tp->ucopy.prequeue)) !=
trickles-userapi_2.c:27331:		      sk->backlog_rcv (sk, skb);
trickles-userapi_2.c:27337:			if (!--*ptr)
trickles-userapi_2.c:27338:			  __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;"
trickles-userapi_2.c:27353:		    tp->ucopy.memory = 0;
trickles-userapi_2.c:27367:		    if (!msk->isStatic)
trickles-userapi_2.c:27383:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp), *dummy_tp =
trickles-userapi_2.c:27386:		    dummy_tp->trickles_opt = tp->trickles_opt;
trickles-userapi_2.c:27387:		    dummy_tp->t.hmacCTX = tp->t.hmacCTX;
trickles-userapi_2.c:27388:		    dummy_tp->t.nonceCTX = tp->t.nonceCTX;
trickles-userapi_2.c:27390:		    msk->serverSK = sk;
trickles-userapi_2.c:27393:		      if (msk->seqnum != last + 1)
trickles-userapi_2.c:27396:		      last = msk->seqnum;
trickles-userapi_2.c:27398:		    if (msk->tag == SYN || msk->tag == ACK || msk->tag == FIN)
trickles-userapi_2.c:27419:			tcb = ((struct tcp_skb_cb *) &((skb)->cb[0]));
trickles-userapi_2.c:27420:			skb->csum = 0;
trickles-userapi_2.c:27421:			skb->ip_summed = 1;
trickles-userapi_2.c:27426:			switch (msk->tag)
trickles-userapi_2.c:27449:					") failed at " "trickles-userapi.c"
trickles-userapi_2.c:27455:			for (i = 0; i < msk->num_packets; i++)
trickles-userapi_2.c:27458:			    skb1->csum = 0;
trickles-userapi_2.c:27459:			    skb1->ip_summed = 1;
trickles-userapi_2.c:27461:			    msk->tag = ACK;
trickles-userapi_2.c:27464:		    struct pminisock *pmsk = msk->pmsk;
trickles-userapi_2.c:27466:			&& ((msk)->cacheRecycleIndex >= 0))
trickles-userapi_2.c:27470:					       pmsk->cacheRecycleIndex, 0);
trickles-userapi_2.c:27489:		    if (!msk->isStatic)
trickles-userapi_2.c:27505:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp), *dummy_tp =
trickles-userapi_2.c:27508:		    dummy_tp->trickles_opt = tp->trickles_opt;
trickles-userapi_2.c:27509:		    dummy_tp->t.hmacCTX = tp->t.hmacCTX;
trickles-userapi_2.c:27510:		    dummy_tp->t.nonceCTX = tp->t.nonceCTX;
trickles-userapi_2.c:27512:		    msk->serverSK = sk;
trickles-userapi_2.c:27515:		      if (msk->seqnum != last + 1)
trickles-userapi_2.c:27518:		      last = msk->seqnum;
trickles-userapi_2.c:27520:		    if (msk->tag == SYN || msk->tag == ACK || msk->tag == FIN)
trickles-userapi_2.c:27541:			tcb = ((struct tcp_skb_cb *) &((skb)->cb[0]));
trickles-userapi_2.c:27542:			skb->csum = 0;
trickles-userapi_2.c:27543:			skb->ip_summed = 1;
trickles-userapi_2.c:27548:			switch (msk->tag)
trickles-userapi_2.c:27571:					") failed at " "trickles-userapi.c"
trickles-userapi_2.c:27577:			for (i = 0; i < msk->num_packets; i++)
trickles-userapi_2.c:27580:			    skb1->csum = 0;
trickles-userapi_2.c:27581:			    skb1->ip_summed = 1;
trickles-userapi_2.c:27583:			    msk->tag = ACK;
trickles-userapi_2.c:27586:		    struct pminisock *pmsk = msk->pmsk;
trickles-userapi_2.c:27588:			&& ((msk)->cacheRecycleIndex >= 0))
trickles-userapi_2.c:27592:					       pmsk->cacheRecycleIndex, 0);
trickles-userapi_2.c:27621:		    struct cminisock_packet *pkts = msk->packets;
trickles-userapi_2.c:27632:		    for (i = numUCChildPackets; i < msk->num_packets; i++)
trickles-userapi_2.c:27640:		    for (i = 0; i < msk->num_packets; i++)
trickles-userapi_2.c:27659:		    for (i = numDataPackets; i < msk->num_packets; i++)
trickles-userapi_2.c:27692:			skb->csum = 0;
trickles-userapi_2.c:27715:		    if (msk->num_packets > (4))
trickles-userapi_2.c:27719:				   msk->num_packets,
trickles-userapi_2.c:27724:			if (!(msk->num_packets >= 0))
trickles-userapi_2.c:27727:				    "msk->num_packets >= 0" ") failed at "
trickles-userapi_2.c:27728:				    "trickles-userapi.c" "(%d)\n", 517);
trickles-userapi_2.c:27737:		    pkts = msk->packets;
trickles-userapi_2.c:27743:		    for (i = 0; i < msk->num_packets; i++)
trickles-userapi_2.c:27745:			maxLen += msk->packets[i].len;
trickles-userapi_2.c:27752:			if (msk->dbg_mark == (50))
trickles-userapi_2.c:27759:			      ("%lud:mark(%d) Short by %d (%d - %d) count=(%d,%d)\n",
trickles-userapi_2.c:27760:			       jiffies, msk->dbg_mark, maxLen - totallen,
trickles-userapi_2.c:27763:				    msk->input_len);
trickles-userapi_2.c:27777:		    for (i = 0; i < msk->num_packets; i++)
trickles-userapi_2.c:27822:			skb->csum = 0;
trickles-userapi_2.c:27823:			skb->ip_summed = 1;
trickles-userapi_2.c:27828:							      iov_len -
trickles-userapi_2.c:27849:				   src, amt, msk->state, msk->seq,
trickles-userapi_2.c:27850:				   msk->TCPBase, msk->seq - msk->TCPBase);
trickles-userapi_2.c:27856:			    totallen -= amt;
trickles-userapi_2.c:27857:			    pkt_remain -= amt;
trickles-userapi_2.c:27870:				    ") failed at " "trickles-userapi.c"
trickles-userapi_2.c:27876:			    printk ("sending pkts[%d] %u-%u\n", i,
trickles-userapi_2.c:27882:			    tiov[tiovlen - 1].iov_base == (void *) -1
trickles-userapi_2.c:27883:			    && tiov[tiovlen - 1].iov_len == 0)
trickles-userapi_2.c:27886:			    msk->tag = FIN;
trickles-userapi_2.c:27908:			       totallen, msk->executionTrace);
trickles-userapi_2.c:27950:			    (void) (&((sk)->lock.slock));
trickles-userapi_2.c:27953:			if ((sk)->lock.users != 0)
trickles-userapi_2.c:27955:			(sk)->lock.users = 1;
trickles-userapi_2.c:27968:				if (!--*ptr)
trickles-userapi_2.c:27969:				  __asm__ __volatile__ ("cmpl $0, -8(%0);"
trickles-userapi_2.c:27991:		    sk->shutdown = 3;
trickles-userapi_2.c:27995:			    __skb_dequeue (&sk->receive_queue)) !=
trickles-userapi_2.c:27999:			  ((struct tcp_skb_cb *) &((skb)->cb[0]))->end_seq -
trickles-userapi_2.c:28000:			  ((struct tcp_skb_cb *) &((skb)->cb[0]))->seq -
trickles-userapi_2.c:28001:			  skb->h.th->fin;
trickles-userapi_2.c:28021:			    (void) (&((sk)->lock.slock));
trickles-userapi_2.c:28024:			if ((sk)->backlog.tail != ((void *) 0))
trickles-userapi_2.c:28026:			(sk)->lock.users = 0;
trickles-userapi_2.c:28027:			if (waitqueue_active (&((sk)->lock.wq)))
trickles-userapi_2.c:28028:			  __wake_up ((&((sk)->lock.wq)), 2 | 1, 1);
trickles-userapi_2.c:28041:				if (!--*ptr)
trickles-userapi_2.c:28042:				  __asm__ __volatile__ ("cmpl $0, -8(%0);"
trickles-userapi_2.c:28071:		    (void) (&((sk)->lock.slock));
trickles-userapi_2.c:28086:			if (!--*ptr)
trickles-userapi_2.c:28087:			  __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;"
trickles-userapi_2.c:28106:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:28124:			    (void) (&((sk)->lock.slock));
trickles-userapi_2.c:28127:			if ((sk)->backlog.tail != ((void *) 0))
trickles-userapi_2.c:28129:			(sk)->lock.users = 0;
trickles-userapi_2.c:28130:			if (waitqueue_active (&((sk)->lock.wq)))
trickles-userapi_2.c:28131:			  __wake_up ((&((sk)->lock.wq)), 2 | 1, 1);
trickles-userapi_2.c:28144:				if (!--*ptr)
trickles-userapi_2.c:28145:				  __asm__ __volatile__ ("cmpl $0, -8(%0);"
trickles-userapi_2.c:28167:		    (void) (&((sk)->lock.slock));
trickles-userapi_2.c:28168:		    if (!(tp->trickles_opt & 0x1) && val & 0x1)
trickles-userapi_2.c:28172:			    tp->t.testseq = 1;
trickles-userapi_2.c:28173:			    sk->prot = &trickles_prot;
trickles-userapi_2.c:28178:			    sk->prot = &trickles_client_prot;
trickles-userapi_2.c:28187:			    tp->t.slowstart_timer.function =
trickles-userapi_2.c:28189:			    tp->t.slowstart_timer.data = (long) sk;
trickles-userapi_2.c:28192:		    tp->trickles_opt = val;
trickles-userapi_2.c:28208:			    (void) (&((sk)->lock.slock));
trickles-userapi_2.c:28211:			if ((sk)->lock.users != 0)
trickles-userapi_2.c:28213:			(sk)->lock.users = 1;
trickles-userapi_2.c:28226:				if (!--*ptr)
trickles-userapi_2.c:28227:				  __asm__ __volatile__ ("cmpl $0, -8(%0);"
trickles-userapi_2.c:28254:			if (!--*ptr)
trickles-userapi_2.c:28255:			  __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;"
trickles-userapi_2.c:28280:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:28283:		    int tiovlen = msg->msg_iovlen;
trickles-userapi_2.c:28284:		    int rval = -22;
trickles-userapi_2.c:28286:		    struct tiovec *tiov = (struct tiovec *) msg->msg_iov;
trickles-userapi_2.c:28287:		    struct cminisock_cmd *cmd = msg->msg_name;
trickles-userapi_2.c:28289:		    if (sizeof (*cmd) != msg->msg_namelen
trickles-userapi_2.c:28290:			|| (int) cmd->magic != (0xbaadd33d))
trickles-userapi_2.c:28292:			return -22;
trickles-userapi_2.c:28295:		    if (cmd->cmd == STARTRCV)
trickles-userapi_2.c:28298:			return -22;
trickles-userapi_2.c:28301:			((tp)->cminisock_api_config.cfg.mmap_base !=
trickles-userapi_2.c:28304:			return -22;
trickles-userapi_2.c:28306:		    if (cmd->cmd == POLL)
trickles-userapi_2.c:28320:				(void) (&((sk)->lock.slock));
trickles-userapi_2.c:28323:			    if ((sk)->lock.users != 0)
trickles-userapi_2.c:28325:			    (sk)->lock.users = 1;
trickles-userapi_2.c:28338:				    if (!--*ptr)
trickles-userapi_2.c:28339:				      __asm__ __volatile__ ("cmpl $0, -8(%0);"
trickles-userapi_2.c:28361:			if (skb_queue_len (&tp->ucopy.prequeue))
trickles-userapi_2.c:28377:				(void) (&((sk)->lock.slock));
trickles-userapi_2.c:28380:			    if ((sk)->backlog.tail != ((void *) 0))
trickles-userapi_2.c:28382:			    (sk)->lock.users = 0;
trickles-userapi_2.c:28383:			    if (waitqueue_active (&((sk)->lock.wq)))
trickles-userapi_2.c:28384:			      __wake_up ((&((sk)->lock.wq)), 2 | 1, 1);
trickles-userapi_2.c:28397:				    if (!--*ptr)
trickles-userapi_2.c:28398:				      __asm__ __volatile__ ("cmpl $0, -8(%0);"
trickles-userapi_2.c:28424:		    msk = cmd->socket;
trickles-userapi_2.c:28438:			    (void) (&((sk)->lock.slock));
trickles-userapi_2.c:28441:			if ((sk)->lock.users != 0)
trickles-userapi_2.c:28443:			(sk)->lock.users = 1;
trickles-userapi_2.c:28456:				if (!--*ptr)
trickles-userapi_2.c:28457:				  __asm__ __volatile__ ("cmpl $0, -8(%0);"
trickles-userapi_2.c:28480:			((tp)->cminisock_api_config.cfg.mmap_base !=
trickles-userapi_2.c:28484:			rval = -22;
trickles-userapi_2.c:28496:				(void) (&((sk)->lock.slock));
trickles-userapi_2.c:28499:			    if ((sk)->backlog.tail != ((void *) 0))
trickles-userapi_2.c:28501:			    (sk)->lock.users = 0;
trickles-userapi_2.c:28502:			    if (waitqueue_active (&((sk)->lock.wq)))
trickles-userapi_2.c:28503:			      __wake_up ((&((sk)->lock.wq)), 2 | 1, 1);
trickles-userapi_2.c:28516:				    if (!--*ptr)
trickles-userapi_2.c:28517:				      __asm__ __volatile__ ("cmpl $0, -8(%0);"
trickles-userapi_2.c:28544:			   struct tcp_opt * _tp = &((sk)->tp_pinfo.af_tcp);
trickles-userapi_2.c:28545:			   (((((char *) ((msk)) -
trickles-userapi_2.c:28546:			       (char *) ((_tp)->cminisock_api_config.cfg.ctl->
trickles-userapi_2.c:28550:				((void *) ((_tp)->cminisock_api_config.cfg.
trickles-userapi_2.c:28551:					   ctl->minisock_base))
trickles-userapi_2.c:28555:				((_tp)->cminisock_api_config.cfg.ctl->
trickles-userapi_2.c:28557:			   && (((msk))->ctl == ALLOC_READY
trickles-userapi_2.c:28558:			       || ((msk))->ctl == ALLOC_HALFFREE);}))
trickles-userapi_2.c:28561:				!(((((char *) (msk) -
trickles-userapi_2.c:28562:				     (char *) ((tp)->cminisock_api_config.cfg.
trickles-userapi_2.c:28563:					       ctl->minisock_base)) %
trickles-userapi_2.c:28567:				      ((void *) ((tp)->cminisock_api_config.
trickles-userapi_2.c:28568:						 cfg.ctl->minisock_base))
trickles-userapi_2.c:28572:				      ((tp)->cminisock_api_config.cfg.ctl->
trickles-userapi_2.c:28574:				!(((msk)->ctl == ALLOC_READY
trickles-userapi_2.c:28575:				   || (msk)->ctl == ALLOC_HALFFREE)));
trickles-userapi_2.c:28576:			rval = -22;
trickles-userapi_2.c:28588:				(void) (&((sk)->lock.slock));
trickles-userapi_2.c:28591:			    if ((sk)->backlog.tail != ((void *) 0))
trickles-userapi_2.c:28593:			    (sk)->lock.users = 0;
trickles-userapi_2.c:28594:			    if (waitqueue_active (&((sk)->lock.wq)))
trickles-userapi_2.c:28595:			      __wake_up ((&((sk)->lock.wq)), 2 | 1, 1);
trickles-userapi_2.c:28608:				    if (!--*ptr)
trickles-userapi_2.c:28609:				      __asm__ __volatile__ ("cmpl $0, -8(%0);"
trickles-userapi_2.c:28640:		    pmsk = msk->pmsk;
trickles-userapi_2.c:28644:		    (msk)->pmsk = ((void *) 0);
trickles-userapi_2.c:28648:		    if (cmd->cmd == DROP)
trickles-userapi_2.c:28652:			(msk)->pmsk = ((void *) 0);
trickles-userapi_2.c:28659:		    if (cmd->cmd != PROCESS)
trickles-userapi_2.c:28665:			(msk)->pmsk = ((void *) 0);
trickles-userapi_2.c:28689:			    (void) (&((sk)->lock.slock));
trickles-userapi_2.c:28692:			if ((sk)->backlog.tail != ((void *) 0))
trickles-userapi_2.c:28694:			(sk)->lock.users = 0;
trickles-userapi_2.c:28695:			if (waitqueue_active (&((sk)->lock.wq)))
trickles-userapi_2.c:28696:			  __wake_up ((&((sk)->lock.wq)), 2 | 1, 1);
trickles-userapi_2.c:28709:				if (!--*ptr)
trickles-userapi_2.c:28710:				  __asm__ __volatile__ ("cmpl $0, -8(%0);"
trickles-userapi_2.c:28759:				(void) (&((sk)->lock.slock));
trickles-userapi_2.c:28762:			    if ((sk)->backlog.tail != ((void *) 0))
trickles-userapi_2.c:28764:			    (sk)->lock.users = 0;
trickles-userapi_2.c:28765:			    if (waitqueue_active (&((sk)->lock.wq)))
trickles-userapi_2.c:28766:			      __wake_up ((&((sk)->lock.wq)), 2 | 1, 1);
trickles-userapi_2.c:28779:				    if (!--*ptr)
trickles-userapi_2.c:28780:				      __asm__ __volatile__ ("cmpl $0, -8(%0);"
trickles-userapi_2.c:28802:			interruptible_sleep_on_timeout (sk->sleep, timeout);
trickles-userapi_2.c:28814:				(void) (&((sk)->lock.slock));
trickles-userapi_2.c:28817:			    if ((sk)->lock.users != 0)
trickles-userapi_2.c:28819:			    (sk)->lock.users = 1;
trickles-userapi_2.c:28832:				    if (!--*ptr)
trickles-userapi_2.c:28833:				      __asm__ __volatile__ ("cmpl $0, -8(%0);"
trickles-userapi_2.c:28865:				    jiffies - in_time);
trickles-userapi_2.c:28866:			    err = -11;
trickles-userapi_2.c:28880:		    struct sock *sk = sock->sk;
trickles-userapi_2.c:28881:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:28885:		    if (((tp)->cminisock_api_config.cfg.mmap_base !=
trickles-userapi_2.c:28889:			  ((&tp->cminisock_api_config.cfg.ctl->
trickles-userapi_2.c:28890:			    update_since_poll)->counter);
trickles-userapi_2.c:28891:			if ((!(tp->trickles_opt & 0x80)
trickles-userapi_2.c:28892:			     && !dlist_empty (&tp->cminisock_api_config.cfg.
trickles-userapi_2.c:28893:					      ctl->pmsk_eventlist))
trickles-userapi_2.c:28894:			    || ((tp->trickles_opt & 0x80) && poll_value > 0
trickles-userapi_2.c:28895:				&& !dlist_empty (&tp->cminisock_api_config.
trickles-userapi_2.c:28896:						 cfg.ctl->pmsk_eventlist)))
trickles-userapi_2.c:28902:					&tp->cminisock_api_config.cfg.ctl->
trickles-userapi_2.c:28931:		      (struct trickles_kconfig *) area->vm_private_data;
trickles-userapi_2.c:28935:		    void *base = api_config->cfg.ctl->ro_base;
trickles-userapi_2.c:28936:		    offset = address - (unsigned long) area->vm_start;
trickles-userapi_2.c:28937:		    if (offset >= api_config->cfg.ctl->ro_len)
trickles-userapi_2.c:28945:			  long) (virt_to_kseg ((char *) base + offset)) -
trickles-userapi_2.c:28948:		      atomic_inc (&(page)->count);
trickles-userapi_2.c:28962:		    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:28977:			while (tp->cminisock_api_config.pending_delivery)
trickles-userapi_2.c:28983:				(get_current ())->state = (1);
trickles-userapi_2.c:28998:				    (void) (&((sk)->lock.slock));
trickles-userapi_2.c:29001:				if ((sk)->backlog.tail != ((void *) 0))
trickles-userapi_2.c:29003:				(sk)->lock.users = 0;
trickles-userapi_2.c:29004:				if (waitqueue_active (&((sk)->lock.wq)))
trickles-userapi_2.c:29005:				  __wake_up ((&((sk)->lock.wq)), 2 | 1, 1);
trickles-userapi_2.c:29018:					if (!--*ptr)
trickles-userapi_2.c:29020:					    __volatile__ ("cmpl $0, -8(%0);"
trickles-userapi_2.c:29054:				    (void) (&((sk)->lock.slock));
trickles-userapi_2.c:29057:				if ((sk)->lock.users != 0)
trickles-userapi_2.c:29059:				(sk)->lock.users = 1;
trickles-userapi_2.c:29072:					if (!--*ptr)
trickles-userapi_2.c:29074:					    __volatile__ ("cmpl $0, -8(%0);"
trickles-userapi_2.c:29100:			    (get_current ())->state = (0);
trickles-userapi_2.c:29107:			    error = -22;
trickles-userapi_2.c:29120:			    error = -14;
trickles-userapi_2.c:29128:			    error = -22;
trickles-userapi_2.c:29136:			    error = -12;
trickles-userapi_2.c:29149:				    ") failed at " "trickles-userapi.c"
trickles-userapi_2.c:29152:			ctl->ro_base = new_config.mmap_base;
trickles-userapi_2.c:29153:			ctl->ro_len =
trickles-userapi_2.c:29154:			  (((mmap_len / 4) + (1UL << 12) -
trickles-userapi_2.c:29155:			    1) & (~((1UL << 12) - 1)));
trickles-userapi_2.c:29156:			ctl->ro_offs =
trickles-userapi_2.c:29157:			  (char *) ctl->ro_base -
trickles-userapi_2.c:29159:			ctl->rw_base = (__u8 *) ctl->ro_base + ctl->ro_len;
trickles-userapi_2.c:29160:			ctl->rw_len =
trickles-userapi_2.c:29161:			  (((mmap_len -
trickles-userapi_2.c:29162:			     ((char *) ctl->rw_base -
trickles-userapi_2.c:29163:			      (char *) new_config.mmap_base)) + (1UL << 12) -
trickles-userapi_2.c:29164:			    1) & (~((1UL << 12) - 1))) - (1UL << 12);
trickles-userapi_2.c:29165:			ctl->rw_offs =
trickles-userapi_2.c:29166:			  (char *) ctl->rw_base -
trickles-userapi_2.c:29168:			(((&ctl->update_since_poll)->counter) = (0));
trickles-userapi_2.c:29173:				(&((struct tq_struct *) (ctl + 1))->list)->
trickles-userapi_2.c:29175:				  (&((struct tq_struct *) (ctl + 1))->list);
trickles-userapi_2.c:29176:				(&((struct tq_struct *) (ctl + 1))->list)->
trickles-userapi_2.c:29178:				  (&((struct tq_struct *) (ctl + 1))->list);
trickles-userapi_2.c:29181:			    ((struct tq_struct *) (ctl + 1))->sync = 0;
trickles-userapi_2.c:29184:				(((struct tq_struct *) (ctl + 1)))->routine =
trickles-userapi_2.c:29186:				(((struct tq_struct *) (ctl + 1)))->data =
trickles-userapi_2.c:29192:			if (!(ctl->rw_len > 0))
trickles-userapi_2.c:29194:			    printk ("KERNEL: assertion (" "ctl->rw_len > 0"
trickles-userapi_2.c:29195:				    ") failed at " "trickles-userapi.c"
trickles-userapi_2.c:29198:			if (!(ctl->ro_len > 0))
trickles-userapi_2.c:29200:			    printk ("KERNEL: assertion (" "ctl->ro_len > 0"
trickles-userapi_2.c:29201:				    ") failed at " "trickles-userapi.c"
trickles-userapi_2.c:29205:			    ((char *) ctl->ro_base <
trickles-userapi_2.c:29209:				    "(char*)ctl->ro_base < (char*)new_config.mmap_base + mmap_len"
trickles-userapi_2.c:29210:				    ") failed at " "trickles-userapi.c"
trickles-userapi_2.c:29214:			init_head (&ctl->msk_eventlist);
trickles-userapi_2.c:29216:			tp->cminisock_api_config.cfg = new_config;
trickles-userapi_2.c:29220:			head = &tp->cminisock_api_config.msk_freelist;
trickles-userapi_2.c:29224:			  (struct cminisock *) ((char *) ctl->ro_base +
trickles-userapi_2.c:29226:			ctl->minisock_base = msk;
trickles-userapi_2.c:29227:			ctl->minisock_offs =
trickles-userapi_2.c:29228:			  (char *) ctl->minisock_base -
trickles-userapi_2.c:29231:			minisock_len = ((ctl->ro_len) / 4);
trickles-userapi_2.c:29232:			ctl->minisock_limit =
trickles-userapi_2.c:29233:			  (char *) ctl->minisock_base + minisock_len;
trickles-userapi_2.c:29237:				    ") failed at " "trickles-userapi.c"
trickles-userapi_2.c:29241:			       (char *) ctl->minisock_limit)
trickles-userapi_2.c:29263:			    msk->ctl = ALLOC_FREE;
trickles-userapi_2.c:29264:			    msk->prev = msk->next = ((void *) 0);
trickles-userapi_2.c:29265:			    msk->list = ((void *) 0);
trickles-userapi_2.c:29272:			int pminisock_len = ((ctl->ro_len) / 4);
trickles-userapi_2.c:29273:			ctl->pminisock_base =
trickles-userapi_2.c:29274:			  ((typeof (ctl->minisock_limit)) (char *)
trickles-userapi_2.c:29275:			   (ctl->minisock_limit) + (1 -
trickles-userapi_2.c:29276:						    ((int) ctl->
trickles-userapi_2.c:29279:			struct pminisock *pmsk = ctl->pminisock_base;
trickles-userapi_2.c:29281:			  &tp->cminisock_api_config.pmsk_freelist;
trickles-userapi_2.c:29283:			dlist_init (&ctl->pmsk_eventlist);
trickles-userapi_2.c:29286:			ctl->pminisock_limit =
trickles-userapi_2.c:29287:			  (char *) ctl->pminisock_base + pminisock_len;
trickles-userapi_2.c:29289:			       (char *) ctl->pminisock_limit)
trickles-userapi_2.c:29311:			    pmsk->prev = pmsk->next = ((void *) 0);
trickles-userapi_2.c:29312:			    pmsk->ctl = ALLOC_FREE;
trickles-userapi_2.c:29320:			ctl->heap_base =
trickles-userapi_2.c:29321:			  ((typeof (ctl->pminisock_limit)) (char *)
trickles-userapi_2.c:29322:			   (ctl->pminisock_limit) + (1 -
trickles-userapi_2.c:29323:						     ((int) ctl->
trickles-userapi_2.c:29326:			tp->t.heapbytesize = ctl->ro_len - pminisock_len;
trickles-userapi_2.c:29337:			    error = -22;
trickles-userapi_2.c:29354:			    tp->t.hmacCTX =
trickles-userapi_2.c:29355:			      kmalloc (sizeof (*tp->t.hmacCTX),
trickles-userapi_2.c:29357:			    if (tp->t.hmacCTX == ((void *) 0))
trickles-userapi_2.c:29360:				error = -12;
trickles-userapi_2.c:29363:			    hmac_setup (tp->t.hmacCTX, hmac_key, (16));
trickles-userapi_2.c:29378:			    tp->t.nonceCTX =
trickles-userapi_2.c:29379:			      kmalloc (sizeof (*tp->t.nonceCTX),
trickles-userapi_2.c:29381:			    if (tp->t.nonceCTX == ((void *) 0))
trickles-userapi_2.c:29384:				error = -12;
trickles-userapi_2.c:29387:			    aes_encrypt_key (nonce_key, (16), tp->t.nonceCTX);
trickles-userapi_2.c:29412:			    return -14;
trickles-userapi_2.c:29416:			   (sizeof (tp->cminisock_api_config.cfg)) ?
trickles-userapi_2.c:29418:						    (&tp->
trickles-userapi_2.c:29422:						     (tp->
trickles-userapi_2.c:29426:						   (&tp->cminisock_api_config.
trickles-userapi_2.c:29429:						    (tp->cminisock_api_config.
trickles-userapi_2.c:29435:			    return -22;
trickles-userapi_2.c:29439:			      long __pu_err = -14;
trickles-userapi_2.c:29443:			unsigned long flag, sum; asm ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag), "=r" (sum):"1" (__pu_addr), "g" ((int) (sizeof (*((int *)optlen)))), "g" (get_current ()->addr_limit.seg)); flag;}) == 0))
trickles-userapi_2.c:29450:__asm__ __volatile__ ("1:	mov" "b" " %" "b" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "iq" (((__typeof__ (*((int *)optlen))) (len))), "m" ((*(struct __large_struct *) (__pu_addr))), "i" (-14), "0" (__pu_err)); break; case 2:
trickles-userapi_2.c:29451:__asm__ __volatile__ ("1:	mov" "w" " %" "w" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*((int *) optlen))) (len))), "m" ((*(struct __large_struct *) (__pu_addr))), "i" (-14), "0" (__pu_err)); break; case 4:
trickles-userapi_2.c:29452:__asm__ __volatile__ ("1:	mov" "l" " %" "" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*((int *) optlen))) (len))), "m" ((*(struct __large_struct *) (__pu_addr))), "i" (-14), "0" (__pu_err)); break; case 8:
trickles-userapi_2.c:29453:__asm__ __volatile__ ("1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous": "=r" (__pu_err): "A" (((__typeof__ (*((int *) optlen))) (len))), "r" (__pu_addr), "i" (-14), "0" (__pu_err)); break; default:
trickles-userapi_2.c:29462:			    return -14;
trickles-userapi_2.c:29484:			    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:29488:				return -22;
trickles-userapi_2.c:29494:				rval = tp->snd_wnd;
trickles-userapi_2.c:29498:				rval = tp->snd_ssthresh;
trickles-userapi_2.c:29509:				return -92;
trickles-userapi_2.c:29526:				return -14;
trickles-userapi_2.c:29530:				return -14;
trickles-userapi_2.c:29534:				  long __pu_err = -14;
trickles-userapi_2.c:29538:			    unsigned long flag, sum; asm ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag), "=r" (sum):"1" (__pu_addr), "g" ((int) (sizeof (*(optlen)))), "g" (get_current ()->addr_limit.seg)); flag;}
trickles-userapi_2.c:29545:__asm__ __volatile__ ("1:	mov" "b" " %" "b" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "iq" (((__typeof__ (*(optlen))) (outputLen))), "m" ((*(struct __large_struct *) (__pu_addr))), "i" (-14), "0" (__pu_err)); break; case 2:
trickles-userapi_2.c:29546:__asm__ __volatile__ ("1:	mov" "w" " %" "w" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(optlen))) (outputLen))), "m" ((*(struct __large_struct *) (__pu_addr))), "i" (-14), "0" (__pu_err)); break; case 4:
trickles-userapi_2.c:29547:__asm__ __volatile__ ("1:	mov" "l" " %" "" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(optlen))) (outputLen))), "m" ((*(struct __large_struct *) (__pu_addr))), "i" (-14), "0" (__pu_err)); break; case 8:
trickles-userapi_2.c:29548:__asm__ __volatile__ ("1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous": "=r" (__pu_err): "A" (((__typeof__ (*(optlen))) (outputLen))), "r" (__pu_addr), "i" (-14), "0" (__pu_err)); break; default:
trickles-userapi_2.c:29555:				return -14;
trickles-userapi_2.c:29559:				    long __pu_err = -14;
trickles-userapi_2.c:29563:			      unsigned long flag, sum; asm ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag), "=r" (sum):"1" (__pu_addr), "g" ((int) (sizeof (*(optval)))), "g" (get_current ()->addr_limit.seg)); flag;}
trickles-userapi_2.c:29571:__asm__ __volatile__ ("1:	mov" "b" " %" "b" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "iq" (((__typeof__ (*(optval))) (rval))), "m" ((*(struct __large_struct *) (__pu_addr))), "i" (-14), "0" (__pu_err)); break; case 2:
trickles-userapi_2.c:29572:__asm__ __volatile__ ("1:	mov" "w" " %" "w" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(optval))) (rval))), "m" ((*(struct __large_struct *) (__pu_addr))), "i" (-14), "0" (__pu_err)); break; case 4:
trickles-userapi_2.c:29573:__asm__ __volatile__ ("1:	mov" "l" " %" "" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(optval))) (rval))), "m" ((*(struct __large_struct *) (__pu_addr))), "i" (-14), "0" (__pu_err)); break; case 8:
trickles-userapi_2.c:29574:__asm__ __volatile__ ("1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous": "=r" (__pu_err): "A" (((__typeof__ (*(optval))) (rval))), "r" (__pu_addr), "i" (-14), "0" (__pu_err)); break; default:
trickles-userapi_2.c:29581:				  return -14;
trickles-userapi_2.c:29590:				  fput (sock->file);
trickles-userapi_2.c:29615:				  err = -22;
trickles-userapi_2.c:29620:				  err = -12;
trickles-userapi_2.c:29633:				      err = -14;
trickles-userapi_2.c:29654:				  sk = sock->sk;
trickles-userapi_2.c:29655:				  tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:29670:					  (void) (&((sk)->lock.slock));
trickles-userapi_2.c:29673:				      if ((sk)->lock.users != 0)
trickles-userapi_2.c:29675:				      (sk)->lock.users = 1;
trickles-userapi_2.c:29690:					      if (!--*ptr)
trickles-userapi_2.c:29693:						  ("cmpl $0, -8(%0);"
trickles-userapi_2.c:29713:				      ((tp)->cminisock_api_config.cfg.
trickles-userapi_2.c:29717:				      err = -22;
trickles-userapi_2.c:29732:					      (void) (&((sk)->lock.slock));
trickles-userapi_2.c:29735:					  if ((sk)->backlog.tail !=
trickles-userapi_2.c:29738:					  (sk)->lock.users = 0;
trickles-userapi_2.c:29740:					      (&((sk)->lock.wq)))
trickles-userapi_2.c:29741:					    __wake_up ((&((sk)->lock.wq)),
trickles-userapi_2.c:29758:						  if (!--*ptr)
trickles-userapi_2.c:29761:						      ("cmpl $0, -8(%0);"
trickles-userapi_2.c:29787:					 &((sk)->tp_pinfo.af_tcp);
trickles-userapi_2.c:29788:					 (((((char *) ((msk)) -
trickles-userapi_2.c:29789:					     (char *) ((_tp)->
trickles-userapi_2.c:29791:						       cfg.ctl->
trickles-userapi_2.c:29798:					   ((void *) ((_tp)->
trickles-userapi_2.c:29800:						      cfg.ctl->minisock_base))
trickles-userapi_2.c:29805:					   ((_tp)->cminisock_api_config.cfg.
trickles-userapi_2.c:29806:					    ctl->minisock_limit)))
trickles-userapi_2.c:29807:					 && (((msk))->ctl == ALLOC_READY
trickles-userapi_2.c:29808:					     || ((msk))->ctl ==
trickles-userapi_2.c:29812:					      !(((((char *) (msk) -
trickles-userapi_2.c:29813:						   (char *) ((tp)->
trickles-userapi_2.c:29815:							     cfg.ctl->
trickles-userapi_2.c:29823:						 ((void *) ((tp)->
trickles-userapi_2.c:29825:							    cfg.ctl->
trickles-userapi_2.c:29831:						 ((tp)->cminisock_api_config.
trickles-userapi_2.c:29832:						  cfg.ctl->minisock_limit))),
trickles-userapi_2.c:29833:					      !(((msk)->ctl == ALLOC_READY
trickles-userapi_2.c:29834:						 || (msk)->ctl ==
trickles-userapi_2.c:29836:				      err = -22;
trickles-userapi_2.c:29851:					      (void) (&((sk)->lock.slock));
trickles-userapi_2.c:29854:					  if ((sk)->backlog.tail !=
trickles-userapi_2.c:29857:					  (sk)->lock.users = 0;
trickles-userapi_2.c:29859:					      (&((sk)->lock.wq)))
trickles-userapi_2.c:29860:					    __wake_up ((&((sk)->lock.wq)),
trickles-userapi_2.c:29877:						  if (!--*ptr)
trickles-userapi_2.c:29880:						      ("cmpl $0, -8(%0);"
trickles-userapi_2.c:29904:				  pmsk = msk->pmsk;
trickles-userapi_2.c:29908:				  (msk)->pmsk = ((void *) 0);
trickles-userapi_2.c:29935:					  (void) (&((sk)->lock.slock));
trickles-userapi_2.c:29938:				      if ((sk)->backlog.tail != ((void *) 0))
trickles-userapi_2.c:29940:				      (sk)->lock.users = 0;
trickles-userapi_2.c:29941:				      if (waitqueue_active (&((sk)->lock.wq)))
trickles-userapi_2.c:29942:					__wake_up ((&((sk)->lock.wq)), 2 | 1,
trickles-userapi_2.c:29958:					      if (!--*ptr)
trickles-userapi_2.c:29961:						  ("cmpl $0, -8(%0);"
trickles-userapi_2.c:29997:				  unsigned long count = desc->count;
trickles-userapi_2.c:29999:				    (struct sk_buff *) desc->buf;
trickles-userapi_2.c:30001:				    ((struct skb_shared_info *) ((skb)->
trickles-userapi_2.c:30002:								 end))->
trickles-userapi_2.c:30011:				      written = -22;
trickles-userapi_2.c:30015:				      atomic_inc (&(page)->count);
trickles-userapi_2.c:30019:				      skb->len += size;
trickles-userapi_2.c:30020:				      skb->data_len += size;
trickles-userapi_2.c:30024:				      desc->error = written;
trickles-userapi_2.c:30027:				  desc->count = count - written;
trickles-userapi_2.c:30028:				  desc->written += written;
trickles-userapi_2.c:30047:				  retval = -9;
trickles-userapi_2.c:30051:				  if (!(in_file->f_mode & 1))
trickles-userapi_2.c:30053:				  retval = -22;
trickles-userapi_2.c:30054:				  in_inode = in_file->f_dentry->d_inode;
trickles-userapi_2.c:30057:				  if (!in_inode->i_mapping->a_ops->readpage)
trickles-userapi_2.c:30061:						       in_file->f_pos, count);
trickles-userapi_2.c:30108:					     msk->num_packets,
trickles-userapi_2.c:30116:				  pkts = msk->packets;
trickles-userapi_2.c:30122:				  for (i = 0; i < msk->num_packets; i++)
trickles-userapi_2.c:30186:				      skb->csum = 0;
trickles-userapi_2.c:30187:				      skb->ip_summed = 1;
trickles-userapi_2.c:30192:						     (fiov[fiov_pos].len -
trickles-userapi_2.c:30208:					  if (fiov[fiov_pos].fd == -2)
trickles-userapi_2.c:30235:						     msk->packets[i].type);
trickles-userapi_2.c:30237:						  rval = -22;
trickles-userapi_2.c:30279:					  totallen -= amt;
trickles-userapi_2.c:30280:					  pkt_remain -= amt;
trickles-userapi_2.c:30295:						  "trickles-userapi.c"
trickles-userapi_2.c:30301:					  printk ("sending pkts[%d] %u-%u\n",
trickles-userapi_2.c:30307:					  fiov[fiovlen - 1].offset == 0
trickles-userapi_2.c:30308:					  && fiov[fiovlen - 1].len == 0)
trickles-userapi_2.c:30310:					  msk->tag = FIN;
trickles-userapi_2.c:30347:				  err = -22;
trickles-userapi_2.c:30354:				    err = -12;
trickles-userapi_2.c:30367:					err = -14;
trickles-userapi_2.c:30385:				  sk = sock->sk;
trickles-userapi_2.c:30386:				  tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:30401:					  (void) (&((sk)->lock.slock));
trickles-userapi_2.c:30404:				      if ((sk)->lock.users != 0)
trickles-userapi_2.c:30406:				      (sk)->lock.users = 1;
trickles-userapi_2.c:30421:					      if (!--*ptr)
trickles-userapi_2.c:30424:						  ("cmpl $0, -8(%0);"
trickles-userapi_2.c:30444:				      ((tp)->cminisock_api_config.cfg.
trickles-userapi_2.c:30462:					      (void) (&((sk)->lock.slock));
trickles-userapi_2.c:30465:					  if ((sk)->backlog.tail !=
trickles-userapi_2.c:30468:					  (sk)->lock.users = 0;
trickles-userapi_2.c:30470:					      (&((sk)->lock.wq)))
trickles-userapi_2.c:30471:					    __wake_up ((&((sk)->lock.wq)),
trickles-userapi_2.c:30488:						  if (!--*ptr)
trickles-userapi_2.c:30491:						      ("cmpl $0, -8(%0);"
trickles-userapi_2.c:30512:				      err = -22;
trickles-userapi_2.c:30518:					 &((sk)->tp_pinfo.af_tcp);
trickles-userapi_2.c:30519:					 (((((char *) ((msk)) -
trickles-userapi_2.c:30520:					     (char *) ((_tp)->
trickles-userapi_2.c:30522:						       cfg.ctl->
trickles-userapi_2.c:30529:					   ((void *) ((_tp)->
trickles-userapi_2.c:30531:						      cfg.ctl->minisock_base))
trickles-userapi_2.c:30536:					   ((_tp)->cminisock_api_config.cfg.
trickles-userapi_2.c:30537:					    ctl->minisock_limit)))
trickles-userapi_2.c:30538:					 && (((msk))->ctl == ALLOC_READY
trickles-userapi_2.c:30539:					     || ((msk))->ctl ==
trickles-userapi_2.c:30543:					      !(((((char *) (msk) -
trickles-userapi_2.c:30544:						   (char *) ((tp)->
trickles-userapi_2.c:30546:							     cfg.ctl->
trickles-userapi_2.c:30554:						 ((void *) ((tp)->
trickles-userapi_2.c:30556:							    cfg.ctl->
trickles-userapi_2.c:30562:						 ((tp)->cminisock_api_config.
trickles-userapi_2.c:30563:						  cfg.ctl->minisock_limit))),
trickles-userapi_2.c:30564:					      !(((msk)->ctl == ALLOC_READY
trickles-userapi_2.c:30565:						 || (msk)->ctl ==
trickles-userapi_2.c:30567:				      err = -22;
trickles-userapi_2.c:30582:					      (void) (&((sk)->lock.slock));
trickles-userapi_2.c:30585:					  if ((sk)->backlog.tail !=
trickles-userapi_2.c:30588:					  (sk)->lock.users = 0;
trickles-userapi_2.c:30590:					      (&((sk)->lock.wq)))
trickles-userapi_2.c:30591:					    __wake_up ((&((sk)->lock.wq)),
trickles-userapi_2.c:30608:						  if (!--*ptr)
trickles-userapi_2.c:30611:						      ("cmpl $0, -8(%0);"
trickles-userapi_2.c:30635:				  pmsk = msk->pmsk;
trickles-userapi_2.c:30639:				  (msk)->pmsk = ((void *) 0);
trickles-userapi_2.c:30666:					  (void) (&((sk)->lock.slock));
trickles-userapi_2.c:30669:				      if ((sk)->backlog.tail != ((void *) 0))
trickles-userapi_2.c:30671:				      (sk)->lock.users = 0;
trickles-userapi_2.c:30672:				      if (waitqueue_active (&((sk)->lock.wq)))
trickles-userapi_2.c:30673:					__wake_up ((&((sk)->lock.wq)), 2 | 1,
trickles-userapi_2.c:30689:					      if (!--*ptr)
trickles-userapi_2.c:30692:						  ("cmpl $0, -8(%0);"
trickles-userapi_2.c:30741:				  sk = sock->sk;
trickles-userapi_2.c:30742:				  tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:30757:					  (void) (&((sk)->lock.slock));
trickles-userapi_2.c:30760:				      if ((sk)->lock.users != 0)
trickles-userapi_2.c:30762:				      (sk)->lock.users = 1;
trickles-userapi_2.c:30777:					      if (!--*ptr)
trickles-userapi_2.c:30780:						  ("cmpl $0, -8(%0);"
trickles-userapi_2.c:30800:				      ((tp)->cminisock_api_config.cfg.
trickles-userapi_2.c:30818:					      (void) (&((sk)->lock.slock));
trickles-userapi_2.c:30821:					  if ((sk)->backlog.tail !=
trickles-userapi_2.c:30824:					  (sk)->lock.users = 0;
trickles-userapi_2.c:30826:					      (&((sk)->lock.wq)))
trickles-userapi_2.c:30827:					    __wake_up ((&((sk)->lock.wq)),
trickles-userapi_2.c:30844:						  if (!--*ptr)
trickles-userapi_2.c:30847:						      ("cmpl $0, -8(%0);"
trickles-userapi_2.c:30868:				      err = -22;
trickles-userapi_2.c:30874:					 &((sk)->tp_pinfo.af_tcp);
trickles-userapi_2.c:30875:					 (((((char *) ((msk)) -
trickles-userapi_2.c:30876:					     (char *) ((_tp)->
trickles-userapi_2.c:30878:						       cfg.ctl->
trickles-userapi_2.c:30885:					   ((void *) ((_tp)->
trickles-userapi_2.c:30887:						      cfg.ctl->minisock_base))
trickles-userapi_2.c:30892:					   ((_tp)->cminisock_api_config.cfg.
trickles-userapi_2.c:30893:					    ctl->minisock_limit)))
trickles-userapi_2.c:30894:					 && (((msk))->ctl == ALLOC_READY
trickles-userapi_2.c:30895:					     || ((msk))->ctl ==
trickles-userapi_2.c:30899:					      !(((((char *) (msk) -
trickles-userapi_2.c:30900:						   (char *) ((tp)->
trickles-userapi_2.c:30902:							     cfg.ctl->
trickles-userapi_2.c:30910:						 ((void *) ((tp)->
trickles-userapi_2.c:30912:							    cfg.ctl->
trickles-userapi_2.c:30918:						 ((tp)->cminisock_api_config.
trickles-userapi_2.c:30919:						  cfg.ctl->minisock_limit))));
trickles-userapi_2.c:30920:				      err = -22;
trickles-userapi_2.c:30935:					      (void) (&((sk)->lock.slock));
trickles-userapi_2.c:30938:					  if ((sk)->backlog.tail !=
trickles-userapi_2.c:30941:					  (sk)->lock.users = 0;
trickles-userapi_2.c:30943:					      (&((sk)->lock.wq)))
trickles-userapi_2.c:30944:					    __wake_up ((&((sk)->lock.wq)),
trickles-userapi_2.c:30961:						  if (!--*ptr)
trickles-userapi_2.c:30964:						      ("cmpl $0, -8(%0);"
trickles-userapi_2.c:30988:				  pmsk = msk->pmsk;
trickles-userapi_2.c:30993:				  if (iov.iov_len == -1)
trickles-userapi_2.c:30996:				      (msk)->pmsk = ((void *) 0);
trickles-userapi_2.c:31002:				  else if (iov.iov_len == -2)
trickles-userapi_2.c:31004:				      if (pmsk->ctl != ALLOC_HALFFREE)
trickles-userapi_2.c:31006:					  pmsk->ctl = ALLOC_HALFFREE;
trickles-userapi_2.c:31014:					  err = -22;
trickles-userapi_2.c:31016:				      if (msk->ctl != ALLOC_HALFFREE)
trickles-userapi_2.c:31018:					  msk->ctl = ALLOC_HALFFREE;
trickles-userapi_2.c:31024:					  err = -22;
trickles-userapi_2.c:31028:				  else if (iov.iov_len == -3)
trickles-userapi_2.c:31030:				      pmsk->tag = FIN;
trickles-userapi_2.c:31031:				      msk->tag = FIN;
trickles-userapi_2.c:31038:				      (msk)->pmsk = ((void *) 0);
trickles-userapi_2.c:31066:					  (void) (&((sk)->lock.slock));
trickles-userapi_2.c:31069:				      if ((sk)->backlog.tail != ((void *) 0))
trickles-userapi_2.c:31071:				      (sk)->lock.users = 0;
trickles-userapi_2.c:31072:				      if (waitqueue_active (&((sk)->lock.wq)))
trickles-userapi_2.c:31073:					__wake_up ((&((sk)->lock.wq)), 2 | 1,
trickles-userapi_2.c:31089:					      if (!--*ptr)
trickles-userapi_2.c:31092:						  ("cmpl $0, -8(%0);"
trickles-userapi_2.c:31122:				  struct sock *sk = sock->sk;
trickles-userapi_2.c:31123:				  struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:31126:				      ((tp)->cminisock_api_config.cfg.
trickles-userapi_2.c:31130:				      return -22;
trickles-userapi_2.c:31133:				  vma->vm_ops = &trickles_vm_ops;
trickles-userapi_2.c:31134:				  vma->vm_private_data =
trickles-userapi_2.c:31135:				    &tp->cminisock_api_config;
trickles-userapi_2.c:31161:				  sk = sock->sk;
trickles-userapi_2.c:31162:				  tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:31177:					  (void) (&((sk)->lock.slock));
trickles-userapi_2.c:31180:				      if ((sk)->lock.users != 0)
trickles-userapi_2.c:31182:				      (sk)->lock.users = 1;
trickles-userapi_2.c:31197:					      if (!--*ptr)
trickles-userapi_2.c:31200:						  ("cmpl $0, -8(%0);"
trickles-userapi_2.c:31220:				      ((tp)->cminisock_api_config.cfg.
trickles-userapi_2.c:31238:					      (void) (&((sk)->lock.slock));
trickles-userapi_2.c:31241:					  if ((sk)->backlog.tail !=
trickles-userapi_2.c:31244:					  (sk)->lock.users = 0;
trickles-userapi_2.c:31246:					      (&((sk)->lock.wq)))
trickles-userapi_2.c:31247:					    __wake_up ((&((sk)->lock.wq)),
trickles-userapi_2.c:31264:						  if (!--*ptr)
trickles-userapi_2.c:31267:						      ("cmpl $0, -8(%0);"
trickles-userapi_2.c:31288:				      err = -22;
trickles-userapi_2.c:31294:					 &((sk)->tp_pinfo.af_tcp);
trickles-userapi_2.c:31295:					 (((((char *) ((msk_compat)) -
trickles-userapi_2.c:31296:					     (char *) ((_tp)->
trickles-userapi_2.c:31298:						       cfg.ctl->
trickles-userapi_2.c:31305:					   ((void *) ((_tp)->
trickles-userapi_2.c:31307:						      cfg.ctl->minisock_base))
trickles-userapi_2.c:31312:					   ((_tp)->cminisock_api_config.cfg.
trickles-userapi_2.c:31313:					    ctl->minisock_limit)))
trickles-userapi_2.c:31314:					 && (((msk_compat))->ctl ==
trickles-userapi_2.c:31316:					     || ((msk_compat))->ctl ==
trickles-userapi_2.c:31320:					      !(((((char *) (msk_compat) -
trickles-userapi_2.c:31321:						   (char *) ((tp)->
trickles-userapi_2.c:31323:							     cfg.ctl->
trickles-userapi_2.c:31331:						 ((void *) ((tp)->
trickles-userapi_2.c:31333:							    cfg.ctl->
trickles-userapi_2.c:31340:						 ((tp)->cminisock_api_config.
trickles-userapi_2.c:31341:						  cfg.ctl->minisock_limit))),
trickles-userapi_2.c:31342:					      !(((msk_compat)->ctl ==
trickles-userapi_2.c:31344:						 || (msk_compat)->ctl ==
trickles-userapi_2.c:31346:				      err = -22;
trickles-userapi_2.c:31361:					      (void) (&((sk)->lock.slock));
trickles-userapi_2.c:31364:					  if ((sk)->backlog.tail !=
trickles-userapi_2.c:31367:					  (sk)->lock.users = 0;
trickles-userapi_2.c:31369:					      (&((sk)->lock.wq)))
trickles-userapi_2.c:31370:					    __wake_up ((&((sk)->lock.wq)),
trickles-userapi_2.c:31387:						  if (!--*ptr)
trickles-userapi_2.c:31390:						      ("cmpl $0, -8(%0);"
trickles-userapi_2.c:31414:				  pmsk = msk_compat->pmsk;
trickles-userapi_2.c:31417:				     pmsk->num_packets,
trickles-userapi_2.c:31418:				     msk_compat->num_packets);
trickles-userapi_2.c:31421:				      || pkt_num >= pmsk->num_packets)
trickles-userapi_2.c:31425:				      err = -22;
trickles-userapi_2.c:31440:					      (void) (&((sk)->lock.slock));
trickles-userapi_2.c:31443:					  if ((sk)->backlog.tail !=
trickles-userapi_2.c:31446:					  (sk)->lock.users = 0;
trickles-userapi_2.c:31448:					      (&((sk)->lock.wq)))
trickles-userapi_2.c:31449:					    __wake_up ((&((sk)->lock.wq)),
trickles-userapi_2.c:31466:						  if (!--*ptr)
trickles-userapi_2.c:31469:						      ("cmpl $0, -8(%0);"
trickles-userapi_2.c:31502:					  err = -12;
trickles-userapi_2.c:31518:							  ((sk)->lock.slock));
trickles-userapi_2.c:31521:					      if ((sk)->backlog.tail !=
trickles-userapi_2.c:31524:					      (sk)->lock.users = 0;
trickles-userapi_2.c:31526:						  (&((sk)->lock.wq)))
trickles-userapi_2.c:31527:						__wake_up ((&((sk)->lock.wq)),
trickles-userapi_2.c:31544:						      if (!--*ptr)
trickles-userapi_2.c:31547:							  ("cmpl $0, -8(%0);"
trickles-userapi_2.c:31581:					  err = -14;
trickles-userapi_2.c:31597:							  ((sk)->lock.slock));
trickles-userapi_2.c:31600:					      if ((sk)->backlog.tail !=
trickles-userapi_2.c:31603:					      (sk)->lock.users = 0;
trickles-userapi_2.c:31605:						  (&((sk)->lock.wq)))
trickles-userapi_2.c:31606:						__wake_up ((&((sk)->lock.wq)),
trickles-userapi_2.c:31623:						      if (!--*ptr)
trickles-userapi_2.c:31626:							  ("cmpl $0, -8(%0);"
trickles-userapi_2.c:31655:				  if (!(pkt_num < pmsk->num_packets))
trickles-userapi_2.c:31658:					      "pkt_num < pmsk->num_packets"
trickles-userapi_2.c:31660:					      "trickles-userapi.c" "(%d)\n",
trickles-userapi_2.c:31663:				  setPacketUCont (&pmsk->packets[pkt_num],
trickles-userapi_2.c:31679:					  (void) (&((sk)->lock.slock));
trickles-userapi_2.c:31682:				      if ((sk)->backlog.tail != ((void *) 0))
trickles-userapi_2.c:31684:				      (sk)->lock.users = 0;
trickles-userapi_2.c:31685:				      if (waitqueue_active (&((sk)->lock.wq)))
trickles-userapi_2.c:31686:					__wake_up ((&((sk)->lock.wq)), 2 | 1,
trickles-userapi_2.c:31702:					      if (!--*ptr)
trickles-userapi_2.c:31705:						  ("cmpl $0, -8(%0);"
trickles-userapi_2.c:31735:				  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_2.c:31736:				  return tp->t.write_seq - tp->t.snd_una <
trickles-userapi_2.c:31737:				    sk->sndbuf;
trickles-userapi_2.c:31759:				  add_wait_queue (sk->sleep, &wait);
trickles-userapi_2.c:31762:				      set_bit (0, &sk->socket->flags);
trickles-userapi_2.c:31766:					  get_current ()->state = (1);
trickles-userapi_2.c:31772:				      if (sk->err || (sk->shutdown & 2))
trickles-userapi_2.c:31778:				      clear_bit (0, &sk->socket->flags);
trickles-userapi_2.c:31783:				      set_bit (2, &sk->socket->flags);
trickles-userapi_2.c:31798:					      (void) (&((sk)->lock.slock));
trickles-userapi_2.c:31801:					  if ((sk)->backlog.tail !=
trickles-userapi_2.c:31804:					  (sk)->lock.users = 0;
trickles-userapi_2.c:31806:					      (&((sk)->lock.wq)))
trickles-userapi_2.c:31807:					    __wake_up ((&((sk)->lock.wq)),
trickles-userapi_2.c:31824:						  if (!--*ptr)
trickles-userapi_2.c:31827:						      ("cmpl $0, -8(%0);"
trickles-userapi_2.c:31866:					      (void) (&((sk)->lock.slock));
trickles-userapi_2.c:31869:					  if ((sk)->lock.users != 0)
trickles-userapi_2.c:31871:					  (sk)->lock.users = 1;
trickles-userapi_2.c:31887:						  if (!--*ptr)
trickles-userapi_2.c:31890:						      ("cmpl $0, -8(%0);"
trickles-userapi_2.c:31914:					  vm_wait -= current_timeo;
trickles-userapi_2.c:31918:					      && (current_timeo -=
trickles-userapi_2.c:31926:				  get_current ()->state = 0;
trickles-userapi_2.c:31927:				  remove_wait_queue (sk->sleep, &wait);
trickles-userapi_2.c:31931:				  err = -32;
trickles-userapi_2.c:31934:				  err = -11;
trickles-userapi_2.c:31958:				  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_2.c:31959:				  iov = msg->msg_iov;
trickles-userapi_2.c:31960:				  iovlen = msg->msg_iovlen;
trickles-userapi_2.c:31980:					  (void) (&((sk)->lock.slock));
trickles-userapi_2.c:31983:				      if ((sk)->lock.users != 0)
trickles-userapi_2.c:31985:				      (sk)->lock.users = 1;
trickles-userapi_2.c:32000:					      if (!--*ptr)
trickles-userapi_2.c:32003:						  ("cmpl $0, -8(%0);"
trickles-userapi_2.c:32037:						  tp->t.write_seq += skb->len;
trickles-userapi_2.c:32039:						   &((skb)->cb[0]))->end_seq =
trickles-userapi_2.c:32040:			      tp->t.write_seq;
trickles-userapi_2.c:32041:						  __skb_queue_tail (&tp->t.
trickles-userapi_2.c:32046:						  ((sk)->tp_pinfo.af_tcp.t.
trickles-userapi_2.c:32048:						   (sk)->tp_pinfo.af_tcp.t.
trickles-userapi_2.c:32049:						   snd_una + (sk)->sndbuf))
trickles-userapi_2.c:32058:						  (tp->t.write_seq -
trickles-userapi_2.c:32059:						   tp->t.snd_una <=
trickles-userapi_2.c:32060:						   sk->sndbuf))
trickles-userapi_2.c:32064:						     "tp->t.write_seq - tp->t.snd_una <= sk->sndbuf"
trickles-userapi_2.c:32066:						     "trickles-userapi.c"
trickles-userapi_2.c:32071:								typeof (sk->
trickles-userapi_2.c:32073:									-
trickles-userapi_2.c:32074:									(tp->
trickles-userapi_2.c:32077:									 -
trickles-userapi_2.c:32078:									 tp->
trickles-userapi_2.c:32083:								 (sk->sndbuf -
trickles-userapi_2.c:32084:								  (tp->t.
trickles-userapi_2.c:32085:								   write_seq -
trickles-userapi_2.c:32086:								   tp->t.
trickles-userapi_2.c:32088:								(totalLen -
trickles-userapi_2.c:32093:								  typeof (sk->
trickles-userapi_2.c:32095:									  -
trickles-userapi_2.c:32096:									  (tp->
trickles-userapi_2.c:32099:									   -
trickles-userapi_2.c:32100:									   tp->
trickles-userapi_2.c:32104:								  (sk->
trickles-userapi_2.c:32105:								   sndbuf -
trickles-userapi_2.c:32106:								   (tp->t.
trickles-userapi_2.c:32108:								    -
trickles-userapi_2.c:32109:								    tp->t.
trickles-userapi_2.c:32133:					       &((skb)->cb[0]))->seq =
trickles-userapi_2.c:32134:			  tp->t.write_seq;
trickles-userapi_2.c:32138:						      typeof (iov[i].iov_len -
trickles-userapi_2.c:32142:						       (iov[i].iov_len -
trickles-userapi_2.c:32149:								      -
trickles-userapi_2.c:32152:							(iov[i].iov_len -
trickles-userapi_2.c:32167:					      result = -14;
trickles-userapi_2.c:32170:					  skb_spaceleft -= copyLen;
trickles-userapi_2.c:32180:					      "trickles-userapi.c" "(%d)\n",
trickles-userapi_2.c:32186:				      tp->t.write_seq += skb->len;
trickles-userapi_2.c:32188:				       &((skb)->cb[0]))->end_seq =
trickles-userapi_2.c:32189:		  tp->t.write_seq;
trickles-userapi_2.c:32190:				      __skb_queue_tail (&tp->t.requestBytes,
trickles-userapi_2.c:32194:				  if (tp->t.write_seq - tp->t.snd_una > 0)
trickles-userapi_2.c:32196:				      switch (tp->t.conversionState)
trickles-userapi_2.c:32200:					  tp->t.conversionState = (1);
trickles-userapi_2.c:32206:					  tp->t.conversionState = (1);
trickles-userapi_2.c:32235:					  (void) (&((sk)->lock.slock));
trickles-userapi_2.c:32238:				      if ((sk)->backlog.tail != ((void *) 0))
trickles-userapi_2.c:32240:				      (sk)->lock.users = 0;
trickles-userapi_2.c:32241:				      if (waitqueue_active (&((sk)->lock.wq)))
trickles-userapi_2.c:32242:					__wake_up ((&((sk)->lock.wq)), 2 | 1,
trickles-userapi_2.c:32258:					      if (!--*ptr)
trickles-userapi_2.c:32261:						  ("cmpl $0, -8(%0);"
trickles-userapi_2.c:32298:					  (void) (&((sk)->lock.slock));
trickles-userapi_2.c:32301:				      if ((sk)->backlog.tail != ((void *) 0))
trickles-userapi_2.c:32303:				      (sk)->lock.users = 0;
trickles-userapi_2.c:32304:				      if (waitqueue_active (&((sk)->lock.wq)))
trickles-userapi_2.c:32305:					__wake_up ((&((sk)->lock.wq)), 2 | 1,
trickles-userapi_2.c:32321:					      if (!--*ptr)
trickles-userapi_2.c:32324:						  ("cmpl $0, -8(%0);"
trickles-userapi_2.c:32354:				  struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:32356:				    tp->t.write_seq - tp->t.snd_una;
trickles-userapi_2.c:32362:					 (typeof (sendBufLen)) ((sysctl_trickles_mss) - (128 + 32));
trickles-userapi_2.c:32373:					tp->t.requestBytes.next;
trickles-userapi_2.c:32379:					       (void *) &tp->t.requestBytes))
trickles-userapi_2.c:32382:						      "(void*)input_skb != (void*)&tp->t.requestBytes"
trickles-userapi_2.c:32384:						      "trickles-userapi.c"
trickles-userapi_2.c:32388:					    ({ typeof (input_skb->len) Z =
trickles-userapi_2.c:32389:					     (typeof (input_skb->len))
trickles-userapi_2.c:32393:					       const typeof (input_skb->
trickles-userapi_2.c:32395:					       (input_skb->len);
trickles-userapi_2.c:32402:					    *src = input_skb->data;
trickles-userapi_2.c:32417:					  copyLen -= pieceLen;
trickles-userapi_2.c:32418:					  input_skb = input_skb->next;
trickles-userapi_2.c:32420:				      skb->csum = csum;
trickles-userapi_2.c:32433:				  add_wait_queue (sk->sleep, &wait);
trickles-userapi_2.c:32437:				      get_current ()->state = (1);
trickles-userapi_2.c:32441:				  set_bit (1, &sk->socket->flags);
trickles-userapi_2.c:32455:					  (void) (&((sk)->lock.slock));
trickles-userapi_2.c:32458:				      if ((sk)->backlog.tail != ((void *) 0))
trickles-userapi_2.c:32460:				      (sk)->lock.users = 0;
trickles-userapi_2.c:32461:				      if (waitqueue_active (&((sk)->lock.wq)))
trickles-userapi_2.c:32462:					__wake_up ((&((sk)->lock.wq)), 2 | 1,
trickles-userapi_2.c:32478:					      if (!--*ptr)
trickles-userapi_2.c:32481:						  ("cmpl $0, -8(%0);"
trickles-userapi_2.c:32501:				  if (skb_queue_empty (&sk->receive_queue))
trickles-userapi_2.c:32517:					  (void) (&((sk)->lock.slock));
trickles-userapi_2.c:32520:				      if ((sk)->lock.users != 0)
trickles-userapi_2.c:32522:				      (sk)->lock.users = 1;
trickles-userapi_2.c:32537:					      if (!--*ptr)
trickles-userapi_2.c:32540:						  ("cmpl $0, -8(%0);"
trickles-userapi_2.c:32559:				  clear_bit (1, &sk->socket->flags);
trickles-userapi_2.c:32561:				  remove_wait_queue (sk->sleep, &wait);
trickles-userapi_2.c:32564:				      get_current ()->state = (0);
trickles-userapi_2.c:32578:				  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi_2.c:32596:					  (void) (&((sk)->lock.slock));
trickles-userapi_2.c:32599:				      if ((sk)->lock.users != 0)
trickles-userapi_2.c:32601:				      (sk)->lock.users = 1;
trickles-userapi_2.c:32616:					      if (!--*ptr)
trickles-userapi_2.c:32619:						  ("cmpl $0, -8(%0);"
trickles-userapi_2.c:32638:				  if (!(tp->trickles_opt & 0x10))
trickles-userapi_2.c:32646:				      tp->trickles_opt |= 0x10;
trickles-userapi_2.c:32649:				  if (!(tp->trickles_opt & 0x40))
trickles-userapi_2.c:32666:					      (void) (&((sk)->lock.slock));
trickles-userapi_2.c:32669:					  if ((sk)->backlog.tail !=
trickles-userapi_2.c:32672:					  (sk)->lock.users = 0;
trickles-userapi_2.c:32674:					      (&((sk)->lock.wq)))
trickles-userapi_2.c:32675:					    __wake_up ((&((sk)->lock.wq)),
trickles-userapi_2.c:32692:						  if (!--*ptr)
trickles-userapi_2.c:32695:						      ("cmpl $0, -8(%0);"
trickles-userapi_2.c:32725:				  result = -107;
trickles-userapi_2.c:32729:				      result = -22;
trickles-userapi_2.c:32739:				      if (tp->rcv_nxt - tp->copied_seq >=
trickles-userapi_2.c:32745:						     (typeof (len)) (tp->
trickles-userapi_2.c:32746:								     rcv_nxt -
trickles-userapi_2.c:32747:								     tp->
trickles-userapi_2.c:32759:					  tp->copied_seq += result;
trickles-userapi_2.c:32769:						     (typeof (target)) (tp->
trickles-userapi_2.c:32771:									-
trickles-userapi_2.c:32772:									tp->
trickles-userapi_2.c:32784:					  tp->copied_seq += result;
trickles-userapi_2.c:32794:				      if (tp->rcv_nxt - tp->copied_seq == 0)
trickles-userapi_2.c:32797:					  if (sk->done)
trickles-userapi_2.c:32800:					  if (sk->err)
trickles-userapi_2.c:32806:					  if (sk->shutdown & 1)
trickles-userapi_2.c:32809:					  if (sk->state == TCP_CLOSE)
trickles-userapi_2.c:32811:					      if (!sk->done)
trickles-userapi_2.c:32816:						  result = -107;
trickles-userapi_2.c:32824:					      result = -11;
trickles-userapi_2.c:32844:					  (void) (&((sk)->lock.slock));
trickles-userapi_2.c:32847:				      if ((sk)->backlog.tail != ((void *) 0))
trickles-userapi_2.c:32849:				      (sk)->lock.users = 0;
trickles-userapi_2.c:32850:				      if (waitqueue_active (&((sk)->lock.wq)))
trickles-userapi_2.c:32851:					__wake_up ((&((sk)->lock.wq)), 2 | 1,
trickles-userapi_2.c:32867:					      if (!--*ptr)
trickles-userapi_2.c:32870:						  ("cmpl $0, -8(%0);"
trickles-userapi_2.c:32896:					  tiov->iov_base, tiov->iov_len);
trickles-userapi_2.c:32903:				  printk ("msk = %p, num =  %d\n", mskd->msk,
trickles-userapi_2.c:32904:					  mskd->tiov_num);
trickles-userapi_2.c:32905:				  dump_tiov (mskd->tiov);
trickles-userapi_2.c:32926:				      err = -22;
trickles-userapi_2.c:32934:				  sk = sock->sk;
trickles-userapi_2.c:32935:				  tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:32960:				      err = -14;
trickles-userapi_2.c:32979:					  (void) (&((sk)->lock.slock));
trickles-userapi_2.c:32982:				      if ((sk)->lock.users != 0)
trickles-userapi_2.c:32984:				      (sk)->lock.users = 1;
trickles-userapi_2.c:32999:					      if (!--*ptr)
trickles-userapi_2.c:33002:						  ("cmpl $0, -8(%0);"
trickles-userapi_2.c:33024:				      struct cminisock *msk = curr_desc->msk;
trickles-userapi_2.c:33030:					     &((sk)->tp_pinfo.af_tcp);
trickles-userapi_2.c:33031:					     (((((char *) ((msk)) -
trickles-userapi_2.c:33032:						 (char *) ((_tp)->
trickles-userapi_2.c:33034:							   cfg.ctl->
trickles-userapi_2.c:33042:					       ((void *) ((_tp)->
trickles-userapi_2.c:33044:							  cfg.ctl->
trickles-userapi_2.c:33050:					       ((_tp)->cminisock_api_config.
trickles-userapi_2.c:33051:						cfg.ctl->minisock_limit)))
trickles-userapi_2.c:33052:					     && (((msk))->ctl == ALLOC_READY
trickles-userapi_2.c:33053:						 || ((msk))->ctl ==
trickles-userapi_2.c:33058:					     !(((((char *) (msk) -
trickles-userapi_2.c:33059:						  (char *) ((tp)->
trickles-userapi_2.c:33061:							    cfg.ctl->
trickles-userapi_2.c:33069:						((void *) ((tp)->
trickles-userapi_2.c:33071:							   cfg.ctl->
trickles-userapi_2.c:33077:						((tp)->cminisock_api_config.
trickles-userapi_2.c:33078:						 cfg.ctl->minisock_limit))),
trickles-userapi_2.c:33079:					     !(((msk)->ctl == ALLOC_READY
trickles-userapi_2.c:33080:						|| (msk)->ctl ==
trickles-userapi_2.c:33082:					  err = -22;
trickles-userapi_2.c:33085:				      pmsk = msk->pmsk;
trickles-userapi_2.c:33087:				      (msk)->pmsk = ((void *) 0);
trickles-userapi_2.c:33092:				      msk->dbg_mark = curr_desc->dbg_mark;
trickles-userapi_2.c:33101:								curr_desc->
trickles-userapi_2.c:33103:								curr_desc->
trickles-userapi_2.c:33109:							   curr_desc)->
trickles-userapi_2.c:33112:							       curr_desc)->
trickles-userapi_2.c:33125:				  if (tp->trickles_opt & 0x100)
trickles-userapi_2.c:33135:					  err = -11;
trickles-userapi_2.c:33152:					  (void) (&((sk)->lock.slock));
trickles-userapi_2.c:33155:				      if ((sk)->backlog.tail != ((void *) 0))
trickles-userapi_2.c:33157:				      (sk)->lock.users = 0;
trickles-userapi_2.c:33158:				      if (waitqueue_active (&((sk)->lock.wq)))
trickles-userapi_2.c:33159:					__wake_up ((&((sk)->lock.wq)), 2 | 1,
trickles-userapi_2.c:33175:					      if (!--*ptr)
trickles-userapi_2.c:33178:						  ("cmpl $0, -8(%0);"
trickles-userapi_2.c:33227:				       (&tricklesProcLogHead)->next;
trickles-userapi_2.c:33232:				       (typeof (logEntry)) logEntry->next)
trickles-userapi_2.c:33236:					logEntry->returnedEvents == 0;
trickles-userapi_2.c:33240:					  for (i = logEntry->returnedEvents;
trickles-userapi_2.c:33241:					       i < logEntry->size; i++)
trickles-userapi_2.c:33243:					      if (logEntry->events[i].valid)
trickles-userapi_2.c:33248:						   htonl (logEntry->addr),
trickles-userapi_2.c:33249:						   htons (logEntry->port),
trickles-userapi_2.c:33250:						   logEntry->rcv_nxt,
trickles-userapi_2.c:33251:						   logEntry->t_rcv_nxt,
trickles-userapi_2.c:33255:				      for (i = logEntry->returnedEvents;
trickles-userapi_2.c:33256:					   i < logEntry->size; i++)
trickles-userapi_2.c:33259:					    &logEntry->events[i];
trickles-userapi_2.c:33263:					  if (!event->valid)
trickles-userapi_2.c:33266:					  switch (event->extra)
trickles-userapi_2.c:33286:						       event->extra);
trickles-userapi_2.c:33289:					  switch (event->state)
trickles-userapi_2.c:33309:						   (int) event->cwnd, state,
trickles-userapi_2.c:33310:						   event->time);
trickles-userapi_2.c:33316:					  temp += logEntry->sentAmount;
trickles-userapi_2.c:33325:						       (count - pos);
trickles-userapi_2.c:33341:									  ((int) strlen (temp)) Z = (typeof ((int) strlen (temp))) (count - pos);
trickles-userapi_2.c:33378:									-
trickles-userapi_2.c:33406:							     (count - pos);
trickles-userapi_2.c:33443:					     logEntry->returnedEvents++;
trickles-userapi_2.c:33444:					     logEntry->sentAmount = 0;}
trickles-userapi_2.c:33447:					     logEntry->sentAmount += copyLen;
trickles-userapi_2.c:33453:						     "trickles-userapi.c"
trickles-userapi_2.c:33458:						 && (i == logEntry->size))
trickles-userapi_2.c:33464:					     logEntry->prev;
trickles-userapi_2.c:33467:					     kfree (clean->events);
trickles-userapi_2.c:33479:				  unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__ ("": : : "memory"); if (!--*ptr) __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t": :"r" (ptr), "i" (do_softirq));}
trickles-userapi_2.c:33495:					     bb->dest = buffer;
trickles-userapi_2.c:33496:					     bb->len = len; bb->curPos = 0;}
trickles-userapi_2.c:33503:					     int prevPos = bb->curPos;
trickles-userapi_2.c:33504:					     int copyLen; bb->curPos = (
trickles-userapi_2.c:33515:									  (bb->
trickles-userapi_2.c:33546:					     copyLen = bb->curPos - prevPos;
trickles-userapi_2.c:33548:					      __constant_memcpy ((bb->dest +
trickles-userapi_2.c:33552:					      __memcpy ((bb->dest + prevPos),
trickles-userapi_2.c:33608:						  (&tricklesCwndProcLogHead)->
trickles-userapi_2.c:33615:						  logEntry->next)
trickles-userapi_2.c:33621:					     switch (logEntry->type)
trickles-userapi_2.c:33624:sprintf (tempbuf, "pkt - %d:%d = %d/%d/%d @ %d s %d us %d rtt0 %d rtt1\n", logEntry->seq, logEntry->ack_seq, logEntry->startCwnd, logEntry->effCwnd, logEntry->ssthresh, logEntry->s, logEntry->us, logEntry->rtt, logEntry->srtt); break; case CONTINUATION_RECORD:
trickles-userapi_2.c:33625:sprintf (tempbuf, "cont - %d:%d = %d/%d/%d TCPBase: %d @ %d s %d us rtt1: %d \n", logEntry->seq, logEntry->ack_seq, logEntry->startCwnd, logEntry->effCwnd, logEntry->ssthresh, logEntry->rtt, logEntry->s, logEntry->us, logEntry->srtt); break; case EVENT_RECORD:
trickles-userapi_2.c:33627:					     int eventtype = logEntry->seq;
trickles-userapi_2.c:33641:						      "%s:%d(%d-%d) = %d/%d/%d TCPBase: %d @ %d s %d us\n",
trickles-userapi_2.c:33643:						      logEntry->ack_seq,
trickles-userapi_2.c:33644:						      logEntry->addr,
trickles-userapi_2.c:33645:						      logEntry->port,
trickles-userapi_2.c:33646:						      logEntry->startCwnd,
trickles-userapi_2.c:33647:						      logEntry->effCwnd,
trickles-userapi_2.c:33648:						      logEntry->ssthresh,
trickles-userapi_2.c:33649:						      logEntry->rtt,
trickles-userapi_2.c:33650:						      logEntry->s,
trickles-userapi_2.c:33651:						      logEntry->us); break;}
trickles-userapi_2.c:33657:					     tempbuf + logEntry->sentAmount;
trickles-userapi_2.c:33661:					     logEntry->sentAmount =
trickles-userapi_2.c:33672:					      *) logEntry->prev;
trickles-userapi_2.c:33690:				    unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__ ("": : : "memory"); if (!--*ptr) __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t": :"r" (ptr), "i" (do_softirq));}
trickles-userapi_2.c:33709:					     return lbb->start + lbb->limit;}
trickles-userapi_2.c:33716:					     return lbb->curr - lbb->start;}
trickles-userapi_2.c:33723:					     return lbb->curr;}
trickles-userapi_2.c:33731:					     return lbb->curr + len -
trickles-userapi_2.c:33732:					     lbb->start <= lbb->limit;}
trickles-userapi_2.c:33740:					     rval = lbb->curr;
trickles-userapi_2.c:33745:					     lbb->curr += len; return rval;}
trickles-userapi_2.c:33828:					      (hmacEnd -
trickles-userapi_2.c:33833:					       (hmacEnd -
trickles-userapi_2.c:33835:					      __generic_copy_to_user_nocheck ((user_addr + hmacStart), (kernel_addr + hmacStart), (hmacEnd - hmacStart))); hmac_update (hmac_ctx, (char *) kernel_addr + hmacStart, hmacEnd - hmacStart); int zero = 0; if (!(patch.width <= sizeof (zero)))
trickles-userapi_2.c:33840:						     "trickles-userapi.c"
trickles-userapi_2.c:33885:						     "trickles-userapi.c"
trickles-userapi_2.c:33895:						     "trickles-userapi.c"
trickles-userapi_2.c:33913:						     "trickles-userapi.c"
trickles-userapi_2.c:33916:					      (len -
trickles-userapi_2.c:33921:					       (len -
trickles-userapi_2.c:33923:					      __generic_copy_to_user_nocheck ((user_addr + lastOffset), (kernel_addr + lastOffset), (len - lastOffset))); if ((in == out))
trickles-userapi_2.c:33928:							  len -
trickles-userapi_2.c:33971:					      (hmacEnd -
trickles-userapi_2.c:33976:					       (hmacEnd -
trickles-userapi_2.c:33978:					      __generic_copy_to_user_nocheck ((user_addr + hmacStart), (kernel_addr + hmacStart), (hmacEnd - hmacStart))); hmac_update (hmac_ctx, (char *) kernel_addr + hmacStart, hmacEnd - hmacStart); int zero = 0; if (!(patch.width <= sizeof (zero)))
trickles-userapi_2.c:33983:						     "trickles-userapi.c"
trickles-userapi_2.c:34028:						     "trickles-userapi.c"
trickles-userapi_2.c:34038:						     "trickles-userapi.c"
trickles-userapi_2.c:34056:						     "trickles-userapi.c"
trickles-userapi_2.c:34059:					      (len -
trickles-userapi_2.c:34064:					       (len -
trickles-userapi_2.c:34066:					      __generic_copy_to_user_nocheck ((user_addr + lastOffset), (kernel_addr + lastOffset), (len - lastOffset))); if ((out == out))
trickles-userapi_2.c:34071:							  len -
trickles-userapi_2.c:34095:					     patch->offset =
trickles-userapi_2.c:34101:						 0)->ucontData) -
trickles-userapi_2.c:34103:					     patch->width =
trickles-userapi_2.c:34106:						0)->ucontData));}
trickles-userapi_2.c:34118:					     ctx->numDeferrals = 0;
trickles-userapi_2.c:34119:					     ctx->next = ((void *) 0);}
trickles-userapi_2.c:34125:					     if (ctx->next != ((void *)0))
trickles-userapi_2.c:34127:					     DeferralContext_free (ctx->next);}
trickles-userapi_2.c:34133:					     while (ctx->next != ((void *)0))
trickles-userapi_2.c:34135:					     if (!(ctx->numDeferrals == (16)))
trickles-userapi_2.c:34138:						     "ctx->numDeferrals == MAX_NUM_DEFERRALS_PER_CONTEXT"
trickles-userapi_2.c:34140:						     "trickles-userapi.c"
trickles-userapi_2.c:34142:					     ctx = ctx->next;}
trickles-userapi_2.c:34143:					     if (ctx->numDeferrals == (16))
trickles-userapi_2.c:34145:					     ctx->next =
trickles-userapi_2.c:34151:					     if (ctx->next == ((void *) 0))
trickles-userapi_2.c:34155:					     return -1;}
trickles-userapi_2.c:34156:					     ctx = ctx->next;}
trickles-userapi_2.c:34157:					     ctx->data[ctx->numDeferrals++] =
trickles-userapi_2.c:34239:					     int desc_len = -1;
trickles-userapi_2.c:34245:					     desc_len += msk->ucont_len;;
trickles-userapi_2.c:34246:					     desc_len += msk->input_len;;
trickles-userapi_2.c:34248:					     msk->num_packets *
trickles-userapi_2.c:34251:					     for (i = 0; i < msk->num_packets;
trickles-userapi_2.c:34255:					     msk->packets[i].ucontLen;;}
trickles-userapi_2.c:34270:					     err = (-1); goto convert_error;}
trickles-userapi_2.c:34282:__asm__ __volatile__ ("1:	mov" "b" " %" "b" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "iq" (((__typeof__ (*(len))) (desc_len))), "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__pu_err)); break; case 2:
trickles-userapi_2.c:34283:__asm__ __volatile__ ("1:	mov" "w" " %" "w" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(len))) (desc_len))), "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__pu_err)); break; case 4:
trickles-userapi_2.c:34284:__asm__ __volatile__ ("1:	mov" "l" " %" "" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(len))) (desc_len))), "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__pu_err)); break; case 8:
trickles-userapi_2.c:34285:__asm__ __volatile__ ("1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous": "=r" (__pu_err): "A" (((__typeof__ (*(len))) (desc_len))), "r" (((len))), "i" (-14), "0" (__pu_err)); break; default:
trickles-userapi_2.c:34304:__asm__ __volatile__ ("1:	mov" "b" " %2,%" "b" "1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor" "b" " %" "b" "1,%" "b" "1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__gu_err), "=q" (__gu_val): "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__gu_err)); break; case 2:
trickles-userapi_2.c:34305:__asm__ __volatile__ ("1:	mov" "w" " %2,%" "w" "1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor" "w" " %" "w" "1,%" "w" "1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__gu_err), "=r" (__gu_val): "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__gu_err)); break; case 4:
trickles-userapi_2.c:34306:__asm__ __volatile__ ("1:	mov" "l" " %2,%" "" "1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor" "l" " %" "" "1,%" "" "1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__gu_err), "=r" (__gu_val): "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__gu_err)); break; default:
trickles-userapi_2.c:34319:									    offset: (((char *)&((struct cminisock *)0)->sk) - (char *)((void *)0)), width:(sizeof
trickles-userapi_2.c:34320:					      (((struct cminisock *) 0)->
trickles-userapi_2.c:34323:									    offset: (((char *)&((struct cminisock *)0)->ucont_data) - (char *)((void *)0)), width:(sizeof
trickles-userapi_2.c:34324:					      (((struct cminisock *) 0)->
trickles-userapi_2.c:34327:									    offset: (((char *)&((struct cminisock *)0)->input) - (char *)((void *)0)), width:(sizeof
trickles-userapi_2.c:34328:					      (((struct cminisock *) 0)->
trickles-userapi_2.c:34331:									  offset: (((char *)&((struct cminisock *)0)->packets) - (char *)((void *)0)), width:(sizeof
trickles-userapi_2.c:34332:					      (((struct cminisock *) 0)->
trickles-userapi_2.c:34343:										       ((msk->ucont_len) == 0)
trickles-userapi_2.c:34351:										       (msk->
trickles-userapi_2.c:34357:										       "msk->ucont_data";
trickles-userapi_2.c:34370:										       ("result overflow - %s\n",
trickles-userapi_2.c:34374:										       (-1);
trickles-userapi_2.c:34387:											msk->
trickles-userapi_2.c:34401:										       (-1);
trickles-userapi_2.c:34404:										       msk->
trickles-userapi_2.c:34411:											(msk->
trickles-userapi_2.c:34424:																		 ((sizeof (*(&((struct cminisock *) _tempdest)->ucont_data))))
trickles-userapi_2.c:34427:__asm__ __volatile__ ("1:	mov" "b" " %" "b" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "iq" (((__typeof__ (*(&((struct cminisock *)_tempdest)->ucont_data))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock *) _tempdest)->ucont_data))))), "i" (-14), "0" (__pu_err)); break; case 2:
trickles-userapi_2.c:34428:__asm__ __volatile__ ("1:	mov" "w" " %" "w" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(&((struct cminisock *) _tempdest)->ucont_data))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock *) _tempdest)->ucont_data))))), "i" (-14), "0" (__pu_err)); break; case 4:
trickles-userapi_2.c:34429:__asm__ __volatile__ ("1:	mov" "l" " %" "" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(&((struct cminisock *) _tempdest)->ucont_data))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock *) _tempdest)->ucont_data))))), "i" (-14), "0" (__pu_err)); break; case 8:
trickles-userapi_2.c:34430:__asm__ __volatile__ ("1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous": "=r" (__pu_err): "A" (((__typeof__ (*(&((struct cminisock *) _tempdest)->ucont_data))) ((char *) _tempdest - currStart))), "r" (((&((struct cminisock *) _tempdest)->ucont_data))), "i" (-14), "0" (__pu_err)); break; default:
trickles-userapi_2.c:34440:						   if ((msk->input_len) == 0)
trickles-userapi_2.c:34446:						   (msk->input_len);
trickles-userapi_2.c:34448:						   "user_" "msk->input";
trickles-userapi_2.c:34455:						   ("result overflow - %s\n",
trickles-userapi_2.c:34456:						    _dest_name); err = (-1);
trickles-userapi_2.c:34463:								     msk->
trickles-userapi_2.c:34472:						   err = (-1);
trickles-userapi_2.c:34474:						   msk->input = alloc_ptr;}
trickles-userapi_2.c:34477:						    (msk->input), _len,
trickles-userapi_2.c:34490:									   ((sizeof (*(&((struct cminisock *) _tempdest)->input))))
trickles-userapi_2.c:34493:__asm__ __volatile__ ("1:	mov" "b" " %" "b" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "iq" (((__typeof__ (*(&((struct cminisock *)_tempdest)->input))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock *) _tempdest)->input))))), "i" (-14), "0" (__pu_err)); break; case 2:
trickles-userapi_2.c:34494:__asm__ __volatile__ ("1:	mov" "w" " %" "w" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(&((struct cminisock *) _tempdest)->input))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock *) _tempdest)->input))))), "i" (-14), "0" (__pu_err)); break; case 4:
trickles-userapi_2.c:34495:__asm__ __volatile__ ("1:	mov" "l" " %" "" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(&((struct cminisock *) _tempdest)->input))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock *) _tempdest)->input))))), "i" (-14), "0" (__pu_err)); break; case 8:
trickles-userapi_2.c:34496:__asm__ __volatile__ ("1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous": "=r" (__pu_err): "A" (((__typeof__ (*(&((struct cminisock *) _tempdest)->input))) ((char *) _tempdest - currStart))), "r" (((&((struct cminisock *) _tempdest)->input))), "i" (-14), "0" (__pu_err)); break; default:
trickles-userapi_2.c:34506:					     msk->num_packets *
trickles-userapi_2.c:34517:						   "user_" "msk->packets";
trickles-userapi_2.c:34524:						   ("result overflow - %s\n",
trickles-userapi_2.c:34525:						    _dest_name); err = (-1);
trickles-userapi_2.c:34540:						   err = (-1);
trickles-userapi_2.c:34542:						   msk->packets = alloc_ptr;}
trickles-userapi_2.c:34545:						    (msk->packets), _len,
trickles-userapi_2.c:34548:						    msk->num_packets);
trickles-userapi_2.c:34559:									    ((sizeof (*(&((struct cminisock *) _tempdest)->packets))))
trickles-userapi_2.c:34562:__asm__ __volatile__ ("1:	mov" "b" " %" "b" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "iq" (((__typeof__ (*(&((struct cminisock *)_tempdest)->packets))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock *) _tempdest)->packets))))), "i" (-14), "0" (__pu_err)); break; case 2:
trickles-userapi_2.c:34563:__asm__ __volatile__ ("1:	mov" "w" " %" "w" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(&((struct cminisock *) _tempdest)->packets))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock *) _tempdest)->packets))))), "i" (-14), "0" (__pu_err)); break; case 4:
trickles-userapi_2.c:34564:__asm__ __volatile__ ("1:	mov" "l" " %" "" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(&((struct cminisock *) _tempdest)->packets))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock *) _tempdest)->packets))))), "i" (-14), "0" (__pu_err)); break; case 8:
trickles-userapi_2.c:34565:__asm__ __volatile__ ("1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous": "=r" (__pu_err): "A" (((__typeof__ (*(&((struct cminisock *) _tempdest)->packets))) ((char *) _tempdest - currStart))), "r" (((&((struct cminisock *) _tempdest)->packets))), "i" (-14), "0" (__pu_err)); break; default:
trickles-userapi_2.c:34574:						      i < msk->num_packets;
trickles-userapi_2.c:34579:					       if ((msk->packets[i].
trickles-userapi_2.c:34586:					       (msk->packets[i].ucontLen);
trickles-userapi_2.c:34589:					       "msk->packets[i].ucontData";
trickles-userapi_2.c:34595:					       ("result overflow - %s\n",
trickles-userapi_2.c:34596:						_dest_name); err = (-1);
trickles-userapi_2.c:34603:								 msk->
trickles-userapi_2.c:34611:					       err = (-1);
trickles-userapi_2.c:34613:					       msk->packets[i].ucontData =
trickles-userapi_2.c:34617:						(msk->packets[i].ucontData),
trickles-userapi_2.c:34629:								       ((sizeof (*(&((struct cminisock_packet *) _tempdest)->ucontData))))
trickles-userapi_2.c:34632:__asm__ __volatile__ ("1:	mov" "b" " %" "b" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "iq" (((__typeof__ (*(&((struct cminisock_packet *)_tempdest)->ucontData))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock_packet *) _tempdest)->ucontData))))), "i" (-14), "0" (__pu_err)); break; case 2:
trickles-userapi_2.c:34633:__asm__ __volatile__ ("1:	mov" "w" " %" "w" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(&((struct cminisock_packet *) _tempdest)->ucontData))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock_packet *) _tempdest)->ucontData))))), "i" (-14), "0" (__pu_err)); break; case 4:
trickles-userapi_2.c:34634:__asm__ __volatile__ ("1:	mov" "l" " %" "" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(&((struct cminisock_packet *) _tempdest)->ucontData))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock_packet *) _tempdest)->ucontData))))), "i" (-14), "0" (__pu_err)); break; case 8:
trickles-userapi_2.c:34635:__asm__ __volatile__ ("1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous": "=r" (__pu_err): "A" (((__typeof__ (*(&((struct cminisock_packet *) _tempdest)->ucontData))) ((char *) _tempdest - currStart))), "r" (((&((struct cminisock_packet *) _tempdest)->ucontData))), "i" (-14), "0" (__pu_err)); break; default:
trickles-userapi_2.c:34647:					     lbb_get_offset (lbb) - startLen;
trickles-userapi_2.c:34655:						     "trickles-userapi.c"
trickles-userapi_2.c:34668:__asm__ __volatile__ ("1:	mov" "b" " %" "b" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "iq" (((__typeof__ (*(len))) (check_len))), "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__pu_err)); break; case 2:
trickles-userapi_2.c:34669:__asm__ __volatile__ ("1:	mov" "w" " %" "w" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(len))) (check_len))), "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__pu_err)); break; case 4:
trickles-userapi_2.c:34670:__asm__ __volatile__ ("1:	mov" "l" " %" "" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(len))) (check_len))), "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__pu_err)); break; case 8:
trickles-userapi_2.c:34671:__asm__ __volatile__ ("1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous": "=r" (__pu_err): "A" (((__typeof__ (*(len))) (check_len))), "r" (((len))), "i" (-14), "0" (__pu_err)); break; default:
trickles-userapi_2.c:34680:					     lbb_get_offset (lbb) - startLen;
trickles-userapi_2.c:34691:__asm__ __volatile__ ("1:	mov" "b" " %2,%" "b" "1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor" "b" " %" "b" "1,%" "b" "1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__gu_err), "=q" (__gu_val): "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__gu_err)); break; case 2:
trickles-userapi_2.c:34692:__asm__ __volatile__ ("1:	mov" "w" " %2,%" "w" "1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor" "w" " %" "w" "1,%" "w" "1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__gu_err), "=r" (__gu_val): "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__gu_err)); break; case 4:
trickles-userapi_2.c:34693:__asm__ __volatile__ ("1:	mov" "l" " %2,%" "" "1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor" "l" " %" "" "1,%" "" "1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__gu_err), "=r" (__gu_val): "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__gu_err)); break; default:
trickles-userapi_2.c:34710:						     "trickles-userapi.c"
trickles-userapi_2.c:34719:						     "trickles-userapi.c"
trickles-userapi_2.c:34729:					     (deferral_ctx.next); return -22;}
trickles-userapi_2.c:34754:					     int desc_len = -1;
trickles-userapi_2.c:34760:					     desc_len += msk->ucont_len;;
trickles-userapi_2.c:34761:					     desc_len += msk->input_len;;
trickles-userapi_2.c:34763:					     msk->num_packets *
trickles-userapi_2.c:34766:					     for (i = 0; i < msk->num_packets;
trickles-userapi_2.c:34770:					     msk->packets[i].ucontLen;;}
trickles-userapi_2.c:34785:					     err = (-1); goto convert_error;}
trickles-userapi_2.c:34797:__asm__ __volatile__ ("1:	mov" "b" " %" "b" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "iq" (((__typeof__ (*(len))) (desc_len))), "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__pu_err)); break; case 2:
trickles-userapi_2.c:34798:__asm__ __volatile__ ("1:	mov" "w" " %" "w" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(len))) (desc_len))), "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__pu_err)); break; case 4:
trickles-userapi_2.c:34799:__asm__ __volatile__ ("1:	mov" "l" " %" "" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(len))) (desc_len))), "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__pu_err)); break; case 8:
trickles-userapi_2.c:34800:__asm__ __volatile__ ("1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous": "=r" (__pu_err): "A" (((__typeof__ (*(len))) (desc_len))), "r" (((len))), "i" (-14), "0" (__pu_err)); break; default:
trickles-userapi_2.c:34819:__asm__ __volatile__ ("1:	mov" "b" " %2,%" "b" "1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor" "b" " %" "b" "1,%" "b" "1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__gu_err), "=q" (__gu_val): "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__gu_err)); break; case 2:
trickles-userapi_2.c:34820:__asm__ __volatile__ ("1:	mov" "w" " %2,%" "w" "1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor" "w" " %" "w" "1,%" "w" "1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__gu_err), "=r" (__gu_val): "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__gu_err)); break; case 4:
trickles-userapi_2.c:34821:__asm__ __volatile__ ("1:	mov" "l" " %2,%" "" "1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor" "l" " %" "" "1,%" "" "1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__gu_err), "=r" (__gu_val): "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__gu_err)); break; default:
trickles-userapi_2.c:34834:															offset: (((char *)&((struct cminisock *)0)->sk) - (char *)((void *)0)), width:(sizeof
trickles-userapi_2.c:34835:					      (((struct cminisock *) 0)->
trickles-userapi_2.c:34838:															offset: (((char *)&((struct cminisock *)0)->ucont_data) - (char *)((void *)0)), width:(sizeof
trickles-userapi_2.c:34839:					      (((struct cminisock *) 0)->
trickles-userapi_2.c:34842:															offset: (((char *)&((struct cminisock *)0)->input) - (char *)((void *)0)), width:(sizeof
trickles-userapi_2.c:34843:					      (((struct cminisock *) 0)->
trickles-userapi_2.c:34846:														      offset: (((char *)&((struct cminisock *)0)->packets) - (char *)((void *)0)), width:(sizeof
trickles-userapi_2.c:34847:					      (((struct cminisock *) 0)->
trickles-userapi_2.c:34858:										       ((msk->ucont_len) == 0)
trickles-userapi_2.c:34866:										       (msk->
trickles-userapi_2.c:34872:										       "msk->ucont_data";
trickles-userapi_2.c:34885:										       ("result overflow - %s\n",
trickles-userapi_2.c:34889:										       (-1);
trickles-userapi_2.c:34902:											msk->
trickles-userapi_2.c:34916:										       (-1);
trickles-userapi_2.c:34919:										       msk->
trickles-userapi_2.c:34926:											(msk->
trickles-userapi_2.c:34939:																		  ((sizeof (*(&((struct cminisock *) _tempdest)->ucont_data))))
trickles-userapi_2.c:34942:__asm__ __volatile__ ("1:	mov" "b" " %" "b" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "iq" (((__typeof__ (*(&((struct cminisock *)_tempdest)->ucont_data))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock *) _tempdest)->ucont_data))))), "i" (-14), "0" (__pu_err)); break; case 2:
trickles-userapi_2.c:34943:__asm__ __volatile__ ("1:	mov" "w" " %" "w" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(&((struct cminisock *) _tempdest)->ucont_data))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock *) _tempdest)->ucont_data))))), "i" (-14), "0" (__pu_err)); break; case 4:
trickles-userapi_2.c:34944:__asm__ __volatile__ ("1:	mov" "l" " %" "" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(&((struct cminisock *) _tempdest)->ucont_data))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock *) _tempdest)->ucont_data))))), "i" (-14), "0" (__pu_err)); break; case 8:
trickles-userapi_2.c:34945:__asm__ __volatile__ ("1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous": "=r" (__pu_err): "A" (((__typeof__ (*(&((struct cminisock *) _tempdest)->ucont_data))) ((char *) _tempdest - currStart))), "r" (((&((struct cminisock *) _tempdest)->ucont_data))), "i" (-14), "0" (__pu_err)); break; default:
trickles-userapi_2.c:34955:						   if ((msk->input_len) == 0)
trickles-userapi_2.c:34961:						   (msk->input_len);
trickles-userapi_2.c:34963:						   "user_" "msk->input";
trickles-userapi_2.c:34970:						   ("result overflow - %s\n",
trickles-userapi_2.c:34971:						    _dest_name); err = (-1);
trickles-userapi_2.c:34978:								      msk->
trickles-userapi_2.c:34987:						   err = (-1);
trickles-userapi_2.c:34989:						   msk->input = alloc_ptr;}
trickles-userapi_2.c:34992:						    (msk->input), _len,
trickles-userapi_2.c:35005:									    ((sizeof (*(&((struct cminisock *) _tempdest)->input))))
trickles-userapi_2.c:35008:__asm__ __volatile__ ("1:	mov" "b" " %" "b" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "iq" (((__typeof__ (*(&((struct cminisock *)_tempdest)->input))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock *) _tempdest)->input))))), "i" (-14), "0" (__pu_err)); break; case 2:
trickles-userapi_2.c:35009:__asm__ __volatile__ ("1:	mov" "w" " %" "w" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(&((struct cminisock *) _tempdest)->input))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock *) _tempdest)->input))))), "i" (-14), "0" (__pu_err)); break; case 4:
trickles-userapi_2.c:35010:__asm__ __volatile__ ("1:	mov" "l" " %" "" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(&((struct cminisock *) _tempdest)->input))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock *) _tempdest)->input))))), "i" (-14), "0" (__pu_err)); break; case 8:
trickles-userapi_2.c:35011:__asm__ __volatile__ ("1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous": "=r" (__pu_err): "A" (((__typeof__ (*(&((struct cminisock *) _tempdest)->input))) ((char *) _tempdest - currStart))), "r" (((&((struct cminisock *) _tempdest)->input))), "i" (-14), "0" (__pu_err)); break; default:
trickles-userapi_2.c:35021:					     msk->num_packets *
trickles-userapi_2.c:35032:						   "user_" "msk->packets";
trickles-userapi_2.c:35039:						   ("result overflow - %s\n",
trickles-userapi_2.c:35040:						    _dest_name); err = (-1);
trickles-userapi_2.c:35055:						   err = (-1);
trickles-userapi_2.c:35057:						   msk->packets = alloc_ptr;}
trickles-userapi_2.c:35060:						    (msk->packets), _len,
trickles-userapi_2.c:35063:						    msk->num_packets);
trickles-userapi_2.c:35074:									     ((sizeof (*(&((struct cminisock *) _tempdest)->packets))))
trickles-userapi_2.c:35077:__asm__ __volatile__ ("1:	mov" "b" " %" "b" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "iq" (((__typeof__ (*(&((struct cminisock *)_tempdest)->packets))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock *) _tempdest)->packets))))), "i" (-14), "0" (__pu_err)); break; case 2:
trickles-userapi_2.c:35078:__asm__ __volatile__ ("1:	mov" "w" " %" "w" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(&((struct cminisock *) _tempdest)->packets))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock *) _tempdest)->packets))))), "i" (-14), "0" (__pu_err)); break; case 4:
trickles-userapi_2.c:35079:__asm__ __volatile__ ("1:	mov" "l" " %" "" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(&((struct cminisock *) _tempdest)->packets))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock *) _tempdest)->packets))))), "i" (-14), "0" (__pu_err)); break; case 8:
trickles-userapi_2.c:35080:__asm__ __volatile__ ("1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous": "=r" (__pu_err): "A" (((__typeof__ (*(&((struct cminisock *) _tempdest)->packets))) ((char *) _tempdest - currStart))), "r" (((&((struct cminisock *) _tempdest)->packets))), "i" (-14), "0" (__pu_err)); break; default:
trickles-userapi_2.c:35089:						      i < msk->num_packets;
trickles-userapi_2.c:35094:					       if ((msk->packets[i].
trickles-userapi_2.c:35101:					       (msk->packets[i].ucontLen);
trickles-userapi_2.c:35104:					       "msk->packets[i].ucontData";
trickles-userapi_2.c:35110:					       ("result overflow - %s\n",
trickles-userapi_2.c:35111:						_dest_name); err = (-1);
trickles-userapi_2.c:35118:								  msk->
trickles-userapi_2.c:35126:					       err = (-1);
trickles-userapi_2.c:35128:					       msk->packets[i].ucontData =
trickles-userapi_2.c:35132:						(msk->packets[i].ucontData),
trickles-userapi_2.c:35144:									((sizeof (*(&((struct cminisock_packet *) _tempdest)->ucontData))))
trickles-userapi_2.c:35147:__asm__ __volatile__ ("1:	mov" "b" " %" "b" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "iq" (((__typeof__ (*(&((struct cminisock_packet *)_tempdest)->ucontData))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock_packet *) _tempdest)->ucontData))))), "i" (-14), "0" (__pu_err)); break; case 2:
trickles-userapi_2.c:35148:__asm__ __volatile__ ("1:	mov" "w" " %" "w" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(&((struct cminisock_packet *) _tempdest)->ucontData))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock_packet *) _tempdest)->ucontData))))), "i" (-14), "0" (__pu_err)); break; case 4:
trickles-userapi_2.c:35149:__asm__ __volatile__ ("1:	mov" "l" " %" "" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(&((struct cminisock_packet *) _tempdest)->ucontData))) ((char *) _tempdest - currStart))), "m" ((*(struct __large_struct *) (((&((struct cminisock_packet *) _tempdest)->ucontData))))), "i" (-14), "0" (__pu_err)); break; case 8:
trickles-userapi_2.c:35150:__asm__ __volatile__ ("1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous": "=r" (__pu_err): "A" (((__typeof__ (*(&((struct cminisock_packet *) _tempdest)->ucontData))) ((char *) _tempdest - currStart))), "r" (((&((struct cminisock_packet *) _tempdest)->ucontData))), "i" (-14), "0" (__pu_err)); break; default:
trickles-userapi_2.c:35162:					     lbb_get_offset (lbb) - startLen;
trickles-userapi_2.c:35170:						     "trickles-userapi.c"
trickles-userapi_2.c:35183:__asm__ __volatile__ ("1:	mov" "b" " %" "b" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "iq" (((__typeof__ (*(len))) (check_len))), "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__pu_err)); break; case 2:
trickles-userapi_2.c:35184:__asm__ __volatile__ ("1:	mov" "w" " %" "w" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(len))) (check_len))), "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__pu_err)); break; case 4:
trickles-userapi_2.c:35185:__asm__ __volatile__ ("1:	mov" "l" " %" "" "1,%2\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__pu_err): "ir" (((__typeof__ (*(len))) (check_len))), "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__pu_err)); break; case 8:
trickles-userapi_2.c:35186:__asm__ __volatile__ ("1:	movl %%eax,0(%2)\n" "2:	movl %%edx,4(%2)\n" "3:\n" ".section .fixup,\"ax\"\n" "4:	movl %3,%0\n" "	jmp 3b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,4b\n" "	.long 2b,4b\n" ".previous": "=r" (__pu_err): "A" (((__typeof__ (*(len))) (check_len))), "r" (((len))), "i" (-14), "0" (__pu_err)); break; default:
trickles-userapi_2.c:35195:					     lbb_get_offset (lbb) - startLen;
trickles-userapi_2.c:35206:__asm__ __volatile__ ("1:	mov" "b" " %2,%" "b" "1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor" "b" " %" "b" "1,%" "b" "1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__gu_err), "=q" (__gu_val): "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__gu_err)); break; case 2:
trickles-userapi_2.c:35207:__asm__ __volatile__ ("1:	mov" "w" " %2,%" "w" "1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor" "w" " %" "w" "1,%" "w" "1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__gu_err), "=r" (__gu_val): "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__gu_err)); break; case 4:
trickles-userapi_2.c:35208:__asm__ __volatile__ ("1:	mov" "l" " %2,%" "" "1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor" "l" " %" "" "1,%" "" "1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__gu_err), "=r" (__gu_val): "m" ((*(struct __large_struct *) (((len))))), "i" (-14), "0" (__gu_err)); break; default:
trickles-userapi_2.c:35225:						     "trickles-userapi.c"
trickles-userapi_2.c:35234:						     "trickles-userapi.c"
trickles-userapi_2.c:35244:					     (deferral_ctx.next); return -22;}
trickles-userapi_2.c:35275:					     msk->ctl = ALLOC_READY;
trickles-userapi_2.c:35312:					     err = -22; goto out;}
trickles-userapi_2.c:35316:					     goto out; sk = sock->sk;
trickles-userapi_2.c:35325:					     (void) (&((sk)->lock.slock));}
trickles-userapi_2.c:35327:					     if ((sk)->lock.users !=
trickles-userapi_2.c:35329:					     (sk)->lock.users = 1;
trickles-userapi_2.c:35338:																					  unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__ ("": : : "memory"); if (!--*ptr) __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t": :"r" (ptr), "i" (do_softirq));}
trickles-userapi_2.c:35343:						 (((sk)->tp_pinfo.af_tcp.
trickles-userapi_2.c:35345:						  && ((sk)->state ==
trickles-userapi_2.c:35349:					     err = -22; goto out_put;}
trickles-userapi_2.c:35351:					     tp = &(sk->tp_pinfo.af_tcp);;
trickles-userapi_2.c:35353:					     tp->cminisock_api_config.
trickles-userapi_2.c:35356:																					unsigned long flag, sum; asm ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag), "=r" (sum):"1" (descbuf), "g" ((int) (descbuf_len)), "g" (get_current ()->addr_limit.seg)); flag;}) == 0))
trickles-userapi_2.c:35360:					     err = -14; goto out_put;}
trickles-userapi_2.c:35367:									      ()->
trickles-userapi_2.c:35374:					     err = -14; goto out_put;}
trickles-userapi_2.c:35389:					     *tp->t.hmacCTX;
trickles-userapi_2.c:35393:						    - (char *) descbuf <
trickles-userapi_2.c:35414:									    &((sk)->tp_pinfo.af_tcp); (((((char *) ((msk)) - (char *) ((_tp)->cminisock_api_config.cfg.ctl->minisock_base)) % sizeof (struct cminisock)) == 0) && (((void *) ((struct cminisock *) ((msk)))) >= ((void *) ((_tp)->cminisock_api_config.cfg.ctl->minisock_base)) && ((void *) ((struct cminisock *) ((msk)) + 1)) <= ((_tp)->cminisock_api_config.cfg.ctl->minisock_limit))) && (((msk))->ctl == ALLOC_READY || ((msk))->ctl == ALLOC_HALFFREE);}))
trickles-userapi_2.c:35418:					      (((((char *) ((msk)) -
trickles-userapi_2.c:35419:						  (char *) ((tp)->
trickles-userapi_2.c:35421:							    cfg.ctl->
trickles-userapi_2.c:35429:						((void *) ((tp)->
trickles-userapi_2.c:35431:							   cfg.ctl->
trickles-userapi_2.c:35437:						((tp)->cminisock_api_config.
trickles-userapi_2.c:35438:						 cfg.ctl->minisock_limit))),
trickles-userapi_2.c:35439:					      (((((char *) ((msk)) -
trickles-userapi_2.c:35440:						  (char *) ((tp)->
trickles-userapi_2.c:35442:							    cfg.ctl->
trickles-userapi_2.c:35450:						((void *) ((tp)->
trickles-userapi_2.c:35452:							   cfg.ctl->
trickles-userapi_2.c:35458:						((tp)->cminisock_api_config.
trickles-userapi_2.c:35459:						 cfg.ctl->minisock_limit)))
trickles-userapi_2.c:35460:					      && (((msk))->ctl == ALLOC_READY
trickles-userapi_2.c:35461:						  || ((msk))->ctl ==
trickles-userapi_2.c:35462:						  ALLOC_HALFFREE)); err = -22;
trickles-userapi_2.c:35464:					     if (msk->ctl != ALLOC_READY)
trickles-userapi_2.c:35468:					     err = -22; goto out_put;}
trickles-userapi_2.c:35481:					     if (err == (-1))
trickles-userapi_2.c:35486:					     if (!(err == (-2)))
trickles-userapi_2.c:35491:						     "trickles-userapi.c"
trickles-userapi_2.c:35493:					     if (err == (-2))
trickles-userapi_2.c:35502:					     msk->ctl = ALLOC_HALFFREE;}
trickles-userapi_2.c:35505:					     if (msk->ctl != ALLOC_HALFFREE)
trickles-userapi_2.c:35508:					     ("Dealloc called on an msk that is not half-freed\n");
trickles-userapi_2.c:35509:					     err = -22; goto out_put;}
trickles-userapi_2.c:35520:					      ((outputCollection->hmac),
trickles-userapi_2.c:35523:					      __generic_copy_to_user_nocheck ((outputCollection->hmac), (hmac), (16))); outputCollection->len = *destLen = lbb.curr - lbb.start;; printk ("Starting instant self-test\n"); int test_numIn; struct alloc_head_list new_msk_list; init_head (&new_msk_list); lbb.limit = lbb_get_offset (&lbb); lbb.curr = lbb.start; if (!(lbb_get_offset (&lbb) == 0))
trickles-userapi_2.c:35528:						     "trickles-userapi.c"
trickles-userapi_2.c:35551:					     *tp->t.hmacCTX;
trickles-userapi_2.c:35556:					     lbb_get_end (&lbb) -
trickles-userapi_2.c:35634:						     "trickles-userapi.c"
trickles-userapi_2.c:35649:					     (void) (&((sk)->lock.slock));}
trickles-userapi_2.c:35651:					     if ((sk)->backlog.tail !=
trickles-userapi_2.c:35654:					     (sk)->lock.users = 0;
trickles-userapi_2.c:35656:						 (&((sk)->lock.wq)))
trickles-userapi_2.c:35657:					     __wake_up ((&((sk)->lock.wq)),
trickles-userapi_2.c:35667:																							unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__ ("": : : "memory"); if (!--*ptr) __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t": :"r" (ptr), "i" (do_softirq));}
trickles-userapi_2.c:35676:					      tp->cminisock_api_config.
trickles-userapi_2.c:35704:					     int err = -1;
trickles-userapi_2.c:35710:					     err = -22; goto out;}
trickles-userapi_2.c:35715:					     err = -22; goto out;}
trickles-userapi_2.c:35717:					     sk = sock->sk;
trickles-userapi_2.c:35726:					     (void) (&((sk)->lock.slock));}
trickles-userapi_2.c:35728:					     if ((sk)->lock.users !=
trickles-userapi_2.c:35730:					     (sk)->lock.users = 1;
trickles-userapi_2.c:35739:																								      unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__ ("": : : "memory"); if (!--*ptr) __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t": :"r" (ptr), "i" (do_softirq));}
trickles-userapi_2.c:35744:						 (((sk)->tp_pinfo.af_tcp.
trickles-userapi_2.c:35746:						  && ((sk)->state ==
trickles-userapi_2.c:35750:					     err = -22; goto out_put;}
trickles-userapi_2.c:35752:					     tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:35754:					     tp->cminisock_api_config.
trickles-userapi_2.c:35757:																								    unsigned long flag, sum; asm ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag), "=r" (sum):"1" (descbuf), "g" ((int) (descbuf_len)), "g" (get_current ()->addr_limit.seg)); flag;}) == 0))
trickles-userapi_2.c:35761:					     err = -14; goto out_put;}
trickles-userapi_2.c:35775:					     descbuf_len - (inputPosition -
trickles-userapi_2.c:35797:					     ("install_event -- descbuf too short for "
trickles-userapi_2.c:35799:					     err = -22; goto out_put;}
trickles-userapi_2.c:35803:						 (&inputCollection->
trickles-userapi_2.c:35808:						     "&inputCollection->descs[0] == lbb_get_pos(&lbb)"
trickles-userapi_2.c:35810:						     "trickles-userapi.c"
trickles-userapi_2.c:35822:								       ((sizeof (*(&inputCollection->len))))
trickles-userapi_2.c:35825:__asm__ __volatile__ ("1:	mov" "b" " %2,%" "b" "1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor" "b" " %" "b" "1,%" "b" "1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__gu_err), "=q" (__gu_val): "m" ((*(struct __large_struct *) (((&inputCollection->len))))), "i" (-14), "0" (__gu_err)); break; case 2:
trickles-userapi_2.c:35826:__asm__ __volatile__ ("1:	mov" "w" " %2,%" "w" "1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor" "w" " %" "w" "1,%" "w" "1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__gu_err), "=r" (__gu_val): "m" ((*(struct __large_struct *) (((&inputCollection->len))))), "i" (-14), "0" (__gu_err)); break; case 4:
trickles-userapi_2.c:35827:__asm__ __volatile__ ("1:	mov" "l" " %2,%" "" "1\n" "2:\n" ".section .fixup,\"ax\"\n" "3:	movl %3,%0\n" "	xor" "l" " %" "" "1,%" "" "1\n" "	jmp 2b\n" ".previous\n" ".section __ex_table,\"a\"\n" "	.align 4\n" "	.long 1b,3b\n" ".previous": "=r" (__gu_err), "=r" (__gu_val): "m" ((*(struct __large_struct *) (((&inputCollection->len))))), "i" (-14), "0" (__gu_err)); break; default:
trickles-userapi_2.c:35832:								       ((collectionLen)) = (__typeof__ (*((&inputCollection->len)))) __gu_val; __gu_err;}
trickles-userapi_2.c:35841:					      numCollections); err = -22;
trickles-userapi_2.c:35848:					       (inputCollection->hmac),
trickles-userapi_2.c:35852:					       (inputCollection->hmac),
trickles-userapi_2.c:35855:					     *tp->t.hmacCTX; char hmac[16];
trickles-userapi_2.c:35859:					     lbb_get_end (&lbb) -
trickles-userapi_2.c:35871:					      numCollections); err = -22;
trickles-userapi_2.c:35882:					     err = -22; goto out_put;}
trickles-userapi_2.c:35892:						     "trickles-userapi.c"
trickles-userapi_2.c:35911:						     "trickles-userapi.c"
trickles-userapi_2.c:35914:						     relink); relink->sk = sk;
trickles-userapi_2.c:35919:							    &((sk)->tp_pinfo.
trickles-userapi_2.c:35923:								-
trickles-userapi_2.c:35925:								 *) ((_tp)->
trickles-userapi_2.c:35927:								     cfg.ctl->
trickles-userapi_2.c:35937:								     *) ((relink)))) >= ((void *) ((_tp)->cminisock_api_config.cfg.ctl->minisock_base)) && ((void *) ((struct cminisock *) ((relink)) + 1)) <= ((_tp)->cminisock_api_config.cfg.ctl->minisock_limit))) && (((relink))->ctl == ALLOC_READY || ((relink))->ctl == ALLOC_HALFFREE);})))
trickles-userapi_2.c:35942:						     "trickles-userapi.c"
trickles-userapi_2.c:35944:					     switch (relink->ctl)
trickles-userapi_2.c:35947:insert_tail (&tp->cminisock_api_config.cfg.ctl->msk_eventlist, (struct alloc_head *) relink); new_event (sk); break; case ALLOC_HALFFREE:
trickles-userapi_2.c:35962:					      relink->ctl);
trickles-userapi_2.c:35965:					     err = -22; goto out_put;}
trickles-userapi_2.c:35967:						 ((relink)->list ==
trickles-userapi_2.c:35968:						  &(tp)->cminisock_api_config.
trickles-userapi_2.c:35970:						  || (relink)->list ==
trickles-userapi_2.c:35971:						  &(tp)->cminisock_api_config.
trickles-userapi_2.c:35972:						  cfg.ctl->msk_eventlist))
trickles-userapi_2.c:35976:					      relink, relink->list);}
trickles-userapi_2.c:35987:					     (void) (&((sk)->lock.slock));}
trickles-userapi_2.c:35989:					     if ((sk)->backlog.tail !=
trickles-userapi_2.c:35992:					     (sk)->lock.users = 0;
trickles-userapi_2.c:35994:						 (&((sk)->lock.wq)))
trickles-userapi_2.c:35995:					     __wake_up ((&((sk)->lock.wq)),
trickles-userapi_2.c:36005:																											  unsigned int *ptr = &((void)((0)), irq_stat[0].__local_bh_count); __asm__ __volatile__ ("": : : "memory"); if (!--*ptr) __asm__ __volatile__ ("cmpl $0, -8(%0);" "jnz 2f;" "1:;" ".subsection 1\n\t" "" ".ifndef " ".text.lock." "tmalloc" "\n\t" ".text.lock." "tmalloc" ":\n\t" ".endif\n\t" "2: pushl %%eax; pushl %%ecx; pushl %%edx;" "call %c1;" "popl %%edx; popl %%ecx; popl %%eax;" "jmp 1b;" ".previous\n\t": :"r" (ptr), "i" (do_softirq));}
trickles-userapi_2.c:36031:						     "trickles-userapi.c"
trickles-userapi_2.c:36033:					     if (toFree->list !=
trickles-userapi_2.c:36042:						 (toFree->list ==
trickles-userapi_2.c:36043:						  &tp->cminisock_api_config.
trickles-userapi_2.c:36047:						     "toFree->list == &tp->cminisock_api_config.msk_freelist"
trickles-userapi_2.c:36049:						     "trickles-userapi.c"
trickles-userapi_2.c:36053:						     tp->cminisock_api_config.
trickles-userapi_2.c:36058:					      tp->cminisock_api_config.
trickles-userapi_2.c:36091:					     err = -12; goto out_put;}
trickles-userapi_2.c:36098:					     msk->prev = ((void *) 0);
trickles-userapi_2.c:36099:					     msk->next = ((void *) 0);
trickles-userapi_2.c:36100:					     msk->list = ((void *) 0);
trickles-userapi_2.c:36103:					     err = -22; goto out_put;}
trickles-userapi_2.c:36104:					     msk->prev = ((void *) 0);
trickles-userapi_2.c:36105:					     msk->next = ((void *) 0);
trickles-userapi_2.c:36106:					     msk->list = ((void *) 0);
trickles-userapi_2.c:36118:						     "trickles-userapi.c"
trickles-userapi_2.c:36136:					     if ((((sk)->tp_pinfo.af_tcp.
trickles-userapi_2.c:36138:						  && ((sk)->state ==
trickles-userapi_2.c:36142:					     &(sk->tp_pinfo.af_tcp);
trickles-userapi_2.c:36144:					     tp->cminisock_api_config.cfg.ctl;
trickles-userapi_2.c:36147:					     &tp->cminisock_api_config.
trickles-userapi_2.c:36150:					     &ctl->msk_eventlist;
trickles-userapi_2.c:36151:					     for (msk = ctl->minisock_base;
trickles-userapi_2.c:36153:						  (void *) ctl->
trickles-userapi_2.c:36158:					     if (msk->list == freeList)
trickles-userapi_2.c:36162:					     if (msk->list == eventList)
trickles-userapi_2.c:36169:					     switch (msk->ctl)
trickles-userapi_2.c:36182:					      msk->list);}
trickles-userapi.c:4:#include "trickles-int.h"
trickles-userapi.c:5:#include "memdump-util.h"
trickles-userapi.c:12:	(((SK)->tp_pinfo.af_tcp.trickles_opt & TCP_TRICKLES_ENABLE) &&	\
trickles-userapi.c:13:	 ((SK)->state == TCP_LISTEN))
trickles-userapi.c:17:			      (MSK)->pmsk = NULL;		\
trickles-userapi.c:25:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi.c:26:	struct cminisock *rval = &tp->t.api_msk;
trickles-userapi.c:33:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi.c:34:	printk("   tp->rcv_nxt = %d\n", tp->rcv_nxt);
trickles-userapi.c:35:	printk("   tp->t.byteRcvNxt = %d\n", tp->t.byteRcvNxt);
trickles-userapi.c:36:	printk("   Recv queue len = %d\n", sk->receive_queue.qlen);
trickles-userapi.c:37:	printk("   Trickles state = %d\n", tp->t.state);
trickles-userapi.c:39:	printk("   Ofo_queue len = %d\n", tp->t.ofo_queue.qlen);
trickles-userapi.c:40:	printk("   data_ofo_queue len = %d\n", tp->t.data_ofo_queue.qlen);
trickles-userapi.c:41:	printk("   request_ofo_queue len = %d\n", tp->t.request_ofo_queue.len);
trickles-userapi.c:49:	while((char*)(chunk+1) - ptr < len && chunknum < 5) {
trickles-userapi.c:50:		printk("Chunk %d(%d) - %d @ %d\n", chunknum,
trickles-userapi.c:52:		       chunk->chunkID,
trickles-userapi.c:54:		       -1,
trickles-userapi.c:57:		       (char*)chunk->data - ptr);
trickles-userapi.c:68:	skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
trickles-userapi.c:69:	frag->page = page;
trickles-userapi.c:70:	frag->page_offset = off;
trickles-userapi.c:71:	frag->size = size;
trickles-userapi.c:72:	skb_shinfo(skb)->nr_frags = i+1;
trickles-userapi.c:82:	int off = skb->len;
trickles-userapi.c:88:		skb->csum = csum_block_add(skb->csum, csum, off);
trickles-userapi.c:90:		//printk("Grepping for range header (e.g., non-zero bytes)\n");
trickles-userapi.c:96:				       dest - (char*)skb->head);
trickles-userapi.c:104:			       dest - (char*)skb->head, count);
trickles-userapi.c:105:			return -EFAULT;
trickles-userapi.c:112:	return -EFAULT;
trickles-userapi.c:118:	msk->sk = sk;
trickles-userapi.c:119:	msk->sk->dst_cache = NULL;
trickles-userapi.c:120:	msk->sk->protinfo.af_inet.opt = NULL;
trickles-userapi.c:121:	msk->sk->protinfo.af_inet.ttl = 255;
trickles-userapi.c:122:	msk->sk->protocol = IPPROTO_TCP;
trickles-userapi.c:123:	msk->sk->protinfo.af_inet.tos = 0;
trickles-userapi.c:124:	msk->sk->tp_pinfo.af_tcp.trickles_opt = 0;
trickles-userapi.c:125:	msk->sk->localroute = 0;
trickles-userapi.c:127:                msk->sk->protinfo.af_inet.pmtudisc = IP_PMTUDISC_DONT;
trickles-userapi.c:129:                msk->sk->protinfo.af_inet.pmtudisc = IP_PMTUDISC_WANT;
trickles-userapi.c:131:	msk->sk->bound_dev_if = 0;
trickles-userapi.c:133:	msk->sk->saddr = msk->saddr;
trickles-userapi.c:134:	msk->sk->sport = msk->source;
trickles-userapi.c:135:	msk->sk->daddr = msk->daddr;
trickles-userapi.c:136:	msk->sk->dport = msk->dest;
trickles-userapi.c:169:			ret |= (va & (PAGE_SIZE -1));
trickles-userapi.c:179:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);			\
trickles-userapi.c:194:										/* printk("Queuing %p : input_len %d\n", msk, msk->input_len); */  \
trickles-userapi.c:195:	msk->tag = tag;							\
trickles-userapi.c:201:		msk->ctl = ALLOC_READY;					\
trickles-userapi.c:204:			for(i=0; i < msk->num_packets; i++) {		\
trickles-userapi.c:205:				printk("upcall pkts[%d]: %u-%u\n", i, msk->packets[i].seq, msk->packets[i].seq + msk->packets[i].len); \
trickles-userapi.c:216:	     insert_tail_mb(&tp->cminisock_api_config.cfg.ctl->msk_eventlist, (struct alloc_head *)msk););
trickles-userapi.c:218:	     dlist_insert_tail_mb(&tp->cminisock_api_config.cfg.ctl->pmsk_eventlist, (struct list_link *)msk););
trickles-userapi.c:222:	wake_up_interruptible(sk->sleep);
trickles-userapi.c:223:	if (!sk->dead) {
trickles-userapi.c:225:		sk->data_ready(sk, 0);
trickles-userapi.c:227:	atomic_inc(&sk->tp_pinfo.af_tcp.cminisock_api_config.cfg.ctl->update_since_poll);
trickles-userapi.c:241:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi.c:243:	net_statistics[smp_processor_id()*2+1].TCPPrequeued += skb_queue_len(&tp->ucopy.prequeue);
trickles-userapi.c:247:	while ((skb = __skb_dequeue(&tp->ucopy.prequeue)) != NULL)
trickles-userapi.c:248:		sk->backlog_rcv(sk, skb);
trickles-userapi.c:252:	tp->ucopy.memory = 0;
trickles-userapi.c:261:	if(!msk->isStatic) {					\
trickles-userapi.c:265:	/* printk("downcall %d\n", msk->seq); */		\
trickles-userapi.c:269:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp),			\
trickles-userapi.c:274:	dummy_tp->trickles_opt = tp->trickles_opt;			\
trickles-userapi.c:275:	dummy_tp->t.hmacCTX = tp->t.hmacCTX;				\
trickles-userapi.c:276:	dummy_tp->t.nonceCTX = tp->t.nonceCTX;				\
trickles-userapi.c:279:	msk->serverSK = sk;						\
trickles-userapi.c:283:		if(msk->seqnum != last+1) {				\
trickles-userapi.c:286:		last = msk->seqnum;					\
trickles-userapi.c:289:	if(msk->tag == SYN || msk->tag == ACK || msk->tag == FIN) { \
trickles-userapi.c:302:		skb->csum = 0;						\
trickles-userapi.c:303:		skb->ip_summed = CHECKSUM_HW;				\
trickles-userapi.c:306:		switch(msk->tag) {					\
trickles-userapi.c:319:		for(i=0; i < msk->num_packets; i++) {			\
trickles-userapi.c:321:			skb1->csum = 0;					\
trickles-userapi.c:322:			skb1->ip_summed = CHECKSUM_HW;			\
trickles-userapi.c:324:			msk->tag = ACK;					\
trickles-userapi.c:330:	struct pminisock *pmsk = msk->pmsk;				\
trickles-userapi.c:334:		pminisock_cache_child(sk, msk, pmsk, pmsk->cacheRecycleIndex, 0); \
trickles-userapi.c:351:	return cpkt->ucontLen < 0;
trickles-userapi.c:356:	*ucontLen = cpkt->ucontLen = -cpkt->ucontLen;
trickles-userapi.c:357:	*user_src = cpkt->ucontData;
trickles-userapi.c:358:	cpkt->ucontData = NULL;
trickles-userapi.c:363:	BUG_TRAP(cpkt->ucontLen == 0);
trickles-userapi.c:364:	cpkt->ucontLen = -ucontLen;
trickles-userapi.c:365:	cpkt->ucontData = user_src;
trickles-userapi.c:372:	struct cminisock_packet *pkts = msk->packets;
trickles-userapi.c:378:		int ucontLen = curr_tiov->ucont_len;
trickles-userapi.c:380:			if(packetNum >= msk->num_packets) {
trickles-userapi.c:386:				return -1;
trickles-userapi.c:388:			insertUContDesc(&pkts[packetNum], ucontLen, curr_tiov->ucont_base);
trickles-userapi.c:402:		skb->csum =
trickles-userapi.c:404:						ucontLen, skb->csum, &error);
trickles-userapi.c:446:	struct cminisock_packet *pkts = msk->packets;
trickles-userapi.c:456:	for(i=numUCChildPackets; i < msk->num_packets; i++) {
trickles-userapi.c:462:	for(i=0; i < msk->num_packets; i++) {
trickles-userapi.c:474:		dump_datachunks(skbs[j]->data, skbs[j]->len);
trickles-userapi.c:478:	for(i = numDataPackets; i < msk->num_packets; i++) {
trickles-userapi.c:499:		skb->csum = 0;
trickles-userapi.c:516:	if(msk->num_packets > MAX_SKBS) {
trickles-userapi.c:517:		skbs = kmalloc(sizeof(struct sk_buff *) * msk->num_packets, GFP_USER);
trickles-userapi.c:519:		BUG_TRAP(msk->num_packets >= 0);
trickles-userapi.c:527:	pkts = msk->packets;
trickles-userapi.c:532:	for(i=0; i < msk->num_packets; i++) {
trickles-userapi.c:533:		maxLen += msk->packets[i].len;
trickles-userapi.c:539:		if(msk->dbg_mark == MAX_NUM_DATACHUNKS) {
trickles-userapi.c:543:			printk("%lud:mark(%d) Short by %d (%d - %d) count=(%d,%d)\n", jiffies, msk->dbg_mark, maxLen - totallen,
trickles-userapi.c:545:			printk("%p short by input_len = %d\n", msk, msk->input_len);
trickles-userapi.c:556:	for(i=0; i < msk->num_packets; i++) {
trickles-userapi.c:575:		skb->csum = 0;
trickles-userapi.c:576:		skb->ip_summed = CHECKSUM_HW;
trickles-userapi.c:578:			int amt = MIN(pkt_remain, tiov[tiov_pos].iov_len - tiov_offs);
trickles-userapi.c:584:			//printk("tiov[%d].tiov_base (%p) + tiov_offs (%u) = %p, data = %p, amt = %d, skb->csum = %x, tail = %p, tailroom = %u, tiov_len = %u, &err=%p\n", tiov_pos, tiov[tiov_pos].tiov_base, tiov_offs, tiov[tiov_pos].tiov_base + tiov_offs, data, amt, skb->csum, skb->tail, skb_tailroom(skb), tiov[tiov_pos].iov_len, &err);
trickles-userapi.c:587:				       src, amt, msk->state, msk->seq, msk->TCPBase, msk->seq - msk->TCPBase);
trickles-userapi.c:593:			totallen -= amt;
trickles-userapi.c:594:			pkt_remain -= amt;
trickles-userapi.c:605:			printk("sending pkts[%d] %u-%u\n", i, pkts[i].seq, pkts[i].seq + pkts[i].len);
trickles-userapi.c:610:		   tiov[tiovlen-1].iov_base == (void*)-1 && tiov[tiovlen-1].iov_len == 0) {
trickles-userapi.c:612:			msk->tag = FIN;
trickles-userapi.c:629:			       totallen, msk->executionTrace);
trickles-userapi.c:643:		//printk("pre disabled kfree %d\n", msk->num_packets);
trickles-userapi.c:655:#if 1 // 0502 - moving receive queue drain inside bh-safe portion
trickles-userapi.c:658:	sk->shutdown = SHUTDOWN_MASK;
trickles-userapi.c:661:	while((skb=__skb_dequeue(&sk->receive_queue))!=NULL) {
trickles-userapi.c:662:		u32 len = TCP_SKB_CB(skb)->end_seq - TCP_SKB_CB(skb)->seq - skb->h.th->fin;
trickles-userapi.c:690:	sk->shutdown = SHUTDOWN_MASK;
trickles-userapi.c:693:	while((skb=__skb_dequeue(&sk->receive_queue))!=NULL) {
trickles-userapi.c:694:		u32 len = TCP_SKB_CB(skb)->end_seq - TCP_SKB_CB(skb)->seq - skb->h.th->fin;
trickles-userapi.c:712:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi.c:716:	if(!(tp->trickles_opt & TCP_TRICKLES_ENABLE) &&
trickles-userapi.c:719:			tp->t.testseq = 1;
trickles-userapi.c:720:			sk->prot = &trickles_prot;
trickles-userapi.c:723:			sk->prot = &trickles_client_prot;
trickles-userapi.c:726:				sk->rcvbuf = 100000000;
trickles-userapi.c:734:			tp->t.events = kmalloc(EVENT_RECORD_LEN, GFP_ATOMIC);
trickles-userapi.c:735:			tp->t.eventsPos = 0;
trickles-userapi.c:736:			tp->t.eventsSize = EVENT_RECORD_LEN /
trickles-userapi.c:739:			for(i=0; i < tp->t.eventsSize; i++) {
trickles-userapi.c:740:				tp->t.events[i].valid = 0;
trickles-userapi.c:745:			tp->t.slowstart_timer.function = &slow_start_timer;
trickles-userapi.c:746:			tp->t.slowstart_timer.data = (long)sk;
trickles-userapi.c:749:	tp->trickles_opt = val;
trickles-userapi.c:757:		struct tcp_opt *_tp = 	&((SK)->tp_pinfo.af_tcp);	\
trickles-userapi.c:763:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi.c:766:	int tiovlen = msg->msg_iovlen;
trickles-userapi.c:767:	int rval = -EINVAL;
trickles-userapi.c:769:	struct tiovec *tiov = (struct tiovec *)msg->msg_iov;
trickles-userapi.c:770:	struct cminisock_cmd *cmd = msg->msg_name;
trickles-userapi.c:772:	if(sizeof(*cmd) != msg->msg_namelen || (int)cmd->magic != TRICKLES_MAGIC) {
trickles-userapi.c:773:		return -EINVAL;
trickles-userapi.c:776:	if(cmd->cmd == STARTRCV) {
trickles-userapi.c:778:		return -EINVAL;
trickles-userapi.c:781:		return -EINVAL;
trickles-userapi.c:783:	if(cmd->cmd == POLL) {
trickles-userapi.c:786:		if (skb_queue_len(&tp->ucopy.prequeue)) {
trickles-userapi.c:795:	msk = cmd->socket;
trickles-userapi.c:801:		rval = -EINVAL;
trickles-userapi.c:809:		rval = -EINVAL;
trickles-userapi.c:814:	pmsk = msk->pmsk;
trickles-userapi.c:820:	if(cmd->cmd == DROP) {
trickles-userapi.c:828:	if(cmd->cmd != PROCESS) {
trickles-userapi.c:851:	//struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi.c:865:		interruptible_sleep_on_timeout(sk->sleep, timeout);
trickles-userapi.c:871:			printk("timeout expired %d\n", jiffies - in_time);
trickles-userapi.c:872:			err = -EAGAIN;
trickles-userapi.c:883:    struct sock *sk = sock->sk;
trickles-userapi.c:884:    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi.c:889:	    int poll_value = atomic_read(&tp->cminisock_api_config.cfg.ctl->update_since_poll);
trickles-userapi.c:890:	    if((!(tp->trickles_opt & TCP_TRICKLES_EDGE)  && !dlist_empty(&tp->cminisock_api_config.cfg.ctl->pmsk_eventlist)) ||
trickles-userapi.c:891:	       ((tp->trickles_opt & TCP_TRICKLES_EDGE) &&
trickles-userapi.c:893:		!dlist_empty(&tp->cminisock_api_config.cfg.ctl->pmsk_eventlist))) {
trickles-userapi.c:897:		    atomic_sub(poll_value, &tp->cminisock_api_config.cfg.ctl->update_since_poll);
trickles-userapi.c:917:	struct trickles_kconfig *api_config = (struct trickles_kconfig*)area->vm_private_data;
trickles-userapi.c:920:	void *base = api_config->cfg.ctl->ro_base;
trickles-userapi.c:921:	offset = address - (unsigned long)area->vm_start;
trickles-userapi.c:922:	if(offset >= api_config->cfg.ctl->ro_len) {
trickles-userapi.c:940:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi.c:953:		   3) Split the new area into read-only and read-write sections */
trickles-userapi.c:954:		while(tp->cminisock_api_config.pending_delivery) {
trickles-userapi.c:968:			error = -EINVAL;
trickles-userapi.c:974:			error = -EFAULT;
trickles-userapi.c:980:			error = -EINVAL;
trickles-userapi.c:987:			error = -ENOMEM;
trickles-userapi.c:995:		ctl->ro_base = new_config.mmap_base;
trickles-userapi.c:996:		ctl->ro_len = PAGE_ALIGN(mmap_len / 4);
trickles-userapi.c:997:		ctl->ro_offs = (char*)ctl->ro_base - (char*)new_config.mmap_base;
trickles-userapi.c:998:		ctl->rw_base = (__u8*)ctl->ro_base + ctl->ro_len;
trickles-userapi.c:999:		ctl->rw_len = PAGE_ALIGN(mmap_len - ((char*)ctl->rw_base - (char*)new_config.mmap_base)) - PAGE_SIZE;
trickles-userapi.c:1000:		ctl->rw_offs = (char*)ctl->rw_base - (char*)new_config.mmap_base;
trickles-userapi.c:1001:		atomic_set(&ctl->update_since_poll, 0);
trickles-userapi.c:1003:		BUG_TRAP(ctl->rw_len > 0);
trickles-userapi.c:1004:		BUG_TRAP(ctl->ro_len > 0);
trickles-userapi.c:1005:		BUG_TRAP((char*)ctl->ro_base < (char*)new_config.mmap_base + mmap_len);
trickles-userapi.c:1007:		init_head(&ctl->msk_eventlist);
trickles-userapi.c:1009:		tp->cminisock_api_config.cfg = new_config;
trickles-userapi.c:1011:		printk("newConfig page ctl is %p\n", tp->cminisock_api_config.cfg.ctl);
trickles-userapi.c:1014:		head = &tp->cminisock_api_config.msk_freelist;
trickles-userapi.c:1017:		msk = (struct cminisock *)((char*)ctl->ro_base + PAGE_SIZE);
trickles-userapi.c:1018:		ctl->minisock_base = msk;
trickles-userapi.c:1019:		ctl->minisock_offs = (char*)ctl->minisock_base - (char*)new_config.mmap_base;
trickles-userapi.c:1021:		minisock_len = MINISOCK_LEN(ctl->ro_len);
trickles-userapi.c:1022:		ctl->minisock_limit = (char*)ctl->minisock_base + minisock_len;
trickles-userapi.c:1030:		while((char*)(msk + 1) <= (char*)ctl->minisock_limit && 
trickles-userapi.c:1033:			msk->ctl = ALLOC_FREE;
trickles-userapi.c:1034:			msk->prev = msk->next = NULL;
trickles-userapi.c:1035:			msk->list = NULL;
trickles-userapi.c:1045:		int pminisock_len = PMINISOCK_LEN(ctl->ro_len);
trickles-userapi.c:1046:		ctl->pminisock_base = ALIGN(ctl->minisock_limit, 1);
trickles-userapi.c:1047:		struct pminisock *pmsk = ctl->pminisock_base;
trickles-userapi.c:1048:		struct dlist *phead = &tp->cminisock_api_config.pmsk_freelist;
trickles-userapi.c:1050:		dlist_init(&ctl->pmsk_eventlist);
trickles-userapi.c:1053:		ctl->pminisock_limit = (char*)ctl->pminisock_base + pminisock_len;
trickles-userapi.c:1056:		while((char*)(pmsk+1) <= (char*)ctl->pminisock_limit && 
trickles-userapi.c:1059:			pmsk->prev = pmsk->next = NULL;
trickles-userapi.c:1060:			pmsk->ctl = ALLOC_FREE;
trickles-userapi.c:1071:		ctl->heap_base = ALIGN(ctl->pminisock_limit, 1);
trickles-userapi.c:1072:		tp->t.heapbytesize = ctl->ro_len - pminisock_len;
trickles-userapi.c:1077:			error = -EINVAL;
trickles-userapi.c:1092:			tp->t.hmacCTX = kmalloc(sizeof(*tp->t.hmacCTX), GFP_KERNEL);
trickles-userapi.c:1093:			if(tp->t.hmacCTX == NULL) {
trickles-userapi.c:1095:				error = -ENOMEM;
trickles-userapi.c:1098:			hmac_setup(tp->t.hmacCTX, hmac_key, HMAC_KEYLEN);
trickles-userapi.c:1101:			memcpy(tp->t.hmacKey, hmac_key, HMAC_KEYLEN);
trickles-userapi.c:1111:			tp->t.nonceCTX = kmalloc(sizeof(*tp->t.nonceCTX), GFP_KERNEL);
trickles-userapi.c:1112:			if(tp->t.nonceCTX == NULL) {
trickles-userapi.c:1114:				error = -ENOMEM;
trickles-userapi.c:1117:			aes_encrypt_key(nonce_key, NONCE_KEYLEN, tp->t.nonceCTX);
trickles-userapi.c:1125:			return -EFAULT;
trickles-userapi.c:1127:		error = copy_to_user(optdata,&tp->cminisock_api_config.cfg,sizeof(tp->cminisock_api_config.cfg));
trickles-userapi.c:1130:			return -EINVAL;
trickles-userapi.c:1134:			return -EFAULT;
trickles-userapi.c:1151:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi.c:1154:		return -EINVAL;
trickles-userapi.c:1159:		rval = tp->snd_wnd;
trickles-userapi.c:1163:		rval = tp->snd_ssthresh;
trickles-userapi.c:1174:		return -ENOPROTOOPT;
trickles-userapi.c:1177:		return -EFAULT;
trickles-userapi.c:1180:		return -EFAULT;
trickles-userapi.c:1183:		return -EFAULT;
trickles-userapi.c:1186:		return -EFAULT;
trickles-userapi.c:1193:        fput(sock->file);
trickles-userapi.c:1212:	err = -EINVAL;
trickles-userapi.c:1216:	err = -ENOMEM;
trickles-userapi.c:1223:		err = -EFAULT;
trickles-userapi.c:1235:	sk = sock->sk;
trickles-userapi.c:1236:	tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi.c:1241:		err = -EINVAL;
trickles-userapi.c:1248:		err = -EINVAL;
trickles-userapi.c:1254:	COMPATIBILITY(pmsk = msk->pmsk);
trickles-userapi.c:1279:	unsigned long count = desc->count;
trickles-userapi.c:1280:	struct sk_buff *skb = (struct sk_buff *) desc->buf;
trickles-userapi.c:1281:	int i = skb_shinfo(skb)->nr_frags;
trickles-userapi.c:1288:		written = -EINVAL;
trickles-userapi.c:1293:		skb->len += size;
trickles-userapi.c:1294:		skb->data_len += size;
trickles-userapi.c:1297:		desc->error = written;
trickles-userapi.c:1300:	desc->count = count - written;
trickles-userapi.c:1301:	desc->written += written;
trickles-userapi.c:1315:	retval = -EBADF;
trickles-userapi.c:1319:	if (!(in_file->f_mode & FMODE_READ))
trickles-userapi.c:1321:	retval = -EINVAL;
trickles-userapi.c:1322:	in_inode = in_file->f_dentry->d_inode;
trickles-userapi.c:1325:	if (!in_inode->i_mapping->a_ops->readpage)
trickles-userapi.c:1327:	retval = locks_verify_area(FLOCK_VERIFY_READ, in_inode, in_file, in_file->f_pos, count);
trickles-userapi.c:1361:		kmalloc(sizeof(struct sk_buff *) * msk->num_packets, GFP_USER),
trickles-userapi.c:1367:	pkts = msk->packets;
trickles-userapi.c:1372:	for(i=0; i < msk->num_packets; i++) {
trickles-userapi.c:1392:		skb->csum = 0;
trickles-userapi.c:1393:		skb->ip_summed = CHECKSUM_HW;
trickles-userapi.c:1395:			int amt = MIN(pkt_remain, fiov[fiov_pos].len - fiov_offs);
trickles-userapi.c:1399:			if(fiov[fiov_pos].fd == -2) {
trickles-userapi.c:1412:					printk("error while csum/copy, base = %p amt = %d pkt_type = %d\n", src, amt, msk->packets[i].type);
trickles-userapi.c:1414:					rval = -EINVAL;
trickles-userapi.c:1432:			//printk("iov[%d].iov_base (%p) + iov_offs (%u) = %p, data = %p, amt = %d, skb->csum = %x, tail = %p, tailroom = %u, iov_len = %u, &err=%p\n", iov_pos, iov[iov_pos].iov_base, iov_offs, iov[iov_pos].iov_base + iov_offs, data, amt, skb->csum, skb->tail, skb_tailroom(skb), iov[iov_pos].iov_len, &err);
trickles-userapi.c:1439:			totallen -= amt;
trickles-userapi.c:1440:			pkt_remain -= amt;
trickles-userapi.c:1451:			printk("sending pkts[%d] %u-%u\n", i, pkts[i].seq, pkts[i].seq + pkts[i].len);
trickles-userapi.c:1455:		   fiov[fiovlen-1].offset == 0 && fiov[fiovlen-1].len == 0) {
trickles-userapi.c:1456:			msk->tag = FIN;
trickles-userapi.c:1482:	err = -EINVAL;
trickles-userapi.c:1488:		err = -ENOMEM;
trickles-userapi.c:1495:			err = -EFAULT;
trickles-userapi.c:1508:	sk = sock->sk;
trickles-userapi.c:1509:	tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi.c:1515:		err = -EINVAL;
trickles-userapi.c:1521:		err = -EINVAL;
trickles-userapi.c:1527:	COMPATIBILITY(pmsk = msk->pmsk);
trickles-userapi.c:1566:	sk = sock->sk;
trickles-userapi.c:1567:	tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi.c:1573:		err = -EINVAL;
trickles-userapi.c:1579:		err = -EINVAL;
trickles-userapi.c:1585:	COMPATIBILITY(pmsk = msk->pmsk);
trickles-userapi.c:1590:	if(iov.iov_len == -1) {
trickles-userapi.c:1594:	} else if(iov.iov_len == -2) {
trickles-userapi.c:1595:		if(pmsk->ctl != ALLOC_HALFFREE) {
trickles-userapi.c:1596:			pmsk->ctl = ALLOC_HALFFREE;
trickles-userapi.c:1600:			/* already half-freed ! */
trickles-userapi.c:1602:			err = -EINVAL;
trickles-userapi.c:1605:		if(msk->ctl != ALLOC_HALFFREE) {
trickles-userapi.c:1606:			msk->ctl = ALLOC_HALFFREE;
trickles-userapi.c:1610:			/* already half-freed ! */
trickles-userapi.c:1612:			err = -EINVAL;
trickles-userapi.c:1615:	} else if(iov.iov_len == -3) {
trickles-userapi.c:1616:		pmsk->tag = FIN;
trickles-userapi.c:1617:		COMPATIBILITY(msk->tag = FIN);
trickles-userapi.c:1639:	struct sock *sk = sock->sk;
trickles-userapi.c:1640:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi.c:1644:		return -EINVAL;
trickles-userapi.c:1647:	vma->vm_ops = &trickles_vm_ops;
trickles-userapi.c:1648:	vma->vm_private_data = &tp->cminisock_api_config;
trickles-userapi.c:1668:	sk = sock->sk;
trickles-userapi.c:1669:	tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi.c:1675:		err = -EINVAL;
trickles-userapi.c:1681:		err = -EINVAL;
trickles-userapi.c:1687:	COMPATIBILITY(pmsk = msk_compat->pmsk);
trickles-userapi.c:1690:	       pmsk->num_packets, msk_compat->num_packets);
trickles-userapi.c:1693:	if(pkt_num < 0 || pkt_num >= pmsk->num_packets) {
trickles-userapi.c:1695:		err = -EINVAL;
trickles-userapi.c:1703:			err = -ENOMEM;
trickles-userapi.c:1709:			err = -EFAULT;
trickles-userapi.c:1716:	BUG_TRAP(pkt_num < pmsk->num_packets);
trickles-userapi.c:1717:	setPacketUCont(&pmsk->packets[pkt_num], buf, ucont_len);
trickles-userapi.c:1737:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi.c:1738:	return tp->t.write_seq - tp->t.snd_una < sk->sndbuf;
trickles-userapi.c:1756:	add_wait_queue(sk->sleep, &wait);
trickles-userapi.c:1758:		set_bit(SOCK_ASYNC_NOSPACE, &sk->socket->flags);
trickles-userapi.c:1762:		if (sk->err || (sk->shutdown & SEND_SHUTDOWN))
trickles-userapi.c:1768:		clear_bit(SOCK_ASYNC_NOSPACE, &sk->socket->flags);
trickles-userapi.c:1772:		set_bit(SOCK_NOSPACE, &sk->socket->flags);
trickles-userapi.c:1779:			vm_wait -= current_timeo;
trickles-userapi.c:1782:			    (current_timeo -= vm_wait) < 0)
trickles-userapi.c:1789:	current->state = TASK_RUNNING;
trickles-userapi.c:1790:	remove_wait_queue(sk->sleep, &wait);
trickles-userapi.c:1794:	err = -EPIPE;
trickles-userapi.c:1797:	err = -EAGAIN;
trickles-userapi.c:1817:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi.c:1818:	iov = msg->msg_iov;
trickles-userapi.c:1819:	iovlen = msg->msg_iovlen;
trickles-userapi.c:1837:					tp->t.write_seq += skb->len;
trickles-userapi.c:1838:					TCP_SKB_CB(skb)->end_seq = tp->t.write_seq;
trickles-userapi.c:1839:					__skb_queue_tail(&tp->t.requestBytes, skb);
trickles-userapi.c:1847:				BUG_TRAP(tp->t.write_seq - tp->t.snd_una <= sk->sndbuf);
trickles-userapi.c:1848:				skb_spaceleft = MIN(sk->sndbuf - (tp->t.write_seq - tp->t.snd_una), totalLen - position);
trickles-userapi.c:1855:				TCP_SKB_CB(skb)->seq = tp->t.write_seq;
trickles-userapi.c:1857:			copyLen = MIN(iov[i].iov_len - iov_position, skb_spaceleft);
trickles-userapi.c:1861:				result = -EFAULT;
trickles-userapi.c:1864:			skb_spaceleft -= copyLen;
trickles-userapi.c:1872:		tp->t.write_seq += skb->len;
trickles-userapi.c:1873:		TCP_SKB_CB(skb)->end_seq = tp->t.write_seq;
trickles-userapi.c:1874:		__skb_queue_tail(&tp->t.requestBytes, skb);
trickles-userapi.c:1877:	if(tp->t.write_seq - tp->t.snd_una > 0) {
trickles-userapi.c:1878:		switch(tp->t.conversionState) {
trickles-userapi.c:1881:			tp->t.conversionState = CONVERSION_WAITFORSERVER;
trickles-userapi.c:1887:			tp->t.conversionState = CONVERSION_WAITFORSERVER;
trickles-userapi.c:1901:	       tp->t.snd_una, tp->t.write_seq);
trickles-userapi.c:1916:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi.c:1917:	int sendBufLen = tp->t.write_seq - tp->t.snd_una;
trickles-userapi.c:1921:			MIN(sendBufLen, TRICKLES_MSS - MAX_TCP_HEADER);
trickles-userapi.c:1922:		struct sk_buff *input_skb = tp->t.requestBytes.next;
trickles-userapi.c:1925:			BUG_TRAP((void*)input_skb != (void*)&tp->t.requestBytes);
trickles-userapi.c:1926:			unsigned pieceLen = MIN(input_skb->len, copyLen);
trickles-userapi.c:1928:				*src = input_skb->data;
trickles-userapi.c:1936:			copyLen -= pieceLen;
trickles-userapi.c:1937:			input_skb = input_skb->next;
trickles-userapi.c:1939:		skb->csum = csum;
trickles-userapi.c:1950:	add_wait_queue(sk->sleep, &wait);
trickles-userapi.c:1954:	set_bit(SOCK_ASYNC_WAITDATA, &sk->socket->flags);
trickles-userapi.c:1957:	if (skb_queue_empty(&sk->receive_queue))
trickles-userapi.c:1961:	clear_bit(SOCK_ASYNC_WAITDATA, &sk->socket->flags);
trickles-userapi.c:1963:	remove_wait_queue(sk->sleep, &wait);
trickles-userapi.c:1971:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
trickles-userapi.c:1977:	if(!(tp->trickles_opt & TCP_TRICKLES_RCV_START)) {
trickles-userapi.c:1979:#if 0 // 0424 - changing client program instead of hacking rcv_start functionality into client
trickles-userapi.c:1984:		tp->trickles_opt |= TCP_TRICKLES_RCV_START;
trickles-userapi.c:1987:	if(!(tp->trickles_opt & TCP_TRICKLES_BUFFERDISCARD)) {
trickles-userapi.c:1997:	result = -ENOTCONN;
trickles-userapi.c:2000:		result = -EINVAL;
trickles-userapi.c:2008:		if(tp->rcv_nxt - tp->copied_seq >= target) {
trickles-userapi.c:2009:			result = MIN(len, tp->rcv_nxt - tp->copied_seq); // 0503 - changed from min to MIN to suppress compilation warning
trickles-userapi.c:2010:			tp->copied_seq += result;
trickles-userapi.c:2015:			result = MIN(target, tp->rcv_nxt - tp->copied_seq); // 0503 - changed from min to MIN to suppress compilation warning
trickles-userapi.c:2016:			tp->copied_seq += result;
trickles-userapi.c:2024:		if(tp->rcv_nxt - tp->copied_seq == 0) {
trickles-userapi.c:2026:			if (sk->done)
trickles-userapi.c:2029:			if (sk->err) {
trickles-userapi.c:2034:			if (sk->shutdown & RCV_SHUTDOWN)
trickles-userapi.c:2037:			if (sk->state == TCP_CLOSE) {
trickles-userapi.c:2038:				if (!sk->done) {
trickles-userapi.c:2042:					result = -ENOTCONN;
trickles-userapi.c:2049:				result = -EAGAIN;
trickles-userapi.c:2061:	printk("tiov_base = %p\ntiov_len = %d", tiov->iov_base, tiov->iov_len);
trickles-userapi.c:2065:	printk("msk = %p, num =  %d\n", mskd->msk, mskd->tiov_num);
trickles-userapi.c:2066:	dump_tiov(mskd->tiov);
trickles-userapi.c:2082:		err = -EINVAL;
trickles-userapi.c:2090:	sk = sock->sk;
trickles-userapi.c:2091:	tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi.c:2101:		err = -EFAULT;
trickles-userapi.c:2110:		struct cminisock *msk = curr_desc->msk;
trickles-userapi.c:2117:			err = -EINVAL;
trickles-userapi.c:2120:		COMPATIBILITY(pmsk = msk->pmsk);
trickles-userapi.c:2125:		msk->dbg_mark = curr_desc->dbg_mark;
trickles-userapi.c:2130:		//printk("Desc %d, len = %d\n", descnum, curr_desc->tiov[0].iov_len);
trickles-userapi.c:2131:		trickles_do_sendmsg_tiov(sk, api_msk, curr_desc->tiov, curr_desc->tiov_num);
trickles-userapi.c:2136:		if (skb_queue_len(&tp->ucopy.prequeue)) {
trickles-userapi.c:2143:	if(tp->trickles_opt & TCP_TRICKLES_BULKPOLL) {
trickles-userapi.c:2144:		//printk("bulk poll %d\n", tp->trickles_opt);
trickles-userapi.c:2149:			err = -EAGAIN;
trickles-userapi.c:2192:	    int first = logEntry->returnedEvents == 0;
trickles-userapi.c:2195:		    for(i=logEntry->returnedEvents; i < logEntry->size; i++) {
trickles-userapi.c:2196:			    if(logEntry->events[i].valid)
trickles-userapi.c:2200:			    htonl(logEntry->addr), htons(logEntry->port),
trickles-userapi.c:2201:			    logEntry->rcv_nxt, logEntry->t_rcv_nxt, count);
trickles-userapi.c:2204:	    for(i=logEntry->returnedEvents; i < logEntry->size; i++) {
trickles-userapi.c:2205:		    struct TricklesLossEvent *event = &logEntry->events[i];
trickles-userapi.c:2209:		    if(!event->valid) continue;
trickles-userapi.c:2211:		    switch(event->extra) {
trickles-userapi.c:2225:			    sprintf(locationBuf, "(bad location %d)", event->extra);
trickles-userapi.c:2228:		    switch(event->state) {
trickles-userapi.c:2245:			    (int)event->cwnd, state, event->time);
trickles-userapi.c:2250:		    temp += logEntry->sentAmount;
trickles-userapi.c:2251:		    int copyLen = MAX(MIN((int)strlen(temp), count - pos), 0);
trickles-userapi.c:2258:			    logEntry->returnedEvents++;
trickles-userapi.c:2259:			    logEntry->sentAmount = 0;
trickles-userapi.c:2261:			    logEntry->sentAmount += copyLen;
trickles-userapi.c:2262:			    //printk("sentamount = %d\n", logEntry->sentAmount);
trickles-userapi.c:2267:	    if(done && (i == logEntry->size)) {
trickles-userapi.c:2269:		    logEntry = (struct TricklesProcLogEntry *)logEntry->prev;
trickles-userapi.c:2271:		    kfree(clean->events);
trickles-userapi.c:2296:	bb->dest = buffer;
trickles-userapi.c:2297:	bb->len = len;
trickles-userapi.c:2298:	bb->curPos = 0;
trickles-userapi.c:2300:	//printk("bbinit: %p %d %d\n", bb->dest, bb->len, bb->curPos);
trickles-userapi.c:2304:	int prevPos = bb->curPos;
trickles-userapi.c:2306:	bb->curPos = MIN(prevPos+len, bb->len);
trickles-userapi.c:2307:	copyLen = bb->curPos - prevPos;
trickles-userapi.c:2309:	memcpy(bb->dest + prevPos, data, copyLen);
trickles-userapi.c:2322:		logentry->prev = logentry->next = NULL;
trickles-userapi.c:2323:		logentry->list = NULL;
trickles-userapi.c:2325:		logentry->type = type;
trickles-userapi.c:2327:		logentry->addr = addr;
trickles-userapi.c:2328:		logentry->port = port;
trickles-userapi.c:2329:		logentry->seq  = seq;
trickles-userapi.c:2330:		logentry->ack_seq = ack_seq;
trickles-userapi.c:2331:		logentry->startCwnd= startCwnd;
trickles-userapi.c:2332:		logentry->effCwnd  = effCwnd;
trickles-userapi.c:2333:		logentry->ssthresh = ssthresh;
trickles-userapi.c:2334:		logentry->sentAmount = 0;
trickles-userapi.c:2336:		logentry->timestamp = jiffies;
trickles-userapi.c:2342:		logentry->s = tv.tv_sec;
trickles-userapi.c:2343:		logentry->us = tv.tv_usec;
trickles-userapi.c:2345:		logentry->rtt = rtt;
trickles-userapi.c:2346:		logentry->srtt = srtt;
trickles-userapi.c:2373:		    switch(logEntry->type) {
trickles-userapi.c:2375:			    sprintf(tempbuf, "pkt - %d:%d = %d/%d/%d @ %d s %d us %d rtt0 %d rtt1\n",
trickles-userapi.c:2376:				    logEntry->seq, logEntry->ack_seq,
trickles-userapi.c:2377:				    logEntry->startCwnd, logEntry->effCwnd, logEntry->ssthresh,
trickles-userapi.c:2378:				    logEntry->s, logEntry->us,
trickles-userapi.c:2379:				    logEntry->rtt,
trickles-userapi.c:2380:				    logEntry->srtt);
trickles-userapi.c:2383:			    sprintf(tempbuf, "cont - %d:%d = %d/%d/%d TCPBase: %d @ %d s %d us rtt1: %d \n",
trickles-userapi.c:2384:				    logEntry->seq, logEntry->ack_seq,
trickles-userapi.c:2385:				    logEntry->startCwnd, logEntry->effCwnd, logEntry->ssthresh,
trickles-userapi.c:2386:				    logEntry->rtt,
trickles-userapi.c:2387:				    logEntry->s, logEntry->us,
trickles-userapi.c:2388:				    logEntry->srtt);
trickles-userapi.c:2391:			    int eventtype = logEntry->seq;
trickles-userapi.c:2418:			    sprintf(tempbuf, "%s:%d(%d-%d) = %d/%d/%d TCPBase: %d @ %d s %d us\n", eventTypeStr, logEntry->ack_seq,
trickles-userapi.c:2419:				    logEntry->addr, logEntry->port,
trickles-userapi.c:2420:				    logEntry->startCwnd, logEntry->effCwnd, logEntry->ssthresh,
trickles-userapi.c:2421:				    logEntry->rtt,
trickles-userapi.c:2422:				    logEntry->s, logEntry->us);
trickles-userapi.c:2429:		    // , logEntry->timestamp);
trickles-userapi.c:2430:		    char *src = tempbuf + logEntry->sentAmount;
trickles-userapi.c:2432:		    logEntry->sentAmount = real_wrlen;
trickles-userapi.c:2440:			    logEntry = (struct TricklesCwndProcLogEntry*)logEntry->prev;
trickles-userapi.c:2491:			/* Generator generates descriptors in-sequence */ \
trickles-userapi.c:2498:			__copy_to_user(user_addr + hmacStart, kernel_addr + hmacStart, hmacEnd - hmacStart); \
trickles-userapi.c:2499:			hmac_update(hmac_ctx, (char*)kernel_addr + hmacStart, hmacEnd - hmacStart); \
trickles-userapi.c:2513:			/* Generator generates descriptors in-sequence */ \
trickles-userapi.c:2526:	__copy_to_user(user_addr + lastOffset, kernel_addr + lastOffset, len - lastOffset); \
trickles-userapi.c:2528:		hmac_update(hmac_ctx, (char*)kernel_addr + lastOffset, len - lastOffset); \
trickles-userapi.c:2541:	patch->offset = num * sizeof(struct cminisock_packet) +
trickles-userapi.c:2543:	patch->width = WIDTH_OF(struct cminisock_packet, ucontData);
trickles-userapi.c:2554:	ctx->numDeferrals = 0;
trickles-userapi.c:2555:	ctx->next = NULL;
trickles-userapi.c:2559:	if(ctx->next != NULL) {
trickles-userapi.c:2560:		DeferralContext_free(ctx->next);
trickles-userapi.c:2566:	while(ctx->next != NULL) {
trickles-userapi.c:2567:		BUG_TRAP(ctx->numDeferrals == MAX_NUM_DEFERRALS_PER_CONTEXT);
trickles-userapi.c:2568:		ctx = ctx->next;
trickles-userapi.c:2570:	if(ctx->numDeferrals == MAX_NUM_DEFERRALS_PER_CONTEXT) {
trickles-userapi.c:2571:		ctx->next = kmalloc(sizeof(struct DeferralContext), GFP_KERNEL);
trickles-userapi.c:2572:		if(ctx->next == NULL) {
trickles-userapi.c:2574:			return -1;
trickles-userapi.c:2576:		ctx = ctx->next;
trickles-userapi.c:2578:	ctx->data[ctx->numDeferrals++] = value;
trickles-userapi.c:2588:		hmac_update(hmac_ctx, (char *) &deferral_ctx->data[0],
trickles-userapi.c:2589:			    deferral_ctx->numDeferrals * sizeof(deferral_ctx->data[0]));
trickles-userapi.c:2592:		deferral_ctx = deferral_ctx->next;
trickles-userapi.c:2629:				printk("result overflow - %s\n", _dest_name); \
trickles-userapi.c:2645:			if(IS_OUTPUT(DIR)) __put_user((char*)_tempdest - currStart, &((PATCH_TYPE*)_tempdest)->PATCH_FIELD); \
trickles-userapi.c:2646:			/* DEFERRED_HMAC((char*)_tempdest - currStart); */ \
trickles-userapi.c:2651:#define DUMP_DESCLEN() do { printk("desclen[%d] = %d\n", desclen_num++, desc_len - prevDescLen); prevDescLen = desc_len; } while(0)
trickles-userapi.c:2653:	do { printk("Delta[%d] = %d\n", deltaNum++, lbb_get_offset(lbb) - prevDeltaLen); prevDeltaLen = lbb_get_offset(lbb);} while(0)
trickles-userapi.c:2664:#define LBB_ERROR (-1)
trickles-userapi.c:2665:#define MSK_ERROR (-2)
trickles-userapi.c:2676:	int desc_len = -1;							\
trickles-userapi.c:2681:		desc_len += msk->ucont_len;				\
trickles-userapi.c:2683:		desc_len += msk->input_len;				\
trickles-userapi.c:2685:		desc_len += msk->num_packets * sizeof(struct cminisock_packet);	\
trickles-userapi.c:2687:		for(i=0; i < msk->num_packets; i++) {			\
trickles-userapi.c:2688:			desc_len += msk->packets[i].ucontLen;		\
trickles-userapi.c:2693:	/* Shared - reserve space for descriptor length */		\
trickles-userapi.c:2723:	RESERVE_COPY_PATCH_HMAC(DIR, tmalloc_helper, msk->ucont_data, \
trickles-userapi.c:2724:				msk->ucont_len,				\
trickles-userapi.c:2730:	RESERVE_COPY_PATCH_HMAC(DIR, tmalloc_helper, msk->input, \
trickles-userapi.c:2731:				msk->input_len,				\
trickles-userapi.c:2737:	int packets_len = msk->num_packets * sizeof(struct cminisock_packet); \
trickles-userapi.c:2738:	RESERVE_COPY_PATCH_HMAC(DIR, tmalloc_helper, msk->packets, \
trickles-userapi.c:2741:				msk->num_packets,			\
trickles-userapi.c:2744:	/* Copy packets[*]->ucontData */				\
trickles-userapi.c:2745:	for(i=0; i < msk->num_packets; i++) {				\
trickles-userapi.c:2746:		RESERVE_COPY_PATCH_HMAC(DIR, kmalloc_helper, msk->packets[i].ucontData, \
trickles-userapi.c:2747:					msk->packets[i].ucontLen,	\
trickles-userapi.c:2755:		int check_len = lbb_get_offset(lbb) - startLen;			\
trickles-userapi.c:2759:		int actual_len = lbb_get_offset(lbb) - startLen;			\
trickles-userapi.c:2765:	/* Apply deferrals -- Deferrals are not needed yet */			\
trickles-userapi.c:2772:		return -EINVAL;						\
trickles-userapi.c:2789:	msk->ctl = ALLOC_READY;
trickles-userapi.c:2813:   - Unfortunately, this is challenging to do efficiently given the way HMAC is computed. Punt.
trickles-userapi.c:2833:		err = -EINVAL;
trickles-userapi.c:2841:	sk = sock->sk;
trickles-userapi.c:2847:		err = -EINVAL;
trickles-userapi.c:2851:	tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi.c:2854:	int origFreeLen = tp->cminisock_api_config.msk_freelist.len;
trickles-userapi.c:2858:		err = -EFAULT;
trickles-userapi.c:2863:		err = -EFAULT;
trickles-userapi.c:2879:	struct HMAC_CTX hmac_ctx = *tp->t.hmacCTX;
trickles-userapi.c:2888:	while((char*)currentInputDesc -  (char*) descbuf < descbuf_len) {
trickles-userapi.c:2893:		//printk("Requesting msk=%p & %p\n", msk, &currentInputDesc->msk);
trickles-userapi.c:2897:			err = -EINVAL;
trickles-userapi.c:2900:		if(msk->ctl != ALLOC_READY) {
trickles-userapi.c:2902:			err = -EINVAL;
trickles-userapi.c:2927:			msk->ctl = ALLOC_HALFFREE;
trickles-userapi.c:2930:			if(msk->ctl != ALLOC_HALFFREE) {
trickles-userapi.c:2931:				printk("Dealloc called on an msk that is not half-freed\n");
trickles-userapi.c:2932:				err = -EINVAL;
trickles-userapi.c:2944:	__copy_to_user(outputCollection->hmac, hmac, HMACLEN);
trickles-userapi.c:2945:	outputCollection->len = *destLen = lbb.curr - lbb.start;
trickles-userapi.c:2949:#if 1 // instant self-test
trickles-userapi.c:2951:	printk("Starting instant self-test\n");
trickles-userapi.c:2964:	struct HMAC_CTX test_hmac_ctx = *tp->t.hmacCTX;
trickles-userapi.c:2966:	//int test_hmac_input_len0 = lbb_get_end(&lbb) - lbb_get_pos(&lbb);
trickles-userapi.c:2969:	int hmac_len = lbb_get_end(&lbb) - lbb_get_pos(&lbb);
trickles-userapi.c:3002:			//printk("post free len = %d %d\n", new_msk_list.len, tp->cminisock_api_config.msk_freelist.len);
trickles-userapi.c:3013:		printk("FreeLoop(%d %d) After extract free list length %d=>%d\n", hitFreeLoop, err, origFreeLen, tp->cminisock_api_config.msk_freelist.len);
trickles-userapi.c:3021:		printk("install_event -- descbuf too short for " #VAR "\n"); \
trickles-userapi.c:3022:		err = -EINVAL;						\
trickles-userapi.c:3031:	((MSK)->list == &(TP)->cminisock_api_config.msk_freelist ||		\
trickles-userapi.c:3032:	 (MSK)->list == &(TP)->cminisock_api_config.cfg.ctl->msk_eventlist)
trickles-userapi.c:3041:	int err = -1;
trickles-userapi.c:3047:		err = -EINVAL;
trickles-userapi.c:3053:		err = -EINVAL;
trickles-userapi.c:3057:	sk = sock->sk;
trickles-userapi.c:3062:		err = -EINVAL;
trickles-userapi.c:3066:	tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi.c:3067:	int origFreeLen = tp->cminisock_api_config.msk_freelist.len;
trickles-userapi.c:3073:		err = -EFAULT;
trickles-userapi.c:3082:		int remaining = descbuf_len - (inputPosition - (char*)descbuf);
trickles-userapi.c:3092:		BUG_TRAP(&inputCollection->descs[0] == lbb_get_pos(&lbb));
trickles-userapi.c:3095:		//printk("Address of input collection length = %p\n", &inputCollection->len);
trickles-userapi.c:3097:		__get_user(collectionLen, &inputCollection->len);
trickles-userapi.c:3100:			err = -EINVAL;
trickles-userapi.c:3109:		__copy_from_user(input_hmac, inputCollection->hmac, HMACLEN);
trickles-userapi.c:3111:		struct HMAC_CTX hmac_ctx = *tp->t.hmacCTX;
trickles-userapi.c:3114:		int hmac_len = lbb_get_end(&lbb) - lbb_get_pos(&lbb);
trickles-userapi.c:3123:			err = -EINVAL;
trickles-userapi.c:3128:			err = -EINVAL;
trickles-userapi.c:3144:		relink->sk = sk;
trickles-userapi.c:3146:		switch(relink->ctl) {
trickles-userapi.c:3148:			insert_tail(&tp->cminisock_api_config.cfg.ctl->msk_eventlist, (struct alloc_head *)relink);
trickles-userapi.c:3154:			// don't re-insert on list
trickles-userapi.c:3157:			printk("Unhandled ctl state %d in installed event\n", relink->ctl);
trickles-userapi.c:3160:			err = -EINVAL;
trickles-userapi.c:3164:			printk("Relink Msk %p not on valid list (list = %p)\n", relink, relink->list);
trickles-userapi.c:3180:				if(toFree->list != &new_msk_list) {
trickles-userapi.c:3185:				//printk("post free len = %d %d\n", new_msk_list.len, tp->cminisock_api_config.msk_freelist.len);
trickles-userapi.c:3186:				BUG_TRAP(toFree->list == &tp->cminisock_api_config.msk_freelist);
trickles-userapi.c:3189:		printk("Free list length %d\n", tp->cminisock_api_config.msk_freelist.len);
trickles-userapi.c:3190:		printk("After insert free list length %d=>%d\n", origFreeLen, tp->cminisock_api_config.msk_freelist.len);
trickles-userapi.c:3212:			err = -ENOMEM;
trickles-userapi.c:3218:			msk->prev = NULL;
trickles-userapi.c:3219:			msk->next = NULL;
trickles-userapi.c:3220:			msk->list = NULL;
trickles-userapi.c:3224:			err = -EINVAL;
trickles-userapi.c:3227:		msk->prev = NULL;
trickles-userapi.c:3228:		msk->next = NULL;
trickles-userapi.c:3229:		msk->list = NULL;
trickles-userapi.c:3248:		struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
trickles-userapi.c:3249:		struct trickles_mmap_ctl *ctl = tp->cminisock_api_config.cfg.ctl;
trickles-userapi.c:3252:		void *freeList = &tp->cminisock_api_config.msk_freelist;
trickles-userapi.c:3253:		void *eventList = &ctl->msk_eventlist;
trickles-userapi.c:3254:		for(msk = ctl->minisock_base; (void*)(msk+1) < (void*)ctl->minisock_limit; msk++) {
trickles-userapi.c:3257:			if(msk->list == freeList) {
trickles-userapi.c:3259:			} else if(msk->list == eventList) {
trickles-userapi.c:3265:			switch(msk->ctl) {
trickles-userapi.c:3274:				       listName, msk->list);
udp.c:33: *		Fred Van Kempen	: 	Net2e support for sk->broadcast.
udp.c:63: *					bound-to-device socket
udp.c:128:			sk = udp_hash[result & (UDP_HTABLE_SIZE - 1)];
udp.c:132:						((result - sysctl_local_port_range[0]) &
udp.c:133:						 (UDP_HTABLE_SIZE - 1));
udp.c:140:			} while ((sk = sk->next) != NULL);
udp.c:149:					+ ((result - sysctl_local_port_range[0]) &
udp.c:150:					   (UDP_HTABLE_SIZE - 1));
udp.c:161:		for (sk2 = udp_hash[snum & (UDP_HTABLE_SIZE - 1)];
udp.c:163:		     sk2 = sk2->next) {
udp.c:164:			if (sk2->num == snum &&
udp.c:167:			    (!sk2->bound_dev_if ||
udp.c:168:			     !sk->bound_dev_if ||
udp.c:169:			     sk2->bound_dev_if == sk->bound_dev_if) &&
udp.c:170:			    (!sk2->rcv_saddr ||
udp.c:171:			     !sk->rcv_saddr ||
udp.c:172:			     sk2->rcv_saddr == sk->rcv_saddr) &&
udp.c:173:			    (!sk2->reuse || !sk->reuse))
udp.c:177:	sk->num = snum;
udp.c:178:	if (sk->pprev == NULL) {
udp.c:179:		struct sock **skp = &udp_hash[snum & (UDP_HTABLE_SIZE - 1)];
udp.c:180:		if ((sk->next = *skp) != NULL)
udp.c:181:			(*skp)->pprev = &sk->next;
udp.c:183:		sk->pprev = skp;
udp.c:184:		sock_prot_inc_use(sk->prot);
udp.c:203:	if (sk->pprev) {
udp.c:204:		if (sk->next)
udp.c:205:			sk->next->pprev = sk->pprev;
udp.c:206:		*sk->pprev = sk->next;
udp.c:207:		sk->pprev = NULL;
udp.c:208:		sk->num = 0;
udp.c:209:		sock_prot_dec_use(sk->prot);
udp.c:216: * harder than this. -DaveM
udp.c:222:	int badness = -1;
udp.c:224:	for(sk = udp_hash[hnum & (UDP_HTABLE_SIZE - 1)]; sk != NULL; sk = sk->next) {
udp.c:225:		if(sk->num == hnum && !ipv6_only_sock(sk)) {
udp.c:228:			score = sk->family == PF_INET ? 1 : 0;
udp.c:232:			if(sk->rcv_saddr) {
udp.c:233:				if(sk->rcv_saddr != daddr)
udp.c:237:			if(sk->daddr) {
udp.c:238:				if(sk->daddr != saddr)
udp.c:242:			if(sk->dport) {
udp.c:243:				if(sk->dport != sport)
udp.c:247:			if(sk->bound_dev_if) {
udp.c:248:				if(sk->bound_dev_if != dif)
udp.c:285:	for(; s; s = s->next) {
udp.c:286:		if ((s->num != hnum)					||
udp.c:287:		    (s->daddr && s->daddr!=rmt_addr)			||
udp.c:288:		    (s->dport != rmt_port && s->dport != 0)			||
udp.c:289:		    (s->rcv_saddr  && s->rcv_saddr != loc_addr)		||
udp.c:291:		    (s->bound_dev_if && s->bound_dev_if != dif))
udp.c:313:	struct iphdr *iph = (struct iphdr*)skb->data;
udp.c:314:	struct udphdr *uh = (struct udphdr*)(skb->data+(iph->ihl<<2));
udp.c:315:	int type = skb->h.icmph->type;
udp.c:316:	int code = skb->h.icmph->code;
udp.c:321:	sk = udp_v4_lookup(iph->daddr, uh->dest, iph->saddr, uh->source, skb->dev->ifindex);
udp.c:343:			if (sk->protinfo.af_inet.pmtudisc != IP_PMTUDISC_DONT) {
udp.c:362:	if (!sk->protinfo.af_inet.recverr) {
udp.c:363:		if (!harderr || sk->state != TCP_ESTABLISHED)
udp.c:366:		ip_icmp_error(sk, skb, err, uh->dest, info, (u8*)(uh+1));
udp.c:368:	sk->err = err;
udp.c:369:	sk->error_report(sk);
udp.c:397:		if (csum_partial_copy_fromiovecend(to+sizeof(struct udphdr), ufh->iov, offset,
udp.c:398:						   fraglen-sizeof(struct udphdr), &ufh->wcheck))
udp.c:399:			return -EFAULT;
udp.c:400: 		ufh->wcheck = csum_partial((char *)ufh, sizeof(struct udphdr),
udp.c:401:					   ufh->wcheck);
udp.c:402:		ufh->uh.check = csum_tcpudp_magic(ufh->saddr, ufh->daddr, 
udp.c:403:					  ntohs(ufh->uh.len),
udp.c:404:					  IPPROTO_UDP, ufh->wcheck);
udp.c:405:		if (ufh->uh.check == 0)
udp.c:406:			ufh->uh.check = -1;
udp.c:410:	if (csum_partial_copy_fromiovecend(to, ufh->iov, offset-sizeof(struct udphdr),
udp.c:411:					   fraglen, &ufh->wcheck))
udp.c:412:		return -EFAULT;
udp.c:426:		return memcpy_fromiovecend(to+sizeof(struct udphdr), ufh->iov, offset,
udp.c:427:					   fraglen-sizeof(struct udphdr));
udp.c:429:	return memcpy_fromiovecend(to, ufh->iov, offset-sizeof(struct udphdr),
udp.c:447:	   in ip_build_xmit --ANK
udp.c:449:	   BTW socket.c -> af_*.c -> ... make multiple
udp.c:450:	   invalid conversions size_t -> int. We MUST repair it f.e.
udp.c:453:	   If len was ULONG_MAX-10 it would be cathastrophe  --ANK
udp.c:457:		return -EMSGSIZE;
udp.c:463:	if (msg->msg_flags&MSG_OOB)	/* Mirror BSD error message compatibility */
udp.c:464:		return -EOPNOTSUPP;
udp.c:470:	if (msg->msg_name) {
udp.c:471:		struct sockaddr_in * usin = (struct sockaddr_in*)msg->msg_name;
udp.c:472:		if (msg->msg_namelen < sizeof(*usin))
udp.c:473:			return -EINVAL;
udp.c:474:		if (usin->sin_family != AF_INET) {
udp.c:475:			if (usin->sin_family != AF_UNSPEC)
udp.c:476:				return -EINVAL;
udp.c:479:		ufh.daddr = usin->sin_addr.s_addr;
udp.c:480:		ufh.uh.dest = usin->sin_port;
udp.c:482:			return -EINVAL;
udp.c:484:		if (sk->state != TCP_ESTABLISHED)
udp.c:485:			return -EDESTADDRREQ;
udp.c:486:		ufh.daddr = sk->daddr;
udp.c:487:		ufh.uh.dest = sk->dport;
udp.c:493:	ipc.addr = sk->saddr;
udp.c:494:	ufh.uh.source = sk->sport;
udp.c:497:	ipc.oif = sk->bound_dev_if;
udp.c:498:	if (msg->msg_controllen) {
udp.c:507:		ipc.opt = sk->protinfo.af_inet.opt;
udp.c:512:	if (ipc.opt && ipc.opt->srr) {
udp.c:514:			return -EINVAL;
udp.c:515:		daddr = ipc.opt->faddr;
udp.c:518:	tos = RT_TOS(sk->protinfo.af_inet.tos);
udp.c:519:	if (sk->localroute || (msg->msg_flags&MSG_DONTROUTE) || 
udp.c:520:	    (ipc.opt && ipc.opt->is_strictroute)) {
udp.c:527:			ipc.oif = sk->protinfo.af_inet.mc_index;
udp.c:529:			ufh.saddr = sk->protinfo.af_inet.mc_addr;
udp.c:541:		err = -EACCES;
udp.c:542:		if (rt->rt_flags&RTCF_BROADCAST && !sk->broadcast) 
udp.c:545:			sk_dst_set(sk, dst_clone(&rt->u.dst));
udp.c:548:	if (msg->msg_flags&MSG_CONFIRM)
udp.c:552:	ufh.saddr = rt->rt_src;
udp.c:554:		ufh.daddr = ipc.addr = rt->rt_dst;
udp.c:557:	ufh.iov = msg->msg_iov;
udp.c:565:			    (sk->no_check == UDP_CSUM_NOXMIT ?
udp.c:568:			    &ufh, ulen, &ipc, rt, msg->msg_flags);
udp.c:581:	dst_confirm(&rt->u.dst);
udp.c:582:	if (!(msg->msg_flags&MSG_PROBE) || len)
udp.c:598:			int amount = atomic_read(&sk->wmem_alloc);
udp.c:608:			spin_lock_irq(&sk->receive_queue.lock);
udp.c:609:			skb = skb_peek(&sk->receive_queue);
udp.c:616:				amount = skb->len - sizeof(struct udphdr);
udp.c:618:			spin_unlock_irq(&sk->receive_queue.lock);
udp.c:623:			return -ENOIOCTLCMD;
udp.c:630:	return (unsigned short)csum_fold(skb_checksum(skb, 0, skb->len, skb->csum));
udp.c:635:	return skb->ip_summed != CHECKSUM_UNNECESSARY &&
udp.c:647:  	struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
udp.c:665:  	copied = skb->len - sizeof(struct udphdr);
udp.c:668:		msg->msg_flags |= MSG_TRUNC;
udp.c:671:	if (skb->ip_summed==CHECKSUM_UNNECESSARY) {
udp.c:672:		err = skb_copy_datagram_iovec(skb, sizeof(struct udphdr), msg->msg_iov,
udp.c:674:	} else if (msg->msg_flags&MSG_TRUNC) {
udp.c:677:		err = skb_copy_datagram_iovec(skb, sizeof(struct udphdr), msg->msg_iov,
udp.c:680:		err = skb_copy_and_csum_datagram_iovec(skb, sizeof(struct udphdr), msg->msg_iov);
udp.c:682:		if (err == -EINVAL)
udp.c:694:		sin->sin_family = AF_INET;
udp.c:695:		sin->sin_port = skb->h.uh->source;
udp.c:696:		sin->sin_addr.s_addr = skb->nh.iph->saddr;
udp.c:697:		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
udp.c:699:	if (sk->protinfo.af_inet.cmsg_flags)
udp.c:714:		spin_lock_irq(&sk->receive_queue.lock);
udp.c:715:		if (skb == skb_peek(&sk->receive_queue)) {
udp.c:716:			__skb_unlink(skb, &sk->receive_queue);
udp.c:719:		spin_unlock_irq(&sk->receive_queue.lock);
udp.c:727:		return -EAGAIN;	
udp.c:741:	  	return -EINVAL;
udp.c:743:	if (usin->sin_family != AF_INET) 
udp.c:744:	  	return -EAFNOSUPPORT;
udp.c:748:	oif = sk->bound_dev_if;
udp.c:749:	saddr = sk->saddr;
udp.c:750:	if (MULTICAST(usin->sin_addr.s_addr)) {
udp.c:752:			oif = sk->protinfo.af_inet.mc_index;
udp.c:754:			saddr = sk->protinfo.af_inet.mc_addr;
udp.c:756:	err = ip_route_connect(&rt, usin->sin_addr.s_addr, saddr,
udp.c:760:	if ((rt->rt_flags&RTCF_BROADCAST) && !sk->broadcast) {
udp.c:762:		return -EACCES;
udp.c:764:  	if(!sk->saddr)
udp.c:765:	  	sk->saddr = rt->rt_src;		/* Update source address */
udp.c:766:	if(!sk->rcv_saddr)
udp.c:767:		sk->rcv_saddr = rt->rt_src;
udp.c:768:	sk->daddr = rt->rt_dst;
udp.c:769:	sk->dport = usin->sin_port;
udp.c:770:	sk->state = TCP_ESTABLISHED;
udp.c:771:	sk->protinfo.af_inet.id = jiffies;
udp.c:773:	sk_dst_set(sk, &rt->u.dst);
udp.c:780:	 *	1003.1g - break association.
udp.c:783:	sk->state = TCP_CLOSE;
udp.c:784:	sk->daddr = 0;
udp.c:785:	sk->dport = 0;
udp.c:786:	sk->bound_dev_if = 0;
udp.c:787:	if (!(sk->userlocks&SOCK_BINDADDR_LOCK)) {
udp.c:788:		sk->rcv_saddr = 0;
udp.c:789:		sk->saddr = 0;
udp.c:791:		memset(&sk->net_pinfo.af_inet6.saddr, 0, 16);
udp.c:792:		memset(&sk->net_pinfo.af_inet6.rcv_saddr, 0, 16);
udp.c:795:	if (!(sk->userlocks&SOCK_BINDPORT_LOCK)) {
udp.c:796:		sk->prot->unhash(sk);
udp.c:797:		sk->sport = 0;
udp.c:815:	if (sk->filter && skb->ip_summed != CHECKSUM_UNNECESSARY) {
udp.c:819:			ip_statistics[smp_processor_id()*2].IpInDelivers--;
udp.c:821:			return -1;
udp.c:823:		skb->ip_summed = CHECKSUM_UNNECESSARY;
udp.c:830:		ip_statistics[smp_processor_id()*2].IpInDelivers--;
udp.c:832:		return -1;
udp.c:851:	sk = udp_hash[ntohs(uh->dest) & (UDP_HTABLE_SIZE - 1)];
udp.c:852:	dif = skb->dev->ifindex;
udp.c:853:	sk = udp_v4_mcast_next(sk, uh->dest, daddr, uh->source, saddr, dif);
udp.c:860:			sknext = udp_v4_mcast_next(sk->next, uh->dest, daddr,
udp.c:861:						   uh->source, saddr, dif);
udp.c:878: * including udp header and folding it to skb->csum.
udp.c:883:	if (uh->check == 0) {
udp.c:884:		skb->ip_summed = CHECKSUM_UNNECESSARY;
udp.c:885:	} else if (skb->ip_summed == CHECKSUM_HW) {
udp.c:886:		skb->ip_summed = CHECKSUM_UNNECESSARY;
udp.c:887:		if (!udp_check(uh, ulen, saddr, daddr, skb->csum))
udp.c:890:		skb->ip_summed = CHECKSUM_NONE;
udp.c:892:	if (skb->ip_summed != CHECKSUM_UNNECESSARY)
udp.c:893:		skb->csum = csum_tcpudp_nofold(saddr, daddr, ulen, IPPROTO_UDP, 0);
udp.c:909:	struct rtable *rt = (struct rtable*)skb->dst;
udp.c:910:	u32 saddr = skb->nh.iph->saddr;
udp.c:911:	u32 daddr = skb->nh.iph->daddr;
udp.c:912:	int len = skb->len;
udp.c:922:  	uh = skb->h.uh;
udp.c:924:	ulen = ntohs(uh->len);
udp.c:935:	if(rt->rt_flags & (RTCF_BROADCAST|RTCF_MULTICAST))
udp.c:938:	sk = udp_v4_lookup(saddr, uh->source, daddr, uh->dest, skb->dev->ifindex);
udp.c:964:			ntohs(uh->source),
udp.c:968:			ntohs(uh->dest)));
udp.c:982:			ntohs(uh->source),
udp.c:984:			ntohs(uh->dest),
udp.c:996:	dest  = sp->daddr;
udp.c:997:	src   = sp->rcv_saddr;
udp.c:998:	destp = ntohs(sp->dport);
udp.c:999:	srcp  = ntohs(sp->sport);
udp.c:1002:		i, src, srcp, dest, destp, sp->state, 
udp.c:1003:		atomic_read(&sp->wmem_alloc), atomic_read(&sp->rmem_alloc),
udp.c:1007:		atomic_read(&sp->refcnt), sp);
udp.c:1018:		len += sprintf(buffer, "%-127s\n",
udp.c:1020:			       "rx_queue tr tm->when retrnsmt   uid  timeout inode");
udp.c:1026:		for (sk = udp_hash[i]; sk; sk = sk->next, num++) {
udp.c:1027:			if (sk->family != PF_INET)
udp.c:1033:			len += sprintf(buffer+len, "%-127s\n", tmpbuf);
udp.c:1040:	begin = len - (pos - offset);
udp.c:1042:	len -= begin;
utils.c:6: *		Various kernel-resident INET utility functions; mainly
utils.c:47:				val += *str - '0';
