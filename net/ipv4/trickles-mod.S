
trickles-mod.o:     file format elf32-i386

Disassembly of section .text:

00000000 <htonl>:
       0:	8b 44 24 04          	mov    0x4(%esp,1),%eax
       4:	66 c1 c8 08          	ror    $0x8,%ax
       8:	c1 c8 10             	ror    $0x10,%eax
       b:	66 c1 c8 08          	ror    $0x8,%ax
       f:	c3                   	ret    

00000010 <htons>:
      10:	8b 44 24 04          	mov    0x4(%esp,1),%eax
      14:	25 ff ff 00 00       	and    $0xffff,%eax
      19:	66 c1 c8 08          	ror    $0x8,%ax
      1d:	c3                   	ret    
      1e:	90                   	nop    
      1f:	90                   	nop    

00000020 <record_transfer_skb>:
void record_free_skb_head(struct sk_buff *skb) {
}

static inline 
void record_transfer_skb(struct sk_buff *skb, int newType) {
      20:	55                   	push   %ebp
      21:	89 e5                	mov    %esp,%ebp
}
      23:	5d                   	pop    %ebp
      24:	c3                   	ret    

00000025 <free_trickles_msk>:
/* Two phase free: first phase disconnects socket from event list,
   sets to ALLOC_PROCESSING; second phase adds the socket to free
   list, sets to ALLOC_FREE and ready for reuse */
#ifndef USERTEST
static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk) {
      25:	55                   	push   %ebp
      26:	89 e5                	mov    %esp,%ebp
      28:	83 ec 08             	sub    $0x8,%esp
	if(!SIMULATION_MODE(sk)) {
      2b:	8b 45 08             	mov    0x8(%ebp),%eax
      2e:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
      34:	83 e0 01             	and    $0x1,%eax
      37:	85 c0                	test   %eax,%eax
      39:	74 1b                	je     56 <free_trickles_msk+0x31>
      3b:	8b 55 08             	mov    0x8(%ebp),%edx
      3e:	8b 45 08             	mov    0x8(%ebp),%eax
      41:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
      47:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
      4d:	83 e0 08             	and    $0x8,%eax
      50:	85 c0                	test   %eax,%eax
      52:	75 02                	jne    56 <free_trickles_msk+0x31>
      54:	eb 6b                	jmp    c1 <free_trickles_msk+0x9c>
		if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) {
      56:	8b 45 0c             	mov    0xc(%ebp),%eax
      59:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
      5d:	74 0b                	je     6a <free_trickles_msk+0x45>
      5f:	8b 45 0c             	mov    0xc(%ebp),%eax
      62:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
      66:	74 02                	je     6a <free_trickles_msk+0x45>
      68:	eb 31                	jmp    9b <free_trickles_msk+0x76>
			printk("double free\n");
      6a:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp,1)
      71:	e8 fc ff ff ff       	call   72 <free_trickles_msk+0x4d>
			BUG();
      76:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
      7d:	00 
      7e:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
      85:	e8 fc ff ff ff       	call   86 <free_trickles_msk+0x61>
      8a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
      91:	e8 fc ff ff ff       	call   92 <free_trickles_msk+0x6d>
      96:	e8 fc ff ff ff       	call   97 <free_trickles_msk+0x72>
		}
		if(msk->ctl == ALLOC_READY && msk->prev != NULL) {
      9b:	8b 45 0c             	mov    0xc(%ebp),%eax
      9e:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
      a2:	75 13                	jne    b7 <free_trickles_msk+0x92>
      a4:	8b 45 0c             	mov    0xc(%ebp),%eax
      a7:	83 38 00             	cmpl   $0x0,(%eax)
      aa:	74 0b                	je     b7 <free_trickles_msk+0x92>
			unlink((struct alloc_head *)msk);
      ac:	8b 45 0c             	mov    0xc(%ebp),%eax
      af:	89 04 24             	mov    %eax,(%esp,1)
      b2:	e8 35 92 00 00       	call   92ec <unlink>
		}
		msk->ctl = ALLOC_PROCESSING;
      b7:	8b 45 0c             	mov    0xc(%ebp),%eax
      ba:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
	}
}
      c1:	c9                   	leave  
      c2:	c3                   	ret    

000000c3 <free_trickles_msk_finish>:

static inline void msk_release(struct sock *sk, struct cminisock *msk) {
	// Perform actual deallocation. This function is common to
	// state cache and event queue
	msk->refCnt--;
	BUG_TRAP(msk->refCnt >= 0);
	if(msk->refCnt == 0) {
		// printk("release: refcnt %p\n", msk);
		struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
		struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;

		free_minisock(sk,msk);
		if(!SIMULATION_MODE(sk)) {
			insert_head(head, (struct alloc_head *)msk);
			msk->ctl = ALLOC_FREE;
		} else {
			if(msk == tp->t.responseMSK) {
			} else {
				// overflow
				unlink((struct alloc_head*)msk);
				kfree(msk);
			}
			tp->t.responseCount--;
		}
	} else {
		//printk("release: refcnt == %d\n", msk->refCnt);
	}
}

static inline void free_trickles_msk_finish(struct sock *sk, struct cminisock *msk) {
      c3:	55                   	push   %ebp
      c4:	89 e5                	mov    %esp,%ebp
      c6:	83 ec 08             	sub    $0x8,%esp
	if(!SIMULATION_MODE(sk)) {
      c9:	8b 45 08             	mov    0x8(%ebp),%eax
      cc:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
      d2:	83 e0 01             	and    $0x1,%eax
      d5:	85 c0                	test   %eax,%eax
      d7:	74 1b                	je     f4 <free_trickles_msk_finish+0x31>
      d9:	8b 55 08             	mov    0x8(%ebp),%edx
      dc:	8b 45 08             	mov    0x8(%ebp),%eax
      df:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
      e5:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
      eb:	83 e0 08             	and    $0x8,%eax
      ee:	85 c0                	test   %eax,%eax
      f0:	75 02                	jne    f4 <free_trickles_msk_finish+0x31>
      f2:	eb 4d                	jmp    141 <free_trickles_msk_finish+0x7e>
		if(msk->ctl != ALLOC_PROCESSING && msk->ctl != ALLOC_HALFFREE) {
      f4:	8b 45 0c             	mov    0xc(%ebp),%eax
      f7:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
      fb:	74 44                	je     141 <free_trickles_msk_finish+0x7e>
      fd:	8b 45 0c             	mov    0xc(%ebp),%eax
     100:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
     104:	74 3b                	je     141 <free_trickles_msk_finish+0x7e>
			printk("(free_trickles_msk_finish) without corresponding free_trickles_msk: msk->ctl = %d\n", msk->ctl);
     106:	8b 45 0c             	mov    0xc(%ebp),%eax
     109:	8b 40 0c             	mov    0xc(%eax),%eax
     10c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     110:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp,1)
     117:	e8 fc ff ff ff       	call   118 <free_trickles_msk_finish+0x55>
			BUG();
     11c:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
     123:	00 
     124:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
     12b:	e8 fc ff ff ff       	call   12c <free_trickles_msk_finish+0x69>
     130:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
     137:	e8 fc ff ff ff       	call   138 <free_trickles_msk_finish+0x75>
     13c:	e8 fc ff ff ff       	call   13d <free_trickles_msk_finish+0x7a>
		}
	}
	msk_release(sk,msk);
     141:	8b 45 0c             	mov    0xc(%ebp),%eax
     144:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     148:	8b 45 08             	mov    0x8(%ebp),%eax
     14b:	89 04 24             	mov    %eax,(%esp,1)
     14e:	e8 bc a6 00 00       	call   a80f <msk_release>
}
     153:	c9                   	leave  
     154:	c3                   	ret    

00000155 <SKBStat_update>:
};

#define SAFEAVG(SUM,COUNT)  (((__u32)((COUNT) >> 4)) ? ((__u32)((SUM) >> 4)) / ((__u32)((COUNT) >> 4)) : 0)

void SKBStat_update(struct SKBStat *sstat, struct sk_buff *skb, int overhead) {
     155:	55                   	push   %ebp
     156:	89 e5                	mov    %esp,%ebp
     158:	56                   	push   %esi
     159:	53                   	push   %ebx
	sstat->count++;
     15a:	8b 45 08             	mov    0x8(%ebp),%eax
     15d:	83 00 01             	addl   $0x1,(%eax)
     160:	83 50 04 00          	adcl   $0x0,0x4(%eax)
	sstat->totalBytes += skb->tail - skb->head;
     164:	8b 5d 08             	mov    0x8(%ebp),%ebx
     167:	8b 75 08             	mov    0x8(%ebp),%esi
     16a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
     16d:	8b 45 0c             	mov    0xc(%ebp),%eax
     170:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
     176:	8b 81 bc 00 00 00    	mov    0xbc(%ecx),%eax
     17c:	29 d0                	sub    %edx,%eax
     17e:	99                   	cltd   
     17f:	03 46 08             	add    0x8(%esi),%eax
     182:	13 56 0c             	adc    0xc(%esi),%edx
     185:	89 43 08             	mov    %eax,0x8(%ebx)
     188:	89 53 0c             	mov    %edx,0xc(%ebx)
	sstat->totalOverheadBytes += overhead;
     18b:	8b 5d 08             	mov    0x8(%ebp),%ebx
     18e:	8b 4d 08             	mov    0x8(%ebp),%ecx
     191:	8b 45 10             	mov    0x10(%ebp),%eax
     194:	99                   	cltd   
     195:	03 41 10             	add    0x10(%ecx),%eax
     198:	13 51 14             	adc    0x14(%ecx),%edx
     19b:	89 43 10             	mov    %eax,0x10(%ebx)
     19e:	89 53 14             	mov    %edx,0x14(%ebx)
}
     1a1:	5b                   	pop    %ebx
     1a2:	5e                   	pop    %esi
     1a3:	5d                   	pop    %ebp
     1a4:	c3                   	ret    

000001a5 <SKBStat_dump>:

void SKBStat_dump(struct SKBStat *sstat) {
     1a5:	55                   	push   %ebp
     1a6:	89 e5                	mov    %esp,%ebp
     1a8:	83 ec 28             	sub    $0x28,%esp
	printk("total = %d, totalBytes = %d (%d), totalOverhead = %d (%d)\n",
     1ab:	8b 45 08             	mov    0x8(%ebp),%eax
     1ae:	8b 50 04             	mov    0x4(%eax),%edx
     1b1:	8b 00                	mov    (%eax),%eax
     1b3:	0f ac d0 04          	shrd   $0x4,%edx,%eax
     1b7:	c1 ea 04             	shr    $0x4,%edx
     1ba:	85 c0                	test   %eax,%eax
     1bc:	74 3e                	je     1fc <SKBStat_dump+0x57>
     1be:	8b 45 08             	mov    0x8(%ebp),%eax
     1c1:	8b 50 14             	mov    0x14(%eax),%edx
     1c4:	8b 40 10             	mov    0x10(%eax),%eax
     1c7:	0f ac d0 04          	shrd   $0x4,%edx,%eax
     1cb:	c1 ea 04             	shr    $0x4,%edx
     1ce:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
     1d1:	8b 45 08             	mov    0x8(%ebp),%eax
     1d4:	8b 50 04             	mov    0x4(%eax),%edx
     1d7:	8b 00                	mov    (%eax),%eax
     1d9:	0f ac d0 04          	shrd   $0x4,%edx,%eax
     1dd:	c1 ea 04             	shr    $0x4,%edx
     1e0:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
     1e3:	89 55 f4             	mov    %edx,0xfffffff4(%ebp)
     1e6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
     1e9:	ba 00 00 00 00       	mov    $0x0,%edx
     1ee:	f7 75 f0             	divl   0xfffffff0(%ebp)
     1f1:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
     1f4:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
     1f7:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
     1fa:	eb 07                	jmp    203 <SKBStat_dump+0x5e>
     1fc:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
     203:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
     206:	89 44 24 14          	mov    %eax,0x14(%esp,1)
     20a:	8b 45 08             	mov    0x8(%ebp),%eax
     20d:	8b 40 10             	mov    0x10(%eax),%eax
     210:	89 44 24 10          	mov    %eax,0x10(%esp,1)
     214:	8b 45 08             	mov    0x8(%ebp),%eax
     217:	8b 50 04             	mov    0x4(%eax),%edx
     21a:	8b 00                	mov    (%eax),%eax
     21c:	0f ac d0 04          	shrd   $0x4,%edx,%eax
     220:	c1 ea 04             	shr    $0x4,%edx
     223:	85 c0                	test   %eax,%eax
     225:	74 3e                	je     265 <SKBStat_dump+0xc0>
     227:	8b 45 08             	mov    0x8(%ebp),%eax
     22a:	8b 50 0c             	mov    0xc(%eax),%edx
     22d:	8b 40 08             	mov    0x8(%eax),%eax
     230:	0f ac d0 04          	shrd   $0x4,%edx,%eax
     234:	c1 ea 04             	shr    $0x4,%edx
     237:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
     23a:	8b 45 08             	mov    0x8(%ebp),%eax
     23d:	8b 50 04             	mov    0x4(%eax),%edx
     240:	8b 00                	mov    (%eax),%eax
     242:	0f ac d0 04          	shrd   $0x4,%edx,%eax
     246:	c1 ea 04             	shr    $0x4,%edx
     249:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
     24c:	89 55 f4             	mov    %edx,0xfffffff4(%ebp)
     24f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
     252:	ba 00 00 00 00       	mov    $0x0,%edx
     257:	f7 75 f0             	divl   0xfffffff0(%ebp)
     25a:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
     25d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
     260:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
     263:	eb 07                	jmp    26c <SKBStat_dump+0xc7>
     265:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
     26c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
     26f:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
     273:	8b 45 08             	mov    0x8(%ebp),%eax
     276:	8b 40 08             	mov    0x8(%eax),%eax
     279:	89 44 24 08          	mov    %eax,0x8(%esp,1)
     27d:	8b 45 08             	mov    0x8(%ebp),%eax
     280:	8b 00                	mov    (%eax),%eax
     282:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     286:	c7 04 24 c0 00 00 00 	movl   $0xc0,(%esp,1)
     28d:	e8 fc ff ff ff       	call   28e <SKBStat_dump+0xe9>
	       (__u32) sstat->count, 
	       (__u32) sstat->totalBytes, (__u32) SAFEAVG(sstat->totalBytes, sstat->count), 
	       (__u32) sstat->totalOverheadBytes, (__u32) SAFEAVG(sstat->totalOverheadBytes, sstat->count));
}
     292:	c9                   	leave  
     293:	c3                   	ret    

00000294 <mem_dump>:
	RECORD_MISSINGDATAMAP_INSERTION_HELPER((REQ)->start, (REQ)->end)

//#define FINDUC_DBG

void mem_dump(char *start, int len) {
     294:	55                   	push   %ebp
     295:	89 e5                	mov    %esp,%ebp
     297:	83 ec 0c             	sub    $0xc,%esp
	int i;
	for(i=0; i < len; i++) {
     29a:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
     2a1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
     2a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
     2a7:	7c 02                	jl     2ab <mem_dump+0x17>
     2a9:	eb 74                	jmp    31f <mem_dump+0x8b>
		if(i > 0 && i % 8 == 0) {
     2ab:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
     2af:	7e 16                	jle    2c7 <mem_dump+0x33>
     2b1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
     2b4:	83 e0 07             	and    $0x7,%eax
     2b7:	85 c0                	test   %eax,%eax
     2b9:	75 0c                	jne    2c7 <mem_dump+0x33>
			printk(" - ");
     2bb:	c7 04 24 fb 00 00 00 	movl   $0xfb,(%esp,1)
     2c2:	e8 fc ff ff ff       	call   2c3 <mem_dump+0x2f>
		}
		printk("%.2x ", start[i]);
     2c7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
     2ca:	03 45 08             	add    0x8(%ebp),%eax
     2cd:	0f be 00             	movsbl (%eax),%eax
     2d0:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     2d4:	c7 04 24 ff 00 00 00 	movl   $0xff,(%esp,1)
     2db:	e8 fc ff ff ff       	call   2dc <mem_dump+0x48>
		if(i > 0 && i % 72 == 0) {
     2e0:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
     2e4:	7e 32                	jle    318 <mem_dump+0x84>
     2e6:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
     2e9:	b8 39 8e e3 38       	mov    $0x38e38e39,%eax
     2ee:	f7 e9                	imul   %ecx
     2f0:	c1 fa 04             	sar    $0x4,%edx
     2f3:	89 c8                	mov    %ecx,%eax
     2f5:	c1 f8 1f             	sar    $0x1f,%eax
     2f8:	29 c2                	sub    %eax,%edx
     2fa:	89 d0                	mov    %edx,%eax
     2fc:	c1 e0 03             	shl    $0x3,%eax
     2ff:	01 d0                	add    %edx,%eax
     301:	c1 e0 03             	shl    $0x3,%eax
     304:	29 c1                	sub    %eax,%ecx
     306:	89 c8                	mov    %ecx,%eax
     308:	85 c0                	test   %eax,%eax
     30a:	75 0c                	jne    318 <mem_dump+0x84>
			printk("\n");
     30c:	c7 04 24 05 01 00 00 	movl   $0x105,(%esp,1)
     313:	e8 fc ff ff ff       	call   314 <mem_dump+0x80>
     318:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
     31b:	ff 00                	incl   (%eax)
     31d:	eb 82                	jmp    2a1 <mem_dump+0xd>
		}
	}
}
     31f:	c9                   	leave  
     320:	c3                   	ret    

00000321 <kmalloc_ConversionRequest>:

int total_csum_bytes = 0;
static int csum_complete_user_count = 0;
static int gNumNomemEvents = 0;
int gNumSetUCont = 0;
int gNumSendv = 0;
int gNumSendbulk = 0;
int gNumSendbulkDesc = 0;

int gUpdateSincePollTotal = 0;
int gUpdateSincePollCount = 0;
int gInvalidReqnum = 0;
int gNumSlowstart = 0;
int gNumRecovery = 0;

__u64 gTotalTimeoutInterval = 0;
int gTotalTimeoutCount = 0;

int gNumRecoveryStates = 0;
int gNumBootstrapStates = 0;
int gNumBootstrapResponses = 0;

static inline void record_delay(int delay) {
	gTotalTimeoutInterval += delay;
	gTotalTimeoutCount++;
}

const int dbgBadChunk = 0;

struct SKBStat gOuterSKBStat, gNoDataSKBStat, gReceivedSKBStat;
struct histogram a_histogram, d_histogram, timeout_histogram;

#define SAVE_ESTIMATOR_STATS(SK)				\
	({ struct tcp_opt *_tp = &(SK)->tp_pinfo.af_tcp;	\
		hist_addPoint(&a_histogram, _tp->t.A);		\
		hist_addPoint(&d_histogram, _tp->t.D);		\
	})

#define SAVE_DELAY_STATS(SK)				\
	({ struct tcp_opt *_tp = &(SK)->tp_pinfo.af_tcp;	\
		hist_addPoint(&timeout_histogram, _tp->t.RTO);		\
	})


int gNumReceivedBytes, gNumUncopiedBytes;
#define NUM_OVERLAPPED (8)
struct {
	int count;
	int total;
	int lineNum;
} gNumOverlapped[NUM_OVERLAPPED];

#define RECORD_OVERLAP(X,Y) do { gNumOverlapped[X].count++; gNumOverlapped[X].total += (Y); gNumOverlapped[X].lineNum = __LINE__; } while(0)

#define RECORD_NOMEM() do { gNumNomemEvents++; } while(0)

static inline int skb_can_put(struct sk_buff *skb, int amt) {
	return skb->tail + amt <= skb->end;
}

#ifdef USERTEST
static inline int addOfoSkb(struct sk_buff *skb) {
	return 1;
}

static inline  void delOfoSkb(struct sk_buff *skb) {
	return;
}

void zap_virt(void *address) {
}
#else

// xxx HACK TO ALLOW > 2000 clients
// The memory allocation scheme results in bursts of memory
atomic_t ofoBufSize = ATOMIC_INIT(0);

// maximum of 256 mb allowed in ofo queue
#define OFO_BUF_LIMIT (256 * 1024 * 1024)
static inline int addOfoSkb(struct sk_buff *skb) {
	if(atomic_read(&ofoBufSize) > OFO_BUF_LIMIT) {
#if 0
		if(trickles_ratelimit())
			printk("%d > ofo limit\n", atomic_read(&ofoBufSize));
#endif
		return 0;
	}
	atomic_add(skb->end - skb->head,&ofoBufSize);
	return 1;
}

static inline  void delOfoSkb(struct sk_buff *skb) {
	atomic_sub(skb->end - skb->head,&ofoBufSize);
}
#endif // USERTEST

// 0425 debug variables to determine goodput
__u64 numRxPackets = 0;
__u64 numRxBytes = 0;
__u64 numRxOverhead = 0;

// 0418 debug variables
int numDataRequestMappings;

int numContinuations;

#if 0
#define MARK_PC(CONT) (CONT)->mark |= (__LINE__) << 18
#else
#define MARK_PC(CONT)
#endif

static inline void unlinkCont(CONTINUATION_TYPE *cont) {
	unlink((struct alloc_head*)cont);
}

#if 0
#define CHECK_IF_ZEROREQUEST(REQ) CHECK_IF_ZEROREQUEST_helper(REQ, __LINE__)
void CHECK_IF_ZEROREQUEST_helper(struct Request *req, int lineno) {
	if(req->type == MREQ_CONVERSION && ) {
		xxx code not don;
	}
}
#else
#define CHECK_IF_ZEROREQUEST(REQ)
#endif

#ifdef DO_INTEGRITY_CHECK
void INTEGRITY_CHECK(struct sock *sk, struct cminisock *msk) {
	return;
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	struct cminisock *ptr;
	int found = 0;

	if(msk->list != &tp->t.cont_list) {
		BUG();
	}
	alloc_head_walk(&tp->t.cont_list, ptr) {
		if(ptr == msk) {
			found = 1;
			break;
		}
	}
	if(!found) BUG();
}
#else
#define INTEGRITY_CHECK(X,Y)
#endif // DO_INTEGRITY_CHECK

#ifdef SAVE_APHIST
#define SAVE_ACK_PREV(TP) { save_ack_prev(TP, __LINE__); }

void save_ack_prev(struct tcp_opt *tp, int lineno) {
	int pos = tp->t.aphistpos;
	if(tp->t.ack_prev != 0) {
		tp->t.aphist[pos] = *tp->t.ack_prev;
	} else {
		memset(&tp->t.aphist[pos], 0xff, sizeof(tp->t.aphist[pos]));
	}
	tp->t.aphist[pos].mark |= (lineno & 0x3fff) << 2;
	pos = (pos + 1) % ACK_PREV_HISTORY_ENTRIES;
	tp->t.aphistpos = pos;
}
#else
#define SAVE_ACK_PREV(TP)
#endif // SAVE_APHIST


static int numConversionRequests = 0;

static int sendAckHelper(struct sock *sk, CONTINUATION_TYPE *cont, enum TrickleRequestType type);

struct ConversionRequest *kmalloc_ConversionRequest(int gfp) {
     321:	55                   	push   %ebp
     322:	89 e5                	mov    %esp,%ebp
     324:	83 ec 08             	sub    $0x8,%esp
	numConversionRequests++;
     327:	ff 05 68 00 00 00    	incl   0x68
	return kmalloc(sizeof(struct ConversionRequest), gfp);
     32d:	8b 45 08             	mov    0x8(%ebp),%eax
     330:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     334:	c7 04 24 68 00 00 00 	movl   $0x68,(%esp,1)
     33b:	e8 fc ff ff ff       	call   33c <kmalloc_ConversionRequest+0x1b>
}
     340:	c9                   	leave  
     341:	c3                   	ret    

00000342 <kmalloc_ContinuationRequest>:

int numContinuationRequests = 0;

struct ContinuationRequest *kmalloc_ContinuationRequest(int gfp) {
     342:	55                   	push   %ebp
     343:	89 e5                	mov    %esp,%ebp
     345:	83 ec 08             	sub    $0x8,%esp
	numContinuationRequests++;
     348:	ff 05 00 00 00 00    	incl   0x0
	return kmalloc(sizeof(struct ContinuationRequest), gfp);
     34e:	8b 45 08             	mov    0x8(%ebp),%eax
     351:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     355:	c7 04 24 5c 00 00 00 	movl   $0x5c,(%esp,1)
     35c:	e8 fc ff ff ff       	call   35d <kmalloc_ContinuationRequest+0x1b>
}
     361:	c9                   	leave  
     362:	c3                   	ret    

00000363 <trickles_add_clientsock>:

#ifdef USE_FLOATINGPOINT
// FSAVE/FRESTORE areas to support use of FPU in bottom half
static char fpu_user_save[NR_CPUS][512];
static char fpu_kernel_save[NR_CPUS][512];

// Based on code from asm-i386/xor.h
#define FPU_SAVE(X)							\
  do {									\
	if (!(current->flags & PF_USEDFPU)) {				\
		__asm__ __volatile__ (" clts;\n");			\
	} else 								\
  		__asm__ __volatile__ ("fsave %0; fwait": "=m"((X)[0]));	\
  } while (0)

#define FPU_RESTORE(X)							\
  do {									\
	if (!(current->flags & PF_USEDFPU)) {				\
		stts();							\
	} else 								\
		__asm__ __volatile__ ("frstor %0": : "m"((X)[0]));	\
  } while (0)
#endif // USE_FLOATINGPOINT

#ifndef USERTEST
struct proto trickles_client_prot;

spinlock_t trickles_sockets_head_lock = SPIN_LOCK_UNLOCKED;
struct sock trickles_sockets_head;

void trickles_add_clientsock(struct sock *sk) {
     363:	55                   	push   %ebp
     364:	89 e5                	mov    %esp,%ebp
     366:	83 ec 08             	sub    $0x8,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
     369:	8b 45 08             	mov    0x8(%ebp),%eax
     36c:	05 bc 00 00 00       	add    $0xbc,%eax
     371:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	struct tcp_opt *htp = &trickles_sockets_head.tp_pinfo.af_tcp;
     374:	c7 45 f8 bc 00 00 00 	movl   $0xbc,0xfffffff8(%ebp)
	spin_lock(&trickles_sockets_head_lock);
	tp->t.dnext = htp->t.dnext;
     37b:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
     37e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
     381:	8b 80 28 09 00 00    	mov    0x928(%eax),%eax
     387:	89 82 28 09 00 00    	mov    %eax,0x928(%edx)
	htp->t.dnext = sk;
     38d:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
     390:	8b 45 08             	mov    0x8(%ebp),%eax
     393:	89 82 28 09 00 00    	mov    %eax,0x928(%edx)
	tp->t.dprev = &trickles_sockets_head;
     399:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
     39c:	c7 80 24 09 00 00 00 	movl   $0x0,0x924(%eax)
     3a3:	00 00 00 
	tp->t.dnext->tp_pinfo.af_tcp.t.dprev = sk;
     3a6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
     3a9:	8b 90 28 09 00 00    	mov    0x928(%eax),%edx
     3af:	8b 45 08             	mov    0x8(%ebp),%eax
     3b2:	89 82 e0 09 00 00    	mov    %eax,0x9e0(%edx)
	spin_unlock(&trickles_sockets_head_lock);
}
     3b8:	c9                   	leave  
     3b9:	c3                   	ret    

000003ba <trickles_del_clientsock>:

void trickles_del_clientsock(struct sock *sk) {
     3ba:	55                   	push   %ebp
     3bb:	89 e5                	mov    %esp,%ebp
     3bd:	83 ec 0c             	sub    $0xc,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
     3c0:	8b 45 08             	mov    0x8(%ebp),%eax
     3c3:	05 bc 00 00 00       	add    $0xbc,%eax
     3c8:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	if(tp->t.dprev == NULL) {
     3cb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
     3ce:	83 b8 24 09 00 00 00 	cmpl   $0x0,0x924(%eax)
     3d5:	75 31                	jne    408 <trickles_del_clientsock+0x4e>
		BUG_TRAP(tp->t.dnext != NULL);
     3d7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
     3da:	83 b8 28 09 00 00 00 	cmpl   $0x0,0x928(%eax)
     3e1:	75 14                	jne    3f7 <trickles_del_clientsock+0x3d>
     3e3:	c7 44 24 04 2a 01 00 	movl   $0x12a,0x4(%esp,1)
     3ea:	00 
     3eb:	c7 04 24 20 01 00 00 	movl   $0x120,(%esp,1)
     3f2:	e8 fc ff ff ff       	call   3f3 <trickles_del_clientsock+0x39>
		printk("Socket not on clientsock list\n");
     3f7:	c7 04 24 80 01 00 00 	movl   $0x180,(%esp,1)
     3fe:	e8 fc ff ff ff       	call   3ff <trickles_del_clientsock+0x45>
		return;
     403:	e9 9a 00 00 00       	jmp    4a2 <trickles_del_clientsock+0xe8>
	}
	spin_lock(&trickles_sockets_head_lock);
	BUG_TRAP(tp->t.dprev->tp_pinfo.af_tcp.t.dnext == sk);
     408:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
     40b:	8b 80 24 09 00 00    	mov    0x924(%eax),%eax
     411:	8b 80 e4 09 00 00    	mov    0x9e4(%eax),%eax
     417:	3b 45 08             	cmp    0x8(%ebp),%eax
     41a:	74 14                	je     430 <trickles_del_clientsock+0x76>
     41c:	c7 44 24 04 2f 01 00 	movl   $0x12f,0x4(%esp,1)
     423:	00 
     424:	c7 04 24 a0 01 00 00 	movl   $0x1a0,(%esp,1)
     42b:	e8 fc ff ff ff       	call   42c <trickles_del_clientsock+0x72>
	BUG_TRAP(tp->t.dnext->tp_pinfo.af_tcp.t.dprev == sk);
     430:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
     433:	8b 80 28 09 00 00    	mov    0x928(%eax),%eax
     439:	8b 80 e0 09 00 00    	mov    0x9e0(%eax),%eax
     43f:	3b 45 08             	cmp    0x8(%ebp),%eax
     442:	74 14                	je     458 <trickles_del_clientsock+0x9e>
     444:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp,1)
     44b:	00 
     44c:	c7 04 24 00 02 00 00 	movl   $0x200,(%esp,1)
     453:	e8 fc ff ff ff       	call   454 <trickles_del_clientsock+0x9a>
	tp->t.dprev->tp_pinfo.af_tcp.t.dnext = tp->t.dnext;
     458:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
     45b:	8b 90 24 09 00 00    	mov    0x924(%eax),%edx
     461:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
     464:	8b 80 28 09 00 00    	mov    0x928(%eax),%eax
     46a:	89 82 e4 09 00 00    	mov    %eax,0x9e4(%edx)
	tp->t.dnext->tp_pinfo.af_tcp.t.dprev = tp->t.dprev;
     470:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
     473:	8b 90 28 09 00 00    	mov    0x928(%eax),%edx
     479:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
     47c:	8b 80 24 09 00 00    	mov    0x924(%eax),%eax
     482:	89 82 e0 09 00 00    	mov    %eax,0x9e0(%edx)

	tp->t.dprev = tp->t.dnext = NULL;
     488:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
     48b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
     48e:	c7 80 28 09 00 00 00 	movl   $0x0,0x928(%eax)
     495:	00 00 00 
     498:	c7 82 24 09 00 00 00 	movl   $0x0,0x924(%edx)
     49f:	00 00 00 
	spin_unlock(&trickles_sockets_head_lock);
}
     4a2:	c9                   	leave  
     4a3:	c3                   	ret    

000004a4 <trickles_kfree_skb>:
#endif

#define SKB_CONTAINS(SKB, SEQ) \
	((TCP_SKB_CB(SKB)->seq <= (SEQ)) && (TCP_SKB_CB(SKB)->end_seq > (SEQ)))

static inline void trickles_kfree_skb(struct sk_buff *skb) {
     4a4:	55                   	push   %ebp
     4a5:	89 e5                	mov    %esp,%ebp
     4a7:	53                   	push   %ebx
     4a8:	83 ec 20             	sub    $0x20,%esp
	if(TCP_SKB_CB(skb)->cont) {
     4ab:	8b 45 08             	mov    0x8(%ebp),%eax
     4ae:	83 c0 30             	add    $0x30,%eax
     4b1:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
     4b5:	74 11                	je     4c8 <trickles_kfree_skb+0x24>
		// 0810 - used to be a straight kfree
		freeClientSide_Continuation(TCP_SKB_CB(skb)->cont);
     4b7:	8b 45 08             	mov    0x8(%ebp),%eax
     4ba:	83 c0 30             	add    $0x30,%eax
     4bd:	8b 40 2c             	mov    0x2c(%eax),%eax
     4c0:	89 04 24             	mov    %eax,(%esp,1)
     4c3:	e8 67 9b 00 00       	call   a02f <freeClientSide_Continuation>
	}
	int i;
	for(i=0; i < TCP_SKB_CB(skb)->numDataChunks-1; i++) {
     4c8:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
     4cf:	8b 45 08             	mov    0x8(%ebp),%eax
     4d2:	83 c0 30             	add    $0x30,%eax
     4d5:	8b 40 34             	mov    0x34(%eax),%eax
     4d8:	48                   	dec    %eax
     4d9:	39 45 f8             	cmp    %eax,0xfffffff8(%ebp)
     4dc:	7c 05                	jl     4e3 <trickles_kfree_skb+0x3f>
     4de:	e9 e5 00 00 00       	jmp    5c8 <trickles_kfree_skb+0x124>
		struct sk_buff **pskb = GET_CHUNK(skb,i);
     4e3:	8b 45 08             	mov    0x8(%ebp),%eax
     4e6:	83 c0 30             	add    $0x30,%eax
     4e9:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
     4ec:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
     4f0:	78 08                	js     4fa <trickles_kfree_skb+0x56>
     4f2:	83 7d f8 31          	cmpl   $0x31,0xfffffff8(%ebp)
     4f6:	7f 02                	jg     4fa <trickles_kfree_skb+0x56>
     4f8:	eb 25                	jmp    51f <trickles_kfree_skb+0x7b>
     4fa:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
     501:	00 
     502:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
     509:	e8 fc ff ff ff       	call   50a <trickles_kfree_skb+0x66>
     50e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
     515:	e8 fc ff ff ff       	call   516 <trickles_kfree_skb+0x72>
     51a:	e8 fc ff ff ff       	call   51b <trickles_kfree_skb+0x77>
     51f:	83 7d f8 04          	cmpl   $0x4,0xfffffff8(%ebp)
     523:	7f 11                	jg     536 <trickles_kfree_skb+0x92>
     525:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
     528:	c1 e0 02             	shl    $0x2,%eax
     52b:	03 45 ec             	add    0xffffffec(%ebp),%eax
     52e:	83 c0 38             	add    $0x38,%eax
     531:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
     534:	eb 6d                	jmp    5a3 <trickles_kfree_skb+0xff>
     536:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
     539:	83 78 4c 00          	cmpl   $0x0,0x4c(%eax)
     53d:	75 52                	jne    591 <trickles_kfree_skb+0xed>
     53f:	c7 45 e8 2d 00 00 00 	movl   $0x2d,0xffffffe8(%ebp)
     546:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
     549:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
     550:	00 
     551:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
     554:	c1 e0 02             	shl    $0x2,%eax
     557:	89 04 24             	mov    %eax,(%esp,1)
     55a:	e8 fc ff ff ff       	call   55b <trickles_kfree_skb+0xb7>
     55f:	89 43 4c             	mov    %eax,0x4c(%ebx)
     562:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
     569:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
     56c:	3b 45 e8             	cmp    0xffffffe8(%ebp),%eax
     56f:	7c 02                	jl     573 <trickles_kfree_skb+0xcf>
     571:	eb 1e                	jmp    591 <trickles_kfree_skb+0xed>
     573:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
     576:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
     579:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
     580:	8b 41 4c             	mov    0x4c(%ecx),%eax
     583:	c7 04 10 00 00 00 00 	movl   $0x0,(%eax,%edx,1)
     58a:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
     58d:	ff 00                	incl   (%eax)
     58f:	eb d8                	jmp    569 <trickles_kfree_skb+0xc5>
     591:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
     594:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
     597:	c1 e0 02             	shl    $0x2,%eax
     59a:	03 42 4c             	add    0x4c(%edx),%eax
     59d:	83 e8 14             	sub    $0x14,%eax
     5a0:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
     5a3:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
     5a6:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		if(*pskb != NULL) {
     5a9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
     5ac:	83 38 00             	cmpl   $0x0,(%eax)
     5af:	74 0d                	je     5be <trickles_kfree_skb+0x11a>
			trickles_kfree_skb(*pskb);
     5b1:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
     5b4:	8b 00                	mov    (%eax),%eax
     5b6:	89 04 24             	mov    %eax,(%esp,1)
     5b9:	e8 e6 fe ff ff       	call   4a4 <trickles_kfree_skb>
     5be:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
     5c1:	ff 00                	incl   (%eax)
     5c3:	e9 07 ff ff ff       	jmp    4cf <trickles_kfree_skb+0x2b>
			if(0 && trickles_ratelimit())
				printk("Freeing undetached skb\n");
		}
	}
	if(TCP_SKB_CB(skb)->chunksOverflow != NULL) {
     5c8:	8b 45 08             	mov    0x8(%ebp),%eax
     5cb:	83 c0 30             	add    $0x30,%eax
     5ce:	83 78 4c 00          	cmpl   $0x0,0x4c(%eax)
     5d2:	74 11                	je     5e5 <trickles_kfree_skb+0x141>
		kfree(TCP_SKB_CB(skb)->chunksOverflow);
     5d4:	8b 45 08             	mov    0x8(%ebp),%eax
     5d7:	83 c0 30             	add    $0x30,%eax
     5da:	8b 40 4c             	mov    0x4c(%eax),%eax
     5dd:	89 04 24             	mov    %eax,(%esp,1)
     5e0:	e8 fc ff ff ff       	call   5e1 <trickles_kfree_skb+0x13d>
	}
	__kfree_skb(skb);
     5e5:	8b 45 08             	mov    0x8(%ebp),%eax
     5e8:	89 04 24             	mov    %eax,(%esp,1)
     5eb:	e8 fc ff ff ff       	call   5ec <trickles_kfree_skb+0x148>
 }
     5f0:	83 c4 20             	add    $0x20,%esp
     5f3:	5b                   	pop    %ebx
     5f4:	5d                   	pop    %ebp
     5f5:	c3                   	ret    

000005f6 <dump_global_stats>:

static void dump_global_stats(void) {
     5f6:	55                   	push   %ebp
     5f7:	89 e5                	mov    %esp,%ebp
     5f9:	83 ec 58             	sub    $0x58,%esp
	printk("numRxPackets = %llu, numRxBytes = %llu, avgRxPacketSize = %d, avgRxOverhead = %d, numTxPackets = %llu, numTxBytes = %llu, avgTxPacketSize = %d\n",
     5fc:	a1 00 00 00 00       	mov    0x0,%eax
     601:	8b 15 04 00 00 00    	mov    0x4,%edx
     607:	0f ac d0 04          	shrd   $0x4,%edx,%eax
     60b:	c1 ea 04             	shr    $0x4,%edx
     60e:	85 c0                	test   %eax,%eax
     610:	74 43                	je     655 <dump_global_stats+0x5f>
     612:	a1 00 00 00 00       	mov    0x0,%eax
     617:	8b 15 04 00 00 00    	mov    0x4,%edx
     61d:	0f ac d0 04          	shrd   $0x4,%edx,%eax
     621:	c1 ea 04             	shr    $0x4,%edx
     624:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
     627:	a1 00 00 00 00       	mov    0x0,%eax
     62c:	8b 15 04 00 00 00    	mov    0x4,%edx
     632:	0f ac d0 04          	shrd   $0x4,%edx,%eax
     636:	c1 ea 04             	shr    $0x4,%edx
     639:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
     63c:	89 55 dc             	mov    %edx,0xffffffdc(%ebp)
     63f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
     642:	ba 00 00 00 00       	mov    $0x0,%edx
     647:	f7 75 d8             	divl   0xffffffd8(%ebp)
     64a:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
     64d:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
     650:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
     653:	eb 07                	jmp    65c <dump_global_stats+0x66>
     655:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
     65c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
     65f:	89 44 24 2c          	mov    %eax,0x2c(%esp,1)
     663:	a1 00 00 00 00       	mov    0x0,%eax
     668:	8b 15 04 00 00 00    	mov    0x4,%edx
     66e:	89 44 24 24          	mov    %eax,0x24(%esp,1)
     672:	89 54 24 28          	mov    %edx,0x28(%esp,1)
     676:	a1 00 00 00 00       	mov    0x0,%eax
     67b:	8b 15 04 00 00 00    	mov    0x4,%edx
     681:	89 44 24 1c          	mov    %eax,0x1c(%esp,1)
     685:	89 54 24 20          	mov    %edx,0x20(%esp,1)
     689:	a1 00 00 00 00       	mov    0x0,%eax
     68e:	8b 15 04 00 00 00    	mov    0x4,%edx
     694:	0f ac d0 04          	shrd   $0x4,%edx,%eax
     698:	c1 ea 04             	shr    $0x4,%edx
     69b:	85 c0                	test   %eax,%eax
     69d:	74 43                	je     6e2 <dump_global_stats+0xec>
     69f:	a1 00 00 00 00       	mov    0x0,%eax
     6a4:	8b 15 04 00 00 00    	mov    0x4,%edx
     6aa:	0f ac d0 04          	shrd   $0x4,%edx,%eax
     6ae:	c1 ea 04             	shr    $0x4,%edx
     6b1:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
     6b4:	a1 00 00 00 00       	mov    0x0,%eax
     6b9:	8b 15 04 00 00 00    	mov    0x4,%edx
     6bf:	0f ac d0 04          	shrd   $0x4,%edx,%eax
     6c3:	c1 ea 04             	shr    $0x4,%edx
     6c6:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
     6c9:	89 55 dc             	mov    %edx,0xffffffdc(%ebp)
     6cc:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
     6cf:	ba 00 00 00 00       	mov    $0x0,%edx
     6d4:	f7 75 d8             	divl   0xffffffd8(%ebp)
     6d7:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
     6da:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
     6dd:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
     6e0:	eb 07                	jmp    6e9 <dump_global_stats+0xf3>
     6e2:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
     6e9:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
     6ec:	89 44 24 18          	mov    %eax,0x18(%esp,1)
     6f0:	a1 00 00 00 00       	mov    0x0,%eax
     6f5:	8b 15 04 00 00 00    	mov    0x4,%edx
     6fb:	0f ac d0 04          	shrd   $0x4,%edx,%eax
     6ff:	c1 ea 04             	shr    $0x4,%edx
     702:	85 c0                	test   %eax,%eax
     704:	74 43                	je     749 <dump_global_stats+0x153>
     706:	a1 00 00 00 00       	mov    0x0,%eax
     70b:	8b 15 04 00 00 00    	mov    0x4,%edx
     711:	0f ac d0 04          	shrd   $0x4,%edx,%eax
     715:	c1 ea 04             	shr    $0x4,%edx
     718:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
     71b:	a1 00 00 00 00       	mov    0x0,%eax
     720:	8b 15 04 00 00 00    	mov    0x4,%edx
     726:	0f ac d0 04          	shrd   $0x4,%edx,%eax
     72a:	c1 ea 04             	shr    $0x4,%edx
     72d:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
     730:	89 55 dc             	mov    %edx,0xffffffdc(%ebp)
     733:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
     736:	ba 00 00 00 00       	mov    $0x0,%edx
     73b:	f7 75 d8             	divl   0xffffffd8(%ebp)
     73e:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
     741:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
     744:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
     747:	eb 07                	jmp    750 <dump_global_stats+0x15a>
     749:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
     750:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
     753:	89 44 24 14          	mov    %eax,0x14(%esp,1)
     757:	a1 00 00 00 00       	mov    0x0,%eax
     75c:	8b 15 04 00 00 00    	mov    0x4,%edx
     762:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
     766:	89 54 24 10          	mov    %edx,0x10(%esp,1)
     76a:	a1 00 00 00 00       	mov    0x0,%eax
     76f:	8b 15 04 00 00 00    	mov    0x4,%edx
     775:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     779:	89 54 24 08          	mov    %edx,0x8(%esp,1)
     77d:	c7 04 24 60 02 00 00 	movl   $0x260,(%esp,1)
     784:	e8 fc ff ff ff       	call   785 <dump_global_stats+0x18f>
	       numRxPackets, numRxBytes, (__u32)(numRxPackets >> 4) ? (__u32)(numRxBytes >> 4) / (__u32)(numRxPackets >> 4) : 0,
	       (__u32)(numRxPackets >> 4) ? (__u32)(numRxOverhead >> 4) / (__u32)(numRxPackets >> 4) : 0,
	       numTxPackets, numTxBytes, (__u32)(numTxPackets >> 4) ? (__u32)(numTxBytes >> 4) / (__u32)(numTxPackets >> 4) : 0);
	numRxPackets = numRxBytes = numTxPackets = numTxBytes = 0;
     789:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
     790:	00 00 00 
     793:	c7 05 04 00 00 00 00 	movl   $0x0,0x4
     79a:	00 00 00 
     79d:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
     7a4:	00 00 00 
     7a7:	c7 05 04 00 00 00 00 	movl   $0x0,0x4
     7ae:	00 00 00 
     7b1:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
     7b8:	00 00 00 
     7bb:	c7 05 04 00 00 00 00 	movl   $0x0,0x4
     7c2:	00 00 00 
     7c5:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
     7cc:	00 00 00 
     7cf:	c7 05 04 00 00 00 00 	movl   $0x0,0x4
     7d6:	00 00 00 

	printk("Number of no memory events: %d\n", gNumNomemEvents);
     7d9:	a1 08 00 00 00       	mov    0x8,%eax
     7de:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     7e2:	c7 04 24 00 03 00 00 	movl   $0x300,(%esp,1)
     7e9:	e8 fc ff ff ff       	call   7ea <dump_global_stats+0x1f4>
	printk("Number of csum bytes %d, ", total_csum_bytes);
     7ee:	a1 00 00 00 00       	mov    0x0,%eax
     7f3:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     7f7:	c7 04 24 20 03 00 00 	movl   $0x320,(%esp,1)
     7fe:	e8 fc ff ff ff       	call   7ff <dump_global_stats+0x209>
	printk("TCP Complete count %d, ", csum_complete_user_count);
     803:	a1 04 00 00 00       	mov    0x4,%eax
     808:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     80c:	c7 04 24 3a 03 00 00 	movl   $0x33a,(%esp,1)
     813:	e8 fc ff ff ff       	call   814 <dump_global_stats+0x21e>
	printk("setucont %d, sendv %d\n", gNumSetUCont, gNumSendv);
     818:	a1 00 00 00 00       	mov    0x0,%eax
     81d:	89 44 24 08          	mov    %eax,0x8(%esp,1)
     821:	a1 00 00 00 00       	mov    0x0,%eax
     826:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     82a:	c7 04 24 52 03 00 00 	movl   $0x352,(%esp,1)
     831:	e8 fc ff ff ff       	call   832 <dump_global_stats+0x23c>
	printk("Num of sendbulk: %d, descs: %d\n", gNumSendbulk, gNumSendbulkDesc);
     836:	a1 00 00 00 00       	mov    0x0,%eax
     83b:	89 44 24 08          	mov    %eax,0x8(%esp,1)
     83f:	a1 00 00 00 00       	mov    0x0,%eax
     844:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     848:	c7 04 24 80 03 00 00 	movl   $0x380,(%esp,1)
     84f:	e8 fc ff ff ff       	call   850 <dump_global_stats+0x25a>
	printk("Average updates per poll %d (%d/%d)\n",
     854:	a1 00 00 00 00       	mov    0x0,%eax
     859:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
     85d:	a1 00 00 00 00       	mov    0x0,%eax
     862:	89 44 24 08          	mov    %eax,0x8(%esp,1)
     866:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
     86d:	74 11                	je     880 <dump_global_stats+0x28a>
     86f:	a1 00 00 00 00       	mov    0x0,%eax
     874:	99                   	cltd   
     875:	f7 3d 00 00 00 00    	idivl  0x0
     87b:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
     87e:	eb 07                	jmp    887 <dump_global_stats+0x291>
     880:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
     887:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
     88a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     88e:	c7 04 24 a0 03 00 00 	movl   $0x3a0,(%esp,1)
     895:	e8 fc ff ff ff       	call   896 <dump_global_stats+0x2a0>
	       gUpdateSincePollCount ?
	       gUpdateSincePollTotal / gUpdateSincePollCount : -1,
	       gUpdateSincePollTotal, gUpdateSincePollCount);
	printk("Invalid reqnum %d\n", gInvalidReqnum);
     89a:	a1 00 00 00 00       	mov    0x0,%eax
     89f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     8a3:	c7 04 24 c5 03 00 00 	movl   $0x3c5,(%esp,1)
     8aa:	e8 fc ff ff ff       	call   8ab <dump_global_stats+0x2b5>
	printk("NumSlowstart %d\n", gNumSlowstart);
     8af:	a1 00 00 00 00       	mov    0x0,%eax
     8b4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     8b8:	c7 04 24 d8 03 00 00 	movl   $0x3d8,(%esp,1)
     8bf:	e8 fc ff ff ff       	call   8c0 <dump_global_stats+0x2ca>
	printk("NumRecovery %d\n", gNumRecovery);
     8c4:	a1 00 00 00 00       	mov    0x0,%eax
     8c9:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     8cd:	c7 04 24 e9 03 00 00 	movl   $0x3e9,(%esp,1)
     8d4:	e8 fc ff ff ff       	call   8d5 <dump_global_stats+0x2df>

	printk("Outer skb stat: "); SKBStat_dump(&gOuterSKBStat);
     8d9:	c7 04 24 f9 03 00 00 	movl   $0x3f9,(%esp,1)
     8e0:	e8 fc ff ff ff       	call   8e1 <dump_global_stats+0x2eb>
     8e5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
     8ec:	e8 fc ff ff ff       	call   8ed <dump_global_stats+0x2f7>
	printk("NoData skb stat: "); SKBStat_dump(&gNoDataSKBStat);
     8f1:	c7 04 24 0a 04 00 00 	movl   $0x40a,(%esp,1)
     8f8:	e8 fc ff ff ff       	call   8f9 <dump_global_stats+0x303>
     8fd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
     904:	e8 fc ff ff ff       	call   905 <dump_global_stats+0x30f>
	printk("Received skb stat: "); SKBStat_dump(&gReceivedSKBStat);
     909:	c7 04 24 1c 04 00 00 	movl   $0x41c,(%esp,1)
     910:	e8 fc ff ff ff       	call   911 <dump_global_stats+0x31b>
     915:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
     91c:	e8 fc ff ff ff       	call   91d <dump_global_stats+0x327>
	printk("Num received bytes: %d\n", gNumReceivedBytes);
     921:	a1 00 00 00 00       	mov    0x0,%eax
     926:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     92a:	c7 04 24 30 04 00 00 	movl   $0x430,(%esp,1)
     931:	e8 fc ff ff ff       	call   932 <dump_global_stats+0x33c>
	printk("Num uncopied bytes: %d\n", gNumUncopiedBytes);
     936:	a1 00 00 00 00       	mov    0x0,%eax
     93b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     93f:	c7 04 24 48 04 00 00 	movl   $0x448,(%esp,1)
     946:	e8 fc ff ff ff       	call   947 <dump_global_stats+0x351>
	//hist_dump(&a_histogram);
	//hist_dump(&d_histogram);
	//hist_dump(&timeout_histogram);

	int i;
	int overlappedTotal = 0;
     94b:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
	for(i=0; i < NUM_OVERLAPPED; i++) {
     952:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
     959:	83 7d fc 07          	cmpl   $0x7,0xfffffffc(%ebp)
     95d:	7e 05                	jle    964 <dump_global_stats+0x36e>
     95f:	e9 dc 00 00 00       	jmp    a40 <dump_global_stats+0x44a>
		printk("Overlapped[lineno=%d] = %d / %d = %d\n", gNumOverlapped[i].lineNum,
     964:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
     967:	89 d0                	mov    %edx,%eax
     969:	01 c0                	add    %eax,%eax
     96b:	01 d0                	add    %edx,%eax
     96d:	c1 e0 02             	shl    $0x2,%eax
     970:	8b 80 00 00 00 00    	mov    0x0(%eax),%eax
     976:	c1 f8 04             	sar    $0x4,%eax
     979:	85 c0                	test   %eax,%eax
     97b:	74 46                	je     9c3 <dump_global_stats+0x3cd>
     97d:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
     980:	89 d0                	mov    %edx,%eax
     982:	01 c0                	add    %eax,%eax
     984:	01 d0                	add    %edx,%eax
     986:	c1 e0 02             	shl    $0x2,%eax
     989:	8b 80 04 00 00 00    	mov    0x4(%eax),%eax
     98f:	c1 f8 04             	sar    $0x4,%eax
     992:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
     995:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
     998:	89 d0                	mov    %edx,%eax
     99a:	01 c0                	add    %eax,%eax
     99c:	01 d0                	add    %edx,%eax
     99e:	c1 e0 02             	shl    $0x2,%eax
     9a1:	8b 80 00 00 00 00    	mov    0x0(%eax),%eax
     9a7:	c1 f8 04             	sar    $0x4,%eax
     9aa:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
     9ad:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
     9b0:	ba 00 00 00 00       	mov    $0x0,%edx
     9b5:	f7 75 d8             	divl   0xffffffd8(%ebp)
     9b8:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
     9bb:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
     9be:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
     9c1:	eb 07                	jmp    9ca <dump_global_stats+0x3d4>
     9c3:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
     9ca:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
     9cd:	89 44 24 10          	mov    %eax,0x10(%esp,1)
     9d1:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
     9d4:	89 d0                	mov    %edx,%eax
     9d6:	01 c0                	add    %eax,%eax
     9d8:	01 d0                	add    %edx,%eax
     9da:	c1 e0 02             	shl    $0x2,%eax
     9dd:	8b 80 00 00 00 00    	mov    0x0(%eax),%eax
     9e3:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
     9e7:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
     9ea:	89 d0                	mov    %edx,%eax
     9ec:	01 c0                	add    %eax,%eax
     9ee:	01 d0                	add    %edx,%eax
     9f0:	c1 e0 02             	shl    $0x2,%eax
     9f3:	8b 80 04 00 00 00    	mov    0x4(%eax),%eax
     9f9:	89 44 24 08          	mov    %eax,0x8(%esp,1)
     9fd:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
     a00:	89 d0                	mov    %edx,%eax
     a02:	01 c0                	add    %eax,%eax
     a04:	01 d0                	add    %edx,%eax
     a06:	c1 e0 02             	shl    $0x2,%eax
     a09:	8b 80 08 00 00 00    	mov    0x8(%eax),%eax
     a0f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     a13:	c7 04 24 60 04 00 00 	movl   $0x460,(%esp,1)
     a1a:	e8 fc ff ff ff       	call   a1b <dump_global_stats+0x425>
		       gNumOverlapped[i].total, gNumOverlapped[i].count,
		       SAFEAVG(gNumOverlapped[i].total, gNumOverlapped[i].count));
		overlappedTotal += gNumOverlapped[i].total;
     a1f:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
     a22:	89 d0                	mov    %edx,%eax
     a24:	01 c0                	add    %eax,%eax
     a26:	01 d0                	add    %edx,%eax
     a28:	c1 e0 02             	shl    $0x2,%eax
     a2b:	8b 90 04 00 00 00    	mov    0x4(%eax),%edx
     a31:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
     a34:	01 10                	add    %edx,(%eax)
     a36:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
     a39:	ff 00                	incl   (%eax)
     a3b:	e9 19 ff ff ff       	jmp    959 <dump_global_stats+0x363>
	}
	printk("Total overlap total = %d\n", overlappedTotal);
     a40:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
     a43:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     a47:	c7 04 24 86 04 00 00 	movl   $0x486,(%esp,1)
     a4e:	e8 fc ff ff ff       	call   a4f <dump_global_stats+0x459>

	printk("Delay updates: avg=%d (cnt=%d)\n", SAFEAVG(gTotalTimeoutInterval, gTotalTimeoutCount),
     a53:	a1 00 00 00 00       	mov    0x0,%eax
     a58:	89 44 24 08          	mov    %eax,0x8(%esp,1)
     a5c:	a1 00 00 00 00       	mov    0x0,%eax
     a61:	c1 f8 04             	sar    $0x4,%eax
     a64:	85 c0                	test   %eax,%eax
     a66:	74 36                	je     a9e <dump_global_stats+0x4a8>
     a68:	a1 00 00 00 00       	mov    0x0,%eax
     a6d:	8b 15 04 00 00 00    	mov    0x4,%edx
     a73:	0f ac d0 04          	shrd   $0x4,%edx,%eax
     a77:	c1 ea 04             	shr    $0x4,%edx
     a7a:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
     a7d:	a1 00 00 00 00       	mov    0x0,%eax
     a82:	c1 f8 04             	sar    $0x4,%eax
     a85:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
     a88:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
     a8b:	ba 00 00 00 00       	mov    $0x0,%edx
     a90:	f7 75 d8             	divl   0xffffffd8(%ebp)
     a93:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
     a96:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
     a99:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
     a9c:	eb 07                	jmp    aa5 <dump_global_stats+0x4af>
     a9e:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
     aa5:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
     aa8:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     aac:	c7 04 24 a0 04 00 00 	movl   $0x4a0,(%esp,1)
     ab3:	e8 fc ff ff ff       	call   ab4 <dump_global_stats+0x4be>
	       gTotalTimeoutCount);
	printk("NumRecoveryStates = %d\n", gNumRecoveryStates);
     ab8:	a1 00 00 00 00       	mov    0x0,%eax
     abd:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     ac1:	c7 04 24 c0 04 00 00 	movl   $0x4c0,(%esp,1)
     ac8:	e8 fc ff ff ff       	call   ac9 <dump_global_stats+0x4d3>
	printk("NumBootstrapStates = %d\n", gNumBootstrapStates);
     acd:	a1 00 00 00 00       	mov    0x0,%eax
     ad2:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     ad6:	c7 04 24 d8 04 00 00 	movl   $0x4d8,(%esp,1)
     add:	e8 fc ff ff ff       	call   ade <dump_global_stats+0x4e8>
	printk("NumBootstrapResponses = %d\n", gNumBootstrapResponses);
     ae2:	a1 00 00 00 00       	mov    0x0,%eax
     ae7:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     aeb:	c7 04 24 f1 04 00 00 	movl   $0x4f1,(%esp,1)
     af2:	e8 fc ff ff ff       	call   af3 <dump_global_stats+0x4fd>
}
     af7:	c9                   	leave  
     af8:	c3                   	ret    

00000af9 <hmac_setup>:

#define requestReleasedData(X) // XXX Deprecated!

/* Simple random number generator */

static unsigned long rand;

static inline unsigned char random(void) {
  /* See "Numerical Recipes in C", second edition, p. 284 */
  rand = rand * 1664525L + 1013904223L;
  return (unsigned char) (rand >> 24);
}

/*
 * Crypto support
 */

#define generateHMAC_VAL (1)
#define generateNonces_VAL (1)

const int generateHMAC = generateHMAC_VAL;
const int generateNonces = generateNonces_VAL;

// hack to give gcc more information about constants
#define generateHMAC (generateHMAC_VAL)
#define generateNonces (generateNonces_VAL)


// Debugging control
int enableDataRecovery = 1;
int serverDebugLevel = 0;
int debugDrops = 0;
int debugTransitions = 0;

#define PRINT_TRANSITION(SK, S)						\
({ struct sock *_sk = (SK);						\
   struct tcp_opt *_tp = &_sk->tp_pinfo.af_tcp;				\
   printk("%p: %s data rcv_nxt = %d t.rcv_nxt = %d\n", _sk, (S), _tp->rcv_nxt, _tp->t.rcv_nxt); })

int debugProofDrops = 1;
int clientDebugLevel = 0;
//#define SPEW_PARTIAL
int disableSevereErrors = 1;
int printOverlap = 0;
int disableTimeout = 0;

#ifdef OPENSSL_HMAC

void hmac_setup(HMAC_CTX *ctx, char *key, int len) {
     af9:	55                   	push   %ebp
     afa:	89 e5                	mov    %esp,%ebp
     afc:	83 ec 50             	sub    $0x50,%esp
  BUG_TRAP(len <= HMAC_BLOCKSIZE);
     aff:	83 7d 10 40          	cmpl   $0x40,0x10(%ebp)
     b03:	7e 14                	jle    b19 <hmac_setup+0x20>
     b05:	c7 44 24 04 ae 01 00 	movl   $0x1ae,0x4(%esp,1)
     b0c:	00 
     b0d:	c7 04 24 20 05 00 00 	movl   $0x520,(%esp,1)
     b14:	e8 fc ff ff ff       	call   b15 <hmac_setup+0x1c>
  memset(ctx->key, 0, HMAC_BLOCKSIZE);
     b19:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp,1)
     b20:	00 
     b21:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
     b28:	00 
     b29:	8b 45 08             	mov    0x8(%ebp),%eax
     b2c:	89 04 24             	mov    %eax,(%esp,1)
     b2f:	e8 1d 81 00 00       	call   8c51 <__constant_c_and_count_memset>
  memcpy(ctx->key, key, len);
     b34:	8b 45 10             	mov    0x10(%ebp),%eax
     b37:	89 44 24 08          	mov    %eax,0x8(%esp,1)
     b3b:	8b 45 0c             	mov    0xc(%ebp),%eax
     b3e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     b42:	8b 45 08             	mov    0x8(%ebp),%eax
     b45:	89 04 24             	mov    %eax,(%esp,1)
     b48:	e8 c5 80 00 00       	call   8c12 <__memcpy>

  int i;
  char pad[HMAC_BLOCKSIZE];

  for (i=0; i<HMAC_BLOCKSIZE; i++)
     b4d:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
     b54:	83 7d fc 3f          	cmpl   $0x3f,0xfffffffc(%ebp)
     b58:	7e 02                	jle    b5c <hmac_setup+0x63>
     b5a:	eb 1d                	jmp    b79 <hmac_setup+0x80>
    pad[i]=0x36^ctx->key[i];
     b5c:	8d 45 bc             	lea    0xffffffbc(%ebp),%eax
     b5f:	89 c1                	mov    %eax,%ecx
     b61:	03 4d fc             	add    0xfffffffc(%ebp),%ecx
     b64:	8b 55 08             	mov    0x8(%ebp),%edx
     b67:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
     b6a:	0f b6 04 10          	movzbl (%eax,%edx,1),%eax
     b6e:	34 36                	xor    $0x36,%al
     b70:	88 01                	mov    %al,(%ecx)
     b72:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
     b75:	ff 00                	incl   (%eax)
     b77:	eb db                	jmp    b54 <hmac_setup+0x5b>
  DIGEST_Init(&ctx->in_ctx);
     b79:	8b 45 08             	mov    0x8(%ebp),%eax
     b7c:	83 c0 40             	add    $0x40,%eax
     b7f:	89 04 24             	mov    %eax,(%esp,1)
     b82:	e8 fc ff ff ff       	call   b83 <hmac_setup+0x8a>
  DIGEST_Update(&ctx->in_ctx, pad, HMAC_BLOCKSIZE);
     b87:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp,1)
     b8e:	00 
     b8f:	8d 45 bc             	lea    0xffffffbc(%ebp),%eax
     b92:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     b96:	8b 45 08             	mov    0x8(%ebp),%eax
     b99:	83 c0 40             	add    $0x40,%eax
     b9c:	89 04 24             	mov    %eax,(%esp,1)
     b9f:	e8 fc ff ff ff       	call   ba0 <hmac_setup+0xa7>

  for (i=0; i<HMAC_BLOCKSIZE; i++)
     ba4:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
     bab:	83 7d fc 3f          	cmpl   $0x3f,0xfffffffc(%ebp)
     baf:	7e 02                	jle    bb3 <hmac_setup+0xba>
     bb1:	eb 1d                	jmp    bd0 <hmac_setup+0xd7>
    pad[i]=0x5c^ctx->key[i];
     bb3:	8d 45 bc             	lea    0xffffffbc(%ebp),%eax
     bb6:	89 c1                	mov    %eax,%ecx
     bb8:	03 4d fc             	add    0xfffffffc(%ebp),%ecx
     bbb:	8b 55 08             	mov    0x8(%ebp),%edx
     bbe:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
     bc1:	0f b6 04 10          	movzbl (%eax,%edx,1),%eax
     bc5:	34 5c                	xor    $0x5c,%al
     bc7:	88 01                	mov    %al,(%ecx)
     bc9:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
     bcc:	ff 00                	incl   (%eax)
     bce:	eb db                	jmp    bab <hmac_setup+0xb2>
  DIGEST_Init(&ctx->out_ctx);
     bd0:	8b 45 08             	mov    0x8(%ebp),%eax
     bd3:	05 9c 00 00 00       	add    $0x9c,%eax
     bd8:	89 04 24             	mov    %eax,(%esp,1)
     bdb:	e8 fc ff ff ff       	call   bdc <hmac_setup+0xe3>
  DIGEST_Update(&ctx->out_ctx, pad, HMAC_BLOCKSIZE);
     be0:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp,1)
     be7:	00 
     be8:	8d 45 bc             	lea    0xffffffbc(%ebp),%eax
     beb:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     bef:	8b 45 08             	mov    0x8(%ebp),%eax
     bf2:	05 9c 00 00 00       	add    $0x9c,%eax
     bf7:	89 04 24             	mov    %eax,(%esp,1)
     bfa:	e8 fc ff ff ff       	call   bfb <hmac_setup+0x102>
}
     bff:	c9                   	leave  
     c00:	c3                   	ret    

00000c01 <hmac_init>:

void hmac_init(HMAC_CTX *ctx) {
     c01:	55                   	push   %ebp
     c02:	89 e5                	mov    %esp,%ebp
     c04:	57                   	push   %edi
     c05:	56                   	push   %esi
  ctx->digest_ctx = ctx->in_ctx;
     c06:	8b 45 08             	mov    0x8(%ebp),%eax
     c09:	8b 55 08             	mov    0x8(%ebp),%edx
     c0c:	8d b8 f8 00 00 00    	lea    0xf8(%eax),%edi
     c12:	8d 72 40             	lea    0x40(%edx),%esi
     c15:	b8 5c 00 00 00       	mov    $0x5c,%eax
     c1a:	fc                   	cld    
     c1b:	89 c1                	mov    %eax,%ecx
     c1d:	c1 e9 02             	shr    $0x2,%ecx
     c20:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
  ctx->len = 0;
     c22:	8b 45 08             	mov    0x8(%ebp),%eax
     c25:	c7 80 54 01 00 00 00 	movl   $0x0,0x154(%eax)
     c2c:	00 00 00 
}
     c2f:	5e                   	pop    %esi
     c30:	5f                   	pop    %edi
     c31:	5d                   	pop    %ebp
     c32:	c3                   	ret    

00000c33 <hmac_update>:

void hmac_update(HMAC_CTX *ctx, void *data, int len) {
     c33:	55                   	push   %ebp
     c34:	89 e5                	mov    %esp,%ebp
     c36:	83 ec 0c             	sub    $0xc,%esp
  DIGEST_Update(&ctx->digest_ctx, data, len);
     c39:	8b 45 10             	mov    0x10(%ebp),%eax
     c3c:	89 44 24 08          	mov    %eax,0x8(%esp,1)
     c40:	8b 45 0c             	mov    0xc(%ebp),%eax
     c43:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     c47:	8b 45 08             	mov    0x8(%ebp),%eax
     c4a:	05 f8 00 00 00       	add    $0xf8,%eax
     c4f:	89 04 24             	mov    %eax,(%esp,1)
     c52:	e8 fc ff ff ff       	call   c53 <hmac_update+0x20>
  ctx->len += len;
     c57:	8b 4d 08             	mov    0x8(%ebp),%ecx
     c5a:	8b 55 08             	mov    0x8(%ebp),%edx
     c5d:	8b 45 10             	mov    0x10(%ebp),%eax
     c60:	03 82 54 01 00 00    	add    0x154(%edx),%eax
     c66:	89 81 54 01 00 00    	mov    %eax,0x154(%ecx)
  //printk("hmac'ed %d\n", len);
}
     c6c:	c9                   	leave  
     c6d:	c3                   	ret    

00000c6e <hmac_final>:

void hmac_final(HMAC_CTX *ctx, char *output) {
     c6e:	55                   	push   %ebp
     c6f:	89 e5                	mov    %esp,%ebp
     c71:	57                   	push   %edi
     c72:	56                   	push   %esi
     c73:	83 ec 4c             	sub    $0x4c,%esp
  char buf[HMAC_BLOCKSIZE];
  DIGEST_Final(buf, &ctx->digest_ctx);
     c76:	8b 45 08             	mov    0x8(%ebp),%eax
     c79:	05 f8 00 00 00       	add    $0xf8,%eax
     c7e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     c82:	8d 45 b8             	lea    0xffffffb8(%ebp),%eax
     c85:	89 04 24             	mov    %eax,(%esp,1)
     c88:	e8 fc ff ff ff       	call   c89 <hmac_final+0x1b>
  ctx->digest_ctx = ctx->out_ctx;
     c8d:	8b 45 08             	mov    0x8(%ebp),%eax
     c90:	8b 55 08             	mov    0x8(%ebp),%edx
     c93:	8d b8 f8 00 00 00    	lea    0xf8(%eax),%edi
     c99:	8d b2 9c 00 00 00    	lea    0x9c(%edx),%esi
     c9f:	b8 5c 00 00 00       	mov    $0x5c,%eax
     ca4:	fc                   	cld    
     ca5:	89 c1                	mov    %eax,%ecx
     ca7:	c1 e9 02             	shr    $0x2,%ecx
     caa:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
  DIGEST_Update(&ctx->digest_ctx, buf, HMACLEN);
     cac:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp,1)
     cb3:	00 
     cb4:	8d 45 b8             	lea    0xffffffb8(%ebp),%eax
     cb7:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     cbb:	8b 45 08             	mov    0x8(%ebp),%eax
     cbe:	05 f8 00 00 00       	add    $0xf8,%eax
     cc3:	89 04 24             	mov    %eax,(%esp,1)
     cc6:	e8 fc ff ff ff       	call   cc7 <hmac_final+0x59>
  DIGEST_Final(output, &ctx->digest_ctx);
     ccb:	8b 45 08             	mov    0x8(%ebp),%eax
     cce:	05 f8 00 00 00       	add    $0xf8,%eax
     cd3:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     cd7:	8b 45 0c             	mov    0xc(%ebp),%eax
     cda:	89 04 24             	mov    %eax,(%esp,1)
     cdd:	e8 fc ff ff ff       	call   cde <hmac_final+0x70>
}
     ce2:	83 c4 4c             	add    $0x4c,%esp
     ce5:	5e                   	pop    %esi
     ce6:	5f                   	pop    %edi
     ce7:	5d                   	pop    %ebp
     ce8:	c3                   	ret    

00000ce9 <computeMAC>:

#endif // OPENSSL_HMAC

/* NONCE uses AES */

void computeMAC(struct sock *sk, PseudoHeader *phdr, const WireContinuation *cont, char *dest) {
     ce9:	55                   	push   %ebp
     cea:	89 e5                	mov    %esp,%ebp
     cec:	83 ec 14             	sub    $0x14,%esp
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
     cef:	8b 45 08             	mov    0x8(%ebp),%eax
     cf2:	05 bc 00 00 00       	add    $0xbc,%eax
     cf7:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	if(generateHMAC) {
#ifdef OPENSSL_HMAC
		HMAC_CTX *ctx = tp->t.hmacCTX;
     cfa:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
     cfd:	8b 80 28 0a 00 00    	mov    0xa28(%eax),%eax
     d03:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
#ifdef DISABLE_SADDR_HMAC
		phdr->serverAddr = 0;
     d06:	8b 45 0c             	mov    0xc(%ebp),%eax
     d09:	c7 40 06 00 00 00 00 	movl   $0x0,0x6(%eax)
#endif
		hmac_init(ctx);
     d10:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
     d13:	89 04 24             	mov    %eax,(%esp,1)
     d16:	e8 fc ff ff ff       	call   d17 <computeMAC+0x2e>
		hmac_update(ctx, (char*)phdr, HMAC_PHEADER_LEN);
     d1b:	c7 44 24 08 12 00 00 	movl   $0x12,0x8(%esp,1)
     d22:	00 
     d23:	8b 45 0c             	mov    0xc(%ebp),%eax
     d26:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     d2a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
     d2d:	89 04 24             	mov    %eax,(%esp,1)
     d30:	e8 fc ff ff ff       	call   d31 <computeMAC+0x48>
		hmac_update(ctx, (char*)cont->hmac_start, WIRECONT_MAC_LEN);
     d35:	c7 44 24 08 25 00 00 	movl   $0x25,0x8(%esp,1)
     d3c:	00 
     d3d:	8b 45 10             	mov    0x10(%ebp),%eax
     d40:	83 c0 25             	add    $0x25,%eax
     d43:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     d47:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
     d4a:	89 04 24             	mov    %eax,(%esp,1)
     d4d:	e8 fc ff ff ff       	call   d4e <computeMAC+0x65>
		hmac_final(ctx, dest);
     d52:	8b 45 14             	mov    0x14(%ebp),%eax
     d55:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     d59:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
     d5c:	89 04 24             	mov    %eax,(%esp,1)
     d5f:	e8 fc ff ff ff       	call   d60 <computeMAC+0x77>
#if 0
		printk("Hmac input\n");
		int position = hexdump((char*)phdr, HMAC_PHEADER_LEN);
		hexdump_helper((char*)cont->hmac_start,
			       WIRECONT_MAC_LEN, position);
		printk("\n");
		printk("Hmac output\n");
		hexdump((char*)dest, HMACLEN);
		printk("\n");
#endif
#else
#error "not implemented"
		// improve parallelism by making local copy
		hmac_sha(tp->t.hmacKey, HMACLEN,
			 (char*)cont->hmac_start - HMAC_PHEADER_LEN, WIRECONT_MAC_LEN,
			 dest, HMACLEN);
#endif
	} else {
		memset(dest, 0, HMACLEN);
	}
}
     d64:	c9                   	leave  
     d65:	c3                   	ret    

00000d66 <generateRangeNonce>:
#define NUM_NONCES_PER_BLOCK (NONCE_BLOCKSIZE / sizeof(__u32))

static inline
__u32 generateCryptoRangeNonceHelper(aes_encrypt_ctx *ctx, __u64 seqNumLeft, __u64 seqNumRight) {
	int i;
	__u64 nums[2] = {seqNumLeft, seqNumRight+1};
	__u64 oldNum = -1;
	__u32 nonce = 0;
	char nonce_out[NONCE_BLOCKSIZE];

	for(i=0; i < 2; i++) {
		__u64 number = nums[i] / NUM_NONCES_PER_BLOCK;
		int offset = nums[i] % NUM_NONCES_PER_BLOCK;
		char nonce_in[NONCE_BLOCKSIZE];
		if(i > 0 && oldNum == number) {
			goto skip_generation;
		}
		memset(nonce_in, 0, NONCE_BLOCKSIZE);
		*((__u64*)nonce_in) = number;
		aes_encrypt(nonce_in, nonce_out, ctx);
	skip_generation:
		nonce ^= ((__u32*)nonce_out)[offset];
		oldNum = number;
	}
	return nonce;
}

__u32 generateRangeNonce(struct sock *sk, __u64 seqNumLeft, __u64 seqNumRight) {
     d66:	55                   	push   %ebp
     d67:	89 e5                	mov    %esp,%ebp
     d69:	83 ec 4c             	sub    $0x4c,%esp
     d6c:	8b 45 0c             	mov    0xc(%ebp),%eax
     d6f:	8b 55 10             	mov    0x10(%ebp),%edx
     d72:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
     d75:	89 55 fc             	mov    %edx,0xfffffffc(%ebp)
     d78:	8b 45 14             	mov    0x14(%ebp),%eax
     d7b:	8b 55 18             	mov    0x18(%ebp),%edx
     d7e:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
     d81:	89 55 f4             	mov    %edx,0xfffffff4(%ebp)
	if(SIMULATION_MODE(sk)) {
     d84:	8b 45 08             	mov    0x8(%ebp),%eax
     d87:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
     d8d:	83 e0 01             	and    $0x1,%eax
     d90:	85 c0                	test   %eax,%eax
     d92:	74 56                	je     dea <generateRangeNonce+0x84>
     d94:	8b 55 08             	mov    0x8(%ebp),%edx
     d97:	8b 45 08             	mov    0x8(%ebp),%eax
     d9a:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
     da0:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
     da6:	83 e0 08             	and    $0x8,%eax
     da9:	85 c0                	test   %eax,%eax
     dab:	75 3d                	jne    dea <generateRangeNonce+0x84>
		BUG_TRAP(!SIMULATION_MODE(sk));
     dad:	8b 45 08             	mov    0x8(%ebp),%eax
     db0:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
     db6:	83 e0 01             	and    $0x1,%eax
     db9:	85 c0                	test   %eax,%eax
     dbb:	74 2d                	je     dea <generateRangeNonce+0x84>
     dbd:	8b 55 08             	mov    0x8(%ebp),%edx
     dc0:	8b 45 08             	mov    0x8(%ebp),%eax
     dc3:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
     dc9:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
     dcf:	83 e0 08             	and    $0x8,%eax
     dd2:	85 c0                	test   %eax,%eax
     dd4:	75 14                	jne    dea <generateRangeNonce+0x84>
     dd6:	c7 44 24 04 15 02 00 	movl   $0x215,0x4(%esp,1)
     ddd:	00 
     dde:	c7 04 24 80 05 00 00 	movl   $0x580,(%esp,1)
     de5:	e8 fc ff ff ff       	call   de6 <generateRangeNonce+0x80>
	}
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
     dea:	8b 45 08             	mov    0x8(%ebp),%eax
     ded:	05 bc 00 00 00       	add    $0xbc,%eax
     df2:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	int myGenerateNonces = generateNonces && !SIMULATION_MODE(sk);
     df5:	c7 45 c8 00 00 00 00 	movl   $0x0,0xffffffc8(%ebp)
     dfc:	8b 45 08             	mov    0x8(%ebp),%eax
     dff:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
     e05:	83 e0 01             	and    $0x1,%eax
     e08:	85 c0                	test   %eax,%eax
     e0a:	74 1b                	je     e27 <generateRangeNonce+0xc1>
     e0c:	8b 55 08             	mov    0x8(%ebp),%edx
     e0f:	8b 45 08             	mov    0x8(%ebp),%eax
     e12:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
     e18:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
     e1e:	83 e0 08             	and    $0x8,%eax
     e21:	85 c0                	test   %eax,%eax
     e23:	75 02                	jne    e27 <generateRangeNonce+0xc1>
     e25:	eb 07                	jmp    e2e <generateRangeNonce+0xc8>
     e27:	c7 45 c8 01 00 00 00 	movl   $0x1,0xffffffc8(%ebp)
     e2e:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
     e31:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
	if(myGenerateNonces) {
     e34:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
     e38:	74 32                	je     e6c <generateRangeNonce+0x106>
		return generateCryptoRangeNonceHelper(tp->t.nonceCTX, seqNumLeft, seqNumRight);
     e3a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
     e3d:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
     e40:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
     e44:	89 54 24 10          	mov    %edx,0x10(%esp,1)
     e48:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
     e4b:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
     e4e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     e52:	89 54 24 08          	mov    %edx,0x8(%esp,1)
     e56:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
     e59:	8b 80 3c 0a 00 00    	mov    0xa3c(%eax),%eax
     e5f:	89 04 24             	mov    %eax,(%esp,1)
     e62:	e8 ea 9d 00 00       	call   ac51 <generateCryptoRangeNonceHelper>
     e67:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
     e6a:	eb 4d                	jmp    eb9 <generateRangeNonce+0x153>
	} else {
		int i;
		__u64 nums[2] = {seqNumLeft, seqNumRight+1};
     e6c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
     e6f:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
     e72:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
     e75:	89 55 d8             	mov    %edx,0xffffffd8(%ebp)
     e78:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
     e7b:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
     e7e:	83 c0 01             	add    $0x1,%eax
     e81:	83 d2 00             	adc    $0x0,%edx
     e84:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
     e87:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
		__u32 nonce = 0;
     e8a:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
		for(i=0; i < 2; i++) {
     e91:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
     e98:	83 7d e4 01          	cmpl   $0x1,0xffffffe4(%ebp)
     e9c:	7e 02                	jle    ea0 <generateRangeNonce+0x13a>
     e9e:	eb 13                	jmp    eb3 <generateRangeNonce+0x14d>
			nonce ^= nums[i];
     ea0:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
     ea3:	8b 54 c5 d4          	mov    0xffffffd4(%ebp,%eax,8),%edx
     ea7:	8d 45 d0             	lea    0xffffffd0(%ebp),%eax
     eaa:	31 10                	xor    %edx,(%eax)
     eac:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
     eaf:	ff 00                	incl   (%eax)
     eb1:	eb e5                	jmp    e98 <generateRangeNonce+0x132>
		}
		return nonce;
     eb3:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
     eb6:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
	}
}
     eb9:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
     ebc:	c9                   	leave  
     ebd:	c3                   	ret    

00000ebe <generateSingleNonce>:

static inline
__u32 generateCryptoSingleNonceHelper(aes_encrypt_ctx *ctx, __u64 seqNum, struct NonceCtx *prevCtx) {
	__u64 number = seqNum / NUM_NONCES_PER_BLOCK;
	int offset = seqNum % NUM_NONCES_PER_BLOCK;
	char nonce_in[NONCE_BLOCKSIZE];
	char nonce_out_data[NONCE_BLOCKSIZE], *nonce_out = nonce_out_data;
	memset(nonce_in, 0, NONCE_BLOCKSIZE);
	__u32 nonce;

	if(prevCtx) {
		nonce_out = prevCtx->prevBlock;
		if(prevCtx->new) {
			prevCtx->prevNumber = number;
			prevCtx->new = 0;
		} else if(prevCtx->prevNumber == number) {
			goto skipGeneration;
		} else {
			prevCtx->prevNumber = number;
		}
	}
	*((__u64*)nonce_in) = number;

	aes_encrypt(nonce_in, nonce_out, ctx);
 skipGeneration:
	nonce = ((__u32*)nonce_out)[offset];
	if(offset == NUM_NONCES_PER_BLOCK-1) {
		number += 1;
		*((__u64*)nonce_in) = number;
		aes_encrypt(nonce_in, nonce_out, ctx);
		nonce ^= ((__u32*)nonce_out)[0];
		if(prevCtx) {
			prevCtx->prevNumber = number;
		}
	} else {
		nonce ^= ((__u32*)nonce_out)[offset + 1];
	}
	return nonce;
}

__u32 generateSingleNonce(struct sock *sk, __u64 seqNum, struct NonceCtx *prevCtx) {
     ebe:	55                   	push   %ebp
     ebf:	89 e5                	mov    %esp,%ebp
     ec1:	83 ec 28             	sub    $0x28,%esp
     ec4:	8b 45 0c             	mov    0xc(%ebp),%eax
     ec7:	8b 55 10             	mov    0x10(%ebp),%edx
     eca:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
     ecd:	89 55 fc             	mov    %edx,0xfffffffc(%ebp)
	BUG_TRAP(!SIMULATION_MODE(sk));
     ed0:	8b 45 08             	mov    0x8(%ebp),%eax
     ed3:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
     ed9:	83 e0 01             	and    $0x1,%eax
     edc:	85 c0                	test   %eax,%eax
     ede:	74 2d                	je     f0d <generateSingleNonce+0x4f>
     ee0:	8b 55 08             	mov    0x8(%ebp),%edx
     ee3:	8b 45 08             	mov    0x8(%ebp),%eax
     ee6:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
     eec:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
     ef2:	83 e0 08             	and    $0x8,%eax
     ef5:	85 c0                	test   %eax,%eax
     ef7:	75 14                	jne    f0d <generateSingleNonce+0x4f>
     ef9:	c7 44 24 04 4e 02 00 	movl   $0x24e,0x4(%esp,1)
     f00:	00 
     f01:	c7 04 24 80 05 00 00 	movl   $0x580,(%esp,1)
     f08:	e8 fc ff ff ff       	call   f09 <generateSingleNonce+0x4b>
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
     f0d:	8b 45 08             	mov    0x8(%ebp),%eax
     f10:	05 bc 00 00 00       	add    $0xbc,%eax
     f15:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	int myGenerateNonces = generateNonces && !SIMULATION_MODE(sk);
     f18:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
     f1f:	8b 45 08             	mov    0x8(%ebp),%eax
     f22:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
     f28:	83 e0 01             	and    $0x1,%eax
     f2b:	85 c0                	test   %eax,%eax
     f2d:	74 1b                	je     f4a <generateSingleNonce+0x8c>
     f2f:	8b 55 08             	mov    0x8(%ebp),%edx
     f32:	8b 45 08             	mov    0x8(%ebp),%eax
     f35:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
     f3b:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
     f41:	83 e0 08             	and    $0x8,%eax
     f44:	85 c0                	test   %eax,%eax
     f46:	75 02                	jne    f4a <generateSingleNonce+0x8c>
     f48:	eb 07                	jmp    f51 <generateSingleNonce+0x93>
     f4a:	c7 45 e8 01 00 00 00 	movl   $0x1,0xffffffe8(%ebp)
     f51:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
     f54:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

	if(myGenerateNonces) {
     f57:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
     f5b:	74 2b                	je     f88 <generateSingleNonce+0xca>
		return generateCryptoSingleNonceHelper(tp->t.nonceCTX, seqNum, prevCtx);
     f5d:	8b 45 14             	mov    0x14(%ebp),%eax
     f60:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
     f64:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
     f67:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
     f6a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     f6e:	89 54 24 08          	mov    %edx,0x8(%esp,1)
     f72:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
     f75:	8b 80 3c 0a 00 00    	mov    0xa3c(%eax),%eax
     f7b:	89 04 24             	mov    %eax,(%esp,1)
     f7e:	e8 e9 9d 00 00       	call   ad6c <generateCryptoSingleNonceHelper>
     f83:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
     f86:	eb 0c                	jmp    f94 <generateSingleNonce+0xd6>
	} else {
		return seqNum ^ (seqNum+1);
     f88:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
     f8b:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
     f8e:	42                   	inc    %edx
     f8f:	31 d0                	xor    %edx,%eax
     f91:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	}
}
     f94:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
     f97:	c9                   	leave  
     f98:	c3                   	ret    

00000f99 <__tcp_checksum_complete_user>:

#ifndef USERTEST

/* begin functions copied from tcp_input.c */
static int __tcp_checksum_complete_user(struct sock *sk, struct sk_buff *skb)
{
     f99:	55                   	push   %ebp
     f9a:	89 e5                	mov    %esp,%ebp
     f9c:	83 ec 20             	sub    $0x20,%esp
        int result;

	if(skb->ip_summed == CHECKSUM_HW) {
     f9f:	8b 45 0c             	mov    0xc(%ebp),%eax
     fa2:	80 b8 a3 00 00 00 01 	cmpb   $0x1,0xa3(%eax)
     fa9:	75 6f                	jne    101a <__tcp_checksum_complete_user+0x81>
		skb->ip_summed = CHECKSUM_UNNECESSARY;
     fab:	8b 45 0c             	mov    0xc(%ebp),%eax
     fae:	c6 80 a3 00 00 00 02 	movb   $0x2,0xa3(%eax)
		if(!tcp_v4_check(skb->h.th, skb->len, skb->nh.iph->saddr, skb->nh.iph->daddr,
     fb5:	8b 45 0c             	mov    0xc(%ebp),%eax
     fb8:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
     fbe:	89 44 24 10          	mov    %eax,0x10(%esp,1)
     fc2:	8b 45 0c             	mov    0xc(%ebp),%eax
     fc5:	8b 40 24             	mov    0x24(%eax),%eax
     fc8:	8b 40 10             	mov    0x10(%eax),%eax
     fcb:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
     fcf:	8b 45 0c             	mov    0xc(%ebp),%eax
     fd2:	8b 40 24             	mov    0x24(%eax),%eax
     fd5:	8b 40 0c             	mov    0xc(%eax),%eax
     fd8:	89 44 24 08          	mov    %eax,0x8(%esp,1)
     fdc:	8b 45 0c             	mov    0xc(%ebp),%eax
     fdf:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
     fe5:	89 44 24 04          	mov    %eax,0x4(%esp,1)
     fe9:	8b 45 0c             	mov    0xc(%ebp),%eax
     fec:	8b 40 20             	mov    0x20(%eax),%eax
     fef:	89 04 24             	mov    %eax,(%esp,1)
     ff2:	e8 48 84 00 00       	call   943f <tcp_v4_check>
     ff7:	66 85 c0             	test   %ax,%ax
     ffa:	75 09                	jne    1005 <__tcp_checksum_complete_user+0x6c>
				 skb->csum))
			return 0;
     ffc:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
    1003:	eb 66                	jmp    106b <__tcp_checksum_complete_user+0xd2>
		printk("hw tcp checksum failed\n");
    1005:	c7 04 24 c3 05 00 00 	movl   $0x5c3,(%esp,1)
    100c:	e8 fc ff ff ff       	call   100d <__tcp_checksum_complete_user+0x74>
		return -1;
    1011:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,0xfffffff4(%ebp)
    1018:	eb 51                	jmp    106b <__tcp_checksum_complete_user+0xd2>
	}
        if (sk->lock.users) {
    101a:	8b 45 08             	mov    0x8(%ebp),%eax
    101d:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
    1021:	74 34                	je     1057 <__tcp_checksum_complete_user+0xbe>
                local_bh_enable();
    1023:	c7 45 f8 08 00 00 00 	movl   $0x8,0xfffffff8(%ebp)
    102a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    102d:	ff 08                	decl   (%eax)
    102f:	83 38 00             	cmpl   $0x0,(%eax)
    1032:	75 0d                	jne    1041 <__tcp_checksum_complete_user+0xa8>
    1034:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    1037:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
    103b:	0f 85 11 b6 00 00    	jne    c652 <.text.lock.tmalloc>
                result = __tcp_checksum_complete(skb);
    1041:	8b 45 0c             	mov    0xc(%ebp),%eax
    1044:	89 04 24             	mov    %eax,(%esp,1)
    1047:	e8 27 84 00 00       	call   9473 <__tcp_checksum_complete>
    104c:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
                local_bh_disable();
    104f:	ff 05 08 00 00 00    	incl   0x8
    1055:	eb 0e                	jmp    1065 <__tcp_checksum_complete_user+0xcc>
        } else {
                result = __tcp_checksum_complete(skb);
    1057:	8b 45 0c             	mov    0xc(%ebp),%eax
    105a:	89 04 24             	mov    %eax,(%esp,1)
    105d:	e8 11 84 00 00       	call   9473 <__tcp_checksum_complete>
    1062:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
        }
        return result;
    1065:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1068:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
}
    106b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    106e:	c9                   	leave  
    106f:	c3                   	ret    

00001070 <update_rx_stats_helper>:

static __inline__ int
tcp_checksum_complete_user(struct sock *sk, struct sk_buff *skb)
{
	csum_complete_user_count++;
        return skb->ip_summed != CHECKSUM_UNNECESSARY &&
                __tcp_checksum_complete_user(sk, skb);
}

/* end functions copied from tcp_input.c */

#define update_rx_stats(IN_SKB) update_rx_stats_helper((IN_SKB), 0)
static void update_rx_stats_helper(struct sk_buff *in_skb, int print) {
    1070:	55                   	push   %ebp
    1071:	89 e5                	mov    %esp,%ebp
    1073:	83 ec 14             	sub    $0x14,%esp
	numRxPackets++;
    1076:	83 05 00 00 00 00 01 	addl   $0x1,0x0
    107d:	83 15 04 00 00 00 00 	adcl   $0x0,0x4
#if 0
	numRxBytes += in_skb->h.th->doff * 4 + in_skb->len;
#else
	numRxBytes += in_skb->len - TCP_SKB_CB(in_skb)->numDataChunks * sizeof(struct DataChunk);
    1084:	8b 4d 08             	mov    0x8(%ebp),%ecx
    1087:	8b 45 08             	mov    0x8(%ebp),%eax
    108a:	83 c0 30             	add    $0x30,%eax
    108d:	8b 50 34             	mov    0x34(%eax),%edx
    1090:	89 d0                	mov    %edx,%eax
    1092:	c1 e0 02             	shl    $0x2,%eax
    1095:	01 d0                	add    %edx,%eax
    1097:	01 c0                	add    %eax,%eax
    1099:	01 d0                	add    %edx,%eax
    109b:	8b 91 94 00 00 00    	mov    0x94(%ecx),%edx
    10a1:	29 c2                	sub    %eax,%edx
    10a3:	89 d0                	mov    %edx,%eax
    10a5:	ba 00 00 00 00       	mov    $0x0,%edx
    10aa:	01 05 00 00 00 00    	add    %eax,0x0
    10b0:	11 15 04 00 00 00    	adc    %edx,0x4
	int overhead = TCP_SKB_CB(in_skb)->numDataChunks * sizeof(struct DataChunk) + in_skb->data - in_skb->head;
    10b6:	8b 4d 08             	mov    0x8(%ebp),%ecx
    10b9:	8b 45 08             	mov    0x8(%ebp),%eax
    10bc:	83 c0 30             	add    $0x30,%eax
    10bf:	8b 50 34             	mov    0x34(%eax),%edx
    10c2:	89 d0                	mov    %edx,%eax
    10c4:	c1 e0 02             	shl    $0x2,%eax
    10c7:	01 d0                	add    %edx,%eax
    10c9:	01 c0                	add    %eax,%eax
    10cb:	01 d0                	add    %edx,%eax
    10cd:	89 c2                	mov    %eax,%edx
    10cf:	03 91 b8 00 00 00    	add    0xb8(%ecx),%edx
    10d5:	8b 45 08             	mov    0x8(%ebp),%eax
    10d8:	2b 90 b4 00 00 00    	sub    0xb4(%eax),%edx
    10de:	89 d0                	mov    %edx,%eax
    10e0:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	if(0 || print) {
    10e3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    10e7:	74 2d                	je     1116 <update_rx_stats_helper+0xa6>
		printk("len = %d overhead = %d (%d)\n", in_skb->len, overhead, TCP_SKB_CB(in_skb)->numDataChunks);
    10e9:	8b 45 08             	mov    0x8(%ebp),%eax
    10ec:	83 c0 30             	add    $0x30,%eax
    10ef:	8b 40 34             	mov    0x34(%eax),%eax
    10f2:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    10f6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    10f9:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    10fd:	8b 45 08             	mov    0x8(%ebp),%eax
    1100:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    1106:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    110a:	c7 04 24 db 05 00 00 	movl   $0x5db,(%esp,1)
    1111:	e8 fc ff ff ff       	call   1112 <update_rx_stats_helper+0xa2>
	}
	numRxOverhead += overhead;
    1116:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1119:	99                   	cltd   
    111a:	01 05 00 00 00 00    	add    %eax,0x0
    1120:	11 15 04 00 00 00    	adc    %edx,0x4
#endif
}
    1126:	c9                   	leave  
    1127:	c3                   	ret    

00001128 <trickles_rcv_impl>:

static inline void trickles_init_tcp_cb(struct sk_buff *skb) {
	TCP_SKB_CB(skb)->cont = NULL;
	TCP_SKB_CB(skb)->numDataChunks = 0;
	TCP_SKB_CB(skb)->chunksOverflow = NULL;
	TCP_SKB_CB(skb)->seq = -1;
	TCP_SKB_CB(skb)->end_seq = -1;
}

static int trickles_rcv_impl(struct sock *sk, struct sk_buff *in_skb) {
    1128:	55                   	push   %ebp
    1129:	89 e5                	mov    %esp,%ebp
    112b:	83 ec 18             	sub    $0x18,%esp
	static int count = 0;
	//printk("TricklesRcvImpl %d\n", count++);

	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    112e:	8b 45 08             	mov    0x8(%ebp),%eax
    1131:	05 bc 00 00 00       	add    $0xbc,%eax
    1136:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	trickles_init_tcp_cb(in_skb);
    1139:	8b 45 0c             	mov    0xc(%ebp),%eax
    113c:	89 04 24             	mov    %eax,(%esp,1)
    113f:	e8 c6 9d 00 00       	call   af0a <trickles_init_tcp_cb>

	if (tcp_checksum_complete_user(sk, in_skb))
    1144:	8b 45 0c             	mov    0xc(%ebp),%eax
    1147:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    114b:	8b 45 08             	mov    0x8(%ebp),%eax
    114e:	89 04 24             	mov    %eax,(%esp,1)
    1151:	e8 73 9d 00 00       	call   aec9 <tcp_checksum_complete_user>
    1156:	85 c0                	test   %eax,%eax
    1158:	74 05                	je     115f <trickles_rcv_impl+0x37>
		goto csum_error;
    115a:	e9 67 02 00 00       	jmp    13c6 <trickles_rcv_impl+0x29e>
	__skb_pull(in_skb, in_skb->h.th->doff * 4);
    115f:	8b 45 0c             	mov    0xc(%ebp),%eax
    1162:	8b 40 20             	mov    0x20(%eax),%eax
    1165:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
    1169:	c0 e8 04             	shr    $0x4,%al
    116c:	66 0f b6 c0          	movzbw %al,%ax
    1170:	0f b7 c0             	movzwl %ax,%eax
    1173:	c1 e0 02             	shl    $0x2,%eax
    1176:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    117a:	8b 45 0c             	mov    0xc(%ebp),%eax
    117d:	89 04 24             	mov    %eax,(%esp,1)
    1180:	e8 e7 7e 00 00       	call   906c <__skb_pull>

	in_skb->ip_summed = CHECKSUM_UNNECESSARY;
    1185:	8b 45 0c             	mov    0xc(%ebp),%eax
    1188:	c6 80 a3 00 00 00 02 	movb   $0x2,0xa3(%eax)
	in_skb->sk = sk;
    118f:	8b 55 0c             	mov    0xc(%ebp),%edx
    1192:	8b 45 08             	mov    0x8(%ebp),%eax
    1195:	89 42 0c             	mov    %eax,0xc(%edx)

	if(sk->tp_pinfo.af_tcp.trickles_opt & TCP_TRICKLES_RSERVER) {
    1198:	8b 45 08             	mov    0x8(%ebp),%eax
    119b:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    11a1:	83 e0 08             	and    $0x8,%eax
    11a4:	85 c0                	test   %eax,%eax
    11a6:	0f 84 d8 01 00 00    	je     1384 <trickles_rcv_impl+0x25c>
		int result;
		// First process prequeue overflow
		struct sk_buff *pre_skb;

		LOG_PACKET(sk, -in_skb->h.th->ack_seq);
		while (can_alloc_trickles_msk(sk) &&
    11ac:	8b 45 08             	mov    0x8(%ebp),%eax
    11af:	89 04 24             	mov    %eax,(%esp,1)
    11b2:	e8 07 96 00 00       	call   a7be <can_alloc_trickles_msk>
    11b7:	85 c0                	test   %eax,%eax
    11b9:	0f 84 c2 00 00 00    	je     1281 <trickles_rcv_impl+0x159>
    11bf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    11c2:	05 40 0a 00 00       	add    $0xa40,%eax
    11c7:	89 04 24             	mov    %eax,(%esp,1)
    11ca:	e8 af 7c 00 00       	call   8e7e <__skb_dequeue>
    11cf:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    11d2:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
    11d6:	75 05                	jne    11dd <trickles_rcv_impl+0xb5>
    11d8:	e9 a4 00 00 00       	jmp    1281 <trickles_rcv_impl+0x159>
		       ((pre_skb = __skb_dequeue(&tp->t.prequeueOverflow))
			!= NULL)) {
			update_rx_stats(pre_skb);
    11dd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    11e4:	00 
    11e5:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    11e8:	89 04 24             	mov    %eax,(%esp,1)
    11eb:	e8 80 fe ff ff       	call   1070 <update_rx_stats_helper>
			result = server_rcv_impl(sk, pre_skb);
    11f0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    11f3:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    11f7:	8b 45 08             	mov    0x8(%ebp),%eax
    11fa:	89 04 24             	mov    %eax,(%esp,1)
    11fd:	e8 fc ff ff ff       	call   11fe <trickles_rcv_impl+0xd6>
    1202:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
			if(result == 0 || result == -EINVAL) {
    1205:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    1209:	74 08                	je     1213 <trickles_rcv_impl+0xeb>
    120b:	83 7d f8 ea          	cmpl   $0xffffffea,0xfffffff8(%ebp)
    120f:	74 02                	je     1213 <trickles_rcv_impl+0xeb>
    1211:	eb 14                	jmp    1227 <trickles_rcv_impl+0xff>
				save_for_recycle(sk, pre_skb);
    1213:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    1216:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    121a:	8b 45 08             	mov    0x8(%ebp),%eax
    121d:	89 04 24             	mov    %eax,(%esp,1)
    1220:	e8 cb 96 00 00       	call   a8f0 <save_for_recycle>
    1225:	eb 85                	jmp    11ac <trickles_rcv_impl+0x84>
			} else {
				BUG_TRAP(result == -ENOMEM);
    1227:	83 7d f8 f4          	cmpl   $0xfffffff4,0xfffffff8(%ebp)
    122b:	74 14                	je     1241 <trickles_rcv_impl+0x119>
    122d:	c7 44 24 04 af 02 00 	movl   $0x2af,0x4(%esp,1)
    1234:	00 
    1235:	c7 04 24 00 06 00 00 	movl   $0x600,(%esp,1)
    123c:	e8 fc ff ff ff       	call   123d <trickles_rcv_impl+0x115>
				RECORD_NOMEM();
    1241:	ff 05 08 00 00 00    	incl   0x8
				__skb_queue_head(&tp->t.prequeueOverflow, pre_skb);
    1247:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    124a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    124e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1251:	05 40 0a 00 00       	add    $0xa40,%eax
    1256:	89 04 24             	mov    %eax,(%esp,1)
    1259:	e8 91 7b 00 00       	call   8def <__skb_queue_head>
				__skb_queue_tail(&tp->t.prequeueOverflow, in_skb);
    125e:	8b 45 0c             	mov    0xc(%ebp),%eax
    1261:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    1265:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1268:	05 40 0a 00 00       	add    $0xa40,%eax
    126d:	89 04 24             	mov    %eax,(%esp,1)
    1270:	e8 c1 7b 00 00       	call   8e36 <__skb_queue_tail>
				return 0;
    1275:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
    127c:	e9 58 01 00 00       	jmp    13d9 <trickles_rcv_impl+0x2b1>
			}
		}
		if(can_alloc_trickles_msk(sk)) {
    1281:	8b 45 08             	mov    0x8(%ebp),%eax
    1284:	89 04 24             	mov    %eax,(%esp,1)
    1287:	e8 32 95 00 00       	call   a7be <can_alloc_trickles_msk>
    128c:	85 c0                	test   %eax,%eax
    128e:	74 02                	je     1292 <trickles_rcv_impl+0x16a>
			goto process_first;
    1290:	eb 6a                	jmp    12fc <trickles_rcv_impl+0x1d4>
		} else {
			// XXX should defer until later
			if(tp->t.prequeueOverflow.qlen < 20000) {
    1292:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1295:	81 b8 48 0a 00 00 1f 	cmpl   $0x4e1f,0xa48(%eax)
    129c:	4e 00 00 
    129f:	77 23                	ja     12c4 <trickles_rcv_impl+0x19c>
				__skb_queue_tail(&tp->t.prequeueOverflow, in_skb);
    12a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    12a4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    12a8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    12ab:	05 40 0a 00 00       	add    $0xa40,%eax
    12b0:	89 04 24             	mov    %eax,(%esp,1)
    12b3:	e8 7e 7b 00 00       	call   8e36 <__skb_queue_tail>
				return 0;
    12b8:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
    12bf:	e9 15 01 00 00       	jmp    13d9 <trickles_rcv_impl+0x2b1>
			} else {
				return -1;
    12c4:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,0xfffffff0(%ebp)
    12cb:	e9 09 01 00 00       	jmp    13d9 <trickles_rcv_impl+0x2b1>
			}
		}
		// optimization: process the rest of the prequeue before restoring FPU context
#ifndef USERTEST
		while (can_alloc_trickles_msk(sk) &&
    12d0:	8b 45 08             	mov    0x8(%ebp),%eax
    12d3:	89 04 24             	mov    %eax,(%esp,1)
    12d6:	e8 e3 94 00 00       	call   a7be <can_alloc_trickles_msk>
    12db:	85 c0                	test   %eax,%eax
    12dd:	0f 84 98 00 00 00    	je     137b <trickles_rcv_impl+0x253>
    12e3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    12e6:	83 c0 34             	add    $0x34,%eax
    12e9:	89 04 24             	mov    %eax,(%esp,1)
    12ec:	e8 8d 7b 00 00       	call   8e7e <__skb_dequeue>
    12f1:	89 45 0c             	mov    %eax,0xc(%ebp)
    12f4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    12f8:	75 02                	jne    12fc <trickles_rcv_impl+0x1d4>
    12fa:	eb 7f                	jmp    137b <trickles_rcv_impl+0x253>
		       ((in_skb = __skb_dequeue(&tp->ucopy.prequeue))
			!= NULL)) {
#endif
		process_first:
			update_rx_stats(in_skb);
    12fc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    1303:	00 
    1304:	8b 45 0c             	mov    0xc(%ebp),%eax
    1307:	89 04 24             	mov    %eax,(%esp,1)
    130a:	e8 61 fd ff ff       	call   1070 <update_rx_stats_helper>
			result = server_rcv_impl(sk, in_skb);
    130f:	8b 45 0c             	mov    0xc(%ebp),%eax
    1312:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    1316:	8b 45 08             	mov    0x8(%ebp),%eax
    1319:	89 04 24             	mov    %eax,(%esp,1)
    131c:	e8 fc ff ff ff       	call   131d <trickles_rcv_impl+0x1f5>
    1321:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
			if(result == 0 || result == -EINVAL) {
    1324:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    1328:	74 08                	je     1332 <trickles_rcv_impl+0x20a>
    132a:	83 7d f8 ea          	cmpl   $0xffffffea,0xfffffff8(%ebp)
    132e:	74 02                	je     1332 <trickles_rcv_impl+0x20a>
    1330:	eb 14                	jmp    1346 <trickles_rcv_impl+0x21e>
				save_for_recycle(sk, in_skb);
    1332:	8b 45 0c             	mov    0xc(%ebp),%eax
    1335:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    1339:	8b 45 08             	mov    0x8(%ebp),%eax
    133c:	89 04 24             	mov    %eax,(%esp,1)
    133f:	e8 ac 95 00 00       	call   a8f0 <save_for_recycle>
    1344:	eb 8a                	jmp    12d0 <trickles_rcv_impl+0x1a8>
			} else {
				BUG_TRAP(result == -ENOMEM);
    1346:	83 7d f8 f4          	cmpl   $0xfffffff4,0xfffffff8(%ebp)
    134a:	74 14                	je     1360 <trickles_rcv_impl+0x238>
    134c:	c7 44 24 04 cd 02 00 	movl   $0x2cd,0x4(%esp,1)
    1353:	00 
    1354:	c7 04 24 00 06 00 00 	movl   $0x600,(%esp,1)
    135b:	e8 fc ff ff ff       	call   135c <trickles_rcv_impl+0x234>
				RECORD_NOMEM();
    1360:	ff 05 08 00 00 00    	incl   0x8
				__skb_queue_tail(&tp->ucopy.prequeue, in_skb);
    1366:	8b 45 0c             	mov    0xc(%ebp),%eax
    1369:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    136d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1370:	83 c0 34             	add    $0x34,%eax
    1373:	89 04 24             	mov    %eax,(%esp,1)
    1376:	e8 bb 7a 00 00       	call   8e36 <__skb_queue_tail>
				break;
			}
#ifndef USERTEST
		}
#endif
		return 0;
    137b:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
    1382:	eb 55                	jmp    13d9 <trickles_rcv_impl+0x2b1>
	} else {
		int result;

		update_rx_stats(in_skb);
    1384:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    138b:	00 
    138c:	8b 45 0c             	mov    0xc(%ebp),%eax
    138f:	89 04 24             	mov    %eax,(%esp,1)
    1392:	e8 d9 fc ff ff       	call   1070 <update_rx_stats_helper>
		//LOG_PACKET(sk, -in_skb->h.th->ack_seq);

		result = client_rcv_impl(sk, in_skb);
    1397:	8b 45 0c             	mov    0xc(%ebp),%eax
    139a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    139e:	8b 45 08             	mov    0x8(%ebp),%eax
    13a1:	89 04 24             	mov    %eax,(%esp,1)
    13a4:	e8 fc ff ff ff       	call   13a5 <trickles_rcv_impl+0x27d>
    13a9:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		if(result) {
    13ac:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
    13b0:	74 0b                	je     13bd <trickles_rcv_impl+0x295>
			__kfree_skb(in_skb);
    13b2:	8b 45 0c             	mov    0xc(%ebp),%eax
    13b5:	89 04 24             	mov    %eax,(%esp,1)
    13b8:	e8 fc ff ff ff       	call   13b9 <trickles_rcv_impl+0x291>
		}
		return 0;
    13bd:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
    13c4:	eb 13                	jmp    13d9 <trickles_rcv_impl+0x2b1>
	}
 csum_error:
	printk("CSUM error!\n");
    13c6:	c7 04 24 40 06 00 00 	movl   $0x640,(%esp,1)
    13cd:	e8 fc ff ff ff       	call   13ce <trickles_rcv_impl+0x2a6>
	return -1;
    13d2:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,0xfffffff0(%ebp)
}
    13d9:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    13dc:	c9                   	leave  
    13dd:	c3                   	ret    

000013de <resetClientTimer>:

#endif // USERTEST

/*
 *
 * Client handling
 *
 */

static int findAckables(struct sock *sk, int skip, struct sk_buff **skip_skb);
static void requestSlowStart(struct sock *sk);
static inline void client_inseq(struct sock *sk, struct sk_buff *in_skb, int noCont);

#if 1

#ifdef HIDE_PREMATURE_LOSS_DETECTION // hack to work around a shortcoming in the client:
/*
During slow start, the old data request mappings are cleared. However, not all request packets were actually lost. So already requested data will be re-requested again during slow start.

    * This assumption will be annoying to remove. It involves getting rid of the byteReq reset, and also properly clearing old dataRequestMappings
    * Life is good if I crank up timeout to 2 seconds
*/

#define MIN_SS_TIMEOUT ((HZ/2))
#else
// RFC 2988 says 1 second is a good value
//#define MIN_SS_TIMEOUT ((HZ/20))
#define MIN_SS_TIMEOUT (HZ)
#endif
// RFC 2988 says 60 second is the right value
//#define MAX_SS_TIMEOUT (3*HZ)
#define MAX_SS_TIMEOUT (60*HZ)

#else

#define MIN_SS_TIMEOUT (2*HZ)
#define MAX_SS_TIMEOUT (HZ/2)

#endif

/* slow start moderation */
void resetClientTimer(struct sock *sk) {
    13de:	55                   	push   %ebp
    13df:	89 e5                	mov    %esp,%ebp
    13e1:	83 ec 28             	sub    $0x28,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    13e4:	8b 45 08             	mov    0x8(%ebp),%eax
    13e7:	05 bc 00 00 00       	add    $0xbc,%eax
    13ec:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	unsigned long expiration = jiffies;
    13ef:	a1 00 00 00 00       	mov    0x0,%eax
    13f4:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

	if(tp->t.state == TRICKLES_CLIENT_SYNACK) {
    13f7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    13fa:	83 b8 cc 02 00 00 04 	cmpl   $0x4,0x2cc(%eax)
    1401:	75 0e                	jne    1411 <resetClientTimer+0x33>
		expiration += 2 * HZ;
    1403:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
    1406:	81 00 c8 00 00 00    	addl   $0xc8,(%eax)
    140c:	e9 b2 00 00 00       	jmp    14c3 <resetClientTimer+0xe5>
	} else {
		int timeout = MAX(RTO_IN_JIFFIES(sk), MIN_SS_TIMEOUT);
    1411:	c7 45 f0 64 00 00 00 	movl   $0x64,0xfffffff0(%ebp)
    1418:	8b 45 08             	mov    0x8(%ebp),%eax
    141b:	05 bc 00 00 00       	add    $0xbc,%eax
    1420:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    1423:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    1426:	8b 80 d8 02 00 00    	mov    0x2d8(%eax),%eax
    142c:	c1 f8 03             	sar    $0x3,%eax
    142f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    1432:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    1435:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    1438:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    143b:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    143e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    1441:	3b 45 ec             	cmp    0xffffffec(%ebp),%eax
    1444:	7d 06                	jge    144c <resetClientTimer+0x6e>
    1446:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    1449:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    144c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    144f:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		timeout = MIN(timeout, MAX_SS_TIMEOUT);
    1452:	c7 45 e8 70 17 00 00 	movl   $0x1770,0xffffffe8(%ebp)
    1459:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    145c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    145f:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    1462:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    1465:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    1468:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    146b:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    146e:	3b 45 ec             	cmp    0xffffffec(%ebp),%eax
    1471:	7e 06                	jle    1479 <resetClientTimer+0x9b>
    1473:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    1476:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    1479:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    147c:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
#ifdef RANDOMIZE_SLOWSTART_TIMER
		timeout += random() % ((HZ * 30) / 1000);
    147f:	e8 a8 97 00 00       	call   ac2c <random>
    1484:	88 c1                	mov    %al,%cl
    1486:	66 0f b6 d1          	movzbw %cl,%dx
    148a:	89 d0                	mov    %edx,%eax
    148c:	c1 e0 03             	shl    $0x3,%eax
    148f:	8d 04 10             	lea    (%eax,%edx,1),%eax
    1492:	01 c0                	add    %eax,%eax
    1494:	8d 14 02             	lea    (%edx,%eax,1),%edx
    1497:	89 d0                	mov    %edx,%eax
    1499:	c1 e0 03             	shl    $0x3,%eax
    149c:	8d 04 10             	lea    (%eax,%edx,1),%eax
    149f:	0f b7 c0             	movzwl %ax,%eax
    14a2:	c1 e8 08             	shr    $0x8,%eax
    14a5:	88 c2                	mov    %al,%dl
    14a7:	d0 ea                	shr    %dl
    14a9:	88 d0                	mov    %dl,%al
    14ab:	00 c0                	add    %al,%al
    14ad:	00 d0                	add    %dl,%al
    14af:	28 c1                	sub    %al,%cl
    14b1:	88 c8                	mov    %cl,%al
    14b3:	0f b6 d0             	movzbl %al,%edx
    14b6:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
    14b9:	01 10                	add    %edx,(%eax)
#endif

		if(0 && trickles_ratelimit()) {
			printk("new timeout %d\n", timeout);
		}

		expiration += timeout;
    14bb:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    14be:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
    14c1:	01 10                	add    %edx,(%eax)
	}
	// todo: change timeout to measured connection rtt
	if(!mod_timer(&tp->t.slowstart_timer, expiration)) {
    14c3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    14c6:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    14ca:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    14cd:	05 48 09 00 00       	add    $0x948,%eax
    14d2:	89 04 24             	mov    %eax,(%esp,1)
    14d5:	e8 fc ff ff ff       	call   14d6 <resetClientTimer+0xf8>
    14da:	85 c0                	test   %eax,%eax
    14dc:	75 0b                	jne    14e9 <resetClientTimer+0x10b>
		sock_hold(sk);
    14de:	8b 45 08             	mov    0x8(%ebp),%eax
    14e1:	89 04 24             	mov    %eax,(%esp,1)
    14e4:	e8 c3 7e 00 00       	call   93ac <sock_hold>
	}
}
    14e9:	c9                   	leave  
    14ea:	c3                   	ret    

000014eb <slow_start_timer>:

static void enterRecoveryState(struct sock *sk, int isSlowStart);
struct UC_Continuation *
findUCContinuation(struct sock *sk, unsigned start, unsigned end);

void slow_start_timer(unsigned long data) {
    14eb:	55                   	push   %ebp
    14ec:	89 e5                	mov    %esp,%ebp
    14ee:	83 ec 4c             	sub    $0x4c,%esp
	struct sock *sk = (struct sock *)data;
    14f1:	8b 45 08             	mov    0x8(%ebp),%eax
    14f4:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    14f7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    14fa:	05 bc 00 00 00       	add    $0xbc,%eax
    14ff:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	int numAcks = 0;
    1502:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
	int backedOff = 0;
    1509:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)

	record_delay(tp->t.RTO);
    1510:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    1513:	8b 80 d8 02 00 00    	mov    0x2d8(%eax),%eax
    1519:	89 04 24             	mov    %eax,(%esp,1)
    151c:	e8 66 96 00 00       	call   ab87 <record_delay>
	SAVE_DELAY_STATS(sk);
    1521:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1524:	05 bc 00 00 00       	add    $0xbc,%eax
    1529:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    152c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    152f:	8b 80 d8 02 00 00    	mov    0x2d8(%eax),%eax
    1535:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    1539:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    1540:	e8 77 95 00 00       	call   aabc <hist_addPoint>
	//printk("slow start timer 0\n");

	gNumSlowstart ++;
    1545:	ff 05 00 00 00 00    	incl   0x0
	//printk("slow start timer -2\n");
	if(0 && (clientDebugLevel >= 1 || ( 1 && gNumSlowstart % 10000 == 0) || usertest)) {
		printk("Slow start timer @ %lu, total = %d, numDataRequestMappings = %d, numContinuations = %d, numConversionRequests = %d, numContinuationRequests = %d, tp->copied_seq/rcv_nxt = %u/%u, tp->t.rcv_nxt = %u, sk = %p", jiffies, gNumSlowstart, numDataRequestMappings, numContinuations, numConversionRequests, numContinuationRequests, tp->copied_seq, tp->rcv_nxt, tp->t.rcv_nxt, sk);
		DUMP_RTO(sk);
		printk("\n");
	}
	tp->t.in_flight = 0;
    154b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    154e:	c7 80 00 03 00 00 00 	movl   $0x0,0x300(%eax)
    1555:	00 00 00 
#ifndef USERTEST
	bh_lock_sock(sk);
	if (sk->state == TCP_CLOSE)
    1558:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    155b:	0f b6 40 20          	movzbl 0x20(%eax),%eax
    155f:	3c 07                	cmp    $0x7,%al
    1561:	75 05                	jne    1568 <slow_start_timer+0x7d>
		goto out_unlock;
    1563:	e9 00 02 00 00       	jmp    1768 <slow_start_timer+0x27d>
#endif // USERTEST

	int haveRequests = !empty(&tp->t.sentRequests) || !empty(&tp->t.queuedRequests);
    1568:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
    156f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    1572:	05 84 09 00 00       	add    $0x984,%eax
    1577:	89 04 24             	mov    %eax,(%esp,1)
    157a:	e8 40 7c 00 00       	call   91bf <empty>
    157f:	85 c0                	test   %eax,%eax
    1581:	74 14                	je     1597 <slow_start_timer+0xac>
    1583:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    1586:	05 98 09 00 00       	add    $0x998,%eax
    158b:	89 04 24             	mov    %eax,(%esp,1)
    158e:	e8 2c 7c 00 00       	call   91bf <empty>
    1593:	85 c0                	test   %eax,%eax
    1595:	75 07                	jne    159e <slow_start_timer+0xb3>
    1597:	c7 45 e0 01 00 00 00 	movl   $0x1,0xffffffe0(%ebp)
    159e:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    15a1:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	//printk("Slow start timer(%p), snd_una = %d, write_seq = %d\n", sk, tp->t.snd_una, tp->t.write_seq);

	//printk("slow start timer 1\n");

	// First, try to send out any pending acks
	if((numAcks = trickles_send_ack_impl(sk, 0)) == 0) {
    15a4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    15ab:	00 
    15ac:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    15af:	89 04 24             	mov    %eax,(%esp,1)
    15b2:	e8 fc ff ff ff       	call   15b3 <slow_start_timer+0xc8>
    15b7:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    15ba:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
    15be:	0f 85 f0 00 00 00    	jne    16b4 <slow_start_timer+0x1c9>
#if 0
		printk("no acks, then %d %d %d \n",
		       tp->t.timerState & TRICKLES_ENABLE_DATA_TIMEOUT,
		       findUCContinuation(sk, tp->t.byteReqNext, tp->t.byteReqNext),
		   haveRequests);
#endif

		if((tp->t.timerState & TRICKLES_ENABLE_DATA_TIMEOUT)
    15c4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    15c7:	8b 80 dc 02 00 00    	mov    0x2dc(%eax),%eax
    15cd:	83 e0 01             	and    $0x1,%eax
    15d0:	85 c0                	test   %eax,%eax
    15d2:	75 34                	jne    1608 <slow_start_timer+0x11d>
    15d4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    15d7:	8b 80 d4 09 00 00    	mov    0x9d4(%eax),%eax
    15dd:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    15e1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    15e4:	8b 80 d4 09 00 00    	mov    0x9d4(%eax),%eax
    15ea:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    15ee:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    15f1:	89 04 24             	mov    %eax,(%esp,1)
    15f4:	e8 fc ff ff ff       	call   15f5 <slow_start_timer+0x10a>
    15f9:	85 c0                	test   %eax,%eax
    15fb:	75 0b                	jne    1608 <slow_start_timer+0x11d>
    15fd:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
    1601:	75 05                	jne    1608 <slow_start_timer+0x11d>
    1603:	e9 ac 00 00 00       	jmp    16b4 <slow_start_timer+0x1c9>
		   || findUCContinuation(sk, tp->t.byteReqNext, tp->t.byteReqNext)
		   || haveRequests) {
			//#define STRICT_BUFFER_CHECK
#ifdef STRICT_BUFFER_CHECK // 0419 - fixing extraneous slowstarts with blocked client
			// NOTE!!! POSSIBLE RACE CONDITION WITH USERSPACE SINCE WE DON'T CHECK USER LOCK
			//printk("need slowstart 1\n");
			int haveRcvBuf = tp->rcv_nxt < tp->copied_seq + sk->rcvbuf;
			printk("HaveRcvBuf = %d (%d %d)\n",
			       haveRcvBuf, tp->rcv_nxt < tp->copied_seq + sk->rcvbuf);
			if(!IS_SEND_UCONTREQ_STATE(tp) ||
			   !empty(&tp->t.sentRequests) ||   // requests we can use
			   !empty(&tp->t.queuedRequests) || //  "" ""
			   (haveRcvBuf && // have space in buffer, and usable continuation
			    findUCContinuation(sk, tp->rcv_nxt, tp->rcv_nxt))) {
#if 0
			}
#endif
#else
			//printk("test a = %d %d %d(%d,%d)\n", !IS_SEND_UCONTREQ_STATE(tp), haveRequests, findUCContinuation(sk, tp->rcv_nxt, tp->rcv_nxt), tp->rcv_nxt, tp->rcv_nxt);

			if(IMPLIES(IS_SEND_UCONTREQ_STATE(tp), haveRequests) ||
    1608:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    160b:	83 b8 cc 02 00 00 01 	cmpl   $0x1,0x2cc(%eax)
    1612:	74 18                	je     162c <slow_start_timer+0x141>
    1614:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    1617:	83 b8 cc 02 00 00 02 	cmpl   $0x2,0x2cc(%eax)
    161e:	74 0c                	je     162c <slow_start_timer+0x141>
    1620:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    1623:	83 b8 cc 02 00 00 03 	cmpl   $0x3,0x2cc(%eax)
    162a:	75 2b                	jne    1657 <slow_start_timer+0x16c>
    162c:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
    1630:	75 25                	jne    1657 <slow_start_timer+0x16c>
    1632:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    1635:	8b 40 08             	mov    0x8(%eax),%eax
    1638:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    163c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    163f:	8b 40 08             	mov    0x8(%eax),%eax
    1642:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    1646:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1649:	89 04 24             	mov    %eax,(%esp,1)
    164c:	e8 fc ff ff ff       	call   164d <slow_start_timer+0x162>
    1651:	85 c0                	test   %eax,%eax
    1653:	75 02                	jne    1657 <slow_start_timer+0x16c>
    1655:	eb 27                	jmp    167e <slow_start_timer+0x193>
			   findUCContinuation(sk, tp->rcv_nxt, tp->rcv_nxt)) {
#endif
				static int gNumSlowstart = 0;
				if(1 || (gNumSlowstart++ % 100 == 0) || clientDebugLevel >= 1) {
#if 0
					printk("Timing out @ %lu (%d times) sk = %p tp->{rcv_nxt, window} = %u/%u\n", jiffies, gNumSlowstart, sk, tp->rcv_nxt, tp->copied_seq- tp->rcv_nxt);
					printk("rtt = %u, total = %d, numDataRequestMappings = %d, numContinuations = %d, numConversionRequests = %d, numContinuationRequests = %d, tp->rcv_nxt = %u, tp->t.rcv_nxt = %u, sk = %p\n", tp->t.A, gNumSlowstart, numDataRequestMappings, numContinuations, numConversionRequests, numContinuationRequests, tp->rcv_nxt, tp->t.rcv_nxt, sk);
					DUMP_RTO(sk);
					printk("ContList Length = %d  Cont OFO queue length %d Data OFO queue length %d\n", tp->t.cont_list.len, tp->t.ofo_queue.qlen, tp->t.data_ofo_queue.qlen);
#endif
				}
				/* 1) Enter recovery mode
				   2) Initiate slow start
				*/
				backedOff = 1;
    1657:	c7 45 f0 01 00 00 00 	movl   $0x1,0xfffffff0(%ebp)
				enterRecoveryState(sk, 1);
    165e:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
    1665:	00 
    1666:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1669:	89 04 24             	mov    %eax,(%esp,1)
    166c:	e8 46 01 00 00       	call   17b7 <enterRecoveryState>
				requestSlowStart(sk);
    1671:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1674:	89 04 24             	mov    %eax,(%esp,1)
    1677:	e8 03 64 00 00       	call   7a7f <requestSlowStart>
    167c:	eb 36                	jmp    16b4 <slow_start_timer+0x1c9>
			} else {
				if(tp->t.conversionState == CONVERSION_IDLE) {
    167e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    1681:	83 b8 dc 09 00 00 00 	cmpl   $0x0,0x9dc(%eax)
    1688:	75 2a                	jne    16b4 <slow_start_timer+0x1c9>
#ifdef STRICT_BUFFER_CHECK
					BUG_TRAP(haveRcvBuf);
#endif
					tp->t.timerState |= TRICKLES_NEED_SLOWSTART;
    168a:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    168d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    1690:	8b 80 dc 02 00 00    	mov    0x2dc(%eax),%eax
    1696:	83 c8 02             	or     $0x2,%eax
    1699:	89 82 dc 02 00 00    	mov    %eax,0x2dc(%edx)
					//printk("need slowstart 2\n");
					tp->t.timerState &= ~TRICKLES_ENABLE_DATA_TIMEOUT;
    169f:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    16a2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    16a5:	8b 80 dc 02 00 00    	mov    0x2dc(%eax),%eax
    16ab:	83 e0 fe             	and    $0xfffffffe,%eax
    16ae:	89 82 dc 02 00 00    	mov    %eax,0x2dc(%edx)
				} else {
					if(trickles_ratelimit()) printk("no requests available for timeout ??? \n");
				}
			}
		}
	}
	if(numAcks) {
    16b4:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
    16b8:	74 13                	je     16cd <slow_start_timer+0x1e2>
		printk("slow start num acks = %d\n", numAcks);
    16ba:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    16bd:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    16c1:	c7 04 24 4d 06 00 00 	movl   $0x64d,(%esp,1)
    16c8:	e8 fc ff ff ff       	call   16c9 <slow_start_timer+0x1de>
	}

	if(!disableTimeout) {
    16cd:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    16d4:	0f 85 8e 00 00 00    	jne    1768 <slow_start_timer+0x27d>
		if(haveRequests || ((tp->t.timerState & TRICKLES_ENABLE_DATA_TIMEOUT) &&
    16da:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
    16de:	75 3b                	jne    171b <slow_start_timer+0x230>
    16e0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    16e3:	8b 80 dc 02 00 00    	mov    0x2dc(%eax),%eax
    16e9:	83 e0 01             	and    $0x1,%eax
    16ec:	85 c0                	test   %eax,%eax
    16ee:	74 78                	je     1768 <slow_start_timer+0x27d>
    16f0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    16f3:	8b 80 d4 09 00 00    	mov    0x9d4(%eax),%eax
    16f9:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    16fd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    1700:	8b 80 d4 09 00 00    	mov    0x9d4(%eax),%eax
    1706:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    170a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    170d:	89 04 24             	mov    %eax,(%esp,1)
    1710:	e8 fc ff ff ff       	call   1711 <slow_start_timer+0x226>
    1715:	85 c0                	test   %eax,%eax
    1717:	75 02                	jne    171b <slow_start_timer+0x230>
    1719:	eb 4d                	jmp    1768 <slow_start_timer+0x27d>
				    findUCContinuation(sk, tp->t.byteReqNext, tp->t.byteReqNext))) {
			if(!backedOff) {
    171b:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
    171f:	75 3c                	jne    175d <slow_start_timer+0x272>
				int newRTO = RTO_IN_JIFFIES(sk);
    1721:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1724:	05 bc 00 00 00       	add    $0xbc,%eax
    1729:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    172c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    172f:	8b 80 d8 02 00 00    	mov    0x2d8(%eax),%eax
    1735:	c1 f8 03             	sar    $0x3,%eax
    1738:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
				newRTO = newRTO * 2;
    173b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    173e:	01 c0                	add    %eax,%eax
    1740:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
				RTO_FROM_JIFFIES(sk, newRTO);
    1743:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1746:	05 bc 00 00 00       	add    $0xbc,%eax
    174b:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    174e:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    1751:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    1754:	c1 e0 03             	shl    $0x3,%eax
    1757:	89 82 d8 02 00 00    	mov    %eax,0x2d8(%edx)
			}
			resetClientTimer(sk); // 0504 - back off timer if no progress made
    175d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1760:	89 04 24             	mov    %eax,(%esp,1)
    1763:	e8 fc ff ff ff       	call   1764 <slow_start_timer+0x279>
		}
		// TRICKY: If !enable_data_timeout, or no continuation findUCContinuation(), we MUST reset the timer
		// when those states become true
	}
#ifndef USERTEST
out_unlock:
	//printk("slow start timer -1\n");
	bh_unlock_sock(sk);
	sock_put(sk);
    1768:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    176b:	89 04 24             	mov    %eax,(%esp,1)
    176e:	e8 65 7c 00 00       	call   93d8 <sock_put>
#endif // USERTEST
}
    1773:	c9                   	leave  
    1774:	c3                   	ret    

00001775 <trickles_client_connected_impl>:

static void trickles_client_connected_impl(struct sock *sk) {
    1775:	55                   	push   %ebp
    1776:	89 e5                	mov    %esp,%ebp
    1778:	83 ec 08             	sub    $0x8,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    177b:	8b 45 08             	mov    0x8(%ebp),%eax
    177e:	05 bc 00 00 00       	add    $0xbc,%eax
    1783:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	/* Called once client establishes connection */
	/*  1) Clear all timers
	   2) Initialize trickles timeout timer
	*/
#ifndef USERTEST
#if 1 // 10/04 -- duplicated earlier in initialization sequence to allow piggybacked data on synack
	tcp_clear_xmit_timers(sk);
    1786:	8b 45 08             	mov    0x8(%ebp),%eax
    1789:	89 04 24             	mov    %eax,(%esp,1)
    178c:	e8 fc ff ff ff       	call   178d <trickles_client_connected_impl+0x18>
	tp->t.slowstart_timer.function = &slow_start_timer;
    1791:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1794:	c7 80 58 09 00 00 00 	movl   $0x0,0x958(%eax)
    179b:	00 00 00 
	tp->t.slowstart_timer.data = (long)sk;
    179e:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    17a1:	8b 45 08             	mov    0x8(%ebp),%eax
    17a4:	89 82 54 09 00 00    	mov    %eax,0x954(%edx)
#endif
	resetClientTimer(sk);
    17aa:	8b 45 08             	mov    0x8(%ebp),%eax
    17ad:	89 04 24             	mov    %eax,(%esp,1)
    17b0:	e8 fc ff ff ff       	call   17b1 <trickles_client_connected_impl+0x3c>
#endif // USERTEST
}
    17b5:	c9                   	leave  
    17b6:	c3                   	ret    

000017b7 <enterRecoveryState>:

inline int Sack_contains(Sack *sack, int seq);

#if 0
// replaced with rebuildAckProof (cleaner design)
static void advanceAckProof(AckProof *proof, __u32 seq) {
	int i, j;
	for(i=0; i < proof->numSacks; i++) {
		if(Sack_contains(&proof->sacks[i], seq)) {
			break;
		}
	}
	if(i == proof->numSacks) {
		printk("advanceAckProof Error: Could not find target seqnum\n");
		proof->numSacks = 0;
		return;
	}
	for(j=0; j < proof->numSacks - i; j++) {
		proof->sacks[j] = proof->sacks[i + j];
	}
	proof->numSacks = proof->numSacks - i;
}
#endif

//#define CURR_CONT(X) ((CONTINUATION_TYPE *)((X)->tp_pinfo.af_tcp.t.ack_curr ? (X)->tp_pinfo.af_tcp.t.ack_curr : (X)->tp_pinfo.af_tcp.t.ack_prev))

void AckProof_dump(AckProof *proof);
static void enterRecoveryState(struct sock *sk, int reqSlowStart) {
    17b7:	55                   	push   %ebp
    17b8:	89 e5                	mov    %esp,%ebp
    17ba:	83 ec 18             	sub    $0x18,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    17bd:	8b 45 08             	mov    0x8(%ebp),%eax
    17c0:	05 bc 00 00 00       	add    $0xbc,%eax
    17c5:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	int newRTO = RTO_IN_JIFFIES(sk);
    17c8:	8b 45 08             	mov    0x8(%ebp),%eax
    17cb:	05 bc 00 00 00       	add    $0xbc,%eax
    17d0:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    17d3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    17d6:	8b 80 d8 02 00 00    	mov    0x2d8(%eax),%eax
    17dc:	c1 f8 03             	sar    $0x3,%eax
    17df:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

#ifdef SLOWSTART_ONLY
	reqSlowStart = 1;
#endif
	// enterRecoveryState may be called multiple times
	// during the same Fast Recovery, but only once per SlowStart attempt
	switch(tp->t.state) {
    17e2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    17e5:	8b 80 cc 02 00 00    	mov    0x2cc(%eax),%eax
    17eb:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    17ee:	83 7d f0 02          	cmpl   $0x2,0xfffffff0(%ebp)
    17f2:	0f 84 e5 00 00 00    	je     18dd <enterRecoveryState+0x126>
    17f8:	83 7d f0 02          	cmpl   $0x2,0xfffffff0(%ebp)
    17fc:	7f 0b                	jg     1809 <enterRecoveryState+0x52>
    17fe:	83 7d f0 01          	cmpl   $0x1,0xfffffff0(%ebp)
    1802:	74 14                	je     1818 <enterRecoveryState+0x61>
    1804:	e9 eb 01 00 00       	jmp    19f4 <enterRecoveryState+0x23d>
    1809:	83 7d f0 03          	cmpl   $0x3,0xfffffff0(%ebp)
    180d:	0f 84 74 01 00 00    	je     1987 <enterRecoveryState+0x1d0>
    1813:	e9 dc 01 00 00       	jmp    19f4 <enterRecoveryState+0x23d>
	case TRICKLES_CLIENT_NORMAL:
		if(reqSlowStart) {
    1818:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    181c:	74 65                	je     1883 <enterRecoveryState+0xcc>
			if(clientDebugLevel >= 1 || debugTransitions)
    181e:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    1825:	7f 0b                	jg     1832 <enterRecoveryState+0x7b>
    1827:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    182e:	75 02                	jne    1832 <enterRecoveryState+0x7b>
    1830:	eb 13                	jmp    1845 <enterRecoveryState+0x8e>
				printk("%p: Normal=>SlowStart\n", sk);
    1832:	8b 45 08             	mov    0x8(%ebp),%eax
    1835:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    1839:	c7 04 24 67 06 00 00 	movl   $0x667,(%esp,1)
    1840:	e8 fc ff ff ff       	call   1841 <enterRecoveryState+0x8a>
			tp->t.state = TRICKLES_CLIENT_SLOWSTART;
    1845:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1848:	c7 80 cc 02 00 00 03 	movl   $0x3,0x2cc(%eax)
    184f:	00 00 00 
			newRTO *= 2;
    1852:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    1855:	01 c0                	add    %eax,%eax
    1857:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
			tp->t.clientStateCounter++;
    185a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    185d:	ff 80 c8 02 00 00    	incl   0x2c8(%eax)
			tp->t.request_snd_nxt++;
    1863:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1866:	ff 80 60 09 00 00    	incl   0x960(%eax)
			tp->t.request_rcv_nxt = tp->t.request_snd_nxt;
    186c:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    186f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1872:	8b 80 60 09 00 00    	mov    0x960(%eax),%eax
    1878:	89 82 5c 09 00 00    	mov    %eax,0x95c(%edx)
    187e:	e9 71 01 00 00       	jmp    19f4 <enterRecoveryState+0x23d>
		} else {
			if(clientDebugLevel >= 1 || debugTransitions) {
    1883:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    188a:	7f 0b                	jg     1897 <enterRecoveryState+0xe0>
    188c:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    1893:	75 02                	jne    1897 <enterRecoveryState+0xe0>
    1895:	eb 23                	jmp    18ba <enterRecoveryState+0x103>
				printk("%p: Normal=>Recovery\n", sk);
    1897:	8b 45 08             	mov    0x8(%ebp),%eax
    189a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    189e:	c7 04 24 7e 06 00 00 	movl   $0x67e,(%esp,1)
    18a5:	e8 fc ff ff ff       	call   18a6 <enterRecoveryState+0xef>
				AckProof_dump(&tp->t.altProof);
    18aa:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    18ad:	05 0c 06 00 00       	add    $0x60c,%eax
    18b2:	89 04 24             	mov    %eax,(%esp,1)
    18b5:	e8 fc ff ff ff       	call   18b6 <enterRecoveryState+0xff>
			}
			tp->t.state = TRICKLES_CLIENT_RECOVERY;
    18ba:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    18bd:	c7 80 cc 02 00 00 02 	movl   $0x2,0x2cc(%eax)
    18c4:	00 00 00 
			newRTO *= 2;
    18c7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    18ca:	01 c0                	add    %eax,%eax
    18cc:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
			tp->t.clientStateCounter++;
    18cf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    18d2:	ff 80 c8 02 00 00    	incl   0x2c8(%eax)
		}
		break;
    18d8:	e9 17 01 00 00       	jmp    19f4 <enterRecoveryState+0x23d>
	case TRICKLES_CLIENT_RECOVERY:
		if(reqSlowStart) {
    18dd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    18e1:	74 65                	je     1948 <enterRecoveryState+0x191>
			tp->t.state = TRICKLES_CLIENT_SLOWSTART;
    18e3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    18e6:	c7 80 cc 02 00 00 03 	movl   $0x3,0x2cc(%eax)
    18ed:	00 00 00 
			newRTO *= 2;
    18f0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    18f3:	01 c0                	add    %eax,%eax
    18f5:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
			if(clientDebugLevel >= 1 || debugTransitions)
    18f8:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    18ff:	7f 0b                	jg     190c <enterRecoveryState+0x155>
    1901:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    1908:	75 02                	jne    190c <enterRecoveryState+0x155>
    190a:	eb 13                	jmp    191f <enterRecoveryState+0x168>
				printk("%p: Recovery=>SlowStart\n", sk);
    190c:	8b 45 08             	mov    0x8(%ebp),%eax
    190f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    1913:	c7 04 24 94 06 00 00 	movl   $0x694,(%esp,1)
    191a:	e8 fc ff ff ff       	call   191b <enterRecoveryState+0x164>
			tp->t.clientStateCounter++;
    191f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1922:	ff 80 c8 02 00 00    	incl   0x2c8(%eax)
			tp->t.request_snd_nxt++;
    1928:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    192b:	ff 80 60 09 00 00    	incl   0x960(%eax)
			tp->t.request_rcv_nxt = tp->t.request_snd_nxt;
    1931:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    1934:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1937:	8b 80 60 09 00 00    	mov    0x960(%eax),%eax
    193d:	89 82 5c 09 00 00    	mov    %eax,0x95c(%edx)
    1943:	e9 ac 00 00 00       	jmp    19f4 <enterRecoveryState+0x23d>
		} else {
			// already in recovery state; take no action
			if(clientDebugLevel >= 1 || debugTransitions) {
    1948:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    194f:	7f 0e                	jg     195f <enterRecoveryState+0x1a8>
    1951:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    1958:	75 05                	jne    195f <enterRecoveryState+0x1a8>
    195a:	e9 af 00 00 00       	jmp    1a0e <enterRecoveryState+0x257>
				printk("%p: Recovery=>Recovery\n", sk);
    195f:	8b 45 08             	mov    0x8(%ebp),%eax
    1962:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    1966:	c7 04 24 ad 06 00 00 	movl   $0x6ad,(%esp,1)
    196d:	e8 fc ff ff ff       	call   196e <enterRecoveryState+0x1b7>
				AckProof_dump(&tp->t.altProof);
    1972:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1975:	05 0c 06 00 00       	add    $0x60c,%eax
    197a:	89 04 24             	mov    %eax,(%esp,1)
    197d:	e8 fc ff ff ff       	call   197e <enterRecoveryState+0x1c7>
			}
			// DO NOT UPDATE CLIENTSTATE COUNTER (or any other state)
			return;
    1982:	e9 87 00 00 00       	jmp    1a0e <enterRecoveryState+0x257>
		}
		break;
	case TRICKLES_CLIENT_SLOWSTART:
		BUG_TRAP(reqSlowStart);
    1987:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    198b:	75 14                	jne    19a1 <enterRecoveryState+0x1ea>
    198d:	c7 44 24 04 fb 03 00 	movl   $0x3fb,0x4(%esp,1)
    1994:	00 
    1995:	c7 04 24 e0 06 00 00 	movl   $0x6e0,(%esp,1)
    199c:	e8 fc ff ff ff       	call   199d <enterRecoveryState+0x1e6>
		newRTO *= 2;
    19a1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    19a4:	01 c0                	add    %eax,%eax
    19a6:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
		if(clientDebugLevel >= 1 || debugTransitions)
    19a9:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    19b0:	7f 0b                	jg     19bd <enterRecoveryState+0x206>
    19b2:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    19b9:	75 02                	jne    19bd <enterRecoveryState+0x206>
    19bb:	eb 13                	jmp    19d0 <enterRecoveryState+0x219>
			printk("%p: SlowStart=>SlowStart\n", sk);
    19bd:	8b 45 08             	mov    0x8(%ebp),%eax
    19c0:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    19c4:	c7 04 24 1b 07 00 00 	movl   $0x71b,(%esp,1)
    19cb:	e8 fc ff ff ff       	call   19cc <enterRecoveryState+0x215>
		// Unlike client_recovery=>client_recovery transition,
		// take action: send another slow start request
		tp->t.clientStateCounter++;
    19d0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    19d3:	ff 80 c8 02 00 00    	incl   0x2c8(%eax)
		tp->t.request_snd_nxt++;
    19d9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    19dc:	ff 80 60 09 00 00    	incl   0x960(%eax)
		tp->t.request_rcv_nxt = tp->t.request_snd_nxt;
    19e2:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    19e5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    19e8:	8b 80 60 09 00 00    	mov    0x960(%eax),%eax
    19ee:	89 82 5c 09 00 00    	mov    %eax,0x95c(%edx)
		break;
	}

	RTO_FROM_JIFFIES(sk, newRTO);
    19f4:	8b 45 08             	mov    0x8(%ebp),%eax
    19f7:	05 bc 00 00 00       	add    $0xbc,%eax
    19fc:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    19ff:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    1a02:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    1a05:	c1 e0 03             	shl    $0x3,%eax
    1a08:	89 82 d8 02 00 00    	mov    %eax,0x2d8(%edx)
}
    1a0e:	c9                   	leave  
    1a0f:	c3                   	ret    

00001a10 <ContList_insert>:

#define NEWER(S0,S1) ((S0)>(S1))
static void ContList_insert(struct sock *sk, CONTINUATION_TYPE *cont) {
    1a10:	55                   	push   %ebp
    1a11:	89 e5                	mov    %esp,%ebp
    1a13:	83 ec 28             	sub    $0x28,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    1a16:	8b 45 08             	mov    0x8(%ebp),%eax
    1a19:	05 bc 00 00 00       	add    $0xbc,%eax
    1a1e:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	CONTINUATION_TYPE *cont_curs, *currentVal = cont, *newCont;
    1a21:	8b 45 0c             	mov    0xc(%ebp),%eax
    1a24:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	/* sorted insert into cont list */
	int replaced = 0;
    1a27:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
	int replaceAckPrev = 0;
    1a2e:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
	if(tp->t.previous_base > cont->TCPBase) {
    1a35:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1a38:	8b 55 0c             	mov    0xc(%ebp),%edx
    1a3b:	8b 80 e4 02 00 00    	mov    0x2e4(%eax),%eax
    1a41:	3b 42 6c             	cmp    0x6c(%edx),%eax
    1a44:	76 23                	jbe    1a69 <ContList_insert+0x59>
		printk("previous base > cont->TCPBase. clientstate %d clientstatecounter %d\n", cont->clientState, tp->t.clientStateCounter);
    1a46:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1a49:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
    1a4f:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    1a53:	8b 45 0c             	mov    0xc(%ebp),%eax
    1a56:	8b 40 38             	mov    0x38(%eax),%eax
    1a59:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    1a5d:	c7 04 24 40 07 00 00 	movl   $0x740,(%esp,1)
    1a64:	e8 fc ff ff ff       	call   1a65 <ContList_insert+0x55>
	}
	for(cont_curs = (CONTINUATION_TYPE*)tp->t.cont_list.prev;
    1a69:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1a6c:	8b 80 34 09 00 00    	mov    0x934(%eax),%eax
    1a72:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    1a75:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1a78:	05 34 09 00 00       	add    $0x934,%eax
    1a7d:	39 45 f8             	cmp    %eax,0xfffffff8(%ebp)
    1a80:	75 02                	jne    1a84 <ContList_insert+0x74>
    1a82:	eb 1a                	jmp    1a9e <ContList_insert+0x8e>
	    cont_curs != (CONTINUATION_TYPE*)&tp->t.cont_list;
	    cont_curs=cont_curs->prev) {
		if(cont_curs->seq < cont->seq)
    1a84:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    1a87:	8b 55 0c             	mov    0xc(%ebp),%edx
    1a8a:	8b 40 30             	mov    0x30(%eax),%eax
    1a8d:	3b 42 30             	cmp    0x30(%edx),%eax
    1a90:	73 02                	jae    1a94 <ContList_insert+0x84>
			break;
    1a92:	eb 0a                	jmp    1a9e <ContList_insert+0x8e>
    1a94:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    1a97:	8b 00                	mov    (%eax),%eax
    1a99:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    1a9c:	eb d7                	jmp    1a75 <ContList_insert+0x65>
	}
	if(cont_curs->next != (CONTINUATION_TYPE*)&tp->t.cont_list &&
    1a9e:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    1aa1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1aa4:	05 34 09 00 00       	add    $0x934,%eax
    1aa9:	39 42 04             	cmp    %eax,0x4(%edx)
    1aac:	0f 84 f4 00 00 00    	je     1ba6 <ContList_insert+0x196>
    1ab2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    1ab5:	8b 40 04             	mov    0x4(%eax),%eax
    1ab8:	8b 55 0c             	mov    0xc(%ebp),%edx
    1abb:	8b 40 30             	mov    0x30(%eax),%eax
    1abe:	3b 42 30             	cmp    0x30(%edx),%eax
    1ac1:	0f 85 df 00 00 00    	jne    1ba6 <ContList_insert+0x196>
	   cont_curs->next->seq == cont->seq) {
		CONTINUATION_TYPE *dup = cont_curs->next;
    1ac7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    1aca:	8b 40 04             	mov    0x4(%eax),%eax
    1acd:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
		if(NEWER(cont->clientState, dup->clientState)) {
    1ad0:	8b 45 0c             	mov    0xc(%ebp),%eax
    1ad3:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    1ad6:	8b 40 38             	mov    0x38(%eax),%eax
    1ad9:	3b 42 38             	cmp    0x38(%edx),%eax
    1adc:	0f 86 80 00 00 00    	jbe    1b62 <ContList_insert+0x152>
			newCont = copyClientSide_Continuation(cont, GFP_ATOMIC);
    1ae2:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    1ae9:	00 
    1aea:	8b 45 0c             	mov    0xc(%ebp),%eax
    1aed:	89 04 24             	mov    %eax,(%esp,1)
    1af0:	e8 ae 83 00 00       	call   9ea3 <copyClientSide_Continuation>
    1af5:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
			if(newCont == NULL) {
    1af8:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
    1afc:	75 11                	jne    1b0f <ContList_insert+0xff>
				printk("ContList_Insert(1); out of memory\n");
    1afe:	c7 04 24 a0 07 00 00 	movl   $0x7a0,(%esp,1)
    1b05:	e8 fc ff ff ff       	call   1b06 <ContList_insert+0xf6>
				goto skip_insert;
    1b0a:	e9 9d 01 00 00       	jmp    1cac <ContList_insert+0x29c>
			}

			replaced = 1;
    1b0f:	c7 45 ec 01 00 00 00 	movl   $0x1,0xffffffec(%ebp)
			// get rid of old one
			if(tp->t.ack_prev == dup)
    1b16:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1b19:	8b 80 f4 02 00 00    	mov    0x2f4(%eax),%eax
    1b1f:	3b 45 e4             	cmp    0xffffffe4(%ebp),%eax
    1b22:	75 07                	jne    1b2b <ContList_insert+0x11b>
				replaceAckPrev = 1;
    1b24:	c7 45 e8 01 00 00 00 	movl   $0x1,0xffffffe8(%ebp)
			if(clientDebugLevel >= 2)
    1b2b:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    1b32:	7e 16                	jle    1b4a <ContList_insert+0x13a>
				printk("Got rid of old cont %u\n", dup->seq);
    1b34:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    1b37:	8b 40 30             	mov    0x30(%eax),%eax
    1b3a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    1b3e:	c7 04 24 c3 07 00 00 	movl   $0x7c3,(%esp,1)
    1b45:	e8 fc ff ff ff       	call   1b46 <ContList_insert+0x136>
			unlinkCont(dup);
    1b4a:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    1b4d:	89 04 24             	mov    %eax,(%esp,1)
    1b50:	e8 c4 90 00 00       	call   ac19 <unlinkCont>
			MARK_PC(dup);
			freeClientSide_Continuation(dup);
    1b55:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    1b58:	89 04 24             	mov    %eax,(%esp,1)
    1b5b:	e8 cf 84 00 00       	call   a02f <freeClientSide_Continuation>
			goto skip_alloc;
    1b60:	eb 71                	jmp    1bd3 <ContList_insert+0x1c3>
		} else {
			// dont use new one
			if(tp->t.ack_prev == cont)
    1b62:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1b65:	8b 80 f4 02 00 00    	mov    0x2f4(%eax),%eax
    1b6b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    1b6e:	75 0c                	jne    1b7c <ContList_insert+0x16c>
				printk("ContList_insert: invalid condition\n");
    1b70:	c7 04 24 e0 07 00 00 	movl   $0x7e0,(%esp,1)
    1b77:	e8 fc ff ff ff       	call   1b78 <ContList_insert+0x168>
			if(clientDebugLevel >= 2)
    1b7c:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    1b83:	7e 16                	jle    1b9b <ContList_insert+0x18b>
				printk("Got rid of new cont %u\n", cont->seq);
    1b85:	8b 45 0c             	mov    0xc(%ebp),%eax
    1b88:	8b 40 30             	mov    0x30(%eax),%eax
    1b8b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    1b8f:	c7 04 24 04 08 00 00 	movl   $0x804,(%esp,1)
    1b96:	e8 fc ff ff ff       	call   1b97 <ContList_insert+0x187>
			currentVal = dup;
    1b9b:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    1b9e:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
			goto skip_insert;
    1ba1:	e9 06 01 00 00       	jmp    1cac <ContList_insert+0x29c>
		}
	}
	/* create copy for transport-level acking and processing */
	newCont = copyClientSide_Continuation(cont, GFP_ATOMIC);
    1ba6:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    1bad:	00 
    1bae:	8b 45 0c             	mov    0xc(%ebp),%eax
    1bb1:	89 04 24             	mov    %eax,(%esp,1)
    1bb4:	e8 ea 82 00 00       	call   9ea3 <copyClientSide_Continuation>
    1bb9:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	if(newCont == NULL) {
    1bbc:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
    1bc0:	75 11                	jne    1bd3 <ContList_insert+0x1c3>
		printk("ContList_Insert: Out of memory\n");
    1bc2:	c7 04 24 20 08 00 00 	movl   $0x820,(%esp,1)
    1bc9:	e8 fc ff ff ff       	call   1bca <ContList_insert+0x1ba>
		goto skip_insert;
    1bce:	e9 d9 00 00 00       	jmp    1cac <ContList_insert+0x29c>
	}
	skip_alloc:
	newCont->mark |= 0x2;
    1bd3:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    1bd6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    1bd9:	8b 80 e4 00 00 00    	mov    0xe4(%eax),%eax
    1bdf:	83 c8 02             	or     $0x2,%eax
    1be2:	89 82 e4 00 00 00    	mov    %eax,0xe4(%edx)

	// don't need user-level data while performing transport-level processing
	newCont->ucont_data = NULL;
    1be8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    1beb:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	newCont->input = NULL;
    1bf2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    1bf5:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
    1bfc:	00 00 00 
	//printk("contlist_insert: newCont %p cont %p\n", newCont, cont);
	insert((struct alloc_head*)newCont, (struct alloc_head*)cont_curs, (struct alloc_head*)cont_curs->next);
    1bff:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    1c02:	8b 40 04             	mov    0x4(%eax),%eax
    1c05:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    1c09:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    1c0c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    1c10:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    1c13:	89 04 24             	mov    %eax,(%esp,1)
    1c16:	e8 17 77 00 00       	call   9332 <insert>
	if(replaceAckPrev || tp->t.ack_prev == cont) {
    1c1b:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
    1c1f:	75 10                	jne    1c31 <ContList_insert+0x221>
    1c21:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1c24:	8b 80 f4 02 00 00    	mov    0x2f4(%eax),%eax
    1c2a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    1c2d:	74 02                	je     1c31 <ContList_insert+0x221>
    1c2f:	eb 0c                	jmp    1c3d <ContList_insert+0x22d>
		tp->t.ack_prev = newCont;
    1c31:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    1c34:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    1c37:	89 82 f4 02 00 00    	mov    %eax,0x2f4(%edx)
		INTEGRITY_CHECK(sk, tp->t.ack_prev);
		SAVE_ACK_PREV(tp);
	}
	if(!(!tp->t.ack_prev || tp->t.ack_prev->next)) {
    1c3d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1c40:	83 b8 f4 02 00 00 00 	cmpl   $0x0,0x2f4(%eax)
    1c47:	74 63                	je     1cac <ContList_insert+0x29c>
    1c49:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1c4c:	8b 80 f4 02 00 00    	mov    0x2f4(%eax),%eax
    1c52:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
    1c56:	75 54                	jne    1cac <ContList_insert+0x29c>
		// 0429
		BUG_TRAP((!tp->t.ack_prev || tp->t.ack_prev->next));
    1c58:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1c5b:	83 b8 f4 02 00 00 00 	cmpl   $0x0,0x2f4(%eax)
    1c62:	74 23                	je     1c87 <ContList_insert+0x277>
    1c64:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1c67:	8b 80 f4 02 00 00    	mov    0x2f4(%eax),%eax
    1c6d:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
    1c71:	75 14                	jne    1c87 <ContList_insert+0x277>
    1c73:	c7 44 24 04 4d 04 00 	movl   $0x44d,0x4(%esp,1)
    1c7a:	00 
    1c7b:	c7 04 24 40 08 00 00 	movl   $0x840,(%esp,1)
    1c82:	e8 fc ff ff ff       	call   1c83 <ContList_insert+0x273>
		BUG();
    1c87:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    1c8e:	00 
    1c8f:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    1c96:	e8 fc ff ff ff       	call   1c97 <ContList_insert+0x287>
    1c9b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    1ca2:	e8 fc ff ff ff       	call   1ca3 <ContList_insert+0x293>
    1ca7:	e8 fc ff ff ff       	call   1ca8 <ContList_insert+0x298>
	}
 skip_insert:
	;
}
    1cac:	c9                   	leave  
    1cad:	c3                   	ret    

00001cae <freeRequest>:

int breakpoint_seq = -1;
int paranoia = 0;

#if 0
struct Request *copyRequest(struct Request *req) {
	struct Request *rval;
	switch(req->type) {
	case MREQ_CONTINUATION: {
		struct ContinuationRequest *contReq = (struct ContinuationRequest *)req, *newContReq;
		newContReq = kmalloc_ContinuationRequest(GFP_ATOMIC);
		if(newContReq == NULL) {
			printk("Out of memory while copying request\n");
			return NULL;
		}
		*newContReq = *contReq;
		newContReq->conts = kmalloc(sizeof(newContReq->conts[0]) * newContReq->numConts, GFP_ATOMIC);
		if(newContReq->conts == NULL) {
			printk("Out of memory while copying request\n");
			kfree(newContReq);
			return NULL;
		}
		memcpy(newContReq->conts, contReq->conts, sizeof(contReq->conts[0]) * contReq->numConts);
		rval = (struct Request *)newContReq;
		break;
	}
	case MREQ_CONVERSION: {
		struct ConversionRequest *convReq = (struct ConversionRequest *)req, *newConvReq;
		newConvReq = kmalloc_ConversionRequest(GFP_ATOMIC);
		if(newConvReq == NULL) {
			printk("Out of memory while copying request\n");
			return NULL;
		}
		*newConvReq = *convReq;
		rval = (struct Request*)newConvReq;
		break;
	}
	default:
		rval = NULL;
		BUG();
	}
	rval->prev = rval->next = NULL;
	rval->list = NULL;
	return rval;
}
#endif

void freeRequest(struct Request *req) {
    1cae:	55                   	push   %ebp
    1caf:	89 e5                	mov    %esp,%ebp
    1cb1:	83 ec 14             	sub    $0x14,%esp
	BUG_TRAP(req->allocated);
    1cb4:	8b 45 08             	mov    0x8(%ebp),%eax
    1cb7:	0f b6 40 48          	movzbl 0x48(%eax),%eax
    1cbb:	d0 e8                	shr    %al
    1cbd:	0f b6 c0             	movzbl %al,%eax
    1cc0:	83 e0 01             	and    $0x1,%eax
    1cc3:	85 c0                	test   %eax,%eax
    1cc5:	75 14                	jne    1cdb <freeRequest+0x2d>
    1cc7:	c7 44 24 04 83 04 00 	movl   $0x483,0x4(%esp,1)
    1cce:	00 
    1ccf:	c7 04 24 a0 08 00 00 	movl   $0x8a0,(%esp,1)
    1cd6:	e8 fc ff ff ff       	call   1cd7 <freeRequest+0x29>
	req->allocated = 0;
    1cdb:	8b 45 08             	mov    0x8(%ebp),%eax
    1cde:	80 60 48 fd          	andb   $0xfd,0x48(%eax)

	switch(req->type) {
    1ce2:	8b 45 08             	mov    0x8(%ebp),%eax
    1ce5:	8b 40 0c             	mov    0xc(%eax),%eax
    1ce8:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    1ceb:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
    1cef:	74 24                	je     1d15 <freeRequest+0x67>
    1cf1:	83 7d f4 01          	cmpl   $0x1,0xfffffff4(%ebp)
    1cf5:	74 02                	je     1cf9 <freeRequest+0x4b>
    1cf7:	eb 74                	jmp    1d6d <freeRequest+0xbf>
	case MREQ_CONTINUATION: {
		struct ContinuationRequest *contReq = (struct ContinuationRequest *)req;
    1cf9:	8b 45 08             	mov    0x8(%ebp),%eax
    1cfc:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
		/* need to deallocate continuation array */
		kfree(contReq->conts);
    1cff:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1d02:	8b 40 58             	mov    0x58(%eax),%eax
    1d05:	89 04 24             	mov    %eax,(%esp,1)
    1d08:	e8 fc ff ff ff       	call   1d09 <freeRequest+0x5b>
		numContinuationRequests--;
    1d0d:	ff 0d 00 00 00 00    	decl   0x0
		break;
    1d13:	eb 7d                	jmp    1d92 <freeRequest+0xe4>
	}
	case MREQ_CONVERSION: {
		struct ConversionRequest *convReq = (struct ConversionRequest *)req;
    1d15:	8b 45 08             	mov    0x8(%ebp),%eax
    1d18:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
		/* skb references are dropped when snd_una is advanced, so don't perform that deallocation here */
		if(convReq->incomplete) {
    1d1b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1d1e:	83 78 54 00          	cmpl   $0x0,0x54(%eax)
    1d22:	74 10                	je     1d34 <freeRequest+0x86>
			kfree(convReq->incompletePred);
    1d24:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1d27:	8b 40 64             	mov    0x64(%eax),%eax
    1d2a:	89 04 24             	mov    %eax,(%esp,1)
    1d2d:	e8 fc ff ff ff       	call   1d2e <freeRequest+0x80>
    1d32:	eb 31                	jmp    1d65 <freeRequest+0xb7>
		} else {
			UC_CONTINUATION_TRYFREE(convReq->completePred);
    1d34:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
    1d3b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1d3e:	8b 40 64             	mov    0x64(%eax),%eax
    1d41:	83 c0 24             	add    $0x24,%eax
    1d44:	89 04 24             	mov    %eax,(%esp,1)
    1d47:	e8 a8 6e 00 00       	call   8bf4 <atomic_dec_and_test>
    1d4c:	85 c0                	test   %eax,%eax
    1d4e:	74 15                	je     1d65 <freeRequest+0xb7>
    1d50:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1d53:	8b 40 64             	mov    0x64(%eax),%eax
    1d56:	89 04 24             	mov    %eax,(%esp,1)
    1d59:	e8 fc ff ff ff       	call   1d5a <freeRequest+0xac>
    1d5e:	c7 45 f8 01 00 00 00 	movl   $0x1,0xfffffff8(%ebp)
		}
		numConversionRequests--;
    1d65:	ff 0d 68 00 00 00    	decl   0x68
		break;
    1d6b:	eb 25                	jmp    1d92 <freeRequest+0xe4>
	}
	default:
		BUG();
    1d6d:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    1d74:	00 
    1d75:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    1d7c:	e8 fc ff ff ff       	call   1d7d <freeRequest+0xcf>
    1d81:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    1d88:	e8 fc ff ff ff       	call   1d89 <freeRequest+0xdb>
    1d8d:	e8 fc ff ff ff       	call   1d8e <freeRequest+0xe0>
	}
	BUG_TRAP(!req->list);
    1d92:	8b 45 08             	mov    0x8(%ebp),%eax
    1d95:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
    1d99:	74 14                	je     1daf <freeRequest+0x101>
    1d9b:	c7 44 24 04 9c 04 00 	movl   $0x49c,0x4(%esp,1)
    1da2:	00 
    1da3:	c7 04 24 e0 08 00 00 	movl   $0x8e0,(%esp,1)
    1daa:	e8 fc ff ff ff       	call   1dab <freeRequest+0xfd>
	kfree(req);
    1daf:	8b 45 08             	mov    0x8(%ebp),%eax
    1db2:	89 04 24             	mov    %eax,(%esp,1)
    1db5:	e8 fc ff ff ff       	call   1db6 <freeRequest+0x108>
}
    1dba:	c9                   	leave  
    1dbb:	c3                   	ret    

00001dbc <pushRequests>:

inline void pushRequests(struct sock *sk) {
    1dbc:	55                   	push   %ebp
    1dbd:	89 e5                	mov    %esp,%ebp
    1dbf:	83 ec 08             	sub    $0x8,%esp
	/* Try to send an ack */
	trickles_send_ack_impl(sk, 0);
    1dc2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    1dc9:	00 
    1dca:	8b 45 08             	mov    0x8(%ebp),%eax
    1dcd:	89 04 24             	mov    %eax,(%esp,1)
    1dd0:	e8 fc ff ff ff       	call   1dd1 <pushRequests+0x15>
}
    1dd5:	c9                   	leave  
    1dd6:	c3                   	ret    

00001dd7 <queueConversionRequests>:

static inline void cleanTxQueue(struct sock *sk) {
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	struct sk_buff *skb = NULL;
	for(skb = tp->t.requestBytes.next; skb != (struct sk_buff*)&tp->t.requestBytes; skb = skb->next) {
		if(TCP_SKB_CB(skb)->end_seq <= tp->t.snd_una) {
			struct sk_buff *clean = skb;
			skb = skb->prev;
			__skb_unlink(clean, &tp->t.requestBytes);
			kfree_skb(clean);
		}
	}
}

void queueConversionRequests(struct sock *sk) {
    1dd7:	55                   	push   %ebp
    1dd8:	89 e5                	mov    %esp,%ebp
    1dda:	83 ec 24             	sub    $0x24,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    1ddd:	8b 45 08             	mov    0x8(%ebp),%eax
    1de0:	05 bc 00 00 00       	add    $0xbc,%eax
    1de5:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	struct ConversionRequest *req;
	struct sk_buff *skb = NULL;
    1de8:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
	int found = 0;
    1def:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
	BUG_TRAP(tp->t.write_seq - tp->t.snd_una > 0);
    1df6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1df9:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    1dfc:	8b 80 e8 09 00 00    	mov    0x9e8(%eax),%eax
    1e02:	3b 82 e0 09 00 00    	cmp    0x9e0(%edx),%eax
    1e08:	75 14                	jne    1e1e <queueConversionRequests+0x47>
    1e0a:	c7 44 24 04 b7 04 00 	movl   $0x4b7,0x4(%esp,1)
    1e11:	00 
    1e12:	c7 04 24 20 09 00 00 	movl   $0x920,(%esp,1)
    1e19:	e8 fc ff ff ff       	call   1e1a <queueConversionRequests+0x43>
	req = kmalloc_ConversionRequest(GFP_ATOMIC);
    1e1e:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp,1)
    1e25:	e8 fc ff ff ff       	call   1e26 <queueConversionRequests+0x4f>
    1e2a:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	if(req == NULL) {
    1e2d:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    1e31:	75 31                	jne    1e64 <queueConversionRequests+0x8d>
		printk("queueConversionRequests: Out of memory!\n");
    1e33:	c7 04 24 80 09 00 00 	movl   $0x980,(%esp,1)
    1e3a:	e8 fc ff ff ff       	call   1e3b <queueConversionRequests+0x64>
		BUG();
    1e3f:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    1e46:	00 
    1e47:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    1e4e:	e8 fc ff ff ff       	call   1e4f <queueConversionRequests+0x78>
    1e53:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    1e5a:	e8 fc ff ff ff       	call   1e5b <queueConversionRequests+0x84>
    1e5f:	e8 fc ff ff ff       	call   1e60 <queueConversionRequests+0x89>
	}
	for(skb = tp->t.requestBytes.next; skb != (struct sk_buff*)&tp->t.requestBytes; skb = skb->next) {
    1e64:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1e67:	8b 80 ec 09 00 00    	mov    0x9ec(%eax),%eax
    1e6d:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    1e70:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1e73:	05 ec 09 00 00       	add    $0x9ec,%eax
    1e78:	39 45 f4             	cmp    %eax,0xfffffff4(%ebp)
    1e7b:	75 05                	jne    1e82 <queueConversionRequests+0xab>
    1e7d:	e9 85 00 00 00       	jmp    1f07 <queueConversionRequests+0x130>
		if(TCP_SKB_CB(skb)->end_seq <= tp->t.snd_una) {
    1e82:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    1e85:	83 c0 30             	add    $0x30,%eax
    1e88:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    1e8b:	8b 40 14             	mov    0x14(%eax),%eax
    1e8e:	3b 82 e0 09 00 00    	cmp    0x9e0(%edx),%eax
    1e94:	77 33                	ja     1ec9 <queueConversionRequests+0xf2>
			struct sk_buff *clean = skb;
    1e96:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    1e99:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
			skb = skb->prev;
    1e9c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    1e9f:	8b 40 04             	mov    0x4(%eax),%eax
    1ea2:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
			__skb_unlink(clean, &tp->t.requestBytes);
    1ea5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1ea8:	05 ec 09 00 00       	add    $0x9ec,%eax
    1ead:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    1eb1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    1eb4:	89 04 24             	mov    %eax,(%esp,1)
    1eb7:	e8 62 70 00 00       	call   8f1e <__skb_unlink>
			kfree_skb(clean);
    1ebc:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    1ebf:	89 04 24             	mov    %eax,(%esp,1)
    1ec2:	e8 ce 6e 00 00       	call   8d95 <kfree_skb>
    1ec7:	eb 31                	jmp    1efa <queueConversionRequests+0x123>
		} else if(SKB_CONTAINS(skb, tp->t.snd_una)) {
    1ec9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    1ecc:	83 c0 30             	add    $0x30,%eax
    1ecf:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    1ed2:	8b 40 10             	mov    0x10(%eax),%eax
    1ed5:	3b 82 e0 09 00 00    	cmp    0x9e0(%edx),%eax
    1edb:	77 1d                	ja     1efa <queueConversionRequests+0x123>
    1edd:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    1ee0:	83 c0 30             	add    $0x30,%eax
    1ee3:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    1ee6:	8b 40 14             	mov    0x14(%eax),%eax
    1ee9:	3b 82 e0 09 00 00    	cmp    0x9e0(%edx),%eax
    1eef:	76 09                	jbe    1efa <queueConversionRequests+0x123>
			found = 1;
    1ef1:	c7 45 f0 01 00 00 00 	movl   $0x1,0xfffffff0(%ebp)
			break;
    1ef8:	eb 0d                	jmp    1f07 <queueConversionRequests+0x130>
    1efa:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    1efd:	8b 00                	mov    (%eax),%eax
    1eff:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    1f02:	e9 69 ff ff ff       	jmp    1e70 <queueConversionRequests+0x99>
		}
	}
	if(!found) {
    1f07:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
    1f0b:	75 3e                	jne    1f4b <queueConversionRequests+0x174>
		printk("Could not find matching bytes to convert\n");
    1f0d:	c7 04 24 c0 09 00 00 	movl   $0x9c0,(%esp,1)
    1f14:	e8 fc ff ff ff       	call   1f15 <queueConversionRequests+0x13e>
		kfree(req);
    1f19:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    1f1c:	89 04 24             	mov    %eax,(%esp,1)
    1f1f:	e8 fc ff ff ff       	call   1f20 <queueConversionRequests+0x149>
		BUG();
    1f24:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    1f2b:	00 
    1f2c:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    1f33:	e8 fc ff ff ff       	call   1f34 <queueConversionRequests+0x15d>
    1f38:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    1f3f:	e8 fc ff ff ff       	call   1f40 <queueConversionRequests+0x169>
    1f44:	e8 fc ff ff ff       	call   1f45 <queueConversionRequests+0x16e>
		return;
    1f49:	eb 3e                	jmp    1f89 <queueConversionRequests+0x1b2>
	}
	initCompleteConversionRequest(req,
    1f4b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1f4e:	8b 80 e0 09 00 00    	mov    0x9e0(%eax),%eax
    1f54:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    1f58:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    1f5b:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    1f5f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    1f62:	8b 80 fc 09 00 00    	mov    0x9fc(%eax),%eax
    1f68:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    1f6c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    1f6f:	89 04 24             	mov    %eax,(%esp,1)
    1f72:	e8 5b 78 00 00       	call   97d2 <initCompleteConversionRequest>
				      tp->t.prevConvCont,
				      /* Data */
				      skb,
				      tp->t.snd_una);
	//printk("%p: init complete conversion request: %d-%d\n", sk, tp->t.snd_una, TCP_SKB_CB(skb)->end_seq);
	//printk("0: start = %d %d\n", tp->t.snd_una, req->start);
	queueNewRequest(sk, (struct Request *)req);
    1f77:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    1f7a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    1f7e:	8b 45 08             	mov    0x8(%ebp),%eax
    1f81:	89 04 24             	mov    %eax,(%esp,1)
    1f84:	e8 ff 77 00 00       	call   9788 <queueNewRequest>
}
    1f89:	c9                   	leave  
    1f8a:	c3                   	ret    

00001f8b <finishIncompleteRequest>:

inline void finishIncompleteRequest(struct sock *sk) {
    1f8b:	55                   	push   %ebp
    1f8c:	89 e5                	mov    %esp,%ebp
    1f8e:	53                   	push   %ebx
    1f8f:	83 ec 1c             	sub    $0x1c,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    1f92:	8b 45 08             	mov    0x8(%ebp),%eax
    1f95:	05 bc 00 00 00       	add    $0xbc,%eax
    1f9a:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	struct ConversionRequest *req = tp->t.newIncompleteRequest;
    1f9d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    1fa0:	8b 80 f8 09 00 00    	mov    0x9f8(%eax),%eax
    1fa6:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	struct sk_buff *skb;
	int found = 0;
    1fa9:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
	if(req == NULL) {
    1fb0:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
    1fb4:	75 31                	jne    1fe7 <finishIncompleteRequest+0x5c>
		printk("finishIncompleteRequest, but no pending incomplete request\n");
    1fb6:	c7 04 24 00 0a 00 00 	movl   $0xa00,(%esp,1)
    1fbd:	e8 fc ff ff ff       	call   1fbe <finishIncompleteRequest+0x33>
		BUG();
    1fc2:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    1fc9:	00 
    1fca:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    1fd1:	e8 fc ff ff ff       	call   1fd2 <finishIncompleteRequest+0x47>
    1fd6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    1fdd:	e8 fc ff ff ff       	call   1fde <finishIncompleteRequest+0x53>
    1fe2:	e8 fc ff ff ff       	call   1fe3 <finishIncompleteRequest+0x58>
	}
	BUG_TRAP(req->incomplete);
    1fe7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    1fea:	83 78 54 00          	cmpl   $0x0,0x54(%eax)
    1fee:	75 14                	jne    2004 <finishIncompleteRequest+0x79>
    1ff0:	c7 44 24 04 e1 04 00 	movl   $0x4e1,0x4(%esp,1)
    1ff7:	00 
    1ff8:	c7 04 24 40 0a 00 00 	movl   $0xa40,(%esp,1)
    1fff:	e8 fc ff ff ff       	call   2000 <finishIncompleteRequest+0x75>

	for(skb = tp->t.requestBytes.next; skb != (struct sk_buff*)&tp->t.requestBytes; skb = skb->next) {
    2004:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    2007:	8b 80 ec 09 00 00    	mov    0x9ec(%eax),%eax
    200d:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    2010:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    2013:	05 ec 09 00 00       	add    $0x9ec,%eax
    2018:	39 45 f0             	cmp    %eax,0xfffffff0(%ebp)
    201b:	75 05                	jne    2022 <finishIncompleteRequest+0x97>
    201d:	e9 85 00 00 00       	jmp    20a7 <finishIncompleteRequest+0x11c>
		if(TCP_SKB_CB(skb)->end_seq <= tp->t.snd_una) {
    2022:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    2025:	83 c0 30             	add    $0x30,%eax
    2028:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    202b:	8b 40 14             	mov    0x14(%eax),%eax
    202e:	3b 82 e0 09 00 00    	cmp    0x9e0(%edx),%eax
    2034:	77 33                	ja     2069 <finishIncompleteRequest+0xde>
			struct sk_buff *clean = skb;
    2036:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    2039:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
			skb = skb->prev;
    203c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    203f:	8b 40 04             	mov    0x4(%eax),%eax
    2042:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
			__skb_unlink(clean, &tp->t.requestBytes);
    2045:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    2048:	05 ec 09 00 00       	add    $0x9ec,%eax
    204d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    2051:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    2054:	89 04 24             	mov    %eax,(%esp,1)
    2057:	e8 c2 6e 00 00       	call   8f1e <__skb_unlink>
			kfree_skb(clean);
    205c:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    205f:	89 04 24             	mov    %eax,(%esp,1)
    2062:	e8 2e 6d 00 00       	call   8d95 <kfree_skb>
    2067:	eb 31                	jmp    209a <finishIncompleteRequest+0x10f>
		} else if(SKB_CONTAINS(skb, tp->t.snd_una)) {
    2069:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    206c:	83 c0 30             	add    $0x30,%eax
    206f:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    2072:	8b 40 10             	mov    0x10(%eax),%eax
    2075:	3b 82 e0 09 00 00    	cmp    0x9e0(%edx),%eax
    207b:	77 1d                	ja     209a <finishIncompleteRequest+0x10f>
    207d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    2080:	83 c0 30             	add    $0x30,%eax
    2083:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    2086:	8b 40 14             	mov    0x14(%eax),%eax
    2089:	3b 82 e0 09 00 00    	cmp    0x9e0(%edx),%eax
    208f:	76 09                	jbe    209a <finishIncompleteRequest+0x10f>
			found = 1;
    2091:	c7 45 ec 01 00 00 00 	movl   $0x1,0xffffffec(%ebp)
			break;
    2098:	eb 0d                	jmp    20a7 <finishIncompleteRequest+0x11c>
    209a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    209d:	8b 00                	mov    (%eax),%eax
    209f:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    20a2:	e9 69 ff ff ff       	jmp    2010 <finishIncompleteRequest+0x85>
		}
	}
	if(!found) {
    20a7:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
    20ab:	75 33                	jne    20e0 <finishIncompleteRequest+0x155>
		printk("Could not find matching bytes to convert\n");
    20ad:	c7 04 24 c0 09 00 00 	movl   $0x9c0,(%esp,1)
    20b4:	e8 fc ff ff ff       	call   20b5 <finishIncompleteRequest+0x12a>
		BUG();
    20b9:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    20c0:	00 
    20c1:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    20c8:	e8 fc ff ff ff       	call   20c9 <finishIncompleteRequest+0x13e>
    20cd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    20d4:	e8 fc ff ff ff       	call   20d5 <finishIncompleteRequest+0x14a>
    20d9:	e8 fc ff ff ff       	call   20da <finishIncompleteRequest+0x14f>
		return;
    20de:	eb 79                	jmp    2159 <finishIncompleteRequest+0x1ce>
	}
	tp->t.newIncompleteRequest = NULL;
    20e0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    20e3:	c7 80 f8 09 00 00 00 	movl   $0x0,0x9f8(%eax)
    20ea:	00 00 00 

	req->data = skb;
    20ed:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    20f0:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    20f3:	89 42 58             	mov    %eax,0x58(%edx)
	req->offset = tp->t.snd_una - TCP_SKB_CB(skb)->seq;
    20f6:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
    20f9:	8b 4d f8             	mov    0xfffffff8(%ebp),%ecx
    20fc:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    20ff:	83 c0 30             	add    $0x30,%eax
    2102:	8b 50 10             	mov    0x10(%eax),%edx
    2105:	8b 81 e0 09 00 00    	mov    0x9e0(%ecx),%eax
    210b:	29 d0                	sub    %edx,%eax
    210d:	89 43 5c             	mov    %eax,0x5c(%ebx)
	req->start = TCP_SKB_CB(skb)->seq + req->offset;
    2110:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
    2113:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    2116:	83 c2 30             	add    $0x30,%edx
    2119:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    211c:	8b 40 5c             	mov    0x5c(%eax),%eax
    211f:	03 42 10             	add    0x10(%edx),%eax
    2122:	89 41 40             	mov    %eax,0x40(%ecx)

	printk("1: start = %d\n", req->start);
    2125:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    2128:	8b 40 40             	mov    0x40(%eax),%eax
    212b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    212f:	c7 04 24 7e 0a 00 00 	movl   $0xa7e,(%esp,1)
    2136:	e8 fc ff ff ff       	call   2137 <finishIncompleteRequest+0x1ac>

	req->end = req->start;
    213b:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    213e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    2141:	8b 40 40             	mov    0x40(%eax),%eax
    2144:	89 42 44             	mov    %eax,0x44(%edx)
	queueNewRequest(sk, (struct Request*)req);
    2147:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    214a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    214e:	8b 45 08             	mov    0x8(%ebp),%eax
    2151:	89 04 24             	mov    %eax,(%esp,1)
    2154:	e8 2f 76 00 00       	call   9788 <queueNewRequest>
}
    2159:	83 c4 1c             	add    $0x1c,%esp
    215c:	5b                   	pop    %ebx
    215d:	5d                   	pop    %ebp
    215e:	c3                   	ret    

0000215f <updateParent>:

static inline int processIncompleteResponse(struct sock *sk, struct WireUC_CVT_IncompleteResponse *incompleteResp, int responseLen) {
	/* Update conversion state, and use the incomplete
	   continuationn to generate and enqueue the request for the
	   next step in the parse */
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	struct ConversionRequest *newConvReq;
	struct sk_buff *skb;
	int foundNextData = 0;
	struct WireUC_CVT_IncompleteContinuation *pred;
	unsigned predLength;
	unsigned ackSeq = ntohl(incompleteResp->ack_seq);
	int bytesConsumed = tp->t.snd_una;

	/* Need to finish this conversion. So find
	   next bytestream data to send, enqueue new
	   request in request queue */

	/* XXX This code does not gracefully handle
	   parallel parse requests */
	if(ackSeq > tp->t.snd_una) {
		tp->t.snd_una = ackSeq;
		if(tp->t.snd_una > tp->t.write_seq) {
			printk("BUG! after byte position update, snd_una %d > write_seq %d !\n", tp->t.snd_una, tp->t.write_seq);
			tp->t.snd_una = tp->t.write_seq;
			return -1;
		}
	}
	bytesConsumed = tp->t.snd_una - bytesConsumed;
	// xxx Should not be TRICKLES_MSS (more like TCP_MSS)
	if(bytesConsumed == 0 &&
	   tp->t.snd_end - tp->t.snd_una >= TRICKLES_MSS) {
		printk("Error: bytesConsumed == 0, but full MSS was sent! Forward progress cannot be made\n");
		return -1;
	}
	/* Deallocate any elements in send queue that we no longer need, and find next skb to use */
	for(skb = tp->t.requestBytes.next; skb != (struct sk_buff*)&tp->t.requestBytes; skb = skb->next) {
		if(TCP_SKB_CB(skb)->end_seq <= tp->t.snd_una) {
			struct sk_buff *clean = skb;
			skb = skb->prev;
			__skb_unlink(clean, &tp->t.requestBytes);
			kfree_skb(clean);
		}
		if(SKB_CONTAINS(skb, tp->t.snd_una)) {
			foundNextData = 1;
			break;
		}
	}
	newConvReq = kmalloc_ConversionRequest(GFP_ATOMIC);
	if(newConvReq == NULL) {
		printk("Out of memory while allocating Request to continue incomplete conversion!\n");
		return -1;
	}
	predLength = responseLen - ((char*)&incompleteResp->newCont - (char*)incompleteResp);
	pred = kmalloc_dup(&incompleteResp->newCont, predLength, GFP_ATOMIC);
	if(pred == NULL) {
		kfree(newConvReq);
		printk("kmalloc_dup() returned error\n");
		return -1;
	}
	if(!foundNextData) {
		// Defer installation of new request until data arrives from userlevel
		BUG_TRAP(tp->t.newIncompleteRequest == NULL);
		tp->t.conversionState = CONVERSION_WAITFORUSER;
		tp->t.newIncompleteRequest = newConvReq;
		initIncompleteConversionRequest(newConvReq,
						pred, predLength,
						/* no data yet */
						NULL, -1);
		//printk("process_incomplete_request set conversion state to waitforuser\n");
	} else {
		BUG_TRAP(tp->t.newIncompleteRequest == NULL);
		tp->t.conversionState = CONVERSION_WAITFORSERVER;
		tp->t.newIncompleteRequest = NULL;
		initIncompleteConversionRequest(newConvReq,
						pred, predLength,
						/* data */
						skb,
						tp->t.snd_una - TCP_SKB_CB(skb)->seq);
		queueNewRequest(sk, (struct Request*)newConvReq);
		//printk("process_incomplete_request set conversion state to waitforserver\n");
	}
	return 0;
}

#define LEFT 0
#define RIGHT 1

/* insertNewDep is used to insert a dependency into a blank range where no previous dependency ever existed */
static inline int insertNewDep(struct UC_DependencyNode *left, struct UC_DependencyNode *right, struct UC_DependencyNode *newDep, int side) {
	unsigned newStart, newEnd;
	struct UC_DependencyNode *clone;
	struct alloc_head *prev, *next;

	if(left == NULL) {
		newStart = newDep->start;
	} else {
		newStart = MAX(left->end, newDep->start);
		prev = (struct alloc_head*)left;
		next = left->next;
	}
	if(right == NULL) {
		newEnd = newDep->end;
	} else {
		newEnd = MIN(newDep->end, right->start);
		prev = right->prev;
		next = (struct alloc_head*)right;
	}
	switch(side) {
	case LEFT:
		if(right) {
			if(newDep->start >= right->start) {
				printk("insertNewDep: supposed to insert on left, but newDep is not at the left\n");
				return -1;
			}
		} else {
			printk("insertNewDep: supposed to insert on left, but nothing to the right\n");
			return -1;
		}
		break;
	case RIGHT:
		if(left) {
			if(newDep->end <= left->end) {
				printk("insertNewDep: supposed to insert on right, but newDep is not at the right\n");
				return -1;
			}
		} else {
			printk("insertNewDep: supposed to insert on right, but nothing to the left\n");
			return -1;
		}
		break;
	default:
		printk("insertNewDep: unknown side\n");
		return -1;
	}
	clone = copyUC_DependencyNode(newDep);
	if(clone == NULL) {
		printk("Out of memory while creating dependency at %d side\n", side);
		return -1;
	}
	insert((struct alloc_head*)clone, prev, next);
	return 0;
}

static inline int addNewUC_Continuation(struct sock *sk, struct UC_Continuation *newCont) {
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	struct UC_Continuation *insertPos;

	// find place to insert new continuation
	alloc_head_reverse_walk(&tp->t.ucontList, insertPos) {
		/* insert the new continuation in the proper location */
		if(insertPos->clientValidStart < newCont->validStart) break;
	}
	newCont->clientValidStart = newCont->validStart;
	newCont->clientValidEnd = newCont->validEnd;

	// find intersections
	// Real validStart and validEnd should NOT be touched in this block
	struct alloc_head_list *insertionList = &tp->t.ucontList;
	insert((struct alloc_head*)newCont,
	       (struct alloc_head*)insertPos, (struct alloc_head*)insertPos->next);

	// Now, resolve overlaps
	struct UC_Continuation *finger = (struct UC_Continuation *)insertPos, *nextCont;

	if((struct alloc_head_list*)finger == insertionList) {
		finger = (struct UC_Continuation*) finger->next;
	}
	unsigned lastByte = newCont->clientValidEnd;
	for(; (struct alloc_head_list*)finger->next != insertionList; finger = nextCont) {
		nextCont = (struct UC_Continuation *)finger->next;
		unsigned start = MAX(finger->clientValidStart, nextCont->clientValidStart),
			end = MIN(finger->clientValidEnd, nextCont->clientValidEnd);
		if(start < end) {
			struct UC_Continuation *left = NULL, *middle = NULL, *right = NULL,
				*older = NULL, *newer = NULL;
			struct alloc_head *iPrev = finger->prev;
			struct alloc_head *iPrev0 = iPrev;
			struct alloc_head *iNext = nextCont->next;

			// let newest continuation take intersection
			if(finger->seq > nextCont->seq) {
				older = nextCont;
				newer = finger;
			} else {
				older = finger;
				newer = nextCont;
			}
			if(older->clientValidStart < start) {
				left = older;
			}
			middle = newer;
			if(older->clientValidEnd > end) {
				if(left == older) {
					struct UC_Continuation *older1 = copyUC_Continuation(older);
					if(older1 == NULL) {
						printk("Out of memory while splitting continuation\n");
						return -1;
					}
#if 0 // 0707 -- unclear ???
					right->prev = right->next = NULL;
					right->list = NULL;
#endif
					right = older1;
				} else {
					right = older;
				}
			} else {
				if(!left) {
					BUG_TRAP(older != NULL);
					// older completely overlapped
					unlink((struct alloc_head*)older);
					kfree(older);
				}
			}
			if(left) {
				if(left->list)
					unlink((struct alloc_head*)left);
				left->clientValidEnd = start;
			}
			if(middle) {
				if(middle->list)
					unlink((struct alloc_head*)middle);
				// no clientValid* adjustment necessary, since middle is preserved
			}
			if(right) {
				if(right->list)
					unlink((struct alloc_head*)right);
				right->clientValidStart = end;
			}
			if(left) {
				insert((struct alloc_head*)left, iPrev, iNext);
				iPrev = (struct alloc_head *)left;
			}
			if(middle) {
				insert((struct alloc_head*)middle, iPrev, iNext);
				iPrev = (struct alloc_head*)middle;
			}
			if(right) {
				insert((struct alloc_head*)right, iPrev, iNext);
				iPrev = (struct alloc_head*)right;
			}
			/* Sanity checks */
			{
				struct UC_Continuation *finger = (struct UC_Continuation*)iPrev0;
				while((struct alloc_head*)finger->next != iNext) {
					if((struct alloc_head_list*)finger != insertionList &&
					   (struct alloc_head_list*)finger->next != insertionList) {
						BUG_TRAP(finger->clientValidEnd <=
							 ((struct UC_Continuation*)finger->next)->clientValidStart);
					}
					finger = (struct UC_Continuation*)finger->next;
				}
			}
			nextCont = (struct UC_Continuation*)iPrev0; // XXX iNext->prev is a more efficient resumption point
		}
		if(end >= lastByte) {
			// no more overlaps possible
			break;
		}
	}
	// it's possible for client timer to block because we dont have continuations
	// XXX we may wish to guard this with more stringent checks to avoid unnecessary timeouts?
	resetClientTimer(sk);
	return 0;
}

void updateParent(struct sock *sk, enum UserRequestType matchType, unsigned matchID,
		 unsigned numSiblings, unsigned position,
		 unsigned start, unsigned end) {
    215f:	55                   	push   %ebp
    2160:	89 e5                	mov    %esp,%ebp
    2162:	83 ec 30             	sub    $0x30,%esp
	/* Additional POSTCONDITION:
	   tp->t.request_rcv_nxt updated
	*/
	int k;
	int foundCleanable = 0;
    2165:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    216c:	8b 45 08             	mov    0x8(%ebp),%eax
    216f:	05 bc 00 00 00       	add    $0xbc,%eax
    2174:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	struct alloc_head_list *list_heads[] = {&tp->t.sentRequests,
    2177:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    217a:	05 84 09 00 00       	add    $0x984,%eax
    217f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    2182:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    2185:	05 98 09 00 00       	add    $0x998,%eax
    218a:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
						&tp->t.queuedRequests};
	struct Request *parent_req;
	for(k=0; k < sizeof(list_heads)/sizeof(list_heads[0]); k++) {
    218d:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
    2194:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
    2198:	76 05                	jbe    219f <updateParent+0x40>
    219a:	e9 f5 01 00 00       	jmp    2394 <updateParent+0x235>
		struct alloc_head_list *head = list_heads[k];
    219f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    21a2:	8b 44 85 ec          	mov    0xffffffec(%ebp,%eax,4),%eax
    21a6:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
		alloc_head_walk(head, parent_req) {
    21a9:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    21ac:	8b 40 04             	mov    0x4(%eax),%eax
    21af:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    21b2:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    21b5:	3b 45 e4             	cmp    0xffffffe4(%ebp),%eax
    21b8:	75 05                	jne    21bf <updateParent+0x60>
    21ba:	e9 c3 01 00 00       	jmp    2382 <updateParent+0x223>
			unsigned positionMask = 1 << position;
    21bf:	b8 01 00 00 00       	mov    $0x1,%eax
    21c4:	0f b6 4d 18          	movzbl 0x18(%ebp),%ecx
    21c8:	d3 e0                	shl    %cl,%eax
    21ca:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
			unsigned allMask;
			if(matchID != parent_req->seq) {
    21cd:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    21d0:	8b 45 10             	mov    0x10(%ebp),%eax
    21d3:	3b 42 3c             	cmp    0x3c(%edx),%eax
    21d6:	74 05                	je     21dd <updateParent+0x7e>
				continue;
    21d8:	e9 97 01 00 00       	jmp    2374 <updateParent+0x215>
			}
			if(parent_req->type != matchType) {
    21dd:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    21e0:	8b 40 0c             	mov    0xc(%eax),%eax
    21e3:	3b 45 0c             	cmp    0xc(%ebp),%eax
    21e6:	74 11                	je     21f9 <updateParent+0x9a>
				printk("updateParent: type does not match\n");
    21e8:	c7 04 24 a0 0a 00 00 	movl   $0xaa0,(%esp,1)
    21ef:	e8 fc ff ff ff       	call   21f0 <updateParent+0x91>
				return;
    21f4:	e9 ad 01 00 00       	jmp    23a6 <updateParent+0x247>
			}
			foundCleanable = 1;
    21f9:	c7 45 f8 01 00 00 00 	movl   $0x1,0xfffffff8(%ebp)

			if(numSiblings > MAX_MREQ_CHILDREN) {
    2200:	83 7d 14 04          	cmpl   $0x4,0x14(%ebp)
    2204:	76 11                	jbe    2217 <updateParent+0xb8>
				printk("Too many siblings!\n");
    2206:	c7 04 24 c3 0a 00 00 	movl   $0xac3,(%esp,1)
    220d:	e8 fc ff ff ff       	call   220e <updateParent+0xaf>
				return;
    2212:	e9 8f 01 00 00       	jmp    23a6 <updateParent+0x247>
			}
			if(position >= numSiblings) {
    2217:	8b 45 18             	mov    0x18(%ebp),%eax
    221a:	3b 45 14             	cmp    0x14(%ebp),%eax
    221d:	72 11                	jb     2230 <updateParent+0xd1>
				printk("position >= numSiblings!\n");
    221f:	c7 04 24 d7 0a 00 00 	movl   $0xad7,(%esp,1)
    2226:	e8 fc ff ff ff       	call   2227 <updateParent+0xc8>
				return;
    222b:	e9 76 01 00 00       	jmp    23a6 <updateParent+0x247>
			}
			if(!(parent_req->numChildren == 0 ||
    2230:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    2233:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
    2237:	74 1c                	je     2255 <updateParent+0xf6>
    2239:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    223c:	8b 45 14             	mov    0x14(%ebp),%eax
    223f:	3b 42 10             	cmp    0x10(%edx),%eax
    2242:	74 11                	je     2255 <updateParent+0xf6>
			     numSiblings == parent_req->numChildren)) {
				printk("Inconsistent number of siblings!\n");
    2244:	c7 04 24 00 0b 00 00 	movl   $0xb00,(%esp,1)
    224b:	e8 fc ff ff ff       	call   224c <updateParent+0xed>
				return;
    2250:	e9 51 01 00 00       	jmp    23a6 <updateParent+0x247>
			}
			if(parent_req->childrenMask & positionMask) {
    2255:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    2258:	0f b6 40 14          	movzbl 0x14(%eax),%eax
    225c:	83 e0 0f             	and    $0xf,%eax
    225f:	23 45 e0             	and    0xffffffe0(%ebp),%eax
    2262:	85 c0                	test   %eax,%eax
    2264:	74 11                	je     2277 <updateParent+0x118>
				printk("Already received this child\n");
    2266:	c7 04 24 22 0b 00 00 	movl   $0xb22,(%esp,1)
    226d:	e8 fc ff ff ff       	call   226e <updateParent+0x10f>
				return;
    2272:	e9 2f 01 00 00       	jmp    23a6 <updateParent+0x247>
			}
			parent_req->numChildren = numSiblings;
    2277:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    227a:	8b 55 14             	mov    0x14(%ebp),%edx
    227d:	89 50 10             	mov    %edx,0x10(%eax)
			if(parent_req->numChildren == 0) {
    2280:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    2283:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
    2287:	75 11                	jne    229a <updateParent+0x13b>
				printk("numChildren == 0 (not possible, because we just received a child\n");
    2289:	c7 04 24 40 0b 00 00 	movl   $0xb40,(%esp,1)
    2290:	e8 fc ff ff ff       	call   2291 <updateParent+0x132>
				return;
    2295:	e9 0c 01 00 00       	jmp    23a6 <updateParent+0x247>
			}
			parent_req->childrenMask |= positionMask;
    229a:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
    229d:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    22a0:	0f b6 40 14          	movzbl 0x14(%eax),%eax
    22a4:	83 e0 0f             	and    $0xf,%eax
    22a7:	89 c2                	mov    %eax,%edx
    22a9:	0b 55 e0             	or     0xffffffe0(%ebp),%edx
    22ac:	0f b6 41 14          	movzbl 0x14(%ecx),%eax
    22b0:	80 e2 0f             	and    $0xf,%dl
    22b3:	24 f0                	and    $0xf0,%al
    22b5:	08 d0                	or     %dl,%al
    22b7:	88 41 14             	mov    %al,0x14(%ecx)
			allMask = (unsigned)(1 << parent_req->numChildren) - 1;
    22ba:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    22bd:	ba 01 00 00 00       	mov    $0x1,%edx
    22c2:	0f b6 48 10          	movzbl 0x10(%eax),%ecx
    22c6:	89 d0                	mov    %edx,%eax
    22c8:	d3 e0                	shl    %cl,%eax
    22ca:	48                   	dec    %eax
    22cb:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)

			if((parent_req->childrenMask & allMask) == allMask) {
    22ce:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    22d1:	0f b6 40 14          	movzbl 0x14(%eax),%eax
    22d5:	83 e0 0f             	and    $0xf,%eax
    22d8:	23 45 dc             	and    0xffffffdc(%ebp),%eax
    22db:	3b 45 dc             	cmp    0xffffffdc(%ebp),%eax
    22de:	0f 85 90 00 00 00    	jne    2374 <updateParent+0x215>
				/* Server may not have generated an update covering the entire continuation. If not, resubmit request */
				switch(parent_req->type) {
    22e4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    22e7:	8b 40 0c             	mov    0xc(%eax),%eax
    22ea:	83 f8 01             	cmp    $0x1,%eax
    22ed:	77 54                	ja     2343 <updateParent+0x1e4>
				case MREQ_CONTINUATION:
				case MREQ_CONVERSION: {
					// Deallocate parent
					// avoid stale pointer dereference when doing next step of alloc_head_walk
					struct Request *clean = parent_req;
    22ef:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    22f2:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
					BUG_TRAP(parent_req->seq == tp->t.request_rcv_nxt);
    22f5:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    22f8:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    22fb:	8b 40 3c             	mov    0x3c(%eax),%eax
    22fe:	3b 82 5c 09 00 00    	cmp    0x95c(%edx),%eax
    2304:	74 14                	je     231a <updateParent+0x1bb>
    2306:	c7 44 24 04 44 06 00 	movl   $0x644,0x4(%esp,1)
    230d:	00 
    230e:	c7 04 24 a0 0b 00 00 	movl   $0xba0,(%esp,1)
    2315:	e8 fc ff ff ff       	call   2316 <updateParent+0x1b7>
					tp->t.request_rcv_nxt++;
    231a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    231d:	ff 80 5c 09 00 00    	incl   0x95c(%eax)

					parent_req = (struct Request *)clean->prev;
    2323:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    2326:	8b 00                	mov    (%eax),%eax
    2328:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
					//printk("removed %u-%u\n", clean->start, clean->end);
					unlink((struct alloc_head*)clean);
    232b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    232e:	89 04 24             	mov    %eax,(%esp,1)
    2331:	e8 b6 6f 00 00       	call   92ec <unlink>
					freeRequest(clean);
    2336:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    2339:	89 04 24             	mov    %eax,(%esp,1)
    233c:	e8 fc ff ff ff       	call   233d <updateParent+0x1de>
					break;
    2341:	eb 31                	jmp    2374 <updateParent+0x215>
				}
				default:
					printk("updateParent: unsupported parent type\n");
    2343:	c7 04 24 00 0c 00 00 	movl   $0xc00,(%esp,1)
    234a:	e8 fc ff ff ff       	call   234b <updateParent+0x1ec>
					BUG();
    234f:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    2356:	00 
    2357:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    235e:	e8 fc ff ff ff       	call   235f <updateParent+0x200>
    2363:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    236a:	e8 fc ff ff ff       	call   236b <updateParent+0x20c>
    236f:	e8 fc ff ff ff       	call   2370 <updateParent+0x211>
    2374:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    2377:	8b 40 04             	mov    0x4(%eax),%eax
    237a:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    237d:	e9 30 fe ff ff       	jmp    21b2 <updateParent+0x53>
				}
			}
		}
		/* back in outer loop */
		if(foundCleanable) {
    2382:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    2386:	74 02                	je     238a <updateParent+0x22b>
			break;
    2388:	eb 0a                	jmp    2394 <updateParent+0x235>
    238a:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
    238d:	ff 00                	incl   (%eax)
    238f:	e9 00 fe ff ff       	jmp    2194 <updateParent+0x35>
		}
	}
	if(!foundCleanable) {
    2394:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    2398:	75 0c                	jne    23a6 <updateParent+0x247>
		printk("Error: could not find matching request in reliable request queue!\n");
    239a:	c7 04 24 40 0c 00 00 	movl   $0xc40,(%esp,1)
    23a1:	e8 fc ff ff ff       	call   23a2 <updateParent+0x243>
	}
}
    23a6:	c9                   	leave  
    23a7:	c3                   	ret    

000023a8 <removeObsoleteContinuations>:

void removeObsoleteContinuations(struct sock *sk) {
    23a8:	55                   	push   %ebp
    23a9:	89 e5                	mov    %esp,%ebp
    23ab:	83 ec 14             	sub    $0x14,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    23ae:	8b 45 08             	mov    0x8(%ebp),%eax
    23b1:	05 bc 00 00 00       	add    $0xbc,%eax
    23b6:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	struct UC_Continuation *ucont;
	int count = 0;
    23b9:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
	alloc_head_walk(&tp->t.ucontList, ucont) {
    23c0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    23c3:	05 00 0a 00 00       	add    $0xa00,%eax
    23c8:	8b 40 04             	mov    0x4(%eax),%eax
    23cb:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    23ce:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    23d1:	05 00 0a 00 00       	add    $0xa00,%eax
    23d6:	39 45 f8             	cmp    %eax,0xfffffff8(%ebp)
    23d9:	75 02                	jne    23dd <removeObsoleteContinuations+0x35>
    23db:	eb 45                	jmp    2422 <removeObsoleteContinuations+0x7a>
#if 0
		if(ucont->kernel.obsoleteAt <= tp->rcv_nxt) {
		}
#else
		if(ucont->kernel.obsoleteAt <= tp->copied_seq) {
    23dd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    23e0:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    23e3:	8b 40 2c             	mov    0x2c(%eax),%eax
    23e6:	3b 82 fc 00 00 00    	cmp    0xfc(%edx),%eax
    23ec:	77 29                	ja     2417 <removeObsoleteContinuations+0x6f>
#endif
			struct UC_Continuation *clean = ucont;
    23ee:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    23f1:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
#ifdef FINDUC_DBG
			printk("Removed continuation c=%d o=%d [%d-%d] [%d-%d]\n",
			       count, clean->kernel.obsoleteAt,
			       clean->validStart, clean->validEnd,
			       clean->clientValidStart, clean->clientValidEnd);
#endif
			ucont = (struct UC_Continuation*)ucont->prev;
    23f4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    23f7:	8b 00                	mov    (%eax),%eax
    23f9:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
			unlink((struct alloc_head*)clean);
    23fc:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    23ff:	89 04 24             	mov    %eax,(%esp,1)
    2402:	e8 e5 6e 00 00       	call   92ec <unlink>
			count++;
    2407:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
    240a:	ff 00                	incl   (%eax)
			kfree(clean);
    240c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    240f:	89 04 24             	mov    %eax,(%esp,1)
    2412:	e8 fc ff ff ff       	call   2413 <removeObsoleteContinuations+0x6b>
    2417:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    241a:	8b 40 04             	mov    0x4(%eax),%eax
    241d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    2420:	eb ac                	jmp    23ce <removeObsoleteContinuations+0x26>
		}
	}
}
    2422:	c9                   	leave  
    2423:	c3                   	ret    

00002424 <removeObsoleteDependencies>:

void removeObsoleteDependencies(struct sock *sk) {
    2424:	55                   	push   %ebp
    2425:	89 e5                	mov    %esp,%ebp
    2427:	83 ec 14             	sub    $0x14,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    242a:	8b 45 08             	mov    0x8(%ebp),%eax
    242d:	05 bc 00 00 00       	add    $0xbc,%eax
    2432:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	struct UC_DependencyNode *depNode;
	/* Drop reference count for dependency nodes that we no longer need for requesting new data */
	alloc_head_walk(&tp->t.depNodeList, depNode) {
    2435:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    2438:	05 14 0a 00 00       	add    $0xa14,%eax
    243d:	8b 40 04             	mov    0x4(%eax),%eax
    2440:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    2443:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    2446:	05 14 0a 00 00       	add    $0xa14,%eax
    244b:	39 45 f8             	cmp    %eax,0xfffffff8(%ebp)
    244e:	75 02                	jne    2452 <removeObsoleteDependencies+0x2e>
    2450:	eb 2f                	jmp    2481 <removeObsoleteDependencies+0x5d>
		struct UC_DependencyNode *prev = (struct UC_DependencyNode*)depNode->prev;
    2452:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    2455:	8b 00                	mov    (%eax),%eax
    2457:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		if(freeDependencyNode(sk,depNode) == 0) {
    245a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    245d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    2461:	8b 45 08             	mov    0x8(%ebp),%eax
    2464:	89 04 24             	mov    %eax,(%esp,1)
    2467:	e8 f0 7e 00 00       	call   a35c <freeDependencyNode>
    246c:	85 c0                	test   %eax,%eax
    246e:	75 06                	jne    2476 <removeObsoleteDependencies+0x52>
			/* dependency was freed and unlinked, so avoid dereferencing a dangling pointer */
			depNode = prev;
    2470:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    2473:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    2476:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    2479:	8b 40 04             	mov    0x4(%eax),%eax
    247c:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    247f:	eb c2                	jmp    2443 <removeObsoleteDependencies+0x1f>
		}
	}
}
    2481:	c9                   	leave  
    2482:	c3                   	ret    

00002483 <UpdateClientTransportState>:

static inline void removeObsoleteDataRequestMaps(struct sock *sk, unsigned transportSeq) {
	/* Side effect: updates rtt estimate */
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	int i;
	struct DataRequestMapping *dataReqMap, *nextDataReqMap;
	struct alloc_head_list* dataRequestLists[] = {
		&tp->t.dataRequestMap,
		&tp->t.missingDataMap};

	TIMING_CTX_DEF0("removeObsoleteDataRequestMaps", "requestMap", "missingMap");
	TIMING_CTX_DEF1(1,1);
	reinitTimingCtx(&ctx);
	for(i=0; i < 2; i++) {
		struct alloc_head_list *currList = dataRequestLists[i];
		recordSample(&ctx, i);
		for(dataReqMap = (struct DataRequestMapping *)currList->next;
		    dataReqMap != (struct DataRequestMapping *)currList;
		    dataReqMap = nextDataReqMap) {
			int freed = 0;
			nextDataReqMap = dataReqMap->next;

			if(dataReqMap->end <= tp->rcv_nxt) {
				unlink((struct alloc_head*)dataReqMap);
				/* update rtt estimate if obsolete request matches current packet */
				// XXX - with this algorithm, reordering inflates rtt (timing is updated when the packet can be delivered in-order, not when it is first received)
				// XXX should we test the sequence number?
				if(1 /* || dataReqMap->transportResponseSeqStart <= transportSeq &&
					transportSeq < dataReqMap->transportResponseSeqEnd */) {
#ifdef FIXEDRTT
					tp->t.A = (FIXEDRTT);
#else
					// code moved to trickles_client_rcv
#endif
					{
						static int rttCounter = 0;
						rttCounter++;
						if(clientDebugLevel >= 2) {
							if(rttCounter % 1000 == 0)
								printk("HZ=%d delta %lu, new rtt %d %d/8\n", HZ, jiffies - dataReqMap->timestamp, tp->t.A >> 3, tp->t.A & 0x7);
						}
					}
				}
				freeDataRequestMapping(dataReqMap);
				freed = 1;
				resetClientTimer(sk);
			}
			if(!freed && dataReqMap->sent &&
			   !dataReqMap->completed && // hint
			   tp->t.rcv_nxt >= dataReqMap->transportResponseSeqEnd) {
				//printk("tp->t.rcv_nxt = %u dataReqMap->transportResponseSeqEnd = %d\n", tp->t.rcv_nxt, dataReqMap->transportResponseSeqEnd);
				// dataReqMap is still valid
				// If tp->t.rcv_nxt >= transportSeqEnd, then the server may not have sent us the full request.
				// Find missing parts of the request, and resubmit

				// save old head
				struct alloc_head *prevMap = (struct alloc_head*) dataReqMap->prev,
					*nextMap = (struct alloc_head*)dataReqMap->next;
				int inserted = 0;
				int lastEnd = MAX(dataReqMap->start, tp->rcv_nxt);
				struct sk_buff *finger = tp->t.ofo_queue.next;
				unlink((struct alloc_head*)dataReqMap);

				// XXX 0505 OPTIMIZE - Pick optimal walking direction? Would probably result in 2x speedup if we
				// check whether we're closer to the left or the right
				skb_queue_walk(&tp->t.data_ofo_queue, finger) {
					// detect overlap
					int minSeq = MAX(TCP_SKB_CB(finger)->seq, dataReqMap->start);
					int maxSeq = MIN(TCP_SKB_CB(finger)->end_seq, dataReqMap->end);
					if(maxSeq >= dataReqMap->end) {
						break;
					}
					if(minSeq < maxSeq) {
						// overlap
						if(lastEnd < minSeq) {
							// void between last skb and this skb; ask server to fill it in
							RECORD_MISSINGDATAMAP_INSERTION_HELPER(lastEnd, minSeq);
							submitDerivedDataRequestMapping(sk, dataReqMap, lastEnd, minSeq);
							inserted = 1;
#ifdef SPEW_PARTIAL
							printk("Inserted %d-%d\n", lastEnd, minSeq);
#endif
						}
						lastEnd = maxSeq;
					}
				}

				if(lastEnd < dataReqMap->end) {
					int myStart = lastEnd,
						myEnd = dataReqMap->end;
					if(!inserted) {
						// common case: server omitted data at the end of the request.
						// Reuse existing mapping
						RECORD_MISSINGDATAMAP_INSERTION_HELPER(myStart, myEnd);
						submitDataRequestMapping(sk, dataReqMap, myStart, myEnd);
#ifdef SPEW_PARTIAL
						printk("Inserted %d-%d\n", myStart, myEnd);
#endif
					} else {
						RECORD_MISSINGDATAMAP_INSERTION_HELPER(myStart, myEnd);
						submitDerivedDataRequestMapping(sk, dataReqMap, myStart, myEnd);
#ifdef SPEW_PARTIAL
						printk("Inserted %d-%d\n", myStart, myEnd);
#endif
					}
				} else {
					if(!inserted) {
						// request is completely covered; put it back
						dataReqMap->completed = 1;
						insert((struct alloc_head*)dataReqMap, prevMap, nextMap);
					}
				}
			}
		}
		recordSample(&ctx, i);
	}
	printTimings(&ctx);
}

void UpdateClientTransportState(struct sock *sk, struct sk_buff *skb, CONTINUATION_TYPE *cont) {
    2483:	55                   	push   %ebp
    2484:	89 e5                	mov    %esp,%ebp
    2486:	57                   	push   %edi
    2487:	56                   	push   %esi
    2488:	83 ec 44             	sub    $0x44,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    248b:	8b 45 08             	mov    0x8(%ebp),%eax
    248e:	05 bc 00 00 00       	add    $0xbc,%eax
    2493:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	// if noCont, then no available information for updating state machine
	BUG_TRAP(cont->seq <= tp->t.rcv_nxt);
    2496:	8b 45 10             	mov    0x10(%ebp),%eax
    2499:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    249c:	8b 40 30             	mov    0x30(%eax),%eax
    249f:	3b 82 e0 02 00 00    	cmp    0x2e0(%edx),%eax
    24a5:	76 14                	jbe    24bb <UpdateClientTransportState+0x38>
    24a7:	c7 44 24 04 fd 06 00 	movl   $0x6fd,0x4(%esp,1)
    24ae:	00 
    24af:	c7 04 24 a0 0c 00 00 	movl   $0xca0,(%esp,1)
    24b6:	e8 fc ff ff ff       	call   24b7 <UpdateClientTransportState+0x34>
#define UPTODATE(CONT) ((CONT)->clientState == tp->t.clientStateCounter)
	/* Transport level updates */
	if(cont->continuationType == CONTTYPE_MINIMAL) {
    24bb:	8b 45 10             	mov    0x10(%ebp),%eax
    24be:	83 78 34 00          	cmpl   $0x0,0x34(%eax)
    24c2:	75 05                	jne    24c9 <UpdateClientTransportState+0x46>
		// minimal continuation type cannot update transport state
		return;
    24c4:	e9 8b 04 00 00       	jmp    2954 <UpdateClientTransportState+0x4d1>
	}
	switch(tp->t.state) {
    24c9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    24cc:	8b 80 cc 02 00 00    	mov    0x2cc(%eax),%eax
    24d2:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
    24d5:	83 7d c8 02          	cmpl   $0x2,0xffffffc8(%ebp)
    24d9:	74 72                	je     254d <UpdateClientTransportState+0xca>
    24db:	83 7d c8 02          	cmpl   $0x2,0xffffffc8(%ebp)
    24df:	7f 0b                	jg     24ec <UpdateClientTransportState+0x69>
    24e1:	83 7d c8 01          	cmpl   $0x1,0xffffffc8(%ebp)
    24e5:	74 14                	je     24fb <UpdateClientTransportState+0x78>
    24e7:	e9 68 04 00 00       	jmp    2954 <UpdateClientTransportState+0x4d1>
    24ec:	83 7d c8 03          	cmpl   $0x3,0xffffffc8(%ebp)
    24f0:	0f 84 8e 00 00 00    	je     2584 <UpdateClientTransportState+0x101>
    24f6:	e9 59 04 00 00       	jmp    2954 <UpdateClientTransportState+0x4d1>
	case TRICKLES_CLIENT_NORMAL:
		if(cont->firstChild)
    24fb:	8b 45 10             	mov    0x10(%ebp),%eax
    24fe:	83 78 58 00          	cmpl   $0x0,0x58(%eax)
    2502:	0f 84 4c 04 00 00    	je     2954 <UpdateClientTransportState+0x4d1>
			tp->t.in_flight = MAX(0, tp->t.in_flight - 1);
    2508:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    250b:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    250e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    2511:	8b 80 00 03 00 00    	mov    0x300(%eax),%eax
    2517:	48                   	dec    %eax
    2518:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    251b:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
    2522:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    2525:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    2528:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    252b:	89 55 dc             	mov    %edx,0xffffffdc(%ebp)
    252e:	8b 75 dc             	mov    0xffffffdc(%ebp),%esi
    2531:	3b 75 ec             	cmp    0xffffffec(%ebp),%esi
    2534:	7d 06                	jge    253c <UpdateClientTransportState+0xb9>
    2536:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
    2539:	89 7d dc             	mov    %edi,0xffffffdc(%ebp)
    253c:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    253f:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    2542:	89 90 00 03 00 00    	mov    %edx,0x300(%eax)
		break;
    2548:	e9 07 04 00 00       	jmp    2954 <UpdateClientTransportState+0x4d1>
	case TRICKLES_CLIENT_RECOVERY:
		if(cont->state == CONT_BOOTSTRAP &&
    254d:	8b 45 10             	mov    0x10(%ebp),%eax
    2550:	83 78 54 02          	cmpl   $0x2,0x54(%eax)
    2554:	0f 85 fa 03 00 00    	jne    2954 <UpdateClientTransportState+0x4d1>
    255a:	8b 45 10             	mov    0x10(%ebp),%eax
    255d:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    2560:	8b 40 38             	mov    0x38(%eax),%eax
    2563:	3b 82 c8 02 00 00    	cmp    0x2c8(%edx),%eax
    2569:	0f 85 e5 03 00 00    	jne    2954 <UpdateClientTransportState+0x4d1>
		   UPTODATE(cont)) {
			if(clientDebugLevel >= 2)
    256f:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    2576:	7e 0c                	jle    2584 <UpdateClientTransportState+0x101>
				printk("received bootstrap continuation\n");
    2578:	c7 04 24 00 0d 00 00 	movl   $0xd00,(%esp,1)
    257f:	e8 fc ff ff ff       	call   2580 <UpdateClientTransportState+0xfd>
			/* during recovery, need to switch to bootstrap continuation */
			/* If bootstrap state, fall through to check if we should exit from recovery */
			goto exit_recovery;
		} else {
			break;
		}
	case TRICKLES_CLIENT_SLOWSTART:
	exit_recovery:
		if(UPTODATE(cont) && cont->seq == cont->TCPBase) {
    2584:	8b 45 10             	mov    0x10(%ebp),%eax
    2587:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    258a:	8b 40 38             	mov    0x38(%eax),%eax
    258d:	3b 82 c8 02 00 00    	cmp    0x2c8(%edx),%eax
    2593:	0f 85 bb 03 00 00    	jne    2954 <UpdateClientTransportState+0x4d1>
    2599:	8b 45 10             	mov    0x10(%ebp),%eax
    259c:	8b 55 10             	mov    0x10(%ebp),%edx
    259f:	8b 40 30             	mov    0x30(%eax),%eax
    25a2:	3b 42 6c             	cmp    0x6c(%edx),%eax
    25a5:	0f 85 a9 03 00 00    	jne    2954 <UpdateClientTransportState+0x4d1>
			/* exit recovery */
			CONTINUATION_TYPE *cont_curs, *next;
			__u32 prev_seq = tp->t.ack_prev->TCPBase; // 0501 cleanup
    25ab:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    25ae:	8b 80 f4 02 00 00    	mov    0x2f4(%eax),%eax
    25b4:	8b 40 6c             	mov    0x6c(%eax),%eax
    25b7:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
			if(clientDebugLevel >= 1)
    25ba:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    25c1:	7e 31                	jle    25f4 <UpdateClientTransportState+0x171>
				printk("client_rcv: exit recovery or slow start : seq = %u oldBase = %u newBase = %u startCwnd = %u\n", cont->seq,
    25c3:	8b 45 10             	mov    0x10(%ebp),%eax
    25c6:	8b 40 64             	mov    0x64(%eax),%eax
    25c9:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    25cd:	8b 45 10             	mov    0x10(%ebp),%eax
    25d0:	8b 40 6c             	mov    0x6c(%eax),%eax
    25d3:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    25d7:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    25da:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    25de:	8b 45 10             	mov    0x10(%ebp),%eax
    25e1:	8b 40 30             	mov    0x30(%eax),%eax
    25e4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    25e8:	c7 04 24 40 0d 00 00 	movl   $0xd40,(%esp,1)
    25ef:	e8 fc ff ff ff       	call   25f0 <UpdateClientTransportState+0x16d>
				       prev_seq, cont->TCPBase, cont->startCwnd);

			tp->t.standardProof.numSacks = 0;
    25f4:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    25f7:	c7 80 04 03 00 00 00 	movl   $0x0,0x304(%eax)
    25fe:	00 00 00 
			AckProof_update(sk, &tp->t.standardProof, cont);
    2601:	8b 45 10             	mov    0x10(%ebp),%eax
    2604:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    2608:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    260b:	05 04 03 00 00       	add    $0x304,%eax
    2610:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    2614:	8b 45 08             	mov    0x8(%ebp),%eax
    2617:	89 04 24             	mov    %eax,(%esp,1)
    261a:	e8 fc ff ff ff       	call   261b <UpdateClientTransportState+0x198>
			for(cont_curs = (CONTINUATION_TYPE*)tp->t.cont_list.next;
    261f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    2622:	8b 80 38 09 00 00    	mov    0x938(%eax),%eax
    2628:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    262b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    262e:	05 34 09 00 00       	add    $0x934,%eax
    2633:	39 45 e8             	cmp    %eax,0xffffffe8(%ebp)
    2636:	75 05                	jne    263d <UpdateClientTransportState+0x1ba>
    2638:	e9 14 01 00 00       	jmp    2751 <UpdateClientTransportState+0x2ce>
			    cont_curs != (CONTINUATION_TYPE*)&tp->t.cont_list;
			    cont_curs = next) {
				next = (CONTINUATION_TYPE*)cont_curs->next;
    263d:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    2640:	8b 40 04             	mov    0x4(%eax),%eax
    2643:	89 45 ec             	mov    %eax,0xffffffec(%ebp)

				// 0424 - tighten up conditions to detect inconsistent states
				/*
				if(((tp->t.state == TRICKLES_CLIENT_SLOWSTART && UPTODATE(cont_curs)) ||
				    ((tp->t.state == TRICKLES_CLIENT_RECOVERY) && cont_curs->seq >= cont->TCPBase))) {
				*/
				if(UPTODATE(cont_curs) && cont_curs->TCPBase >= cont->TCPBase) {
    2646:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    2649:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    264c:	8b 40 38             	mov    0x38(%eax),%eax
    264f:	3b 82 c8 02 00 00    	cmp    0x2c8(%edx),%eax
    2655:	75 53                	jne    26aa <UpdateClientTransportState+0x227>
    2657:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    265a:	8b 55 10             	mov    0x10(%ebp),%edx
    265d:	8b 40 6c             	mov    0x6c(%eax),%eax
    2660:	3b 42 6c             	cmp    0x6c(%edx),%eax
    2663:	72 45                	jb     26aa <UpdateClientTransportState+0x227>
					BUG_TRAP(cont_curs->TCPBase >= cont->TCPBase);
    2665:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    2668:	8b 55 10             	mov    0x10(%ebp),%edx
    266b:	8b 40 6c             	mov    0x6c(%eax),%eax
    266e:	3b 42 6c             	cmp    0x6c(%edx),%eax
    2671:	73 14                	jae    2687 <UpdateClientTransportState+0x204>
    2673:	c7 44 24 04 2b 07 00 	movl   $0x72b,0x4(%esp,1)
    267a:	00 
    267b:	c7 04 24 a0 0d 00 00 	movl   $0xda0,(%esp,1)
    2682:	e8 fc ff ff ff       	call   2683 <UpdateClientTransportState+0x200>
					AckProof_update(sk, &tp->t.standardProof, cont_curs);
    2687:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    268a:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    268e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    2691:	05 04 03 00 00       	add    $0x304,%eax
    2696:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    269a:	8b 45 08             	mov    0x8(%ebp),%eax
    269d:	89 04 24             	mov    %eax,(%esp,1)
    26a0:	e8 fc ff ff ff       	call   26a1 <UpdateClientTransportState+0x21e>
    26a5:	e9 9c 00 00 00       	jmp    2746 <UpdateClientTransportState+0x2c3>
				} else {
					/* there should not be any older continuations in list */
					// XXX 0426 - Additional violation situations are possible if requestSlowStart fails because it cannot find a continuation that can be used for the slow start request
					if(!(cont_curs->clientState == tp->t.clientStateCounter-2 /* recovery followed by slow start */ ||
    26aa:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    26ad:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    26b0:	8b 92 c8 02 00 00    	mov    0x2c8(%edx),%edx
    26b6:	83 ea 02             	sub    $0x2,%edx
    26b9:	39 50 38             	cmp    %edx,0x38(%eax)
    26bc:	74 56                	je     2714 <UpdateClientTransportState+0x291>
    26be:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    26c1:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    26c4:	8b 92 c8 02 00 00    	mov    0x2c8(%edx),%edx
    26ca:	4a                   	dec    %edx
    26cb:	39 50 38             	cmp    %edx,0x38(%eax)
    26ce:	74 44                	je     2714 <UpdateClientTransportState+0x291>
    26d0:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    26d3:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    26d6:	8b 40 38             	mov    0x38(%eax),%eax
    26d9:	3b 82 c8 02 00 00    	cmp    0x2c8(%edx),%eax
    26df:	74 33                	je     2714 <UpdateClientTransportState+0x291>
					     cont_curs->clientState == tp->t.clientStateCounter-1 /* recovery */||
					     cont_curs->clientState == tp->t.clientStateCounter)) {
						if(!disableSevereErrors)
    26e1:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    26e8:	75 2a                	jne    2714 <UpdateClientTransportState+0x291>
							printk("%p: cleaning violation: cursor state %d current client state %d\n",
    26ea:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    26ed:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
    26f3:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    26f7:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    26fa:	8b 40 38             	mov    0x38(%eax),%eax
    26fd:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    2701:	8b 45 08             	mov    0x8(%ebp),%eax
    2704:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    2708:	c7 04 24 00 0e 00 00 	movl   $0xe00,(%esp,1)
    270f:	e8 fc ff ff ff       	call   2710 <UpdateClientTransportState+0x28d>
							       sk, cont_curs->clientState, tp->t.clientStateCounter);
					}
					BUG_TRAP(cont_curs != cont);
    2714:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    2717:	3b 45 10             	cmp    0x10(%ebp),%eax
    271a:	75 14                	jne    2730 <UpdateClientTransportState+0x2ad>
    271c:	c7 44 24 04 37 07 00 	movl   $0x737,0x4(%esp,1)
    2723:	00 
    2724:	c7 04 24 60 0e 00 00 	movl   $0xe60,(%esp,1)
    272b:	e8 fc ff ff ff       	call   272c <UpdateClientTransportState+0x2a9>
					unlinkCont(cont_curs);
    2730:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    2733:	89 04 24             	mov    %eax,(%esp,1)
    2736:	e8 de 84 00 00       	call   ac19 <unlinkCont>
					MARK_PC(cont_curs);
#if 1 // 0430 disabled to isolate bug (yes this reveals a bunch of memory errors)
					freeClientSide_Continuation(cont_curs);
    273b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    273e:	89 04 24             	mov    %eax,(%esp,1)
    2741:	e8 e9 78 00 00       	call   a02f <freeClientSide_Continuation>
    2746:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    2749:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    274c:	e9 da fe ff ff       	jmp    262b <UpdateClientTransportState+0x1a8>
#else
					if((int)cont_curs & 0xfff) {
						BUG();
					}
					BUG_TRAP(((int)cont_curs & 0xfff) == 0);
					zap_virt(cont_curs);
#endif
				}
			}
			/* only up-to-date continuations in cont_list now */
			tp->t.altProof = tp->t.standardProof;
    2751:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    2754:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    2757:	05 0c 06 00 00       	add    $0x60c,%eax
    275c:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    275f:	81 c2 04 03 00 00    	add    $0x304,%edx
    2765:	89 55 d4             	mov    %edx,0xffffffd4(%ebp)
    2768:	c7 45 d0 08 03 00 00 	movl   $0x308,0xffffffd0(%ebp)
    276f:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    2772:	83 e0 04             	and    $0x4,%eax
    2775:	85 c0                	test   %eax,%eax
    2777:	74 16                	je     278f <UpdateClientTransportState+0x30c>
    2779:	8b 75 d4             	mov    0xffffffd4(%ebp),%esi
    277c:	8b 06                	mov    (%esi),%eax
    277e:	8b 7d d8             	mov    0xffffffd8(%ebp),%edi
    2781:	89 07                	mov    %eax,(%edi)
    2783:	83 45 d8 04          	addl   $0x4,0xffffffd8(%ebp)
    2787:	83 45 d4 04          	addl   $0x4,0xffffffd4(%ebp)
    278b:	83 6d d0 04          	subl   $0x4,0xffffffd0(%ebp)
    278f:	fc                   	cld    
    2790:	8b 4d d0             	mov    0xffffffd0(%ebp),%ecx
    2793:	c1 e9 02             	shr    $0x2,%ecx
    2796:	8b 7d d8             	mov    0xffffffd8(%ebp),%edi
    2799:	8b 75 d4             	mov    0xffffffd4(%ebp),%esi
    279c:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
#if 0
			printk("standard ");
			AckProof_dump(&tp->t.standardProof);
			printk("alt ");
			AckProof_dump(&tp->t.altProof);
#endif
			BUG_TRAP(tp->t.standardProof.sacks[0].left <= cont->TCPBase);
    279e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    27a1:	8b 55 10             	mov    0x10(%ebp),%edx
    27a4:	8b 80 0c 03 00 00    	mov    0x30c(%eax),%eax
    27aa:	3b 42 6c             	cmp    0x6c(%edx),%eax
    27ad:	76 14                	jbe    27c3 <UpdateClientTransportState+0x340>
    27af:	c7 44 24 04 4d 07 00 	movl   $0x74d,0x4(%esp,1)
    27b6:	00 
    27b7:	c7 04 24 a0 0e 00 00 	movl   $0xea0,(%esp,1)
    27be:	e8 fc ff ff ff       	call   27bf <UpdateClientTransportState+0x33c>
			BUG_TRAP(tp->t.altProof.sacks[0].left <= cont->TCPBase);
    27c3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    27c6:	8b 55 10             	mov    0x10(%ebp),%edx
    27c9:	8b 80 14 06 00 00    	mov    0x614(%eax),%eax
    27cf:	3b 42 6c             	cmp    0x6c(%edx),%eax
    27d2:	76 14                	jbe    27e8 <UpdateClientTransportState+0x365>
    27d4:	c7 44 24 04 4e 07 00 	movl   $0x74e,0x4(%esp,1)
    27db:	00 
    27dc:	c7 04 24 20 0f 00 00 	movl   $0xf20,(%esp,1)
    27e3:	e8 fc ff ff ff       	call   27e4 <UpdateClientTransportState+0x361>

			tp->t.previous_base = cont->TCPBase;
    27e8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    27eb:	8b 55 10             	mov    0x10(%ebp),%edx
    27ee:	8b 52 6c             	mov    0x6c(%edx),%edx
    27f1:	89 90 e4 02 00 00    	mov    %edx,0x2e4(%eax)
			if(clientDebugLevel >= 1)
    27f7:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    27fe:	7e 34                	jle    2834 <UpdateClientTransportState+0x3b1>
				printk("new cwnd: %d ssthresh: %d seq: %d base: %d\n", cont->startCwnd, cont->ssthresh, cont->seq, cont->TCPBase);
    2800:	8b 45 10             	mov    0x10(%ebp),%eax
    2803:	8b 40 6c             	mov    0x6c(%eax),%eax
    2806:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    280a:	8b 45 10             	mov    0x10(%ebp),%eax
    280d:	8b 40 30             	mov    0x30(%eax),%eax
    2810:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    2814:	8b 45 10             	mov    0x10(%ebp),%eax
    2817:	8b 40 68             	mov    0x68(%eax),%eax
    281a:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    281e:	8b 45 10             	mov    0x10(%ebp),%eax
    2821:	8b 40 64             	mov    0x64(%eax),%eax
    2824:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    2828:	c7 04 24 80 0f 00 00 	movl   $0xf80,(%esp,1)
    282f:	e8 fc ff ff ff       	call   2830 <UpdateClientTransportState+0x3ad>
			if(clientDebugLevel >= 1 ||  debugTransitions) {
    2834:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    283b:	7f 0e                	jg     284b <UpdateClientTransportState+0x3c8>
    283d:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    2844:	75 05                	jne    284b <UpdateClientTransportState+0x3c8>
    2846:	e9 ae 00 00 00       	jmp    28f9 <UpdateClientTransportState+0x476>
				char *oldState;
				switch(tp->t.state) {
    284b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    284e:	8b 80 cc 02 00 00    	mov    0x2cc(%eax),%eax
    2854:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    2857:	83 7d cc 02          	cmpl   $0x2,0xffffffcc(%ebp)
    285b:	74 1f                	je     287c <UpdateClientTransportState+0x3f9>
    285d:	83 7d cc 02          	cmpl   $0x2,0xffffffcc(%ebp)
    2861:	7f 08                	jg     286b <UpdateClientTransportState+0x3e8>
    2863:	83 7d cc 01          	cmpl   $0x1,0xffffffcc(%ebp)
    2867:	74 1c                	je     2885 <UpdateClientTransportState+0x402>
    2869:	eb 48                	jmp    28b3 <UpdateClientTransportState+0x430>
    286b:	83 7d cc 03          	cmpl   $0x3,0xffffffcc(%ebp)
    286f:	74 02                	je     2873 <UpdateClientTransportState+0x3f0>
    2871:	eb 40                	jmp    28b3 <UpdateClientTransportState+0x430>
				case TRICKLES_CLIENT_SLOWSTART:
					oldState = "SlowStart";
    2873:	c7 45 e4 ac 0f 00 00 	movl   $0xfac,0xffffffe4(%ebp)
					break;
    287a:	eb 63                	jmp    28df <UpdateClientTransportState+0x45c>
				case TRICKLES_CLIENT_RECOVERY:
					oldState = "Recovery";
    287c:	c7 45 e4 b6 0f 00 00 	movl   $0xfb6,0xffffffe4(%ebp)
					break;
    2883:	eb 5a                	jmp    28df <UpdateClientTransportState+0x45c>
				case TRICKLES_CLIENT_NORMAL:
					oldState = "NORMAL!!";
    2885:	c7 45 e4 bf 0f 00 00 	movl   $0xfbf,0xffffffe4(%ebp)
					BUG();
    288c:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    2893:	00 
    2894:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    289b:	e8 fc ff ff ff       	call   289c <UpdateClientTransportState+0x419>
    28a0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    28a7:	e8 fc ff ff ff       	call   28a8 <UpdateClientTransportState+0x425>
    28ac:	e8 fc ff ff ff       	call   28ad <UpdateClientTransportState+0x42a>
					break;
    28b1:	eb 2c                	jmp    28df <UpdateClientTransportState+0x45c>
				default:
					oldState = "UNKNOWN!!";
    28b3:	c7 45 e4 c8 0f 00 00 	movl   $0xfc8,0xffffffe4(%ebp)
					BUG();
    28ba:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    28c1:	00 
    28c2:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    28c9:	e8 fc ff ff ff       	call   28ca <UpdateClientTransportState+0x447>
    28ce:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    28d5:	e8 fc ff ff ff       	call   28d6 <UpdateClientTransportState+0x453>
    28da:	e8 fc ff ff ff       	call   28db <UpdateClientTransportState+0x458>
					break;
				}
				printk("%p: %s=>Normal\n", sk, oldState); // 0419
    28df:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    28e2:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    28e6:	8b 45 08             	mov    0x8(%ebp),%eax
    28e9:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    28ed:	c7 04 24 d2 0f 00 00 	movl   $0xfd2,(%esp,1)
    28f4:	e8 fc ff ff ff       	call   28f5 <UpdateClientTransportState+0x472>
			}
			appendTricklesLossEvent(sk, MIN(cont->startCwnd, EVENT_CWND_MAX),
						EVENT_EXTRA_RECV, tp->t.state);

			tp->t.state = TRICKLES_CLIENT_NORMAL;
    28f9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    28fc:	c7 80 cc 02 00 00 01 	movl   $0x1,0x2cc(%eax)
    2903:	00 00 00 
			tp->t.oo_count = 0;
    2906:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    2909:	c7 80 fc 02 00 00 00 	movl   $0x0,0x2fc(%eax)
    2910:	00 00 00 
			tp->t.in_flight = 0;
    2913:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    2916:	c7 80 00 03 00 00 00 	movl   $0x0,0x300(%eax)
    291d:	00 00 00 

			tp->t.timerState = TRICKLES_ENABLE_DATA_TIMEOUT;
    2920:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    2923:	c7 80 dc 02 00 00 01 	movl   $0x1,0x2dc(%eax)
    292a:	00 00 00 
			resetClientTimer(sk);
    292d:	8b 45 08             	mov    0x8(%ebp),%eax
    2930:	89 04 24             	mov    %eax,(%esp,1)
    2933:	e8 fc ff ff ff       	call   2934 <UpdateClientTransportState+0x4b1>

			//SAVE_ACK_PREV(tp);
			tp->t.ack_prev = NULL;
    2938:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    293b:	c7 80 f4 02 00 00 00 	movl   $0x0,0x2f4(%eax)
    2942:	00 00 00 
			tp->t.ack_last = cont->seq;
    2945:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    2948:	8b 45 10             	mov    0x10(%ebp),%eax
    294b:	8b 40 30             	mov    0x30(%eax),%eax
    294e:	89 82 f8 02 00 00    	mov    %eax,0x2f8(%edx)
			//0501 - called twice when recovering
			//findAckables(sk, 0, NULL);
			break;
		}
	}
}
    2954:	83 c4 44             	add    $0x44,%esp
    2957:	5e                   	pop    %esi
    2958:	5f                   	pop    %edi
    2959:	5d                   	pop    %ebp
    295a:	c3                   	ret    

0000295b <UpdateClientUCState>:

static void UpdateClientUCState(struct sock *sk, struct RequestOFOEntry *ofo_entry) {
    295b:	55                   	push   %ebp
    295c:	89 e5                	mov    %esp,%ebp
    295e:	83 ec 60             	sub    $0x60,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    2961:	8b 45 08             	mov    0x8(%ebp),%eax
    2964:	05 bc 00 00 00       	add    $0xbc,%eax
    2969:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	struct WireUC_RespHeader *hdr;
	struct UC_Continuation *addedUCont = NULL;
    296c:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
	CONTINUATION_TYPE *cont = ofo_entry->cont;
    2973:	8b 45 0c             	mov    0xc(%ebp),%eax
    2976:	8b 40 0c             	mov    0xc(%eax),%eax
    2979:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	int ucont_position;
	int ucontNum = 0;
    297c:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)

	/*
	 *
	 *
	 * UC-level updates
	 *
	 *
	 */

	// Examine user continuation
	// 0505 - allow multiple continuations per packet
	//printk("%p @ ucont_len = %d\n", cont->ucont_data, cont->ucont_len);
	for(ucont_position = 0;
    2983:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
    298a:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    298d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    2990:	3b 42 78             	cmp    0x78(%edx),%eax
    2993:	7c 05                	jl     299a <UpdateClientUCState+0x3f>
    2995:	e9 fa 05 00 00       	jmp    2f94 <UpdateClientUCState+0x639>
	    ucont_position < cont->ucont_len;
	    ucont_position += ntohs(hdr->len)) {
		//printk("ucont_position = %d\n", ucont_position);
		void *ucont_start = cont->ucont_data + ucont_position;
    299a:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    299d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    29a0:	03 42 7c             	add    0x7c(%edx),%eax
    29a3:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
		hdr = (struct WireUC_RespHeader *)ucont_start;
    29a6:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    29a9:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
		int ucont_len = ntohs(hdr->len);
    29ac:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    29af:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    29b3:	89 04 24             	mov    %eax,(%esp,1)
    29b6:	e8 fc ff ff ff       	call   29b7 <UpdateClientUCState+0x5c>
    29bb:	0f b7 c0             	movzwl %ax,%eax
    29be:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)

		if(ucont_len < sizeof(struct WireUC_RespHeader)) {
    29c1:	83 7d e0 03          	cmpl   $0x3,0xffffffe0(%ebp)
    29c5:	77 1f                	ja     29e6 <UpdateClientUCState+0x8b>
			printk("User continuation %d @ %d too short\n", ucontNum, ucont_position);
    29c7:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    29ca:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    29ce:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    29d1:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    29d5:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp,1)
    29dc:	e8 fc ff ff ff       	call   29dd <UpdateClientUCState+0x82>
			return;
    29e1:	e9 ae 05 00 00       	jmp    2f94 <UpdateClientUCState+0x639>
		}
		ucontNum++;
    29e6:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
    29e9:	ff 00                	incl   (%eax)

		switch((enum UC_Type)hdr->type) {
    29eb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    29ee:	0f b6 00             	movzbl (%eax),%eax
    29f1:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
    29f4:	83 7d c0 01          	cmpl   $0x1,0xffffffc0(%ebp)
    29f8:	0f 84 e2 00 00 00    	je     2ae0 <UpdateClientUCState+0x185>
    29fe:	83 7d c0 01          	cmpl   $0x1,0xffffffc0(%ebp)
    2a02:	72 19                	jb     2a1d <UpdateClientUCState+0xc2>
    2a04:	83 7d c0 02          	cmpl   $0x2,0xffffffc0(%ebp)
    2a08:	0f 84 57 03 00 00    	je     2d65 <UpdateClientUCState+0x40a>
    2a0e:	83 7d c0 04          	cmpl   $0x4,0xffffffc0(%ebp)
    2a12:	0f 84 d5 03 00 00    	je     2ded <UpdateClientUCState+0x492>
    2a18:	e9 5a 04 00 00       	jmp    2e77 <UpdateClientUCState+0x51c>
		case UC_INCOMPLETE: {
			struct WireUC_CVT_IncompleteResponse *incompleteResp =
    2a1d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    2a20:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
				(struct WireUC_CVT_IncompleteResponse *) hdr;
			int res;
			if(ucont_len < sizeof(*incompleteResp)) {
    2a23:	83 7d e0 0b          	cmpl   $0xb,0xffffffe0(%ebp)
    2a27:	77 11                	ja     2a3a <UpdateClientUCState+0xdf>
				printk("User continuation too short for incomplete response\n");
    2a29:	c7 04 24 40 10 00 00 	movl   $0x1040,(%esp,1)
    2a30:	e8 fc ff ff ff       	call   2a31 <UpdateClientUCState+0xd6>
				return;
    2a35:	e9 5a 05 00 00       	jmp    2f94 <UpdateClientUCState+0x639>
			}
			switch(tp->t.conversionState) {
    2a3a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    2a3d:	8b 80 dc 09 00 00    	mov    0x9dc(%eax),%eax
    2a43:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
    2a46:	83 7d c8 01          	cmpl   $0x1,0xffffffc8(%ebp)
    2a4a:	74 16                	je     2a62 <UpdateClientUCState+0x107>
    2a4c:	83 7d c8 01          	cmpl   $0x1,0xffffffc8(%ebp)
    2a50:	7f 08                	jg     2a5a <UpdateClientUCState+0xff>
    2a52:	83 7d c8 00          	cmpl   $0x0,0xffffffc8(%ebp)
    2a56:	74 41                	je     2a99 <UpdateClientUCState+0x13e>
    2a58:	eb 50                	jmp    2aaa <UpdateClientUCState+0x14f>
    2a5a:	83 7d c8 02          	cmpl   $0x2,0xffffffc8(%ebp)
    2a5e:	74 39                	je     2a99 <UpdateClientUCState+0x13e>
    2a60:	eb 48                	jmp    2aaa <UpdateClientUCState+0x14f>
			case CONVERSION_WAITFORSERVER:
				res = processIncompleteResponse(sk,incompleteResp,ucont_len);
    2a62:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    2a65:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    2a69:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    2a6c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    2a70:	8b 45 08             	mov    0x8(%ebp),%eax
    2a73:	89 04 24             	mov    %eax,(%esp,1)
    2a76:	e8 59 85 00 00       	call   afd4 <processIncompleteResponse>
    2a7b:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
				if(res) {
    2a7e:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
    2a82:	0f 84 00 04 00 00    	je     2e88 <UpdateClientUCState+0x52d>
					printk("Error while processing incompleteResponse\n");
    2a88:	c7 04 24 80 10 00 00 	movl   $0x1080,(%esp,1)
    2a8f:	e8 fc ff ff ff       	call   2a90 <UpdateClientUCState+0x135>
					return;
    2a94:	e9 fb 04 00 00       	jmp    2f94 <UpdateClientUCState+0x639>
				}
				break;
			case CONVERSION_IDLE:
			case CONVERSION_WAITFORUSER:
				printk("Invalid conversion state (supposed to be WAITFORSERVER) while processing incompleteResponse\n");
    2a99:	c7 04 24 c0 10 00 00 	movl   $0x10c0,(%esp,1)
    2aa0:	e8 fc ff ff ff       	call   2aa1 <UpdateClientUCState+0x146>
				return;
    2aa5:	e9 ea 04 00 00       	jmp    2f94 <UpdateClientUCState+0x639>
			default:
				printk("Invalid state!\n");
    2aaa:	c7 04 24 1d 11 00 00 	movl   $0x111d,(%esp,1)
    2ab1:	e8 fc ff ff ff       	call   2ab2 <UpdateClientUCState+0x157>
				BUG();
    2ab6:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    2abd:	00 
    2abe:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    2ac5:	e8 fc ff ff ff       	call   2ac6 <UpdateClientUCState+0x16b>
    2aca:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    2ad1:	e8 fc ff ff ff       	call   2ad2 <UpdateClientUCState+0x177>
    2ad6:	e8 fc ff ff ff       	call   2ad7 <UpdateClientUCState+0x17c>
				return;
    2adb:	e9 b4 04 00 00       	jmp    2f94 <UpdateClientUCState+0x639>
			}
			break;
		}
		case UC_COMPLETE: {
			//printk("complete\n");
			struct WireUC_CVT_CompleteResponse *completeResp =
    2ae0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    2ae3:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
				(struct WireUC_CVT_CompleteResponse *) hdr;
			struct UC_Continuation *ucont;
			if(ucont_len < sizeof(*completeResp)) {
    2ae6:	83 7d e0 14          	cmpl   $0x14,0xffffffe0(%ebp)
    2aea:	77 11                	ja     2afd <UpdateClientUCState+0x1a2>
				printk("User continuation too short for complete response\n");
    2aec:	c7 04 24 40 11 00 00 	movl   $0x1140,(%esp,1)
    2af3:	e8 fc ff ff ff       	call   2af4 <UpdateClientUCState+0x199>
				return;
    2af8:	e9 97 04 00 00       	jmp    2f94 <UpdateClientUCState+0x639>
			}
			//printk("conversionstate\n");
			switch(tp->t.conversionState) {
    2afd:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    2b00:	8b 80 dc 09 00 00    	mov    0x9dc(%eax),%eax
    2b06:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
    2b09:	83 7d c4 01          	cmpl   $0x1,0xffffffc4(%ebp)
    2b0d:	74 24                	je     2b33 <UpdateClientUCState+0x1d8>
    2b0f:	83 7d c4 01          	cmpl   $0x1,0xffffffc4(%ebp)
    2b13:	7f 0f                	jg     2b24 <UpdateClientUCState+0x1c9>
    2b15:	83 7d c4 00          	cmpl   $0x0,0xffffffc4(%ebp)
    2b19:	0f 84 ee 01 00 00    	je     2d0d <UpdateClientUCState+0x3b2>
    2b1f:	e9 0b 02 00 00       	jmp    2d2f <UpdateClientUCState+0x3d4>
    2b24:	83 7d c4 02          	cmpl   $0x2,0xffffffc4(%ebp)
    2b28:	0f 84 f0 01 00 00    	je     2d1e <UpdateClientUCState+0x3c3>
    2b2e:	e9 fc 01 00 00       	jmp    2d2f <UpdateClientUCState+0x3d4>
				struct UC_Continuation *newConvCont;
				unsigned ackSeq;
			case CONVERSION_WAITFORSERVER:
				ucont = unmarshallUC_Continuation(&completeResp->newCont,
    2b33:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    2b36:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    2b39:	29 d0                	sub    %edx,%eax
    2b3b:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    2b3e:	83 e8 08             	sub    $0x8,%eax
    2b41:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    2b45:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    2b48:	83 c0 08             	add    $0x8,%eax
    2b4b:	89 04 24             	mov    %eax,(%esp,1)
    2b4e:	e8 be 75 00 00       	call   a111 <unmarshallUC_Continuation>
    2b53:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
								  ucont_len - ((char*)&completeResp->newCont - (char*)ucont_start));
				if(ucont == NULL) {
    2b56:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
    2b5a:	75 11                	jne    2b6d <UpdateClientUCState+0x212>
					printk("Error while unmarshalling UC Continuation for UC_Complete packet\n");
    2b5c:	c7 04 24 80 11 00 00 	movl   $0x1180,(%esp,1)
    2b63:	e8 fc ff ff ff       	call   2b64 <UpdateClientUCState+0x209>
					return;
    2b68:	e9 27 04 00 00       	jmp    2f94 <UpdateClientUCState+0x639>
				}
				/* Save continuation for use in subsequent conversion request */
				newConvCont = copyUC_Continuation(ucont);
    2b6d:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    2b70:	89 04 24             	mov    %eax,(%esp,1)
    2b73:	e8 0b 77 00 00       	call   a283 <copyUC_Continuation>
    2b78:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
				atomic_set(&newConvCont->refcnt, 1);
    2b7b:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    2b7e:	83 c0 24             	add    $0x24,%eax
    2b81:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
				if(newConvCont == NULL) {
    2b87:	83 7d d4 00          	cmpl   $0x0,0xffffffd4(%ebp)
    2b8b:	75 1c                	jne    2ba9 <UpdateClientUCState+0x24e>
					printk("Error while saving convCont in prevConvCont\n");
    2b8d:	c7 04 24 e0 11 00 00 	movl   $0x11e0,(%esp,1)
    2b94:	e8 fc ff ff ff       	call   2b95 <UpdateClientUCState+0x23a>
					kfree(ucont);
    2b99:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    2b9c:	89 04 24             	mov    %eax,(%esp,1)
    2b9f:	e8 fc ff ff ff       	call   2ba0 <UpdateClientUCState+0x245>
					return;
    2ba4:	e9 eb 03 00 00       	jmp    2f94 <UpdateClientUCState+0x639>
				}
				if(tp->t.prevConvCont) {
    2ba9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    2bac:	83 b8 fc 09 00 00 00 	cmpl   $0x0,0x9fc(%eax)
    2bb3:	74 37                	je     2bec <UpdateClientUCState+0x291>
					// XXX Leave these FINDING_LEAK defines in here to find the lurking memory leak
#ifdef FINDING_LEAK
					printk("prevConvCont: \n");
					UC_Continuation_dump(tp->t.prevConvCont);
#endif
					UC_CONTINUATION_TRYFREE(tp->t.prevConvCont);
    2bb5:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
    2bbc:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    2bbf:	8b 80 fc 09 00 00    	mov    0x9fc(%eax),%eax
    2bc5:	83 c0 24             	add    $0x24,%eax
    2bc8:	89 04 24             	mov    %eax,(%esp,1)
    2bcb:	e8 24 60 00 00       	call   8bf4 <atomic_dec_and_test>
    2bd0:	85 c0                	test   %eax,%eax
    2bd2:	74 18                	je     2bec <UpdateClientUCState+0x291>
    2bd4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    2bd7:	8b 80 fc 09 00 00    	mov    0x9fc(%eax),%eax
    2bdd:	89 04 24             	mov    %eax,(%esp,1)
    2be0:	e8 fc ff ff ff       	call   2be1 <UpdateClientUCState+0x286>
    2be5:	c7 45 cc 01 00 00 00 	movl   $0x1,0xffffffcc(%ebp)
#ifdef FINDING_LEAK
					printk("newConvCont0: \n");
					UC_Continuation_dump(ucont);
					printk("newConvCont1: \n");
					UC_Continuation_dump(newConvCont);
#endif
				}
				tp->t.prevConvCont = newConvCont;
    2bec:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    2bef:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    2bf2:	89 82 fc 09 00 00    	mov    %eax,0x9fc(%edx)

				ackSeq = ntohl(completeResp->ack_seq);
    2bf8:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    2bfb:	8b 40 04             	mov    0x4(%eax),%eax
    2bfe:	89 04 24             	mov    %eax,(%esp,1)
    2c01:	e8 fc ff ff ff       	call   2c02 <UpdateClientUCState+0x2a7>
    2c06:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
				if(ackSeq > tp->t.snd_una) {
    2c09:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    2c0c:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    2c0f:	3b 82 e0 09 00 00    	cmp    0x9e0(%edx),%eax
    2c15:	76 58                	jbe    2c6f <UpdateClientUCState+0x314>
					tp->t.snd_una = ackSeq;
    2c17:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    2c1a:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    2c1d:	89 82 e0 09 00 00    	mov    %eax,0x9e0(%edx)
					//printk("snd_una = %d\n", tp->t.snd_una);
					if(tp->t.snd_una > tp->t.write_seq) {
    2c23:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    2c26:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    2c29:	8b 80 e0 09 00 00    	mov    0x9e0(%eax),%eax
    2c2f:	3b 82 e8 09 00 00    	cmp    0x9e8(%edx),%eax
    2c35:	76 38                	jbe    2c6f <UpdateClientUCState+0x314>
						printk("Error! snd_una %d > tp->t.write_seq %d while processing CompleteConversion\n", tp->t.snd_una, tp->t.write_seq);
    2c37:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    2c3a:	8b 80 e8 09 00 00    	mov    0x9e8(%eax),%eax
    2c40:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    2c44:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    2c47:	8b 80 e0 09 00 00    	mov    0x9e0(%eax),%eax
    2c4d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    2c51:	c7 04 24 20 12 00 00 	movl   $0x1220,(%esp,1)
    2c58:	e8 fc ff ff ff       	call   2c59 <UpdateClientUCState+0x2fe>
						tp->t.snd_una = tp->t.write_seq;
    2c5d:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    2c60:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    2c63:	8b 80 e8 09 00 00    	mov    0x9e8(%eax),%eax
    2c69:	89 82 e0 09 00 00    	mov    %eax,0x9e0(%edx)
					}
				}
#if 0
				else {
					printk("snd_una not updated\n");
				}
#endif

#if FINDING_LEAK
				printk("ackseq = %d snd_una = %d write_seq = %d\n", ackSeq, tp->t.snd_una, tp->t.write_seq);
#endif
				if(addNewUC_Continuation(sk, ucont)) {
    2c6f:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    2c72:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    2c76:	8b 45 08             	mov    0x8(%ebp),%eax
    2c79:	89 04 24             	mov    %eax,(%esp,1)
    2c7c:	e8 62 86 00 00       	call   b2e3 <addNewUC_Continuation>
    2c81:	85 c0                	test   %eax,%eax
    2c83:	74 3a                	je     2cbf <UpdateClientUCState+0x364>
					printk("UC_COMPLETE: error while adding new continuation\n");
    2c85:	c7 04 24 80 12 00 00 	movl   $0x1280,(%esp,1)
    2c8c:	e8 fc ff ff ff       	call   2c8d <UpdateClientUCState+0x332>
					kfree(ucont);
    2c91:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    2c94:	89 04 24             	mov    %eax,(%esp,1)
    2c97:	e8 fc ff ff ff       	call   2c98 <UpdateClientUCState+0x33d>
					// xxx don't need to check refcnt on prevConvCont, since we
					// know that there's only  one reference
					kfree(tp->t.prevConvCont);
    2c9c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    2c9f:	8b 80 fc 09 00 00    	mov    0x9fc(%eax),%eax
    2ca5:	89 04 24             	mov    %eax,(%esp,1)
    2ca8:	e8 fc ff ff ff       	call   2ca9 <UpdateClientUCState+0x34e>
					tp->t.prevConvCont = NULL;
    2cad:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    2cb0:	c7 80 fc 09 00 00 00 	movl   $0x0,0x9fc(%eax)
    2cb7:	00 00 00 
					return;
    2cba:	e9 d5 02 00 00       	jmp    2f94 <UpdateClientUCState+0x639>
				}
				requestReleasedData(sk);
				if(tp->t.write_seq - tp->t.snd_una > 0) {
    2cbf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    2cc2:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    2cc5:	8b 80 e8 09 00 00    	mov    0x9e8(%eax),%eax
    2ccb:	3b 82 e0 09 00 00    	cmp    0x9e0(%edx),%eax
    2cd1:	74 1d                	je     2cf0 <UpdateClientUCState+0x395>
					queueConversionRequests(sk);
    2cd3:	8b 45 08             	mov    0x8(%ebp),%eax
    2cd6:	89 04 24             	mov    %eax,(%esp,1)
    2cd9:	e8 fc ff ff ff       	call   2cda <UpdateClientUCState+0x37f>
					tp->t.conversionState = CONVERSION_WAITFORSERVER;
    2cde:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    2ce1:	c7 80 dc 09 00 00 01 	movl   $0x1,0x9dc(%eax)
    2ce8:	00 00 00 
    2ceb:	e9 98 01 00 00       	jmp    2e88 <UpdateClientUCState+0x52d>
#if 0 // 0426 - do not push out requests in interrupt context, since the requests will be sent automatically
					pushRequests(sk);
#endif
					//printk("update client state set conversion state to waitforserver\n");
				} else {
					cleanTxQueue(sk);
    2cf0:	8b 45 08             	mov    0x8(%ebp),%eax
    2cf3:	89 04 24             	mov    %eax,(%esp,1)
    2cf6:	e8 55 82 00 00       	call   af50 <cleanTxQueue>
					tp->t.conversionState = CONVERSION_IDLE;
    2cfb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    2cfe:	c7 80 dc 09 00 00 00 	movl   $0x0,0x9dc(%eax)
    2d05:	00 00 00 
					//printk("update client state set conversion state to IDLE: %d\n", tp->t.conversionState);
				}
				break;
    2d08:	e9 7b 01 00 00       	jmp    2e88 <UpdateClientUCState+0x52d>
			case CONVERSION_IDLE:
				printk("Invalid state: CONVERSION_IDLE while processing completeResponse\n");
    2d0d:	c7 04 24 c0 12 00 00 	movl   $0x12c0,(%esp,1)
    2d14:	e8 fc ff ff ff       	call   2d15 <UpdateClientUCState+0x3ba>
				return;
    2d19:	e9 76 02 00 00       	jmp    2f94 <UpdateClientUCState+0x639>
			case CONVERSION_WAITFORUSER:
				printk("Invalid state: CONVERSION_WAITFORUSER while processing completeResponse\n");
    2d1e:	c7 04 24 20 13 00 00 	movl   $0x1320,(%esp,1)
    2d25:	e8 fc ff ff ff       	call   2d26 <UpdateClientUCState+0x3cb>
				return;
    2d2a:	e9 65 02 00 00       	jmp    2f94 <UpdateClientUCState+0x639>
			default:
				printk("Invalid state!\n");
    2d2f:	c7 04 24 1d 11 00 00 	movl   $0x111d,(%esp,1)
    2d36:	e8 fc ff ff ff       	call   2d37 <UpdateClientUCState+0x3dc>
				BUG();
    2d3b:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    2d42:	00 
    2d43:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    2d4a:	e8 fc ff ff ff       	call   2d4b <UpdateClientUCState+0x3f0>
    2d4f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    2d56:	e8 fc ff ff ff       	call   2d57 <UpdateClientUCState+0x3fc>
    2d5b:	e8 fc ff ff ff       	call   2d5c <UpdateClientUCState+0x401>
				return;
    2d60:	e9 2f 02 00 00       	jmp    2f94 <UpdateClientUCState+0x639>
			}
			break;
		}
		case UC_UPDATE: {
			/* This code was written 3/25, but never
			   used. See UC_NCONT code path below for New
			   CONTinuation Update technique */
			struct WireUC_MGMT_UpdateResponse *updateResp =
    2d65:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    2d68:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
				(struct WireUC_MGMT_UpdateResponse *) hdr;
			struct UC_Continuation *ucont;
			if(ucont_len < sizeof(*updateResp)) {
    2d6b:	83 7d e0 10          	cmpl   $0x10,0xffffffe0(%ebp)
    2d6f:	77 11                	ja     2d82 <UpdateClientUCState+0x427>
				printk("User continuation too short for update response\n");
    2d71:	c7 04 24 80 13 00 00 	movl   $0x1380,(%esp,1)
    2d78:	e8 fc ff ff ff       	call   2d79 <UpdateClientUCState+0x41e>
				return;
    2d7d:	e9 12 02 00 00       	jmp    2f94 <UpdateClientUCState+0x639>
			}
			ucont =	unmarshallUC_Continuation(&updateResp->newCont,
    2d82:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
    2d85:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    2d88:	29 d0                	sub    %edx,%eax
    2d8a:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    2d8d:	83 e8 04             	sub    $0x4,%eax
    2d90:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    2d94:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    2d97:	83 c0 04             	add    $0x4,%eax
    2d9a:	89 04 24             	mov    %eax,(%esp,1)
    2d9d:	e8 6f 73 00 00       	call   a111 <unmarshallUC_Continuation>
    2da2:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
							  ucont_len - ((char*)&updateResp->newCont - (char*)ucont_start));
			if(ucont == NULL) {
    2da5:	83 7d d0 00          	cmpl   $0x0,0xffffffd0(%ebp)
    2da9:	75 11                	jne    2dbc <UpdateClientUCState+0x461>
				printk("UC_Update: out of memory while unmarshalling new continuation\n");
    2dab:	c7 04 24 c0 13 00 00 	movl   $0x13c0,(%esp,1)
    2db2:	e8 fc ff ff ff       	call   2db3 <UpdateClientUCState+0x458>
				return;
    2db7:	e9 d8 01 00 00       	jmp    2f94 <UpdateClientUCState+0x639>
			}
			addedUCont = ucont;
    2dbc:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    2dbf:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
			if(addNewUC_Continuation(sk, addedUCont)) {
    2dc2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    2dc5:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    2dc9:	8b 45 08             	mov    0x8(%ebp),%eax
    2dcc:	89 04 24             	mov    %eax,(%esp,1)
    2dcf:	e8 0f 85 00 00       	call   b2e3 <addNewUC_Continuation>
    2dd4:	85 c0                	test   %eax,%eax
    2dd6:	0f 84 ac 00 00 00    	je     2e88 <UpdateClientUCState+0x52d>
				printk("UC_Update: error while adding new continuation\n");
    2ddc:	c7 04 24 00 14 00 00 	movl   $0x1400,(%esp,1)
    2de3:	e8 fc ff ff ff       	call   2de4 <UpdateClientUCState+0x489>
				return;
    2de8:	e9 a7 01 00 00       	jmp    2f94 <UpdateClientUCState+0x639>
			}
			requestReleasedData(sk);
			break;
		}
		case UC_NEWCONT: {
			struct WireUC_NewContinuationResponse *newContResp =
    2ded:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    2df0:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
				(struct WireUC_NewContinuationResponse *) hdr;
			struct UC_Continuation *ucont;
			if(ucont_len < sizeof(*newContResp)) {
    2df3:	83 7d e0 11          	cmpl   $0x11,0xffffffe0(%ebp)
    2df7:	77 11                	ja     2e0a <UpdateClientUCState+0x4af>
				printk("User continuation too short for UC_NEWCONT\n");
    2df9:	c7 04 24 40 14 00 00 	movl   $0x1440,(%esp,1)
    2e00:	e8 fc ff ff ff       	call   2e01 <UpdateClientUCState+0x4a6>
				return;
    2e05:	e9 8a 01 00 00       	jmp    2f94 <UpdateClientUCState+0x639>
			}
			ucont = unmarshallUC_Continuation(&newContResp->newCont,
    2e0a:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
    2e0d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    2e10:	29 d0                	sub    %edx,%eax
    2e12:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    2e15:	83 e8 04             	sub    $0x4,%eax
    2e18:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    2e1c:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    2e1f:	83 c0 04             	add    $0x4,%eax
    2e22:	89 04 24             	mov    %eax,(%esp,1)
    2e25:	e8 e7 72 00 00       	call   a111 <unmarshallUC_Continuation>
    2e2a:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
							  ucont_len - ((char*)&newContResp->newCont - (char*)ucont_start));
			if(ucont == NULL) {
    2e2d:	83 7d d0 00          	cmpl   $0x0,0xffffffd0(%ebp)
    2e31:	75 0c                	jne    2e3f <UpdateClientUCState+0x4e4>
				printk("Error while unmarshalling UC Continuation for UC_NEWCONT packet\n");
    2e33:	c7 04 24 80 14 00 00 	movl   $0x1480,(%esp,1)
    2e3a:	e8 fc ff ff ff       	call   2e3b <UpdateClientUCState+0x4e0>
			}
			addedUCont = ucont;
    2e3f:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    2e42:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
			if(addNewUC_Continuation(sk, ucont)) {
    2e45:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    2e48:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    2e4c:	8b 45 08             	mov    0x8(%ebp),%eax
    2e4f:	89 04 24             	mov    %eax,(%esp,1)
    2e52:	e8 8c 84 00 00       	call   b2e3 <addNewUC_Continuation>
    2e57:	85 c0                	test   %eax,%eax
    2e59:	74 2d                	je     2e88 <UpdateClientUCState+0x52d>
				printk("UC_NEWCONT: error while adding new continuation\n");
    2e5b:	c7 04 24 e0 14 00 00 	movl   $0x14e0,(%esp,1)
    2e62:	e8 fc ff ff ff       	call   2e63 <UpdateClientUCState+0x508>
				kfree(ucont);
    2e67:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    2e6a:	89 04 24             	mov    %eax,(%esp,1)
    2e6d:	e8 fc ff ff ff       	call   2e6e <UpdateClientUCState+0x513>
				return;
    2e72:	e9 1d 01 00 00       	jmp    2f94 <UpdateClientUCState+0x639>
			}
			requestReleasedData(sk);
			break;
		}
		default:
			printk("Invalid UC response \n");
    2e77:	c7 04 24 11 15 00 00 	movl   $0x1511,(%esp,1)
    2e7e:	e8 fc ff ff ff       	call   2e7f <UpdateClientUCState+0x524>
			return;
    2e83:	e9 0c 01 00 00       	jmp    2f94 <UpdateClientUCState+0x639>
		}
		/*
		 * Update parent, removing from reliable queues if necessary
		 */
		if(ofo_entry->isSynack) {
    2e88:	8b 45 0c             	mov    0xc(%ebp),%eax
    2e8b:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
    2e8f:	74 1f                	je     2eb0 <UpdateClientUCState+0x555>
			// synack does not have a parent
			tp->t.request_rcv_nxt = 1;
    2e91:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    2e94:	c7 80 5c 09 00 00 01 	movl   $0x1,0x95c(%eax)
    2e9b:	00 00 00 
			tp->t.request_snd_nxt = 1;
    2e9e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    2ea1:	c7 80 60 09 00 00 01 	movl   $0x1,0x960(%eax)
    2ea8:	00 00 00 
    2eab:	e9 c8 00 00 00       	jmp    2f78 <UpdateClientUCState+0x61d>
		} else {
			enum UserRequestType type;
			unsigned start, end;
			switch(hdr->type) {
    2eb0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    2eb3:	0f b6 00             	movzbl (%eax),%eax
    2eb6:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
    2eb9:	83 7d bc 02          	cmpl   $0x2,0xffffffbc(%ebp)
    2ebd:	74 38                	je     2ef7 <UpdateClientUCState+0x59c>
    2ebf:	83 7d bc 02          	cmpl   $0x2,0xffffffbc(%ebp)
    2ec3:	7f 0c                	jg     2ed1 <UpdateClientUCState+0x576>
    2ec5:	83 7d bc 00          	cmpl   $0x0,0xffffffbc(%ebp)
    2ec9:	0f 88 9d 00 00 00    	js     2f6c <UpdateClientUCState+0x611>
    2ecf:	eb 0f                	jmp    2ee0 <UpdateClientUCState+0x585>
    2ed1:	83 7d bc 04          	cmpl   $0x4,0xffffffbc(%ebp)
    2ed5:	0f 84 9d 00 00 00    	je     2f78 <UpdateClientUCState+0x61d>
    2edb:	e9 8c 00 00 00       	jmp    2f6c <UpdateClientUCState+0x611>
			case UC_INCOMPLETE:
			case UC_COMPLETE:
				type = MREQ_CONVERSION;
    2ee0:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
				start = -1;
    2ee7:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,0xffffffd0(%ebp)
				end = -1;
    2eee:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,0xffffffd4(%ebp)
				goto update_parent;
    2ef5:	eb 33                	jmp    2f2a <UpdateClientUCState+0x5cf>
			case UC_UPDATE:
				BUG_TRAP(addedUCont);
    2ef7:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
    2efb:	75 14                	jne    2f11 <UpdateClientUCState+0x5b6>
    2efd:	c7 44 24 04 5f 08 00 	movl   $0x85f,0x4(%esp,1)
    2f04:	00 
    2f05:	c7 04 24 40 15 00 00 	movl   $0x1540,(%esp,1)
    2f0c:	e8 fc ff ff ff       	call   2f0d <UpdateClientUCState+0x5b2>
				type = MREQ_CONTINUATION;
    2f11:	c7 45 cc 01 00 00 00 	movl   $0x1,0xffffffcc(%ebp)
				start = addedUCont->validStart;
    2f18:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    2f1b:	8b 40 10             	mov    0x10(%eax),%eax
    2f1e:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
				end = addedUCont->validEnd;
    2f21:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    2f24:	8b 40 14             	mov    0x14(%eax),%eax
    2f27:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
			update_parent:
				updateParent(sk, type, ofo_entry->parent,
    2f2a:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    2f2d:	89 44 24 18          	mov    %eax,0x18(%esp,1)
    2f31:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    2f34:	89 44 24 14          	mov    %eax,0x14(%esp,1)
    2f38:	8b 45 0c             	mov    0xc(%ebp),%eax
    2f3b:	0f b6 40 19          	movzbl 0x19(%eax),%eax
    2f3f:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    2f43:	8b 45 0c             	mov    0xc(%ebp),%eax
    2f46:	0f b6 40 18          	movzbl 0x18(%eax),%eax
    2f4a:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    2f4e:	8b 45 0c             	mov    0xc(%ebp),%eax
    2f51:	8b 40 14             	mov    0x14(%eax),%eax
    2f54:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    2f58:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    2f5b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    2f5f:	8b 45 08             	mov    0x8(%ebp),%eax
    2f62:	89 04 24             	mov    %eax,(%esp,1)
    2f65:	e8 fc ff ff ff       	call   2f66 <UpdateClientUCState+0x60b>
					     ofo_entry->numSiblings, ofo_entry->position,
					     start, end);
				break;
    2f6a:	eb 0c                	jmp    2f78 <UpdateClientUCState+0x61d>
			case UC_NEWCONT:
				/// do nothing
				break;
			default:
				printk("Invalid Uc response \n");
    2f6c:	c7 04 24 79 15 00 00 	movl   $0x1579,(%esp,1)
    2f73:	e8 fc ff ff ff       	call   2f74 <UpdateClientUCState+0x619>
    2f78:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    2f7b:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    2f7f:	89 04 24             	mov    %eax,(%esp,1)
    2f82:	e8 fc ff ff ff       	call   2f83 <UpdateClientUCState+0x628>
    2f87:	0f b7 d0             	movzwl %ax,%edx
    2f8a:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
    2f8d:	01 10                	add    %edx,(%eax)
    2f8f:	e9 f6 f9 ff ff       	jmp    298a <UpdateClientUCState+0x2f>
			}
		}
	}
}
    2f94:	c9                   	leave  
    2f95:	c3                   	ret    

00002f96 <client_rcv_impl>:


#define SYNACK_TIMEOUT (HZ)

static inline int try_queue_data_helper(struct sock *sk, struct sk_buff *skb, int linenum);
#define try_queue_data(SK,SKB)    try_queue_data_helper(SK,SKB,__LINE__)

#define DROP() do { dropline = __LINE__; goto drop; } while(0)

#define TICK() printk("%d:client_rcv_impl(%d,%d) @%d\n", (int) jiffies, skb_seq, skb_len, __LINE__)
#define TICK()

int client_rcv_impl(struct sock *sk, struct sk_buff *in_skb) {
    2f96:	55                   	push   %ebp
    2f97:	89 e5                	mov    %esp,%ebp
    2f99:	56                   	push   %esi
    2f9a:	53                   	push   %ebx
    2f9b:	83 ec 78             	sub    $0x78,%esp
	int skb_len = in_skb->len;
    2f9e:	8b 45 0c             	mov    0xc(%ebp),%eax
    2fa1:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    2fa7:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	int skb_seq = -1;
    2faa:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,0xfffffff0(%ebp)
	//printk("Enter client_rcv_impl(%p)\n", in_skb);
	int dropline = -1;
    2fb1:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    2fb8:	8b 45 08             	mov    0x8(%ebp),%eax
    2fbb:	05 bc 00 00 00       	add    $0xbc,%eax
    2fc0:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
	WireTrickleResponse *tresp_hdr;

	trickles_init_tcp_cb(in_skb);
    2fc3:	8b 45 0c             	mov    0xc(%ebp),%eax
    2fc6:	89 04 24             	mov    %eax,(%esp,1)
    2fc9:	e8 3c 7f 00 00       	call   af0a <trickles_init_tcp_cb>

	CONTINUATION_TYPE *cont = newClientSide_Continuation(GFP_ATOMIC);
    2fce:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp,1)
    2fd5:	e8 8b 6d 00 00       	call   9d65 <newClientSide_Continuation>
    2fda:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
	TCP_SKB_CB(in_skb)->cont = cont;
    2fdd:	8b 55 0c             	mov    0xc(%ebp),%edx
    2fe0:	83 c2 30             	add    $0x30,%edx
    2fe3:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    2fe6:	89 42 2c             	mov    %eax,0x2c(%edx)
	if(TCP_SKB_CB(in_skb)->cont == NULL) {
    2fe9:	8b 45 0c             	mov    0xc(%ebp),%eax
    2fec:	83 c0 30             	add    $0x30,%eax
    2fef:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
    2ff3:	75 11                	jne    3006 <client_rcv_impl+0x70>
		printk("could not allocate client side continuation\n");
    2ff5:	c7 04 24 a0 15 00 00 	movl   $0x15a0,(%esp,1)
    2ffc:	e8 fc ff ff ff       	call   2ffd <client_rcv_impl+0x67>
		goto drop;
    3001:	e9 45 10 00 00       	jmp    404b <client_rcv_impl+0x10b5>
	}

#if 0
	if(IS_RECOVERY_STATE()) {
		printk("Received packet during recovery %d\n", tp->t.clientStateCounter);
	}
#endif
	short ucont_len;
	char *ucont_in;
	int progress;
	unsigned cur_seq;
	int noCont = 0;
    3006:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
	int synack = 0;
    300d:	c7 45 c8 00 00 00 00 	movl   $0x0,0xffffffc8(%ebp)


	TIMING_CTX_DEF0("client_rcv_impl", "top", "int0", "int1");
	TIMING_CTX_DEF1(8,7,4);
	reinitTimingCtx(&ctx);
	recordSample(&ctx,0);


	if(cont == NULL) {
    3014:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
    3018:	75 18                	jne    3032 <client_rcv_impl+0x9c>
		printk("client_rcv: Could not allocate continuation\n");
    301a:	c7 04 24 e0 15 00 00 	movl   $0x15e0,(%esp,1)
    3021:	e8 fc ff ff ff       	call   3022 <client_rcv_impl+0x8c>
		DROP();
    3026:	c7 45 ec a3 08 00 00 	movl   $0x8a3,0xffffffec(%ebp)
    302d:	e9 19 10 00 00       	jmp    404b <client_rcv_impl+0x10b5>
	}
	cont->mark |= 0x1;
    3032:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    3035:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    3038:	8b 80 e4 00 00 00    	mov    0xe4(%eax),%eax
    303e:	83 c8 01             	or     $0x1,%eax
    3041:	89 82 e4 00 00 00    	mov    %eax,0xe4(%edx)

#ifdef RCV_COPY_TO_SMALLER_SKB
	// in_skb is too big (in 4K slab for device). So copy it into a smaller skb (order 2048
	// disable for performance, enable for scalability
	{
		struct sk_buff *copy;
		int copyLen = in_skb->tail - in_skb->head;
    3047:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    304a:	8b 45 0c             	mov    0xc(%ebp),%eax
    304d:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
    3053:	8b 81 bc 00 00 00    	mov    0xbc(%ecx),%eax
    3059:	29 d0                	sub    %edx,%eax
    305b:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
		copy = alloc_skb(copyLen, GFP_ATOMIC);
    305e:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    3065:	00 
    3066:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
    3069:	89 04 24             	mov    %eax,(%esp,1)
    306c:	e8 fc ff ff ff       	call   306d <client_rcv_impl+0xd7>
    3071:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
		if(copy == NULL) {
    3074:	83 7d c4 00          	cmpl   $0x0,0xffffffc4(%ebp)
    3078:	75 0c                	jne    3086 <client_rcv_impl+0xf0>
			DROP();
    307a:	c7 45 ec af 08 00 00 	movl   $0x8af,0xffffffec(%ebp)
    3081:	e9 c5 0f 00 00       	jmp    404b <client_rcv_impl+0x10b5>
		}
		memcpy(copy->head, in_skb->head, copyLen);
    3086:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
    3089:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    308d:	8b 45 0c             	mov    0xc(%ebp),%eax
    3090:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
    3096:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    309a:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    309d:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
    30a3:	89 04 24             	mov    %eax,(%esp,1)
    30a6:	e8 67 5b 00 00       	call   8c12 <__memcpy>
		skb_reserve(copy, in_skb->data - in_skb->head);
    30ab:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    30ae:	8b 45 0c             	mov    0xc(%ebp),%eax
    30b1:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
    30b7:	8b 81 b8 00 00 00    	mov    0xb8(%ecx),%eax
    30bd:	29 d0                	sub    %edx,%eax
    30bf:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    30c3:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    30c6:	89 04 24             	mov    %eax,(%esp,1)
    30c9:	e8 a1 60 00 00       	call   916f <skb_reserve>
		copy->h.th = (struct tcphdr*)(copy->head + ((char*)in_skb->h.th - (char*)in_skb->head));
    30ce:	8b 75 c4             	mov    0xffffffc4(%ebp),%esi
    30d1:	8b 5d c4             	mov    0xffffffc4(%ebp),%ebx
    30d4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    30d7:	8b 45 0c             	mov    0xc(%ebp),%eax
    30da:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
    30e0:	8b 41 20             	mov    0x20(%ecx),%eax
    30e3:	29 d0                	sub    %edx,%eax
    30e5:	03 83 b4 00 00 00    	add    0xb4(%ebx),%eax
    30eb:	89 46 20             	mov    %eax,0x20(%esi)
		copy->nh.iph = (struct iphdr*)(copy->head + ((char*)in_skb->nh.iph - (char*)in_skb->head));
    30ee:	8b 75 c4             	mov    0xffffffc4(%ebp),%esi
    30f1:	8b 5d c4             	mov    0xffffffc4(%ebp),%ebx
    30f4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    30f7:	8b 45 0c             	mov    0xc(%ebp),%eax
    30fa:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
    3100:	8b 41 24             	mov    0x24(%ecx),%eax
    3103:	29 d0                	sub    %edx,%eax
    3105:	03 83 b4 00 00 00    	add    0xb4(%ebx),%eax
    310b:	89 46 24             	mov    %eax,0x24(%esi)
		skb_put(copy, in_skb->len);
    310e:	8b 45 0c             	mov    0xc(%ebp),%eax
    3111:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    3117:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    311b:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    311e:	89 04 24             	mov    %eax,(%esp,1)
    3121:	e8 45 5e 00 00       	call   8f6b <skb_put>
		BUG_TRAP(copy->len == in_skb->len);
    3126:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    3129:	8b 55 0c             	mov    0xc(%ebp),%edx
    312c:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    3132:	3b 82 94 00 00 00    	cmp    0x94(%edx),%eax
    3138:	74 14                	je     314e <client_rcv_impl+0x1b8>
    313a:	c7 44 24 04 b6 08 00 	movl   $0x8b6,0x4(%esp,1)
    3141:	00 
    3142:	c7 04 24 20 16 00 00 	movl   $0x1620,(%esp,1)
    3149:	e8 fc ff ff ff       	call   314a <client_rcv_impl+0x1b4>
		copy->sk = in_skb->sk;
    314e:	8b 55 c4             	mov    0xffffffc4(%ebp),%edx
    3151:	8b 45 0c             	mov    0xc(%ebp),%eax
    3154:	8b 40 0c             	mov    0xc(%eax),%eax
    3157:	89 42 0c             	mov    %eax,0xc(%edx)

		__kfree_skb(in_skb);
    315a:	8b 45 0c             	mov    0xc(%ebp),%eax
    315d:	89 04 24             	mov    %eax,(%esp,1)
    3160:	e8 fc ff ff ff       	call   3161 <client_rcv_impl+0x1cb>
		in_skb = copy;
    3165:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    3168:	89 45 0c             	mov    %eax,0xc(%ebp)
		TCP_SKB_CB(in_skb)->cont = cont;
    316b:	8b 55 0c             	mov    0xc(%ebp),%edx
    316e:	83 c2 30             	add    $0x30,%edx
    3171:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    3174:	89 42 2c             	mov    %eax,0x2c(%edx)
	}
#endif

#ifdef DEBUG_RECOVERY_MICROTEST
	{
		static int dropCount = 0;
		dropCount++;
		if(dropCount > 1000 && dropCount % 1000 <= 3) {
			DROP();
		}
	}
#endif

	tresp_hdr = (WireTrickleResponse *)in_skb->data;
    3177:	8b 45 0c             	mov    0xc(%ebp),%eax
    317a:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
    3180:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
	/* 0429 - hash compression support */
	/* XXX HASHCOMPRESSED does not work for retransmitted packets */
	if(tresp_hdr->cont.continuationType & CONTTYPE_HASHCOMPRESSED) {
    3183:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    3186:	0f b6 40 08          	movzbl 0x8(%eax),%eax
    318a:	24 80                	and    $0x80,%al
    318c:	84 c0                	test   %al,%al
    318e:	74 0c                	je     319c <client_rcv_impl+0x206>
		TICK();
#ifdef ENABLE_HASHCOMPRESS
		if(!pskb_may_pull(in_skb, RESPONSELEN_HASHCOMPRESS)) {
			printk("client_rcv: could not pull hash compress continuation\n");
			DROP();
		}

		CONTINUATION_TYPE *finger, *simulationOutput;
		static struct WireContinuation scratch[NR_CPUS]; // avoid stack allocation (which risks stack overflow), and kmalloc, which is inefficient
		struct WireContinuation *wc_scratch = &scratch[smp_processor_id()];
		struct WireContinuation *wcont = &tresp_hdr->cont;
		int fullType;
		tresp_hdr->cont.continuationType &= ~CONTTYPE_HASHCOMPRESSED;
		fullType = tresp_hdr->cont.continuationType == CONTTYPE_FULL1 ||
			tresp_hdr->cont.continuationType == CONTTYPE_FULL2;
		BUG_TRAP(fullType ||
			 tresp_hdr->cont.continuationType == CONTTYPE_MINIMAL);

		/* find matching continuation */
		alloc_head_reverse_walk(&tp->t.cont_list, finger) {
			if(wcont->hash.parentSeq  == (typeof(wcont->hash.parentSeq)) finger->seq &&
			   wcont->hash.clientState == (typeof(wcont->hash.clientState)) finger->clientState) {
				break;
			}
		}
		if(finger == (CONTINUATION_TYPE *)&tp->t.cont_list) {
			if(clientDebugLevel >= 2)
				printk("could not find matching parent continuation\n");
			DROP();
		}
		simulationOutput = finger + 1;
		// 0430 - numSiblings is from UC level; there is no similar field for Transport level
		//BUG_TRAP(tresp_hdr->numSiblings == simulationOutput->num_packets);

		BUG_TRAP(finger->simulated);
		BUG_TRAP(wcont->hash.position < simulationOutput->num_packets);

		// XXX replace this roundabout construction of new continuation with direct transformation
		marshallContinuationServerCopyMAC(sk, wc_scratch, simulationOutput, wcont->hash.position);
		unmarshallContinuationClient(in_skb, cont, wc_scratch);
		//LOG_PACKET_CONT(in_skb, in_skb->h.th->ack_seq, cont);

		/* set up fields that client could not predict */
		cont->timestamp = ntohl(wcont->hash.timestamp);
		cont->mrtt = cont->rawMrtt = ntohs(wcont->hash.mrtt);
		cont->parentMSK = finger;

		if(fullType) {
			memcpy(cont->mac, wcont->hash.mac, HMACLEN);
		} else {
			noCont = 1;
		}

		__skb_pull(in_skb, RESPONSELEN_HASHCOMPRESS);
#else
		if(trickles_ratelimit())
			printk("Hash compressed continuation received, but support not compiled in\n");
		DROP();
    3190:	c7 45 ec 06 09 00 00 	movl   $0x906,0xffffffec(%ebp)
    3197:	e9 af 0e 00 00       	jmp    404b <client_rcv_impl+0x10b5>
#endif
	} else {
		TICK();
		if(!pskb_may_pull(in_skb, RESPONSELEN_MINIMAL)) {
    319c:	c7 44 24 04 1d 00 00 	movl   $0x1d,0x4(%esp,1)
    31a3:	00 
    31a4:	8b 45 0c             	mov    0xc(%ebp),%eax
    31a7:	89 04 24             	mov    %eax,(%esp,1)
    31aa:	e8 4e 5f 00 00       	call   90fd <pskb_may_pull>
    31af:	85 c0                	test   %eax,%eax
    31b1:	75 0c                	jne    31bf <client_rcv_impl+0x229>
			//printk("client_rcv: could not pull WireTrickleResponse\n");
			DROP();
    31b3:	c7 45 ec 0c 09 00 00 	movl   $0x90c,0xffffffec(%ebp)
    31ba:	e9 8c 0e 00 00       	jmp    404b <client_rcv_impl+0x10b5>
		}

		switch(tresp_hdr->cont.continuationType) {
    31bf:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    31c2:	0f b6 40 08          	movzbl 0x8(%eax),%eax
    31c6:	89 45 9c             	mov    %eax,0xffffff9c(%ebp)
    31c9:	83 7d 9c 00          	cmpl   $0x0,0xffffff9c(%ebp)
    31cd:	74 0e                	je     31dd <client_rcv_impl+0x247>
    31cf:	83 7d 9c 00          	cmpl   $0x0,0xffffff9c(%ebp)
    31d3:	78 68                	js     323d <client_rcv_impl+0x2a7>
    31d5:	83 7d 9c 02          	cmpl   $0x2,0xffffff9c(%ebp)
    31d9:	7f 62                	jg     323d <client_rcv_impl+0x2a7>
    31db:	eb 1c                	jmp    31f9 <client_rcv_impl+0x263>
		case CONTTYPE_MINIMAL:
			__skb_pull(in_skb, RESPONSELEN_MINIMAL);
    31dd:	c7 44 24 04 1d 00 00 	movl   $0x1d,0x4(%esp,1)
    31e4:	00 
    31e5:	8b 45 0c             	mov    0xc(%ebp),%eax
    31e8:	89 04 24             	mov    %eax,(%esp,1)
    31eb:	e8 7c 5e 00 00       	call   906c <__skb_pull>
			//printk("minimal continuation, length = %d(%d)\n", in_skb->len, in_skb->data - in_skb->head);
			noCont = 1;
    31f0:	c7 45 cc 01 00 00 00 	movl   $0x1,0xffffffcc(%ebp)
			break;
    31f7:	eb 69                	jmp    3262 <client_rcv_impl+0x2cc>
		case CONTTYPE_FULL1:
		case CONTTYPE_FULL2:
			if(!pskb_may_pull(in_skb, sizeof(WireTrickleResponse))) {
    31f9:	c7 44 24 04 52 00 00 	movl   $0x52,0x4(%esp,1)
    3200:	00 
    3201:	8b 45 0c             	mov    0xc(%ebp),%eax
    3204:	89 04 24             	mov    %eax,(%esp,1)
    3207:	e8 f1 5e 00 00       	call   90fd <pskb_may_pull>
    320c:	85 c0                	test   %eax,%eax
    320e:	75 18                	jne    3228 <client_rcv_impl+0x292>
				printk("client_rcv: could not pull full WireTrickleResponse\n");
    3210:	c7 04 24 80 16 00 00 	movl   $0x1680,(%esp,1)
    3217:	e8 fc ff ff ff       	call   3218 <client_rcv_impl+0x282>
				DROP();
    321c:	c7 45 ec 19 09 00 00 	movl   $0x919,0xffffffec(%ebp)
    3223:	e9 23 0e 00 00       	jmp    404b <client_rcv_impl+0x10b5>
			}
			__skb_pull(in_skb, sizeof(WireTrickleResponse));
    3228:	c7 44 24 04 52 00 00 	movl   $0x52,0x4(%esp,1)
    322f:	00 
    3230:	8b 45 0c             	mov    0xc(%ebp),%eax
    3233:	89 04 24             	mov    %eax,(%esp,1)
    3236:	e8 31 5e 00 00       	call   906c <__skb_pull>
			//printk("full continuation, length = %d(%d)\n", in_skb->len, in_skb->data - in_skb->head);
			break;
    323b:	eb 25                	jmp    3262 <client_rcv_impl+0x2cc>
		default:
			BUG();
    323d:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    3244:	00 
    3245:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    324c:	e8 fc ff ff ff       	call   324d <client_rcv_impl+0x2b7>
    3251:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    3258:	e8 fc ff ff ff       	call   3259 <client_rcv_impl+0x2c3>
    325d:	e8 fc ff ff ff       	call   325e <client_rcv_impl+0x2c8>
		}
		if(noCont) {
    3262:	83 7d cc 00          	cmpl   $0x0,0xffffffcc(%ebp)
    3266:	74 47                	je     32af <client_rcv_impl+0x319>
			cont->continuationType = tresp_hdr->cont.continuationType;
    3268:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    326b:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    326e:	0f b6 40 08          	movzbl 0x8(%eax),%eax
    3272:	89 42 34             	mov    %eax,0x34(%edx)
			cont->seq = ntohl(tresp_hdr->cont.seq);
    3275:	8b 5d e0             	mov    0xffffffe0(%ebp),%ebx
    3278:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    327b:	8b 40 09             	mov    0x9(%eax),%eax
    327e:	89 04 24             	mov    %eax,(%esp,1)
    3281:	e8 fc ff ff ff       	call   3282 <client_rcv_impl+0x2ec>
    3286:	89 43 30             	mov    %eax,0x30(%ebx)
			cont->clientState = tresp_hdr->cont.clientState;
    3289:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    328c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    328f:	8b 40 11             	mov    0x11(%eax),%eax
    3292:	89 42 38             	mov    %eax,0x38(%edx)
			cont->clientTimestamp = tresp_hdr->cont.clientTimestamp;
    3295:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    3298:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    329b:	8b 40 19             	mov    0x19(%eax),%eax
    329e:	89 42 4c             	mov    %eax,0x4c(%edx)
			cont->parent = tresp_hdr->cont.parent;
    32a1:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    32a4:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    32a7:	8b 40 15             	mov    0x15(%eax),%eax
    32aa:	89 42 3c             	mov    %eax,0x3c(%edx)
    32ad:	eb 1c                	jmp    32cb <client_rcv_impl+0x335>
		} else {
			unmarshallContinuationClient(in_skb, cont, &tresp_hdr->cont);
    32af:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    32b2:	83 c0 08             	add    $0x8,%eax
    32b5:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    32b9:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    32bc:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    32c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    32c3:	89 04 24             	mov    %eax,(%esp,1)
    32c6:	e8 45 68 00 00       	call   9b10 <unmarshallContinuationClient>
		}
		skb_seq = cont->seq;
    32cb:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    32ce:	8b 40 30             	mov    0x30(%eax),%eax
    32d1:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
		LOG_PACKET_CONT(sk, in_skb->h.th->ack_seq, cont);
	}
	if(!noCont && (cont->seq > tp->t.rcv_nxt + 1000000 ||
    32d4:	83 7d cc 00          	cmpl   $0x0,0xffffffcc(%ebp)
    32d8:	75 15                	jne    32ef <client_rcv_impl+0x359>
    32da:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    32dd:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    32e0:	8b 92 e0 02 00 00    	mov    0x2e0(%edx),%edx
    32e6:	81 c2 40 42 0f 00    	add    $0xf4240,%edx
    32ec:	39 50 30             	cmp    %edx,0x30(%eax)
		       cont->TCPBase > tp->t.rcv_nxt + 1000000)) {
		if(trickles_ratelimit())
			printk("Warning: client received bogus sequence number (%u) or TCPBase (%u)\n", cont->seq, cont->TCPBase);
	}
	TCP_SKB_CB(in_skb)->numSiblings = tresp_hdr->numSiblings;
    32ef:	8b 55 0c             	mov    0xc(%ebp),%edx
    32f2:	83 c2 30             	add    $0x30,%edx
    32f5:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    32f8:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    32fc:	88 42 54             	mov    %al,0x54(%edx)
	TCP_SKB_CB(in_skb)->position = tresp_hdr->position;
    32ff:	8b 55 0c             	mov    0xc(%ebp),%edx
    3302:	83 c2 30             	add    $0x30,%edx
    3305:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    3308:	0f b6 40 05          	movzbl 0x5(%eax),%eax
    330c:	88 42 55             	mov    %al,0x55(%edx)

	ucont_len = ntohs(tresp_hdr->ucont_len);
    330f:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    3312:	0f b7 40 06          	movzwl 0x6(%eax),%eax
    3316:	89 04 24             	mov    %eax,(%esp,1)
    3319:	e8 fc ff ff ff       	call   331a <client_rcv_impl+0x384>
    331e:	66 89 45 de          	mov    %ax,0xffffffde(%ebp)
	//printk("tresp_hdr->ucont_len = %d\n", ucont_len);
	char *ucont_start = ucont_in = in_skb->data;
    3322:	8b 45 0c             	mov    0xc(%ebp),%eax
    3325:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
    332b:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    332e:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)

	cont->mark = SKBLIST;
    3331:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    3334:	c7 80 e4 00 00 00 fe 	movl   $0xfffffffe,0xe4(%eax)
    333b:	ff ff ff 

	recordSample(&ctx,0);

	cont->ucont_len = ucont_len;
    333e:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    3341:	0f bf 45 de          	movswl 0xffffffde(%ebp),%eax
    3345:	89 42 78             	mov    %eax,0x78(%edx)

	cont->cum_nonce = tresp_hdr->nonce;
    3348:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    334b:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    334e:	8b 00                	mov    (%eax),%eax
    3350:	89 42 2c             	mov    %eax,0x2c(%edx)
	cont->next = cont->prev = NULL;
    3353:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    3356:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    3359:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    335f:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)

#define QUEUE_AND_DROP()				\
	do { dropline = __LINE__; goto queue_data_and_drop; } while(0)

	if(!pskb_may_pull(in_skb, ucont_len)) {
    3366:	0f bf 45 de          	movswl 0xffffffde(%ebp),%eax
    336a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    336e:	8b 45 0c             	mov    0xc(%ebp),%eax
    3371:	89 04 24             	mov    %eax,(%esp,1)
    3374:	e8 84 5d 00 00       	call   90fd <pskb_may_pull>
    3379:	85 c0                	test   %eax,%eax
    337b:	75 2d                	jne    33aa <client_rcv_impl+0x414>
		printk("client_rcv: could not pull ucont (ucont_len = %d, skb_len = %d)\n", (int)ucont_len, in_skb->len);
    337d:	8b 45 0c             	mov    0xc(%ebp),%eax
    3380:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    3386:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    338a:	0f bf 45 de          	movswl 0xffffffde(%ebp),%eax
    338e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3392:	c7 04 24 c0 16 00 00 	movl   $0x16c0,(%esp,1)
    3399:	e8 fc ff ff ff       	call   339a <client_rcv_impl+0x404>
		DROP();
    339e:	c7 45 ec 47 09 00 00 	movl   $0x947,0xffffffec(%ebp)
    33a5:	e9 a1 0c 00 00       	jmp    404b <client_rcv_impl+0x10b5>
	}
	if(ucont_len) {
    33aa:	66 83 7d de 00       	cmpw   $0x0,0xffffffde(%ebp)
    33af:	74 7e                	je     342f <client_rcv_impl+0x499>
		cont->ucont_data = kmalloc(ucont_len, GFP_ATOMIC);
    33b1:	8b 5d e0             	mov    0xffffffe0(%ebp),%ebx
    33b4:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    33bb:	00 
    33bc:	0f bf 45 de          	movswl 0xffffffde(%ebp),%eax
    33c0:	89 04 24             	mov    %eax,(%esp,1)
    33c3:	e8 fc ff ff ff       	call   33c4 <client_rcv_impl+0x42e>
    33c8:	89 43 7c             	mov    %eax,0x7c(%ebx)
		if(cont->ucont_data == NULL) {
    33cb:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    33ce:	83 78 7c 00          	cmpl   $0x0,0x7c(%eax)
    33d2:	75 2b                	jne    33ff <client_rcv_impl+0x469>
			printk("client_rcv: out of memory while copying user continuation\n");
    33d4:	c7 04 24 20 17 00 00 	movl   $0x1720,(%esp,1)
    33db:	e8 fc ff ff ff       	call   33dc <client_rcv_impl+0x446>
			__skb_pull(in_skb, ucont_len);
    33e0:	0f bf 45 de          	movswl 0xffffffde(%ebp),%eax
    33e4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    33e8:	8b 45 0c             	mov    0xc(%ebp),%eax
    33eb:	89 04 24             	mov    %eax,(%esp,1)
    33ee:	e8 79 5c 00 00       	call   906c <__skb_pull>
			QUEUE_AND_DROP();
    33f3:	c7 45 ec 4e 09 00 00 	movl   $0x94e,0xffffffec(%ebp)
    33fa:	e9 11 0c 00 00       	jmp    4010 <client_rcv_impl+0x107a>
		}
		memcpy(cont->ucont_data, ucont_in, ucont_len);
    33ff:	0f bf 45 de          	movswl 0xffffffde(%ebp),%eax
    3403:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    3407:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    340a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    340e:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    3411:	8b 40 7c             	mov    0x7c(%eax),%eax
    3414:	89 04 24             	mov    %eax,(%esp,1)
    3417:	e8 f6 57 00 00       	call   8c12 <__memcpy>
		__skb_pull(in_skb, ucont_len);
    341c:	0f bf 45 de          	movswl 0xffffffde(%ebp),%eax
    3420:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3424:	8b 45 0c             	mov    0xc(%ebp),%eax
    3427:	89 04 24             	mov    %eax,(%esp,1)
    342a:	e8 3d 5c 00 00       	call   906c <__skb_pull>
	}
	//printk("cont->ucont_data = %p, cont->ucont_len = %d\n", cont->ucont_data, cont->ucont_len);

	TCP_SKB_CB(in_skb)->trickle_seq = cont->seq;
    342f:	8b 55 0c             	mov    0xc(%ebp),%edx
    3432:	83 c2 30             	add    $0x30,%edx
    3435:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    3438:	8b 40 30             	mov    0x30(%eax),%eax
    343b:	89 42 24             	mov    %eax,0x24(%edx)
	TCP_SKB_CB(in_skb)->clientState = cont->clientState;
    343e:	8b 55 0c             	mov    0xc(%ebp),%edx
    3441:	83 c2 30             	add    $0x30,%edx
    3444:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    3447:	8b 40 38             	mov    0x38(%eax),%eax
    344a:	89 42 28             	mov    %eax,0x28(%edx)

#if 0
	if(IS_RECOVERY_STATE())
		printk("Recovery packet client state counter = %d, socket counter = %d\n", cont->clientState, tp->t.clientStateCounter);
#endif
	if(cont->seq < tp->t.rcv_nxt) {
    344d:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    3450:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    3453:	8b 40 30             	mov    0x30(%eax),%eax
    3456:	3b 82 e0 02 00 00    	cmp    0x2e0(%edx),%eax
    345c:	73 43                	jae    34a1 <client_rcv_impl+0x50b>
		if(clientDebugLevel >= 2 || debugDrops)
    345e:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    3465:	7f 0b                	jg     3472 <client_rcv_impl+0x4dc>
    3467:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    346e:	75 02                	jne    3472 <client_rcv_impl+0x4dc>
    3470:	eb 23                	jmp    3495 <client_rcv_impl+0x4ff>
			printk("Client_rcv: Useless old packet cont.seq = %u < rcv_nxt = %u; dropping\n", cont->seq, tp->t.rcv_nxt);
    3472:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3475:	8b 80 e0 02 00 00    	mov    0x2e0(%eax),%eax
    347b:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    347f:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    3482:	8b 40 30             	mov    0x30(%eax),%eax
    3485:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3489:	c7 04 24 60 17 00 00 	movl   $0x1760,(%esp,1)
    3490:	e8 fc ff ff ff       	call   3491 <client_rcv_impl+0x4fb>
		QUEUE_AND_DROP();
    3495:	c7 45 ec 5f 09 00 00 	movl   $0x95f,0xffffffec(%ebp)
    349c:	e9 6f 0b 00 00       	jmp    4010 <client_rcv_impl+0x107a>
	}

	recordSample(&ctx,0);
	if(sk->state != TCP_ESTABLISHED) {
    34a1:	8b 45 08             	mov    0x8(%ebp),%eax
    34a4:	0f b6 40 20          	movzbl 0x20(%eax),%eax
    34a8:	3c 01                	cmp    $0x1,%al
    34aa:	0f 84 7d 01 00 00    	je     362d <client_rcv_impl+0x697>
		if(!(in_skb->h.th->syn && in_skb->h.th->ack) )
    34b0:	8b 45 0c             	mov    0xc(%ebp),%eax
    34b3:	8b 40 20             	mov    0x20(%eax),%eax
    34b6:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    34ba:	24 02                	and    $0x2,%al
    34bc:	84 c0                	test   %al,%al
    34be:	74 10                	je     34d0 <client_rcv_impl+0x53a>
    34c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    34c3:	8b 40 20             	mov    0x20(%eax),%eax
    34c6:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    34ca:	24 10                	and    $0x10,%al
    34cc:	84 c0                	test   %al,%al
    34ce:	75 0c                	jne    34dc <client_rcv_impl+0x546>
			DROP();
    34d0:	c7 45 ec 65 09 00 00 	movl   $0x965,0xffffffec(%ebp)
    34d7:	e9 6f 0b 00 00       	jmp    404b <client_rcv_impl+0x10b5>
		synack = 1;
    34dc:	c7 45 c8 01 00 00 00 	movl   $0x1,0xffffffc8(%ebp)
		BUG_TRAP(!noCont);
    34e3:	83 7d cc 00          	cmpl   $0x0,0xffffffcc(%ebp)
    34e7:	74 14                	je     34fd <client_rcv_impl+0x567>
    34e9:	c7 44 24 04 67 09 00 	movl   $0x967,0x4(%esp,1)
    34f0:	00 
    34f1:	c7 04 24 c0 17 00 00 	movl   $0x17c0,(%esp,1)
    34f8:	e8 fc ff ff ff       	call   34f9 <client_rcv_impl+0x563>
		sk->state = TCP_ESTABLISHED;
    34fd:	8b 45 08             	mov    0x8(%ebp),%eax
    3500:	c6 40 20 01          	movb   $0x1,0x20(%eax)
		tp->rcv_nxt = 0;
    3504:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3507:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		tp->rcv_wup = 0;
    350e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3511:	c7 80 f0 00 00 00 00 	movl   $0x0,0xf0(%eax)
    3518:	00 00 00 
		tp->copied_seq = 0;
    351b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    351e:	c7 80 fc 00 00 00 00 	movl   $0x0,0xfc(%eax)
    3525:	00 00 00 
		trickles_client_connected_impl(sk);
    3528:	8b 45 08             	mov    0x8(%ebp),%eax
    352b:	89 04 24             	mov    %eax,(%esp,1)
    352e:	e8 42 e2 ff ff       	call   1775 <trickles_client_connected_impl>
		tp->t.rcv_nxt = cont->seq;
    3533:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    3536:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    3539:	8b 40 30             	mov    0x30(%eax),%eax
    353c:	89 82 e0 02 00 00    	mov    %eax,0x2e0(%edx)
		tp->t.previous_base = cont->TCPBase;
    3542:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    3545:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    3548:	8b 40 6c             	mov    0x6c(%eax),%eax
    354b:	89 82 e4 02 00 00    	mov    %eax,0x2e4(%edx)
		tp->t.state = TRICKLES_CLIENT_NORMAL;
    3551:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3554:	c7 80 cc 02 00 00 01 	movl   $0x1,0x2cc(%eax)
    355b:	00 00 00 

		//SAVE_ACK_PREV(tp);
		tp->t.ack_prev = NULL;
    355e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3561:	c7 80 f4 02 00 00 00 	movl   $0x0,0x2f4(%eax)
    3568:	00 00 00 
		tp->t.ack_last = cont->seq + 1;
    356b:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    356e:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    3571:	8b 40 30             	mov    0x30(%eax),%eax
    3574:	40                   	inc    %eax
    3575:	89 82 f8 02 00 00    	mov    %eax,0x2f8(%edx)
		tp->t.A = 0;
    357b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    357e:	c7 80 d0 02 00 00 00 	movl   $0x0,0x2d0(%eax)
    3585:	00 00 00 
		tp->t.D = 0;
    3588:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    358b:	c7 80 d4 02 00 00 00 	movl   $0x0,0x2d4(%eax)
    3592:	00 00 00 
		tp->t.RTO = INITIAL_RTO;
    3595:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3598:	c7 80 d8 02 00 00 60 	movl   $0x960,0x2d8(%eax)
    359f:	09 00 00 

		tp->t.timerState = TRICKLES_ENABLE_DATA_TIMEOUT;
    35a2:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    35a5:	c7 80 dc 02 00 00 01 	movl   $0x1,0x2dc(%eax)
    35ac:	00 00 00 
		resetClientTimer(sk);
    35af:	8b 45 08             	mov    0x8(%ebp),%eax
    35b2:	89 04 24             	mov    %eax,(%esp,1)
    35b5:	e8 fc ff ff ff       	call   35b6 <client_rcv_impl+0x620>
		/* code below copied from tcp_synsent_state_process; copy more if necessary */
		mb();
    35ba:	f0 83 44 24 00 00    	lock addl $0x0,0x0(%esp,1)
		tcp_set_state(sk, TCP_ESTABLISHED);
    35c0:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
    35c7:	00 
    35c8:	8b 45 08             	mov    0x8(%ebp),%eax
    35cb:	89 04 24             	mov    %eax,(%esp,1)
    35ce:	e8 e0 5e 00 00       	call   94b3 <tcp_set_state>
		if(!sk->dead) {
    35d3:	8b 45 08             	mov    0x8(%ebp),%eax
    35d6:	0f b6 80 80 00 00 00 	movzbl 0x80(%eax),%eax
    35dd:	84 c0                	test   %al,%al
    35df:	75 2c                	jne    360d <client_rcv_impl+0x677>
			sk->state_change(sk);
    35e1:	8b 55 08             	mov    0x8(%ebp),%edx
    35e4:	8b 45 08             	mov    0x8(%ebp),%eax
    35e7:	89 04 24             	mov    %eax,(%esp,1)
    35ea:	8b 82 d0 0b 00 00    	mov    0xbd0(%edx),%eax
    35f0:	ff d0                	call   *%eax
			sk_wake_async(sk, 0, POLL_OUT);
    35f2:	c7 44 24 08 02 00 02 	movl   $0x20002,0x8(%esp,1)
    35f9:	00 
    35fa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    3601:	00 
    3602:	8b 45 08             	mov    0x8(%ebp),%eax
    3605:	89 04 24             	mov    %eax,(%esp,1)
    3608:	e8 f0 5d 00 00       	call   93fd <sk_wake_async>
		}
		tp->t.clientStateCounter = cont->clientState;
    360d:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    3610:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    3613:	8b 40 38             	mov    0x38(%eax),%eax
    3616:	89 82 c8 02 00 00    	mov    %eax,0x2c8(%edx)
		cont->parent = tp->t.request_rcv_nxt;
    361c:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    361f:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3622:	8b 80 5c 09 00 00    	mov    0x95c(%eax),%eax
    3628:	89 42 3c             	mov    %eax,0x3c(%edx)
    362b:	eb 39                	jmp    3666 <client_rcv_impl+0x6d0>
	} else if(tp->t.state == TRICKLES_CLIENT_SYNACK &&
    362d:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3630:	83 b8 cc 02 00 00 04 	cmpl   $0x4,0x2cc(%eax)
    3637:	75 2d                	jne    3666 <client_rcv_impl+0x6d0>
    3639:	8b 45 0c             	mov    0xc(%ebp),%eax
    363c:	8b 40 20             	mov    0x20(%eax),%eax
    363f:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    3643:	24 02                	and    $0x2,%al
    3645:	84 c0                	test   %al,%al
    3647:	75 1d                	jne    3666 <client_rcv_impl+0x6d0>
    3649:	8b 45 0c             	mov    0xc(%ebp),%eax
    364c:	8b 40 20             	mov    0x20(%eax),%eax
    364f:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    3653:	24 10                	and    $0x10,%al
    3655:	84 c0                	test   %al,%al
    3657:	74 0d                	je     3666 <client_rcv_impl+0x6d0>
		  !in_skb->h.th->syn && in_skb->h.th->ack) {
		tp->t.state = TRICKLES_CLIENT_NORMAL;
    3659:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    365c:	c7 80 cc 02 00 00 01 	movl   $0x1,0x2cc(%eax)
    3663:	00 00 00 
	}
	TICK();
	// 0502 search end

	// Must initialize in_skb->parent here, since
	// cont->parent is initialized in SYN/ACK processing
	TCP_SKB_CB(in_skb)->parent = cont->parent;
    3666:	8b 55 0c             	mov    0xc(%ebp),%edx
    3669:	83 c2 30             	add    $0x30,%edx
    366c:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    366f:	8b 40 3c             	mov    0x3c(%eax),%eax
    3672:	89 42 50             	mov    %eax,0x50(%edx)

	recordSample(&ctx,0);
	/*
	printk("Client received %u, rcv_nxt = %u, ack_seq = %u, ack_last = %u\n",
	       cont.seq, tp->t.rcv_nxt, tp->t.ack_seq, tp->t.ack_last);
	*/

	recordSample(&ctx,0);

	/*
	 *
	 *
	 * DATA STRUCTURE INVARIANTS
	 * ofo_queue - inserted during initial packet receipt, removed when dequeued, handed off to userspace, freed when duplicate arrives
	 * cont_list - inserted during initial packet receipt (not reordering), and freed during acking. NEVER freed during ofo_queue walk!!!
	 * In other words, continuations are treated separately from data
	 *
	 */

	recordSample(&ctx,0);
	if(!(((tp->t.state == TRICKLES_CLIENT_NORMAL || tp->t.state == TRICKLES_CLIENT_SLOWSTART) &&
    3675:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3678:	83 b8 cc 02 00 00 01 	cmpl   $0x1,0x2cc(%eax)
    367f:	74 0c                	je     368d <client_rcv_impl+0x6f7>
    3681:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3684:	83 b8 cc 02 00 00 03 	cmpl   $0x3,0x2cc(%eax)
    368b:	75 16                	jne    36a3 <client_rcv_impl+0x70d>
    368d:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    3690:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    3693:	8b 40 38             	mov    0x38(%eax),%eax
    3696:	3b 82 c8 02 00 00    	cmp    0x2c8(%edx),%eax
    369c:	75 05                	jne    36a3 <client_rcv_impl+0x70d>
    369e:	e9 94 00 00 00       	jmp    3737 <client_rcv_impl+0x7a1>
    36a3:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    36a6:	83 b8 cc 02 00 00 02 	cmpl   $0x2,0x2cc(%eax)
    36ad:	75 25                	jne    36d4 <client_rcv_impl+0x73e>
    36af:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    36b2:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    36b5:	8b 40 38             	mov    0x38(%eax),%eax
    36b8:	3b 82 c8 02 00 00    	cmp    0x2c8(%edx),%eax
    36be:	74 77                	je     3737 <client_rcv_impl+0x7a1>
    36c0:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    36c3:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    36c6:	8b 92 c8 02 00 00    	mov    0x2c8(%edx),%edx
    36cc:	4a                   	dec    %edx
    36cd:	39 50 38             	cmp    %edx,0x38(%eax)
    36d0:	75 02                	jne    36d4 <client_rcv_impl+0x73e>
    36d2:	eb 63                	jmp    3737 <client_rcv_impl+0x7a1>
	      cont->clientState == tp->t.clientStateCounter) ||
	     (tp->t.state == TRICKLES_CLIENT_RECOVERY &&
	      (cont->clientState == tp->t.clientStateCounter || cont->clientState == tp->t.clientStateCounter-1)))) {
		if(clientDebugLevel >= 2 || debugDrops)
    36d4:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    36db:	7f 0b                	jg     36e8 <client_rcv_impl+0x752>
    36dd:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    36e4:	75 02                	jne    36e8 <client_rcv_impl+0x752>
    36e6:	eb 43                	jmp    372b <client_rcv_impl+0x795>
			printk("%d %d client state did not match, packet seq = %u state = %u, clientstate = %u\n", (int) jiffies, tp->t.state, cont->seq, cont->clientState, tp->t.clientStateCounter);
    36e8:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    36eb:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
    36f1:	89 44 24 14          	mov    %eax,0x14(%esp,1)
    36f5:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    36f8:	8b 40 38             	mov    0x38(%eax),%eax
    36fb:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    36ff:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    3702:	8b 40 30             	mov    0x30(%eax),%eax
    3705:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    3709:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    370c:	8b 80 cc 02 00 00    	mov    0x2cc(%eax),%eax
    3712:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    3716:	a1 00 00 00 00       	mov    0x0,%eax
    371b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    371f:	c7 04 24 00 18 00 00 	movl   $0x1800,(%esp,1)
    3726:	e8 fc ff ff ff       	call   3727 <client_rcv_impl+0x791>
		QUEUE_AND_DROP();
    372b:	c7 45 ec a7 09 00 00 	movl   $0x9a7,0xffffffec(%ebp)
    3732:	e9 d9 08 00 00       	jmp    4010 <client_rcv_impl+0x107a>
	}
	/* always add to alt sacks */
	if(!AckProof_update(sk, &tp->t.altProof, cont)) {
    3737:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    373a:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    373e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3741:	05 0c 06 00 00       	add    $0x60c,%eax
    3746:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    374a:	8b 45 08             	mov    0x8(%ebp),%eax
    374d:	89 04 24             	mov    %eax,(%esp,1)
    3750:	e8 fc ff ff ff       	call   3751 <client_rcv_impl+0x7bb>
    3755:	85 c0                	test   %eax,%eax
    3757:	75 1c                	jne    3775 <client_rcv_impl+0x7df>
		if(clientDebugLevel >= 2 || debugDrops || debugProofDrops) {
    3759:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    3760:	7f 07                	jg     3769 <client_rcv_impl+0x7d3>
    3762:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
			if(trickles_ratelimit())
				printk("altproof not updated, dropping\n");
		}
		QUEUE_AND_DROP();
    3769:	c7 45 ec af 09 00 00 	movl   $0x9af,0xffffffec(%ebp)
    3770:	e9 9b 08 00 00       	jmp    4010 <client_rcv_impl+0x107a>
	}
	if(tp->t.ack_prev == NULL || cont->seq > tp->t.ack_prev->seq) {
    3775:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3778:	83 b8 f4 02 00 00 00 	cmpl   $0x0,0x2f4(%eax)
    377f:	74 16                	je     3797 <client_rcv_impl+0x801>
    3781:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
    3784:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3787:	8b 90 f4 02 00 00    	mov    0x2f4(%eax),%edx
    378d:	8b 41 30             	mov    0x30(%ecx),%eax
    3790:	3b 42 30             	cmp    0x30(%edx),%eax
    3793:	77 02                	ja     3797 <client_rcv_impl+0x801>
    3795:	eb 4a                	jmp    37e1 <client_rcv_impl+0x84b>
		//printk("  client: updating standardProof\n");
		/* have not acked yet, so add to standard sack */
		if(!AckProof_update(sk, &tp->t.standardProof, cont) &&
    3797:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    379a:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    379e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    37a1:	05 04 03 00 00       	add    $0x304,%eax
    37a6:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    37aa:	8b 45 08             	mov    0x8(%ebp),%eax
    37ad:	89 04 24             	mov    %eax,(%esp,1)
    37b0:	e8 fc ff ff ff       	call   37b1 <client_rcv_impl+0x81b>
    37b5:	85 c0                	test   %eax,%eax
    37b7:	75 28                	jne    37e1 <client_rcv_impl+0x84b>
    37b9:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    37bc:	83 b8 cc 02 00 00 01 	cmpl   $0x1,0x2cc(%eax)
    37c3:	75 1c                	jne    37e1 <client_rcv_impl+0x84b>
		   // 0419: need this test since tp->t.standardProof can be in bad states during recovery and slowstart
		   tp->t.state == TRICKLES_CLIENT_NORMAL) {
			if(clientDebugLevel >= 2 || debugDrops || debugProofDrops){
    37c5:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    37cc:	7f 07                	jg     37d5 <client_rcv_impl+0x83f>
    37ce:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
				if(trickles_ratelimit())
					printk("standardProof not updated, dropping\n");
			}
			QUEUE_AND_DROP();
    37d5:	c7 45 ec bb 09 00 00 	movl   $0x9bb,0xffffffec(%ebp)
    37dc:	e9 2f 08 00 00       	jmp    4010 <client_rcv_impl+0x107a>
		}
	}

	if(!noCont) {
    37e1:	83 7d cc 00          	cmpl   $0x0,0xffffffcc(%ebp)
    37e5:	75 14                	jne    37fb <client_rcv_impl+0x865>
		/* receiving packets, so we're making progress */
		if(!disableTimeout) {
    37e7:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    37ee:	75 0b                	jne    37fb <client_rcv_impl+0x865>
			resetClientTimer(sk);
    37f0:	8b 45 08             	mov    0x8(%ebp),%eax
    37f3:	89 04 24             	mov    %eax,(%esp,1)
    37f6:	e8 fc ff ff ff       	call   37f7 <client_rcv_impl+0x861>
		}
	}
	cur_seq = cont->seq; // save value since cont might be deallocated soon
    37fb:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    37fe:	8b 40 30             	mov    0x30(%eax),%eax
    3801:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)

	TICK();

#ifdef FIXEDRTT
	tp->t.A = FIXEDRTT;
	tp->t.RTO = (tp->t.A >> 3) * TIMEOUT_MULTIPLIER;
#else
	if(!synack) {
    3804:	83 7d c8 00          	cmpl   $0x0,0xffffffc8(%ebp)
    3808:	0f 85 20 01 00 00    	jne    392e <client_rcv_impl+0x998>
		int delta = jiffies - cont->clientTimestamp;
    380e:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    3811:	8b 15 00 00 00 00    	mov    0x0,%edx
    3817:	2b 50 4c             	sub    0x4c(%eax),%edx
    381a:	89 d0                	mov    %edx,%eax
    381c:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
		if(delta > 0) {
    381f:	83 7d c4 00          	cmpl   $0x0,0xffffffc4(%ebp)
    3823:	0f 8e 05 01 00 00    	jle    392e <client_rcv_impl+0x998>
			// protect against wraparound
			if(delta > 1000) {
    3829:	81 7d c4 e8 03 00 00 	cmpl   $0x3e8,0xffffffc4(%ebp)
    3830:	7e 05                	jle    3837 <client_rcv_impl+0x8a1>
				//printk("warning: delta = %d\n", delta);
				goto skip;
    3832:	e9 f7 00 00 00       	jmp    392e <client_rcv_impl+0x998>
			}
			if(tp->t.A == 0) {
    3837:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    383a:	83 b8 d0 02 00 00 00 	cmpl   $0x0,0x2d0(%eax)
    3841:	75 28                	jne    386b <client_rcv_impl+0x8d5>
				tp->t.A = (delta) << 3;
    3843:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    3846:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    3849:	c1 e0 03             	shl    $0x3,%eax
    384c:	89 82 d0 02 00 00    	mov    %eax,0x2d0(%edx)
				// initial variance is initial estimate / 2
				tp->t.D = tp->t.A >> 1;
    3852:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    3855:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3858:	8b 80 d0 02 00 00    	mov    0x2d0(%eax),%eax
    385e:	d1 f8                	sar    %eax
    3860:	89 82 d4 02 00 00    	mov    %eax,0x2d4(%edx)
    3866:	e9 86 00 00 00       	jmp    38f1 <client_rcv_impl+0x95b>
			} else {
				int Err = (delta << 3) - tp->t.A; // units of jiffies/8
    386b:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    386e:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    3875:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3878:	2b 90 d0 02 00 00    	sub    0x2d0(%eax),%edx
    387e:	89 d0                	mov    %edx,%eax
    3880:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
				// Err is in units of jiffies/8, A is in units of jiffies/8
				//effect is A += 1/8 Err
				tp->t.A += (Err >> 3);
    3883:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
    3886:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    3889:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    388c:	c1 f8 03             	sar    $0x3,%eax
    388f:	03 82 d0 02 00 00    	add    0x2d0(%edx),%eax
    3895:	89 81 d0 02 00 00    	mov    %eax,0x2d0(%ecx)
				//effect is D += 1/4 (Err - D)
				tp->t.D += ((iabs(Err) - tp->t.D) >> 2);
    389b:	8b 5d e8             	mov    0xffffffe8(%ebp),%ebx
    389e:	8b 75 e8             	mov    0xffffffe8(%ebp),%esi
    38a1:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    38a4:	89 04 24             	mov    %eax,(%esp,1)
    38a7:	e8 6d 71 00 00       	call   aa19 <iabs>
    38ac:	89 c2                	mov    %eax,%edx
    38ae:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    38b1:	2b 90 d4 02 00 00    	sub    0x2d4(%eax),%edx
    38b7:	89 d0                	mov    %edx,%eax
    38b9:	c1 f8 02             	sar    $0x2,%eax
    38bc:	03 86 d4 02 00 00    	add    0x2d4(%esi),%eax
    38c2:	89 83 d4 02 00 00    	mov    %eax,0x2d4(%ebx)
				tp->t.RTO = VJ90RTO8(sk);
    38c8:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
    38cb:	8b 45 08             	mov    0x8(%ebp),%eax
    38ce:	05 bc 00 00 00       	add    $0xbc,%eax
    38d3:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
    38d6:	8b 55 b8             	mov    0xffffffb8(%ebp),%edx
    38d9:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
    38dc:	8b 80 d4 02 00 00    	mov    0x2d4(%eax),%eax
    38e2:	c1 e0 02             	shl    $0x2,%eax
    38e5:	03 82 d0 02 00 00    	add    0x2d0(%edx),%eax
    38eb:	89 81 d8 02 00 00    	mov    %eax,0x2d8(%ecx)
			}
			SAVE_ESTIMATOR_STATS(sk);
    38f1:	8b 45 08             	mov    0x8(%ebp),%eax
    38f4:	05 bc 00 00 00       	add    $0xbc,%eax
    38f9:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
    38fc:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
    38ff:	8b 80 d0 02 00 00    	mov    0x2d0(%eax),%eax
    3905:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3909:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    3910:	e8 a7 71 00 00       	call   aabc <hist_addPoint>
    3915:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
    3918:	8b 80 d4 02 00 00    	mov    0x2d4(%eax),%eax
    391e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3922:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    3929:	e8 8e 71 00 00       	call   aabc <hist_addPoint>
			if(0 && trickles_ratelimit()) {
				DUMP_RTO(sk);
				printk("\n");
			}
		}
	skip:
	}
#endif

	TICK();
	if(cont->seq == tp->t.rcv_nxt) {
    392e:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    3931:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    3934:	8b 40 30             	mov    0x30(%eax),%eax
    3937:	3b 82 e0 02 00 00    	cmp    0x2e0(%edx),%eax
    393d:	0f 85 6c 01 00 00    	jne    3aaf <client_rcv_impl+0xb19>
		TICK();
		int closedGap = 0;
    3943:	c7 45 b8 00 00 00 00 	movl   $0x0,0xffffffb8(%ebp)
		struct sk_buff *skb = in_skb;
    394a:	8b 45 0c             	mov    0xc(%ebp),%eax
    394d:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
		unsigned seq = cont->seq;
    3950:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    3953:	8b 40 30             	mov    0x30(%eax),%eax
    3956:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
		int first = 1;
    3959:	c7 45 b4 01 00 00 00 	movl   $0x1,0xffffffb4(%ebp)
		recordSample(&ctx,1);

		if(!noCont) {
    3960:	83 7d cc 00          	cmpl   $0x0,0xffffffcc(%ebp)
    3964:	75 12                	jne    3978 <client_rcv_impl+0x9e2>
			ContList_insert(sk,cont);
    3966:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    3969:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    396d:	8b 45 08             	mov    0x8(%ebp),%eax
    3970:	89 04 24             	mov    %eax,(%esp,1)
    3973:	e8 98 e0 ff ff       	call   1a10 <ContList_insert>
    3978:	90                   	nop    
		}
		recordSample(&ctx,1);
		while(1) {
			/* do NOT reinsert continuations from ofo queue; they're already in the ContList */
			client_inseq(sk, skb, noCont);
    3979:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    397c:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    3980:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    3983:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3987:	8b 45 08             	mov    0x8(%ebp),%eax
    398a:	89 04 24             	mov    %eax,(%esp,1)
    398d:	e8 c1 0c 00 00       	call   4653 <client_inseq>
			// client inseq may deallocate cont, so unlink here
			cont = NULL;
    3992:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
			if(first) recordSample(&ctx,1);
			if(paranoia >= 1 &&
    3999:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    39a0:	7e 3a                	jle    39dc <client_rcv_impl+0xa46>
    39a2:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    39a5:	8b 80 e0 02 00 00    	mov    0x2e0(%eax),%eax
    39ab:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    39af:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    39b2:	8b 80 e0 02 00 00    	mov    0x2e0(%eax),%eax
    39b8:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    39bc:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    39bf:	05 0c 06 00 00       	add    $0x60c,%eax
    39c4:	89 04 24             	mov    %eax,(%esp,1)
    39c7:	e8 fc ff ff ff       	call   39c8 <client_rcv_impl+0xa32>
    39cc:	85 c0                	test   %eax,%eax
    39ce:	75 0c                	jne    39dc <client_rcv_impl+0xa46>
			   AckProof_checkRange(&tp->t.altProof, tp->t.rcv_nxt, tp->t.rcv_nxt) == BADRANGE) {
				printk("Could not find rcv_nxt in altProof\n");
    39d0:	c7 04 24 60 18 00 00 	movl   $0x1860,(%esp,1)
    39d7:	e8 fc ff ff ff       	call   39d8 <client_rcv_impl+0xa42>
			}
			tp->t.rcv_nxt++;
    39dc:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    39df:	ff 80 e0 02 00 00    	incl   0x2e0(%eax)
#if 0
			if(IS_RECOVERY_STATE())
				printk("rcv nxt now %d ack_last = %d\n", tp->t.rcv_nxt, tp->t.ack_last);
#endif
			skb = skb_peek(&tp->t.ofo_queue);
    39e5:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    39e8:	05 e8 02 00 00       	add    $0x2e8,%eax
    39ed:	89 04 24             	mov    %eax,(%esp,1)
    39f0:	e8 d8 53 00 00       	call   8dcd <skb_peek>
    39f5:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
			if(first) recordSample(&ctx,1);
			if(!skb || TCP_SKB_CB(skb)->trickle_seq != tp->t.rcv_nxt) {
    39f8:	83 7d bc 00          	cmpl   $0x0,0xffffffbc(%ebp)
    39fc:	74 40                	je     3a3e <client_rcv_impl+0xaa8>
    39fe:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    3a01:	83 c0 30             	add    $0x30,%eax
    3a04:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    3a07:	8b 40 24             	mov    0x24(%eax),%eax
    3a0a:	3b 82 e0 02 00 00    	cmp    0x2e0(%edx),%eax
    3a10:	75 2c                	jne    3a3e <client_rcv_impl+0xaa8>
				if(first) recordSample(&ctx,1);
				break;
			}
			closedGap++;
    3a12:	8d 45 b8             	lea    0xffffffb8(%ebp),%eax
    3a15:	ff 00                	incl   (%eax)
			__skb_dequeue(&tp->t.ofo_queue);
    3a17:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3a1a:	05 e8 02 00 00       	add    $0x2e8,%eax
    3a1f:	89 04 24             	mov    %eax,(%esp,1)
    3a22:	e8 57 54 00 00       	call   8e7e <__skb_dequeue>
			delOfoSkb(skb);
    3a27:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    3a2a:	89 04 24             	mov    %eax,(%esp,1)
    3a2d:	e8 bb 71 00 00       	call   abed <delOfoSkb>
			if(first) recordSample(&ctx,1);
			first = 0;
    3a32:	c7 45 b4 00 00 00 00 	movl   $0x0,0xffffffb4(%ebp)
    3a39:	e9 3b ff ff ff       	jmp    3979 <client_rcv_impl+0x9e3>
		}
		recordSample(&ctx,1);
		if(closedGap) {
    3a3e:	83 7d b8 00          	cmpl   $0x0,0xffffffb8(%ebp)
    3a42:	74 39                	je     3a7d <client_rcv_impl+0xae7>
			if(clientDebugLevel >= 2)
    3a44:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    3a4b:	0f 8e 77 02 00 00    	jle    3cc8 <client_rcv_impl+0xd32>
				printk("%u closed gap of %d, ack_last = %u\n", seq, closedGap, tp->t.ack_last);
    3a51:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3a54:	8b 80 f8 02 00 00    	mov    0x2f8(%eax),%eax
    3a5a:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    3a5e:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
    3a61:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    3a65:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    3a68:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3a6c:	c7 04 24 a0 18 00 00 	movl   $0x18a0,(%esp,1)
    3a73:	e8 fc ff ff ff       	call   3a74 <client_rcv_impl+0xade>
    3a78:	e9 4b 02 00 00       	jmp    3cc8 <client_rcv_impl+0xd32>
		} else {
			if(clientDebugLevel >= 2)
    3a7d:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    3a84:	0f 8e 3e 02 00 00    	jle    3cc8 <client_rcv_impl+0xd32>
				printk("%u in order, ack_last = %u\n", seq, tp->t.ack_last);
    3a8a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3a8d:	8b 80 f8 02 00 00    	mov    0x2f8(%eax),%eax
    3a93:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    3a97:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    3a9a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3a9e:	c7 04 24 c4 18 00 00 	movl   $0x18c4,(%esp,1)
    3aa5:	e8 fc ff ff ff       	call   3aa6 <client_rcv_impl+0xb10>
    3aaa:	e9 19 02 00 00       	jmp    3cc8 <client_rcv_impl+0xd32>
		}
		recordSample(&ctx,1);
	} else {
		TICK();
		//printk("seq = %d, rcv_nxt = %d\n", cont->seq, tp->t.rcv_nxt);
		/* enqueue in ofo_queue */
		if(skb_peek(&tp->t.ofo_queue) == NULL) {
    3aaf:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3ab2:	05 e8 02 00 00       	add    $0x2e8,%eax
    3ab7:	89 04 24             	mov    %eax,(%esp,1)
    3aba:	e8 0e 53 00 00       	call   8dcd <skb_peek>
    3abf:	85 c0                	test   %eax,%eax
    3ac1:	75 75                	jne    3b38 <client_rcv_impl+0xba2>
			if(clientDebugLevel >= 2)
    3ac3:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    3aca:	7e 19                	jle    3ae5 <client_rcv_impl+0xb4f>
				printk("  client: %u inserted at ofo head\n", TCP_SKB_CB(in_skb)->trickle_seq);
    3acc:	8b 45 0c             	mov    0xc(%ebp),%eax
    3acf:	83 c0 30             	add    $0x30,%eax
    3ad2:	8b 40 24             	mov    0x24(%eax),%eax
    3ad5:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3ad9:	c7 04 24 e0 18 00 00 	movl   $0x18e0,(%esp,1)
    3ae0:	e8 fc ff ff ff       	call   3ae1 <client_rcv_impl+0xb4b>
			if(!addOfoSkb(in_skb)) {
    3ae5:	8b 45 0c             	mov    0xc(%ebp),%eax
    3ae8:	89 04 24             	mov    %eax,(%esp,1)
    3aeb:	e8 b2 70 00 00       	call   aba2 <addOfoSkb>
    3af0:	85 c0                	test   %eax,%eax
    3af2:	75 0c                	jne    3b00 <client_rcv_impl+0xb6a>
				DROP();
    3af4:	c7 45 ec 25 0a 00 00 	movl   $0xa25,0xffffffec(%ebp)
    3afb:	e9 4b 05 00 00       	jmp    404b <client_rcv_impl+0x10b5>
			}
			__skb_queue_head(&tp->t.ofo_queue, in_skb);
    3b00:	8b 45 0c             	mov    0xc(%ebp),%eax
    3b03:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3b07:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3b0a:	05 e8 02 00 00       	add    $0x2e8,%eax
    3b0f:	89 04 24             	mov    %eax,(%esp,1)
    3b12:	e8 d8 52 00 00       	call   8def <__skb_queue_head>
			if(!noCont) {
    3b17:	83 7d cc 00          	cmpl   $0x0,0xffffffcc(%ebp)
    3b1b:	0f 85 a7 01 00 00    	jne    3cc8 <client_rcv_impl+0xd32>
				ContList_insert(sk,cont);
    3b21:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    3b24:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3b28:	8b 45 08             	mov    0x8(%ebp),%eax
    3b2b:	89 04 24             	mov    %eax,(%esp,1)
    3b2e:	e8 dd de ff ff       	call   1a10 <ContList_insert>
    3b33:	e9 90 01 00 00       	jmp    3cc8 <client_rcv_impl+0xd32>
			}
		} else {
			struct sk_buff *skb = tp->t.ofo_queue.prev;
    3b38:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3b3b:	8b 80 ec 02 00 00    	mov    0x2ec(%eax),%eax
    3b41:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
			do {
				if(TCP_SKB_CB(skb)->trickle_seq < TCP_SKB_CB(in_skb)->trickle_seq)
    3b44:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
    3b47:	83 c0 30             	add    $0x30,%eax
    3b4a:	8b 55 0c             	mov    0xc(%ebp),%edx
    3b4d:	83 c2 30             	add    $0x30,%edx
    3b50:	8b 40 24             	mov    0x24(%eax),%eax
    3b53:	3b 42 24             	cmp    0x24(%edx),%eax
    3b56:	73 02                	jae    3b5a <client_rcv_impl+0xbc4>
					break;
    3b58:	eb 15                	jmp    3b6f <client_rcv_impl+0xbd9>
			} while((struct sk_buff_head*)(skb=skb->prev) != &tp->t.ofo_queue);
    3b5a:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
    3b5d:	8b 50 04             	mov    0x4(%eax),%edx
    3b60:	89 55 b4             	mov    %edx,0xffffffb4(%ebp)
    3b63:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3b66:	05 e8 02 00 00       	add    $0x2e8,%eax
    3b6b:	39 c2                	cmp    %eax,%edx
    3b6d:	75 d5                	jne    3b44 <client_rcv_impl+0xbae>

			if((struct sk_buff_head*)skb->next != &tp->t.ofo_queue &&
    3b6f:	8b 55 b4             	mov    0xffffffb4(%ebp),%edx
    3b72:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3b75:	05 e8 02 00 00       	add    $0x2e8,%eax
    3b7a:	39 02                	cmp    %eax,(%edx)
    3b7c:	0f 84 ae 00 00 00    	je     3c30 <client_rcv_impl+0xc9a>
    3b82:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
    3b85:	8b 00                	mov    (%eax),%eax
    3b87:	83 c0 30             	add    $0x30,%eax
    3b8a:	8b 55 0c             	mov    0xc(%ebp),%edx
    3b8d:	83 c2 30             	add    $0x30,%edx
    3b90:	8b 40 24             	mov    0x24(%eax),%eax
    3b93:	3b 42 24             	cmp    0x24(%edx),%eax
    3b96:	0f 85 94 00 00 00    	jne    3c30 <client_rcv_impl+0xc9a>
			   TCP_SKB_CB(skb->next)->trickle_seq == TCP_SKB_CB(in_skb)->trickle_seq) {
				// overlap
				struct sk_buff *next = skb->next;
    3b9c:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
    3b9f:	8b 00                	mov    (%eax),%eax
    3ba1:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
				if(NEWER(TCP_SKB_CB(in_skb)->clientState, TCP_SKB_CB(next)->clientState)) {
    3ba4:	8b 45 0c             	mov    0xc(%ebp),%eax
    3ba7:	83 c0 30             	add    $0x30,%eax
    3baa:	8b 55 b8             	mov    0xffffffb8(%ebp),%edx
    3bad:	83 c2 30             	add    $0x30,%edx
    3bb0:	8b 40 28             	mov    0x28(%eax),%eax
    3bb3:	3b 42 28             	cmp    0x28(%edx),%eax
    3bb6:	76 46                	jbe    3bfe <client_rcv_impl+0xc68>

					if(clientDebugLevel >= 2)
    3bb8:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    3bbf:	7e 19                	jle    3bda <client_rcv_impl+0xc44>
						printk("Got rid of old skb %u\n", TCP_SKB_CB(next)->trickle_seq);
    3bc1:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
    3bc4:	83 c0 30             	add    $0x30,%eax
    3bc7:	8b 40 24             	mov    0x24(%eax),%eax
    3bca:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3bce:	c7 04 24 03 19 00 00 	movl   $0x1903,(%esp,1)
    3bd5:	e8 fc ff ff ff       	call   3bd6 <client_rcv_impl+0xc40>
					__skb_unlink(next, &tp->t.ofo_queue);
    3bda:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3bdd:	05 e8 02 00 00       	add    $0x2e8,%eax
    3be2:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3be6:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
    3be9:	89 04 24             	mov    %eax,(%esp,1)
    3bec:	e8 2d 53 00 00       	call   8f1e <__skb_unlink>
					trickles_kfree_skb(next);
    3bf1:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
    3bf4:	89 04 24             	mov    %eax,(%esp,1)
    3bf7:	e8 a8 c8 ff ff       	call   4a4 <trickles_kfree_skb>
    3bfc:	eb 32                	jmp    3c30 <client_rcv_impl+0xc9a>
				} else {
					if(clientDebugLevel >= 2)
    3bfe:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    3c05:	7e 19                	jle    3c20 <client_rcv_impl+0xc8a>
						printk("Got rid of new skb %u\n", TCP_SKB_CB(in_skb)->trickle_seq);
    3c07:	8b 45 0c             	mov    0xc(%ebp),%eax
    3c0a:	83 c0 30             	add    $0x30,%eax
    3c0d:	8b 40 24             	mov    0x24(%eax),%eax
    3c10:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3c14:	c7 04 24 1a 19 00 00 	movl   $0x191a,(%esp,1)
    3c1b:	e8 fc ff ff ff       	call   3c1c <client_rcv_impl+0xc86>
					trickles_kfree_skb(in_skb);
    3c20:	8b 45 0c             	mov    0xc(%ebp),%eax
    3c23:	89 04 24             	mov    %eax,(%esp,1)
    3c26:	e8 79 c8 ff ff       	call   4a4 <trickles_kfree_skb>
					goto skip_insert;
    3c2b:	e9 98 00 00 00       	jmp    3cc8 <client_rcv_impl+0xd32>
				}
			}
			if(clientDebugLevel >= 2) {
    3c30:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    3c37:	7e 35                	jle    3c6e <client_rcv_impl+0xcd8>
				printk("  client: inserted %u after %u, before %u\n", TCP_SKB_CB(in_skb)->trickle_seq, TCP_SKB_CB(skb)->trickle_seq, TCP_SKB_CB(skb->next)->trickle_seq);
    3c39:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
    3c3c:	8b 00                	mov    (%eax),%eax
    3c3e:	83 c0 30             	add    $0x30,%eax
    3c41:	8b 40 24             	mov    0x24(%eax),%eax
    3c44:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    3c48:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
    3c4b:	83 c0 30             	add    $0x30,%eax
    3c4e:	8b 40 24             	mov    0x24(%eax),%eax
    3c51:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    3c55:	8b 45 0c             	mov    0xc(%ebp),%eax
    3c58:	83 c0 30             	add    $0x30,%eax
    3c5b:	8b 40 24             	mov    0x24(%eax),%eax
    3c5e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3c62:	c7 04 24 40 19 00 00 	movl   $0x1940,(%esp,1)
    3c69:	e8 fc ff ff ff       	call   3c6a <client_rcv_impl+0xcd4>
			}
			if(!addOfoSkb(in_skb)) {
    3c6e:	8b 45 0c             	mov    0xc(%ebp),%eax
    3c71:	89 04 24             	mov    %eax,(%esp,1)
    3c74:	e8 29 6f 00 00       	call   aba2 <addOfoSkb>
    3c79:	85 c0                	test   %eax,%eax
    3c7b:	75 0c                	jne    3c89 <client_rcv_impl+0xcf3>
				DROP();
    3c7d:	c7 45 ec 47 0a 00 00 	movl   $0xa47,0xffffffec(%ebp)
    3c84:	e9 c2 03 00 00       	jmp    404b <client_rcv_impl+0x10b5>
			}
			__skb_insert(in_skb, skb, skb->next, &tp->t.ofo_queue);
    3c89:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3c8c:	05 e8 02 00 00       	add    $0x2e8,%eax
    3c91:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    3c95:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
    3c98:	8b 00                	mov    (%eax),%eax
    3c9a:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    3c9e:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
    3ca1:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3ca5:	8b 45 0c             	mov    0xc(%ebp),%eax
    3ca8:	89 04 24             	mov    %eax,(%esp,1)
    3cab:	e8 38 52 00 00       	call   8ee8 <__skb_insert>

			/* sorted insert into cont list */
			if(!noCont)
    3cb0:	83 7d cc 00          	cmpl   $0x0,0xffffffcc(%ebp)
    3cb4:	75 12                	jne    3cc8 <client_rcv_impl+0xd32>
				ContList_insert(sk, cont);
    3cb6:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    3cb9:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3cbd:	8b 45 08             	mov    0x8(%ebp),%eax
    3cc0:	89 04 24             	mov    %eax,(%esp,1)
    3cc3:	e8 48 dd ff ff       	call   1a10 <ContList_insert>
		skip_insert: ;
		}
	}
	recordSample(&ctx,0);
	cont = NULL;
    3cc8:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
	in_skb = NULL;
    3ccf:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
	// After this point, never reference cont or in_skb

	switch(tp->t.state) {
    3cd6:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3cd9:	8b 80 cc 02 00 00    	mov    0x2cc(%eax),%eax
    3cdf:	89 45 98             	mov    %eax,0xffffff98(%ebp)
    3ce2:	83 7d 98 03          	cmpl   $0x3,0xffffff98(%ebp)
    3ce6:	0f 84 df 03 00 00    	je     40cb <client_rcv_impl+0x1135>
    3cec:	83 7d 98 03          	cmpl   $0x3,0xffffff98(%ebp)
    3cf0:	7f 0c                	jg     3cfe <client_rcv_impl+0xd68>
    3cf2:	83 7d 98 01          	cmpl   $0x1,0xffffff98(%ebp)
    3cf6:	0f 8c ea 02 00 00    	jl     3fe6 <client_rcv_impl+0x1050>
    3cfc:	eb 0b                	jmp    3d09 <client_rcv_impl+0xd73>
    3cfe:	83 7d 98 04          	cmpl   $0x4,0xffffff98(%ebp)
    3d02:	74 05                	je     3d09 <client_rcv_impl+0xd73>
    3d04:	e9 dd 02 00 00       	jmp    3fe6 <client_rcv_impl+0x1050>
	case TRICKLES_CLIENT_SYNACK:
		TICK();
	case TRICKLES_CLIENT_NORMAL:
		TICK();
	case TRICKLES_CLIENT_RECOVERY:
		TICK();
		/* Check whether we want to send an ack */
		recordSample(&ctx,2);
		progress = findAckables(sk,0,NULL);
    3d09:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    3d10:	00 
    3d11:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    3d18:	00 
    3d19:	8b 45 08             	mov    0x8(%ebp),%eax
    3d1c:	89 04 24             	mov    %eax,(%esp,1)
    3d1f:	e8 50 1f 00 00       	call   5c74 <findAckables>
    3d24:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
		recordSample(&ctx,2);
		if(!progress) {
    3d27:	83 7d d4 00          	cmpl   $0x0,0xffffffd4(%ebp)
    3d2b:	0f 85 9d 02 00 00    	jne    3fce <client_rcv_impl+0x1038>
			if(clientDebugLevel >= 2)
    3d31:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    3d38:	7e 19                	jle    3d53 <client_rcv_impl+0xdbd>
				printk("  client: no ackable found, rcv_nxt = %u\n", tp->t.rcv_nxt);
    3d3a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3d3d:	8b 80 e0 02 00 00    	mov    0x2e0(%eax),%eax
    3d43:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3d47:	c7 04 24 80 19 00 00 	movl   $0x1980,(%esp,1)
    3d4e:	e8 fc ff ff ff       	call   3d4f <client_rcv_impl+0xdb9>
#ifndef DISABLE_FASTRECOVERY
			if(cur_seq > tp->t.ack_last) {
    3d53:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    3d56:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    3d59:	3b 82 f8 02 00 00    	cmp    0x2f8(%edx),%eax
    3d5f:	0f 86 69 02 00 00    	jbe    3fce <client_rcv_impl+0x1038>
				tp->t.oo_count++;
    3d65:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3d68:	ff 80 fc 02 00 00    	incl   0x2fc(%eax)
#if 1 // 0714 - try different out of order thresholds
				if(tp->t.oo_count >= OO_THRESHOLD) {
    3d6e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3d71:	8b 80 fc 02 00 00    	mov    0x2fc(%eax),%eax
    3d77:	3b 05 00 00 00 00    	cmp    0x0,%eax
    3d7d:	0f 8c 4b 02 00 00    	jl     3fce <client_rcv_impl+0x1038>
#else
				if(tp->t.oo_count >= min(OO_THRESHOLD, max(tp->t.sentRequests.len / 4, 3))) {
				}
#endif
					int old_last = tp->t.ack_last;
    3d83:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3d86:	8b 80 f8 02 00 00    	mov    0x2f8(%eax),%eax
    3d8c:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
					unsigned first_seq, seq;
					struct sk_buff *skip_skb;
					struct Request *req;
					struct DataRequestMapping *dataReqMap;

					if(clientDebugLevel >= 2)
    3d8f:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    3d96:	7e 0c                	jle    3da4 <client_rcv_impl+0xe0e>
						printk("oo threshold exceeded\n");
    3d98:	c7 04 24 aa 19 00 00 	movl   $0x19aa,(%esp,1)
    3d9f:	e8 fc ff ff ff       	call   3da0 <client_rcv_impl+0xe0a>
					tp->t.oo_count = 0;
    3da4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3da7:	c7 80 fc 02 00 00 00 	movl   $0x0,0x2fc(%eax)
    3dae:	00 00 00 
					gNumRecovery++;
    3db1:	ff 05 00 00 00 00    	incl   0x0
#ifdef REPORT_RECOVERY
					printk("entering recovery @ ack_last = %d seq = %d\n", tp->t.ack_last, cur_seq);
#endif

					enterRecoveryState(sk, 0);
    3db7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    3dbe:	00 
    3dbf:	8b 45 08             	mov    0x8(%ebp),%eax
    3dc2:	89 04 24             	mov    %eax,(%esp,1)
    3dc5:	e8 ed d9 ff ff       	call   17b7 <enterRecoveryState>
					findAckables(sk, 1,&skip_skb);
    3dca:	8d 45 c4             	lea    0xffffffc4(%ebp),%eax
    3dcd:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    3dd1:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
    3dd8:	00 
    3dd9:	8b 45 08             	mov    0x8(%ebp),%eax
    3ddc:	89 04 24             	mov    %eax,(%esp,1)
    3ddf:	e8 90 1e 00 00       	call   5c74 <findAckables>

					BUG_TRAP(tp->t.ack_last >= old_last);
    3de4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3de7:	8b 80 f8 02 00 00    	mov    0x2f8(%eax),%eax
    3ded:	3b 45 b4             	cmp    0xffffffb4(%ebp),%eax
    3df0:	7d 14                	jge    3e06 <client_rcv_impl+0xe70>
    3df2:	c7 44 24 04 7e 0a 00 	movl   $0xa7e,0x4(%esp,1)
    3df9:	00 
    3dfa:	c7 04 24 e0 19 00 00 	movl   $0x19e0,(%esp,1)
    3e01:	e8 fc ff ff ff       	call   3e02 <client_rcv_impl+0xe6c>
					BUG_TRAP(skip_skb != NULL);
    3e06:	83 7d c4 00          	cmpl   $0x0,0xffffffc4(%ebp)
    3e0a:	75 14                	jne    3e20 <client_rcv_impl+0xe8a>
    3e0c:	c7 44 24 04 7f 0a 00 	movl   $0xa7f,0x4(%esp,1)
    3e13:	00 
    3e14:	c7 04 24 40 1a 00 00 	movl   $0x1a40,(%esp,1)
    3e1b:	e8 fc ff ff ff       	call   3e1c <client_rcv_impl+0xe86>
					if(skip_skb->prev != (struct sk_buff*)&tp->t.ofo_queue) {
    3e20:	8b 55 c4             	mov    0xffffffc4(%ebp),%edx
    3e23:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3e26:	05 e8 02 00 00       	add    $0x2e8,%eax
    3e2b:	39 42 04             	cmp    %eax,0x4(%edx)
    3e2e:	74 12                	je     3e42 <client_rcv_impl+0xeac>
						first_seq = TCP_SKB_CB(skip_skb->prev)->trickle_seq + 1;
    3e30:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    3e33:	8b 40 04             	mov    0x4(%eax),%eax
    3e36:	83 c0 30             	add    $0x30,%eax
    3e39:	8b 40 24             	mov    0x24(%eax),%eax
    3e3c:	40                   	inc    %eax
    3e3d:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
    3e40:	eb 0c                	jmp    3e4e <client_rcv_impl+0xeb8>
					} else {
						first_seq = tp->t.rcv_nxt;
    3e42:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3e45:	8b 80 e0 02 00 00    	mov    0x2e0(%eax),%eax
    3e4b:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
					}
					BUG_TRAP(first_seq < TCP_SKB_CB(skip_skb)->trickle_seq);
    3e4e:	8b 55 c4             	mov    0xffffffc4(%ebp),%edx
    3e51:	83 c2 30             	add    $0x30,%edx
    3e54:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
    3e57:	3b 42 24             	cmp    0x24(%edx),%eax
    3e5a:	72 14                	jb     3e70 <client_rcv_impl+0xeda>
    3e5c:	c7 44 24 04 85 0a 00 	movl   $0xa85,0x4(%esp,1)
    3e63:	00 
    3e64:	c7 04 24 80 1a 00 00 	movl   $0x1a80,(%esp,1)
    3e6b:	e8 fc ff ff ff       	call   3e6c <client_rcv_impl+0xed6>
#if 1 // 0418 [AA
					for(seq = first_seq,
						    dataReqMap = (struct DataRequestMapping*)tp->t.dataRequestMap.next,
						    req = (struct Request *)tp->t.sentRequests.next;
    3e70:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
    3e73:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
    3e76:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3e79:	8b 80 b0 09 00 00    	mov    0x9b0(%eax),%eax
    3e7f:	89 45 ac             	mov    %eax,0xffffffac(%ebp)
    3e82:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3e85:	8b 80 88 09 00 00    	mov    0x988(%eax),%eax
    3e8b:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
    3e8e:	8b 55 c4             	mov    0xffffffc4(%ebp),%edx
    3e91:	83 c2 30             	add    $0x30,%edx
    3e94:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    3e97:	3b 42 24             	cmp    0x24(%edx),%eax
    3e9a:	72 05                	jb     3ea1 <client_rcv_impl+0xf0b>
    3e9c:	e9 2d 01 00 00       	jmp    3fce <client_rcv_impl+0x1038>
					    seq < TCP_SKB_CB(skip_skb)->trickle_seq;
					    seq++) {
						int foundMapping = 0, foundRequest = 0;
    3ea1:	c7 45 a8 00 00 00 00 	movl   $0x0,0xffffffa8(%ebp)
    3ea8:	c7 45 a4 00 00 00 00 	movl   $0x0,0xffffffa4(%ebp)
						while(dataReqMap != (struct DataRequestMapping*) &tp->t.dataRequestMap &&
    3eaf:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3eb2:	05 ac 09 00 00       	add    $0x9ac,%eax
    3eb7:	39 45 ac             	cmp    %eax,0xffffffac(%ebp)
    3eba:	74 18                	je     3ed4 <client_rcv_impl+0xf3e>
    3ebc:	8b 45 ac             	mov    0xffffffac(%ebp),%eax
    3ebf:	8b 40 1c             	mov    0x1c(%eax),%eax
    3ec2:	3b 45 bc             	cmp    0xffffffbc(%ebp),%eax
    3ec5:	76 02                	jbe    3ec9 <client_rcv_impl+0xf33>
    3ec7:	eb 0b                	jmp    3ed4 <client_rcv_impl+0xf3e>
						      dataReqMap->transportResponseSeqEnd <= seq) {
							dataReqMap = dataReqMap->next;
    3ec9:	8b 45 ac             	mov    0xffffffac(%ebp),%eax
    3ecc:	8b 40 04             	mov    0x4(%eax),%eax
    3ecf:	89 45 ac             	mov    %eax,0xffffffac(%ebp)
    3ed2:	eb db                	jmp    3eaf <client_rcv_impl+0xf19>
						}
						if(dataReqMap != (struct DataRequestMapping*)&tp->t.dataRequestMap &&
    3ed4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3ed7:	05 ac 09 00 00       	add    $0x9ac,%eax
    3edc:	39 45 ac             	cmp    %eax,0xffffffac(%ebp)
    3edf:	74 57                	je     3f38 <client_rcv_impl+0xfa2>
    3ee1:	8b 45 ac             	mov    0xffffffac(%ebp),%eax
    3ee4:	8b 40 18             	mov    0x18(%eax),%eax
    3ee7:	3b 45 bc             	cmp    0xffffffbc(%ebp),%eax
    3eea:	77 4c                	ja     3f38 <client_rcv_impl+0xfa2>
    3eec:	8b 55 ac             	mov    0xffffffac(%ebp),%edx
    3eef:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    3ef2:	3b 42 1c             	cmp    0x1c(%edx),%eax
    3ef5:	73 41                	jae    3f38 <client_rcv_impl+0xfa2>
						   dataReqMap->transportResponseSeqStart <= seq &&
						   seq < dataReqMap->transportResponseSeqEnd) {
							struct DataRequestMapping *next = dataReqMap->next;
    3ef7:	8b 45 ac             	mov    0xffffffac(%ebp),%eax
    3efa:	8b 40 04             	mov    0x4(%eax),%eax
    3efd:	89 45 a0             	mov    %eax,0xffffffa0(%ebp)
							// Missing packet overlaps a data mapping
							if(enableDataRecovery) {
    3f00:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    3f07:	74 29                	je     3f32 <client_rcv_impl+0xf9c>
								unlink((struct alloc_head*)dataReqMap);
    3f09:	8b 45 ac             	mov    0xffffffac(%ebp),%eax
    3f0c:	89 04 24             	mov    %eax,(%esp,1)
    3f0f:	e8 d8 53 00 00       	call   92ec <unlink>
								RECORD_MISSINGDATAMAP_INSERTION(dataReqMap);
								insert_tail(&tp->t.missingDataMap,
    3f14:	8b 45 ac             	mov    0xffffffac(%ebp),%eax
    3f17:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3f1b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3f1e:	05 c0 09 00 00       	add    $0x9c0,%eax
    3f23:	89 04 24             	mov    %eax,(%esp,1)
    3f26:	e8 49 53 00 00       	call   9274 <insert_tail>
									    (struct alloc_head*)dataReqMap);
								foundMapping = 1;
    3f2b:	c7 45 a8 01 00 00 00 	movl   $0x1,0xffffffa8(%ebp)
							}
							dataReqMap = next;
    3f32:	8b 45 a0             	mov    0xffffffa0(%ebp),%eax
    3f35:	89 45 ac             	mov    %eax,0xffffffac(%ebp)
    3f38:	90                   	nop    
						}

						while(req != (struct Request *)&tp->t.sentRequests &&
    3f39:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3f3c:	05 84 09 00 00       	add    $0x984,%eax
    3f41:	39 45 b0             	cmp    %eax,0xffffffb0(%ebp)
    3f44:	74 18                	je     3f5e <client_rcv_impl+0xfc8>
    3f46:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
    3f49:	8b 40 50             	mov    0x50(%eax),%eax
    3f4c:	3b 45 bc             	cmp    0xffffffbc(%ebp),%eax
    3f4f:	76 02                	jbe    3f53 <client_rcv_impl+0xfbd>
    3f51:	eb 0b                	jmp    3f5e <client_rcv_impl+0xfc8>
						      req->transportResponseSeqEnd <= seq) {
							req = (struct Request*)req->next;
    3f53:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
    3f56:	8b 40 04             	mov    0x4(%eax),%eax
    3f59:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
    3f5c:	eb db                	jmp    3f39 <client_rcv_impl+0xfa3>
						}
						if(req != (struct Request *)&tp->t.sentRequests &&
    3f5e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3f61:	05 84 09 00 00       	add    $0x984,%eax
    3f66:	39 45 b0             	cmp    %eax,0xffffffb0(%ebp)
    3f69:	74 59                	je     3fc4 <client_rcv_impl+0x102e>
    3f6b:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
    3f6e:	8b 40 4c             	mov    0x4c(%eax),%eax
    3f71:	3b 45 bc             	cmp    0xffffffbc(%ebp),%eax
    3f74:	77 4e                	ja     3fc4 <client_rcv_impl+0x102e>
    3f76:	8b 55 b0             	mov    0xffffffb0(%ebp),%edx
    3f79:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    3f7c:	3b 42 50             	cmp    0x50(%edx),%eax
    3f7f:	73 43                	jae    3fc4 <client_rcv_impl+0x102e>
						   req->transportResponseSeqStart <= seq &&
						   seq < req->transportResponseSeqEnd) {
							struct Request *next = (struct Request*)req->next;
    3f81:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
    3f84:	8b 40 04             	mov    0x4(%eax),%eax
    3f87:	89 45 a0             	mov    %eax,0xffffffa0(%ebp)

							unlink((struct alloc_head*)req);
    3f8a:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
    3f8d:	89 04 24             	mov    %eax,(%esp,1)
    3f90:	e8 57 53 00 00       	call   92ec <unlink>
							resetRequest(req);
    3f95:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
    3f98:	89 04 24             	mov    %eax,(%esp,1)
    3f9b:	e8 b2 57 00 00       	call   9752 <resetRequest>
							CHECK_IF_ZEROREQUEST(req);
							insert_head(&tp->t.queuedRequests, (struct alloc_head*)req);
    3fa0:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
    3fa3:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    3fa7:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    3faa:	05 98 09 00 00       	add    $0x998,%eax
    3faf:	89 04 24             	mov    %eax,(%esp,1)
    3fb2:	e8 42 52 00 00       	call   91f9 <insert_head>
							foundRequest = 1;
    3fb7:	c7 45 a4 01 00 00 00 	movl   $0x1,0xffffffa4(%ebp)
							req = next;
    3fbe:	8b 45 a0             	mov    0xffffffa0(%ebp),%eax
    3fc1:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
    3fc4:	8d 45 bc             	lea    0xffffffbc(%ebp),%eax
    3fc7:	ff 00                	incl   (%eax)
    3fc9:	e9 c0 fe ff ff       	jmp    3e8e <client_rcv_impl+0xef8>
						}
						if(!(foundRequest ^ foundMapping)) {
#if 0 // 0418 trickles should be able to recover from these conditions
							if(foundRequest && foundMapping) {
								printk("weird, found both a request and a mapping\n");
							} else {
								printk("found neither request nor mapping\n");
							}
#endif
						}
					}
#endif // 0418 AA]
				}
			}
#endif // DISABLE_FASTRECOVERY
		} else {
			//printk("  client: after findackables: ack_seq = %d ack_last = %d\n", tp->t.ack_seq, tp->t.ack_last);
		}
		recordSample(&ctx,2);
		trickles_send_ack_impl(sk, 0);
    3fce:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    3fd5:	00 
    3fd6:	8b 45 08             	mov    0x8(%ebp),%eax
    3fd9:	89 04 24             	mov    %eax,(%esp,1)
    3fdc:	e8 fc ff ff ff       	call   3fdd <client_rcv_impl+0x1047>
		recordSample(&ctx,2);
		break;
    3fe1:	e9 e5 00 00 00       	jmp    40cb <client_rcv_impl+0x1135>
	case TRICKLES_CLIENT_SLOWSTART:
		// do nothing
		break;
	default:
		BUG();
    3fe6:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    3fed:	00 
    3fee:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    3ff5:	e8 fc ff ff ff       	call   3ff6 <client_rcv_impl+0x1060>
    3ffa:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    4001:	e8 fc ff ff ff       	call   4002 <client_rcv_impl+0x106c>
    4006:	e8 fc ff ff ff       	call   4007 <client_rcv_impl+0x1071>
	}
	recordSample(&ctx,0);
	printTimings(&ctx);
	//printk("Exit client_rcv_impl(%p)\n", in_skb);
	return 0;
    400b:	e9 bb 00 00 00       	jmp    40cb <client_rcv_impl+0x1135>

 queue_data_and_drop:
	//printk("dropline = %d ", dropline);
	TICK();

	// 0901 -- Scrape out the last bit of performane from the dropped packets

	// Always attempt to enqueue the DATA, even if the rest of the
	// protocol is b0rked
	TCP_SKB_CB(in_skb)->dbg = __LINE__;
    4010:	8b 45 0c             	mov    0xc(%ebp),%eax
    4013:	83 c0 30             	add    $0x30,%eax
    4016:	c7 40 58 d8 0a 00 00 	movl   $0xad8,0x58(%eax)
	if(try_queue_data(sk,in_skb) >= 0) {
    401d:	c7 44 24 08 d9 0a 00 	movl   $0xad9,0x8(%esp,1)
    4024:	00 
    4025:	8b 45 0c             	mov    0xc(%ebp),%eax
    4028:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    402c:	8b 45 08             	mov    0x8(%ebp),%eax
    402f:	89 04 24             	mov    %eax,(%esp,1)
    4032:	e8 6d 08 00 00       	call   48a4 <try_queue_data_helper>
    4037:	85 c0                	test   %eax,%eax
    4039:	78 10                	js     404b <client_rcv_impl+0x10b5>
		//printk("try queue data returned success\n");
		trickles_kfree_skb(in_skb);
    403b:	8b 45 0c             	mov    0xc(%ebp),%eax
    403e:	89 04 24             	mov    %eax,(%esp,1)
    4041:	e8 5e c4 ff ff       	call   4a4 <trickles_kfree_skb>
		return 0;
    4046:	e9 80 00 00 00       	jmp    40cb <client_rcv_impl+0x1135>
	} else {
		//printk("try queue data returned failure\n");
	}
 drop:
	TICK();
	if(debugDrops) {
    404b:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    4052:	74 33                	je     4087 <client_rcv_impl+0x10f1>
		printk("dropping @ %d ", dropline);
    4054:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    4057:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    405b:	c7 04 24 dc 1a 00 00 	movl   $0x1adc,(%esp,1)
    4062:	e8 fc ff ff ff       	call   4063 <client_rcv_impl+0x10cd>
		printk("state = %d seq = %d ", cont->state, cont->seq);
    4067:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    406a:	8b 40 30             	mov    0x30(%eax),%eax
    406d:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    4071:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    4074:	8b 40 54             	mov    0x54(%eax),%eax
    4077:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    407b:	c7 04 24 eb 1a 00 00 	movl   $0x1aeb,(%esp,1)
    4082:	e8 fc ff ff ff       	call   4083 <client_rcv_impl+0x10ed>
		//update_rx_stats_helper(in_skb, 1);
	} else {
		//update_rx_stats_helper(in_skb, 0);
	}

	trickles_kfree_skb(in_skb);
    4087:	8b 45 0c             	mov    0xc(%ebp),%eax
    408a:	89 04 24             	mov    %eax,(%esp,1)
    408d:	e8 12 c4 ff ff       	call   4a4 <trickles_kfree_skb>
	if(cont != NULL && (tp->t.ack_prev == cont)) {
    4092:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
    4096:	74 33                	je     40cb <client_rcv_impl+0x1135>
    4098:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    409b:	8b 80 f4 02 00 00    	mov    0x2f4(%eax),%eax
    40a1:	3b 45 e0             	cmp    0xffffffe0(%ebp),%eax
    40a4:	75 25                	jne    40cb <client_rcv_impl+0x1135>
		BUG();
    40a6:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    40ad:	00 
    40ae:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    40b5:	e8 fc ff ff ff       	call   40b6 <client_rcv_impl+0x1120>
    40ba:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    40c1:	e8 fc ff ff ff       	call   40c2 <client_rcv_impl+0x112c>
    40c6:	e8 fc ff ff ff       	call   40c7 <client_rcv_impl+0x1131>
	}
#if 0 // 0813 trickles_kfree_skb now handles deallocation
	if(cont) {
		printk("dropline = %d\n", dropline);
		MARK_PC(cont);
		freeClientSide_Continuation(cont);
	}
#endif
	//printk("Exit client_rcv_impl(%p)\n", in_skb);
	return 0;
}
    40cb:	b8 00 00 00 00       	mov    $0x0,%eax
    40d0:	83 c4 78             	add    $0x78,%esp
    40d3:	5b                   	pop    %ebx
    40d4:	5e                   	pop    %esi
    40d5:	5d                   	pop    %ebp
    40d6:	c3                   	ret    

000040d7 <trickles_send_ack_impl>:
#undef DROP
#undef QUEUE_AND_DROP

int trickles_send_ack_impl(struct sock *sk, int user_ctx) {
    40d7:	55                   	push   %ebp
    40d8:	89 e5                	mov    %esp,%ebp
    40da:	83 ec 34             	sub    $0x34,%esp
	int num_iterations = 0;
    40dd:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    40e4:	8b 45 08             	mov    0x8(%ebp),%eax
    40e7:	05 bc 00 00 00       	add    $0xbc,%eax
    40ec:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	CONTINUATION_TYPE *cont = tp->t.ack_prev;
    40ef:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    40f2:	8b 80 f4 02 00 00    	mov    0x2f4(%eax),%eax
    40f8:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	int contSource = 1;
    40fb:	c7 45 f0 01 00 00 00 	movl   $0x1,0xfffffff0(%ebp)
	int caller = user_ctx ? 1 : 0; // DON'T REMOVE! Used when timing is enabled
    4102:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    4106:	0f 95 c0             	setne  %al
    4109:	0f b6 c0             	movzbl %al,%eax
    410c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	int numAcksSent = 0;
    410f:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)

	TIMING_CTX_DEF0("trickles_send_ack_impl", "kernel", "user");
	TIMING_CTX_DEF1(5,5);
	reinitTimingCtx(&ctx);
	recordSample(&ctx,caller);
	if(caller)  ; // force reference to caller in all compilation environments

#if 1
#define REACHED(LABEL)
#else
#define REACHED(LABEL)						\
	if(IS_RECOVERY_STATE()) {				\
		printk("trickles_send_ack " #LABEL " - seq = %d\n", cont != NULL ? cont->seq : -1); \
	}
#endif

	if(cont == NULL) {
    4116:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
    411a:	75 12                	jne    412e <trickles_send_ack_impl+0x57>
		contSource = 0;
    411c:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
		cont = (CONTINUATION_TYPE *)&tp->t.cont_list;
    4123:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4126:	05 34 09 00 00       	add    $0x934,%eax
    412b:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    412e:	90                   	nop    
		REACHED(cont_list);
	}
	REACHED(top);

	while(1) {
		int is_curr = 0;
    412f:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
		num_iterations++;
    4136:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
    4139:	ff 00                	incl   (%eax)

		recordSample(&ctx,caller);
		cont = cont->next;
    413b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    413e:	8b 40 04             	mov    0x4(%eax),%eax
    4141:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		/* Send ack */
		if(cont == NULL) {
    4144:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
    4148:	75 36                	jne    4180 <trickles_send_ack_impl+0xa9>
			printk("trickles_send_ack_impl: cont == NULL\n");
    414a:	c7 04 24 00 1b 00 00 	movl   $0x1b00,(%esp,1)
    4151:	e8 fc ff ff ff       	call   4152 <trickles_send_ack_impl+0x7b>
			BUG();
    4156:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    415d:	00 
    415e:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    4165:	e8 fc ff ff ff       	call   4166 <trickles_send_ack_impl+0x8f>
    416a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    4171:	e8 fc ff ff ff       	call   4172 <trickles_send_ack_impl+0x9b>
    4176:	e8 fc ff ff ff       	call   4177 <trickles_send_ack_impl+0xa0>
			goto out;
    417b:	e9 5c 02 00 00       	jmp    43dc <trickles_send_ack_impl+0x305>
		}
		REACHED(1);

		if(cont == (CONTINUATION_TYPE*)&tp->t.cont_list ||
    4180:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4183:	05 34 09 00 00       	add    $0x934,%eax
    4188:	39 45 f4             	cmp    %eax,0xfffffff4(%ebp)
    418b:	74 13                	je     41a0 <trickles_send_ack_impl+0xc9>
    418d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    4190:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    4193:	8b 40 30             	mov    0x30(%eax),%eax
    4196:	3b 82 f8 02 00 00    	cmp    0x2f8(%edx),%eax
    419c:	73 02                	jae    41a0 <trickles_send_ack_impl+0xc9>
    419e:	eb 34                	jmp    41d4 <trickles_send_ack_impl+0xfd>
		   cont->seq >= tp->t.ack_last) {
			/* advanced too far; don't update */
			if(is_curr) BUG();
    41a0:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
    41a4:	0f 84 32 02 00 00    	je     43dc <trickles_send_ack_impl+0x305>
    41aa:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    41b1:	00 
    41b2:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    41b9:	e8 fc ff ff ff       	call   41ba <trickles_send_ack_impl+0xe3>
    41be:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    41c5:	e8 fc ff ff ff       	call   41c6 <trickles_send_ack_impl+0xef>
    41ca:	e8 fc ff ff ff       	call   41cb <trickles_send_ack_impl+0xf4>
			goto out;
    41cf:	e9 08 02 00 00       	jmp    43dc <trickles_send_ack_impl+0x305>
		}
		REACHED(2);

		recordSample(&ctx,caller);

		if(!sendAckHelper(sk,cont,TREQ_NORMAL)) {
    41d4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    41db:	00 
    41dc:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    41df:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    41e3:	8b 45 08             	mov    0x8(%ebp),%eax
    41e6:	89 04 24             	mov    %eax,(%esp,1)
    41e9:	e8 f8 20 00 00       	call   62e6 <sendAckHelper>
    41ee:	85 c0                	test   %eax,%eax
    41f0:	75 05                	jne    41f7 <trickles_send_ack_impl+0x120>
			/* some error while transmitting ack */
			goto out;
    41f2:	e9 e5 01 00 00       	jmp    43dc <trickles_send_ack_impl+0x305>
		}
		REACHED(3);
		numAcksSent++;
    41f7:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
    41fa:	ff 00                	incl   (%eax)

		if(clientDebugLevel >= 2) {
    41fc:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    4203:	7e 1f                	jle    4224 <trickles_send_ack_impl+0x14d>
			if(cont->state == CONT_BOOTSTRAP) {
    4205:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    4208:	83 78 54 02          	cmpl   $0x2,0x54(%eax)
    420c:	75 16                	jne    4224 <trickles_send_ack_impl+0x14d>
				printk("bootstrap ack: %u\n", cont->seq);
    420e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    4211:	8b 40 30             	mov    0x30(%eax),%eax
    4214:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    4218:	c7 04 24 26 1b 00 00 	movl   $0x1b26,(%esp,1)
    421f:	e8 fc ff ff ff       	call   4220 <trickles_send_ack_impl+0x149>
			}
		}

		recordSample(&ctx,caller);
		tp->t.ack_prev = cont;
    4224:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4227:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    422a:	89 90 f4 02 00 00    	mov    %edx,0x2f4(%eax)
		INTEGRITY_CHECK(sk, tp->t.ack_prev);
		SAVE_ACK_PREV(tp);
		if(!(!tp->t.ack_prev || tp->t.ack_prev->next)) {
    4230:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4233:	83 b8 f4 02 00 00 00 	cmpl   $0x0,0x2f4(%eax)
    423a:	74 63                	je     429f <trickles_send_ack_impl+0x1c8>
    423c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    423f:	8b 80 f4 02 00 00    	mov    0x2f4(%eax),%eax
    4245:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
    4249:	75 54                	jne    429f <trickles_send_ack_impl+0x1c8>
			// 0429
			BUG_TRAP(!tp->t.ack_prev || tp->t.ack_prev->next);
    424b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    424e:	83 b8 f4 02 00 00 00 	cmpl   $0x0,0x2f4(%eax)
    4255:	74 23                	je     427a <trickles_send_ack_impl+0x1a3>
    4257:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    425a:	8b 80 f4 02 00 00    	mov    0x2f4(%eax),%eax
    4260:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
    4264:	75 14                	jne    427a <trickles_send_ack_impl+0x1a3>
    4266:	c7 44 24 04 44 0b 00 	movl   $0xb44,0x4(%esp,1)
    426d:	00 
    426e:	c7 04 24 40 1b 00 00 	movl   $0x1b40,(%esp,1)
    4275:	e8 fc ff ff ff       	call   4276 <trickles_send_ack_impl+0x19f>
			BUG();
    427a:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    4281:	00 
    4282:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    4289:	e8 fc ff ff ff       	call   428a <trickles_send_ack_impl+0x1b3>
    428e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    4295:	e8 fc ff ff ff       	call   4296 <trickles_send_ack_impl+0x1bf>
    429a:	e8 fc ff ff ff       	call   429b <trickles_send_ack_impl+0x1c4>
		}

		if(tp->t.state == TRICKLES_CLIENT_NORMAL) {
    429f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    42a2:	83 b8 cc 02 00 00 01 	cmpl   $0x1,0x2cc(%eax)
    42a9:	0f 85 1f 01 00 00    	jne    43ce <trickles_send_ack_impl+0x2f7>
			CONTINUATION_TYPE *clean = (CONTINUATION_TYPE*)tp->t.cont_list.next;
    42af:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    42b2:	8b 80 38 09 00 00    	mov    0x938(%eax),%eax
    42b8:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
			REACHED(4);
			while(clean != (CONTINUATION_TYPE*)&tp->t.cont_list) {
    42bb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    42be:	05 34 09 00 00       	add    $0x934,%eax
    42c3:	39 45 e0             	cmp    %eax,0xffffffe0(%ebp)
    42c6:	75 05                	jne    42cd <trickles_send_ack_impl+0x1f6>
    42c8:	e9 01 01 00 00       	jmp    43ce <trickles_send_ack_impl+0x2f7>
				CONTINUATION_TYPE *prev = clean;
    42cd:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    42d0:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
				clean = clean->next;
    42d3:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    42d6:	8b 40 04             	mov    0x4(%eax),%eax
    42d9:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
				// XXX  0429 hash compress changes needed
				REACHED(5);
				if(
    42dc:	8b 4d dc             	mov    0xffffffdc(%ebp),%ecx
    42df:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    42e2:	8b 90 f4 02 00 00    	mov    0x2f4(%eax),%edx
    42e8:	8b 41 30             	mov    0x30(%ecx),%eax
    42eb:	3b 42 30             	cmp    0x30(%edx),%eax
    42ee:	0f 83 da 00 00 00    	jae    43ce <trickles_send_ack_impl+0x2f7>
    42f4:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    42f7:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    42fa:	8b 40 30             	mov    0x30(%eax),%eax
    42fd:	3b 82 e0 02 00 00    	cmp    0x2e0(%edx),%eax
    4303:	0f 83 c5 00 00 00    	jae    43ce <trickles_send_ack_impl+0x2f7>
#ifdef ENABLE_HASHCOMPRESS
				   prev->numChildrenReceived < prev->numTransportChildren ||
#endif
				   prev->seq >= tp->t.ack_prev->seq ||
				   prev->seq >= tp->t.rcv_nxt /* ||
								 prev->seq >= tp->t.previous_base */) {
#if 0
					printk("skipped continued deallocation (list len = %d): prev->seq (%d) >= tp->t.ack_prev->seq (%d), prev->seq (%d) >= tp->t.rcv_nxt (%d)\n",
					       tp->t.cont_list.len,
					       prev->seq, tp->t.ack_prev->seq,
					       prev->seq, tp->t.rcv_nxt);
#endif
					REACHED(6);
					break;
				}
				REACHED(7);
				BUG_TRAP(prev != tp->t.ack_prev);
    4309:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    430c:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    430f:	3b 82 f4 02 00 00    	cmp    0x2f4(%edx),%eax
    4315:	75 14                	jne    432b <trickles_send_ack_impl+0x254>
    4317:	c7 44 24 04 61 0b 00 	movl   $0xb61,0x4(%esp,1)
    431e:	00 
    431f:	c7 04 24 a0 1b 00 00 	movl   $0x1ba0,(%esp,1)
    4326:	e8 fc ff ff ff       	call   4327 <trickles_send_ack_impl+0x250>
				BUG_TRAP(prev != cont);
    432b:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    432e:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
    4331:	75 14                	jne    4347 <trickles_send_ack_impl+0x270>
    4333:	c7 44 24 04 62 0b 00 	movl   $0xb62,0x4(%esp,1)
    433a:	00 
    433b:	c7 04 24 00 1c 00 00 	movl   $0x1c00,(%esp,1)
    4342:	e8 fc ff ff ff       	call   4343 <trickles_send_ack_impl+0x26c>
				unlinkCont(prev);
    4347:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    434a:	89 04 24             	mov    %eax,(%esp,1)
    434d:	e8 c7 68 00 00       	call   ac19 <unlinkCont>
				MARK_PC(prev);
				if(tp->t.ack_prev == prev) {
    4352:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4355:	8b 80 f4 02 00 00    	mov    0x2f4(%eax),%eax
    435b:	3b 45 dc             	cmp    0xffffffdc(%ebp),%eax
    435e:	75 25                	jne    4385 <trickles_send_ack_impl+0x2ae>
					BUG();
    4360:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    4367:	00 
    4368:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    436f:	e8 fc ff ff ff       	call   4370 <trickles_send_ack_impl+0x299>
    4374:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    437b:	e8 fc ff ff ff       	call   437c <trickles_send_ack_impl+0x2a5>
    4380:	e8 fc ff ff ff       	call   4381 <trickles_send_ack_impl+0x2aa>
				}
				if(clientDebugLevel >= 2) {
    4385:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    438c:	7e 30                	jle    43be <trickles_send_ack_impl+0x2e7>
					printk("freeing %d, rcv_nxt=%d, previous_base = %d\n", prev->seq, tp->t.rcv_nxt, tp->t.previous_base);
    438e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4391:	8b 80 e4 02 00 00    	mov    0x2e4(%eax),%eax
    4397:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    439b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    439e:	8b 80 e0 02 00 00    	mov    0x2e0(%eax),%eax
    43a4:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    43a8:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    43ab:	8b 40 30             	mov    0x30(%eax),%eax
    43ae:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    43b2:	c7 04 24 40 1c 00 00 	movl   $0x1c40,(%esp,1)
    43b9:	e8 fc ff ff ff       	call   43ba <trickles_send_ack_impl+0x2e3>
				}
				freeClientSide_Continuation(prev);
    43be:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    43c1:	89 04 24             	mov    %eax,(%esp,1)
    43c4:	e8 66 5c 00 00       	call   a02f <freeClientSide_Continuation>
    43c9:	e9 ed fe ff ff       	jmp    42bb <trickles_send_ack_impl+0x1e4>
			}
		}
		REACHED(8);
		tp->t.in_flight++;
    43ce:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    43d1:	ff 80 00 03 00 00    	incl   0x300(%eax)
    43d7:	e9 53 fd ff ff       	jmp    412f <trickles_send_ack_impl+0x58>
		recordSample(&ctx,caller);
		//printTimings(&ctx);
	}
 out:
	return numAcksSent;
    43dc:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
	//printTimings(&ctx);

#undef REACHED
}
    43df:	c9                   	leave  
    43e0:	c3                   	ret    

000043e1 <user_ack_impl>:

void user_ack_impl(struct sock *sk) {
    43e1:	55                   	push   %ebp
    43e2:	89 e5                	mov    %esp,%ebp
    43e4:	83 ec 18             	sub    $0x18,%esp
	/* Wrapper for trickles_send_ack_impl */
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    43e7:	8b 45 08             	mov    0x8(%ebp),%eax
    43ea:	05 bc 00 00 00       	add    $0xbc,%eax
    43ef:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

	BUG_TRAP(in_softirq());
    43f2:	83 3d 08 00 00 00 00 	cmpl   $0x0,0x8
    43f9:	75 14                	jne    440f <user_ack_impl+0x2e>
    43fb:	c7 44 24 04 7e 0b 00 	movl   $0xb7e,0x4(%esp,1)
    4402:	00 
    4403:	c7 04 24 80 1c 00 00 	movl   $0x1c80,(%esp,1)
    440a:	e8 fc ff ff ff       	call   440b <user_ack_impl+0x2a>


	tp->t.timerState |= TRICKLES_ENABLE_DATA_TIMEOUT;
    440f:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    4412:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    4415:	8b 80 dc 02 00 00    	mov    0x2dc(%eax),%eax
    441b:	83 c8 01             	or     $0x1,%eax
    441e:	89 82 dc 02 00 00    	mov    %eax,0x2dc(%edx)
	if((tp->t.timerState & TRICKLES_NEED_SLOWSTART)) {
    4424:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    4427:	8b 80 dc 02 00 00    	mov    0x2dc(%eax),%eax
    442d:	83 e0 02             	and    $0x2,%eax
    4430:	85 c0                	test   %eax,%eax
    4432:	74 49                	je     447d <user_ack_impl+0x9c>
		// slow start blocked by user
		enterRecoveryState(sk, 1);
    4434:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
    443b:	00 
    443c:	8b 45 08             	mov    0x8(%ebp),%eax
    443f:	89 04 24             	mov    %eax,(%esp,1)
    4442:	e8 70 d3 ff ff       	call   17b7 <enterRecoveryState>

		if(clientDebugLevel >= 2)
    4447:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    444e:	7e 20                	jle    4470 <user_ack_impl+0x8f>
			printk("user_ack_impl requestslowstart %p state = %d\n", sk, tp->t.timerState);
    4450:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    4453:	8b 80 dc 02 00 00    	mov    0x2dc(%eax),%eax
    4459:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    445d:	8b 45 08             	mov    0x8(%ebp),%eax
    4460:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    4464:	c7 04 24 c0 1c 00 00 	movl   $0x1cc0,(%esp,1)
    446b:	e8 fc ff ff ff       	call   446c <user_ack_impl+0x8b>
		requestSlowStart(sk);
    4470:	8b 45 08             	mov    0x8(%ebp),%eax
    4473:	89 04 24             	mov    %eax,(%esp,1)
    4476:	e8 04 36 00 00       	call   7a7f <requestSlowStart>
    447b:	eb 5f                	jmp    44dc <user_ack_impl+0xfb>
	} else if(NEED_USERACK(sk)) {
    447d:	8b 45 08             	mov    0x8(%ebp),%eax
    4480:	8b 80 98 03 00 00    	mov    0x398(%eax),%eax
    4486:	83 e0 04             	and    $0x4,%eax
    4489:	85 c0                	test   %eax,%eax
    448b:	74 4f                	je     44dc <user_ack_impl+0xfb>
		local_bh_disable();
    448d:	ff 05 08 00 00 00    	incl   0x8
		//printk("pre user triggering sendackimpl = %d,%d\n", tp->t.ack_last, tp->t.rcv_nxt);
		int numAcks = trickles_send_ack_impl(sk, 1);
    4493:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
    449a:	00 
    449b:	8b 45 08             	mov    0x8(%ebp),%eax
    449e:	89 04 24             	mov    %eax,(%esp,1)
    44a1:	e8 fc ff ff ff       	call   44a2 <user_ack_impl+0xc1>
    44a6:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
		//printk("user triggering sendackimpl = %d,%d,%d\n", numAcks, tp->t.ack_last, tp->t.rcv_nxt);
		if(numAcks > 0) {
			LOG_PACKET_USERUNBLOCKEVENT(NULL);
		} else {
			LOG_PACKET_USERBADUNBLOCKEVENT(NULL);
			//printk("badunblock\n");
		}
		tp->t.timerState &= ~TRICKLES_NEED_USERACK;
    44a9:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    44ac:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    44af:	8b 80 dc 02 00 00    	mov    0x2dc(%eax),%eax
    44b5:	83 e0 fb             	and    $0xfffffffb,%eax
    44b8:	89 82 dc 02 00 00    	mov    %eax,0x2dc(%edx)
		local_bh_enable();
    44be:	c7 45 f4 08 00 00 00 	movl   $0x8,0xfffffff4(%ebp)
    44c5:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    44c8:	ff 08                	decl   (%eax)
    44ca:	83 38 00             	cmpl   $0x0,(%eax)
    44cd:	75 0d                	jne    44dc <user_ack_impl+0xfb>
    44cf:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    44d2:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
    44d6:	0f 85 86 81 00 00    	jne    c662 <.text.lock.tmalloc+0x10>
	}
	resetClientTimer(sk);
    44dc:	8b 45 08             	mov    0x8(%ebp),%eax
    44df:	89 04 24             	mov    %eax,(%esp,1)
    44e2:	e8 fc ff ff ff       	call   44e3 <user_ack_impl+0x102>
}
    44e7:	c9                   	leave  
    44e8:	c3                   	ret    

000044e9 <trickles_fin>:

void tcp_data_queue(struct sock *sk, struct sk_buff *skb);
#ifndef USERTEST
void trickles_fin(struct sock *sk) {
    44e9:	55                   	push   %ebp
    44ea:	89 e5                	mov    %esp,%ebp
    44ec:	83 ec 0c             	sub    $0xc,%esp
	// based on tcp_fin()
	sk->shutdown |= RCV_SHUTDOWN;
    44ef:	8b 55 08             	mov    0x8(%ebp),%edx
    44f2:	8b 45 08             	mov    0x8(%ebp),%eax
    44f5:	0f b6 40 27          	movzbl 0x27(%eax),%eax
    44f9:	0c 01                	or     $0x1,%al
    44fb:	88 42 27             	mov    %al,0x27(%edx)
	sk->done = 0;
    44fe:	8b 45 08             	mov    0x8(%ebp),%eax
    4501:	c6 80 81 00 00 00 00 	movb   $0x0,0x81(%eax)
	sk->err = EPIPE;
    4508:	8b 45 08             	mov    0x8(%ebp),%eax
    450b:	c7 80 48 0b 00 00 20 	movl   $0x20,0xb48(%eax)
    4512:	00 00 00 
	tcp_set_state(sk, TCP_CLOSE);
    4515:	c7 44 24 04 07 00 00 	movl   $0x7,0x4(%esp,1)
    451c:	00 
    451d:	8b 45 08             	mov    0x8(%ebp),%eax
    4520:	89 04 24             	mov    %eax,(%esp,1)
    4523:	e8 8b 4f 00 00       	call   94b3 <tcp_set_state>

	sk->state_change(sk);
    4528:	8b 55 08             	mov    0x8(%ebp),%edx
    452b:	8b 45 08             	mov    0x8(%ebp),%eax
    452e:	89 04 24             	mov    %eax,(%esp,1)
    4531:	8b 82 d0 0b 00 00    	mov    0xbd0(%edx),%eax
    4537:	ff d0                	call   *%eax
	/* Do not send POLL_HUP for half duplex close. */
	if (sk->shutdown == SHUTDOWN_MASK || sk->state == TCP_CLOSE)
    4539:	8b 45 08             	mov    0x8(%ebp),%eax
    453c:	80 78 27 03          	cmpb   $0x3,0x27(%eax)
    4540:	74 0d                	je     454f <trickles_fin+0x66>
    4542:	8b 45 08             	mov    0x8(%ebp),%eax
    4545:	0f b6 40 20          	movzbl 0x20(%eax),%eax
    4549:	3c 07                	cmp    $0x7,%al
    454b:	74 02                	je     454f <trickles_fin+0x66>
    454d:	eb 1d                	jmp    456c <trickles_fin+0x83>
		sk_wake_async(sk, 1, POLL_HUP);
    454f:	c7 44 24 08 06 00 02 	movl   $0x20006,0x8(%esp,1)
    4556:	00 
    4557:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
    455e:	00 
    455f:	8b 45 08             	mov    0x8(%ebp),%eax
    4562:	89 04 24             	mov    %eax,(%esp,1)
    4565:	e8 93 4e 00 00       	call   93fd <sk_wake_async>
    456a:	eb 1b                	jmp    4587 <trickles_fin+0x9e>
	else
		sk_wake_async(sk, 1, POLL_IN);
    456c:	c7 44 24 08 01 00 02 	movl   $0x20001,0x8(%esp,1)
    4573:	00 
    4574:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
    457b:	00 
    457c:	8b 45 08             	mov    0x8(%ebp),%eax
    457f:	89 04 24             	mov    %eax,(%esp,1)
    4582:	e8 76 4e 00 00       	call   93fd <sk_wake_async>
}
    4587:	c9                   	leave  
    4588:	c3                   	ret    

00004589 <tcp_copy_to_iovec>:

/* begin functions copied from tcp_input.c */
static int tcp_copy_to_iovec(struct sock *sk, struct sk_buff *skb, int hlen)
{
    4589:	55                   	push   %ebp
    458a:	89 e5                	mov    %esp,%ebp
    458c:	83 ec 20             	sub    $0x20,%esp
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
    458f:	8b 45 08             	mov    0x8(%ebp),%eax
    4592:	05 bc 00 00 00       	add    $0xbc,%eax
    4597:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	int chunk = skb->len - hlen;
    459a:	8b 45 0c             	mov    0xc(%ebp),%eax
    459d:	8b 55 10             	mov    0x10(%ebp),%edx
    45a0:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    45a6:	29 d0                	sub    %edx,%eax
    45a8:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	int err;

	local_bh_enable();
    45ab:	c7 45 f0 08 00 00 00 	movl   $0x8,0xfffffff0(%ebp)
    45b2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    45b5:	ff 08                	decl   (%eax)
    45b7:	83 38 00             	cmpl   $0x0,(%eax)
    45ba:	75 0d                	jne    45c9 <tcp_copy_to_iovec+0x40>
    45bc:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    45bf:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
    45c3:	0f 85 a9 80 00 00    	jne    c672 <.text.lock.tmalloc+0x20>
	if (skb->ip_summed==CHECKSUM_UNNECESSARY)
    45c9:	8b 45 0c             	mov    0xc(%ebp),%eax
    45cc:	80 b8 a3 00 00 00 02 	cmpb   $0x2,0xa3(%eax)
    45d3:	75 28                	jne    45fd <tcp_copy_to_iovec+0x74>
		err = skb_copy_datagram_iovec(skb, hlen, tp->ucopy.iov, chunk);
    45d5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    45d8:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    45dc:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    45df:	8b 40 44             	mov    0x44(%eax),%eax
    45e2:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    45e6:	8b 45 10             	mov    0x10(%ebp),%eax
    45e9:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    45ed:	8b 45 0c             	mov    0xc(%ebp),%eax
    45f0:	89 04 24             	mov    %eax,(%esp,1)
    45f3:	e8 fc ff ff ff       	call   45f4 <tcp_copy_to_iovec+0x6b>
    45f8:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    45fb:	eb 1f                	jmp    461c <tcp_copy_to_iovec+0x93>
	else
		err = skb_copy_and_csum_datagram_iovec(skb, hlen, tp->ucopy.iov);
    45fd:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    4600:	8b 40 44             	mov    0x44(%eax),%eax
    4603:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    4607:	8b 45 10             	mov    0x10(%ebp),%eax
    460a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    460e:	8b 45 0c             	mov    0xc(%ebp),%eax
    4611:	89 04 24             	mov    %eax,(%esp,1)
    4614:	e8 fc ff ff ff       	call   4615 <tcp_copy_to_iovec+0x8c>
    4619:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

	if (!err) {
    461c:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
    4620:	75 26                	jne    4648 <tcp_copy_to_iovec+0xbf>
		tp->ucopy.len -= chunk;
    4622:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
    4625:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    4628:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    462b:	8b 40 4c             	mov    0x4c(%eax),%eax
    462e:	29 d0                	sub    %edx,%eax
    4630:	89 41 4c             	mov    %eax,0x4c(%ecx)
		tp->copied_seq += chunk;
    4633:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
    4636:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    4639:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    463c:	03 82 fc 00 00 00    	add    0xfc(%edx),%eax
    4642:	89 81 fc 00 00 00    	mov    %eax,0xfc(%ecx)
	}

	local_bh_disable();
    4648:	ff 05 08 00 00 00    	incl   0x8
	return err;
    464e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
}
    4651:	c9                   	leave  
    4652:	c3                   	ret    

00004653 <client_inseq>:

//#define SAVE_LAST_DATA_TIME
#ifdef SAVE_LAST_DATA_TIME
struct timeval last_data_time;
#endif // SAVE_LAST_DATA_TIME

static inline void tcp_fast_path_queue(struct sock *sk, struct sk_buff *skb) {
	// derived from fast path code in tcp_input.c
	int eaten = 0;
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	int len = skb->len;
	int direct_copy = tp->ucopy.task == current &&
	    tp->copied_seq == tp->rcv_nxt &&
	    len <= tp->ucopy.len &&
	    sk->lock.users;

	TIMING_CTX_DEF0("fast_path_queue", "not direct copy", "direct copy");
	TIMING_CTX_DEF1(3,3);
	reinitTimingCtx(&ctx);
	direct_copy = direct_copy ? 1 : 0;
	recordSample(&ctx,direct_copy);

	if(len == 0) goto skip;

	// 10/15 Linux tcp.c doesn't understand data on syn/ack. So we need to mask the fact that this packet was a syn. Ugly
	skb->h.th->syn = 0;
	if(!(tp->trickles_opt & TCP_TRICKLES_BUFFERDISCARD)) {
		if(TCP_SKB_CB(skb)->seq != tp->rcv_nxt) {
			printk("start sequence not at rcv nxt: %d %d\n", TCP_SKB_CB(skb)->seq, tp->rcv_nxt);
		}

		if (direct_copy) {
			printk("direct copy\n");
			__set_current_state(TASK_RUNNING);

			if (!tcp_copy_to_iovec(sk, skb, 0)) {
				tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq;
				NET_INC_STATS_BH(TCPHPHitsToUser);
				eaten = 1;
			}
		}
		recordSample(&ctx,direct_copy);
		if (!eaten) {
			NET_INC_STATS_BH(TCPHPHits);

			/* Bulk data transfer: receiver */

			if(TCP_SKB_CB(skb)->cont) {
				freeClientSide_Continuation(TCP_SKB_CB(skb)->cont);
				TCP_SKB_CB(skb)->cont = NULL;
			}
			__skb_queue_tail(&sk->receive_queue, skb);
			tcp_set_owner_r(skb, sk);
#if 0
			if(atomic_read(&skb_shinfo(skb)->dataref) > 2) {
				printk("skb to send to user had refcnt > 2\n");
			}
#endif
			tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq;
			// print out error if we exceed by more than 12.5%
			if(tp->rcv_nxt > (sk->rcvbuf + tp->copied_seq + (sk->rcvbuf >> 2))) {
				if(!disableSevereErrors)
					printk("exceeded constraint on rcvbuf by %d\n", tp->rcv_nxt - (sk->rcvbuf + tp->copied_seq));
			}
		}
	} else {
		// TCP_TRICKLES_BUFFERDISCARD
		gNumReceivedBytes += TCP_SKB_CB(skb)->end_seq - tp->rcv_nxt;
		tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq;
		SKBStat_update(&gReceivedSKBStat, skb, skb->data - skb->head);
		if(atomic_read(&skb->users) > 1) {
			printk("Buffer discarding %p, refcnt = %d\n", skb, atomic_read(&skb->users));
		}
		trickles_kfree_skb(skb);
	}

	if((int)tp->rcv_nxt < 0) {
		printk("rcv_nxt = %d\n", tp->rcv_nxt);
	}

#if 1 // 0810 advance byteReqNext in case we have pushed data
	// XXX Should the datarequestmap also be updated?
	if(tp->t.byteReqNext < tp->rcv_nxt) {
		tp->t.byteReqNext = tp->rcv_nxt;
	}
#endif
	recordSample(&ctx,direct_copy);
	sk_wake_async(sk, 0, POLL_IN);
	if(skb->h.th->fin) {
		trickles_fin(sk);
	}
	printTimings(&ctx);
 skip:
	if (eaten)
		trickles_kfree_skb(skb);
	else
		sk->data_ready(sk, 0);
#ifdef SAVE_LAST_DATA_TIME
        do_gettimeofday(&last_data_time);
#endif // SAVE_LAST_DATA_TIME
	return;
}
#endif // USERTEST

#if 0
#define TRICKLES_SKB_GENERIC(SUFFIX)					\
static struct sk_buff *trickles_skb_ ##SUFFIX (struct sk_buff *skb, int flags) { \
	struct sk_buff *newSkb = skb_##SUFFIX(skb, flags);			\
	if(newSkb == NULL) {						\
		return NULL;						\
	}								\
	TCP_SKB_CB(newSkb)->cont = copyClientSide_Continuation(TCP_SKB_CB(newSkb)->cont, GFP_ATOMIC); \
	if(TCP_SKB_CB(newSkb)->cont == NULL) {				\
		__kfree_skb(newSkb);					\
		return NULL;						\
	}								\
	return newSkb;							\
}

TRICKLES_SKB_GENERIC(copy);
TRICKLES_SKB_GENERIC(clone);
#endif

static inline int process_new_ucont(struct sock *sk, struct RequestOFOEntry *ofo_entry);

static inline void client_inseq(struct sock *sk, struct sk_buff *skb, int noCont) {
    4653:	55                   	push   %ebp
    4654:	89 e5                	mov    %esp,%ebp
    4656:	83 ec 34             	sub    $0x34,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    4659:	8b 45 08             	mov    0x8(%ebp),%eax
    465c:	05 bc 00 00 00       	add    $0xbc,%eax
    4661:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	CONTINUATION_TYPE *cont = TCP_SKB_CB(skb)->cont;
    4664:	8b 45 0c             	mov    0xc(%ebp),%eax
    4667:	83 c0 30             	add    $0x30,%eax
    466a:	8b 40 2c             	mov    0x2c(%eax),%eax
    466d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	TCP_SKB_CB(skb)->cont = NULL;
    4670:	8b 45 0c             	mov    0xc(%ebp),%eax
    4673:	83 c0 30             	add    $0x30,%eax
    4676:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
	unsigned transportSeq = cont->seq;
    467d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4680:	8b 40 30             	mov    0x30(%eax),%eax
    4683:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
#ifdef LAST_CHUNK
	int is_last_chunk = IS_LAST_CHUNK(skb);
	void *origSKB = skb;
#endif

	LOG_PACKET_INSEQEVENT(cont);

	// Perform state updates before queuing packet, for otherwise skb might disappear
	/* find matching continuation in ContList */
	if(!noCont) {
    4686:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    468a:	75 7b                	jne    4707 <client_inseq+0xb4>
		CONTINUATION_TYPE *cont;
		int found = 0;
    468c:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
		alloc_head_reverse_walk(&tp->t.cont_list, cont) {
    4693:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    4696:	05 34 09 00 00       	add    $0x934,%eax
    469b:	8b 00                	mov    (%eax),%eax
    469d:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    46a0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    46a3:	05 34 09 00 00       	add    $0x934,%eax
    46a8:	39 45 f0             	cmp    %eax,0xfffffff0(%ebp)
    46ab:	75 02                	jne    46af <client_inseq+0x5c>
    46ad:	eb 3d                	jmp    46ec <client_inseq+0x99>
			if(cont->seq == tp->t.rcv_nxt) {
    46af:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    46b2:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    46b5:	8b 40 30             	mov    0x30(%eax),%eax
    46b8:	3b 82 e0 02 00 00    	cmp    0x2e0(%edx),%eax
    46be:	75 22                	jne    46e2 <client_inseq+0x8f>
				found = 1;
    46c0:	c7 45 ec 01 00 00 00 	movl   $0x1,0xffffffec(%ebp)
				UpdateClientTransportState(sk, skb, cont);
    46c7:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    46ca:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    46ce:	8b 45 0c             	mov    0xc(%ebp),%eax
    46d1:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    46d5:	8b 45 08             	mov    0x8(%ebp),%eax
    46d8:	89 04 24             	mov    %eax,(%esp,1)
    46db:	e8 fc ff ff ff       	call   46dc <client_inseq+0x89>
#ifdef ENABLE_HASHCOMPRESS
				if(cont->parentMSK) {
					cont->parentMSK->numChildrenReceived++;
				}
#endif
				// cannot continue looping after performing update, since list may have changed
				break;
    46e0:	eb 0a                	jmp    46ec <client_inseq+0x99>
    46e2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    46e5:	8b 00                	mov    (%eax),%eax
    46e7:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    46ea:	eb b4                	jmp    46a0 <client_inseq+0x4d>
			}
		}
		if(!found) {
    46ec:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
    46f0:	75 15                	jne    4707 <client_inseq+0xb4>
			if(clientDebugLevel >= 2) {
    46f2:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    46f9:	7e 0c                	jle    4707 <client_inseq+0xb4>
				printk("client_inseq: could not find transport level continuation to use for state update\n");
    46fb:	c7 04 24 00 1d 00 00 	movl   $0x1d00,(%esp,1)
    4702:	e8 fc ff ff ff       	call   4703 <client_inseq+0xb0>
			}
		}
	}

	int may_contain_interesting_ucont =
    4707:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
    470e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4711:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
    4715:	7e 0c                	jle    4723 <client_inseq+0xd0>
    4717:	8b 45 0c             	mov    0xc(%ebp),%eax
    471a:	83 b8 94 00 00 00 00 	cmpl   $0x0,0x94(%eax)
    4721:	75 16                	jne    4739 <client_inseq+0xe6>
    4723:	8b 45 0c             	mov    0xc(%ebp),%eax
    4726:	83 c0 30             	add    $0x30,%eax
    4729:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    472c:	8b 40 50             	mov    0x50(%eax),%eax
    472f:	3b 82 5c 09 00 00    	cmp    0x95c(%edx),%eax
    4735:	73 02                	jae    4739 <client_inseq+0xe6>
    4737:	eb 07                	jmp    4740 <client_inseq+0xed>
    4739:	c7 45 e4 01 00 00 00 	movl   $0x1,0xffffffe4(%ebp)
    4740:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    4743:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	  (cont->ucont_len > 0 && skb->len > 0) ||
	   TCP_SKB_CB(skb)->parent >= tp->t.request_rcv_nxt;
	struct RequestOFOEntry *ofo_entry = NULL;
    4746:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
	if(may_contain_interesting_ucont) {
    474d:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
    4751:	0f 84 9b 00 00 00    	je     47f2 <client_inseq+0x19f>
		int isSynack = skb->h.th->syn && skb->h.th->ack;
    4757:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
    475e:	8b 45 0c             	mov    0xc(%ebp),%eax
    4761:	8b 40 20             	mov    0x20(%eax),%eax
    4764:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    4768:	24 02                	and    $0x2,%al
    476a:	84 c0                	test   %al,%al
    476c:	74 17                	je     4785 <client_inseq+0x132>
    476e:	8b 45 0c             	mov    0xc(%ebp),%eax
    4771:	8b 40 20             	mov    0x20(%eax),%eax
    4774:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    4778:	24 10                	and    $0x10,%al
    477a:	84 c0                	test   %al,%al
    477c:	74 07                	je     4785 <client_inseq+0x132>
    477e:	c7 45 e0 01 00 00 00 	movl   $0x1,0xffffffe0(%ebp)
    4785:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    4788:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
		ofo_entry =
    478b:	8b 45 0c             	mov    0xc(%ebp),%eax
    478e:	83 c0 30             	add    $0x30,%eax
    4791:	0f b6 40 55          	movzbl 0x55(%eax),%eax
    4795:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    4799:	8b 45 0c             	mov    0xc(%ebp),%eax
    479c:	83 c0 30             	add    $0x30,%eax
    479f:	0f b6 40 54          	movzbl 0x54(%eax),%eax
    47a3:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    47a7:	8b 45 0c             	mov    0xc(%ebp),%eax
    47aa:	83 c0 30             	add    $0x30,%eax
    47ad:	8b 40 50             	mov    0x50(%eax),%eax
    47b0:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    47b4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    47b7:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    47bb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    47be:	89 04 24             	mov    %eax,(%esp,1)
    47c1:	e8 95 50 00 00       	call   985b <RequestOFOEntry_new>
    47c6:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
			RequestOFOEntry_new(cont, isSynack,
					    TCP_SKB_CB(skb)->parent,
					    TCP_SKB_CB(skb)->numSiblings,
					    TCP_SKB_CB(skb)->position);
		cont = NULL;
    47c9:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
		if(ofo_entry == NULL) {
    47d0:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
    47d4:	75 1c                	jne    47f2 <client_inseq+0x19f>
			printk("RequestOFOEntry returned null, inseq exiting prematurely\n");
    47d6:	c7 04 24 60 1d 00 00 	movl   $0x1d60,(%esp,1)
    47dd:	e8 fc ff ff ff       	call   47de <client_inseq+0x18b>
			trickles_kfree_skb(skb);
    47e2:	8b 45 0c             	mov    0xc(%ebp),%eax
    47e5:	89 04 24             	mov    %eax,(%esp,1)
    47e8:	e8 b7 bc ff ff       	call   4a4 <trickles_kfree_skb>
			return;
    47ed:	e9 b0 00 00 00       	jmp    48a2 <client_inseq+0x24f>
		}
	}

	/* During retransmission, the association between transport
	   level sequence numbers and UC-level request numbers is
	   scrambled. Hence, client needs to perform a reordering on
	   UC requests */

	// 0810 was cont->ucont_len instead of tcp_cb->cont->ucont_len

	TCP_SKB_CB(skb)->dbg = __LINE__;
    47f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    47f5:	83 c0 30             	add    $0x30,%eax
    47f8:	c7 40 58 7c 0c 00 00 	movl   $0xc7c,0x58(%eax)

	if(try_queue_data(sk, skb) >= 0) {
    47ff:	c7 44 24 08 7e 0c 00 	movl   $0xc7e,0x8(%esp,1)
    4806:	00 
    4807:	8b 45 0c             	mov    0xc(%ebp),%eax
    480a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    480e:	8b 45 08             	mov    0x8(%ebp),%eax
    4811:	89 04 24             	mov    %eax,(%esp,1)
    4814:	e8 8b 00 00 00       	call   48a4 <try_queue_data_helper>
    4819:	85 c0                	test   %eax,%eax
    481b:	78 02                	js     481f <client_inseq+0x1cc>
    481d:	eb 31                	jmp    4850 <client_inseq+0x1fd>
		// DO NOTHING
#undef DROP_DATA_PACKET
	} else {
		// No data
		int overhead = skb->tail - skb->head;
    481f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    4822:	8b 45 0c             	mov    0xc(%ebp),%eax
    4825:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
    482b:	8b 81 bc 00 00 00    	mov    0xbc(%ecx),%eax
    4831:	29 d0                	sub    %edx,%eax
    4833:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
		//printk("%d: seq = %d\n", (int)jiffies, transportSeq);
		SKBStat_update(&gNoDataSKBStat, skb, overhead);
    4836:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    4839:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    483d:	8b 45 0c             	mov    0xc(%ebp),%eax
    4840:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    4844:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    484b:	e8 fc ff ff ff       	call   484c <client_inseq+0x1f9>
	}
	trickles_kfree_skb(skb);
    4850:	8b 45 0c             	mov    0xc(%ebp),%eax
    4853:	89 04 24             	mov    %eax,(%esp,1)
    4856:	e8 49 bc ff ff       	call   4a4 <trickles_kfree_skb>
	skb = NULL;
    485b:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)

	if(may_contain_interesting_ucont) {
    4862:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
    4866:	74 12                	je     487a <client_inseq+0x227>
		process_new_ucont(sk, ofo_entry);
    4868:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    486b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    486f:	8b 45 08             	mov    0x8(%ebp),%eax
    4872:	89 04 24             	mov    %eax,(%esp,1)
    4875:	e8 02 0c 00 00       	call   547c <process_new_ucont>
	}
	//}
	goto done_processing; // suppress warning
 done_processing:
	/* Clean out stuff just rendered obsolete */
#ifdef LAST_CHUNK
	if(is_last_chunk) {
		printk("removing obsolete data request maps\n");
		removeObsoleteDataRequestMaps(sk, transportSeq);  // moved out of data-only path, so that it executes unconditionally
	} else {
		printk("%p: not last chunk\n", origSKB);
	}
#else
	removeObsoleteDataRequestMaps(sk, transportSeq);  // moved out of data-only path, so that it executes unconditionally
    487a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    487d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    4881:	8b 45 08             	mov    0x8(%ebp),%eax
    4884:	89 04 24             	mov    %eax,(%esp,1)
    4887:	e8 db 6d 00 00       	call   b667 <removeObsoleteDataRequestMaps>
#endif
	removeObsoleteContinuations(sk);
    488c:	8b 45 08             	mov    0x8(%ebp),%eax
    488f:	89 04 24             	mov    %eax,(%esp,1)
    4892:	e8 fc ff ff ff       	call   4893 <client_inseq+0x240>
	removeObsoleteDependencies(sk);
    4897:	8b 45 08             	mov    0x8(%ebp),%eax
    489a:	89 04 24             	mov    %eax,(%esp,1)
    489d:	e8 fc ff ff ff       	call   489e <client_inseq+0x24b>
	return;
 drop:
	if(skb) {
		trickles_kfree_skb(skb);
	}
}
    48a2:	c9                   	leave  
    48a3:	c3                   	ret    

000048a4 <try_queue_data_helper>:

/*********************** Data management code *************************/
static inline int fragment_skb(struct sk_buff *in_skb);

static inline int try_queue_data_helper(struct sock *sk, struct sk_buff *outerSKB, int linenum) {
    48a4:	55                   	push   %ebp
    48a5:	89 e5                	mov    %esp,%ebp
    48a7:	53                   	push   %ebx
    48a8:	83 ec 38             	sub    $0x38,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    48ab:	8b 45 08             	mov    0x8(%ebp),%eax
    48ae:	05 bc 00 00 00       	add    $0xbc,%eax
    48b3:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	// XXX This function is way too big
	// Check for non-data chunk
	struct ResponseChunk *rchunk = (struct ResponseChunk *)outerSKB->data;
    48b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    48b9:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
    48bf:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	if(outerSKB->len == 0) {
    48c2:	8b 45 0c             	mov    0xc(%ebp),%eax
    48c5:	83 b8 94 00 00 00 00 	cmpl   $0x0,0x94(%eax)
    48cc:	75 0c                	jne    48da <try_queue_data_helper+0x36>
		//printk("%d: len == 0, rcv_nxt = %d, syn = %d ack = %d\n", (int)jiffies, tp->rcv_nxt, outerSKB->h.th->syn, outerSKB->h.th->ack);
		return -1;
    48ce:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,0xffffffd4(%ebp)
    48d5:	e9 9c 07 00 00       	jmp    5076 <try_queue_data_helper+0x7d2>
	}
	if(outerSKB->len < sizeof(*rchunk)) {
    48da:	8b 45 0c             	mov    0xc(%ebp),%eax
    48dd:	83 b8 94 00 00 00 02 	cmpl   $0x2,0x94(%eax)
    48e4:	77 0c                	ja     48f2 <try_queue_data_helper+0x4e>
		if(trickles_ratelimit()) {
			printk("try_queue_data: too short\n");
		}
		return -1;
    48e6:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,0xffffffd4(%ebp)
    48ed:	e9 84 07 00 00       	jmp    5076 <try_queue_data_helper+0x7d2>
	}
	if(!IS_VALID_CHUNKTYPE(rchunk->type)) {
    48f2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    48f5:	80 38 01             	cmpb   $0x1,(%eax)
    48f8:	74 14                	je     490e <try_queue_data_helper+0x6a>
    48fa:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    48fd:	80 38 02             	cmpb   $0x2,(%eax)
    4900:	74 0c                	je     490e <try_queue_data_helper+0x6a>
		if(trickles_ratelimit()) {
			printk("Invalid chunktype %d\n", rchunk->type);
		}
		return -1;
    4902:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,0xffffffd4(%ebp)
    4909:	e9 68 07 00 00       	jmp    5076 <try_queue_data_helper+0x7d2>
	}
	if(rchunk->type == RCHUNK_PUSH_HINT) {
    490e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    4911:	80 38 01             	cmpb   $0x1,(%eax)
    4914:	75 77                	jne    498d <try_queue_data_helper+0xe9>
		struct PushHintChunk *phchunk =
    4916:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    4919:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
			(struct PushHintChunk *) rchunk;
		int chunk_len = ntohs(phchunk->chunkLen);
    491c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    491f:	0f b7 40 01          	movzwl 0x1(%eax),%eax
    4923:	89 04 24             	mov    %eax,(%esp,1)
    4926:	e8 fc ff ff ff       	call   4927 <try_queue_data_helper+0x83>
    492b:	0f b7 c0             	movzwl %ax,%eax
    492e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
		//printk("Pulling %d", chunk_len);
		skb_pull(outerSKB, chunk_len);
    4931:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    4934:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    4938:	8b 45 0c             	mov    0xc(%ebp),%eax
    493b:	89 04 24             	mov    %eax,(%esp,1)
    493e:	e8 83 47 00 00       	call   90c6 <skb_pull>

		int start = ntohl(phchunk->start),
    4943:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    4946:	8b 40 07             	mov    0x7(%eax),%eax
    4949:	89 04 24             	mov    %eax,(%esp,1)
    494c:	e8 fc ff ff ff       	call   494d <try_queue_data_helper+0xa9>
    4951:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
			end = ntohl(phchunk->end);
    4954:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    4957:	8b 40 0b             	mov    0xb(%eax),%eax
    495a:	89 04 24             	mov    %eax,(%esp,1)
    495d:	e8 fc ff ff ff       	call   495e <try_queue_data_helper+0xba>
    4962:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
		//printk("Hint is [%d-%d]\n", start, end);
		if(start <= tp->t.byteReqNext && tp->t.byteReqNext < end) {
    4965:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    4968:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    496b:	3b 82 d4 09 00 00    	cmp    0x9d4(%edx),%eax
    4971:	77 1a                	ja     498d <try_queue_data_helper+0xe9>
    4973:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4976:	8b 80 d4 09 00 00    	mov    0x9d4(%eax),%eax
    497c:	3b 45 e4             	cmp    0xffffffe4(%ebp),%eax
    497f:	73 0c                	jae    498d <try_queue_data_helper+0xe9>
			//printk("Adjusting byteReqNext: %d => %d\n", tp->t.byteReqNext, end);
			tp->t.byteReqNext = end;
    4981:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    4984:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    4987:	89 82 d4 09 00 00    	mov    %eax,0x9d4(%edx)
		}
	}
	if(fragment_skb(outerSKB) > 0) {
    498d:	8b 45 0c             	mov    0xc(%ebp),%eax
    4990:	89 04 24             	mov    %eax,(%esp,1)
    4993:	e8 e7 06 00 00       	call   507f <fragment_skb>
    4998:	85 c0                	test   %eax,%eax
    499a:	0f 8e cf 06 00 00    	jle    506f <try_queue_data_helper+0x7cb>
		// Process all fragments
		int fragnum;

		int overhead = TCP_SKB_CB(outerSKB)->numDataChunks * sizeof(struct DataChunk) + outerSKB->data - outerSKB->head;
    49a0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    49a3:	8b 45 0c             	mov    0xc(%ebp),%eax
    49a6:	83 c0 30             	add    $0x30,%eax
    49a9:	8b 50 34             	mov    0x34(%eax),%edx
    49ac:	89 d0                	mov    %edx,%eax
    49ae:	c1 e0 02             	shl    $0x2,%eax
    49b1:	01 d0                	add    %edx,%eax
    49b3:	01 c0                	add    %eax,%eax
    49b5:	01 d0                	add    %edx,%eax
    49b7:	89 c2                	mov    %eax,%edx
    49b9:	03 91 b8 00 00 00    	add    0xb8(%ecx),%edx
    49bf:	8b 45 0c             	mov    0xc(%ebp),%eax
    49c2:	2b 90 b4 00 00 00    	sub    0xb4(%eax),%edx
    49c8:	89 d0                	mov    %edx,%eax
    49ca:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
		SKBStat_update(&gOuterSKBStat, outerSKB, overhead);
    49cd:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    49d0:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    49d4:	8b 45 0c             	mov    0xc(%ebp),%eax
    49d7:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    49db:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    49e2:	e8 fc ff ff ff       	call   49e3 <try_queue_data_helper+0x13f>

		for(fragnum = 0; fragnum < TCP_SKB_CB(outerSKB)->numDataChunks;
    49e7:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
    49ee:	8b 55 0c             	mov    0xc(%ebp),%edx
    49f1:	83 c2 30             	add    $0x30,%edx
    49f4:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    49f7:	3b 42 34             	cmp    0x34(%edx),%eax
    49fa:	7c 05                	jl     4a01 <try_queue_data_helper+0x15d>
    49fc:	e9 65 06 00 00       	jmp    5066 <try_queue_data_helper+0x7c2>
		    fragnum++) {
			struct sk_buff **pskb = GET_CHUNK(outerSKB, fragnum);
    4a01:	8b 45 0c             	mov    0xc(%ebp),%eax
    4a04:	83 c0 30             	add    $0x30,%eax
    4a07:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    4a0a:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
    4a0e:	78 08                	js     4a18 <try_queue_data_helper+0x174>
    4a10:	83 7d e4 31          	cmpl   $0x31,0xffffffe4(%ebp)
    4a14:	7f 02                	jg     4a18 <try_queue_data_helper+0x174>
    4a16:	eb 25                	jmp    4a3d <try_queue_data_helper+0x199>
    4a18:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    4a1f:	00 
    4a20:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    4a27:	e8 fc ff ff ff       	call   4a28 <try_queue_data_helper+0x184>
    4a2c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    4a33:	e8 fc ff ff ff       	call   4a34 <try_queue_data_helper+0x190>
    4a38:	e8 fc ff ff ff       	call   4a39 <try_queue_data_helper+0x195>
    4a3d:	83 7d e4 04          	cmpl   $0x4,0xffffffe4(%ebp)
    4a41:	7f 11                	jg     4a54 <try_queue_data_helper+0x1b0>
    4a43:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    4a46:	c1 e0 02             	shl    $0x2,%eax
    4a49:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    4a4c:	83 c0 38             	add    $0x38,%eax
    4a4f:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    4a52:	eb 6d                	jmp    4ac1 <try_queue_data_helper+0x21d>
    4a54:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    4a57:	83 78 4c 00          	cmpl   $0x0,0x4c(%eax)
    4a5b:	75 52                	jne    4aaf <try_queue_data_helper+0x20b>
    4a5d:	c7 45 dc 2d 00 00 00 	movl   $0x2d,0xffffffdc(%ebp)
    4a64:	8b 5d e0             	mov    0xffffffe0(%ebp),%ebx
    4a67:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    4a6e:	00 
    4a6f:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    4a72:	c1 e0 02             	shl    $0x2,%eax
    4a75:	89 04 24             	mov    %eax,(%esp,1)
    4a78:	e8 fc ff ff ff       	call   4a79 <try_queue_data_helper+0x1d5>
    4a7d:	89 43 4c             	mov    %eax,0x4c(%ebx)
    4a80:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
    4a87:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4a8a:	3b 45 dc             	cmp    0xffffffdc(%ebp),%eax
    4a8d:	7c 02                	jl     4a91 <try_queue_data_helper+0x1ed>
    4a8f:	eb 1e                	jmp    4aaf <try_queue_data_helper+0x20b>
    4a91:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
    4a94:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4a97:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4a9e:	8b 41 4c             	mov    0x4c(%ecx),%eax
    4aa1:	c7 04 10 00 00 00 00 	movl   $0x0,(%eax,%edx,1)
    4aa8:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
    4aab:	ff 00                	incl   (%eax)
    4aad:	eb d8                	jmp    4a87 <try_queue_data_helper+0x1e3>
    4aaf:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    4ab2:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    4ab5:	c1 e0 02             	shl    $0x2,%eax
    4ab8:	03 42 4c             	add    0x4c(%edx),%eax
    4abb:	83 e8 14             	sub    $0x14,%eax
    4abe:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    4ac1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    4ac4:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
			struct sk_buff *skb = *pskb;
    4ac7:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    4aca:	8b 00                	mov    (%eax),%eax
    4acc:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
			*pskb = NULL;
    4acf:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    4ad2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#if 0
			printk("Frag[%d/%d]= [%d,%d]\n", fragnum,
			       TCP_SKB_CB(skb)->numDataChunks,
			       TCP_SKB_CB(skb)->byteNum,
			       TCP_SKB_CB(skb)->byteNum + skb->len);
#endif

#if 0 // 0901 -- after factoring out thies functino, this sanity check can no longer be performed
			if(!(IMPLIES(tp->t.ack_prev != NULL, tp->t.ack_prev != cont))) {
				BUG_TRAP(IMPLIES(tp->t.ack_prev != NULL, tp->t.ack_prev != cont));
				printk("tp->t.ack_prev->list = %p\n", tp->t.ack_prev->list);
			}
			MARK_PC(cont);
#endif

			if(skb->len == 0) {
    4ad8:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4adb:	83 b8 94 00 00 00 00 	cmpl   $0x0,0x94(%eax)
    4ae2:	75 11                	jne    4af5 <try_queue_data_helper+0x251>
				printk("skb == 0\n");
    4ae4:	c7 04 24 9a 1d 00 00 	movl   $0x1d9a,(%esp,1)
    4aeb:	e8 fc ff ff ff       	call   4aec <try_queue_data_helper+0x248>
				goto bad_packet;
    4af0:	e9 7a 05 00 00       	jmp    506f <try_queue_data_helper+0x7cb>
			}

			if(TCP_SKB_CB(skb)->byteNum > tp->rcv_nxt) {
    4af5:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4af8:	83 c0 30             	add    $0x30,%eax
    4afb:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    4afe:	8b 40 30             	mov    0x30(%eax),%eax
    4b01:	3b 42 08             	cmp    0x8(%edx),%eax
    4b04:	0f 86 54 02 00 00    	jbe    4d5e <try_queue_data_helper+0x4ba>
				struct sk_buff *finger, *next;
				/*
				  Enqueue in ofo queue
				*/
				TCP_SKB_CB(skb)->seq = TCP_SKB_CB(skb)->byteNum;
    4b0a:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    4b0d:	83 c2 30             	add    $0x30,%edx
    4b10:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4b13:	83 c0 30             	add    $0x30,%eax
    4b16:	8b 40 30             	mov    0x30(%eax),%eax
    4b19:	89 42 10             	mov    %eax,0x10(%edx)
				TCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(skb)->seq + skb->len;
    4b1c:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
    4b1f:	83 c1 30             	add    $0x30,%ecx
    4b22:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    4b25:	83 c2 30             	add    $0x30,%edx
    4b28:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4b2b:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    4b31:	03 42 10             	add    0x10(%edx),%eax
    4b34:	89 41 14             	mov    %eax,0x14(%ecx)
				//printk("end_seq = %d\n", TCP_SKB_CB(skb)->end_seq);
				if(skb_peek(&tp->t.data_ofo_queue)) {
    4b37:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4b3a:	05 78 09 00 00       	add    $0x978,%eax
    4b3f:	89 04 24             	mov    %eax,(%esp,1)
    4b42:	e8 86 42 00 00       	call   8dcd <skb_peek>
    4b47:	85 c0                	test   %eax,%eax
    4b49:	74 39                	je     4b84 <try_queue_data_helper+0x2e0>
					finger = tp->t.data_ofo_queue.prev;
    4b4b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4b4e:	8b 80 7c 09 00 00    	mov    0x97c(%eax),%eax
    4b54:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
					/* eliminate overlap later, when using elements from ofo queue */
					do {

						if(TCP_SKB_CB(finger)->seq < TCP_SKB_CB(skb)->seq)
    4b57:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    4b5a:	83 c0 30             	add    $0x30,%eax
    4b5d:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    4b60:	83 c2 30             	add    $0x30,%edx
    4b63:	8b 40 10             	mov    0x10(%eax),%eax
    4b66:	3b 42 10             	cmp    0x10(%edx),%eax
    4b69:	73 02                	jae    4b6d <try_queue_data_helper+0x2c9>
							break;
    4b6b:	eb 22                	jmp    4b8f <try_queue_data_helper+0x2eb>
					} while((struct sk_buff_head*)(finger=finger->prev) != &tp->t.data_ofo_queue);
    4b6d:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    4b70:	8b 50 04             	mov    0x4(%eax),%edx
    4b73:	89 55 dc             	mov    %edx,0xffffffdc(%ebp)
    4b76:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4b79:	05 78 09 00 00       	add    $0x978,%eax
    4b7e:	39 c2                	cmp    %eax,%edx
    4b80:	75 d5                	jne    4b57 <try_queue_data_helper+0x2b3>
    4b82:	eb 0b                	jmp    4b8f <try_queue_data_helper+0x2eb>
				} else {
					finger = (struct sk_buff *)&tp->t.data_ofo_queue;
    4b84:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4b87:	05 78 09 00 00       	add    $0x978,%eax
    4b8c:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
				}
				next = finger->next;
    4b8f:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    4b92:	8b 00                	mov    (%eax),%eax
    4b94:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
				if(finger != (struct sk_buff*)&tp->t.data_ofo_queue) {
    4b97:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4b9a:	05 78 09 00 00       	add    $0x978,%eax
    4b9f:	39 45 dc             	cmp    %eax,0xffffffdc(%ebp)
    4ba2:	0f 84 a5 00 00 00    	je     4c4d <try_queue_data_helper+0x3a9>
					int slack = TCP_SKB_CB(finger)->end_seq - TCP_SKB_CB(skb)->seq;
    4ba8:	8b 4d dc             	mov    0xffffffdc(%ebp),%ecx
    4bab:	83 c1 30             	add    $0x30,%ecx
    4bae:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4bb1:	83 c0 30             	add    $0x30,%eax
    4bb4:	8b 50 10             	mov    0x10(%eax),%edx
    4bb7:	8b 41 14             	mov    0x14(%ecx),%eax
    4bba:	29 d0                	sub    %edx,%eax
    4bbc:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
					if(slack > 0) {
    4bbf:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
    4bc3:	0f 8e 84 00 00 00    	jle    4c4d <try_queue_data_helper+0x3a9>
						if(slack >= skb->len) {
    4bc9:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    4bcc:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    4bcf:	3b 82 94 00 00 00    	cmp    0x94(%edx),%eax
    4bd5:	72 36                	jb     4c0d <try_queue_data_helper+0x369>
							RECORD_OVERLAP(0, skb->len);
    4bd7:	ff 05 00 00 00 00    	incl   0x0
    4bdd:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4be0:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    4be6:	01 05 04 00 00 00    	add    %eax,0x4
    4bec:	c7 05 08 00 00 00 03 	movl   $0xd03,0x8
    4bf3:	0d 00 00 
							// completely covered by old packet
							trickles_kfree_skb(skb);
    4bf6:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4bf9:	89 04 24             	mov    %eax,(%esp,1)
    4bfc:	e8 a3 b8 ff ff       	call   4a4 <trickles_kfree_skb>
							skb = NULL;
    4c01:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
							// 0717 Trying to increase efficiency
							if(0 && trickles_ratelimit()) {
								printk("New packet completely covered by old packet\n");
							}
							goto skip_ofo_insert;
    4c08:	e9 4f 04 00 00       	jmp    505c <try_queue_data_helper+0x7b8>
						} else {
							RECORD_OVERLAP(1, slack);
    4c0d:	ff 05 0c 00 00 00    	incl   0xc
    4c13:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    4c16:	01 05 10 00 00 00    	add    %eax,0x10
    4c1c:	c7 05 14 00 00 00 0d 	movl   $0xd0d,0x14
    4c23:	0d 00 00 
							skb_pull(skb, slack);
    4c26:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    4c29:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    4c2d:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4c30:	89 04 24             	mov    %eax,(%esp,1)
    4c33:	e8 8e 44 00 00       	call   90c6 <skb_pull>
							TCP_SKB_CB(skb)->seq += slack;
    4c38:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
    4c3b:	83 c1 30             	add    $0x30,%ecx
    4c3e:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    4c41:	83 c2 30             	add    $0x30,%edx
    4c44:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    4c47:	03 42 10             	add    0x10(%edx),%eax
    4c4a:	89 41 10             	mov    %eax,0x10(%ecx)
							// 0717 Trying to increase efficiency
							if(0 && trickles_ratelimit()) {
								printk("New packet overlapped old packet by %d\n", slack);
							}
						}
					}
				}
				if(next != (struct sk_buff*)&tp->t.data_ofo_queue) {
    4c4d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4c50:	05 78 09 00 00       	add    $0x978,%eax
    4c55:	39 45 e0             	cmp    %eax,0xffffffe0(%ebp)
    4c58:	0f 84 cd 00 00 00    	je     4d2b <try_queue_data_helper+0x487>
					int slack = TCP_SKB_CB(skb)->end_seq - TCP_SKB_CB(next)->seq;
    4c5e:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
    4c61:	83 c1 30             	add    $0x30,%ecx
    4c64:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    4c67:	83 c0 30             	add    $0x30,%eax
    4c6a:	8b 50 10             	mov    0x10(%eax),%edx
    4c6d:	8b 41 14             	mov    0x14(%ecx),%eax
    4c70:	29 d0                	sub    %edx,%eax
    4c72:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
					if(slack > 0) {
    4c75:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
    4c79:	0f 8e ac 00 00 00    	jle    4d2b <try_queue_data_helper+0x487>
						if(slack >= next->len) {
    4c7f:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    4c82:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    4c85:	3b 82 94 00 00 00    	cmp    0x94(%edx),%eax
    4c8b:	72 5e                	jb     4ceb <try_queue_data_helper+0x447>
							RECORD_OVERLAP(2, next->len);
    4c8d:	ff 05 18 00 00 00    	incl   0x18
    4c93:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    4c96:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    4c9c:	01 05 1c 00 00 00    	add    %eax,0x1c
    4ca2:	c7 05 20 00 00 00 1b 	movl   $0xd1b,0x20
    4ca9:	0d 00 00 
							// completely covered by new packet
							__skb_unlink(next, &tp->t.data_ofo_queue);
    4cac:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4caf:	05 78 09 00 00       	add    $0x978,%eax
    4cb4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    4cb8:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    4cbb:	89 04 24             	mov    %eax,(%esp,1)
    4cbe:	e8 5b 42 00 00       	call   8f1e <__skb_unlink>
							if(tp->t.byteReqHint == next)
    4cc3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4cc6:	8b 80 d8 09 00 00    	mov    0x9d8(%eax),%eax
    4ccc:	3b 45 e0             	cmp    0xffffffe0(%ebp),%eax
    4ccf:	75 0d                	jne    4cde <try_queue_data_helper+0x43a>
								tp->t.byteReqHint = NULL;
    4cd1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4cd4:	c7 80 d8 09 00 00 00 	movl   $0x0,0x9d8(%eax)
    4cdb:	00 00 00 
							// 0717 Trying to increase efficiency
							if(0 && trickles_ratelimit()) {
								printk("Old packet completely covered by old packet\n");
							}
							trickles_kfree_skb(next);
    4cde:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    4ce1:	89 04 24             	mov    %eax,(%esp,1)
    4ce4:	e8 bb b7 ff ff       	call   4a4 <trickles_kfree_skb>
    4ce9:	eb 40                	jmp    4d2b <try_queue_data_helper+0x487>
						} else {
							RECORD_OVERLAP(3, slack);
    4ceb:	ff 05 24 00 00 00    	incl   0x24
    4cf1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    4cf4:	01 05 28 00 00 00    	add    %eax,0x28
    4cfa:	c7 05 2c 00 00 00 26 	movl   $0xd26,0x2c
    4d01:	0d 00 00 
							skb_pull(next, slack);
    4d04:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    4d07:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    4d0b:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    4d0e:	89 04 24             	mov    %eax,(%esp,1)
    4d11:	e8 b0 43 00 00       	call   90c6 <skb_pull>
							TCP_SKB_CB(next)->seq += slack;
    4d16:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
    4d19:	83 c1 30             	add    $0x30,%ecx
    4d1c:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    4d1f:	83 c2 30             	add    $0x30,%edx
    4d22:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    4d25:	03 42 10             	add    0x10(%edx),%eax
    4d28:	89 41 10             	mov    %eax,0x10(%ecx)
							// 0717 Trying to increase efficiency
							if(0 && trickles_ratelimit()) {
								printk("Old packet overlapped new packet by %d\n", slack);
							}
						}
					}
				}
				__skb_insert(skb, finger, finger->next, &tp->t.data_ofo_queue);
    4d2b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4d2e:	05 78 09 00 00       	add    $0x978,%eax
    4d33:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    4d37:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    4d3a:	8b 00                	mov    (%eax),%eax
    4d3c:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    4d40:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    4d43:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    4d47:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4d4a:	89 04 24             	mov    %eax,(%esp,1)
    4d4d:	e8 96 41 00 00       	call   8ee8 <__skb_insert>
				skb = NULL;
    4d52:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
			skip_ofo_insert:
				goto data_done;
    4d59:	e9 fe 02 00 00       	jmp    505c <try_queue_data_helper+0x7b8>
			}
			if(TCP_SKB_CB(skb)->byteNum < tp->rcv_nxt) {
    4d5e:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4d61:	83 c0 30             	add    $0x30,%eax
    4d64:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    4d67:	8b 40 30             	mov    0x30(%eax),%eax
    4d6a:	3b 42 08             	cmp    0x8(%edx),%eax
    4d6d:	0f 83 ad 00 00 00    	jae    4e20 <try_queue_data_helper+0x57c>
				int slack = tp->rcv_nxt - TCP_SKB_CB(skb)->byteNum;
    4d73:	8b 4d f8             	mov    0xfffffff8(%ebp),%ecx
    4d76:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4d79:	83 c0 30             	add    $0x30,%eax
    4d7c:	8b 50 30             	mov    0x30(%eax),%edx
    4d7f:	8b 41 08             	mov    0x8(%ecx),%eax
    4d82:	29 d0                	sub    %edx,%eax
    4d84:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
				if(slack >= skb->len) {
    4d87:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    4d8a:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    4d8d:	3b 82 94 00 00 00    	cmp    0x94(%edx),%eax
    4d93:	72 4b                	jb     4de0 <try_queue_data_helper+0x53c>
					if(clientDebugLevel >= 2)
    4d95:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    4d9c:	7e 0c                	jle    4daa <try_queue_data_helper+0x506>
						printk("ByteNum < tp->rcv_nxt and no overlap; discarding\n");
    4d9e:	c7 04 24 c0 1d 00 00 	movl   $0x1dc0,(%esp,1)
    4da5:	e8 fc ff ff ff       	call   4da6 <try_queue_data_helper+0x502>
					RECORD_OVERLAP(6,skb->len);
    4daa:	ff 05 48 00 00 00    	incl   0x48
    4db0:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4db3:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    4db9:	01 05 4c 00 00 00    	add    %eax,0x4c
    4dbf:	c7 05 50 00 00 00 3a 	movl   $0xd3a,0x50
    4dc6:	0d 00 00 
					trickles_kfree_skb(skb);
    4dc9:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4dcc:	89 04 24             	mov    %eax,(%esp,1)
    4dcf:	e8 d0 b6 ff ff       	call   4a4 <trickles_kfree_skb>
					skb = NULL;
    4dd4:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
					goto data_done;
    4ddb:	e9 7c 02 00 00       	jmp    505c <try_queue_data_helper+0x7b8>
				} else {
					RECORD_OVERLAP(4,slack);
    4de0:	ff 05 30 00 00 00    	incl   0x30
    4de6:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    4de9:	01 05 34 00 00 00    	add    %eax,0x34
    4def:	c7 05 38 00 00 00 3f 	movl   $0xd3f,0x38
    4df6:	0d 00 00 
					__skb_pull(skb, slack);
    4df9:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    4dfc:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    4e00:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4e03:	89 04 24             	mov    %eax,(%esp,1)
    4e06:	e8 61 42 00 00       	call   906c <__skb_pull>
					TCP_SKB_CB(skb)->byteNum += slack;
    4e0b:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
    4e0e:	83 c1 30             	add    $0x30,%ecx
    4e11:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    4e14:	83 c2 30             	add    $0x30,%edx
    4e17:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    4e1a:	03 42 30             	add    0x30(%edx),%eax
    4e1d:	89 41 30             	mov    %eax,0x30(%ecx)
				}
			}
			if(skb->len == 0) {
    4e20:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4e23:	83 b8 94 00 00 00 00 	cmpl   $0x0,0x94(%eax)
    4e2a:	75 17                	jne    4e43 <try_queue_data_helper+0x59f>
				trickles_kfree_skb(skb);
    4e2c:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4e2f:	89 04 24             	mov    %eax,(%esp,1)
    4e32:	e8 6d b6 ff ff       	call   4a4 <trickles_kfree_skb>
				skb = NULL;
    4e37:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
				goto data_done;
    4e3e:	e9 19 02 00 00       	jmp    505c <try_queue_data_helper+0x7b8>
			}
			BUG_TRAP(TCP_SKB_CB(skb)->byteNum == tp->rcv_nxt);
    4e43:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4e46:	83 c0 30             	add    $0x30,%eax
    4e49:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    4e4c:	8b 40 30             	mov    0x30(%eax),%eax
    4e4f:	3b 42 08             	cmp    0x8(%edx),%eax
    4e52:	74 14                	je     4e68 <try_queue_data_helper+0x5c4>
    4e54:	c7 44 24 04 49 0d 00 	movl   $0xd49,0x4(%esp,1)
    4e5b:	00 
    4e5c:	c7 04 24 00 1e 00 00 	movl   $0x1e00,(%esp,1)
    4e63:	e8 fc ff ff ff       	call   4e64 <try_queue_data_helper+0x5c0>
			TCP_SKB_CB(skb)->seq = tp->rcv_nxt;
    4e68:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    4e6b:	83 c2 30             	add    $0x30,%edx
    4e6e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4e71:	8b 40 08             	mov    0x8(%eax),%eax
    4e74:	89 42 10             	mov    %eax,0x10(%edx)
			TCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(skb)->seq + skb->len;
    4e77:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
    4e7a:	83 c1 30             	add    $0x30,%ecx
    4e7d:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    4e80:	83 c2 30             	add    $0x30,%edx
    4e83:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4e86:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    4e8c:	03 42 10             	add    0x10(%edx),%eax
    4e8f:	89 41 14             	mov    %eax,0x14(%ecx)
			//printk("end_seq = %d\n", TCP_SKB_CB(skb)->end_seq);

			while(1) {
			queue_next_packet:
				/* TODO: This code trusts that only client actions generate
				   packets. Add windowsize check to prevent attackers from
				   overflowing window */

				BUG_TRAP(skb->len > 0);
    4e92:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4e95:	83 b8 94 00 00 00 00 	cmpl   $0x0,0x94(%eax)
    4e9c:	75 14                	jne    4eb2 <try_queue_data_helper+0x60e>
    4e9e:	c7 44 24 04 54 0d 00 	movl   $0xd54,0x4(%esp,1)
    4ea5:	00 
    4ea6:	c7 04 24 60 1e 00 00 	movl   $0x1e60,(%esp,1)
    4ead:	e8 fc ff ff ff       	call   4eae <try_queue_data_helper+0x60a>

#ifndef USERTEST
				tcp_fast_path_queue(sk, skb);
    4eb2:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4eb5:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    4eb9:	8b 45 08             	mov    0x8(%ebp),%eax
    4ebc:	89 04 24             	mov    %eax,(%esp,1)
    4ebf:	e8 dd 6a 00 00       	call   b9a1 <tcp_fast_path_queue>
#else
				tcp_data_queue(sk, skb);
#endif // USERTEST
				if(tp->t.byteReqHint == skb)
    4ec4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4ec7:	8b 80 d8 09 00 00    	mov    0x9d8(%eax),%eax
    4ecd:	3b 45 d8             	cmp    0xffffffd8(%ebp),%eax
    4ed0:	75 0d                	jne    4edf <try_queue_data_helper+0x63b>
					tp->t.byteReqHint = NULL;
    4ed2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4ed5:	c7 80 d8 09 00 00 00 	movl   $0x0,0x9d8(%eax)
    4edc:	00 00 00 
    4edf:	90                   	nop    

				while((skb = skb_peek(&tp->t.data_ofo_queue))) {
    4ee0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4ee3:	05 78 09 00 00       	add    $0x978,%eax
    4ee8:	89 04 24             	mov    %eax,(%esp,1)
    4eeb:	e8 dd 3e 00 00       	call   8dcd <skb_peek>
    4ef0:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    4ef3:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
    4ef7:	75 05                	jne    4efe <try_queue_data_helper+0x65a>
    4ef9:	e9 5e 01 00 00       	jmp    505c <try_queue_data_helper+0x7b8>
					if(TCP_SKB_CB(skb)->seq > tp->rcv_nxt) {
    4efe:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4f01:	83 c0 30             	add    $0x30,%eax
    4f04:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    4f07:	8b 40 10             	mov    0x10(%eax),%eax
    4f0a:	3b 42 08             	cmp    0x8(%edx),%eax
    4f0d:	76 05                	jbe    4f14 <try_queue_data_helper+0x670>
						goto data_done;
    4f0f:	e9 48 01 00 00       	jmp    505c <try_queue_data_helper+0x7b8>
					}
					__skb_unlink(skb, &tp->t.data_ofo_queue);
    4f14:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4f17:	05 78 09 00 00       	add    $0x978,%eax
    4f1c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    4f20:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4f23:	89 04 24             	mov    %eax,(%esp,1)
    4f26:	e8 f3 3f 00 00       	call   8f1e <__skb_unlink>
					if(tp->t.byteReqHint == skb)
    4f2b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4f2e:	8b 80 d8 09 00 00    	mov    0x9d8(%eax),%eax
    4f34:	3b 45 d8             	cmp    0xffffffd8(%ebp),%eax
    4f37:	75 0d                	jne    4f46 <try_queue_data_helper+0x6a2>
						tp->t.byteReqHint = NULL;
    4f39:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    4f3c:	c7 80 d8 09 00 00 00 	movl   $0x0,0x9d8(%eax)
    4f43:	00 00 00 

					if(TCP_SKB_CB(skb)->end_seq <= tp->rcv_nxt) {
    4f46:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4f49:	83 c0 30             	add    $0x30,%eax
    4f4c:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    4f4f:	8b 40 14             	mov    0x14(%eax),%eax
    4f52:	3b 42 08             	cmp    0x8(%edx),%eax
    4f55:	77 51                	ja     4fa8 <try_queue_data_helper+0x704>
						if(printOverlap)
    4f57:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    4f5e:	74 19                	je     4f79 <try_queue_data_helper+0x6d5>
							printk("IN SEQUENCE WHOLE PACKET REMOVED: %d\n", skb->len);
    4f60:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4f63:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    4f69:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    4f6d:	c7 04 24 a0 1e 00 00 	movl   $0x1ea0,(%esp,1)
    4f74:	e8 fc ff ff ff       	call   4f75 <try_queue_data_helper+0x6d1>
						RECORD_OVERLAP(7,skb->len);
    4f79:	ff 05 54 00 00 00    	incl   0x54
    4f7f:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4f82:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    4f88:	01 05 58 00 00 00    	add    %eax,0x58
    4f8e:	c7 05 5c 00 00 00 69 	movl   $0xd69,0x5c
    4f95:	0d 00 00 
						trickles_kfree_skb(skb);
    4f98:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4f9b:	89 04 24             	mov    %eax,(%esp,1)
    4f9e:	e8 01 b5 ff ff       	call   4a4 <trickles_kfree_skb>
    4fa3:	e9 38 ff ff ff       	jmp    4ee0 <try_queue_data_helper+0x63c>
					} else {
						int slack = tp->rcv_nxt - TCP_SKB_CB(skb)->seq;
    4fa8:	8b 4d f8             	mov    0xfffffff8(%ebp),%ecx
    4fab:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4fae:	83 c0 30             	add    $0x30,%eax
    4fb1:	8b 50 10             	mov    0x10(%eax),%edx
    4fb4:	8b 41 08             	mov    0x8(%ecx),%eax
    4fb7:	29 d0                	sub    %edx,%eax
    4fb9:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
						RECORD_OVERLAP(5, slack);
    4fbc:	ff 05 3c 00 00 00    	incl   0x3c
    4fc2:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    4fc5:	01 05 40 00 00 00    	add    %eax,0x40
    4fcb:	c7 05 44 00 00 00 6d 	movl   $0xd6d,0x44
    4fd2:	0d 00 00 
						__skb_pull(skb, slack);
    4fd5:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    4fd8:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    4fdc:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4fdf:	89 04 24             	mov    %eax,(%esp,1)
    4fe2:	e8 85 40 00 00       	call   906c <__skb_pull>
						TCP_SKB_CB(skb)->seq += slack;
    4fe7:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
    4fea:	83 c1 30             	add    $0x30,%ecx
    4fed:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    4ff0:	83 c2 30             	add    $0x30,%edx
    4ff3:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    4ff6:	03 42 10             	add    0x10(%edx),%eax
    4ff9:	89 41 10             	mov    %eax,0x10(%ecx)
						BUG_TRAP(TCP_SKB_CB(skb)->seq == tp->rcv_nxt &&
							 skb->len > 0);
    4ffc:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    4fff:	83 c0 30             	add    $0x30,%eax
    5002:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    5005:	8b 40 10             	mov    0x10(%eax),%eax
    5008:	3b 42 08             	cmp    0x8(%edx),%eax
    500b:	75 0c                	jne    5019 <try_queue_data_helper+0x775>
    500d:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    5010:	83 b8 94 00 00 00 00 	cmpl   $0x0,0x94(%eax)
    5017:	75 14                	jne    502d <try_queue_data_helper+0x789>
    5019:	c7 44 24 04 71 0d 00 	movl   $0xd71,0x4(%esp,1)
    5020:	00 
    5021:	c7 04 24 e0 1e 00 00 	movl   $0x1ee0,(%esp,1)
    5028:	e8 fc ff ff ff       	call   5029 <try_queue_data_helper+0x785>
						if(slack) {
    502d:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
    5031:	0f 84 5b fe ff ff    	je     4e92 <try_queue_data_helper+0x5ee>
							if(printOverlap)
    5037:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    503e:	0f 84 4e fe ff ff    	je     4e92 <try_queue_data_helper+0x5ee>
								printk("IN SEQUENCE SLACK REMOVED: %d\n", slack);
    5044:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    5047:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    504b:	c7 04 24 60 1f 00 00 	movl   $0x1f60,(%esp,1)
    5052:	e8 fc ff ff ff       	call   5053 <try_queue_data_helper+0x7af>
						}
						goto queue_next_packet;
    5057:	e9 36 fe ff ff       	jmp    4e92 <try_queue_data_helper+0x5ee>
    505c:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
    505f:	ff 00                	incl   (%eax)
    5061:	e9 88 f9 ff ff       	jmp    49ee <try_queue_data_helper+0x14a>
					}
				}
				// only reach this point if no suitable packet found
				break;
			}
		data_done: // jump to data_done if rcv_nxt was updated
			/* Remove obsolete missingDataMap and dataRequestMap entries */
			// 0505 - moved to common code path
			;
		}
		return 0;
    5066:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
    506d:	eb 07                	jmp    5076 <try_queue_data_helper+0x7d2>
	} else {
	bad_packet:
		return -1;
    506f:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,0xffffffd4(%ebp)
	}
}
    5076:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    5079:	83 c4 38             	add    $0x38,%esp
    507c:	5b                   	pop    %ebx
    507d:	5d                   	pop    %ebp
    507e:	c3                   	ret    

0000507f <fragment_skb>:

static inline int fragment_skb(struct sk_buff *in_skb) {
    507f:	55                   	push   %ebp
    5080:	89 e5                	mov    %esp,%ebp
    5082:	53                   	push   %ebx
    5083:	83 ec 50             	sub    $0x50,%esp
#define BAD_DATA() do { if(dbgBadChunk) printk("bad data line %d\n", __LINE__); goto bad_data; } while(0)
	struct DataChunk *currChunk = (struct DataChunk *)
    5086:	8b 45 08             	mov    0x8(%ebp),%eax
    5089:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
    508f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
		in_skb->data,
		*prevChunk = NULL;
    5092:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
	char *origTail = in_skb->tail;
    5099:	8b 45 08             	mov    0x8(%ebp),%eax
    509c:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
    50a2:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	char *origDataStart = in_skb->data;
    50a5:	8b 45 08             	mov    0x8(%ebp),%eax
    50a8:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
    50ae:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	int origLen = in_skb->len;
    50b1:	8b 45 08             	mov    0x8(%ebp),%eax
    50b4:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    50ba:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
	//BUG_TRAP(currChunk->type == RCHUNK_DATA);
	if(currChunk->type != RCHUNK_DATA) {
    50bd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    50c0:	80 38 02             	cmpb   $0x2,(%eax)
    50c3:	74 05                	je     50ca <fragment_skb+0x4b>
		if(trickles_ratelimit())
			printk("currChunk->type = %d, len = %d\n", currChunk->type, ntohs(currChunk->chunkLen));
		goto bad_data;
    50c5:	e9 a2 03 00 00       	jmp    546c <fragment_skb+0x3ed>
	}

	TCP_SKB_CB(in_skb)->numDataChunks = 0;
    50ca:	8b 45 08             	mov    0x8(%ebp),%eax
    50cd:	83 c0 30             	add    $0x30,%eax
    50d0:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)

	if((char*)currChunk == origTail) {
    50d7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    50da:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
    50dd:	75 31                	jne    5110 <fragment_skb+0x91>
		//printk("No chunks, origlen =  %d\n", origLen);
		in_skb->data = in_skb->tail;
    50df:	8b 55 08             	mov    0x8(%ebp),%edx
    50e2:	8b 45 08             	mov    0x8(%ebp),%eax
    50e5:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
    50eb:	89 82 b8 00 00 00    	mov    %eax,0xb8(%edx)
		in_skb->len = 0;
    50f1:	8b 45 08             	mov    0x8(%ebp),%eax
    50f4:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
    50fb:	00 00 00 
		TCP_SKB_CB(in_skb)->numDataChunks = 0;
    50fe:	8b 45 08             	mov    0x8(%ebp),%eax
    5101:	83 c0 30             	add    $0x30,%eax
    5104:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
    510b:	e9 4e 03 00 00       	jmp    545e <fragment_skb+0x3df>
	} else {
		if(!((char*)currChunk < origTail)) {
    5110:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    5113:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
    5116:	72 36                	jb     514e <fragment_skb+0xcf>
			BUG_TRAP((char*)currChunk < origTail);
    5118:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    511b:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
    511e:	72 14                	jb     5134 <fragment_skb+0xb5>
    5120:	c7 44 24 04 a0 0d 00 	movl   $0xda0,0x4(%esp,1)
    5127:	00 
    5128:	c7 04 24 80 1f 00 00 	movl   $0x1f80,(%esp,1)
    512f:	e8 fc ff ff ff       	call   5130 <fragment_skb+0xb1>
			printk("currChunk = %p origTail = %p\n", currChunk, origTail);
    5134:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    5137:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    513b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    513e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    5142:	c7 04 24 ca 1f 00 00 	movl   $0x1fca,(%esp,1)
    5149:	e8 fc ff ff ff       	call   514a <fragment_skb+0xcb>
		}

		struct sk_buff *curr_skb = NULL;
    514e:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
		int chunkNum = 0;
    5155:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
		while((char*) (currChunk+1) <= origTail &&
    515c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    515f:	83 c0 0b             	add    $0xb,%eax
    5162:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
    5165:	0f 87 48 02 00 00    	ja     53b3 <fragment_skb+0x334>
    516b:	83 7d e0 31          	cmpl   $0x31,0xffffffe0(%ebp)
    516f:	7e 05                	jle    5176 <fragment_skb+0xf7>
    5171:	e9 3d 02 00 00       	jmp    53b3 <fragment_skb+0x334>
		      chunkNum < MAX_NUM_DATACHUNKS) {
			int dataLen = DATA_LEN(currChunk);
    5176:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    5179:	0f b7 40 01          	movzwl 0x1(%eax),%eax
    517d:	89 04 24             	mov    %eax,(%esp,1)
    5180:	e8 fc ff ff ff       	call   5181 <fragment_skb+0x102>
    5185:	0f b7 c0             	movzwl %ax,%eax
    5188:	83 e8 0b             	sub    $0xb,%eax
    518b:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
			if(dataLen < 0) {
    518e:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
    5192:	0f 89 8c 00 00 00    	jns    5224 <fragment_skb+0x1a5>
				if(dbgBadChunk)
    5198:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    519f:	74 5d                	je     51fe <fragment_skb+0x17f>
					printk("Bad data len (%d), ignoring for data purposes @ chunkno = %d lineno = %d %d-%d\n",
    51a1:	8b 4d 08             	mov    0x8(%ebp),%ecx
    51a4:	8b 45 08             	mov    0x8(%ebp),%eax
    51a7:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
    51ad:	8b 81 bc 00 00 00    	mov    0xbc(%ecx),%eax
    51b3:	29 d0                	sub    %edx,%eax
    51b5:	89 44 24 14          	mov    %eax,0x14(%esp,1)
    51b9:	8b 4d 08             	mov    0x8(%ebp),%ecx
    51bc:	8b 45 08             	mov    0x8(%ebp),%eax
    51bf:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
    51c5:	8b 81 b8 00 00 00    	mov    0xb8(%ecx),%eax
    51cb:	29 d0                	sub    %edx,%eax
    51cd:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    51d1:	8b 45 08             	mov    0x8(%ebp),%eax
    51d4:	83 c0 30             	add    $0x30,%eax
    51d7:	8b 40 58             	mov    0x58(%eax),%eax
    51da:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    51de:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    51e1:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    51e5:	8b 45 08             	mov    0x8(%ebp),%eax
    51e8:	8b 40 20             	mov    0x20(%eax),%eax
    51eb:	8b 40 08             	mov    0x8(%eax),%eax
    51ee:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    51f2:	c7 04 24 00 20 00 00 	movl   $0x2000,(%esp,1)
    51f9:	e8 fc ff ff ff       	call   51fa <fragment_skb+0x17b>
				       in_skb->h.th->ack_seq, chunkNum, TCP_SKB_CB(in_skb)->dbg,
				       in_skb->data - in_skb->head, in_skb->tail - in_skb->head);
				BAD_DATA();
    51fe:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    5205:	0f 84 61 02 00 00    	je     546c <fragment_skb+0x3ed>
    520b:	c7 44 24 04 ae 0d 00 	movl   $0xdae,0x4(%esp,1)
    5212:	00 
    5213:	c7 04 24 50 20 00 00 	movl   $0x2050,(%esp,1)
    521a:	e8 fc ff ff ff       	call   521b <fragment_skb+0x19c>
    521f:	e9 48 02 00 00       	jmp    546c <fragment_skb+0x3ed>
			}
			curr_skb = skb_clone(in_skb, GFP_ATOMIC);
    5224:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    522b:	00 
    522c:	8b 45 08             	mov    0x8(%ebp),%eax
    522f:	89 04 24             	mov    %eax,(%esp,1)
    5232:	e8 fc ff ff ff       	call   5233 <fragment_skb+0x1b4>
    5237:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
			if(curr_skb == NULL) {
    523a:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
    523e:	75 32                	jne    5272 <fragment_skb+0x1f3>
				printk("Out of memory while splitting skb\n");
    5240:	c7 04 24 80 20 00 00 	movl   $0x2080,(%esp,1)
    5247:	e8 fc ff ff ff       	call   5248 <fragment_skb+0x1c9>
				BAD_DATA();
    524c:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    5253:	0f 84 13 02 00 00    	je     546c <fragment_skb+0x3ed>
    5259:	c7 44 24 04 b3 0d 00 	movl   $0xdb3,0x4(%esp,1)
    5260:	00 
    5261:	c7 04 24 50 20 00 00 	movl   $0x2050,(%esp,1)
    5268:	e8 fc ff ff ff       	call   5269 <fragment_skb+0x1ea>
    526d:	e9 fa 01 00 00       	jmp    546c <fragment_skb+0x3ed>
			}
			trickles_init_tcp_cb(curr_skb);
    5272:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    5275:	89 04 24             	mov    %eax,(%esp,1)
    5278:	e8 8d 5c 00 00       	call   af0a <trickles_init_tcp_cb>
			*GET_CHUNK(in_skb,chunkNum) = curr_skb;
    527d:	8b 45 08             	mov    0x8(%ebp),%eax
    5280:	83 c0 30             	add    $0x30,%eax
    5283:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
    5286:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
    528a:	78 08                	js     5294 <fragment_skb+0x215>
    528c:	83 7d e0 31          	cmpl   $0x31,0xffffffe0(%ebp)
    5290:	7f 02                	jg     5294 <fragment_skb+0x215>
    5292:	eb 25                	jmp    52b9 <fragment_skb+0x23a>
    5294:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    529b:	00 
    529c:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    52a3:	e8 fc ff ff ff       	call   52a4 <fragment_skb+0x225>
    52a8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    52af:	e8 fc ff ff ff       	call   52b0 <fragment_skb+0x231>
    52b4:	e8 fc ff ff ff       	call   52b5 <fragment_skb+0x236>
    52b9:	83 7d e0 04          	cmpl   $0x4,0xffffffe0(%ebp)
    52bd:	7f 11                	jg     52d0 <fragment_skb+0x251>
    52bf:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    52c2:	c1 e0 02             	shl    $0x2,%eax
    52c5:	03 45 d4             	add    0xffffffd4(%ebp),%eax
    52c8:	83 c0 38             	add    $0x38,%eax
    52cb:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    52ce:	eb 6d                	jmp    533d <fragment_skb+0x2be>
    52d0:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    52d3:	83 78 4c 00          	cmpl   $0x0,0x4c(%eax)
    52d7:	75 52                	jne    532b <fragment_skb+0x2ac>
    52d9:	c7 45 d0 2d 00 00 00 	movl   $0x2d,0xffffffd0(%ebp)
    52e0:	8b 5d d4             	mov    0xffffffd4(%ebp),%ebx
    52e3:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    52ea:	00 
    52eb:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    52ee:	c1 e0 02             	shl    $0x2,%eax
    52f1:	89 04 24             	mov    %eax,(%esp,1)
    52f4:	e8 fc ff ff ff       	call   52f5 <fragment_skb+0x276>
    52f9:	89 43 4c             	mov    %eax,0x4c(%ebx)
    52fc:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
    5303:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    5306:	3b 45 d0             	cmp    0xffffffd0(%ebp),%eax
    5309:	7c 02                	jl     530d <fragment_skb+0x28e>
    530b:	eb 1e                	jmp    532b <fragment_skb+0x2ac>
    530d:	8b 4d d4             	mov    0xffffffd4(%ebp),%ecx
    5310:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    5313:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    531a:	8b 41 4c             	mov    0x4c(%ecx),%eax
    531d:	c7 04 10 00 00 00 00 	movl   $0x0,(%eax,%edx,1)
    5324:	8d 45 cc             	lea    0xffffffcc(%ebp),%eax
    5327:	ff 00                	incl   (%eax)
    5329:	eb d8                	jmp    5303 <fragment_skb+0x284>
    532b:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
    532e:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    5331:	c1 e0 02             	shl    $0x2,%eax
    5334:	03 42 4c             	add    0x4c(%edx),%eax
    5337:	83 e8 14             	sub    $0x14,%eax
    533a:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    533d:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    5340:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    5343:	89 02                	mov    %eax,(%edx)

			//printk("Chunk(%d) at %d, %d %d\n", ntohs(currChunk->chunkLen), (char*)curr_skb->data - ucont_start,  (char*) (currChunk+1) - ucont_start, origTail - ucont_start);
			curr_skb->data = currChunk->data;
    5345:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    5348:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    534b:	83 c0 0b             	add    $0xb,%eax
    534e:	89 82 b8 00 00 00    	mov    %eax,0xb8(%edx)
			curr_skb->tail = curr_skb->data + dataLen;
    5354:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
    5357:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    535a:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    535d:	03 82 b8 00 00 00    	add    0xb8(%edx),%eax
    5363:	89 81 bc 00 00 00    	mov    %eax,0xbc(%ecx)
			curr_skb->len = dataLen;
    5369:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    536c:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    536f:	89 82 94 00 00 00    	mov    %eax,0x94(%edx)
			TCP_SKB_CB(curr_skb)->byteNum =
    5375:	8b 5d e4             	mov    0xffffffe4(%ebp),%ebx
    5378:	83 c3 30             	add    $0x30,%ebx
    537b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    537e:	8b 40 07             	mov    0x7(%eax),%eax
    5381:	89 04 24             	mov    %eax,(%esp,1)
    5384:	e8 fc ff ff ff       	call   5385 <fragment_skb+0x306>
    5389:	89 43 30             	mov    %eax,0x30(%ebx)
				htonl(currChunk->byteNum);

#if 0
			printk("%p: NumDataChunks = %d\n",
			       curr_skb, TCP_SKB_CB(curr_skb)->numDataChunks);
#endif
			// Prepare for next loop
			prevChunk = currChunk;
    538c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    538f:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
			currChunk = (struct DataChunk *)
    5392:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    5395:	0f b7 40 01          	movzwl 0x1(%eax),%eax
    5399:	89 04 24             	mov    %eax,(%esp,1)
    539c:	e8 fc ff ff ff       	call   539d <fragment_skb+0x31e>
    53a1:	0f b7 d0             	movzwl %ax,%edx
    53a4:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
    53a7:	01 10                	add    %edx,(%eax)
				NEXT_CHUNK_ADDR(currChunk);
			//printk("%p => %p\n", origChunk, currChunk);
			chunkNum++;
    53a9:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
    53ac:	ff 00                	incl   (%eax)
    53ae:	e9 a9 fd ff ff       	jmp    515c <fragment_skb+0xdd>
		}
		BUG_TRAP(chunkNum >= 1);
    53b3:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
    53b7:	7f 14                	jg     53cd <fragment_skb+0x34e>
    53b9:	c7 44 24 04 ca 0d 00 	movl   $0xdca,0x4(%esp,1)
    53c0:	00 
    53c1:	c7 04 24 c0 20 00 00 	movl   $0x20c0,(%esp,1)
    53c8:	e8 fc ff ff ff       	call   53c9 <fragment_skb+0x34a>
		// Harmless padding
		if((char*)(currChunk-1) >= origTail) {
    53cd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    53d0:	83 e8 0b             	sub    $0xb,%eax
    53d3:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
    53d6:	72 7a                	jb     5452 <fragment_skb+0x3d3>
			int dumpLen = (char*)origTail - (char*)currChunk;
    53d8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    53db:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    53de:	29 c2                	sub    %eax,%edx
    53e0:	89 d0                	mov    %edx,%eax
    53e2:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
			if(dbgBadChunk)
    53e5:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    53ec:	74 52                	je     5440 <fragment_skb+0x3c1>
				printk("curr chunk (prev=%d, packetID=%d) exceeds tail!, chunkNum = %d, origLen = %d, chunkOffset = %d\n",
    53ee:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    53f1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    53f4:	29 d0                	sub    %edx,%eax
    53f6:	89 44 24 14          	mov    %eax,0x14(%esp,1)
    53fa:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    53fd:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    5401:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    5404:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    5408:	8b 45 08             	mov    0x8(%ebp),%eax
    540b:	8b 40 20             	mov    0x20(%eax),%eax
    540e:	8b 40 08             	mov    0x8(%eax),%eax
    5411:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    5415:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
    5419:	74 0b                	je     5426 <fragment_skb+0x3a7>
    541b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    541e:	8b 40 03             	mov    0x3(%eax),%eax
    5421:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
    5424:	eb 07                	jmp    542d <fragment_skb+0x3ae>
    5426:	c7 45 c4 ff ff ff ff 	movl   $0xffffffff,0xffffffc4(%ebp)
    542d:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    5430:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    5434:	c7 04 24 00 21 00 00 	movl   $0x2100,(%esp,1)
    543b:	e8 fc ff ff ff       	call   543c <fragment_skb+0x3bd>
#ifdef CHUNKID
			       prevChunk != NULL ? prevChunk->chunkID :
#endif
			       -1,
			       in_skb->h.th->ack_seq, chunkNum, origLen, (char*)currChunk - origDataStart);
			mem_dump((char*)currChunk, dumpLen);
    5440:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    5443:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    5447:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    544a:	89 04 24             	mov    %eax,(%esp,1)
    544d:	e8 fc ff ff ff       	call   544e <fragment_skb+0x3cf>
		}
		TCP_SKB_CB(in_skb)->numDataChunks = chunkNum;
    5452:	8b 55 08             	mov    0x8(%ebp),%edx
    5455:	83 c2 30             	add    $0x30,%edx
    5458:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    545b:	89 42 34             	mov    %eax,0x34(%edx)

		//printk("%p: NumDataChunks = %d\n", in_skb, TCP_SKB_CB(in_skb)->numDataChunks);
	}
	//update_rx_stats(in_skb);

	//printk("in_skb: byteNum = %d, len = %d\n", TCP_SKB_CB(in_skb)->byteNum, in_skb->len);
#undef BAD_DATA

	return TCP_SKB_CB(in_skb)->numDataChunks;
    545e:	8b 45 08             	mov    0x8(%ebp),%eax
    5461:	83 c0 30             	add    $0x30,%eax
    5464:	8b 40 34             	mov    0x34(%eax),%eax
    5467:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
    546a:	eb 07                	jmp    5473 <fragment_skb+0x3f4>
 bad_data:
	return -1;
    546c:	c7 45 c8 ff ff ff ff 	movl   $0xffffffff,0xffffffc8(%ebp)
}
    5473:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    5476:	83 c4 50             	add    $0x50,%esp
    5479:	5b                   	pop    %ebx
    547a:	5d                   	pop    %ebp
    547b:	c3                   	ret    

0000547c <process_new_ucont>:


/* **************** Continuation management code ***************************/

static inline int process_new_ucont(struct sock *sk, struct RequestOFOEntry *ofo_entry) {
    547c:	55                   	push   %ebp
    547d:	89 e5                	mov    %esp,%ebp
    547f:	83 ec 18             	sub    $0x18,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    5482:	8b 45 08             	mov    0x8(%ebp),%eax
    5485:	05 bc 00 00 00       	add    $0xbc,%eax
    548a:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

	BUG_TRAP(ofo_entry != NULL);
    548d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    5491:	75 14                	jne    54a7 <process_new_ucont+0x2b>
    5493:	c7 44 24 04 eb 0d 00 	movl   $0xdeb,0x4(%esp,1)
    549a:	00 
    549b:	c7 04 24 60 21 00 00 	movl   $0x2160,(%esp,1)
    54a2:	e8 fc ff ff ff       	call   54a3 <process_new_ucont+0x27>
	if(ofo_entry->parent == TRANSPORT_OR_DATA_ONLY_REQNUM) {
    54a7:	8b 45 0c             	mov    0xc(%ebp),%eax
    54aa:	83 78 14 ff          	cmpl   $0xffffffff,0x14(%eax)
    54ae:	75 1d                	jne    54cd <process_new_ucont+0x51>
		gInvalidReqnum++;
    54b0:	ff 05 00 00 00 00    	incl   0x0
		RequestOFOEntry_free(ofo_entry);
    54b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    54b9:	89 04 24             	mov    %eax,(%esp,1)
    54bc:	e8 66 51 00 00       	call   a627 <RequestOFOEntry_free>
		return -1;
    54c1:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,0xfffffff4(%ebp)
    54c8:	e9 db 01 00 00       	jmp    56a8 <process_new_ucont+0x22c>
	}
	BUG_TRAP(ofo_entry->parent != TRANSPORT_ONLY_REQNUM);
    54cd:	8b 45 0c             	mov    0xc(%ebp),%eax
    54d0:	83 78 14 ff          	cmpl   $0xffffffff,0x14(%eax)
    54d4:	75 14                	jne    54ea <process_new_ucont+0x6e>
    54d6:	c7 44 24 04 f1 0d 00 	movl   $0xdf1,0x4(%esp,1)
    54dd:	00 
    54de:	c7 04 24 a0 21 00 00 	movl   $0x21a0,(%esp,1)
    54e5:	e8 fc ff ff ff       	call   54e6 <process_new_ucont+0x6a>

	//printk("Contains ucont1\n");
	if(ofo_entry->parent == tp->t.request_rcv_nxt) {
    54ea:	8b 45 0c             	mov    0xc(%ebp),%eax
    54ed:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    54f0:	8b 40 14             	mov    0x14(%eax),%eax
    54f3:	3b 82 5c 09 00 00    	cmp    0x95c(%edx),%eax
    54f9:	0f 85 99 00 00 00    	jne    5598 <process_new_ucont+0x11c>
		for(;;) {
			// process formerly out of order continuations that are now in-order
			CONTINUATION_TYPE *cont = ofo_entry->cont;
    54ff:	8b 45 0c             	mov    0xc(%ebp),%eax
    5502:	8b 40 0c             	mov    0xc(%eax),%eax
    5505:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
#ifndef TEST_TRANSPORT_ONLY
			//printk("pre update\n");
			UpdateClientUCState(sk, ofo_entry);
    5508:	8b 45 0c             	mov    0xc(%ebp),%eax
    550b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    550f:	8b 45 08             	mov    0x8(%ebp),%eax
    5512:	89 04 24             	mov    %eax,(%esp,1)
    5515:	e8 41 d4 ff ff       	call   295b <UpdateClientUCState>
			RequestOFOEntry_free(ofo_entry);
    551a:	8b 45 0c             	mov    0xc(%ebp),%eax
    551d:	89 04 24             	mov    %eax,(%esp,1)
    5520:	e8 02 51 00 00       	call   a627 <RequestOFOEntry_free>
			//printk("post update, ucontlist = %d\n", tp->t.ucontList.len);
#endif
			// deallocation of skb->cont must occur after references in the above block
			BUG_TRAP(tp->t.ack_prev != cont); // 0429 track down corruption error
    5525:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    5528:	8b 80 f4 02 00 00    	mov    0x2f4(%eax),%eax
    552e:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
    5531:	75 14                	jne    5547 <process_new_ucont+0xcb>
    5533:	c7 44 24 04 ff 0d 00 	movl   $0xdff,0x4(%esp,1)
    553a:	00 
    553b:	c7 04 24 00 22 00 00 	movl   $0x2200,(%esp,1)
    5542:	e8 fc ff ff ff       	call   5543 <process_new_ucont+0xc7>
			MARK_PC(cont);
			// request_rcv_nxt is updated in updateParent
			if(empty(&tp->t.request_ofo_queue)) {
    5547:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    554a:	05 64 09 00 00       	add    $0x964,%eax
    554f:	89 04 24             	mov    %eax,(%esp,1)
    5552:	e8 68 3c 00 00       	call   91bf <empty>
    5557:	85 c0                	test   %eax,%eax
    5559:	74 02                	je     555d <process_new_ucont+0xe1>
				break;
    555b:	eb 2f                	jmp    558c <process_new_ucont+0x110>
			}
			ofo_entry = (struct RequestOFOEntry *)tp->t.request_ofo_queue.next;
    555d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    5560:	8b 80 68 09 00 00    	mov    0x968(%eax),%eax
    5566:	89 45 0c             	mov    %eax,0xc(%ebp)
			if(ofo_entry->parent != tp->t.request_rcv_nxt) {
    5569:	8b 45 0c             	mov    0xc(%ebp),%eax
    556c:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    556f:	8b 40 14             	mov    0x14(%eax),%eax
    5572:	3b 82 5c 09 00 00    	cmp    0x95c(%edx),%eax
    5578:	74 02                	je     557c <process_new_ucont+0x100>
				break;
    557a:	eb 10                	jmp    558c <process_new_ucont+0x110>
			}
			unlink((struct alloc_head*) ofo_entry);
    557c:	8b 45 0c             	mov    0xc(%ebp),%eax
    557f:	89 04 24             	mov    %eax,(%esp,1)
    5582:	e8 65 3d 00 00       	call   92ec <unlink>
    5587:	e9 73 ff ff ff       	jmp    54ff <process_new_ucont+0x83>
		}
		ofo_entry = NULL;
    558c:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
    5593:	e9 09 01 00 00       	jmp    56a1 <process_new_ucont+0x225>
	} else {
		//printk("ofo\n");
		/* enqueue in request_ofo_queue */
		struct RequestOFOEntry *finger;
		BUG_TRAP(ofo_entry->parent > tp->t.request_rcv_nxt);
    5598:	8b 45 0c             	mov    0xc(%ebp),%eax
    559b:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    559e:	8b 40 14             	mov    0x14(%eax),%eax
    55a1:	3b 82 5c 09 00 00    	cmp    0x95c(%edx),%eax
    55a7:	77 14                	ja     55bd <process_new_ucont+0x141>
    55a9:	c7 44 24 04 10 0e 00 	movl   $0xe10,0x4(%esp,1)
    55b0:	00 
    55b1:	c7 04 24 60 22 00 00 	movl   $0x2260,(%esp,1)
    55b8:	e8 fc ff ff ff       	call   55b9 <process_new_ucont+0x13d>
		if(empty(&tp->t.request_ofo_queue)) {
    55bd:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    55c0:	05 64 09 00 00       	add    $0x964,%eax
    55c5:	89 04 24             	mov    %eax,(%esp,1)
    55c8:	e8 f2 3b 00 00       	call   91bf <empty>
    55cd:	85 c0                	test   %eax,%eax
    55cf:	74 1c                	je     55ed <process_new_ucont+0x171>
			insert_head((struct alloc_head_list*)&tp->t.request_ofo_queue,
    55d1:	8b 45 0c             	mov    0xc(%ebp),%eax
    55d4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    55d8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    55db:	05 64 09 00 00       	add    $0x964,%eax
    55e0:	89 04 24             	mov    %eax,(%esp,1)
    55e3:	e8 11 3c 00 00       	call   91f9 <insert_head>
    55e8:	e9 b4 00 00 00       	jmp    56a1 <process_new_ucont+0x225>
				    (struct alloc_head*)ofo_entry);
		} else {
			finger = (struct RequestOFOEntry *)tp->t.request_ofo_queue.prev;
    55ed:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    55f0:	8b 80 64 09 00 00    	mov    0x964(%eax),%eax
    55f6:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
			do {
				if(finger->parent < ofo_entry->parent)
    55f9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    55fc:	8b 55 0c             	mov    0xc(%ebp),%edx
    55ff:	8b 40 14             	mov    0x14(%eax),%eax
    5602:	3b 42 14             	cmp    0x14(%edx),%eax
    5605:	73 02                	jae    5609 <process_new_ucont+0x18d>
					break;
    5607:	eb 14                	jmp    561d <process_new_ucont+0x1a1>
			} while((struct alloc_head_list*)(finger=finger->prev) != &tp->t.request_ofo_queue);
    5609:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    560c:	8b 10                	mov    (%eax),%edx
    560e:	89 55 f8             	mov    %edx,0xfffffff8(%ebp)
    5611:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    5614:	05 64 09 00 00       	add    $0x964,%eax
    5619:	39 c2                	cmp    %eax,%edx
    561b:	75 dc                	jne    55f9 <process_new_ucont+0x17d>
			if(finger->next != (struct RequestOFOEntry*)&tp->t.request_ofo_queue) {
    561d:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    5620:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    5623:	05 64 09 00 00       	add    $0x964,%eax
    5628:	39 42 04             	cmp    %eax,0x4(%edx)
    562b:	74 51                	je     567e <process_new_ucont+0x202>
				if( ((struct RequestOFOEntry*)finger->next)->parent == ofo_entry->parent) {
    562d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    5630:	8b 40 04             	mov    0x4(%eax),%eax
    5633:	8b 55 0c             	mov    0xc(%ebp),%edx
    5636:	8b 40 14             	mov    0x14(%eax),%eax
    5639:	3b 42 14             	cmp    0x14(%edx),%eax
    563c:	75 1b                	jne    5659 <process_new_ucont+0x1dd>
					RequestOFOEntry_free(ofo_entry);
    563e:	8b 45 0c             	mov    0xc(%ebp),%eax
    5641:	89 04 24             	mov    %eax,(%esp,1)
    5644:	e8 de 4f 00 00       	call   a627 <RequestOFOEntry_free>
					ofo_entry = NULL;
    5649:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
					return 1;
    5650:	c7 45 f4 01 00 00 00 	movl   $0x1,0xfffffff4(%ebp)
    5657:	eb 4f                	jmp    56a8 <process_new_ucont+0x22c>
				}
				BUG_TRAP(((struct RequestOFOEntry*)
					  finger->next)->parent >
					 ofo_entry->parent);
    5659:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    565c:	8b 40 04             	mov    0x4(%eax),%eax
    565f:	8b 55 0c             	mov    0xc(%ebp),%edx
    5662:	8b 40 14             	mov    0x14(%eax),%eax
    5665:	3b 42 14             	cmp    0x14(%edx),%eax
    5668:	77 14                	ja     567e <process_new_ucont+0x202>
    566a:	c7 44 24 04 22 0e 00 	movl   $0xe22,0x4(%esp,1)
    5671:	00 
    5672:	c7 04 24 c0 22 00 00 	movl   $0x22c0,(%esp,1)
    5679:	e8 fc ff ff ff       	call   567a <process_new_ucont+0x1fe>
			}
			insert((struct alloc_head*)ofo_entry,
    567e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    5681:	8b 40 04             	mov    0x4(%eax),%eax
    5684:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    5688:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    568b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    568f:	8b 45 0c             	mov    0xc(%ebp),%eax
    5692:	89 04 24             	mov    %eax,(%esp,1)
    5695:	e8 98 3c 00 00       	call   9332 <insert>
			       (struct alloc_head*)finger,
			       (struct alloc_head*)finger->next);
			ofo_entry = NULL;
    569a:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
		}
	}
	//BUG_TRAP(ofo_entry == NULL);
	return 0;
    56a1:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
 }
    56a8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    56ab:	c9                   	leave  
    56ac:	c3                   	ret    

000056ad <AckProof_update>:

/* TODO: Strip out sk argument */
int AckProof_update(struct sock *sk, AckProof *ackProof, CONTINUATION_TYPE *cont) {
    56ad:	55                   	push   %ebp
    56ae:	89 e5                	mov    %esp,%ebp
    56b0:	57                   	push   %edi
    56b1:	56                   	push   %esi
    56b2:	53                   	push   %ebx
    56b3:	83 ec 38             	sub    $0x38,%esp
	int i, j;
	__u32 seq = cont->seq;
    56b6:	8b 45 10             	mov    0x10(%ebp),%eax
    56b9:	8b 40 30             	mov    0x30(%eax),%eax
    56bc:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
	int *numSacks = &ackProof->numSacks;
    56bf:	8b 45 0c             	mov    0xc(%ebp),%eax
    56c2:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
	Sack *sacks = ackProof->sacks;
    56c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    56c8:	83 c0 08             	add    $0x8,%eax
    56cb:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
	for(i=0; i < *numSacks && (seq >= sacks[i].left || seq == sacks[i].left - 1); i++) {
    56ce:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
    56d5:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    56d8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    56db:	3b 02                	cmp    (%edx),%eax
    56dd:	0f 8d 7d 03 00 00    	jge    5a60 <AckProof_update+0x3b3>
    56e3:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    56e6:	89 d0                	mov    %edx,%eax
    56e8:	01 c0                	add    %eax,%eax
    56ea:	01 d0                	add    %edx,%eax
    56ec:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    56f3:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    56f6:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    56f9:	3b 04 0a             	cmp    (%edx,%ecx,1),%eax
    56fc:	73 21                	jae    571f <AckProof_update+0x72>
    56fe:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5701:	89 d0                	mov    %edx,%eax
    5703:	01 c0                	add    %eax,%eax
    5705:	01 d0                	add    %edx,%eax
    5707:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    570e:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    5711:	8b 04 10             	mov    (%eax,%edx,1),%eax
    5714:	48                   	dec    %eax
    5715:	39 45 e8             	cmp    %eax,0xffffffe8(%ebp)
    5718:	74 05                	je     571f <AckProof_update+0x72>
    571a:	e9 41 03 00 00       	jmp    5a60 <AckProof_update+0x3b3>
	  /* condition not expressed as > because of overflow/underflow */
		if(seq == sacks[i].left - 1) {
    571f:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5722:	89 d0                	mov    %edx,%eax
    5724:	01 c0                	add    %eax,%eax
    5726:	01 d0                	add    %edx,%eax
    5728:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    572f:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    5732:	8b 04 10             	mov    (%eax,%edx,1),%eax
    5735:	48                   	dec    %eax
    5736:	39 45 e8             	cmp    %eax,0xffffffe8(%ebp)
    5739:	0f 85 65 01 00 00    	jne    58a4 <AckProof_update+0x1f7>
			sacks[i].left = seq;
    573f:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5742:	89 d0                	mov    %edx,%eax
    5744:	01 c0                	add    %eax,%eax
    5746:	01 d0                	add    %edx,%eax
    5748:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    574f:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    5752:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    5755:	89 04 0a             	mov    %eax,(%edx,%ecx,1)
			sacks[i].nonceSummary ^= cont->cum_nonce;
    5758:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    575b:	89 d0                	mov    %edx,%eax
    575d:	01 c0                	add    %eax,%eax
    575f:	01 d0                	add    %edx,%eax
    5761:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
    5768:	8b 5d e0             	mov    0xffffffe0(%ebp),%ebx
    576b:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    576e:	89 d0                	mov    %edx,%eax
    5770:	01 c0                	add    %eax,%eax
    5772:	01 d0                	add    %edx,%eax
    5774:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    577b:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    577e:	8b 45 10             	mov    0x10(%ebp),%eax
    5781:	8b 40 2c             	mov    0x2c(%eax),%eax
    5784:	33 44 0a 08          	xor    0x8(%edx,%ecx,1),%eax
    5788:	89 44 33 08          	mov    %eax,0x8(%ebx,%esi,1)
			if(i > 0 && sacks[i-1].right == sacks[i].left - 1) {
    578c:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
    5790:	0f 8e 02 01 00 00    	jle    5898 <AckProof_update+0x1eb>
    5796:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5799:	89 d0                	mov    %edx,%eax
    579b:	01 c0                	add    %eax,%eax
    579d:	01 d0                	add    %edx,%eax
    579f:	c1 e0 02             	shl    $0x2,%eax
    57a2:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    57a5:	8d 48 f4             	lea    0xfffffff4(%eax),%ecx
    57a8:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    57ab:	89 d0                	mov    %edx,%eax
    57ad:	01 c0                	add    %eax,%eax
    57af:	01 d0                	add    %edx,%eax
    57b1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    57b8:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    57bb:	8b 04 10             	mov    (%eax,%edx,1),%eax
    57be:	48                   	dec    %eax
    57bf:	39 41 04             	cmp    %eax,0x4(%ecx)
    57c2:	0f 85 d0 00 00 00    	jne    5898 <AckProof_update+0x1eb>
				printk("Not supposed to reach this point\n");
    57c8:	c7 04 24 40 23 00 00 	movl   $0x2340,(%esp,1)
    57cf:	e8 fc ff ff ff       	call   57d0 <AckProof_update+0x123>
			  /* actually, this case should never be reached */
				/* coalesce */
				sacks[i-1].right = sacks[i].right;
    57d4:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    57d7:	89 d0                	mov    %edx,%eax
    57d9:	01 c0                	add    %eax,%eax
    57db:	01 d0                	add    %edx,%eax
    57dd:	c1 e0 02             	shl    $0x2,%eax
    57e0:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    57e3:	8d 48 f4             	lea    0xfffffff4(%eax),%ecx
    57e6:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    57e9:	89 d0                	mov    %edx,%eax
    57eb:	01 c0                	add    %eax,%eax
    57ed:	01 d0                	add    %edx,%eax
    57ef:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    57f6:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    57f9:	8b 44 10 04          	mov    0x4(%eax,%edx,1),%eax
    57fd:	89 41 04             	mov    %eax,0x4(%ecx)
				sacks[i-1].nonceSummary ^= sacks[i].nonceSummary;
    5800:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5803:	89 d0                	mov    %edx,%eax
    5805:	01 c0                	add    %eax,%eax
    5807:	01 d0                	add    %edx,%eax
    5809:	c1 e0 02             	shl    $0x2,%eax
    580c:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    580f:	8d 58 f4             	lea    0xfffffff4(%eax),%ebx
    5812:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5815:	89 d0                	mov    %edx,%eax
    5817:	01 c0                	add    %eax,%eax
    5819:	01 d0                	add    %edx,%eax
    581b:	c1 e0 02             	shl    $0x2,%eax
    581e:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    5821:	8d 48 f4             	lea    0xfffffff4(%eax),%ecx
    5824:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5827:	89 d0                	mov    %edx,%eax
    5829:	01 c0                	add    %eax,%eax
    582b:	01 d0                	add    %edx,%eax
    582d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5834:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    5837:	8b 44 10 08          	mov    0x8(%eax,%edx,1),%eax
    583b:	33 41 08             	xor    0x8(%ecx),%eax
    583e:	89 43 08             	mov    %eax,0x8(%ebx)
				for(j=i + 1; j < *numSacks; j++) {
    5841:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    5844:	40                   	inc    %eax
    5845:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    5848:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    584b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    584e:	3b 02                	cmp    (%edx),%eax
    5850:	7c 02                	jl     5854 <AckProof_update+0x1a7>
    5852:	eb 3f                	jmp    5893 <AckProof_update+0x1e6>
					sacks[j - 1] = sacks[j];
    5854:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    5857:	89 d0                	mov    %edx,%eax
    5859:	01 c0                	add    %eax,%eax
    585b:	01 d0                	add    %edx,%eax
    585d:	c1 e0 02             	shl    $0x2,%eax
    5860:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    5863:	8d 58 f4             	lea    0xfffffff4(%eax),%ebx
    5866:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    5869:	89 d0                	mov    %edx,%eax
    586b:	01 c0                	add    %eax,%eax
    586d:	01 d0                	add    %edx,%eax
    586f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    5876:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    5879:	8b 04 0a             	mov    (%edx,%ecx,1),%eax
    587c:	89 03                	mov    %eax,(%ebx)
    587e:	8b 44 0a 04          	mov    0x4(%edx,%ecx,1),%eax
    5882:	89 43 04             	mov    %eax,0x4(%ebx)
    5885:	8b 44 0a 08          	mov    0x8(%edx,%ecx,1),%eax
    5889:	89 43 08             	mov    %eax,0x8(%ebx)
    588c:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
    588f:	ff 00                	incl   (%eax)
    5891:	eb b5                	jmp    5848 <AckProof_update+0x19b>
				}
				(*numSacks)--;
    5893:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    5896:	ff 08                	decl   (%eax)
			}
			return 1;
    5898:	c7 45 d0 01 00 00 00 	movl   $0x1,0xffffffd0(%ebp)
    589f:	e9 c5 03 00 00       	jmp    5c69 <AckProof_update+0x5bc>
		} else if(seq == sacks[i].right + 1) {
    58a4:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    58a7:	89 d0                	mov    %edx,%eax
    58a9:	01 c0                	add    %eax,%eax
    58ab:	01 d0                	add    %edx,%eax
    58ad:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    58b4:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    58b7:	8b 44 10 04          	mov    0x4(%eax,%edx,1),%eax
    58bb:	40                   	inc    %eax
    58bc:	39 45 e8             	cmp    %eax,0xffffffe8(%ebp)
    58bf:	0f 85 63 01 00 00    	jne    5a28 <AckProof_update+0x37b>
			sacks[i].right = seq;
    58c5:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    58c8:	89 d0                	mov    %edx,%eax
    58ca:	01 c0                	add    %eax,%eax
    58cc:	01 d0                	add    %edx,%eax
    58ce:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    58d5:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    58d8:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    58db:	89 44 0a 04          	mov    %eax,0x4(%edx,%ecx,1)
			sacks[i].nonceSummary ^= cont->cum_nonce;
    58df:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    58e2:	89 d0                	mov    %edx,%eax
    58e4:	01 c0                	add    %eax,%eax
    58e6:	01 d0                	add    %edx,%eax
    58e8:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
    58ef:	8b 5d e0             	mov    0xffffffe0(%ebp),%ebx
    58f2:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    58f5:	89 d0                	mov    %edx,%eax
    58f7:	01 c0                	add    %eax,%eax
    58f9:	01 d0                	add    %edx,%eax
    58fb:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    5902:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    5905:	8b 45 10             	mov    0x10(%ebp),%eax
    5908:	8b 40 2c             	mov    0x2c(%eax),%eax
    590b:	33 44 0a 08          	xor    0x8(%edx,%ecx,1),%eax
    590f:	89 44 33 08          	mov    %eax,0x8(%ebx,%esi,1)
			if(i + 1 < *numSacks && sacks[i].right == sacks[i+1].left - 1) {
    5913:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5916:	42                   	inc    %edx
    5917:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    591a:	3b 10                	cmp    (%eax),%edx
    591c:	0f 8d fa 00 00 00    	jge    5a1c <AckProof_update+0x36f>
    5922:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5925:	89 d0                	mov    %edx,%eax
    5927:	01 c0                	add    %eax,%eax
    5929:	01 d0                	add    %edx,%eax
    592b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    5932:	8b 5d e0             	mov    0xffffffe0(%ebp),%ebx
    5935:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5938:	89 d0                	mov    %edx,%eax
    593a:	01 c0                	add    %eax,%eax
    593c:	01 d0                	add    %edx,%eax
    593e:	c1 e0 02             	shl    $0x2,%eax
    5941:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    5944:	83 c0 0c             	add    $0xc,%eax
    5947:	8b 00                	mov    (%eax),%eax
    5949:	48                   	dec    %eax
    594a:	39 44 0b 04          	cmp    %eax,0x4(%ebx,%ecx,1)
    594e:	0f 85 c8 00 00 00    	jne    5a1c <AckProof_update+0x36f>
				/* coalesce */
				sacks[i].right = sacks[i+1].right;
    5954:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5957:	89 d0                	mov    %edx,%eax
    5959:	01 c0                	add    %eax,%eax
    595b:	01 d0                	add    %edx,%eax
    595d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    5964:	8b 5d e0             	mov    0xffffffe0(%ebp),%ebx
    5967:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    596a:	89 d0                	mov    %edx,%eax
    596c:	01 c0                	add    %eax,%eax
    596e:	01 d0                	add    %edx,%eax
    5970:	c1 e0 02             	shl    $0x2,%eax
    5973:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    5976:	83 c0 0c             	add    $0xc,%eax
    5979:	8b 40 04             	mov    0x4(%eax),%eax
    597c:	89 44 0b 04          	mov    %eax,0x4(%ebx,%ecx,1)
				sacks[i].nonceSummary ^= sacks[i+1].nonceSummary;
    5980:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5983:	89 d0                	mov    %edx,%eax
    5985:	01 c0                	add    %eax,%eax
    5987:	01 d0                	add    %edx,%eax
    5989:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
    5990:	8b 7d e0             	mov    0xffffffe0(%ebp),%edi
    5993:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5996:	89 d0                	mov    %edx,%eax
    5998:	01 c0                	add    %eax,%eax
    599a:	01 d0                	add    %edx,%eax
    599c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    59a3:	8b 5d e0             	mov    0xffffffe0(%ebp),%ebx
    59a6:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    59a9:	89 d0                	mov    %edx,%eax
    59ab:	01 c0                	add    %eax,%eax
    59ad:	01 d0                	add    %edx,%eax
    59af:	c1 e0 02             	shl    $0x2,%eax
    59b2:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    59b5:	83 c0 0c             	add    $0xc,%eax
    59b8:	8b 40 08             	mov    0x8(%eax),%eax
    59bb:	33 44 0b 08          	xor    0x8(%ebx,%ecx,1),%eax
    59bf:	89 44 37 08          	mov    %eax,0x8(%edi,%esi,1)
				for(j=i + 2; j < *numSacks; j++) {
    59c3:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    59c6:	83 c0 02             	add    $0x2,%eax
    59c9:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    59cc:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    59cf:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    59d2:	3b 02                	cmp    (%edx),%eax
    59d4:	7c 02                	jl     59d8 <AckProof_update+0x32b>
    59d6:	eb 3f                	jmp    5a17 <AckProof_update+0x36a>
					sacks[j - 1] = sacks[j];
    59d8:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    59db:	89 d0                	mov    %edx,%eax
    59dd:	01 c0                	add    %eax,%eax
    59df:	01 d0                	add    %edx,%eax
    59e1:	c1 e0 02             	shl    $0x2,%eax
    59e4:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    59e7:	8d 58 f4             	lea    0xfffffff4(%eax),%ebx
    59ea:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    59ed:	89 d0                	mov    %edx,%eax
    59ef:	01 c0                	add    %eax,%eax
    59f1:	01 d0                	add    %edx,%eax
    59f3:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    59fa:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    59fd:	8b 04 0a             	mov    (%edx,%ecx,1),%eax
    5a00:	89 03                	mov    %eax,(%ebx)
    5a02:	8b 44 0a 04          	mov    0x4(%edx,%ecx,1),%eax
    5a06:	89 43 04             	mov    %eax,0x4(%ebx)
    5a09:	8b 44 0a 08          	mov    0x8(%edx,%ecx,1),%eax
    5a0d:	89 43 08             	mov    %eax,0x8(%ebx)
    5a10:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
    5a13:	ff 00                	incl   (%eax)
    5a15:	eb b5                	jmp    59cc <AckProof_update+0x31f>
				}
				(*numSacks)--;
    5a17:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    5a1a:	ff 08                	decl   (%eax)
			}
			return 1;
    5a1c:	c7 45 d0 01 00 00 00 	movl   $0x1,0xffffffd0(%ebp)
    5a23:	e9 41 02 00 00       	jmp    5c69 <AckProof_update+0x5bc>
		} else if(Sack_contains(&sacks[i], seq)) {
    5a28:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    5a2b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    5a2f:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5a32:	89 d0                	mov    %edx,%eax
    5a34:	01 c0                	add    %eax,%eax
    5a36:	01 d0                	add    %edx,%eax
    5a38:	c1 e0 02             	shl    $0x2,%eax
    5a3b:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    5a3e:	89 04 24             	mov    %eax,(%esp,1)
    5a41:	e8 fc ff ff ff       	call   5a42 <AckProof_update+0x395>
    5a46:	85 c0                	test   %eax,%eax
    5a48:	74 0c                	je     5a56 <AckProof_update+0x3a9>
			/* In the middle of an existing sack */
			return 1;
    5a4a:	c7 45 d0 01 00 00 00 	movl   $0x1,0xffffffd0(%ebp)
    5a51:	e9 13 02 00 00       	jmp    5c69 <AckProof_update+0x5bc>
    5a56:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
    5a59:	ff 00                	incl   (%eax)
    5a5b:	e9 75 fc ff ff       	jmp    56d5 <AckProof_update+0x28>
		}
	}
	if(i >= MAX_KERNEL_SACKS) {
    5a60:	83 7d f0 3f          	cmpl   $0x3f,0xfffffff0(%ebp)
    5a64:	7e 0c                	jle    5a72 <AckProof_update+0x3c5>
		//printk("exceeded # of sacks while updating sack\n");
		return 0;
    5a66:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
    5a6d:	e9 f7 01 00 00       	jmp    5c69 <AckProof_update+0x5bc>
	}
	/* Cannot extend any sack ; create new one */
	/* seq is between i-1 and i; shift upwards all sacks i and up */
	for(j=MIN(*numSacks, MAX_KERNEL_SACKS-1); j > i; j--) {
    5a72:	c7 45 dc 3f 00 00 00 	movl   $0x3f,0xffffffdc(%ebp)
    5a79:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    5a7c:	8b 00                	mov    (%eax),%eax
    5a7e:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    5a81:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    5a84:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
    5a87:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    5a8a:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    5a8d:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
    5a90:	3b 55 d8             	cmp    0xffffffd8(%ebp),%edx
    5a93:	7e 06                	jle    5a9b <AckProof_update+0x3ee>
    5a95:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    5a98:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    5a9b:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
    5a9e:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
    5aa1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    5aa4:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
    5aa7:	7f 02                	jg     5aab <AckProof_update+0x3fe>
    5aa9:	eb 3f                	jmp    5aea <AckProof_update+0x43d>
		sacks[j] = sacks[j-1];
    5aab:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    5aae:	89 d0                	mov    %edx,%eax
    5ab0:	01 c0                	add    %eax,%eax
    5ab2:	01 d0                	add    %edx,%eax
    5ab4:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    5abb:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
    5abe:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    5ac1:	89 d0                	mov    %edx,%eax
    5ac3:	01 c0                	add    %eax,%eax
    5ac5:	01 d0                	add    %edx,%eax
    5ac7:	c1 e0 02             	shl    $0x2,%eax
    5aca:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    5acd:	8d 50 f4             	lea    0xfffffff4(%eax),%edx
    5ad0:	8b 02                	mov    (%edx),%eax
    5ad2:	89 04 19             	mov    %eax,(%ecx,%ebx,1)
    5ad5:	8b 42 04             	mov    0x4(%edx),%eax
    5ad8:	89 44 19 04          	mov    %eax,0x4(%ecx,%ebx,1)
    5adc:	8b 42 08             	mov    0x8(%edx),%eax
    5adf:	89 44 19 08          	mov    %eax,0x8(%ecx,%ebx,1)
    5ae3:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
    5ae6:	ff 08                	decl   (%eax)
    5ae8:	eb b7                	jmp    5aa1 <AckProof_update+0x3f4>
	}
	sacks[i].left = sacks[i].right = seq;
    5aea:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5aed:	89 d0                	mov    %edx,%eax
    5aef:	01 c0                	add    %eax,%eax
    5af1:	01 d0                	add    %edx,%eax
    5af3:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    5afa:	8b 75 e0             	mov    0xffffffe0(%ebp),%esi
    5afd:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5b00:	89 d0                	mov    %edx,%eax
    5b02:	01 c0                	add    %eax,%eax
    5b04:	01 d0                	add    %edx,%eax
    5b06:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    5b0d:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    5b10:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    5b13:	89 44 0a 04          	mov    %eax,0x4(%edx,%ecx,1)
    5b17:	89 04 1e             	mov    %eax,(%esi,%ebx,1)
	sacks[i].nonceSummary = cont->cum_nonce;
    5b1a:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5b1d:	89 d0                	mov    %edx,%eax
    5b1f:	01 c0                	add    %eax,%eax
    5b21:	01 d0                	add    %edx,%eax
    5b23:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    5b2a:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    5b2d:	8b 45 10             	mov    0x10(%ebp),%eax
    5b30:	8b 40 2c             	mov    0x2c(%eax),%eax
    5b33:	89 44 0a 08          	mov    %eax,0x8(%edx,%ecx,1)
	*numSacks = MIN(*numSacks+1, MAX_KERNEL_SACKS);
    5b37:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    5b3a:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
    5b3d:	c7 45 d4 40 00 00 00 	movl   $0x40,0xffffffd4(%ebp)
    5b44:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    5b47:	8b 00                	mov    (%eax),%eax
    5b49:	40                   	inc    %eax
    5b4a:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    5b4d:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    5b50:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    5b53:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    5b56:	89 55 c4             	mov    %edx,0xffffffc4(%ebp)
    5b59:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    5b5c:	3b 45 d8             	cmp    0xffffffd8(%ebp),%eax
    5b5f:	7e 06                	jle    5b67 <AckProof_update+0x4ba>
    5b61:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    5b64:	89 55 c4             	mov    %edx,0xffffffc4(%ebp)
    5b67:	8b 55 c4             	mov    0xffffffc4(%ebp),%edx
    5b6a:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    5b6d:	89 10                	mov    %edx,(%eax)
	/* Sanity checks */
	BUG_TRAP(i == *numSacks-1 || (sacks[i].right != sacks[i+1].left - 1 &&
				      sacks[i].right < sacks[i+1].left));
    5b6f:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    5b72:	8b 00                	mov    (%eax),%eax
    5b74:	48                   	dec    %eax
    5b75:	39 45 f0             	cmp    %eax,0xfffffff0(%ebp)
    5b78:	74 71                	je     5beb <AckProof_update+0x53e>
    5b7a:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5b7d:	89 d0                	mov    %edx,%eax
    5b7f:	01 c0                	add    %eax,%eax
    5b81:	01 d0                	add    %edx,%eax
    5b83:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    5b8a:	8b 5d e0             	mov    0xffffffe0(%ebp),%ebx
    5b8d:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5b90:	89 d0                	mov    %edx,%eax
    5b92:	01 c0                	add    %eax,%eax
    5b94:	01 d0                	add    %edx,%eax
    5b96:	c1 e0 02             	shl    $0x2,%eax
    5b99:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    5b9c:	83 c0 0c             	add    $0xc,%eax
    5b9f:	8b 00                	mov    (%eax),%eax
    5ba1:	48                   	dec    %eax
    5ba2:	39 44 0b 04          	cmp    %eax,0x4(%ebx,%ecx,1)
    5ba6:	74 2f                	je     5bd7 <AckProof_update+0x52a>
    5ba8:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5bab:	89 d0                	mov    %edx,%eax
    5bad:	01 c0                	add    %eax,%eax
    5baf:	01 d0                	add    %edx,%eax
    5bb1:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    5bb8:	8b 5d e0             	mov    0xffffffe0(%ebp),%ebx
    5bbb:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5bbe:	89 d0                	mov    %edx,%eax
    5bc0:	01 c0                	add    %eax,%eax
    5bc2:	01 d0                	add    %edx,%eax
    5bc4:	c1 e0 02             	shl    $0x2,%eax
    5bc7:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    5bca:	8d 50 0c             	lea    0xc(%eax),%edx
    5bcd:	8b 44 0b 04          	mov    0x4(%ebx,%ecx,1),%eax
    5bd1:	3b 02                	cmp    (%edx),%eax
    5bd3:	73 02                	jae    5bd7 <AckProof_update+0x52a>
    5bd5:	eb 14                	jmp    5beb <AckProof_update+0x53e>
    5bd7:	c7 44 24 04 65 0e 00 	movl   $0xe65,0x4(%esp,1)
    5bde:	00 
    5bdf:	c7 04 24 80 23 00 00 	movl   $0x2380,(%esp,1)
    5be6:	e8 fc ff ff ff       	call   5be7 <AckProof_update+0x53a>
	BUG_TRAP(i == 0 || (sacks[i-1].right != sacks[i].left - 1 &&
			    sacks[i-1].right < sacks[i].left));
    5beb:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
    5bef:	74 71                	je     5c62 <AckProof_update+0x5b5>
    5bf1:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5bf4:	89 d0                	mov    %edx,%eax
    5bf6:	01 c0                	add    %eax,%eax
    5bf8:	01 d0                	add    %edx,%eax
    5bfa:	c1 e0 02             	shl    $0x2,%eax
    5bfd:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    5c00:	8d 48 f4             	lea    0xfffffff4(%eax),%ecx
    5c03:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5c06:	89 d0                	mov    %edx,%eax
    5c08:	01 c0                	add    %eax,%eax
    5c0a:	01 d0                	add    %edx,%eax
    5c0c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5c13:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    5c16:	8b 04 10             	mov    (%eax,%edx,1),%eax
    5c19:	48                   	dec    %eax
    5c1a:	39 41 04             	cmp    %eax,0x4(%ecx)
    5c1d:	74 2f                	je     5c4e <AckProof_update+0x5a1>
    5c1f:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5c22:	89 d0                	mov    %edx,%eax
    5c24:	01 c0                	add    %eax,%eax
    5c26:	01 d0                	add    %edx,%eax
    5c28:	c1 e0 02             	shl    $0x2,%eax
    5c2b:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    5c2e:	8d 58 f4             	lea    0xfffffff4(%eax),%ebx
    5c31:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    5c34:	89 d0                	mov    %edx,%eax
    5c36:	01 c0                	add    %eax,%eax
    5c38:	01 d0                	add    %edx,%eax
    5c3a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    5c41:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    5c44:	8b 43 04             	mov    0x4(%ebx),%eax
    5c47:	3b 04 0a             	cmp    (%edx,%ecx,1),%eax
    5c4a:	73 02                	jae    5c4e <AckProof_update+0x5a1>
    5c4c:	eb 14                	jmp    5c62 <AckProof_update+0x5b5>
    5c4e:	c7 44 24 04 67 0e 00 	movl   $0xe67,0x4(%esp,1)
    5c55:	00 
    5c56:	c7 04 24 20 24 00 00 	movl   $0x2420,(%esp,1)
    5c5d:	e8 fc ff ff ff       	call   5c5e <AckProof_update+0x5b1>

	return 1;
    5c62:	c7 45 d0 01 00 00 00 	movl   $0x1,0xffffffd0(%ebp)
}
    5c69:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    5c6c:	83 c4 38             	add    $0x38,%esp
    5c6f:	5b                   	pop    %ebx
    5c70:	5e                   	pop    %esi
    5c71:	5f                   	pop    %edi
    5c72:	5d                   	pop    %ebp
    5c73:	c3                   	ret    

00005c74 <findAckables>:


static int findAckables(struct sock *sk, int skip, struct sk_buff **skip_skb) {
    5c74:	55                   	push   %ebp
    5c75:	89 e5                	mov    %esp,%ebp
    5c77:	83 ec 20             	sub    $0x20,%esp
	// skip == 1 if we are to ignore leading missing packets (loss assumed)
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    5c7a:	8b 45 08             	mov    0x8(%ebp),%eax
    5c7d:	05 bc 00 00 00       	add    $0xbc,%eax
    5c82:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	int progress = 0;
    5c85:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
	struct sk_buff *skb = skb_peek(&tp->t.ofo_queue);
    5c8c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    5c8f:	05 e8 02 00 00       	add    $0x2e8,%eax
    5c94:	89 04 24             	mov    %eax,(%esp,1)
    5c97:	e8 31 31 00 00       	call   8dcd <skb_peek>
    5c9c:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	if(skip_skb) *skip_skb = NULL;
    5c9f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    5ca3:	74 09                	je     5cae <findAckables+0x3a>
    5ca5:	8b 45 10             	mov    0x10(%ebp),%eax
    5ca8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	// 0419 special case - if ack_curr is set (due to recovery), we've already made progress in finding an ackable continuation
#if 0
	// 0501 - don't call findAckable when exiting recovery
	if(tp->t.ack_prev == NULL && tp->t.cont_list.len >= 1) {
		progress = 1;
		goto done;
	}
#endif

	if(tp->t.ack_last < tp->t.rcv_nxt) {
    5cae:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    5cb1:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    5cb4:	8b 80 f8 02 00 00    	mov    0x2f8(%eax),%eax
    5cba:	3b 82 e0 02 00 00    	cmp    0x2e0(%edx),%eax
    5cc0:	7d 19                	jge    5cdb <findAckables+0x67>
		tp->t.ack_last = tp->t.rcv_nxt;
    5cc2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    5cc5:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    5cc8:	8b 92 e0 02 00 00    	mov    0x2e0(%edx),%edx
    5cce:	89 90 f8 02 00 00    	mov    %edx,0x2f8(%eax)
		progress = 1;
    5cd4:	c7 45 f8 01 00 00 00 	movl   $0x1,0xfffffff8(%ebp)
	}
	if(skb) {
    5cdb:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
    5cdf:	0f 84 25 01 00 00    	je     5e0a <findAckables+0x196>
		if(!progress && skip) {
    5ce5:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    5ce9:	0f 85 c9 00 00 00    	jne    5db8 <findAckables+0x144>
    5cef:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    5cf3:	0f 84 bf 00 00 00    	je     5db8 <findAckables+0x144>
			while((struct sk_buff_head*)skb != &tp->t.ofo_queue &&
    5cf9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    5cfc:	05 e8 02 00 00       	add    $0x2e8,%eax
    5d01:	39 45 f4             	cmp    %eax,0xfffffff4(%ebp)
    5d04:	74 20                	je     5d26 <findAckables+0xb2>
    5d06:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    5d09:	83 c0 30             	add    $0x30,%eax
    5d0c:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    5d0f:	8b 40 24             	mov    0x24(%eax),%eax
    5d12:	3b 82 f8 02 00 00    	cmp    0x2f8(%edx),%eax
    5d18:	72 02                	jb     5d1c <findAckables+0xa8>
    5d1a:	eb 0a                	jmp    5d26 <findAckables+0xb2>
			      TCP_SKB_CB(skb)->trickle_seq < tp->t.ack_last) {
				skb = skb->next;
    5d1c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    5d1f:	8b 00                	mov    (%eax),%eax
    5d21:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    5d24:	eb d3                	jmp    5cf9 <findAckables+0x85>
			}
			if((struct sk_buff_head*)skb == &tp->t.ofo_queue) return 0 /* no progress*/;
    5d26:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    5d29:	05 e8 02 00 00       	add    $0x2e8,%eax
    5d2e:	39 45 f4             	cmp    %eax,0xfffffff4(%ebp)
    5d31:	75 0c                	jne    5d3f <findAckables+0xcb>
    5d33:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
    5d3a:	e9 d1 00 00 00       	jmp    5e10 <findAckables+0x19c>
			if(0 || clientDebugLevel >= 2)
    5d3f:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    5d46:	7e 4e                	jle    5d96 <findAckables+0x122>
				printk("ack_last skipped over gap: %u - %u\n",
    5d48:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    5d4b:	83 c0 30             	add    $0x30,%eax
    5d4e:	8b 40 24             	mov    0x24(%eax),%eax
    5d51:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    5d55:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    5d58:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    5d5b:	05 e8 02 00 00       	add    $0x2e8,%eax
    5d60:	39 42 04             	cmp    %eax,0x4(%edx)
    5d63:	74 11                	je     5d76 <findAckables+0x102>
    5d65:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    5d68:	8b 40 04             	mov    0x4(%eax),%eax
    5d6b:	83 c0 30             	add    $0x30,%eax
    5d6e:	8b 40 24             	mov    0x24(%eax),%eax
    5d71:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    5d74:	eb 0d                	jmp    5d83 <findAckables+0x10f>
    5d76:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    5d79:	8b 80 e0 02 00 00    	mov    0x2e0(%eax),%eax
    5d7f:	48                   	dec    %eax
    5d80:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    5d83:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    5d86:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    5d8a:	c7 04 24 c0 24 00 00 	movl   $0x24c0,(%esp,1)
    5d91:	e8 fc ff ff ff       	call   5d92 <findAckables+0x11e>
				       (struct sk_buff_head*)skb->prev != &tp->t.ofo_queue ?
				       TCP_SKB_CB(skb->prev)->trickle_seq :
				       tp->t.rcv_nxt - 1, TCP_SKB_CB(skb)->trickle_seq);
			tp->t.ack_last = TCP_SKB_CB(skb)->trickle_seq + 1;
    5d96:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    5d99:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    5d9c:	83 c0 30             	add    $0x30,%eax
    5d9f:	8b 40 24             	mov    0x24(%eax),%eax
    5da2:	40                   	inc    %eax
    5da3:	89 82 f8 02 00 00    	mov    %eax,0x2f8(%edx)
			*skip_skb = skb;
    5da9:	8b 55 10             	mov    0x10(%ebp),%edx
    5dac:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    5daf:	89 02                	mov    %eax,(%edx)
			progress = 1;
    5db1:	c7 45 f8 01 00 00 00 	movl   $0x1,0xfffffff8(%ebp)
    5db8:	90                   	nop    
		}
		while((struct sk_buff_head*)skb != &tp->t.ofo_queue &&
    5db9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    5dbc:	05 e8 02 00 00       	add    $0x2e8,%eax
    5dc1:	39 45 f4             	cmp    %eax,0xfffffff4(%ebp)
    5dc4:	74 44                	je     5e0a <findAckables+0x196>
    5dc6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    5dc9:	83 c0 30             	add    $0x30,%eax
    5dcc:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    5dcf:	8b 40 24             	mov    0x24(%eax),%eax
    5dd2:	3b 82 f8 02 00 00    	cmp    0x2f8(%edx),%eax
    5dd8:	76 02                	jbe    5ddc <findAckables+0x168>
    5dda:	eb 2e                	jmp    5e0a <findAckables+0x196>
		      TCP_SKB_CB(skb)->trickle_seq <= tp->t.ack_last) {
			if(tp->t.ack_last == TCP_SKB_CB(skb)->trickle_seq) {
    5ddc:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    5ddf:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    5de2:	83 c2 30             	add    $0x30,%edx
    5de5:	8b 80 f8 02 00 00    	mov    0x2f8(%eax),%eax
    5deb:	3b 42 24             	cmp    0x24(%edx),%eax
    5dee:	75 10                	jne    5e00 <findAckables+0x18c>
				tp->t.ack_last++;
    5df0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    5df3:	ff 80 f8 02 00 00    	incl   0x2f8(%eax)
				progress = 1;
    5df9:	c7 45 f8 01 00 00 00 	movl   $0x1,0xfffffff8(%ebp)
			}
			skb = skb->next;
    5e00:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    5e03:	8b 00                	mov    (%eax),%eax
    5e05:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    5e08:	eb af                	jmp    5db9 <findAckables+0x145>
		}
	}
#if 0
 done:
#endif
	return progress;
    5e0a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    5e0d:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
}
    5e10:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    5e13:	c9                   	leave  
    5e14:	c3                   	ret    

00005e15 <findUCContinuation>:

 struct UC_Continuation *findUCContinuation(struct sock *sk, unsigned start, unsigned end) {
    5e15:	55                   	push   %ebp
    5e16:	89 e5                	mov    %esp,%ebp
    5e18:	83 ec 34             	sub    $0x34,%esp
	 /* XXX use faster datastructure/algorithms? */

	 struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    5e1b:	8b 45 08             	mov    0x8(%ebp),%eax
    5e1e:	05 bc 00 00 00       	add    $0xbc,%eax
    5e23:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	 struct UC_Continuation *ucont = (struct UC_Continuation*)tp->t.ucontList.next,
    5e26:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    5e29:	8b 80 04 0a 00 00    	mov    0xa04(%eax),%eax
    5e2f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
		 *candidate = NULL;
    5e32:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
	 int found = 0;
    5e39:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)

#if 0
	 while(ucont != (struct UC_Continuation *)&tp->t.ucontList) {
		 if(ucont->validStart <= start) {
			 if(end <= ucont->validEnd) {
				 // perfect fit
				 found = 1;
				 candidate = ucont;
				 break;
			 }
			 if(candidate == NULL) {
				 candidate = ucont;
			 } else if(ucont->validEnd > candidate->validEnd) {
				 // better fit than previous candidate
				 candidate = ucont;
			 }
		 }
		 ucont = (struct UC_Continuation*)ucont->next;
	 }
#else
	 // return continuation with maximum overlap
	 int overlapSize = 0;
    5e40:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
	 while(ucont != (struct UC_Continuation *)&tp->t.ucontList) {
    5e47:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    5e4a:	05 00 0a 00 00       	add    $0xa00,%eax
    5e4f:	39 45 f8             	cmp    %eax,0xfffffff8(%ebp)
    5e52:	75 05                	jne    5e59 <findUCContinuation+0x44>
    5e54:	e9 ec 00 00 00       	jmp    5f45 <findUCContinuation+0x130>
#ifdef FINDUC_DBG
		 printk("Considering %p: [%d-%d]\n", ucont,
			ucont->validStart, ucont->validEnd);
#endif
		 int overlapStart = MAX(ucont->validStart, start);
    5e59:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e5c:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    5e5f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    5e62:	8b 40 10             	mov    0x10(%eax),%eax
    5e65:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    5e68:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    5e6b:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    5e6e:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    5e71:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    5e74:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    5e77:	3b 45 e0             	cmp    0xffffffe0(%ebp),%eax
    5e7a:	73 06                	jae    5e82 <findUCContinuation+0x6d>
    5e7c:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    5e7f:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    5e82:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    5e85:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
		 int overlapEnd = MIN(ucont->validEnd, end);
    5e88:	8b 45 10             	mov    0x10(%ebp),%eax
    5e8b:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    5e8e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    5e91:	8b 40 14             	mov    0x14(%eax),%eax
    5e94:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    5e97:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    5e9a:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    5e9d:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    5ea0:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    5ea3:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    5ea6:	3b 45 e4             	cmp    0xffffffe4(%ebp),%eax
    5ea9:	76 06                	jbe    5eb1 <findUCContinuation+0x9c>
    5eab:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    5eae:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    5eb1:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    5eb4:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
		 int zerolenOK = start == end;
    5eb7:	8b 45 0c             	mov    0xc(%ebp),%eax
    5eba:	3b 45 10             	cmp    0x10(%ebp),%eax
    5ebd:	0f 94 c0             	sete   %al
    5ec0:	0f b6 c0             	movzbl %al,%eax
    5ec3:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
		 int curr_overlapSize = overlapEnd - overlapStart;
    5ec6:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    5ec9:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    5ecc:	29 d0                	sub    %edx,%eax
    5ece:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
		 if(overlapStart > start || overlapStart > overlapEnd ||
    5ed1:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    5ed4:	3b 45 0c             	cmp    0xc(%ebp),%eax
    5ed7:	77 5e                	ja     5f37 <findUCContinuation+0x122>
    5ed9:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    5edc:	3b 45 dc             	cmp    0xffffffdc(%ebp),%eax
    5edf:	7f 56                	jg     5f37 <findUCContinuation+0x122>
    5ee1:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
    5ee5:	75 08                	jne    5eef <findUCContinuation+0xda>
    5ee7:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
    5eeb:	75 02                	jne    5eef <findUCContinuation+0xda>
		    (!zerolenOK && curr_overlapSize == 0)) {
#ifdef FINDUC_DBG
			 printk("skipped overlap = [%d=%d]\n",
				overlapStart, overlapEnd);
#endif
			 goto next;
    5eed:	eb 48                	jmp    5f37 <findUCContinuation+0x122>
		 }

		 if(overlapEnd == end) {
    5eef:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    5ef2:	3b 45 10             	cmp    0x10(%ebp),%eax
    5ef5:	75 0f                	jne    5f06 <findUCContinuation+0xf1>
			 // done, found perfect fit
			 found = 1;
    5ef7:	c7 45 f0 01 00 00 00 	movl   $0x1,0xfffffff0(%ebp)
#ifdef FINDUC_DBG
			 printk("perfect fit, set to %p\n", ucont);
#endif
			 candidate = ucont;
    5efe:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    5f01:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
			 break;
    5f04:	eb 3f                	jmp    5f45 <findUCContinuation+0x130>
		 }
		 if((curr_overlapSize > 0 || zerolenOK) &&
    5f06:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
    5f0a:	7f 08                	jg     5f14 <findUCContinuation+0xff>
    5f0c:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
    5f10:	75 02                	jne    5f14 <findUCContinuation+0xff>
    5f12:	eb 23                	jmp    5f37 <findUCContinuation+0x122>
    5f14:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
    5f18:	74 0a                	je     5f24 <findUCContinuation+0x10f>
    5f1a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    5f1d:	3b 45 e0             	cmp    0xffffffe0(%ebp),%eax
    5f20:	7c 02                	jl     5f24 <findUCContinuation+0x10f>
    5f22:	eb 13                	jmp    5f37 <findUCContinuation+0x122>
		    (candidate == NULL || overlapSize < curr_overlapSize)) {
#ifdef FINDUC_DBG
			 printk("%d %d candidate set to %p\n", overlapSize,
				curr_overlapSize, ucont);
#endif
			 found = 1;
    5f24:	c7 45 f0 01 00 00 00 	movl   $0x1,0xfffffff0(%ebp)
			 overlapSize = curr_overlapSize;
    5f2b:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    5f2e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
			 candidate = ucont;
    5f31:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    5f34:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		 }
	 next:
#ifdef FINDUC_DBG
		 printk("next\n");
#endif
		 ucont = (struct UC_Continuation*)ucont->next;
    5f37:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    5f3a:	8b 40 04             	mov    0x4(%eax),%eax
    5f3d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    5f40:	e9 02 ff ff ff       	jmp    5e47 <findUCContinuation+0x32>
	 }
#endif
#ifdef FINDUC_DBG
	 printk("uc_continuation: [%d-%d] ", start, end);
#endif
	 if(!found) {
    5f45:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
    5f49:	75 09                	jne    5f54 <findUCContinuation+0x13f>
#ifdef FINDUC_DBG
		 printk("not found\n");
#endif
		 return NULL;
    5f4b:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
    5f52:	eb 06                	jmp    5f5a <findUCContinuation+0x145>
	 }
#ifdef FINDUC_DBG
	 printk("%p [%d-%d]\n", candidate, candidate->validStart,
		candidate->validEnd);
#endif

	 return candidate;
    5f54:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    5f57:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
 }
    5f5a:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    5f5d:	c9                   	leave  
    5f5e:	c3                   	ret    

00005f5f <startSimulation>:

struct sk_buff *startSimulation(struct sock *sk, CONTINUATION_TYPE *cont, struct sk_buff *skb) {
    5f5f:	55                   	push   %ebp
    5f60:	89 e5                	mov    %esp,%ebp
    5f62:	83 ec 14             	sub    $0x14,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    5f65:	8b 45 08             	mov    0x8(%ebp),%eax
    5f68:	05 bc 00 00 00       	add    $0xbc,%eax
    5f6d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	struct sk_buff *result = skb_copy(skb, GFP_ATOMIC);
    5f70:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    5f77:	00 
    5f78:	8b 45 10             	mov    0x10(%ebp),%eax
    5f7b:	89 04 24             	mov    %eax,(%esp,1)
    5f7e:	e8 fc ff ff ff       	call   5f7f <startSimulation+0x20>
    5f83:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	if(result == NULL) {
    5f86:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    5f8a:	75 09                	jne    5f95 <startSimulation+0x36>
		return NULL;
    5f8c:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
    5f93:	eb 63                	jmp    5ff8 <startSimulation+0x99>
	}
	tp->t.responseMSK = cont;
    5f95:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    5f98:	8b 45 0c             	mov    0xc(%ebp),%eax
    5f9b:	89 82 64 0a 00 00    	mov    %eax,0xa64(%edx)
	tp->t.responseCount = 0;
    5fa1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    5fa4:	c7 80 7c 0a 00 00 00 	movl   $0x0,0xa7c(%eax)
    5fab:	00 00 00 

	BUG_TRAP(tp->t.responseList.len == 0);
    5fae:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    5fb1:	83 b8 78 0a 00 00 00 	cmpl   $0x0,0xa78(%eax)
    5fb8:	74 14                	je     5fce <startSimulation+0x6f>
    5fba:	c7 44 24 04 02 0f 00 	movl   $0xf02,0x4(%esp,1)
    5fc1:	00 
    5fc2:	c7 04 24 00 25 00 00 	movl   $0x2500,(%esp,1)
    5fc9:	e8 fc ff ff ff       	call   5fca <startSimulation+0x6b>
	init_head(&tp->t.responseList);
    5fce:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    5fd1:	05 68 0a 00 00       	add    $0xa68,%eax
    5fd6:	89 04 24             	mov    %eax,(%esp,1)
    5fd9:	e8 f5 31 00 00       	call   91d3 <init_head>

	result->h.th = NULL;
    5fde:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    5fe1:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
	result->nh.iph = NULL;
    5fe8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    5feb:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
	return result;
    5ff2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    5ff5:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
}
    5ff8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    5ffb:	c9                   	leave  
    5ffc:	c3                   	ret    

00005ffd <finishSimulation>:

void finishSimulation(struct sock *sk, CONTINUATION_TYPE *destCont, CONTINUATION_TYPE *simCont) {
    5ffd:	55                   	push   %ebp
    5ffe:	89 e5                	mov    %esp,%ebp
    6000:	56                   	push   %esi
    6001:	53                   	push   %ebx
    6002:	83 ec 20             	sub    $0x20,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    6005:	8b 45 08             	mov    0x8(%ebp),%eax
    6008:	05 bc 00 00 00       	add    $0xbc,%eax
    600d:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	CONTINUATION_TYPE *finger;
	if(tp->t.responseCount >= 1) {
    6010:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    6013:	83 b8 7c 0a 00 00 00 	cmpl   $0x0,0xa7c(%eax)
    601a:	0f 8e f1 00 00 00    	jle    6111 <finishSimulation+0x114>
		int totalDataLen = 0;
    6020:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
		int i;
		BUG_TRAP(simCont == tp->t.responseMSK);
    6027:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    602a:	8b 45 10             	mov    0x10(%ebp),%eax
    602d:	3b 82 64 0a 00 00    	cmp    0xa64(%edx),%eax
    6033:	74 14                	je     6049 <finishSimulation+0x4c>
    6035:	c7 44 24 04 10 0f 00 	movl   $0xf10,0x4(%esp,1)
    603c:	00 
    603d:	c7 04 24 60 25 00 00 	movl   $0x2560,(%esp,1)
    6044:	e8 fc ff ff ff       	call   6045 <finishSimulation+0x48>
		for(i=0; i < simCont->num_packets; i++) {
    6049:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
    6050:	8b 55 10             	mov    0x10(%ebp),%edx
    6053:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    6056:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
    605c:	7c 05                	jl     6063 <finishSimulation+0x66>
    605e:	e9 85 00 00 00       	jmp    60e8 <finishSimulation+0xeb>
			totalDataLen += simCont->packets[i].len;
    6063:	8b 4d 10             	mov    0x10(%ebp),%ecx
    6066:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    6069:	89 d0                	mov    %edx,%eax
    606b:	c1 e0 03             	shl    $0x3,%eax
    606e:	01 d0                	add    %edx,%eax
    6070:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6077:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
    607d:	8b 54 10 08          	mov    0x8(%eax,%edx,1),%edx
    6081:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
    6084:	01 10                	add    %edx,(%eax)
			simCont->packets[i].contType &= ~CONTTYPE_HASHCOMPRESSED;
    6086:	8b 4d 10             	mov    0x10(%ebp),%ecx
    6089:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    608c:	89 d0                	mov    %edx,%eax
    608e:	c1 e0 03             	shl    $0x3,%eax
    6091:	01 d0                	add    %edx,%eax
    6093:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    609a:	8b b1 ec 00 00 00    	mov    0xec(%ecx),%esi
    60a0:	8b 4d 10             	mov    0x10(%ebp),%ecx
    60a3:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    60a6:	89 d0                	mov    %edx,%eax
    60a8:	c1 e0 03             	shl    $0x3,%eax
    60ab:	01 d0                	add    %edx,%eax
    60ad:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    60b4:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
    60ba:	0f b6 44 10 0c       	movzbl 0xc(%eax,%edx,1),%eax
    60bf:	c0 e8 03             	shr    $0x3,%al
    60c2:	88 c2                	mov    %al,%dl
    60c4:	80 e2 07             	and    $0x7,%dl
    60c7:	b0 7f                	mov    $0x7f,%al
    60c9:	20 c2                	and    %al,%dl
    60cb:	0f b6 44 1e 0c       	movzbl 0xc(%esi,%ebx,1),%eax
    60d0:	80 e2 07             	and    $0x7,%dl
    60d3:	c0 e2 03             	shl    $0x3,%dl
    60d6:	24 c7                	and    $0xc7,%al
    60d8:	08 d0                	or     %dl,%al
    60da:	88 44 1e 0c          	mov    %al,0xc(%esi,%ebx,1)
    60de:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
    60e1:	ff 00                	incl   (%eax)
    60e3:	e9 68 ff ff ff       	jmp    6050 <finishSimulation+0x53>
		}

#if 0 // 0822 -- use packets directly rather than minresponselen
		destCont->minResponseLen = totalDataLen;
#ifdef MIN_RESPONSELEN_ADJ_HACK
		destCont->minResponseLen = MAX(0, destCont->minResponseLen - MIN_RESPONSELEN_ADJ_HACK);
#endif
#ifdef MIN_RESPONSELEN_ADJUP_TEST
		destCont->minResponseLen += 200;
#endif
#endif  // 0822
		destCont->firstTransportChild = simCont->packets[0].seq;
    60e8:	8b 55 0c             	mov    0xc(%ebp),%edx
    60eb:	8b 45 10             	mov    0x10(%ebp),%eax
    60ee:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
    60f4:	8b 40 04             	mov    0x4(%eax),%eax
    60f7:	89 82 c4 00 00 00    	mov    %eax,0xc4(%edx)
		destCont->numTransportChildren = simCont->num_packets;
    60fd:	8b 55 0c             	mov    0xc(%ebp),%edx
    6100:	8b 45 10             	mov    0x10(%ebp),%eax
    6103:	8b 80 e8 00 00 00    	mov    0xe8(%eax),%eax
    6109:	89 82 c8 00 00 00    	mov    %eax,0xc8(%edx)
    610f:	eb 27                	jmp    6138 <finishSimulation+0x13b>
	} else {
		//printk("No simulation output (could be harmless, e.g. during fast recovery!!\n");
#if 0 // 0822
		destCont->minResponseLen = 0;
#endif
		destCont->firstTransportChild = 0;
    6111:	8b 45 0c             	mov    0xc(%ebp),%eax
    6114:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    611b:	00 00 00 
		destCont->numTransportChildren = 0;
    611e:	8b 45 0c             	mov    0xc(%ebp),%eax
    6121:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%eax)
    6128:	00 00 00 
		destCont->mark = -1;
    612b:	8b 45 0c             	mov    0xc(%ebp),%eax
    612e:	c7 80 e4 00 00 00 ff 	movl   $0xffffffff,0xe4(%eax)
    6135:	ff ff ff 
	}
	finger = (CONTINUATION_TYPE*)tp->t.responseList.next;
    6138:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    613b:	8b 80 6c 0a 00 00    	mov    0xa6c(%eax),%eax
    6141:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	while(finger != (CONTINUATION_TYPE*)&tp->t.responseList) {
    6144:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    6147:	05 68 0a 00 00       	add    $0xa68,%eax
    614c:	39 45 f0             	cmp    %eax,0xfffffff0(%ebp)
    614f:	75 02                	jne    6153 <finishSimulation+0x156>
    6151:	eb 7b                	jmp    61ce <finishSimulation+0x1d1>
		printk("responseListlen = %d\n", tp->t.responseList.len);
    6153:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    6156:	8b 80 78 0a 00 00    	mov    0xa78(%eax),%eax
    615c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6160:	c7 04 24 ab 25 00 00 	movl   $0x25ab,(%esp,1)
    6167:	e8 fc ff ff ff       	call   6168 <finishSimulation+0x16b>
		printk("finger=%p (%p  %p)\n", finger, finger->prev, finger->next);
    616c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    616f:	8b 40 04             	mov    0x4(%eax),%eax
    6172:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    6176:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    6179:	8b 00                	mov    (%eax),%eax
    617b:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    617f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    6182:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6186:	c7 04 24 c1 25 00 00 	movl   $0x25c1,(%esp,1)
    618d:	e8 fc ff ff ff       	call   618e <finishSimulation+0x191>
		struct cminisock *clean = finger;
    6192:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    6195:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
		finger = finger->next;
    6198:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    619b:	8b 40 04             	mov    0x4(%eax),%eax
    619e:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
		unlinkCont(clean);
    61a1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    61a4:	89 04 24             	mov    %eax,(%esp,1)
    61a7:	e8 6d 4a 00 00       	call   ac19 <unlinkCont>
		MARK_PC(clean);
		free_minisock(sk, clean);
    61ac:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    61af:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    61b3:	8b 45 08             	mov    0x8(%ebp),%eax
    61b6:	89 04 24             	mov    %eax,(%esp,1)
    61b9:	e8 ba 44 00 00       	call   a678 <free_minisock>
		kfree(clean); // not a bug! alloc_trickles_msk creates the msk w/ kmalloc()
    61be:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    61c1:	89 04 24             	mov    %eax,(%esp,1)
    61c4:	e8 fc ff ff ff       	call   61c5 <finishSimulation+0x1c8>
    61c9:	e9 76 ff ff ff       	jmp    6144 <finishSimulation+0x147>
	}
	destCont->simulated = 1;
    61ce:	8b 45 0c             	mov    0xc(%ebp),%eax
    61d1:	c7 80 d8 00 00 00 01 	movl   $0x1,0xd8(%eax)
    61d8:	00 00 00 
}
    61db:	83 c4 20             	add    $0x20,%esp
    61de:	5b                   	pop    %ebx
    61df:	5e                   	pop    %esi
    61e0:	5d                   	pop    %ebp
    61e1:	c3                   	ret    

000061e2 <runSimulation>:

static int runSimulation(struct sock *sk, CONTINUATION_TYPE *cont, struct sk_buff *skb) {
    61e2:	55                   	push   %ebp
    61e3:	89 e5                	mov    %esp,%ebp
    61e5:	83 ec 1c             	sub    $0x1c,%esp
	struct sk_buff *scratchSkb = startSimulation(sk, cont + 1, skb);
    61e8:	8b 45 10             	mov    0x10(%ebp),%eax
    61eb:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    61ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    61f2:	05 fc 00 00 00       	add    $0xfc,%eax
    61f7:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    61fb:	8b 45 08             	mov    0x8(%ebp),%eax
    61fe:	89 04 24             	mov    %eax,(%esp,1)
    6201:	e8 fc ff ff ff       	call   6202 <runSimulation+0x20>
    6206:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	cont->source = sk->sport;
    6209:	8b 55 0c             	mov    0xc(%ebp),%edx
    620c:	8b 45 08             	mov    0x8(%ebp),%eax
    620f:	0f b7 40 22          	movzwl 0x22(%eax),%eax
    6213:	66 89 42 1c          	mov    %ax,0x1c(%edx)
	cont->dest = sk->dport;
    6217:	8b 55 0c             	mov    0xc(%ebp),%edx
    621a:	8b 45 08             	mov    0x8(%ebp),%eax
    621d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    6221:	66 89 42 1e          	mov    %ax,0x1e(%edx)
	//printk("%d %d\n", cont->source, cont->dest);
#if 0
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	if(IS_RECOVERY_STATE())
		printk("recovery simulation of seq = %d, rcvnxt = %d\n", cont->seq, tp->t.rcv_nxt);
#endif
	if(scratchSkb == NULL) {
    6225:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
    6229:	75 18                	jne    6243 <runSimulation+0x61>
		printk("Out of memory during simulation\n");
    622b:	c7 04 24 e0 25 00 00 	movl   $0x25e0,(%esp,1)
    6232:	e8 fc ff ff ff       	call   6233 <runSimulation+0x51>
		return 0;
    6237:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
    623e:	e9 9e 00 00 00       	jmp    62e1 <runSimulation+0xff>
	}

	int rval = server_rcv_impl(sk, scratchSkb);
    6243:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    6246:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    624a:	8b 45 08             	mov    0x8(%ebp),%eax
    624d:	89 04 24             	mov    %eax,(%esp,1)
    6250:	e8 fc ff ff ff       	call   6251 <runSimulation+0x6f>
    6255:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	// server_rcv_impl never deallocates skb
	__kfree_skb(scratchSkb);
    6258:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    625b:	89 04 24             	mov    %eax,(%esp,1)
    625e:	e8 fc ff ff ff       	call   625f <runSimulation+0x7d>
	if(rval == -EINVAL) {
    6263:	83 7d f8 ea          	cmpl   $0xffffffea,0xfffffff8(%ebp)
    6267:	75 27                	jne    6290 <runSimulation+0xae>
		if(!disableSevereErrors) {
			if(trickles_ratelimit()) {
				printk("simulation failure\n");
			}
		}
		finishSimulation(sk, cont, cont + 1);
    6269:	8b 45 0c             	mov    0xc(%ebp),%eax
    626c:	05 fc 00 00 00       	add    $0xfc,%eax
    6271:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    6275:	8b 45 0c             	mov    0xc(%ebp),%eax
    6278:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    627c:	8b 45 08             	mov    0x8(%ebp),%eax
    627f:	89 04 24             	mov    %eax,(%esp,1)
    6282:	e8 fc ff ff ff       	call   6283 <runSimulation+0xa1>
		return 0;
    6287:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
    628e:	eb 51                	jmp    62e1 <runSimulation+0xff>
	} else {
		if(rval != 0) {
			if(trickles_ratelimit()) {
				printk("simulation rval == %d\n", rval);
			}
		}
		// debugging
		struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    6290:	8b 45 08             	mov    0x8(%ebp),%eax
    6293:	05 bc 00 00 00       	add    $0xbc,%eax
    6298:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		tp->snd_cwnd = cont->actualCwnd;
    629b:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    629e:	8b 45 0c             	mov    0xc(%ebp),%eax
    62a1:	8b 80 e0 00 00 00    	mov    0xe0(%eax),%eax
    62a7:	89 82 94 00 00 00    	mov    %eax,0x94(%edx)
		tp->snd_ssthresh = cont->ssthresh;
    62ad:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    62b0:	8b 45 0c             	mov    0xc(%ebp),%eax
    62b3:	8b 40 68             	mov    0x68(%eax),%eax
    62b6:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
	}
	finishSimulation(sk, cont, cont + 1);
    62bc:	8b 45 0c             	mov    0xc(%ebp),%eax
    62bf:	05 fc 00 00 00       	add    $0xfc,%eax
    62c4:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    62c8:	8b 45 0c             	mov    0xc(%ebp),%eax
    62cb:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    62cf:	8b 45 08             	mov    0x8(%ebp),%eax
    62d2:	89 04 24             	mov    %eax,(%esp,1)
    62d5:	e8 fc ff ff ff       	call   62d6 <runSimulation+0xf4>
	return 1;
    62da:	c7 45 f0 01 00 00 00 	movl   $0x1,0xfffffff0(%ebp)
}
    62e1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    62e4:	c9                   	leave  
    62e5:	c3                   	ret    

000062e6 <sendAckHelper>:

#define USEFULNESS_THRESHOLD (1000) // don't use continuation unless we can receive at least this many bytes

#define PACKET_RESPONSE_LEN(CONT, P) 			\
	(( 0 <= (P) && (P) < SIMULATION_NUM_PACKETS(CONT)) ? SIMULATION_PACKETS(CONT)[(P)].len : 0)

#define OUT_FREE (-1)
#define OUT_FREE_IGNORE (-2)
#define OUT_NODATAREQUEST (-3)

// XXX XXX XXX XXX

// Out_NoDataRequest propagation is not 100% kosher. The
// implementation forces the state machine to unconditionally wait for
// the window to open. But the exception may potentially be thrown
// when the window is not empty.
// *** To save time, this is "Good Enough For Now"

#define PROPAGATE_ERR(STMT, STR, OFREE)					\
({									\
	int _rval = STMT;							\
	if(_rval != 0) {						\
		/* if(IS_RECOVERY_STATE())  printk("rval = %d\n", _rval); */ \
		/* if(( _rval == OUT_FREE_IGNORE) && trickles_ratelimit()) printk(STR, _rval);  */  \
		if(_rval == OUT_FREE) { OFREE; }  \
		if(_rval == OUT_FREE_IGNORE) { goto out_free_ignore_this_cont; }  \
		if(_rval == OUT_NODATAREQUEST) { goto no_data_request; }	\
	}								\
 })

static inline
int generateRequestsFromPending(struct sock *sk, struct sk_buff *skb,
			struct WireTrickleRequest *wreq,
			CONTINUATION_TYPE *cont);
static inline
int generateDataRequests(struct sock *sk, struct sk_buff *skb,
			struct WireTrickleRequest *wreq,
			CONTINUATION_TYPE *cont);

#define TICK() printk("sendackhelper @%d\n", __LINE__)
#define TICK()
static int sendAckHelper(struct sock *sk, CONTINUATION_TYPE *cont, enum TrickleRequestType type) {
    62e6:	55                   	push   %ebp
    62e7:	89 e5                	mov    %esp,%ebp
    62e9:	53                   	push   %ebx
    62ea:	83 ec 40             	sub    $0x40,%esp
	TICK();
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    62ed:	8b 45 08             	mov    0x8(%ebp),%eax
    62f0:	05 bc 00 00 00       	add    $0xbc,%eax
    62f5:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	struct sk_buff *skb;
	int res;
	static int packetID = 0;

	while((skb=__skb_dequeue(&tp->t.sendAckOverflow))) {
    62f8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    62fb:	05 4c 0a 00 00       	add    $0xa4c,%eax
    6300:	89 04 24             	mov    %eax,(%esp,1)
    6303:	e8 76 2b 00 00       	call   8e7e <__skb_dequeue>
    6308:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    630b:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
    630f:	75 02                	jne    6313 <sendAckHelper+0x2d>
    6311:	eb 6f                	jmp    6382 <sendAckHelper+0x9c>
		BUG_TRAP(skb->sk == sk);
    6313:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    6316:	8b 40 0c             	mov    0xc(%eax),%eax
    6319:	3b 45 08             	cmp    0x8(%ebp),%eax
    631c:	74 14                	je     6332 <sendAckHelper+0x4c>
    631e:	c7 44 24 04 91 0f 00 	movl   $0xf91,0x4(%esp,1)
    6325:	00 
    6326:	c7 04 24 20 26 00 00 	movl   $0x2620,(%esp,1)
    632d:	e8 fc ff ff ff       	call   632e <sendAckHelper+0x48>
		skb->sk = sk;
    6332:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    6335:	8b 45 08             	mov    0x8(%ebp),%eax
    6338:	89 42 0c             	mov    %eax,0xc(%edx)
		if((res = tp->af_specific->queue_xmit(skb, 0)) != 0) {
    633b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    633e:	8b 90 dc 00 00 00    	mov    0xdc(%eax),%edx
    6344:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    634b:	00 
    634c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    634f:	89 04 24             	mov    %eax,(%esp,1)
    6352:	8b 02                	mov    (%edx),%eax
    6354:	ff d0                	call   *%eax
    6356:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    6359:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
    635d:	74 99                	je     62f8 <sendAckHelper+0x12>
			if(trickles_ratelimit()) {
				printk("dropped while sending ack from overflow\n");
			}
			// push back
			__skb_queue_head(&tp->t.sendAckOverflow, skb);
    635f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    6362:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6366:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    6369:	05 4c 0a 00 00       	add    $0xa4c,%eax
    636e:	89 04 24             	mov    %eax,(%esp,1)
    6371:	e8 79 2a 00 00       	call   8def <__skb_queue_head>
			TICK();
			return 0;
    6376:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
    637d:	e9 fa 04 00 00       	jmp    687c <sendAckHelper+0x596>
		}
	}

#if 0 // 0420, tracking down source of order 4096 objects
	skb = alloc_skb(ETHERNET_MTU, GFP_ATOMIC);
#else
	skb = alloc_skb(MAX_TCP_HEADER + MAX_TRICKLES_CLIENT_HDR_LEN + TRICKLES_MSS, GFP_ATOMIC);
    6382:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    6389:	00 
    638a:	a1 00 00 00 00       	mov    0x0,%eax
    638f:	05 ee 03 00 00       	add    $0x3ee,%eax
    6394:	89 04 24             	mov    %eax,(%esp,1)
    6397:	e8 fc ff ff ff       	call   6398 <sendAckHelper+0xb2>
    639c:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
#endif
	WireTrickleRequest *wreq;
	int tcp_header_size;
	struct tcphdr *th;
	AckProof *proof;
	short windowValue = -1;
    639f:	66 c7 45 de ff ff    	movw   $0xffff,0xffffffde(%ebp)

	TIMING_CTX_DEF0("sendAckHelper", "sent", "didn't send", "inner0", "inner10", "inner11");
	TIMING_CTX_DEF1(6, 4, 2, 3, 3);
	reinitTimingCtx(&ctx);
	recordSample(&ctx,0);
	recordSample(&ctx,1);

	if(skb == NULL) {
    63a5:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
    63a9:	75 18                	jne    63c3 <sendAckHelper+0xdd>
		printk("sendAckHelper: out of memory\n");
    63ab:	c7 04 24 5c 26 00 00 	movl   $0x265c,(%esp,1)
    63b2:	e8 fc ff ff ff       	call   63b3 <sendAckHelper+0xcd>
		return 0;
    63b7:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
    63be:	e9 b9 04 00 00       	jmp    687c <sendAckHelper+0x596>
	}

	if(cont->state == CONT_BOOTSTRAP ||
    63c3:	8b 45 0c             	mov    0xc(%ebp),%eax
    63c6:	83 78 54 02          	cmpl   $0x2,0x54(%eax)
    63ca:	74 08                	je     63d4 <sendAckHelper+0xee>
    63cc:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    63d0:	74 02                	je     63d4 <sendAckHelper+0xee>
    63d2:	eb 2d                	jmp    6401 <sendAckHelper+0x11b>
	   type == TREQ_SLOWSTART) {
		proof = &tp->t.altProof;
    63d4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    63d7:	05 0c 06 00 00       	add    $0x60c,%eax
    63dc:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
		if(clientDebugLevel >= 2) {
    63df:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    63e6:	7e 24                	jle    640c <sendAckHelper+0x126>
			printk("sending alt proof\n");
    63e8:	c7 04 24 7a 26 00 00 	movl   $0x267a,(%esp,1)
    63ef:	e8 fc ff ff ff       	call   63f0 <sendAckHelper+0x10a>
			AckProof_dump(proof);
    63f4:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    63f7:	89 04 24             	mov    %eax,(%esp,1)
    63fa:	e8 fc ff ff ff       	call   63fb <sendAckHelper+0x115>
    63ff:	eb 0b                	jmp    640c <sendAckHelper+0x126>
		}
	} else {
		proof = &tp->t.standardProof;
    6401:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    6404:	05 04 03 00 00       	add    $0x304,%eax
    6409:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
	}

	skb_reserve(skb, MAX_TCP_HEADER);
    640c:	c7 44 24 04 a0 00 00 	movl   $0xa0,0x4(%esp,1)
    6413:	00 
    6414:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    6417:	89 04 24             	mov    %eax,(%esp,1)
    641a:	e8 50 2d 00 00       	call   916f <skb_reserve>
	wreq = (WireTrickleRequest *)skb_put(skb, sizeof(WireTrickleRequest) + proof->numSacks * sizeof(WireSack));
    641f:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    6422:	8b 10                	mov    (%eax),%edx
    6424:	89 d0                	mov    %edx,%eax
    6426:	01 c0                	add    %eax,%eax
    6428:	01 d0                	add    %edx,%eax
    642a:	c1 e0 02             	shl    $0x2,%eax
    642d:	83 c0 4e             	add    $0x4e,%eax
    6430:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6434:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    6437:	89 04 24             	mov    %eax,(%esp,1)
    643a:	e8 2c 2b 00 00       	call   8f6b <skb_put>
    643f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	//printk("sendackhelper - req: %p\n", &req->cont);

	wreq->type = type;
    6442:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    6445:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
    6449:	88 02                	mov    %al,(%edx)
	wreq->ucont_len = 0; // hack to make input to simulation well-formed
    644b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    644e:	66 c7 40 4b 00 00    	movw   $0x0,0x4b(%eax)
	recordSample(&ctx,0);
	recordSample(&ctx,1);

	__u32 oldClientTimestamp = cont->clientTimestamp ;
    6454:	8b 45 0c             	mov    0xc(%ebp),%eax
    6457:	8b 40 4c             	mov    0x4c(%eax),%eax
    645a:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
	__u32 oldClientState = cont->clientState;
    645d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6460:	8b 40 38             	mov    0x38(%eax),%eax
    6463:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
	cont->clientTimestamp = jiffies;
    6466:	8b 55 0c             	mov    0xc(%ebp),%edx
    6469:	a1 00 00 00 00       	mov    0x0,%eax
    646e:	89 42 4c             	mov    %eax,0x4c(%edx)
	cont->clientState = tp->t.clientStateCounter;
    6471:	8b 55 0c             	mov    0xc(%ebp),%edx
    6474:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    6477:	8b 80 c8 02 00 00    	mov    0x2c8(%eax),%eax
    647d:	89 42 38             	mov    %eax,0x38(%edx)
	marshallContinuationClient(sk,&wreq->cont,cont, -1);
    6480:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp,1)
    6487:	ff 
    6488:	8b 45 0c             	mov    0xc(%ebp),%eax
    648b:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    648f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    6492:	40                   	inc    %eax
    6493:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6497:	8b 45 08             	mov    0x8(%ebp),%eax
    649a:	89 04 24             	mov    %eax,(%esp,1)
    649d:	e8 54 34 00 00       	call   98f6 <marshallContinuationClient>
#ifdef ENABLE_HASHCOMPRESS
	// reset number of children that we have received
	cont->numChildrenReceived = 0;
	// dont restore the timestamp and client state; we need them when reconstructing the packet
#else
	cont->clientTimestamp = oldClientTimestamp;
    64a2:	8b 55 0c             	mov    0xc(%ebp),%edx
    64a5:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    64a8:	89 42 4c             	mov    %eax,0x4c(%edx)
	cont->clientState = oldClientState;
    64ab:	8b 55 0c             	mov    0xc(%ebp),%edx
    64ae:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    64b1:	89 42 38             	mov    %eax,0x38(%edx)
#endif

	marshallAckProof(&wreq->ackProof, proof);
    64b4:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    64b7:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    64bb:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    64be:	83 c0 4d             	add    $0x4d,%eax
    64c1:	89 04 24             	mov    %eax,(%esp,1)
    64c4:	e8 48 35 00 00       	call   9a11 <marshallAckProof>
	recordSample(&ctx,0);
	recordSample(&ctx,1);

#if 1
#define IN_WINDOW(SK, SEQ)	\
	((SEQ) < (SK)->tp_pinfo.af_tcp.rcv_nxt + (SK)->rcvbuf)
#else
#define IN_WINDOW(SK, SEQ)	\
	((SEQ) < (SK)->tp_pinfo.af_tcp.copied_seq + (SK)->rcvbuf)
#endif

	if(IS_SEND_UCONTREQ_STATE(tp)) {
    64c9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    64cc:	83 b8 cc 02 00 00 01 	cmpl   $0x1,0x2cc(%eax)
    64d3:	74 1d                	je     64f2 <sendAckHelper+0x20c>
    64d5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    64d8:	83 b8 cc 02 00 00 02 	cmpl   $0x2,0x2cc(%eax)
    64df:	74 11                	je     64f2 <sendAckHelper+0x20c>
    64e1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    64e4:	83 b8 cc 02 00 00 03 	cmpl   $0x3,0x2cc(%eax)
    64eb:	74 05                	je     64f2 <sendAckHelper+0x20c>
    64ed:	e9 0a 01 00 00       	jmp    65fc <sendAckHelper+0x316>
		// Only send requests in normal state
		// Manage reliable request queue here
		if(HAS_PENDING_REQUESTS(sk)) {
    64f2:	8b 45 08             	mov    0x8(%ebp),%eax
    64f5:	05 54 0a 00 00       	add    $0xa54,%eax
    64fa:	89 04 24             	mov    %eax,(%esp,1)
    64fd:	e8 bd 2c 00 00       	call   91bf <empty>
    6502:	85 c0                	test   %eax,%eax
    6504:	75 4c                	jne    6552 <sendAckHelper+0x26c>
#if 0
			if(IS_RECOVERY_STATE()) 	printk("trying to send pending request during recovery\n");
#endif
			TICK();
			PROPAGATE_ERR(generateRequestsFromPending(sk, skb, wreq, cont),
				      "generateRequestsFromPending returned error %d\n", goto try_data);
    6506:	8b 45 0c             	mov    0xc(%ebp),%eax
    6509:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    650d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    6510:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    6514:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    6517:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    651b:	8b 45 08             	mov    0x8(%ebp),%eax
    651e:	89 04 24             	mov    %eax,(%esp,1)
    6521:	e8 5f 03 00 00       	call   6885 <generateRequestsFromPending>
    6526:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    6529:	83 7d d0 00          	cmpl   $0x0,0xffffffd0(%ebp)
    652d:	0f 84 69 01 00 00    	je     669c <sendAckHelper+0x3b6>
    6533:	83 7d d0 ff          	cmpl   $0xffffffff,0xffffffd0(%ebp)
    6537:	75 02                	jne    653b <sendAckHelper+0x255>
    6539:	eb 17                	jmp    6552 <sendAckHelper+0x26c>
    653b:	83 7d d0 fe          	cmpl   $0xfffffffe,0xffffffd0(%ebp)
    653f:	75 05                	jne    6546 <sendAckHelper+0x260>
    6541:	e9 24 03 00 00       	jmp    686a <sendAckHelper+0x584>
    6546:	83 7d d0 fd          	cmpl   $0xfffffffd,0xffffffd0(%ebp)
    654a:	0f 85 4c 01 00 00    	jne    669c <sendAckHelper+0x3b6>
    6550:	eb 7b                	jmp    65cd <sendAckHelper+0x2e7>
			TICK();
		} else {
		try_data:
			if(IN_WINDOW(sk, tp->t.byteReqNext) ||
    6552:	8b 4d f8             	mov    0xfffffff8(%ebp),%ecx
    6555:	8b 55 08             	mov    0x8(%ebp),%edx
    6558:	8b 45 08             	mov    0x8(%ebp),%eax
    655b:	8b 40 38             	mov    0x38(%eax),%eax
    655e:	03 82 c4 00 00 00    	add    0xc4(%edx),%eax
    6564:	39 81 d4 09 00 00    	cmp    %eax,0x9d4(%ecx)
    656a:	72 14                	jb     6580 <sendAckHelper+0x29a>
    656c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    656f:	05 c0 09 00 00       	add    $0x9c0,%eax
    6574:	89 04 24             	mov    %eax,(%esp,1)
    6577:	e8 43 2c 00 00       	call   91bf <empty>
    657c:	85 c0                	test   %eax,%eax
    657e:	75 4d                	jne    65cd <sendAckHelper+0x2e7>
			   !empty(&tp->t.missingDataMap)) {
#if 0
				if(IS_RECOVERY_STATE()) printk("trying to send data request during recovery\n");
#endif
				TICK();
				PROPAGATE_ERR(generateDataRequests(sk, skb, wreq, cont),
					      "generateDataRequests returned error %d\n", goto out_free_error);
    6580:	8b 45 0c             	mov    0xc(%ebp),%eax
    6583:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    6587:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    658a:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    658e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    6591:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6595:	8b 45 08             	mov    0x8(%ebp),%eax
    6598:	89 04 24             	mov    %eax,(%esp,1)
    659b:	e8 97 0a 00 00       	call   7037 <generateDataRequests>
    65a0:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    65a3:	83 7d d0 00          	cmpl   $0x0,0xffffffd0(%ebp)
    65a7:	0f 84 ef 00 00 00    	je     669c <sendAckHelper+0x3b6>
    65ad:	83 7d d0 ff          	cmpl   $0xffffffff,0xffffffd0(%ebp)
    65b1:	75 05                	jne    65b8 <sendAckHelper+0x2d2>
    65b3:	e9 9e 02 00 00       	jmp    6856 <sendAckHelper+0x570>
    65b8:	83 7d d0 fe          	cmpl   $0xfffffffe,0xffffffd0(%ebp)
    65bc:	75 05                	jne    65c3 <sendAckHelper+0x2dd>
    65be:	e9 a7 02 00 00       	jmp    686a <sendAckHelper+0x584>
    65c3:	83 7d d0 fd          	cmpl   $0xfffffffd,0xffffffd0(%ebp)
    65c7:	0f 85 cf 00 00 00    	jne    669c <sendAckHelper+0x3b6>
				TICK();
#if 0
				if(IS_RECOVERY_STATE()) printk("might have sent data request during recovery\n");
#endif
			} else {
				/* couldn't send out a request */
				//printk("couldnot sent out request 0 ");
				TICK();
			no_data_request:
				TICK();
				//printk("couldnot sent out request 1 ");
				if(tp->rcv_nxt > tp->copied_seq) { // only safe if user_ack will reset this bit later
    65cd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    65d0:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    65d3:	8b 40 08             	mov    0x8(%eax),%eax
    65d6:	3b 82 fc 00 00 00    	cmp    0xfc(%edx),%eax
    65dc:	0f 86 74 02 00 00    	jbe    6856 <sendAckHelper+0x570>
					//printk("mask timeout ");
					tp->t.timerState &= ~TRICKLES_ENABLE_DATA_TIMEOUT;
    65e2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    65e5:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    65e8:	8b 92 dc 02 00 00    	mov    0x2dc(%edx),%edx
    65ee:	83 e2 fe             	and    $0xfffffffe,%edx
    65f1:	89 90 dc 02 00 00    	mov    %edx,0x2dc(%eax)
				}
				recordSample(&ctx,1);
#if 0
				if(IS_RECOVERY_STATE()) printk("could not send out request\n");
#endif
				goto out_free_error;
    65f7:	e9 5a 02 00 00       	jmp    6856 <sendAckHelper+0x570>
			}
		}
		/* Todo: Add support for direct interface */
	} else {
		/* In all other states, do only transport layer */
		printk("transport only\n");
    65fc:	c7 04 24 8d 26 00 00 	movl   $0x268d,(%esp,1)
    6603:	e8 fc ff ff ff       	call   6604 <sendAckHelper+0x31e>
		wreq->ucont_len = htons(0);
    6608:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
    660b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    6612:	e8 fc ff ff ff       	call   6613 <sendAckHelper+0x32d>
    6617:	66 89 43 4b          	mov    %ax,0x4b(%ebx)
		wreq->cont.parent = TRANSPORT_ONLY_REQNUM;
    661b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    661e:	c7 40 0e ff ff ff ff 	movl   $0xffffffff,0xe(%eax)

		if(!runSimulation(sk,cont,skb)) {
    6625:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    6628:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    662c:	8b 45 0c             	mov    0xc(%ebp),%eax
    662f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6633:	8b 45 08             	mov    0x8(%ebp),%eax
    6636:	89 04 24             	mov    %eax,(%esp,1)
    6639:	e8 a4 fb ff ff       	call   61e2 <runSimulation>
    663e:	85 c0                	test   %eax,%eax
    6640:	75 11                	jne    6653 <sendAckHelper+0x36d>
			printk("couldnot run simulation ");
    6642:	c7 04 24 9d 26 00 00 	movl   $0x269d,(%esp,1)
    6649:	e8 fc ff ff ff       	call   664a <sendAckHelper+0x364>
			goto out_free_ignore_this_cont;
    664e:	e9 17 02 00 00       	jmp    686a <sendAckHelper+0x584>
		}
		if(PACKET_RESPONSE_LEN(cont,0) < USEFULNESS_THRESHOLD) {
    6653:	8b 45 0c             	mov    0xc(%ebp),%eax
    6656:	05 fc 00 00 00       	add    $0xfc,%eax
    665b:	83 b8 e8 00 00 00 00 	cmpl   $0x0,0xe8(%eax)
    6662:	7e 19                	jle    667d <sendAckHelper+0x397>
    6664:	8b 45 0c             	mov    0xc(%ebp),%eax
    6667:	05 fc 00 00 00       	add    $0xfc,%eax
    666c:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
    6672:	81 78 08 e7 03 00 00 	cmpl   $0x3e7,0x8(%eax)
    6679:	76 02                	jbe    667d <sendAckHelper+0x397>
    667b:	eb 19                	jmp    6696 <sendAckHelper+0x3b0>
			printk("Not useful at %d\n", __LINE__);
    667d:	c7 44 24 04 19 10 00 	movl   $0x1019,0x4(%esp,1)
    6684:	00 
    6685:	c7 04 24 b6 26 00 00 	movl   $0x26b6,(%esp,1)
    668c:	e8 fc ff ff ff       	call   668d <sendAckHelper+0x3a7>
			goto out_free_ignore_this_cont;
    6691:	e9 d4 01 00 00       	jmp    686a <sendAckHelper+0x584>
		}
		static int transportCount = 0;
		transportCount++;
    6696:	ff 05 ac 00 00 00    	incl   0xac
		if(trickles_ratelimit()) {
			printk("transportCount = %d\n", transportCount);
		}
	}

	if(tp->t.eventsPos == 0) {
    669c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    669f:	83 b8 84 0a 00 00 00 	cmpl   $0x0,0xa84(%eax)
    66a6:	75 02                	jne    66aa <sendAckHelper+0x3c4>
		goto sample;
    66a8:	eb 3e                	jmp    66e8 <sendAckHelper+0x402>
	} else {
		struct TricklesLossEvent *lastEvent = &tp->t.events[tp->t.eventsPos - 1];
    66aa:	8b 4d f8             	mov    0xfffffff8(%ebp),%ecx
    66ad:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    66b0:	8b 90 84 0a 00 00    	mov    0xa84(%eax),%edx
    66b6:	89 d0                	mov    %edx,%eax
    66b8:	c1 e0 02             	shl    $0x2,%eax
    66bb:	01 d0                	add    %edx,%eax
    66bd:	03 81 80 0a 00 00    	add    0xa80(%ecx),%eax
    66c3:	83 e8 05             	sub    $0x5,%eax
    66c6:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
		if(tp->t.state != lastEvent->state) {
    66c9:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    66cc:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    66cf:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    66d3:	c0 e8 05             	shr    $0x5,%al
    66d6:	0f b6 c0             	movzbl %al,%eax
    66d9:	39 82 cc 02 00 00    	cmp    %eax,0x2cc(%edx)
    66df:	74 02                	je     66e3 <sendAckHelper+0x3fd>
    66e1:	eb 05                	jmp    66e8 <sendAckHelper+0x402>
		// state change
			appendTricklesLossEvent(sk, MIN((cont+1)->mark, EVENT_CWND_MAX),
						EVENT_EXTRA_SEND, tp->t.state);
		}  else if(jiffies - lastEvent->time >= HZ) {
    66e3:	a1 00 00 00 00       	mov    0x0,%eax
		sample:
			appendTricklesLossEvent(sk, MIN(tp->t.cont_list.len, EVENT_CWND_MAX),
						EVENT_EXTRA_SAMPLE0, tp->t.state);
			appendTricklesLossEvent(sk, MIN((cont+1)->mark, EVENT_CWND_MAX),
						EVENT_EXTRA_SAMPLE1, tp->t.state);
		}
	}

	skb->csum = 0;
    66e8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    66eb:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
    66f2:	00 00 00 
	skb->ip_summed = CHECKSUM_HW;
    66f5:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    66f8:	c6 80 a3 00 00 00 01 	movb   $0x1,0xa3(%eax)
	skb->sk = sk;
    66ff:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    6702:	8b 45 08             	mov    0x8(%ebp),%eax
    6705:	89 42 0c             	mov    %eax,0xc(%edx)
	tcp_header_size = sizeof(struct tcphdr) + TCPOLEN_TRICKLES;
    6708:	c7 45 e8 18 00 00 00 	movl   $0x18,0xffffffe8(%ebp)
	th = (struct tcphdr *) skb_push(skb, tcp_header_size);
    670f:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    6712:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6716:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    6719:	89 04 24             	mov    %eax,(%esp,1)
    671c:	e8 da 28 00 00       	call   8ffb <skb_push>
    6721:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
	skb->h.th = th;
    6724:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    6727:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    672a:	89 42 20             	mov    %eax,0x20(%edx)
	th->source = sk->sport;
    672d:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    6730:	8b 45 08             	mov    0x8(%ebp),%eax
    6733:	0f b7 40 22          	movzwl 0x22(%eax),%eax
    6737:	66 89 02             	mov    %ax,(%edx)
	th->dest = sk->dport;
    673a:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    673d:	8b 45 08             	mov    0x8(%ebp),%eax
    6740:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    6744:	66 89 42 02          	mov    %ax,0x2(%edx)

	// Save minResponseLen in seqno for comparison at the server with the server side computation
	if(cont != NULL) {
    6748:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    674c:	74 0c                	je     675a <sendAckHelper+0x474>
#ifdef RECORD_UCONT_OFFSET
		th->seq = cont->ucont_offset;
#else
		th->seq = -2;
    674e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    6751:	c7 40 04 fe ff ff ff 	movl   $0xfffffffe,0x4(%eax)
    6758:	eb 0a                	jmp    6764 <sendAckHelper+0x47e>
#endif
	} else {
		th->seq = -1;
    675a:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    675d:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%eax)
	}

	// zero out flags and set tcp header size
	*(((__u16 *)th) + 6) = 0;
    6764:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    6767:	83 c0 0c             	add    $0xc,%eax
    676a:	66 c7 00 00 00       	movw   $0x0,(%eax)

	th->doff = tcp_header_size >> 2;
    676f:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
    6772:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    6775:	89 c2                	mov    %eax,%edx
    6777:	c1 fa 02             	sar    $0x2,%edx
    677a:	0f b6 41 0c          	movzbl 0xc(%ecx),%eax
    677e:	c0 e2 04             	shl    $0x4,%dl
    6781:	24 0f                	and    $0xf,%al
    6783:	08 d0                	or     %dl,%al
    6785:	88 41 0c             	mov    %al,0xc(%ecx)
	//th->ack = htonl(cont->seq);

	// TODO: Find uses for window, urg_ptr fields
	th->window = htons(windowValue);
    6788:	8b 5d e4             	mov    0xffffffe4(%ebp),%ebx
    678b:	0f b7 45 de          	movzwl 0xffffffde(%ebp),%eax
    678f:	89 04 24             	mov    %eax,(%esp,1)
    6792:	e8 fc ff ff ff       	call   6793 <sendAckHelper+0x4ad>
    6797:	66 89 43 0e          	mov    %ax,0xe(%ebx)
	th->check = 0;
    679b:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    679e:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
	th->urg_ptr = 0;
    67a4:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    67a7:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
	*(__u32*)(th+1) = htonl((TCPOPT_TRICKLES << 24)  |
    67ad:	c7 04 24 00 00 04 0b 	movl   $0xb040000,(%esp,1)
    67b4:	e8 fc ff ff ff       	call   67b5 <sendAckHelper+0x4cf>
    67b9:	89 c2                	mov    %eax,%edx
    67bb:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    67be:	83 c0 14             	add    $0x14,%eax
    67c1:	89 10                	mov    %edx,(%eax)
				(TCPOLEN_TRICKLES << 16) |
				0);
	th->ack = 1;
    67c3:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    67c6:	80 48 0d 10          	orb    $0x10,0xd(%eax)
	th->syn = 0;
    67ca:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    67cd:	80 60 0d fd          	andb   $0xfd,0xd(%eax)
	th->fin = 0;
    67d1:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    67d4:	80 60 0d fe          	andb   $0xfe,0xd(%eax)
	th->rst = 0;
    67d8:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    67db:	80 60 0d fb          	andb   $0xfb,0xd(%eax)

	th->seq = ENCODE_SIMULATION_RESULT(cont);
    67df:	8b 5d e4             	mov    0xffffffe4(%ebp),%ebx
    67e2:	8b 45 0c             	mov    0xc(%ebp),%eax
    67e5:	89 04 24             	mov    %eax,(%esp,1)
    67e8:	e8 19 35 00 00       	call   9d06 <SIMULATION_TOTAL_LEN>
    67ed:	0f b7 d0             	movzwl %ax,%edx
    67f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    67f3:	05 fc 00 00 00       	add    $0xfc,%eax
    67f8:	8b 80 e8 00 00 00    	mov    0xe8(%eax),%eax
    67fe:	c1 e0 10             	shl    $0x10,%eax
    6801:	09 d0                	or     %edx,%eax
    6803:	89 43 04             	mov    %eax,0x4(%ebx)
	th->ack_seq = packetID;
    6806:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    6809:	a1 a8 00 00 00       	mov    0xa8,%eax
    680e:	89 42 08             	mov    %eax,0x8(%edx)
	packetID++;
    6811:	ff 05 a8 00 00 00    	incl   0xa8

#ifndef USERTEST
	recordSample(&ctx,0);
	trickles_checksum(skb, skb->len);
    6817:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    681a:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    6820:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6824:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    6827:	89 04 24             	mov    %eax,(%esp,1)
    682a:	e8 7b 2d 00 00       	call   95aa <trickles_checksum>
	recordSample(&ctx,0);

	//printk("requestType=%d queuexmit\n", type);

	if((res = tp->af_specific->queue_xmit(skb, 0)) != 0) {
    682f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    6832:	8b 90 dc 00 00 00    	mov    0xdc(%eax),%edx
    6838:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    683f:	00 
    6840:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    6843:	89 04 24             	mov    %eax,(%esp,1)
    6846:	8b 02                	mov    (%edx),%eax
    6848:	ff d0                	call   *%eax
    684a:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
		if(trickles_ratelimit()) {
			printk("sendAckHelper wants to spill to overflow due to send failure (tx res = %d)\n", res);
#ifndef DISABLE_SENDACKOVERFLOW
			printk("However, it's disabled!!! All you need is an skb_copy() above in the queue_xmit, but I haven't tested it\n", res);
#endif
		}
#ifndef DISABLE_SENDACKOVERFLOW
		__skb_queue_tail(&tp->t.sendAckOverflow, skb);
#else
		//__kfree_skb(skb);
#endif
	} else {
		//LOG_PACKET_CONT(sk, -1, cont);
	}
	recordSample(&ctx,0);
#else
	skb->nh.iph = (struct iphdr*)skb_push(skb, sizeof(struct iphdr));
	skb->nh.iph->daddr = sk->daddr;
	skb->nh.iph->saddr = sk->saddr;
	sendtoserver(skb);
#endif

	printTimings(&ctx);
	return 1;
    684d:	c7 45 cc 01 00 00 00 	movl   $0x1,0xffffffcc(%ebp)
    6854:	eb 26                	jmp    687c <sendAckHelper+0x596>
 out_free_error:
#if 0
	if(IS_RECOVERY_STATE()) printk(" out free error\n");
#endif
	__kfree_skb(skb);
    6856:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    6859:	89 04 24             	mov    %eax,(%esp,1)
    685c:	e8 fc ff ff ff       	call   685d <sendAckHelper+0x577>
	return 0;
    6861:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
    6868:	eb 12                	jmp    687c <sendAckHelper+0x596>
 out_free_ignore_this_cont:
	//printk(" out free ignore this cont\n");
	__kfree_skb(skb);
    686a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    686d:	89 04 24             	mov    %eax,(%esp,1)
    6870:	e8 fc ff ff ff       	call   6871 <sendAckHelper+0x58b>
	return 1;
    6875:	c7 45 cc 01 00 00 00 	movl   $0x1,0xffffffcc(%ebp)
}
    687c:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    687f:	83 c4 40             	add    $0x40,%esp
    6882:	5b                   	pop    %ebx
    6883:	5d                   	pop    %ebp
    6884:	c3                   	ret    

00006885 <generateRequestsFromPending>:

/* Precondition: skb head must point at location to place request header */

#if 0
#define USERACK_BEAT(STR) if(NEED_USERACK(sk)) printk("USERACK:" STR);
#else
#define USERACK_BEAT(STR)
#endif

static inline
int generateRequestsFromPending(struct sock *sk, struct sk_buff *skb,
				 struct WireTrickleRequest *wreq,
				 CONTINUATION_TYPE *cont) {
    6885:	55                   	push   %ebp
    6886:	89 e5                	mov    %esp,%ebp
    6888:	53                   	push   %ebx
    6889:	83 ec 50             	sub    $0x50,%esp
	USERACK_BEAT("generateRequestsFromPending()\n");
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    688c:	8b 45 08             	mov    0x8(%ebp),%eax
    688f:	05 bc 00 00 00       	add    $0xbc,%eax
    6894:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	recordSample(&ctx,2);
	/* Execute simulation to initialize
	   minResponseLen
	   firstTransportChild
	   numTransportChildren

	   MUST occur after skb is initialized with transport-level fields!
	*/
	if(!runSimulation(sk,cont,skb)) {
    6897:	8b 45 0c             	mov    0xc(%ebp),%eax
    689a:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    689e:	8b 45 14             	mov    0x14(%ebp),%eax
    68a1:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    68a5:	8b 45 08             	mov    0x8(%ebp),%eax
    68a8:	89 04 24             	mov    %eax,(%esp,1)
    68ab:	e8 32 f9 ff ff       	call   61e2 <runSimulation>
    68b0:	85 c0                	test   %eax,%eax
    68b2:	75 18                	jne    68cc <generateRequestsFromPending+0x47>
		printk("simulation failed\n");
    68b4:	c7 04 24 c8 26 00 00 	movl   $0x26c8,(%esp,1)
    68bb:	e8 fc ff ff ff       	call   68bc <generateRequestsFromPending+0x37>
		return OUT_FREE;
    68c0:	c7 45 c4 ff ff ff ff 	movl   $0xffffffff,0xffffffc4(%ebp)
    68c7:	e9 62 07 00 00       	jmp    702e <generateRequestsFromPending+0x7a9>
	}
	if(PACKET_RESPONSE_LEN(cont,0) < USEFULNESS_THRESHOLD) {
    68cc:	8b 45 14             	mov    0x14(%ebp),%eax
    68cf:	05 fc 00 00 00       	add    $0xfc,%eax
    68d4:	83 b8 e8 00 00 00 00 	cmpl   $0x0,0xe8(%eax)
    68db:	7e 19                	jle    68f6 <generateRequestsFromPending+0x71>
    68dd:	8b 45 14             	mov    0x14(%ebp),%eax
    68e0:	05 fc 00 00 00       	add    $0xfc,%eax
    68e5:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
    68eb:	81 78 08 e7 03 00 00 	cmpl   $0x3e7,0x8(%eax)
    68f2:	76 02                	jbe    68f6 <generateRequestsFromPending+0x71>
    68f4:	eb 5b                	jmp    6951 <generateRequestsFromPending+0xcc>
		BUG_TRAP(PACKET_RESPONSE_LEN(cont,0) == 0);
    68f6:	8b 45 14             	mov    0x14(%ebp),%eax
    68f9:	05 fc 00 00 00       	add    $0xfc,%eax
    68fe:	83 b8 e8 00 00 00 00 	cmpl   $0x0,0xe8(%eax)
    6905:	7e 2a                	jle    6931 <generateRequestsFromPending+0xac>
    6907:	8b 45 14             	mov    0x14(%ebp),%eax
    690a:	05 fc 00 00 00       	add    $0xfc,%eax
    690f:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
    6915:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
    6919:	75 02                	jne    691d <generateRequestsFromPending+0x98>
    691b:	eb 14                	jmp    6931 <generateRequestsFromPending+0xac>
    691d:	c7 44 24 04 a5 10 00 	movl   $0x10a5,0x4(%esp,1)
    6924:	00 
    6925:	c7 04 24 e0 26 00 00 	movl   $0x26e0,(%esp,1)
    692c:	e8 fc ff ff ff       	call   692d <generateRequestsFromPending+0xa8>
		printk("Not useful at %d\n", __LINE__);
    6931:	c7 44 24 04 a6 10 00 	movl   $0x10a6,0x4(%esp,1)
    6938:	00 
    6939:	c7 04 24 b6 26 00 00 	movl   $0x26b6,(%esp,1)
    6940:	e8 fc ff ff ff       	call   6941 <generateRequestsFromPending+0xbc>
		return OUT_FREE_IGNORE;
    6945:	c7 45 c4 fe ff ff ff 	movl   $0xfffffffe,0xffffffc4(%ebp)
    694c:	e9 dd 06 00 00       	jmp    702e <generateRequestsFromPending+0x7a9>
	}
	struct Request *mreq = (struct Request*)tp->t.queuedRequests.next;
    6951:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    6954:	8b 80 9c 09 00 00    	mov    0x99c(%eax),%eax
    695a:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

	unlink((struct alloc_head*)mreq);
    695d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    6960:	89 04 24             	mov    %eax,(%esp,1)
    6963:	e8 84 29 00 00       	call   92ec <unlink>
	insert_tail(&tp->t.sentRequests, (struct alloc_head*)mreq);
    6968:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    696b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    696f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    6972:	05 84 09 00 00       	add    $0x984,%eax
    6977:	89 04 24             	mov    %eax,(%esp,1)
    697a:	e8 f5 28 00 00       	call   9274 <insert_tail>
	mreq->transport_seq = cont->seq;
    697f:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    6982:	8b 45 14             	mov    0x14(%ebp),%eax
    6985:	8b 40 30             	mov    0x30(%eax),%eax
    6988:	89 42 38             	mov    %eax,0x38(%edx)
	if(mreq->isNew) {
    698b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    698e:	0f b6 40 48          	movzbl 0x48(%eax),%eax
    6992:	83 e0 01             	and    $0x1,%eax
    6995:	85 c0                	test   %eax,%eax
    6997:	74 29                	je     69c2 <generateRequestsFromPending+0x13d>
		mreq->seq = tp->t.request_snd_nxt;
    6999:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    699c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    699f:	8b 80 60 09 00 00    	mov    0x960(%eax),%eax
    69a5:	89 42 3c             	mov    %eax,0x3c(%edx)
		tp->t.request_snd_nxt = tp->t.request_snd_nxt + 1; // sequence number is the identifier to match during scoreboard management
    69a8:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    69ab:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    69ae:	8b 80 60 09 00 00    	mov    0x960(%eax),%eax
    69b4:	40                   	inc    %eax
    69b5:	89 82 60 09 00 00    	mov    %eax,0x960(%edx)
		mreq->isNew = 0;
    69bb:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    69be:	80 60 48 fe          	andb   $0xfe,0x48(%eax)
	}
	// Now that we have UC sequence number, marshall continuation
	wreq->cont.parent = mreq->seq;
    69c2:	8b 55 10             	mov    0x10(%ebp),%edx
    69c5:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    69c8:	8b 40 3c             	mov    0x3c(%eax),%eax
    69cb:	89 42 0e             	mov    %eax,0xe(%edx)

	/* All MTU handling is performed at this level */
	switch(mreq->type) {
    69ce:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    69d1:	8b 40 0c             	mov    0xc(%eax),%eax
    69d4:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
    69d7:	83 7d b8 00          	cmpl   $0x0,0xffffffb8(%ebp)
    69db:	74 0f                	je     69ec <generateRequestsFromPending+0x167>
    69dd:	83 7d b8 01          	cmpl   $0x1,0xffffffb8(%ebp)
    69e1:	0f 84 bf 04 00 00    	je     6ea6 <generateRequestsFromPending+0x621>
    69e7:	e9 02 06 00 00       	jmp    6fee <generateRequestsFromPending+0x769>
	case MREQ_CONVERSION: {
		struct ConversionRequest *convReq =
    69ec:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    69ef:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
			(struct ConversionRequest *)mreq;
		struct sk_buff *input_skb;
		unsigned outContLen, copyLen, copyOffset;
		__u16 wlen;

#if 1 // 0901 bugs fix, see wiki for 8/30
		int path;
		if(tp->t.snd_una <= convReq->start) {
    69f2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    69f5:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    69f8:	8b 80 e0 09 00 00    	mov    0x9e0(%eax),%eax
    69fe:	3b 42 40             	cmp    0x40(%edx),%eax
    6a01:	77 57                	ja     6a5a <generateRequestsFromPending+0x1d5>
			input_skb = convReq->data;
    6a03:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    6a06:	8b 40 58             	mov    0x58(%eax),%eax
    6a09:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
			copyOffset = convReq->offset;
    6a0c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    6a0f:	8b 40 5c             	mov    0x5c(%eax),%eax
    6a12:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
			if(convReq->start != TCP_SKB_CB(input_skb)->seq + copyOffset) {
    6a15:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    6a18:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    6a1b:	83 c2 30             	add    $0x30,%edx
    6a1e:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    6a21:	03 42 10             	add    0x10(%edx),%eax
    6a24:	39 41 40             	cmp    %eax,0x40(%ecx)
    6a27:	74 25                	je     6a4e <generateRequestsFromPending+0x1c9>
				BUG();
    6a29:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    6a30:	00 
    6a31:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    6a38:	e8 fc ff ff ff       	call   6a39 <generateRequestsFromPending+0x1b4>
    6a3d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    6a44:	e8 fc ff ff ff       	call   6a45 <generateRequestsFromPending+0x1c0>
    6a49:	e8 fc ff ff ff       	call   6a4a <generateRequestsFromPending+0x1c5>
			}
			path = 0;
    6a4e:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
    6a55:	e9 3b 01 00 00       	jmp    6b95 <generateRequestsFromPending+0x310>
		} else {
			if(tp->t.snd_una == tp->t.write_seq) {
    6a5a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    6a5d:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    6a60:	8b 80 e0 09 00 00    	mov    0x9e0(%eax),%eax
    6a66:	3b 82 e8 09 00 00    	cmp    0x9e8(%edx),%eax
    6a6c:	75 17                	jne    6a85 <generateRequestsFromPending+0x200>
				//printk("Conversion now obsolete\n");
				unlink((struct alloc_head*)convReq);
    6a6e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    6a71:	89 04 24             	mov    %eax,(%esp,1)
    6a74:	e8 73 28 00 00       	call   92ec <unlink>
				return OUT_FREE;
    6a79:	c7 45 c4 ff ff ff ff 	movl   $0xffffffff,0xffffffc4(%ebp)
    6a80:	e9 a9 05 00 00       	jmp    702e <generateRequestsFromPending+0x7a9>
			}
			// find input skb corresponding to current snd_una, and adjust convReq->input_skb accordingly
			input_skb = tp->t.requestBytes.next;
    6a85:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    6a88:	8b 80 ec 09 00 00    	mov    0x9ec(%eax),%eax
    6a8e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
			while(input_skb != &tp->t.requestBytes) {
    6a91:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    6a94:	05 ec 09 00 00       	add    $0x9ec,%eax
    6a99:	39 45 ec             	cmp    %eax,0xffffffec(%ebp)
    6a9c:	75 02                	jne    6aa0 <generateRequestsFromPending+0x21b>
    6a9e:	eb 34                	jmp    6ad4 <generateRequestsFromPending+0x24f>
				if(TCP_SKB_CB(input_skb)->seq <= tp->t.snd_una &&
    6aa0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    6aa3:	83 c0 30             	add    $0x30,%eax
    6aa6:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    6aa9:	8b 40 10             	mov    0x10(%eax),%eax
    6aac:	3b 82 e0 09 00 00    	cmp    0x9e0(%edx),%eax
    6ab2:	77 dd                	ja     6a91 <generateRequestsFromPending+0x20c>
    6ab4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    6ab7:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    6aba:	83 c2 30             	add    $0x30,%edx
    6abd:	8b 80 e0 09 00 00    	mov    0x9e0(%eax),%eax
    6ac3:	3b 42 14             	cmp    0x14(%edx),%eax
    6ac6:	73 c9                	jae    6a91 <generateRequestsFromPending+0x20c>
				   tp->t.snd_una < TCP_SKB_CB(input_skb)->end_seq) {
					printk("matched during update\n");
    6ac8:	c7 04 24 2f 27 00 00 	movl   $0x272f,(%esp,1)
    6acf:	e8 fc ff ff ff       	call   6ad0 <generateRequestsFromPending+0x24b>
					break;
				}
			}
			if(input_skb == &tp->t.requestBytes) {
    6ad4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    6ad7:	05 ec 09 00 00       	add    $0x9ec,%eax
    6adc:	39 45 ec             	cmp    %eax,0xffffffec(%ebp)
    6adf:	75 31                	jne    6b12 <generateRequestsFromPending+0x28d>
				printk("screwed up during update\n");
    6ae1:	c7 04 24 46 27 00 00 	movl   $0x2746,(%esp,1)
    6ae8:	e8 fc ff ff ff       	call   6ae9 <generateRequestsFromPending+0x264>
				BUG();
    6aed:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    6af4:	00 
    6af5:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    6afc:	e8 fc ff ff ff       	call   6afd <generateRequestsFromPending+0x278>
    6b01:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    6b08:	e8 fc ff ff ff       	call   6b09 <generateRequestsFromPending+0x284>
    6b0d:	e8 fc ff ff ff       	call   6b0e <generateRequestsFromPending+0x289>
			}
			convReq->data = input_skb;
    6b12:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    6b15:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    6b18:	89 42 58             	mov    %eax,0x58(%edx)
			convReq->start = tp->t.snd_una;
    6b1b:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    6b1e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    6b21:	8b 80 e0 09 00 00    	mov    0x9e0(%eax),%eax
    6b27:	89 42 40             	mov    %eax,0x40(%edx)
			printk("2: start = %d\n", convReq->start);
    6b2a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    6b2d:	8b 40 40             	mov    0x40(%eax),%eax
    6b30:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6b34:	c7 04 24 60 27 00 00 	movl   $0x2760,(%esp,1)
    6b3b:	e8 fc ff ff ff       	call   6b3c <generateRequestsFromPending+0x2b7>
			convReq->offset = copyOffset = convReq->start - TCP_SKB_CB(input_skb)->seq;
    6b40:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    6b43:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    6b46:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    6b49:	83 c0 30             	add    $0x30,%eax
    6b4c:	8b 50 10             	mov    0x10(%eax),%edx
    6b4f:	8b 41 40             	mov    0x40(%ecx),%eax
    6b52:	29 d0                	sub    %edx,%eax
    6b54:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    6b57:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    6b5a:	89 43 5c             	mov    %eax,0x5c(%ebx)
			convReq->end = tp->t.write_seq;
    6b5d:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    6b60:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    6b63:	8b 80 e8 09 00 00    	mov    0x9e8(%eax),%eax
    6b69:	89 42 44             	mov    %eax,0x44(%edx)

			BUG_TRAP(convReq->offset >= 0);
			BUG_TRAP(convReq->end > convReq->start);
    6b6c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    6b6f:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    6b72:	8b 40 44             	mov    0x44(%eax),%eax
    6b75:	3b 42 40             	cmp    0x40(%edx),%eax
    6b78:	77 14                	ja     6b8e <generateRequestsFromPending+0x309>
    6b7a:	c7 44 24 04 e2 10 00 	movl   $0x10e2,0x4(%esp,1)
    6b81:	00 
    6b82:	c7 04 24 80 27 00 00 	movl   $0x2780,(%esp,1)
    6b89:	e8 fc ff ff ff       	call   6b8a <generateRequestsFromPending+0x305>
			path = 1;
    6b8e:	c7 45 d8 01 00 00 00 	movl   $0x1,0xffffffd8(%ebp)
		}
		if(input_skb == NULL) {
    6b95:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
    6b99:	75 25                	jne    6bc0 <generateRequestsFromPending+0x33b>
			BUG();
    6b9b:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    6ba2:	00 
    6ba3:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    6baa:	e8 fc ff ff ff       	call   6bab <generateRequestsFromPending+0x326>
    6baf:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    6bb6:	e8 fc ff ff ff       	call   6bb7 <generateRequestsFromPending+0x332>
    6bbb:	e8 fc ff ff ff       	call   6bbc <generateRequestsFromPending+0x337>
		}
#endif

		if(convReq->incomplete) {
    6bc0:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    6bc3:	83 78 54 00          	cmpl   $0x0,0x54(%eax)
    6bc7:	0f 84 ac 00 00 00    	je     6c79 <generateRequestsFromPending+0x3f4>
			struct WireUC_CVT_IncompleteRequest *wInConvReq;
			unsigned contLen;

			/* get current position */
			wInConvReq = (struct WireUC_CVT_IncompleteRequest *)
    6bcd:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp,1)
    6bd4:	00 
    6bd5:	8b 45 0c             	mov    0xc(%ebp),%eax
    6bd8:	89 04 24             	mov    %eax,(%esp,1)
    6bdb:	e8 8b 23 00 00       	call   8f6b <skb_put>
    6be0:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
				skb_put(skb, sizeof(*wInConvReq));
			contLen = convReq->predLength;
    6be3:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    6be6:	8b 40 60             	mov    0x60(%eax),%eax
    6be9:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
			skb_put(skb, contLen - sizeof(wInConvReq->predCont));
    6bec:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    6bef:	83 e8 04             	sub    $0x4,%eax
    6bf2:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6bf6:	8b 45 0c             	mov    0xc(%ebp),%eax
    6bf9:	89 04 24             	mov    %eax,(%esp,1)
    6bfc:	e8 6a 23 00 00       	call   8f6b <skb_put>
			memcpy(&wInConvReq->predCont, convReq->incompletePred, contLen);
    6c01:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    6c04:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    6c08:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    6c0b:	8b 40 64             	mov    0x64(%eax),%eax
    6c0e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6c12:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    6c15:	83 c0 07             	add    $0x7,%eax
    6c18:	89 04 24             	mov    %eax,(%esp,1)
    6c1b:	e8 f2 1f 00 00       	call   8c12 <__memcpy>
			wInConvReq->type = UC_INCOMPLETE;
    6c20:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    6c23:	c6 00 00             	movb   $0x0,(%eax)
			outContLen = (char*)skb_put(skb, 0) - (char*)wInConvReq;
    6c26:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    6c2d:	00 
    6c2e:	8b 45 0c             	mov    0xc(%ebp),%eax
    6c31:	89 04 24             	mov    %eax,(%esp,1)
    6c34:	e8 32 23 00 00       	call   8f6b <skb_put>
    6c39:	2b 45 d4             	sub    0xffffffd4(%ebp),%eax
    6c3c:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
			wlen = htons((short)outContLen);
    6c3f:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
    6c43:	89 04 24             	mov    %eax,(%esp,1)
    6c46:	e8 fc ff ff ff       	call   6c47 <generateRequestsFromPending+0x3c2>
    6c4b:	66 89 45 de          	mov    %ax,0xffffffde(%ebp)
			wInConvReq->len = wlen;
    6c4f:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
    6c52:	0f b7 45 de          	movzwl 0xffffffde(%ebp),%eax
    6c56:	66 89 42 01          	mov    %ax,0x1(%edx)
			wInConvReq->seq =
    6c5a:	8b 5d d4             	mov    0xffffffd4(%ebp),%ebx
    6c5d:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    6c60:	83 c2 30             	add    $0x30,%edx
    6c63:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    6c66:	03 42 10             	add    0x10(%edx),%eax
    6c69:	89 04 24             	mov    %eax,(%esp,1)
    6c6c:	e8 fc ff ff ff       	call   6c6d <generateRequestsFromPending+0x3e8>
    6c71:	89 43 03             	mov    %eax,0x3(%ebx)
    6c74:	e9 9a 00 00 00       	jmp    6d13 <generateRequestsFromPending+0x48e>
				htonl(TCP_SKB_CB(input_skb)->seq + copyOffset);
		} else {
			struct WireUC_CVT_CompleteRequest *wConvReq;
			unsigned contLen;

			wConvReq = (struct WireUC_CVT_CompleteRequest*)
    6c79:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp,1)
    6c80:	00 
    6c81:	8b 45 0c             	mov    0xc(%ebp),%eax
    6c84:	89 04 24             	mov    %eax,(%esp,1)
    6c87:	e8 df 22 00 00       	call   8f6b <skb_put>
    6c8c:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
				skb_put(skb, sizeof(*wConvReq));
			contLen = marshallUC_Continuation(&wConvReq->predCont,
    6c8f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    6c92:	8b 40 64             	mov    0x64(%eax),%eax
    6c95:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6c99:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    6c9c:	83 c0 07             	add    $0x7,%eax
    6c9f:	89 04 24             	mov    %eax,(%esp,1)
    6ca2:	e8 59 35 00 00       	call   a200 <marshallUC_Continuation>
    6ca7:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
							  convReq->completePred);

			skb_put(skb, contLen - sizeof(wConvReq->predCont));
    6caa:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    6cad:	83 e8 0d             	sub    $0xd,%eax
    6cb0:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6cb4:	8b 45 0c             	mov    0xc(%ebp),%eax
    6cb7:	89 04 24             	mov    %eax,(%esp,1)
    6cba:	e8 ac 22 00 00       	call   8f6b <skb_put>
			wConvReq->type = UC_COMPLETE;
    6cbf:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    6cc2:	c6 00 01             	movb   $0x1,(%eax)
			outContLen = (char*)skb_put(skb, 0) - (char*)wConvReq;
    6cc5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    6ccc:	00 
    6ccd:	8b 45 0c             	mov    0xc(%ebp),%eax
    6cd0:	89 04 24             	mov    %eax,(%esp,1)
    6cd3:	e8 93 22 00 00       	call   8f6b <skb_put>
    6cd8:	2b 45 d0             	sub    0xffffffd0(%ebp),%eax
    6cdb:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
			wlen = htons((short)outContLen);
    6cde:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
    6ce2:	89 04 24             	mov    %eax,(%esp,1)
    6ce5:	e8 fc ff ff ff       	call   6ce6 <generateRequestsFromPending+0x461>
    6cea:	66 89 45 de          	mov    %ax,0xffffffde(%ebp)
			wConvReq->len = wlen;
    6cee:	8b 55 d0             	mov    0xffffffd0(%ebp),%edx
    6cf1:	0f b7 45 de          	movzwl 0xffffffde(%ebp),%eax
    6cf5:	66 89 42 01          	mov    %ax,0x1(%edx)
			wConvReq->seq =
    6cf9:	8b 5d d0             	mov    0xffffffd0(%ebp),%ebx
    6cfc:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    6cff:	83 c2 30             	add    $0x30,%edx
    6d02:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    6d05:	03 42 10             	add    0x10(%edx),%eax
    6d08:	89 04 24             	mov    %eax,(%esp,1)
    6d0b:	e8 fc ff ff ff       	call   6d0c <generateRequestsFromPending+0x487>
    6d10:	89 43 03             	mov    %eax,0x3(%ebx)
				htonl(TCP_SKB_CB(input_skb)->seq + copyOffset);
		}
		if(outContLen > TRICKLES_MSS) {
    6d13:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    6d16:	3b 05 00 00 00 00    	cmp    0x0,%eax
    6d1c:	76 18                	jbe    6d36 <generateRequestsFromPending+0x4b1>
			printk("outContLen > TRICKLES_MSS\n");
    6d1e:	c7 04 24 cc 27 00 00 	movl   $0x27cc,(%esp,1)
    6d25:	e8 fc ff ff ff       	call   6d26 <generateRequestsFromPending+0x4a1>
			recordSample(&ctx,1);
			return OUT_FREE;
    6d2a:	c7 45 c4 ff ff ff ff 	movl   $0xffffffff,0xffffffc4(%ebp)
    6d31:	e9 f8 02 00 00       	jmp    702e <generateRequestsFromPending+0x7a9>
		}
		wreq->ucont_len = wlen;
    6d36:	8b 55 10             	mov    0x10(%ebp),%edx
    6d39:	0f b7 45 de          	movzwl 0xffffffde(%ebp),%eax
    6d3d:	66 89 42 4b          	mov    %ax,0x4b(%edx)

#if 1 // 0901 bugs fix, see wiki for 8/30
		copyLen = MIN(TRICKLES_MSS - outContLen, tp->t.write_seq - convReq->start);
    6d41:	8b 4d f8             	mov    0xfffffff8(%ebp),%ecx
    6d44:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    6d47:	8b 50 40             	mov    0x40(%eax),%edx
    6d4a:	8b 81 e8 09 00 00    	mov    0x9e8(%ecx),%eax
    6d50:	29 d0                	sub    %edx,%eax
    6d52:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    6d55:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    6d58:	a1 00 00 00 00       	mov    0x0,%eax
    6d5d:	29 d0                	sub    %edx,%eax
    6d5f:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
    6d62:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    6d65:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    6d68:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    6d6b:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
    6d6e:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
    6d71:	3b 45 d4             	cmp    0xffffffd4(%ebp),%eax
    6d74:	76 06                	jbe    6d7c <generateRequestsFromPending+0x4f7>
    6d76:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    6d79:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
    6d7c:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
    6d7f:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
		if(copyLen == 0) {
    6d82:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
    6d86:	75 25                	jne    6dad <generateRequestsFromPending+0x528>
			BUG();
    6d88:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    6d8f:	00 
    6d90:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    6d97:	e8 fc ff ff ff       	call   6d98 <generateRequestsFromPending+0x513>
    6d9c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    6da3:	e8 fc ff ff ff       	call   6da4 <generateRequestsFromPending+0x51f>
    6da8:	e8 fc ff ff ff       	call   6da9 <generateRequestsFromPending+0x524>
		}
#endif
		convReq->end = convReq->start + copyLen;
    6dad:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    6db0:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    6db3:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    6db6:	03 42 40             	add    0x40(%edx),%eax
    6db9:	89 41 44             	mov    %eax,0x44(%ecx)

		/* Update snd_end to allow for progress check */
		tp->t.snd_end = convReq->end;
    6dbc:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    6dbf:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    6dc2:	8b 40 44             	mov    0x44(%eax),%eax
    6dc5:	89 82 e4 09 00 00    	mov    %eax,0x9e4(%edx)

		/* Copy bytestream to request */
		BUG_TRAP(copyLen + outContLen <= TRICKLES_MSS);
    6dcb:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    6dce:	03 45 e4             	add    0xffffffe4(%ebp),%eax
    6dd1:	3b 05 00 00 00 00    	cmp    0x0,%eax
    6dd7:	76 14                	jbe    6ded <generateRequestsFromPending+0x568>
    6dd9:	c7 44 24 04 1e 11 00 	movl   $0x111e,0x4(%esp,1)
    6de0:	00 
    6de1:	c7 04 24 00 28 00 00 	movl   $0x2800,(%esp,1)
    6de8:	e8 fc ff ff ff       	call   6de9 <generateRequestsFromPending+0x564>
		if(copyLen == 0) {
    6ded:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
    6df1:	75 16                	jne    6e09 <generateRequestsFromPending+0x584>
			printk("ReqType = %d CopyLen == 0\n", mreq->type);
    6df3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    6df6:	8b 40 0c             	mov    0xc(%eax),%eax
    6df9:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6dfd:	c7 04 24 53 28 00 00 	movl   $0x2853,(%esp,1)
    6e04:	e8 fc ff ff ff       	call   6e05 <generateRequestsFromPending+0x580>
    6e09:	90                   	nop    
		}
		while(copyLen > 0) {
    6e0a:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
    6e0e:	75 05                	jne    6e15 <generateRequestsFromPending+0x590>
    6e10:	e9 86 00 00 00       	jmp    6e9b <generateRequestsFromPending+0x616>
			unsigned pieceLen = MIN(input_skb->len - copyOffset, copyLen);
    6e15:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    6e18:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    6e1b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    6e1e:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    6e21:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    6e27:	29 d0                	sub    %edx,%eax
    6e29:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
    6e2c:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    6e2f:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
    6e32:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    6e35:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
    6e38:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    6e3b:	3b 45 d4             	cmp    0xffffffd4(%ebp),%eax
    6e3e:	76 06                	jbe    6e46 <generateRequestsFromPending+0x5c1>
    6e40:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    6e43:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
    6e46:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    6e49:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
			memcpy(skb_put(skb, pieceLen), input_skb->data + copyOffset, pieceLen);
    6e4c:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    6e4f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6e53:	8b 45 0c             	mov    0xc(%ebp),%eax
    6e56:	89 04 24             	mov    %eax,(%esp,1)
    6e59:	e8 0d 21 00 00       	call   8f6b <skb_put>
    6e5e:	89 c1                	mov    %eax,%ecx
    6e60:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    6e63:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    6e67:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    6e6a:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    6e6d:	03 82 b8 00 00 00    	add    0xb8(%edx),%eax
    6e73:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6e77:	89 0c 24             	mov    %ecx,(%esp,1)
    6e7a:	e8 93 1d 00 00       	call   8c12 <__memcpy>
			copyOffset = 0;
    6e7f:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
			copyLen -= pieceLen;
    6e86:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
    6e89:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
    6e8c:	29 10                	sub    %edx,(%eax)
			input_skb = input_skb->next;
    6e8e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    6e91:	8b 00                	mov    (%eax),%eax
    6e93:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    6e96:	e9 6f ff ff ff       	jmp    6e0a <generateRequestsFromPending+0x585>
		}
#ifdef PRINT_CLIENT_CONVERSIONCOUNT
		static int conversionCount = 0;
		conversionCount++;
    6e9b:	ff 05 b0 00 00 00    	incl   0xb0
		if(trickles_ratelimit()) {
			printk("conversionCount = %d\n", conversionCount);
		}
#endif
		break;
    6ea1:	e9 5d 01 00 00       	jmp    7003 <generateRequestsFromPending+0x77e>
	}
	case MREQ_CONTINUATION: {
		struct ContinuationRequest *updateReq = (struct ContinuationRequest *)mreq;
    6ea6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    6ea9:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
		struct WireUC_MGMT_UpdateRequest *wUpdateReq;
		int i;
		unsigned numContinuations = updateReq->numConts;
    6eac:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    6eaf:	8b 40 54             	mov    0x54(%eax),%eax
    6eb2:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
		unsigned totalLen = 0;
    6eb5:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)

		wUpdateReq = (struct WireUC_MGMT_UpdateRequest*)skb_put(skb, sizeof(*wUpdateReq));
    6ebc:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp,1)
    6ec3:	00 
    6ec4:	8b 45 0c             	mov    0xc(%ebp),%eax
    6ec7:	89 04 24             	mov    %eax,(%esp,1)
    6eca:	e8 9c 20 00 00       	call   8f6b <skb_put>
    6ecf:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
		wUpdateReq->newStart = htonl(updateReq->start);
    6ed2:	8b 5d cc             	mov    0xffffffcc(%ebp),%ebx
    6ed5:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    6ed8:	8b 40 40             	mov    0x40(%eax),%eax
    6edb:	89 04 24             	mov    %eax,(%esp,1)
    6ede:	e8 fc ff ff ff       	call   6edf <generateRequestsFromPending+0x65a>
    6ee3:	89 43 03             	mov    %eax,0x3(%ebx)
		wUpdateReq->newEnd = htonl(updateReq->end);
    6ee6:	8b 5d cc             	mov    0xffffffcc(%ebp),%ebx
    6ee9:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    6eec:	8b 40 44             	mov    0x44(%eax),%eax
    6eef:	89 04 24             	mov    %eax,(%esp,1)
    6ef2:	e8 fc ff ff ff       	call   6ef3 <generateRequestsFromPending+0x66e>
    6ef7:	89 43 07             	mov    %eax,0x7(%ebx)
		wUpdateReq->numContinuations = (__u8)numContinuations;
    6efa:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
    6efd:	0f b6 45 d4          	movzbl 0xffffffd4(%ebp),%eax
    6f01:	88 42 0b             	mov    %al,0xb(%edx)
		for(i=0; i < numContinuations; i++) {
    6f04:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
    6f0b:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    6f0e:	3b 45 d4             	cmp    0xffffffd4(%ebp),%eax
    6f11:	72 05                	jb     6f18 <generateRequestsFromPending+0x693>
    6f13:	e9 89 00 00 00       	jmp    6fa1 <generateRequestsFromPending+0x71c>
			// length
			__u16 *lenPtr = (__u16*)skb_put(skb, sizeof(__u16));
    6f18:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp,1)
    6f1f:	00 
    6f20:	8b 45 0c             	mov    0xc(%ebp),%eax
    6f23:	89 04 24             	mov    %eax,(%esp,1)
    6f26:	e8 40 20 00 00       	call   8f6b <skb_put>
    6f2b:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
			unsigned contLen;
			contLen = marshallUC_Continuation((struct WireUC_Continuation*)skb_put(skb, 0), updateReq->conts[i]);
    6f2e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    6f35:	00 
    6f36:	8b 45 0c             	mov    0xc(%ebp),%eax
    6f39:	89 04 24             	mov    %eax,(%esp,1)
    6f3c:	e8 2a 20 00 00       	call   8f6b <skb_put>
    6f41:	89 c3                	mov    %eax,%ebx
    6f43:	8b 4d c8             	mov    0xffffffc8(%ebp),%ecx
    6f46:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    6f49:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6f50:	8b 41 58             	mov    0x58(%ecx),%eax
    6f53:	8b 04 10             	mov    (%eax,%edx,1),%eax
    6f56:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6f5a:	89 1c 24             	mov    %ebx,(%esp,1)
    6f5d:	e8 9e 32 00 00       	call   a200 <marshallUC_Continuation>
    6f62:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
			skb_put(skb, contLen);
    6f65:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    6f68:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    6f6c:	8b 45 0c             	mov    0xc(%ebp),%eax
    6f6f:	89 04 24             	mov    %eax,(%esp,1)
    6f72:	e8 f4 1f 00 00       	call   8f6b <skb_put>
			*lenPtr = htons((short)contLen);
    6f77:	0f b7 45 e8          	movzwl 0xffffffe8(%ebp),%eax
    6f7b:	89 04 24             	mov    %eax,(%esp,1)
    6f7e:	e8 fc ff ff ff       	call   6f7f <generateRequestsFromPending+0x6fa>
    6f83:	89 c2                	mov    %eax,%edx
    6f85:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    6f88:	66 89 10             	mov    %dx,(%eax)
			totalLen += sizeof(__u16) + contLen;
    6f8b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    6f8e:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    6f91:	83 c0 02             	add    $0x2,%eax
    6f94:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    6f97:	8d 45 d0             	lea    0xffffffd0(%ebp),%eax
    6f9a:	ff 00                	incl   (%eax)
    6f9c:	e9 6a ff ff ff       	jmp    6f0b <generateRequestsFromPending+0x686>
		}
		BUG_TRAP(totalLen <= TRICKLES_MSS);
    6fa1:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    6fa4:	3b 05 00 00 00 00    	cmp    0x0,%eax
    6faa:	76 14                	jbe    6fc0 <generateRequestsFromPending+0x73b>
    6fac:	c7 44 24 04 46 11 00 	movl   $0x1146,0x4(%esp,1)
    6fb3:	00 
    6fb4:	c7 04 24 80 28 00 00 	movl   $0x2880,(%esp,1)
    6fbb:	e8 fc ff ff ff       	call   6fbc <generateRequestsFromPending+0x737>
		wUpdateReq->type = UC_UPDATE;
    6fc0:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    6fc3:	c6 00 02             	movb   $0x2,(%eax)
		wUpdateReq->len = htons((short)(sizeof(*wUpdateReq) + totalLen));
    6fc6:	8b 5d cc             	mov    0xffffffcc(%ebp),%ebx
    6fc9:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    6fcc:	83 c0 0c             	add    $0xc,%eax
    6fcf:	0f b7 c0             	movzwl %ax,%eax
    6fd2:	89 04 24             	mov    %eax,(%esp,1)
    6fd5:	e8 fc ff ff ff       	call   6fd6 <generateRequestsFromPending+0x751>
    6fda:	66 89 43 01          	mov    %ax,0x1(%ebx)
		wreq->ucont_len = wUpdateReq->len;
    6fde:	8b 55 10             	mov    0x10(%ebp),%edx
    6fe1:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    6fe4:	0f b7 40 01          	movzwl 0x1(%eax),%eax
    6fe8:	66 89 42 4b          	mov    %ax,0x4b(%edx)
		break;
    6fec:	eb 15                	jmp    7003 <generateRequestsFromPending+0x77e>
	}
	default:
		printk("sendackhelper: Unknown request type!\n");
    6fee:	c7 04 24 e0 28 00 00 	movl   $0x28e0,(%esp,1)
    6ff5:	e8 fc ff ff ff       	call   6ff6 <generateRequestsFromPending+0x771>
		recordSample(&ctx,1);
		return OUT_FREE;
    6ffa:	c7 45 c4 ff ff ff ff 	movl   $0xffffffff,0xffffffc4(%ebp)
    7001:	eb 2b                	jmp    702e <generateRequestsFromPending+0x7a9>
	}
	mreq->transportResponseSeqStart = cont->firstTransportChild;
    7003:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    7006:	8b 45 14             	mov    0x14(%ebp),%eax
    7009:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    700f:	89 42 4c             	mov    %eax,0x4c(%edx)
	mreq->transportResponseSeqEnd =
    7012:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
    7015:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    7018:	8b 45 14             	mov    0x14(%ebp),%eax
    701b:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
    7021:	03 42 4c             	add    0x4c(%edx),%eax
    7024:	89 41 50             	mov    %eax,0x50(%ecx)
		mreq->transportResponseSeqStart + cont->numTransportChildren;

	recordSample(&ctx,2);
	return 0;
    7027:	c7 45 c4 00 00 00 00 	movl   $0x0,0xffffffc4(%ebp)
}
    702e:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    7031:	83 c4 50             	add    $0x50,%esp
    7034:	5b                   	pop    %ebx
    7035:	5d                   	pop    %ebp
    7036:	c3                   	ret    

00007037 <generateDataRequests>:

/* Precondition: skb head must point at location to place request header */

static int sendOnlyOneRequest = 0;

static inline
void generateRequestsFromMissingDataMap(struct sock *sk, struct sk_buff *skb,
					unsigned tseq_start, unsigned tseq_end,
					struct UC_Continuation **pdreq_ucont,
					struct GenerateDataContext *gctx,
					int *numRequests);
static inline
void generateRequestsFromUnrequestedData(struct sock *sk, struct sk_buff *skb,
					unsigned tseq_start, unsigned tseq_end,
					struct UC_Continuation **pdreq_ucont,
					struct GenerateDataContext *gctx,
					int *numRequests);

static inline
int generateDataRequests(struct sock *sk, struct sk_buff *skb,
		 struct WireTrickleRequest *wreq,
		 CONTINUATION_TYPE *cont) {
    7037:	55                   	push   %ebp
    7038:	89 e5                	mov    %esp,%ebp
    703a:	53                   	push   %ebx
    703b:	83 ec 6c             	sub    $0x6c,%esp
	USERACK_BEAT("generateDataRequests()\n");
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    703e:	8b 45 08             	mov    0x8(%ebp),%eax
    7041:	05 bc 00 00 00       	add    $0xbc,%eax
    7046:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

	struct WireUC_DataRequest *wDataReq = (struct WireUC_DataRequest*)
    7049:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp,1)
    7050:	00 
    7051:	8b 45 0c             	mov    0xc(%ebp),%eax
    7054:	89 04 24             	mov    %eax,(%esp,1)
    7057:	e8 0f 1f 00 00       	call   8f6b <skb_put>
    705c:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		skb_put(skb, sizeof(struct WireUC_DataRequest));
	unsigned outContLen;
	void *ptr;

	/* Execute simulation to initialize
	   minResponseLen
	   firstTransportChild
	   numTransportChildren

	   MUST occur after skb is initialized with transport-level fields!

	   xxx There should not be any simulation
	   dependencies on the header fields that are
	   initialized after start of simulation
	*/
	if(!runSimulation(sk,cont,skb)) {
    705f:	8b 45 0c             	mov    0xc(%ebp),%eax
    7062:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    7066:	8b 45 14             	mov    0x14(%ebp),%eax
    7069:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    706d:	8b 45 08             	mov    0x8(%ebp),%eax
    7070:	89 04 24             	mov    %eax,(%esp,1)
    7073:	e8 6a f1 ff ff       	call   61e2 <runSimulation>
    7078:	85 c0                	test   %eax,%eax
    707a:	75 0c                	jne    7088 <generateDataRequests+0x51>
		//printk("Simulation error\n");
		return OUT_FREE;
    707c:	c7 45 ac ff ff ff ff 	movl   $0xffffffff,0xffffffac(%ebp)
    7083:	e9 e4 02 00 00       	jmp    736c <generateDataRequests+0x335>
	}
	if(SIMULATION_NUM_PACKETS(cont) == 0) {
    7088:	8b 45 14             	mov    0x14(%ebp),%eax
    708b:	05 fc 00 00 00       	add    $0xfc,%eax
    7090:	83 b8 e8 00 00 00 00 	cmpl   $0x0,0xe8(%eax)
    7097:	75 0c                	jne    70a5 <generateDataRequests+0x6e>
#if 0
		if(IS_RECOVERY_STATE()) {
			printk("no children\n");
		}
#endif
		return OUT_FREE_IGNORE;
    7099:	c7 45 ac fe ff ff ff 	movl   $0xfffffffe,0xffffffac(%ebp)
    70a0:	e9 c7 02 00 00       	jmp    736c <generateDataRequests+0x335>
	}

#if 0 // 0822 obsolete due to packet-oriented handling
	if(cont->minResponseLen < USEFULNESS_THRESHOLD) {
		BUG_TRAP(cont->minResponseLen == 0);
		//printk("minResponseLen = %d\n", cont->minResponseLen);
		return OUT_FREE_IGNORE;
	}
#endif

	unsigned tseq_start = cont->firstTransportChild,
    70a5:	8b 45 14             	mov    0x14(%ebp),%eax
    70a8:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    70ae:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
		tseq_end = tseq_start + cont->numTransportChildren;
    70b1:	8b 45 14             	mov    0x14(%ebp),%eax
    70b4:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
    70ba:	03 45 e8             	add    0xffffffe8(%ebp),%eax
    70bd:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
	BUG_TRAP(tseq_start != -1 && tseq_end != -1);
    70c0:	83 7d e8 ff          	cmpl   $0xffffffff,0xffffffe8(%ebp)
    70c4:	74 08                	je     70ce <generateDataRequests+0x97>
    70c6:	83 7d e4 ff          	cmpl   $0xffffffff,0xffffffe4(%ebp)
    70ca:	74 02                	je     70ce <generateDataRequests+0x97>
    70cc:	eb 14                	jmp    70e2 <generateDataRequests+0xab>
    70ce:	c7 44 24 04 98 11 00 	movl   $0x1198,0x4(%esp,1)
    70d5:	00 
    70d6:	c7 04 24 20 29 00 00 	movl   $0x2920,(%esp,1)
    70dd:	e8 fc ff ff ff       	call   70de <generateDataRequests+0xa7>

#if 0
	if(cont->minResponseLen <= 0) {
		printk("simulation responseLen: %d\n", cont->minResponseLen);
	}
#endif

	// update parent with latest sequence number
	wreq->cont.parent = DATA_ONLY_REQNUM;
    70e2:	8b 45 10             	mov    0x10(%ebp),%eax
    70e5:	c7 40 0e ff ff ff ff 	movl   $0xffffffff,0xe(%eax)
	wDataReq->type = UC_DATA;
    70ec:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    70ef:	c6 00 03             	movb   $0x3,(%eax)
	wDataReq->len = -1;
    70f2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    70f5:	66 c7 40 01 ff ff    	movw   $0xffff,0x1(%eax)

	int numRequests = 0;
    70fb:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
	// First generate requests for data that was already requested, but lost
	struct UC_Continuation *dreq_ucont = NULL;
    7102:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
	//printk("premissing\n");
	struct GenerateDataContext gctx;
	GenerateDataContext_init(&gctx, (void*)0xFFFF0000, SIMULATION_PACKETS(cont),
    7109:	8b 45 14             	mov    0x14(%ebp),%eax
    710c:	05 fc 00 00 00       	add    $0xfc,%eax
    7111:	8b 80 e8 00 00 00    	mov    0xe8(%eax),%eax
    7117:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    711b:	8b 45 14             	mov    0x14(%ebp),%eax
    711e:	05 fc 00 00 00       	add    $0xfc,%eax
    7123:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
    7129:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    712d:	c7 44 24 04 00 00 ff 	movl   $0xffff0000,0x4(%esp,1)
    7134:	ff 
    7135:	8d 45 bc             	lea    0xffffffbc(%ebp),%eax
    7138:	89 04 24             	mov    %eax,(%esp,1)
    713b:	e8 5a 32 00 00       	call   a39a <GenerateDataContext_init>
				 SIMULATION_NUM_PACKETS(cont));
	generateRequestsFromMissingDataMap(sk, skb, tseq_start, tseq_end,
    7140:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
    7143:	89 44 24 18          	mov    %eax,0x18(%esp,1)
    7147:	8d 45 bc             	lea    0xffffffbc(%ebp),%eax
    714a:	89 44 24 14          	mov    %eax,0x14(%esp,1)
    714e:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
    7151:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    7155:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    7158:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    715c:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    715f:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    7163:	8b 45 0c             	mov    0xc(%ebp),%eax
    7166:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    716a:	8b 45 08             	mov    0x8(%ebp),%eax
    716d:	89 04 24             	mov    %eax,(%esp,1)
    7170:	e8 00 02 00 00       	call   7375 <generateRequestsFromMissingDataMap>
					&dreq_ucont, &gctx, &numRequests);
	GenerateDataContext_sanityCheck(&gctx);
    7175:	8d 45 bc             	lea    0xffffffbc(%ebp),%eax
    7178:	89 04 24             	mov    %eax,(%esp,1)
    717b:	e8 5d 34 00 00       	call   a5dd <GenerateDataContext_sanityCheck>
#if 0
	if(!(maxResponseLen <= cont->minResponseLen)) {
		BUG_TRAP(maxResponseLen <= cont->minResponseLen);
		printk("0: %d < %d\n", maxResponseLen, cont->minResponseLen);
	}	// Then, generate requests starting from byteReqNext
#endif

	static int missingCount = 0;
	if(numRequests > 0) {
    7180:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
    7184:	7e 06                	jle    718c <generateDataRequests+0x155>
		//printk("0: request used %d, %d left\n", cont->minResponseLen - maxResponseLen, maxResponseLen);
		missingCount++;
    7186:	ff 05 b8 00 00 00    	incl   0xb8
		if(0 && trickles_ratelimit()) {
			printk("MissingCount = %d\n", missingCount);
		}
	}
	int numMissingRequests = numRequests;
    718c:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    718f:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
	if(numRequests ==  0 || !sendOnlyOneRequest) {
    7192:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
    7196:	74 09                	je     71a1 <generateDataRequests+0x16a>
    7198:	83 3d b4 00 00 00 00 	cmpl   $0x0,0xb4
    719f:	75 78                	jne    7219 <generateDataRequests+0x1e2>
		int origNumRequests = numRequests;
    71a1:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    71a4:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
		generateRequestsFromUnrequestedData(sk, skb, tseq_start, tseq_end,
    71a7:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
    71aa:	89 44 24 18          	mov    %eax,0x18(%esp,1)
    71ae:	8d 45 bc             	lea    0xffffffbc(%ebp),%eax
    71b1:	89 44 24 14          	mov    %eax,0x14(%esp,1)
    71b5:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
    71b8:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    71bc:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    71bf:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    71c3:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    71c6:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    71ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    71cd:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    71d1:	8b 45 08             	mov    0x8(%ebp),%eax
    71d4:	89 04 24             	mov    %eax,(%esp,1)
    71d7:	e8 5b 04 00 00       	call   7637 <generateRequestsFromUnrequestedData>
						    &dreq_ucont, &gctx, &numRequests);
		if(origNumRequests < SIMULATION_NUM_PACKETS(cont) &&
    71dc:	8b 55 14             	mov    0x14(%ebp),%edx
    71df:	81 c2 fc 00 00 00    	add    $0xfc,%edx
    71e5:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
    71e8:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
    71ee:	7d 1d                	jge    720d <generateDataRequests+0x1d6>
    71f0:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    71f3:	3b 45 b4             	cmp    0xffffffb4(%ebp),%eax
    71f6:	75 15                	jne    720d <generateDataRequests+0x1d6>
		   numRequests == origNumRequests) {
			LOG_PACKET_USERBLOCKEVENT(cont);
			tp->t.timerState |= TRICKLES_NEED_USERACK;
    71f8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    71fb:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    71fe:	8b 92 dc 02 00 00    	mov    0x2dc(%edx),%edx
    7204:	83 ca 04             	or     $0x4,%edx
    7207:	89 90 dc 02 00 00    	mov    %edx,0x2dc(%eax)
		}
		if(numRequests > 0) {
    720d:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
    7211:	7e 06                	jle    7219 <generateDataRequests+0x1e2>
			static int unrequestedCount = 0;
			unrequestedCount++;
    7213:	ff 05 bc 00 00 00    	incl   0xbc
#if 0
			printk("1: request used %d, %d left (%d,%d)\n", cont->minResponseLen - maxResponseLen, maxResponseLen,
			       missingCount, unrequestedCount);
#endif
		}
	}
#if 0
	if(numMissingRequests == 0 && gctx.packetNum < gctx.numPackets && gctx.packetPos < ((gctx.packets[gctx.packetNum].len * 7) / 8) ) {
		if(trickles_ratelimit())
			printk("request too short; waiting until later\n");
		return OUT_FREE;
	}
#else
	numMissingRequests = -1;
    7219:	c7 45 b8 ff ff ff ff 	movl   $0xffffffff,0xffffffb8(%ebp)
#endif

#if 0
	//printk("postunrequested\n");
	if(maxResponseLen > cont->minResponseLen) {
		printk("1(bug): %d < %d\n", maxResponseLen, cont->minResponseLen);
		BUG();
	}
#endif
	BUG_TRAP(numRequests <= MAX_NUM_DATACHUNKS);
    7220:	83 7d e0 32          	cmpl   $0x32,0xffffffe0(%ebp)
    7224:	7e 14                	jle    723a <generateDataRequests+0x203>
    7226:	c7 44 24 04 e2 11 00 	movl   $0x11e2,0x4(%esp,1)
    722d:	00 
    722e:	c7 04 24 80 29 00 00 	movl   $0x2980,(%esp,1)
    7235:	e8 fc ff ff ff       	call   7236 <generateDataRequests+0x1ff>

	wDataReq->numRequestRanges = numRequests;
    723a:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    723d:	0f b6 45 e0          	movzbl 0xffffffe0(%ebp),%eax
    7241:	88 42 03             	mov    %al,0x3(%edx)
	//printk("Sending %d requests\n", numRequests);
	short wDataReqLen =
    7244:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    7247:	0f b6 40 03          	movzbl 0x3(%eax),%eax
    724b:	c1 e0 03             	shl    $0x3,%eax
    724e:	83 c0 04             	add    $0x4,%eax
    7251:	66 89 45 b2          	mov    %ax,0xffffffb2(%ebp)
		WIREUC_DATAREQUEST_SIZE(wDataReq->numRequestRanges);
	wDataReq->len = htons(wDataReqLen);
    7255:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
    7258:	0f b7 45 b2          	movzwl 0xffffffb2(%ebp),%eax
    725c:	89 04 24             	mov    %eax,(%esp,1)
    725f:	e8 fc ff ff ff       	call   7260 <generateDataRequests+0x229>
    7264:	66 89 43 01          	mov    %ax,0x1(%ebx)

#ifdef PRINT_CLIENT_ZEROCOUNT
	if(wDataReq->numRequestRanges) {
		static int zeroCount = 0;
		zeroCount++;
		if(trickles_ratelimit()) {
			printk("client ZeroCount (requestRanges) %d\n", zeroCount);
		}
	}
#endif

	if(dreq_ucont != NULL) {
    7268:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
    726c:	0f 84 d0 00 00 00    	je     7342 <generateDataRequests+0x30b>
		BUG_TRAP(numRequests > 0);
    7272:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
    7276:	7f 14                	jg     728c <generateDataRequests+0x255>
    7278:	c7 44 24 04 f5 11 00 	movl   $0x11f5,0x4(%esp,1)
    727f:	00 
    7280:	c7 04 24 e0 29 00 00 	movl   $0x29e0,(%esp,1)
    7287:	e8 fc ff ff ff       	call   7288 <generateDataRequests+0x251>
		outContLen = wDataReqLen +
    728c:	0f bf 5d b2          	movswl 0xffffffb2(%ebp),%ebx
    7290:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    7297:	00 
    7298:	8b 45 0c             	mov    0xc(%ebp),%eax
    729b:	89 04 24             	mov    %eax,(%esp,1)
    729e:	e8 c8 1c 00 00       	call   8f6b <skb_put>
    72a3:	89 c2                	mov    %eax,%edx
    72a5:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    72a8:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    72ac:	89 14 24             	mov    %edx,(%esp,1)
    72af:	e8 4c 2f 00 00       	call   a200 <marshallUC_Continuation>
    72b4:	8d 04 18             	lea    (%eax,%ebx,1),%eax
    72b7:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
			marshallUC_Continuation((struct WireUC_Continuation *)skb_put(skb,0), dreq_ucont);
		ptr = skb_put(skb, outContLen);
    72ba:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    72bd:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    72c1:	8b 45 0c             	mov    0xc(%ebp),%eax
    72c4:	89 04 24             	mov    %eax,(%esp,1)
    72c7:	e8 9f 1c 00 00       	call   8f6b <skb_put>
    72cc:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
		wreq->ucont_len = htons(outContLen);
    72cf:	8b 5d 10             	mov    0x10(%ebp),%ebx
    72d2:	0f b7 45 f0          	movzwl 0xfffffff0(%ebp),%eax
    72d6:	89 04 24             	mov    %eax,(%esp,1)
    72d9:	e8 fc ff ff ff       	call   72da <generateDataRequests+0x2a3>
    72de:	66 89 43 4b          	mov    %ax,0x4b(%ebx)
		BUG_TRAP(dreq_ucont->validStart <= dreq_ucont->validEnd);
    72e2:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    72e5:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    72e8:	8b 40 10             	mov    0x10(%eax),%eax
    72eb:	3b 42 14             	cmp    0x14(%edx),%eax
    72ee:	76 14                	jbe    7304 <generateDataRequests+0x2cd>
    72f0:	c7 44 24 04 fa 11 00 	movl   $0x11fa,0x4(%esp,1)
    72f7:	00 
    72f8:	c7 04 24 20 2a 00 00 	movl   $0x2a20,(%esp,1)
    72ff:	e8 fc ff ff ff       	call   7300 <generateDataRequests+0x2c9>

		if(1) {
			struct WireUC_Continuation *wucont = (struct WireUC_Continuation*) ptr;
    7304:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    7307:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
			BUG_TRAP(ntohl(wucont->validStart) <= ntohl(wucont->validEnd));
    730a:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
    730d:	8b 40 04             	mov    0x4(%eax),%eax
    7310:	89 04 24             	mov    %eax,(%esp,1)
    7313:	e8 fc ff ff ff       	call   7314 <generateDataRequests+0x2dd>
    7318:	89 c3                	mov    %eax,%ebx
    731a:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
    731d:	8b 40 08             	mov    0x8(%eax),%eax
    7320:	89 04 24             	mov    %eax,(%esp,1)
    7323:	e8 fc ff ff ff       	call   7324 <generateDataRequests+0x2ed>
    7328:	39 c3                	cmp    %eax,%ebx
    732a:	76 39                	jbe    7365 <generateDataRequests+0x32e>
    732c:	c7 44 24 04 fe 11 00 	movl   $0x11fe,0x4(%esp,1)
    7333:	00 
    7334:	c7 04 24 80 2a 00 00 	movl   $0x2a80,(%esp,1)
    733b:	e8 fc ff ff ff       	call   733c <generateDataRequests+0x305>
    7340:	eb 23                	jmp    7365 <generateDataRequests+0x32e>

#ifdef RECORD_UCONT_OFFSET
			cont->ucont_offset = (char*)ptr - (char*)wreq;
#endif
			//printk("ucont offset = %d\n", cont->ucont_offset);
		}
	} else {
		//printk("no data request\n");
#if 0
		if(IS_RECOVERY_STATE()) {
			printk("no recovery data request -- ucontlist len = %d, num response packets = %d\n", tp->t.ucontList.len, SIMULATION_NUM_PACKETS(cont));
		}
#endif
		BUG_TRAP(numRequests == 0);
    7342:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
    7346:	74 14                	je     735c <generateDataRequests+0x325>
    7348:	c7 44 24 04 0c 12 00 	movl   $0x120c,0x4(%esp,1)
    734f:	00 
    7350:	c7 04 24 00 2b 00 00 	movl   $0x2b00,(%esp,1)
    7357:	e8 fc ff ff ff       	call   7358 <generateDataRequests+0x321>
		return OUT_NODATAREQUEST;
    735c:	c7 45 ac fd ff ff ff 	movl   $0xfffffffd,0xffffffac(%ebp)
    7363:	eb 07                	jmp    736c <generateDataRequests+0x335>
	}

#ifdef DISABLE_DATAREQUEST // 0418 added in attempt to isolate mapping lists from rest of system
	freeDataRequestMapping(dataReqMap);
#endif
	recordSample(&ctx,3);
	recordSample(&ctx,4);

	return 0;
    7365:	c7 45 ac 00 00 00 00 	movl   $0x0,0xffffffac(%ebp)
 }
    736c:	8b 45 ac             	mov    0xffffffac(%ebp),%eax
    736f:	83 c4 6c             	add    $0x6c,%esp
    7372:	5b                   	pop    %ebx
    7373:	5d                   	pop    %ebp
    7374:	c3                   	ret    

00007375 <generateRequestsFromMissingDataMap>:

static inline
int addDataRequest(struct sock *sk, struct sk_buff *skb,
		   unsigned tseq_start,
		   struct DataRequestMapping *dataReqMap) {
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	 struct DataRequestMapping *finger;
	 finger = (struct DataRequestMapping*)tp->t.dataRequestMap.prev;
#ifndef DISABLE_DATAREQUEST
	 insert_tail(&tp->t.dataRequestMap, (struct alloc_head*)dataReqMap);
#endif
	 dataReqMap->sent = 1;
	 BUG_TRAP(dataReqMap->start < dataReqMap->end);

	 //printk("Added data request [%d-%d]\n", dataReqMap->start, dataReqMap->end);
	 if(finger != (struct DataRequestMapping *)&tp->t.dataRequestMap) {
		 if(finger->transportResponseSeqEnd > tseq_start) {
			 if(!disableSevereErrors) {
				 printk("WARNING: Out of order continuation transportResponseSeqEnd received (%u %u). Either server or client is buggy\n", finger->transportResponseSeqEnd, tseq_start);
			 }
		 }
	 }
	 if(!skb_can_put(skb, sizeof(struct WireUC_DataRequestRange))) {
		 printk("Cannot add new data request range\n");
		 return -1;
	 }
	 struct WireUC_DataRequestRange *range = (struct WireUC_DataRequestRange *)
		 skb_put(skb, sizeof(struct WireUC_DataRequestRange));
	 range->start = htonl(dataReqMap->start);
	 range->end = htonl(dataReqMap->end);
	 //printk("Added request %d-%d\n", dataReqMap->start, dataReqMap->end);
	 return 0;
 }

// Returns the number of generated requests

#define CAN_SEND_MORE_REQUESTS(CURR_REQNUM)			\
	((CURR_REQNUM) < MAX_NUM_DATACHUNKS)

#define CHECK_FOR_DIFFERENT_CONTINUATION(UCONT)		\
	(*pdreq_ucont != NULL && *pdreq_ucont != ucont)

static inline
void generateRequestsFromMissingDataMap(struct sock *sk, struct sk_buff *skb,
				unsigned tseq_start, unsigned tseq_end,
				struct UC_Continuation **pdreq_ucont,
				struct GenerateDataContext *gctx,
				int *numRequests) {
    7375:	55                   	push   %ebp
    7376:	89 e5                	mov    %esp,%ebp
    7378:	83 ec 4c             	sub    $0x4c,%esp
	USERACK_BEAT("generateRequestsFromMissingDataMap()\n");
	int origNumRequests = *numRequests;
    737b:	8b 45 20             	mov    0x20(%ebp),%eax
    737e:	8b 00                	mov    (%eax),%eax
    7380:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    7383:	8b 45 08             	mov    0x8(%ebp),%eax
    7386:	05 bc 00 00 00       	add    $0xbc,%eax
    738b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	BUG_TRAP(*numRequests < MAX_NUM_DATACHUNKS);
    738e:	8b 45 20             	mov    0x20(%ebp),%eax
    7391:	83 38 31             	cmpl   $0x31,(%eax)
    7394:	7e 14                	jle    73aa <generateRequestsFromMissingDataMap+0x35>
    7396:	c7 44 24 04 4b 12 00 	movl   $0x124b,0x4(%esp,1)
    739d:	00 
    739e:	c7 04 24 40 2b 00 00 	movl   $0x2b40,(%esp,1)
    73a5:	e8 fc ff ff ff       	call   73a6 <generateRequestsFromMissingDataMap+0x31>
    73aa:	90                   	nop    

#if 0
	if(IS_RECOVERY_STATE()) {
		printk("recovery missing data map top\n");
	}
#endif
	while(CAN_SEND_MORE_REQUESTS(*numRequests)  &&
    73ab:	8b 45 20             	mov    0x20(%ebp),%eax
    73ae:	83 38 31             	cmpl   $0x31,(%eax)
    73b1:	0f 8f 7e 02 00 00    	jg     7635 <generateRequestsFromMissingDataMap+0x2c0>
    73b7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    73ba:	05 c0 09 00 00       	add    $0x9c0,%eax
    73bf:	89 04 24             	mov    %eax,(%esp,1)
    73c2:	e8 f8 1d 00 00       	call   91bf <empty>
    73c7:	85 c0                	test   %eax,%eax
    73c9:	0f 85 66 02 00 00    	jne    7635 <generateRequestsFromMissingDataMap+0x2c0>
	      !empty(&tp->t.missingDataMap)) {
#if 0
		if(IS_RECOVERY_STATE()) {
			printk("recovery missing data map inside top\n");
		}
#endif
		// simulate server-side response to this request
		int maxLen = GenerateDataContext_simulateRequest(gctx);
    73cf:	8b 45 1c             	mov    0x1c(%ebp),%eax
    73d2:	89 04 24             	mov    %eax,(%esp,1)
    73d5:	e8 bf 31 00 00       	call   a599 <GenerateDataContext_simulateRequest>
    73da:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		if(maxLen <= 0) {
    73dd:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
    73e1:	7f 05                	jg     73e8 <generateRequestsFromMissingDataMap+0x73>
#if 0
			printk("missingdatamap: no more space for data chunks at ");
			GenerateDataContext_dump(gctx);
#endif
			break;
    73e3:	e9 4d 02 00 00       	jmp    7635 <generateRequestsFromMissingDataMap+0x2c0>
		}
		// printk("missingDataMap maxLen = %d ", maxLen);

		recordSample(&ctx,3);
		BUG_TRAP(enableDataRecovery);
    73e8:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    73ef:	75 14                	jne    7405 <generateRequestsFromMissingDataMap+0x90>
    73f1:	c7 44 24 04 65 12 00 	movl   $0x1265,0x4(%esp,1)
    73f8:	00 
    73f9:	c7 04 24 a0 2b 00 00 	movl   $0x2ba0,(%esp,1)
    7400:	e8 fc ff ff ff       	call   7401 <generateRequestsFromMissingDataMap+0x8c>

		struct DataRequestMapping *dataReqMap = (struct DataRequestMapping*)
    7405:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    7408:	8b 80 c4 09 00 00    	mov    0x9c4(%eax),%eax
    740e:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
			tp->t.missingDataMap.next;
		struct UC_Continuation *ucont = dataReqMap->ucont;
    7411:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    7414:	8b 40 0c             	mov    0xc(%eax),%eax
    7417:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
#if 1 // 0810 adjust based on rcv_nxt, to accomodate unforseen piggyback and other cases
// 0813 Not so sure this is the best place to put this check
		int oldStart = dataReqMap->start;
    741a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    741d:	8b 40 20             	mov    0x20(%eax),%eax
    7420:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
		dataReqMap->start = MIN(MAX(dataReqMap->start, tp->rcv_nxt), dataReqMap->end);
    7423:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    7426:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    7429:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    742c:	8b 40 24             	mov    0x24(%eax),%eax
    742f:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    7432:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    7435:	8b 40 08             	mov    0x8(%eax),%eax
    7438:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    743b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    743e:	8b 40 20             	mov    0x20(%eax),%eax
    7441:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    7444:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    7447:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
    744a:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
    744d:	89 55 cc             	mov    %edx,0xffffffcc(%ebp)
    7450:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    7453:	3b 45 d8             	cmp    0xffffffd8(%ebp),%eax
    7456:	73 06                	jae    745e <generateRequestsFromMissingDataMap+0xe9>
    7458:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    745b:	89 55 cc             	mov    %edx,0xffffffcc(%ebp)
    745e:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    7461:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    7464:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    7467:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
    746a:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
    746d:	89 55 c8             	mov    %edx,0xffffffc8(%ebp)
    7470:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    7473:	3b 45 e0             	cmp    0xffffffe0(%ebp),%eax
    7476:	76 06                	jbe    747e <generateRequestsFromMissingDataMap+0x109>
    7478:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    747b:	89 55 c8             	mov    %edx,0xffffffc8(%ebp)
    747e:	8b 55 c8             	mov    0xffffffc8(%ebp),%edx
    7481:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    7484:	89 50 20             	mov    %edx,0x20(%eax)
		if(oldStart != dataReqMap->start) {
			if(0 && trickles_ratelimit()) {
				printk("OldStart %d NewStart %d End %d\n",
				       oldStart, dataReqMap->start, dataReqMap->end);
			}
		}
#endif

		if(CHECK_FOR_DIFFERENT_CONTINUATION(ucont)) {
    7487:	8b 45 18             	mov    0x18(%ebp),%eax
    748a:	83 38 00             	cmpl   $0x0,(%eax)
    748d:	74 1b                	je     74aa <generateRequestsFromMissingDataMap+0x135>
    748f:	8b 45 18             	mov    0x18(%ebp),%eax
    7492:	8b 00                	mov    (%eax),%eax
    7494:	3b 45 ec             	cmp    0xffffffec(%ebp),%eax
    7497:	74 11                	je     74aa <generateRequestsFromMissingDataMap+0x135>
			printk("GenerateRequestsfrom missing data map: Different data request continuation needed\n");
    7499:	c7 04 24 00 2c 00 00 	movl   $0x2c00,(%esp,1)
    74a0:	e8 fc ff ff ff       	call   74a1 <generateRequestsFromMissingDataMap+0x12c>
			return;
    74a5:	e9 8b 01 00 00       	jmp    7635 <generateRequestsFromMissingDataMap+0x2c0>
		}
		if(ucont == NULL) {
    74aa:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
    74ae:	75 0c                	jne    74bc <generateRequestsFromMissingDataMap+0x147>
			printk("Setting pdreq_ucont to NULL\n");
    74b0:	c7 04 24 53 2c 00 00 	movl   $0x2c53,(%esp,1)
    74b7:	e8 fc ff ff ff       	call   74b8 <generateRequestsFromMissingDataMap+0x143>
		}
		*pdreq_ucont = ucont;
    74bc:	8b 55 18             	mov    0x18(%ebp),%edx
    74bf:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    74c2:	89 02                	mov    %eax,(%edx)

		if(dataReqMap->end - dataReqMap->start > maxLen) {
    74c4:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    74c7:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    74ca:	8b 50 20             	mov    0x20(%eax),%edx
    74cd:	8b 41 24             	mov    0x24(%ecx),%eax
    74d0:	29 d0                	sub    %edx,%eax
    74d2:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
    74d5:	76 72                	jbe    7549 <generateRequestsFromMissingDataMap+0x1d4>
			unsigned newStart = dataReqMap->start + maxLen;
    74d7:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    74da:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    74dd:	03 42 20             	add    0x20(%edx),%eax
    74e0:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
			struct DataRequestMapping *rest =
    74e3:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    74e6:	8b 40 24             	mov    0x24(%eax),%eax
    74e9:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    74ed:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    74f0:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    74f4:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp,1)
    74fb:	ff 
    74fc:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp,1)
    7503:	ff 
    7504:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    7507:	89 04 24             	mov    %eax,(%esp,1)
    750a:	e8 84 21 00 00       	call   9693 <newDataRequestMapping>
    750f:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
				newDataRequestMapping(ucont, -1, -1, newStart, dataReqMap->end);
			if(rest == NULL) {
    7512:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
    7516:	75 11                	jne    7529 <generateRequestsFromMissingDataMap+0x1b4>
				printk("out of memory while splitting missing data mapping\n");
    7518:	c7 04 24 80 2c 00 00 	movl   $0x2c80,(%esp,1)
    751f:	e8 fc ff ff ff       	call   7520 <generateRequestsFromMissingDataMap+0x1ab>
				recordSample(&ctx,1);
				return;
    7524:	e9 0c 01 00 00       	jmp    7635 <generateRequestsFromMissingDataMap+0x2c0>
			}
			dataReqMap->end = newStart;
    7529:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    752c:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    752f:	89 42 24             	mov    %eax,0x24(%edx)
			RECORD_MISSINGDATAMAP_INSERTION(rest);
			insert_tail(&tp->t.missingDataMap,
    7532:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    7535:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    7539:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    753c:	05 c0 09 00 00       	add    $0x9c0,%eax
    7541:	89 04 24             	mov    %eax,(%esp,1)
    7544:	e8 2b 1d 00 00       	call   9274 <insert_tail>
				    (struct alloc_head*)rest);
		}
		int actualLen = dataReqMap->end - dataReqMap->start;
    7549:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    754c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    754f:	8b 50 20             	mov    0x20(%eax),%edx
    7552:	8b 41 24             	mov    0x24(%ecx),%eax
    7555:	29 d0                	sub    %edx,%eax
    7557:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
		if(!(actualLen <= maxLen)) {
    755a:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    755d:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
    7560:	7e 1c                	jle    757e <generateRequestsFromMissingDataMap+0x209>
			BUG_TRAP(actualLen <= maxLen);
    7562:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    7565:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
    7568:	7e 14                	jle    757e <generateRequestsFromMissingDataMap+0x209>
    756a:	c7 44 24 04 8f 12 00 	movl   $0x128f,0x4(%esp,1)
    7571:	00 
    7572:	c7 04 24 c0 2c 00 00 	movl   $0x2cc0,(%esp,1)
    7579:	e8 fc ff ff ff       	call   757a <generateRequestsFromMissingDataMap+0x205>
		}
		unlink((struct alloc_head*)dataReqMap);
    757e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    7581:	89 04 24             	mov    %eax,(%esp,1)
    7584:	e8 63 1d 00 00       	call   92ec <unlink>
		if(actualLen == 0) {
    7589:	83 7d d4 00          	cmpl   $0x0,0xffffffd4(%ebp)
    758d:	75 10                	jne    759f <generateRequestsFromMissingDataMap+0x22a>
			// this mapping is now useless
			freeDataRequestMapping(dataReqMap);
    758f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    7592:	89 04 24             	mov    %eax,(%esp,1)
    7595:	e8 9f 21 00 00       	call   9739 <freeDataRequestMapping>
			continue;
    759a:	e9 0c fe ff ff       	jmp    73ab <generateRequestsFromMissingDataMap+0x36>
		}

		dataReqMap->transportResponseSeqStart = tseq_start;
    759f:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    75a2:	8b 45 10             	mov    0x10(%ebp),%eax
    75a5:	89 42 18             	mov    %eax,0x18(%edx)
		dataReqMap->transportResponseSeqEnd = tseq_end;
    75a8:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    75ab:	8b 45 14             	mov    0x14(%ebp),%eax
    75ae:	89 42 1c             	mov    %eax,0x1c(%edx)
		recordSample(&ctx,3);
		//printk("missing dataRequest = [%d,%d]\n", dataReqMap->start, dataReqMap->end);
		if(addDataRequest(sk, skb, tseq_start, dataReqMap)) {
    75b1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    75b4:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    75b8:	8b 45 10             	mov    0x10(%ebp),%eax
    75bb:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    75bf:	8b 45 0c             	mov    0xc(%ebp),%eax
    75c2:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    75c6:	8b 45 08             	mov    0x8(%ebp),%eax
    75c9:	89 04 24             	mov    %eax,(%esp,1)
    75cc:	e8 03 47 00 00       	call   bcd4 <addDataRequest>
    75d1:	85 c0                	test   %eax,%eax
    75d3:	74 0e                	je     75e3 <generateRequestsFromMissingDataMap+0x26e>
			printk("generateRequestsFromMissingDataMap: no more space in request for more data\n");
    75d5:	c7 04 24 20 2d 00 00 	movl   $0x2d20,(%esp,1)
    75dc:	e8 fc ff ff ff       	call   75dd <generateRequestsFromMissingDataMap+0x268>
			return;
    75e1:	eb 52                	jmp    7635 <generateRequestsFromMissingDataMap+0x2c0>
		}

		//printk("actualLen = %d\n", actualLen);
		void *check = GenerateDataContext_put(gctx, actualLen);
    75e3:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    75e6:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    75ea:	8b 45 1c             	mov    0x1c(%ebp),%eax
    75ed:	89 04 24             	mov    %eax,(%esp,1)
    75f0:	e8 de 2d 00 00       	call   a3d3 <GenerateDataContext_put>
    75f5:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
		if(check == NULL) BUG();
    75f8:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
    75fc:	75 25                	jne    7623 <generateRequestsFromMissingDataMap+0x2ae>
    75fe:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    7605:	00 
    7606:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    760d:	e8 fc ff ff ff       	call   760e <generateRequestsFromMissingDataMap+0x299>
    7612:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    7619:	e8 fc ff ff ff       	call   761a <generateRequestsFromMissingDataMap+0x2a5>
    761e:	e8 fc ff ff ff       	call   761f <generateRequestsFromMissingDataMap+0x2aa>

		(*numRequests)++;
    7623:	8b 45 20             	mov    0x20(%ebp),%eax
    7626:	ff 00                	incl   (%eax)
		if(sendOnlyOneRequest) {
    7628:	83 3d b4 00 00 00 00 	cmpl   $0x0,0xb4
    762f:	0f 84 76 fd ff ff    	je     73ab <generateRequestsFromMissingDataMap+0x36>
			break;
		}
	}

	if(0 && *numRequests == origNumRequests) {
		printk("Missing data: No requests generated %d %d\n",
		       CAN_SEND_MORE_REQUESTS(*numRequests),
		       !empty(&tp->t.missingDataMap));
	}
}
    7635:	c9                   	leave  
    7636:	c3                   	ret    

00007637 <generateRequestsFromUnrequestedData>:


// Returns the number of generated requests

static inline
void generateRequestsFromUnrequestedData(struct sock *sk, struct sk_buff *skb,
				unsigned tseq_start, unsigned tseq_end,
				struct UC_Continuation **pdreq_ucont,
				struct GenerateDataContext *gctx,
				int *numRequests) {
    7637:	55                   	push   %ebp
    7638:	89 e5                	mov    %esp,%ebp
    763a:	83 ec 74             	sub    $0x74,%esp
	USERACK_BEAT("generateRequestsFromUnrequestedData()\n");
	enum BreakReason {
		NONE,
		NO_MORE_SPACE,
		SEND_ONLY_ONE
	} reason = NONE;
    763d:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
	int origNumRequests = *numRequests;
    7644:	8b 45 20             	mov    0x20(%ebp),%eax
    7647:	8b 00                	mov    (%eax),%eax
    7649:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	int loopTopCount = 0, loopBottomCount = 0;
    764c:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
    7653:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    765a:	8b 45 08             	mov    0x8(%ebp),%eax
    765d:	05 bc 00 00 00       	add    $0xbc,%eax
    7662:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	int first = 1;
    7665:	c7 45 e8 01 00 00 00 	movl   $0x1,0xffffffe8(%ebp)

	 recordSample(&ctx,4);
#if 0
	if(IS_RECOVERY_STATE()) {
		printk("recovery unrequested top\n");
	}
#endif

	// We want to avoid sending short requests that don't use up
	// all available packets. So, only perform the in_window check
	// once
	 while(CAN_SEND_MORE_REQUESTS(*numRequests) &&
    766c:	8b 45 20             	mov    0x20(%ebp),%eax
    766f:	83 38 31             	cmpl   $0x31,(%eax)
    7672:	0f 8f 32 03 00 00    	jg     79aa <generateRequestsFromUnrequestedData+0x373>
    7678:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
    767c:	74 1f                	je     769d <generateRequestsFromUnrequestedData+0x66>
    767e:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    7681:	8b 55 08             	mov    0x8(%ebp),%edx
    7684:	8b 45 08             	mov    0x8(%ebp),%eax
    7687:	8b 40 38             	mov    0x38(%eax),%eax
    768a:	03 82 c4 00 00 00    	add    0xc4(%edx),%eax
    7690:	39 81 d4 09 00 00    	cmp    %eax,0x9d4(%ecx)
    7696:	72 05                	jb     769d <generateRequestsFromUnrequestedData+0x66>
    7698:	e9 0d 03 00 00       	jmp    79aa <generateRequestsFromUnrequestedData+0x373>
	       (!first || IN_WINDOW(sk, tp->t.byteReqNext))) {
		 first = 0;
    769d:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
#if 0
		if(IS_RECOVERY_STATE()) {
			printk("recovery unrequested data map inside top\n");
		}
#endif
		 loopTopCount++;
    76a4:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
    76a7:	ff 00                	incl   (%eax)
		 int maxLen = GenerateDataContext_simulateRequest(gctx);
    76a9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    76ac:	89 04 24             	mov    %eax,(%esp,1)
    76af:	e8 e5 2e 00 00       	call   a599 <GenerateDataContext_simulateRequest>
    76b4:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
		if(maxLen <= 0) {
    76b7:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
    76bb:	7f 0c                	jg     76c9 <generateRequestsFromUnrequestedData+0x92>
#if 0
			printk("unrequestedData: no more space for data chunks at ");
			GenerateDataContext_dump(gctx);
#endif
			reason = NO_MORE_SPACE;
    76bd:	c7 45 fc 01 00 00 00 	movl   $0x1,0xfffffffc(%ebp)
			break;
    76c4:	e9 e1 02 00 00       	jmp    79aa <generateRequestsFromUnrequestedData+0x373>
		}
		//printk("UnrequestedData maxLen = %d ", maxLen);

		 struct sk_buff *finger;
		 unsigned start, end;
		 unsigned gapLen = 0;
    76c9:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
		 // XXX: needs more performance tuning, e.g. hint pointing at next element to process

		 if(tp->t.byteReqHint) {
    76d0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    76d3:	83 b8 d8 09 00 00 00 	cmpl   $0x0,0x9d8(%eax)
    76da:	74 0e                	je     76ea <generateRequestsFromUnrequestedData+0xb3>
			 finger = tp->t.byteReqHint;
    76dc:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    76df:	8b 80 d8 09 00 00    	mov    0x9d8(%eax),%eax
    76e5:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    76e8:	eb 0c                	jmp    76f6 <generateRequestsFromUnrequestedData+0xbf>
		 } else {
			 finger = tp->t.data_ofo_queue.next;
    76ea:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    76ed:	8b 80 78 09 00 00    	mov    0x978(%eax),%eax
    76f3:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    76f6:	90                   	nop    
		 }
		 // SACK: Find a gap to fill in
		 while(finger != (struct sk_buff*)&tp->t.data_ofo_queue) {
    76f7:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    76fa:	05 78 09 00 00       	add    $0x978,%eax
    76ff:	39 45 e0             	cmp    %eax,0xffffffe0(%ebp)
    7702:	75 05                	jne    7709 <generateRequestsFromUnrequestedData+0xd2>
    7704:	e9 87 00 00 00       	jmp    7790 <generateRequestsFromUnrequestedData+0x159>
			 if(SKB_CONTAINS(finger, tp->t.byteReqNext)) {
    7709:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    770c:	83 c0 30             	add    $0x30,%eax
    770f:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    7712:	8b 40 10             	mov    0x10(%eax),%eax
    7715:	3b 82 d4 09 00 00    	cmp    0x9d4(%edx),%eax
    771b:	77 50                	ja     776d <generateRequestsFromUnrequestedData+0x136>
    771d:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    7720:	83 c0 30             	add    $0x30,%eax
    7723:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    7726:	8b 40 14             	mov    0x14(%eax),%eax
    7729:	3b 82 d4 09 00 00    	cmp    0x9d4(%edx),%eax
    772f:	76 3c                	jbe    776d <generateRequestsFromUnrequestedData+0x136>
				 tp->t.byteReqNext = TCP_SKB_CB(finger)->end_seq;
    7731:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    7734:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    7737:	83 c0 30             	add    $0x30,%eax
    773a:	8b 40 14             	mov    0x14(%eax),%eax
    773d:	89 82 d4 09 00 00    	mov    %eax,0x9d4(%edx)
				 if(finger->next != (struct sk_buff*)&tp->t.data_ofo_queue) {
    7743:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    7746:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    7749:	05 78 09 00 00       	add    $0x978,%eax
    774e:	39 02                	cmp    %eax,(%edx)
    7750:	74 31                	je     7783 <generateRequestsFromUnrequestedData+0x14c>
					 gapLen = TCP_SKB_CB(finger->next)->seq - tp->t.byteReqNext;
    7752:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    7755:	8b 08                	mov    (%eax),%ecx
    7757:	83 c1 30             	add    $0x30,%ecx
    775a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    775d:	8b 90 d4 09 00 00    	mov    0x9d4(%eax),%edx
    7763:	8b 41 10             	mov    0x10(%ecx),%eax
    7766:	29 d0                	sub    %edx,%eax
    7768:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
    776b:	eb 16                	jmp    7783 <generateRequestsFromUnrequestedData+0x14c>
				 }
			 } else if(TCP_SKB_CB(finger)->seq > tp->t.byteReqNext) {
    776d:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    7770:	83 c0 30             	add    $0x30,%eax
    7773:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    7776:	8b 40 10             	mov    0x10(%eax),%eax
    7779:	3b 82 d4 09 00 00    	cmp    0x9d4(%edx),%eax
    777f:	76 02                	jbe    7783 <generateRequestsFromUnrequestedData+0x14c>
				 break;
    7781:	eb 0d                	jmp    7790 <generateRequestsFromUnrequestedData+0x159>
			 }
			 finger = finger->next;
    7783:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    7786:	8b 00                	mov    (%eax),%eax
    7788:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    778b:	e9 67 ff ff ff       	jmp    76f7 <generateRequestsFromUnrequestedData+0xc0>
		 }
		 if(gapLen == 0) {
    7790:	83 7d d4 00          	cmpl   $0x0,0xffffffd4(%ebp)
    7794:	75 06                	jne    779c <generateRequestsFromUnrequestedData+0x165>
			 gapLen = maxLen;
    7796:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    7799:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
		 }
		 if(finger != (struct sk_buff *)&tp->t.data_ofo_queue) {
    779c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    779f:	05 78 09 00 00       	add    $0x978,%eax
    77a4:	39 45 e0             	cmp    %eax,0xffffffe0(%ebp)
    77a7:	74 0e                	je     77b7 <generateRequestsFromUnrequestedData+0x180>
			 tp->t.byteReqHint = finger;
    77a9:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    77ac:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    77af:	89 82 d8 09 00 00    	mov    %eax,0x9d8(%edx)
    77b5:	eb 0d                	jmp    77c4 <generateRequestsFromUnrequestedData+0x18d>
		 } else {
			 tp->t.byteReqHint = NULL;
    77b7:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    77ba:	c7 80 d8 09 00 00 00 	movl   $0x0,0x9d8(%eax)
    77c1:	00 00 00 
		 }

		 start = tp->t.byteReqNext;
    77c4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    77c7:	8b 80 d4 09 00 00    	mov    0x9d4(%eax),%eax
    77cd:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
		 struct UC_Continuation *ucont = findUCContinuation(sk, start, start + gapLen);
    77d0:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    77d3:	03 45 dc             	add    0xffffffdc(%ebp),%eax
    77d6:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    77da:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    77dd:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    77e1:	8b 45 08             	mov    0x8(%ebp),%eax
    77e4:	89 04 24             	mov    %eax,(%esp,1)
    77e7:	e8 fc ff ff ff       	call   77e8 <generateRequestsFromUnrequestedData+0x1b1>
    77ec:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)

		 // XXX XXX XXX
		 // Logic is not 100% kosher. State mutation occurs before checking that request can actually be sent
		 if(ucont == NULL) {
    77ef:	83 7d d0 00          	cmpl   $0x0,0xffffffd0(%ebp)
    77f3:	75 05                	jne    77fa <generateRequestsFromUnrequestedData+0x1c3>
			 //printk("could not find ucont (%d,%d)\n", start, start + gapLen);
			 recordSample(&ctx,1);
			 goto error;
    77f5:	e9 0e 02 00 00       	jmp    7a08 <generateRequestsFromUnrequestedData+0x3d1>
		 }

		 // Place this check before ALL state mutation
		if(CHECK_FOR_DIFFERENT_CONTINUATION(ucont)) {
    77fa:	8b 45 18             	mov    0x18(%ebp),%eax
    77fd:	83 38 00             	cmpl   $0x0,(%eax)
    7800:	74 1b                	je     781d <generateRequestsFromUnrequestedData+0x1e6>
    7802:	8b 45 18             	mov    0x18(%ebp),%eax
    7805:	8b 00                	mov    (%eax),%eax
    7807:	3b 45 d0             	cmp    0xffffffd0(%ebp),%eax
    780a:	74 11                	je     781d <generateRequestsFromUnrequestedData+0x1e6>
			printk("GenerateRequestsfrom missing data map: Different data request continuation needed\n");
    780c:	c7 04 24 00 2c 00 00 	movl   $0x2c00,(%esp,1)
    7813:	e8 fc ff ff ff       	call   7814 <generateRequestsFromUnrequestedData+0x1dd>
			return;
    7818:	e9 eb 01 00 00       	jmp    7a08 <generateRequestsFromUnrequestedData+0x3d1>
		}
		if(ucont == NULL) {
    781d:	83 7d d0 00          	cmpl   $0x0,0xffffffd0(%ebp)
    7821:	75 0c                	jne    782f <generateRequestsFromUnrequestedData+0x1f8>
			printk("Setting pdreq_ucont to NULL\n");
    7823:	c7 04 24 53 2c 00 00 	movl   $0x2c53,(%esp,1)
    782a:	e8 fc ff ff ff       	call   782b <generateRequestsFromUnrequestedData+0x1f4>
		}
		*pdreq_ucont = ucont;
    782f:	8b 55 18             	mov    0x18(%ebp),%edx
    7832:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    7835:	89 02                	mov    %eax,(%edx)

		int tryRequestLen = MIN(gapLen, maxLen);
    7837:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    783a:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
    783d:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    7840:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
    7843:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    7846:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
    7849:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
    784c:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
    784f:	8b 55 bc             	mov    0xffffffbc(%ebp),%edx
    7852:	3b 55 c4             	cmp    0xffffffc4(%ebp),%edx
    7855:	76 06                	jbe    785d <generateRequestsFromUnrequestedData+0x226>
    7857:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    785a:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
    785d:	8b 55 bc             	mov    0xffffffbc(%ebp),%edx
    7860:	89 55 cc             	mov    %edx,0xffffffcc(%ebp)
		tp->t.byteReqNext = end =
    7863:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    7866:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
			 MIN(start + tryRequestLen, ucont->validEnd);
    7869:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    786c:	8b 40 14             	mov    0x14(%eax),%eax
    786f:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
    7872:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    7875:	03 45 dc             	add    0xffffffdc(%ebp),%eax
    7878:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
    787b:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
    787e:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
    7881:	8b 55 c8             	mov    0xffffffc8(%ebp),%edx
    7884:	89 55 b4             	mov    %edx,0xffffffb4(%ebp)
    7887:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
    788a:	3b 45 c4             	cmp    0xffffffc4(%ebp),%eax
    788d:	76 06                	jbe    7895 <generateRequestsFromUnrequestedData+0x25e>
    788f:	8b 55 c4             	mov    0xffffffc4(%ebp),%edx
    7892:	89 55 b4             	mov    %edx,0xffffffb4(%ebp)
    7895:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
    7898:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    789b:	8b 55 b8             	mov    0xffffffb8(%ebp),%edx
    789e:	89 82 d4 09 00 00    	mov    %eax,0x9d4(%edx)
		 int actualLen = end - start;
    78a4:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    78a7:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    78aa:	29 d0                	sub    %edx,%eax
    78ac:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)

		 tp->t.byteReqHint = NULL;
    78af:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    78b2:	c7 80 d8 09 00 00 00 	movl   $0x0,0x9d8(%eax)
    78b9:	00 00 00 
		 struct DataRequestMapping *dataReqMap =
    78bc:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    78bf:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    78c3:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    78c6:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    78ca:	8b 45 14             	mov    0x14(%ebp),%eax
    78cd:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    78d1:	8b 45 10             	mov    0x10(%ebp),%eax
    78d4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    78d8:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    78db:	89 04 24             	mov    %eax,(%esp,1)
    78de:	e8 b0 1d 00 00       	call   9693 <newDataRequestMapping>
    78e3:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
			 newDataRequestMapping(ucont, tseq_start, tseq_end, start, end);
		 if(dataReqMap == NULL) {
    78e6:	83 7d c4 00          	cmpl   $0x0,0xffffffc4(%ebp)
    78ea:	75 11                	jne    78fd <generateRequestsFromUnrequestedData+0x2c6>
			 printk("Out of memory while allocating new data request mapping\n");
    78ec:	c7 04 24 80 2d 00 00 	movl   $0x2d80,(%esp,1)
    78f3:	e8 fc ff ff ff       	call   78f4 <generateRequestsFromUnrequestedData+0x2bd>
			 recordSample(&ctx,1);
			 goto error;
    78f8:	e9 0b 01 00 00       	jmp    7a08 <generateRequestsFromUnrequestedData+0x3d1>
		 }
		 if(addDataRequest(sk, skb, tseq_start, dataReqMap)) {
    78fd:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    7900:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    7904:	8b 45 10             	mov    0x10(%ebp),%eax
    7907:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    790b:	8b 45 0c             	mov    0xc(%ebp),%eax
    790e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    7912:	8b 45 08             	mov    0x8(%ebp),%eax
    7915:	89 04 24             	mov    %eax,(%esp,1)
    7918:	e8 b7 43 00 00       	call   bcd4 <addDataRequest>
    791d:	85 c0                	test   %eax,%eax
    791f:	74 0c                	je     792d <generateRequestsFromUnrequestedData+0x2f6>
			printk("generateRequestsFromUnrequestedData: no more space in request for more data\n");
    7921:	c7 04 24 c0 2d 00 00 	movl   $0x2dc0,(%esp,1)
    7928:	e8 fc ff ff ff       	call   7929 <generateRequestsFromUnrequestedData+0x2f2>
		 }
		 BUG_TRAP(actualLen <= maxLen);
    792d:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
    7930:	3b 45 e4             	cmp    0xffffffe4(%ebp),%eax
    7933:	7e 14                	jle    7949 <generateRequestsFromUnrequestedData+0x312>
    7935:	c7 44 24 04 28 13 00 	movl   $0x1328,0x4(%esp,1)
    793c:	00 
    793d:	c7 04 24 c0 2c 00 00 	movl   $0x2cc0,(%esp,1)
    7944:	e8 fc ff ff ff       	call   7945 <generateRequestsFromUnrequestedData+0x30e>

		 //printk("actualLen = %d\n", actualLen);
		void *check = GenerateDataContext_put(gctx, actualLen);
    7949:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
    794c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    7950:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7953:	89 04 24             	mov    %eax,(%esp,1)
    7956:	e8 78 2a 00 00       	call   a3d3 <GenerateDataContext_put>
    795b:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
		if(check == NULL) BUG();
    795e:	83 7d c8 00          	cmpl   $0x0,0xffffffc8(%ebp)
    7962:	75 25                	jne    7989 <generateRequestsFromUnrequestedData+0x352>
    7964:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    796b:	00 
    796c:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    7973:	e8 fc ff ff ff       	call   7974 <generateRequestsFromUnrequestedData+0x33d>
    7978:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    797f:	e8 fc ff ff ff       	call   7980 <generateRequestsFromUnrequestedData+0x349>
    7984:	e8 fc ff ff ff       	call   7985 <generateRequestsFromUnrequestedData+0x34e>
		 (*numRequests)++;
    7989:	8b 45 20             	mov    0x20(%ebp),%eax
    798c:	ff 00                	incl   (%eax)

		if(sendOnlyOneRequest) {
    798e:	83 3d b4 00 00 00 00 	cmpl   $0x0,0xb4
    7995:	74 09                	je     79a0 <generateRequestsFromUnrequestedData+0x369>
			reason = SEND_ONLY_ONE;
    7997:	c7 45 fc 02 00 00 00 	movl   $0x2,0xfffffffc(%ebp)
			break;
    799e:	eb 0a                	jmp    79aa <generateRequestsFromUnrequestedData+0x373>
		}
		 loopBottomCount++;
    79a0:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
    79a3:	ff 00                	incl   (%eax)
    79a5:	e9 c2 fc ff ff       	jmp    766c <generateRequestsFromUnrequestedData+0x35>
	 }
	 if(1 && *numRequests == origNumRequests) {
    79aa:	8b 45 20             	mov    0x20(%ebp),%eax
    79ad:	8b 00                	mov    (%eax),%eax
    79af:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
    79b2:	75 54                	jne    7a08 <generateRequestsFromUnrequestedData+0x3d1>
		 int canSendMore = CAN_SEND_MORE_REQUESTS(*numRequests);
    79b4:	8b 45 20             	mov    0x20(%ebp),%eax
    79b7:	83 38 31             	cmpl   $0x31,(%eax)
    79ba:	0f 9e c0             	setle  %al
    79bd:	0f b6 c0             	movzbl %al,%eax
    79c0:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
		 int inWindow = IN_WINDOW(sk, tp->t.byteReqNext);
    79c3:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    79c6:	8b 55 08             	mov    0x8(%ebp),%edx
    79c9:	8b 45 08             	mov    0x8(%ebp),%eax
    79cc:	8b 40 38             	mov    0x38(%eax),%eax
    79cf:	03 82 c4 00 00 00    	add    0xc4(%edx),%eax
    79d5:	39 81 d4 09 00 00    	cmp    %eax,0x9d4(%ecx)
    79db:	0f 92 c0             	setb   %al
    79de:	0f b6 c0             	movzbl %al,%eax
    79e1:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
		 static int canSendMoreCount = 0;
		 static int noMoreSpaceCount = 0;
		 static int outOfWindowCount = 0;
		 if(canSendMore) {
    79e4:	83 7d c0 00          	cmpl   $0x0,0xffffffc0(%ebp)
    79e8:	74 06                	je     79f0 <generateRequestsFromUnrequestedData+0x3b9>
			 canSendMoreCount++;
    79ea:	ff 05 c0 00 00 00    	incl   0xc0
		 }
		 if(!inWindow) {
    79f0:	83 7d c4 00          	cmpl   $0x0,0xffffffc4(%ebp)
    79f4:	75 06                	jne    79fc <generateRequestsFromUnrequestedData+0x3c5>
			 outOfWindowCount++;
    79f6:	ff 05 c8 00 00 00    	incl   0xc8
		 }
		 if(reason == NO_MORE_SPACE) {
    79fc:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
    7a00:	75 06                	jne    7a08 <generateRequestsFromUnrequestedData+0x3d1>
			 noMoreSpaceCount++;
    7a02:	ff 05 c4 00 00 00    	incl   0xc4
		 }

		 if( (0 && NEED_USERACK(sk)) ||
		    (0 && reason != NO_MORE_SPACE && trickles_ratelimit())) {
			 printk("OrigData: No requests generated %d %d reason = %d top = %d bottom = %d canSendMoreCount = %d noMoreSpaceCount = %d canSendMoreCount - noMoreSpaceCount = %d outOfWindow = %d\n",
				canSendMore,
				inWindow,
				reason, loopTopCount, loopBottomCount,
				canSendMoreCount,
				noMoreSpaceCount,
				canSendMoreCount - noMoreSpaceCount,
				outOfWindowCount);
		 }
	 }
	 recordSample(&ctx,4);
	 return;
 error:
	 USERACK_BEAT("unrequested data error\n");
	 ;
}
    7a08:	c9                   	leave  
    7a09:	c3                   	ret    

00007a0a <ContList_dump>:

#if 0 // 0426 removed static to allow call from gdb
static
#endif
void ContList_dump(struct sock *sk) {
    7a0a:	55                   	push   %ebp
    7a0b:	89 e5                	mov    %esp,%ebp
    7a0d:	83 ec 10             	sub    $0x10,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    7a10:	8b 45 08             	mov    0x8(%ebp),%eax
    7a13:	05 bc 00 00 00       	add    $0xbc,%eax
    7a18:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	CONTINUATION_TYPE *msk = (CONTINUATION_TYPE *)tp->t.cont_list.next;
    7a1b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7a1e:	8b 80 38 09 00 00    	mov    0x938(%eax),%eax
    7a24:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	printk("  ContList: ");
    7a27:	c7 04 24 0d 2e 00 00 	movl   $0x2e0d,(%esp,1)
    7a2e:	e8 fc ff ff ff       	call   7a2f <ContList_dump+0x25>

#if 0 // 0426 more extensive dump
	if(msk != (CONTINUATION_TYPE*)&tp->t.cont_list) {
		printk("%d-%d", ((CONTINUATION_TYPE *)tp->t.cont_list.next)->seq,
		       ((CONTINUATION_TYPE *)tp->t.cont_list.prev)->seq);
	}
#else
	alloc_head_walk(&tp->t.cont_list, msk) {
    7a33:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7a36:	05 34 09 00 00       	add    $0x934,%eax
    7a3b:	8b 40 04             	mov    0x4(%eax),%eax
    7a3e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    7a41:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7a44:	05 34 09 00 00       	add    $0x934,%eax
    7a49:	39 45 f8             	cmp    %eax,0xfffffff8(%ebp)
    7a4c:	75 02                	jne    7a50 <ContList_dump+0x46>
    7a4e:	eb 21                	jmp    7a71 <ContList_dump+0x67>
		printk("%d, ", msk->seq);
    7a50:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    7a53:	8b 40 30             	mov    0x30(%eax),%eax
    7a56:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    7a5a:	c7 04 24 1a 2e 00 00 	movl   $0x2e1a,(%esp,1)
    7a61:	e8 fc ff ff ff       	call   7a62 <ContList_dump+0x58>
    7a66:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    7a69:	8b 40 04             	mov    0x4(%eax),%eax
    7a6c:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    7a6f:	eb d0                	jmp    7a41 <ContList_dump+0x37>
	}
#endif
	printk("\n");
    7a71:	c7 04 24 05 01 00 00 	movl   $0x105,(%esp,1)
    7a78:	e8 fc ff ff ff       	call   7a79 <ContList_dump+0x6f>
}
    7a7d:	c9                   	leave  
    7a7e:	c3                   	ret    

00007a7f <requestSlowStart>:

static void requestSlowStart(struct sock *sk) {
    7a7f:	55                   	push   %ebp
    7a80:	89 e5                	mov    %esp,%ebp
    7a82:	83 ec 5c             	sub    $0x5c,%esp
	//printk("requestSlowStart -- entry\n");
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    7a85:	8b 45 08             	mov    0x8(%ebp),%eax
    7a88:	05 bc 00 00 00       	add    $0xbc,%eax
    7a8d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	CONTINUATION_TYPE *msk = NULL, *curr_cont, *clean;
    7a90:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
	struct sk_buff *skb;
	struct Request *mreq, *prev;
	struct DataRequestMapping *dataReq, *nextDataReq;
	__u32 left, right, lastRcv = tp->t.rcv_nxt - 1;
    7a97:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7a9a:	8b 80 e0 02 00 00    	mov    0x2e0(%eax),%eax
    7aa0:	48                   	dec    %eax
    7aa1:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
	int leftViolation = 0, rightViolation = 0;
    7aa4:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
    7aab:	c7 45 c8 00 00 00 00 	movl   $0x0,0xffffffc8(%ebp)

	tp->t.timerState &= ~TRICKLES_NEED_SLOWSTART;
    7ab2:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    7ab5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7ab8:	8b 80 dc 02 00 00    	mov    0x2dc(%eax),%eax
    7abe:	83 e0 fd             	and    $0xfffffffd,%eax
    7ac1:	89 82 dc 02 00 00    	mov    %eax,0x2dc(%edx)
	if(clientDebugLevel >= 1) {
    7ac7:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    7ace:	7e 3d                	jle    7b0d <requestSlowStart+0x8e>
		printk("  client: slow start acking %u, tp->rcv_nxt = %u, tp->copied_seq = %u\n", tp->t.rcv_nxt - 1, tp->rcv_nxt, tp->copied_seq);
    7ad0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7ad3:	8b 80 fc 00 00 00    	mov    0xfc(%eax),%eax
    7ad9:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    7add:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7ae0:	8b 40 08             	mov    0x8(%eax),%eax
    7ae3:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    7ae7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7aea:	8b 80 e0 02 00 00    	mov    0x2e0(%eax),%eax
    7af0:	48                   	dec    %eax
    7af1:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    7af5:	c7 04 24 20 2e 00 00 	movl   $0x2e20,(%esp,1)
    7afc:	e8 fc ff ff ff       	call   7afd <requestSlowStart+0x7e>
		printk("Slow start dump\n");
    7b01:	c7 04 24 67 2e 00 00 	movl   $0x2e67,(%esp,1)
    7b08:	e8 fc ff ff ff       	call   7b09 <requestSlowStart+0x8a>
	}
	right = AckProof_findRight(&tp->t.altProof, lastRcv);
    7b0d:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    7b10:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    7b14:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7b17:	05 0c 06 00 00       	add    $0x60c,%eax
    7b1c:	89 04 24             	mov    %eax,(%esp,1)
    7b1f:	e8 fc ff ff ff       	call   7b20 <requestSlowStart+0xa1>
    7b24:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
	left = AckProof_findLeft(&tp->t.altProof, lastRcv);
    7b27:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    7b2a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    7b2e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7b31:	05 0c 06 00 00       	add    $0x60c,%eax
    7b36:	89 04 24             	mov    %eax,(%esp,1)
    7b39:	e8 fc ff ff ff       	call   7b3a <requestSlowStart+0xbb>
    7b3e:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
	if(right != lastRcv) {
#if 0
		BUG_TRAP(right != tp->t.rcv_nxt - 1);
		printk("right (%u) != tp->t.rcv_nxt - 1 (%u)\n", right, tp->t.rcv_nxt - 1);
		AckProof_dump(&tp->t.altProof;
#endif
	}
	if(right >= lastRcv) {
    7b41:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    7b44:	3b 45 d0             	cmp    0xffffffd0(%ebp),%eax
    7b47:	72 25                	jb     7b6e <requestSlowStart+0xef>
		if(clientDebugLevel >= 2) {
    7b49:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    7b50:	7e 1c                	jle    7b6e <requestSlowStart+0xef>
			printk("right >= lastRcv ");
    7b52:	c7 04 24 78 2e 00 00 	movl   $0x2e78,(%esp,1)
    7b59:	e8 fc ff ff ff       	call   7b5a <requestSlowStart+0xdb>
			AckProof_dump(&tp->t.altProof);
    7b5e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7b61:	05 0c 06 00 00       	add    $0x60c,%eax
    7b66:	89 04 24             	mov    %eax,(%esp,1)
    7b69:	e8 fc ff ff ff       	call   7b6a <requestSlowStart+0xeb>
		}
	}
	alloc_head_reverse_walk(&tp->t.cont_list, curr_cont) {
    7b6e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7b71:	05 34 09 00 00       	add    $0x934,%eax
    7b76:	8b 00                	mov    (%eax),%eax
    7b78:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    7b7b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7b7e:	05 34 09 00 00       	add    $0x934,%eax
    7b83:	39 45 f4             	cmp    %eax,0xfffffff4(%ebp)
    7b86:	75 02                	jne    7b8a <requestSlowStart+0x10b>
    7b88:	eb 6e                	jmp    7bf8 <requestSlowStart+0x179>
		if(left <= curr_cont->TCPBase && curr_cont->TCPBase <= right) {
    7b8a:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    7b8d:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    7b90:	3b 42 6c             	cmp    0x6c(%edx),%eax
    7b93:	77 13                	ja     7ba8 <requestSlowStart+0x129>
    7b95:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    7b98:	8b 40 6c             	mov    0x6c(%eax),%eax
    7b9b:	3b 45 d4             	cmp    0xffffffd4(%ebp),%eax
    7b9e:	77 08                	ja     7ba8 <requestSlowStart+0x129>
			msk = curr_cont;
    7ba0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    7ba3:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
			break;
    7ba6:	eb 50                	jmp    7bf8 <requestSlowStart+0x179>
			//BUG_TRAP();
		}
		if(left > curr_cont->TCPBase) leftViolation++;
    7ba8:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    7bab:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    7bae:	3b 42 6c             	cmp    0x6c(%edx),%eax
    7bb1:	76 05                	jbe    7bb8 <requestSlowStart+0x139>
    7bb3:	8d 45 cc             	lea    0xffffffcc(%ebp),%eax
    7bb6:	ff 00                	incl   (%eax)
		if(right < curr_cont->TCPBase) rightViolation++;
    7bb8:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    7bbb:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    7bbe:	3b 42 6c             	cmp    0x6c(%edx),%eax
    7bc1:	73 05                	jae    7bc8 <requestSlowStart+0x149>
    7bc3:	8d 45 c8             	lea    0xffffffc8(%ebp),%eax
    7bc6:	ff 00                	incl   (%eax)
		if(curr_cont->TCPBase > tp->t.previous_base) {
    7bc8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    7bcb:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    7bce:	8b 40 6c             	mov    0x6c(%eax),%eax
    7bd1:	3b 82 e4 02 00 00    	cmp    0x2e4(%edx),%eax
    7bd7:	76 15                	jbe    7bee <requestSlowStart+0x16f>
			if(clientDebugLevel >= 2) {
    7bd9:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    7be0:	7e 0c                	jle    7bee <requestSlowStart+0x16f>
				printk("requestslowstart tcpbase > previousbase\n");
    7be2:	c7 04 24 a0 2e 00 00 	movl   $0x2ea0,(%esp,1)
    7be9:	e8 fc ff ff ff       	call   7bea <requestSlowStart+0x16b>
    7bee:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    7bf1:	8b 00                	mov    (%eax),%eax
    7bf3:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    7bf6:	eb 83                	jmp    7b7b <requestSlowStart+0xfc>
			}
		}
	}

	if(msk == NULL) {
    7bf8:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    7bfc:	75 05                	jne    7c03 <requestSlowStart+0x184>
		if(0 || !disableSevereErrors)
    7bfe:	e9 2a 03 00 00       	jmp    7f2d <requestSlowStart+0x4ae>
			if(trickles_ratelimit())
				printk("%p: Could not find acceptable msk in requestSlowStart, contlist len = %d, left violations %d, right violations %d\n", sk, tp->t.cont_list.len, leftViolation, rightViolation);
		return;
	}
	if(clientDebugLevel >= 1)
    7c03:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    7c0a:	7e 2e                	jle    7c3a <requestSlowStart+0x1bb>
	  printk("using cont %u, base = %u, left = %u right = %u\n", msk->seq, msk->TCPBase, left, right);
    7c0c:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    7c0f:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    7c13:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    7c16:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    7c1a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    7c1d:	8b 40 6c             	mov    0x6c(%eax),%eax
    7c20:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    7c24:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    7c27:	8b 40 30             	mov    0x30(%eax),%eax
    7c2a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    7c2e:	c7 04 24 e0 2e 00 00 	movl   $0x2ee0,(%esp,1)
    7c35:	e8 fc ff ff ff       	call   7c36 <requestSlowStart+0x1b7>
	BUG_TRAP(msk != (CONTINUATION_TYPE*)&tp->t.cont_list);
    7c3a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7c3d:	05 34 09 00 00       	add    $0x934,%eax
    7c42:	39 45 f8             	cmp    %eax,0xfffffff8(%ebp)
    7c45:	75 14                	jne    7c5b <requestSlowStart+0x1dc>
    7c47:	c7 44 24 04 a2 13 00 	movl   $0x13a2,0x4(%esp,1)
    7c4e:	00 
    7c4f:	c7 04 24 20 2f 00 00 	movl   $0x2f20,(%esp,1)
    7c56:	e8 fc ff ff ff       	call   7c57 <requestSlowStart+0x1d8>
	skb = tp->t.ofo_queue.next;
    7c5b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7c5e:	8b 80 e8 02 00 00    	mov    0x2e8(%eax),%eax
    7c64:	89 45 ec             	mov    %eax,0xffffffec(%ebp)

	/* Clean up state to avoid interference from other packets */
	while(skb != (struct sk_buff*)&tp->t.ofo_queue) {
    7c67:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7c6a:	05 e8 02 00 00       	add    $0x2e8,%eax
    7c6f:	39 45 ec             	cmp    %eax,0xffffffec(%ebp)
    7c72:	75 05                	jne    7c79 <requestSlowStart+0x1fa>
    7c74:	e9 8a 00 00 00       	jmp    7d03 <requestSlowStart+0x284>
		struct sk_buff *prev = skb;
    7c79:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    7c7c:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
		skb = skb->next;
    7c7f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    7c82:	8b 00                	mov    (%eax),%eax
    7c84:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
		__skb_unlink(prev, &tp->t.ofo_queue);
    7c87:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7c8a:	05 e8 02 00 00       	add    $0x2e8,%eax
    7c8f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    7c93:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    7c96:	89 04 24             	mov    %eax,(%esp,1)
    7c99:	e8 80 12 00 00       	call   8f1e <__skb_unlink>

#if 1
		TCP_SKB_CB(skb)->dbg = __LINE__;
    7c9e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    7ca1:	83 c0 30             	add    $0x30,%eax
    7ca4:	c7 40 58 ac 13 00 00 	movl   $0x13ac,0x58(%eax)
		if(try_queue_data(sk, prev) >= 0) {
    7cab:	c7 44 24 08 ad 13 00 	movl   $0x13ad,0x8(%esp,1)
    7cb2:	00 
    7cb3:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    7cb6:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    7cba:	8b 45 08             	mov    0x8(%ebp),%eax
    7cbd:	89 04 24             	mov    %eax,(%esp,1)
    7cc0:	e8 df cb ff ff       	call   48a4 <try_queue_data_helper>
			//printk("timeout: try queue data returned success (well, maybe it didn't actually stick in useful data\n");
		} else {
			//printk("timeout: try queue data returned failure\n");
		}
#else
		printk(" Timeout: I want to change this code to enqueue as much data as possible\n");
#endif

		delOfoSkb(prev);
    7cc5:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    7cc8:	89 04 24             	mov    %eax,(%esp,1)
    7ccb:	e8 1d 2f 00 00       	call   abed <delOfoSkb>
		BUG_TRAP(TCP_SKB_CB(prev)->cont->list == NULL); // 0430 tracking down corruption bug
    7cd0:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    7cd3:	83 c0 30             	add    $0x30,%eax
    7cd6:	8b 40 2c             	mov    0x2c(%eax),%eax
    7cd9:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
    7cdd:	74 14                	je     7cf3 <requestSlowStart+0x274>
    7cdf:	c7 44 24 04 b7 13 00 	movl   $0x13b7,0x4(%esp,1)
    7ce6:	00 
    7ce7:	c7 04 24 80 2f 00 00 	movl   $0x2f80,(%esp,1)
    7cee:	e8 fc ff ff ff       	call   7cef <requestSlowStart+0x270>
		MARK_PC(TCP_SKB_CB(prev)->cont);
		trickles_kfree_skb(prev);
    7cf3:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    7cf6:	89 04 24             	mov    %eax,(%esp,1)
    7cf9:	e8 a6 87 ff ff       	call   4a4 <trickles_kfree_skb>
    7cfe:	e9 64 ff ff ff       	jmp    7c67 <requestSlowStart+0x1e8>
	}
	clean = (CONTINUATION_TYPE*)tp->t.cont_list.next;
    7d03:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7d06:	8b 80 38 09 00 00    	mov    0x938(%eax),%eax
    7d0c:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	while(clean != (CONTINUATION_TYPE*)&tp->t.cont_list) {
    7d0f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7d12:	05 34 09 00 00       	add    $0x934,%eax
    7d17:	39 45 f0             	cmp    %eax,0xfffffff0(%ebp)
    7d1a:	75 02                	jne    7d1e <requestSlowStart+0x29f>
    7d1c:	eb 2f                	jmp    7d4d <requestSlowStart+0x2ce>
		CONTINUATION_TYPE *prev = clean;
    7d1e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    7d21:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
		clean = clean->next;
    7d24:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    7d27:	8b 40 04             	mov    0x4(%eax),%eax
    7d2a:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
		// 0424: clean out all continuations other than the one we are using for slowstart
		if(prev != msk) {
    7d2d:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    7d30:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
    7d33:	74 da                	je     7d0f <requestSlowStart+0x290>
			unlinkCont(prev);
    7d35:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    7d38:	89 04 24             	mov    %eax,(%esp,1)
    7d3b:	e8 d9 2e 00 00       	call   ac19 <unlinkCont>
			MARK_PC(prev);
			freeClientSide_Continuation(prev);
    7d40:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    7d43:	89 04 24             	mov    %eax,(%esp,1)
    7d46:	e8 e4 22 00 00       	call   a02f <freeClientSide_Continuation>
    7d4b:	eb c2                	jmp    7d0f <requestSlowStart+0x290>
		}
	}

	/* Retransmit all UC requests:
	   move sentRequests back to queuedRequests
	*/
	for(mreq = (struct Request*)tp->t.sentRequests.prev;
    7d4d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7d50:	8b 80 84 09 00 00    	mov    0x984(%eax),%eax
    7d56:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    7d59:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7d5c:	05 84 09 00 00       	add    $0x984,%eax
    7d61:	39 45 e8             	cmp    %eax,0xffffffe8(%ebp)
    7d64:	75 02                	jne    7d68 <requestSlowStart+0x2e9>
    7d66:	eb 5f                	jmp    7dc7 <requestSlowStart+0x348>
	    mreq != (struct Request*)&tp->t.sentRequests;
	    mreq = (struct Request*)prev) {
		prev = (struct Request*)mreq->prev;
    7d68:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    7d6b:	8b 00                	mov    (%eax),%eax
    7d6d:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)

		/* note: can't just splice the ends, since each list
		   node contains a pointer to the containing list */
		// Shift to front of queuedRequests, in order
		BUG_TRAP(!mreq->isNew);
    7d70:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    7d73:	0f b6 40 48          	movzbl 0x48(%eax),%eax
    7d77:	83 e0 01             	and    $0x1,%eax
    7d7a:	85 c0                	test   %eax,%eax
    7d7c:	74 14                	je     7d92 <requestSlowStart+0x313>
    7d7e:	c7 44 24 04 d2 13 00 	movl   $0x13d2,0x4(%esp,1)
    7d85:	00 
    7d86:	c7 04 24 e0 2f 00 00 	movl   $0x2fe0,(%esp,1)
    7d8d:	e8 fc ff ff ff       	call   7d8e <requestSlowStart+0x30f>
		unlink((struct alloc_head*)mreq);
    7d92:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    7d95:	89 04 24             	mov    %eax,(%esp,1)
    7d98:	e8 4f 15 00 00       	call   92ec <unlink>
		resetRequest(mreq);
    7d9d:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    7da0:	89 04 24             	mov    %eax,(%esp,1)
    7da3:	e8 aa 19 00 00       	call   9752 <resetRequest>
		CHECK_IF_ZEROREQUEST(mreq);
		insert_head(&tp->t.queuedRequests, (struct alloc_head*)mreq);
    7da8:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    7dab:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    7daf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7db2:	05 98 09 00 00       	add    $0x998,%eax
    7db7:	89 04 24             	mov    %eax,(%esp,1)
    7dba:	e8 3a 14 00 00       	call   91f9 <insert_head>
    7dbf:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    7dc2:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    7dc5:	eb 92                	jmp    7d59 <requestSlowStart+0x2da>
	}
	/* clear data requests */
	{
		int i;
		struct alloc_head_list* dataRequestLists[] = {
    7dc7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7dca:	05 ac 09 00 00       	add    $0x9ac,%eax
    7dcf:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
    7dd2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7dd5:	05 c0 09 00 00       	add    $0x9c0,%eax
    7dda:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
			&tp->t.dataRequestMap,
			&tp->t.missingDataMap};
		for(i=0; i < 2; i++) {
    7ddd:	c7 45 c4 00 00 00 00 	movl   $0x0,0xffffffc4(%ebp)
    7de4:	83 7d c4 01          	cmpl   $0x1,0xffffffc4(%ebp)
    7de8:	7e 02                	jle    7dec <requestSlowStart+0x36d>
    7dea:	eb 4b                	jmp    7e37 <requestSlowStart+0x3b8>
			struct alloc_head_list *currList = dataRequestLists[i];
    7dec:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    7def:	8b 44 85 bc          	mov    0xffffffbc(%ebp,%eax,4),%eax
    7df3:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
			for(dataReq = (struct DataRequestMapping *)currList->next;
    7df6:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
    7df9:	8b 40 04             	mov    0x4(%eax),%eax
    7dfc:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    7dff:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    7e02:	3b 45 b8             	cmp    0xffffffb8(%ebp),%eax
    7e05:	75 02                	jne    7e09 <requestSlowStart+0x38a>
    7e07:	eb 27                	jmp    7e30 <requestSlowStart+0x3b1>
			    dataReq != (struct DataRequestMapping *)currList;
			    dataReq = nextDataReq) {
				nextDataReq = dataReq->next;
    7e09:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    7e0c:	8b 40 04             	mov    0x4(%eax),%eax
    7e0f:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
				unlink((struct alloc_head*)dataReq);
    7e12:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    7e15:	89 04 24             	mov    %eax,(%esp,1)
    7e18:	e8 cf 14 00 00       	call   92ec <unlink>
				freeDataRequestMapping(dataReq);
    7e1d:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    7e20:	89 04 24             	mov    %eax,(%esp,1)
    7e23:	e8 11 19 00 00       	call   9739 <freeDataRequestMapping>
    7e28:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    7e2b:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    7e2e:	eb cf                	jmp    7dff <requestSlowStart+0x380>
    7e30:	8d 45 c4             	lea    0xffffffc4(%ebp),%eax
    7e33:	ff 00                	incl   (%eax)
    7e35:	eb ad                	jmp    7de4 <requestSlowStart+0x365>
			}
		}

		tp->t.byteReqNext = tp->rcv_nxt;
    7e37:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    7e3a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7e3d:	8b 40 08             	mov    0x8(%eax),%eax
    7e40:	89 82 d4 09 00 00    	mov    %eax,0x9d4(%edx)
		tp->t.byteReqHint = NULL;
    7e46:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7e49:	c7 80 d8 09 00 00 00 	movl   $0x0,0x9d8(%eax)
    7e50:	00 00 00 
	}

	tp->t.ack_prev = msk;
    7e53:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    7e56:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    7e59:	89 82 f4 02 00 00    	mov    %eax,0x2f4(%edx)
	INTEGRITY_CHECK(sk, tp->t.ack_prev);

	SAVE_ACK_PREV(tp);
	tp->t.ack_last = tp->t.ack_prev->seq + 1;
    7e5f:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    7e62:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7e65:	8b 80 f4 02 00 00    	mov    0x2f4(%eax),%eax
    7e6b:	8b 40 30             	mov    0x30(%eax),%eax
    7e6e:	40                   	inc    %eax
    7e6f:	89 82 f8 02 00 00    	mov    %eax,0x2f8(%edx)
	if(!(!tp->t.ack_prev || tp->t.ack_prev->next)) {
    7e75:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7e78:	83 b8 f4 02 00 00 00 	cmpl   $0x0,0x2f4(%eax)
    7e7f:	74 63                	je     7ee4 <requestSlowStart+0x465>
    7e81:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7e84:	8b 80 f4 02 00 00    	mov    0x2f4(%eax),%eax
    7e8a:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
    7e8e:	75 54                	jne    7ee4 <requestSlowStart+0x465>
		// 0429
		BUG_TRAP(!tp->t.ack_prev || tp->t.ack_prev->next);
    7e90:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7e93:	83 b8 f4 02 00 00 00 	cmpl   $0x0,0x2f4(%eax)
    7e9a:	74 23                	je     7ebf <requestSlowStart+0x440>
    7e9c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7e9f:	8b 80 f4 02 00 00    	mov    0x2f4(%eax),%eax
    7ea5:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
    7ea9:	75 14                	jne    7ebf <requestSlowStart+0x440>
    7eab:	c7 44 24 04 f4 13 00 	movl   $0x13f4,0x4(%esp,1)
    7eb2:	00 
    7eb3:	c7 04 24 40 1b 00 00 	movl   $0x1b40,(%esp,1)
    7eba:	e8 fc ff ff ff       	call   7ebb <requestSlowStart+0x43c>
		BUG();
    7ebf:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    7ec6:	00 
    7ec7:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    7ece:	e8 fc ff ff ff       	call   7ecf <requestSlowStart+0x450>
    7ed3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    7eda:	e8 fc ff ff ff       	call   7edb <requestSlowStart+0x45c>
    7edf:	e8 fc ff ff ff       	call   7ee0 <requestSlowStart+0x461>
    7ee4:	90                   	nop    
	}

	// free sendAckOverflow list
	while((skb = __skb_dequeue(&tp->t.sendAckOverflow))) {
    7ee5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7ee8:	05 4c 0a 00 00       	add    $0xa4c,%eax
    7eed:	89 04 24             	mov    %eax,(%esp,1)
    7ef0:	e8 89 0f 00 00       	call   8e7e <__skb_dequeue>
    7ef5:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    7ef8:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
    7efc:	75 02                	jne    7f00 <requestSlowStart+0x481>
    7efe:	eb 0d                	jmp    7f0d <requestSlowStart+0x48e>
		__kfree_skb(skb);
    7f00:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    7f03:	89 04 24             	mov    %eax,(%esp,1)
    7f06:	e8 fc ff ff ff       	call   7f07 <requestSlowStart+0x488>
    7f0b:	eb d8                	jmp    7ee5 <requestSlowStart+0x466>
	}
#if 0
	// recorded in SendAckHelper()
	appendTricklesLossEvent(sk, MIN(tp->t.ack_prev->startCwnd, EVENT_CWND_MAX),
				-3, tp->t.state);
#endif
	//printk("requestSlowStart -- calling sendAck\n");
	sendAckHelper(sk,tp->t.ack_prev,TREQ_SLOWSTART);
    7f0d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp,1)
    7f14:	00 
    7f15:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7f18:	8b 80 f4 02 00 00    	mov    0x2f4(%eax),%eax
    7f1e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    7f22:	8b 45 08             	mov    0x8(%ebp),%eax
    7f25:	89 04 24             	mov    %eax,(%esp,1)
    7f28:	e8 b9 e3 ff ff       	call   62e6 <sendAckHelper>
}
    7f2d:	c9                   	leave  
    7f2e:	c3                   	ret    

00007f2f <trickles_clear_timers>:


#ifndef USERTEST
/*
 *
 * Destructors
 *
 *
 */
static void trickles_clear_timers(struct sock *sk) {
    7f2f:	55                   	push   %ebp
    7f30:	89 e5                	mov    %esp,%ebp
    7f32:	83 ec 08             	sub    $0x8,%esp
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
    7f35:	8b 45 08             	mov    0x8(%ebp),%eax
    7f38:	05 bc 00 00 00       	add    $0xbc,%eax
    7f3d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	if(timer_pending(&tp->t.slowstart_timer)) {
    7f40:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7f43:	05 48 09 00 00       	add    $0x948,%eax
    7f48:	89 04 24             	mov    %eax,(%esp,1)
    7f4b:	e8 34 0e 00 00       	call   8d84 <timer_pending>
    7f50:	85 c0                	test   %eax,%eax
    7f52:	74 25                	je     7f79 <trickles_clear_timers+0x4a>
		static int numCleared = 0;
		if(del_timer(&tp->t.slowstart_timer)) {
    7f54:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    7f57:	05 48 09 00 00       	add    $0x948,%eax
    7f5c:	89 04 24             	mov    %eax,(%esp,1)
    7f5f:	e8 fc ff ff ff       	call   7f60 <trickles_clear_timers+0x31>
    7f64:	85 c0                	test   %eax,%eax
    7f66:	74 0b                	je     7f73 <trickles_clear_timers+0x44>
			__sock_put(sk);
    7f68:	8b 45 08             	mov    0x8(%ebp),%eax
    7f6b:	89 04 24             	mov    %eax,(%esp,1)
    7f6e:	e8 4f 14 00 00       	call   93c2 <__sock_put>
		}
		numCleared++;
    7f73:	ff 05 cc 00 00 00    	incl   0xcc
		//printk("%d timers cleared\n", numCleared);
	}
	return;
}
    7f79:	c9                   	leave  
    7f7a:	c3                   	ret    

00007f7b <trickles_destroy>:

#endif //USERTEST

static void trickles_destroy(struct sock *sk) {
    7f7b:	55                   	push   %ebp
    7f7c:	89 e5                	mov    %esp,%ebp
    7f7e:	83 ec 64             	sub    $0x64,%esp
	int i;
	struct sk_buff *skb;
	CONTINUATION_TYPE *cont;
	struct UC_Continuation *ucont;
	struct UC_DependencyNode *depNode;
	struct Request *req;
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
    7f81:	8b 45 08             	mov    0x8(%ebp),%eax
    7f84:	05 bc 00 00 00       	add    $0xbc,%eax
    7f89:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
	struct alloc_head_list *lists[] = {&tp->t.sentRequests, &tp->t.queuedRequests};
    7f8c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    7f8f:	05 84 09 00 00       	add    $0x984,%eax
    7f94:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    7f97:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    7f9a:	05 98 09 00 00       	add    $0x998,%eax
    7f9f:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
	struct alloc_head_list *dataRequestLists[] = {&tp->t.dataRequestMap, &tp->t.missingDataMap};
    7fa2:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    7fa5:	05 ac 09 00 00       	add    $0x9ac,%eax
    7faa:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
    7fad:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    7fb0:	05 c0 09 00 00       	add    $0x9c0,%eax
    7fb5:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)

#ifdef SAVE_LAST_DATA_TIME
        struct timeval t1;
        do_gettimeofday(&t1);
        printk("last data at (%d,%d) %d = (%d,%d)\n", last_data_time.tv_sec,
               last_data_time.tv_usec, jiffies, t1.tv_sec, t1.tv_usec);
#endif // SAVE_LAST_DATA_TIME

	//printk("destroy() on entry\n");
#ifndef USERTEST
	if(!(tp->trickles_opt & TCP_TRICKLES_ENABLE)) {
    7fb8:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    7fbb:	8b 80 ec 01 00 00    	mov    0x1ec(%eax),%eax
    7fc1:	83 e0 01             	and    $0x1,%eax
    7fc4:	85 c0                	test   %eax,%eax
    7fc6:	75 05                	jne    7fcd <trickles_destroy+0x52>
		return;
    7fc8:	e9 94 04 00 00       	jmp    8461 <trickles_destroy+0x4e6>
	}

	//KGDB_ASSERT("BREAK", 0);
	/* Schedule vfree() for later */
	if(TRICKLES_USERAPI_CONFIGURED_TP(tp)) {
    7fcd:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    7fd0:	83 b8 d0 01 00 00 00 	cmpl   $0x0,0x1d0(%eax)
    7fd7:	74 14                	je     7fed <trickles_destroy+0x72>
		schedule_work((struct work_struct *)(tp->cminisock_api_config.cfg.ctl + 1));
    7fd9:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    7fdc:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
    7fe2:	83 c0 40             	add    $0x40,%eax
    7fe5:	89 04 24             	mov    %eax,(%esp,1)
    7fe8:	e8 fc ff ff ff       	call   7fe9 <trickles_destroy+0x6e>
	}

	trickles_clear_timers(sk);
    7fed:	8b 45 08             	mov    0x8(%ebp),%eax
    7ff0:	89 04 24             	mov    %eax,(%esp,1)
    7ff3:	e8 37 ff ff ff       	call   7f2f <trickles_clear_timers>
#endif //USERTEST

	//printk("destroy() before ofo_queue\n");
	/* drain ofo queues */
	while((skb=__skb_dequeue(&tp->t.ofo_queue))!=NULL) {
    7ff8:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    7ffb:	05 e8 02 00 00       	add    $0x2e8,%eax
    8000:	89 04 24             	mov    %eax,(%esp,1)
    8003:	e8 76 0e 00 00       	call   8e7e <__skb_dequeue>
    8008:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    800b:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    800f:	75 02                	jne    8013 <trickles_destroy+0x98>
    8011:	eb 18                	jmp    802b <trickles_destroy+0xb0>
		if(TCP_SKB_CB(skb)->cont)
			MARK_PC(TCP_SKB_CB(skb)->cont);
		delOfoSkb(skb);
    8013:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    8016:	89 04 24             	mov    %eax,(%esp,1)
    8019:	e8 cf 2b 00 00       	call   abed <delOfoSkb>
		trickles_kfree_skb(skb);
    801e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    8021:	89 04 24             	mov    %eax,(%esp,1)
    8024:	e8 7b 84 ff ff       	call   4a4 <trickles_kfree_skb>
    8029:	eb cd                	jmp    7ff8 <trickles_destroy+0x7d>
    802b:	90                   	nop    
	}
	//printk("destroy() before freeing request_ofo_queue\n");
	while(!empty(&tp->t.request_ofo_queue)) {
    802c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    802f:	05 64 09 00 00       	add    $0x964,%eax
    8034:	89 04 24             	mov    %eax,(%esp,1)
    8037:	e8 83 11 00 00       	call   91bf <empty>
    803c:	85 c0                	test   %eax,%eax
    803e:	74 02                	je     8042 <trickles_destroy+0xc7>
    8040:	eb 45                	jmp    8087 <trickles_destroy+0x10c>
		struct RequestOFOEntry *entry = (struct RequestOFOEntry*)
    8042:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    8045:	8b 80 68 09 00 00    	mov    0x968(%eax),%eax
    804b:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
			tp->t.request_ofo_queue.next;
		BUG_TRAP(entry != (struct RequestOFOEntry *)&tp->t.request_ofo_queue);
    804e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    8051:	05 64 09 00 00       	add    $0x964,%eax
    8056:	39 45 d0             	cmp    %eax,0xffffffd0(%ebp)
    8059:	75 14                	jne    806f <trickles_destroy+0xf4>
    805b:	c7 44 24 04 49 14 00 	movl   $0x1449,0x4(%esp,1)
    8062:	00 
    8063:	c7 04 24 20 30 00 00 	movl   $0x3020,(%esp,1)
    806a:	e8 fc ff ff ff       	call   806b <trickles_destroy+0xf0>
		unlink((struct alloc_head*)entry);
    806f:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    8072:	89 04 24             	mov    %eax,(%esp,1)
    8075:	e8 72 12 00 00       	call   92ec <unlink>
		RequestOFOEntry_free(entry);
    807a:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    807d:	89 04 24             	mov    %eax,(%esp,1)
    8080:	e8 a2 25 00 00       	call   a627 <RequestOFOEntry_free>
    8085:	eb a5                	jmp    802c <trickles_destroy+0xb1>
    8087:	90                   	nop    
	}
	//printk("destroy() after freeing request_ofo_queue\n");
	while((skb=__skb_dequeue(&tp->t.data_ofo_queue))!=NULL) {
    8088:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    808b:	05 78 09 00 00       	add    $0x978,%eax
    8090:	89 04 24             	mov    %eax,(%esp,1)
    8093:	e8 e6 0d 00 00       	call   8e7e <__skb_dequeue>
    8098:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    809b:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    809f:	75 02                	jne    80a3 <trickles_destroy+0x128>
    80a1:	eb 29                	jmp    80cc <trickles_destroy+0x151>
		// data ofo queue continuations were already deallocated
		// 0418 check skb reference count
#ifndef USERTEST
		if(atomic_read(&skb_shinfo(skb)->dataref) > 2) {
    80a3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    80a6:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    80ac:	8b 00                	mov    (%eax),%eax
    80ae:	83 f8 02             	cmp    $0x2,%eax
    80b1:	7e 0c                	jle    80bf <trickles_destroy+0x144>
			printk("skb on data_ofo_queue had refcnt > 2\n");
    80b3:	c7 04 24 a0 30 00 00 	movl   $0x30a0,(%esp,1)
    80ba:	e8 fc ff ff ff       	call   80bb <trickles_destroy+0x140>
			// xxx are there skb references other than this queue?
#if 0
			while(atomic_read(&skb_shinfo(skb)->dataref) >= 2) {
				trickles_kfree_skb(skb);
			}
#endif
		}
#endif // USERTEST
		trickles_kfree_skb(skb);
    80bf:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    80c2:	89 04 24             	mov    %eax,(%esp,1)
    80c5:	e8 da 83 ff ff       	call   4a4 <trickles_kfree_skb>
    80ca:	eb bc                	jmp    8088 <trickles_destroy+0x10d>
    80cc:	90                   	nop    
	}
	//printk("destroy() after data ofo queue\n");

	// Drain overflow queues
	while((skb=__skb_dequeue(&tp->t.prequeueOverflow))) {
    80cd:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    80d0:	05 40 0a 00 00       	add    $0xa40,%eax
    80d5:	89 04 24             	mov    %eax,(%esp,1)
    80d8:	e8 a1 0d 00 00       	call   8e7e <__skb_dequeue>
    80dd:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    80e0:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    80e4:	75 02                	jne    80e8 <trickles_destroy+0x16d>
    80e6:	eb 0d                	jmp    80f5 <trickles_destroy+0x17a>
		__kfree_skb(skb);
    80e8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    80eb:	89 04 24             	mov    %eax,(%esp,1)
    80ee:	e8 fc ff ff ff       	call   80ef <trickles_destroy+0x174>
    80f3:	eb d8                	jmp    80cd <trickles_destroy+0x152>
    80f5:	90                   	nop    
	}
	//printk("destroy() after overflow queue\n");
	while((skb=__skb_dequeue(&tp->t.sendAckOverflow))) {
    80f6:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    80f9:	05 4c 0a 00 00       	add    $0xa4c,%eax
    80fe:	89 04 24             	mov    %eax,(%esp,1)
    8101:	e8 78 0d 00 00       	call   8e7e <__skb_dequeue>
    8106:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    8109:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    810d:	75 02                	jne    8111 <trickles_destroy+0x196>
    810f:	eb 0d                	jmp    811e <trickles_destroy+0x1a3>
		__kfree_skb(skb);
    8111:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    8114:	89 04 24             	mov    %eax,(%esp,1)
    8117:	e8 fc ff ff ff       	call   8118 <trickles_destroy+0x19d>
    811c:	eb d8                	jmp    80f6 <trickles_destroy+0x17b>
    811e:	90                   	nop    
	}
	//printk("destroy() after sendack overvlow\n");
	while((skb=__skb_dequeue(&tp->t.recycleList))) {
    811f:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    8122:	05 58 0a 00 00       	add    $0xa58,%eax
    8127:	89 04 24             	mov    %eax,(%esp,1)
    812a:	e8 4f 0d 00 00       	call   8e7e <__skb_dequeue>
    812f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    8132:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    8136:	75 02                	jne    813a <trickles_destroy+0x1bf>
    8138:	eb 0d                	jmp    8147 <trickles_destroy+0x1cc>
		__kfree_skb(skb);
    813a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    813d:	89 04 24             	mov    %eax,(%esp,1)
    8140:	e8 fc ff ff ff       	call   8141 <trickles_destroy+0x1c6>
    8145:	eb d8                	jmp    811f <trickles_destroy+0x1a4>
	}
	//printk("destroy() after recycle list\n");

	/* Clean protocol continuation list */
	cont = (CONTINUATION_TYPE *)tp->t.cont_list.next;
    8147:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    814a:	8b 80 38 09 00 00    	mov    0x938(%eax),%eax
    8150:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
#if 0 // 0426 used to debug continuation memory leaks
	{
		static int cleanNum = 0;
		printk("conts cleaned: %d\n", cleanNum += tp->t.cont_list.len);
	}
#endif

	while(cont != (CONTINUATION_TYPE*)&tp->t.cont_list) {
    8153:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    8156:	05 34 09 00 00       	add    $0x934,%eax
    815b:	39 45 f4             	cmp    %eax,0xfffffff4(%ebp)
    815e:	75 02                	jne    8162 <trickles_destroy+0x1e7>
    8160:	eb 27                	jmp    8189 <trickles_destroy+0x20e>
		CONTINUATION_TYPE *prev = cont;
    8162:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    8165:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
		cont = cont->next;
    8168:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    816b:	8b 40 04             	mov    0x4(%eax),%eax
    816e:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		unlinkCont(prev);
    8171:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    8174:	89 04 24             	mov    %eax,(%esp,1)
    8177:	e8 9d 2a 00 00       	call   ac19 <unlinkCont>
		MARK_PC(prev);
		freeClientSide_Continuation(prev);
    817c:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    817f:	89 04 24             	mov    %eax,(%esp,1)
    8182:	e8 a8 1e 00 00       	call   a02f <freeClientSide_Continuation>
    8187:	eb ca                	jmp    8153 <trickles_destroy+0x1d8>
	}

	/* Clean sent and pending requests */
	for(i=0; i < sizeof(lists)/sizeof(lists[0]); i++) {
    8189:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
    8190:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
    8194:	76 02                	jbe    8198 <trickles_destroy+0x21d>
    8196:	eb 4b                	jmp    81e3 <trickles_destroy+0x268>
		struct alloc_head_list *list = lists[i];
    8198:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    819b:	8b 44 85 dc          	mov    0xffffffdc(%ebp,%eax,4),%eax
    819f:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
		for(req = (struct Request*)list->next; req != (struct Request*)list;) {
    81a2:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    81a5:	8b 40 04             	mov    0x4(%eax),%eax
    81a8:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    81ab:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    81ae:	3b 45 d0             	cmp    0xffffffd0(%ebp),%eax
    81b1:	75 02                	jne    81b5 <trickles_destroy+0x23a>
    81b3:	eb 27                	jmp    81dc <trickles_destroy+0x261>
			struct Request *clean = req;
    81b5:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    81b8:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
			req = (struct Request*)req->next;
    81bb:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    81be:	8b 40 04             	mov    0x4(%eax),%eax
    81c1:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
			unlink((struct alloc_head*)clean);
    81c4:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    81c7:	89 04 24             	mov    %eax,(%esp,1)
    81ca:	e8 1d 11 00 00       	call   92ec <unlink>
			freeRequest(clean);
    81cf:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    81d2:	89 04 24             	mov    %eax,(%esp,1)
    81d5:	e8 fc ff ff ff       	call   81d6 <trickles_destroy+0x25b>
    81da:	eb cf                	jmp    81ab <trickles_destroy+0x230>
    81dc:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
    81df:	ff 00                	incl   (%eax)
    81e1:	eb ad                	jmp    8190 <trickles_destroy+0x215>
		}
	}

	for(i=0; i < sizeof(dataRequestLists)/sizeof(dataRequestLists[0]); i++) {
    81e3:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
    81ea:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
    81ee:	76 02                	jbe    81f2 <trickles_destroy+0x277>
    81f0:	eb 4b                	jmp    823d <trickles_destroy+0x2c2>
		struct DataRequestMapping *mapping;
		struct alloc_head_list *list = dataRequestLists[i];
    81f2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    81f5:	8b 44 85 d4          	mov    0xffffffd4(%ebp,%eax,4),%eax
    81f9:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
		for(mapping  = (struct DataRequestMapping*)list->next;
    81fc:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    81ff:	8b 40 04             	mov    0x4(%eax),%eax
    8202:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    8205:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    8208:	3b 45 d0             	cmp    0xffffffd0(%ebp),%eax
    820b:	75 02                	jne    820f <trickles_destroy+0x294>
    820d:	eb 27                	jmp    8236 <trickles_destroy+0x2bb>
		    mapping != (struct DataRequestMapping*)list;) {
			struct DataRequestMapping *clean = mapping;
    820f:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    8212:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
			mapping = mapping->next;
    8215:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    8218:	8b 40 04             	mov    0x4(%eax),%eax
    821b:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
			unlink((struct alloc_head*)clean);
    821e:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    8221:	89 04 24             	mov    %eax,(%esp,1)
    8224:	e8 c3 10 00 00       	call   92ec <unlink>
			freeDataRequestMapping(clean);
    8229:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    822c:	89 04 24             	mov    %eax,(%esp,1)
    822f:	e8 05 15 00 00       	call   9739 <freeDataRequestMapping>
    8234:	eb cf                	jmp    8205 <trickles_destroy+0x28a>
    8236:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
    8239:	ff 00                	incl   (%eax)
    823b:	eb ad                	jmp    81ea <trickles_destroy+0x26f>
		}
	}

	if(tp->t.newIncompleteRequest) {
    823d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    8240:	83 b8 f8 09 00 00 00 	cmpl   $0x0,0x9f8(%eax)
    8247:	74 1e                	je     8267 <trickles_destroy+0x2ec>
		freeRequest((struct Request*)tp->t.newIncompleteRequest);
    8249:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    824c:	8b 80 f8 09 00 00    	mov    0x9f8(%eax),%eax
    8252:	89 04 24             	mov    %eax,(%esp,1)
    8255:	e8 fc ff ff ff       	call   8256 <trickles_destroy+0x2db>
		tp->t.newIncompleteRequest = NULL;
    825a:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    825d:	c7 80 f8 09 00 00 00 	movl   $0x0,0x9f8(%eax)
    8264:	00 00 00 
	}
	if(tp->t.prevConvCont) {
    8267:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    826a:	83 b8 fc 09 00 00 00 	cmpl   $0x0,0x9fc(%eax)
    8271:	74 1e                	je     8291 <trickles_destroy+0x316>
		// don't bother with refcnt, since we're cleaning up
		kfree(tp->t.prevConvCont);
    8273:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    8276:	8b 80 fc 09 00 00    	mov    0x9fc(%eax),%eax
    827c:	89 04 24             	mov    %eax,(%esp,1)
    827f:	e8 fc ff ff ff       	call   8280 <trickles_destroy+0x305>
		tp->t.prevConvCont = NULL;
    8284:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    8287:	c7 80 fc 09 00 00 00 	movl   $0x0,0x9fc(%eax)
    828e:	00 00 00 
	}
	/* Clean user continuations and dependencies */
	for(ucont = (struct UC_Continuation*)tp->t.ucontList.next;
    8291:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    8294:	8b 80 04 0a 00 00    	mov    0xa04(%eax),%eax
    829a:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    829d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    82a0:	05 00 0a 00 00       	add    $0xa00,%eax
    82a5:	39 45 f0             	cmp    %eax,0xfffffff0(%ebp)
    82a8:	75 02                	jne    82ac <trickles_destroy+0x331>
    82aa:	eb 1c                	jmp    82c8 <trickles_destroy+0x34d>
	    ucont != (struct UC_Continuation*)&tp->t.ucontList;) {
		struct UC_Continuation *clean = (struct UC_Continuation*) ucont;
    82ac:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    82af:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
		ucont = (struct UC_Continuation*)ucont->next;
    82b2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    82b5:	8b 40 04             	mov    0x4(%eax),%eax
    82b8:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
		kfree(clean);
    82bb:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    82be:	89 04 24             	mov    %eax,(%esp,1)
    82c1:	e8 fc ff ff ff       	call   82c2 <trickles_destroy+0x347>
    82c6:	eb d5                	jmp    829d <trickles_destroy+0x322>
	}
	for(depNode = (struct UC_DependencyNode*)tp->t.depNodeList.next;
    82c8:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    82cb:	8b 80 18 0a 00 00    	mov    0xa18(%eax),%eax
    82d1:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    82d4:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    82d7:	05 14 0a 00 00       	add    $0xa14,%eax
    82dc:	39 45 ec             	cmp    %eax,0xffffffec(%ebp)
    82df:	75 02                	jne    82e3 <trickles_destroy+0x368>
    82e1:	eb 2a                	jmp    830d <trickles_destroy+0x392>
	    depNode != (struct UC_DependencyNode*)&tp->t.depNodeList;) {
		struct UC_DependencyNode *clean = depNode;
    82e3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    82e6:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
		depNode = (struct UC_DependencyNode*)depNode->next;
    82e9:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    82ec:	8b 40 04             	mov    0x4(%eax),%eax
    82ef:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
		vector_free(&depNode->depLinks);
    82f2:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    82f5:	83 c0 24             	add    $0x24,%eax
    82f8:	89 04 24             	mov    %eax,(%esp,1)
    82fb:	e8 9e 0e 00 00       	call   919e <vector_free>
		kfree(clean);
    8300:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    8303:	89 04 24             	mov    %eax,(%esp,1)
    8306:	e8 fc ff ff ff       	call   8307 <trickles_destroy+0x38c>
    830b:	eb c7                	jmp    82d4 <trickles_destroy+0x359>
	}

#ifndef USERTEST
	/* deallocate minisockets */

	if((tp->trickles_opt & TCP_TRICKLES_ENABLE) &&
    830d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    8310:	8b 80 ec 01 00 00    	mov    0x1ec(%eax),%eax
    8316:	83 e0 01             	and    $0x1,%eax
    8319:	85 c0                	test   %eax,%eax
    831b:	74 62                	je     837f <trickles_destroy+0x404>
    831d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    8320:	8b 80 ec 01 00 00    	mov    0x1ec(%eax),%eax
    8326:	83 e0 08             	and    $0x8,%eax
    8329:	85 c0                	test   %eax,%eax
    832b:	74 52                	je     837f <trickles_destroy+0x404>
    832d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    8330:	83 b8 d0 01 00 00 00 	cmpl   $0x0,0x1d0(%eax)
    8337:	74 46                	je     837f <trickles_destroy+0x404>
	   (tp->trickles_opt & TCP_TRICKLES_RSERVER) &&
	   TRICKLES_USERAPI_CONFIGURED_TP(tp)) {
		struct trickles_mmap_ctl *ctl = (struct trickles_mmap_ctl *)&tp->cminisock_api_config.cfg.ctl;
    8339:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    833c:	05 cc 01 00 00       	add    $0x1cc,%eax
    8341:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
		struct cminisock *msk = (struct cminisock *)ctl->minisock_base;
    8344:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    8347:	8b 40 0c             	mov    0xc(%eax),%eax
    834a:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
		while((char*)msk <= (char*)ctl->ro_base + MINISOCK_LEN(ctl->ro_len)) {
    834d:	8b 55 c8             	mov    0xffffffc8(%ebp),%edx
    8350:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    8353:	8b 40 24             	mov    0x24(%eax),%eax
    8356:	d1 e8                	shr    %eax
    8358:	03 42 18             	add    0x18(%edx),%eax
    835b:	39 45 cc             	cmp    %eax,0xffffffcc(%ebp)
    835e:	76 02                	jbe    8362 <trickles_destroy+0x3e7>
    8360:	eb 1d                	jmp    837f <trickles_destroy+0x404>
			free_minisock(sk,msk);
    8362:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    8365:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    8369:	8b 45 08             	mov    0x8(%ebp),%eax
    836c:	89 04 24             	mov    %eax,(%esp,1)
    836f:	e8 04 23 00 00       	call   a678 <free_minisock>
			msk++;
    8374:	8d 45 cc             	lea    0xffffffcc(%ebp),%eax
    8377:	81 00 fc 00 00 00    	addl   $0xfc,(%eax)
    837d:	eb ce                	jmp    834d <trickles_destroy+0x3d2>
		}
	}
#endif // USERTEST

#ifdef OPENSSL_HMAC
	// for OpenSSL HMAC
	if(tp->t.hmacCTX) {
    837f:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    8382:	83 b8 28 0a 00 00 00 	cmpl   $0x0,0xa28(%eax)
    8389:	74 1e                	je     83a9 <trickles_destroy+0x42e>
		kfree(tp->t.hmacCTX);
    838b:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    838e:	8b 80 28 0a 00 00    	mov    0xa28(%eax),%eax
    8394:	89 04 24             	mov    %eax,(%esp,1)
    8397:	e8 fc ff ff ff       	call   8398 <trickles_destroy+0x41d>
		tp->t.hmacCTX = NULL;
    839c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    839f:	c7 80 28 0a 00 00 00 	movl   $0x0,0xa28(%eax)
    83a6:	00 00 00 
	}
#endif
	if(tp->t.nonceCTX) {
    83a9:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    83ac:	83 b8 3c 0a 00 00 00 	cmpl   $0x0,0xa3c(%eax)
    83b3:	74 1e                	je     83d3 <trickles_destroy+0x458>
		kfree(tp->t.nonceCTX);
    83b5:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    83b8:	8b 80 3c 0a 00 00    	mov    0xa3c(%eax),%eax
    83be:	89 04 24             	mov    %eax,(%esp,1)
    83c1:	e8 fc ff ff ff       	call   83c2 <trickles_destroy+0x447>
		tp->t.nonceCTX = NULL;
    83c6:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    83c9:	c7 80 3c 0a 00 00 00 	movl   $0x0,0xa3c(%eax)
    83d0:	00 00 00 
	}
	if(0 && trickles_ratelimit() && (numRxPackets != 0 || numTxPackets != 0)) {
		printk("numRxPackets = %llu, numRxBytes = %llu, avgRxPacketSize = %d, numTxPackets = %llu, numTxBytes = %llu, avgTxPacketSize = %d\n",
		       numRxPackets, numRxBytes, (__u32)(numRxPackets >> 4) ? (__u32)(numRxBytes >> 4) / (__u32)(numRxPackets >> 4) : 0,
		       numTxPackets, numTxBytes, (__u32)(numTxPackets >> 4) ? (__u32)(numTxBytes >> 4) / (__u32)(numTxPackets >> 4) : 0);
		numRxPackets = numRxBytes = numTxPackets = numTxBytes = 0;
	}

#ifndef USERTEST
	/* Unlink from global client socket list */
	if((tp->trickles_opt & TCP_TRICKLES_ENABLE) && !(tp->trickles_opt & TCP_TRICKLES_RSERVER)) {
    83d3:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    83d6:	8b 80 ec 01 00 00    	mov    0x1ec(%eax),%eax
    83dc:	83 e0 01             	and    $0x1,%eax
    83df:	85 c0                	test   %eax,%eax
    83e1:	74 1d                	je     8400 <trickles_destroy+0x485>
    83e3:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    83e6:	8b 80 ec 01 00 00    	mov    0x1ec(%eax),%eax
    83ec:	83 e0 08             	and    $0x8,%eax
    83ef:	85 c0                	test   %eax,%eax
    83f1:	75 0d                	jne    8400 <trickles_destroy+0x485>
		trickles_del_clientsock(sk);
    83f3:	8b 45 08             	mov    0x8(%ebp),%eax
    83f6:	89 04 24             	mov    %eax,(%esp,1)
    83f9:	e8 fc ff ff ff       	call   83fa <trickles_destroy+0x47f>
    83fe:	eb 20                	jmp    8420 <trickles_destroy+0x4a5>
	} else {
		BUG_TRAP(tp->t.dnext == NULL);
    8400:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    8403:	83 b8 28 09 00 00 00 	cmpl   $0x0,0x928(%eax)
    840a:	74 14                	je     8420 <trickles_destroy+0x4a5>
    840c:	c7 44 24 04 d4 14 00 	movl   $0x14d4,0x4(%esp,1)
    8413:	00 
    8414:	c7 04 24 e0 30 00 00 	movl   $0x30e0,(%esp,1)
    841b:	e8 fc ff ff ff       	call   841c <trickles_destroy+0x4a1>
	}
#endif // USERTEST

#ifdef RECORD_LOSS_EVENTS
	if(tp->t.events != NULL) {
		struct TricklesProcLogEntry *newEntry =
			kmalloc(sizeof(struct TricklesProcLogEntry), GFP_ATOMIC);
		newEntry->next = newEntry->prev = NULL;
		newEntry->list = NULL;
		newEntry->addr = sk->daddr;
		newEntry->port = sk->dport;
		newEntry->rcv_nxt = tp->rcv_nxt;
		newEntry->t_rcv_nxt = tp->t.rcv_nxt;

		newEntry->events = tp->t.events;
		newEntry->size = tp->t.eventsSize;
		newEntry->returnedEvents = 0;
		newEntry->sentAmount = 0;
		insert_tail(&tricklesProcLogHead, (struct alloc_head *)newEntry);
	}
#endif
	if(sk->prev) {
    8420:	8b 45 08             	mov    0x8(%ebp),%eax
    8423:	83 78 7c 00          	cmpl   $0x0,0x7c(%eax)
    8427:	74 0c                	je     8435 <trickles_destroy+0x4ba>
		printk("Trickles prev != NULL\n");
    8429:	c7 04 24 22 31 00 00 	movl   $0x3122,(%esp,1)
    8430:	e8 fc ff ff ff       	call   8431 <trickles_destroy+0x4b6>
	}
	if(sk->bind_next) {
    8435:	8b 45 08             	mov    0x8(%ebp),%eax
    8438:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
    843c:	74 0c                	je     844a <trickles_destroy+0x4cf>
		printk("Trickles bind_next != NULL\n");
    843e:	c7 04 24 39 31 00 00 	movl   $0x3139,(%esp,1)
    8445:	e8 fc ff ff ff       	call   8446 <trickles_destroy+0x4cb>
	}
	gNumUncopiedBytes += tp->rcv_nxt - tp->copied_seq;
    844a:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
    844d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    8450:	8b 90 fc 00 00 00    	mov    0xfc(%eax),%edx
    8456:	8b 41 08             	mov    0x8(%ecx),%eax
    8459:	29 d0                	sub    %edx,%eax
    845b:	01 05 00 00 00 00    	add    %eax,0x0
	//dump_global_stats();
}
    8461:	c9                   	leave  
    8462:	c3                   	ret    

00008463 <init_module>:

#ifndef USERTEST

kmem_cache_t *clientSideContinuation_cache;

static inline void clientSideContinuation_init(void *p, kmem_cache_t *cache,
					       unsigned long flags) {
	return;
}

static char *contCacheName;

int trickles_init(void) {
    8463:	55                   	push   %ebp
    8464:	89 e5                	mov    %esp,%ebp
    8466:	57                   	push   %edi
    8467:	56                   	push   %esi
    8468:	83 ec 18             	sub    $0x18,%esp
	BUG_TRAP(HMAC_PHEADER_LEN == sizeof(PseudoHeader));
	sysctl_trickles_mss = 1374 - 16;
    846b:	c7 05 00 00 00 00 4e 	movl   $0x54e,0x0
    8472:	05 00 00 
	//sysctl_trickles_mss = 1374 - 32;

	trickles_prot = tcp_prot;
    8475:	bf 00 00 00 00       	mov    $0x0,%edi
    847a:	be 00 00 00 00       	mov    $0x0,%esi
    847f:	b8 84 00 00 00       	mov    $0x84,%eax
    8484:	fc                   	cld    
    8485:	89 c1                	mov    %eax,%ecx
    8487:	c1 e9 02             	shr    $0x2,%ecx
    848a:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
	trickles_prot.sendmsg = trickles_sendmsg;
    848c:	c7 05 28 00 00 00 00 	movl   $0x0,0x28
    8493:	00 00 00 
	trickles_prot.close = trickles_close;
    8496:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    849d:	00 00 00 
	trickles_client_prot = trickles_prot;
    84a0:	bf 00 00 00 00       	mov    $0x0,%edi
    84a5:	be 00 00 00 00       	mov    $0x0,%esi
    84aa:	b8 84 00 00 00       	mov    $0x84,%eax
    84af:	fc                   	cld    
    84b0:	89 c1                	mov    %eax,%ecx
    84b2:	c1 e9 02             	shr    $0x2,%ecx
    84b5:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)

	trickles_client_prot.sendmsg = trickles_client_sendmsg;
    84b7:	c7 05 28 00 00 00 00 	movl   $0x0,0x28
    84be:	00 00 00 
	trickles_client_prot.recvmsg = trickles_client_recvmsg;
    84c1:	c7 05 2c 00 00 00 00 	movl   $0x0,0x2c
    84c8:	00 00 00 

	trickles_rcv_hook = trickles_rcv_impl;
    84cb:	c7 05 00 00 00 00 28 	movl   $0x1128,0x0
    84d2:	11 00 00 
	trickles_destroy_hook = trickles_destroy;
    84d5:	c7 05 00 00 00 00 7b 	movl   $0x7f7b,0x0
    84dc:	7f 00 00 

	cminisock_config_pipe_hook = cminisock_config_pipe_impl;
    84df:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    84e6:	00 00 00 
	trickles_sendv_hook = trickles_sendv_impl;
    84e9:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    84f0:	00 00 00 
	trickles_send_hook = trickles_send_impl;
    84f3:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    84fa:	00 00 00 
	trickles_sendfilev_hook = trickles_sendfilev_impl;
    84fd:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    8504:	00 00 00 
	trickles_mmap_hook = trickles_mmap_impl;
    8507:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    850e:	00 00 00 
	trickles_setucont_hook = trickles_setucont_impl;
    8511:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    8518:	00 00 00 

	trickles_sock_poll_hook = trickles_sock_poll_impl;
    851b:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    8522:	00 00 00 
	trickles_init_sock_hook = trickles_init_sock_impl;
    8525:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    852c:	00 00 00 

	trickles_send_ack_hook = user_ack_impl;
    852f:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    8536:	00 00 00 

	trickles_sockets_head.tp_pinfo.af_tcp.t.dnext = &trickles_sockets_head;
    8539:	c7 05 e4 09 00 00 00 	movl   $0x0,0x9e4
    8540:	00 00 00 
	trickles_sockets_head.tp_pinfo.af_tcp.t.dprev = &trickles_sockets_head;
    8543:	c7 05 e0 09 00 00 00 	movl   $0x0,0x9e0
    854a:	00 00 00 

	trickles_getsockopt_hook = trickles_getsockopt_impl;
    854d:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    8554:	00 00 00 

	printk("Warning: Low level Trickles client interface not implemented\n");
    8557:	c7 04 24 60 31 00 00 	movl   $0x3160,(%esp,1)
    855e:	e8 fc ff ff ff       	call   855f <init_module+0xfc>
	trickles_sendmsg_hook = NULL;
    8563:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    856a:	00 00 00 

	trickles_sendbulk_hook = trickles_sendbulk_impl;
    856d:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    8574:	00 00 00 

	trickles_extract_events_hook = trickles_extract_events_impl;
    8577:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    857e:	00 00 00 
	trickles_install_events_hook = trickles_install_events_impl;
    8581:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    8588:	00 00 00 
	trickles_syn_piggyback_hook = trickles_syn_piggyback_impl;
    858b:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    8592:	00 00 00 

	/* initialize crappy RNG */
	rand = jiffies;
    8595:	a1 00 00 00 00       	mov    0x0,%eax
    859a:	a3 60 73 04 00       	mov    %eax,0x47360

	//trickles_client_connected_hook = trickles_client_connected_impl;

#ifdef USE_FLOATINGPOINT
	{
		int i;
		kernel_fpu_begin();
		barrier();
		init_fpu();
		barrier();
		for(i=0; i < NR_CPUS; i++) {
#ifdef FAST_CONTEXT
			asm __volatile__ ("fninit\n fnstcw %0": "=m"(fpu_kernel_save[i][0]));
			*((short*)fpu_kernel_save[i]) |= 0x1f; // mask all exceptions
#else
			asm __volatile__ ("fninit\n");
			barrier();
			FPU_SAVE(fpu_kernel_save[i]);
			barrier();
#endif
		}
		barrier();
		kernel_fpu_end();
	}
#else
		/*
		  for(i=0; i < 1000; i++) {
		  printk("mborg_isqrt(%d) = %d\n", i, mborg_isqrt4(i));
		  }
		*/
#endif // USE_FLOATINGPOINT

	printk("trickles loaded (hmac = %d nonce = %d): %s %s\n", generateHMAC, generateNonces, UTS_VERSION, LINUX_COMPILE_HOST);
    859f:	c7 44 24 10 9e 31 00 	movl   $0x319e,0x10(%esp,1)
    85a6:	00 
    85a7:	c7 44 24 0c c0 31 00 	movl   $0x31c0,0xc(%esp,1)
    85ae:	00 
    85af:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp,1)
    85b6:	00 
    85b7:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
    85be:	00 
    85bf:	c7 04 24 00 32 00 00 	movl   $0x3200,(%esp,1)
    85c6:	e8 fc ff ff ff       	call   85c7 <init_module+0x164>


#ifdef DEBUG_LIST
	printk("***** Warning: DebugList\n");
#endif

#ifdef CONFIG_DEBUG_SLAB
	printk("***** Warning: Compiled with SLAB debug on, will be absolutely extremely slow. You won't believe how slow this is.\n");
#endif

#ifdef FIXEDRTT
	printk("***** Warning :FIXEDRTT\n");
#endif

	if(disableSevereErrors) {
    85cb:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    85d2:	74 0c                	je     85e0 <init_module+0x17d>
		printk("***** Warning: Printk of severe errors & warnings suppressed\n");
    85d4:	c7 04 24 40 32 00 00 	movl   $0x3240,(%esp,1)
    85db:	e8 fc ff ff ff       	call   85dc <init_module+0x179>
	}

#ifdef DEBUG_TRICKLES_ALLOCATION
	printk("***** Warning: debugging trickles allocation\n");
#endif

	if(!enableDataRecovery) {
    85e0:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    85e7:	75 0c                	jne    85f5 <init_module+0x192>
		printk("**** Warning: enableDataRecovery == 0\n");
    85e9:	c7 04 24 80 32 00 00 	movl   $0x3280,(%esp,1)
    85f0:	e8 fc ff ff ff       	call   85f1 <init_module+0x18e>
	}
	contCacheName = kmalloc(128, GFP_ATOMIC);
    85f5:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    85fc:	00 
    85fd:	c7 04 24 80 00 00 00 	movl   $0x80,(%esp,1)
    8604:	e8 fc ff ff ff       	call   8605 <init_module+0x1a2>
    8609:	a3 64 73 04 00       	mov    %eax,0x47364
	// We leak about 30 objects from this slab every run. For now, change the name of the run on each bootup to avoid BUG() assertion on kmem_cache_create
	sprintf(contCacheName, "cont#%lu", jiffies);
    860e:	a1 00 00 00 00       	mov    0x0,%eax
    8613:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    8617:	c7 44 24 04 a7 32 00 	movl   $0x32a7,0x4(%esp,1)
    861e:	00 
    861f:	a1 64 73 04 00       	mov    0x47364,%eax
    8624:	89 04 24             	mov    %eax,(%esp,1)
    8627:	e8 fc ff ff ff       	call   8628 <init_module+0x1c5>

	//0501 hack to find memory leak
	if(2 * sizeof(CONTINUATION_TYPE) > 4096) {
		BUG();
	}
#ifdef DEBUG_ALLOC
	printk("Warning: 4K allocation for clientsidecontinuation_cache: compiling in 386 mode to disable PSE, PGE. pse = %d, pge = %d; ack_prev integrity check\n", cpu_has_pse, cpu_has_pge);
	clientSideContinuation_cache =
		kmem_cache_create(contCacheName,
				  4096,
				  0,
				  SLAB_PAGE_ALIGN | SLAB_DEBUG_INITIAL | SLAB_POISON | SLAB_RED_ZONE,
				  clientSideContinuation_init, NULL);
#else
	clientSideContinuation_cache =
    862c:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp,1)
    8633:	00 
    8634:	c7 44 24 10 ec bd 00 	movl   $0xbdec,0x10(%esp,1)
    863b:	00 
    863c:	c7 44 24 0c 00 20 00 	movl   $0x2000,0xc(%esp,1)
    8643:	00 
    8644:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    864b:	00 
    864c:	c7 44 24 04 f8 01 00 	movl   $0x1f8,0x4(%esp,1)
    8653:	00 
    8654:	a1 64 73 04 00       	mov    0x47364,%eax
    8659:	89 04 24             	mov    %eax,(%esp,1)
    865c:	e8 fc ff ff ff       	call   865d <init_module+0x1fa>
    8661:	a3 00 00 00 00       	mov    %eax,0x0
		kmem_cache_create(contCacheName,
				  CLIENTSIDE_CONTINUATION_SIZE,
				  0,
				  SLAB_HWCACHE_ALIGN /* | SLAB_DEBUG_INITIAL | SLAB_POISON | SLAB_RED_ZONE */,
				  clientSideContinuation_init, NULL);
#endif
#ifndef INIT2
	printk("Warning: not initializing both elements in continuation arrays\n");
#endif
#ifdef SAVE_APHIST
	printk("Warning: APHist array being allocated and wasting space\n");
#endif

	printk("Warning: Stuck client state detection (slow start left/right violation) disabled\n");
    8666:	c7 04 24 c0 32 00 00 	movl   $0x32c0,(%esp,1)
    866d:	e8 fc ff ff ff       	call   866e <init_module+0x20b>
	printk("Warning: Disabled server-side recovery mode's out of memory errors\n");
    8672:	c7 04 24 20 33 00 00 	movl   $0x3320,(%esp,1)
    8679:	e8 fc ff ff ff       	call   867a <init_module+0x217>

#ifdef DISABLE_DATAREQUEST
	printk("Warning: Disabling DataRequest\n");
#endif
#ifdef RECORD_LOSS_EVENTS
	printk("Warning: Recording loss events\n");
#endif

#ifdef SLOWSTART_ONLY
	printk("Warning: Slow start only; no fast recovery\n");
#endif

#ifdef RANDOMIZE_SLOWSTART_TIMER
	printk("Randomizing slow start timer\n");
    867e:	c7 04 24 64 33 00 00 	movl   $0x3364,(%esp,1)
    8685:	e8 fc ff ff ff       	call   8686 <init_module+0x223>
#endif

#ifdef STOMP_CONNECTIONS
	printk("Stomping connections every %d\n", STOMP_CONNECTIONS);
#endif

	sysctl_dbg_cwnd = 0;
    868a:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    8691:	00 00 00 
	if(sysctl_dbg_cwnd) {
    8694:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    869b:	74 0c                	je     86a9 <init_module+0x246>
		printk("Dumping cwnd to log\n");
    869d:	c7 04 24 82 33 00 00 	movl   $0x3382,(%esp,1)
    86a4:	e8 fc ff ff ff       	call   86a5 <init_module+0x242>
	}

	init_head(&tricklesProcLogHead);
    86a9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    86b0:	e8 1e 0b 00 00       	call   91d3 <init_head>
	create_proc_read_entry("trickles", S_IRUGO | S_IWUSR,
    86b5:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp,1)
    86bc:	00 
    86bd:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp,1)
    86c4:	00 
    86c5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    86cc:	00 
    86cd:	c7 44 24 04 a4 01 00 	movl   $0x1a4,0x4(%esp,1)
    86d4:	00 
    86d5:	c7 04 24 97 33 00 00 	movl   $0x3397,(%esp,1)
    86dc:	e8 5f 24 00 00       	call   ab40 <create_proc_read_entry>
			       NULL, trickles_read_proc, NULL);

	init_head(&tricklesCwndProcLogHead);
    86e1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    86e8:	e8 e6 0a 00 00       	call   91d3 <init_head>
	create_proc_read_entry("trickles_cwnd", S_IRUGO | S_IWUSR,
    86ed:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp,1)
    86f4:	00 
    86f5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp,1)
    86fc:	00 
    86fd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    8704:	00 
    8705:	c7 44 24 04 a4 01 00 	movl   $0x1a4,0x4(%esp,1)
    870c:	00 
    870d:	c7 04 24 a0 33 00 00 	movl   $0x33a0,(%esp,1)
    8714:	e8 27 24 00 00       	call   ab40 <create_proc_read_entry>
			       NULL, trickles_cwnd_read_proc, NULL);

#ifdef LOG_CWND_ENABLE
	trickles_logCwnd_hook = trickles_logCwnd_impl;
	printk("Log cwnd enabled!!!\n");
#else
	trickles_logCwnd_hook = trickles_logCwnd_default;
    8719:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    8720:	00 00 00 
#endif

	printk("Multiplicative factor = %d\n", MULT_FACTOR);
    8723:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp,1)
    872a:	00 
    872b:	c7 04 24 ae 33 00 00 	movl   $0x33ae,(%esp,1)
    8732:	e8 fc ff ff ff       	call   8733 <init_module+0x2d0>

#ifdef ACKTCP_CWND_SPEED_HACK
#define STRINGIFY(X) #X
	printk("Using AckTCPCwnd speed hack " STRINGIFY(ACKTCP_CWND_SPEED_HACK) "\n");
    8737:	c7 04 24 e0 33 00 00 	movl   $0x33e0,(%esp,1)
    873e:	e8 fc ff ff ff       	call   873f <init_module+0x2dc>
#undef STRINGIFY
#endif
	printk("Timeout multiplier: %d\n", TIMEOUT_MULTIPLIER);
    8743:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp,1)
    874a:	00 
    874b:	c7 04 24 14 34 00 00 	movl   $0x3414,(%esp,1)
    8752:	e8 fc ff ff ff       	call   8753 <init_module+0x2f0>

#ifdef ZERO_SSTHRESH_PROTECTION_HACK
	printk("Zero ssthresh protection hack\n");
    8757:	c7 04 24 40 34 00 00 	movl   $0x3440,(%esp,1)
    875e:	e8 fc ff ff ff       	call   875f <init_module+0x2fc>
#endif
#ifdef DISABLE_ACKTCPCWND_WARNINGS
	printk("AckTCPCwnd warnings disabled\n");
    8763:	c7 04 24 5f 34 00 00 	movl   $0x345f,(%esp,1)
    876a:	e8 fc ff ff ff       	call   876b <init_module+0x308>
#endif
#ifdef DISABLE_SENDACKOVERFLOW
	printk("SendAckOverflow disabled\n");
    876f:	c7 04 24 7d 34 00 00 	movl   $0x347d,(%esp,1)
    8776:	e8 fc ff ff ff       	call   8777 <init_module+0x314>
#endif

#ifdef FIXED_CRYPTO_KEYS
	printk("Fixed crypto keys\n");
    877b:	c7 04 24 97 34 00 00 	movl   $0x3497,(%esp,1)
    8782:	e8 fc ff ff ff       	call   8783 <init_module+0x320>
#endif
	if(DISABLE_NONCE_CHECK) {
		printk("Nonce check disabled\n");
	}

#ifdef DISABLE_SADDR_HMAC
	printk("Server source address not included in HMAC\n");
    8787:	c7 04 24 c0 34 00 00 	movl   $0x34c0,(%esp,1)
    878e:	e8 fc ff ff ff       	call   878f <init_module+0x32c>
#endif

#ifdef DISABLE_NONCE_FAIL
	printk("!!!Disabled nonce mismatch check!!!\n");
#endif

#ifdef PRINT_NONCE_DIAG
	{
		int i;
		struct aes_encrypt_ctx ctx;
		char nonce_key[NONCE_KEYLEN];
		char block[NONCE_BLOCKSIZE];
		memset(nonce_key, 0, NONCE_KEYLEN);
		memset(block, 0, NONCE_BLOCKSIZE);
		strcpy(nonce_key, "hello w");
		aes_encrypt_key(nonce_key, NONCE_KEYLEN, &ctx);
		for(i=0; i < 10; i++) {
			char output[NONCE_BLOCKSIZE];
			*(__u64*)block = i * i;
			aes_encrypt(block, output, &ctx);
			printk(" Input: ");
			hexdump(block, NONCE_BLOCKSIZE);
			printk("\n");
			printk("Output: ");
			hexdump(output, NONCE_BLOCKSIZE);
			printk("\n");
		}
#define TAR_MAX (10)
		__u32 testArray[TAR_MAX];
		for(i=1; i <= TAR_MAX; i++) {
			printk("Range nonce 1-%d 0x%0X\n", i,
			       testArray[i] =
			       generateCryptoRangeNonceHelper(&ctx, 1, i));
		}
		printk("Nonces 1-%d: ", TAR_MAX);
		struct NonceCtx nctx;
		nctx.new = 1;
		__u32 accum = 0;
		for(i=1; i <= TAR_MAX; i++) {
			__u32 curr = generateCryptoSingleNonceHelper(&ctx, i, &nctx);
			accum ^= curr;
			printk("0x%0X%c ", accum, (accum == testArray[i]) ? 'g' : '!');
		}
#undef TAR_MAX
	}
#endif
	printk("WIRECONT_MAC_LEN: %d\n", WIRECONT_MAC_LEN);
    8793:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp,1)
    879a:	00 
    879b:	c7 04 24 ec 34 00 00 	movl   $0x34ec,(%esp,1)
    87a2:	e8 fc ff ff ff       	call   87a3 <init_module+0x340>

#ifdef RCV_COPY_TO_SMALLER_SKB
	printk("Client is copying dev skbs to minimal size skbs\n");
    87a7:	c7 04 24 20 35 00 00 	movl   $0x3520,(%esp,1)
    87ae:	e8 fc ff ff ff       	call   87af <init_module+0x34c>
#endif
	printk("FullMSS = %d, MinimalMSS = %d, "
    87b3:	c7 44 24 14 1f 00 00 	movl   $0x1f,0x14(%esp,1)
    87ba:	00 
    87bb:	c7 44 24 10 15 00 00 	movl   $0x15,0x10(%esp,1)
    87c2:	00 
    87c3:	c7 44 24 0c 4a 00 00 	movl   $0x4a,0xc(%esp,1)
    87ca:	00 
    87cb:	a1 00 00 00 00       	mov    0x0,%eax
    87d0:	83 c0 35             	add    $0x35,%eax
    87d3:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    87d7:	a1 00 00 00 00       	mov    0x0,%eax
    87dc:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    87e0:	c7 04 24 60 35 00 00 	movl   $0x3560,(%esp,1)
    87e7:	e8 fc ff ff ff       	call   87e8 <init_module+0x385>
	       "CONTTYPELEN_FULL = %d, CONTTYPELEN_MINIMAL = %d, HASHCOMPRESS = %d\n",
	       CONTTYPE_FULL_MSS, CONTTYPE_MINIMAL_MSS,
	       CONTTYPELEN_FULL, CONTTYPELEN_MINIMAL,
	       CONTTYPELEN_HASHCOMPRESS);

	if(sendOnlyOneRequest) {
    87ec:	83 3d b4 00 00 00 00 	cmpl   $0x0,0xb4
    87f3:	74 0c                	je     8801 <init_module+0x39e>
		printk("sending only one request from missing data map and unrequested data\n");
    87f5:	c7 04 24 e0 35 00 00 	movl   $0x35e0,(%esp,1)
    87fc:	e8 fc ff ff ff       	call   87fd <init_module+0x39a>
	}

#ifdef SANITY_CHECK_RANGEHEADER
	printk("Warning: Sanity checking range header at kernel level in msk_transmit_skb()\n");
#endif

#ifdef GREP_FOR_RANGEHEADER
	printk("Warning: grepping for misplaced range header in input\n");
#endif

#ifdef CHECK_MINRESPONSELEN
	printk("Warning: Checking minresponselen\n");
#endif

#ifdef MIN_RESPONSELEN_ADJ_HACK
	printk("MinResponseLenAdjHack(%d) enabled\n", MIN_RESPONSELEN_ADJ_HACK);
#endif
#ifdef MIN_RESPONSELEN_ADJUP_TEST
	printk("MIN_RESPONSELEN_ADJUP_TEST -- performance will be horrible\n");
#endif

#ifdef RTT_INCLUDES_USER
	printk("Rtt will include server-side user time\n");
    8801:	c7 04 24 40 36 00 00 	movl   $0x3640,(%esp,1)
    8808:	e8 fc ff ff ff       	call   8809 <init_module+0x3a6>
#else
	printk("Rtt will NOT include server-side user time\n");
#endif

#ifdef HIDE_PREMATURE_LOSS_DETECTION
	printk("Hiding premature loss detection, the slow start thresholds are (min,max) = (%d,%d)\n", MIN_SS_TIMEOUT, MAX_SS_TIMEOUT);
#endif

	if(TIMEOUT_MULTIPLIER != 2) {
		printk("Warning: Timeout multiplier %d != 2\n",
		       TIMEOUT_MULTIPLIER);
	}

	printk("HZ = %d\n", HZ);
    880d:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp,1)
    8814:	00 
    8815:	c7 04 24 68 36 00 00 	movl   $0x3668,(%esp,1)
    881c:	e8 fc ff ff ff       	call   881d <init_module+0x3ba>

#ifdef CHUNKID
	printk("Warning: using CHUNKID\n");
    8821:	c7 04 24 71 36 00 00 	movl   $0x3671,(%esp,1)
    8828:	e8 fc ff ff ff       	call   8829 <init_module+0x3c6>
#endif
	if(!dbgBadChunk) {
    882d:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    8834:	75 0c                	jne    8842 <init_module+0x3df>
		printk("bad data chunk errors suppressed\n");
    8836:	c7 04 24 a0 36 00 00 	movl   $0x36a0,(%esp,1)
    883d:	e8 fc ff ff ff       	call   883e <init_module+0x3db>
	}

	hist_init(&a_histogram, "A", 40, 0, 400);
    8842:	c7 44 24 10 90 01 00 	movl   $0x190,0x10(%esp,1)
    8849:	00 
    884a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp,1)
    8851:	00 
    8852:	c7 44 24 08 28 00 00 	movl   $0x28,0x8(%esp,1)
    8859:	00 
    885a:	c7 44 24 04 c2 36 00 	movl   $0x36c2,0x4(%esp,1)
    8861:	00 
    8862:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    8869:	e8 bc 21 00 00       	call   aa2a <hist_init>
	hist_init(&d_histogram, "D", 40, 0, 400);
    886e:	c7 44 24 10 90 01 00 	movl   $0x190,0x10(%esp,1)
    8875:	00 
    8876:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp,1)
    887d:	00 
    887e:	c7 44 24 08 28 00 00 	movl   $0x28,0x8(%esp,1)
    8885:	00 
    8886:	c7 44 24 04 c4 36 00 	movl   $0x36c4,0x4(%esp,1)
    888d:	00 
    888e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    8895:	e8 90 21 00 00       	call   aa2a <hist_init>
	hist_init(&timeout_histogram, "timeout", 100, 0, 1000);
    889a:	c7 44 24 10 e8 03 00 	movl   $0x3e8,0x10(%esp,1)
    88a1:	00 
    88a2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp,1)
    88a9:	00 
    88aa:	c7 44 24 08 64 00 00 	movl   $0x64,0x8(%esp,1)
    88b1:	00 
    88b2:	c7 44 24 04 c6 36 00 	movl   $0x36c6,0x4(%esp,1)
    88b9:	00 
    88ba:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    88c1:	e8 64 21 00 00       	call   aa2a <hist_init>


#ifdef ENABLE_RECYCLING
	printk("SKB recycling enabled\n");
    88c6:	c7 04 24 ce 36 00 00 	movl   $0x36ce,(%esp,1)
    88cd:	e8 fc ff ff ff       	call   88ce <init_module+0x46b>
#else
	printk("SKB recycling disabled\n");
#endif

	printk("Server debug level = %d\n", serverDebugLevel);
    88d2:	a1 00 00 00 00       	mov    0x0,%eax
    88d7:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    88db:	c7 04 24 e5 36 00 00 	movl   $0x36e5,(%esp,1)
    88e2:	e8 fc ff ff ff       	call   88e3 <init_module+0x480>

	StateCache_init();
    88e7:	e8 fc ff ff ff       	call   88e8 <init_module+0x485>
	printk("trickles continuation state cache enable: %d\n", sysctl_trickles_Continuation_enable);
    88ec:	a1 00 00 00 00       	mov    0x0,%eax
    88f1:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    88f5:	c7 04 24 00 37 00 00 	movl   $0x3700,(%esp,1)
    88fc:	e8 fc ff ff ff       	call   88fd <init_module+0x49a>
	printk("Warning: Only one single global continuation state cache (yes, this is broken)\n");
    8901:	c7 04 24 40 37 00 00 	movl   $0x3740,(%esp,1)
    8908:	e8 fc ff ff ff       	call   8909 <init_module+0x4a6>

	return 0;
    890d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8912:	83 c4 18             	add    $0x18,%esp
    8915:	5e                   	pop    %esi
    8916:	5f                   	pop    %edi
    8917:	5d                   	pop    %ebp
    8918:	c3                   	ret    

00008919 <cleanup_module>:

static void trickles_exit(void) {
    8919:	55                   	push   %ebp
    891a:	89 e5                	mov    %esp,%ebp
    891c:	83 ec 38             	sub    $0x38,%esp
	struct sock *sk = trickles_sockets_head.next;
    891f:	a1 10 00 00 00       	mov    0x10,%eax
    8924:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	trickles_rcv_hook = trickles_rcv_default;
    8927:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    892e:	00 00 00 
	trickles_destroy_hook = trickles_destroy_default;
    8931:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    8938:	00 00 00 
	cminisock_config_pipe_hook = cminisock_config_pipe_default;
    893b:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    8942:	00 00 00 
	trickles_sendv_hook = trickles_sendv_default;
    8945:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    894c:	00 00 00 
	trickles_send_hook = trickles_send_default;
    894f:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    8956:	00 00 00 
	trickles_sendfilev_hook = trickles_sendfilev_default;
    8959:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    8960:	00 00 00 
	trickles_mmap_hook = trickles_mmap_default;
    8963:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    896a:	00 00 00 
	trickles_sock_poll_hook = trickles_sock_poll_default;
    896d:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    8974:	00 00 00 
	trickles_init_sock_hook = trickles_init_sock_default;
    8977:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    897e:	00 00 00 
	trickles_send_ack_hook = trickles_send_ack_default;
    8981:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    8988:	00 00 00 
	trickles_setucont_hook = trickles_setucont_default;
    898b:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    8992:	00 00 00 
	trickles_getsockopt_hook = trickles_getsockopt_default;
    8995:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    899c:	00 00 00 

	trickles_sendmsg_hook = trickles_sendmsg_default;
    899f:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    89a6:	00 00 00 
	trickles_logCwnd_hook = trickles_logCwnd_default;
    89a9:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    89b0:	00 00 00 

	trickles_sendbulk_hook = trickles_sendbulk_default;
    89b3:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    89ba:	00 00 00 

	trickles_extract_events_hook = trickles_extract_events_default;
    89bd:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    89c4:	00 00 00 
	trickles_install_events_hook = trickles_install_events_default;
    89c7:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    89ce:	00 00 00 
	trickles_syn_piggyback_hook = trickles_syn_piggyback_default;
    89d1:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    89d8:	00 00 00 

	spin_lock(&trickles_sockets_head_lock);
	int i = 0;
    89db:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
	local_bh_disable();
    89e2:	ff 05 08 00 00 00    	incl   0x8
    89e8:	90                   	nop    
	while(sk && sk != &trickles_sockets_head) {
    89e9:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
    89ed:	74 29                	je     8a18 <cleanup_module+0xff>
    89ef:	81 7d fc 00 00 00 00 	cmpl   $0x0,0xfffffffc(%ebp)
    89f6:	75 02                	jne    89fa <cleanup_module+0xe1>
    89f8:	eb 1e                	jmp    8a18 <cleanup_module+0xff>
		trickles_clear_timers(sk);
    89fa:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    89fd:	89 04 24             	mov    %eax,(%esp,1)
    8a00:	e8 2a f5 ff ff       	call   7f2f <trickles_clear_timers>
		sk = sk->tp_pinfo.af_tcp.t.dnext;
    8a05:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    8a08:	8b 80 e4 09 00 00    	mov    0x9e4(%eax),%eax
    8a0e:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
		i++;
    8a11:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
    8a14:	ff 00                	incl   (%eax)
    8a16:	eb d1                	jmp    89e9 <cleanup_module+0xd0>
	}
	printk("%d timers cleared\n", i);
    8a18:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    8a1b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    8a1f:	c7 04 24 90 37 00 00 	movl   $0x3790,(%esp,1)
    8a26:	e8 fc ff ff ff       	call   8a27 <cleanup_module+0x10e>
	local_bh_enable();
    8a2b:	c7 45 f4 08 00 00 00 	movl   $0x8,0xfffffff4(%ebp)
    8a32:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    8a35:	ff 08                	decl   (%eax)
    8a37:	83 38 00             	cmpl   $0x0,(%eax)
    8a3a:	75 0d                	jne    8a49 <cleanup_module+0x130>
    8a3c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    8a3f:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
    8a43:	0f 85 39 3c 00 00    	jne    c682 <.text.lock.tmalloc+0x30>
	spin_unlock(&trickles_sockets_head_lock);
	//trickles_client_connected_hook = trickles_client_connected_default;
	printk("trickles unloaded\n");
    8a49:	c7 04 24 a3 37 00 00 	movl   $0x37a3,(%esp,1)
    8a50:	e8 fc ff ff ff       	call   8a51 <cleanup_module+0x138>
	printk("numConversionRequests = %d, numContinuationRequests = %d, numDataRequestMappings = %d\n",
    8a55:	a1 00 00 00 00       	mov    0x0,%eax
    8a5a:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    8a5e:	a1 00 00 00 00       	mov    0x0,%eax
    8a63:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    8a67:	a1 68 00 00 00       	mov    0x68,%eax
    8a6c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    8a70:	c7 04 24 c0 37 00 00 	movl   $0x37c0,(%esp,1)
    8a77:	e8 fc ff ff ff       	call   8a78 <cleanup_module+0x15f>
	       numConversionRequests, numContinuationRequests, numDataRequestMappings);

	printk("numRxPackets = %llu, numRxBytes = %llu, numTxPackets = %llu, numTxBytes = %llu\n",
    8a7c:	a1 00 00 00 00       	mov    0x0,%eax
    8a81:	8b 15 04 00 00 00    	mov    0x4,%edx
    8a87:	89 44 24 1c          	mov    %eax,0x1c(%esp,1)
    8a8b:	89 54 24 20          	mov    %edx,0x20(%esp,1)
    8a8f:	a1 00 00 00 00       	mov    0x0,%eax
    8a94:	8b 15 04 00 00 00    	mov    0x4,%edx
    8a9a:	89 44 24 14          	mov    %eax,0x14(%esp,1)
    8a9e:	89 54 24 18          	mov    %edx,0x18(%esp,1)
    8aa2:	a1 00 00 00 00       	mov    0x0,%eax
    8aa7:	8b 15 04 00 00 00    	mov    0x4,%edx
    8aad:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    8ab1:	89 54 24 10          	mov    %edx,0x10(%esp,1)
    8ab5:	a1 00 00 00 00       	mov    0x0,%eax
    8aba:	8b 15 04 00 00 00    	mov    0x4,%edx
    8ac0:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    8ac4:	89 54 24 08          	mov    %edx,0x8(%esp,1)
    8ac8:	c7 04 24 20 38 00 00 	movl   $0x3820,(%esp,1)
    8acf:	e8 fc ff ff ff       	call   8ad0 <cleanup_module+0x1b7>
	       numRxPackets, numRxBytes, numTxPackets, numTxBytes);

	kmem_cache_destroy(clientSideContinuation_cache);
    8ad4:	a1 00 00 00 00       	mov    0x0,%eax
    8ad9:	89 04 24             	mov    %eax,(%esp,1)
    8adc:	e8 fc ff ff ff       	call   8add <cleanup_module+0x1c4>

	struct TricklesProcLogEntry *logEntry;
	struct TricklesCwndProcLogEntry *cwndLogEntry;
	local_bh_disable();
    8ae1:	ff 05 08 00 00 00    	incl   0x8
	alloc_head_walk(&tricklesProcLogHead, logEntry) {
    8ae7:	a1 04 00 00 00       	mov    0x4,%eax
    8aec:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    8aef:	81 7d f4 00 00 00 00 	cmpl   $0x0,0xfffffff4(%ebp)
    8af6:	75 02                	jne    8afa <cleanup_module+0x1e1>
    8af8:	eb 3d                	jmp    8b37 <cleanup_module+0x21e>
		struct TricklesProcLogEntry *clean = logEntry;
    8afa:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    8afd:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
		logEntry = (struct TricklesProcLogEntry*)logEntry->prev;
    8b00:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    8b03:	8b 00                	mov    (%eax),%eax
    8b05:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		unlink((struct alloc_head*)clean);
    8b08:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    8b0b:	89 04 24             	mov    %eax,(%esp,1)
    8b0e:	e8 d9 07 00 00       	call   92ec <unlink>
		kfree(clean->events);
    8b13:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    8b16:	8b 40 1c             	mov    0x1c(%eax),%eax
    8b19:	89 04 24             	mov    %eax,(%esp,1)
    8b1c:	e8 fc ff ff ff       	call   8b1d <cleanup_module+0x204>
		kfree(clean);
    8b21:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    8b24:	89 04 24             	mov    %eax,(%esp,1)
    8b27:	e8 fc ff ff ff       	call   8b28 <cleanup_module+0x20f>
    8b2c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    8b2f:	8b 40 04             	mov    0x4(%eax),%eax
    8b32:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    8b35:	eb b8                	jmp    8aef <cleanup_module+0x1d6>
	}
	// should not need to take locks if bh is disabled
	alloc_head_walk(&tricklesCwndProcLogHead, cwndLogEntry) {
    8b37:	a1 04 00 00 00       	mov    0x4,%eax
    8b3c:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    8b3f:	81 7d f0 00 00 00 00 	cmpl   $0x0,0xfffffff0(%ebp)
    8b46:	75 02                	jne    8b4a <cleanup_module+0x231>
    8b48:	eb 2f                	jmp    8b79 <cleanup_module+0x260>
		struct TricklesCwndProcLogEntry *clean = cwndLogEntry;
    8b4a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    8b4d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
		cwndLogEntry = (struct TricklesCwndProcLogEntry*)cwndLogEntry->prev;
    8b50:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    8b53:	8b 00                	mov    (%eax),%eax
    8b55:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
		unlink((struct alloc_head*)clean);
    8b58:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    8b5b:	89 04 24             	mov    %eax,(%esp,1)
    8b5e:	e8 89 07 00 00       	call   92ec <unlink>
		kfree(clean);
    8b63:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    8b66:	89 04 24             	mov    %eax,(%esp,1)
    8b69:	e8 fc ff ff ff       	call   8b6a <cleanup_module+0x251>
    8b6e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    8b71:	8b 40 04             	mov    0x4(%eax),%eax
    8b74:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    8b77:	eb c6                	jmp    8b3f <cleanup_module+0x226>
	}
	local_bh_enable();
    8b79:	c7 45 ec 08 00 00 00 	movl   $0x8,0xffffffec(%ebp)
    8b80:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    8b83:	ff 08                	decl   (%eax)
    8b85:	83 38 00             	cmpl   $0x0,(%eax)
    8b88:	75 0d                	jne    8b97 <cleanup_module+0x27e>
    8b8a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    8b8d:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
    8b91:	0f 85 fb 3a 00 00    	jne    c692 <.text.lock.tmalloc+0x40>
	remove_proc_entry("trickles", NULL);
    8b97:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    8b9e:	00 
    8b9f:	c7 04 24 97 33 00 00 	movl   $0x3397,(%esp,1)
    8ba6:	e8 fc ff ff ff       	call   8ba7 <cleanup_module+0x28e>
	remove_proc_entry("trickles_cwnd", NULL);
    8bab:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    8bb2:	00 
    8bb3:	c7 04 24 a0 33 00 00 	movl   $0x33a0,(%esp,1)
    8bba:	e8 fc ff ff ff       	call   8bbb <cleanup_module+0x2a2>
	dump_global_stats();
    8bbf:	e8 32 7a ff ff       	call   5f6 <dump_global_stats>

	hist_destroy(&a_histogram);
    8bc4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    8bcb:	e8 d6 1e 00 00       	call   aaa6 <hist_destroy>
	hist_destroy(&d_histogram);
    8bd0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    8bd7:	e8 ca 1e 00 00       	call   aaa6 <hist_destroy>
	hist_destroy(&timeout_histogram);
    8bdc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    8be3:	e8 be 1e 00 00       	call   aaa6 <hist_destroy>

	dump_cache_stats();
    8be8:	e8 fc ff ff ff       	call   8be9 <cleanup_module+0x2d0>
	StateCache_destroy();
    8bed:	e8 fc ff ff ff       	call   8bee <cleanup_module+0x2d5>
}
    8bf2:	c9                   	leave  
    8bf3:	c3                   	ret    

00008bf4 <atomic_dec_and_test>:
 * cases.  Note that the guaranteed
 * useful range of an atomic_t is only 24 bits.
 */ 
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
    8bf4:	55                   	push   %ebp
    8bf5:	89 e5                	mov    %esp,%ebp
    8bf7:	83 ec 04             	sub    $0x4,%esp
	unsigned char c;

	__asm__ __volatile__(
    8bfa:	8b 55 08             	mov    0x8(%ebp),%edx
    8bfd:	8b 45 08             	mov    0x8(%ebp),%eax
    8c00:	ff 0a                	decl   (%edx)
    8c02:	0f 94 45 ff          	sete   0xffffffff(%ebp)
		LOCK "decl %0; sete %1"
		:"=m" (v->counter), "=qm" (c)
		:"m" (v->counter) : "memory");
	return c != 0;
    8c06:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
    8c0a:	0f 95 c0             	setne  %al
    8c0d:	0f b6 c0             	movzbl %al,%eax
}
    8c10:	c9                   	leave  
    8c11:	c3                   	ret    

00008c12 <__memcpy>:
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
    8c12:	55                   	push   %ebp
    8c13:	89 e5                	mov    %esp,%ebp
    8c15:	57                   	push   %edi
    8c16:	56                   	push   %esi
    8c17:	83 ec 0c             	sub    $0xc,%esp
int d0, d1, d2;
__asm__ __volatile__(
    8c1a:	8b 45 10             	mov    0x10(%ebp),%eax
    8c1d:	89 c1                	mov    %eax,%ecx
    8c1f:	c1 e9 02             	shr    $0x2,%ecx
    8c22:	8b 45 10             	mov    0x10(%ebp),%eax
    8c25:	8b 7d 08             	mov    0x8(%ebp),%edi
    8c28:	8b 75 0c             	mov    0xc(%ebp),%esi
    8c2b:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    8c2d:	a8 02                	test   $0x2,%al
    8c2f:	74 02                	je     8c33 <__memcpy+0x21>
    8c31:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    8c33:	a8 01                	test   $0x1,%al
    8c35:	74 01                	je     8c38 <__memcpy+0x26>
    8c37:	a4                   	movsb  %ds:(%esi),%es:(%edi)
    8c38:	89 c8                	mov    %ecx,%eax
    8c3a:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    8c3d:	89 f8                	mov    %edi,%eax
    8c3f:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    8c42:	89 f0                	mov    %esi,%eax
    8c44:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	"rep ; movsl\n\t"
	"testb $2,%b4\n\t"
	"je 1f\n\t"
	"movsw\n"
	"1:\ttestb $1,%b4\n\t"
	"je 2f\n\t"
	"movsb\n"
	"2:"
	: "=&c" (d0), "=&D" (d1), "=&S" (d2)
	:"0" (n/4), "q" (n),"1" ((long) to),"2" ((long) from)
	: "memory");
return (to);
    8c47:	8b 45 08             	mov    0x8(%ebp),%eax
}
    8c4a:	83 c4 0c             	add    $0xc,%esp
    8c4d:	5e                   	pop    %esi
    8c4e:	5f                   	pop    %edi
    8c4f:	5d                   	pop    %ebp
    8c50:	c3                   	ret    

00008c51 <__constant_c_and_count_memset>:

/*
 * This looks horribly ugly, but the compiler can optimize it totally,
 * as the count is constant.
 */
static inline void * __constant_memcpy(void * to, const void * from, size_t n)
{
	switch (n) {
		case 0:
			return to;
		case 1:
			*(unsigned char *)to = *(const unsigned char *)from;
			return to;
		case 2:
			*(unsigned short *)to = *(const unsigned short *)from;
			return to;
		case 3:
			*(unsigned short *)to = *(const unsigned short *)from;
			*(2+(unsigned char *)to) = *(2+(const unsigned char *)from);
			return to;
		case 4:
			*(unsigned long *)to = *(const unsigned long *)from;
			return to;
		case 6:	/* for Ethernet addresses */
			*(unsigned long *)to = *(const unsigned long *)from;
			*(2+(unsigned short *)to) = *(2+(const unsigned short *)from);
			return to;
		case 8:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			return to;
		case 12:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
			return to;
		case 16:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
			*(3+(unsigned long *)to) = *(3+(const unsigned long *)from);
			return to;
		case 20:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
			*(3+(unsigned long *)to) = *(3+(const unsigned long *)from);
			*(4+(unsigned long *)to) = *(4+(const unsigned long *)from);
			return to;
	}
#define COMMON(x) \
__asm__ __volatile__( \
	"rep ; movsl" \
	x \
	: "=&c" (d0), "=&D" (d1), "=&S" (d2) \
	: "0" (n/4),"1" ((long) to),"2" ((long) from) \
	: "memory");
{
	int d0, d1, d2;
	switch (n % 4) {
		case 0: COMMON(""); return to;
		case 1: COMMON("\n\tmovsb"); return to;
		case 2: COMMON("\n\tmovsw"); return to;
		default: COMMON("\n\tmovsw\n\tmovsb"); return to;
	}
}
  
#undef COMMON
}

#define __HAVE_ARCH_MEMCPY

#ifdef CONFIG_X86_USE_3DNOW

#include <asm/mmx.h>

/*
 *	This CPU favours 3DNow strongly (eg AMD Athlon)
 */

static inline void * __constant_memcpy3d(void * to, const void * from, size_t len)
{
	if (len < 512)
		return __constant_memcpy(to, from, len);
	return _mmx_memcpy(to, from, len);
}

static __inline__ void *__memcpy3d(void *to, const void *from, size_t len)
{
	if (len < 512)
		return __memcpy(to, from, len);
	return _mmx_memcpy(to, from, len);
}

#define memcpy(t, f, n) \
(__builtin_constant_p(n) ? \
 __constant_memcpy3d((t),(f),(n)) : \
 __memcpy3d((t),(f),(n)))

#else

/*
 *	No 3D Now!
 */
 
#define memcpy(t, f, n) \
(__builtin_constant_p(n) ? \
 __constant_memcpy((t),(f),(n)) : \
 __memcpy((t),(f),(n)))

#endif

/*
 * struct_cpy(x,y), copy structure *x into (matching structure) *y.
 *
 * We get link-time errors if the structure sizes do not match.
 * There is no runtime overhead, it's all optimized away at
 * compile time.
 */
extern void __struct_cpy_bug (void);

#define struct_cpy(x,y) 			\
({						\
	if (sizeof(*(x)) != sizeof(*(y))) 	\
		__struct_cpy_bug;		\
	memcpy(x, y, sizeof(*(x)));		\
})

#define __HAVE_ARCH_MEMMOVE
static inline void * memmove(void * dest,const void * src, size_t n)
{
int d0, d1, d2;
if (dest<src)
__asm__ __volatile__(
	"rep\n\t"
	"movsb"
	: "=&c" (d0), "=&S" (d1), "=&D" (d2)
	:"0" (n),"1" (src),"2" (dest)
	: "memory");
else
__asm__ __volatile__(
	"std\n\t"
	"rep\n\t"
	"movsb\n\t"
	"cld"
	: "=&c" (d0), "=&S" (d1), "=&D" (d2)
	:"0" (n),
	 "1" (n-1+(const char *)src),
	 "2" (n-1+(char *)dest)
	:"memory");
return dest;
}

#define memcmp __builtin_memcmp

#define __HAVE_ARCH_MEMCHR
static inline void * memchr(const void * cs,int c,size_t count)
{
int d0;
register void * __res;
if (!count)
	return NULL;
__asm__ __volatile__(
	"repne\n\t"
	"scasb\n\t"
	"je 1f\n\t"
	"movl $1,%0\n"
	"1:\tdecl %0"
	:"=D" (__res), "=&c" (d0) : "a" (c),"0" (cs),"1" (count));
return __res;
}

static inline void * __memset_generic(void * s, char c,size_t count)
{
int d0, d1;
__asm__ __volatile__(
	"rep\n\t"
	"stosb"
	: "=&c" (d0), "=&D" (d1)
	:"a" (c),"1" (s),"0" (count)
	:"memory");
return s;
}

/* we might want to write optimized versions of these later */
#define __constant_count_memset(s,c,count) __memset_generic((s),(c),(count))

/*
 * memset(x,0,y) is a reasonably common thing to do, so we want to fill
 * things 32 bits at a time even when we don't know the size of the
 * area at compile-time..
 */
static inline void * __constant_c_memset(void * s, unsigned long c, size_t count)
{
int d0, d1;
__asm__ __volatile__(
	"rep ; stosl\n\t"
	"testb $2,%b3\n\t"
	"je 1f\n\t"
	"stosw\n"
	"1:\ttestb $1,%b3\n\t"
	"je 2f\n\t"
	"stosb\n"
	"2:"
	: "=&c" (d0), "=&D" (d1)
	:"a" (c), "q" (count), "0" (count/4), "1" ((long) s)
	:"memory");
return (s);	
}

/* Added by Gertjan van Wingerde to make minix and sysv module work */
#define __HAVE_ARCH_STRNLEN
static inline size_t strnlen(const char * s, size_t count)
{
int d0;
register int __res;
__asm__ __volatile__(
	"movl %2,%0\n\t"
	"jmp 2f\n"
	"1:\tcmpb $0,(%0)\n\t"
	"je 3f\n\t"
	"incl %0\n"
	"2:\tdecl %1\n\t"
	"cmpl $-1,%1\n\t"
	"jne 1b\n"
	"3:\tsubl %2,%0"
	:"=a" (__res), "=&d" (d0)
	:"c" (s),"1" (count));
return __res;
}
/* end of additional stuff */

#define __HAVE_ARCH_STRSTR

extern char *strstr(const char *cs, const char *ct);

/*
 * This looks horribly ugly, but the compiler can optimize it totally,
 * as we by now know that both pattern and count is constant..
 */
static inline void * __constant_c_and_count_memset(void * s, unsigned long pattern, size_t count)
{
    8c51:	55                   	push   %ebp
    8c52:	89 e5                	mov    %esp,%ebp
    8c54:	57                   	push   %edi
    8c55:	83 ec 10             	sub    $0x10,%esp
	switch (count) {
    8c58:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
    8c5c:	77 74                	ja     8cd2 <__constant_c_and_count_memset+0x81>
    8c5e:	8b 45 10             	mov    0x10(%ebp),%eax
    8c61:	c1 e0 02             	shl    $0x2,%eax
    8c64:	8b 80 70 38 00 00    	mov    0x3870(%eax),%eax
    8c6a:	ff e0                	jmp    *%eax
		case 0:
			return s;
    8c6c:	8b 45 08             	mov    0x8(%ebp),%eax
    8c6f:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    8c72:	e9 04 01 00 00       	jmp    8d7b <__constant_c_and_count_memset+0x12a>
		case 1:
			*(unsigned char *)s = pattern;
    8c77:	8b 45 08             	mov    0x8(%ebp),%eax
    8c7a:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
    8c7e:	88 10                	mov    %dl,(%eax)
			return s;
    8c80:	8b 45 08             	mov    0x8(%ebp),%eax
    8c83:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    8c86:	e9 f0 00 00 00       	jmp    8d7b <__constant_c_and_count_memset+0x12a>
		case 2:
			*(unsigned short *)s = pattern;
    8c8b:	8b 45 08             	mov    0x8(%ebp),%eax
    8c8e:	8b 55 0c             	mov    0xc(%ebp),%edx
    8c91:	66 89 10             	mov    %dx,(%eax)
			return s;
    8c94:	8b 45 08             	mov    0x8(%ebp),%eax
    8c97:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    8c9a:	e9 dc 00 00 00       	jmp    8d7b <__constant_c_and_count_memset+0x12a>
		case 3:
			*(unsigned short *)s = pattern;
    8c9f:	8b 55 08             	mov    0x8(%ebp),%edx
    8ca2:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ca5:	66 89 02             	mov    %ax,(%edx)
			*(2+(unsigned char *)s) = pattern;
    8ca8:	8b 55 08             	mov    0x8(%ebp),%edx
    8cab:	83 c2 02             	add    $0x2,%edx
    8cae:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    8cb2:	88 02                	mov    %al,(%edx)
			return s;
    8cb4:	8b 45 08             	mov    0x8(%ebp),%eax
    8cb7:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    8cba:	e9 bc 00 00 00       	jmp    8d7b <__constant_c_and_count_memset+0x12a>
		case 4:
			*(unsigned long *)s = pattern;
    8cbf:	8b 45 08             	mov    0x8(%ebp),%eax
    8cc2:	8b 55 0c             	mov    0xc(%ebp),%edx
    8cc5:	89 10                	mov    %edx,(%eax)
			return s;
    8cc7:	8b 45 08             	mov    0x8(%ebp),%eax
    8cca:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    8ccd:	e9 a9 00 00 00       	jmp    8d7b <__constant_c_and_count_memset+0x12a>
	}
#define COMMON(x) \
__asm__  __volatile__( \
	"rep ; stosl" \
	x \
	: "=&c" (d0), "=&D" (d1) \
	: "a" (pattern),"0" (count/4),"1" ((long) s) \
	: "memory")
{
	int d0, d1;
	switch (count % 4) {
    8cd2:	8b 45 10             	mov    0x10(%ebp),%eax
    8cd5:	83 e0 03             	and    $0x3,%eax
    8cd8:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    8cdb:	83 7d ec 01          	cmpl   $0x1,0xffffffec(%ebp)
    8cdf:	74 30                	je     8d11 <__constant_c_and_count_memset+0xc0>
    8ce1:	83 7d ec 01          	cmpl   $0x1,0xffffffec(%ebp)
    8ce5:	72 08                	jb     8cef <__constant_c_and_count_memset+0x9e>
    8ce7:	83 7d ec 02          	cmpl   $0x2,0xffffffec(%ebp)
    8ceb:	74 47                	je     8d34 <__constant_c_and_count_memset+0xe3>
    8ced:	eb 69                	jmp    8d58 <__constant_c_and_count_memset+0x107>
		case 0: COMMON(""); return s;
    8cef:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cf2:	8b 55 10             	mov    0x10(%ebp),%edx
    8cf5:	89 d1                	mov    %edx,%ecx
    8cf7:	c1 e9 02             	shr    $0x2,%ecx
    8cfa:	8b 7d 08             	mov    0x8(%ebp),%edi
    8cfd:	f3 ab                	repz stos %eax,%es:(%edi)
    8cff:	89 c8                	mov    %ecx,%eax
    8d01:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    8d04:	89 f8                	mov    %edi,%eax
    8d06:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    8d09:	8b 45 08             	mov    0x8(%ebp),%eax
    8d0c:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    8d0f:	eb 6a                	jmp    8d7b <__constant_c_and_count_memset+0x12a>
		case 1: COMMON("\n\tstosb"); return s;
    8d11:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d14:	8b 55 10             	mov    0x10(%ebp),%edx
    8d17:	89 d1                	mov    %edx,%ecx
    8d19:	c1 e9 02             	shr    $0x2,%ecx
    8d1c:	8b 7d 08             	mov    0x8(%ebp),%edi
    8d1f:	f3 ab                	repz stos %eax,%es:(%edi)
    8d21:	aa                   	stos   %al,%es:(%edi)
    8d22:	89 c8                	mov    %ecx,%eax
    8d24:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    8d27:	89 f8                	mov    %edi,%eax
    8d29:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    8d2c:	8b 45 08             	mov    0x8(%ebp),%eax
    8d2f:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    8d32:	eb 47                	jmp    8d7b <__constant_c_and_count_memset+0x12a>
		case 2: COMMON("\n\tstosw"); return s;
    8d34:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d37:	8b 55 10             	mov    0x10(%ebp),%edx
    8d3a:	89 d1                	mov    %edx,%ecx
    8d3c:	c1 e9 02             	shr    $0x2,%ecx
    8d3f:	8b 7d 08             	mov    0x8(%ebp),%edi
    8d42:	f3 ab                	repz stos %eax,%es:(%edi)
    8d44:	66 ab                	stos   %ax,%es:(%edi)
    8d46:	89 c8                	mov    %ecx,%eax
    8d48:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    8d4b:	89 f8                	mov    %edi,%eax
    8d4d:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    8d50:	8b 45 08             	mov    0x8(%ebp),%eax
    8d53:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    8d56:	eb 23                	jmp    8d7b <__constant_c_and_count_memset+0x12a>
		default: COMMON("\n\tstosw\n\tstosb"); return s;
    8d58:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d5b:	8b 55 10             	mov    0x10(%ebp),%edx
    8d5e:	89 d1                	mov    %edx,%ecx
    8d60:	c1 e9 02             	shr    $0x2,%ecx
    8d63:	8b 7d 08             	mov    0x8(%ebp),%edi
    8d66:	f3 ab                	repz stos %eax,%es:(%edi)
    8d68:	66 ab                	stos   %ax,%es:(%edi)
    8d6a:	aa                   	stos   %al,%es:(%edi)
    8d6b:	89 c8                	mov    %ecx,%eax
    8d6d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    8d70:	89 f8                	mov    %edi,%eax
    8d72:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    8d75:	8b 45 08             	mov    0x8(%ebp),%eax
    8d78:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	}
}
  
#undef COMMON
}
    8d7b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    8d7e:	83 c4 10             	add    $0x10,%esp
    8d81:	5f                   	pop    %edi
    8d82:	5d                   	pop    %ebp
    8d83:	c3                   	ret    

00008d84 <timer_pending>:
	timer->list.next = timer->list.prev = NULL;
}

static inline int timer_pending (const struct timer_list * timer)
{
    8d84:	55                   	push   %ebp
    8d85:	89 e5                	mov    %esp,%ebp
	return timer->list.next != NULL;
    8d87:	8b 45 08             	mov    0x8(%ebp),%eax
    8d8a:	83 38 00             	cmpl   $0x0,(%eax)
    8d8d:	0f 95 c0             	setne  %al
    8d90:	0f b6 c0             	movzbl %al,%eax
}
    8d93:	5d                   	pop    %ebp
    8d94:	c3                   	ret    

00008d95 <kfree_skb>:
 *	hit zero.
 */
 
static inline void kfree_skb(struct sk_buff *skb)
{
    8d95:	55                   	push   %ebp
    8d96:	89 e5                	mov    %esp,%ebp
    8d98:	83 ec 04             	sub    $0x4,%esp
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
    8d9b:	8b 45 08             	mov    0x8(%ebp),%eax
    8d9e:	05 a8 00 00 00       	add    $0xa8,%eax
    8da3:	8b 00                	mov    (%eax),%eax
    8da5:	83 f8 01             	cmp    $0x1,%eax
    8da8:	74 16                	je     8dc0 <kfree_skb+0x2b>
    8daa:	8b 45 08             	mov    0x8(%ebp),%eax
    8dad:	05 a8 00 00 00       	add    $0xa8,%eax
    8db2:	89 04 24             	mov    %eax,(%esp,1)
    8db5:	e8 3a fe ff ff       	call   8bf4 <atomic_dec_and_test>
    8dba:	85 c0                	test   %eax,%eax
    8dbc:	75 02                	jne    8dc0 <kfree_skb+0x2b>
    8dbe:	eb 0b                	jmp    8dcb <kfree_skb+0x36>
		__kfree_skb(skb);
    8dc0:	8b 45 08             	mov    0x8(%ebp),%eax
    8dc3:	89 04 24             	mov    %eax,(%esp,1)
    8dc6:	e8 fc ff ff ff       	call   8dc7 <kfree_skb+0x32>
}
    8dcb:	c9                   	leave  
    8dcc:	c3                   	ret    

00008dcd <skb_peek>:

/* Use this if you didn't touch the skb state [for fast switching] */
static inline void kfree_skb_fast(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
		kfree_skbmem(skb);	
}

/**
 *	skb_cloned - is the buffer a clone
 *	@skb: buffer to check
 *
 *	Returns true if the buffer was generated with skb_clone() and is
 *	one of multiple shared copies of the buffer. Cloned buffers are
 *	shared data so must not be written to under normal circumstances.
 */

static inline int skb_cloned(struct sk_buff *skb)
{
	return skb->cloned && atomic_read(&skb_shinfo(skb)->dataref) != 1;
}

/**
 *	skb_shared - is the buffer shared
 *	@skb: buffer to check
 *
 *	Returns true if more than one person has a reference to this
 *	buffer.
 */
 
static inline int skb_shared(struct sk_buff *skb)
{
	return (atomic_read(&skb->users) != 1);
}

/** 
 *	skb_share_check - check if buffer is shared and if so clone it
 *	@skb: buffer to check
 *	@pri: priority for memory allocation
 *	
 *	If the buffer is shared the buffer is cloned and the old copy
 *	drops a reference. A new clone with a single reference is returned.
 *	If the buffer is not shared the original buffer is returned. When
 *	being called from interrupt status or with spinlocks held pri must
 *	be GFP_ATOMIC.
 *
 *	NULL is returned on a memory allocation failure.
 */
 
static inline struct sk_buff *skb_share_check(struct sk_buff *skb, int pri)
{
	if (skb_shared(skb)) {
		struct sk_buff *nskb;
		nskb = skb_clone(skb, pri);
		kfree_skb(skb);
		return nskb;
	}
	return skb;
}


/*
 *	Copy shared buffers into a new sk_buff. We effectively do COW on
 *	packets to handle cases where we have a local reader and forward
 *	and a couple of other messy ones. The normal one is tcpdumping
 *	a packet thats being forwarded.
 */
 
/**
 *	skb_unshare - make a copy of a shared buffer
 *	@skb: buffer to check
 *	@pri: priority for memory allocation
 *
 *	If the socket buffer is a clone then this function creates a new
 *	copy of the data, drops a reference count on the old copy and returns
 *	the new copy with the reference count at 1. If the buffer is not a clone
 *	the original buffer is returned. When called with a spinlock held or
 *	from interrupt state @pri must be %GFP_ATOMIC
 *
 *	%NULL is returned on a memory allocation failure.
 */
 
static inline struct sk_buff *skb_unshare(struct sk_buff *skb, int pri)
{
	struct sk_buff *nskb;
	if(!skb_cloned(skb))
		return skb;
	nskb=skb_copy(skb, pri);
	kfree_skb(skb);		/* Free our shared copy */
	return nskb;
}

/**
 *	skb_peek
 *	@list_: list to peek at
 *
 *	Peek an &sk_buff. Unlike most other operations you _MUST_
 *	be careful with this one. A peek leaves the buffer on the
 *	list and someone else may run off with it. You must hold
 *	the appropriate locks or have a private queue to do this.
 *
 *	Returns %NULL for an empty list or a pointer to the head element.
 *	The reference count is not incremented and the reference is therefore
 *	volatile. Use with caution.
 */
 
static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
{
    8dcd:	55                   	push   %ebp
    8dce:	89 e5                	mov    %esp,%ebp
    8dd0:	83 ec 04             	sub    $0x4,%esp
	struct sk_buff *list = ((struct sk_buff *)list_)->next;
    8dd3:	8b 45 08             	mov    0x8(%ebp),%eax
    8dd6:	8b 00                	mov    (%eax),%eax
    8dd8:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	if (list == (struct sk_buff *)list_)
    8ddb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    8dde:	3b 45 08             	cmp    0x8(%ebp),%eax
    8de1:	75 07                	jne    8dea <skb_peek+0x1d>
		list = NULL;
    8de3:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
	return list;
    8dea:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
    8ded:	c9                   	leave  
    8dee:	c3                   	ret    

00008def <__skb_queue_head>:

/**
 *	skb_peek_tail
 *	@list_: list to peek at
 *
 *	Peek an &sk_buff. Unlike most other operations you _MUST_
 *	be careful with this one. A peek leaves the buffer on the
 *	list and someone else may run off with it. You must hold
 *	the appropriate locks or have a private queue to do this.
 *
 *	Returns %NULL for an empty list or a pointer to the tail element.
 *	The reference count is not incremented and the reference is therefore
 *	volatile. Use with caution.
 */

static inline struct sk_buff *skb_peek_tail(struct sk_buff_head *list_)
{
	struct sk_buff *list = ((struct sk_buff *)list_)->prev;
	if (list == (struct sk_buff *)list_)
		list = NULL;
	return list;
}

/**
 *	skb_queue_len	- get queue length
 *	@list_: list to measure
 *
 *	Return the length of an &sk_buff queue. 
 */
 
static inline __u32 skb_queue_len(struct sk_buff_head *list_)
{
	return(list_->qlen);
}

static inline void skb_queue_head_init(struct sk_buff_head *list)
{
	spin_lock_init(&list->lock);
	list->prev = (struct sk_buff *)list;
	list->next = (struct sk_buff *)list;
	list->qlen = 0;
}

/*
 *	Insert an sk_buff at the start of a list.
 *
 *	The "__skb_xxxx()" functions are the non-atomic ones that
 *	can only be called with interrupts disabled.
 */

/**
 *	__skb_queue_head - queue a buffer at the list head
 *	@list: list to use
 *	@newsk: buffer to queue
 *
 *	Queue a buffer at the start of a list. This function takes no locks
 *	and you must therefore hold required locks before calling it.
 *
 *	A buffer cannot be placed on two lists at the same time.
 */	
 
static inline void __skb_queue_head(struct sk_buff_head *list, struct sk_buff *newsk)
{
    8def:	55                   	push   %ebp
    8df0:	89 e5                	mov    %esp,%ebp
    8df2:	83 ec 08             	sub    $0x8,%esp
	struct sk_buff *prev, *next;

	newsk->list = list;
    8df5:	8b 55 0c             	mov    0xc(%ebp),%edx
    8df8:	8b 45 08             	mov    0x8(%ebp),%eax
    8dfb:	89 42 08             	mov    %eax,0x8(%edx)
	list->qlen++;
    8dfe:	8b 45 08             	mov    0x8(%ebp),%eax
    8e01:	ff 40 08             	incl   0x8(%eax)
	prev = (struct sk_buff *)list;
    8e04:	8b 45 08             	mov    0x8(%ebp),%eax
    8e07:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	next = prev->next;
    8e0a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    8e0d:	8b 00                	mov    (%eax),%eax
    8e0f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	newsk->next = next;
    8e12:	8b 55 0c             	mov    0xc(%ebp),%edx
    8e15:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    8e18:	89 02                	mov    %eax,(%edx)
	newsk->prev = prev;
    8e1a:	8b 55 0c             	mov    0xc(%ebp),%edx
    8e1d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    8e20:	89 42 04             	mov    %eax,0x4(%edx)
	next->prev = newsk;
    8e23:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    8e26:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e29:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = newsk;
    8e2c:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    8e2f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e32:	89 02                	mov    %eax,(%edx)
}
    8e34:	c9                   	leave  
    8e35:	c3                   	ret    

00008e36 <__skb_queue_tail>:


/**
 *	skb_queue_head - queue a buffer at the list head
 *	@list: list to use
 *	@newsk: buffer to queue
 *
 *	Queue a buffer at the start of the list. This function takes the
 *	list lock and can be used safely with other locking &sk_buff functions
 *	safely.
 *
 *	A buffer cannot be placed on two lists at the same time.
 */	

static inline void skb_queue_head(struct sk_buff_head *list, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&list->lock, flags);
	__skb_queue_head(list, newsk);
	spin_unlock_irqrestore(&list->lock, flags);
}

/**
 *	__skb_queue_tail - queue a buffer at the list tail
 *	@list: list to use
 *	@newsk: buffer to queue
 *
 *	Queue a buffer at the end of a list. This function takes no locks
 *	and you must therefore hold required locks before calling it.
 *
 *	A buffer cannot be placed on two lists at the same time.
 */	
 

static inline void __skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
    8e36:	55                   	push   %ebp
    8e37:	89 e5                	mov    %esp,%ebp
    8e39:	83 ec 08             	sub    $0x8,%esp
	struct sk_buff *prev, *next;

	newsk->list = list;
    8e3c:	8b 55 0c             	mov    0xc(%ebp),%edx
    8e3f:	8b 45 08             	mov    0x8(%ebp),%eax
    8e42:	89 42 08             	mov    %eax,0x8(%edx)
	list->qlen++;
    8e45:	8b 45 08             	mov    0x8(%ebp),%eax
    8e48:	ff 40 08             	incl   0x8(%eax)
	next = (struct sk_buff *)list;
    8e4b:	8b 45 08             	mov    0x8(%ebp),%eax
    8e4e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	prev = next->prev;
    8e51:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    8e54:	8b 40 04             	mov    0x4(%eax),%eax
    8e57:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	newsk->next = next;
    8e5a:	8b 55 0c             	mov    0xc(%ebp),%edx
    8e5d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    8e60:	89 02                	mov    %eax,(%edx)
	newsk->prev = prev;
    8e62:	8b 55 0c             	mov    0xc(%ebp),%edx
    8e65:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    8e68:	89 42 04             	mov    %eax,0x4(%edx)
	next->prev = newsk;
    8e6b:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    8e6e:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e71:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = newsk;
    8e74:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    8e77:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e7a:	89 02                	mov    %eax,(%edx)
}
    8e7c:	c9                   	leave  
    8e7d:	c3                   	ret    

00008e7e <__skb_dequeue>:

/**
 *	skb_queue_tail - queue a buffer at the list tail
 *	@list: list to use
 *	@newsk: buffer to queue
 *
 *	Queue a buffer at the tail of the list. This function takes the
 *	list lock and can be used safely with other locking &sk_buff functions
 *	safely.
 *
 *	A buffer cannot be placed on two lists at the same time.
 */	

static inline void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&list->lock, flags);
	__skb_queue_tail(list, newsk);
	spin_unlock_irqrestore(&list->lock, flags);
}

/**
 *	__skb_dequeue - remove from the head of the queue
 *	@list: list to dequeue from
 *
 *	Remove the head of the list. This function does not take any locks
 *	so must be used with appropriate locks held only. The head item is
 *	returned or %NULL if the list is empty.
 */

static inline struct sk_buff *__skb_dequeue(struct sk_buff_head *list)
{
    8e7e:	55                   	push   %ebp
    8e7f:	89 e5                	mov    %esp,%ebp
    8e81:	83 ec 0c             	sub    $0xc,%esp
	struct sk_buff *next, *prev, *result;

	prev = (struct sk_buff *) list;
    8e84:	8b 45 08             	mov    0x8(%ebp),%eax
    8e87:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	next = prev->next;
    8e8a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    8e8d:	8b 00                	mov    (%eax),%eax
    8e8f:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	result = NULL;
    8e92:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
	if (next != prev) {
    8e99:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    8e9c:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
    8e9f:	74 42                	je     8ee3 <__skb_dequeue+0x65>
		result = next;
    8ea1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    8ea4:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		next = next->next;
    8ea7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    8eaa:	8b 00                	mov    (%eax),%eax
    8eac:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
		list->qlen--;
    8eaf:	8b 45 08             	mov    0x8(%ebp),%eax
    8eb2:	ff 48 08             	decl   0x8(%eax)
		next->prev = prev;
    8eb5:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    8eb8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    8ebb:	89 42 04             	mov    %eax,0x4(%edx)
		prev->next = next;
    8ebe:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    8ec1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    8ec4:	89 02                	mov    %eax,(%edx)
		result->next = NULL;
    8ec6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    8ec9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		result->prev = NULL;
    8ecf:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    8ed2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		result->list = NULL;
    8ed9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    8edc:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	}
	return result;
    8ee3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
}
    8ee6:	c9                   	leave  
    8ee7:	c3                   	ret    

00008ee8 <__skb_insert>:

/**
 *	skb_dequeue - remove from the head of the queue
 *	@list: list to dequeue from
 *
 *	Remove the head of the list. The list lock is taken so the function
 *	may be used safely with other locking list functions. The head item is
 *	returned or %NULL if the list is empty.
 */

static inline struct sk_buff *skb_dequeue(struct sk_buff_head *list)
{
	unsigned long flags;
	struct sk_buff *result;

	spin_lock_irqsave(&list->lock, flags);
	result = __skb_dequeue(list);
	spin_unlock_irqrestore(&list->lock, flags);
	return result;
}

/*
 *	Insert a packet on a list.
 */

static inline void __skb_insert(struct sk_buff *newsk,
	struct sk_buff * prev, struct sk_buff *next,
	struct sk_buff_head * list)
{
    8ee8:	55                   	push   %ebp
    8ee9:	89 e5                	mov    %esp,%ebp
	newsk->next = next;
    8eeb:	8b 55 08             	mov    0x8(%ebp),%edx
    8eee:	8b 45 10             	mov    0x10(%ebp),%eax
    8ef1:	89 02                	mov    %eax,(%edx)
	newsk->prev = prev;
    8ef3:	8b 55 08             	mov    0x8(%ebp),%edx
    8ef6:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ef9:	89 42 04             	mov    %eax,0x4(%edx)
	next->prev = newsk;
    8efc:	8b 55 10             	mov    0x10(%ebp),%edx
    8eff:	8b 45 08             	mov    0x8(%ebp),%eax
    8f02:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = newsk;
    8f05:	8b 55 0c             	mov    0xc(%ebp),%edx
    8f08:	8b 45 08             	mov    0x8(%ebp),%eax
    8f0b:	89 02                	mov    %eax,(%edx)
	newsk->list = list;
    8f0d:	8b 55 08             	mov    0x8(%ebp),%edx
    8f10:	8b 45 14             	mov    0x14(%ebp),%eax
    8f13:	89 42 08             	mov    %eax,0x8(%edx)
	list->qlen++;
    8f16:	8b 45 14             	mov    0x14(%ebp),%eax
    8f19:	ff 40 08             	incl   0x8(%eax)
}
    8f1c:	5d                   	pop    %ebp
    8f1d:	c3                   	ret    

00008f1e <__skb_unlink>:

/**
 *	skb_insert	-	insert a buffer
 *	@old: buffer to insert before
 *	@newsk: buffer to insert
 *
 *	Place a packet before a given packet in a list. The list locks are taken
 *	and this function is atomic with respect to other list locked calls
 *	A buffer cannot be placed on two lists at the same time.
 */

static inline void skb_insert(struct sk_buff *old, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&old->list->lock, flags);
	__skb_insert(newsk, old->prev, old, old->list);
	spin_unlock_irqrestore(&old->list->lock, flags);
}

/*
 *	Place a packet after a given packet in a list.
 */

static inline void __skb_append(struct sk_buff *old, struct sk_buff *newsk)
{
	__skb_insert(newsk, old, old->next, old->list);
}

/**
 *	skb_append	-	append a buffer
 *	@old: buffer to insert after
 *	@newsk: buffer to insert
 *
 *	Place a packet after a given packet in a list. The list locks are taken
 *	and this function is atomic with respect to other list locked calls.
 *	A buffer cannot be placed on two lists at the same time.
 */


static inline void skb_append(struct sk_buff *old, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&old->list->lock, flags);
	__skb_append(old, newsk);
	spin_unlock_irqrestore(&old->list->lock, flags);
}

/*
 * remove sk_buff from list. _Must_ be called atomically, and with
 * the list known..
 */
 
static inline void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
{
    8f1e:	55                   	push   %ebp
    8f1f:	89 e5                	mov    %esp,%ebp
    8f21:	83 ec 08             	sub    $0x8,%esp
	struct sk_buff * next, * prev;

	list->qlen--;
    8f24:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f27:	ff 48 08             	decl   0x8(%eax)
	next = skb->next;
    8f2a:	8b 45 08             	mov    0x8(%ebp),%eax
    8f2d:	8b 00                	mov    (%eax),%eax
    8f2f:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	prev = skb->prev;
    8f32:	8b 45 08             	mov    0x8(%ebp),%eax
    8f35:	8b 40 04             	mov    0x4(%eax),%eax
    8f38:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	skb->next = NULL;
    8f3b:	8b 45 08             	mov    0x8(%ebp),%eax
    8f3e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	skb->prev = NULL;
    8f44:	8b 45 08             	mov    0x8(%ebp),%eax
    8f47:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	skb->list = NULL;
    8f4e:	8b 45 08             	mov    0x8(%ebp),%eax
    8f51:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	next->prev = prev;
    8f58:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    8f5b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    8f5e:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    8f61:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    8f64:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    8f67:	89 02                	mov    %eax,(%edx)
}
    8f69:	c9                   	leave  
    8f6a:	c3                   	ret    

00008f6b <skb_put>:

/**
 *	skb_unlink	-	remove a buffer from a list
 *	@skb: buffer to remove
 *
 *	Place a packet after a given packet in a list. The list locks are taken
 *	and this function is atomic with respect to other list locked calls
 *	
 *	Works even without knowing the list it is sitting on, which can be 
 *	handy at times. It also means that THE LIST MUST EXIST when you 
 *	unlink. Thus a list must have its contents unlinked before it is
 *	destroyed.
 */

static inline void skb_unlink(struct sk_buff *skb)
{
	struct sk_buff_head *list = skb->list;

	if(list) {
		unsigned long flags;

		spin_lock_irqsave(&list->lock, flags);
		if(skb->list == list)
			__skb_unlink(skb, skb->list);
		spin_unlock_irqrestore(&list->lock, flags);
	}
}

/* XXX: more streamlined implementation */

/**
 *	__skb_dequeue_tail - remove from the tail of the queue
 *	@list: list to dequeue from
 *
 *	Remove the tail of the list. This function does not take any locks
 *	so must be used with appropriate locks held only. The tail item is
 *	returned or %NULL if the list is empty.
 */

static inline struct sk_buff *__skb_dequeue_tail(struct sk_buff_head *list)
{
	struct sk_buff *skb = skb_peek_tail(list); 
	if (skb)
		__skb_unlink(skb, list);
	return skb;
}

/**
 *	skb_dequeue - remove from the head of the queue
 *	@list: list to dequeue from
 *
 *	Remove the head of the list. The list lock is taken so the function
 *	may be used safely with other locking list functions. The tail item is
 *	returned or %NULL if the list is empty.
 */

static inline struct sk_buff *skb_dequeue_tail(struct sk_buff_head *list)
{
	unsigned long flags;
	struct sk_buff *result;

	spin_lock_irqsave(&list->lock, flags);
	result = __skb_dequeue_tail(list);
	spin_unlock_irqrestore(&list->lock, flags);
	return result;
}

static inline int skb_is_nonlinear(const struct sk_buff *skb)
{
	return skb->data_len;
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
	return skb->len - skb->data_len;
}

#define SKB_PAGE_ASSERT(skb) do { if (skb_shinfo(skb)->nr_frags) out_of_line_bug(); } while (0)
#define SKB_FRAG_ASSERT(skb) do { if (skb_shinfo(skb)->frag_list) out_of_line_bug(); } while (0)
#define SKB_LINEAR_ASSERT(skb) do { if (skb_is_nonlinear(skb)) out_of_line_bug(); } while (0)

/*
 *	Add data to an sk_buff
 */
 
static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	return tmp;
}

/**
 *	skb_put - add data to a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer. If this would
 *	exceed the total buffer size the kernel will panic. A pointer to the
 *	first byte of the extra data is returned.
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
    8f6b:	55                   	push   %ebp
    8f6c:	89 e5                	mov    %esp,%ebp
    8f6e:	83 ec 14             	sub    $0x14,%esp
	unsigned char *tmp=skb->tail;
    8f71:	8b 45 08             	mov    0x8(%ebp),%eax
    8f74:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
    8f7a:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	SKB_LINEAR_ASSERT(skb);
    8f7d:	8b 45 08             	mov    0x8(%ebp),%eax
    8f80:	89 04 24             	mov    %eax,(%esp,1)
    8f83:	e8 9a 31 00 00       	call   c122 <skb_is_nonlinear>
    8f88:	85 c0                	test   %eax,%eax
    8f8a:	74 0c                	je     8f98 <skb_put+0x2d>
    8f8c:	c7 04 24 24 03 00 00 	movl   $0x324,(%esp,1)
    8f93:	e8 fc ff ff ff       	call   8f94 <skb_put+0x29>
	skb->tail+=len;
    8f98:	8b 4d 08             	mov    0x8(%ebp),%ecx
    8f9b:	8b 55 08             	mov    0x8(%ebp),%edx
    8f9e:	8b 45 0c             	mov    0xc(%ebp),%eax
    8fa1:	03 82 bc 00 00 00    	add    0xbc(%edx),%eax
    8fa7:	89 81 bc 00 00 00    	mov    %eax,0xbc(%ecx)
	skb->len+=len;
    8fad:	8b 4d 08             	mov    0x8(%ebp),%ecx
    8fb0:	8b 55 08             	mov    0x8(%ebp),%edx
    8fb3:	8b 45 0c             	mov    0xc(%ebp),%eax
    8fb6:	03 82 94 00 00 00    	add    0x94(%edx),%eax
    8fbc:	89 81 94 00 00 00    	mov    %eax,0x94(%ecx)
	if(skb->tail>skb->end) {
    8fc2:	8b 45 08             	mov    0x8(%ebp),%eax
    8fc5:	8b 55 08             	mov    0x8(%ebp),%edx
    8fc8:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
    8fce:	3b 82 c0 00 00 00    	cmp    0xc0(%edx),%eax
    8fd4:	76 20                	jbe    8ff6 <skb_put+0x8b>
		skb_over_panic(skb, len, current_text_addr());
    8fd6:	c7 45 f8 dd 8f 00 00 	movl   $0x8fdd,0xfffffff8(%ebp)
    8fdd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    8fe0:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    8fe4:	8b 45 0c             	mov    0xc(%ebp),%eax
    8fe7:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    8feb:	8b 45 08             	mov    0x8(%ebp),%eax
    8fee:	89 04 24             	mov    %eax,(%esp,1)
    8ff1:	e8 fc ff ff ff       	call   8ff2 <skb_put+0x87>
	}
	return tmp;
    8ff6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
    8ff9:	c9                   	leave  
    8ffa:	c3                   	ret    

00008ffb <skb_push>:

static inline unsigned char *__skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
	skb->len+=len;
	return skb->data;
}

/**
 *	skb_push - add data to the start of a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer at the buffer
 *	start. If this would exceed the total buffer headroom the kernel will
 *	panic. A pointer to the first byte of the extra data is returned.
 */

static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
{
    8ffb:	55                   	push   %ebp
    8ffc:	89 e5                	mov    %esp,%ebp
    8ffe:	83 ec 10             	sub    $0x10,%esp
	skb->data-=len;
    9001:	8b 4d 08             	mov    0x8(%ebp),%ecx
    9004:	8b 45 08             	mov    0x8(%ebp),%eax
    9007:	8b 55 0c             	mov    0xc(%ebp),%edx
    900a:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
    9010:	29 d0                	sub    %edx,%eax
    9012:	89 81 b8 00 00 00    	mov    %eax,0xb8(%ecx)
	skb->len+=len;
    9018:	8b 4d 08             	mov    0x8(%ebp),%ecx
    901b:	8b 55 08             	mov    0x8(%ebp),%edx
    901e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9021:	03 82 94 00 00 00    	add    0x94(%edx),%eax
    9027:	89 81 94 00 00 00    	mov    %eax,0x94(%ecx)
	if(skb->data<skb->head) {
    902d:	8b 45 08             	mov    0x8(%ebp),%eax
    9030:	8b 55 08             	mov    0x8(%ebp),%edx
    9033:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
    9039:	3b 82 b4 00 00 00    	cmp    0xb4(%edx),%eax
    903f:	73 20                	jae    9061 <skb_push+0x66>
		skb_under_panic(skb, len, current_text_addr());
    9041:	c7 45 fc 48 90 00 00 	movl   $0x9048,0xfffffffc(%ebp)
    9048:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    904b:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    904f:	8b 45 0c             	mov    0xc(%ebp),%eax
    9052:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    9056:	8b 45 08             	mov    0x8(%ebp),%eax
    9059:	89 04 24             	mov    %eax,(%esp,1)
    905c:	e8 fc ff ff ff       	call   905d <skb_push+0x62>
	}
	return skb->data;
    9061:	8b 45 08             	mov    0x8(%ebp),%eax
    9064:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
}
    906a:	c9                   	leave  
    906b:	c3                   	ret    

0000906c <__skb_pull>:

static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
    906c:	55                   	push   %ebp
    906d:	89 e5                	mov    %esp,%ebp
    906f:	83 ec 04             	sub    $0x4,%esp
	skb->len-=len;
    9072:	8b 4d 08             	mov    0x8(%ebp),%ecx
    9075:	8b 45 08             	mov    0x8(%ebp),%eax
    9078:	8b 55 0c             	mov    0xc(%ebp),%edx
    907b:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    9081:	29 d0                	sub    %edx,%eax
    9083:	89 81 94 00 00 00    	mov    %eax,0x94(%ecx)
	if (skb->len < skb->data_len)
    9089:	8b 45 08             	mov    0x8(%ebp),%eax
    908c:	8b 55 08             	mov    0x8(%ebp),%edx
    908f:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    9095:	3b 82 98 00 00 00    	cmp    0x98(%edx),%eax
    909b:	73 0c                	jae    90a9 <__skb_pull+0x3d>
		out_of_line_bug();
    909d:	c7 04 24 4c 03 00 00 	movl   $0x34c,(%esp,1)
    90a4:	e8 fc ff ff ff       	call   90a5 <__skb_pull+0x39>
	return 	skb->data+=len;
    90a9:	8b 4d 08             	mov    0x8(%ebp),%ecx
    90ac:	8b 55 08             	mov    0x8(%ebp),%edx
    90af:	8b 45 0c             	mov    0xc(%ebp),%eax
    90b2:	03 82 b8 00 00 00    	add    0xb8(%edx),%eax
    90b8:	89 81 b8 00 00 00    	mov    %eax,0xb8(%ecx)
    90be:	8b 81 b8 00 00 00    	mov    0xb8(%ecx),%eax
}
    90c4:	c9                   	leave  
    90c5:	c3                   	ret    

000090c6 <skb_pull>:

/**
 *	skb_pull - remove data from the start of a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to remove
 *
 *	This function removes data from the start of a buffer, returning
 *	the memory to the headroom. A pointer to the next data in the buffer
 *	is returned. Once the data has been pulled future pushes will overwrite
 *	the old data.
 */

static inline unsigned char * skb_pull(struct sk_buff *skb, unsigned int len)
{	
    90c6:	55                   	push   %ebp
    90c7:	89 e5                	mov    %esp,%ebp
    90c9:	83 ec 0c             	sub    $0xc,%esp
	if (len > skb->len)
    90cc:	8b 55 08             	mov    0x8(%ebp),%edx
    90cf:	8b 45 0c             	mov    0xc(%ebp),%eax
    90d2:	3b 82 94 00 00 00    	cmp    0x94(%edx),%eax
    90d8:	76 09                	jbe    90e3 <skb_pull+0x1d>
		return NULL;
    90da:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
    90e1:	eb 15                	jmp    90f8 <skb_pull+0x32>
	return __skb_pull(skb,len);
    90e3:	8b 45 0c             	mov    0xc(%ebp),%eax
    90e6:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    90ea:	8b 45 08             	mov    0x8(%ebp),%eax
    90ed:	89 04 24             	mov    %eax,(%esp,1)
    90f0:	e8 77 ff ff ff       	call   906c <__skb_pull>
    90f5:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
}
    90f8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    90fb:	c9                   	leave  
    90fc:	c3                   	ret    

000090fd <pskb_may_pull>:

extern unsigned char * __pskb_pull_tail(struct sk_buff *skb, int delta);

static inline char *__pskb_pull(struct sk_buff *skb, unsigned int len)
{
	if (len > skb_headlen(skb) &&
	    __pskb_pull_tail(skb, len-skb_headlen(skb)) == NULL)
		return NULL;
	skb->len -= len;
	return 	skb->data += len;
}

static inline unsigned char * pskb_pull(struct sk_buff *skb, unsigned int len)
{	
	if (len > skb->len)
		return NULL;
	return __pskb_pull(skb,len);
}

static inline int pskb_may_pull(struct sk_buff *skb, unsigned int len)
{
    90fd:	55                   	push   %ebp
    90fe:	89 e5                	mov    %esp,%ebp
    9100:	83 ec 10             	sub    $0x10,%esp
	if (len <= skb_headlen(skb))
    9103:	8b 45 08             	mov    0x8(%ebp),%eax
    9106:	89 04 24             	mov    %eax,(%esp,1)
    9109:	e8 22 30 00 00       	call   c130 <skb_headlen>
    910e:	39 45 0c             	cmp    %eax,0xc(%ebp)
    9111:	77 09                	ja     911c <pskb_may_pull+0x1f>
		return 1;
    9113:	c7 45 fc 01 00 00 00 	movl   $0x1,0xfffffffc(%ebp)
    911a:	eb 4e                	jmp    916a <pskb_may_pull+0x6d>
	if (len > skb->len)
    911c:	8b 55 08             	mov    0x8(%ebp),%edx
    911f:	8b 45 0c             	mov    0xc(%ebp),%eax
    9122:	3b 82 94 00 00 00    	cmp    0x94(%edx),%eax
    9128:	76 09                	jbe    9133 <pskb_may_pull+0x36>
		return 0;
    912a:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
    9131:	eb 37                	jmp    916a <pskb_may_pull+0x6d>
	return (__pskb_pull_tail(skb, len-skb_headlen(skb)) != NULL);
    9133:	8b 45 08             	mov    0x8(%ebp),%eax
    9136:	89 04 24             	mov    %eax,(%esp,1)
    9139:	e8 f2 2f 00 00       	call   c130 <skb_headlen>
    913e:	89 c2                	mov    %eax,%edx
    9140:	8b 45 0c             	mov    0xc(%ebp),%eax
    9143:	29 d0                	sub    %edx,%eax
    9145:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    9149:	8b 45 08             	mov    0x8(%ebp),%eax
    914c:	89 04 24             	mov    %eax,(%esp,1)
    914f:	e8 fc ff ff ff       	call   9150 <pskb_may_pull+0x53>
    9154:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    9157:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    915b:	0f 95 c0             	setne  %al
    915e:	0f b6 c0             	movzbl %al,%eax
    9161:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    9164:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9167:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
}
    916a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    916d:	c9                   	leave  
    916e:	c3                   	ret    

0000916f <skb_reserve>:

/**
 *	skb_headroom - bytes at buffer head
 *	@skb: buffer to check
 *
 *	Return the number of bytes of free space at the head of an &sk_buff.
 */
 
static inline int skb_headroom(const struct sk_buff *skb)
{
	return skb->data-skb->head;
}

/**
 *	skb_tailroom - bytes at buffer end
 *	@skb: buffer to check
 *
 *	Return the number of bytes of free space at the tail of an sk_buff
 */

static inline int skb_tailroom(const struct sk_buff *skb)
{
	return skb_is_nonlinear(skb) ? 0 : skb->end-skb->tail;
}

/**
 *	skb_reserve - adjust headroom
 *	@skb: buffer to alter
 *	@len: bytes to move
 *
 *	Increase the headroom of an empty &sk_buff by reducing the tail
 *	room. This is only allowed for an empty buffer.
 */

static inline void skb_reserve(struct sk_buff *skb, unsigned int len)
{
    916f:	55                   	push   %ebp
    9170:	89 e5                	mov    %esp,%ebp
	skb->data+=len;
    9172:	8b 4d 08             	mov    0x8(%ebp),%ecx
    9175:	8b 55 08             	mov    0x8(%ebp),%edx
    9178:	8b 45 0c             	mov    0xc(%ebp),%eax
    917b:	03 82 b8 00 00 00    	add    0xb8(%edx),%eax
    9181:	89 81 b8 00 00 00    	mov    %eax,0xb8(%ecx)
	skb->tail+=len;
    9187:	8b 4d 08             	mov    0x8(%ebp),%ecx
    918a:	8b 55 08             	mov    0x8(%ebp),%edx
    918d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9190:	03 82 bc 00 00 00    	add    0xbc(%edx),%eax
    9196:	89 81 bc 00 00 00    	mov    %eax,0xbc(%ecx)
}
    919c:	5d                   	pop    %ebp
    919d:	c3                   	ret    

0000919e <vector_free>:
	}
	return;
}

static inline void vector_free(struct vector *vec) {
    919e:	55                   	push   %ebp
    919f:	89 e5                	mov    %esp,%ebp
    91a1:	83 ec 04             	sub    $0x4,%esp
	kfree(vec->elems);
    91a4:	8b 45 08             	mov    0x8(%ebp),%eax
    91a7:	8b 40 08             	mov    0x8(%eax),%eax
    91aa:	89 04 24             	mov    %eax,(%esp,1)
    91ad:	e8 fc ff ff ff       	call   91ae <vector_free+0x10>
	kfree(vec);
    91b2:	8b 45 08             	mov    0x8(%ebp),%eax
    91b5:	89 04 24             	mov    %eax,(%esp,1)
    91b8:	e8 fc ff ff ff       	call   91b9 <vector_free+0x1b>
}
    91bd:	c9                   	leave  
    91be:	c3                   	ret    

000091bf <empty>:
static inline void vector_append(struct vector *vec, void *newElem) {
	if(vec->num == vec->size) {
		void **newElems;
		vec->size *= 2;
		newElems = kmalloc(vec->size * sizeof(newElems[0]), GFP_ATOMIC);
		if(newElems == NULL) {
			printk("Not enough memory while resizing vector\n");
			// TODO: Throw proper exception
			BUG();
			return;
		}
	}
	vec->elems[vec->num++] = newElem;
}

#endif // __KERNEL__

#ifdef __KERNEL__
#define VALID_MSK_CTL(X) ((X)->ctl == ALLOC_READY || \
                          (X)->ctl == ALLOC_HALFFREE)

static inline int empty(struct alloc_head_list *head) {
    91bf:	55                   	push   %ebp
    91c0:	89 e5                	mov    %esp,%ebp
	return head->next == (struct alloc_head*)head;
    91c2:	8b 45 08             	mov    0x8(%ebp),%eax
    91c5:	8b 40 04             	mov    0x4(%eax),%eax
    91c8:	3b 45 08             	cmp    0x8(%ebp),%eax
    91cb:	0f 94 c0             	sete   %al
    91ce:	0f b6 c0             	movzbl %al,%eax
}
    91d1:	5d                   	pop    %ebp
    91d2:	c3                   	ret    

000091d3 <init_head>:

static inline void init_head(struct alloc_head_list *head) {
    91d3:	55                   	push   %ebp
    91d4:	89 e5                	mov    %esp,%ebp
	head->next = head->prev = (struct alloc_head*)head;
    91d6:	8b 4d 08             	mov    0x8(%ebp),%ecx
    91d9:	8b 55 08             	mov    0x8(%ebp),%edx
    91dc:	8b 45 08             	mov    0x8(%ebp),%eax
    91df:	89 02                	mov    %eax,(%edx)
    91e1:	89 41 04             	mov    %eax,0x4(%ecx)
	head->list = head;
    91e4:	8b 55 08             	mov    0x8(%ebp),%edx
    91e7:	8b 45 08             	mov    0x8(%ebp),%eax
    91ea:	89 42 08             	mov    %eax,0x8(%edx)
	head->len = 0;
    91ed:	8b 45 08             	mov    0x8(%ebp),%eax
    91f0:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
}
    91f7:	5d                   	pop    %ebp
    91f8:	c3                   	ret    

000091f9 <insert_head>:

#if 0
static inline void unlink_head(struct alloc_head_list *head) {
	struct alloc_head *prev = head->prev;
	head->prev->next = head->next;
	head->next->prev = head->prev;
	head->next = head->prev = NULL;
	if(prev->next == prev && prev->prev != prev) {
		BUG();
		show_stack(NULL);
	}
	head->len--;
}
#endif

//#define DEBUG_LIST

static inline void insert_head(struct alloc_head_list *head, struct alloc_head *elem) {
    91f9:	55                   	push   %ebp
    91fa:	89 e5                	mov    %esp,%ebp
    91fc:	83 ec 08             	sub    $0x8,%esp
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
#endif
	if(head->next == elem /* || elem->prev != NULL || elem->next != NULL */) {
    91ff:	8b 45 08             	mov    0x8(%ebp),%eax
    9202:	8b 40 04             	mov    0x4(%eax),%eax
    9205:	3b 45 0c             	cmp    0xc(%ebp),%eax
    9208:	75 31                	jne    923b <insert_head+0x42>
		BUG();
    920a:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    9211:	00 
    9212:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    9219:	e8 fc ff ff ff       	call   921a <insert_head+0x21>
    921e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    9225:	e8 fc ff ff ff       	call   9226 <insert_head+0x2d>
    922a:	e8 fc ff ff ff       	call   922b <insert_head+0x32>
		show_stack(NULL);	
    922f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    9236:	e8 fc ff ff ff       	call   9237 <insert_head+0x3e>
	}
	elem->next = head->next;
    923b:	8b 55 0c             	mov    0xc(%ebp),%edx
    923e:	8b 45 08             	mov    0x8(%ebp),%eax
    9241:	8b 40 04             	mov    0x4(%eax),%eax
    9244:	89 42 04             	mov    %eax,0x4(%edx)
	head->next->prev = elem;
    9247:	8b 45 08             	mov    0x8(%ebp),%eax
    924a:	8b 50 04             	mov    0x4(%eax),%edx
    924d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9250:	89 02                	mov    %eax,(%edx)

	elem->prev = (struct alloc_head*)head;
    9252:	8b 55 0c             	mov    0xc(%ebp),%edx
    9255:	8b 45 08             	mov    0x8(%ebp),%eax
    9258:	89 02                	mov    %eax,(%edx)
	head->next = elem;
    925a:	8b 55 08             	mov    0x8(%ebp),%edx
    925d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9260:	89 42 04             	mov    %eax,0x4(%edx)

	elem->list = head;
    9263:	8b 55 0c             	mov    0xc(%ebp),%edx
    9266:	8b 45 08             	mov    0x8(%ebp),%eax
    9269:	89 42 08             	mov    %eax,0x8(%edx)
	head->len++;
    926c:	8b 45 08             	mov    0x8(%ebp),%eax
    926f:	ff 40 10             	incl   0x10(%eax)
}
    9272:	c9                   	leave  
    9273:	c3                   	ret    

00009274 <insert_tail>:

static inline void insert_tail(struct alloc_head_list *head, struct alloc_head *elem) {
    9274:	55                   	push   %ebp
    9275:	89 e5                	mov    %esp,%ebp
    9277:	83 ec 08             	sub    $0x8,%esp
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
    927a:	8b 45 08             	mov    0x8(%ebp),%eax
    927d:	8b 00                	mov    (%eax),%eax
    927f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    9282:	75 31                	jne    92b5 <insert_tail+0x41>
		BUG();
    9284:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    928b:	00 
    928c:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    9293:	e8 fc ff ff ff       	call   9294 <insert_tail+0x20>
    9298:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    929f:	e8 fc ff ff ff       	call   92a0 <insert_tail+0x2c>
    92a4:	e8 fc ff ff ff       	call   92a5 <insert_tail+0x31>
		show_stack(NULL);
    92a9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    92b0:	e8 fc ff ff ff       	call   92b1 <insert_tail+0x3d>
	}
#if 1 // 10-01: moved next pointer up to make consistent with mb version
	elem->next = (struct alloc_head*)head;
    92b5:	8b 55 0c             	mov    0xc(%ebp),%edx
    92b8:	8b 45 08             	mov    0x8(%ebp),%eax
    92bb:	89 42 04             	mov    %eax,0x4(%edx)
#endif
	elem->prev = head->prev;
    92be:	8b 55 0c             	mov    0xc(%ebp),%edx
    92c1:	8b 45 08             	mov    0x8(%ebp),%eax
    92c4:	8b 00                	mov    (%eax),%eax
    92c6:	89 02                	mov    %eax,(%edx)

	head->prev->next = elem;
    92c8:	8b 45 08             	mov    0x8(%ebp),%eax
    92cb:	8b 10                	mov    (%eax),%edx
    92cd:	8b 45 0c             	mov    0xc(%ebp),%eax
    92d0:	89 42 04             	mov    %eax,0x4(%edx)

	elem->list = head;
    92d3:	8b 55 0c             	mov    0xc(%ebp),%edx
    92d6:	8b 45 08             	mov    0x8(%ebp),%eax
    92d9:	89 42 08             	mov    %eax,0x8(%edx)
	head->prev = elem;
    92dc:	8b 55 08             	mov    0x8(%ebp),%edx
    92df:	8b 45 0c             	mov    0xc(%ebp),%eax
    92e2:	89 02                	mov    %eax,(%edx)
	head->len++;
    92e4:	8b 45 08             	mov    0x8(%ebp),%eax
    92e7:	ff 40 10             	incl   0x10(%eax)
}
    92ea:	c9                   	leave  
    92eb:	c3                   	ret    

000092ec <unlink>:

static inline void insert_tail_mb(struct alloc_head_list *head, struct alloc_head *elem) {
#if 1
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
		BUG();
		show_stack(NULL);
	}
#define INSERT_TAIL_MB
#ifdef INSERT_TAIL_MB // 10-01: moved next pointer up and added memory barrier to insure that forward walk through element list works properly without locking
	elem->next = (struct alloc_head*)head;
#endif
	elem->prev = head->prev;

#ifdef INSERT_TAIL_MB // 10-01
	mb();
#endif

	head->prev->next = elem;

#ifndef INSERT_TAIL_MB
	elem->next = (struct alloc_head*)head;
#endif

	elem->list = head;
	head->prev = elem;
	head->len++;
#endif
}

static inline void unlink(struct alloc_head *elem) {
    92ec:	55                   	push   %ebp
    92ed:	89 e5                	mov    %esp,%ebp
#ifdef DEBUG_LIST
	if(elem->list == (struct alloc_head_list*) elem) {
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    92ef:	8b 45 08             	mov    0x8(%ebp),%eax
    92f2:	8b 50 04             	mov    0x4(%eax),%edx
    92f5:	8b 45 08             	mov    0x8(%ebp),%eax
    92f8:	8b 00                	mov    (%eax),%eax
    92fa:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    92fc:	8b 45 08             	mov    0x8(%ebp),%eax
    92ff:	8b 10                	mov    (%eax),%edx
    9301:	8b 45 08             	mov    0x8(%ebp),%eax
    9304:	8b 40 04             	mov    0x4(%eax),%eax
    9307:	89 42 04             	mov    %eax,0x4(%edx)
	elem->prev = elem->next = NULL;
    930a:	8b 55 08             	mov    0x8(%ebp),%edx
    930d:	8b 45 08             	mov    0x8(%ebp),%eax
    9310:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    9317:	c7 02 00 00 00 00    	movl   $0x0,(%edx)

	elem->list->len--;
    931d:	8b 45 08             	mov    0x8(%ebp),%eax
    9320:	8b 40 08             	mov    0x8(%eax),%eax
    9323:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    9326:	8b 45 08             	mov    0x8(%ebp),%eax
    9329:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
    9330:	5d                   	pop    %ebp
    9331:	c3                   	ret    

00009332 <insert>:

static inline void insert(struct alloc_head *elem, struct alloc_head *prev, struct alloc_head *next) {
    9332:	55                   	push   %ebp
    9333:	89 e5                	mov    %esp,%ebp
    9335:	83 ec 08             	sub    $0x8,%esp
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
	if(prev->next != next || next->prev != prev) {
		BUG();
	}
#endif

	if(!(elem->next == NULL && elem->prev == NULL)) BUG();
    9338:	8b 45 08             	mov    0x8(%ebp),%eax
    933b:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
    933f:	75 0a                	jne    934b <insert+0x19>
    9341:	8b 45 08             	mov    0x8(%ebp),%eax
    9344:	83 38 00             	cmpl   $0x0,(%eax)
    9347:	75 02                	jne    934b <insert+0x19>
    9349:	eb 25                	jmp    9370 <insert+0x3e>
    934b:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    9352:	00 
    9353:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    935a:	e8 fc ff ff ff       	call   935b <insert+0x29>
    935f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    9366:	e8 fc ff ff ff       	call   9367 <insert+0x35>
    936b:	e8 fc ff ff ff       	call   936c <insert+0x3a>
	elem->next = prev->next;
    9370:	8b 55 08             	mov    0x8(%ebp),%edx
    9373:	8b 45 0c             	mov    0xc(%ebp),%eax
    9376:	8b 40 04             	mov    0x4(%eax),%eax
    9379:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = elem;
    937c:	8b 55 0c             	mov    0xc(%ebp),%edx
    937f:	8b 45 08             	mov    0x8(%ebp),%eax
    9382:	89 42 04             	mov    %eax,0x4(%edx)

	elem->prev = prev;
    9385:	8b 55 08             	mov    0x8(%ebp),%edx
    9388:	8b 45 0c             	mov    0xc(%ebp),%eax
    938b:	89 02                	mov    %eax,(%edx)
	next->prev = elem;
    938d:	8b 55 10             	mov    0x10(%ebp),%edx
    9390:	8b 45 08             	mov    0x8(%ebp),%eax
    9393:	89 02                	mov    %eax,(%edx)

	elem->list = prev->list;
    9395:	8b 55 08             	mov    0x8(%ebp),%edx
    9398:	8b 45 0c             	mov    0xc(%ebp),%eax
    939b:	8b 40 08             	mov    0x8(%eax),%eax
    939e:	89 42 08             	mov    %eax,0x8(%edx)
	elem->list->len++;
    93a1:	8b 45 08             	mov    0x8(%ebp),%eax
    93a4:	8b 40 08             	mov    0x8(%eax),%eax
    93a7:	ff 40 10             	incl   0x10(%eax)
}
    93aa:	c9                   	leave  
    93ab:	c3                   	ret    

000093ac <sock_hold>:
   modifications.
 */

static inline void sock_hold(struct sock *sk)
{
    93ac:	55                   	push   %ebp
    93ad:	89 e5                	mov    %esp,%ebp
    93af:	83 ec 04             	sub    $0x4,%esp
	atomic_inc(&sk->refcnt);
    93b2:	8b 45 08             	mov    0x8(%ebp),%eax
    93b5:	83 c0 28             	add    $0x28,%eax
    93b8:	89 04 24             	mov    %eax,(%esp,1)
    93bb:	e8 51 2a 00 00       	call   be11 <atomic_inc>
}
    93c0:	c9                   	leave  
    93c1:	c3                   	ret    

000093c2 <__sock_put>:

/* Ungrab socket in the context, which assumes that socket refcnt
   cannot hit zero, f.e. it is true in context of any socketcall.
 */
static inline void __sock_put(struct sock *sk)
{
    93c2:	55                   	push   %ebp
    93c3:	89 e5                	mov    %esp,%ebp
    93c5:	83 ec 04             	sub    $0x4,%esp
	atomic_dec(&sk->refcnt);
    93c8:	8b 45 08             	mov    0x8(%ebp),%eax
    93cb:	83 c0 28             	add    $0x28,%eax
    93ce:	89 04 24             	mov    %eax,(%esp,1)
    93d1:	e8 48 2a 00 00       	call   be1e <atomic_dec>
}
    93d6:	c9                   	leave  
    93d7:	c3                   	ret    

000093d8 <sock_put>:

/* Ungrab socket and destroy it, if it was the last reference. */
static inline void sock_put(struct sock *sk)
{
    93d8:	55                   	push   %ebp
    93d9:	89 e5                	mov    %esp,%ebp
    93db:	83 ec 04             	sub    $0x4,%esp
	if (atomic_dec_and_test(&sk->refcnt))
    93de:	8b 45 08             	mov    0x8(%ebp),%eax
    93e1:	83 c0 28             	add    $0x28,%eax
    93e4:	89 04 24             	mov    %eax,(%esp,1)
    93e7:	e8 08 f8 ff ff       	call   8bf4 <atomic_dec_and_test>
    93ec:	85 c0                	test   %eax,%eax
    93ee:	74 0b                	je     93fb <sock_put+0x23>
		sk_free(sk);
    93f0:	8b 45 08             	mov    0x8(%ebp),%eax
    93f3:	89 04 24             	mov    %eax,(%esp,1)
    93f6:	e8 fc ff ff ff       	call   93f7 <sock_put+0x1f>
}
    93fb:	c9                   	leave  
    93fc:	c3                   	ret    

000093fd <sk_wake_async>:

/* Detach socket from process context.
 * Announce socket dead, detach it from wait queue and inode.
 * Note that parent inode held reference count on this struct sock,
 * we do not release it in this function, because protocol
 * probably wants some additional cleanups or even continuing
 * to work with this socket (TCP).
 */
static inline void sock_orphan(struct sock *sk)
{
	write_lock_bh(&sk->callback_lock);
	sk->dead = 1;
	sk->socket = NULL;
	sk->sleep = NULL;
	write_unlock_bh(&sk->callback_lock);
}

static inline void sock_graft(struct sock *sk, struct socket *parent)
{
	write_lock_bh(&sk->callback_lock);
	sk->sleep = &parent->wait;
	parent->sk = sk;
	sk->socket = parent;
	write_unlock_bh(&sk->callback_lock);
}

static inline int sock_i_uid(struct sock *sk)
{
	int uid;

	read_lock(&sk->callback_lock);
	uid = sk->socket ? sk->socket->inode->i_uid : 0;
	read_unlock(&sk->callback_lock);
	return uid;
}

static inline unsigned long sock_i_ino(struct sock *sk)
{
	unsigned long ino;

	read_lock(&sk->callback_lock);
	ino = sk->socket ? sk->socket->inode->i_ino : 0;
	read_unlock(&sk->callback_lock);
	return ino;
}

static inline struct dst_entry *
__sk_dst_get(struct sock *sk)
{
	return sk->dst_cache;
}

static inline struct dst_entry *
sk_dst_get(struct sock *sk)
{
	struct dst_entry *dst;

	read_lock(&sk->dst_lock);
	dst = sk->dst_cache;
	if (dst)
		dst_hold(dst);
	read_unlock(&sk->dst_lock);
	return dst;
}

static inline void
__sk_dst_set(struct sock *sk, struct dst_entry *dst)
{
	struct dst_entry *old_dst;

	old_dst = sk->dst_cache;
	sk->dst_cache = dst;
	dst_release(old_dst);
}

static inline void
sk_dst_set(struct sock *sk, struct dst_entry *dst)
{
	write_lock(&sk->dst_lock);
	__sk_dst_set(sk, dst);
	write_unlock(&sk->dst_lock);
}

static inline void
__sk_dst_reset(struct sock *sk)
{
	struct dst_entry *old_dst;

	old_dst = sk->dst_cache;
	sk->dst_cache = NULL;
	dst_release(old_dst);
}

static inline void
sk_dst_reset(struct sock *sk)
{
	write_lock(&sk->dst_lock);
	__sk_dst_reset(sk);
	write_unlock(&sk->dst_lock);
}

static inline struct dst_entry *
__sk_dst_check(struct sock *sk, u32 cookie)
{
	struct dst_entry *dst = sk->dst_cache;

	if (dst && dst->obsolete && dst->ops->check(dst, cookie) == NULL) {
		sk->dst_cache = NULL;
		return NULL;
	}

	return dst;
}

static inline struct dst_entry *
sk_dst_check(struct sock *sk, u32 cookie)
{
	struct dst_entry *dst = sk_dst_get(sk);

	if (dst && dst->obsolete && dst->ops->check(dst, cookie) == NULL) {
		sk_dst_reset(sk);
		return NULL;
	}

	return dst;
}


/*
 * 	Queue a received datagram if it will fit. Stream and sequenced
 *	protocols can't normally use this as they need to fit buffers in
 *	and play with them.
 *
 * 	Inlined as it's very short and called for pretty much every
 *	packet ever received.
 */

static inline void skb_set_owner_w(struct sk_buff *skb, struct sock *sk)
{
	sock_hold(sk);
	skb->sk = sk;
	skb->destructor = sock_wfree;
	atomic_add(skb->truesize, &sk->wmem_alloc);
}

static inline void skb_set_owner_r(struct sk_buff *skb, struct sock *sk)
{
	skb->sk = sk;
	skb->destructor = sock_rfree;
	atomic_add(skb->truesize, &sk->rmem_alloc);
}

static inline int sock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)
{
	int err = 0;
	int skb_len;

	/* Cast skb->rcvbuf to unsigned... It's pointless, but reduces
	   number of warnings when compiling with -W --ANK
	 */
	if (atomic_read(&sk->rmem_alloc) + skb->truesize >= (unsigned)sk->rcvbuf) {
		err = -ENOMEM;
		goto out;
	}

	/* It would be deadlock, if sock_queue_rcv_skb is used
	   with socket lock! We assume that users of this
	   function are lock free.
	*/
	err = sk_filter(sk, skb, 1);
	if (err)
		goto out;

	skb->dev = NULL;
	skb_set_owner_r(skb, sk);

	/* Cache the SKB length before we tack it onto the receive
	 * queue.  Once it is added it no longer belongs to us and
	 * may be freed by other threads of control pulling packets
	 * from the queue.
	 */
	skb_len = skb->len;

	skb_queue_tail(&sk->receive_queue, skb);
	if (!sk->dead)
		sk->data_ready(sk,skb_len);
out:
	return err;
}

static inline int sock_queue_err_skb(struct sock *sk, struct sk_buff *skb)
{
	/* Cast skb->rcvbuf to unsigned... It's pointless, but reduces
	   number of warnings when compiling with -W --ANK
	 */
	if (atomic_read(&sk->rmem_alloc) + skb->truesize >= (unsigned)sk->rcvbuf)
		return -ENOMEM;
	skb_set_owner_r(skb, sk);
	skb_queue_tail(&sk->error_queue,skb);
	if (!sk->dead)
		sk->data_ready(sk,skb->len);
	return 0;
}

/*
 *	Recover an error report and clear atomically
 */
 
static inline int sock_error(struct sock *sk)
{
	int err=xchg(&sk->err,0);
	return -err;
}

static inline unsigned long sock_wspace(struct sock *sk)
{
	int amt = 0;

	if (!(sk->shutdown & SEND_SHUTDOWN)) {
		amt = sk->sndbuf - atomic_read(&sk->wmem_alloc);
		if (amt < 0) 
			amt = 0;
	}
	return amt;
}

static inline void sk_wake_async(struct sock *sk, int how, int band)
{
    93fd:	55                   	push   %ebp
    93fe:	89 e5                	mov    %esp,%ebp
    9400:	83 ec 0c             	sub    $0xc,%esp
	if (sk->socket && sk->socket->fasync_list)
    9403:	8b 45 08             	mov    0x8(%ebp),%eax
    9406:	83 b8 c8 0b 00 00 00 	cmpl   $0x0,0xbc8(%eax)
    940d:	74 2e                	je     943d <sk_wake_async+0x40>
    940f:	8b 45 08             	mov    0x8(%ebp),%eax
    9412:	8b 80 c8 0b 00 00    	mov    0xbc8(%eax),%eax
    9418:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
    941c:	74 1f                	je     943d <sk_wake_async+0x40>
		sock_wake_async(sk->socket, how, band);
    941e:	8b 45 10             	mov    0x10(%ebp),%eax
    9421:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    9425:	8b 45 0c             	mov    0xc(%ebp),%eax
    9428:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    942c:	8b 45 08             	mov    0x8(%ebp),%eax
    942f:	8b 80 c8 0b 00 00    	mov    0xbc8(%eax),%eax
    9435:	89 04 24             	mov    %eax,(%esp,1)
    9438:	e8 fc ff ff ff       	call   9439 <sk_wake_async+0x3c>
}
    943d:	c9                   	leave  
    943e:	c3                   	ret    

0000943f <tcp_v4_check>:
 */
static __inline__ u16 tcp_v4_check(struct tcphdr *th, int len,
				   unsigned long saddr, unsigned long daddr, 
				   unsigned long base)
{
    943f:	55                   	push   %ebp
    9440:	89 e5                	mov    %esp,%ebp
    9442:	83 ec 14             	sub    $0x14,%esp
	return csum_tcpudp_magic(saddr,daddr,len,IPPROTO_TCP,base);
    9445:	8b 45 18             	mov    0x18(%ebp),%eax
    9448:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    944c:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp,1)
    9453:	00 
    9454:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
    9458:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    945c:	8b 45 14             	mov    0x14(%ebp),%eax
    945f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    9463:	8b 45 10             	mov    0x10(%ebp),%eax
    9466:	89 04 24             	mov    %eax,(%esp,1)
    9469:	e8 02 2d 00 00       	call   c170 <csum_tcpudp_magic>
    946e:	0f b7 c0             	movzwl %ax,%eax
}
    9471:	c9                   	leave  
    9472:	c3                   	ret    

00009473 <__tcp_checksum_complete>:

static __inline__ int __tcp_checksum_complete(struct sk_buff *skb)
{
    9473:	55                   	push   %ebp
    9474:	89 e5                	mov    %esp,%ebp
    9476:	83 ec 10             	sub    $0x10,%esp
	return (unsigned short)csum_fold(skb_checksum(skb, 0, skb->len, skb->csum));
    9479:	8b 45 08             	mov    0x8(%ebp),%eax
    947c:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
    9482:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    9486:	8b 45 08             	mov    0x8(%ebp),%eax
    9489:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    948f:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    9493:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    949a:	00 
    949b:	8b 45 08             	mov    0x8(%ebp),%eax
    949e:	89 04 24             	mov    %eax,(%esp,1)
    94a1:	e8 fc ff ff ff       	call   94a2 <__tcp_checksum_complete+0x2f>
    94a6:	89 04 24             	mov    %eax,(%esp,1)
    94a9:	e8 9b 2c 00 00       	call   c149 <csum_fold>
    94ae:	0f b7 c0             	movzwl %ax,%eax
}
    94b1:	c9                   	leave  
    94b2:	c3                   	ret    

000094b3 <tcp_set_state>:

static __inline__ int tcp_checksum_complete(struct sk_buff *skb)
{
	return skb->ip_summed != CHECKSUM_UNNECESSARY &&
		__tcp_checksum_complete(skb);
}

/* Prequeue for VJ style copy to user, combined with checksumming. */

static __inline__ void tcp_prequeue_init(struct tcp_opt *tp)
{
	tp->ucopy.task = NULL;
	tp->ucopy.len = 0;
	tp->ucopy.memory = 0;
	skb_queue_head_init(&tp->ucopy.prequeue);
}

/* Packet is added to VJ-style prequeue for processing in process
 * context, if a reader task is waiting. Apparently, this exciting
 * idea (VJ's mail "Re: query about TCP header on tcp-ip" of 07 Sep 93)
 * failed somewhere. Latency? Burstiness? Well, at least now we will
 * see, why it failed. 8)8)				  --ANK
 *
 * NOTE: is this not too big to inline?
 */
static __inline__ int tcp_prequeue(struct sock *sk, struct sk_buff *skb)
{
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;

	if (!sysctl_tcp_low_latency && tp->ucopy.task) {
		__skb_queue_tail(&tp->ucopy.prequeue, skb);
		tp->ucopy.memory += skb->truesize;
		if (tp->ucopy.memory > sk->rcvbuf) {
			struct sk_buff *skb1;

			if (sk->lock.users)
				out_of_line_bug();

			while ((skb1 = __skb_dequeue(&tp->ucopy.prequeue)) != NULL) {
				sk->backlog_rcv(sk, skb1);
				NET_INC_STATS_BH(TCPPrequeueDropped);
			}

			tp->ucopy.memory = 0;
		} else if (skb_queue_len(&tp->ucopy.prequeue) == 1) {
			wake_up_interruptible(sk->sleep);
			if (!tcp_ack_scheduled(tp))
				tcp_reset_xmit_timer(sk, TCP_TIME_DACK, (3*TCP_RTO_MIN)/4);
		}
		return 1;
	}
	return 0;
}


#undef STATE_TRACE

#ifdef STATE_TRACE
static char *statename[]={
	"Unused","Established","Syn Sent","Syn Recv",
	"Fin Wait 1","Fin Wait 2","Time Wait", "Close",
	"Close Wait","Last ACK","Listen","Closing"
};
#endif

static __inline__ void tcp_set_state(struct sock *sk, int state)
{
    94b3:	55                   	push   %ebp
    94b4:	89 e5                	mov    %esp,%ebp
    94b6:	83 ec 18             	sub    $0x18,%esp
	int oldstate = sk->state;
    94b9:	8b 45 08             	mov    0x8(%ebp),%eax
    94bc:	0f b6 40 20          	movzbl 0x20(%eax),%eax
    94c0:	0f b6 c0             	movzbl %al,%eax
    94c3:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

	switch (state) {
    94c6:	8b 45 0c             	mov    0xc(%ebp),%eax
    94c9:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    94cc:	83 7d ec 01          	cmpl   $0x1,0xffffffec(%ebp)
    94d0:	74 0b                	je     94dd <tcp_set_state+0x2a>
    94d2:	83 7d ec 07          	cmpl   $0x7,0xffffffec(%ebp)
    94d6:	74 36                	je     950e <tcp_set_state+0x5b>
    94d8:	e9 99 00 00 00       	jmp    9576 <tcp_set_state+0xc3>
	case TCP_ESTABLISHED:
		if (oldstate != TCP_ESTABLISHED)
    94dd:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
    94e1:	0f 84 b7 00 00 00    	je     959e <tcp_set_state+0xeb>
			TCP_INC_STATS(TcpCurrEstab);
    94e7:	83 3d 08 00 00 00 00 	cmpl   $0x0,0x8
    94ee:	75 09                	jne    94f9 <tcp_set_state+0x46>
    94f0:	c7 45 f8 60 00 00 00 	movl   $0x60,0xfffffff8(%ebp)
    94f7:	eb 07                	jmp    9500 <tcp_set_state+0x4d>
    94f9:	c7 45 f8 20 00 00 00 	movl   $0x20,0xfffffff8(%ebp)
    9500:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9503:	ff 80 00 00 00 00    	incl   0x0(%eax)
		break;
    9509:	e9 90 00 00 00       	jmp    959e <tcp_set_state+0xeb>

	case TCP_CLOSE:
		if (oldstate == TCP_CLOSE_WAIT || oldstate == TCP_ESTABLISHED)
    950e:	83 7d fc 08          	cmpl   $0x8,0xfffffffc(%ebp)
    9512:	74 08                	je     951c <tcp_set_state+0x69>
    9514:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
    9518:	74 02                	je     951c <tcp_set_state+0x69>
    951a:	eb 22                	jmp    953e <tcp_set_state+0x8b>
			TCP_INC_STATS(TcpEstabResets);
    951c:	83 3d 08 00 00 00 00 	cmpl   $0x0,0x8
    9523:	75 09                	jne    952e <tcp_set_state+0x7b>
    9525:	c7 45 f4 40 00 00 00 	movl   $0x40,0xfffffff4(%ebp)
    952c:	eb 07                	jmp    9535 <tcp_set_state+0x82>
    952e:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
    9535:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    9538:	ff 80 1c 00 00 00    	incl   0x1c(%eax)

		sk->prot->unhash(sk);
    953e:	8b 45 08             	mov    0x8(%ebp),%eax
    9541:	8b 90 b8 00 00 00    	mov    0xb8(%eax),%edx
    9547:	8b 45 08             	mov    0x8(%ebp),%eax
    954a:	89 04 24             	mov    %eax,(%esp,1)
    954d:	8b 42 3c             	mov    0x3c(%edx),%eax
    9550:	ff d0                	call   *%eax
		if (sk->prev && !(sk->userlocks&SOCK_BINDPORT_LOCK))
    9552:	8b 45 08             	mov    0x8(%ebp),%eax
    9555:	83 78 7c 00          	cmpl   $0x0,0x7c(%eax)
    9559:	74 1b                	je     9576 <tcp_set_state+0xc3>
    955b:	8b 45 08             	mov    0x8(%ebp),%eax
    955e:	0f b6 80 8c 00 00 00 	movzbl 0x8c(%eax),%eax
    9565:	24 08                	and    $0x8,%al
    9567:	84 c0                	test   %al,%al
    9569:	75 0b                	jne    9576 <tcp_set_state+0xc3>
			tcp_put_port(sk);
    956b:	8b 45 08             	mov    0x8(%ebp),%eax
    956e:	89 04 24             	mov    %eax,(%esp,1)
    9571:	e8 fc ff ff ff       	call   9572 <tcp_set_state+0xbf>
		/* fall through */
	default:
		if (oldstate==TCP_ESTABLISHED)
    9576:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
    957a:	75 22                	jne    959e <tcp_set_state+0xeb>
			tcp_statistics[smp_processor_id()*2+!in_softirq()].TcpCurrEstab--;
    957c:	83 3d 08 00 00 00 00 	cmpl   $0x0,0x8
    9583:	75 09                	jne    958e <tcp_set_state+0xdb>
    9585:	c7 45 f0 60 00 00 00 	movl   $0x60,0xfffffff0(%ebp)
    958c:	eb 07                	jmp    9595 <tcp_set_state+0xe2>
    958e:	c7 45 f0 20 00 00 00 	movl   $0x20,0xfffffff0(%ebp)
    9595:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    9598:	ff 88 00 00 00 00    	decl   0x0(%eax)
	}

	/* Change state AFTER socket is unhashed to avoid closed
	 * socket sitting in hash tables.
	 */
	sk->state = state;
    959e:	8b 55 08             	mov    0x8(%ebp),%edx
    95a1:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    95a5:	88 42 20             	mov    %al,0x20(%edx)

#ifdef STATE_TRACE
	SOCK_DEBUG(sk, "TCP sk=%p, State %s -> %s\n",sk, statename[oldstate],statename[state]);
#endif	
}
    95a8:	c9                   	leave  
    95a9:	c3                   	ret    

000095aa <trickles_checksum>:

#define MINISOCK_LEN(RO_LEN) ((RO_LEN) / 2)

#ifndef USERTEST
static inline void trickles_checksum(struct sk_buff *skb, int headerLen) {
    95aa:	55                   	push   %ebp
    95ab:	89 e5                	mov    %esp,%ebp
    95ad:	53                   	push   %ebx
    95ae:	83 ec 18             	sub    $0x18,%esp
	struct sock *sk = skb->sk;
    95b1:	8b 45 08             	mov    0x8(%ebp),%eax
    95b4:	8b 40 0c             	mov    0xc(%eax),%eax
    95b7:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	if(skb->ip_summed == CHECKSUM_HW) {
    95ba:	8b 45 08             	mov    0x8(%ebp),%eax
    95bd:	80 b8 a3 00 00 00 01 	cmpb   $0x1,0xa3(%eax)
    95c4:	75 5d                	jne    9623 <trickles_checksum+0x79>
		skb->h.th->check = 0;
    95c6:	8b 45 08             	mov    0x8(%ebp),%eax
    95c9:	8b 40 20             	mov    0x20(%eax),%eax
    95cc:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
		skb->h.th->check = ~tcp_v4_check(skb->h.th, skb->len, sk->saddr, sk->daddr,
    95d2:	8b 45 08             	mov    0x8(%ebp),%eax
    95d5:	8b 58 20             	mov    0x20(%eax),%ebx
    95d8:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp,1)
    95df:	00 
    95e0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    95e3:	8b 00                	mov    (%eax),%eax
    95e5:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    95e9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    95ec:	8b 40 70             	mov    0x70(%eax),%eax
    95ef:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    95f3:	8b 45 08             	mov    0x8(%ebp),%eax
    95f6:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    95fc:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    9600:	8b 45 08             	mov    0x8(%ebp),%eax
    9603:	8b 40 20             	mov    0x20(%eax),%eax
    9606:	89 04 24             	mov    %eax,(%esp,1)
    9609:	e8 31 fe ff ff       	call   943f <tcp_v4_check>
    960e:	f7 d0                	not    %eax
    9610:	66 89 43 10          	mov    %ax,0x10(%ebx)
					 0);
		skb->csum = offsetof(struct tcphdr, check);
    9614:	8b 45 08             	mov    0x8(%ebp),%eax
    9617:	c7 80 9c 00 00 00 10 	movl   $0x10,0x9c(%eax)
    961e:	00 00 00 
    9621:	eb 6a                	jmp    968d <trickles_checksum+0xe3>
	} else {
		skb->h.th->check = 0;
    9623:	8b 45 08             	mov    0x8(%ebp),%eax
    9626:	8b 40 20             	mov    0x20(%eax),%eax
    9629:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
		skb->h.th->check = tcp_v4_check(skb->h.th, skb->len, sk->saddr, sk->daddr,
    962f:	8b 45 08             	mov    0x8(%ebp),%eax
    9632:	8b 58 20             	mov    0x20(%eax),%ebx
    9635:	8b 45 08             	mov    0x8(%ebp),%eax
    9638:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
    963e:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    9642:	8b 45 0c             	mov    0xc(%ebp),%eax
    9645:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    9649:	8b 45 08             	mov    0x8(%ebp),%eax
    964c:	8b 40 20             	mov    0x20(%eax),%eax
    964f:	89 04 24             	mov    %eax,(%esp,1)
    9652:	e8 fc ff ff ff       	call   9653 <trickles_checksum+0xa9>
    9657:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    965b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    965e:	8b 00                	mov    (%eax),%eax
    9660:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    9664:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9667:	8b 40 70             	mov    0x70(%eax),%eax
    966a:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    966e:	8b 45 08             	mov    0x8(%ebp),%eax
    9671:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    9677:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    967b:	8b 45 08             	mov    0x8(%ebp),%eax
    967e:	8b 40 20             	mov    0x20(%eax),%eax
    9681:	89 04 24             	mov    %eax,(%esp,1)
    9684:	e8 b6 fd ff ff       	call   943f <tcp_v4_check>
    9689:	66 89 43 10          	mov    %ax,0x10(%ebx)
					 csum_partial((char*)skb->h.th, headerLen, skb->csum));
	}
}
    968d:	83 c4 18             	add    $0x18,%esp
    9690:	5b                   	pop    %ebx
    9691:	5d                   	pop    %ebp
    9692:	c3                   	ret    

00009693 <newDataRequestMapping>:
extern int numDataRequestMappings;

static inline
struct DataRequestMapping *newDataRequestMapping(struct UC_Continuation *ucont, unsigned tseq_start, unsigned tseq_end,
						 unsigned start, unsigned end) {
    9693:	55                   	push   %ebp
    9694:	89 e5                	mov    %esp,%ebp
    9696:	83 ec 10             	sub    $0x10,%esp
	struct DataRequestMapping *newMapping = kmalloc(sizeof(struct DataRequestMapping), GFP_ATOMIC);
    9699:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    96a0:	00 
    96a1:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp,1)
    96a8:	e8 fc ff ff ff       	call   96a9 <newDataRequestMapping+0x16>
    96ad:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	if(newMapping == NULL) return NULL;
    96b0:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
    96b4:	75 09                	jne    96bf <newDataRequestMapping+0x2c>
    96b6:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
    96bd:	eb 75                	jmp    9734 <newDataRequestMapping+0xa1>
	newMapping->next = newMapping->prev = NULL;
    96bf:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    96c2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    96c5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    96cb:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
	newMapping->list = NULL;
    96d2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    96d5:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

	newMapping->completed = 0;
    96dc:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    96df:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	newMapping->ucont = ucont;
    96e6:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    96e9:	8b 45 08             	mov    0x8(%ebp),%eax
    96ec:	89 42 0c             	mov    %eax,0xc(%edx)
	newMapping->transportResponseSeqStart = tseq_start;
    96ef:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    96f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    96f5:	89 42 18             	mov    %eax,0x18(%edx)
	newMapping->transportResponseSeqEnd = tseq_end;
    96f8:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    96fb:	8b 45 10             	mov    0x10(%ebp),%eax
    96fe:	89 42 1c             	mov    %eax,0x1c(%edx)
	newMapping->sent = 0;
    9701:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    9704:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	newMapping->start = start;
    970b:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    970e:	8b 45 14             	mov    0x14(%ebp),%eax
    9711:	89 42 20             	mov    %eax,0x20(%edx)
	newMapping->end = end;
    9714:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    9717:	8b 45 18             	mov    0x18(%ebp),%eax
    971a:	89 42 24             	mov    %eax,0x24(%edx)
#ifndef USERTEST
	newMapping->timestamp = jiffies;
    971d:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    9720:	a1 00 00 00 00       	mov    0x0,%eax
    9725:	89 42 28             	mov    %eax,0x28(%edx)
#endif

	numDataRequestMappings++;
    9728:	ff 05 00 00 00 00    	incl   0x0
	return newMapping;
    972e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    9731:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
}
    9734:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9737:	c9                   	leave  
    9738:	c3                   	ret    

00009739 <freeDataRequestMapping>:

static inline void freeDataRequestMapping(struct DataRequestMapping *dataReq) {
    9739:	55                   	push   %ebp
    973a:	89 e5                	mov    %esp,%ebp
    973c:	83 ec 04             	sub    $0x4,%esp
	numDataRequestMappings--;
    973f:	ff 0d 00 00 00 00    	decl   0x0
	kfree(dataReq);
    9745:	8b 45 08             	mov    0x8(%ebp),%eax
    9748:	89 04 24             	mov    %eax,(%esp,1)
    974b:	e8 fc ff ff ff       	call   974c <freeDataRequestMapping+0x13>
}
    9750:	c9                   	leave  
    9751:	c3                   	ret    

00009752 <resetRequest>:

/* These requests are queued in the reliable request queues. As the
   client earns tokens to use to service requests, the entries in this
   queue are sent to the server. During recovery, all requests are
   retried */

enum UserRequestType {
  /* MemoryREQuest */
	MREQ_CONVERSION,
	MREQ_CONTINUATION
};

struct Request {
  /* Generic "base" type */
#define MAX_MREQ_CHILDREN 4
#define REQUEST_FIELDS							\
	struct alloc_head *prev;					\
	struct alloc_head *next;					\
	struct alloc_head_list *list;					\
	enum UserRequestType type;					\
	unsigned numChildren;						\
	unsigned childrenMask : MAX_MREQ_CHILDREN;			\
	struct { __u32 start, end; } childRanges[MAX_MREQ_CHILDREN];	\
	unsigned transport_seq;						\
	unsigned seq;							\
	unsigned start, end;					        \
		unsigned isNew : 1;					\
		unsigned allocated : 1;					\
		unsigned transportResponseSeqStart, transportResponseSeqEnd;

	// Request uses only alloc_head list management operations. Thus,
	// Request does not need a 'ctl' field

	REQUEST_FIELDS
};

static inline void resetRequest(struct Request *req) {
    9752:	55                   	push   %ebp
    9753:	89 e5                	mov    %esp,%ebp
	req->numChildren = 0;
    9755:	8b 45 08             	mov    0x8(%ebp),%eax
    9758:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	req->childrenMask = 0;
    975f:	8b 55 08             	mov    0x8(%ebp),%edx
    9762:	0f b6 42 14          	movzbl 0x14(%edx),%eax
    9766:	24 f0                	and    $0xf0,%al
    9768:	88 42 14             	mov    %al,0x14(%edx)
	req->transport_seq = -1;
    976b:	8b 45 08             	mov    0x8(%ebp),%eax
    976e:	c7 40 38 ff ff ff ff 	movl   $0xffffffff,0x38(%eax)
	req->seq = -1;
    9775:	8b 45 08             	mov    0x8(%ebp),%eax
    9778:	c7 40 3c ff ff ff ff 	movl   $0xffffffff,0x3c(%eax)
	req->isNew = 1;
    977f:	8b 45 08             	mov    0x8(%ebp),%eax
    9782:	80 48 48 01          	orb    $0x1,0x48(%eax)
}
    9786:	5d                   	pop    %ebp
    9787:	c3                   	ret    

00009788 <queueNewRequest>:

static inline void initRequest(struct Request *req, enum UserRequestType type) {
	/* Initialize generic fields */
	req->type = type;
	req->prev = req->next = NULL;
	req->list = NULL;
	resetRequest(req);
	req->start = req->end = -1;
	req->allocated = 1;
}

void resetClientTimer(struct sock *sk);

static inline void queueNewRequest(struct sock *sk, struct Request *req) {
    9788:	55                   	push   %ebp
    9789:	89 e5                	mov    %esp,%ebp
    978b:	83 ec 0c             	sub    $0xc,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    978e:	8b 45 08             	mov    0x8(%ebp),%eax
    9791:	05 bc 00 00 00       	add    $0xbc,%eax
    9796:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	insert_tail(&tp->t.queuedRequests, (struct alloc_head*)req);
    9799:	8b 45 0c             	mov    0xc(%ebp),%eax
    979c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    97a0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    97a3:	05 98 09 00 00       	add    $0x998,%eax
    97a8:	89 04 24             	mov    %eax,(%esp,1)
    97ab:	e8 c4 fa ff ff       	call   9274 <insert_tail>
	tp->t.timerState |= TRICKLES_ENABLE_DATA_TIMEOUT;
    97b0:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    97b3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    97b6:	8b 80 dc 02 00 00    	mov    0x2dc(%eax),%eax
    97bc:	83 c8 01             	or     $0x1,%eax
    97bf:	89 82 dc 02 00 00    	mov    %eax,0x2dc(%edx)
	resetClientTimer(sk);
    97c5:	8b 45 08             	mov    0x8(%ebp),%eax
    97c8:	89 04 24             	mov    %eax,(%esp,1)
    97cb:	e8 fc ff ff ff       	call   97cc <queueNewRequest+0x44>
}
    97d0:	c9                   	leave  
    97d1:	c3                   	ret    

000097d2 <initCompleteConversionRequest>:

struct ConversionRequest {
	REQUEST_FIELDS

	_bool incomplete; //  0 = complete, 1 = incomplete
	// First skb that contains data to convert
	struct sk_buff *data;
	// Offset within sk_buff
	unsigned offset;
#if 0
	// Length to send. If necessary, consult successors to 'data'
	unsigned length;
	// if length == 0, length is undefined and should be set in sendAck (possibly performing fragmentation)
#endif

	unsigned predLength;
	union {
		struct WireUC_CVT_IncompleteContinuation *incompletePred;
		struct UC_Continuation *completePred;
	};
};

static inline void initCompleteConversionRequest(struct ConversionRequest *req, struct UC_Continuation *pred, struct sk_buff *data, unsigned start) {
    97d2:	55                   	push   %ebp
    97d3:	89 e5                	mov    %esp,%ebp
    97d5:	53                   	push   %ebx
    97d6:	83 ec 08             	sub    $0x8,%esp
	initRequest((struct Request *)req, MREQ_CONVERSION);
    97d9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    97e0:	00 
    97e1:	8b 45 08             	mov    0x8(%ebp),%eax
    97e4:	89 04 24             	mov    %eax,(%esp,1)
    97e7:	e8 50 2b 00 00       	call   c33c <initRequest>
	req->incomplete = 0;
    97ec:	8b 45 08             	mov    0x8(%ebp),%eax
    97ef:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
	req->completePred = pred;
    97f6:	8b 55 08             	mov    0x8(%ebp),%edx
    97f9:	8b 45 0c             	mov    0xc(%ebp),%eax
    97fc:	89 42 64             	mov    %eax,0x64(%edx)
	atomic_inc(&req->completePred->refcnt);
    97ff:	8b 45 08             	mov    0x8(%ebp),%eax
    9802:	8b 40 64             	mov    0x64(%eax),%eax
    9805:	83 c0 24             	add    $0x24,%eax
    9808:	89 04 24             	mov    %eax,(%esp,1)
    980b:	e8 01 26 00 00       	call   be11 <atomic_inc>
#if 1 // 0707
	if(atomic_read(&req->completePred->refcnt) < 2) {
    9810:	8b 45 08             	mov    0x8(%ebp),%eax
    9813:	8b 40 64             	mov    0x64(%eax),%eax
    9816:	83 c0 24             	add    $0x24,%eax
    9819:	8b 00                	mov    (%eax),%eax
    981b:	83 f8 01             	cmp    $0x1,%eax
    981e:	7f 0c                	jg     982c <initCompleteConversionRequest+0x5a>
		printk("refcnt should be > 1!\n");
    9820:	c7 04 24 84 38 00 00 	movl   $0x3884,(%esp,1)
    9827:	e8 fc ff ff ff       	call   9828 <initCompleteConversionRequest+0x56>
	}
#endif
	req->data = data;
    982c:	8b 55 08             	mov    0x8(%ebp),%edx
    982f:	8b 45 10             	mov    0x10(%ebp),%eax
    9832:	89 42 58             	mov    %eax,0x58(%edx)
	req->start = start;
    9835:	8b 55 08             	mov    0x8(%ebp),%edx
    9838:	8b 45 14             	mov    0x14(%ebp),%eax
    983b:	89 42 40             	mov    %eax,0x40(%edx)
	req->offset = req->start - TCP_SKB_CB(data)->seq;
    983e:	8b 5d 08             	mov    0x8(%ebp),%ebx
    9841:	8b 4d 08             	mov    0x8(%ebp),%ecx
    9844:	8b 45 10             	mov    0x10(%ebp),%eax
    9847:	83 c0 30             	add    $0x30,%eax
    984a:	8b 50 10             	mov    0x10(%eax),%edx
    984d:	8b 41 40             	mov    0x40(%ecx),%eax
    9850:	29 d0                	sub    %edx,%eax
    9852:	89 43 5c             	mov    %eax,0x5c(%ebx)
}
    9855:	83 c4 08             	add    $0x8,%esp
    9858:	5b                   	pop    %ebx
    9859:	5d                   	pop    %ebp
    985a:	c3                   	ret    

0000985b <RequestOFOEntry_new>:

static inline void initIncompleteConversionRequest(struct ConversionRequest *req, struct WireUC_CVT_IncompleteContinuation *pred, unsigned predLength, struct sk_buff *data, unsigned offset) {
	initRequest((struct Request *)req, MREQ_CONVERSION);
	req->incomplete = 1;
	req->incompletePred = pred;
	req->predLength = predLength;
	req->data = data;
	req->offset = offset;
}

struct ContinuationRequest {
	REQUEST_FIELDS

	// conts array is kmalloc()'d, and deallocated when the response is
	// processed, and request dequeued
	//
	// The continuations themselves are deallocated by higher
	// layer once no longer needed as dependencies
	unsigned numConts;
	struct UC_Continuation **conts;
};

static inline int initContinuationRequest(struct ContinuationRequest *req, unsigned start, unsigned end, int numConts) {
	initRequest((struct Request *)req, MREQ_CONTINUATION);
	req->start = start;
	req->end = end;
	req->numConts = numConts;
	req->conts = kmalloc(sizeof(struct UC_Continuation*) * numConts, GFP_ATOMIC);
	if(req == NULL) {
		if(trickles_ratelimit())
			printk("Could not allocate continuation request\n");
		return -1;
	}
	return 0;
}

extern int numContinuationRequests;
static inline struct ContinuationRequest *copyContinuationRequest(struct ContinuationRequest *src) {
	struct ContinuationRequest *newReq = kmalloc(sizeof(struct ContinuationRequest), GFP_ATOMIC);
	numContinuationRequests++;
	if(newReq == NULL) return NULL;
	*newReq = *src;
	newReq->conts = kmalloc(sizeof(struct UC_Continuation*) * newReq->numConts, GFP_ATOMIC);
	if(newReq->conts == NULL) {
		kfree(newReq);
		return NULL;
	}
	memcpy(newReq->conts, src->conts, sizeof(struct UC_Continuation*) * newReq->numConts);
	return newReq;
}

struct RequestOFOEntry {
	struct RequestOFOEntry *prev;
	struct RequestOFOEntry *next;
	struct alloc_head_list *list;

	CONTINUATION_TYPE *cont;
	int isSynack;
	__u32 parent;
	__u8 numSiblings;
	__u8 position;
};

static inline struct RequestOFOEntry *
RequestOFOEntry_new(CONTINUATION_TYPE *cont,
		    int isSynack, __u32 parent, __u8 numSiblings, __u8 position) {
    985b:	55                   	push   %ebp
    985c:	89 e5                	mov    %esp,%ebp
    985e:	83 ec 14             	sub    $0x14,%esp
    9861:	8b 45 14             	mov    0x14(%ebp),%eax
    9864:	8b 55 18             	mov    0x18(%ebp),%edx
    9867:	88 45 ff             	mov    %al,0xffffffff(%ebp)
    986a:	88 55 fe             	mov    %dl,0xfffffffe(%ebp)
	struct  RequestOFOEntry *rval =
    986d:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    9874:	00 
    9875:	c7 04 24 1c 00 00 00 	movl   $0x1c,(%esp,1)
    987c:	e8 fc ff ff ff       	call   987d <RequestOFOEntry_new+0x22>
    9881:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
		kmalloc(sizeof(struct RequestOFOEntry), GFP_ATOMIC);
	if(rval == NULL) {
    9884:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    9888:	75 15                	jne    989f <RequestOFOEntry_new+0x44>
		printk("Out of memory while allocating RequesOFOEntry\n");
    988a:	c7 04 24 a0 38 00 00 	movl   $0x38a0,(%esp,1)
    9891:	e8 fc ff ff ff       	call   9892 <RequestOFOEntry_new+0x37>
		return NULL;
    9896:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
    989d:	eb 52                	jmp    98f1 <RequestOFOEntry_new+0x96>
	}
	rval->prev = rval->next = NULL;
    989f:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    98a2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    98a5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    98ac:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	rval->list = NULL;
    98b2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    98b5:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

	rval->cont = cont;
    98bc:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    98bf:	8b 45 08             	mov    0x8(%ebp),%eax
    98c2:	89 42 0c             	mov    %eax,0xc(%edx)
	rval->isSynack = isSynack;
    98c5:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    98c8:	8b 45 0c             	mov    0xc(%ebp),%eax
    98cb:	89 42 10             	mov    %eax,0x10(%edx)
	rval->parent = parent;
    98ce:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    98d1:	8b 45 10             	mov    0x10(%ebp),%eax
    98d4:	89 42 14             	mov    %eax,0x14(%edx)
	rval->numSiblings = numSiblings;
    98d7:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    98da:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
    98de:	88 42 18             	mov    %al,0x18(%edx)
	rval->position = position;
    98e1:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    98e4:	0f b6 45 fe          	movzbl 0xfffffffe(%ebp),%eax
    98e8:	88 42 19             	mov    %al,0x19(%edx)

	return rval;
    98eb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    98ee:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
}
    98f1:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    98f4:	c9                   	leave  
    98f5:	c3                   	ret    

000098f6 <marshallContinuationClient>:
  } while(0)

MARSHALL_CONTINUATION(Server, 1, SERVER_COMPUTE_MAC)
MARSHALL_CONTINUATION(ServerCopyMAC, 1, CLIENT_COMPUTE_MAC)
MARSHALL_CONTINUATION(Client, 0, CLIENT_COMPUTE_MAC)
    98f6:	55                   	push   %ebp
    98f7:	89 e5                	mov    %esp,%ebp
    98f9:	53                   	push   %ebx
    98fa:	83 ec 10             	sub    $0x10,%esp
    98fd:	8b 55 0c             	mov    0xc(%ebp),%edx
    9900:	8b 45 10             	mov    0x10(%ebp),%eax
    9903:	8b 40 38             	mov    0x38(%eax),%eax
    9906:	89 42 09             	mov    %eax,0x9(%edx)
    9909:	8b 55 0c             	mov    0xc(%ebp),%edx
    990c:	8b 45 10             	mov    0x10(%ebp),%eax
    990f:	8b 40 3c             	mov    0x3c(%eax),%eax
    9912:	89 42 0d             	mov    %eax,0xd(%edx)
    9915:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9918:	8b 45 10             	mov    0x10(%ebp),%eax
    991b:	8b 40 30             	mov    0x30(%eax),%eax
    991e:	89 04 24             	mov    %eax,(%esp,1)
    9921:	e8 fc ff ff ff       	call   9922 <marshallContinuationClient+0x2c>
    9926:	89 43 01             	mov    %eax,0x1(%ebx)
    9929:	8b 55 0c             	mov    0xc(%ebp),%edx
    992c:	8b 45 10             	mov    0x10(%ebp),%eax
    992f:	0f b6 40 34          	movzbl 0x34(%eax),%eax
    9933:	88 02                	mov    %al,(%edx)
    9935:	8b 55 0c             	mov    0xc(%ebp),%edx
    9938:	8b 45 10             	mov    0x10(%ebp),%eax
    993b:	0f b6 40 58          	movzbl 0x58(%eax),%eax
    993f:	88 42 05             	mov    %al,0x5(%edx)
    9942:	8b 55 0c             	mov    0xc(%ebp),%edx
    9945:	8b 45 10             	mov    0x10(%ebp),%eax
    9948:	0f b6 40 54          	movzbl 0x54(%eax),%eax
    994c:	88 42 2d             	mov    %al,0x2d(%edx)
    994f:	8b 55 0c             	mov    0xc(%ebp),%edx
    9952:	8b 45 10             	mov    0x10(%ebp),%eax
    9955:	8b 40 40             	mov    0x40(%eax),%eax
    9958:	89 42 25             	mov    %eax,0x25(%edx)
    995b:	8b 55 0c             	mov    0xc(%ebp),%edx
    995e:	8b 45 10             	mov    0x10(%ebp),%eax
    9961:	8b 40 4c             	mov    0x4c(%eax),%eax
    9964:	89 42 11             	mov    %eax,0x11(%edx)
    9967:	8b 55 0c             	mov    0xc(%ebp),%edx
    996a:	8b 45 10             	mov    0x10(%ebp),%eax
    996d:	8b 40 44             	mov    0x44(%eax),%eax
    9970:	89 42 29             	mov    %eax,0x29(%edx)
    9973:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9976:	8b 45 10             	mov    0x10(%ebp),%eax
    9979:	8b 40 5c             	mov    0x5c(%eax),%eax
    997c:	89 04 24             	mov    %eax,(%esp,1)
    997f:	e8 fc ff ff ff       	call   9980 <marshallContinuationClient+0x8a>
    9984:	89 43 2e             	mov    %eax,0x2e(%ebx)
    9987:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    998a:	8b 45 10             	mov    0x10(%ebp),%eax
    998d:	8b 40 60             	mov    0x60(%eax),%eax
    9990:	89 04 24             	mov    %eax,(%esp,1)
    9993:	e8 fc ff ff ff       	call   9994 <marshallContinuationClient+0x9e>
    9998:	89 43 32             	mov    %eax,0x32(%ebx)
    999b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    999e:	8b 45 10             	mov    0x10(%ebp),%eax
    99a1:	8b 40 64             	mov    0x64(%eax),%eax
    99a4:	89 04 24             	mov    %eax,(%esp,1)
    99a7:	e8 fc ff ff ff       	call   99a8 <marshallContinuationClient+0xb2>
    99ac:	89 43 36             	mov    %eax,0x36(%ebx)
    99af:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    99b2:	8b 45 10             	mov    0x10(%ebp),%eax
    99b5:	8b 40 68             	mov    0x68(%eax),%eax
    99b8:	89 04 24             	mov    %eax,(%esp,1)
    99bb:	e8 fc ff ff ff       	call   99bc <marshallContinuationClient+0xc6>
    99c0:	89 43 3a             	mov    %eax,0x3a(%ebx)
    99c3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    99c6:	8b 45 10             	mov    0x10(%ebp),%eax
    99c9:	8b 40 6c             	mov    0x6c(%eax),%eax
    99cc:	89 04 24             	mov    %eax,(%esp,1)
    99cf:	e8 fc ff ff ff       	call   99d0 <marshallContinuationClient+0xda>
    99d4:	89 43 3e             	mov    %eax,0x3e(%ebx)
    99d7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    99da:	8b 45 10             	mov    0x10(%ebp),%eax
    99dd:	8b 50 74             	mov    0x74(%eax),%edx
    99e0:	8b 40 70             	mov    0x70(%eax),%eax
    99e3:	89 41 42             	mov    %eax,0x42(%ecx)
    99e6:	89 51 46             	mov    %edx,0x46(%ecx)
    99e9:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp,1)
    99f0:	00 
    99f1:	8b 45 10             	mov    0x10(%ebp),%eax
    99f4:	05 9c 00 00 00       	add    $0x9c,%eax
    99f9:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    99fd:	8b 45 0c             	mov    0xc(%ebp),%eax
    9a00:	83 c0 15             	add    $0x15,%eax
    9a03:	89 04 24             	mov    %eax,(%esp,1)
    9a06:	e8 4f 24 00 00       	call   be5a <__constant_memcpy>
    9a0b:	83 c4 10             	add    $0x10,%esp
    9a0e:	5b                   	pop    %ebx
    9a0f:	5d                   	pop    %ebp
    9a10:	c3                   	ret    

00009a11 <marshallAckProof>:
#undef SERVER_COMPUTE_MAC
#undef CLIENT_COMPUTE_MAC
#undef HNCONVERTLONG

static inline void marshallAckProof(WireAckProof *dproof, const AckProof *sproof) {
    9a11:	55                   	push   %ebp
    9a12:	89 e5                	mov    %esp,%ebp
    9a14:	56                   	push   %esi
    9a15:	53                   	push   %ebx
    9a16:	83 ec 1c             	sub    $0x1c,%esp
#define HNCONVERTLONG(X) dproof->X = htonl(sproof->X);
#define COPYLONG(X) dproof->X = sproof->X
  int i;
  dproof->numSacks = MIN(sproof->numSacks, MAXSACKS);
    9a19:	8b 45 08             	mov    0x8(%ebp),%eax
    9a1c:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    9a1f:	c7 45 f0 40 00 00 00 	movl   $0x40,0xfffffff0(%ebp)
    9a26:	8b 45 0c             	mov    0xc(%ebp),%eax
    9a29:	8b 00                	mov    (%eax),%eax
    9a2b:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    9a2e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    9a31:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    9a34:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    9a37:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
    9a3a:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    9a3d:	3b 45 ec             	cmp    0xffffffec(%ebp),%eax
    9a40:	7e 06                	jle    9a48 <marshallAckProof+0x37>
    9a42:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    9a45:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
    9a48:	0f b6 45 e0          	movzbl 0xffffffe0(%ebp),%eax
    9a4c:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    9a4f:	88 02                	mov    %al,(%edx)
  for(i=0; i < dproof->numSacks; i++) {
    9a51:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
    9a58:	8b 45 08             	mov    0x8(%ebp),%eax
    9a5b:	0f b6 00             	movzbl (%eax),%eax
    9a5e:	39 45 f4             	cmp    %eax,0xfffffff4(%ebp)
    9a61:	7c 05                	jl     9a68 <marshallAckProof+0x57>
    9a63:	e9 a1 00 00 00       	jmp    9b09 <marshallAckProof+0xf8>
    HNCONVERTLONG(sacks[i].left);
    9a68:	8b 5d 08             	mov    0x8(%ebp),%ebx
    9a6b:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    9a6e:	89 d0                	mov    %edx,%eax
    9a70:	01 c0                	add    %eax,%eax
    9a72:	01 d0                	add    %edx,%eax
    9a74:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
    9a7b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    9a7e:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    9a81:	89 d0                	mov    %edx,%eax
    9a83:	01 c0                	add    %eax,%eax
    9a85:	01 d0                	add    %edx,%eax
    9a87:	c1 e0 02             	shl    $0x2,%eax
    9a8a:	01 c8                	add    %ecx,%eax
    9a8c:	83 c0 08             	add    $0x8,%eax
    9a8f:	8b 00                	mov    (%eax),%eax
    9a91:	89 04 24             	mov    %eax,(%esp,1)
    9a94:	e8 fc ff ff ff       	call   9a95 <marshallAckProof+0x84>
    9a99:	89 44 33 01          	mov    %eax,0x1(%ebx,%esi,1)
    HNCONVERTLONG(sacks[i].right);
    9a9d:	8b 5d 08             	mov    0x8(%ebp),%ebx
    9aa0:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    9aa3:	89 d0                	mov    %edx,%eax
    9aa5:	01 c0                	add    %eax,%eax
    9aa7:	01 d0                	add    %edx,%eax
    9aa9:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
    9ab0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    9ab3:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    9ab6:	89 d0                	mov    %edx,%eax
    9ab8:	01 c0                	add    %eax,%eax
    9aba:	01 d0                	add    %edx,%eax
    9abc:	c1 e0 02             	shl    $0x2,%eax
    9abf:	01 c8                	add    %ecx,%eax
    9ac1:	83 c0 0c             	add    $0xc,%eax
    9ac4:	8b 00                	mov    (%eax),%eax
    9ac6:	89 04 24             	mov    %eax,(%esp,1)
    9ac9:	e8 fc ff ff ff       	call   9aca <marshallAckProof+0xb9>
    9ace:	89 44 33 05          	mov    %eax,0x5(%ebx,%esi,1)
    COPYLONG(sacks[i].nonceSummary);
    9ad2:	8b 75 08             	mov    0x8(%ebp),%esi
    9ad5:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    9ad8:	89 d0                	mov    %edx,%eax
    9ada:	01 c0                	add    %eax,%eax
    9adc:	01 d0                	add    %edx,%eax
    9ade:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    9ae5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    9ae8:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    9aeb:	89 d0                	mov    %edx,%eax
    9aed:	01 c0                	add    %eax,%eax
    9aef:	01 d0                	add    %edx,%eax
    9af1:	c1 e0 02             	shl    $0x2,%eax
    9af4:	01 c8                	add    %ecx,%eax
    9af6:	83 c0 10             	add    $0x10,%eax
    9af9:	8b 00                	mov    (%eax),%eax
    9afb:	89 44 1e 09          	mov    %eax,0x9(%esi,%ebx,1)
    9aff:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
    9b02:	ff 00                	incl   (%eax)
    9b04:	e9 4f ff ff ff       	jmp    9a58 <marshallAckProof+0x47>
  }
#undef HNCONVERTLONG
#undef COPYLONG
}
    9b09:	83 c4 1c             	add    $0x1c,%esp
    9b0c:	5b                   	pop    %ebx
    9b0d:	5e                   	pop    %esi
    9b0e:	5d                   	pop    %ebp
    9b0f:	c3                   	ret    

00009b10 <unmarshallContinuationClient>:

#define NHCONVERTLONG(X) dcont->X = ntohl(scont->X);
#define COPYLONG(X) dcont->X = scont->X

struct sk_buff;
/* skb is used to initialize connection endpoint variables */

#define UNMARSHALL_CONTINUATION(SUFFIX, COMPUTE_MAC)			\
  static inline int unmarshallContinuation ## SUFFIX(struct sk_buff *skb, CONTINUATION_TYPE *dcont, const WireContinuation *scont) { \
    COMPUTE_MAC();							\
  dcont->continuationType = scont->continuationType;			\
  NHCONVERTLONG(seq); /* printk("dcont->seq = %d\n", dcont->seq); */	\
									\
  dcont->clientState = scont->clientState;				\
  dcont->parent = scont->parent;					\
									\
  dcont->rawTimestamp = scont->timestamp;				\
  dcont->timestamp = ntohl(scont->timestamp);				\
  dcont->clientTimestamp = scont->clientTimestamp;			\
  dcont->rawMrtt = scont->mrtt;						\
									\
  dcont->mrtt = ntohl(scont->mrtt);					\
  dcont->state = scont->state;						\
  dcont->firstChild = scont->firstChild;				\
									\
  /* printk("unmarshall - firstLoss: %p\n", &dcont->firstLoss); */	\
  NHCONVERTLONG(firstLoss);						\
  NHCONVERTLONG(firstBootstrapSeq);					\
  NHCONVERTLONG(startCwnd);						\
  NHCONVERTLONG(ssthresh);						\
  NHCONVERTLONG(TCPBase);						\
									\
  if(unlikely(!SIMULATION_MODE(skb->sk))) {				\
	  dcont->saddr = skb->nh.iph->daddr;				\
	  dcont->daddr = skb->nh.iph->saddr;				\
	  dcont->source = skb->h.th->dest;				\
	  dcont->dest = skb->h.th->source;				\
  }									\
  dcont->num_packets = 0;						\
									\
  dcont->tokenCounterBase = scont->tokenCounterBase;			\
									\
  dcont->numChildrenReceived = 0;					\
  dcont->parentMSK = NULL;						\
									\
  return 1;								\
}

#define MAC_VERIFY_PHDR()			\
	phdr->seq = scont->seq;					\
	phdr->type = scont->continuationType;			\
	phdr->first = scont->firstChild;			\
	phdr->serverAddr = skb->nh.iph->daddr;			\
	phdr->serverPort = skb->h.th->dest;			\
	phdr->clientAddr = skb->nh.iph->saddr;			\
	phdr->clientPort = skb->h.th->source

#define SERVER_COMPUTE_MAC()			\
do {						\
    if(unlikely(!SIMULATION_MODE(skb->sk))) {	\
	    char mac[HMACLEN];						\
	    PseudoHeader hdr, *phdr = &hdr;				\
	    MAC_VERIFY_PHDR();						\
									\
	    computeMAC(skb->sk, phdr, scont, mac);			\
	    if(memcmp(mac, scont->mac, HMACLEN)) {			\
		    printk("failed hmac comparison\n"); return 0;	\
	    }								\
    }						\
} while(0);

#define CLIENT_COMPUTE_MAC()			\
  do {					\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
UNMARSHALL_CONTINUATION(Client, CLIENT_COMPUTE_MAC);
    9b10:	55                   	push   %ebp
    9b11:	89 e5                	mov    %esp,%ebp
    9b13:	53                   	push   %ebx
    9b14:	83 ec 10             	sub    $0x10,%esp
    9b17:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp,1)
    9b1e:	00 
    9b1f:	8b 45 10             	mov    0x10(%ebp),%eax
    9b22:	83 c0 15             	add    $0x15,%eax
    9b25:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    9b29:	8b 45 0c             	mov    0xc(%ebp),%eax
    9b2c:	05 9c 00 00 00       	add    $0x9c,%eax
    9b31:	89 04 24             	mov    %eax,(%esp,1)
    9b34:	e8 21 23 00 00       	call   be5a <__constant_memcpy>
    9b39:	8b 55 0c             	mov    0xc(%ebp),%edx
    9b3c:	8b 45 10             	mov    0x10(%ebp),%eax
    9b3f:	0f b6 00             	movzbl (%eax),%eax
    9b42:	89 42 34             	mov    %eax,0x34(%edx)
    9b45:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9b48:	8b 45 10             	mov    0x10(%ebp),%eax
    9b4b:	8b 40 01             	mov    0x1(%eax),%eax
    9b4e:	89 04 24             	mov    %eax,(%esp,1)
    9b51:	e8 fc ff ff ff       	call   9b52 <unmarshallContinuationClient+0x42>
    9b56:	89 43 30             	mov    %eax,0x30(%ebx)
    9b59:	8b 55 0c             	mov    0xc(%ebp),%edx
    9b5c:	8b 45 10             	mov    0x10(%ebp),%eax
    9b5f:	8b 40 09             	mov    0x9(%eax),%eax
    9b62:	89 42 38             	mov    %eax,0x38(%edx)
    9b65:	8b 55 0c             	mov    0xc(%ebp),%edx
    9b68:	8b 45 10             	mov    0x10(%ebp),%eax
    9b6b:	8b 40 0d             	mov    0xd(%eax),%eax
    9b6e:	89 42 3c             	mov    %eax,0x3c(%edx)
    9b71:	8b 55 0c             	mov    0xc(%ebp),%edx
    9b74:	8b 45 10             	mov    0x10(%ebp),%eax
    9b77:	8b 40 25             	mov    0x25(%eax),%eax
    9b7a:	89 42 40             	mov    %eax,0x40(%edx)
    9b7d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9b80:	8b 45 10             	mov    0x10(%ebp),%eax
    9b83:	8b 40 25             	mov    0x25(%eax),%eax
    9b86:	89 04 24             	mov    %eax,(%esp,1)
    9b89:	e8 fc ff ff ff       	call   9b8a <unmarshallContinuationClient+0x7a>
    9b8e:	89 43 48             	mov    %eax,0x48(%ebx)
    9b91:	8b 55 0c             	mov    0xc(%ebp),%edx
    9b94:	8b 45 10             	mov    0x10(%ebp),%eax
    9b97:	8b 40 11             	mov    0x11(%eax),%eax
    9b9a:	89 42 4c             	mov    %eax,0x4c(%edx)
    9b9d:	8b 55 0c             	mov    0xc(%ebp),%edx
    9ba0:	8b 45 10             	mov    0x10(%ebp),%eax
    9ba3:	8b 40 29             	mov    0x29(%eax),%eax
    9ba6:	89 42 44             	mov    %eax,0x44(%edx)
    9ba9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9bac:	8b 45 10             	mov    0x10(%ebp),%eax
    9baf:	8b 40 29             	mov    0x29(%eax),%eax
    9bb2:	89 04 24             	mov    %eax,(%esp,1)
    9bb5:	e8 fc ff ff ff       	call   9bb6 <unmarshallContinuationClient+0xa6>
    9bba:	89 43 50             	mov    %eax,0x50(%ebx)
    9bbd:	8b 55 0c             	mov    0xc(%ebp),%edx
    9bc0:	8b 45 10             	mov    0x10(%ebp),%eax
    9bc3:	0f b6 40 2d          	movzbl 0x2d(%eax),%eax
    9bc7:	89 42 54             	mov    %eax,0x54(%edx)
    9bca:	8b 55 0c             	mov    0xc(%ebp),%edx
    9bcd:	8b 45 10             	mov    0x10(%ebp),%eax
    9bd0:	0f b6 40 05          	movzbl 0x5(%eax),%eax
    9bd4:	89 42 58             	mov    %eax,0x58(%edx)
    9bd7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9bda:	8b 45 10             	mov    0x10(%ebp),%eax
    9bdd:	8b 40 2e             	mov    0x2e(%eax),%eax
    9be0:	89 04 24             	mov    %eax,(%esp,1)
    9be3:	e8 fc ff ff ff       	call   9be4 <unmarshallContinuationClient+0xd4>
    9be8:	89 43 5c             	mov    %eax,0x5c(%ebx)
    9beb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9bee:	8b 45 10             	mov    0x10(%ebp),%eax
    9bf1:	8b 40 32             	mov    0x32(%eax),%eax
    9bf4:	89 04 24             	mov    %eax,(%esp,1)
    9bf7:	e8 fc ff ff ff       	call   9bf8 <unmarshallContinuationClient+0xe8>
    9bfc:	89 43 60             	mov    %eax,0x60(%ebx)
    9bff:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9c02:	8b 45 10             	mov    0x10(%ebp),%eax
    9c05:	8b 40 36             	mov    0x36(%eax),%eax
    9c08:	89 04 24             	mov    %eax,(%esp,1)
    9c0b:	e8 fc ff ff ff       	call   9c0c <unmarshallContinuationClient+0xfc>
    9c10:	89 43 64             	mov    %eax,0x64(%ebx)
    9c13:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9c16:	8b 45 10             	mov    0x10(%ebp),%eax
    9c19:	8b 40 3a             	mov    0x3a(%eax),%eax
    9c1c:	89 04 24             	mov    %eax,(%esp,1)
    9c1f:	e8 fc ff ff ff       	call   9c20 <unmarshallContinuationClient+0x110>
    9c24:	89 43 68             	mov    %eax,0x68(%ebx)
    9c27:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9c2a:	8b 45 10             	mov    0x10(%ebp),%eax
    9c2d:	8b 40 3e             	mov    0x3e(%eax),%eax
    9c30:	89 04 24             	mov    %eax,(%esp,1)
    9c33:	e8 fc ff ff ff       	call   9c34 <unmarshallContinuationClient+0x124>
    9c38:	89 43 6c             	mov    %eax,0x6c(%ebx)
    9c3b:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
    9c42:	8b 45 08             	mov    0x8(%ebp),%eax
    9c45:	8b 40 0c             	mov    0xc(%eax),%eax
    9c48:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    9c4e:	83 e0 01             	and    $0x1,%eax
    9c51:	85 c0                	test   %eax,%eax
    9c53:	74 21                	je     9c76 <unmarshallContinuationClient+0x166>
    9c55:	8b 45 08             	mov    0x8(%ebp),%eax
    9c58:	8b 50 0c             	mov    0xc(%eax),%edx
    9c5b:	8b 45 08             	mov    0x8(%ebp),%eax
    9c5e:	8b 40 0c             	mov    0xc(%eax),%eax
    9c61:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    9c67:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
    9c6d:	83 e0 08             	and    $0x8,%eax
    9c70:	85 c0                	test   %eax,%eax
    9c72:	75 02                	jne    9c76 <unmarshallContinuationClient+0x166>
    9c74:	eb 07                	jmp    9c7d <unmarshallContinuationClient+0x16d>
    9c76:	c7 45 f8 01 00 00 00 	movl   $0x1,0xfffffff8(%ebp)
    9c7d:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    9c81:	74 3f                	je     9cc2 <unmarshallContinuationClient+0x1b2>
    9c83:	8b 55 0c             	mov    0xc(%ebp),%edx
    9c86:	8b 45 08             	mov    0x8(%ebp),%eax
    9c89:	8b 40 24             	mov    0x24(%eax),%eax
    9c8c:	8b 40 10             	mov    0x10(%eax),%eax
    9c8f:	89 42 14             	mov    %eax,0x14(%edx)
    9c92:	8b 55 0c             	mov    0xc(%ebp),%edx
    9c95:	8b 45 08             	mov    0x8(%ebp),%eax
    9c98:	8b 40 24             	mov    0x24(%eax),%eax
    9c9b:	8b 40 0c             	mov    0xc(%eax),%eax
    9c9e:	89 42 18             	mov    %eax,0x18(%edx)
    9ca1:	8b 55 0c             	mov    0xc(%ebp),%edx
    9ca4:	8b 45 08             	mov    0x8(%ebp),%eax
    9ca7:	8b 40 20             	mov    0x20(%eax),%eax
    9caa:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    9cae:	66 89 42 1c          	mov    %ax,0x1c(%edx)
    9cb2:	8b 55 0c             	mov    0xc(%ebp),%edx
    9cb5:	8b 45 08             	mov    0x8(%ebp),%eax
    9cb8:	8b 40 20             	mov    0x20(%eax),%eax
    9cbb:	0f b7 00             	movzwl (%eax),%eax
    9cbe:	66 89 42 1e          	mov    %ax,0x1e(%edx)
    9cc2:	8b 45 0c             	mov    0xc(%ebp),%eax
    9cc5:	c7 80 e8 00 00 00 00 	movl   $0x0,0xe8(%eax)
    9ccc:	00 00 00 
    9ccf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    9cd2:	8b 45 10             	mov    0x10(%ebp),%eax
    9cd5:	8b 50 46             	mov    0x46(%eax),%edx
    9cd8:	8b 40 42             	mov    0x42(%eax),%eax
    9cdb:	89 41 70             	mov    %eax,0x70(%ecx)
    9cde:	89 51 74             	mov    %edx,0x74(%ecx)
    9ce1:	8b 45 0c             	mov    0xc(%ebp),%eax
    9ce4:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%eax)
    9ceb:	00 00 00 
    9cee:	8b 45 0c             	mov    0xc(%ebp),%eax
    9cf1:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%eax)
    9cf8:	00 00 00 
    9cfb:	b8 01 00 00 00       	mov    $0x1,%eax
    9d00:	83 c4 10             	add    $0x10,%esp
    9d03:	5b                   	pop    %ebx
    9d04:	5d                   	pop    %ebp
    9d05:	c3                   	ret    

00009d06 <SIMULATION_TOTAL_LEN>:

#undef SERVER_COMPUTE_MAC
#undef CLIENT_COMPUTE_MAC
#undef NHCONVERTLONG
#undef COPYLONG

extern int numContinuations;

#ifndef USERTEST
extern kmem_cache_t *clientSideContinuation_cache;
#endif


// Simulation accessors
#define SIMULATION_PACKETS(CONT)  (((CONT)+1)->packets)
#define SIMULATION_NUM_PACKETS(CONT)  (((CONT)+1)->num_packets)

static inline int SIMULATION_TOTAL_LEN(struct cminisock *cont) {
    9d06:	55                   	push   %ebp
    9d07:	89 e5                	mov    %esp,%ebp
    9d09:	83 ec 08             	sub    $0x8,%esp
	int i;
	int total = 0;
    9d0c:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)

	for(i=0; i < SIMULATION_NUM_PACKETS(cont); i++) {
    9d13:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
    9d1a:	8b 55 08             	mov    0x8(%ebp),%edx
    9d1d:	81 c2 fc 00 00 00    	add    $0xfc,%edx
    9d23:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    9d26:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
    9d2c:	7c 02                	jl     9d30 <SIMULATION_TOTAL_LEN+0x2a>
    9d2e:	eb 30                	jmp    9d60 <SIMULATION_TOTAL_LEN+0x5a>
		total += SIMULATION_PACKETS(cont)[i].len;
    9d30:	8b 4d 08             	mov    0x8(%ebp),%ecx
    9d33:	81 c1 fc 00 00 00    	add    $0xfc,%ecx
    9d39:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    9d3c:	89 d0                	mov    %edx,%eax
    9d3e:	c1 e0 03             	shl    $0x3,%eax
    9d41:	01 d0                	add    %edx,%eax
    9d43:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9d4a:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
    9d50:	8b 54 10 08          	mov    0x8(%eax,%edx,1),%edx
    9d54:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
    9d57:	01 10                	add    %edx,(%eax)
    9d59:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
    9d5c:	ff 00                	incl   (%eax)
    9d5e:	eb ba                	jmp    9d1a <SIMULATION_TOTAL_LEN+0x14>
	}

	return total;
    9d60:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
}
    9d63:	c9                   	leave  
    9d64:	c3                   	ret    

00009d65 <newClientSide_Continuation>:

#define ENCODE_SIMULATION_RESULT(CONT)		\
	((SIMULATION_TOTAL_LEN(CONT) & 0xffff) |	\
	 SIMULATION_NUM_PACKETS(CONT) << 16)

static inline void DECODE_SIMULATION_RESULT(__u32 value, int *pTotalLen, int *pNumPackets) {
	*pTotalLen = value & 0xffff;
	*pNumPackets = (value >> 16) & 0xffff;
}

#define USESLAB
#define INIT2

#define CLIENTSIDE_CONTINUATION_SIZE (2 * sizeof(CONTINUATION_TYPE))
static inline CONTINUATION_TYPE *newClientSide_Continuation(int flags) {
    9d65:	55                   	push   %ebp
    9d66:	89 e5                	mov    %esp,%ebp
    9d68:	83 ec 14             	sub    $0x14,%esp
  int i;
#ifdef USERTEST
  CONTINUATION_TYPE *rval = kmalloc(CLIENTSIDE_CONTINUATION_SIZE, flags);
#else
  CONTINUATION_TYPE *rval = kmem_cache_alloc(clientSideContinuation_cache, GFP_ATOMIC);
    9d6b:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    9d72:	00 
    9d73:	a1 00 00 00 00       	mov    0x0,%eax
    9d78:	89 04 24             	mov    %eax,(%esp,1)
    9d7b:	e8 fc ff ff ff       	call   9d7c <newClientSide_Continuation+0x17>
    9d80:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
#endif

#ifdef DEBUG_TRICKLES_ALLOCATION // 0418
  numContinuations++;
#endif

  if(rval == NULL) {
    9d83:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    9d87:	75 18                	jne    9da1 <newClientSide_Continuation+0x3c>
    printk("out of memory while allocating continuation\n");
    9d89:	c7 04 24 e0 38 00 00 	movl   $0x38e0,(%esp,1)
    9d90:	e8 fc ff ff ff       	call   9d91 <newClientSide_Continuation+0x2c>
    return NULL;
    9d95:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
    9d9c:	e9 fd 00 00 00       	jmp    9e9e <newClientSide_Continuation+0x139>
  }

  rval->prev = rval->next = NULL;
    9da1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9da4:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    9da7:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
    9dae:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  rval->list = NULL;
    9db4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9db7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
#ifdef INIT2 // 0502 - initialize only the first one (simulation is off)
  for(i=0; i < 2; i++) {
    9dbe:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
    9dc5:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
    9dc9:	7e 05                	jle    9dd0 <newClientSide_Continuation+0x6b>
    9dcb:	e9 be 00 00 00       	jmp    9e8e <newClientSide_Continuation+0x129>
#else
  for(i=0; i < 1; i++) {
#endif
	  (rval+i)->ucont_len = 0;
    9dd0:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    9dd3:	89 d0                	mov    %edx,%eax
    9dd5:	c1 e0 06             	shl    $0x6,%eax
    9dd8:	29 d0                	sub    %edx,%eax
    9dda:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9de1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9de4:	c7 44 10 78 00 00 00 	movl   $0x0,0x78(%eax,%edx,1)
    9deb:	00 
	  (rval+i)->ucont_data = NULL;
    9dec:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    9def:	89 d0                	mov    %edx,%eax
    9df1:	c1 e0 06             	shl    $0x6,%eax
    9df4:	29 d0                	sub    %edx,%eax
    9df6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9dfd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9e00:	c7 44 10 7c 00 00 00 	movl   $0x0,0x7c(%eax,%edx,1)
    9e07:	00 
	  (rval+i)->input_len = 0;
    9e08:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    9e0b:	89 d0                	mov    %edx,%eax
    9e0d:	c1 e0 06             	shl    $0x6,%eax
    9e10:	29 d0                	sub    %edx,%eax
    9e12:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9e19:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9e1c:	c7 84 10 94 00 00 00 	movl   $0x0,0x94(%eax,%edx,1)
    9e23:	00 00 00 00 
	  (rval+i)->input = NULL;
    9e27:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    9e2a:	89 d0                	mov    %edx,%eax
    9e2c:	c1 e0 06             	shl    $0x6,%eax
    9e2f:	29 d0                	sub    %edx,%eax
    9e31:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9e38:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9e3b:	c7 84 10 98 00 00 00 	movl   $0x0,0x98(%eax,%edx,1)
    9e42:	00 00 00 00 
	  // 0429 null mark
	  (rval+i)->mark = 0;
    9e46:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    9e49:	89 d0                	mov    %edx,%eax
    9e4b:	c1 e0 06             	shl    $0x6,%eax
    9e4e:	29 d0                	sub    %edx,%eax
    9e50:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9e57:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9e5a:	c7 84 10 e4 00 00 00 	movl   $0x0,0xe4(%eax,%edx,1)
    9e61:	00 00 00 00 
	  (rval+i)->simulated = 0;
    9e65:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    9e68:	89 d0                	mov    %edx,%eax
    9e6a:	c1 e0 06             	shl    $0x6,%eax
    9e6d:	29 d0                	sub    %edx,%eax
    9e6f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9e76:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9e79:	c7 84 10 d8 00 00 00 	movl   $0x0,0xd8(%eax,%edx,1)
    9e80:	00 00 00 00 
    9e84:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
    9e87:	ff 00                	incl   (%eax)
    9e89:	e9 37 ff ff ff       	jmp    9dc5 <newClientSide_Continuation+0x60>
  }
  rval->sk = NULL;
    9e8e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9e91:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  return rval;
    9e98:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9e9b:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
}
    9e9e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    9ea1:	c9                   	leave  
    9ea2:	c3                   	ret    

00009ea3 <copyClientSide_Continuation>:

static inline void *kmalloc_dup(void *src, int len, unsigned gfp) {
	char *ptr = kmalloc(len, gfp);
	if(ptr == NULL) {
		printk("out of memory in kmalloc_dup\n");
		return NULL;
	}
	memcpy(ptr, src, len);
	return ptr;
}

static inline CONTINUATION_TYPE *copyClientSide_Continuation(CONTINUATION_TYPE *cont, int flags) {
    9ea3:	55                   	push   %ebp
    9ea4:	89 e5                	mov    %esp,%ebp
    9ea6:	83 ec 18             	sub    $0x18,%esp
  int i;
#ifdef USERTEST
  CONTINUATION_TYPE *rval = kmalloc(2 * sizeof(CONTINUATION_TYPE), flags);
#else  //0426 - change kernel to slab cache
  CONTINUATION_TYPE *rval = kmem_cache_alloc(clientSideContinuation_cache, GFP_ATOMIC);
    9ea9:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    9eb0:	00 
    9eb1:	a1 00 00 00 00       	mov    0x0,%eax
    9eb6:	89 04 24             	mov    %eax,(%esp,1)
    9eb9:	e8 fc ff ff ff       	call   9eba <copyClientSide_Continuation+0x17>
    9ebe:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
#endif

#ifdef DEBUG_TRICKLES_ALLOCATION // 0418
  numContinuations++;
#endif

  // 0501 - attempting to track down corruption bug
#ifdef DEBUG_ALLOC
#ifndef USERTEST
  if(((int)rval) & 0xfff) {
	  printk("incorrect alignment\n");
	  BUG();
  }
#endif // USERTEST
#endif // DEBUG_ALLOC

  if(rval == NULL) {
    9ec1:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    9ec5:	75 18                	jne    9edf <copyClientSide_Continuation+0x3c>
    printk("out of memory while allocating continuation to copy\n");
    9ec7:	c7 04 24 20 39 00 00 	movl   $0x3920,(%esp,1)
    9ece:	e8 fc ff ff ff       	call   9ecf <copyClientSide_Continuation+0x2c>
    return NULL;
    9ed3:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
    9eda:	e9 4b 01 00 00       	jmp    a02a <copyClientSide_Continuation+0x187>
  }
  rval->prev = rval->next = NULL;
    9edf:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    9ee2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9ee5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    9eec:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  rval->list = NULL;
    9ef2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9ef5:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  memcpy(rval, cont, (int)((CONTINUATION_TYPE *)0)->clientside_copy_end);
    9efc:	c7 44 24 08 e8 00 00 	movl   $0xe8,0x8(%esp,1)
    9f03:	00 
    9f04:	8b 45 08             	mov    0x8(%ebp),%eax
    9f07:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    9f0b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9f0e:	89 04 24             	mov    %eax,(%esp,1)
    9f11:	e8 44 1f 00 00       	call   be5a <__constant_memcpy>
  for(i=0; i < 2; i++) {
    9f16:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
    9f1d:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
    9f21:	7e 05                	jle    9f28 <copyClientSide_Continuation+0x85>
    9f23:	e9 fc 00 00 00       	jmp    a024 <copyClientSide_Continuation+0x181>
#if 0 // 0812 - copy makes the code very slow, so rewrite to avoid the copy
	  (rval+i)->ucont_len = (cont+i)->ucont_len;
	  char *src_ucont = (cont+i)->ucont_data;
	  if(src_ucont != NULL) {
		  (rval+i)->ucont_data = kmalloc_dup(src_ucont, (rval+i)->ucont_len, GFP_ATOMIC);
	  } else {
		  (rval+i)->ucont_data = NULL;
	  }
#else
	  (rval+i)->ucont_len = 0;
    9f28:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    9f2b:	89 d0                	mov    %edx,%eax
    9f2d:	c1 e0 06             	shl    $0x6,%eax
    9f30:	29 d0                	sub    %edx,%eax
    9f32:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9f39:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9f3c:	c7 44 10 78 00 00 00 	movl   $0x0,0x78(%eax,%edx,1)
    9f43:	00 
	  (rval+i)->ucont_data = NULL;
    9f44:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    9f47:	89 d0                	mov    %edx,%eax
    9f49:	c1 e0 06             	shl    $0x6,%eax
    9f4c:	29 d0                	sub    %edx,%eax
    9f4e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9f55:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9f58:	c7 44 10 7c 00 00 00 	movl   $0x0,0x7c(%eax,%edx,1)
    9f5f:	00 
#endif
	  (rval+i)->input_len = 0;
    9f60:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    9f63:	89 d0                	mov    %edx,%eax
    9f65:	c1 e0 06             	shl    $0x6,%eax
    9f68:	29 d0                	sub    %edx,%eax
    9f6a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9f71:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9f74:	c7 84 10 94 00 00 00 	movl   $0x0,0x94(%eax,%edx,1)
    9f7b:	00 00 00 00 
	  (rval+i)->input = NULL;
    9f7f:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    9f82:	89 d0                	mov    %edx,%eax
    9f84:	c1 e0 06             	shl    $0x6,%eax
    9f87:	29 d0                	sub    %edx,%eax
    9f89:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9f90:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9f93:	c7 84 10 98 00 00 00 	movl   $0x0,0x98(%eax,%edx,1)
    9f9a:	00 00 00 00 
	  // 0429 null mark
	  (rval+i)->mark = 0;
    9f9e:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    9fa1:	89 d0                	mov    %edx,%eax
    9fa3:	c1 e0 06             	shl    $0x6,%eax
    9fa6:	29 d0                	sub    %edx,%eax
    9fa8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9faf:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9fb2:	c7 84 10 e4 00 00 00 	movl   $0x0,0xe4(%eax,%edx,1)
    9fb9:	00 00 00 00 
	  (rval+i)->simulated = 0;
    9fbd:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    9fc0:	89 d0                	mov    %edx,%eax
    9fc2:	c1 e0 06             	shl    $0x6,%eax
    9fc5:	29 d0                	sub    %edx,%eax
    9fc7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9fce:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9fd1:	c7 84 10 d8 00 00 00 	movl   $0x0,0xd8(%eax,%edx,1)
    9fd8:	00 00 00 00 
	  (rval+i)->num_packets = 0;
    9fdc:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    9fdf:	89 d0                	mov    %edx,%eax
    9fe1:	c1 e0 06             	shl    $0x6,%eax
    9fe4:	29 d0                	sub    %edx,%eax
    9fe6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9fed:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    9ff0:	c7 84 10 e8 00 00 00 	movl   $0x0,0xe8(%eax,%edx,1)
    9ff7:	00 00 00 00 
	  (rval+i)->actualCwnd = 0;
    9ffb:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    9ffe:	89 d0                	mov    %edx,%eax
    a000:	c1 e0 06             	shl    $0x6,%eax
    a003:	29 d0                	sub    %edx,%eax
    a005:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    a00c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    a00f:	c7 84 10 e0 00 00 00 	movl   $0x0,0xe0(%eax,%edx,1)
    a016:	00 00 00 00 
    a01a:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
    a01d:	ff 00                	incl   (%eax)
    a01f:	e9 f9 fe ff ff       	jmp    9f1d <copyClientSide_Continuation+0x7a>
  }
  //printk("copy rval = %p, input = %p\n", rval, cont);
  return rval;
    a024:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    a027:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
}
    a02a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    a02d:	c9                   	leave  
    a02e:	c3                   	ret    

0000a02f <freeClientSide_Continuation>:

#ifndef TRACE_FREE
static inline void freeClientSide_Continuation(CONTINUATION_TYPE *cont) {
    a02f:	55                   	push   %ebp
    a030:	89 e5                	mov    %esp,%ebp
    a032:	83 ec 0c             	sub    $0xc,%esp

#if 0
}
#endif

#else
#define CONT_POISON ((void*)0x7FFFFFFF)
#warning "Paranoid freeclientside continuation"

#define freeClientSide_Continuation(CONT) freeClientSide_ContinuationHelper((CONT), __FILE__, __LINE__)
 static inline void freeClientSide_ContinuationHelper(CONTINUATION_TYPE *cont, char *file, int lineno) {

#endif
#ifdef TRACE_FREE
  printk("freeingclientside %p @ (%s:%d)\n", cont, file, lineno);
#endif

  int i;

#ifdef TRACE_FREE
  if(cont->sk == CONT_POISON) {
	  printk("Warning: Continuation poisoned\n");
	  BUG();
  }
#endif // TRACE_FREE

#ifdef DEBUG_TRICKLES_ALLOCATION // 0418
  numContinuations--;
#endif
#ifdef DEBUG_ALLOC
#ifndef USERTEST
  if((int)cont & 0xfff) {
	  BUG();
  }
#endif // USERTEST
#endif // DEBUG_ALLOC

  if(cont->list) {
    a035:	8b 45 08             	mov    0x8(%ebp),%eax
    a038:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
    a03c:	74 25                	je     a063 <freeClientSide_Continuation+0x34>
	  BUG();
    a03e:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    a045:	00 
    a046:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    a04d:	e8 fc ff ff ff       	call   a04e <freeClientSide_Continuation+0x1f>
    a052:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    a059:	e8 fc ff ff ff       	call   a05a <freeClientSide_Continuation+0x2b>
    a05e:	e8 fc ff ff ff       	call   a05f <freeClientSide_Continuation+0x30>
  }

  for(i=0; i < 2; i++) {
    a063:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
    a06a:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
    a06e:	7e 05                	jle    a075 <freeClientSide_Continuation+0x46>
    a070:	e9 86 00 00 00       	jmp    a0fb <freeClientSide_Continuation+0xcc>
    if((cont+i)->ucont_data)
    a075:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    a078:	89 d0                	mov    %edx,%eax
    a07a:	c1 e0 06             	shl    $0x6,%eax
    a07d:	29 d0                	sub    %edx,%eax
    a07f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    a086:	8b 45 08             	mov    0x8(%ebp),%eax
    a089:	83 7c 10 7c 00       	cmpl   $0x0,0x7c(%eax,%edx,1)
    a08e:	74 20                	je     a0b0 <freeClientSide_Continuation+0x81>
      kfree((cont+i)->ucont_data);
    a090:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    a093:	89 d0                	mov    %edx,%eax
    a095:	c1 e0 06             	shl    $0x6,%eax
    a098:	29 d0                	sub    %edx,%eax
    a09a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    a0a1:	8b 45 08             	mov    0x8(%ebp),%eax
    a0a4:	8b 44 10 7c          	mov    0x7c(%eax,%edx,1),%eax
    a0a8:	89 04 24             	mov    %eax,(%esp,1)
    a0ab:	e8 fc ff ff ff       	call   a0ac <freeClientSide_Continuation+0x7d>
    if((cont+i)->input)
    a0b0:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    a0b3:	89 d0                	mov    %edx,%eax
    a0b5:	c1 e0 06             	shl    $0x6,%eax
    a0b8:	29 d0                	sub    %edx,%eax
    a0ba:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    a0c1:	8b 45 08             	mov    0x8(%ebp),%eax
    a0c4:	83 bc 10 98 00 00 00 	cmpl   $0x0,0x98(%eax,%edx,1)
    a0cb:	00 
    a0cc:	74 23                	je     a0f1 <freeClientSide_Continuation+0xc2>
      kfree((cont+i)->input);
    a0ce:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    a0d1:	89 d0                	mov    %edx,%eax
    a0d3:	c1 e0 06             	shl    $0x6,%eax
    a0d6:	29 d0                	sub    %edx,%eax
    a0d8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    a0df:	8b 45 08             	mov    0x8(%ebp),%eax
    a0e2:	8b 84 10 98 00 00 00 	mov    0x98(%eax,%edx,1),%eax
    a0e9:	89 04 24             	mov    %eax,(%esp,1)
    a0ec:	e8 fc ff ff ff       	call   a0ed <freeClientSide_Continuation+0xbe>
    a0f1:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
    a0f4:	ff 00                	incl   (%eax)
    a0f6:	e9 6f ff ff ff       	jmp    a06a <freeClientSide_Continuation+0x3b>
  }
  // poison
#ifdef TRACE_FREE
  cont->sk = CONT_POISON;
#endif // TRACE_FREE

#ifdef USERTEST
  kfree(cont);
#else  //0426 - change kernel to slab cache
#ifdef DEBUG_ALLOC
  zap_virt(cont);
  //memset(cont, 0x3e, sizeof(*cont));
#else
#ifndef USESLAB
  kfree(cont);  // 0502 maybe slab cache usage is buggy
#else
  kmem_cache_free(clientSideContinuation_cache, cont);
    a0fb:	8b 45 08             	mov    0x8(%ebp),%eax
    a0fe:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    a102:	a1 00 00 00 00       	mov    0x0,%eax
    a107:	89 04 24             	mov    %eax,(%esp,1)
    a10a:	e8 fc ff ff ff       	call   a10b <freeClientSide_Continuation+0xdc>
#endif
#endif
#endif
}
    a10f:	c9                   	leave  
    a110:	c3                   	ret    

0000a111 <unmarshallUC_Continuation>:

static inline void unmarshallAckProof(AckProof *dproof, const WireAckProof *sproof) {
#define NHCONVERTLONG(X) dproof->X = ntohl(sproof->X);
#define COPYLONG(X) dproof->X = sproof->X
  int i;
  dproof->numSacks = sproof->numSacks;
  for(i=0; i < sproof->numSacks; i++) {
    NHCONVERTLONG(sacks[i].left);
    NHCONVERTLONG(sacks[i].right);
    COPYLONG(sacks[i].nonceSummary);
  }
#undef NHCONVERTLONG
#undef COPYLONG
}

static inline struct UC_Continuation *unmarshallUC_Continuation(struct WireUC_Continuation *scont, unsigned length) {
    a111:	55                   	push   %ebp
    a112:	89 e5                	mov    %esp,%ebp
    a114:	53                   	push   %ebx
    a115:	83 ec 18             	sub    $0x18,%esp
  unsigned dataLen = length - sizeof(struct WireUC_Continuation);
    a118:	8b 45 0c             	mov    0xc(%ebp),%eax
    a11b:	83 e8 0d             	sub    $0xd,%eax
    a11e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  struct UC_Continuation *rval = kmalloc(sizeof(struct UC_Continuation) + dataLen, GFP_ATOMIC);
    a121:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    a128:	00 
    a129:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    a12c:	83 c0 30             	add    $0x30,%eax
    a12f:	89 04 24             	mov    %eax,(%esp,1)
    a132:	e8 fc ff ff ff       	call   a133 <unmarshallUC_Continuation+0x22>
    a137:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

  if(rval == NULL) {
    a13a:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
    a13e:	75 18                	jne    a158 <unmarshallUC_Continuation+0x47>
    printk("Out of memory while unmarshalling UC_Continuation\n");
    a140:	c7 04 24 60 39 00 00 	movl   $0x3960,(%esp,1)
    a147:	e8 fc ff ff ff       	call   a148 <unmarshallUC_Continuation+0x37>
    return NULL;
    a14c:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
    a153:	e9 9f 00 00 00       	jmp    a1f7 <unmarshallUC_Continuation+0xe6>
  }
  rval->prev = rval->next = NULL;
    a158:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    a15b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    a15e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    a165:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  rval->list = NULL;
    a16b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    a16e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  rval->seq = ntohl(scont->seq);
    a175:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
    a178:	8b 45 08             	mov    0x8(%ebp),%eax
    a17b:	8b 00                	mov    (%eax),%eax
    a17d:	89 04 24             	mov    %eax,(%esp,1)
    a180:	e8 fc ff ff ff       	call   a181 <unmarshallUC_Continuation+0x70>
    a185:	89 43 0c             	mov    %eax,0xc(%ebx)
  rval->validStart = ntohl(scont->validStart);
    a188:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
    a18b:	8b 45 08             	mov    0x8(%ebp),%eax
    a18e:	8b 40 04             	mov    0x4(%eax),%eax
    a191:	89 04 24             	mov    %eax,(%esp,1)
    a194:	e8 fc ff ff ff       	call   a195 <unmarshallUC_Continuation+0x84>
    a199:	89 43 10             	mov    %eax,0x10(%ebx)
  rval->validEnd = ntohl(scont->validEnd);
    a19c:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
    a19f:	8b 45 08             	mov    0x8(%ebp),%eax
    a1a2:	8b 40 08             	mov    0x8(%eax),%eax
    a1a5:	89 04 24             	mov    %eax,(%esp,1)
    a1a8:	e8 fc ff ff ff       	call   a1a9 <unmarshallUC_Continuation+0x98>
    a1ad:	89 43 14             	mov    %eax,0x14(%ebx)
  rval->fields = scont->fields;
    a1b0:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    a1b3:	8b 45 08             	mov    0x8(%ebp),%eax
    a1b6:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
    a1ba:	88 42 20             	mov    %al,0x20(%edx)
  rval->dataLen = dataLen;
    a1bd:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    a1c0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    a1c3:	89 42 28             	mov    %eax,0x28(%edx)
  rval->kernel.obsoleteAt = rval->validEnd;
    a1c6:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    a1c9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    a1cc:	8b 40 14             	mov    0x14(%eax),%eax
    a1cf:	89 42 2c             	mov    %eax,0x2c(%edx)
  memcpy(rval->kernel.data, scont->data, dataLen);
    a1d2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    a1d5:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    a1d9:	8b 45 08             	mov    0x8(%ebp),%eax
    a1dc:	83 c0 0d             	add    $0xd,%eax
    a1df:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    a1e3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    a1e6:	83 c0 30             	add    $0x30,%eax
    a1e9:	89 04 24             	mov    %eax,(%esp,1)
    a1ec:	e8 21 ea ff ff       	call   8c12 <__memcpy>
  return rval;
    a1f1:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    a1f4:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
}
    a1f7:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    a1fa:	83 c4 18             	add    $0x18,%esp
    a1fd:	5b                   	pop    %ebx
    a1fe:	5d                   	pop    %ebp
    a1ff:	c3                   	ret    

0000a200 <marshallUC_Continuation>:

static inline unsigned marshallUC_Continuation(struct WireUC_Continuation *dcont, struct UC_Continuation *scont) {
    a200:	55                   	push   %ebp
    a201:	89 e5                	mov    %esp,%ebp
    a203:	53                   	push   %ebx
    a204:	83 ec 10             	sub    $0x10,%esp
  int dataLen = scont->dataLen;
    a207:	8b 45 0c             	mov    0xc(%ebp),%eax
    a20a:	8b 40 28             	mov    0x28(%eax),%eax
    a20d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  dcont->seq = htonl(scont->seq);
    a210:	8b 5d 08             	mov    0x8(%ebp),%ebx
    a213:	8b 45 0c             	mov    0xc(%ebp),%eax
    a216:	8b 40 0c             	mov    0xc(%eax),%eax
    a219:	89 04 24             	mov    %eax,(%esp,1)
    a21c:	e8 fc ff ff ff       	call   a21d <marshallUC_Continuation+0x1d>
    a221:	89 03                	mov    %eax,(%ebx)
  dcont->validStart = htonl(scont->validStart);
    a223:	8b 5d 08             	mov    0x8(%ebp),%ebx
    a226:	8b 45 0c             	mov    0xc(%ebp),%eax
    a229:	8b 40 10             	mov    0x10(%eax),%eax
    a22c:	89 04 24             	mov    %eax,(%esp,1)
    a22f:	e8 fc ff ff ff       	call   a230 <marshallUC_Continuation+0x30>
    a234:	89 43 04             	mov    %eax,0x4(%ebx)
  dcont->validEnd = htonl(scont->validEnd);
    a237:	8b 5d 08             	mov    0x8(%ebp),%ebx
    a23a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a23d:	8b 40 14             	mov    0x14(%eax),%eax
    a240:	89 04 24             	mov    %eax,(%esp,1)
    a243:	e8 fc ff ff ff       	call   a244 <marshallUC_Continuation+0x44>
    a248:	89 43 08             	mov    %eax,0x8(%ebx)
  dcont->fields = scont->fields;
    a24b:	8b 55 08             	mov    0x8(%ebp),%edx
    a24e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a251:	0f b6 40 20          	movzbl 0x20(%eax),%eax
    a255:	88 42 0c             	mov    %al,0xc(%edx)
  memcpy(dcont->data, scont->kernel.data, dataLen);
    a258:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    a25b:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    a25f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a262:	83 c0 30             	add    $0x30,%eax
    a265:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    a269:	8b 45 08             	mov    0x8(%ebp),%eax
    a26c:	83 c0 0d             	add    $0xd,%eax
    a26f:	89 04 24             	mov    %eax,(%esp,1)
    a272:	e8 9b e9 ff ff       	call   8c12 <__memcpy>
  return sizeof(*dcont) + dataLen;
    a277:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    a27a:	83 c0 0d             	add    $0xd,%eax
}
    a27d:	83 c4 10             	add    $0x10,%esp
    a280:	5b                   	pop    %ebx
    a281:	5d                   	pop    %ebp
    a282:	c3                   	ret    

0000a283 <copyUC_Continuation>:

static inline void WireUC_addDependency(struct WireUC_Continuation *completeResp, struct UC_DependencyLink *dep) {
  printk("Dependency handling not complete\n");
  BUG();
  completeResp->fields |= (0x01);
  /* and more stuff */
  /* ... */
}

static inline struct UC_Continuation *copyUC_Continuation(struct UC_Continuation *scont) {
    a283:	55                   	push   %ebp
    a284:	89 e5                	mov    %esp,%ebp
    a286:	83 ec 18             	sub    $0x18,%esp
  /* create a separate copy */
  int dataLen = scont->dataLen;
    a289:	8b 45 08             	mov    0x8(%ebp),%eax
    a28c:	8b 40 28             	mov    0x28(%eax),%eax
    a28f:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  struct UC_Continuation *rval = kmalloc(sizeof(*rval) + dataLen, GFP_ATOMIC);
    a292:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    a299:	00 
    a29a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    a29d:	83 c0 30             	add    $0x30,%eax
    a2a0:	89 04 24             	mov    %eax,(%esp,1)
    a2a3:	e8 fc ff ff ff       	call   a2a4 <copyUC_Continuation+0x21>
    a2a8:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  if(rval == NULL) {
    a2ab:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    a2af:	75 18                	jne    a2c9 <copyUC_Continuation+0x46>
    printk("Out of memory while copying UC_Continuation\n");
    a2b1:	c7 04 24 a0 39 00 00 	movl   $0x39a0,(%esp,1)
    a2b8:	e8 fc ff ff ff       	call   a2b9 <copyUC_Continuation+0x36>
    return NULL;
    a2bd:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
    a2c4:	e9 8e 00 00 00       	jmp    a357 <copyUC_Continuation+0xd4>
  }
  *rval = *scont;
    a2c9:	8b 4d f8             	mov    0xfffffff8(%ebp),%ecx
    a2cc:	8b 55 08             	mov    0x8(%ebp),%edx
    a2cf:	8b 02                	mov    (%edx),%eax
    a2d1:	89 01                	mov    %eax,(%ecx)
    a2d3:	8b 42 04             	mov    0x4(%edx),%eax
    a2d6:	89 41 04             	mov    %eax,0x4(%ecx)
    a2d9:	8b 42 08             	mov    0x8(%edx),%eax
    a2dc:	89 41 08             	mov    %eax,0x8(%ecx)
    a2df:	8b 42 0c             	mov    0xc(%edx),%eax
    a2e2:	89 41 0c             	mov    %eax,0xc(%ecx)
    a2e5:	8b 42 10             	mov    0x10(%edx),%eax
    a2e8:	89 41 10             	mov    %eax,0x10(%ecx)
    a2eb:	8b 42 14             	mov    0x14(%edx),%eax
    a2ee:	89 41 14             	mov    %eax,0x14(%ecx)
    a2f1:	8b 42 18             	mov    0x18(%edx),%eax
    a2f4:	89 41 18             	mov    %eax,0x18(%ecx)
    a2f7:	8b 42 1c             	mov    0x1c(%edx),%eax
    a2fa:	89 41 1c             	mov    %eax,0x1c(%ecx)
    a2fd:	8b 42 20             	mov    0x20(%edx),%eax
    a300:	89 41 20             	mov    %eax,0x20(%ecx)
    a303:	8b 42 24             	mov    0x24(%edx),%eax
    a306:	89 41 24             	mov    %eax,0x24(%ecx)
    a309:	8b 42 28             	mov    0x28(%edx),%eax
    a30c:	89 41 28             	mov    %eax,0x28(%ecx)
    a30f:	8b 42 2c             	mov    0x2c(%edx),%eax
    a312:	89 41 2c             	mov    %eax,0x2c(%ecx)
  rval->prev = rval->next = NULL;
    a315:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    a318:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    a31b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    a322:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  rval->list = NULL;
    a328:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    a32b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  memcpy(rval->kernel.data, scont->kernel.data, dataLen);
    a332:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    a335:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    a339:	8b 45 08             	mov    0x8(%ebp),%eax
    a33c:	83 c0 30             	add    $0x30,%eax
    a33f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    a343:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    a346:	83 c0 30             	add    $0x30,%eax
    a349:	89 04 24             	mov    %eax,(%esp,1)
    a34c:	e8 c1 e8 ff ff       	call   8c12 <__memcpy>
  return rval;
    a351:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    a354:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
}
    a357:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    a35a:	c9                   	leave  
    a35b:	c3                   	ret    

0000a35c <freeDependencyNode>:

static inline struct UC_DependencyLink *unmarshallUC_Dependency(struct sock *sk, struct WireUC_Dependency *sdep) {
#if 0
  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
  struct UC_Dependency *rval, *currDep;
  int i;
  /* scan through sk to see if any dependencies can be resolved */
  /* May return pointer to existing dependency */

  if(sdep->pred.start > sdep->pred.end ||
     sdep->succ.start > sdep->succ.end) { 
      printk("unmarshallUC_Dependency: bad dep\n"); 
      return NULL;
  }
  rval = kmalloc(sizeof(struct UC_Dependency), GFP_ATOMIC);
  if(rval == NULL) {
    printk("Out of memory while unmarshalling UC Dependency\n");
    return NULL;
  }
  rval->prev = rval->next = NULL;
  rval->list = NULL;
  rval->refCnt = 1;

  rval->start = ntohl(sdep->succ.start);
  rval->end = ntohl(sdep->succ.end);

  initVector(&rval->vec);
#else
  printk("Dependency management doesn't work yet\n");
  BUG();
  return NULL;
#endif
}

static inline int freeDependencyNode(struct sock *sk, struct UC_DependencyNode *dep) {
    a35c:	55                   	push   %ebp
    a35d:	89 e5                	mov    %esp,%ebp
    a35f:	83 ec 08             	sub    $0x8,%esp
#if 0
  dep->refCnt--;
  if(dep->refCnt == 0) {
    if(dep->list) {
      unlink(dep);
    }
    kfree(dep);
    return 0;
  }
  return dep->refCnt;
#else
  printk("Dependency management doesn't work yet\n");
    a362:	c7 04 24 e0 39 00 00 	movl   $0x39e0,(%esp,1)
    a369:	e8 fc ff ff ff       	call   a36a <freeDependencyNode+0xe>
  BUG();
    a36e:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp,1)
    a375:	00 
    a376:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp,1)
    a37d:	e8 fc ff ff ff       	call   a37e <freeDependencyNode+0x22>
    a382:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    a389:	e8 fc ff ff ff       	call   a38a <freeDependencyNode+0x2e>
    a38e:	e8 fc ff ff ff       	call   a38f <freeDependencyNode+0x33>
  return -1;
    a393:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
#endif
}
    a398:	c9                   	leave  
    a399:	c3                   	ret    

0000a39a <GenerateDataContext_init>:

static inline struct UC_DependencyNode *copyUC_DependencyNode(struct UC_DependencyNode *sdep) {
#if 0
  int i;
  struct UC_Dependency *rval = kmalloc(sizeof(struct UC_Dependency), GFP_ATOMIC);
  if(rval == NULL) {
    printk("Out of memory while copying UC_Dependency\n");
    return NULL;
  }
  *rval = *sdep;
  rval->prev = rval->next = NULL;
  rval->list = NULL;
  rval->deps = kmalloc(sizeof(struct UC_Continuation*) * rval->maxDeps, GFP_ATOMIC);
  if(rval->deps == NULL) {
    printk("Out of memory while copying UC_Dependency\n");
    kfree(rval);
    return NULL;
  }
  for(i=0; i < rval->numDeps; i++) {
    rval->deps[i] = sdep->deps[i];
    rval->deps[i]->refCnt++;
  }
  return rval;
#else
  printk("Dependency management doesn't work yet\n");
  BUG();
  return NULL;
#endif
}

static inline 
void updateUC_ContinuationAndDependency(struct UC_Continuation *cont, struct UC_DependencyNode *dep) {
#if 0
/* called when resolving old dependency chains when new continuations
   are inserted called when inserting new dependencies */
  BUG_TRAP(dep->start >= cont->validStart && dep->end <= cont->validEnd);
  BUG_TRAP(!dep->resolved && dep->cont == NULL);
  dep->resolved = 1;
  dep->cont = cont;
  cont->kernel.obsoleteAt = MAX(cont->kernel.obsoleteAt, dep->end);
#else
  printk("Dependency management doesn't work yet\n");
  BUG();
#endif
}

static inline int addDependencyLink(struct UC_DependencyNode *changedDep, struct UC_DependencyLink *newLink) {
#if 0
  if(changedDep->numDeps < changedDep->maxDeps) {
    changedDep->deps[changedDep->numDeps++] = newDep;
  } else {
    /* Resize */
    struct UC_Dependency *resizedDeps[];
    int newSize = changedDep->maxDeps * 2;

    resizedDeps = kmalloc(newSize * sizeof(UC_Dependency*), GFP_ATOMIC);
    if(resizedDeps == NULL) {
      printk("Out of memory while adding dependency link\n");
      return -1;
    }
    memcpy(resizedDeps, changedDep->deps, changedDep->numDeps * sizeof(UC_Dependency*));
    kfree(changedDep->deps);
    changedDep->deps = resizedDeps;
    changedDep->deps[changedDep->numDeps++] = newDep;
    changedDep->maxDeps = newSize;
  }
  newDep->refCnt++;
  return 0;
#else
  printk("Dependency management doesn't work yet\n");
  BUG();
  return -1;
#endif
}
#endif // __KERNEL__

/* HELPER FUNCTIONS FOR USER SPACE CODE */

static inline 
void WireUC_clearFields(struct WireUC_Continuation *wireContinuation) {
  wireContinuation->fields = 0;
}

static inline void *WireUC_getDataStart(struct WireUC_Continuation *wireContinuation) {
  char *rval = wireContinuation->data;
  /* get start of data area, taking into account the variable header length */
  if(wireContinuation->fields & FIELD_DEPS) {
    printk("getWireUC_dataStart: no dependency support\n");
    BUG();
  }
  if(wireContinuation->fields & ~FIELD_ALL) {
    printk("getWireUC_dataStart: unknown field\n");
    BUG();
  }

  /* perform necessary adjustments on rval here */
  return rval;
}

static inline void initResponseHeader(struct WireUC_RespHeader *resp, enum UC_Type type, int error, unsigned len) {
  resp->type = type;
  resp->error = error;
  resp->len = htons((short)len);
}

static inline void initIncompleteResponse(struct WireUC_CVT_IncompleteResponse *incompleteResp, unsigned ack_seq, int error, 
			    unsigned validStart, unsigned convContLen) {
  initResponseHeader((struct WireUC_RespHeader *)incompleteResp, UC_INCOMPLETE,
		     error, 
		     sizeof(struct WireUC_CVT_IncompleteResponse) + convContLen);
  incompleteResp->ack_seq = htonl(ack_seq);
  incompleteResp->newCont.validStart = htonl(validStart);
}

static inline void initCompleteResponse(struct WireUC_CVT_CompleteResponse *completeResp, unsigned ack_seq, 
					unsigned convContLen, unsigned seq, unsigned validStart, unsigned validEnd) {
  initResponseHeader((struct WireUC_RespHeader *)completeResp, UC_COMPLETE,
		     0, 
		     sizeof(struct WireUC_CVT_CompleteResponse) + convContLen);
  completeResp->ack_seq = htonl(ack_seq);
  completeResp->newCont.seq = htonl(seq);
  completeResp->newCont.validStart = htonl(validStart);
  completeResp->newCont.validEnd = htonl(validEnd);
  completeResp->newCont.fields = 0;
}

static inline void initNewContinuationResponse(struct WireUC_NewContinuationResponse *newContinuationResp, 
					       unsigned contLen, unsigned seq, unsigned validStart, unsigned validEnd) {
	initResponseHeader((struct WireUC_RespHeader*)newContinuationResp, UC_NEWCONT,
			   0,
			   sizeof(struct WireUC_NewContinuationResponse) + contLen);
	newContinuationResp->newCont.seq = htonl(seq);
	newContinuationResp->newCont.validStart = htonl(validStart);
	newContinuationResp->newCont.validEnd = htonl(validEnd);
	newContinuationResp->newCont.fields = 0;
}

#ifdef __KERNEL__
 static inline void UC_Continuation_dump(struct UC_Continuation *ucont) {
	 printk("seq=[%d]\n", ucont->seq);
	 printk("valid=[%d-%d] [%d-%d]\n", ucont->validStart, ucont->validEnd,
		htonl(ucont->validStart), htonl(ucont->validEnd));
	 printk("cvalid=[%d-%d] [%d-%d]\n", ucont->clientValidStart, ucont->clientValidEnd,
		htonl(ucont->clientValidStart), htonl(ucont->clientValidEnd));
}
#endif // __KERNEL__

static inline struct DataChunk *
data_buildChunkHeader(struct DataChunk *chunk, int byteNum, int chunkLen) {
	BUG_TRAP(! (chunkLen & ~0xffff));
	chunk->byteNum = htonl(byteNum);
	chunk->type = RCHUNK_DATA;
	chunk->chunkLen = htons(chunkLen + sizeof(struct DataChunk));
	// return pointer to next datachunk
	return (struct DataChunk *) (chunk->data + chunkLen);
 }

static inline struct RequestChunk *
pushhint_buildChunkHeader(struct RequestChunk *chunk, int start, int end) {
	struct PushHintChunk *phchunk = (struct PushHintChunk *) chunk;
	phchunk->type = RCHUNK_PUSH_HINT;
	phchunk->chunkLen = htons(sizeof(struct PushHintChunk));
	phchunk->start = htonl(start);
	phchunk->end = htonl(end);
	
	// return pointer to next chunk
	return (struct RequestChunk *) (phchunk+1);
 }
//
// Helper routines for properly striping range responses across multiple packets
//
struct GenerateDataContext {
	int packetNum;
	int packetPos;
	char *outputStart;
	char *outputPos;

	struct cminisock_packet *packets;
	int numPackets;
};

static inline
void GenerateDataContext_init(struct GenerateDataContext *ctx, char *dest, 
			      struct cminisock_packet *packets, int numPackets) {
    a39a:	55                   	push   %ebp
    a39b:	89 e5                	mov    %esp,%ebp
	ctx->packetNum = 0;
    a39d:	8b 45 08             	mov    0x8(%ebp),%eax
    a3a0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	ctx->packetPos = 0;
    a3a6:	8b 45 08             	mov    0x8(%ebp),%eax
    a3a9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	ctx->outputPos = ctx->outputStart = dest;
    a3b0:	8b 4d 08             	mov    0x8(%ebp),%ecx
    a3b3:	8b 55 08             	mov    0x8(%ebp),%edx
    a3b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    a3b9:	89 42 08             	mov    %eax,0x8(%edx)
    a3bc:	89 41 0c             	mov    %eax,0xc(%ecx)
	ctx->packets = packets;
    a3bf:	8b 55 08             	mov    0x8(%ebp),%edx
    a3c2:	8b 45 10             	mov    0x10(%ebp),%eax
    a3c5:	89 42 10             	mov    %eax,0x10(%edx)
	ctx->numPackets = numPackets;
    a3c8:	8b 55 08             	mov    0x8(%ebp),%edx
    a3cb:	8b 45 14             	mov    0x14(%ebp),%eax
    a3ce:	89 42 14             	mov    %eax,0x14(%edx)
}
    a3d1:	5d                   	pop    %ebp
    a3d2:	c3                   	ret    

0000a3d3 <GenerateDataContext_put>:

static inline
void GenerateDataContext_describePackets(struct GenerateDataContext *ctx) {
	int i;
	for(i=0; i < ctx->numPackets; i++) {
		printk("Packet [%d] = %d\n", i, ctx->packets[i].len);
	}
}

static inline
void GenerateDataContext_dump(struct GenerateDataContext *ctx) {
	printk("\tPacketNum = %d\n\tPacketPos = %d\n\tOutputPos = %p\n\tnumPackets = %d\n\tpackets = %p\n",
	       ctx->packetNum, ctx->packetPos, ctx->outputPos, ctx->numPackets, ctx->packets);
}

static inline
int GenerateDataContext_packetSpace(struct GenerateDataContext *ctx) {
	if(ctx->packetNum >= ctx->numPackets) {
		return 0;
	}
	return ctx->packets[ctx->packetNum].len - ctx->packetPos;
}

static inline
char *GenerateDataContext_put(struct GenerateDataContext *ctx, int numBytes) {
    a3d3:	55                   	push   %ebp
    a3d4:	89 e5                	mov    %esp,%ebp
    a3d6:	57                   	push   %edi
    a3d7:	56                   	push   %esi
    a3d8:	53                   	push   %ebx
    a3d9:	83 ec 14             	sub    $0x14,%esp
#define CHECK_OUT_OF_SPACE()				\
	do {						\
		if(ctx->packetNum >= ctx->numPackets) {	\
			/* out of space */		\
			return NULL;			\
		}					\
	} while(0)

	if(numBytes == 0) return ctx->outputPos;
    a3dc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    a3e0:	75 0e                	jne    a3f0 <GenerateDataContext_put+0x1d>
    a3e2:	8b 45 08             	mov    0x8(%ebp),%eax
    a3e5:	8b 40 0c             	mov    0xc(%eax),%eax
    a3e8:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    a3eb:	e9 9e 01 00 00       	jmp    a58e <GenerateDataContext_put+0x1bb>

	CHECK_OUT_OF_SPACE();
    a3f0:	8b 45 08             	mov    0x8(%ebp),%eax
    a3f3:	8b 55 08             	mov    0x8(%ebp),%edx
    a3f6:	8b 00                	mov    (%eax),%eax
    a3f8:	3b 42 14             	cmp    0x14(%edx),%eax
    a3fb:	7c 0c                	jl     a409 <GenerateDataContext_put+0x36>
    a3fd:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
    a404:	e9 85 01 00 00       	jmp    a58e <GenerateDataContext_put+0x1bb>

	if(!(ctx->packetNum <= ctx->numPackets)) {
    a409:	8b 45 08             	mov    0x8(%ebp),%eax
    a40c:	8b 55 08             	mov    0x8(%ebp),%edx
    a40f:	8b 00                	mov    (%eax),%eax
    a411:	3b 42 14             	cmp    0x14(%edx),%eax
    a414:	7e 40                	jle    a456 <GenerateDataContext_put+0x83>
		BUG_TRAP(ctx->packetNum <= ctx->numPackets);
    a416:	8b 45 08             	mov    0x8(%ebp),%eax
    a419:	8b 55 08             	mov    0x8(%ebp),%edx
    a41c:	8b 00                	mov    (%eax),%eax
    a41e:	3b 42 14             	cmp    0x14(%edx),%eax
    a421:	7e 14                	jle    a437 <GenerateDataContext_put+0x64>
    a423:	c7 44 24 04 ee 02 00 	movl   $0x2ee,0x4(%esp,1)
    a42a:	00 
    a42b:	c7 04 24 20 3a 00 00 	movl   $0x3a20,(%esp,1)
    a432:	e8 fc ff ff ff       	call   a433 <GenerateDataContext_put+0x60>
		printk("%d !<= %d\n", ctx->packetNum, ctx->numPackets);
    a437:	8b 45 08             	mov    0x8(%ebp),%eax
    a43a:	8b 40 14             	mov    0x14(%eax),%eax
    a43d:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    a441:	8b 45 08             	mov    0x8(%ebp),%eax
    a444:	8b 00                	mov    (%eax),%eax
    a446:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    a44a:	c7 04 24 a0 3a 00 00 	movl   $0x3aa0,(%esp,1)
    a451:	e8 fc ff ff ff       	call   a452 <GenerateDataContext_put+0x7f>
	}
	char *temp;
	if(GenerateDataContext_packetSpace(ctx) >= numBytes) {
    a456:	8b 45 08             	mov    0x8(%ebp),%eax
    a459:	89 04 24             	mov    %eax,(%esp,1)
    a45c:	e8 d2 1f 00 00       	call   c433 <GenerateDataContext_packetSpace>
    a461:	3b 45 0c             	cmp    0xc(%ebp),%eax
    a464:	7c 02                	jl     a468 <GenerateDataContext_put+0x95>
    a466:	eb 76                	jmp    a4de <GenerateDataContext_put+0x10b>
		// no adjustments needed in normal operation
		//printk("putting %d at %d[%d]\n", numBytes, ctx->packetNum, ctx->packetPos);
	} else {
		// can't fit request into current packet
		BUG_TRAP(numBytes <= ctx->packets[ctx->packetNum].len);
    a468:	8b 5d 08             	mov    0x8(%ebp),%ebx
    a46b:	8b 45 08             	mov    0x8(%ebp),%eax
    a46e:	8b 10                	mov    (%eax),%edx
    a470:	89 d0                	mov    %edx,%eax
    a472:	c1 e0 03             	shl    $0x3,%eax
    a475:	01 d0                	add    %edx,%eax
    a477:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    a47e:	8b 53 10             	mov    0x10(%ebx),%edx
    a481:	8b 45 0c             	mov    0xc(%ebp),%eax
    a484:	3b 44 0a 08          	cmp    0x8(%edx,%ecx,1),%eax
    a488:	76 14                	jbe    a49e <GenerateDataContext_put+0xcb>
    a48a:	c7 44 24 04 f7 02 00 	movl   $0x2f7,0x4(%esp,1)
    a491:	00 
    a492:	c7 04 24 c0 3a 00 00 	movl   $0x3ac0,(%esp,1)
    a499:	e8 fc ff ff ff       	call   a49a <GenerateDataContext_put+0xc7>
		ctx->outputPos += ctx->packets[ctx->packetNum].len - ctx->packetPos;
    a49e:	8b 75 08             	mov    0x8(%ebp),%esi
    a4a1:	8b 7d 08             	mov    0x8(%ebp),%edi
    a4a4:	8b 4d 08             	mov    0x8(%ebp),%ecx
    a4a7:	8b 45 08             	mov    0x8(%ebp),%eax
    a4aa:	8b 10                	mov    (%eax),%edx
    a4ac:	89 d0                	mov    %edx,%eax
    a4ae:	c1 e0 03             	shl    $0x3,%eax
    a4b1:	01 d0                	add    %edx,%eax
    a4b3:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    a4ba:	8b 49 10             	mov    0x10(%ecx),%ecx
    a4bd:	8b 45 08             	mov    0x8(%ebp),%eax
    a4c0:	8b 50 04             	mov    0x4(%eax),%edx
    a4c3:	8b 44 19 08          	mov    0x8(%ecx,%ebx,1),%eax
    a4c7:	29 d0                	sub    %edx,%eax
    a4c9:	03 47 0c             	add    0xc(%edi),%eax
    a4cc:	89 46 0c             	mov    %eax,0xc(%esi)
		ctx->packetPos = 0;
    a4cf:	8b 45 08             	mov    0x8(%ebp),%eax
    a4d2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		ctx->packetNum++;
    a4d9:	8b 45 08             	mov    0x8(%ebp),%eax
    a4dc:	ff 00                	incl   (%eax)
	}
	temp = ctx->outputPos;
    a4de:	8b 45 08             	mov    0x8(%ebp),%eax
    a4e1:	8b 40 0c             	mov    0xc(%eax),%eax
    a4e4:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	ctx->packetPos += numBytes;
    a4e7:	8b 4d 08             	mov    0x8(%ebp),%ecx
    a4ea:	8b 55 08             	mov    0x8(%ebp),%edx
    a4ed:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4f0:	03 42 04             	add    0x4(%edx),%eax
    a4f3:	89 41 04             	mov    %eax,0x4(%ecx)
	ctx->outputPos += numBytes;
    a4f6:	8b 4d 08             	mov    0x8(%ebp),%ecx
    a4f9:	8b 55 08             	mov    0x8(%ebp),%edx
    a4fc:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4ff:	03 42 0c             	add    0xc(%edx),%eax
    a502:	89 41 0c             	mov    %eax,0xc(%ecx)

	CHECK_OUT_OF_SPACE();
    a505:	8b 45 08             	mov    0x8(%ebp),%eax
    a508:	8b 55 08             	mov    0x8(%ebp),%edx
    a50b:	8b 00                	mov    (%eax),%eax
    a50d:	3b 42 14             	cmp    0x14(%edx),%eax
    a510:	7c 09                	jl     a51b <GenerateDataContext_put+0x148>
    a512:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
    a519:	eb 73                	jmp    a58e <GenerateDataContext_put+0x1bb>

	BUG_TRAP(ctx->packetPos <= ctx->packets[ctx->packetNum].len);
    a51b:	8b 5d 08             	mov    0x8(%ebp),%ebx
    a51e:	8b 75 08             	mov    0x8(%ebp),%esi
    a521:	8b 45 08             	mov    0x8(%ebp),%eax
    a524:	8b 10                	mov    (%eax),%edx
    a526:	89 d0                	mov    %edx,%eax
    a528:	c1 e0 03             	shl    $0x3,%eax
    a52b:	01 d0                	add    %edx,%eax
    a52d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    a534:	8b 56 10             	mov    0x10(%esi),%edx
    a537:	8b 43 04             	mov    0x4(%ebx),%eax
    a53a:	3b 44 0a 08          	cmp    0x8(%edx,%ecx,1),%eax
    a53e:	76 14                	jbe    a554 <GenerateDataContext_put+0x181>
    a540:	c7 44 24 04 02 03 00 	movl   $0x302,0x4(%esp,1)
    a547:	00 
    a548:	c7 04 24 60 3b 00 00 	movl   $0x3b60,(%esp,1)
    a54f:	e8 fc ff ff ff       	call   a550 <GenerateDataContext_put+0x17d>

	if(ctx->packetPos == ctx->packets[ctx->packetNum].len) {
    a554:	8b 5d 08             	mov    0x8(%ebp),%ebx
    a557:	8b 75 08             	mov    0x8(%ebp),%esi
    a55a:	8b 45 08             	mov    0x8(%ebp),%eax
    a55d:	8b 10                	mov    (%eax),%edx
    a55f:	89 d0                	mov    %edx,%eax
    a561:	c1 e0 03             	shl    $0x3,%eax
    a564:	01 d0                	add    %edx,%eax
    a566:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    a56d:	8b 56 10             	mov    0x10(%esi),%edx
    a570:	8b 43 04             	mov    0x4(%ebx),%eax
    a573:	3b 44 0a 08          	cmp    0x8(%edx,%ecx,1),%eax
    a577:	75 0f                	jne    a588 <GenerateDataContext_put+0x1b5>
		ctx->packetPos = 0;
    a579:	8b 45 08             	mov    0x8(%ebp),%eax
    a57c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		ctx->packetNum++;
    a583:	8b 45 08             	mov    0x8(%ebp),%eax
    a586:	ff 00                	incl   (%eax)
	}
	return temp;
    a588:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    a58b:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
#undef CHECK_OUT_OF_SPACE
}
    a58e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    a591:	83 c4 14             	add    $0x14,%esp
    a594:	5b                   	pop    %ebx
    a595:	5e                   	pop    %esi
    a596:	5f                   	pop    %edi
    a597:	5d                   	pop    %ebp
    a598:	c3                   	ret    

0000a599 <GenerateDataContext_simulateRequest>:

static inline 
struct DataChunk *GenerateDataContext_reserveHeader(struct GenerateDataContext *ctx, int generatePadding) {
#define PAD_VALUE  (0x3F)
	char *currpos = ctx->outputPos;
	struct DataChunk *output = (struct DataChunk *) GenerateDataContext_put(ctx, sizeof(struct DataChunk));
	if(output == NULL) {
		//printk("reserve header returning null\n");
		return NULL;
	} else {
		//printk("reserve header succeeded\n");
		if(currpos != (char*)output) {
			// need padding
			if(generatePadding) {
				printk("generating padding\n");
				while(currpos != (char*)output) {
					*currpos++ = PAD_VALUE;
				}
			}
		}
	}
#undef PAD_VALUE

	return output;
}

static inline 
int GenerateDataContext_simulateRequest(struct GenerateDataContext *gctx) {
    a599:	55                   	push   %ebp
    a59a:	89 e5                	mov    %esp,%ebp
    a59c:	83 ec 14             	sub    $0x14,%esp
	struct DataChunk *test = GenerateDataContext_reserveHeader(gctx, 0);
    a59f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    a5a6:	00 
    a5a7:	8b 45 08             	mov    0x8(%ebp),%eax
    a5aa:	89 04 24             	mov    %eax,(%esp,1)
    a5ad:	e8 cf 1e 00 00       	call   c481 <GenerateDataContext_reserveHeader>
    a5b2:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	if(test == NULL) {
    a5b5:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
    a5b9:	75 09                	jne    a5c4 <GenerateDataContext_simulateRequest+0x2b>
		return -1;
    a5bb:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,0xfffffff4(%ebp)
    a5c2:	eb 14                	jmp    a5d8 <GenerateDataContext_simulateRequest+0x3f>
	}

	int maxLen = GenerateDataContext_packetSpace(gctx);
    a5c4:	8b 45 08             	mov    0x8(%ebp),%eax
    a5c7:	89 04 24             	mov    %eax,(%esp,1)
    a5ca:	e8 64 1e 00 00       	call   c433 <GenerateDataContext_packetSpace>
    a5cf:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	return maxLen;
    a5d2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    a5d5:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
 }
    a5d8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    a5db:	c9                   	leave  
    a5dc:	c3                   	ret    

0000a5dd <GenerateDataContext_sanityCheck>:

static inline int validateDataChunks(char *start, int len) {
#define VALIDATION_LIMIT (100)
	int chunknum = 0, dataLen = 0;
	struct DataChunk *chunk = (struct DataChunk *)start;
	int goodCount = 0, loopcount = 0, printAtReturn = 0, count = 0;
	while((char*)(chunk+1) - start < len) {
		int len = DATA_LEN(chunk);
		if(len <= 0) {
			if(trickles_ratelimit())
				printk("bad length chunk(%d) -- ", len);
			printAtReturn = 1;
		} else {
			goodCount++;
		}
		dataLen += len;
		chunknum++;

		chunk = NEXT_CHUNK_ADDR(chunk);
		//printk("offset at %d\n", (char*)chunk - start);

		loopcount++;
		if(loopcount > VALIDATION_LIMIT) {
			printk("validation limit exceeded, goodCount = %d\n", goodCount);
			return -1;
		}
	}
	if((char*)chunk - start > len) {
		printk("data chunk validation failed, %d > %d\n", (char*)chunk-start, len);
		return -chunknum - 1;
	}
	if(printAtReturn) {
		printk("returning\n");
	}
	return chunknum;
#undef  VALIDATION_LIMIT
}

static inline 
void GenerateDataContext_sanityCheck(struct GenerateDataContext *gctx) {
    a5dd:	55                   	push   %ebp
    a5de:	89 e5                	mov    %esp,%ebp
    a5e0:	83 ec 18             	sub    $0x18,%esp
	// Verify  that number of packets was not exceeded
	BUG_TRAP(gctx->packetNum <= gctx->numPackets);
    a5e3:	8b 45 08             	mov    0x8(%ebp),%eax
    a5e6:	8b 55 08             	mov    0x8(%ebp),%edx
    a5e9:	8b 00                	mov    (%eax),%eax
    a5eb:	3b 42 14             	cmp    0x14(%edx),%eax
    a5ee:	7e 14                	jle    a604 <GenerateDataContext_sanityCheck+0x27>
    a5f0:	c7 44 24 04 58 03 00 	movl   $0x358,0x4(%esp,1)
    a5f7:	00 
    a5f8:	c7 04 24 00 3c 00 00 	movl   $0x3c00,(%esp,1)
    a5ff:	e8 fc ff ff ff       	call   a600 <GenerateDataContext_sanityCheck+0x23>
	// Verify that aggregate packet limit was not exceeded, and
	// that the datachunks within each packet are consistent
	int i;
	int totalLen = 0;
    a604:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
	int outputLen = gctx->outputPos - gctx->outputStart;
    a60b:	8b 4d 08             	mov    0x8(%ebp),%ecx
    a60e:	8b 45 08             	mov    0x8(%ebp),%eax
    a611:	8b 50 08             	mov    0x8(%eax),%edx
    a614:	8b 41 0c             	mov    0xc(%ecx),%eax
    a617:	29 d0                	sub    %edx,%eax
    a619:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	char *buf = gctx->outputStart;
    a61c:	8b 45 08             	mov    0x8(%ebp),%eax
    a61f:	8b 40 08             	mov    0x8(%eax),%eax
    a622:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
#ifndef __KERNEL__
	for(i=0; i < gctx->numPackets; i++) {

#warning "not compiling kernel version"
		int numChunks = validateDataChunks(buf, MIN(gctx->packets[i].len, MAX(outputLen - totalLen,0)));
		totalLen += gctx->packets[i].len;
		if(numChunks < 0) {
			numChunks = -numChunks;
			printk("Packet %d: chunk processing error, %d/%d\n", i, numChunks, gctx->numPackets);
		}
		buf += gctx->packets[i].len;
	}
	if(outputLen > totalLen) {
		BUG_TRAP(gctx->outputPos - gctx->outputStart <= totalLen);
		printk("%d !<= %d %d\n", gctx->outputPos - gctx->outputStart, totalLen, gctx->numPackets);
	}
#endif
}
    a625:	c9                   	leave  
    a626:	c3                   	ret    

0000a627 <RequestOFOEntry_free>:
#else
#include "trickles_packet_helpers.h"
#endif
static inline
void RequestOFOEntry_free(struct RequestOFOEntry *entry) {
    a627:	55                   	push   %ebp
    a628:	89 e5                	mov    %esp,%ebp
    a62a:	83 ec 08             	sub    $0x8,%esp
	BUG_TRAP(entry->prev == NULL && entry->next == NULL &&
		 entry->list == NULL);
    a62d:	8b 45 08             	mov    0x8(%ebp),%eax
    a630:	83 38 00             	cmpl   $0x0,(%eax)
    a633:	75 14                	jne    a649 <RequestOFOEntry_free+0x22>
    a635:	8b 45 08             	mov    0x8(%ebp),%eax
    a638:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
    a63c:	75 0b                	jne    a649 <RequestOFOEntry_free+0x22>
    a63e:	8b 45 08             	mov    0x8(%ebp),%eax
    a641:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
    a645:	75 02                	jne    a649 <RequestOFOEntry_free+0x22>
    a647:	eb 14                	jmp    a65d <RequestOFOEntry_free+0x36>
    a649:	c7 44 24 04 27 01 00 	movl   $0x127,0x4(%esp,1)
    a650:	00 
    a651:	c7 04 24 a0 3c 00 00 	movl   $0x3ca0,(%esp,1)
    a658:	e8 fc ff ff ff       	call   a659 <RequestOFOEntry_free+0x32>
	freeClientSide_Continuation(entry->cont);
    a65d:	8b 45 08             	mov    0x8(%ebp),%eax
    a660:	8b 40 0c             	mov    0xc(%eax),%eax
    a663:	89 04 24             	mov    %eax,(%esp,1)
    a666:	e8 c4 f9 ff ff       	call   a02f <freeClientSide_Continuation>
	kfree(entry);
    a66b:	8b 45 08             	mov    0x8(%ebp),%eax
    a66e:	89 04 24             	mov    %eax,(%esp,1)
    a671:	e8 fc ff ff ff       	call   a672 <RequestOFOEntry_free+0x4b>
}
    a676:	c9                   	leave  
    a677:	c3                   	ret    

0000a678 <free_minisock>:
	msk->serverSK = NULL;
}

#ifdef CAN_USE_TFREE
static inline void free_minisock(struct sock *sk, struct cminisock *msk) {
    a678:	55                   	push   %ebp
    a679:	89 e5                	mov    %esp,%ebp
    a67b:	83 ec 0c             	sub    $0xc,%esp
	int i;
	/*
	printk("msk summary (%p [%d]) (%p [%d]) (%p [%d])\n", 
	       msk->packets, msk->num_packets,
	       msk->ucont_data, msk->ucont_len,
	       msk->input, msk->input_len);
	*/
	for(i=0; i < msk->num_packets; i++) {
    a67e:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
    a685:	8b 55 0c             	mov    0xc(%ebp),%edx
    a688:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    a68b:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
    a691:	7c 02                	jl     a695 <free_minisock+0x1d>
    a693:	eb 4e                	jmp    a6e3 <free_minisock+0x6b>
		if(msk->packets[i].ucontData != NULL) {
    a695:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    a698:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    a69b:	89 d0                	mov    %edx,%eax
    a69d:	c1 e0 03             	shl    $0x3,%eax
    a6a0:	01 d0                	add    %edx,%eax
    a6a2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    a6a9:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
    a6af:	83 7c 10 14 00       	cmpl   $0x0,0x14(%eax,%edx,1)
    a6b4:	74 26                	je     a6dc <free_minisock+0x64>
			kfree(msk->packets[i].ucontData);
    a6b6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    a6b9:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    a6bc:	89 d0                	mov    %edx,%eax
    a6be:	c1 e0 03             	shl    $0x3,%eax
    a6c1:	01 d0                	add    %edx,%eax
    a6c3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    a6ca:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
    a6d0:	8b 44 10 14          	mov    0x14(%eax,%edx,1),%eax
    a6d4:	89 04 24             	mov    %eax,(%esp,1)
    a6d7:	e8 fc ff ff ff       	call   a6d8 <free_minisock+0x60>
    a6dc:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
    a6df:	ff 00                	incl   (%eax)
    a6e1:	eb a2                	jmp    a685 <free_minisock+0xd>
		}
	}
	// printk("done with packet data\n");
	if(!SIMULATION_MODE(sk) && msk->packets) {
    a6e3:	8b 45 08             	mov    0x8(%ebp),%eax
    a6e6:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    a6ec:	83 e0 01             	and    $0x1,%eax
    a6ef:	85 c0                	test   %eax,%eax
    a6f1:	74 1b                	je     a70e <free_minisock+0x96>
    a6f3:	8b 55 08             	mov    0x8(%ebp),%edx
    a6f6:	8b 45 08             	mov    0x8(%ebp),%eax
    a6f9:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    a6ff:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
    a705:	83 e0 08             	and    $0x8,%eax
    a708:	85 c0                	test   %eax,%eax
    a70a:	75 02                	jne    a70e <free_minisock+0x96>
    a70c:	eb 31                	jmp    a73f <free_minisock+0xc7>
    a70e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a711:	83 b8 ec 00 00 00 00 	cmpl   $0x0,0xec(%eax)
    a718:	74 25                	je     a73f <free_minisock+0xc7>
		tfree(sk,msk->packets);
    a71a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a71d:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
    a723:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    a727:	8b 45 08             	mov    0x8(%ebp),%eax
    a72a:	89 04 24             	mov    %eax,(%esp,1)
    a72d:	e8 fc ff ff ff       	call   a72e <free_minisock+0xb6>
		msk->packets = NULL;
    a732:	8b 45 0c             	mov    0xc(%ebp),%eax
    a735:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%eax)
    a73c:	00 00 00 
	}
	// printk("done with packet array\n");
	msk->num_packets = 0;
    a73f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a742:	c7 80 e8 00 00 00 00 	movl   $0x0,0xe8(%eax)
    a749:	00 00 00 

	if(msk->ucont_data != NULL) {
    a74c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a74f:	83 78 7c 00          	cmpl   $0x0,0x7c(%eax)
    a753:	74 1f                	je     a774 <free_minisock+0xfc>
		tfree(sk,msk->ucont_data);
    a755:	8b 45 0c             	mov    0xc(%ebp),%eax
    a758:	8b 40 7c             	mov    0x7c(%eax),%eax
    a75b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    a75f:	8b 45 08             	mov    0x8(%ebp),%eax
    a762:	89 04 24             	mov    %eax,(%esp,1)
    a765:	e8 fc ff ff ff       	call   a766 <free_minisock+0xee>
		msk->ucont_data = NULL;
    a76a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a76d:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	}
	// printk("done with ucont data\n");
	msk->ucont_len = 0;
    a774:	8b 45 0c             	mov    0xc(%ebp),%eax
    a777:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
	if(msk->input != NULL) {
    a77e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a781:	83 b8 98 00 00 00 00 	cmpl   $0x0,0x98(%eax)
    a788:	74 25                	je     a7af <free_minisock+0x137>
		tfree(sk,msk->input);
    a78a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a78d:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
    a793:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    a797:	8b 45 08             	mov    0x8(%ebp),%eax
    a79a:	89 04 24             	mov    %eax,(%esp,1)
    a79d:	e8 fc ff ff ff       	call   a79e <free_minisock+0x126>
		msk->input = NULL;
    a7a2:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7a5:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
    a7ac:	00 00 00 
	}
	// printk("done with input len\n");
	msk->input_len = 0;
    a7af:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7b2:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
    a7b9:	00 00 00 
}
    a7bc:	c9                   	leave  
    a7bd:	c3                   	ret    

0000a7be <can_alloc_trickles_msk>:

static inline void msk_free_fields(struct sock *sk, struct cminisock *msk) {
	free_minisock(sk, msk);
}

static inline void msk_clear_fields(struct cminisock *msk) {
	msk->num_packets = 0;
	msk->packets = NULL;

	msk->ucont_len = 0;
	msk->ucont_data = NULL;

	msk->input_len = 0;
	msk->input = NULL;
}

#endif

#ifndef USERTEST

static inline int alloc_msk_packets(struct cminisock *msk, int numPackets) {
	BUG_TRAP(msk->num_packets == 0);
	BUG_TRAP(numPackets >= 0);
#define MAX_NUM_SIMULATION_PACKETS (8000)
	static struct cminisock_packet packets[NR_CPUS][MAX_NUM_SIMULATION_PACKETS];
	if(!SIMULATION_MODE(msk->sk)) {
		msk->packets = tmalloc(msk->sk, sizeof(struct cminisock_packet) * numPackets);

		// printk("allocated packets to %p\n", msk->packets);

		if(msk->packets == NULL) {
			if(trickles_ratelimit()) {
				printk("out of memory while tmalloc()'ing space for packets\n");
			}
			return 0;
		}
	} else {
		// avoid malloc
		if(numPackets <= MAX_NUM_SIMULATION_PACKETS) {
			msk->packets = packets[smp_processor_id()];
		} else {
			msk->packets = NULL;
			if(trickles_ratelimit()) {
				printk("Too many packets requested during simulation\n");
			}
			return 0;
		}
	}
	msk->num_packets = numPackets;
	return 1;
}

static inline
int can_alloc_trickles_msk(struct sock *sk) {
    a7be:	55                   	push   %ebp
    a7bf:	89 e5                	mov    %esp,%ebp
    a7c1:	83 ec 0c             	sub    $0xc,%esp
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
    a7c4:	8b 45 08             	mov    0x8(%ebp),%eax
    a7c7:	05 bc 00 00 00       	add    $0xbc,%eax
    a7cc:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
    a7cf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    a7d2:	05 d4 01 00 00       	add    $0x1d4,%eax
    a7d7:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	struct cminisock *curr =
    a7da:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    a7dd:	8b 40 04             	mov    0x4(%eax),%eax
    a7e0:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		(struct cminisock *)head->next;
	while((struct alloc_head_list*)curr != head && curr->ctl == ALLOC_PROCESSING) {
    a7e3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    a7e6:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
    a7e9:	74 16                	je     a801 <can_alloc_trickles_msk+0x43>
    a7eb:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    a7ee:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
    a7f2:	74 02                	je     a7f6 <can_alloc_trickles_msk+0x38>
    a7f4:	eb 0b                	jmp    a801 <can_alloc_trickles_msk+0x43>
		//printk("alloc_head loop\n");
		curr = curr->next;
    a7f6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    a7f9:	8b 40 04             	mov    0x4(%eax),%eax
    a7fc:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    a7ff:	eb e2                	jmp    a7e3 <can_alloc_trickles_msk+0x25>
	}
	return (struct alloc_head_list*)curr != head;
    a801:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    a804:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
    a807:	0f 95 c0             	setne  %al
    a80a:	0f b6 c0             	movzbl %al,%eax
}
    a80d:	c9                   	leave  
    a80e:	c3                   	ret    

0000a80f <msk_release>:

static inline struct cminisock *alloc_trickles_msk(struct sock *sk) {
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
	struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
	struct cminisock *rval = NULL, *curr = (struct cminisock *)tp->cminisock_api_config.msk_freelist.next;

	if(!SIMULATION_MODE(sk)) {
		while((struct alloc_head_list*)curr != head && curr->ctl == ALLOC_PROCESSING) {
			//printk("alloc_head loop\n");
			curr = curr->next;
		}
		//printk("out of alloc_head loop\n");

		if((struct alloc_head_list *)curr == head) return NULL;

		rval = curr;
		unlink((struct alloc_head*)rval);
		rval->ctl = ALLOC_PENDING;
	} else {
		if(tp->t.responseCount == 0) {
			rval = tp->t.responseMSK;
			rval->list = NULL;
			rval->next = rval->prev = NULL;
		} else {
			rval = kmalloc(sizeof (struct cminisock), GFP_ATOMIC);
			if(rval == NULL) {
				printk("out of memory during compatibility mode\n");
				return NULL;
			}
			rval->next = rval->prev = NULL;
			rval->list = NULL;
			insert_tail(&tp->t.responseList, (struct alloc_head*)rval);
		}
		tp->t.responseCount++;

		rval->sk = sk;
		rval->ctl = ALLOC_PENDING;
	}

	init_minisock(rval);

	return rval;
}

static inline void msk_hold(struct cminisock *msk) {
	msk->refCnt++;
}

#endif // USERTEST

static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk);
static inline void free_trickles_msk_finish(struct sock *sk, struct cminisock *msk);

static inline struct cminisock *
shallow_copy_msk(struct sock *sk, struct cminisock *msk) {
	struct cminisock *rval = alloc_trickles_msk(sk);

	struct alloc_head head;

	if(rval == NULL) {
		printk("out of memory while copying msk\n");
		return NULL;
	}
	/* save & restore alloc head */
	head = *(struct alloc_head*)rval;
	*rval = *msk;
	*(struct alloc_head*)rval = head;

	rval->refCnt = 1;

	return rval;
}


#ifdef CAN_USE_TFREE
static inline struct cminisock *copy_msk(struct sock *sk, struct cminisock *msk) {
	// Copy everything except for per-packet information.

	printk("CopyMSK\n");
#if 0
	struct cminisock *rval = alloc_trickles_msk(sk);
	struct alloc_head head;
	if(rval == NULL) {
		printk("out of memory while copying msk\n");
		return NULL;
	}
	/* save & restore alloc head */
	head = *(struct alloc_head*)rval;
	*rval = *msk;
	*(struct alloc_head*)rval = head;
#else
	struct cminisock *rval = shallow_copy_msk(sk, msk);
	if(rval == NULL) {
		printk("out of memory while copying msk\n");
		return NULL;
	}
#endif

	rval->num_packets = 0;
	rval->packets = NULL;

	if(rval->ucont_len > 0) {
		rval->ucont_data = tmalloc(sk,rval->ucont_len);
		// printk("copymsk: tmalloc ucontdata\n");
		if(rval->ucont_data == NULL) {
			printk("out of tmalloc memory while copying msk (len = %d)\n", rval->ucont_len);
			free_trickles_msk(sk,rval);
			free_trickles_msk_finish(sk,rval);
			return NULL;
		}
	} else {
		rval->ucont_data = NULL;
	}
	if(rval->input_len > 0) {
		rval->input = tmalloc(sk,rval->input_len);
		// printk("copymsk: tmalloc inputlen\n");
		if(rval->input == NULL) {
			printk("out of tmalloc memory while copying msk (len = %d)\n", rval->input_len);
			tfree(sk,rval->ucont_data);
			free_trickles_msk(sk,rval);
			free_trickles_msk_finish(sk,rval);
			return NULL;
		}
	} else {
		rval->input = NULL;
	}
	if(rval->ucont_data)
		memcpy(rval->ucont_data,msk->ucont_data,rval->ucont_len);
	if(rval->input)
		memcpy(rval->input,msk->input,rval->input_len);

	rval->executionTrace |= 0x80;
	return rval;
}
#endif // CAN_USE_TFREE

/* Two phase free: first phase disconnects socket from event list,
   sets to ALLOC_PROCESSING; second phase adds the socket to free
   list, sets to ALLOC_FREE and ready for reuse */
#ifndef USERTEST
static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk) {
	if(!SIMULATION_MODE(sk)) {
		if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) {
			printk("double free\n");
			BUG();
		}
		if(msk->ctl == ALLOC_READY && msk->prev != NULL) {
			unlink((struct alloc_head *)msk);
		}
		msk->ctl = ALLOC_PROCESSING;
	}
}

static inline void msk_release(struct sock *sk, struct cminisock *msk) {
    a80f:	55                   	push   %ebp
    a810:	89 e5                	mov    %esp,%ebp
    a812:	83 ec 10             	sub    $0x10,%esp
	// Perform actual deallocation. This function is common to
	// state cache and event queue
	msk->refCnt--;
    a815:	8b 45 0c             	mov    0xc(%ebp),%eax
    a818:	ff 88 f0 00 00 00    	decl   0xf0(%eax)
	BUG_TRAP(msk->refCnt >= 0);
    a81e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a821:	83 b8 f0 00 00 00 00 	cmpl   $0x0,0xf0(%eax)
    a828:	79 14                	jns    a83e <msk_release+0x2f>
    a82a:	c7 44 24 04 13 01 00 	movl   $0x113,0x4(%esp,1)
    a831:	00 
    a832:	c7 04 24 40 3d 00 00 	movl   $0x3d40,(%esp,1)
    a839:	e8 fc ff ff ff       	call   a83a <msk_release+0x2b>
	if(msk->refCnt == 0) {
    a83e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a841:	83 b8 f0 00 00 00 00 	cmpl   $0x0,0xf0(%eax)
    a848:	0f 85 a0 00 00 00    	jne    a8ee <msk_release+0xdf>
		// printk("release: refcnt %p\n", msk);
		struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
    a84e:	8b 45 08             	mov    0x8(%ebp),%eax
    a851:	05 bc 00 00 00       	add    $0xbc,%eax
    a856:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
		struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
    a859:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    a85c:	05 d4 01 00 00       	add    $0x1d4,%eax
    a861:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

		free_minisock(sk,msk);
    a864:	8b 45 0c             	mov    0xc(%ebp),%eax
    a867:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    a86b:	8b 45 08             	mov    0x8(%ebp),%eax
    a86e:	89 04 24             	mov    %eax,(%esp,1)
    a871:	e8 02 fe ff ff       	call   a678 <free_minisock>
		if(!SIMULATION_MODE(sk)) {
    a876:	8b 45 08             	mov    0x8(%ebp),%eax
    a879:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    a87f:	83 e0 01             	and    $0x1,%eax
    a882:	85 c0                	test   %eax,%eax
    a884:	74 1b                	je     a8a1 <msk_release+0x92>
    a886:	8b 55 08             	mov    0x8(%ebp),%edx
    a889:	8b 45 08             	mov    0x8(%ebp),%eax
    a88c:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    a892:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
    a898:	83 e0 08             	and    $0x8,%eax
    a89b:	85 c0                	test   %eax,%eax
    a89d:	75 02                	jne    a8a1 <msk_release+0x92>
    a89f:	eb 1e                	jmp    a8bf <msk_release+0xb0>
			insert_head(head, (struct alloc_head *)msk);
    a8a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8a4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    a8a8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    a8ab:	89 04 24             	mov    %eax,(%esp,1)
    a8ae:	e8 46 e9 ff ff       	call   91f9 <insert_head>
			msk->ctl = ALLOC_FREE;
    a8b3:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8b6:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    a8bd:	eb 2f                	jmp    a8ee <msk_release+0xdf>
		} else {
			if(msk == tp->t.responseMSK) {
    a8bf:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    a8c2:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8c5:	3b 82 64 0a 00 00    	cmp    0xa64(%edx),%eax
    a8cb:	75 02                	jne    a8cf <msk_release+0xc0>
    a8cd:	eb 16                	jmp    a8e5 <msk_release+0xd6>
			} else {
				// overflow
				unlink((struct alloc_head*)msk);
    a8cf:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8d2:	89 04 24             	mov    %eax,(%esp,1)
    a8d5:	e8 12 ea ff ff       	call   92ec <unlink>
				kfree(msk);
    a8da:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8dd:	89 04 24             	mov    %eax,(%esp,1)
    a8e0:	e8 fc ff ff ff       	call   a8e1 <msk_release+0xd2>
			}
			tp->t.responseCount--;
    a8e5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    a8e8:	ff 88 7c 0a 00 00    	decl   0xa7c(%eax)
		}
	} else {
		//printk("release: refcnt == %d\n", msk->refCnt);
	}
}
    a8ee:	c9                   	leave  
    a8ef:	c3                   	ret    

0000a8f0 <save_for_recycle>:
#endif
}

#ifdef ENABLE_RECYCLING
static inline void save_for_recycle(struct sock *sk, struct sk_buff *skb) {
    a8f0:	55                   	push   %ebp
    a8f1:	89 e5                	mov    %esp,%ebp
    a8f3:	83 ec 28             	sub    $0x28,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    a8f6:	8b 45 08             	mov    0x8(%ebp),%eax
    a8f9:	05 bc 00 00 00       	add    $0xbc,%eax
    a8fe:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	int r0 = skb_shinfo(skb)->nr_frags != 0,
    a901:	8b 45 0c             	mov    0xc(%ebp),%eax
    a904:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    a90a:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
    a90e:	0f 95 c0             	setne  %al
    a911:	0f b6 c0             	movzbl %al,%eax
    a914:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
		r1 = tp->t.recycleList.qlen >= RECYCLE_LIMIT,
    a917:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    a91a:	81 b8 60 0a 00 00 e7 	cmpl   $0x3e7,0xa60(%eax)
    a921:	03 00 00 
    a924:	0f 97 c0             	seta   %al
    a927:	0f b6 c0             	movzbl %al,%eax
    a92a:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		r2 = skb->truesize - sizeof(struct sk_buff) < TRICKLES_TX_SKB_LEN;
    a92d:	8b 45 0c             	mov    0xc(%ebp),%eax
    a930:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
    a936:	81 ea d8 00 00 00    	sub    $0xd8,%edx
    a93c:	a1 00 00 00 00       	mov    0x0,%eax
    a941:	05 f2 00 00 00       	add    $0xf2,%eax
    a946:	39 c2                	cmp    %eax,%edx
    a948:	0f 92 c0             	setb   %al
    a94b:	0f b6 c0             	movzbl %al,%eax
    a94e:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	if(r0 || r1 || r2) {
    a951:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    a955:	75 0e                	jne    a965 <save_for_recycle+0x75>
    a957:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
    a95b:	75 08                	jne    a965 <save_for_recycle+0x75>
    a95d:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
    a961:	75 02                	jne    a965 <save_for_recycle+0x75>
    a963:	eb 14                	jmp    a979 <save_for_recycle+0x89>
		if(r0 || r2) {
    a965:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
			if(trickles_ratelimit())
				printk("Unsuitable for recycling %d %d %d truesize = %d skblen = %d\n", r0, r1, r2, skb->truesize, TRICKLES_TX_SKB_LEN);
		}
		__kfree_skb(skb);
    a969:	8b 45 0c             	mov    0xc(%ebp),%eax
    a96c:	89 04 24             	mov    %eax,(%esp,1)
    a96f:	e8 fc ff ff ff       	call   a970 <save_for_recycle+0x80>
		return;
    a974:	e9 9e 00 00 00       	jmp    aa17 <save_for_recycle+0x127>
	}
	// initialization copied from alloc_skb
	recycle_headerinit(skb);
    a979:	8b 45 0c             	mov    0xc(%ebp),%eax
    a97c:	89 04 24             	mov    %eax,(%esp,1)
    a97f:	e8 6d 1b 00 00       	call   c4f1 <recycle_headerinit>

	skb->tail = skb->data = skb->head;
    a984:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    a987:	8b 55 0c             	mov    0xc(%ebp),%edx
    a98a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a98d:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
    a993:	89 82 b8 00 00 00    	mov    %eax,0xb8(%edx)
    a999:	89 81 bc 00 00 00    	mov    %eax,0xbc(%ecx)
	skb->len = 0;
    a99f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9a2:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
    a9a9:	00 00 00 
	skb->cloned = 0;
    a9ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9af:	c6 80 a1 00 00 00 00 	movb   $0x0,0xa1(%eax)
	skb->data_len =0;
    a9b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9b9:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
    a9c0:	00 00 00 

	atomic_set(&skb->users, 1);
    a9c3:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9c6:	05 a8 00 00 00       	add    $0xa8,%eax
    a9cb:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	atomic_set(&(skb_shinfo(skb)->dataref), 1);
    a9d1:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9d4:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    a9da:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	skb_shinfo(skb)->nr_frags = 0;
    a9e0:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9e3:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    a9e9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	skb_shinfo(skb)->frag_list = NULL;
    a9f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9f3:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    a9f9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

	__skb_queue_tail(&tp->t.recycleList, skb);
    aa00:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa03:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    aa07:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    aa0a:	05 58 0a 00 00       	add    $0xa58,%eax
    aa0f:	89 04 24             	mov    %eax,(%esp,1)
    aa12:	e8 1f e4 ff ff       	call   8e36 <__skb_queue_tail>
}
    aa17:	c9                   	leave  
    aa18:	c3                   	ret    

0000aa19 <iabs>:
static inline int iabs(int x) {
    aa19:	55                   	push   %ebp
    aa1a:	89 e5                	mov    %esp,%ebp
	if(x < 0) x = -x;
    aa1c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    aa20:	79 03                	jns    aa25 <iabs+0xc>
    aa22:	f7 5d 08             	negl   0x8(%ebp)
	return x;
    aa25:	8b 45 08             	mov    0x8(%ebp),%eax
}
    aa28:	5d                   	pop    %ebp
    aa29:	c3                   	ret    

0000aa2a <hist_init>:
	int maxVal;
	int *bins;
};

static inline void hist_init(struct histogram *hist, char *name, int numBins, int minVal, int maxVal) {
    aa2a:	55                   	push   %ebp
    aa2b:	89 e5                	mov    %esp,%ebp
    aa2d:	53                   	push   %ebx
    aa2e:	83 ec 10             	sub    $0x10,%esp
	strcpy(hist->name, name);
    aa31:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa34:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    aa38:	8b 45 08             	mov    0x8(%ebp),%eax
    aa3b:	89 04 24             	mov    %eax,(%esp,1)
    aa3e:	e8 e8 13 00 00       	call   be2b <strcpy>
	hist->numBins = numBins;
    aa43:	8b 55 08             	mov    0x8(%ebp),%edx
    aa46:	8b 45 10             	mov    0x10(%ebp),%eax
    aa49:	89 42 40             	mov    %eax,0x40(%edx)
	hist->minVal = minVal;
    aa4c:	8b 55 08             	mov    0x8(%ebp),%edx
    aa4f:	8b 45 14             	mov    0x14(%ebp),%eax
    aa52:	89 42 44             	mov    %eax,0x44(%edx)
	hist->maxVal = maxVal;
    aa55:	8b 55 08             	mov    0x8(%ebp),%edx
    aa58:	8b 45 18             	mov    0x18(%ebp),%eax
    aa5b:	89 42 48             	mov    %eax,0x48(%edx)
	// reserve slots for overflow and underflow
	int alloc_size = (numBins + 2) * sizeof(int);
    aa5e:	8b 45 10             	mov    0x10(%ebp),%eax
    aa61:	c1 e0 02             	shl    $0x2,%eax
    aa64:	83 c0 08             	add    $0x8,%eax
    aa67:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	hist->bins = kmalloc(alloc_size, GFP_ATOMIC);
    aa6a:	8b 5d 08             	mov    0x8(%ebp),%ebx
    aa6d:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    aa74:	00 
    aa75:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    aa78:	89 04 24             	mov    %eax,(%esp,1)
    aa7b:	e8 fc ff ff ff       	call   aa7c <hist_init+0x52>
    aa80:	89 43 4c             	mov    %eax,0x4c(%ebx)
	memset(hist->bins, 0, alloc_size);
    aa83:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    aa86:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    aa8a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    aa91:	00 
    aa92:	8b 45 08             	mov    0x8(%ebp),%eax
    aa95:	8b 40 4c             	mov    0x4c(%eax),%eax
    aa98:	89 04 24             	mov    %eax,(%esp,1)
    aa9b:	e8 31 16 00 00       	call   c0d1 <__constant_c_memset>
}
    aaa0:	83 c4 10             	add    $0x10,%esp
    aaa3:	5b                   	pop    %ebx
    aaa4:	5d                   	pop    %ebp
    aaa5:	c3                   	ret    

0000aaa6 <hist_destroy>:

static inline void hist_destroy(struct histogram *hist) {
    aaa6:	55                   	push   %ebp
    aaa7:	89 e5                	mov    %esp,%ebp
    aaa9:	83 ec 04             	sub    $0x4,%esp
	kfree(hist->bins);
    aaac:	8b 45 08             	mov    0x8(%ebp),%eax
    aaaf:	8b 40 4c             	mov    0x4c(%eax),%eax
    aab2:	89 04 24             	mov    %eax,(%esp,1)
    aab5:	e8 fc ff ff ff       	call   aab6 <hist_destroy+0x10>
}
    aaba:	c9                   	leave  
    aabb:	c3                   	ret    

0000aabc <hist_addPoint>:

static inline void hist_addPoint(struct histogram *hist, int value) {
    aabc:	55                   	push   %ebp
    aabd:	89 e5                	mov    %esp,%ebp
    aabf:	53                   	push   %ebx
    aac0:	83 ec 0c             	sub    $0xc,%esp
	int normalizedPosition = 
    aac3:	8b 45 08             	mov    0x8(%ebp),%eax
    aac6:	8b 50 44             	mov    0x44(%eax),%edx
    aac9:	8b 45 0c             	mov    0xc(%ebp),%eax
    aacc:	29 d0                	sub    %edx,%eax
    aace:	89 c2                	mov    %eax,%edx
    aad0:	8b 45 08             	mov    0x8(%ebp),%eax
    aad3:	89 d3                	mov    %edx,%ebx
    aad5:	0f af 58 40          	imul   0x40(%eax),%ebx
    aad9:	8b 4d 08             	mov    0x8(%ebp),%ecx
    aadc:	8b 45 08             	mov    0x8(%ebp),%eax
    aadf:	8b 50 44             	mov    0x44(%eax),%edx
    aae2:	8b 41 48             	mov    0x48(%ecx),%eax
    aae5:	29 d0                	sub    %edx,%eax
    aae7:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    aaea:	89 d8                	mov    %ebx,%eax
    aaec:	99                   	cltd   
    aaed:	f7 7d f0             	idivl  0xfffffff0(%ebp)
    aaf0:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
		(value - hist->minVal) * hist->numBins /
		(hist->maxVal - hist->minVal);
	int index = -1;
    aaf3:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,0xfffffff4(%ebp)
	if(normalizedPosition < 0) {
    aafa:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    aafe:	79 09                	jns    ab09 <hist_addPoint+0x4d>
		// set to underflow
		index = 0;
    ab00:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
    ab07:	eb 1e                	jmp    ab27 <hist_addPoint+0x6b>
	} else if(normalizedPosition >= hist->numBins) {
    ab09:	8b 55 08             	mov    0x8(%ebp),%edx
    ab0c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    ab0f:	3b 42 40             	cmp    0x40(%edx),%eax
    ab12:	7c 0c                	jl     ab20 <hist_addPoint+0x64>
		// set to overflow
		index = hist->numBins + 1;
    ab14:	8b 45 08             	mov    0x8(%ebp),%eax
    ab17:	8b 40 40             	mov    0x40(%eax),%eax
    ab1a:	40                   	inc    %eax
    ab1b:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    ab1e:	eb 07                	jmp    ab27 <hist_addPoint+0x6b>
	} else {
		// skip past underflow position
		index = 1 + normalizedPosition;
    ab20:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    ab23:	40                   	inc    %eax
    ab24:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	}
	hist->bins[index]++;
    ab27:	8b 4d 08             	mov    0x8(%ebp),%ecx
    ab2a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    ab2d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ab34:	8b 41 4c             	mov    0x4c(%ecx),%eax
    ab37:	ff 04 10             	incl   (%eax,%edx,1)
}
    ab3a:	83 c4 0c             	add    $0xc,%esp
    ab3d:	5b                   	pop    %ebx
    ab3e:	5d                   	pop    %ebp
    ab3f:	c3                   	ret    

0000ab40 <create_proc_read_entry>:

static inline struct proc_dir_entry *create_proc_read_entry(const char *name,
	mode_t mode, struct proc_dir_entry *base, 
	read_proc_t *read_proc, void * data)
{
    ab40:	55                   	push   %ebp
    ab41:	89 e5                	mov    %esp,%ebp
    ab43:	83 ec 14             	sub    $0x14,%esp
    ab46:	8b 45 0c             	mov    0xc(%ebp),%eax
    ab49:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
	struct proc_dir_entry *res=create_proc_entry(name,mode,base);
    ab4d:	8b 45 10             	mov    0x10(%ebp),%eax
    ab50:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    ab54:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
    ab58:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ab5c:	8b 45 08             	mov    0x8(%ebp),%eax
    ab5f:	89 04 24             	mov    %eax,(%esp,1)
    ab62:	e8 fc ff ff ff       	call   ab63 <create_proc_read_entry+0x23>
    ab67:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	if (res) {
    ab6a:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    ab6e:	74 12                	je     ab82 <create_proc_read_entry+0x42>
		res->read_proc=read_proc;
    ab70:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    ab73:	8b 45 14             	mov    0x14(%ebp),%eax
    ab76:	89 42 38             	mov    %eax,0x38(%edx)
		res->data=data;
    ab79:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    ab7c:	8b 45 18             	mov    0x18(%ebp),%eax
    ab7f:	89 42 34             	mov    %eax,0x34(%edx)
	}
	return res;
    ab82:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
}
    ab85:	c9                   	leave  
    ab86:	c3                   	ret    

0000ab87 <record_delay>:
    ab87:	55                   	push   %ebp
    ab88:	89 e5                	mov    %esp,%ebp
    ab8a:	8b 45 08             	mov    0x8(%ebp),%eax
    ab8d:	99                   	cltd   
    ab8e:	01 05 00 00 00 00    	add    %eax,0x0
    ab94:	11 15 04 00 00 00    	adc    %edx,0x4
    ab9a:	ff 05 00 00 00 00    	incl   0x0
    aba0:	5d                   	pop    %ebp
    aba1:	c3                   	ret    

0000aba2 <addOfoSkb>:
    aba2:	55                   	push   %ebp
    aba3:	89 e5                	mov    %esp,%ebp
    aba5:	83 ec 0c             	sub    $0xc,%esp
    aba8:	a1 00 00 00 00       	mov    0x0,%eax
    abad:	3d 00 00 00 10       	cmp    $0x10000000,%eax
    abb2:	7e 09                	jle    abbd <addOfoSkb+0x1b>
    abb4:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
    abbb:	eb 2b                	jmp    abe8 <addOfoSkb+0x46>
    abbd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    abc4:	00 
    abc5:	8b 4d 08             	mov    0x8(%ebp),%ecx
    abc8:	8b 45 08             	mov    0x8(%ebp),%eax
    abcb:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
    abd1:	8b 81 c0 00 00 00    	mov    0xc0(%ecx),%eax
    abd7:	29 d0                	sub    %edx,%eax
    abd9:	89 04 24             	mov    %eax,(%esp,1)
    abdc:	e8 10 12 00 00       	call   bdf1 <atomic_add>
    abe1:	c7 45 fc 01 00 00 00 	movl   $0x1,0xfffffffc(%ebp)
    abe8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    abeb:	c9                   	leave  
    abec:	c3                   	ret    

0000abed <delOfoSkb>:
    abed:	55                   	push   %ebp
    abee:	89 e5                	mov    %esp,%ebp
    abf0:	83 ec 08             	sub    $0x8,%esp
    abf3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    abfa:	00 
    abfb:	8b 4d 08             	mov    0x8(%ebp),%ecx
    abfe:	8b 45 08             	mov    0x8(%ebp),%eax
    ac01:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
    ac07:	8b 81 c0 00 00 00    	mov    0xc0(%ecx),%eax
    ac0d:	29 d0                	sub    %edx,%eax
    ac0f:	89 04 24             	mov    %eax,(%esp,1)
    ac12:	e8 ea 11 00 00       	call   be01 <atomic_sub>
    ac17:	c9                   	leave  
    ac18:	c3                   	ret    

0000ac19 <unlinkCont>:
    ac19:	55                   	push   %ebp
    ac1a:	89 e5                	mov    %esp,%ebp
    ac1c:	83 ec 04             	sub    $0x4,%esp
    ac1f:	8b 45 08             	mov    0x8(%ebp),%eax
    ac22:	89 04 24             	mov    %eax,(%esp,1)
    ac25:	e8 c2 e6 ff ff       	call   92ec <unlink>
    ac2a:	c9                   	leave  
    ac2b:	c3                   	ret    

0000ac2c <random>:
    ac2c:	55                   	push   %ebp
    ac2d:	89 e5                	mov    %esp,%ebp
    ac2f:	a1 60 73 04 00       	mov    0x47360,%eax
    ac34:	69 c0 0d 66 19 00    	imul   $0x19660d,%eax,%eax
    ac3a:	05 5f f3 6e 3c       	add    $0x3c6ef35f,%eax
    ac3f:	a3 60 73 04 00       	mov    %eax,0x47360
    ac44:	a1 60 73 04 00       	mov    0x47360,%eax
    ac49:	c1 e8 18             	shr    $0x18,%eax
    ac4c:	0f b6 c0             	movzbl %al,%eax
    ac4f:	5d                   	pop    %ebp
    ac50:	c3                   	ret    

0000ac51 <generateCryptoRangeNonceHelper>:
    ac51:	55                   	push   %ebp
    ac52:	89 e5                	mov    %esp,%ebp
    ac54:	53                   	push   %ebx
    ac55:	83 ec 68             	sub    $0x68,%esp
    ac58:	8b 45 0c             	mov    0xc(%ebp),%eax
    ac5b:	8b 55 10             	mov    0x10(%ebp),%edx
    ac5e:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    ac61:	89 55 f8             	mov    %edx,0xfffffff8(%ebp)
    ac64:	8b 45 14             	mov    0x14(%ebp),%eax
    ac67:	8b 55 18             	mov    0x18(%ebp),%edx
    ac6a:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    ac6d:	89 55 f0             	mov    %edx,0xfffffff0(%ebp)
    ac70:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    ac73:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    ac76:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    ac79:	89 55 dc             	mov    %edx,0xffffffdc(%ebp)
    ac7c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    ac7f:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    ac82:	83 c0 01             	add    $0x1,%eax
    ac85:	83 d2 00             	adc    $0x0,%edx
    ac88:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    ac8b:	89 55 e4             	mov    %edx,0xffffffe4(%ebp)
    ac8e:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,0xffffffd0(%ebp)
    ac95:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,0xffffffd4(%ebp)
    ac9c:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
    aca3:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
    acaa:	83 7d e8 01          	cmpl   $0x1,0xffffffe8(%ebp)
    acae:	7e 05                	jle    acb5 <generateCryptoRangeNonceHelper+0x64>
    acb0:	e9 ae 00 00 00       	jmp    ad63 <generateCryptoRangeNonceHelper+0x112>
    acb5:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    acb8:	8b 54 c5 dc          	mov    0xffffffdc(%ebp,%eax,8),%edx
    acbc:	8b 44 c5 d8          	mov    0xffffffd8(%ebp,%eax,8),%eax
    acc0:	0f ac d0 02          	shrd   $0x2,%edx,%eax
    acc4:	c1 ea 02             	shr    $0x2,%edx
    acc7:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
    acca:	89 55 b8             	mov    %edx,0xffffffb8(%ebp)
    accd:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    acd0:	8b 4c c5 d8          	mov    0xffffffd8(%ebp,%eax,8),%ecx
    acd4:	8b 5c c5 dc          	mov    0xffffffdc(%ebp,%eax,8),%ebx
    acd8:	89 c8                	mov    %ecx,%eax
    acda:	83 e0 03             	and    $0x3,%eax
    acdd:	89 da                	mov    %ebx,%edx
    acdf:	83 e2 00             	and    $0x0,%edx
    ace2:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
    ace5:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
    ace9:	7e 16                	jle    ad01 <generateCryptoRangeNonceHelper+0xb0>
    aceb:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    acee:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
    acf1:	89 d1                	mov    %edx,%ecx
    acf3:	33 4d b8             	xor    0xffffffb8(%ebp),%ecx
    acf6:	33 45 b4             	xor    0xffffffb4(%ebp),%eax
    acf9:	09 c8                	or     %ecx,%eax
    acfb:	85 c0                	test   %eax,%eax
    acfd:	75 02                	jne    ad01 <generateCryptoRangeNonceHelper+0xb0>
    acff:	eb 40                	jmp    ad41 <generateCryptoRangeNonceHelper+0xf0>
    ad01:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp,1)
    ad08:	00 
    ad09:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    ad10:	00 
    ad11:	8d 45 a0             	lea    0xffffffa0(%ebp),%eax
    ad14:	89 04 24             	mov    %eax,(%esp,1)
    ad17:	e8 35 df ff ff       	call   8c51 <__constant_c_and_count_memset>
    ad1c:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
    ad1f:	8b 55 b8             	mov    0xffffffb8(%ebp),%edx
    ad22:	89 45 a0             	mov    %eax,0xffffffa0(%ebp)
    ad25:	89 55 a4             	mov    %edx,0xffffffa4(%ebp)
    ad28:	8b 45 08             	mov    0x8(%ebp),%eax
    ad2b:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    ad2f:	8d 45 bc             	lea    0xffffffbc(%ebp),%eax
    ad32:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ad36:	8d 45 a0             	lea    0xffffffa0(%ebp),%eax
    ad39:	89 04 24             	mov    %eax,(%esp,1)
    ad3c:	e8 fc ff ff ff       	call   ad3d <generateCryptoRangeNonceHelper+0xec>
    ad41:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
    ad44:	8b 54 85 bc          	mov    0xffffffbc(%ebp,%eax,4),%edx
    ad48:	8d 45 cc             	lea    0xffffffcc(%ebp),%eax
    ad4b:	31 10                	xor    %edx,(%eax)
    ad4d:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
    ad50:	8b 55 b8             	mov    0xffffffb8(%ebp),%edx
    ad53:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    ad56:	89 55 d4             	mov    %edx,0xffffffd4(%ebp)
    ad59:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
    ad5c:	ff 00                	incl   (%eax)
    ad5e:	e9 47 ff ff ff       	jmp    acaa <generateCryptoRangeNonceHelper+0x59>
    ad63:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    ad66:	83 c4 68             	add    $0x68,%esp
    ad69:	5b                   	pop    %ebx
    ad6a:	5d                   	pop    %ebp
    ad6b:	c3                   	ret    

0000ad6c <generateCryptoSingleNonceHelper>:
    ad6c:	55                   	push   %ebp
    ad6d:	89 e5                	mov    %esp,%ebp
    ad6f:	53                   	push   %ebx
    ad70:	83 ec 48             	sub    $0x48,%esp
    ad73:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad76:	8b 55 10             	mov    0x10(%ebp),%edx
    ad79:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    ad7c:	89 55 f8             	mov    %edx,0xfffffff8(%ebp)
    ad7f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    ad82:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    ad85:	0f ac d0 02          	shrd   $0x2,%edx,%eax
    ad89:	c1 ea 02             	shr    $0x2,%edx
    ad8c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    ad8f:	89 55 f0             	mov    %edx,0xfffffff0(%ebp)
    ad92:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
    ad95:	8b 5d f8             	mov    0xfffffff8(%ebp),%ebx
    ad98:	89 c8                	mov    %ecx,%eax
    ad9a:	83 e0 03             	and    $0x3,%eax
    ad9d:	89 da                	mov    %ebx,%edx
    ad9f:	83 e2 00             	and    $0x0,%edx
    ada2:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    ada5:	8d 45 c8             	lea    0xffffffc8(%ebp),%eax
    ada8:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
    adab:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp,1)
    adb2:	00 
    adb3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    adba:	00 
    adbb:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
    adbe:	89 04 24             	mov    %eax,(%esp,1)
    adc1:	e8 8b de ff ff       	call   8c51 <__constant_c_and_count_memset>
    adc6:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    adca:	74 53                	je     ae1f <generateCryptoSingleNonceHelper+0xb3>
    adcc:	8b 45 14             	mov    0x14(%ebp),%eax
    adcf:	83 c0 0c             	add    $0xc,%eax
    add2:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
    add5:	8b 45 14             	mov    0x14(%ebp),%eax
    add8:	83 38 00             	cmpl   $0x0,(%eax)
    addb:	74 1a                	je     adf7 <generateCryptoSingleNonceHelper+0x8b>
    addd:	8b 45 14             	mov    0x14(%ebp),%eax
    ade0:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    ade3:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    ade6:	89 50 04             	mov    %edx,0x4(%eax)
    ade9:	89 48 08             	mov    %ecx,0x8(%eax)
    adec:	8b 45 14             	mov    0x14(%ebp),%eax
    adef:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    adf5:	eb 28                	jmp    ae1f <generateCryptoSingleNonceHelper+0xb3>
    adf7:	8b 45 14             	mov    0x14(%ebp),%eax
    adfa:	8b 50 08             	mov    0x8(%eax),%edx
    adfd:	8b 40 04             	mov    0x4(%eax),%eax
    ae00:	89 d1                	mov    %edx,%ecx
    ae02:	33 4d f0             	xor    0xfffffff0(%ebp),%ecx
    ae05:	33 45 ec             	xor    0xffffffec(%ebp),%eax
    ae08:	09 c8                	or     %ecx,%eax
    ae0a:	85 c0                	test   %eax,%eax
    ae0c:	75 02                	jne    ae10 <generateCryptoSingleNonceHelper+0xa4>
    ae0e:	eb 34                	jmp    ae44 <generateCryptoSingleNonceHelper+0xd8>
    ae10:	8b 4d 14             	mov    0x14(%ebp),%ecx
    ae13:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    ae16:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    ae19:	89 41 04             	mov    %eax,0x4(%ecx)
    ae1c:	89 51 08             	mov    %edx,0x8(%ecx)
    ae1f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    ae22:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    ae25:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    ae28:	89 55 dc             	mov    %edx,0xffffffdc(%ebp)
    ae2b:	8b 45 08             	mov    0x8(%ebp),%eax
    ae2e:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    ae32:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    ae35:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ae39:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
    ae3c:	89 04 24             	mov    %eax,(%esp,1)
    ae3f:	e8 fc ff ff ff       	call   ae40 <generateCryptoSingleNonceHelper+0xd4>
    ae44:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    ae47:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ae4e:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    ae51:	8b 04 10             	mov    (%eax,%edx,1),%eax
    ae54:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
    ae57:	83 7d e8 03          	cmpl   $0x3,0xffffffe8(%ebp)
    ae5b:	75 50                	jne    aead <generateCryptoSingleNonceHelper+0x141>
    ae5d:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
    ae60:	83 00 01             	addl   $0x1,(%eax)
    ae63:	83 50 04 00          	adcl   $0x0,0x4(%eax)
    ae67:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    ae6a:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    ae6d:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    ae70:	89 55 dc             	mov    %edx,0xffffffdc(%ebp)
    ae73:	8b 45 08             	mov    0x8(%ebp),%eax
    ae76:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    ae7a:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    ae7d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ae81:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
    ae84:	89 04 24             	mov    %eax,(%esp,1)
    ae87:	e8 fc ff ff ff       	call   ae88 <generateCryptoSingleNonceHelper+0x11c>
    ae8c:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    ae8f:	8b 10                	mov    (%eax),%edx
    ae91:	8d 45 c0             	lea    0xffffffc0(%ebp),%eax
    ae94:	31 10                	xor    %edx,(%eax)
    ae96:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    ae9a:	74 24                	je     aec0 <generateCryptoSingleNonceHelper+0x154>
    ae9c:	8b 4d 14             	mov    0x14(%ebp),%ecx
    ae9f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    aea2:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    aea5:	89 41 04             	mov    %eax,0x4(%ecx)
    aea8:	89 51 08             	mov    %edx,0x8(%ecx)
    aeab:	eb 13                	jmp    aec0 <generateCryptoSingleNonceHelper+0x154>
    aead:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    aeb0:	c1 e0 02             	shl    $0x2,%eax
    aeb3:	03 45 c4             	add    0xffffffc4(%ebp),%eax
    aeb6:	83 c0 04             	add    $0x4,%eax
    aeb9:	8b 10                	mov    (%eax),%edx
    aebb:	8d 45 c0             	lea    0xffffffc0(%ebp),%eax
    aebe:	31 10                	xor    %edx,(%eax)
    aec0:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
    aec3:	83 c4 48             	add    $0x48,%esp
    aec6:	5b                   	pop    %ebx
    aec7:	5d                   	pop    %ebp
    aec8:	c3                   	ret    

0000aec9 <tcp_checksum_complete_user>:
    aec9:	55                   	push   %ebp
    aeca:	89 e5                	mov    %esp,%ebp
    aecc:	83 ec 0c             	sub    $0xc,%esp
    aecf:	ff 05 04 00 00 00    	incl   0x4
    aed5:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
    aedc:	8b 45 0c             	mov    0xc(%ebp),%eax
    aedf:	80 b8 a3 00 00 00 02 	cmpb   $0x2,0xa3(%eax)
    aee6:	74 1d                	je     af05 <tcp_checksum_complete_user+0x3c>
    aee8:	8b 45 0c             	mov    0xc(%ebp),%eax
    aeeb:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    aeef:	8b 45 08             	mov    0x8(%ebp),%eax
    aef2:	89 04 24             	mov    %eax,(%esp,1)
    aef5:	e8 9f 60 ff ff       	call   f99 <__tcp_checksum_complete_user>
    aefa:	85 c0                	test   %eax,%eax
    aefc:	74 07                	je     af05 <tcp_checksum_complete_user+0x3c>
    aefe:	c7 45 fc 01 00 00 00 	movl   $0x1,0xfffffffc(%ebp)
    af05:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    af08:	c9                   	leave  
    af09:	c3                   	ret    

0000af0a <trickles_init_tcp_cb>:
    af0a:	55                   	push   %ebp
    af0b:	89 e5                	mov    %esp,%ebp
    af0d:	8b 45 08             	mov    0x8(%ebp),%eax
    af10:	83 c0 30             	add    $0x30,%eax
    af13:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
    af1a:	8b 45 08             	mov    0x8(%ebp),%eax
    af1d:	83 c0 30             	add    $0x30,%eax
    af20:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
    af27:	8b 45 08             	mov    0x8(%ebp),%eax
    af2a:	83 c0 30             	add    $0x30,%eax
    af2d:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
    af34:	8b 45 08             	mov    0x8(%ebp),%eax
    af37:	83 c0 30             	add    $0x30,%eax
    af3a:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
    af41:	8b 45 08             	mov    0x8(%ebp),%eax
    af44:	83 c0 30             	add    $0x30,%eax
    af47:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
    af4e:	5d                   	pop    %ebp
    af4f:	c3                   	ret    

0000af50 <cleanTxQueue>:
    af50:	55                   	push   %ebp
    af51:	89 e5                	mov    %esp,%ebp
    af53:	83 ec 14             	sub    $0x14,%esp
    af56:	8b 45 08             	mov    0x8(%ebp),%eax
    af59:	05 bc 00 00 00       	add    $0xbc,%eax
    af5e:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    af61:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
    af68:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    af6b:	8b 80 ec 09 00 00    	mov    0x9ec(%eax),%eax
    af71:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    af74:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    af77:	05 ec 09 00 00       	add    $0x9ec,%eax
    af7c:	39 45 f8             	cmp    %eax,0xfffffff8(%ebp)
    af7f:	75 02                	jne    af83 <cleanTxQueue+0x33>
    af81:	eb 4f                	jmp    afd2 <cleanTxQueue+0x82>
    af83:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    af86:	83 c0 30             	add    $0x30,%eax
    af89:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    af8c:	8b 40 14             	mov    0x14(%eax),%eax
    af8f:	3b 82 e0 09 00 00    	cmp    0x9e0(%edx),%eax
    af95:	77 31                	ja     afc8 <cleanTxQueue+0x78>
    af97:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    af9a:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    af9d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    afa0:	8b 40 04             	mov    0x4(%eax),%eax
    afa3:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    afa6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    afa9:	05 ec 09 00 00       	add    $0x9ec,%eax
    afae:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    afb2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    afb5:	89 04 24             	mov    %eax,(%esp,1)
    afb8:	e8 61 df ff ff       	call   8f1e <__skb_unlink>
    afbd:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    afc0:	89 04 24             	mov    %eax,(%esp,1)
    afc3:	e8 cd dd ff ff       	call   8d95 <kfree_skb>
    afc8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    afcb:	8b 00                	mov    (%eax),%eax
    afcd:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    afd0:	eb a2                	jmp    af74 <cleanTxQueue+0x24>
    afd2:	c9                   	leave  
    afd3:	c3                   	ret    

0000afd4 <processIncompleteResponse>:
    afd4:	55                   	push   %ebp
    afd5:	89 e5                	mov    %esp,%ebp
    afd7:	83 ec 3c             	sub    $0x3c,%esp
    afda:	8b 45 08             	mov    0x8(%ebp),%eax
    afdd:	05 bc 00 00 00       	add    $0xbc,%eax
    afe2:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    afe5:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
    afec:	8b 45 0c             	mov    0xc(%ebp),%eax
    afef:	8b 40 04             	mov    0x4(%eax),%eax
    aff2:	89 04 24             	mov    %eax,(%esp,1)
    aff5:	e8 fc ff ff ff       	call   aff6 <processIncompleteResponse+0x22>
    affa:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    affd:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b000:	8b 80 e0 09 00 00    	mov    0x9e0(%eax),%eax
    b006:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    b009:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    b00c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    b00f:	3b 82 e0 09 00 00    	cmp    0x9e0(%edx),%eax
    b015:	76 64                	jbe    b07b <processIncompleteResponse+0xa7>
    b017:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    b01a:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    b01d:	89 82 e0 09 00 00    	mov    %eax,0x9e0(%edx)
    b023:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b026:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    b029:	8b 80 e0 09 00 00    	mov    0x9e0(%eax),%eax
    b02f:	3b 82 e8 09 00 00    	cmp    0x9e8(%edx),%eax
    b035:	76 44                	jbe    b07b <processIncompleteResponse+0xa7>
    b037:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b03a:	8b 80 e8 09 00 00    	mov    0x9e8(%eax),%eax
    b040:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    b044:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b047:	8b 80 e0 09 00 00    	mov    0x9e0(%eax),%eax
    b04d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b051:	c7 04 24 c0 3d 00 00 	movl   $0x3dc0,(%esp,1)
    b058:	e8 fc ff ff ff       	call   b059 <processIncompleteResponse+0x85>
    b05d:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    b060:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b063:	8b 80 e8 09 00 00    	mov    0x9e8(%eax),%eax
    b069:	89 82 e0 09 00 00    	mov    %eax,0x9e0(%edx)
    b06f:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,0xffffffd8(%ebp)
    b076:	e9 63 02 00 00       	jmp    b2de <processIncompleteResponse+0x30a>
    b07b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b07e:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    b081:	8b 80 e0 09 00 00    	mov    0x9e0(%eax),%eax
    b087:	29 d0                	sub    %edx,%eax
    b089:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    b08c:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
    b090:	75 34                	jne    b0c6 <processIncompleteResponse+0xf2>
    b092:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
    b095:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b098:	8b 90 e0 09 00 00    	mov    0x9e0(%eax),%edx
    b09e:	8b 81 e4 09 00 00    	mov    0x9e4(%ecx),%eax
    b0a4:	29 d0                	sub    %edx,%eax
    b0a6:	3b 05 00 00 00 00    	cmp    0x0,%eax
    b0ac:	72 18                	jb     b0c6 <processIncompleteResponse+0xf2>
    b0ae:	c7 04 24 00 3e 00 00 	movl   $0x3e00,(%esp,1)
    b0b5:	e8 fc ff ff ff       	call   b0b6 <processIncompleteResponse+0xe2>
    b0ba:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,0xffffffd8(%ebp)
    b0c1:	e9 18 02 00 00       	jmp    b2de <processIncompleteResponse+0x30a>
    b0c6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b0c9:	8b 80 ec 09 00 00    	mov    0x9ec(%eax),%eax
    b0cf:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    b0d2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b0d5:	05 ec 09 00 00       	add    $0x9ec,%eax
    b0da:	39 45 f4             	cmp    %eax,0xfffffff4(%ebp)
    b0dd:	75 05                	jne    b0e4 <processIncompleteResponse+0x110>
    b0df:	e9 83 00 00 00       	jmp    b167 <processIncompleteResponse+0x193>
    b0e4:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b0e7:	83 c0 30             	add    $0x30,%eax
    b0ea:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    b0ed:	8b 40 14             	mov    0x14(%eax),%eax
    b0f0:	3b 82 e0 09 00 00    	cmp    0x9e0(%edx),%eax
    b0f6:	77 31                	ja     b129 <processIncompleteResponse+0x155>
    b0f8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b0fb:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    b0fe:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b101:	8b 40 04             	mov    0x4(%eax),%eax
    b104:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    b107:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b10a:	05 ec 09 00 00       	add    $0x9ec,%eax
    b10f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b113:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    b116:	89 04 24             	mov    %eax,(%esp,1)
    b119:	e8 00 de ff ff       	call   8f1e <__skb_unlink>
    b11e:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    b121:	89 04 24             	mov    %eax,(%esp,1)
    b124:	e8 6c dc ff ff       	call   8d95 <kfree_skb>
    b129:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b12c:	83 c0 30             	add    $0x30,%eax
    b12f:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    b132:	8b 40 10             	mov    0x10(%eax),%eax
    b135:	3b 82 e0 09 00 00    	cmp    0x9e0(%edx),%eax
    b13b:	77 1d                	ja     b15a <processIncompleteResponse+0x186>
    b13d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b140:	83 c0 30             	add    $0x30,%eax
    b143:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    b146:	8b 40 14             	mov    0x14(%eax),%eax
    b149:	3b 82 e0 09 00 00    	cmp    0x9e0(%edx),%eax
    b14f:	76 09                	jbe    b15a <processIncompleteResponse+0x186>
    b151:	c7 45 f0 01 00 00 00 	movl   $0x1,0xfffffff0(%ebp)
    b158:	eb 0d                	jmp    b167 <processIncompleteResponse+0x193>
    b15a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b15d:	8b 00                	mov    (%eax),%eax
    b15f:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    b162:	e9 6b ff ff ff       	jmp    b0d2 <processIncompleteResponse+0xfe>
    b167:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp,1)
    b16e:	e8 fc ff ff ff       	call   b16f <processIncompleteResponse+0x19b>
    b173:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    b176:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    b17a:	75 18                	jne    b194 <processIncompleteResponse+0x1c0>
    b17c:	c7 04 24 60 3e 00 00 	movl   $0x3e60,(%esp,1)
    b183:	e8 fc ff ff ff       	call   b184 <processIncompleteResponse+0x1b0>
    b188:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,0xffffffd8(%ebp)
    b18f:	e9 4a 01 00 00       	jmp    b2de <processIncompleteResponse+0x30a>
    b194:	8b 45 10             	mov    0x10(%ebp),%eax
    b197:	83 e8 08             	sub    $0x8,%eax
    b19a:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    b19d:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp,1)
    b1a4:	00 
    b1a5:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    b1a8:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b1ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    b1af:	83 c0 08             	add    $0x8,%eax
    b1b2:	89 04 24             	mov    %eax,(%esp,1)
    b1b5:	e8 1f 12 00 00       	call   c3d9 <kmalloc_dup>
    b1ba:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    b1bd:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
    b1c1:	75 23                	jne    b1e6 <processIncompleteResponse+0x212>
    b1c3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    b1c6:	89 04 24             	mov    %eax,(%esp,1)
    b1c9:	e8 fc ff ff ff       	call   b1ca <processIncompleteResponse+0x1f6>
    b1ce:	c7 04 24 ab 3e 00 00 	movl   $0x3eab,(%esp,1)
    b1d5:	e8 fc ff ff ff       	call   b1d6 <processIncompleteResponse+0x202>
    b1da:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,0xffffffd8(%ebp)
    b1e1:	e9 f8 00 00 00       	jmp    b2de <processIncompleteResponse+0x30a>
    b1e6:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
    b1ea:	75 67                	jne    b253 <processIncompleteResponse+0x27f>
    b1ec:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b1ef:	83 b8 f8 09 00 00 00 	cmpl   $0x0,0x9f8(%eax)
    b1f6:	74 14                	je     b20c <processIncompleteResponse+0x238>
    b1f8:	c7 44 24 04 3c 05 00 	movl   $0x53c,0x4(%esp,1)
    b1ff:	00 
    b200:	c7 04 24 e0 3e 00 00 	movl   $0x3ee0,(%esp,1)
    b207:	e8 fc ff ff ff       	call   b208 <processIncompleteResponse+0x234>
    b20c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b20f:	c7 80 dc 09 00 00 02 	movl   $0x2,0x9dc(%eax)
    b216:	00 00 00 
    b219:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    b21c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    b21f:	89 82 f8 09 00 00    	mov    %eax,0x9f8(%edx)
    b225:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp,1)
    b22c:	ff 
    b22d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp,1)
    b234:	00 
    b235:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    b238:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    b23c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    b23f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b243:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    b246:	89 04 24             	mov    %eax,(%esp,1)
    b249:	e8 42 11 00 00       	call   c390 <initIncompleteConversionRequest>
    b24e:	e9 84 00 00 00       	jmp    b2d7 <processIncompleteResponse+0x303>
    b253:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b256:	83 b8 f8 09 00 00 00 	cmpl   $0x0,0x9f8(%eax)
    b25d:	74 14                	je     b273 <processIncompleteResponse+0x29f>
    b25f:	c7 44 24 04 45 05 00 	movl   $0x545,0x4(%esp,1)
    b266:	00 
    b267:	c7 04 24 e0 3e 00 00 	movl   $0x3ee0,(%esp,1)
    b26e:	e8 fc ff ff ff       	call   b26f <processIncompleteResponse+0x29b>
    b273:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b276:	c7 80 dc 09 00 00 01 	movl   $0x1,0x9dc(%eax)
    b27d:	00 00 00 
    b280:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b283:	c7 80 f8 09 00 00 00 	movl   $0x0,0x9f8(%eax)
    b28a:	00 00 00 
    b28d:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
    b290:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b293:	83 c0 30             	add    $0x30,%eax
    b296:	8b 50 10             	mov    0x10(%eax),%edx
    b299:	8b 81 e0 09 00 00    	mov    0x9e0(%ecx),%eax
    b29f:	29 d0                	sub    %edx,%eax
    b2a1:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    b2a5:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b2a8:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    b2ac:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    b2af:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    b2b3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    b2b6:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b2ba:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    b2bd:	89 04 24             	mov    %eax,(%esp,1)
    b2c0:	e8 cb 10 00 00       	call   c390 <initIncompleteConversionRequest>
    b2c5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    b2c8:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b2cc:	8b 45 08             	mov    0x8(%ebp),%eax
    b2cf:	89 04 24             	mov    %eax,(%esp,1)
    b2d2:	e8 b1 e4 ff ff       	call   9788 <queueNewRequest>
    b2d7:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
    b2de:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    b2e1:	c9                   	leave  
    b2e2:	c3                   	ret    

0000b2e3 <addNewUC_Continuation>:
    b2e3:	55                   	push   %ebp
    b2e4:	89 e5                	mov    %esp,%ebp
    b2e6:	83 ec 5c             	sub    $0x5c,%esp
    b2e9:	8b 45 08             	mov    0x8(%ebp),%eax
    b2ec:	05 bc 00 00 00       	add    $0xbc,%eax
    b2f1:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    b2f4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b2f7:	05 00 0a 00 00       	add    $0xa00,%eax
    b2fc:	8b 00                	mov    (%eax),%eax
    b2fe:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    b301:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b304:	05 00 0a 00 00       	add    $0xa00,%eax
    b309:	39 45 f8             	cmp    %eax,0xfffffff8(%ebp)
    b30c:	75 02                	jne    b310 <addNewUC_Continuation+0x2d>
    b30e:	eb 1a                	jmp    b32a <addNewUC_Continuation+0x47>
    b310:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    b313:	8b 55 0c             	mov    0xc(%ebp),%edx
    b316:	8b 40 18             	mov    0x18(%eax),%eax
    b319:	3b 42 10             	cmp    0x10(%edx),%eax
    b31c:	73 02                	jae    b320 <addNewUC_Continuation+0x3d>
    b31e:	eb 0a                	jmp    b32a <addNewUC_Continuation+0x47>
    b320:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    b323:	8b 00                	mov    (%eax),%eax
    b325:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    b328:	eb d7                	jmp    b301 <addNewUC_Continuation+0x1e>
    b32a:	8b 55 0c             	mov    0xc(%ebp),%edx
    b32d:	8b 45 0c             	mov    0xc(%ebp),%eax
    b330:	8b 40 10             	mov    0x10(%eax),%eax
    b333:	89 42 18             	mov    %eax,0x18(%edx)
    b336:	8b 55 0c             	mov    0xc(%ebp),%edx
    b339:	8b 45 0c             	mov    0xc(%ebp),%eax
    b33c:	8b 40 14             	mov    0x14(%eax),%eax
    b33f:	89 42 1c             	mov    %eax,0x1c(%edx)
    b342:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b345:	05 00 0a 00 00       	add    $0xa00,%eax
    b34a:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    b34d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    b350:	8b 40 04             	mov    0x4(%eax),%eax
    b353:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    b357:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    b35a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b35e:	8b 45 0c             	mov    0xc(%ebp),%eax
    b361:	89 04 24             	mov    %eax,(%esp,1)
    b364:	e8 c9 df ff ff       	call   9332 <insert>
    b369:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    b36c:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    b36f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b372:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
    b375:	75 09                	jne    b380 <addNewUC_Continuation+0x9d>
    b377:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b37a:	8b 40 04             	mov    0x4(%eax),%eax
    b37d:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    b380:	8b 45 0c             	mov    0xc(%ebp),%eax
    b383:	8b 40 1c             	mov    0x1c(%eax),%eax
    b386:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    b389:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b38c:	8b 40 04             	mov    0x4(%eax),%eax
    b38f:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
    b392:	75 05                	jne    b399 <addNewUC_Continuation+0xb6>
    b394:	e9 b7 02 00 00       	jmp    b650 <addNewUC_Continuation+0x36d>
    b399:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b39c:	8b 40 04             	mov    0x4(%eax),%eax
    b39f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    b3a2:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    b3a5:	8b 40 18             	mov    0x18(%eax),%eax
    b3a8:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    b3ab:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b3ae:	8b 40 18             	mov    0x18(%eax),%eax
    b3b1:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    b3b4:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    b3b7:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    b3ba:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    b3bd:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
    b3c0:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
    b3c3:	3b 45 dc             	cmp    0xffffffdc(%ebp),%eax
    b3c6:	73 06                	jae    b3ce <addNewUC_Continuation+0xeb>
    b3c8:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    b3cb:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
    b3ce:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
    b3d1:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    b3d4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    b3d7:	8b 40 1c             	mov    0x1c(%eax),%eax
    b3da:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    b3dd:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b3e0:	8b 40 1c             	mov    0x1c(%eax),%eax
    b3e3:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    b3e6:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    b3e9:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
    b3ec:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    b3ef:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
    b3f2:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
    b3f5:	3b 45 e0             	cmp    0xffffffe0(%ebp),%eax
    b3f8:	76 06                	jbe    b400 <addNewUC_Continuation+0x11d>
    b3fa:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    b3fd:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
    b400:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
    b403:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    b406:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    b409:	3b 45 d8             	cmp    0xffffffd8(%ebp),%eax
    b40c:	0f 83 29 02 00 00    	jae    b63b <addNewUC_Continuation+0x358>
    b412:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
    b419:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
    b420:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
    b427:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
    b42e:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
    b435:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b438:	8b 00                	mov    (%eax),%eax
    b43a:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
    b43d:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    b440:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
    b443:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    b446:	8b 40 04             	mov    0x4(%eax),%eax
    b449:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
    b44c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b44f:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    b452:	8b 40 0c             	mov    0xc(%eax),%eax
    b455:	3b 42 0c             	cmp    0xc(%edx),%eax
    b458:	76 0e                	jbe    b468 <addNewUC_Continuation+0x185>
    b45a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    b45d:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    b460:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b463:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    b466:	eb 0c                	jmp    b474 <addNewUC_Continuation+0x191>
    b468:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b46b:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    b46e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    b471:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    b474:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    b477:	8b 40 18             	mov    0x18(%eax),%eax
    b47a:	3b 45 e4             	cmp    0xffffffe4(%ebp),%eax
    b47d:	73 06                	jae    b485 <addNewUC_Continuation+0x1a2>
    b47f:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    b482:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
    b485:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    b488:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    b48b:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    b48e:	8b 40 1c             	mov    0x1c(%eax),%eax
    b491:	3b 45 d8             	cmp    0xffffffd8(%ebp),%eax
    b494:	76 44                	jbe    b4da <addNewUC_Continuation+0x1f7>
    b496:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    b499:	3b 45 d0             	cmp    0xffffffd0(%ebp),%eax
    b49c:	75 34                	jne    b4d2 <addNewUC_Continuation+0x1ef>
    b49e:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    b4a1:	89 04 24             	mov    %eax,(%esp,1)
    b4a4:	e8 da ed ff ff       	call   a283 <copyUC_Continuation>
    b4a9:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
    b4ac:	83 7d bc 00          	cmpl   $0x0,0xffffffbc(%ebp)
    b4b0:	75 18                	jne    b4ca <addNewUC_Continuation+0x1e7>
    b4b2:	c7 04 24 40 3f 00 00 	movl   $0x3f40,(%esp,1)
    b4b9:	e8 fc ff ff ff       	call   b4ba <addNewUC_Continuation+0x1d7>
    b4be:	c7 45 b8 ff ff ff ff 	movl   $0xffffffff,0xffffffb8(%ebp)
    b4c5:	e9 98 01 00 00       	jmp    b662 <addNewUC_Continuation+0x37f>
    b4ca:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    b4cd:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    b4d0:	eb 3e                	jmp    b510 <addNewUC_Continuation+0x22d>
    b4d2:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    b4d5:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    b4d8:	eb 36                	jmp    b510 <addNewUC_Continuation+0x22d>
    b4da:	83 7d d4 00          	cmpl   $0x0,0xffffffd4(%ebp)
    b4de:	75 30                	jne    b510 <addNewUC_Continuation+0x22d>
    b4e0:	83 7d d0 00          	cmpl   $0x0,0xffffffd0(%ebp)
    b4e4:	75 14                	jne    b4fa <addNewUC_Continuation+0x217>
    b4e6:	c7 44 24 04 cf 05 00 	movl   $0x5cf,0x4(%esp,1)
    b4ed:	00 
    b4ee:	c7 04 24 80 3f 00 00 	movl   $0x3f80,(%esp,1)
    b4f5:	e8 fc ff ff ff       	call   b4f6 <addNewUC_Continuation+0x213>
    b4fa:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    b4fd:	89 04 24             	mov    %eax,(%esp,1)
    b500:	e8 e7 dd ff ff       	call   92ec <unlink>
    b505:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    b508:	89 04 24             	mov    %eax,(%esp,1)
    b50b:	e8 fc ff ff ff       	call   b50c <addNewUC_Continuation+0x229>
    b510:	83 7d d4 00          	cmpl   $0x0,0xffffffd4(%ebp)
    b514:	74 1d                	je     b533 <addNewUC_Continuation+0x250>
    b516:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    b519:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
    b51d:	74 0b                	je     b52a <addNewUC_Continuation+0x247>
    b51f:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    b522:	89 04 24             	mov    %eax,(%esp,1)
    b525:	e8 c2 dd ff ff       	call   92ec <unlink>
    b52a:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
    b52d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    b530:	89 42 1c             	mov    %eax,0x1c(%edx)
    b533:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
    b537:	74 14                	je     b54d <addNewUC_Continuation+0x26a>
    b539:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    b53c:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
    b540:	74 0b                	je     b54d <addNewUC_Continuation+0x26a>
    b542:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    b545:	89 04 24             	mov    %eax,(%esp,1)
    b548:	e8 9f dd ff ff       	call   92ec <unlink>
    b54d:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
    b551:	74 1d                	je     b570 <addNewUC_Continuation+0x28d>
    b553:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    b556:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
    b55a:	74 0b                	je     b567 <addNewUC_Continuation+0x284>
    b55c:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    b55f:	89 04 24             	mov    %eax,(%esp,1)
    b562:	e8 85 dd ff ff       	call   92ec <unlink>
    b567:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    b56a:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    b56d:	89 42 18             	mov    %eax,0x18(%edx)
    b570:	83 7d d4 00          	cmpl   $0x0,0xffffffd4(%ebp)
    b574:	74 1f                	je     b595 <addNewUC_Continuation+0x2b2>
    b576:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
    b579:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    b57d:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    b580:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b584:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    b587:	89 04 24             	mov    %eax,(%esp,1)
    b58a:	e8 a3 dd ff ff       	call   9332 <insert>
    b58f:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    b592:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
    b595:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
    b599:	74 1f                	je     b5ba <addNewUC_Continuation+0x2d7>
    b59b:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
    b59e:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    b5a2:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    b5a5:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b5a9:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    b5ac:	89 04 24             	mov    %eax,(%esp,1)
    b5af:	e8 7e dd ff ff       	call   9332 <insert>
    b5b4:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    b5b7:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
    b5ba:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
    b5be:	74 1f                	je     b5df <addNewUC_Continuation+0x2fc>
    b5c0:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
    b5c3:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    b5c7:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    b5ca:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b5ce:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    b5d1:	89 04 24             	mov    %eax,(%esp,1)
    b5d4:	e8 59 dd ff ff       	call   9332 <insert>
    b5d9:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    b5dc:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
    b5df:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    b5e2:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
    b5e5:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    b5e8:	8b 40 04             	mov    0x4(%eax),%eax
    b5eb:	3b 45 c0             	cmp    0xffffffc0(%ebp),%eax
    b5ee:	75 02                	jne    b5f2 <addNewUC_Continuation+0x30f>
    b5f0:	eb 43                	jmp    b635 <addNewUC_Continuation+0x352>
    b5f2:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    b5f5:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
    b5f8:	74 30                	je     b62a <addNewUC_Continuation+0x347>
    b5fa:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    b5fd:	8b 40 04             	mov    0x4(%eax),%eax
    b600:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
    b603:	74 25                	je     b62a <addNewUC_Continuation+0x347>
    b605:	8b 4d bc             	mov    0xffffffbc(%ebp),%ecx
    b608:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    b60b:	8b 50 04             	mov    0x4(%eax),%edx
    b60e:	8b 41 1c             	mov    0x1c(%ecx),%eax
    b611:	3b 42 18             	cmp    0x18(%edx),%eax
    b614:	76 14                	jbe    b62a <addNewUC_Continuation+0x347>
    b616:	c7 44 24 04 f7 05 00 	movl   $0x5f7,0x4(%esp,1)
    b61d:	00 
    b61e:	c7 04 24 c0 3f 00 00 	movl   $0x3fc0,(%esp,1)
    b625:	e8 fc ff ff ff       	call   b626 <addNewUC_Continuation+0x343>
    b62a:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    b62d:	8b 40 04             	mov    0x4(%eax),%eax
    b630:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
    b633:	eb b0                	jmp    b5e5 <addNewUC_Continuation+0x302>
    b635:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    b638:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    b63b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    b63e:	3b 45 e8             	cmp    0xffffffe8(%ebp),%eax
    b641:	72 02                	jb     b645 <addNewUC_Continuation+0x362>
    b643:	eb 0b                	jmp    b650 <addNewUC_Continuation+0x36d>
    b645:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    b648:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    b64b:	e9 39 fd ff ff       	jmp    b389 <addNewUC_Continuation+0xa6>
    b650:	8b 45 08             	mov    0x8(%ebp),%eax
    b653:	89 04 24             	mov    %eax,(%esp,1)
    b656:	e8 fc ff ff ff       	call   b657 <addNewUC_Continuation+0x374>
    b65b:	c7 45 b8 00 00 00 00 	movl   $0x0,0xffffffb8(%ebp)
    b662:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
    b665:	c9                   	leave  
    b666:	c3                   	ret    

0000b667 <removeObsoleteDataRequestMaps>:
    b667:	55                   	push   %ebp
    b668:	89 e5                	mov    %esp,%ebp
    b66a:	83 ec 68             	sub    $0x68,%esp
    b66d:	8b 45 08             	mov    0x8(%ebp),%eax
    b670:	05 bc 00 00 00       	add    $0xbc,%eax
    b675:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    b678:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b67b:	05 ac 09 00 00       	add    $0x9ac,%eax
    b680:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    b683:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b686:	05 c0 09 00 00       	add    $0x9c0,%eax
    b68b:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    b68e:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
    b695:	83 7d f8 01          	cmpl   $0x1,0xfffffff8(%ebp)
    b699:	7e 05                	jle    b6a0 <removeObsoleteDataRequestMaps+0x39>
    b69b:	e9 ff 02 00 00       	jmp    b99f <removeObsoleteDataRequestMaps+0x338>
    b6a0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    b6a3:	8b 44 85 e8          	mov    0xffffffe8(%ebp,%eax,4),%eax
    b6a7:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    b6aa:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    b6ad:	8b 40 04             	mov    0x4(%eax),%eax
    b6b0:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    b6b3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b6b6:	3b 45 e4             	cmp    0xffffffe4(%ebp),%eax
    b6b9:	75 05                	jne    b6c0 <removeObsoleteDataRequestMaps+0x59>
    b6bb:	e9 d5 02 00 00       	jmp    b995 <removeObsoleteDataRequestMaps+0x32e>
    b6c0:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
    b6c7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b6ca:	8b 40 04             	mov    0x4(%eax),%eax
    b6cd:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    b6d0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b6d3:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    b6d6:	8b 40 24             	mov    0x24(%eax),%eax
    b6d9:	3b 42 08             	cmp    0x8(%edx),%eax
    b6dc:	0f 87 a1 00 00 00    	ja     b783 <removeObsoleteDataRequestMaps+0x11c>
    b6e2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b6e5:	89 04 24             	mov    %eax,(%esp,1)
    b6e8:	e8 ff db ff ff       	call   92ec <unlink>
    b6ed:	ff 05 a4 00 00 00    	incl   0xa4
    b6f3:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    b6fa:	7e 6a                	jle    b766 <removeObsoleteDataRequestMaps+0xff>
    b6fc:	8b 0d a4 00 00 00    	mov    0xa4,%ecx
    b702:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
    b707:	f7 e9                	imul   %ecx
    b709:	c1 fa 06             	sar    $0x6,%edx
    b70c:	89 c8                	mov    %ecx,%eax
    b70e:	c1 f8 1f             	sar    $0x1f,%eax
    b711:	29 c2                	sub    %eax,%edx
    b713:	89 d0                	mov    %edx,%eax
    b715:	69 c0 e8 03 00 00    	imul   $0x3e8,%eax,%eax
    b71b:	29 c1                	sub    %eax,%ecx
    b71d:	89 c8                	mov    %ecx,%eax
    b71f:	85 c0                	test   %eax,%eax
    b721:	75 43                	jne    b766 <removeObsoleteDataRequestMaps+0xff>
    b723:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b726:	8b 80 d0 02 00 00    	mov    0x2d0(%eax),%eax
    b72c:	83 e0 07             	and    $0x7,%eax
    b72f:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    b733:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b736:	8b 80 d0 02 00 00    	mov    0x2d0(%eax),%eax
    b73c:	c1 f8 03             	sar    $0x3,%eax
    b73f:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    b743:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    b746:	a1 00 00 00 00       	mov    0x0,%eax
    b74b:	2b 42 28             	sub    0x28(%edx),%eax
    b74e:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    b752:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp,1)
    b759:	00 
    b75a:	c7 04 24 60 40 00 00 	movl   $0x4060,(%esp,1)
    b761:	e8 fc ff ff ff       	call   b762 <removeObsoleteDataRequestMaps+0xfb>
    b766:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b769:	89 04 24             	mov    %eax,(%esp,1)
    b76c:	e8 c8 df ff ff       	call   9739 <freeDataRequestMapping>
    b771:	c7 45 e0 01 00 00 00 	movl   $0x1,0xffffffe0(%ebp)
    b778:	8b 45 08             	mov    0x8(%ebp),%eax
    b77b:	89 04 24             	mov    %eax,(%esp,1)
    b77e:	e8 fc ff ff ff       	call   b77f <removeObsoleteDataRequestMaps+0x118>
    b783:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
    b787:	0f 85 fd 01 00 00    	jne    b98a <removeObsoleteDataRequestMaps+0x323>
    b78d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b790:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
    b794:	0f 84 f0 01 00 00    	je     b98a <removeObsoleteDataRequestMaps+0x323>
    b79a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b79d:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
    b7a1:	0f 85 e3 01 00 00    	jne    b98a <removeObsoleteDataRequestMaps+0x323>
    b7a7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b7aa:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    b7ad:	8b 80 e0 02 00 00    	mov    0x2e0(%eax),%eax
    b7b3:	3b 42 1c             	cmp    0x1c(%edx),%eax
    b7b6:	0f 82 ce 01 00 00    	jb     b98a <removeObsoleteDataRequestMaps+0x323>
    b7bc:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b7bf:	8b 00                	mov    (%eax),%eax
    b7c1:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    b7c4:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b7c7:	8b 40 04             	mov    0x4(%eax),%eax
    b7ca:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    b7cd:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
    b7d4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b7d7:	8b 40 08             	mov    0x8(%eax),%eax
    b7da:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    b7dd:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b7e0:	8b 40 20             	mov    0x20(%eax),%eax
    b7e3:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
    b7e6:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    b7e9:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
    b7ec:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    b7ef:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
    b7f2:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
    b7f5:	3b 45 c8             	cmp    0xffffffc8(%ebp),%eax
    b7f8:	73 06                	jae    b800 <removeObsoleteDataRequestMaps+0x199>
    b7fa:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    b7fd:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
    b800:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
    b803:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    b806:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b809:	8b 80 e8 02 00 00    	mov    0x2e8(%eax),%eax
    b80f:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
    b812:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b815:	89 04 24             	mov    %eax,(%esp,1)
    b818:	e8 cf da ff ff       	call   92ec <unlink>
    b81d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b820:	05 78 09 00 00       	add    $0x978,%eax
    b825:	8b 00                	mov    (%eax),%eax
    b827:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
    b82a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    b82d:	05 78 09 00 00       	add    $0x978,%eax
    b832:	39 45 c4             	cmp    %eax,0xffffffc4(%ebp)
    b835:	75 05                	jne    b83c <removeObsoleteDataRequestMaps+0x1d5>
    b837:	e9 c1 00 00 00       	jmp    b8fd <removeObsoleteDataRequestMaps+0x296>
    b83c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b83f:	8b 40 20             	mov    0x20(%eax),%eax
    b842:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    b845:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    b848:	83 c0 30             	add    $0x30,%eax
    b84b:	8b 40 10             	mov    0x10(%eax),%eax
    b84e:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
    b851:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    b854:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
    b857:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    b85a:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
    b85d:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
    b860:	3b 45 c0             	cmp    0xffffffc0(%ebp),%eax
    b863:	73 06                	jae    b86b <removeObsoleteDataRequestMaps+0x204>
    b865:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
    b868:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
    b86b:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
    b86e:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
    b871:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b874:	8b 40 24             	mov    0x24(%eax),%eax
    b877:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
    b87a:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    b87d:	83 c0 30             	add    $0x30,%eax
    b880:	8b 40 14             	mov    0x14(%eax),%eax
    b883:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    b886:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
    b889:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
    b88c:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
    b88f:	89 45 ac             	mov    %eax,0xffffffac(%ebp)
    b892:	8b 45 ac             	mov    0xffffffac(%ebp),%eax
    b895:	3b 45 cc             	cmp    0xffffffcc(%ebp),%eax
    b898:	76 06                	jbe    b8a0 <removeObsoleteDataRequestMaps+0x239>
    b89a:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    b89d:	89 45 ac             	mov    %eax,0xffffffac(%ebp)
    b8a0:	8b 45 ac             	mov    0xffffffac(%ebp),%eax
    b8a3:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
    b8a6:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    b8a9:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    b8ac:	3b 42 24             	cmp    0x24(%edx),%eax
    b8af:	72 02                	jb     b8b3 <removeObsoleteDataRequestMaps+0x24c>
    b8b1:	eb 4a                	jmp    b8fd <removeObsoleteDataRequestMaps+0x296>
    b8b3:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    b8b6:	3b 45 bc             	cmp    0xffffffbc(%ebp),%eax
    b8b9:	7d 35                	jge    b8f0 <removeObsoleteDataRequestMaps+0x289>
    b8bb:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    b8be:	3b 45 c8             	cmp    0xffffffc8(%ebp),%eax
    b8c1:	7d 27                	jge    b8ea <removeObsoleteDataRequestMaps+0x283>
    b8c3:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    b8c6:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    b8ca:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    b8cd:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    b8d1:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b8d4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b8d8:	8b 45 08             	mov    0x8(%ebp),%eax
    b8db:	89 04 24             	mov    %eax,(%esp,1)
    b8de:	e8 b7 09 00 00       	call   c29a <submitDerivedDataRequestMapping>
    b8e3:	c7 45 d4 01 00 00 00 	movl   $0x1,0xffffffd4(%ebp)
    b8ea:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    b8ed:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    b8f0:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    b8f3:	8b 00                	mov    (%eax),%eax
    b8f5:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
    b8f8:	e9 2d ff ff ff       	jmp    b82a <removeObsoleteDataRequestMaps+0x1c3>
    b8fd:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    b900:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    b903:	3b 42 24             	cmp    0x24(%edx),%eax
    b906:	73 59                	jae    b961 <removeObsoleteDataRequestMaps+0x2fa>
    b908:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    b90b:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
    b90e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b911:	8b 40 24             	mov    0x24(%eax),%eax
    b914:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
    b917:	83 7d d4 00          	cmpl   $0x0,0xffffffd4(%ebp)
    b91b:	75 22                	jne    b93f <removeObsoleteDataRequestMaps+0x2d8>
    b91d:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    b920:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    b924:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
    b927:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    b92b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b92e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b932:	8b 45 08             	mov    0x8(%ebp),%eax
    b935:	89 04 24             	mov    %eax,(%esp,1)
    b938:	e8 d2 08 00 00       	call   c20f <submitDataRequestMapping>
    b93d:	eb 4b                	jmp    b98a <removeObsoleteDataRequestMaps+0x323>
    b93f:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
    b942:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    b946:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
    b949:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    b94d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b950:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b954:	8b 45 08             	mov    0x8(%ebp),%eax
    b957:	89 04 24             	mov    %eax,(%esp,1)
    b95a:	e8 3b 09 00 00       	call   c29a <submitDerivedDataRequestMapping>
    b95f:	eb 29                	jmp    b98a <removeObsoleteDataRequestMaps+0x323>
    b961:	83 7d d4 00          	cmpl   $0x0,0xffffffd4(%ebp)
    b965:	75 23                	jne    b98a <removeObsoleteDataRequestMaps+0x323>
    b967:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b96a:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%eax)
    b971:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    b974:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    b978:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    b97b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    b97f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b982:	89 04 24             	mov    %eax,(%esp,1)
    b985:	e8 a8 d9 ff ff       	call   9332 <insert>
    b98a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b98d:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    b990:	e9 1e fd ff ff       	jmp    b6b3 <removeObsoleteDataRequestMaps+0x4c>
    b995:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
    b998:	ff 00                	incl   (%eax)
    b99a:	e9 f6 fc ff ff       	jmp    b695 <removeObsoleteDataRequestMaps+0x2e>
    b99f:	c9                   	leave  
    b9a0:	c3                   	ret    

0000b9a1 <tcp_fast_path_queue>:
    b9a1:	55                   	push   %ebp
    b9a2:	89 e5                	mov    %esp,%ebp
    b9a4:	53                   	push   %ebx
    b9a5:	83 ec 20             	sub    $0x20,%esp
    b9a8:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
    b9af:	8b 45 08             	mov    0x8(%ebp),%eax
    b9b2:	05 bc 00 00 00       	add    $0xbc,%eax
    b9b7:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    b9ba:	8b 45 0c             	mov    0xc(%ebp),%eax
    b9bd:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    b9c3:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    b9c6:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
    b9cd:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
    b9d0:	e8 38 07 00 00       	call   c10d <get_current>
    b9d5:	39 43 40             	cmp    %eax,0x40(%ebx)
    b9d8:	75 2c                	jne    ba06 <tcp_fast_path_queue+0x65>
    b9da:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    b9dd:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    b9e0:	8b 80 fc 00 00 00    	mov    0xfc(%eax),%eax
    b9e6:	3b 42 08             	cmp    0x8(%edx),%eax
    b9e9:	75 1b                	jne    ba06 <tcp_fast_path_queue+0x65>
    b9eb:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    b9ee:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    b9f1:	3b 42 4c             	cmp    0x4c(%edx),%eax
    b9f4:	7f 10                	jg     ba06 <tcp_fast_path_queue+0x65>
    b9f6:	8b 45 08             	mov    0x8(%ebp),%eax
    b9f9:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
    b9fd:	74 07                	je     ba06 <tcp_fast_path_queue+0x65>
    b9ff:	c7 45 e8 01 00 00 00 	movl   $0x1,0xffffffe8(%ebp)
    ba06:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    ba09:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    ba0c:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
    ba10:	0f 95 c0             	setne  %al
    ba13:	0f b6 c0             	movzbl %al,%eax
    ba16:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    ba19:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
    ba1d:	75 05                	jne    ba24 <tcp_fast_path_queue+0x83>
    ba1f:	e9 7e 02 00 00       	jmp    bca2 <tcp_fast_path_queue+0x301>
    ba24:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba27:	8b 40 20             	mov    0x20(%eax),%eax
    ba2a:	80 60 0d fd          	andb   $0xfd,0xd(%eax)
    ba2e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    ba31:	8b 80 ec 01 00 00    	mov    0x1ec(%eax),%eax
    ba37:	83 e0 40             	and    $0x40,%eax
    ba3a:	85 c0                	test   %eax,%eax
    ba3c:	0f 85 5f 01 00 00    	jne    bba1 <tcp_fast_path_queue+0x200>
    ba42:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba45:	83 c0 30             	add    $0x30,%eax
    ba48:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    ba4b:	8b 40 10             	mov    0x10(%eax),%eax
    ba4e:	3b 42 08             	cmp    0x8(%edx),%eax
    ba51:	74 23                	je     ba76 <tcp_fast_path_queue+0xd5>
    ba53:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    ba56:	8b 40 08             	mov    0x8(%eax),%eax
    ba59:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    ba5d:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba60:	83 c0 30             	add    $0x30,%eax
    ba63:	8b 40 10             	mov    0x10(%eax),%eax
    ba66:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ba6a:	c7 04 24 a0 40 00 00 	movl   $0x40a0,(%esp,1)
    ba71:	e8 fc ff ff ff       	call   ba72 <tcp_fast_path_queue+0xd1>
    ba76:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
    ba7a:	74 51                	je     bacd <tcp_fast_path_queue+0x12c>
    ba7c:	c7 04 24 c6 40 00 00 	movl   $0x40c6,(%esp,1)
    ba83:	e8 fc ff ff ff       	call   ba84 <tcp_fast_path_queue+0xe3>
    ba88:	e8 80 06 00 00       	call   c10d <get_current>
    ba8d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    ba93:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    ba9a:	00 
    ba9b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba9e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    baa2:	8b 45 08             	mov    0x8(%ebp),%eax
    baa5:	89 04 24             	mov    %eax,(%esp,1)
    baa8:	e8 dc 8a ff ff       	call   4589 <tcp_copy_to_iovec>
    baad:	85 c0                	test   %eax,%eax
    baaf:	75 1c                	jne    bacd <tcp_fast_path_queue+0x12c>
    bab1:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    bab4:	8b 55 0c             	mov    0xc(%ebp),%edx
    bab7:	83 c2 30             	add    $0x30,%edx
    baba:	8b 52 14             	mov    0x14(%edx),%edx
    babd:	89 50 08             	mov    %edx,0x8(%eax)
    bac0:	ff 05 68 00 00 00    	incl   0x68
    bac6:	c7 45 f8 01 00 00 00 	movl   $0x1,0xfffffff8(%ebp)
    bacd:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    bad1:	0f 85 56 01 00 00    	jne    bc2d <tcp_fast_path_queue+0x28c>
    bad7:	ff 05 64 00 00 00    	incl   0x64
    badd:	8b 45 0c             	mov    0xc(%ebp),%eax
    bae0:	83 c0 30             	add    $0x30,%eax
    bae3:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
    bae7:	74 1e                	je     bb07 <tcp_fast_path_queue+0x166>
    bae9:	8b 45 0c             	mov    0xc(%ebp),%eax
    baec:	83 c0 30             	add    $0x30,%eax
    baef:	8b 40 2c             	mov    0x2c(%eax),%eax
    baf2:	89 04 24             	mov    %eax,(%esp,1)
    baf5:	e8 35 e5 ff ff       	call   a02f <freeClientSide_Continuation>
    bafa:	8b 45 0c             	mov    0xc(%ebp),%eax
    bafd:	83 c0 30             	add    $0x30,%eax
    bb00:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
    bb07:	8b 45 0c             	mov    0xc(%ebp),%eax
    bb0a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    bb0e:	8b 45 08             	mov    0x8(%ebp),%eax
    bb11:	83 c0 48             	add    $0x48,%eax
    bb14:	89 04 24             	mov    %eax,(%esp,1)
    bb17:	e8 1a d3 ff ff       	call   8e36 <__skb_queue_tail>
    bb1c:	8b 45 08             	mov    0x8(%ebp),%eax
    bb1f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    bb23:	8b 45 0c             	mov    0xc(%ebp),%eax
    bb26:	89 04 24             	mov    %eax,(%esp,1)
    bb29:	e8 8c 06 00 00       	call   c1ba <tcp_set_owner_r>
    bb2e:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    bb31:	8b 45 0c             	mov    0xc(%ebp),%eax
    bb34:	83 c0 30             	add    $0x30,%eax
    bb37:	8b 40 14             	mov    0x14(%eax),%eax
    bb3a:	89 42 08             	mov    %eax,0x8(%edx)
    bb3d:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
    bb40:	8b 55 08             	mov    0x8(%ebp),%edx
    bb43:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    bb46:	8b 80 fc 00 00 00    	mov    0xfc(%eax),%eax
    bb4c:	8b 52 38             	mov    0x38(%edx),%edx
    bb4f:	01 c2                	add    %eax,%edx
    bb51:	8b 45 08             	mov    0x8(%ebp),%eax
    bb54:	8b 40 38             	mov    0x38(%eax),%eax
    bb57:	c1 f8 02             	sar    $0x2,%eax
    bb5a:	8d 04 10             	lea    (%eax,%edx,1),%eax
    bb5d:	39 41 08             	cmp    %eax,0x8(%ecx)
    bb60:	0f 86 c7 00 00 00    	jbe    bc2d <tcp_fast_path_queue+0x28c>
    bb66:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    bb6d:	0f 85 ba 00 00 00    	jne    bc2d <tcp_fast_path_queue+0x28c>
    bb73:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
    bb76:	8b 55 08             	mov    0x8(%ebp),%edx
    bb79:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    bb7c:	8b 80 fc 00 00 00    	mov    0xfc(%eax),%eax
    bb82:	8b 52 38             	mov    0x38(%edx),%edx
    bb85:	01 c2                	add    %eax,%edx
    bb87:	8b 41 08             	mov    0x8(%ecx),%eax
    bb8a:	29 d0                	sub    %edx,%eax
    bb8c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    bb90:	c7 04 24 e0 40 00 00 	movl   $0x40e0,(%esp,1)
    bb97:	e8 fc ff ff ff       	call   bb98 <tcp_fast_path_queue+0x1f7>
    bb9c:	e9 8c 00 00 00       	jmp    bc2d <tcp_fast_path_queue+0x28c>
    bba1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    bba4:	83 c1 30             	add    $0x30,%ecx
    bba7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    bbaa:	8b 50 08             	mov    0x8(%eax),%edx
    bbad:	8b 41 14             	mov    0x14(%ecx),%eax
    bbb0:	29 d0                	sub    %edx,%eax
    bbb2:	01 05 00 00 00 00    	add    %eax,0x0
    bbb8:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    bbbb:	8b 45 0c             	mov    0xc(%ebp),%eax
    bbbe:	83 c0 30             	add    $0x30,%eax
    bbc1:	8b 40 14             	mov    0x14(%eax),%eax
    bbc4:	89 42 08             	mov    %eax,0x8(%edx)
    bbc7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    bbca:	8b 45 0c             	mov    0xc(%ebp),%eax
    bbcd:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
    bbd3:	8b 81 b8 00 00 00    	mov    0xb8(%ecx),%eax
    bbd9:	29 d0                	sub    %edx,%eax
    bbdb:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    bbdf:	8b 45 0c             	mov    0xc(%ebp),%eax
    bbe2:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    bbe6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    bbed:	e8 fc ff ff ff       	call   bbee <tcp_fast_path_queue+0x24d>
    bbf2:	8b 45 0c             	mov    0xc(%ebp),%eax
    bbf5:	05 a8 00 00 00       	add    $0xa8,%eax
    bbfa:	8b 00                	mov    (%eax),%eax
    bbfc:	83 f8 01             	cmp    $0x1,%eax
    bbff:	7e 21                	jle    bc22 <tcp_fast_path_queue+0x281>
    bc01:	8b 45 0c             	mov    0xc(%ebp),%eax
    bc04:	05 a8 00 00 00       	add    $0xa8,%eax
    bc09:	8b 00                	mov    (%eax),%eax
    bc0b:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    bc0f:	8b 45 0c             	mov    0xc(%ebp),%eax
    bc12:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    bc16:	c7 04 24 20 41 00 00 	movl   $0x4120,(%esp,1)
    bc1d:	e8 fc ff ff ff       	call   bc1e <tcp_fast_path_queue+0x27d>
    bc22:	8b 45 0c             	mov    0xc(%ebp),%eax
    bc25:	89 04 24             	mov    %eax,(%esp,1)
    bc28:	e8 77 48 ff ff       	call   4a4 <trickles_kfree_skb>
    bc2d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    bc30:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
    bc34:	79 16                	jns    bc4c <tcp_fast_path_queue+0x2ab>
    bc36:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    bc39:	8b 40 08             	mov    0x8(%eax),%eax
    bc3c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    bc40:	c7 04 24 43 41 00 00 	movl   $0x4143,(%esp,1)
    bc47:	e8 fc ff ff ff       	call   bc48 <tcp_fast_path_queue+0x2a7>
    bc4c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    bc4f:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    bc52:	8b 80 d4 09 00 00    	mov    0x9d4(%eax),%eax
    bc58:	3b 42 08             	cmp    0x8(%edx),%eax
    bc5b:	73 0f                	jae    bc6c <tcp_fast_path_queue+0x2cb>
    bc5d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    bc60:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    bc63:	8b 52 08             	mov    0x8(%edx),%edx
    bc66:	89 90 d4 09 00 00    	mov    %edx,0x9d4(%eax)
    bc6c:	c7 44 24 08 01 00 02 	movl   $0x20001,0x8(%esp,1)
    bc73:	00 
    bc74:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    bc7b:	00 
    bc7c:	8b 45 08             	mov    0x8(%ebp),%eax
    bc7f:	89 04 24             	mov    %eax,(%esp,1)
    bc82:	e8 76 d7 ff ff       	call   93fd <sk_wake_async>
    bc87:	8b 45 0c             	mov    0xc(%ebp),%eax
    bc8a:	8b 40 20             	mov    0x20(%eax),%eax
    bc8d:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    bc91:	24 01                	and    $0x1,%al
    bc93:	84 c0                	test   %al,%al
    bc95:	74 0b                	je     bca2 <tcp_fast_path_queue+0x301>
    bc97:	8b 45 08             	mov    0x8(%ebp),%eax
    bc9a:	89 04 24             	mov    %eax,(%esp,1)
    bc9d:	e8 fc ff ff ff       	call   bc9e <tcp_fast_path_queue+0x2fd>
    bca2:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    bca6:	74 0d                	je     bcb5 <tcp_fast_path_queue+0x314>
    bca8:	8b 45 0c             	mov    0xc(%ebp),%eax
    bcab:	89 04 24             	mov    %eax,(%esp,1)
    bcae:	e8 f1 47 ff ff       	call   4a4 <trickles_kfree_skb>
    bcb3:	eb 19                	jmp    bcce <tcp_fast_path_queue+0x32d>
    bcb5:	8b 45 08             	mov    0x8(%ebp),%eax
    bcb8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    bcbf:	00 
    bcc0:	8b 55 08             	mov    0x8(%ebp),%edx
    bcc3:	89 14 24             	mov    %edx,(%esp,1)
    bcc6:	8b 80 d4 0b 00 00    	mov    0xbd4(%eax),%eax
    bccc:	ff d0                	call   *%eax
    bcce:	83 c4 20             	add    $0x20,%esp
    bcd1:	5b                   	pop    %ebx
    bcd2:	5d                   	pop    %ebp
    bcd3:	c3                   	ret    

0000bcd4 <addDataRequest>:
    bcd4:	55                   	push   %ebp
    bcd5:	89 e5                	mov    %esp,%ebp
    bcd7:	53                   	push   %ebx
    bcd8:	83 ec 1c             	sub    $0x1c,%esp
    bcdb:	8b 45 08             	mov    0x8(%ebp),%eax
    bcde:	05 bc 00 00 00       	add    $0xbc,%eax
    bce3:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    bce6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    bce9:	8b 80 ac 09 00 00    	mov    0x9ac(%eax),%eax
    bcef:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    bcf2:	8b 45 14             	mov    0x14(%ebp),%eax
    bcf5:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    bcf9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    bcfc:	05 ac 09 00 00       	add    $0x9ac,%eax
    bd01:	89 04 24             	mov    %eax,(%esp,1)
    bd04:	e8 6b d5 ff ff       	call   9274 <insert_tail>
    bd09:	8b 45 14             	mov    0x14(%ebp),%eax
    bd0c:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    bd13:	8b 45 14             	mov    0x14(%ebp),%eax
    bd16:	8b 55 14             	mov    0x14(%ebp),%edx
    bd19:	8b 40 20             	mov    0x20(%eax),%eax
    bd1c:	3b 42 24             	cmp    0x24(%edx),%eax
    bd1f:	72 14                	jb     bd35 <addDataRequest+0x61>
    bd21:	c7 44 24 04 24 12 00 	movl   $0x1224,0x4(%esp,1)
    bd28:	00 
    bd29:	c7 04 24 60 41 00 00 	movl   $0x4160,(%esp,1)
    bd30:	e8 fc ff ff ff       	call   bd31 <addDataRequest+0x5d>
    bd35:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    bd38:	05 ac 09 00 00       	add    $0x9ac,%eax
    bd3d:	39 45 f4             	cmp    %eax,0xfffffff4(%ebp)
    bd40:	74 31                	je     bd73 <addDataRequest+0x9f>
    bd42:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    bd45:	8b 40 1c             	mov    0x1c(%eax),%eax
    bd48:	3b 45 10             	cmp    0x10(%ebp),%eax
    bd4b:	76 26                	jbe    bd73 <addDataRequest+0x9f>
    bd4d:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    bd54:	75 1d                	jne    bd73 <addDataRequest+0x9f>
    bd56:	8b 45 10             	mov    0x10(%ebp),%eax
    bd59:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    bd5d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    bd60:	8b 40 1c             	mov    0x1c(%eax),%eax
    bd63:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    bd67:	c7 04 24 c0 41 00 00 	movl   $0x41c0,(%esp,1)
    bd6e:	e8 fc ff ff ff       	call   bd6f <addDataRequest+0x9b>
    bd73:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp,1)
    bd7a:	00 
    bd7b:	8b 45 0c             	mov    0xc(%ebp),%eax
    bd7e:	89 04 24             	mov    %eax,(%esp,1)
    bd81:	e8 54 08 00 00       	call   c5da <skb_can_put>
    bd86:	85 c0                	test   %eax,%eax
    bd88:	75 15                	jne    bd9f <addDataRequest+0xcb>
    bd8a:	c7 04 24 40 42 00 00 	movl   $0x4240,(%esp,1)
    bd91:	e8 fc ff ff ff       	call   bd92 <addDataRequest+0xbe>
    bd96:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
    bd9d:	eb 44                	jmp    bde3 <addDataRequest+0x10f>
    bd9f:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp,1)
    bda6:	00 
    bda7:	8b 45 0c             	mov    0xc(%ebp),%eax
    bdaa:	89 04 24             	mov    %eax,(%esp,1)
    bdad:	e8 b9 d1 ff ff       	call   8f6b <skb_put>
    bdb2:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    bdb5:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    bdb8:	8b 45 14             	mov    0x14(%ebp),%eax
    bdbb:	8b 40 20             	mov    0x20(%eax),%eax
    bdbe:	89 04 24             	mov    %eax,(%esp,1)
    bdc1:	e8 fc ff ff ff       	call   bdc2 <addDataRequest+0xee>
    bdc6:	89 03                	mov    %eax,(%ebx)
    bdc8:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    bdcb:	8b 45 14             	mov    0x14(%ebp),%eax
    bdce:	8b 40 24             	mov    0x24(%eax),%eax
    bdd1:	89 04 24             	mov    %eax,(%esp,1)
    bdd4:	e8 fc ff ff ff       	call   bdd5 <addDataRequest+0x101>
    bdd9:	89 43 04             	mov    %eax,0x4(%ebx)
    bddc:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
    bde3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    bde6:	83 c4 1c             	add    $0x1c,%esp
    bde9:	5b                   	pop    %ebx
    bdea:	5d                   	pop    %ebp
    bdeb:	c3                   	ret    

0000bdec <clientSideContinuation_init>:
    bdec:	55                   	push   %ebp
    bded:	89 e5                	mov    %esp,%ebp
    bdef:	5d                   	pop    %ebp
    bdf0:	c3                   	ret    

0000bdf1 <atomic_add>:
 * Atomically adds @i to @v.  Note that the guaranteed useful range
 * of an atomic_t is only 24 bits.
 */
static __inline__ void atomic_add(int i, atomic_t *v)
{
    bdf1:	55                   	push   %ebp
    bdf2:	89 e5                	mov    %esp,%ebp
	__asm__ __volatile__(
    bdf4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    bdf7:	8b 55 08             	mov    0x8(%ebp),%edx
    bdfa:	8b 45 0c             	mov    0xc(%ebp),%eax
    bdfd:	01 11                	add    %edx,(%ecx)
		LOCK "addl %1,%0"
		:"=m" (v->counter)
		:"ir" (i), "m" (v->counter));
}
    bdff:	5d                   	pop    %ebp
    be00:	c3                   	ret    

0000be01 <atomic_sub>:

/**
 * atomic_sub - subtract the atomic variable
 * @i: integer value to subtract
 * @v: pointer of type atomic_t
 * 
 * Atomically subtracts @i from @v.  Note that the guaranteed
 * useful range of an atomic_t is only 24 bits.
 */
static __inline__ void atomic_sub(int i, atomic_t *v)
{
    be01:	55                   	push   %ebp
    be02:	89 e5                	mov    %esp,%ebp
	__asm__ __volatile__(
    be04:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    be07:	8b 55 08             	mov    0x8(%ebp),%edx
    be0a:	8b 45 0c             	mov    0xc(%ebp),%eax
    be0d:	29 11                	sub    %edx,(%ecx)
		LOCK "subl %1,%0"
		:"=m" (v->counter)
		:"ir" (i), "m" (v->counter));
}
    be0f:	5d                   	pop    %ebp
    be10:	c3                   	ret    

0000be11 <atomic_inc>:

/**
 * atomic_sub_and_test - subtract value from variable and test result
 * @i: integer value to subtract
 * @v: pointer of type atomic_t
 * 
 * Atomically subtracts @i from @v and returns
 * true if the result is zero, or false for all
 * other cases.  Note that the guaranteed
 * useful range of an atomic_t is only 24 bits.
 */
static __inline__ int atomic_sub_and_test(int i, atomic_t *v)
{
	unsigned char c;

	__asm__ __volatile__(
		LOCK "subl %2,%0; sete %1"
		:"=m" (v->counter), "=qm" (c)
		:"ir" (i), "m" (v->counter) : "memory");
	return c;
}

/**
 * atomic_inc - increment atomic variable
 * @v: pointer of type atomic_t
 * 
 * Atomically increments @v by 1.  Note that the guaranteed
 * useful range of an atomic_t is only 24 bits.
 */ 
static __inline__ void atomic_inc(atomic_t *v)
{
    be11:	55                   	push   %ebp
    be12:	89 e5                	mov    %esp,%ebp
	__asm__ __volatile__(
    be14:	8b 55 08             	mov    0x8(%ebp),%edx
    be17:	8b 45 08             	mov    0x8(%ebp),%eax
    be1a:	ff 02                	incl   (%edx)
		LOCK "incl %0"
		:"=m" (v->counter)
		:"m" (v->counter));
}
    be1c:	5d                   	pop    %ebp
    be1d:	c3                   	ret    

0000be1e <atomic_dec>:

/**
 * atomic_dec - decrement atomic variable
 * @v: pointer of type atomic_t
 * 
 * Atomically decrements @v by 1.  Note that the guaranteed
 * useful range of an atomic_t is only 24 bits.
 */ 
static __inline__ void atomic_dec(atomic_t *v)
{
    be1e:	55                   	push   %ebp
    be1f:	89 e5                	mov    %esp,%ebp
	__asm__ __volatile__(
    be21:	8b 55 08             	mov    0x8(%ebp),%edx
    be24:	8b 45 08             	mov    0x8(%ebp),%eax
    be27:	ff 0a                	decl   (%edx)
		LOCK "decl %0"
		:"=m" (v->counter)
		:"m" (v->counter));
}
    be29:	5d                   	pop    %ebp
    be2a:	c3                   	ret    

0000be2b <strcpy>:
 */

#define __HAVE_ARCH_STRCPY
static inline char * strcpy(char * dest,const char *src)
{
    be2b:	55                   	push   %ebp
    be2c:	89 e5                	mov    %esp,%ebp
    be2e:	57                   	push   %edi
    be2f:	56                   	push   %esi
    be30:	83 ec 0c             	sub    $0xc,%esp
int d0, d1, d2;
__asm__ __volatile__(
    be33:	8b 75 0c             	mov    0xc(%ebp),%esi
    be36:	8b 7d 08             	mov    0x8(%ebp),%edi
    be39:	ac                   	lods   %ds:(%esi),%al
    be3a:	aa                   	stos   %al,%es:(%edi)
    be3b:	84 c0                	test   %al,%al
    be3d:	75 fa                	jne    be39 <strcpy+0xe>
    be3f:	89 c2                	mov    %eax,%edx
    be41:	89 f0                	mov    %esi,%eax
    be43:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    be46:	89 f8                	mov    %edi,%eax
    be48:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    be4b:	89 d0                	mov    %edx,%eax
    be4d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	"1:\tlodsb\n\t"
	"stosb\n\t"
	"testb %%al,%%al\n\t"
	"jne 1b"
	: "=&S" (d0), "=&D" (d1), "=&a" (d2)
	:"0" (src),"1" (dest) : "memory");
return dest;
    be50:	8b 45 08             	mov    0x8(%ebp),%eax
}
    be53:	83 c4 0c             	add    $0xc,%esp
    be56:	5e                   	pop    %esi
    be57:	5f                   	pop    %edi
    be58:	5d                   	pop    %ebp
    be59:	c3                   	ret    

0000be5a <__constant_memcpy>:

#define __HAVE_ARCH_STRNCPY
static inline char * strncpy(char * dest,const char *src,size_t count)
{
int d0, d1, d2, d3;
__asm__ __volatile__(
	"1:\tdecl %2\n\t"
	"js 2f\n\t"
	"lodsb\n\t"
	"stosb\n\t"
	"testb %%al,%%al\n\t"
	"jne 1b\n\t"
	"rep\n\t"
	"stosb\n"
	"2:"
	: "=&S" (d0), "=&D" (d1), "=&c" (d2), "=&a" (d3)
	:"0" (src),"1" (dest),"2" (count) : "memory");
return dest;
}

#define __HAVE_ARCH_STRCAT
static inline char * strcat(char * dest,const char * src)
{
int d0, d1, d2, d3;
__asm__ __volatile__(
	"repne\n\t"
	"scasb\n\t"
	"decl %1\n"
	"1:\tlodsb\n\t"
	"stosb\n\t"
	"testb %%al,%%al\n\t"
	"jne 1b"
	: "=&S" (d0), "=&D" (d1), "=&a" (d2), "=&c" (d3)
	: "0" (src), "1" (dest), "2" (0), "3" (0xffffffff):"memory");
return dest;
}

#define __HAVE_ARCH_STRNCAT
static inline char * strncat(char * dest,const char * src,size_t count)
{
int d0, d1, d2, d3;
__asm__ __volatile__(
	"repne\n\t"
	"scasb\n\t"
	"decl %1\n\t"
	"movl %8,%3\n"
	"1:\tdecl %3\n\t"
	"js 2f\n\t"
	"lodsb\n\t"
	"stosb\n\t"
	"testb %%al,%%al\n\t"
	"jne 1b\n"
	"2:\txorl %2,%2\n\t"
	"stosb"
	: "=&S" (d0), "=&D" (d1), "=&a" (d2), "=&c" (d3)
	: "0" (src),"1" (dest),"2" (0),"3" (0xffffffff), "g" (count)
	: "memory");
return dest;
}

#define __HAVE_ARCH_STRCMP
static inline int strcmp(const char * cs,const char * ct)
{
int d0, d1;
register int __res;
__asm__ __volatile__(
	"1:\tlodsb\n\t"
	"scasb\n\t"
	"jne 2f\n\t"
	"testb %%al,%%al\n\t"
	"jne 1b\n\t"
	"xorl %%eax,%%eax\n\t"
	"jmp 3f\n"
	"2:\tsbbl %%eax,%%eax\n\t"
	"orb $1,%%al\n"
	"3:"
	:"=a" (__res), "=&S" (d0), "=&D" (d1)
		     :"1" (cs),"2" (ct));
return __res;
}

#define __HAVE_ARCH_STRNCMP
static inline int strncmp(const char * cs,const char * ct,size_t count)
{
register int __res;
int d0, d1, d2;
__asm__ __volatile__(
	"1:\tdecl %3\n\t"
	"js 2f\n\t"
	"lodsb\n\t"
	"scasb\n\t"
	"jne 3f\n\t"
	"testb %%al,%%al\n\t"
	"jne 1b\n"
	"2:\txorl %%eax,%%eax\n\t"
	"jmp 4f\n"
	"3:\tsbbl %%eax,%%eax\n\t"
	"orb $1,%%al\n"
	"4:"
		     :"=a" (__res), "=&S" (d0), "=&D" (d1), "=&c" (d2)
		     :"1" (cs),"2" (ct),"3" (count));
return __res;
}

#define __HAVE_ARCH_STRCHR
static inline char * strchr(const char * s, int c)
{
int d0;
register char * __res;
__asm__ __volatile__(
	"movb %%al,%%ah\n"
	"1:\tlodsb\n\t"
	"cmpb %%ah,%%al\n\t"
	"je 2f\n\t"
	"testb %%al,%%al\n\t"
	"jne 1b\n\t"
	"movl $1,%1\n"
	"2:\tmovl %1,%0\n\t"
	"decl %0"
	:"=a" (__res), "=&S" (d0) : "1" (s),"0" (c));
return __res;
}

#define __HAVE_ARCH_STRRCHR
static inline char * strrchr(const char * s, int c)
{
int d0, d1;
register char * __res;
__asm__ __volatile__(
	"movb %%al,%%ah\n"
	"1:\tlodsb\n\t"
	"cmpb %%ah,%%al\n\t"
	"jne 2f\n\t"
	"leal -1(%%esi),%0\n"
	"2:\ttestb %%al,%%al\n\t"
	"jne 1b"
	:"=g" (__res), "=&S" (d0), "=&a" (d1) :"0" (0),"1" (s),"2" (c));
return __res;
}

#define __HAVE_ARCH_STRLEN
static inline size_t strlen(const char * s)
{
int d0;
register int __res;
__asm__ __volatile__(
	"repne\n\t"
	"scasb\n\t"
	"notl %0\n\t"
	"decl %0"
	:"=c" (__res), "=&D" (d0) :"1" (s),"a" (0), "0" (0xffffffff));
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
int d0, d1, d2;
__asm__ __volatile__(
	"rep ; movsl\n\t"
	"testb $2,%b4\n\t"
	"je 1f\n\t"
	"movsw\n"
	"1:\ttestb $1,%b4\n\t"
	"je 2f\n\t"
	"movsb\n"
	"2:"
	: "=&c" (d0), "=&D" (d1), "=&S" (d2)
	:"0" (n/4), "q" (n),"1" ((long) to),"2" ((long) from)
	: "memory");
return (to);
}

/*
 * This looks horribly ugly, but the compiler can optimize it totally,
 * as the count is constant.
 */
static inline void * __constant_memcpy(void * to, const void * from, size_t n)
{
    be5a:	55                   	push   %ebp
    be5b:	89 e5                	mov    %esp,%ebp
    be5d:	57                   	push   %edi
    be5e:	56                   	push   %esi
    be5f:	83 ec 14             	sub    $0x14,%esp
	switch (n) {
    be62:	83 7d 10 14          	cmpl   $0x14,0x10(%ebp)
    be66:	0f 87 9e 01 00 00    	ja     c00a <__constant_memcpy+0x1b0>
    be6c:	8b 45 10             	mov    0x10(%ebp),%eax
    be6f:	c1 e0 02             	shl    $0x2,%eax
    be72:	8b 80 64 42 00 00    	mov    0x4264(%eax),%eax
    be78:	ff e0                	jmp    *%eax
		case 0:
			return to;
    be7a:	8b 45 08             	mov    0x8(%ebp),%eax
    be7d:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    be80:	e9 42 02 00 00       	jmp    c0c7 <__constant_memcpy+0x26d>
		case 1:
			*(unsigned char *)to = *(const unsigned char *)from;
    be85:	8b 55 08             	mov    0x8(%ebp),%edx
    be88:	8b 45 0c             	mov    0xc(%ebp),%eax
    be8b:	0f b6 00             	movzbl (%eax),%eax
    be8e:	88 02                	mov    %al,(%edx)
			return to;
    be90:	8b 45 08             	mov    0x8(%ebp),%eax
    be93:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    be96:	e9 2c 02 00 00       	jmp    c0c7 <__constant_memcpy+0x26d>
		case 2:
			*(unsigned short *)to = *(const unsigned short *)from;
    be9b:	8b 55 08             	mov    0x8(%ebp),%edx
    be9e:	8b 45 0c             	mov    0xc(%ebp),%eax
    bea1:	0f b7 00             	movzwl (%eax),%eax
    bea4:	66 89 02             	mov    %ax,(%edx)
			return to;
    bea7:	8b 45 08             	mov    0x8(%ebp),%eax
    beaa:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    bead:	e9 15 02 00 00       	jmp    c0c7 <__constant_memcpy+0x26d>
		case 3:
			*(unsigned short *)to = *(const unsigned short *)from;
    beb2:	8b 55 08             	mov    0x8(%ebp),%edx
    beb5:	8b 45 0c             	mov    0xc(%ebp),%eax
    beb8:	0f b7 00             	movzwl (%eax),%eax
    bebb:	66 89 02             	mov    %ax,(%edx)
			*(2+(unsigned char *)to) = *(2+(const unsigned char *)from);
    bebe:	8b 55 08             	mov    0x8(%ebp),%edx
    bec1:	83 c2 02             	add    $0x2,%edx
    bec4:	8b 45 0c             	mov    0xc(%ebp),%eax
    bec7:	83 c0 02             	add    $0x2,%eax
    beca:	0f b6 00             	movzbl (%eax),%eax
    becd:	88 02                	mov    %al,(%edx)
			return to;
    becf:	8b 45 08             	mov    0x8(%ebp),%eax
    bed2:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    bed5:	e9 ed 01 00 00       	jmp    c0c7 <__constant_memcpy+0x26d>
		case 4:
			*(unsigned long *)to = *(const unsigned long *)from;
    beda:	8b 55 08             	mov    0x8(%ebp),%edx
    bedd:	8b 45 0c             	mov    0xc(%ebp),%eax
    bee0:	8b 00                	mov    (%eax),%eax
    bee2:	89 02                	mov    %eax,(%edx)
			return to;
    bee4:	8b 45 08             	mov    0x8(%ebp),%eax
    bee7:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    beea:	e9 d8 01 00 00       	jmp    c0c7 <__constant_memcpy+0x26d>
		case 6:	/* for Ethernet addresses */
			*(unsigned long *)to = *(const unsigned long *)from;
    beef:	8b 55 08             	mov    0x8(%ebp),%edx
    bef2:	8b 45 0c             	mov    0xc(%ebp),%eax
    bef5:	8b 00                	mov    (%eax),%eax
    bef7:	89 02                	mov    %eax,(%edx)
			*(2+(unsigned short *)to) = *(2+(const unsigned short *)from);
    bef9:	8b 55 08             	mov    0x8(%ebp),%edx
    befc:	83 c2 04             	add    $0x4,%edx
    beff:	8b 45 0c             	mov    0xc(%ebp),%eax
    bf02:	83 c0 04             	add    $0x4,%eax
    bf05:	0f b7 00             	movzwl (%eax),%eax
    bf08:	66 89 02             	mov    %ax,(%edx)
			return to;
    bf0b:	8b 45 08             	mov    0x8(%ebp),%eax
    bf0e:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    bf11:	e9 b1 01 00 00       	jmp    c0c7 <__constant_memcpy+0x26d>
		case 8:
			*(unsigned long *)to = *(const unsigned long *)from;
    bf16:	8b 55 08             	mov    0x8(%ebp),%edx
    bf19:	8b 45 0c             	mov    0xc(%ebp),%eax
    bf1c:	8b 00                	mov    (%eax),%eax
    bf1e:	89 02                	mov    %eax,(%edx)
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
    bf20:	8b 55 08             	mov    0x8(%ebp),%edx
    bf23:	83 c2 04             	add    $0x4,%edx
    bf26:	8b 45 0c             	mov    0xc(%ebp),%eax
    bf29:	83 c0 04             	add    $0x4,%eax
    bf2c:	8b 00                	mov    (%eax),%eax
    bf2e:	89 02                	mov    %eax,(%edx)
			return to;
    bf30:	8b 45 08             	mov    0x8(%ebp),%eax
    bf33:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    bf36:	e9 8c 01 00 00       	jmp    c0c7 <__constant_memcpy+0x26d>
		case 12:
			*(unsigned long *)to = *(const unsigned long *)from;
    bf3b:	8b 55 08             	mov    0x8(%ebp),%edx
    bf3e:	8b 45 0c             	mov    0xc(%ebp),%eax
    bf41:	8b 00                	mov    (%eax),%eax
    bf43:	89 02                	mov    %eax,(%edx)
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
    bf45:	8b 55 08             	mov    0x8(%ebp),%edx
    bf48:	83 c2 04             	add    $0x4,%edx
    bf4b:	8b 45 0c             	mov    0xc(%ebp),%eax
    bf4e:	83 c0 04             	add    $0x4,%eax
    bf51:	8b 00                	mov    (%eax),%eax
    bf53:	89 02                	mov    %eax,(%edx)
			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
    bf55:	8b 55 08             	mov    0x8(%ebp),%edx
    bf58:	83 c2 08             	add    $0x8,%edx
    bf5b:	8b 45 0c             	mov    0xc(%ebp),%eax
    bf5e:	83 c0 08             	add    $0x8,%eax
    bf61:	8b 00                	mov    (%eax),%eax
    bf63:	89 02                	mov    %eax,(%edx)
			return to;
    bf65:	8b 45 08             	mov    0x8(%ebp),%eax
    bf68:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    bf6b:	e9 57 01 00 00       	jmp    c0c7 <__constant_memcpy+0x26d>
		case 16:
			*(unsigned long *)to = *(const unsigned long *)from;
    bf70:	8b 55 08             	mov    0x8(%ebp),%edx
    bf73:	8b 45 0c             	mov    0xc(%ebp),%eax
    bf76:	8b 00                	mov    (%eax),%eax
    bf78:	89 02                	mov    %eax,(%edx)
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
    bf7a:	8b 55 08             	mov    0x8(%ebp),%edx
    bf7d:	83 c2 04             	add    $0x4,%edx
    bf80:	8b 45 0c             	mov    0xc(%ebp),%eax
    bf83:	83 c0 04             	add    $0x4,%eax
    bf86:	8b 00                	mov    (%eax),%eax
    bf88:	89 02                	mov    %eax,(%edx)
			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
    bf8a:	8b 55 08             	mov    0x8(%ebp),%edx
    bf8d:	83 c2 08             	add    $0x8,%edx
    bf90:	8b 45 0c             	mov    0xc(%ebp),%eax
    bf93:	83 c0 08             	add    $0x8,%eax
    bf96:	8b 00                	mov    (%eax),%eax
    bf98:	89 02                	mov    %eax,(%edx)
			*(3+(unsigned long *)to) = *(3+(const unsigned long *)from);
    bf9a:	8b 55 08             	mov    0x8(%ebp),%edx
    bf9d:	83 c2 0c             	add    $0xc,%edx
    bfa0:	8b 45 0c             	mov    0xc(%ebp),%eax
    bfa3:	83 c0 0c             	add    $0xc,%eax
    bfa6:	8b 00                	mov    (%eax),%eax
    bfa8:	89 02                	mov    %eax,(%edx)
			return to;
    bfaa:	8b 45 08             	mov    0x8(%ebp),%eax
    bfad:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    bfb0:	e9 12 01 00 00       	jmp    c0c7 <__constant_memcpy+0x26d>
		case 20:
			*(unsigned long *)to = *(const unsigned long *)from;
    bfb5:	8b 55 08             	mov    0x8(%ebp),%edx
    bfb8:	8b 45 0c             	mov    0xc(%ebp),%eax
    bfbb:	8b 00                	mov    (%eax),%eax
    bfbd:	89 02                	mov    %eax,(%edx)
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
    bfbf:	8b 55 08             	mov    0x8(%ebp),%edx
    bfc2:	83 c2 04             	add    $0x4,%edx
    bfc5:	8b 45 0c             	mov    0xc(%ebp),%eax
    bfc8:	83 c0 04             	add    $0x4,%eax
    bfcb:	8b 00                	mov    (%eax),%eax
    bfcd:	89 02                	mov    %eax,(%edx)
			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
    bfcf:	8b 55 08             	mov    0x8(%ebp),%edx
    bfd2:	83 c2 08             	add    $0x8,%edx
    bfd5:	8b 45 0c             	mov    0xc(%ebp),%eax
    bfd8:	83 c0 08             	add    $0x8,%eax
    bfdb:	8b 00                	mov    (%eax),%eax
    bfdd:	89 02                	mov    %eax,(%edx)
			*(3+(unsigned long *)to) = *(3+(const unsigned long *)from);
    bfdf:	8b 55 08             	mov    0x8(%ebp),%edx
    bfe2:	83 c2 0c             	add    $0xc,%edx
    bfe5:	8b 45 0c             	mov    0xc(%ebp),%eax
    bfe8:	83 c0 0c             	add    $0xc,%eax
    bfeb:	8b 00                	mov    (%eax),%eax
    bfed:	89 02                	mov    %eax,(%edx)
			*(4+(unsigned long *)to) = *(4+(const unsigned long *)from);
    bfef:	8b 55 08             	mov    0x8(%ebp),%edx
    bff2:	83 c2 10             	add    $0x10,%edx
    bff5:	8b 45 0c             	mov    0xc(%ebp),%eax
    bff8:	83 c0 10             	add    $0x10,%eax
    bffb:	8b 00                	mov    (%eax),%eax
    bffd:	89 02                	mov    %eax,(%edx)
			return to;
    bfff:	8b 45 08             	mov    0x8(%ebp),%eax
    c002:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    c005:	e9 bd 00 00 00       	jmp    c0c7 <__constant_memcpy+0x26d>
	}
#define COMMON(x) \
__asm__ __volatile__( \
	"rep ; movsl" \
	x \
	: "=&c" (d0), "=&D" (d1), "=&S" (d2) \
	: "0" (n/4),"1" ((long) to),"2" ((long) from) \
	: "memory");
{
	int d0, d1, d2;
	switch (n % 4) {
    c00a:	8b 45 10             	mov    0x10(%ebp),%eax
    c00d:	83 e0 03             	and    $0x3,%eax
    c010:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    c013:	83 7d e4 01          	cmpl   $0x1,0xffffffe4(%ebp)
    c017:	74 35                	je     c04e <__constant_memcpy+0x1f4>
    c019:	83 7d e4 01          	cmpl   $0x1,0xffffffe4(%ebp)
    c01d:	72 08                	jb     c027 <__constant_memcpy+0x1cd>
    c01f:	83 7d e4 02          	cmpl   $0x2,0xffffffe4(%ebp)
    c023:	74 51                	je     c076 <__constant_memcpy+0x21c>
    c025:	eb 78                	jmp    c09f <__constant_memcpy+0x245>
		case 0: COMMON(""); return to;
    c027:	8b 45 10             	mov    0x10(%ebp),%eax
    c02a:	89 c1                	mov    %eax,%ecx
    c02c:	c1 e9 02             	shr    $0x2,%ecx
    c02f:	8b 7d 08             	mov    0x8(%ebp),%edi
    c032:	8b 75 0c             	mov    0xc(%ebp),%esi
    c035:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    c037:	89 c8                	mov    %ecx,%eax
    c039:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    c03c:	89 f8                	mov    %edi,%eax
    c03e:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    c041:	89 f0                	mov    %esi,%eax
    c043:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    c046:	8b 45 08             	mov    0x8(%ebp),%eax
    c049:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    c04c:	eb 79                	jmp    c0c7 <__constant_memcpy+0x26d>
		case 1: COMMON("\n\tmovsb"); return to;
    c04e:	8b 45 10             	mov    0x10(%ebp),%eax
    c051:	89 c1                	mov    %eax,%ecx
    c053:	c1 e9 02             	shr    $0x2,%ecx
    c056:	8b 7d 08             	mov    0x8(%ebp),%edi
    c059:	8b 75 0c             	mov    0xc(%ebp),%esi
    c05c:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    c05e:	a4                   	movsb  %ds:(%esi),%es:(%edi)
    c05f:	89 c8                	mov    %ecx,%eax
    c061:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    c064:	89 f8                	mov    %edi,%eax
    c066:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    c069:	89 f0                	mov    %esi,%eax
    c06b:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    c06e:	8b 45 08             	mov    0x8(%ebp),%eax
    c071:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    c074:	eb 51                	jmp    c0c7 <__constant_memcpy+0x26d>
		case 2: COMMON("\n\tmovsw"); return to;
    c076:	8b 45 10             	mov    0x10(%ebp),%eax
    c079:	89 c1                	mov    %eax,%ecx
    c07b:	c1 e9 02             	shr    $0x2,%ecx
    c07e:	8b 7d 08             	mov    0x8(%ebp),%edi
    c081:	8b 75 0c             	mov    0xc(%ebp),%esi
    c084:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    c086:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    c088:	89 c8                	mov    %ecx,%eax
    c08a:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    c08d:	89 f8                	mov    %edi,%eax
    c08f:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    c092:	89 f0                	mov    %esi,%eax
    c094:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    c097:	8b 45 08             	mov    0x8(%ebp),%eax
    c09a:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    c09d:	eb 28                	jmp    c0c7 <__constant_memcpy+0x26d>
		default: COMMON("\n\tmovsw\n\tmovsb"); return to;
    c09f:	8b 45 10             	mov    0x10(%ebp),%eax
    c0a2:	89 c1                	mov    %eax,%ecx
    c0a4:	c1 e9 02             	shr    $0x2,%ecx
    c0a7:	8b 7d 08             	mov    0x8(%ebp),%edi
    c0aa:	8b 75 0c             	mov    0xc(%ebp),%esi
    c0ad:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    c0af:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    c0b1:	a4                   	movsb  %ds:(%esi),%es:(%edi)
    c0b2:	89 c8                	mov    %ecx,%eax
    c0b4:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    c0b7:	89 f8                	mov    %edi,%eax
    c0b9:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    c0bc:	89 f0                	mov    %esi,%eax
    c0be:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    c0c1:	8b 45 08             	mov    0x8(%ebp),%eax
    c0c4:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
	}
}
  
#undef COMMON
}
    c0c7:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    c0ca:	83 c4 14             	add    $0x14,%esp
    c0cd:	5e                   	pop    %esi
    c0ce:	5f                   	pop    %edi
    c0cf:	5d                   	pop    %ebp
    c0d0:	c3                   	ret    

0000c0d1 <__constant_c_memset>:

#define __HAVE_ARCH_MEMCPY

#ifdef CONFIG_X86_USE_3DNOW

#include <asm/mmx.h>

/*
 *	This CPU favours 3DNow strongly (eg AMD Athlon)
 */

static inline void * __constant_memcpy3d(void * to, const void * from, size_t len)
{
	if (len < 512)
		return __constant_memcpy(to, from, len);
	return _mmx_memcpy(to, from, len);
}

static __inline__ void *__memcpy3d(void *to, const void *from, size_t len)
{
	if (len < 512)
		return __memcpy(to, from, len);
	return _mmx_memcpy(to, from, len);
}

#define memcpy(t, f, n) \
(__builtin_constant_p(n) ? \
 __constant_memcpy3d((t),(f),(n)) : \
 __memcpy3d((t),(f),(n)))

#else

/*
 *	No 3D Now!
 */
 
#define memcpy(t, f, n) \
(__builtin_constant_p(n) ? \
 __constant_memcpy((t),(f),(n)) : \
 __memcpy((t),(f),(n)))

#endif

/*
 * struct_cpy(x,y), copy structure *x into (matching structure) *y.
 *
 * We get link-time errors if the structure sizes do not match.
 * There is no runtime overhead, it's all optimized away at
 * compile time.
 */
extern void __struct_cpy_bug (void);

#define struct_cpy(x,y) 			\
({						\
	if (sizeof(*(x)) != sizeof(*(y))) 	\
		__struct_cpy_bug;		\
	memcpy(x, y, sizeof(*(x)));		\
})

#define __HAVE_ARCH_MEMMOVE
static inline void * memmove(void * dest,const void * src, size_t n)
{
int d0, d1, d2;
if (dest<src)
__asm__ __volatile__(
	"rep\n\t"
	"movsb"
	: "=&c" (d0), "=&S" (d1), "=&D" (d2)
	:"0" (n),"1" (src),"2" (dest)
	: "memory");
else
__asm__ __volatile__(
	"std\n\t"
	"rep\n\t"
	"movsb\n\t"
	"cld"
	: "=&c" (d0), "=&S" (d1), "=&D" (d2)
	:"0" (n),
	 "1" (n-1+(const char *)src),
	 "2" (n-1+(char *)dest)
	:"memory");
return dest;
}

#define memcmp __builtin_memcmp

#define __HAVE_ARCH_MEMCHR
static inline void * memchr(const void * cs,int c,size_t count)
{
int d0;
register void * __res;
if (!count)
	return NULL;
__asm__ __volatile__(
	"repne\n\t"
	"scasb\n\t"
	"je 1f\n\t"
	"movl $1,%0\n"
	"1:\tdecl %0"
	:"=D" (__res), "=&c" (d0) : "a" (c),"0" (cs),"1" (count));
return __res;
}

static inline void * __memset_generic(void * s, char c,size_t count)
{
int d0, d1;
__asm__ __volatile__(
	"rep\n\t"
	"stosb"
	: "=&c" (d0), "=&D" (d1)
	:"a" (c),"1" (s),"0" (count)
	:"memory");
return s;
}

/* we might want to write optimized versions of these later */
#define __constant_count_memset(s,c,count) __memset_generic((s),(c),(count))

/*
 * memset(x,0,y) is a reasonably common thing to do, so we want to fill
 * things 32 bits at a time even when we don't know the size of the
 * area at compile-time..
 */
static inline void * __constant_c_memset(void * s, unsigned long c, size_t count)
{
    c0d1:	55                   	push   %ebp
    c0d2:	89 e5                	mov    %esp,%ebp
    c0d4:	57                   	push   %edi
    c0d5:	53                   	push   %ebx
    c0d6:	83 ec 08             	sub    $0x8,%esp
int d0, d1;
__asm__ __volatile__(
    c0d9:	8b 55 0c             	mov    0xc(%ebp),%edx
    c0dc:	8b 4d 10             	mov    0x10(%ebp),%ecx
    c0df:	c1 e9 02             	shr    $0x2,%ecx
    c0e2:	8b 7d 08             	mov    0x8(%ebp),%edi
    c0e5:	89 d0                	mov    %edx,%eax
    c0e7:	8b 5d 10             	mov    0x10(%ebp),%ebx
    c0ea:	f3 ab                	repz stos %eax,%es:(%edi)
    c0ec:	f6 c3 02             	test   $0x2,%bl
    c0ef:	74 02                	je     c0f3 <__constant_c_memset+0x22>
    c0f1:	66 ab                	stos   %ax,%es:(%edi)
    c0f3:	f6 c3 01             	test   $0x1,%bl
    c0f6:	74 01                	je     c0f9 <__constant_c_memset+0x28>
    c0f8:	aa                   	stos   %al,%es:(%edi)
    c0f9:	89 c8                	mov    %ecx,%eax
    c0fb:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    c0fe:	89 f8                	mov    %edi,%eax
    c100:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	"rep ; stosl\n\t"
	"testb $2,%b3\n\t"
	"je 1f\n\t"
	"stosw\n"
	"1:\ttestb $1,%b3\n\t"
	"je 2f\n\t"
	"stosb\n"
	"2:"
	: "=&c" (d0), "=&D" (d1)
	:"a" (c), "q" (count), "0" (count/4), "1" ((long) s)
	:"memory");
return (s);	
    c103:	8b 45 08             	mov    0x8(%ebp),%eax
}
    c106:	83 c4 08             	add    $0x8,%esp
    c109:	5b                   	pop    %ebx
    c10a:	5f                   	pop    %edi
    c10b:	5d                   	pop    %ebp
    c10c:	c3                   	ret    

0000c10d <get_current>:

struct task_struct;

static inline struct task_struct * get_current(void)
{
    c10d:	55                   	push   %ebp
    c10e:	89 e5                	mov    %esp,%ebp
    c110:	83 ec 04             	sub    $0x4,%esp
	struct task_struct *current;
	__asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
    c113:	b8 00 e0 ff ff       	mov    $0xffffe000,%eax
    c118:	21 e0                	and    %esp,%eax
    c11a:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	return current;
    c11d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
 }
    c120:	c9                   	leave  
    c121:	c3                   	ret    

0000c122 <skb_is_nonlinear>:
	return result;
}

static inline int skb_is_nonlinear(const struct sk_buff *skb)
{
    c122:	55                   	push   %ebp
    c123:	89 e5                	mov    %esp,%ebp
	return skb->data_len;
    c125:	8b 45 08             	mov    0x8(%ebp),%eax
    c128:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
}
    c12e:	5d                   	pop    %ebp
    c12f:	c3                   	ret    

0000c130 <skb_headlen>:

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
    c130:	55                   	push   %ebp
    c131:	89 e5                	mov    %esp,%ebp
	return skb->len - skb->data_len;
    c133:	8b 4d 08             	mov    0x8(%ebp),%ecx
    c136:	8b 45 08             	mov    0x8(%ebp),%eax
    c139:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
    c13f:	8b 81 94 00 00 00    	mov    0x94(%ecx),%eax
    c145:	29 d0                	sub    %edx,%eax
}
    c147:	5d                   	pop    %ebp
    c148:	c3                   	ret    

0000c149 <csum_fold>:
 *	Fold a partial checksum
 */

static inline unsigned int csum_fold(unsigned int sum)
{
    c149:	55                   	push   %ebp
    c14a:	89 e5                	mov    %esp,%ebp
	__asm__(
    c14c:	8b 45 08             	mov    0x8(%ebp),%eax
    c14f:	89 c2                	mov    %eax,%edx
    c151:	c1 e2 10             	shl    $0x10,%edx
    c154:	8b 45 08             	mov    0x8(%ebp),%eax
    c157:	25 00 00 ff ff       	and    $0xffff0000,%eax
    c15c:	01 d0                	add    %edx,%eax
    c15e:	15 ff ff 00 00       	adc    $0xffff,%eax
    c163:	89 45 08             	mov    %eax,0x8(%ebp)
		"addl %1, %0		;\n"
		"adcl $0xffff, %0	;\n"
		: "=r" (sum)
		: "r" (sum << 16), "0" (sum & 0xffff0000)
	);
	return (~sum) >> 16;
    c166:	8b 45 08             	mov    0x8(%ebp),%eax
    c169:	f7 d0                	not    %eax
    c16b:	c1 e8 10             	shr    $0x10,%eax
}
    c16e:	5d                   	pop    %ebp
    c16f:	c3                   	ret    

0000c170 <csum_tcpudp_magic>:

static inline unsigned long csum_tcpudp_nofold(unsigned long saddr,
						   unsigned long daddr,
						   unsigned short len,
						   unsigned short proto,
						   unsigned int sum)
{
    __asm__(
	"addl %1, %0	;\n"
	"adcl %2, %0	;\n"
	"adcl %3, %0	;\n"
	"adcl $0, %0	;\n"
	: "=r" (sum)
	: "g" (daddr), "g"(saddr), "g"((ntohs(len)<<16)+proto*256), "0"(sum));
    return sum;
}

/*
 * computes the checksum of the TCP/UDP pseudo-header
 * returns a 16-bit checksum, already complemented
 */
static inline unsigned short int csum_tcpudp_magic(unsigned long saddr,
						   unsigned long daddr,
						   unsigned short len,
						   unsigned short proto,
						   unsigned int sum)
{
    c170:	55                   	push   %ebp
    c171:	89 e5                	mov    %esp,%ebp
    c173:	83 ec 18             	sub    $0x18,%esp
    c176:	8b 45 10             	mov    0x10(%ebp),%eax
    c179:	8b 55 14             	mov    0x14(%ebp),%edx
    c17c:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
    c180:	66 89 55 fc          	mov    %dx,0xfffffffc(%ebp)
	return csum_fold(csum_tcpudp_nofold(saddr,daddr,len,proto,sum));
    c184:	8b 45 18             	mov    0x18(%ebp),%eax
    c187:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    c18b:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
    c18f:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    c193:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
    c197:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    c19b:	8b 45 0c             	mov    0xc(%ebp),%eax
    c19e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    c1a2:	8b 45 08             	mov    0x8(%ebp),%eax
    c1a5:	89 04 24             	mov    %eax,(%esp,1)
    c1a8:	e8 5e 04 00 00       	call   c60b <csum_tcpudp_nofold>
    c1ad:	89 04 24             	mov    %eax,(%esp,1)
    c1b0:	e8 94 ff ff ff       	call   c149 <csum_fold>
    c1b5:	0f b7 c0             	movzwl %ax,%eax
}
    c1b8:	c9                   	leave  
    c1b9:	c3                   	ret    

0000c1ba <tcp_set_owner_r>:

extern void tcp_rfree(struct sk_buff *skb);

static inline void tcp_set_owner_r(struct sk_buff *skb, struct sock *sk)
{
    c1ba:	55                   	push   %ebp
    c1bb:	89 e5                	mov    %esp,%ebp
    c1bd:	53                   	push   %ebx
    c1be:	83 ec 08             	sub    $0x8,%esp
	skb->sk = sk;
    c1c1:	8b 55 08             	mov    0x8(%ebp),%edx
    c1c4:	8b 45 0c             	mov    0xc(%ebp),%eax
    c1c7:	89 42 0c             	mov    %eax,0xc(%edx)
	skb->destructor = tcp_rfree;
    c1ca:	8b 45 08             	mov    0x8(%ebp),%eax
    c1cd:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    c1d4:	00 00 00 
	atomic_add(skb->truesize, &sk->rmem_alloc);
    c1d7:	8b 45 0c             	mov    0xc(%ebp),%eax
    c1da:	83 c0 44             	add    $0x44,%eax
    c1dd:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    c1e1:	8b 45 08             	mov    0x8(%ebp),%eax
    c1e4:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
    c1ea:	89 04 24             	mov    %eax,(%esp,1)
    c1ed:	e8 ff fb ff ff       	call   bdf1 <atomic_add>
	sk->forward_alloc -= skb->truesize;
    c1f2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    c1f5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    c1f8:	8b 45 08             	mov    0x8(%ebp),%eax
    c1fb:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
    c201:	8b 41 6c             	mov    0x6c(%ecx),%eax
    c204:	29 d0                	sub    %edx,%eax
    c206:	89 43 6c             	mov    %eax,0x6c(%ebx)
}
    c209:	83 c4 08             	add    $0x8,%esp
    c20c:	5b                   	pop    %ebx
    c20d:	5d                   	pop    %ebp
    c20e:	c3                   	ret    

0000c20f <submitDataRequestMapping>:
};

static inline
void submitDataRequestMapping(struct sock *sk, struct DataRequestMapping *dataReq,
					      unsigned newStart, unsigned newEnd) {
    c20f:	55                   	push   %ebp
    c210:	89 e5                	mov    %esp,%ebp
    c212:	83 ec 0c             	sub    $0xc,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    c215:	8b 45 08             	mov    0x8(%ebp),%eax
    c218:	05 bc 00 00 00       	add    $0xbc,%eax
    c21d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	BUG_TRAP(dataReq->list == NULL);
    c220:	8b 45 0c             	mov    0xc(%ebp),%eax
    c223:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
    c227:	74 14                	je     c23d <submitDataRequestMapping+0x2e>
    c229:	c7 44 24 04 2f 00 00 	movl   $0x2f,0x4(%esp,1)
    c230:	00 
    c231:	c7 04 24 c0 42 00 00 	movl   $0x42c0,(%esp,1)
    c238:	e8 fc ff ff ff       	call   c239 <submitDataRequestMapping+0x2a>
	dataReq->completed = 0;
    c23d:	8b 45 0c             	mov    0xc(%ebp),%eax
    c240:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	dataReq->sent = 0;
    c247:	8b 45 0c             	mov    0xc(%ebp),%eax
    c24a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	// poison values
	dataReq->transportResponseSeqStart = UINT_MAX;
    c251:	8b 45 0c             	mov    0xc(%ebp),%eax
    c254:	c7 40 18 ff ff ff ff 	movl   $0xffffffff,0x18(%eax)
	dataReq->transportResponseSeqEnd = UINT_MAX;
    c25b:	8b 45 0c             	mov    0xc(%ebp),%eax
    c25e:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%eax)
	dataReq->timestamp = UINT_MAX;
    c265:	8b 45 0c             	mov    0xc(%ebp),%eax
    c268:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
	dataReq->start = newStart;
    c26f:	8b 55 0c             	mov    0xc(%ebp),%edx
    c272:	8b 45 10             	mov    0x10(%ebp),%eax
    c275:	89 42 20             	mov    %eax,0x20(%edx)
	dataReq->end = newEnd;
    c278:	8b 55 0c             	mov    0xc(%ebp),%edx
    c27b:	8b 45 14             	mov    0x14(%ebp),%eax
    c27e:	89 42 24             	mov    %eax,0x24(%edx)
	insert_tail(&tp->t.missingDataMap, (struct alloc_head*)dataReq);
    c281:	8b 45 0c             	mov    0xc(%ebp),%eax
    c284:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    c288:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c28b:	05 c0 09 00 00       	add    $0x9c0,%eax
    c290:	89 04 24             	mov    %eax,(%esp,1)
    c293:	e8 dc cf ff ff       	call   9274 <insert_tail>
}
    c298:	c9                   	leave  
    c299:	c3                   	ret    

0000c29a <submitDerivedDataRequestMapping>:

static inline
void submitDerivedDataRequestMapping(struct sock *sk, struct DataRequestMapping *oldReqMap,
					    unsigned start, unsigned end) {
    c29a:	55                   	push   %ebp
    c29b:	89 e5                	mov    %esp,%ebp
    c29d:	83 ec 14             	sub    $0x14,%esp
	struct DataRequestMapping *newMap =
    c2a0:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    c2a7:	00 
    c2a8:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp,1)
    c2af:	e8 fc ff ff ff       	call   c2b0 <submitDerivedDataRequestMapping+0x16>
    c2b4:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
		kmalloc(sizeof(struct DataRequestMapping), GFP_ATOMIC);
	*newMap = *oldReqMap;
    c2b7:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
    c2ba:	8b 55 0c             	mov    0xc(%ebp),%edx
    c2bd:	8b 02                	mov    (%edx),%eax
    c2bf:	89 01                	mov    %eax,(%ecx)
    c2c1:	8b 42 04             	mov    0x4(%edx),%eax
    c2c4:	89 41 04             	mov    %eax,0x4(%ecx)
    c2c7:	8b 42 08             	mov    0x8(%edx),%eax
    c2ca:	89 41 08             	mov    %eax,0x8(%ecx)
    c2cd:	8b 42 0c             	mov    0xc(%edx),%eax
    c2d0:	89 41 0c             	mov    %eax,0xc(%ecx)
    c2d3:	8b 42 10             	mov    0x10(%edx),%eax
    c2d6:	89 41 10             	mov    %eax,0x10(%ecx)
    c2d9:	8b 42 14             	mov    0x14(%edx),%eax
    c2dc:	89 41 14             	mov    %eax,0x14(%ecx)
    c2df:	8b 42 18             	mov    0x18(%edx),%eax
    c2e2:	89 41 18             	mov    %eax,0x18(%ecx)
    c2e5:	8b 42 1c             	mov    0x1c(%edx),%eax
    c2e8:	89 41 1c             	mov    %eax,0x1c(%ecx)
    c2eb:	8b 42 20             	mov    0x20(%edx),%eax
    c2ee:	89 41 20             	mov    %eax,0x20(%ecx)
    c2f1:	8b 42 24             	mov    0x24(%edx),%eax
    c2f4:	89 41 24             	mov    %eax,0x24(%ecx)
    c2f7:	8b 42 28             	mov    0x28(%edx),%eax
    c2fa:	89 41 28             	mov    %eax,0x28(%ecx)
	if(newMap == NULL) {
    c2fd:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
    c301:	75 17                	jne    c31a <submitDerivedDataRequestMapping+0x80>
		if(!disableSevereErrors) {
    c303:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    c30a:	75 2e                	jne    c33a <submitDerivedDataRequestMapping+0xa0>
			printk("emitDerivedDataRequest: out of memory\n");
    c30c:	c7 04 24 40 43 00 00 	movl   $0x4340,(%esp,1)
    c313:	e8 fc ff ff ff       	call   c314 <submitDerivedDataRequestMapping+0x7a>
		}
		return;
    c318:	eb 20                	jmp    c33a <submitDerivedDataRequestMapping+0xa0>
	}
	submitDataRequestMapping(sk, newMap, start, end);
    c31a:	8b 45 14             	mov    0x14(%ebp),%eax
    c31d:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    c321:	8b 45 10             	mov    0x10(%ebp),%eax
    c324:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    c328:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c32b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    c32f:	8b 45 08             	mov    0x8(%ebp),%eax
    c332:	89 04 24             	mov    %eax,(%esp,1)
    c335:	e8 d5 fe ff ff       	call   c20f <submitDataRequestMapping>
}
    c33a:	c9                   	leave  
    c33b:	c3                   	ret    

0000c33c <initRequest>:



extern int numDataRequestMappings;

static inline
struct DataRequestMapping *newDataRequestMapping(struct UC_Continuation *ucont, unsigned tseq_start, unsigned tseq_end,
						 unsigned start, unsigned end) {
	struct DataRequestMapping *newMapping = kmalloc(sizeof(struct DataRequestMapping), GFP_ATOMIC);
	if(newMapping == NULL) return NULL;
	newMapping->next = newMapping->prev = NULL;
	newMapping->list = NULL;

	newMapping->completed = 0;
	newMapping->ucont = ucont;
	newMapping->transportResponseSeqStart = tseq_start;
	newMapping->transportResponseSeqEnd = tseq_end;
	newMapping->sent = 0;
	newMapping->start = start;
	newMapping->end = end;
#ifndef USERTEST
	newMapping->timestamp = jiffies;
#endif

	numDataRequestMappings++;
	return newMapping;
}

static inline void freeDataRequestMapping(struct DataRequestMapping *dataReq) {
	numDataRequestMappings--;
	kfree(dataReq);
}

/* These requests are queued in the reliable request queues. As the
   client earns tokens to use to service requests, the entries in this
   queue are sent to the server. During recovery, all requests are
   retried */

enum UserRequestType {
  /* MemoryREQuest */
	MREQ_CONVERSION,
	MREQ_CONTINUATION
};

struct Request {
  /* Generic "base" type */
#define MAX_MREQ_CHILDREN 4
#define REQUEST_FIELDS							\
	struct alloc_head *prev;					\
	struct alloc_head *next;					\
	struct alloc_head_list *list;					\
	enum UserRequestType type;					\
	unsigned numChildren;						\
	unsigned childrenMask : MAX_MREQ_CHILDREN;			\
	struct { __u32 start, end; } childRanges[MAX_MREQ_CHILDREN];	\
	unsigned transport_seq;						\
	unsigned seq;							\
	unsigned start, end;					        \
		unsigned isNew : 1;					\
		unsigned allocated : 1;					\
		unsigned transportResponseSeqStart, transportResponseSeqEnd;

	// Request uses only alloc_head list management operations. Thus,
	// Request does not need a 'ctl' field

	REQUEST_FIELDS
};

static inline void resetRequest(struct Request *req) {
	req->numChildren = 0;
	req->childrenMask = 0;
	req->transport_seq = -1;
	req->seq = -1;
	req->isNew = 1;
}

static inline void initRequest(struct Request *req, enum UserRequestType type) {
    c33c:	55                   	push   %ebp
    c33d:	89 e5                	mov    %esp,%ebp
    c33f:	83 ec 04             	sub    $0x4,%esp
	/* Initialize generic fields */
	req->type = type;
    c342:	8b 55 08             	mov    0x8(%ebp),%edx
    c345:	8b 45 0c             	mov    0xc(%ebp),%eax
    c348:	89 42 0c             	mov    %eax,0xc(%edx)
	req->prev = req->next = NULL;
    c34b:	8b 55 08             	mov    0x8(%ebp),%edx
    c34e:	8b 45 08             	mov    0x8(%ebp),%eax
    c351:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    c358:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	req->list = NULL;
    c35e:	8b 45 08             	mov    0x8(%ebp),%eax
    c361:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	resetRequest(req);
    c368:	8b 45 08             	mov    0x8(%ebp),%eax
    c36b:	89 04 24             	mov    %eax,(%esp,1)
    c36e:	e8 df d3 ff ff       	call   9752 <resetRequest>
	req->start = req->end = -1;
    c373:	8b 55 08             	mov    0x8(%ebp),%edx
    c376:	8b 45 08             	mov    0x8(%ebp),%eax
    c379:	c7 40 44 ff ff ff ff 	movl   $0xffffffff,0x44(%eax)
    c380:	c7 42 40 ff ff ff ff 	movl   $0xffffffff,0x40(%edx)
	req->allocated = 1;
    c387:	8b 45 08             	mov    0x8(%ebp),%eax
    c38a:	80 48 48 02          	orb    $0x2,0x48(%eax)
}
    c38e:	c9                   	leave  
    c38f:	c3                   	ret    

0000c390 <initIncompleteConversionRequest>:

void resetClientTimer(struct sock *sk);

static inline void queueNewRequest(struct sock *sk, struct Request *req) {
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
	insert_tail(&tp->t.queuedRequests, (struct alloc_head*)req);
	tp->t.timerState |= TRICKLES_ENABLE_DATA_TIMEOUT;
	resetClientTimer(sk);
}

struct ConversionRequest {
	REQUEST_FIELDS

	_bool incomplete; //  0 = complete, 1 = incomplete
	// First skb that contains data to convert
	struct sk_buff *data;
	// Offset within sk_buff
	unsigned offset;
#if 0
	// Length to send. If necessary, consult successors to 'data'
	unsigned length;
	// if length == 0, length is undefined and should be set in sendAck (possibly performing fragmentation)
#endif

	unsigned predLength;
	union {
		struct WireUC_CVT_IncompleteContinuation *incompletePred;
		struct UC_Continuation *completePred;
	};
};

static inline void initCompleteConversionRequest(struct ConversionRequest *req, struct UC_Continuation *pred, struct sk_buff *data, unsigned start) {
	initRequest((struct Request *)req, MREQ_CONVERSION);
	req->incomplete = 0;
	req->completePred = pred;
	atomic_inc(&req->completePred->refcnt);
#if 1 // 0707
	if(atomic_read(&req->completePred->refcnt) < 2) {
		printk("refcnt should be > 1!\n");
	}
#endif
	req->data = data;
	req->start = start;
	req->offset = req->start - TCP_SKB_CB(data)->seq;
}

static inline void initIncompleteConversionRequest(struct ConversionRequest *req, struct WireUC_CVT_IncompleteContinuation *pred, unsigned predLength, struct sk_buff *data, unsigned offset) {
    c390:	55                   	push   %ebp
    c391:	89 e5                	mov    %esp,%ebp
    c393:	83 ec 08             	sub    $0x8,%esp
	initRequest((struct Request *)req, MREQ_CONVERSION);
    c396:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    c39d:	00 
    c39e:	8b 45 08             	mov    0x8(%ebp),%eax
    c3a1:	89 04 24             	mov    %eax,(%esp,1)
    c3a4:	e8 93 ff ff ff       	call   c33c <initRequest>
	req->incomplete = 1;
    c3a9:	8b 45 08             	mov    0x8(%ebp),%eax
    c3ac:	c7 40 54 01 00 00 00 	movl   $0x1,0x54(%eax)
	req->incompletePred = pred;
    c3b3:	8b 55 08             	mov    0x8(%ebp),%edx
    c3b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    c3b9:	89 42 64             	mov    %eax,0x64(%edx)
	req->predLength = predLength;
    c3bc:	8b 55 08             	mov    0x8(%ebp),%edx
    c3bf:	8b 45 10             	mov    0x10(%ebp),%eax
    c3c2:	89 42 60             	mov    %eax,0x60(%edx)
	req->data = data;
    c3c5:	8b 55 08             	mov    0x8(%ebp),%edx
    c3c8:	8b 45 14             	mov    0x14(%ebp),%eax
    c3cb:	89 42 58             	mov    %eax,0x58(%edx)
	req->offset = offset;
    c3ce:	8b 55 08             	mov    0x8(%ebp),%edx
    c3d1:	8b 45 18             	mov    0x18(%ebp),%eax
    c3d4:	89 42 5c             	mov    %eax,0x5c(%edx)
}
    c3d7:	c9                   	leave  
    c3d8:	c3                   	ret    

0000c3d9 <kmalloc_dup>:
  rval->sk = NULL;
  return rval;
}

static inline void *kmalloc_dup(void *src, int len, unsigned gfp) {
    c3d9:	55                   	push   %ebp
    c3da:	89 e5                	mov    %esp,%ebp
    c3dc:	83 ec 14             	sub    $0x14,%esp
	char *ptr = kmalloc(len, gfp);
    c3df:	8b 45 10             	mov    0x10(%ebp),%eax
    c3e2:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    c3e6:	8b 45 0c             	mov    0xc(%ebp),%eax
    c3e9:	89 04 24             	mov    %eax,(%esp,1)
    c3ec:	e8 fc ff ff ff       	call   c3ed <kmalloc_dup+0x14>
    c3f1:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	if(ptr == NULL) {
    c3f4:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
    c3f8:	75 15                	jne    c40f <kmalloc_dup+0x36>
		printk("out of memory in kmalloc_dup\n");
    c3fa:	c7 04 24 67 43 00 00 	movl   $0x4367,(%esp,1)
    c401:	e8 fc ff ff ff       	call   c402 <kmalloc_dup+0x29>
		return NULL;
    c406:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
    c40d:	eb 1f                	jmp    c42e <kmalloc_dup+0x55>
	}
	memcpy(ptr, src, len);
    c40f:	8b 45 0c             	mov    0xc(%ebp),%eax
    c412:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    c416:	8b 45 08             	mov    0x8(%ebp),%eax
    c419:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    c41d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c420:	89 04 24             	mov    %eax,(%esp,1)
    c423:	e8 ea c7 ff ff       	call   8c12 <__memcpy>
	return ptr;
    c428:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c42b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
}
    c42e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    c431:	c9                   	leave  
    c432:	c3                   	ret    

0000c433 <GenerateDataContext_packetSpace>:

static inline CONTINUATION_TYPE *copyClientSide_Continuation(CONTINUATION_TYPE *cont, int flags) {
  int i;
#ifdef USERTEST
  CONTINUATION_TYPE *rval = kmalloc(2 * sizeof(CONTINUATION_TYPE), flags);
#else  //0426 - change kernel to slab cache
  CONTINUATION_TYPE *rval = kmem_cache_alloc(clientSideContinuation_cache, GFP_ATOMIC);
#endif

#ifdef DEBUG_TRICKLES_ALLOCATION // 0418
  numContinuations++;
#endif

  // 0501 - attempting to track down corruption bug
#ifdef DEBUG_ALLOC
#ifndef USERTEST
  if(((int)rval) & 0xfff) {
	  printk("incorrect alignment\n");
	  BUG();
  }
#endif // USERTEST
#endif // DEBUG_ALLOC

  if(rval == NULL) {
    printk("out of memory while allocating continuation to copy\n");
    return NULL;
  }
  rval->prev = rval->next = NULL;
  rval->list = NULL;

  memcpy(rval, cont, (int)((CONTINUATION_TYPE *)0)->clientside_copy_end);
  for(i=0; i < 2; i++) {
#if 0 // 0812 - copy makes the code very slow, so rewrite to avoid the copy
	  (rval+i)->ucont_len = (cont+i)->ucont_len;
	  char *src_ucont = (cont+i)->ucont_data;
	  if(src_ucont != NULL) {
		  (rval+i)->ucont_data = kmalloc_dup(src_ucont, (rval+i)->ucont_len, GFP_ATOMIC);
	  } else {
		  (rval+i)->ucont_data = NULL;
	  }
#else
	  (rval+i)->ucont_len = 0;
	  (rval+i)->ucont_data = NULL;
#endif
	  (rval+i)->input_len = 0;
	  (rval+i)->input = NULL;
	  // 0429 null mark
	  (rval+i)->mark = 0;
	  (rval+i)->simulated = 0;
	  (rval+i)->num_packets = 0;
	  (rval+i)->actualCwnd = 0;
  }
  //printk("copy rval = %p, input = %p\n", rval, cont);
  return rval;
}

#ifndef TRACE_FREE
static inline void freeClientSide_Continuation(CONTINUATION_TYPE *cont) {

#if 0
}
#endif

#else
#define CONT_POISON ((void*)0x7FFFFFFF)
#warning "Paranoid freeclientside continuation"

#define freeClientSide_Continuation(CONT) freeClientSide_ContinuationHelper((CONT), __FILE__, __LINE__)
 static inline void freeClientSide_ContinuationHelper(CONTINUATION_TYPE *cont, char *file, int lineno) {

#endif
#ifdef TRACE_FREE
  printk("freeingclientside %p @ (%s:%d)\n", cont, file, lineno);
#endif

  int i;

#ifdef TRACE_FREE
  if(cont->sk == CONT_POISON) {
	  printk("Warning: Continuation poisoned\n");
	  BUG();
  }
#endif // TRACE_FREE

#ifdef DEBUG_TRICKLES_ALLOCATION // 0418
  numContinuations--;
#endif
#ifdef DEBUG_ALLOC
#ifndef USERTEST
  if((int)cont & 0xfff) {
	  BUG();
  }
#endif // USERTEST
#endif // DEBUG_ALLOC

  if(cont->list) {
	  BUG();
  }

  for(i=0; i < 2; i++) {
    if((cont+i)->ucont_data)
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
      kfree((cont+i)->input);
  }
  // poison
#ifdef TRACE_FREE
  cont->sk = CONT_POISON;
#endif // TRACE_FREE

#ifdef USERTEST
  kfree(cont);
#else  //0426 - change kernel to slab cache
#ifdef DEBUG_ALLOC
  zap_virt(cont);
  //memset(cont, 0x3e, sizeof(*cont));
#else
#ifndef USESLAB
  kfree(cont);  // 0502 maybe slab cache usage is buggy
#else
  kmem_cache_free(clientSideContinuation_cache, cont);
#endif
#endif
#endif
}

static inline void unmarshallAckProof(AckProof *dproof, const WireAckProof *sproof) {
#define NHCONVERTLONG(X) dproof->X = ntohl(sproof->X);
#define COPYLONG(X) dproof->X = sproof->X
  int i;
  dproof->numSacks = sproof->numSacks;
  for(i=0; i < sproof->numSacks; i++) {
    NHCONVERTLONG(sacks[i].left);
    NHCONVERTLONG(sacks[i].right);
    COPYLONG(sacks[i].nonceSummary);
  }
#undef NHCONVERTLONG
#undef COPYLONG
}

static inline struct UC_Continuation *unmarshallUC_Continuation(struct WireUC_Continuation *scont, unsigned length) {
  unsigned dataLen = length - sizeof(struct WireUC_Continuation);
  struct UC_Continuation *rval = kmalloc(sizeof(struct UC_Continuation) + dataLen, GFP_ATOMIC);

  if(rval == NULL) {
    printk("Out of memory while unmarshalling UC_Continuation\n");
    return NULL;
  }
  rval->prev = rval->next = NULL;
  rval->list = NULL;

  rval->seq = ntohl(scont->seq);
  rval->validStart = ntohl(scont->validStart);
  rval->validEnd = ntohl(scont->validEnd);
  rval->fields = scont->fields;
  rval->dataLen = dataLen;
  rval->kernel.obsoleteAt = rval->validEnd;
  memcpy(rval->kernel.data, scont->data, dataLen);
  return rval;
}

static inline unsigned marshallUC_Continuation(struct WireUC_Continuation *dcont, struct UC_Continuation *scont) {
  int dataLen = scont->dataLen;
  dcont->seq = htonl(scont->seq);
  dcont->validStart = htonl(scont->validStart);
  dcont->validEnd = htonl(scont->validEnd);
  dcont->fields = scont->fields;
  memcpy(dcont->data, scont->kernel.data, dataLen);
  return sizeof(*dcont) + dataLen;
}

static inline void WireUC_addDependency(struct WireUC_Continuation *completeResp, struct UC_DependencyLink *dep) {
  printk("Dependency handling not complete\n");
  BUG();
  completeResp->fields |= (0x01);
  /* and more stuff */
  /* ... */
}

static inline struct UC_Continuation *copyUC_Continuation(struct UC_Continuation *scont) {
  /* create a separate copy */
  int dataLen = scont->dataLen;
  struct UC_Continuation *rval = kmalloc(sizeof(*rval) + dataLen, GFP_ATOMIC);
  if(rval == NULL) {
    printk("Out of memory while copying UC_Continuation\n");
    return NULL;
  }
  *rval = *scont;
  rval->prev = rval->next = NULL;
  rval->list = NULL;

  memcpy(rval->kernel.data, scont->kernel.data, dataLen);
  return rval;
}

static inline struct UC_DependencyLink *unmarshallUC_Dependency(struct sock *sk, struct WireUC_Dependency *sdep) {
#if 0
  struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
  struct UC_Dependency *rval, *currDep;
  int i;
  /* scan through sk to see if any dependencies can be resolved */
  /* May return pointer to existing dependency */

  if(sdep->pred.start > sdep->pred.end ||
     sdep->succ.start > sdep->succ.end) { 
      printk("unmarshallUC_Dependency: bad dep\n"); 
      return NULL;
  }
  rval = kmalloc(sizeof(struct UC_Dependency), GFP_ATOMIC);
  if(rval == NULL) {
    printk("Out of memory while unmarshalling UC Dependency\n");
    return NULL;
  }
  rval->prev = rval->next = NULL;
  rval->list = NULL;
  rval->refCnt = 1;

  rval->start = ntohl(sdep->succ.start);
  rval->end = ntohl(sdep->succ.end);

  initVector(&rval->vec);
#else
  printk("Dependency management doesn't work yet\n");
  BUG();
  return NULL;
#endif
}

static inline int freeDependencyNode(struct sock *sk, struct UC_DependencyNode *dep) {
#if 0
  dep->refCnt--;
  if(dep->refCnt == 0) {
    if(dep->list) {
      unlink(dep);
    }
    kfree(dep);
    return 0;
  }
  return dep->refCnt;
#else
  printk("Dependency management doesn't work yet\n");
  BUG();
  return -1;
#endif
}

static inline struct UC_DependencyNode *copyUC_DependencyNode(struct UC_DependencyNode *sdep) {
#if 0
  int i;
  struct UC_Dependency *rval = kmalloc(sizeof(struct UC_Dependency), GFP_ATOMIC);
  if(rval == NULL) {
    printk("Out of memory while copying UC_Dependency\n");
    return NULL;
  }
  *rval = *sdep;
  rval->prev = rval->next = NULL;
  rval->list = NULL;
  rval->deps = kmalloc(sizeof(struct UC_Continuation*) * rval->maxDeps, GFP_ATOMIC);
  if(rval->deps == NULL) {
    printk("Out of memory while copying UC_Dependency\n");
    kfree(rval);
    return NULL;
  }
  for(i=0; i < rval->numDeps; i++) {
    rval->deps[i] = sdep->deps[i];
    rval->deps[i]->refCnt++;
  }
  return rval;
#else
  printk("Dependency management doesn't work yet\n");
  BUG();
  return NULL;
#endif
}

static inline 
void updateUC_ContinuationAndDependency(struct UC_Continuation *cont, struct UC_DependencyNode *dep) {
#if 0
/* called when resolving old dependency chains when new continuations
   are inserted called when inserting new dependencies */
  BUG_TRAP(dep->start >= cont->validStart && dep->end <= cont->validEnd);
  BUG_TRAP(!dep->resolved && dep->cont == NULL);
  dep->resolved = 1;
  dep->cont = cont;
  cont->kernel.obsoleteAt = MAX(cont->kernel.obsoleteAt, dep->end);
#else
  printk("Dependency management doesn't work yet\n");
  BUG();
#endif
}

static inline int addDependencyLink(struct UC_DependencyNode *changedDep, struct UC_DependencyLink *newLink) {
#if 0
  if(changedDep->numDeps < changedDep->maxDeps) {
    changedDep->deps[changedDep->numDeps++] = newDep;
  } else {
    /* Resize */
    struct UC_Dependency *resizedDeps[];
    int newSize = changedDep->maxDeps * 2;

    resizedDeps = kmalloc(newSize * sizeof(UC_Dependency*), GFP_ATOMIC);
    if(resizedDeps == NULL) {
      printk("Out of memory while adding dependency link\n");
      return -1;
    }
    memcpy(resizedDeps, changedDep->deps, changedDep->numDeps * sizeof(UC_Dependency*));
    kfree(changedDep->deps);
    changedDep->deps = resizedDeps;
    changedDep->deps[changedDep->numDeps++] = newDep;
    changedDep->maxDeps = newSize;
  }
  newDep->refCnt++;
  return 0;
#else
  printk("Dependency management doesn't work yet\n");
  BUG();
  return -1;
#endif
}
#endif // __KERNEL__

/* HELPER FUNCTIONS FOR USER SPACE CODE */

static inline 
void WireUC_clearFields(struct WireUC_Continuation *wireContinuation) {
  wireContinuation->fields = 0;
}

static inline void *WireUC_getDataStart(struct WireUC_Continuation *wireContinuation) {
  char *rval = wireContinuation->data;
  /* get start of data area, taking into account the variable header length */
  if(wireContinuation->fields & FIELD_DEPS) {
    printk("getWireUC_dataStart: no dependency support\n");
    BUG();
  }
  if(wireContinuation->fields & ~FIELD_ALL) {
    printk("getWireUC_dataStart: unknown field\n");
    BUG();
  }

  /* perform necessary adjustments on rval here */
  return rval;
}

static inline void initResponseHeader(struct WireUC_RespHeader *resp, enum UC_Type type, int error, unsigned len) {
  resp->type = type;
  resp->error = error;
  resp->len = htons((short)len);
}

static inline void initIncompleteResponse(struct WireUC_CVT_IncompleteResponse *incompleteResp, unsigned ack_seq, int error, 
			    unsigned validStart, unsigned convContLen) {
  initResponseHeader((struct WireUC_RespHeader *)incompleteResp, UC_INCOMPLETE,
		     error, 
		     sizeof(struct WireUC_CVT_IncompleteResponse) + convContLen);
  incompleteResp->ack_seq = htonl(ack_seq);
  incompleteResp->newCont.validStart = htonl(validStart);
}

static inline void initCompleteResponse(struct WireUC_CVT_CompleteResponse *completeResp, unsigned ack_seq, 
					unsigned convContLen, unsigned seq, unsigned validStart, unsigned validEnd) {
  initResponseHeader((struct WireUC_RespHeader *)completeResp, UC_COMPLETE,
		     0, 
		     sizeof(struct WireUC_CVT_CompleteResponse) + convContLen);
  completeResp->ack_seq = htonl(ack_seq);
  completeResp->newCont.seq = htonl(seq);
  completeResp->newCont.validStart = htonl(validStart);
  completeResp->newCont.validEnd = htonl(validEnd);
  completeResp->newCont.fields = 0;
}

static inline void initNewContinuationResponse(struct WireUC_NewContinuationResponse *newContinuationResp, 
					       unsigned contLen, unsigned seq, unsigned validStart, unsigned validEnd) {
	initResponseHeader((struct WireUC_RespHeader*)newContinuationResp, UC_NEWCONT,
			   0,
			   sizeof(struct WireUC_NewContinuationResponse) + contLen);
	newContinuationResp->newCont.seq = htonl(seq);
	newContinuationResp->newCont.validStart = htonl(validStart);
	newContinuationResp->newCont.validEnd = htonl(validEnd);
	newContinuationResp->newCont.fields = 0;
}

#ifdef __KERNEL__
 static inline void UC_Continuation_dump(struct UC_Continuation *ucont) {
	 printk("seq=[%d]\n", ucont->seq);
	 printk("valid=[%d-%d] [%d-%d]\n", ucont->validStart, ucont->validEnd,
		htonl(ucont->validStart), htonl(ucont->validEnd));
	 printk("cvalid=[%d-%d] [%d-%d]\n", ucont->clientValidStart, ucont->clientValidEnd,
		htonl(ucont->clientValidStart), htonl(ucont->clientValidEnd));
}
#endif // __KERNEL__

static inline struct DataChunk *
data_buildChunkHeader(struct DataChunk *chunk, int byteNum, int chunkLen) {
	BUG_TRAP(! (chunkLen & ~0xffff));
	chunk->byteNum = htonl(byteNum);
	chunk->type = RCHUNK_DATA;
	chunk->chunkLen = htons(chunkLen + sizeof(struct DataChunk));
	// return pointer to next datachunk
	return (struct DataChunk *) (chunk->data + chunkLen);
 }

static inline struct RequestChunk *
pushhint_buildChunkHeader(struct RequestChunk *chunk, int start, int end) {
	struct PushHintChunk *phchunk = (struct PushHintChunk *) chunk;
	phchunk->type = RCHUNK_PUSH_HINT;
	phchunk->chunkLen = htons(sizeof(struct PushHintChunk));
	phchunk->start = htonl(start);
	phchunk->end = htonl(end);
	
	// return pointer to next chunk
	return (struct RequestChunk *) (phchunk+1);
 }
//
// Helper routines for properly striping range responses across multiple packets
//
struct GenerateDataContext {
	int packetNum;
	int packetPos;
	char *outputStart;
	char *outputPos;

	struct cminisock_packet *packets;
	int numPackets;
};

static inline
void GenerateDataContext_init(struct GenerateDataContext *ctx, char *dest, 
			      struct cminisock_packet *packets, int numPackets) {
	ctx->packetNum = 0;
	ctx->packetPos = 0;
	ctx->outputPos = ctx->outputStart = dest;
	ctx->packets = packets;
	ctx->numPackets = numPackets;
}

static inline
void GenerateDataContext_describePackets(struct GenerateDataContext *ctx) {
	int i;
	for(i=0; i < ctx->numPackets; i++) {
		printk("Packet [%d] = %d\n", i, ctx->packets[i].len);
	}
}

static inline
void GenerateDataContext_dump(struct GenerateDataContext *ctx) {
	printk("\tPacketNum = %d\n\tPacketPos = %d\n\tOutputPos = %p\n\tnumPackets = %d\n\tpackets = %p\n",
	       ctx->packetNum, ctx->packetPos, ctx->outputPos, ctx->numPackets, ctx->packets);
}

static inline
int GenerateDataContext_packetSpace(struct GenerateDataContext *ctx) {
    c433:	55                   	push   %ebp
    c434:	89 e5                	mov    %esp,%ebp
    c436:	53                   	push   %ebx
    c437:	83 ec 04             	sub    $0x4,%esp
	if(ctx->packetNum >= ctx->numPackets) {
    c43a:	8b 45 08             	mov    0x8(%ebp),%eax
    c43d:	8b 55 08             	mov    0x8(%ebp),%edx
    c440:	8b 00                	mov    (%eax),%eax
    c442:	3b 42 14             	cmp    0x14(%edx),%eax
    c445:	7c 09                	jl     c450 <GenerateDataContext_packetSpace+0x1d>
		return 0;
    c447:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
    c44e:	eb 28                	jmp    c478 <GenerateDataContext_packetSpace+0x45>
	}
	return ctx->packets[ctx->packetNum].len - ctx->packetPos;
    c450:	8b 4d 08             	mov    0x8(%ebp),%ecx
    c453:	8b 45 08             	mov    0x8(%ebp),%eax
    c456:	8b 10                	mov    (%eax),%edx
    c458:	89 d0                	mov    %edx,%eax
    c45a:	c1 e0 03             	shl    $0x3,%eax
    c45d:	01 d0                	add    %edx,%eax
    c45f:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    c466:	8b 49 10             	mov    0x10(%ecx),%ecx
    c469:	8b 45 08             	mov    0x8(%ebp),%eax
    c46c:	8b 50 04             	mov    0x4(%eax),%edx
    c46f:	8b 44 19 08          	mov    0x8(%ecx,%ebx,1),%eax
    c473:	29 d0                	sub    %edx,%eax
    c475:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
}
    c478:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    c47b:	83 c4 04             	add    $0x4,%esp
    c47e:	5b                   	pop    %ebx
    c47f:	5d                   	pop    %ebp
    c480:	c3                   	ret    

0000c481 <GenerateDataContext_reserveHeader>:

static inline
char *GenerateDataContext_put(struct GenerateDataContext *ctx, int numBytes) {
#define CHECK_OUT_OF_SPACE()				\
	do {						\
		if(ctx->packetNum >= ctx->numPackets) {	\
			/* out of space */		\
			return NULL;			\
		}					\
	} while(0)

	if(numBytes == 0) return ctx->outputPos;

	CHECK_OUT_OF_SPACE();

	if(!(ctx->packetNum <= ctx->numPackets)) {
		BUG_TRAP(ctx->packetNum <= ctx->numPackets);
		printk("%d !<= %d\n", ctx->packetNum, ctx->numPackets);
	}
	char *temp;
	if(GenerateDataContext_packetSpace(ctx) >= numBytes) {
		// no adjustments needed in normal operation
		//printk("putting %d at %d[%d]\n", numBytes, ctx->packetNum, ctx->packetPos);
	} else {
		// can't fit request into current packet
		BUG_TRAP(numBytes <= ctx->packets[ctx->packetNum].len);
		ctx->outputPos += ctx->packets[ctx->packetNum].len - ctx->packetPos;
		ctx->packetPos = 0;
		ctx->packetNum++;
	}
	temp = ctx->outputPos;
	ctx->packetPos += numBytes;
	ctx->outputPos += numBytes;

	CHECK_OUT_OF_SPACE();

	BUG_TRAP(ctx->packetPos <= ctx->packets[ctx->packetNum].len);

	if(ctx->packetPos == ctx->packets[ctx->packetNum].len) {
		ctx->packetPos = 0;
		ctx->packetNum++;
	}
	return temp;
#undef CHECK_OUT_OF_SPACE
}

static inline 
struct DataChunk *GenerateDataContext_reserveHeader(struct GenerateDataContext *ctx, int generatePadding) {
    c481:	55                   	push   %ebp
    c482:	89 e5                	mov    %esp,%ebp
    c484:	83 ec 14             	sub    $0x14,%esp
#define PAD_VALUE  (0x3F)
	char *currpos = ctx->outputPos;
    c487:	8b 45 08             	mov    0x8(%ebp),%eax
    c48a:	8b 40 0c             	mov    0xc(%eax),%eax
    c48d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	struct DataChunk *output = (struct DataChunk *) GenerateDataContext_put(ctx, sizeof(struct DataChunk));
    c490:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp,1)
    c497:	00 
    c498:	8b 45 08             	mov    0x8(%ebp),%eax
    c49b:	89 04 24             	mov    %eax,(%esp,1)
    c49e:	e8 30 df ff ff       	call   a3d3 <GenerateDataContext_put>
    c4a3:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	if(output == NULL) {
    c4a6:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    c4aa:	75 09                	jne    c4b5 <GenerateDataContext_reserveHeader+0x34>
		//printk("reserve header returning null\n");
		return NULL;
    c4ac:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
    c4b3:	eb 37                	jmp    c4ec <GenerateDataContext_reserveHeader+0x6b>
	} else {
		//printk("reserve header succeeded\n");
		if(currpos != (char*)output) {
    c4b5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c4b8:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
    c4bb:	74 29                	je     c4e6 <GenerateDataContext_reserveHeader+0x65>
			// need padding
			if(generatePadding) {
    c4bd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    c4c1:	74 23                	je     c4e6 <GenerateDataContext_reserveHeader+0x65>
				printk("generating padding\n");
    c4c3:	c7 04 24 85 43 00 00 	movl   $0x4385,(%esp,1)
    c4ca:	e8 fc ff ff ff       	call   c4cb <GenerateDataContext_reserveHeader+0x4a>
				while(currpos != (char*)output) {
    c4cf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c4d2:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
    c4d5:	75 02                	jne    c4d9 <GenerateDataContext_reserveHeader+0x58>
    c4d7:	eb 0d                	jmp    c4e6 <GenerateDataContext_reserveHeader+0x65>
					*currpos++ = PAD_VALUE;
    c4d9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c4dc:	c6 00 3f             	movb   $0x3f,(%eax)
    c4df:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
    c4e2:	ff 00                	incl   (%eax)
    c4e4:	eb e9                	jmp    c4cf <GenerateDataContext_reserveHeader+0x4e>
				}
			}
		}
	}
#undef PAD_VALUE

	return output;
    c4e6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    c4e9:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
}
    c4ec:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    c4ef:	c9                   	leave  
    c4f0:	c3                   	ret    

0000c4f1 <recycle_headerinit>:
// Helper functions for recycling old skb
#define TRICKLES_TX_SKB_LEN (MAX_TCP_HEADER + MAX_TRICKLES_SERVER_HDR_LEN + TRICKLES_MSS)

static inline void recycle_headerinit(void *p)
{
    c4f1:	55                   	push   %ebp
    c4f2:	89 e5                	mov    %esp,%ebp
    c4f4:	83 ec 10             	sub    $0x10,%esp
	struct sk_buff *skb = p;
    c4f7:	8b 45 08             	mov    0x8(%ebp),%eax
    c4fa:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

	skb->next = NULL;
    c4fd:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c500:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	skb->prev = NULL;
    c506:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c509:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	skb->list = NULL;
    c510:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c513:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	skb->sk = NULL;
    c51a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c51d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	skb->stamp.tv_sec=0;	/* No idea about time */
    c524:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c527:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	skb->dev = NULL;
    c52e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c531:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	skb->real_dev = NULL;
    c538:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c53b:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	skb->dst = NULL;
    c542:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c545:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
	memset(skb->cb, 0, sizeof(skb->cb));
    c54c:	c7 44 24 08 60 00 00 	movl   $0x60,0x8(%esp,1)
    c553:	00 
    c554:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    c55b:	00 
    c55c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c55f:	83 c0 30             	add    $0x30,%eax
    c562:	89 04 24             	mov    %eax,(%esp,1)
    c565:	e8 e7 c6 ff ff       	call   8c51 <__constant_c_and_count_memset>
	skb->pkt_type = PACKET_HOST;	/* Default type */
    c56a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c56d:	c6 80 a2 00 00 00 00 	movb   $0x0,0xa2(%eax)
	skb->ip_summed = 0;
    c574:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c577:	c6 80 a3 00 00 00 00 	movb   $0x0,0xa3(%eax)
	skb->priority = 0;
    c57e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c581:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
    c588:	00 00 00 
	skb->security = 0;	/* By default packets are insecure */
    c58b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c58e:	66 c7 80 ae 00 00 00 	movw   $0x0,0xae(%eax)
    c595:	00 00 
	skb->destructor = NULL;
    c597:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c59a:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    c5a1:	00 00 00 

#ifdef CONFIG_NETFILTER
	skb->nfmark = skb->nfcache = 0;
    c5a4:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    c5a7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c5aa:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%eax)
    c5b1:	00 00 00 
    c5b4:	c7 82 c8 00 00 00 00 	movl   $0x0,0xc8(%edx)
    c5bb:	00 00 00 
	skb->nfct = NULL;
    c5be:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c5c1:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%eax)
    c5c8:	00 00 00 
#ifdef CONFIG_NETFILTER_DEBUG
	skb->nf_debug = 0;
#endif
#endif
#ifdef CONFIG_NET_SCHED
	skb->tc_index = 0;
    c5cb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c5ce:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%eax)
    c5d5:	00 00 00 
#endif
}
    c5d8:	c9                   	leave  
    c5d9:	c3                   	ret    

0000c5da <skb_can_put>:
    c5da:	55                   	push   %ebp
    c5db:	89 e5                	mov    %esp,%ebp
    c5dd:	83 ec 04             	sub    $0x4,%esp
    c5e0:	8b 55 08             	mov    0x8(%ebp),%edx
    c5e3:	8b 45 0c             	mov    0xc(%ebp),%eax
    c5e6:	8b 92 bc 00 00 00    	mov    0xbc(%edx),%edx
    c5ec:	01 c2                	add    %eax,%edx
    c5ee:	89 55 fc             	mov    %edx,0xfffffffc(%ebp)
    c5f1:	8b 45 08             	mov    0x8(%ebp),%eax
    c5f4:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    c5f7:	3b 90 c0 00 00 00    	cmp    0xc0(%eax),%edx
    c5fd:	0f 96 c0             	setbe  %al
    c600:	0f b6 c0             	movzbl %al,%eax
    c603:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    c606:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c609:	c9                   	leave  
    c60a:	c3                   	ret    

0000c60b <csum_tcpudp_nofold>:
						   unsigned long daddr,
						   unsigned short len,
						   unsigned short proto,
						   unsigned int sum)
{
    c60b:	55                   	push   %ebp
    c60c:	89 e5                	mov    %esp,%ebp
    c60e:	83 ec 08             	sub    $0x8,%esp
    c611:	8b 45 10             	mov    0x10(%ebp),%eax
    c614:	8b 55 14             	mov    0x14(%ebp),%edx
    c617:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
    c61b:	66 89 55 fc          	mov    %dx,0xfffffffc(%ebp)
    __asm__(
    c61f:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
    c623:	89 04 24             	mov    %eax,(%esp,1)
    c626:	e8 fc ff ff ff       	call   c627 <csum_tcpudp_nofold+0x1c>
    c62b:	0f b7 c0             	movzwl %ax,%eax
    c62e:	89 c2                	mov    %eax,%edx
    c630:	c1 e2 10             	shl    $0x10,%edx
    c633:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
    c637:	c1 e0 08             	shl    $0x8,%eax
    c63a:	01 c2                	add    %eax,%edx
    c63c:	8b 45 18             	mov    0x18(%ebp),%eax
    c63f:	03 45 0c             	add    0xc(%ebp),%eax
    c642:	13 45 08             	adc    0x8(%ebp),%eax
    c645:	11 d0                	adc    %edx,%eax
    c647:	83 d0 00             	adc    $0x0,%eax
    c64a:	89 45 18             	mov    %eax,0x18(%ebp)
	"addl %1, %0	;\n"
	"adcl %2, %0	;\n"
	"adcl %3, %0	;\n"
	"adcl $0, %0	;\n"
	: "=r" (sum)
	: "g" (daddr), "g"(saddr), "g"((ntohs(len)<<16)+proto*256), "0"(sum));
    return sum;
    c64d:	8b 45 18             	mov    0x18(%ebp),%eax
}
    c650:	c9                   	leave  
    c651:	c3                   	ret    

0000c652 <.text.lock.tmalloc>:
    c652:	50                   	push   %eax
    c653:	51                   	push   %ecx
    c654:	52                   	push   %edx
    c655:	e8 fc ff ff ff       	call   c656 <.text.lock.tmalloc+0x4>
    c65a:	5a                   	pop    %edx
    c65b:	59                   	pop    %ecx
    c65c:	58                   	pop    %eax
    c65d:	e9 df 49 ff ff       	jmp    1041 <__tcp_checksum_complete_user+0xa8>
    c662:	50                   	push   %eax
    c663:	51                   	push   %ecx
    c664:	52                   	push   %edx
    c665:	e8 fc ff ff ff       	call   c666 <.text.lock.tmalloc+0x14>
    c66a:	5a                   	pop    %edx
    c66b:	59                   	pop    %ecx
    c66c:	58                   	pop    %eax
    c66d:	e9 6a 7e ff ff       	jmp    44dc <user_ack_impl+0xfb>
    c672:	50                   	push   %eax
    c673:	51                   	push   %ecx
    c674:	52                   	push   %edx
    c675:	e8 fc ff ff ff       	call   c676 <.text.lock.tmalloc+0x24>
    c67a:	5a                   	pop    %edx
    c67b:	59                   	pop    %ecx
    c67c:	58                   	pop    %eax
    c67d:	e9 47 7f ff ff       	jmp    45c9 <tcp_copy_to_iovec+0x40>
    c682:	50                   	push   %eax
    c683:	51                   	push   %ecx
    c684:	52                   	push   %edx
    c685:	e8 fc ff ff ff       	call   c686 <.text.lock.tmalloc+0x34>
    c68a:	5a                   	pop    %edx
    c68b:	59                   	pop    %ecx
    c68c:	58                   	pop    %eax
    c68d:	e9 b7 c3 ff ff       	jmp    8a49 <cleanup_module+0x130>
    c692:	50                   	push   %eax
    c693:	51                   	push   %ecx
    c694:	52                   	push   %edx
    c695:	e8 fc ff ff ff       	call   c696 <.text.lock.tmalloc+0x44>
    c69a:	5a                   	pop    %edx
    c69b:	59                   	pop    %ecx
    c69c:	58                   	pop    %eax
    c69d:	e9 f5 c4 ff ff       	jmp    8b97 <cleanup_module+0x27e>
    c6a2:	90                   	nop    
    c6a3:	90                   	nop    

0000c6a4 <record_transfer_skb>:
void record_free_skb_head(struct sk_buff *skb) {
}

static inline 
void record_transfer_skb(struct sk_buff *skb, int newType) {
    c6a4:	55                   	push   %ebp
    c6a5:	89 e5                	mov    %esp,%ebp
}
    c6a7:	5d                   	pop    %ebp
    c6a8:	c3                   	ret    

0000c6a9 <free_trickles_msk>:
/* Two phase free: first phase disconnects socket from event list,
   sets to ALLOC_PROCESSING; second phase adds the socket to free
   list, sets to ALLOC_FREE and ready for reuse */
#ifndef USERTEST
static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk) {
    c6a9:	55                   	push   %ebp
    c6aa:	89 e5                	mov    %esp,%ebp
    c6ac:	83 ec 08             	sub    $0x8,%esp
	if(!SIMULATION_MODE(sk)) {
    c6af:	8b 45 08             	mov    0x8(%ebp),%eax
    c6b2:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    c6b8:	83 e0 01             	and    $0x1,%eax
    c6bb:	85 c0                	test   %eax,%eax
    c6bd:	74 1b                	je     c6da <free_trickles_msk+0x31>
    c6bf:	8b 55 08             	mov    0x8(%ebp),%edx
    c6c2:	8b 45 08             	mov    0x8(%ebp),%eax
    c6c5:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    c6cb:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
    c6d1:	83 e0 08             	and    $0x8,%eax
    c6d4:	85 c0                	test   %eax,%eax
    c6d6:	75 02                	jne    c6da <free_trickles_msk+0x31>
    c6d8:	eb 6b                	jmp    c745 <free_trickles_msk+0x9c>
		if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) {
    c6da:	8b 45 0c             	mov    0xc(%ebp),%eax
    c6dd:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
    c6e1:	74 0b                	je     c6ee <free_trickles_msk+0x45>
    c6e3:	8b 45 0c             	mov    0xc(%ebp),%eax
    c6e6:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
    c6ea:	74 02                	je     c6ee <free_trickles_msk+0x45>
    c6ec:	eb 31                	jmp    c71f <free_trickles_msk+0x76>
			printk("double free\n");
    c6ee:	c7 04 24 cc 43 00 00 	movl   $0x43cc,(%esp,1)
    c6f5:	e8 fc ff ff ff       	call   c6f6 <free_trickles_msk+0x4d>
			BUG();
    c6fa:	c7 44 24 04 d9 43 00 	movl   $0x43d9,0x4(%esp,1)
    c701:	00 
    c702:	c7 04 24 dd 43 00 00 	movl   $0x43dd,(%esp,1)
    c709:	e8 fc ff ff ff       	call   c70a <free_trickles_msk+0x61>
    c70e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    c715:	e8 fc ff ff ff       	call   c716 <free_trickles_msk+0x6d>
    c71a:	e8 fc ff ff ff       	call   c71b <free_trickles_msk+0x72>
		}
		if(msk->ctl == ALLOC_READY && msk->prev != NULL) {
    c71f:	8b 45 0c             	mov    0xc(%ebp),%eax
    c722:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
    c726:	75 13                	jne    c73b <free_trickles_msk+0x92>
    c728:	8b 45 0c             	mov    0xc(%ebp),%eax
    c72b:	83 38 00             	cmpl   $0x0,(%eax)
    c72e:	74 0b                	je     c73b <free_trickles_msk+0x92>
			unlink((struct alloc_head *)msk);
    c730:	8b 45 0c             	mov    0xc(%ebp),%eax
    c733:	89 04 24             	mov    %eax,(%esp,1)
    c736:	e8 6a 14 00 00       	call   dba5 <unlink>
		}
		msk->ctl = ALLOC_PROCESSING;
    c73b:	8b 45 0c             	mov    0xc(%ebp),%eax
    c73e:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
	}
}
    c745:	c9                   	leave  
    c746:	c3                   	ret    

0000c747 <free_trickles_msk_finish>:

static inline void msk_release(struct sock *sk, struct cminisock *msk) {
	// Perform actual deallocation. This function is common to
	// state cache and event queue
	msk->refCnt--;
	BUG_TRAP(msk->refCnt >= 0);
	if(msk->refCnt == 0) {
		// printk("release: refcnt %p\n", msk);
		struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
		struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;

		free_minisock(sk,msk);
		if(!SIMULATION_MODE(sk)) {
			insert_head(head, (struct alloc_head *)msk);
			msk->ctl = ALLOC_FREE;
		} else {
			if(msk == tp->t.responseMSK) {
			} else {
				// overflow
				unlink((struct alloc_head*)msk);
				kfree(msk);
			}
			tp->t.responseCount--;
		}
	} else {
		//printk("release: refcnt == %d\n", msk->refCnt);
	}
}

static inline void free_trickles_msk_finish(struct sock *sk, struct cminisock *msk) {
    c747:	55                   	push   %ebp
    c748:	89 e5                	mov    %esp,%ebp
    c74a:	83 ec 08             	sub    $0x8,%esp
	if(!SIMULATION_MODE(sk)) {
    c74d:	8b 45 08             	mov    0x8(%ebp),%eax
    c750:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    c756:	83 e0 01             	and    $0x1,%eax
    c759:	85 c0                	test   %eax,%eax
    c75b:	74 1b                	je     c778 <free_trickles_msk_finish+0x31>
    c75d:	8b 55 08             	mov    0x8(%ebp),%edx
    c760:	8b 45 08             	mov    0x8(%ebp),%eax
    c763:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    c769:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
    c76f:	83 e0 08             	and    $0x8,%eax
    c772:	85 c0                	test   %eax,%eax
    c774:	75 02                	jne    c778 <free_trickles_msk_finish+0x31>
    c776:	eb 4d                	jmp    c7c5 <free_trickles_msk_finish+0x7e>
		if(msk->ctl != ALLOC_PROCESSING && msk->ctl != ALLOC_HALFFREE) {
    c778:	8b 45 0c             	mov    0xc(%ebp),%eax
    c77b:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
    c77f:	74 44                	je     c7c5 <free_trickles_msk_finish+0x7e>
    c781:	8b 45 0c             	mov    0xc(%ebp),%eax
    c784:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
    c788:	74 3b                	je     c7c5 <free_trickles_msk_finish+0x7e>
			printk("(free_trickles_msk_finish) without corresponding free_trickles_msk: msk->ctl = %d\n", msk->ctl);
    c78a:	8b 45 0c             	mov    0xc(%ebp),%eax
    c78d:	8b 40 0c             	mov    0xc(%eax),%eax
    c790:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    c794:	c7 04 24 00 44 00 00 	movl   $0x4400,(%esp,1)
    c79b:	e8 fc ff ff ff       	call   c79c <free_trickles_msk_finish+0x55>
			BUG();
    c7a0:	c7 44 24 04 d9 43 00 	movl   $0x43d9,0x4(%esp,1)
    c7a7:	00 
    c7a8:	c7 04 24 dd 43 00 00 	movl   $0x43dd,(%esp,1)
    c7af:	e8 fc ff ff ff       	call   c7b0 <free_trickles_msk_finish+0x69>
    c7b4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    c7bb:	e8 fc ff ff ff       	call   c7bc <free_trickles_msk_finish+0x75>
    c7c0:	e8 fc ff ff ff       	call   c7c1 <free_trickles_msk_finish+0x7a>
		}
	}
	msk_release(sk,msk);
    c7c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    c7c8:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    c7cc:	8b 45 08             	mov    0x8(%ebp),%eax
    c7cf:	89 04 24             	mov    %eax,(%esp,1)
    c7d2:	e8 14 14 00 00       	call   dbeb <msk_release>
}
    c7d7:	c9                   	leave  
    c7d8:	c3                   	ret    

0000c7d9 <trickles_morecore>:
#include "compat.h"
#include "skbuff.h"
#endif

void *trickles_morecore(struct sock *sk, long size) {
    c7d9:	55                   	push   %ebp
    c7da:	89 e5                	mov    %esp,%ebp
    c7dc:	83 ec 0c             	sub    $0xc,%esp
    void *result;
    struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    c7df:	8b 45 08             	mov    0x8(%ebp),%eax
    c7e2:	05 bc 00 00 00       	add    $0xbc,%eax
    c7e7:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    if(tp->t.heapbytesallocated + size > tp->t.heapbytesize) {
    c7ea:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    c7ed:	8b 45 0c             	mov    0xc(%ebp),%eax
    c7f0:	8b 92 20 02 00 00    	mov    0x220(%edx),%edx
    c7f6:	01 c2                	add    %eax,%edx
    c7f8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    c7fb:	3b 90 1c 02 00 00    	cmp    0x21c(%eax),%edx
    c801:	7e 09                	jle    c80c <trickles_morecore+0x33>
      if(trickles_ratelimit()) {
	printk("tmalloc: out of memory\n");
      }
      return NULL;
    c803:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
    c80a:	eb 38                	jmp    c844 <trickles_morecore+0x6b>
    }
#ifndef USERTEST
    result = (char*)tp->cminisock_api_config.cfg.ctl->heap_base;
    c80c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    c80f:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
    c815:	8b 40 14             	mov    0x14(%eax),%eax
    c818:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
#else 
    result = (char*)tp->t.heap_absolute_base;
#endif
    result = (char*)result + tp->t.heapbytesallocated;
    c81b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    c81e:	8b 90 20 02 00 00    	mov    0x220(%eax),%edx
    c824:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
    c827:	01 10                	add    %edx,(%eax)
    tp->t.heapbytesallocated += size;
    c829:	8b 4d f8             	mov    0xfffffff8(%ebp),%ecx
    c82c:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    c82f:	8b 45 0c             	mov    0xc(%ebp),%eax
    c832:	03 82 20 02 00 00    	add    0x220(%edx),%eax
    c838:	89 81 20 02 00 00    	mov    %eax,0x220(%ecx)
    return result;
    c83e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c841:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
}
    c844:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    c847:	c9                   	leave  
    c848:	c3                   	ret    

0000c849 <align>:

void *(*_morecore)(struct sock *, long) = trickles_morecore;

void tfree(struct sock *sk, void *ptr);

/* Aligned allocation. */
static void *
align(struct sock *sk, size_t size)
{
    c849:	55                   	push   %ebp
    c84a:	89 e5                	mov    %esp,%ebp
    c84c:	83 ec 10             	sub    $0x10,%esp
    void *result;
    unsigned int adj;

    result = (*_morecore)(sk, size);
    c84f:	8b 45 0c             	mov    0xc(%ebp),%eax
    c852:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    c856:	8b 45 08             	mov    0x8(%ebp),%eax
    c859:	89 04 24             	mov    %eax,(%esp,1)
    c85c:	a1 00 00 00 00       	mov    0x0,%eax
    c861:	ff d0                	call   *%eax
    c863:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    adj = (unsigned int) ((char *) result - (char *) NULL) % BLOCKSIZE;
    c866:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    c869:	25 ff 0f 00 00       	and    $0xfff,%eax
    c86e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    if (adj != 0) {
    c871:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    c875:	74 27                	je     c89e <align+0x55>
	(*_morecore)(sk,adj = BLOCKSIZE - adj);
    c877:	b8 00 10 00 00       	mov    $0x1000,%eax
    c87c:	2b 45 f8             	sub    0xfffffff8(%ebp),%eax
    c87f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    c882:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    c885:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    c889:	8b 45 08             	mov    0x8(%ebp),%eax
    c88c:	89 04 24             	mov    %eax,(%esp,1)
    c88f:	a1 00 00 00 00       	mov    0x0,%eax
    c894:	ff d0                	call   *%eax
	result = (char *) result + adj;
    c896:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    c899:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
    c89c:	01 10                	add    %edx,(%eax)
    }
    return result;
    c89e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
    c8a1:	c9                   	leave  
    c8a2:	c3                   	ret    

0000c8a3 <initialize_malloc>:

/* Set everything up and remember that we have. */
static int
initialize_malloc(struct sock *sk)
{
    c8a3:	55                   	push   %ebp
    c8a4:	89 e5                	mov    %esp,%ebp
    c8a6:	53                   	push   %ebx
    c8a7:	83 ec 1c             	sub    $0x1c,%esp
    struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    c8aa:	8b 45 08             	mov    0x8(%ebp),%eax
    c8ad:	05 bc 00 00 00       	add    $0xbc,%eax
    c8b2:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    tp->t.heapsize = tp->t.heapbytesize / BLOCKSIZE;
    c8b5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    c8b8:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    c8bb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    c8be:	8b 80 1c 02 00 00    	mov    0x21c(%eax),%eax
    c8c4:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    c8c7:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
    c8cb:	79 07                	jns    c8d4 <initialize_malloc+0x31>
    c8cd:	81 45 ec ff 0f 00 00 	addl   $0xfff,0xffffffec(%ebp)
    c8d4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    c8d7:	c1 f8 0c             	sar    $0xc,%eax
    c8da:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    c8dd:	89 82 24 02 00 00    	mov    %eax,0x224(%edx)
    tp->t.heapinfo = align(sk, tp->t.heapsize * sizeof (union heap_info));
    c8e3:	8b 5d f8             	mov    0xfffffff8(%ebp),%ebx
    c8e6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    c8e9:	8b 90 24 02 00 00    	mov    0x224(%eax),%edx
    c8ef:	89 d0                	mov    %edx,%eax
    c8f1:	01 c0                	add    %eax,%eax
    c8f3:	01 d0                	add    %edx,%eax
    c8f5:	c1 e0 02             	shl    $0x2,%eax
    c8f8:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    c8fc:	8b 45 08             	mov    0x8(%ebp),%eax
    c8ff:	89 04 24             	mov    %eax,(%esp,1)
    c902:	e8 42 ff ff ff       	call   c849 <align>
    c907:	89 83 2c 02 00 00    	mov    %eax,0x22c(%ebx)
    if (!tp->t.heapinfo)
    c90d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    c910:	83 b8 2c 02 00 00 00 	cmpl   $0x0,0x22c(%eax)
    c917:	75 0c                	jne    c925 <initialize_malloc+0x82>
	return 0;
    c919:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
    c920:	e9 91 00 00 00       	jmp    c9b6 <initialize_malloc+0x113>
    memset(tp->t.heapinfo, 0, tp->t.heapsize * sizeof (union heap_info));
    c925:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    c928:	8b 90 24 02 00 00    	mov    0x224(%eax),%edx
    c92e:	89 d0                	mov    %edx,%eax
    c930:	01 c0                	add    %eax,%eax
    c932:	01 d0                	add    %edx,%eax
    c934:	c1 e0 02             	shl    $0x2,%eax
    c937:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    c93b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    c942:	00 
    c943:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    c946:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    c94c:	89 04 24             	mov    %eax,(%esp,1)
    c94f:	e8 15 12 00 00       	call   db69 <__constant_c_memset>
    tp->t.heapinfo[0].free.size = 0;
    c954:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    c957:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    c95d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    tp->t.heapinfo[0].free.next = tp->t.heapinfo[0].free.prev = 0;
    c963:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    c966:	8b 90 2c 02 00 00    	mov    0x22c(%eax),%edx
    c96c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    c96f:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    c975:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    c97c:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
    tp->t.heapindex = 0;
    c983:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    c986:	c7 80 30 02 00 00 00 	movl   $0x0,0x230(%eax)
    c98d:	00 00 00 
    tp->t.heapbase = (char *) tp->t.heapinfo;
    c990:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    c993:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    c996:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    c99c:	89 82 28 02 00 00    	mov    %eax,0x228(%edx)
    tp->t.malloc_initialized = 1;
    c9a2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    c9a5:	c7 80 18 02 00 00 01 	movl   $0x1,0x218(%eax)
    c9ac:	00 00 00 
    return 1;
    c9af:	c7 45 f4 01 00 00 00 	movl   $0x1,0xfffffff4(%ebp)
}
    c9b6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    c9b9:	83 c4 1c             	add    $0x1c,%esp
    c9bc:	5b                   	pop    %ebx
    c9bd:	5d                   	pop    %ebp
    c9be:	c3                   	ret    

0000c9bf <morecore>:

/* Get neatly aligned memory, initializing or growing the
   heap info table as necessary. */
static void *
morecore(struct sock *sk, size_t size)
{
    c9bf:	55                   	push   %ebp
    c9c0:	89 e5                	mov    %esp,%ebp
    c9c2:	83 ec 3c             	sub    $0x3c,%esp
    struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    c9c5:	8b 45 08             	mov    0x8(%ebp),%eax
    c9c8:	05 bc 00 00 00       	add    $0xbc,%eax
    c9cd:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    void *result;
    union heap_info *newinfo, *oldinfo;
    int newsize;

    result = align(sk,size);
    c9d0:	8b 45 0c             	mov    0xc(%ebp),%eax
    c9d3:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    c9d7:	8b 45 08             	mov    0x8(%ebp),%eax
    c9da:	89 04 24             	mov    %eax,(%esp,1)
    c9dd:	e8 67 fe ff ff       	call   c849 <align>
    c9e2:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    if (!result)
    c9e5:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    c9e9:	75 0c                	jne    c9f7 <morecore+0x38>
	return NULL;
    c9eb:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
    c9f2:	e9 17 02 00 00       	jmp    cc0e <morecore+0x24f>

    /* Check if we need to grow the info table. */
    if (BLOCK(sk,(char *) result + size) > tp->t.heapsize) {
    c9f7:	8b 45 0c             	mov    0xc(%ebp),%eax
    c9fa:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    c9fd:	01 c2                	add    %eax,%edx
    c9ff:	8b 45 08             	mov    0x8(%ebp),%eax
    ca02:	2b 90 e4 02 00 00    	sub    0x2e4(%eax),%edx
    ca08:	89 d0                	mov    %edx,%eax
    ca0a:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    ca0d:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
    ca11:	79 07                	jns    ca1a <morecore+0x5b>
    ca13:	81 45 e4 ff 0f 00 00 	addl   $0xfff,0xffffffe4(%ebp)
    ca1a:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    ca1d:	c1 f8 0c             	sar    $0xc,%eax
    ca20:	8d 50 01             	lea    0x1(%eax),%edx
    ca23:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    ca26:	3b 90 24 02 00 00    	cmp    0x224(%eax),%edx
    ca2c:	0f 8e 9d 01 00 00    	jle    cbcf <morecore+0x210>
	newsize = tp->t.heapsize;
    ca32:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    ca35:	8b 80 24 02 00 00    	mov    0x224(%eax),%eax
    ca3b:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	while (BLOCK(sk,(char *) result + size) > newsize)
    ca3e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ca41:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    ca44:	01 c2                	add    %eax,%edx
    ca46:	8b 45 08             	mov    0x8(%ebp),%eax
    ca49:	2b 90 e4 02 00 00    	sub    0x2e4(%eax),%edx
    ca4f:	89 d0                	mov    %edx,%eax
    ca51:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    ca54:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
    ca58:	79 07                	jns    ca61 <morecore+0xa2>
    ca5a:	81 45 e0 ff 0f 00 00 	addl   $0xfff,0xffffffe0(%ebp)
    ca61:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    ca64:	c1 f8 0c             	sar    $0xc,%eax
    ca67:	40                   	inc    %eax
    ca68:	3b 45 ec             	cmp    0xffffffec(%ebp),%eax
    ca6b:	7f 02                	jg     ca6f <morecore+0xb0>
    ca6d:	eb 0a                	jmp    ca79 <morecore+0xba>
	    newsize *= 2;
    ca6f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    ca72:	01 c0                	add    %eax,%eax
    ca74:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    ca77:	eb c5                	jmp    ca3e <morecore+0x7f>
	newinfo = align(sk,newsize * sizeof (union heap_info));
    ca79:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    ca7c:	89 d0                	mov    %edx,%eax
    ca7e:	01 c0                	add    %eax,%eax
    ca80:	01 d0                	add    %edx,%eax
    ca82:	c1 e0 02             	shl    $0x2,%eax
    ca85:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ca89:	8b 45 08             	mov    0x8(%ebp),%eax
    ca8c:	89 04 24             	mov    %eax,(%esp,1)
    ca8f:	e8 b5 fd ff ff       	call   c849 <align>
    ca94:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	if (!newinfo) {
    ca97:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
    ca9b:	75 22                	jne    cabf <morecore+0x100>
	    (*_morecore)(sk,-size);
    ca9d:	8b 45 0c             	mov    0xc(%ebp),%eax
    caa0:	f7 d8                	neg    %eax
    caa2:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    caa6:	8b 45 08             	mov    0x8(%ebp),%eax
    caa9:	89 04 24             	mov    %eax,(%esp,1)
    caac:	a1 00 00 00 00       	mov    0x0,%eax
    cab1:	ff d0                	call   *%eax
	    return NULL;
    cab3:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
    caba:	e9 4f 01 00 00       	jmp    cc0e <morecore+0x24f>
	}
	memset(newinfo, 0, newsize * sizeof (union heap_info));
    cabf:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    cac2:	89 d0                	mov    %edx,%eax
    cac4:	01 c0                	add    %eax,%eax
    cac6:	01 d0                	add    %edx,%eax
    cac8:	c1 e0 02             	shl    $0x2,%eax
    cacb:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    cacf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    cad6:	00 
    cad7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    cada:	89 04 24             	mov    %eax,(%esp,1)
    cadd:	e8 87 10 00 00       	call   db69 <__constant_c_memset>
	memcpy(newinfo, tp->t.heapinfo, tp->t.heapsize * sizeof (union heap_info));
    cae2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    cae5:	8b 90 24 02 00 00    	mov    0x224(%eax),%edx
    caeb:	89 d0                	mov    %edx,%eax
    caed:	01 c0                	add    %eax,%eax
    caef:	01 d0                	add    %edx,%eax
    caf1:	c1 e0 02             	shl    $0x2,%eax
    caf4:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    caf8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    cafb:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    cb01:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    cb05:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    cb08:	89 04 24             	mov    %eax,(%esp,1)
    cb0b:	e8 1a 10 00 00       	call   db2a <__memcpy>
	oldinfo = tp->t.heapinfo;
    cb10:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    cb13:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    cb19:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	newinfo[BLOCK(sk,oldinfo)].busy.type = 0;
    cb1c:	8b 45 08             	mov    0x8(%ebp),%eax
    cb1f:	8b 90 e4 02 00 00    	mov    0x2e4(%eax),%edx
    cb25:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    cb28:	29 d0                	sub    %edx,%eax
    cb2a:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    cb2d:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
    cb31:	79 07                	jns    cb3a <morecore+0x17b>
    cb33:	81 45 dc ff 0f 00 00 	addl   $0xfff,0xffffffdc(%ebp)
    cb3a:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    cb3d:	c1 fa 0c             	sar    $0xc,%edx
    cb40:	89 d0                	mov    %edx,%eax
    cb42:	01 c0                	add    %eax,%eax
    cb44:	01 d0                	add    %edx,%eax
    cb46:	c1 e0 02             	shl    $0x2,%eax
    cb49:	03 45 f4             	add    0xfffffff4(%ebp),%eax
    cb4c:	83 c0 0c             	add    $0xc,%eax
    cb4f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	newinfo[BLOCK(sk,oldinfo)].busy.info.size
    cb55:	8b 45 08             	mov    0x8(%ebp),%eax
    cb58:	8b 90 e4 02 00 00    	mov    0x2e4(%eax),%edx
    cb5e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    cb61:	29 d0                	sub    %edx,%eax
    cb63:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    cb66:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
    cb6a:	79 07                	jns    cb73 <morecore+0x1b4>
    cb6c:	81 45 d8 ff 0f 00 00 	addl   $0xfff,0xffffffd8(%ebp)
    cb73:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    cb76:	c1 fa 0c             	sar    $0xc,%edx
    cb79:	89 d0                	mov    %edx,%eax
    cb7b:	01 c0                	add    %eax,%eax
    cb7d:	01 d0                	add    %edx,%eax
    cb7f:	c1 e0 02             	shl    $0x2,%eax
    cb82:	03 45 f4             	add    0xfffffff4(%ebp),%eax
    cb85:	8d 48 0c             	lea    0xc(%eax),%ecx
    cb88:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    cb8b:	8b 90 24 02 00 00    	mov    0x224(%eax),%edx
    cb91:	89 d0                	mov    %edx,%eax
    cb93:	01 c0                	add    %eax,%eax
    cb95:	01 d0                	add    %edx,%eax
    cb97:	c1 e0 02             	shl    $0x2,%eax
    cb9a:	05 ff 0f 00 00       	add    $0xfff,%eax
    cb9f:	c1 e8 0c             	shr    $0xc,%eax
    cba2:	89 41 04             	mov    %eax,0x4(%ecx)
	    = BLOCKIFY(tp->t.heapsize * sizeof (union heap_info));
	tp->t.heapinfo = newinfo;
    cba5:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    cba8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    cbab:	89 82 2c 02 00 00    	mov    %eax,0x22c(%edx)
	tfree(sk,oldinfo);
    cbb1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    cbb4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    cbb8:	8b 45 08             	mov    0x8(%ebp),%eax
    cbbb:	89 04 24             	mov    %eax,(%esp,1)
    cbbe:	e8 fc ff ff ff       	call   cbbf <morecore+0x200>
	tp->t.heapsize = newsize;
    cbc3:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    cbc6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    cbc9:	89 82 24 02 00 00    	mov    %eax,0x224(%edx)
    }
    tp->t.heaplimit = BLOCK(sk,(char *) result + size);
    cbcf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    cbd2:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
    cbd5:	8b 45 0c             	mov    0xc(%ebp),%eax
    cbd8:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    cbdb:	01 c2                	add    %eax,%edx
    cbdd:	8b 45 08             	mov    0x8(%ebp),%eax
    cbe0:	2b 90 e4 02 00 00    	sub    0x2e4(%eax),%edx
    cbe6:	89 d0                	mov    %edx,%eax
    cbe8:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    cbeb:	83 7d d0 00          	cmpl   $0x0,0xffffffd0(%ebp)
    cbef:	79 07                	jns    cbf8 <morecore+0x239>
    cbf1:	81 45 d0 ff 0f 00 00 	addl   $0xfff,0xffffffd0(%ebp)
    cbf8:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    cbfb:	c1 f8 0c             	sar    $0xc,%eax
    cbfe:	40                   	inc    %eax
    cbff:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
    cc02:	89 82 34 02 00 00    	mov    %eax,0x234(%edx)
    return result;
    cc08:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    cc0b:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
}
    cc0e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    cc11:	c9                   	leave  
    cc12:	c3                   	ret    

0000cc13 <tmalloc>:

/* Allocate memory from the heap. */
void *
tmalloc(struct sock *sk, size_t size)
{
    cc13:	55                   	push   %ebp
    cc14:	89 e5                	mov    %esp,%ebp
    cc16:	57                   	push   %edi
    cc17:	56                   	push   %esi
    cc18:	53                   	push   %ebx
    cc19:	83 ec 3c             	sub    $0x3c,%esp
    struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    cc1c:	8b 45 08             	mov    0x8(%ebp),%eax
    cc1f:	05 bc 00 00 00       	add    $0xbc,%eax
    cc24:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    void *result;
    int log, block, blocks, i, lastblocks, start;
    struct heap_list *next;

    if(SIMULATION_MODE(sk)) {
    cc27:	8b 45 08             	mov    0x8(%ebp),%eax
    cc2a:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    cc30:	83 e0 01             	and    $0x1,%eax
    cc33:	85 c0                	test   %eax,%eax
    cc35:	74 34                	je     cc6b <tmalloc+0x58>
    cc37:	8b 55 08             	mov    0x8(%ebp),%edx
    cc3a:	8b 45 08             	mov    0x8(%ebp),%eax
    cc3d:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    cc43:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
    cc49:	83 e0 08             	and    $0x8,%eax
    cc4c:	85 c0                	test   %eax,%eax
    cc4e:	75 1b                	jne    cc6b <tmalloc+0x58>
	    return kmalloc(size, GFP_ATOMIC);
    cc50:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
    cc57:	00 
    cc58:	8b 45 0c             	mov    0xc(%ebp),%eax
    cc5b:	89 04 24             	mov    %eax,(%esp,1)
    cc5e:	e8 fc ff ff ff       	call   cc5f <tmalloc+0x4c>
    cc63:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    cc66:	e9 e9 06 00 00       	jmp    d354 <tmalloc+0x741>
    }

    if (!tp->t.malloc_initialized && !initialize_malloc(sk))
    cc6b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    cc6e:	83 b8 18 02 00 00 00 	cmpl   $0x0,0x218(%eax)
    cc75:	75 1b                	jne    cc92 <tmalloc+0x7f>
    cc77:	8b 45 08             	mov    0x8(%ebp),%eax
    cc7a:	89 04 24             	mov    %eax,(%esp,1)
    cc7d:	e8 21 fc ff ff       	call   c8a3 <initialize_malloc>
    cc82:	85 c0                	test   %eax,%eax
    cc84:	75 0c                	jne    cc92 <tmalloc+0x7f>
	return NULL;
    cc86:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
    cc8d:	e9 c2 06 00 00       	jmp    d354 <tmalloc+0x741>

    if (size == 0)
    cc92:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    cc96:	75 0c                	jne    cca4 <tmalloc+0x91>
	return NULL;
    cc98:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
    cc9f:	e9 b0 06 00 00       	jmp    d354 <tmalloc+0x741>

    if (size < sizeof (struct heap_list))
    cca4:	83 7d 0c 07          	cmpl   $0x7,0xc(%ebp)
    cca8:	77 07                	ja     ccb1 <tmalloc+0x9e>
	size = sizeof (struct heap_list);
    ccaa:	c7 45 0c 08 00 00 00 	movl   $0x8,0xc(%ebp)

    /* Determine the allocation policy based on the request size. */
    if (size <= BLOCKSIZE / 2) {
    ccb1:	81 7d 0c 00 08 00 00 	cmpl   $0x800,0xc(%ebp)
    ccb8:	0f 87 1a 02 00 00    	ja     ced8 <tmalloc+0x2c5>
	/* Small allocation to receive a fragment of a block. Determine
	   the logarithm to base two of the fragment size. */
	--size;
    ccbe:	8d 45 0c             	lea    0xc(%ebp),%eax
    ccc1:	ff 08                	decl   (%eax)
	for (log = 1; (size >>= 1) != 0; ++log)
    ccc3:	c7 45 e8 01 00 00 00 	movl   $0x1,0xffffffe8(%ebp)
    ccca:	8d 45 0c             	lea    0xc(%ebp),%eax
    cccd:	d1 28                	shrl   (%eax)
    cccf:	8b 45 0c             	mov    0xc(%ebp),%eax
    ccd2:	85 c0                	test   %eax,%eax
    ccd4:	75 02                	jne    ccd8 <tmalloc+0xc5>
    ccd6:	eb 07                	jmp    ccdf <tmalloc+0xcc>
    ccd8:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
    ccdb:	ff 00                	incl   (%eax)
    ccdd:	eb eb                	jmp    ccca <tmalloc+0xb7>
	    ;

	/* Look in the fragment lists for a free fragment of the
	   desired size. */
	if ((next = tp->t.fraghead[log].next) != 0) {
    ccdf:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    cce2:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    cce5:	8b 84 d0 68 02 00 00 	mov    0x268(%eax,%edx,8),%eax
    ccec:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    ccef:	85 c0                	test   %eax,%eax
    ccf1:	0f 84 ab 00 00 00    	je     cda2 <tmalloc+0x18f>
	    /* There are free fragments of this size.  Pop a fragment
	       out of the fragment list and return it.  Update the block's
	       nfree and first counters. */
	    result = next;
    ccf7:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    ccfa:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	    next->prev->next = next->next;
    ccfd:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    cd00:	8b 50 04             	mov    0x4(%eax),%edx
    cd03:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    cd06:	8b 00                	mov    (%eax),%eax
    cd08:	89 02                	mov    %eax,(%edx)
	    if (next->next)
    cd0a:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    cd0d:	83 38 00             	cmpl   $0x0,(%eax)
    cd10:	74 0e                	je     cd20 <tmalloc+0x10d>
		next->next->prev = next->prev;
    cd12:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    cd15:	8b 10                	mov    (%eax),%edx
    cd17:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    cd1a:	8b 40 04             	mov    0x4(%eax),%eax
    cd1d:	89 42 04             	mov    %eax,0x4(%edx)
	    block = BLOCK(sk,result);
    cd20:	8b 45 08             	mov    0x8(%ebp),%eax
    cd23:	8b 90 e4 02 00 00    	mov    0x2e4(%eax),%edx
    cd29:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    cd2c:	29 d0                	sub    %edx,%eax
    cd2e:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
    cd31:	83 7d c8 00          	cmpl   $0x0,0xffffffc8(%ebp)
    cd35:	79 07                	jns    cd3e <tmalloc+0x12b>
    cd37:	81 45 c8 ff 0f 00 00 	addl   $0xfff,0xffffffc8(%ebp)
    cd3e:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    cd41:	c1 f8 0c             	sar    $0xc,%eax
    cd44:	40                   	inc    %eax
    cd45:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
	    if (--tp->t.heapinfo[block].busy.info.frag.nfree)
    cd48:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    cd4b:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    cd4e:	89 d0                	mov    %edx,%eax
    cd50:	01 c0                	add    %eax,%eax
    cd52:	01 d0                	add    %edx,%eax
    cd54:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    cd5b:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    cd61:	ff 4c 10 04          	decl   0x4(%eax,%edx,1)
    cd65:	83 7c 10 04 00       	cmpl   $0x0,0x4(%eax,%edx,1)
    cd6a:	0f 84 de 05 00 00    	je     d34e <tmalloc+0x73b>
		tp->t.heapinfo[block].busy.info.frag.first
    cd70:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    cd73:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    cd76:	89 d0                	mov    %edx,%eax
    cd78:	01 c0                	add    %eax,%eax
    cd7a:	01 d0                	add    %edx,%eax
    cd7c:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    cd83:	8b 91 2c 02 00 00    	mov    0x22c(%ecx),%edx
    cd89:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    cd8c:	8b 00                	mov    (%eax),%eax
    cd8e:	25 ff 0f 00 00       	and    $0xfff,%eax
    cd93:	0f b6 4d e8          	movzbl 0xffffffe8(%ebp),%ecx
    cd97:	d3 e8                	shr    %cl,%eax
    cd99:	89 44 1a 08          	mov    %eax,0x8(%edx,%ebx,1)
    cd9d:	e9 ac 05 00 00       	jmp    d34e <tmalloc+0x73b>
		    = (unsigned int) ((char *) next->next - (char *) NULL)
		      % BLOCKSIZE >> log;
	} else {
	    /* No free fragments of the desired size, so get a new block
	       and break it into fragments, returning the first. */
	    result = tmalloc(sk,BLOCKSIZE);
    cda2:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp,1)
    cda9:	00 
    cdaa:	8b 45 08             	mov    0x8(%ebp),%eax
    cdad:	89 04 24             	mov    %eax,(%esp,1)
    cdb0:	e8 fc ff ff ff       	call   cdb1 <tmalloc+0x19e>
    cdb5:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	    if (!result)
    cdb8:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
    cdbc:	75 0c                	jne    cdca <tmalloc+0x1b7>
		return NULL;
    cdbe:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
    cdc5:	e9 8a 05 00 00       	jmp    d354 <tmalloc+0x741>
	    ++tp->t.fragblocks[log];
    cdca:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    cdcd:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    cdd0:	ff 84 82 38 02 00 00 	incl   0x238(%edx,%eax,4)

	    /* Link all fragments but the first into the free list. */
	    for (i = 1; i < BLOCKSIZE >> log; ++i) {
    cdd7:	c7 45 dc 01 00 00 00 	movl   $0x1,0xffffffdc(%ebp)
    cdde:	b8 00 10 00 00       	mov    $0x1000,%eax
    cde3:	0f b6 4d e8          	movzbl 0xffffffe8(%ebp),%ecx
    cde7:	d3 f8                	sar    %cl,%eax
    cde9:	39 45 dc             	cmp    %eax,0xffffffdc(%ebp)
    cdec:	7c 02                	jl     cdf0 <tmalloc+0x1dd>
    cdee:	eb 5a                	jmp    ce4a <tmalloc+0x237>
		next = (struct heap_list *) ((char *) result + (i << log));
    cdf0:	0f b6 4d e8          	movzbl 0xffffffe8(%ebp),%ecx
    cdf4:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    cdf7:	d3 e0                	shl    %cl,%eax
    cdf9:	03 45 ec             	add    0xffffffec(%ebp),%eax
    cdfc:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
		next->next = tp->t.fraghead[log].next;
    cdff:	8b 4d d0             	mov    0xffffffd0(%ebp),%ecx
    ce02:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    ce05:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    ce08:	8b 84 c2 68 02 00 00 	mov    0x268(%edx,%eax,8),%eax
    ce0f:	89 01                	mov    %eax,(%ecx)
		next->prev = &tp->t.fraghead[log];
    ce11:	8b 55 d0             	mov    0xffffffd0(%ebp),%edx
    ce14:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    ce17:	c1 e0 03             	shl    $0x3,%eax
    ce1a:	03 45 f0             	add    0xfffffff0(%ebp),%eax
    ce1d:	05 68 02 00 00       	add    $0x268,%eax
    ce22:	89 42 04             	mov    %eax,0x4(%edx)
		next->prev->next = next;
    ce25:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    ce28:	8b 50 04             	mov    0x4(%eax),%edx
    ce2b:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    ce2e:	89 02                	mov    %eax,(%edx)
		if (next->next)
    ce30:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    ce33:	83 38 00             	cmpl   $0x0,(%eax)
    ce36:	74 0b                	je     ce43 <tmalloc+0x230>
		    next->next->prev = next;
    ce38:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    ce3b:	8b 10                	mov    (%eax),%edx
    ce3d:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    ce40:	89 42 04             	mov    %eax,0x4(%edx)
    ce43:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
    ce46:	ff 00                	incl   (%eax)
    ce48:	eb 94                	jmp    cdde <tmalloc+0x1cb>
	    }

	    /* Initialize the nfree and first counters for this block. */
	    block = BLOCK(sk,result);
    ce4a:	8b 45 08             	mov    0x8(%ebp),%eax
    ce4d:	8b 90 e4 02 00 00    	mov    0x2e4(%eax),%edx
    ce53:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    ce56:	29 d0                	sub    %edx,%eax
    ce58:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
    ce5b:	83 7d c4 00          	cmpl   $0x0,0xffffffc4(%ebp)
    ce5f:	79 07                	jns    ce68 <tmalloc+0x255>
    ce61:	81 45 c4 ff 0f 00 00 	addl   $0xfff,0xffffffc4(%ebp)
    ce68:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
    ce6b:	c1 f8 0c             	sar    $0xc,%eax
    ce6e:	40                   	inc    %eax
    ce6f:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
	    tp->t.heapinfo[block].busy.type = log;
    ce72:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    ce75:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    ce78:	89 d0                	mov    %edx,%eax
    ce7a:	01 c0                	add    %eax,%eax
    ce7c:	01 d0                	add    %edx,%eax
    ce7e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    ce85:	8b 93 2c 02 00 00    	mov    0x22c(%ebx),%edx
    ce8b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    ce8e:	89 04 0a             	mov    %eax,(%edx,%ecx,1)
	    tp->t.heapinfo[block].busy.info.frag.nfree = i - 1;
    ce91:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    ce94:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    ce97:	89 d0                	mov    %edx,%eax
    ce99:	01 c0                	add    %eax,%eax
    ce9b:	01 d0                	add    %edx,%eax
    ce9d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    cea4:	8b 93 2c 02 00 00    	mov    0x22c(%ebx),%edx
    ceaa:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    cead:	48                   	dec    %eax
    ceae:	89 44 0a 04          	mov    %eax,0x4(%edx,%ecx,1)
	    tp->t.heapinfo[block].busy.info.frag.first = i - 1;
    ceb2:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    ceb5:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    ceb8:	89 d0                	mov    %edx,%eax
    ceba:	01 c0                	add    %eax,%eax
    cebc:	01 d0                	add    %edx,%eax
    cebe:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    cec5:	8b 93 2c 02 00 00    	mov    0x22c(%ebx),%edx
    cecb:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    cece:	48                   	dec    %eax
    cecf:	89 44 0a 08          	mov    %eax,0x8(%edx,%ecx,1)
    ced3:	e9 76 04 00 00       	jmp    d34e <tmalloc+0x73b>
	}
    } else {
	/* Large allocation to receive one or more blocks.  Search
	   the free list in a circle starting at the last place visited.
	   If we loop completely around without finding a large enough
	   space we will have to get more memory from the system. */
	blocks = BLOCKIFY(size);
    ced8:	8b 45 0c             	mov    0xc(%ebp),%eax
    cedb:	05 ff 0f 00 00       	add    $0xfff,%eax
    cee0:	c1 e8 0c             	shr    $0xc,%eax
    cee3:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
	start = block = tp->t.heapindex;
    cee6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    cee9:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
    ceef:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    cef2:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
	while (tp->t.heapinfo[block].free.size < blocks) {
    cef5:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    cef8:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    cefb:	89 d0                	mov    %edx,%eax
    cefd:	01 c0                	add    %eax,%eax
    ceff:	01 d0                	add    %edx,%eax
    cf01:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    cf08:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    cf0e:	8b 04 10             	mov    (%eax,%edx,1),%eax
    cf11:	3b 45 e0             	cmp    0xffffffe0(%ebp),%eax
    cf14:	7c 05                	jl     cf1b <tmalloc+0x308>
    cf16:	e9 be 01 00 00       	jmp    d0d9 <tmalloc+0x4c6>
	    block = tp->t.heapinfo[block].free.next;
    cf1b:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    cf1e:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    cf21:	89 d0                	mov    %edx,%eax
    cf23:	01 c0                	add    %eax,%eax
    cf25:	01 d0                	add    %edx,%eax
    cf27:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    cf2e:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    cf34:	8b 44 10 04          	mov    0x4(%eax,%edx,1),%eax
    cf38:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
	    if (block == start) {
    cf3b:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    cf3e:	3b 45 d4             	cmp    0xffffffd4(%ebp),%eax
    cf41:	75 b2                	jne    cef5 <tmalloc+0x2e2>
		/* Need to get more from the system.  Check to see if
		   the new core will be contiguous with the final free
		   block; if so we don't need to get as much. */
		block = tp->t.heapinfo[0].free.prev;
    cf43:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    cf46:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    cf4c:	8b 40 08             	mov    0x8(%eax),%eax
    cf4f:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
		lastblocks = tp->t.heapinfo[block].free.size;
    cf52:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    cf55:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    cf58:	89 d0                	mov    %edx,%eax
    cf5a:	01 c0                	add    %eax,%eax
    cf5c:	01 d0                	add    %edx,%eax
    cf5e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    cf65:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    cf6b:	8b 04 10             	mov    (%eax,%edx,1),%eax
    cf6e:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
		if (tp->t.heaplimit && block + lastblocks == tp->t.heaplimit
    cf71:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    cf74:	83 b8 34 02 00 00 00 	cmpl   $0x0,0x234(%eax)
    cf7b:	0f 84 bb 00 00 00    	je     d03c <tmalloc+0x429>
    cf81:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    cf84:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    cf87:	01 c2                	add    %eax,%edx
    cf89:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    cf8c:	3b 90 34 02 00 00    	cmp    0x234(%eax),%edx
    cf92:	0f 85 a4 00 00 00    	jne    d03c <tmalloc+0x429>
    cf98:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    cf9f:	00 
    cfa0:	8b 45 08             	mov    0x8(%ebp),%eax
    cfa3:	89 04 24             	mov    %eax,(%esp,1)
    cfa6:	a1 00 00 00 00       	mov    0x0,%eax
    cfab:	ff d0                	call   *%eax
    cfad:	89 c1                	mov    %eax,%ecx
    cfaf:	8b 55 08             	mov    0x8(%ebp),%edx
    cfb2:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    cfb5:	03 45 e4             	add    0xffffffe4(%ebp),%eax
    cfb8:	c1 e0 0c             	shl    $0xc,%eax
    cfbb:	03 82 e4 02 00 00    	add    0x2e4(%edx),%eax
    cfc1:	2d 00 10 00 00       	sub    $0x1000,%eax
    cfc6:	39 c1                	cmp    %eax,%ecx
    cfc8:	75 72                	jne    d03c <tmalloc+0x429>
    cfca:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    cfcd:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    cfd0:	29 d0                	sub    %edx,%eax
    cfd2:	c1 e0 0c             	shl    $0xc,%eax
    cfd5:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    cfd9:	8b 45 08             	mov    0x8(%ebp),%eax
    cfdc:	89 04 24             	mov    %eax,(%esp,1)
    cfdf:	e8 db f9 ff ff       	call   c9bf <morecore>
    cfe4:	85 c0                	test   %eax,%eax
    cfe6:	74 54                	je     d03c <tmalloc+0x429>
		    && (*_morecore)(sk,0) == ADDRESS(sk,block + lastblocks)
		    && morecore(sk,(blocks - lastblocks) * BLOCKSIZE)) {
		    /* Note that morecore() can change the location of
		       the final block if it moves the info table and the
		       old one gets coalesced into the final block. */
		    block = tp->t.heapinfo[0].free.prev;
    cfe8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    cfeb:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    cff1:	8b 40 08             	mov    0x8(%eax),%eax
    cff4:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
		    tp->t.heapinfo[block].free.size += blocks - lastblocks;
    cff7:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    cffa:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    cffd:	89 d0                	mov    %edx,%eax
    cfff:	01 c0                	add    %eax,%eax
    d001:	01 d0                	add    %edx,%eax
    d003:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
    d00a:	8b b9 2c 02 00 00    	mov    0x22c(%ecx),%edi
    d010:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d013:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d016:	89 d0                	mov    %edx,%eax
    d018:	01 c0                	add    %eax,%eax
    d01a:	01 d0                	add    %edx,%eax
    d01c:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d023:	8b 89 2c 02 00 00    	mov    0x22c(%ecx),%ecx
    d029:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    d02c:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    d02f:	29 d0                	sub    %edx,%eax
    d031:	03 04 19             	add    (%ecx,%ebx,1),%eax
    d034:	89 04 37             	mov    %eax,(%edi,%esi,1)
		    continue;
    d037:	e9 b9 fe ff ff       	jmp    cef5 <tmalloc+0x2e2>
		}
		result = morecore(sk,blocks * BLOCKSIZE);
    d03c:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    d03f:	c1 e0 0c             	shl    $0xc,%eax
    d042:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    d046:	8b 45 08             	mov    0x8(%ebp),%eax
    d049:	89 04 24             	mov    %eax,(%esp,1)
    d04c:	e8 6e f9 ff ff       	call   c9bf <morecore>
    d051:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
		if (!result)
    d054:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
    d058:	75 0c                	jne    d066 <tmalloc+0x453>
		    return NULL;
    d05a:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
    d061:	e9 ee 02 00 00       	jmp    d354 <tmalloc+0x741>
		block = BLOCK(sk,result);
    d066:	8b 45 08             	mov    0x8(%ebp),%eax
    d069:	8b 90 e4 02 00 00    	mov    0x2e4(%eax),%edx
    d06f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    d072:	29 d0                	sub    %edx,%eax
    d074:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
    d077:	83 7d c0 00          	cmpl   $0x0,0xffffffc0(%ebp)
    d07b:	79 07                	jns    d084 <tmalloc+0x471>
    d07d:	81 45 c0 ff 0f 00 00 	addl   $0xfff,0xffffffc0(%ebp)
    d084:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
    d087:	c1 f8 0c             	sar    $0xc,%eax
    d08a:	40                   	inc    %eax
    d08b:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
		tp->t.heapinfo[block].busy.type = 0;
    d08e:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d091:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d094:	89 d0                	mov    %edx,%eax
    d096:	01 c0                	add    %eax,%eax
    d098:	01 d0                	add    %edx,%eax
    d09a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d0a1:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d0a7:	c7 04 10 00 00 00 00 	movl   $0x0,(%eax,%edx,1)
		tp->t.heapinfo[block].busy.info.size = blocks;
    d0ae:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    d0b1:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d0b4:	89 d0                	mov    %edx,%eax
    d0b6:	01 c0                	add    %eax,%eax
    d0b8:	01 d0                	add    %edx,%eax
    d0ba:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d0c1:	8b 93 2c 02 00 00    	mov    0x22c(%ebx),%edx
    d0c7:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    d0ca:	89 44 0a 04          	mov    %eax,0x4(%edx,%ecx,1)

		//printk("tmalloc: returning %p\n", result);
		//show_stack(0);

		return result;
    d0ce:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    d0d1:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    d0d4:	e9 7b 02 00 00       	jmp    d354 <tmalloc+0x741>
	    }
	}

	/* At this point we have found a suitable free list entry.
	   Figure out how to remove what we need from the list. */
	result = ADDRESS(sk,block);
    d0d9:	8b 55 08             	mov    0x8(%ebp),%edx
    d0dc:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    d0df:	c1 e0 0c             	shl    $0xc,%eax
    d0e2:	03 82 e4 02 00 00    	add    0x2e4(%edx),%eax
    d0e8:	2d 00 10 00 00       	sub    $0x1000,%eax
    d0ed:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	if (tp->t.heapinfo[block].free.size > blocks) {
    d0f0:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d0f3:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d0f6:	89 d0                	mov    %edx,%eax
    d0f8:	01 c0                	add    %eax,%eax
    d0fa:	01 d0                	add    %edx,%eax
    d0fc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d103:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d109:	8b 04 10             	mov    (%eax,%edx,1),%eax
    d10c:	3b 45 e0             	cmp    0xffffffe0(%ebp),%eax
    d10f:	0f 8e 48 01 00 00    	jle    d25d <tmalloc+0x64a>
	    /* The block we found has a bit left over, so relink the
	       tail end back into the free list. */
	    tp->t.heapinfo[block + blocks].free.size
    d115:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d118:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    d11b:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d11e:	01 c2                	add    %eax,%edx
    d120:	89 d0                	mov    %edx,%eax
    d122:	01 c0                	add    %eax,%eax
    d124:	01 d0                	add    %edx,%eax
    d126:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
    d12d:	8b b9 2c 02 00 00    	mov    0x22c(%ecx),%edi
    d133:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    d136:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d139:	89 d0                	mov    %edx,%eax
    d13b:	01 c0                	add    %eax,%eax
    d13d:	01 d0                	add    %edx,%eax
    d13f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d146:	8b 83 2c 02 00 00    	mov    0x22c(%ebx),%eax
    d14c:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    d14f:	8b 04 08             	mov    (%eax,%ecx,1),%eax
    d152:	29 d0                	sub    %edx,%eax
    d154:	89 04 37             	mov    %eax,(%edi,%esi,1)
		= tp->t.heapinfo[block].free.size - blocks;
	    tp->t.heapinfo[block + blocks].free.next
    d157:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d15a:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    d15d:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d160:	01 c2                	add    %eax,%edx
    d162:	89 d0                	mov    %edx,%eax
    d164:	01 c0                	add    %eax,%eax
    d166:	01 d0                	add    %edx,%eax
    d168:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d16f:	8b b1 2c 02 00 00    	mov    0x22c(%ecx),%esi
    d175:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d178:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d17b:	89 d0                	mov    %edx,%eax
    d17d:	01 c0                	add    %eax,%eax
    d17f:	01 d0                	add    %edx,%eax
    d181:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d188:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d18e:	8b 44 10 04          	mov    0x4(%eax,%edx,1),%eax
    d192:	89 44 1e 04          	mov    %eax,0x4(%esi,%ebx,1)
		= tp->t.heapinfo[block].free.next;
	    tp->t.heapinfo[block + blocks].free.prev
    d196:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d199:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    d19c:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d19f:	01 c2                	add    %eax,%edx
    d1a1:	89 d0                	mov    %edx,%eax
    d1a3:	01 c0                	add    %eax,%eax
    d1a5:	01 d0                	add    %edx,%eax
    d1a7:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d1ae:	8b b1 2c 02 00 00    	mov    0x22c(%ecx),%esi
    d1b4:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d1b7:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d1ba:	89 d0                	mov    %edx,%eax
    d1bc:	01 c0                	add    %eax,%eax
    d1be:	01 d0                	add    %edx,%eax
    d1c0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d1c7:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d1cd:	8b 44 10 08          	mov    0x8(%eax,%edx,1),%eax
    d1d1:	89 44 1e 08          	mov    %eax,0x8(%esi,%ebx,1)
		= tp->t.heapinfo[block].free.prev;
	    tp->t.heapinfo[tp->t.heapinfo[block].free.prev].free.next
    d1d5:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    d1d8:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d1db:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d1de:	89 d0                	mov    %edx,%eax
    d1e0:	01 c0                	add    %eax,%eax
    d1e2:	01 d0                	add    %edx,%eax
    d1e4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d1eb:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d1f1:	8b 54 10 08          	mov    0x8(%eax,%edx,1),%edx
    d1f5:	89 d0                	mov    %edx,%eax
    d1f7:	01 c0                	add    %eax,%eax
    d1f9:	01 d0                	add    %edx,%eax
    d1fb:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
    d202:	8b bb 2c 02 00 00    	mov    0x22c(%ebx),%edi
    d208:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    d20b:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d20e:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d211:	89 d0                	mov    %edx,%eax
    d213:	01 c0                	add    %eax,%eax
    d215:	01 d0                	add    %edx,%eax
    d217:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d21e:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d224:	8b 54 10 04          	mov    0x4(%eax,%edx,1),%edx
    d228:	89 d0                	mov    %edx,%eax
    d22a:	01 c0                	add    %eax,%eax
    d22c:	01 d0                	add    %edx,%eax
    d22e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d235:	8b 9b 2c 02 00 00    	mov    0x22c(%ebx),%ebx
    d23b:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    d23e:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    d241:	03 45 e4             	add    0xffffffe4(%ebp),%eax
    d244:	89 82 30 02 00 00    	mov    %eax,0x230(%edx)
    d24a:	8b 82 30 02 00 00    	mov    0x230(%edx),%eax
    d250:	89 44 0b 08          	mov    %eax,0x8(%ebx,%ecx,1)
    d254:	89 44 37 04          	mov    %eax,0x4(%edi,%esi,1)
    d258:	e9 b1 00 00 00       	jmp    d30e <tmalloc+0x6fb>
		= tp->t.heapinfo[tp->t.heapinfo[block].free.next].free.prev
		    = tp->t.heapindex = block + blocks;
	} else {
	    /* The block exactly matches our requirements, so
	       just remove it from the list. */
	    tp->t.heapinfo[tp->t.heapinfo[block].free.next].free.prev
    d25d:	8b 75 f0             	mov    0xfffffff0(%ebp),%esi
    d260:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d263:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d266:	89 d0                	mov    %edx,%eax
    d268:	01 c0                	add    %eax,%eax
    d26a:	01 d0                	add    %edx,%eax
    d26c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d273:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d279:	8b 54 10 04          	mov    0x4(%eax,%edx,1),%edx
    d27d:	89 d0                	mov    %edx,%eax
    d27f:	01 c0                	add    %eax,%eax
    d281:	01 d0                	add    %edx,%eax
    d283:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d28a:	8b b6 2c 02 00 00    	mov    0x22c(%esi),%esi
    d290:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d293:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d296:	89 d0                	mov    %edx,%eax
    d298:	01 c0                	add    %eax,%eax
    d29a:	01 d0                	add    %edx,%eax
    d29c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d2a3:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d2a9:	8b 44 10 08          	mov    0x8(%eax,%edx,1),%eax
    d2ad:	89 44 1e 08          	mov    %eax,0x8(%esi,%ebx,1)
		= tp->t.heapinfo[block].free.prev;
	    tp->t.heapinfo[tp->t.heapinfo[block].free.prev].free.next
    d2b1:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    d2b4:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d2b7:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d2ba:	89 d0                	mov    %edx,%eax
    d2bc:	01 c0                	add    %eax,%eax
    d2be:	01 d0                	add    %edx,%eax
    d2c0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d2c7:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d2cd:	8b 54 10 08          	mov    0x8(%eax,%edx,1),%edx
    d2d1:	89 d0                	mov    %edx,%eax
    d2d3:	01 c0                	add    %eax,%eax
    d2d5:	01 d0                	add    %edx,%eax
    d2d7:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
    d2de:	8b bb 2c 02 00 00    	mov    0x22c(%ebx),%edi
    d2e4:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    d2e7:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d2ea:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d2ed:	89 d0                	mov    %edx,%eax
    d2ef:	01 c0                	add    %eax,%eax
    d2f1:	01 d0                	add    %edx,%eax
    d2f3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d2fa:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d300:	8b 44 10 04          	mov    0x4(%eax,%edx,1),%eax
    d304:	89 83 30 02 00 00    	mov    %eax,0x230(%ebx)
    d30a:	89 44 37 04          	mov    %eax,0x4(%edi,%esi,1)
		= tp->t.heapindex = tp->t.heapinfo[block].free.next;
	}

	tp->t.heapinfo[block].busy.type = 0;
    d30e:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d311:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d314:	89 d0                	mov    %edx,%eax
    d316:	01 c0                	add    %eax,%eax
    d318:	01 d0                	add    %edx,%eax
    d31a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d321:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d327:	c7 04 10 00 00 00 00 	movl   $0x0,(%eax,%edx,1)
	tp->t.heapinfo[block].busy.info.size = blocks;
    d32e:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    d331:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d334:	89 d0                	mov    %edx,%eax
    d336:	01 c0                	add    %eax,%eax
    d338:	01 d0                	add    %edx,%eax
    d33a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d341:	8b 93 2c 02 00 00    	mov    0x22c(%ebx),%edx
    d347:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    d34a:	89 44 0a 04          	mov    %eax,0x4(%edx,%ecx,1)
    }

    //printk("tmalloc: returning %p\n", result);
    //show_stack(0);

    return result;
    d34e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    d351:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
}
    d354:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    d357:	83 c4 3c             	add    $0x3c,%esp
    d35a:	5b                   	pop    %ebx
    d35b:	5e                   	pop    %esi
    d35c:	5f                   	pop    %edi
    d35d:	5d                   	pop    %ebp
    d35e:	c3                   	ret    

0000d35f <tfree>:

/* Return memory to the heap. */
void
tfree(struct sock *sk, void *ptr)
{
    d35f:	55                   	push   %ebp
    d360:	89 e5                	mov    %esp,%ebp
    d362:	57                   	push   %edi
    d363:	56                   	push   %esi
    d364:	53                   	push   %ebx
    d365:	83 ec 34             	sub    $0x34,%esp
	//printk("tfreeing %p\n", ptr);
    struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
    d368:	8b 45 08             	mov    0x8(%ebp),%eax
    d36b:	05 bc 00 00 00       	add    $0xbc,%eax
    d370:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    int block, blocks, i, type;
    struct heap_list *prev, *next;

    if (!ptr)
    d373:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    d377:	75 05                	jne    d37e <tfree+0x1f>
	return;
    d379:	e9 a4 07 00 00       	jmp    db22 <tfree+0x7c3>

    if(SIMULATION_MODE(sk)) {
    d37e:	8b 45 08             	mov    0x8(%ebp),%eax
    d381:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    d387:	83 e0 01             	and    $0x1,%eax
    d38a:	85 c0                	test   %eax,%eax
    d38c:	74 29                	je     d3b7 <tfree+0x58>
    d38e:	8b 55 08             	mov    0x8(%ebp),%edx
    d391:	8b 45 08             	mov    0x8(%ebp),%eax
    d394:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    d39a:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
    d3a0:	83 e0 08             	and    $0x8,%eax
    d3a3:	85 c0                	test   %eax,%eax
    d3a5:	75 10                	jne    d3b7 <tfree+0x58>
	    kfree(ptr);
    d3a7:	8b 45 0c             	mov    0xc(%ebp),%eax
    d3aa:	89 04 24             	mov    %eax,(%esp,1)
    d3ad:	e8 fc ff ff ff       	call   d3ae <tfree+0x4f>
	    return;
    d3b2:	e9 6b 07 00 00       	jmp    db22 <tfree+0x7c3>
    }

    block = BLOCK(sk,ptr);
    d3b7:	8b 45 08             	mov    0x8(%ebp),%eax
    d3ba:	8b 90 e4 02 00 00    	mov    0x2e4(%eax),%edx
    d3c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    d3c3:	29 d0                	sub    %edx,%eax
    d3c5:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
    d3c8:	83 7d d4 00          	cmpl   $0x0,0xffffffd4(%ebp)
    d3cc:	79 07                	jns    d3d5 <tfree+0x76>
    d3ce:	81 45 d4 ff 0f 00 00 	addl   $0xfff,0xffffffd4(%ebp)
    d3d5:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    d3d8:	c1 f8 0c             	sar    $0xc,%eax
    d3db:	40                   	inc    %eax
    d3dc:	89 45 ec             	mov    %eax,0xffffffec(%ebp)

    switch (type = tp->t.heapinfo[block].busy.type) {
    d3df:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d3e2:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d3e5:	89 d0                	mov    %edx,%eax
    d3e7:	01 c0                	add    %eax,%eax
    d3e9:	01 d0                	add    %edx,%eax
    d3eb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d3f2:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d3f8:	8b 04 10             	mov    (%eax,%edx,1),%eax
    d3fb:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    d3fe:	85 c0                	test   %eax,%eax
    d400:	74 05                	je     d407 <tfree+0xa8>
    d402:	e9 cc 04 00 00       	jmp    d8d3 <tfree+0x574>
    case 0:
	/* Find the free cluster previous to this one in the free list.
	   Start searching at the last block referenced; this may benefit
	   programs with locality of allocation. */
	i = tp->t.heapindex;
    d407:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    d40a:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
    d410:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
	if (i > block)
    d413:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    d416:	3b 45 ec             	cmp    0xffffffec(%ebp),%eax
    d419:	7e 2c                	jle    d447 <tfree+0xe8>
	    while (i > block)
    d41b:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    d41e:	3b 45 ec             	cmp    0xffffffec(%ebp),%eax
    d421:	7f 02                	jg     d425 <tfree+0xc6>
    d423:	eb 70                	jmp    d495 <tfree+0x136>
		i = tp->t.heapinfo[i].free.prev;
    d425:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d428:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d42b:	89 d0                	mov    %edx,%eax
    d42d:	01 c0                	add    %eax,%eax
    d42f:	01 d0                	add    %edx,%eax
    d431:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d438:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d43e:	8b 44 10 08          	mov    0x8(%eax,%edx,1),%eax
    d442:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    d445:	eb d4                	jmp    d41b <tfree+0xbc>
	else {
	    do
		i = tp->t.heapinfo[i].free.next;
    d447:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d44a:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d44d:	89 d0                	mov    %edx,%eax
    d44f:	01 c0                	add    %eax,%eax
    d451:	01 d0                	add    %edx,%eax
    d453:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d45a:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d460:	8b 44 10 04          	mov    0x4(%eax,%edx,1),%eax
    d464:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    d467:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
    d46b:	7e 08                	jle    d475 <tfree+0x116>
    d46d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    d470:	3b 45 ec             	cmp    0xffffffec(%ebp),%eax
    d473:	7c d2                	jl     d447 <tfree+0xe8>
	    while (i > 0 && i < block);
	    i = tp->t.heapinfo[i].free.prev;
    d475:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d478:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d47b:	89 d0                	mov    %edx,%eax
    d47d:	01 c0                	add    %eax,%eax
    d47f:	01 d0                	add    %edx,%eax
    d481:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d488:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d48e:	8b 44 10 08          	mov    0x8(%eax,%edx,1),%eax
    d492:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
	}

	/* Determine how to link this block into the free list. */
	if (block == i + tp->t.heapinfo[i].free.size) {
    d495:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d498:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d49b:	89 d0                	mov    %edx,%eax
    d49d:	01 c0                	add    %eax,%eax
    d49f:	01 d0                	add    %edx,%eax
    d4a1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d4a8:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d4ae:	8b 04 10             	mov    (%eax,%edx,1),%eax
    d4b1:	03 45 e4             	add    0xffffffe4(%ebp),%eax
    d4b4:	39 45 ec             	cmp    %eax,0xffffffec(%ebp)
    d4b7:	75 66                	jne    d51f <tfree+0x1c0>
	    /* Coalesce this block with its predecessor. */
	    tp->t.heapinfo[i].free.size += tp->t.heapinfo[block].busy.info.size;
    d4b9:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d4bc:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d4bf:	89 d0                	mov    %edx,%eax
    d4c1:	01 c0                	add    %eax,%eax
    d4c3:	01 d0                	add    %edx,%eax
    d4c5:	8d 3c 85 00 00 00 00 	lea    0x0(,%eax,4),%edi
    d4cc:	8b 89 2c 02 00 00    	mov    0x22c(%ecx),%ecx
    d4d2:	89 4d d0             	mov    %ecx,0xffffffd0(%ebp)
    d4d5:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d4d8:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d4db:	89 d0                	mov    %edx,%eax
    d4dd:	01 c0                	add    %eax,%eax
    d4df:	01 d0                	add    %edx,%eax
    d4e1:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d4e8:	8b b1 2c 02 00 00    	mov    0x22c(%ecx),%esi
    d4ee:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d4f1:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d4f4:	89 d0                	mov    %edx,%eax
    d4f6:	01 c0                	add    %eax,%eax
    d4f8:	01 d0                	add    %edx,%eax
    d4fa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d501:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d507:	8b 44 10 04          	mov    0x4(%eax,%edx,1),%eax
    d50b:	03 04 1e             	add    (%esi,%ebx,1),%eax
    d50e:	8b 55 d0             	mov    0xffffffd0(%ebp),%edx
    d511:	89 04 3a             	mov    %eax,(%edx,%edi,1)
	    block = i;
    d514:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    d517:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    d51a:	e9 ed 00 00 00       	jmp    d60c <tfree+0x2ad>
	} else {
	    /* Really link this block back into the free list. */
	    tp->t.heapinfo[block].free.size = tp->t.heapinfo[block].busy.info.size;
    d51f:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d522:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d525:	89 d0                	mov    %edx,%eax
    d527:	01 c0                	add    %eax,%eax
    d529:	01 d0                	add    %edx,%eax
    d52b:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d532:	8b b1 2c 02 00 00    	mov    0x22c(%ecx),%esi
    d538:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d53b:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d53e:	89 d0                	mov    %edx,%eax
    d540:	01 c0                	add    %eax,%eax
    d542:	01 d0                	add    %edx,%eax
    d544:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d54b:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d551:	8b 44 10 04          	mov    0x4(%eax,%edx,1),%eax
    d555:	89 04 1e             	mov    %eax,(%esi,%ebx,1)
	    tp->t.heapinfo[block].free.next = tp->t.heapinfo[i].free.next;
    d558:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d55b:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d55e:	89 d0                	mov    %edx,%eax
    d560:	01 c0                	add    %eax,%eax
    d562:	01 d0                	add    %edx,%eax
    d564:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d56b:	8b b1 2c 02 00 00    	mov    0x22c(%ecx),%esi
    d571:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d574:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d577:	89 d0                	mov    %edx,%eax
    d579:	01 c0                	add    %eax,%eax
    d57b:	01 d0                	add    %edx,%eax
    d57d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d584:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d58a:	8b 44 10 04          	mov    0x4(%eax,%edx,1),%eax
    d58e:	89 44 1e 04          	mov    %eax,0x4(%esi,%ebx,1)
	    tp->t.heapinfo[block].free.prev = i;
    d592:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    d595:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d598:	89 d0                	mov    %edx,%eax
    d59a:	01 c0                	add    %eax,%eax
    d59c:	01 d0                	add    %edx,%eax
    d59e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d5a5:	8b 93 2c 02 00 00    	mov    0x22c(%ebx),%edx
    d5ab:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    d5ae:	89 44 0a 08          	mov    %eax,0x8(%edx,%ecx,1)
	    tp->t.heapinfo[i].free.next = block;
    d5b2:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    d5b5:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
    d5b8:	89 d0                	mov    %edx,%eax
    d5ba:	01 c0                	add    %eax,%eax
    d5bc:	01 d0                	add    %edx,%eax
    d5be:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d5c5:	8b 93 2c 02 00 00    	mov    0x22c(%ebx),%edx
    d5cb:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    d5ce:	89 44 0a 04          	mov    %eax,0x4(%edx,%ecx,1)
	    tp->t.heapinfo[tp->t.heapinfo[block].free.next].free.prev = block;
    d5d2:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    d5d5:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d5d8:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d5db:	89 d0                	mov    %edx,%eax
    d5dd:	01 c0                	add    %eax,%eax
    d5df:	01 d0                	add    %edx,%eax
    d5e1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d5e8:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d5ee:	8b 54 10 04          	mov    0x4(%eax,%edx,1),%edx
    d5f2:	89 d0                	mov    %edx,%eax
    d5f4:	01 c0                	add    %eax,%eax
    d5f6:	01 d0                	add    %edx,%eax
    d5f8:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d5ff:	8b 93 2c 02 00 00    	mov    0x22c(%ebx),%edx
    d605:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    d608:	89 44 0a 08          	mov    %eax,0x8(%edx,%ecx,1)
	}

	/* Now that the block is linked in, see if we can coalesce it
	   with its successor (by deleting its successor from the list
	   and adding in its size). */
	if (block + tp->t.heapinfo[block].free.size == tp->t.heapinfo[block].free.next) {
    d60c:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d60f:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d612:	89 d0                	mov    %edx,%eax
    d614:	01 c0                	add    %eax,%eax
    d616:	01 d0                	add    %edx,%eax
    d618:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d61f:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d625:	8b 04 10             	mov    (%eax,%edx,1),%eax
    d628:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
    d62b:	01 c3                	add    %eax,%ebx
    d62d:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d630:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d633:	89 d0                	mov    %edx,%eax
    d635:	01 c0                	add    %eax,%eax
    d637:	01 d0                	add    %edx,%eax
    d639:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d640:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d646:	3b 5c 10 04          	cmp    0x4(%eax,%edx,1),%ebx
    d64a:	0f 85 04 01 00 00    	jne    d754 <tfree+0x3f5>
	    tp->t.heapinfo[block].free.size
    d650:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d653:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d656:	89 d0                	mov    %edx,%eax
    d658:	01 c0                	add    %eax,%eax
    d65a:	01 d0                	add    %edx,%eax
    d65c:	c1 e0 02             	shl    $0x2,%eax
    d65f:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    d662:	8b 89 2c 02 00 00    	mov    0x22c(%ecx),%ecx
    d668:	89 4d c8             	mov    %ecx,0xffffffc8(%ebp)
    d66b:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d66e:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d671:	89 d0                	mov    %edx,%eax
    d673:	01 c0                	add    %eax,%eax
    d675:	01 d0                	add    %edx,%eax
    d677:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d67e:	8b b1 2c 02 00 00    	mov    0x22c(%ecx),%esi
    d684:	8b 7d f0             	mov    0xfffffff0(%ebp),%edi
    d687:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d68a:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d68d:	89 d0                	mov    %edx,%eax
    d68f:	01 c0                	add    %eax,%eax
    d691:	01 d0                	add    %edx,%eax
    d693:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d69a:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d6a0:	8b 54 10 04          	mov    0x4(%eax,%edx,1),%edx
    d6a4:	89 d0                	mov    %edx,%eax
    d6a6:	01 c0                	add    %eax,%eax
    d6a8:	01 d0                	add    %edx,%eax
    d6aa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d6b1:	8b 87 2c 02 00 00    	mov    0x22c(%edi),%eax
    d6b7:	8b 04 10             	mov    (%eax,%edx,1),%eax
    d6ba:	03 04 1e             	add    (%esi,%ebx,1),%eax
    d6bd:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
    d6c0:	8b 55 c8             	mov    0xffffffc8(%ebp),%edx
    d6c3:	89 04 0a             	mov    %eax,(%edx,%ecx,1)
		+= tp->t.heapinfo[tp->t.heapinfo[block].free.next].free.size;
	    tp->t.heapinfo[block].free.next
    d6c6:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d6c9:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d6cc:	89 d0                	mov    %edx,%eax
    d6ce:	01 c0                	add    %eax,%eax
    d6d0:	01 d0                	add    %edx,%eax
    d6d2:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d6d9:	8b b1 2c 02 00 00    	mov    0x22c(%ecx),%esi
    d6df:	8b 7d f0             	mov    0xfffffff0(%ebp),%edi
    d6e2:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d6e5:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d6e8:	89 d0                	mov    %edx,%eax
    d6ea:	01 c0                	add    %eax,%eax
    d6ec:	01 d0                	add    %edx,%eax
    d6ee:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d6f5:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d6fb:	8b 54 10 04          	mov    0x4(%eax,%edx,1),%edx
    d6ff:	89 d0                	mov    %edx,%eax
    d701:	01 c0                	add    %eax,%eax
    d703:	01 d0                	add    %edx,%eax
    d705:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d70c:	8b 87 2c 02 00 00    	mov    0x22c(%edi),%eax
    d712:	8b 44 10 04          	mov    0x4(%eax,%edx,1),%eax
    d716:	89 44 1e 04          	mov    %eax,0x4(%esi,%ebx,1)
		= tp->t.heapinfo[tp->t.heapinfo[block].free.next].free.next;
	    tp->t.heapinfo[tp->t.heapinfo[block].free.next].free.prev = block;
    d71a:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    d71d:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d720:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d723:	89 d0                	mov    %edx,%eax
    d725:	01 c0                	add    %eax,%eax
    d727:	01 d0                	add    %edx,%eax
    d729:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d730:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d736:	8b 54 10 04          	mov    0x4(%eax,%edx,1),%edx
    d73a:	89 d0                	mov    %edx,%eax
    d73c:	01 c0                	add    %eax,%eax
    d73e:	01 d0                	add    %edx,%eax
    d740:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d747:	8b 93 2c 02 00 00    	mov    0x22c(%ebx),%edx
    d74d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    d750:	89 44 0a 08          	mov    %eax,0x8(%edx,%ecx,1)
	}

	/* Now see if we can return stuff to the system. */
	blocks = tp->t.heapinfo[block].free.size;
    d754:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d757:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d75a:	89 d0                	mov    %edx,%eax
    d75c:	01 c0                	add    %eax,%eax
    d75e:	01 d0                	add    %edx,%eax
    d760:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d767:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d76d:	8b 04 10             	mov    (%eax,%edx,1),%eax
    d770:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
	if (blocks >= FINAL_FREE_BLOCKS && block + blocks == tp->t.heaplimit
    d773:	83 7d e8 07          	cmpl   $0x7,0xffffffe8(%ebp)
    d777:	0f 8e 45 01 00 00    	jle    d8c2 <tfree+0x563>
    d77d:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    d780:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d783:	01 c2                	add    %eax,%edx
    d785:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    d788:	3b 90 34 02 00 00    	cmp    0x234(%eax),%edx
    d78e:	0f 85 2e 01 00 00    	jne    d8c2 <tfree+0x563>
    d794:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    d79b:	00 
    d79c:	8b 45 08             	mov    0x8(%ebp),%eax
    d79f:	89 04 24             	mov    %eax,(%esp,1)
    d7a2:	a1 00 00 00 00       	mov    0x0,%eax
    d7a7:	ff d0                	call   *%eax
    d7a9:	89 c1                	mov    %eax,%ecx
    d7ab:	8b 55 08             	mov    0x8(%ebp),%edx
    d7ae:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    d7b1:	03 45 ec             	add    0xffffffec(%ebp),%eax
    d7b4:	c1 e0 0c             	shl    $0xc,%eax
    d7b7:	03 82 e4 02 00 00    	add    0x2e4(%edx),%eax
    d7bd:	2d 00 10 00 00       	sub    $0x1000,%eax
    d7c2:	39 c1                	cmp    %eax,%ecx
    d7c4:	0f 85 f8 00 00 00    	jne    d8c2 <tfree+0x563>
	    && (*_morecore)(sk,0) == ADDRESS(sk,block + blocks)) {
	    tp->t.heaplimit -= blocks;
    d7ca:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d7cd:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    d7d0:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    d7d3:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
    d7d9:	29 d0                	sub    %edx,%eax
    d7db:	89 81 34 02 00 00    	mov    %eax,0x234(%ecx)
	    (*_morecore)(sk,-blocks * BLOCKSIZE);
    d7e1:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    d7e4:	f7 d8                	neg    %eax
    d7e6:	c1 e0 0c             	shl    $0xc,%eax
    d7e9:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    d7ed:	8b 45 08             	mov    0x8(%ebp),%eax
    d7f0:	89 04 24             	mov    %eax,(%esp,1)
    d7f3:	a1 00 00 00 00       	mov    0x0,%eax
    d7f8:	ff d0                	call   *%eax
	    tp->t.heapinfo[tp->t.heapinfo[block].free.prev].free.next
    d7fa:	8b 75 f0             	mov    0xfffffff0(%ebp),%esi
    d7fd:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d800:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d803:	89 d0                	mov    %edx,%eax
    d805:	01 c0                	add    %eax,%eax
    d807:	01 d0                	add    %edx,%eax
    d809:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d810:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d816:	8b 54 10 08          	mov    0x8(%eax,%edx,1),%edx
    d81a:	89 d0                	mov    %edx,%eax
    d81c:	01 c0                	add    %eax,%eax
    d81e:	01 d0                	add    %edx,%eax
    d820:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d827:	8b b6 2c 02 00 00    	mov    0x22c(%esi),%esi
    d82d:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d830:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d833:	89 d0                	mov    %edx,%eax
    d835:	01 c0                	add    %eax,%eax
    d837:	01 d0                	add    %edx,%eax
    d839:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d840:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d846:	8b 44 10 04          	mov    0x4(%eax,%edx,1),%eax
    d84a:	89 44 1e 04          	mov    %eax,0x4(%esi,%ebx,1)
		= tp->t.heapinfo[block].free.next;
	    tp->t.heapinfo[tp->t.heapinfo[block].free.next].free.prev
    d84e:	8b 75 f0             	mov    0xfffffff0(%ebp),%esi
    d851:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d854:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d857:	89 d0                	mov    %edx,%eax
    d859:	01 c0                	add    %eax,%eax
    d85b:	01 d0                	add    %edx,%eax
    d85d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d864:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d86a:	8b 54 10 04          	mov    0x4(%eax,%edx,1),%edx
    d86e:	89 d0                	mov    %edx,%eax
    d870:	01 c0                	add    %eax,%eax
    d872:	01 d0                	add    %edx,%eax
    d874:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d87b:	8b b6 2c 02 00 00    	mov    0x22c(%esi),%esi
    d881:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d884:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d887:	89 d0                	mov    %edx,%eax
    d889:	01 c0                	add    %eax,%eax
    d88b:	01 d0                	add    %edx,%eax
    d88d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d894:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d89a:	8b 44 10 08          	mov    0x8(%eax,%edx,1),%eax
    d89e:	89 44 1e 08          	mov    %eax,0x8(%esi,%ebx,1)
		= tp->t.heapinfo[block].free.prev;
	    block = tp->t.heapinfo[block].free.prev;
    d8a2:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d8a5:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d8a8:	89 d0                	mov    %edx,%eax
    d8aa:	01 c0                	add    %eax,%eax
    d8ac:	01 d0                	add    %edx,%eax
    d8ae:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d8b5:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d8bb:	8b 44 10 08          	mov    0x8(%eax,%edx,1),%eax
    d8bf:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	}

	/* Set the next search to begin at this block. */
	tp->t.heapindex = block;
    d8c2:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    d8c5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    d8c8:	89 82 30 02 00 00    	mov    %eax,0x230(%edx)
	break;
    d8ce:	e9 4f 02 00 00       	jmp    db22 <tfree+0x7c3>

    default:
	/* Get the address of the first free fragment in this block. */
	prev = (struct heap_list *) ((char *) ADDRESS(sk,block)
    d8d3:	8b 55 08             	mov    0x8(%ebp),%edx
    d8d6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    d8d9:	c1 e0 0c             	shl    $0xc,%eax
    d8dc:	89 c3                	mov    %eax,%ebx
    d8de:	03 9a e4 02 00 00    	add    0x2e4(%edx),%ebx
    d8e4:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d8e7:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d8ea:	89 d0                	mov    %edx,%eax
    d8ec:	01 c0                	add    %eax,%eax
    d8ee:	01 d0                	add    %edx,%eax
    d8f0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d8f7:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d8fd:	0f b6 4d e0          	movzbl 0xffffffe0(%ebp),%ecx
    d901:	8b 44 10 08          	mov    0x8(%eax,%edx,1),%eax
    d905:	d3 e0                	shl    %cl,%eax
    d907:	8d 04 18             	lea    (%eax,%ebx,1),%eax
    d90a:	2d 00 10 00 00       	sub    $0x1000,%eax
    d90f:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
				+ (tp->t.heapinfo[block].busy.info.frag.first
				   << type));

	if (tp->t.heapinfo[block].busy.info.frag.nfree == (BLOCKSIZE >> type) - 1
    d912:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d915:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d918:	89 d0                	mov    %edx,%eax
    d91a:	01 c0                	add    %eax,%eax
    d91c:	01 d0                	add    %edx,%eax
    d91e:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d925:	8b 91 2c 02 00 00    	mov    0x22c(%ecx),%edx
    d92b:	b8 00 10 00 00       	mov    $0x1000,%eax
    d930:	0f b6 4d e0          	movzbl 0xffffffe0(%ebp),%ecx
    d934:	d3 f8                	sar    %cl,%eax
    d936:	48                   	dec    %eax
    d937:	39 44 1a 04          	cmp    %eax,0x4(%edx,%ebx,1)
    d93b:	0f 85 d5 00 00 00    	jne    da16 <tfree+0x6b7>
    d941:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    d944:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    d947:	83 bc 82 38 02 00 00 	cmpl   $0x1,0x238(%edx,%eax,4)
    d94e:	01 
    d94f:	0f 8e c1 00 00 00    	jle    da16 <tfree+0x6b7>
	&& tp->t.fragblocks[type] > 1) {
	    /* If all fragments of this block are free, remove them
	       from the fragment list and free the whole block. */
	    --tp->t.fragblocks[type];
    d955:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    d958:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    d95b:	ff 8c 90 38 02 00 00 	decl   0x238(%eax,%edx,4)
	    for (next = prev, i = 1; i < BLOCKSIZE >> type; ++i)
    d962:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    d965:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    d968:	c7 45 e4 01 00 00 00 	movl   $0x1,0xffffffe4(%ebp)
    d96f:	b8 00 10 00 00       	mov    $0x1000,%eax
    d974:	0f b6 4d e0          	movzbl 0xffffffe0(%ebp),%ecx
    d978:	d3 f8                	sar    %cl,%eax
    d97a:	39 45 e4             	cmp    %eax,0xffffffe4(%ebp)
    d97d:	7c 02                	jl     d981 <tfree+0x622>
    d97f:	eb 0f                	jmp    d990 <tfree+0x631>
		next = next->next;
    d981:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    d984:	8b 00                	mov    (%eax),%eax
    d986:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    d989:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
    d98c:	ff 00                	incl   (%eax)
    d98e:	eb df                	jmp    d96f <tfree+0x610>
	    prev->prev->next = next;
    d990:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    d993:	8b 50 04             	mov    0x4(%eax),%edx
    d996:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    d999:	89 02                	mov    %eax,(%edx)
	    if (next)
    d99b:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
    d99f:	74 0c                	je     d9ad <tfree+0x64e>
		next->prev = prev->prev;
    d9a1:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    d9a4:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    d9a7:	8b 52 04             	mov    0x4(%edx),%edx
    d9aa:	89 50 04             	mov    %edx,0x4(%eax)
	    tp->t.heapinfo[block].busy.type = 0;
    d9ad:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d9b0:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d9b3:	89 d0                	mov    %edx,%eax
    d9b5:	01 c0                	add    %eax,%eax
    d9b7:	01 d0                	add    %edx,%eax
    d9b9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d9c0:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d9c6:	c7 04 10 00 00 00 00 	movl   $0x0,(%eax,%edx,1)
	    tp->t.heapinfo[block].busy.info.size = 1;
    d9cd:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    d9d0:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    d9d3:	89 d0                	mov    %edx,%eax
    d9d5:	01 c0                	add    %eax,%eax
    d9d7:	01 d0                	add    %edx,%eax
    d9d9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d9e0:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    d9e6:	c7 44 10 04 01 00 00 	movl   $0x1,0x4(%eax,%edx,1)
    d9ed:	00 
	    tfree(sk,ADDRESS(sk,block));
    d9ee:	8b 55 08             	mov    0x8(%ebp),%edx
    d9f1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    d9f4:	c1 e0 0c             	shl    $0xc,%eax
    d9f7:	03 82 e4 02 00 00    	add    0x2e4(%edx),%eax
    d9fd:	2d 00 10 00 00       	sub    $0x1000,%eax
    da02:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    da06:	8b 45 08             	mov    0x8(%ebp),%eax
    da09:	89 04 24             	mov    %eax,(%esp,1)
    da0c:	e8 fc ff ff ff       	call   da0d <tfree+0x6ae>
    da11:	e9 0c 01 00 00       	jmp    db22 <tfree+0x7c3>
	} else if (tp->t.heapinfo[block].busy.info.frag.nfree) {
    da16:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    da19:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    da1c:	89 d0                	mov    %edx,%eax
    da1e:	01 c0                	add    %eax,%eax
    da20:	01 d0                	add    %edx,%eax
    da22:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    da29:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    da2f:	83 7c 10 04 00       	cmpl   $0x0,0x4(%eax,%edx,1)
    da34:	74 56                	je     da8c <tfree+0x72d>
	    /* If some fragments of this block are free, link this fragment
	       into the fragment list after the first free fragment of
	       this block. */
	    next = ptr;
    da36:	8b 45 0c             	mov    0xc(%ebp),%eax
    da39:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
	    next->next = prev->next;
    da3c:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    da3f:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    da42:	8b 00                	mov    (%eax),%eax
    da44:	89 02                	mov    %eax,(%edx)
	    next->prev = prev;
    da46:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    da49:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    da4c:	89 42 04             	mov    %eax,0x4(%edx)
	    prev->next = next;
    da4f:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    da52:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    da55:	89 02                	mov    %eax,(%edx)
	    if (next->next)
    da57:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    da5a:	83 38 00             	cmpl   $0x0,(%eax)
    da5d:	74 0b                	je     da6a <tfree+0x70b>
		next->next->prev = next;
    da5f:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    da62:	8b 10                	mov    (%eax),%edx
    da64:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    da67:	89 42 04             	mov    %eax,0x4(%edx)
	    ++tp->t.heapinfo[block].busy.info.frag.nfree;
    da6a:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    da6d:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    da70:	89 d0                	mov    %edx,%eax
    da72:	01 c0                	add    %eax,%eax
    da74:	01 d0                	add    %edx,%eax
    da76:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    da7d:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    da83:	ff 44 10 04          	incl   0x4(%eax,%edx,1)
    da87:	e9 96 00 00 00       	jmp    db22 <tfree+0x7c3>
	} else {
	    /* No fragments of this block are free, so link this fragment
	       into the fragment list and announce that it is the first
	       free fragment of this block. */
	    prev = (struct heap_list *) ptr;
    da8c:	8b 45 0c             	mov    0xc(%ebp),%eax
    da8f:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
	    tp->t.heapinfo[block].busy.info.frag.nfree = 1;
    da92:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    da95:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    da98:	89 d0                	mov    %edx,%eax
    da9a:	01 c0                	add    %eax,%eax
    da9c:	01 d0                	add    %edx,%eax
    da9e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    daa5:	8b 81 2c 02 00 00    	mov    0x22c(%ecx),%eax
    daab:	c7 44 10 04 01 00 00 	movl   $0x1,0x4(%eax,%edx,1)
    dab2:	00 
	    tp->t.heapinfo[block].busy.info.frag.first
    dab3:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    dab6:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    dab9:	89 d0                	mov    %edx,%eax
    dabb:	01 c0                	add    %eax,%eax
    dabd:	01 d0                	add    %edx,%eax
    dabf:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    dac6:	8b 91 2c 02 00 00    	mov    0x22c(%ecx),%edx
    dacc:	8b 45 0c             	mov    0xc(%ebp),%eax
    dacf:	25 ff 0f 00 00       	and    $0xfff,%eax
    dad4:	0f b6 4d e0          	movzbl 0xffffffe0(%ebp),%ecx
    dad8:	d3 e8                	shr    %cl,%eax
    dada:	89 44 1a 08          	mov    %eax,0x8(%edx,%ebx,1)
		= (unsigned int) ((char *) ptr - (char *) NULL) % BLOCKSIZE
		  >> type;
	    prev->next = tp->t.fraghead[type].next;
    dade:	8b 4d dc             	mov    0xffffffdc(%ebp),%ecx
    dae1:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    dae4:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    dae7:	8b 84 c2 68 02 00 00 	mov    0x268(%edx,%eax,8),%eax
    daee:	89 01                	mov    %eax,(%ecx)
	    prev->prev = &tp->t.fraghead[type];
    daf0:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    daf3:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    daf6:	c1 e0 03             	shl    $0x3,%eax
    daf9:	03 45 f0             	add    0xfffffff0(%ebp),%eax
    dafc:	05 68 02 00 00       	add    $0x268,%eax
    db01:	89 42 04             	mov    %eax,0x4(%edx)
	    prev->prev->next = prev;
    db04:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    db07:	8b 50 04             	mov    0x4(%eax),%edx
    db0a:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    db0d:	89 02                	mov    %eax,(%edx)
	    if (prev->next)
    db0f:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    db12:	83 38 00             	cmpl   $0x0,(%eax)
    db15:	74 0b                	je     db22 <tfree+0x7c3>
		prev->next->prev = prev;
    db17:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    db1a:	8b 10                	mov    (%eax),%edx
    db1c:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    db1f:	89 42 04             	mov    %eax,0x4(%edx)
	}
	break;
    }
}
    db22:	83 c4 34             	add    $0x34,%esp
    db25:	5b                   	pop    %ebx
    db26:	5e                   	pop    %esi
    db27:	5f                   	pop    %edi
    db28:	5d                   	pop    %ebp
    db29:	c3                   	ret    

0000db2a <__memcpy>:
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
    db2a:	55                   	push   %ebp
    db2b:	89 e5                	mov    %esp,%ebp
    db2d:	57                   	push   %edi
    db2e:	56                   	push   %esi
    db2f:	83 ec 0c             	sub    $0xc,%esp
int d0, d1, d2;
__asm__ __volatile__(
    db32:	8b 45 10             	mov    0x10(%ebp),%eax
    db35:	89 c1                	mov    %eax,%ecx
    db37:	c1 e9 02             	shr    $0x2,%ecx
    db3a:	8b 45 10             	mov    0x10(%ebp),%eax
    db3d:	8b 7d 08             	mov    0x8(%ebp),%edi
    db40:	8b 75 0c             	mov    0xc(%ebp),%esi
    db43:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
    db45:	a8 02                	test   $0x2,%al
    db47:	74 02                	je     db4b <__memcpy+0x21>
    db49:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    db4b:	a8 01                	test   $0x1,%al
    db4d:	74 01                	je     db50 <__memcpy+0x26>
    db4f:	a4                   	movsb  %ds:(%esi),%es:(%edi)
    db50:	89 c8                	mov    %ecx,%eax
    db52:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    db55:	89 f8                	mov    %edi,%eax
    db57:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    db5a:	89 f0                	mov    %esi,%eax
    db5c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	"rep ; movsl\n\t"
	"testb $2,%b4\n\t"
	"je 1f\n\t"
	"movsw\n"
	"1:\ttestb $1,%b4\n\t"
	"je 2f\n\t"
	"movsb\n"
	"2:"
	: "=&c" (d0), "=&D" (d1), "=&S" (d2)
	:"0" (n/4), "q" (n),"1" ((long) to),"2" ((long) from)
	: "memory");
return (to);
    db5f:	8b 45 08             	mov    0x8(%ebp),%eax
}
    db62:	83 c4 0c             	add    $0xc,%esp
    db65:	5e                   	pop    %esi
    db66:	5f                   	pop    %edi
    db67:	5d                   	pop    %ebp
    db68:	c3                   	ret    

0000db69 <__constant_c_memset>:

/*
 * This looks horribly ugly, but the compiler can optimize it totally,
 * as the count is constant.
 */
static inline void * __constant_memcpy(void * to, const void * from, size_t n)
{
	switch (n) {
		case 0:
			return to;
		case 1:
			*(unsigned char *)to = *(const unsigned char *)from;
			return to;
		case 2:
			*(unsigned short *)to = *(const unsigned short *)from;
			return to;
		case 3:
			*(unsigned short *)to = *(const unsigned short *)from;
			*(2+(unsigned char *)to) = *(2+(const unsigned char *)from);
			return to;
		case 4:
			*(unsigned long *)to = *(const unsigned long *)from;
			return to;
		case 6:	/* for Ethernet addresses */
			*(unsigned long *)to = *(const unsigned long *)from;
			*(2+(unsigned short *)to) = *(2+(const unsigned short *)from);
			return to;
		case 8:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			return to;
		case 12:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
			return to;
		case 16:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
			*(3+(unsigned long *)to) = *(3+(const unsigned long *)from);
			return to;
		case 20:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
			*(3+(unsigned long *)to) = *(3+(const unsigned long *)from);
			*(4+(unsigned long *)to) = *(4+(const unsigned long *)from);
			return to;
	}
#define COMMON(x) \
__asm__ __volatile__( \
	"rep ; movsl" \
	x \
	: "=&c" (d0), "=&D" (d1), "=&S" (d2) \
	: "0" (n/4),"1" ((long) to),"2" ((long) from) \
	: "memory");
{
	int d0, d1, d2;
	switch (n % 4) {
		case 0: COMMON(""); return to;
		case 1: COMMON("\n\tmovsb"); return to;
		case 2: COMMON("\n\tmovsw"); return to;
		default: COMMON("\n\tmovsw\n\tmovsb"); return to;
	}
}
  
#undef COMMON
}

#define __HAVE_ARCH_MEMCPY

#ifdef CONFIG_X86_USE_3DNOW

#include <asm/mmx.h>

/*
 *	This CPU favours 3DNow strongly (eg AMD Athlon)
 */

static inline void * __constant_memcpy3d(void * to, const void * from, size_t len)
{
	if (len < 512)
		return __constant_memcpy(to, from, len);
	return _mmx_memcpy(to, from, len);
}

static __inline__ void *__memcpy3d(void *to, const void *from, size_t len)
{
	if (len < 512)
		return __memcpy(to, from, len);
	return _mmx_memcpy(to, from, len);
}

#define memcpy(t, f, n) \
(__builtin_constant_p(n) ? \
 __constant_memcpy3d((t),(f),(n)) : \
 __memcpy3d((t),(f),(n)))

#else

/*
 *	No 3D Now!
 */
 
#define memcpy(t, f, n) \
(__builtin_constant_p(n) ? \
 __constant_memcpy((t),(f),(n)) : \
 __memcpy((t),(f),(n)))

#endif

/*
 * struct_cpy(x,y), copy structure *x into (matching structure) *y.
 *
 * We get link-time errors if the structure sizes do not match.
 * There is no runtime overhead, it's all optimized away at
 * compile time.
 */
extern void __struct_cpy_bug (void);

#define struct_cpy(x,y) 			\
({						\
	if (sizeof(*(x)) != sizeof(*(y))) 	\
		__struct_cpy_bug;		\
	memcpy(x, y, sizeof(*(x)));		\
})

#define __HAVE_ARCH_MEMMOVE
static inline void * memmove(void * dest,const void * src, size_t n)
{
int d0, d1, d2;
if (dest<src)
__asm__ __volatile__(
	"rep\n\t"
	"movsb"
	: "=&c" (d0), "=&S" (d1), "=&D" (d2)
	:"0" (n),"1" (src),"2" (dest)
	: "memory");
else
__asm__ __volatile__(
	"std\n\t"
	"rep\n\t"
	"movsb\n\t"
	"cld"
	: "=&c" (d0), "=&S" (d1), "=&D" (d2)
	:"0" (n),
	 "1" (n-1+(const char *)src),
	 "2" (n-1+(char *)dest)
	:"memory");
return dest;
}

#define memcmp __builtin_memcmp

#define __HAVE_ARCH_MEMCHR
static inline void * memchr(const void * cs,int c,size_t count)
{
int d0;
register void * __res;
if (!count)
	return NULL;
__asm__ __volatile__(
	"repne\n\t"
	"scasb\n\t"
	"je 1f\n\t"
	"movl $1,%0\n"
	"1:\tdecl %0"
	:"=D" (__res), "=&c" (d0) : "a" (c),"0" (cs),"1" (count));
return __res;
}

static inline void * __memset_generic(void * s, char c,size_t count)
{
int d0, d1;
__asm__ __volatile__(
	"rep\n\t"
	"stosb"
	: "=&c" (d0), "=&D" (d1)
	:"a" (c),"1" (s),"0" (count)
	:"memory");
return s;
}

/* we might want to write optimized versions of these later */
#define __constant_count_memset(s,c,count) __memset_generic((s),(c),(count))

/*
 * memset(x,0,y) is a reasonably common thing to do, so we want to fill
 * things 32 bits at a time even when we don't know the size of the
 * area at compile-time..
 */
static inline void * __constant_c_memset(void * s, unsigned long c, size_t count)
{
    db69:	55                   	push   %ebp
    db6a:	89 e5                	mov    %esp,%ebp
    db6c:	57                   	push   %edi
    db6d:	53                   	push   %ebx
    db6e:	83 ec 08             	sub    $0x8,%esp
int d0, d1;
__asm__ __volatile__(
    db71:	8b 55 0c             	mov    0xc(%ebp),%edx
    db74:	8b 4d 10             	mov    0x10(%ebp),%ecx
    db77:	c1 e9 02             	shr    $0x2,%ecx
    db7a:	8b 7d 08             	mov    0x8(%ebp),%edi
    db7d:	89 d0                	mov    %edx,%eax
    db7f:	8b 5d 10             	mov    0x10(%ebp),%ebx
    db82:	f3 ab                	repz stos %eax,%es:(%edi)
    db84:	f6 c3 02             	test   $0x2,%bl
    db87:	74 02                	je     db8b <__constant_c_memset+0x22>
    db89:	66 ab                	stos   %ax,%es:(%edi)
    db8b:	f6 c3 01             	test   $0x1,%bl
    db8e:	74 01                	je     db91 <__constant_c_memset+0x28>
    db90:	aa                   	stos   %al,%es:(%edi)
    db91:	89 c8                	mov    %ecx,%eax
    db93:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    db96:	89 f8                	mov    %edi,%eax
    db98:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	"rep ; stosl\n\t"
	"testb $2,%b3\n\t"
	"je 1f\n\t"
	"stosw\n"
	"1:\ttestb $1,%b3\n\t"
	"je 2f\n\t"
	"stosb\n"
	"2:"
	: "=&c" (d0), "=&D" (d1)
	:"a" (c), "q" (count), "0" (count/4), "1" ((long) s)
	:"memory");
return (s);	
    db9b:	8b 45 08             	mov    0x8(%ebp),%eax
}
    db9e:	83 c4 08             	add    $0x8,%esp
    dba1:	5b                   	pop    %ebx
    dba2:	5f                   	pop    %edi
    dba3:	5d                   	pop    %ebp
    dba4:	c3                   	ret    

0000dba5 <unlink>:
	head->len++;
#endif
}

static inline void unlink(struct alloc_head *elem) {
    dba5:	55                   	push   %ebp
    dba6:	89 e5                	mov    %esp,%ebp
#ifdef DEBUG_LIST
	if(elem->list == (struct alloc_head_list*) elem) {
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
    dba8:	8b 45 08             	mov    0x8(%ebp),%eax
    dbab:	8b 50 04             	mov    0x4(%eax),%edx
    dbae:	8b 45 08             	mov    0x8(%ebp),%eax
    dbb1:	8b 00                	mov    (%eax),%eax
    dbb3:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
    dbb5:	8b 45 08             	mov    0x8(%ebp),%eax
    dbb8:	8b 10                	mov    (%eax),%edx
    dbba:	8b 45 08             	mov    0x8(%ebp),%eax
    dbbd:	8b 40 04             	mov    0x4(%eax),%eax
    dbc0:	89 42 04             	mov    %eax,0x4(%edx)
	elem->prev = elem->next = NULL;
    dbc3:	8b 55 08             	mov    0x8(%ebp),%edx
    dbc6:	8b 45 08             	mov    0x8(%ebp),%eax
    dbc9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    dbd0:	c7 02 00 00 00 00    	movl   $0x0,(%edx)

	elem->list->len--;
    dbd6:	8b 45 08             	mov    0x8(%ebp),%eax
    dbd9:	8b 40 08             	mov    0x8(%eax),%eax
    dbdc:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
    dbdf:	8b 45 08             	mov    0x8(%ebp),%eax
    dbe2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
    dbe9:	5d                   	pop    %ebp
    dbea:	c3                   	ret    

0000dbeb <msk_release>:
		msk->ctl = ALLOC_PROCESSING;
	}
}

static inline void msk_release(struct sock *sk, struct cminisock *msk) {
    dbeb:	55                   	push   %ebp
    dbec:	89 e5                	mov    %esp,%ebp
    dbee:	83 ec 10             	sub    $0x10,%esp
	// Perform actual deallocation. This function is common to
	// state cache and event queue
	msk->refCnt--;
    dbf1:	8b 45 0c             	mov    0xc(%ebp),%eax
    dbf4:	ff 88 f0 00 00 00    	decl   0xf0(%eax)
	BUG_TRAP(msk->refCnt >= 0);
    dbfa:	8b 45 0c             	mov    0xc(%ebp),%eax
    dbfd:	83 b8 f0 00 00 00 00 	cmpl   $0x0,0xf0(%eax)
    dc04:	79 14                	jns    dc1a <msk_release+0x2f>
    dc06:	c7 44 24 04 13 01 00 	movl   $0x113,0x4(%esp,1)
    dc0d:	00 
    dc0e:	c7 04 24 60 44 00 00 	movl   $0x4460,(%esp,1)
    dc15:	e8 fc ff ff ff       	call   dc16 <msk_release+0x2b>
	if(msk->refCnt == 0) {
    dc1a:	8b 45 0c             	mov    0xc(%ebp),%eax
    dc1d:	83 b8 f0 00 00 00 00 	cmpl   $0x0,0xf0(%eax)
    dc24:	0f 85 a0 00 00 00    	jne    dcca <msk_release+0xdf>
		// printk("release: refcnt %p\n", msk);
		struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
    dc2a:	8b 45 08             	mov    0x8(%ebp),%eax
    dc2d:	05 bc 00 00 00       	add    $0xbc,%eax
    dc32:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
		struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
    dc35:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    dc38:	05 d4 01 00 00       	add    $0x1d4,%eax
    dc3d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

		free_minisock(sk,msk);
    dc40:	8b 45 0c             	mov    0xc(%ebp),%eax
    dc43:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    dc47:	8b 45 08             	mov    0x8(%ebp),%eax
    dc4a:	89 04 24             	mov    %eax,(%esp,1)
    dc4d:	e8 f5 00 00 00       	call   dd47 <free_minisock>
		if(!SIMULATION_MODE(sk)) {
    dc52:	8b 45 08             	mov    0x8(%ebp),%eax
    dc55:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    dc5b:	83 e0 01             	and    $0x1,%eax
    dc5e:	85 c0                	test   %eax,%eax
    dc60:	74 1b                	je     dc7d <msk_release+0x92>
    dc62:	8b 55 08             	mov    0x8(%ebp),%edx
    dc65:	8b 45 08             	mov    0x8(%ebp),%eax
    dc68:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    dc6e:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
    dc74:	83 e0 08             	and    $0x8,%eax
    dc77:	85 c0                	test   %eax,%eax
    dc79:	75 02                	jne    dc7d <msk_release+0x92>
    dc7b:	eb 1e                	jmp    dc9b <msk_release+0xb0>
			insert_head(head, (struct alloc_head *)msk);
    dc7d:	8b 45 0c             	mov    0xc(%ebp),%eax
    dc80:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    dc84:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    dc87:	89 04 24             	mov    %eax,(%esp,1)
    dc8a:	e8 3d 00 00 00       	call   dccc <insert_head>
			msk->ctl = ALLOC_FREE;
    dc8f:	8b 45 0c             	mov    0xc(%ebp),%eax
    dc92:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    dc99:	eb 2f                	jmp    dcca <msk_release+0xdf>
		} else {
			if(msk == tp->t.responseMSK) {
    dc9b:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    dc9e:	8b 45 0c             	mov    0xc(%ebp),%eax
    dca1:	3b 82 64 0a 00 00    	cmp    0xa64(%edx),%eax
    dca7:	75 02                	jne    dcab <msk_release+0xc0>
    dca9:	eb 16                	jmp    dcc1 <msk_release+0xd6>
			} else {
				// overflow
				unlink((struct alloc_head*)msk);
    dcab:	8b 45 0c             	mov    0xc(%ebp),%eax
    dcae:	89 04 24             	mov    %eax,(%esp,1)
    dcb1:	e8 ef fe ff ff       	call   dba5 <unlink>
				kfree(msk);
    dcb6:	8b 45 0c             	mov    0xc(%ebp),%eax
    dcb9:	89 04 24             	mov    %eax,(%esp,1)
    dcbc:	e8 fc ff ff ff       	call   dcbd <msk_release+0xd2>
			}
			tp->t.responseCount--;
    dcc1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    dcc4:	ff 88 7c 0a 00 00    	decl   0xa7c(%eax)
		}
	} else {
		//printk("release: refcnt == %d\n", msk->refCnt);
	}
}
    dcca:	c9                   	leave  
    dccb:	c3                   	ret    

0000dccc <insert_head>:
#endif

//#define DEBUG_LIST

static inline void insert_head(struct alloc_head_list *head, struct alloc_head *elem) {
    dccc:	55                   	push   %ebp
    dccd:	89 e5                	mov    %esp,%ebp
    dccf:	83 ec 08             	sub    $0x8,%esp
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
#endif
	if(head->next == elem /* || elem->prev != NULL || elem->next != NULL */) {
    dcd2:	8b 45 08             	mov    0x8(%ebp),%eax
    dcd5:	8b 40 04             	mov    0x4(%eax),%eax
    dcd8:	3b 45 0c             	cmp    0xc(%ebp),%eax
    dcdb:	75 31                	jne    dd0e <insert_head+0x42>
		BUG();
    dcdd:	c7 44 24 04 d9 43 00 	movl   $0x43d9,0x4(%esp,1)
    dce4:	00 
    dce5:	c7 04 24 dd 43 00 00 	movl   $0x43dd,(%esp,1)
    dcec:	e8 fc ff ff ff       	call   dced <insert_head+0x21>
    dcf1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    dcf8:	e8 fc ff ff ff       	call   dcf9 <insert_head+0x2d>
    dcfd:	e8 fc ff ff ff       	call   dcfe <insert_head+0x32>
		show_stack(NULL);	
    dd02:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    dd09:	e8 fc ff ff ff       	call   dd0a <insert_head+0x3e>
	}
	elem->next = head->next;
    dd0e:	8b 55 0c             	mov    0xc(%ebp),%edx
    dd11:	8b 45 08             	mov    0x8(%ebp),%eax
    dd14:	8b 40 04             	mov    0x4(%eax),%eax
    dd17:	89 42 04             	mov    %eax,0x4(%edx)
	head->next->prev = elem;
    dd1a:	8b 45 08             	mov    0x8(%ebp),%eax
    dd1d:	8b 50 04             	mov    0x4(%eax),%edx
    dd20:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd23:	89 02                	mov    %eax,(%edx)

	elem->prev = (struct alloc_head*)head;
    dd25:	8b 55 0c             	mov    0xc(%ebp),%edx
    dd28:	8b 45 08             	mov    0x8(%ebp),%eax
    dd2b:	89 02                	mov    %eax,(%edx)
	head->next = elem;
    dd2d:	8b 55 08             	mov    0x8(%ebp),%edx
    dd30:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd33:	89 42 04             	mov    %eax,0x4(%edx)

	elem->list = head;
    dd36:	8b 55 0c             	mov    0xc(%ebp),%edx
    dd39:	8b 45 08             	mov    0x8(%ebp),%eax
    dd3c:	89 42 08             	mov    %eax,0x8(%edx)
	head->len++;
    dd3f:	8b 45 08             	mov    0x8(%ebp),%eax
    dd42:	ff 40 10             	incl   0x10(%eax)
}
    dd45:	c9                   	leave  
    dd46:	c3                   	ret    

0000dd47 <free_minisock>:
	msk->serverSK = NULL;
}

#ifdef CAN_USE_TFREE
static inline void free_minisock(struct sock *sk, struct cminisock *msk) {
    dd47:	55                   	push   %ebp
    dd48:	89 e5                	mov    %esp,%ebp
    dd4a:	83 ec 0c             	sub    $0xc,%esp
	int i;
	/*
	printk("msk summary (%p [%d]) (%p [%d]) (%p [%d])\n", 
	       msk->packets, msk->num_packets,
	       msk->ucont_data, msk->ucont_len,
	       msk->input, msk->input_len);
	*/
	for(i=0; i < msk->num_packets; i++) {
    dd4d:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
    dd54:	8b 55 0c             	mov    0xc(%ebp),%edx
    dd57:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    dd5a:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
    dd60:	7c 02                	jl     dd64 <free_minisock+0x1d>
    dd62:	eb 4e                	jmp    ddb2 <free_minisock+0x6b>
		if(msk->packets[i].ucontData != NULL) {
    dd64:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    dd67:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    dd6a:	89 d0                	mov    %edx,%eax
    dd6c:	c1 e0 03             	shl    $0x3,%eax
    dd6f:	01 d0                	add    %edx,%eax
    dd71:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dd78:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
    dd7e:	83 7c 10 14 00       	cmpl   $0x0,0x14(%eax,%edx,1)
    dd83:	74 26                	je     ddab <free_minisock+0x64>
			kfree(msk->packets[i].ucontData);
    dd85:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    dd88:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    dd8b:	89 d0                	mov    %edx,%eax
    dd8d:	c1 e0 03             	shl    $0x3,%eax
    dd90:	01 d0                	add    %edx,%eax
    dd92:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dd99:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
    dd9f:	8b 44 10 14          	mov    0x14(%eax,%edx,1),%eax
    dda3:	89 04 24             	mov    %eax,(%esp,1)
    dda6:	e8 fc ff ff ff       	call   dda7 <free_minisock+0x60>
    ddab:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
    ddae:	ff 00                	incl   (%eax)
    ddb0:	eb a2                	jmp    dd54 <free_minisock+0xd>
		}
	}
	// printk("done with packet data\n");
	if(!SIMULATION_MODE(sk) && msk->packets) {
    ddb2:	8b 45 08             	mov    0x8(%ebp),%eax
    ddb5:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    ddbb:	83 e0 01             	and    $0x1,%eax
    ddbe:	85 c0                	test   %eax,%eax
    ddc0:	74 1b                	je     dddd <free_minisock+0x96>
    ddc2:	8b 55 08             	mov    0x8(%ebp),%edx
    ddc5:	8b 45 08             	mov    0x8(%ebp),%eax
    ddc8:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    ddce:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
    ddd4:	83 e0 08             	and    $0x8,%eax
    ddd7:	85 c0                	test   %eax,%eax
    ddd9:	75 02                	jne    dddd <free_minisock+0x96>
    dddb:	eb 31                	jmp    de0e <free_minisock+0xc7>
    dddd:	8b 45 0c             	mov    0xc(%ebp),%eax
    dde0:	83 b8 ec 00 00 00 00 	cmpl   $0x0,0xec(%eax)
    dde7:	74 25                	je     de0e <free_minisock+0xc7>
		tfree(sk,msk->packets);
    dde9:	8b 45 0c             	mov    0xc(%ebp),%eax
    ddec:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
    ddf2:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ddf6:	8b 45 08             	mov    0x8(%ebp),%eax
    ddf9:	89 04 24             	mov    %eax,(%esp,1)
    ddfc:	e8 fc ff ff ff       	call   ddfd <free_minisock+0xb6>
		msk->packets = NULL;
    de01:	8b 45 0c             	mov    0xc(%ebp),%eax
    de04:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%eax)
    de0b:	00 00 00 
	}
	// printk("done with packet array\n");
	msk->num_packets = 0;
    de0e:	8b 45 0c             	mov    0xc(%ebp),%eax
    de11:	c7 80 e8 00 00 00 00 	movl   $0x0,0xe8(%eax)
    de18:	00 00 00 

	if(msk->ucont_data != NULL) {
    de1b:	8b 45 0c             	mov    0xc(%ebp),%eax
    de1e:	83 78 7c 00          	cmpl   $0x0,0x7c(%eax)
    de22:	74 1f                	je     de43 <free_minisock+0xfc>
		tfree(sk,msk->ucont_data);
    de24:	8b 45 0c             	mov    0xc(%ebp),%eax
    de27:	8b 40 7c             	mov    0x7c(%eax),%eax
    de2a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    de2e:	8b 45 08             	mov    0x8(%ebp),%eax
    de31:	89 04 24             	mov    %eax,(%esp,1)
    de34:	e8 fc ff ff ff       	call   de35 <free_minisock+0xee>
		msk->ucont_data = NULL;
    de39:	8b 45 0c             	mov    0xc(%ebp),%eax
    de3c:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	}
	// printk("done with ucont data\n");
	msk->ucont_len = 0;
    de43:	8b 45 0c             	mov    0xc(%ebp),%eax
    de46:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
	if(msk->input != NULL) {
    de4d:	8b 45 0c             	mov    0xc(%ebp),%eax
    de50:	83 b8 98 00 00 00 00 	cmpl   $0x0,0x98(%eax)
    de57:	74 25                	je     de7e <free_minisock+0x137>
		tfree(sk,msk->input);
    de59:	8b 45 0c             	mov    0xc(%ebp),%eax
    de5c:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
    de62:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    de66:	8b 45 08             	mov    0x8(%ebp),%eax
    de69:	89 04 24             	mov    %eax,(%esp,1)
    de6c:	e8 fc ff ff ff       	call   de6d <free_minisock+0x126>
		msk->input = NULL;
    de71:	8b 45 0c             	mov    0xc(%ebp),%eax
    de74:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
    de7b:	00 00 00 
	}
	// printk("done with input len\n");
	msk->input_len = 0;
    de7e:	8b 45 0c             	mov    0xc(%ebp),%eax
    de81:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
    de88:	00 00 00 
}
    de8b:	c9                   	leave  
    de8c:	c3                   	ret    
    de8d:	90                   	nop    
    de8e:	90                   	nop    
    de8f:	90                   	nop    

0000de90 <record_transfer_skb>:
void record_free_skb_head(struct sk_buff *skb) {
}

static inline 
void record_transfer_skb(struct sk_buff *skb, int newType) {
    de90:	55                   	push   %ebp
    de91:	89 e5                	mov    %esp,%ebp
}
    de93:	5d                   	pop    %ebp
    de94:	c3                   	ret    

0000de95 <free_trickles_msk>:
/* Two phase free: first phase disconnects socket from event list,
   sets to ALLOC_PROCESSING; second phase adds the socket to free
   list, sets to ALLOC_FREE and ready for reuse */
#ifndef USERTEST
static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk) {
    de95:	55                   	push   %ebp
    de96:	89 e5                	mov    %esp,%ebp
    de98:	83 ec 08             	sub    $0x8,%esp
	if(!SIMULATION_MODE(sk)) {
    de9b:	8b 45 08             	mov    0x8(%ebp),%eax
    de9e:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    dea4:	83 e0 01             	and    $0x1,%eax
    dea7:	85 c0                	test   %eax,%eax
    dea9:	74 1b                	je     dec6 <free_trickles_msk+0x31>
    deab:	8b 55 08             	mov    0x8(%ebp),%edx
    deae:	8b 45 08             	mov    0x8(%ebp),%eax
    deb1:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    deb7:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
    debd:	83 e0 08             	and    $0x8,%eax
    dec0:	85 c0                	test   %eax,%eax
    dec2:	75 02                	jne    dec6 <free_trickles_msk+0x31>
    dec4:	eb 6b                	jmp    df31 <free_trickles_msk+0x9c>
		if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) {
    dec6:	8b 45 0c             	mov    0xc(%ebp),%eax
    dec9:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
    decd:	74 0b                	je     deda <free_trickles_msk+0x45>
    decf:	8b 45 0c             	mov    0xc(%ebp),%eax
    ded2:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
    ded6:	74 02                	je     deda <free_trickles_msk+0x45>
    ded8:	eb 31                	jmp    df0b <free_trickles_msk+0x76>
			printk("double free\n");
    deda:	c7 04 24 0c 45 00 00 	movl   $0x450c,(%esp,1)
    dee1:	e8 fc ff ff ff       	call   dee2 <free_trickles_msk+0x4d>
			BUG();
    dee6:	c7 44 24 04 19 45 00 	movl   $0x4519,0x4(%esp,1)
    deed:	00 
    deee:	c7 04 24 1d 45 00 00 	movl   $0x451d,(%esp,1)
    def5:	e8 fc ff ff ff       	call   def6 <free_trickles_msk+0x61>
    defa:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    df01:	e8 fc ff ff ff       	call   df02 <free_trickles_msk+0x6d>
    df06:	e8 fc ff ff ff       	call   df07 <free_trickles_msk+0x72>
		}
		if(msk->ctl == ALLOC_READY && msk->prev != NULL) {
    df0b:	8b 45 0c             	mov    0xc(%ebp),%eax
    df0e:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
    df12:	75 13                	jne    df27 <free_trickles_msk+0x92>
    df14:	8b 45 0c             	mov    0xc(%ebp),%eax
    df17:	83 38 00             	cmpl   $0x0,(%eax)
    df1a:	74 0b                	je     df27 <free_trickles_msk+0x92>
			unlink((struct alloc_head *)msk);
    df1c:	8b 45 0c             	mov    0xc(%ebp),%eax
    df1f:	89 04 24             	mov    %eax,(%esp,1)
    df22:	e8 4c 36 00 00       	call   11573 <unlink>
		}
		msk->ctl = ALLOC_PROCESSING;
    df27:	8b 45 0c             	mov    0xc(%ebp),%eax
    df2a:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
	}
}
    df31:	c9                   	leave  
    df32:	c3                   	ret    

0000df33 <free_trickles_msk_finish>:

static inline void msk_release(struct sock *sk, struct cminisock *msk) {
	// Perform actual deallocation. This function is common to
	// state cache and event queue
	msk->refCnt--;
	BUG_TRAP(msk->refCnt >= 0);
	if(msk->refCnt == 0) {
		// printk("release: refcnt %p\n", msk);
		struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
		struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;

		free_minisock(sk,msk);
		if(!SIMULATION_MODE(sk)) {
			insert_head(head, (struct alloc_head *)msk);
			msk->ctl = ALLOC_FREE;
		} else {
			if(msk == tp->t.responseMSK) {
			} else {
				// overflow
				unlink((struct alloc_head*)msk);
				kfree(msk);
			}
			tp->t.responseCount--;
		}
	} else {
		//printk("release: refcnt == %d\n", msk->refCnt);
	}
}

static inline void free_trickles_msk_finish(struct sock *sk, struct cminisock *msk) {
    df33:	55                   	push   %ebp
    df34:	89 e5                	mov    %esp,%ebp
    df36:	83 ec 08             	sub    $0x8,%esp
	if(!SIMULATION_MODE(sk)) {
    df39:	8b 45 08             	mov    0x8(%ebp),%eax
    df3c:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    df42:	83 e0 01             	and    $0x1,%eax
    df45:	85 c0                	test   %eax,%eax
    df47:	74 1b                	je     df64 <free_trickles_msk_finish+0x31>
    df49:	8b 55 08             	mov    0x8(%ebp),%edx
    df4c:	8b 45 08             	mov    0x8(%ebp),%eax
    df4f:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    df55:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
    df5b:	83 e0 08             	and    $0x8,%eax
    df5e:	85 c0                	test   %eax,%eax
    df60:	75 02                	jne    df64 <free_trickles_msk_finish+0x31>
    df62:	eb 4d                	jmp    dfb1 <free_trickles_msk_finish+0x7e>
		if(msk->ctl != ALLOC_PROCESSING && msk->ctl != ALLOC_HALFFREE) {
    df64:	8b 45 0c             	mov    0xc(%ebp),%eax
    df67:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
    df6b:	74 44                	je     dfb1 <free_trickles_msk_finish+0x7e>
    df6d:	8b 45 0c             	mov    0xc(%ebp),%eax
    df70:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
    df74:	74 3b                	je     dfb1 <free_trickles_msk_finish+0x7e>
			printk("(free_trickles_msk_finish) without corresponding free_trickles_msk: msk->ctl = %d\n", msk->ctl);
    df76:	8b 45 0c             	mov    0xc(%ebp),%eax
    df79:	8b 40 0c             	mov    0xc(%eax),%eax
    df7c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    df80:	c7 04 24 40 45 00 00 	movl   $0x4540,(%esp,1)
    df87:	e8 fc ff ff ff       	call   df88 <free_trickles_msk_finish+0x55>
			BUG();
    df8c:	c7 44 24 04 19 45 00 	movl   $0x4519,0x4(%esp,1)
    df93:	00 
    df94:	c7 04 24 1d 45 00 00 	movl   $0x451d,(%esp,1)
    df9b:	e8 fc ff ff ff       	call   df9c <free_trickles_msk_finish+0x69>
    dfa0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    dfa7:	e8 fc ff ff ff       	call   dfa8 <free_trickles_msk_finish+0x75>
    dfac:	e8 fc ff ff ff       	call   dfad <free_trickles_msk_finish+0x7a>
		}
	}
	msk_release(sk,msk);
    dfb1:	8b 45 0c             	mov    0xc(%ebp),%eax
    dfb4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    dfb8:	8b 45 08             	mov    0x8(%ebp),%eax
    dfbb:	89 04 24             	mov    %eax,(%esp,1)
    dfbe:	e8 f1 40 00 00       	call   120b4 <msk_release>
}
    dfc3:	c9                   	leave  
    dfc4:	c3                   	ret    

0000dfc5 <mborg_isqrt4>:
#define QUAD(SIGN,a,b,c) (-(b) SIGN sqrtf((b) * (b) - 4*(a)*(c))) / (2 * a)
#define COMPUTE_CWND(SSTHRESH, TCPBASE, SEQ) \
   QUAD(+, 1.0/2.0, 1.0/2.0, -((int)(SSTHRESH) * ((int)(SSTHRESH) + 1)) / 2.0 - (SEQ) + (TCPBASE));
#else
static unsigned int mborg_isqrt4(unsigned long val) {
    dfc5:	55                   	push   %ebp
    dfc6:	89 e5                	mov    %esp,%ebp
    dfc8:	83 ec 08             	sub    $0x8,%esp
  unsigned int temp, g=0;
    dfcb:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)

  if (val >= 0x40000000) {
    dfd2:	81 7d 08 ff ff ff 3f 	cmpl   $0x3fffffff,0x8(%ebp)
    dfd9:	76 0e                	jbe    dfe9 <mborg_isqrt4+0x24>
    g = 0x8000; 
    dfdb:	c7 45 f8 00 80 00 00 	movl   $0x8000,0xfffffff8(%ebp)
    val -= 0x40000000;
    dfe2:	81 6d 08 00 00 00 40 	subl   $0x40000000,0x8(%ebp)
  }

#define INNER_MBGSQRT(s)                      \
  temp = (g << (s)) + (1 << ((s) * 2 - 2));   \
  if (val >= temp) {                          \
    g += 1 << ((s)-1);                        \
    val -= temp;                              \
  }

  INNER_MBGSQRT (15)
    dfe9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    dfec:	c1 e0 0f             	shl    $0xf,%eax
    dfef:	05 00 00 00 10       	add    $0x10000000,%eax
    dff4:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    dff7:	8b 45 08             	mov    0x8(%ebp),%eax
    dffa:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
    dffd:	72 0f                	jb     e00e <mborg_isqrt4+0x49>
    dfff:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
    e002:	81 00 00 40 00 00    	addl   $0x4000,(%eax)
    e008:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    e00b:	29 45 08             	sub    %eax,0x8(%ebp)
  INNER_MBGSQRT (14)
    e00e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e011:	c1 e0 0e             	shl    $0xe,%eax
    e014:	05 00 00 00 04       	add    $0x4000000,%eax
    e019:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    e01c:	8b 45 08             	mov    0x8(%ebp),%eax
    e01f:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
    e022:	72 0f                	jb     e033 <mborg_isqrt4+0x6e>
    e024:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
    e027:	81 00 00 20 00 00    	addl   $0x2000,(%eax)
    e02d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    e030:	29 45 08             	sub    %eax,0x8(%ebp)
  INNER_MBGSQRT (13)
    e033:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e036:	c1 e0 0d             	shl    $0xd,%eax
    e039:	05 00 00 00 01       	add    $0x1000000,%eax
    e03e:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    e041:	8b 45 08             	mov    0x8(%ebp),%eax
    e044:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
    e047:	72 0f                	jb     e058 <mborg_isqrt4+0x93>
    e049:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
    e04c:	81 00 00 10 00 00    	addl   $0x1000,(%eax)
    e052:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    e055:	29 45 08             	sub    %eax,0x8(%ebp)
  INNER_MBGSQRT (12)
    e058:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e05b:	c1 e0 0c             	shl    $0xc,%eax
    e05e:	05 00 00 40 00       	add    $0x400000,%eax
    e063:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    e066:	8b 45 08             	mov    0x8(%ebp),%eax
    e069:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
    e06c:	72 0f                	jb     e07d <mborg_isqrt4+0xb8>
    e06e:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
    e071:	81 00 00 08 00 00    	addl   $0x800,(%eax)
    e077:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    e07a:	29 45 08             	sub    %eax,0x8(%ebp)
  INNER_MBGSQRT (11)
    e07d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e080:	c1 e0 0b             	shl    $0xb,%eax
    e083:	05 00 00 10 00       	add    $0x100000,%eax
    e088:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    e08b:	8b 45 08             	mov    0x8(%ebp),%eax
    e08e:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
    e091:	72 0f                	jb     e0a2 <mborg_isqrt4+0xdd>
    e093:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
    e096:	81 00 00 04 00 00    	addl   $0x400,(%eax)
    e09c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    e09f:	29 45 08             	sub    %eax,0x8(%ebp)
  INNER_MBGSQRT (10)
    e0a2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e0a5:	c1 e0 0a             	shl    $0xa,%eax
    e0a8:	05 00 00 04 00       	add    $0x40000,%eax
    e0ad:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    e0b0:	8b 45 08             	mov    0x8(%ebp),%eax
    e0b3:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
    e0b6:	72 0f                	jb     e0c7 <mborg_isqrt4+0x102>
    e0b8:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
    e0bb:	81 00 00 02 00 00    	addl   $0x200,(%eax)
    e0c1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    e0c4:	29 45 08             	sub    %eax,0x8(%ebp)
  INNER_MBGSQRT ( 9)
    e0c7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e0ca:	c1 e0 09             	shl    $0x9,%eax
    e0cd:	05 00 00 01 00       	add    $0x10000,%eax
    e0d2:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    e0d5:	8b 45 08             	mov    0x8(%ebp),%eax
    e0d8:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
    e0db:	72 0f                	jb     e0ec <mborg_isqrt4+0x127>
    e0dd:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
    e0e0:	81 00 00 01 00 00    	addl   $0x100,(%eax)
    e0e6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    e0e9:	29 45 08             	sub    %eax,0x8(%ebp)
  INNER_MBGSQRT ( 8)
    e0ec:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e0ef:	c1 e0 08             	shl    $0x8,%eax
    e0f2:	05 00 40 00 00       	add    $0x4000,%eax
    e0f7:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    e0fa:	8b 45 08             	mov    0x8(%ebp),%eax
    e0fd:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
    e100:	72 0c                	jb     e10e <mborg_isqrt4+0x149>
    e102:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
    e105:	83 28 80             	subl   $0xffffff80,(%eax)
    e108:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    e10b:	29 45 08             	sub    %eax,0x8(%ebp)
  INNER_MBGSQRT ( 7)
    e10e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e111:	c1 e0 07             	shl    $0x7,%eax
    e114:	05 00 10 00 00       	add    $0x1000,%eax
    e119:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    e11c:	8b 45 08             	mov    0x8(%ebp),%eax
    e11f:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
    e122:	72 0c                	jb     e130 <mborg_isqrt4+0x16b>
    e124:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
    e127:	83 00 40             	addl   $0x40,(%eax)
    e12a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    e12d:	29 45 08             	sub    %eax,0x8(%ebp)
  INNER_MBGSQRT ( 6)
    e130:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e133:	c1 e0 06             	shl    $0x6,%eax
    e136:	05 00 04 00 00       	add    $0x400,%eax
    e13b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    e13e:	8b 45 08             	mov    0x8(%ebp),%eax
    e141:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
    e144:	72 0c                	jb     e152 <mborg_isqrt4+0x18d>
    e146:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
    e149:	83 00 20             	addl   $0x20,(%eax)
    e14c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    e14f:	29 45 08             	sub    %eax,0x8(%ebp)
  INNER_MBGSQRT ( 5)
    e152:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e155:	c1 e0 05             	shl    $0x5,%eax
    e158:	05 00 01 00 00       	add    $0x100,%eax
    e15d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    e160:	8b 45 08             	mov    0x8(%ebp),%eax
    e163:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
    e166:	72 0c                	jb     e174 <mborg_isqrt4+0x1af>
    e168:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
    e16b:	83 00 10             	addl   $0x10,(%eax)
    e16e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    e171:	29 45 08             	sub    %eax,0x8(%ebp)
  INNER_MBGSQRT ( 4)
    e174:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e177:	c1 e0 04             	shl    $0x4,%eax
    e17a:	83 c0 40             	add    $0x40,%eax
    e17d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    e180:	8b 45 08             	mov    0x8(%ebp),%eax
    e183:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
    e186:	72 0c                	jb     e194 <mborg_isqrt4+0x1cf>
    e188:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
    e18b:	83 00 08             	addl   $0x8,(%eax)
    e18e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    e191:	29 45 08             	sub    %eax,0x8(%ebp)
  INNER_MBGSQRT ( 3)
    e194:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e197:	c1 e0 03             	shl    $0x3,%eax
    e19a:	83 c0 10             	add    $0x10,%eax
    e19d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    e1a0:	8b 45 08             	mov    0x8(%ebp),%eax
    e1a3:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
    e1a6:	72 0c                	jb     e1b4 <mborg_isqrt4+0x1ef>
    e1a8:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
    e1ab:	83 00 04             	addl   $0x4,(%eax)
    e1ae:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    e1b1:	29 45 08             	sub    %eax,0x8(%ebp)
  INNER_MBGSQRT ( 2)
    e1b4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e1b7:	c1 e0 02             	shl    $0x2,%eax
    e1ba:	83 c0 04             	add    $0x4,%eax
    e1bd:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    e1c0:	8b 45 08             	mov    0x8(%ebp),%eax
    e1c3:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
    e1c6:	72 0c                	jb     e1d4 <mborg_isqrt4+0x20f>
    e1c8:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
    e1cb:	83 00 02             	addl   $0x2,(%eax)
    e1ce:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    e1d1:	29 45 08             	sub    %eax,0x8(%ebp)

#undef INNER_MBGSQRT

  temp = g+g+1;
    e1d4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e1d7:	03 45 f8             	add    0xfffffff8(%ebp),%eax
    e1da:	40                   	inc    %eax
    e1db:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  if (val >= temp) g++;
    e1de:	8b 45 08             	mov    0x8(%ebp),%eax
    e1e1:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
    e1e4:	72 05                	jb     e1eb <mborg_isqrt4+0x226>
    e1e6:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
    e1e9:	ff 00                	incl   (%eax)
  return g;
    e1eb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
}
    e1ee:	c9                   	leave  
    e1ef:	c3                   	ret    

0000e1f0 <AckTCPCwnd>:

#define QUAD(SIGN,a,b,c) (-(b) SIGN mborg_isqrt4((b) * (b) - 4*(a)*(c))) / (2 * a)

// TODO: Improve precision?
/*
 * Fixed point computation with a fast square root is a bit tricky. 
 * We perform the square root at .(2*PREC) precision, after which the datatype becomes
 * .(PREC) (since the scaling factor is taken to ^-0.5)

     In floating point, the expression is 
      - (1/2) + sqrt((1/2)^2 - 4*1/2*(-(ssthresh*(ssthresh+1)/2 - *(seq - TCPBase))))
*/

#define PREC (1)
#define COMPUTE_CWND(SSTHRESH, TCPBASE, SEQ) \
	(((-1 << (PREC - 1)) + mborg_isqrt4((1 << (2*PREC - 2)) - ((-((int)(ssthresh) * ((int)(ssthresh) + 1)) - 2 * (((int)seq) - (TCPBase))) << (2*PREC)))) >> PREC)
#endif // USE_FLOATINGPOINT

#define MAX_CWND ((1<<13)-1)
#define CLAMP(X) (MIN((X),MAX_CWND))

// TODO: Investigate using -msoftfloat, or saving/restoring FPU state
// while processing interrupts

int AckTCPCwnd(unsigned seq, const CONTINUATION_TYPE *cont, int *hintResult) {
    e1f0:	55                   	push   %ebp
    e1f1:	89 e5                	mov    %esp,%ebp
    e1f3:	83 ec 60             	sub    $0x60,%esp
  int res, hint = -1;
    e1f6:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,0xfffffff8(%ebp)
  // hint is processed as a relative offset in the body, then converted to an absolute offset just before returning
  unsigned startCwnd = cont->startCwnd;
    e1fd:	8b 45 0c             	mov    0xc(%ebp),%eax
    e200:	8b 40 64             	mov    0x64(%eax),%eax
    e203:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  unsigned ssthresh = MIN(MAX(cont->ssthresh, startCwnd), MAX_CWND);
    e206:	c7 45 ec ff 1f 00 00 	movl   $0x1fff,0xffffffec(%ebp)
    e20d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    e210:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    e213:	8b 45 0c             	mov    0xc(%ebp),%eax
    e216:	8b 40 68             	mov    0x68(%eax),%eax
    e219:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
    e21c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    e21f:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    e222:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    e225:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
    e228:	8b 55 c4             	mov    0xffffffc4(%ebp),%edx
    e22b:	3b 55 e0             	cmp    0xffffffe0(%ebp),%edx
    e22e:	73 06                	jae    e236 <AckTCPCwnd+0x46>
    e230:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    e233:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
    e236:	8b 55 c4             	mov    0xffffffc4(%ebp),%edx
    e239:	89 55 e8             	mov    %edx,0xffffffe8(%ebp)
    e23c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    e23f:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    e242:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    e245:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
    e248:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
    e24b:	3b 55 e8             	cmp    0xffffffe8(%ebp),%edx
    e24e:	76 06                	jbe    e256 <AckTCPCwnd+0x66>
    e250:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    e253:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
    e256:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
    e259:	89 55 f0             	mov    %edx,0xfffffff0(%ebp)
  unsigned TCPBase = cont->TCPBase;
    e25c:	8b 45 0c             	mov    0xc(%ebp),%eax
    e25f:	8b 40 6c             	mov    0x6c(%eax),%eax
    e262:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  unsigned additiveStart = (ssthresh - startCwnd + TCPBase) + ssthresh;
    e265:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    e268:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    e26b:	29 d0                	sub    %edx,%eax
    e26d:	03 45 dc             	add    0xffffffdc(%ebp),%eax
    e270:	03 45 f0             	add    0xfffffff0(%ebp),%eax
    e273:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)

#ifdef ACKTCP_CWND_SPEED_HACK
  seq = TCPBase + (seq - TCPBase) * ACKTCP_CWND_SPEED_HACK;
    e276:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    e279:	8b 45 08             	mov    0x8(%ebp),%eax
    e27c:	29 d0                	sub    %edx,%eax
    e27e:	d1 e8                	shr    %eax
    e280:	03 45 dc             	add    0xffffffdc(%ebp),%eax
    e283:	89 45 08             	mov    %eax,0x8(%ebp)
#endif

  if(seq < TCPBase) {
    e286:	8b 45 08             	mov    0x8(%ebp),%eax
    e289:	3b 45 dc             	cmp    0xffffffdc(%ebp),%eax
    e28c:	73 2f                	jae    e2bd <AckTCPCwnd+0xcd>
    if(!disableSevereErrors) 
    e28e:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    e295:	75 1a                	jne    e2b1 <AckTCPCwnd+0xc1>
      ERROR("Seq (%u) < TCPBase (%u)\n", seq, TCPBase);
    e297:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    e29a:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    e29e:	8b 45 08             	mov    0x8(%ebp),%eax
    e2a1:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    e2a5:	c7 04 24 93 45 00 00 	movl   $0x4593,(%esp,1)
    e2ac:	e8 fc ff ff ff       	call   e2ad <AckTCPCwnd+0xbd>
    res = -1;
    e2b1:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,0xfffffffc(%ebp)
    goto done;
    e2b8:	e9 c5 01 00 00       	jmp    e482 <AckTCPCwnd+0x292>
  }

#if 0
  // obsolete test
  if(seq - TCPBase > MAX_CWND * MAX_CWND) {
	  printk("Exceeded max limit without renormalizing\n");
	  res = -1;
	  goto done;
  }
#endif
  if(seq < ssthresh - startCwnd + TCPBase) {
    e2bd:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    e2c0:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    e2c3:	29 d0                	sub    %edx,%eax
    e2c5:	03 45 dc             	add    0xffffffdc(%ebp),%eax
    e2c8:	39 45 08             	cmp    %eax,0x8(%ebp)
    e2cb:	73 13                	jae    e2e0 <AckTCPCwnd+0xf0>
    res = startCwnd + (seq - TCPBase);
    e2cd:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    e2d0:	8b 45 08             	mov    0x8(%ebp),%eax
    e2d3:	29 d0                	sub    %edx,%eax
    e2d5:	03 45 f4             	add    0xfffffff4(%ebp),%eax
    e2d8:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    e2db:	e9 a2 01 00 00       	jmp    e482 <AckTCPCwnd+0x292>
  } else if(ssthresh - startCwnd + TCPBase <= seq &&
    e2e0:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    e2e3:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    e2e6:	29 d0                	sub    %edx,%eax
    e2e8:	03 45 dc             	add    0xffffffdc(%ebp),%eax
    e2eb:	3b 45 08             	cmp    0x8(%ebp),%eax
    e2ee:	77 13                	ja     e303 <AckTCPCwnd+0x113>
    e2f0:	8b 45 08             	mov    0x8(%ebp),%eax
    e2f3:	3b 45 e0             	cmp    0xffffffe0(%ebp),%eax
    e2f6:	73 0b                	jae    e303 <AckTCPCwnd+0x113>
	    seq < additiveStart) {
    res = ssthresh;
    e2f8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    e2fb:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    e2fe:	e9 7f 01 00 00       	jmp    e482 <AckTCPCwnd+0x292>
  } else {
	  /* result is solution to x(x+1)-ssthresh(ssthresh+1)
                                   --------------------------- - N
                                                2                  */
	  //int offset = seq - TCPBase;
	  int offset = seq - additiveStart;
    e303:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
    e306:	8b 45 08             	mov    0x8(%ebp),%eax
    e309:	29 d0                	sub    %edx,%eax
    e30b:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
#ifdef USE_SQRT
	  int position, cwnd;
	  //double a = 1.0/2.0, b = 1.0/2.0, c = -((int)ssthresh * ((int)ssthresh + 1)) / 2.0 - seq + TCPBase;
	  cwnd = COMPUTE_CWND(ssthresh, TCPBase, seq);
    e30e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    e311:	40                   	inc    %eax
    e312:	0f af 45 f0          	imul   0xfffffff0(%ebp),%eax
    e316:	89 c1                	mov    %eax,%ecx
    e318:	f7 d9                	neg    %ecx
    e31a:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
    e31d:	8b 45 08             	mov    0x8(%ebp),%eax
    e320:	29 d0                	sub    %edx,%eax
    e322:	01 c0                	add    %eax,%eax
    e324:	29 c1                	sub    %eax,%ecx
    e326:	89 c8                	mov    %ecx,%eax
    e328:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e32f:	b8 01 00 00 00       	mov    $0x1,%eax
    e334:	29 d0                	sub    %edx,%eax
    e336:	89 04 24             	mov    %eax,(%esp,1)
    e339:	e8 87 fc ff ff       	call   dfc5 <mborg_isqrt4>
    e33e:	48                   	dec    %eax
    e33f:	d1 e8                	shr    %eax
    e341:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	  
	  //val = 1/4 - (-((int)(ssthresh) * ((int)(ssthresh) + 1)) - 2 * (((int)seq) - (TCPBase)))
	  //printk("sqrt(%d) = %d\n", val, mborg_isqrt4(val));

	  cwnd = CLAMP(cwnd);
    e344:	c7 45 d8 ff 1f 00 00 	movl   $0x1fff,0xffffffd8(%ebp)
    e34b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    e34e:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
    e351:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    e354:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    e357:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    e35a:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
    e35d:	8b 55 bc             	mov    0xffffffbc(%ebp),%edx
    e360:	3b 55 d4             	cmp    0xffffffd4(%ebp),%edx
    e363:	7e 06                	jle    e36b <AckTCPCwnd+0x17b>
    e365:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    e368:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
    e36b:	8b 55 bc             	mov    0xffffffbc(%ebp),%edx
    e36e:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
	  position = (cwnd*(cwnd+1)-ssthresh*(ssthresh+1)) / 2;
    e371:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    e374:	40                   	inc    %eax
    e375:	89 c2                	mov    %eax,%edx
    e377:	0f af 55 ec          	imul   0xffffffec(%ebp),%edx
    e37b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    e37e:	40                   	inc    %eax
    e37f:	0f af 45 f0          	imul   0xfffffff0(%ebp),%eax
    e383:	29 c2                	sub    %eax,%edx
    e385:	89 d0                	mov    %edx,%eax
    e387:	d1 e8                	shr    %eax
    e389:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
	  if(cwnd == MAX_CWND) {
    e38c:	81 7d ec ff 1f 00 00 	cmpl   $0x1fff,0xffffffec(%ebp)
    e393:	75 12                	jne    e3a7 <AckTCPCwnd+0x1b7>
		  res = cwnd;
    e395:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    e398:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
		  hint = - 1;
    e39b:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,0xfffffff8(%ebp)
    e3a2:	e9 db 00 00 00       	jmp    e482 <AckTCPCwnd+0x292>
	  } else {
		  if(offset >= position) {
    e3a7:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    e3aa:	3b 45 e8             	cmp    0xffffffe8(%ebp),%eax
    e3ad:	0f 8c 94 00 00 00    	jl     e447 <AckTCPCwnd+0x257>
			  int cwnd_1 = CLAMP(cwnd + 1),
    e3b3:	c7 45 d4 ff 1f 00 00 	movl   $0x1fff,0xffffffd4(%ebp)
    e3ba:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    e3bd:	40                   	inc    %eax
    e3be:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    e3c1:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    e3c4:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    e3c7:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    e3ca:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
    e3cd:	8b 55 b8             	mov    0xffffffb8(%ebp),%edx
    e3d0:	3b 55 d8             	cmp    0xffffffd8(%ebp),%edx
    e3d3:	7e 06                	jle    e3db <AckTCPCwnd+0x1eb>
    e3d5:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    e3d8:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
    e3db:	8b 55 b8             	mov    0xffffffb8(%ebp),%edx
    e3de:	89 55 d0             	mov    %edx,0xffffffd0(%ebp)
				  cwnd_2 = CLAMP(cwnd + 2);
    e3e1:	c7 45 d4 ff 1f 00 00 	movl   $0x1fff,0xffffffd4(%ebp)
    e3e8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    e3eb:	83 c0 02             	add    $0x2,%eax
    e3ee:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
    e3f1:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    e3f4:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
    e3f7:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
    e3fa:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
    e3fd:	8b 55 b4             	mov    0xffffffb4(%ebp),%edx
    e400:	3b 55 d8             	cmp    0xffffffd8(%ebp),%edx
    e403:	7e 06                	jle    e40b <AckTCPCwnd+0x21b>
    e405:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    e408:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
    e40b:	8b 55 b4             	mov    0xffffffb4(%ebp),%edx
    e40e:	89 55 cc             	mov    %edx,0xffffffcc(%ebp)
			  if(offset < position + cwnd_1) {
    e411:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    e414:	03 45 e8             	add    0xffffffe8(%ebp),%eax
    e417:	39 45 e4             	cmp    %eax,0xffffffe4(%ebp)
    e41a:	7d 14                	jge    e430 <AckTCPCwnd+0x240>
				  res = cwnd_1;
    e41c:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
    e41f:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
				  hint = additiveStart + position + cwnd_1;
    e422:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    e425:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    e428:	03 45 d0             	add    0xffffffd0(%ebp),%eax
    e42b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    e42e:	eb 52                	jmp    e482 <AckTCPCwnd+0x292>
			  } else {
				  if(!(offset < position + cwnd_1 + cwnd_2)) {
#ifndef DISABLE_ACKTCPCWND_WARNINGS
					  BUG_TRAP(0);
#endif
				  }
				  res = cwnd_2;
    e430:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
    e433:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
				  hint = additiveStart + position + cwnd_1 + cwnd_2;
    e436:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    e439:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    e43c:	03 45 d0             	add    0xffffffd0(%ebp),%eax
    e43f:	03 45 cc             	add    0xffffffcc(%ebp),%eax
    e442:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    e445:	eb 3b                	jmp    e482 <AckTCPCwnd+0x292>
			  }
		  } else if(offset < position) {
    e447:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    e44a:	3b 45 e8             	cmp    0xffffffe8(%ebp),%eax
    e44d:	7d 33                	jge    e482 <AckTCPCwnd+0x292>
			  if(offset > position - cwnd) {
    e44f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    e452:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    e455:	29 c2                	sub    %eax,%edx
    e457:	89 d0                	mov    %edx,%eax
    e459:	39 45 e4             	cmp    %eax,0xffffffe4(%ebp)
    e45c:	7e 11                	jle    e46f <AckTCPCwnd+0x27f>
				  res = cwnd;
    e45e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    e461:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
				  hint = additiveStart + position;
    e464:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    e467:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    e46a:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    e46d:	eb 13                	jmp    e482 <AckTCPCwnd+0x292>
			  } else {
				  if(!(offset > position - cwnd - (cwnd - 1))) {
#ifndef DISABLE_ACKTCPCWND_WARNINGS
					  BUG_TRAP(0);
#endif
				  }
				  if((cwnd - 1) < ssthresh) {
#ifndef DISABLE_ACKTCPCWND_WARNINGS

					  BUG_TRAP(0);
#endif
				  }
#ifndef DISABLE_ACKTCPCWND_WARNINGS
				  BUG_TRAP(cwnd - 1 >= 1);
#endif
				  res = cwnd - 1;
    e46f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    e472:	48                   	dec    %eax
    e473:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
				  hint = additiveStart + position - cwnd;
    e476:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    e479:	03 45 e0             	add    0xffffffe0(%ebp),%eax
    e47c:	2b 45 ec             	sub    0xffffffec(%ebp),%eax
    e47f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
			  }		  
		  }
	  }
#else
	  // Fixed point Newton's method to solve (cwnd*(cwnd+1) - ssthresh*(ssthresh+)) / 2 = 
#define FRAC (2)
	  int i;
	  static int numIterations, count = 0;
	  //long long x;
	  typedef int FIXEDPT_TYPE;
	  FIXEDPT_TYPE x, oldX[32];;
	  // Special case: offset > max clamp
	  if(offset >= (MAX_CWND * (MAX_CWND + 1) - ssthresh*(ssthresh+1)) / 2) {
		  res = MAX_CWND;
		  goto done;
	  }

	  /* Newton iteration:
	     x_{k+1} = x_k - f(x_k)/f'(x_k) */
	  // set initial guess to maximum possible value to avoid converging to wrong root	  
	  x = (MAX_CWND) << FRAC;
#define MAX_NEWTON_ITERATIONS (sizeof(FIXEDPT_TYPE) * 8)
	  for(i=0; i < MAX_NEWTON_ITERATIONS; i++) {
		  FIXEDPT_TYPE cwnd, xupdate;
		  unsigned position;
		  cwnd = x >> FRAC;

#if 0
		  printk("offset = %d ssthresh = %d x_%d: %d ", offset, ssthresh, i, x >> FRAC);
		  printk("f(x_%d) * 2 = %d (%d %d %d) ", i, (x * (x + (1 << FRAC)) - (((int)ssthresh * ((int)ssthresh + 1) + 2 * offset) << (2 * FRAC))) >> (2 * FRAC), x * (x + (1 << FRAC)), (((int)ssthresh * ((int)ssthresh + 1) + 2 * offset)) << (2 * FRAC), (x * (x + (1 << FRAC)) - (((int)ssthresh * ((int)ssthresh + 1) + 2 * offset) << (2 * FRAC))));
		  printk("f'(x_%d) * 2 = %d ", i, (2 * x + (1 << FRAC)) >> FRAC);
		  printk("f/f' = %d ", ((x * (x + (1 << FRAC)) - (((int)ssthresh * ((int)ssthresh + 1) + 2 * offset) << (2 * FRAC))) /
					 (2 * x + (1 << FRAC))));
		  printk("\n");
#endif
		  position = (cwnd*(cwnd+1)-ssthresh*(ssthresh+1)) / 2;
		  if(offset - position >= 0 && 
		     offset - position < cwnd + 1) {
			  res = CLAMP(cwnd + 1);
			  hint = additiveStart + position + res;

			  if(i > numIterations || count == 100000) {
			    numIterations = i;
			    printk("%d iterations - result = %d\n", i, cwnd);
			    if(count == 100000) count = 0;
			  }
			  count++;
			  goto done;
		  } else if(position - offset > 0 &&
			    position - offset < cwnd) {
			  res = CLAMP(cwnd);
			  hint = additiveStart + position;

			  if(i > numIterations || count == 100000) {
			    numIterations = i;
			    printk("%d iterations - result = %d\n", i, cwnd);
			    if(count == 100000) count = 0;
			  }
			  count++;
			  goto done;
		  }
		  xupdate = (x - 
		       ((x * (x + (1 << FRAC)) - (((int)ssthresh * ((int)ssthresh + 1) + 2 * offset) << (2 * FRAC))) /
			(2 * x + (1 << FRAC))));
		  oldX[i] = x;
		  if(xupdate == x) {
			  int sign0 = ((int)ssthresh * ((int)ssthresh + 1) + 2 * offset) > 0 ? 1 : -1,
				  sign1 = (2 * x + (1 << FRAC)) > 0 ? 1 : -1;
			  x -= (sign0 * sign1) << FRAC;
		  } else {
			  x = xupdate;
		  }
	  }
	  printk("AckTCPCwnd SQRT: Too many iterations: x = %d f(x) = %d f'(x) = %d offset = %d ssthresh * (ssthresh+1) = %d, %d \n", 
		 x >> FRAC, 
		 (x * (x + (1 << FRAC)) - (((int)ssthresh * ((int)ssthresh + 1) + 2 * offset) << (2 * FRAC))) >> (2 * FRAC), 
		 ((2 * x) >> FRAC) + 1,
		 offset, 
		 ssthresh*(ssthresh+1), 
		 (((int)ssthresh * ((int)ssthresh + 1) + 2 * offset))/2);
	  for(i = 0; i < MAX_NEWTON_ITERATIONS; i++) {
		  printk("X_%d = %d\n", i, oldX[i]);
	  }
	  res = (-(1 << (FRAC-1)) + x) >> FRAC;

#endif
#undef FRAC
  }
  done:
	  ;
  if(res > MAX_CWND)
    e482:	81 7d fc ff 1f 00 00 	cmpl   $0x1fff,0xfffffffc(%ebp)
    e489:	7e 07                	jle    e492 <AckTCPCwnd+0x2a2>
	  res = MAX_CWND;
    e48b:	c7 45 fc ff 1f 00 00 	movl   $0x1fff,0xfffffffc(%ebp)
  if(hintResult != NULL)
    e492:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    e496:	74 21                	je     e4b9 <AckTCPCwnd+0x2c9>
    *hintResult = (hint >= 0) ? hint : -1;
    e498:	8b 45 10             	mov    0x10(%ebp),%eax
    e49b:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
    e49e:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    e4a1:	89 55 ac             	mov    %edx,0xffffffac(%ebp)
    e4a4:	83 7d ac ff          	cmpl   $0xffffffff,0xffffffac(%ebp)
    e4a8:	7d 07                	jge    e4b1 <AckTCPCwnd+0x2c1>
    e4aa:	c7 45 ac ff ff ff ff 	movl   $0xffffffff,0xffffffac(%ebp)
    e4b1:	8b 55 ac             	mov    0xffffffac(%ebp),%edx
    e4b4:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
    e4b7:	89 10                	mov    %edx,(%eax)
  ((CONTINUATION_TYPE*)cont)->mark = res; // tricklesLossEvent gets cwnd size from here
    e4b9:	8b 55 0c             	mov    0xc(%ebp),%edx
    e4bc:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    e4bf:	89 82 e4 00 00 00    	mov    %eax,0xe4(%edx)
  return res;
    e4c5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
    e4c8:	c9                   	leave  
    e4c9:	c3                   	ret    

0000e4ca <AckTCPCwndScalar>:

inline int AckTCPCwndScalar(unsigned seq, const CONTINUATION_TYPE *cont) {
    e4ca:	55                   	push   %ebp
    e4cb:	89 e5                	mov    %esp,%ebp
    e4cd:	83 ec 0c             	sub    $0xc,%esp
	return AckTCPCwnd(seq, cont, NULL);
    e4d0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
    e4d7:	00 
    e4d8:	8b 45 0c             	mov    0xc(%ebp),%eax
    e4db:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    e4df:	8b 45 08             	mov    0x8(%ebp),%eax
    e4e2:	89 04 24             	mov    %eax,(%esp,1)
    e4e5:	e8 fc ff ff ff       	call   e4e6 <AckTCPCwndScalar+0x1c>
}
    e4ea:	c9                   	leave  
    e4eb:	c3                   	ret    

0000e4ec <Sack_validate>:

int Sack_validate(CONTINUATION_TYPE *cont, Sack *sack) {
    e4ec:	55                   	push   %ebp
    e4ed:	89 e5                	mov    %esp,%ebp
    e4ef:	83 ec 1c             	sub    $0x1c,%esp
  if(sack->left > sack->right) {
    e4f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    e4f5:	8b 55 0c             	mov    0xc(%ebp),%edx
    e4f8:	8b 00                	mov    (%eax),%eax
    e4fa:	3b 42 04             	cmp    0x4(%edx),%eax
    e4fd:	76 09                	jbe    e508 <Sack_validate+0x1c>
    return 0;
    e4ff:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
    e506:	eb 51                	jmp    e559 <Sack_validate+0x6d>
  }
  /* Verify that cumulative nonce matches sack range */
  if(!DISABLE_NONCE_CHECK) {
    __u32 genNonce = generateRangeNonce(cont->sk, sack->left, sack->right);
    e508:	8b 45 0c             	mov    0xc(%ebp),%eax
    e50b:	8b 40 04             	mov    0x4(%eax),%eax
    e50e:	ba 00 00 00 00       	mov    $0x0,%edx
    e513:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    e517:	89 54 24 10          	mov    %edx,0x10(%esp,1)
    e51b:	8b 45 0c             	mov    0xc(%ebp),%eax
    e51e:	8b 00                	mov    (%eax),%eax
    e520:	ba 00 00 00 00       	mov    $0x0,%edx
    e525:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    e529:	89 54 24 08          	mov    %edx,0x8(%esp,1)
    e52d:	8b 45 08             	mov    0x8(%ebp),%eax
    e530:	8b 40 20             	mov    0x20(%eax),%eax
    e533:	89 04 24             	mov    %eax,(%esp,1)
    e536:	e8 fc ff ff ff       	call   e537 <Sack_validate+0x4b>
    e53b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    if(genNonce != sack->nonceSummary) {
    e53e:	8b 55 0c             	mov    0xc(%ebp),%edx
    e541:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    e544:	3b 42 08             	cmp    0x8(%edx),%eax
    e547:	74 09                	je     e552 <Sack_validate+0x66>
#ifdef DISABLE_NONCE_FAIL // 0715 - this was old code used force side effect from generateRangeNonce() without actually performing nonce check
      static volatile int w;
      w++;
#else
      if(trickles_ratelimit()) {
	printk("nonce check failed for [%d-%d] = 0x%0X != 0x%0X\n", 
	       sack->left, sack->right, genNonce, sack->nonceSummary);
      }
      return 0;
    e549:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
    e550:	eb 07                	jmp    e559 <Sack_validate+0x6d>
#endif
    }
  }
#if 0
  if(trickles_ratelimit()) {
	  printk("nonce check succeeded\n");
  }
#endif
  return 1;
    e552:	c7 45 f8 01 00 00 00 	movl   $0x1,0xfffffff8(%ebp)
}
    e559:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e55c:	c9                   	leave  
    e55d:	c3                   	ret    

0000e55e <Sack_contains>:

inline int Sack_contains(Sack *sack, int seq) {
    e55e:	55                   	push   %ebp
    e55f:	89 e5                	mov    %esp,%ebp
    e561:	83 ec 04             	sub    $0x4,%esp
  return sack->left <= seq && seq <= sack->right;
    e564:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
    e56b:	8b 45 08             	mov    0x8(%ebp),%eax
    e56e:	8b 00                	mov    (%eax),%eax
    e570:	3b 45 0c             	cmp    0xc(%ebp),%eax
    e573:	77 12                	ja     e587 <Sack_contains+0x29>
    e575:	8b 55 08             	mov    0x8(%ebp),%edx
    e578:	8b 45 0c             	mov    0xc(%ebp),%eax
    e57b:	3b 42 04             	cmp    0x4(%edx),%eax
    e57e:	77 07                	ja     e587 <Sack_contains+0x29>
    e580:	c7 45 fc 01 00 00 00 	movl   $0x1,0xfffffffc(%ebp)
    e587:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
    e58a:	c9                   	leave  
    e58b:	c3                   	ret    

0000e58c <Sack_gapLen>:

inline int Sack_gapLen(Sack *left, Sack *right) {
    e58c:	55                   	push   %ebp
    e58d:	89 e5                	mov    %esp,%ebp
  return right->left - left->right - 1;
    e58f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e592:	8b 45 08             	mov    0x8(%ebp),%eax
    e595:	8b 50 04             	mov    0x4(%eax),%edx
    e598:	8b 01                	mov    (%ecx),%eax
    e59a:	29 d0                	sub    %edx,%eax
    e59c:	48                   	dec    %eax
}
    e59d:	5d                   	pop    %ebp
    e59e:	c3                   	ret    

0000e59f <Sack_adjacent>:

inline int Sack_adjacent(Sack *left, Sack *right) {
    e59f:	55                   	push   %ebp
    e5a0:	89 e5                	mov    %esp,%ebp
    e5a2:	83 ec 0c             	sub    $0xc,%esp
  return Sack_gapLen(left, right) == 0;
    e5a5:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5a8:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    e5ac:	8b 45 08             	mov    0x8(%ebp),%eax
    e5af:	89 04 24             	mov    %eax,(%esp,1)
    e5b2:	e8 fc ff ff ff       	call   e5b3 <Sack_adjacent+0x14>
    e5b7:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    e5ba:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
    e5be:	0f 94 c0             	sete   %al
    e5c1:	0f b6 c0             	movzbl %al,%eax
    e5c4:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    e5c7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
    e5ca:	c9                   	leave  
    e5cb:	c3                   	ret    

0000e5cc <AckProof_isPoisoned>:

int AckProof_isPoisoned(AckProof *proof, Sack *sack) {
    e5cc:	55                   	push   %ebp
    e5cd:	89 e5                	mov    %esp,%ebp
  /* For now, always return 0 */
  return 0;
    e5cf:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e5d4:	5d                   	pop    %ebp
    e5d5:	c3                   	ret    

0000e5d6 <AckProof_validate>:

int AckProof_validate(AckProof *proof) {
    e5d6:	55                   	push   %ebp
    e5d7:	89 e5                	mov    %esp,%ebp
    e5d9:	53                   	push   %ebx
    e5da:	83 ec 28             	sub    $0x28,%esp
  int i;
  CONTINUATION_TYPE *cont = proof->cont;
    e5dd:	8b 45 08             	mov    0x8(%ebp),%eax
    e5e0:	8b 40 04             	mov    0x4(%eax),%eax
    e5e3:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  Sack *sacks = proof->sacks;
    e5e6:	8b 45 08             	mov    0x8(%ebp),%eax
    e5e9:	83 c0 08             	add    $0x8,%eax
    e5ec:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  int numSacks = proof->numSacks;
    e5ef:	8b 45 08             	mov    0x8(%ebp),%eax
    e5f2:	8b 00                	mov    (%eax),%eax
    e5f4:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  // 0714 MAXSACKS is appropriate here (e.g., NOT MAX_KERNEL_SACKS) because 
  // this numSacks comes from the wire
  if(numSacks == 0 || numSacks > MAXSACKS || 
    e5f7:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
    e5fb:	74 15                	je     e612 <AckProof_validate+0x3c>
    e5fd:	83 7d ec 40          	cmpl   $0x40,0xffffffec(%ebp)
    e601:	7f 0f                	jg     e612 <AckProof_validate+0x3c>
    e603:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    e606:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    e609:	8b 00                	mov    (%eax),%eax
    e60b:	3b 42 6c             	cmp    0x6c(%edx),%eax
    e60e:	77 02                	ja     e612 <AckProof_validate+0x3c>
    e610:	eb 45                	jmp    e657 <AckProof_validate+0x81>
     sacks[0].left > cont->TCPBase) {
	  if(!disableSevereErrors)
    e612:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    e619:	75 30                	jne    e64b <AckProof_validate+0x75>
		  printk("Zero sacks (%d), too many sacks, or start (%u) > TCPBase (%u) [seq = %u]\n", numSacks, sacks[0].left, cont->TCPBase, cont->seq);
    e61b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    e61e:	8b 40 30             	mov    0x30(%eax),%eax
    e621:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    e625:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    e628:	8b 40 6c             	mov    0x6c(%eax),%eax
    e62b:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    e62f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    e632:	8b 00                	mov    (%eax),%eax
    e634:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    e638:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    e63b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    e63f:	c7 04 24 c0 45 00 00 	movl   $0x45c0,(%esp,1)
    e646:	e8 fc ff ff ff       	call   e647 <AckProof_validate+0x71>
    return 0;
    e64b:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
    e652:	e9 86 00 00 00       	jmp    e6dd <AckProof_validate+0x107>
  }
  for(i=0; i < numSacks; i++) {
    e657:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
    e65e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e661:	3b 45 ec             	cmp    0xffffffec(%ebp),%eax
    e664:	7c 02                	jl     e668 <AckProof_validate+0x92>
    e666:	eb 6e                	jmp    e6d6 <AckProof_validate+0x100>
    if(!Sack_validate(cont, &sacks[i])) {
    e668:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    e66b:	89 d0                	mov    %edx,%eax
    e66d:	01 c0                	add    %eax,%eax
    e66f:	01 d0                	add    %edx,%eax
    e671:	c1 e0 02             	shl    $0x2,%eax
    e674:	03 45 f0             	add    0xfffffff0(%ebp),%eax
    e677:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    e67b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    e67e:	89 04 24             	mov    %eax,(%esp,1)
    e681:	e8 fc ff ff ff       	call   e682 <AckProof_validate+0xac>
    e686:	85 c0                	test   %eax,%eax
    e688:	75 09                	jne    e693 <AckProof_validate+0xbd>
      return 0;
    e68a:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
    e691:	eb 4a                	jmp    e6dd <AckProof_validate+0x107>
    }
    if(i > 0 && sacks[i].left <= sacks[i-1].right) {
    e693:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    e697:	7e 36                	jle    e6cf <AckProof_validate+0xf9>
    e699:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    e69c:	89 d0                	mov    %edx,%eax
    e69e:	01 c0                	add    %eax,%eax
    e6a0:	01 d0                	add    %edx,%eax
    e6a2:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    e6a9:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    e6ac:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
    e6af:	89 d0                	mov    %edx,%eax
    e6b1:	01 c0                	add    %eax,%eax
    e6b3:	01 d0                	add    %edx,%eax
    e6b5:	c1 e0 02             	shl    $0x2,%eax
    e6b8:	03 45 f0             	add    0xfffffff0(%ebp),%eax
    e6bb:	8d 50 f4             	lea    0xfffffff4(%eax),%edx
    e6be:	8b 04 0b             	mov    (%ebx,%ecx,1),%eax
    e6c1:	3b 42 04             	cmp    0x4(%edx),%eax
    e6c4:	77 09                	ja     e6cf <AckProof_validate+0xf9>
      return 0;
    e6c6:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
    e6cd:	eb 0e                	jmp    e6dd <AckProof_validate+0x107>
    e6cf:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
    e6d2:	ff 00                	incl   (%eax)
    e6d4:	eb 88                	jmp    e65e <AckProof_validate+0x88>
    }
  }
  return 1;
    e6d6:	c7 45 e8 01 00 00 00 	movl   $0x1,0xffffffe8(%ebp)
}
    e6dd:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    e6e0:	83 c4 28             	add    $0x28,%esp
    e6e3:	5b                   	pop    %ebx
    e6e4:	5d                   	pop    %ebp
    e6e5:	c3                   	ret    

0000e6e6 <AckProof_firstLoss>:

/* Note: FirstLoss considers poisoned nonces as present */
int AckProof_firstLoss(AckProof *proof) {
    e6e6:	55                   	push   %ebp
    e6e7:	89 e5                	mov    %esp,%ebp
    e6e9:	83 ec 18             	sub    $0x18,%esp
  int i, numSacks = proof->numSacks;
    e6ec:	8b 45 08             	mov    0x8(%ebp),%eax
    e6ef:	8b 00                	mov    (%eax),%eax
    e6f1:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  Sack *sacks = proof->sacks;
    e6f4:	8b 45 08             	mov    0x8(%ebp),%eax
    e6f7:	83 c0 08             	add    $0x8,%eax
    e6fa:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  for(i=1; i < numSacks; i++) {
    e6fd:	c7 45 fc 01 00 00 00 	movl   $0x1,0xfffffffc(%ebp)
    e704:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    e707:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
    e70a:	7c 02                	jl     e70e <AckProof_firstLoss+0x28>
    e70c:	eb 53                	jmp    e761 <AckProof_firstLoss+0x7b>
    if(!Sack_adjacent(&sacks[i-1], &sacks[i])) {
    e70e:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    e711:	89 d0                	mov    %edx,%eax
    e713:	01 c0                	add    %eax,%eax
    e715:	01 d0                	add    %edx,%eax
    e717:	c1 e0 02             	shl    $0x2,%eax
    e71a:	03 45 f4             	add    0xfffffff4(%ebp),%eax
    e71d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    e721:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    e724:	89 d0                	mov    %edx,%eax
    e726:	01 c0                	add    %eax,%eax
    e728:	01 d0                	add    %edx,%eax
    e72a:	c1 e0 02             	shl    $0x2,%eax
    e72d:	03 45 f4             	add    0xfffffff4(%ebp),%eax
    e730:	83 e8 0c             	sub    $0xc,%eax
    e733:	89 04 24             	mov    %eax,(%esp,1)
    e736:	e8 fc ff ff ff       	call   e737 <AckProof_firstLoss+0x51>
    e73b:	85 c0                	test   %eax,%eax
    e73d:	75 1b                	jne    e75a <AckProof_firstLoss+0x74>
      return sacks[i-1].right + 1;
    e73f:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    e742:	89 d0                	mov    %edx,%eax
    e744:	01 c0                	add    %eax,%eax
    e746:	01 d0                	add    %edx,%eax
    e748:	c1 e0 02             	shl    $0x2,%eax
    e74b:	03 45 f4             	add    0xfffffff4(%ebp),%eax
    e74e:	83 e8 0c             	sub    $0xc,%eax
    e751:	8b 40 04             	mov    0x4(%eax),%eax
    e754:	40                   	inc    %eax
    e755:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    e758:	eb 1a                	jmp    e774 <AckProof_firstLoss+0x8e>
    e75a:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
    e75d:	ff 00                	incl   (%eax)
    e75f:	eb a3                	jmp    e704 <AckProof_firstLoss+0x1e>
    }
  }
  ERROR("No loss!\n");
    e761:	c7 04 24 0a 46 00 00 	movl   $0x460a,(%esp,1)
    e768:	e8 fc ff ff ff       	call   e769 <AckProof_firstLoss+0x83>
  return -1;
    e76d:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,0xfffffff0(%ebp)
}
    e774:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    e777:	c9                   	leave  
    e778:	c3                   	ret    

0000e779 <AckProof_checkRange>:

enum CheckRangeResult AckProof_checkRange(AckProof *proof, int left, int right) {
    e779:	55                   	push   %ebp
    e77a:	89 e5                	mov    %esp,%ebp
    e77c:	83 ec 20             	sub    $0x20,%esp
  int i;
  int cursor;
  int poisoned = 0;
    e77f:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  Sack *sacks = proof->sacks;
    e786:	8b 45 08             	mov    0x8(%ebp),%eax
    e789:	83 c0 08             	add    $0x8,%eax
    e78c:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  /* Check if AckProof covers the desired range */
  cursor = left;
    e78f:	8b 45 0c             	mov    0xc(%ebp),%eax
    e792:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  for(i=0; i < proof->numSacks; i++) {
    e795:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
    e79c:	8b 55 08             	mov    0x8(%ebp),%edx
    e79f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    e7a2:	3b 02                	cmp    (%edx),%eax
    e7a4:	7c 02                	jl     e7a8 <AckProof_checkRange+0x2f>
    e7a6:	eb 7a                	jmp    e822 <AckProof_checkRange+0xa9>
    if(Sack_contains(&sacks[i], cursor)) {
    e7a8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e7ab:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    e7af:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    e7b2:	89 d0                	mov    %edx,%eax
    e7b4:	01 c0                	add    %eax,%eax
    e7b6:	01 d0                	add    %edx,%eax
    e7b8:	c1 e0 02             	shl    $0x2,%eax
    e7bb:	03 45 f0             	add    0xfffffff0(%ebp),%eax
    e7be:	89 04 24             	mov    %eax,(%esp,1)
    e7c1:	e8 fc ff ff ff       	call   e7c2 <AckProof_checkRange+0x49>
    e7c6:	85 c0                	test   %eax,%eax
    e7c8:	74 4e                	je     e818 <AckProof_checkRange+0x9f>
      if(AckProof_isPoisoned(proof, &sacks[i])) {
    e7ca:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    e7cd:	89 d0                	mov    %edx,%eax
    e7cf:	01 c0                	add    %eax,%eax
    e7d1:	01 d0                	add    %edx,%eax
    e7d3:	c1 e0 02             	shl    $0x2,%eax
    e7d6:	03 45 f0             	add    0xfffffff0(%ebp),%eax
    e7d9:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    e7dd:	8b 45 08             	mov    0x8(%ebp),%eax
    e7e0:	89 04 24             	mov    %eax,(%esp,1)
    e7e3:	e8 fc ff ff ff       	call   e7e4 <AckProof_checkRange+0x6b>
    e7e8:	85 c0                	test   %eax,%eax
    e7ea:	74 07                	je     e7f3 <AckProof_checkRange+0x7a>
	poisoned = 1;
    e7ec:	c7 45 f4 01 00 00 00 	movl   $0x1,0xfffffff4(%ebp)
      }
      cursor = sacks[i].right + 1;
    e7f3:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    e7f6:	89 d0                	mov    %edx,%eax
    e7f8:	01 c0                	add    %eax,%eax
    e7fa:	01 d0                	add    %edx,%eax
    e7fc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e803:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    e806:	8b 44 10 04          	mov    0x4(%eax,%edx,1),%eax
    e80a:	40                   	inc    %eax
    e80b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
      if(cursor > right) break;
    e80e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e811:	3b 45 10             	cmp    0x10(%ebp),%eax
    e814:	7e 02                	jle    e818 <AckProof_checkRange+0x9f>
    e816:	eb 0a                	jmp    e822 <AckProof_checkRange+0xa9>
    e818:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
    e81b:	ff 00                	incl   (%eax)
    e81d:	e9 7a ff ff ff       	jmp    e79c <AckProof_checkRange+0x23>
    }
  }
  if(i == proof->numSacks) {
    e822:	8b 55 08             	mov    0x8(%ebp),%edx
    e825:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    e828:	3b 02                	cmp    (%edx),%eax
    e82a:	75 09                	jne    e835 <AckProof_checkRange+0xbc>
    return BADRANGE;
    e82c:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
    e833:	eb 1c                	jmp    e851 <AckProof_checkRange+0xd8>
  }
  return poisoned ? POISONEDRANGE : NORMALRANGE;
    e835:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
    e839:	74 09                	je     e844 <AckProof_checkRange+0xcb>
    e83b:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,0xffffffe8(%ebp)
    e842:	eb 07                	jmp    e84b <AckProof_checkRange+0xd2>
    e844:	c7 45 e8 01 00 00 00 	movl   $0x1,0xffffffe8(%ebp)
    e84b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    e84e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
}
    e851:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    e854:	c9                   	leave  
    e855:	c3                   	ret    

0000e856 <AckProof_findRight>:

__u32 AckProof_findRight(AckProof *proof, int start) {
    e856:	55                   	push   %ebp
    e857:	89 e5                	mov    %esp,%ebp
    e859:	83 ec 1c             	sub    $0x1c,%esp
  int i;
  int cursor;
  int poisoned = 0;
    e85c:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  Sack *sacks = proof->sacks;
    e863:	8b 45 08             	mov    0x8(%ebp),%eax
    e866:	83 c0 08             	add    $0x8,%eax
    e869:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  /* Check if AckProof covers the desired range */
  cursor = start;
    e86c:	8b 45 0c             	mov    0xc(%ebp),%eax
    e86f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  for(i=0; i < proof->numSacks; i++) {
    e872:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
    e879:	8b 55 08             	mov    0x8(%ebp),%edx
    e87c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    e87f:	3b 02                	cmp    (%edx),%eax
    e881:	7c 02                	jl     e885 <AckProof_findRight+0x2f>
    e883:	eb 6d                	jmp    e8f2 <AckProof_findRight+0x9c>
    if(Sack_contains(&sacks[i], cursor)) {
    e885:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e888:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    e88c:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    e88f:	89 d0                	mov    %edx,%eax
    e891:	01 c0                	add    %eax,%eax
    e893:	01 d0                	add    %edx,%eax
    e895:	c1 e0 02             	shl    $0x2,%eax
    e898:	03 45 f0             	add    0xfffffff0(%ebp),%eax
    e89b:	89 04 24             	mov    %eax,(%esp,1)
    e89e:	e8 fc ff ff ff       	call   e89f <AckProof_findRight+0x49>
    e8a3:	85 c0                	test   %eax,%eax
    e8a5:	74 44                	je     e8eb <AckProof_findRight+0x95>
      if(AckProof_isPoisoned(proof, &sacks[i])) {
    e8a7:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    e8aa:	89 d0                	mov    %edx,%eax
    e8ac:	01 c0                	add    %eax,%eax
    e8ae:	01 d0                	add    %edx,%eax
    e8b0:	c1 e0 02             	shl    $0x2,%eax
    e8b3:	03 45 f0             	add    0xfffffff0(%ebp),%eax
    e8b6:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    e8ba:	8b 45 08             	mov    0x8(%ebp),%eax
    e8bd:	89 04 24             	mov    %eax,(%esp,1)
    e8c0:	e8 fc ff ff ff       	call   e8c1 <AckProof_findRight+0x6b>
    e8c5:	85 c0                	test   %eax,%eax
    e8c7:	74 07                	je     e8d0 <AckProof_findRight+0x7a>
	poisoned = 1;
    e8c9:	c7 45 f4 01 00 00 00 	movl   $0x1,0xfffffff4(%ebp)
      }
      cursor = sacks[i].right + 1;
    e8d0:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    e8d3:	89 d0                	mov    %edx,%eax
    e8d5:	01 c0                	add    %eax,%eax
    e8d7:	01 d0                	add    %edx,%eax
    e8d9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e8e0:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    e8e3:	8b 44 10 04          	mov    0x4(%eax,%edx,1),%eax
    e8e7:	40                   	inc    %eax
    e8e8:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    e8eb:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
    e8ee:	ff 00                	incl   (%eax)
    e8f0:	eb 87                	jmp    e879 <AckProof_findRight+0x23>
    }
  }
  if(cursor > start) 
    e8f2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e8f5:	3b 45 0c             	cmp    0xc(%ebp),%eax
    e8f8:	7e 09                	jle    e903 <AckProof_findRight+0xad>
	  return cursor - 1;
    e8fa:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e8fd:	48                   	dec    %eax
    e8fe:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    e901:	eb 07                	jmp    e90a <AckProof_findRight+0xb4>
  else
	  return start - 1; // error condition
    e903:	8b 45 0c             	mov    0xc(%ebp),%eax
    e906:	48                   	dec    %eax
    e907:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
}
    e90a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    e90d:	c9                   	leave  
    e90e:	c3                   	ret    

0000e90f <AckProof_findLeft>:

__u32 AckProof_findLeft(AckProof *proof, int start) {
    e90f:	55                   	push   %ebp
    e910:	89 e5                	mov    %esp,%ebp
    e912:	83 ec 1c             	sub    $0x1c,%esp
  int i;
  int cursor;
  int poisoned = 0;
    e915:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  Sack *sacks = proof->sacks;
    e91c:	8b 45 08             	mov    0x8(%ebp),%eax
    e91f:	83 c0 08             	add    $0x8,%eax
    e922:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  /* Check if AckProof covers the desired range */
  cursor = start;
    e925:	8b 45 0c             	mov    0xc(%ebp),%eax
    e928:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
  for(i=proof->numSacks - 1; i >= 0; i--) {
    e92b:	8b 45 08             	mov    0x8(%ebp),%eax
    e92e:	8b 00                	mov    (%eax),%eax
    e930:	48                   	dec    %eax
    e931:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    e934:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
    e938:	79 02                	jns    e93c <AckProof_findLeft+0x2d>
    e93a:	eb 6c                	jmp    e9a8 <AckProof_findLeft+0x99>
    if(Sack_contains(&sacks[i], cursor)) {
    e93c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e93f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    e943:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    e946:	89 d0                	mov    %edx,%eax
    e948:	01 c0                	add    %eax,%eax
    e94a:	01 d0                	add    %edx,%eax
    e94c:	c1 e0 02             	shl    $0x2,%eax
    e94f:	03 45 f0             	add    0xfffffff0(%ebp),%eax
    e952:	89 04 24             	mov    %eax,(%esp,1)
    e955:	e8 fc ff ff ff       	call   e956 <AckProof_findLeft+0x47>
    e95a:	85 c0                	test   %eax,%eax
    e95c:	74 43                	je     e9a1 <AckProof_findLeft+0x92>
      if(AckProof_isPoisoned(proof, &sacks[i])) {
    e95e:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    e961:	89 d0                	mov    %edx,%eax
    e963:	01 c0                	add    %eax,%eax
    e965:	01 d0                	add    %edx,%eax
    e967:	c1 e0 02             	shl    $0x2,%eax
    e96a:	03 45 f0             	add    0xfffffff0(%ebp),%eax
    e96d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    e971:	8b 45 08             	mov    0x8(%ebp),%eax
    e974:	89 04 24             	mov    %eax,(%esp,1)
    e977:	e8 fc ff ff ff       	call   e978 <AckProof_findLeft+0x69>
    e97c:	85 c0                	test   %eax,%eax
    e97e:	74 07                	je     e987 <AckProof_findLeft+0x78>
	poisoned = 1;
    e980:	c7 45 f4 01 00 00 00 	movl   $0x1,0xfffffff4(%ebp)
      }
      cursor = sacks[i].left - 1;
    e987:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    e98a:	89 d0                	mov    %edx,%eax
    e98c:	01 c0                	add    %eax,%eax
    e98e:	01 d0                	add    %edx,%eax
    e990:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e997:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    e99a:	8b 04 10             	mov    (%eax,%edx,1),%eax
    e99d:	48                   	dec    %eax
    e99e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    e9a1:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
    e9a4:	ff 08                	decl   (%eax)
    e9a6:	eb 8c                	jmp    e934 <AckProof_findLeft+0x25>
    }
  }
  if(cursor < start) 
    e9a8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e9ab:	3b 45 0c             	cmp    0xc(%ebp),%eax
    e9ae:	7d 09                	jge    e9b9 <AckProof_findLeft+0xaa>
	  return cursor + 1;
    e9b0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    e9b3:	40                   	inc    %eax
    e9b4:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    e9b7:	eb 07                	jmp    e9c0 <AckProof_findLeft+0xb1>
  else
	  return start + 1; // error condition
    e9b9:	8b 45 0c             	mov    0xc(%ebp),%eax
    e9bc:	40                   	inc    %eax
    e9bd:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
}
    e9c0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    e9c3:	c9                   	leave  
    e9c4:	c3                   	ret    

0000e9c5 <AckProof_dump>:

static int DoNormalStep(CONTINUATION_TYPE **cont, AckProof *ackProof, enum cminisock_event_tag event);
static int DoRecoveryStep(CONTINUATION_TYPE **cont, AckProof *ackProof, enum cminisock_event_tag event);
static int DoSlowStartStep(CONTINUATION_TYPE **cont, AckProof *ackProof, __u32 newBase, enum cminisock_event_tag event);

void AckProof_dump(AckProof *proof) {
    e9c5:	55                   	push   %ebp
    e9c6:	89 e5                	mov    %esp,%ebp
    e9c8:	83 ec 10             	sub    $0x10,%esp
	int i;
	printk("proof(%d) = ", proof->numSacks);
    e9cb:	8b 45 08             	mov    0x8(%ebp),%eax
    e9ce:	8b 00                	mov    (%eax),%eax
    e9d0:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    e9d4:	c7 04 24 15 46 00 00 	movl   $0x4615,(%esp,1)
    e9db:	e8 fc ff ff ff       	call   e9dc <AckProof_dump+0x17>
	for(i = 0; i < proof->numSacks; i++) {
    e9e0:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
    e9e7:	8b 55 08             	mov    0x8(%ebp),%edx
    e9ea:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
    e9ed:	3b 02                	cmp    (%edx),%eax
    e9ef:	7c 02                	jl     e9f3 <AckProof_dump+0x2e>
    e9f1:	eb 47                	jmp    ea3a <AckProof_dump+0x75>
		printk("[%d-%d]", proof->sacks[i].left, proof->sacks[i].right);
    e9f3:	8b 4d 08             	mov    0x8(%ebp),%ecx
    e9f6:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    e9f9:	89 d0                	mov    %edx,%eax
    e9fb:	01 c0                	add    %eax,%eax
    e9fd:	01 d0                	add    %edx,%eax
    e9ff:	c1 e0 02             	shl    $0x2,%eax
    ea02:	01 c8                	add    %ecx,%eax
    ea04:	83 c0 0c             	add    $0xc,%eax
    ea07:	8b 00                	mov    (%eax),%eax
    ea09:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    ea0d:	8b 4d 08             	mov    0x8(%ebp),%ecx
    ea10:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
    ea13:	89 d0                	mov    %edx,%eax
    ea15:	01 c0                	add    %eax,%eax
    ea17:	01 d0                	add    %edx,%eax
    ea19:	c1 e0 02             	shl    $0x2,%eax
    ea1c:	01 c8                	add    %ecx,%eax
    ea1e:	83 c0 08             	add    $0x8,%eax
    ea21:	8b 00                	mov    (%eax),%eax
    ea23:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ea27:	c7 04 24 22 46 00 00 	movl   $0x4622,(%esp,1)
    ea2e:	e8 fc ff ff ff       	call   ea2f <AckProof_dump+0x6a>
    ea33:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
    ea36:	ff 00                	incl   (%eax)
    ea38:	eb ad                	jmp    e9e7 <AckProof_dump+0x22>
	}
	printk("\n");
    ea3a:	c7 04 24 2a 46 00 00 	movl   $0x462a,(%esp,1)
    ea41:	e8 fc ff ff ff       	call   ea42 <AckProof_dump+0x7d>
}
    ea46:	c9                   	leave  
    ea47:	c3                   	ret    

0000ea48 <WireTrickleRequest_extract>:

WireTrickleRequest *WireTrickleRequest_extract(struct cminisock **msk, struct sk_buff *skb, int *error) {
    ea48:	55                   	push   %ebp
    ea49:	89 e5                	mov    %esp,%ebp
    ea4b:	53                   	push   %ebx
    ea4c:	83 ec 30             	sub    $0x30,%esp
	int sacks_len;
	WireTrickleRequest *req = (WireTrickleRequest*)skb->data;
    ea4f:	8b 45 0c             	mov    0xc(%ebp),%eax
    ea52:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
    ea58:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	*error = EINVAL;
    ea5b:	8b 45 10             	mov    0x10(%ebp),%eax
    ea5e:	c7 00 16 00 00 00    	movl   $0x16,(%eax)

	if(!pskb_may_pull(skb, sizeof(*req))) {
    ea64:	c7 44 24 04 4e 00 00 	movl   $0x4e,0x4(%esp,1)
    ea6b:	00 
    ea6c:	8b 45 0c             	mov    0xc(%ebp),%eax
    ea6f:	89 04 24             	mov    %eax,(%esp,1)
    ea72:	e8 8a 2a 00 00       	call   11501 <pskb_may_pull>
    ea77:	85 c0                	test   %eax,%eax
    ea79:	75 0c                	jne    ea87 <WireTrickleRequest_extract+0x3f>
		if(trickles_ratelimit()) {
			printk("SKB too short for WireTrickleRequest, len = %d\n", skb->len);
		}
		return NULL;
    ea7b:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
    ea82:	e9 23 05 00 00       	jmp    efaa <WireTrickleRequest_extract+0x562>
	}

	/* Now possible to decode msk */

	struct cminisock *lookup;
	__u32 seqno = ntohl(req->cont.seq);
    ea87:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    ea8a:	8b 40 02             	mov    0x2(%eax),%eax
    ea8d:	89 04 24             	mov    %eax,(%esp,1)
    ea90:	e8 fc ff ff ff       	call   ea91 <WireTrickleRequest_extract+0x49>
    ea95:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	struct sock *serverSK = (*msk)->serverSK;
    ea98:	8b 45 08             	mov    0x8(%ebp),%eax
    ea9b:	8b 00                	mov    (%eax),%eax
    ea9d:	8b 80 f8 00 00 00    	mov    0xf8(%eax),%eax
    eaa3:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
	if(!SIMULATION_MODE((*msk)->sk) && 
    eaa6:	8b 45 08             	mov    0x8(%ebp),%eax
    eaa9:	8b 00                	mov    (%eax),%eax
    eaab:	8b 40 20             	mov    0x20(%eax),%eax
    eaae:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    eab4:	83 e0 01             	and    $0x1,%eax
    eab7:	85 c0                	test   %eax,%eax
    eab9:	74 28                	je     eae3 <WireTrickleRequest_extract+0x9b>
    eabb:	8b 45 08             	mov    0x8(%ebp),%eax
    eabe:	8b 00                	mov    (%eax),%eax
    eac0:	8b 50 20             	mov    0x20(%eax),%edx
    eac3:	8b 45 08             	mov    0x8(%ebp),%eax
    eac6:	8b 00                	mov    (%eax),%eax
    eac8:	8b 40 20             	mov    0x20(%eax),%eax
    eacb:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    ead1:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
    ead7:	83 e0 08             	and    $0x8,%eax
    eada:	85 c0                	test   %eax,%eax
    eadc:	75 05                	jne    eae3 <WireTrickleRequest_extract+0x9b>
    eade:	e9 d0 01 00 00       	jmp    ecb3 <WireTrickleRequest_extract+0x26b>
    eae3:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    eaea:	0f 84 c3 01 00 00    	je     ecb3 <WireTrickleRequest_extract+0x26b>
	   sysctl_trickles_Continuation_enable) {
		if(( lookup = cminisock_lookup(serverSK, seqno)) != NULL) {
    eaf0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    eaf3:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    eaf7:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    eafa:	89 04 24             	mov    %eax,(%esp,1)
    eafd:	e8 fc ff ff ff       	call   eafe <WireTrickleRequest_extract+0xb6>
    eb02:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    eb05:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
    eb09:	0f 84 91 01 00 00    	je     eca0 <WireTrickleRequest_extract+0x258>
			struct WireContinuation *scont = &req->cont;
    eb0f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    eb12:	40                   	inc    %eax
    eb13:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)

			// Fields that may not propagate from the cache
			// seq, firstChild, clientState, parent, clientTimestamp

			lookup->seq = ntohl(scont->seq);
    eb16:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
    eb19:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    eb1c:	8b 40 01             	mov    0x1(%eax),%eax
    eb1f:	89 04 24             	mov    %eax,(%esp,1)
    eb22:	e8 fc ff ff ff       	call   eb23 <WireTrickleRequest_extract+0xdb>
    eb27:	89 43 30             	mov    %eax,0x30(%ebx)
			lookup->firstChild = scont->firstChild;
    eb2a:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    eb2d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    eb30:	0f b6 40 05          	movzbl 0x5(%eax),%eax
    eb34:	89 42 58             	mov    %eax,0x58(%edx)
			lookup->clientState = scont->clientState;
    eb37:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    eb3a:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    eb3d:	8b 40 09             	mov    0x9(%eax),%eax
    eb40:	89 42 38             	mov    %eax,0x38(%edx)
			lookup->parent = scont->parent;
    eb43:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    eb46:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    eb49:	8b 40 0d             	mov    0xd(%eax),%eax
    eb4c:	89 42 3c             	mov    %eax,0x3c(%edx)
			lookup->clientTimestamp = scont->clientTimestamp;
    eb4f:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    eb52:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    eb55:	8b 40 11             	mov    0x11(%eax),%eax
    eb58:	89 42 4c             	mov    %eax,0x4c(%edx)

			lookup->saddr = skb->nh.iph->daddr;
    eb5b:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    eb5e:	8b 45 0c             	mov    0xc(%ebp),%eax
    eb61:	8b 40 24             	mov    0x24(%eax),%eax
    eb64:	8b 40 10             	mov    0x10(%eax),%eax
    eb67:	89 42 14             	mov    %eax,0x14(%edx)
			lookup->daddr = skb->nh.iph->saddr;
    eb6a:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    eb6d:	8b 45 0c             	mov    0xc(%ebp),%eax
    eb70:	8b 40 24             	mov    0x24(%eax),%eax
    eb73:	8b 40 0c             	mov    0xc(%eax),%eax
    eb76:	89 42 18             	mov    %eax,0x18(%edx)
			lookup->source = skb->h.th->dest;
    eb79:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    eb7c:	8b 45 0c             	mov    0xc(%ebp),%eax
    eb7f:	8b 40 20             	mov    0x20(%eax),%eax
    eb82:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    eb86:	66 89 42 1c          	mov    %ax,0x1c(%edx)
			lookup->dest = skb->h.th->source;
    eb8a:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
    eb8d:	8b 45 0c             	mov    0xc(%ebp),%eax
    eb90:	8b 40 20             	mov    0x20(%eax),%eax
    eb93:	0f b7 00             	movzwl (%eax),%eax
    eb96:	66 89 42 1e          	mov    %ax,0x1e(%edx)

#if 1 // compare 
			struct cminisock *testmsk = 
    eb9a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    eb9d:	89 04 24             	mov    %eax,(%esp,1)
    eba0:	e8 fb 32 00 00       	call   11ea0 <alloc_trickles_msk>
    eba5:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
				alloc_trickles_msk(serverSK);
			if(unmarshallContinuationServer(skb, testmsk, &req->cont)) {
    eba8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    ebab:	40                   	inc    %eax
    ebac:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    ebb0:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    ebb3:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ebb7:	8b 45 0c             	mov    0xc(%ebp),%eax
    ebba:	89 04 24             	mov    %eax,(%esp,1)
    ebbd:	e8 d1 2d 00 00       	call   11993 <unmarshallContinuationServer>
    ebc2:	85 c0                	test   %eax,%eax
    ebc4:	74 1c                	je     ebe2 <WireTrickleRequest_extract+0x19a>
				byte_diff(testmsk, lookup, sizeof(*testmsk));
    ebc6:	c7 44 24 08 fc 00 00 	movl   $0xfc,0x8(%esp,1)
    ebcd:	00 
    ebce:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    ebd1:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ebd5:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    ebd8:	89 04 24             	mov    %eax,(%esp,1)
    ebdb:	e8 b5 35 00 00       	call   12195 <byte_diff>
    ebe0:	eb 0c                	jmp    ebee <WireTrickleRequest_extract+0x1a6>
#if 0
				DELAY();
				DELAY();
				DELAY();
				local_bh_disable();
				while(1);
				local_bh_enable();
#endif
			} else {
				printk("could not unmarshall for comparison\n");
    ebe2:	c7 04 24 40 46 00 00 	movl   $0x4640,(%esp,1)
    ebe9:	e8 fc ff ff ff       	call   ebea <WireTrickleRequest_extract+0x1a2>
			} 

			free_trickles_msk(serverSK, testmsk);
    ebee:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    ebf1:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ebf5:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    ebf8:	89 04 24             	mov    %eax,(%esp,1)
    ebfb:	e8 95 f2 ff ff       	call   de95 <free_trickles_msk>
			free_trickles_msk_finish(serverSK, testmsk);
    ec00:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    ec03:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ec07:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    ec0a:	89 04 24             	mov    %eax,(%esp,1)
    ec0d:	e8 21 f3 ff ff       	call   df33 <free_trickles_msk_finish>
#endif

#if 0 // lookup only
#if 0
			msk_release(serverSK, lookup);
#else
			free_trickles_msk(serverSK, lookup);
			free_trickles_msk_finish(serverSK, lookup);
#endif
			goto lookup_failed;
#endif // end lookup only

			//printk("found, serversk = %p, %p\n", serverSK, *msk);
			printk("found %d\n", seqno);
    ec12:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    ec15:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ec19:	c7 04 24 65 46 00 00 	movl   $0x4665,(%esp,1)
    ec20:	e8 fc ff ff ff       	call   ec21 <WireTrickleRequest_extract+0x1d9>
			//DELAY();
			free_trickles_msk(serverSK, *msk);
    ec25:	8b 45 08             	mov    0x8(%ebp),%eax
    ec28:	8b 00                	mov    (%eax),%eax
    ec2a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ec2e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    ec31:	89 04 24             	mov    %eax,(%esp,1)
    ec34:	e8 5c f2 ff ff       	call   de95 <free_trickles_msk>
			//printk("free\n");
			//DELAY();
			free_trickles_msk_finish(serverSK, *msk);
    ec39:	8b 45 08             	mov    0x8(%ebp),%eax
    ec3c:	8b 00                	mov    (%eax),%eax
    ec3e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ec42:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    ec45:	89 04 24             	mov    %eax,(%esp,1)
    ec48:	e8 e6 f2 ff ff       	call   df33 <free_trickles_msk_finish>
			//printk("finish\n");
			//DELAY();
			*msk = lookup;
    ec4d:	8b 55 08             	mov    0x8(%ebp),%edx
    ec50:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    ec53:	89 02                	mov    %eax,(%edx)
			BUG_TRAP((*msk)->ctl == ALLOC_PENDING);
    ec55:	8b 45 08             	mov    0x8(%ebp),%eax
    ec58:	8b 00                	mov    (%eax),%eax
    ec5a:	83 78 0c 02          	cmpl   $0x2,0xc(%eax)
    ec5e:	74 14                	je     ec74 <WireTrickleRequest_extract+0x22c>
    ec60:	c7 44 24 04 0f 02 00 	movl   $0x20f,0x4(%esp,1)
    ec67:	00 
    ec68:	c7 04 24 80 46 00 00 	movl   $0x4680,(%esp,1)
    ec6f:	e8 fc ff ff ff       	call   ec70 <WireTrickleRequest_extract+0x228>
			DELAY();
    ec74:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
    ec7b:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    ec7e:	3d ff c9 9a 3b       	cmp    $0x3b9ac9ff,%eax
    ec83:	7e 02                	jle    ec87 <WireTrickleRequest_extract+0x23f>
    ec85:	eb 09                	jmp    ec90 <WireTrickleRequest_extract+0x248>
    ec87:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    ec8a:	40                   	inc    %eax
    ec8b:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    ec8e:	eb eb                	jmp    ec7b <WireTrickleRequest_extract+0x233>

			(*msk)->serverSK = serverSK;
    ec90:	8b 45 08             	mov    0x8(%ebp),%eax
    ec93:	8b 10                	mov    (%eax),%edx
    ec95:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    ec98:	89 82 f8 00 00 00    	mov    %eax,0xf8(%edx)
    ec9e:	eb 3f                	jmp    ecdf <WireTrickleRequest_extract+0x297>
		} else {
			printk("couldn't find %d\n", seqno);
    eca0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    eca3:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    eca7:	c7 04 24 d2 46 00 00 	movl   $0x46d2,(%esp,1)
    ecae:	e8 fc ff ff ff       	call   ecaf <WireTrickleRequest_extract+0x267>
			// DELAY();
			goto lookup_failed;
		}
	} else {
	lookup_failed:
		if(!unmarshallContinuationServer(skb, *msk, &req->cont)) {
    ecb3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    ecb6:	40                   	inc    %eax
    ecb7:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    ecbb:	8b 45 08             	mov    0x8(%ebp),%eax
    ecbe:	8b 00                	mov    (%eax),%eax
    ecc0:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ecc4:	8b 45 0c             	mov    0xc(%ebp),%eax
    ecc7:	89 04 24             	mov    %eax,(%esp,1)
    ecca:	e8 c4 2c 00 00       	call   11993 <unmarshallContinuationServer>
    eccf:	85 c0                	test   %eax,%eax
    ecd1:	75 0c                	jne    ecdf <WireTrickleRequest_extract+0x297>
			/* MAC error */
			if(trickles_ratelimit())
				printk("Mac error\n");
			return NULL;
    ecd3:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
    ecda:	e9 cb 02 00 00       	jmp    efaa <WireTrickleRequest_extract+0x562>
		}
	}

	__skb_pull(skb, sizeof(*req));
    ecdf:	c7 44 24 04 4e 00 00 	movl   $0x4e,0x4(%esp,1)
    ece6:	00 
    ece7:	8b 45 0c             	mov    0xc(%ebp),%eax
    ecea:	89 04 24             	mov    %eax,(%esp,1)
    eced:	e8 b5 27 00 00       	call   114a7 <__skb_pull>
	/* Handle variable length fields */
	sacks_len = req->ackProof.numSacks * sizeof(WireSack);
    ecf2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    ecf5:	0f b6 50 4d          	movzbl 0x4d(%eax),%edx
    ecf9:	89 d0                	mov    %edx,%eax
    ecfb:	01 c0                	add    %eax,%eax
    ecfd:	01 d0                	add    %edx,%eax
    ecff:	c1 e0 02             	shl    $0x2,%eax
    ed02:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

	// 0714 MAXSACKS is appropriate here (e.g., NOT MAX_KERNEL_SACKS) because 
	// value comes from wire
	if(!(req->ackProof.numSacks <= MAXSACKS &&
    ed05:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    ed08:	80 78 4d 40          	cmpb   $0x40,0x4d(%eax)
    ed0c:	77 16                	ja     ed24 <WireTrickleRequest_extract+0x2dc>
    ed0e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    ed11:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ed15:	8b 45 0c             	mov    0xc(%ebp),%eax
    ed18:	89 04 24             	mov    %eax,(%esp,1)
    ed1b:	e8 e1 27 00 00       	call   11501 <pskb_may_pull>
    ed20:	85 c0                	test   %eax,%eax
    ed22:	75 18                	jne    ed3c <WireTrickleRequest_extract+0x2f4>
	     pskb_may_pull(skb, sacks_len))) {
		printk("SKB too short for WireTrickleRequest (either too many sacks, or not enough space in packet header for sacks\n");
    ed24:	c7 04 24 00 47 00 00 	movl   $0x4700,(%esp,1)
    ed2b:	e8 fc ff ff ff       	call   ed2c <WireTrickleRequest_extract+0x2e4>
		return NULL;
    ed30:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
    ed37:	e9 6e 02 00 00       	jmp    efaa <WireTrickleRequest_extract+0x562>
	}
	__skb_pull(skb, sacks_len);
    ed3c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    ed3f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ed43:	8b 45 0c             	mov    0xc(%ebp),%eax
    ed46:	89 04 24             	mov    %eax,(%esp,1)
    ed49:	e8 59 27 00 00       	call   114a7 <__skb_pull>

	(*msk)->ucont_len = ntohs(req->ucont_len);
    ed4e:	8b 45 08             	mov    0x8(%ebp),%eax
    ed51:	8b 18                	mov    (%eax),%ebx
    ed53:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    ed56:	0f b7 40 4b          	movzwl 0x4b(%eax),%eax
    ed5a:	89 04 24             	mov    %eax,(%esp,1)
    ed5d:	e8 fc ff ff ff       	call   ed5e <WireTrickleRequest_extract+0x316>
    ed62:	0f b7 c0             	movzwl %ax,%eax
    ed65:	89 43 78             	mov    %eax,0x78(%ebx)
	if(!pskb_may_pull(skb, (*msk)->ucont_len)) {
    ed68:	8b 45 08             	mov    0x8(%ebp),%eax
    ed6b:	8b 00                	mov    (%eax),%eax
    ed6d:	8b 40 78             	mov    0x78(%eax),%eax
    ed70:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ed74:	8b 45 0c             	mov    0xc(%ebp),%eax
    ed77:	89 04 24             	mov    %eax,(%esp,1)
    ed7a:	e8 82 27 00 00       	call   11501 <pskb_may_pull>
    ed7f:	85 c0                	test   %eax,%eax
    ed81:	75 18                	jne    ed9b <WireTrickleRequest_extract+0x353>
		printk("WireTrickleRequest_extract: skb too short for ucont\n");
    ed83:	c7 04 24 80 47 00 00 	movl   $0x4780,(%esp,1)
    ed8a:	e8 fc ff ff ff       	call   ed8b <WireTrickleRequest_extract+0x343>
		return NULL;
    ed8f:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
    ed96:	e9 0f 02 00 00       	jmp    efaa <WireTrickleRequest_extract+0x562>
	}
#if RECORD_UCONT_OFFSET
	(*msk)->ucont_offset = -1;
#endif
	if(!SIMULATION_MODE((*msk)->sk)) {
    ed9b:	8b 45 08             	mov    0x8(%ebp),%eax
    ed9e:	8b 00                	mov    (%eax),%eax
    eda0:	8b 40 20             	mov    0x20(%eax),%eax
    eda3:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    eda9:	83 e0 01             	and    $0x1,%eax
    edac:	85 c0                	test   %eax,%eax
    edae:	74 28                	je     edd8 <WireTrickleRequest_extract+0x390>
    edb0:	8b 45 08             	mov    0x8(%ebp),%eax
    edb3:	8b 00                	mov    (%eax),%eax
    edb5:	8b 50 20             	mov    0x20(%eax),%edx
    edb8:	8b 45 08             	mov    0x8(%ebp),%eax
    edbb:	8b 00                	mov    (%eax),%eax
    edbd:	8b 40 20             	mov    0x20(%eax),%eax
    edc0:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    edc6:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
    edcc:	83 e0 08             	and    $0x8,%eax
    edcf:	85 c0                	test   %eax,%eax
    edd1:	75 05                	jne    edd8 <WireTrickleRequest_extract+0x390>
    edd3:	e9 a4 00 00 00       	jmp    ee7c <WireTrickleRequest_extract+0x434>
		if((*msk)->ucont_len > 0) {
    edd8:	8b 45 08             	mov    0x8(%ebp),%eax
    eddb:	8b 00                	mov    (%eax),%eax
    eddd:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
    ede1:	0f 8e 87 00 00 00    	jle    ee6e <WireTrickleRequest_extract+0x426>
			(*msk)->ucont_data = tmalloc(skb->sk, (*msk)->ucont_len);
    ede7:	8b 45 08             	mov    0x8(%ebp),%eax
    edea:	8b 18                	mov    (%eax),%ebx
    edec:	8b 45 08             	mov    0x8(%ebp),%eax
    edef:	8b 00                	mov    (%eax),%eax
    edf1:	8b 40 78             	mov    0x78(%eax),%eax
    edf4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    edf8:	8b 45 0c             	mov    0xc(%ebp),%eax
    edfb:	8b 40 0c             	mov    0xc(%eax),%eax
    edfe:	89 04 24             	mov    %eax,(%esp,1)
    ee01:	e8 fc ff ff ff       	call   ee02 <WireTrickleRequest_extract+0x3ba>
    ee06:	89 43 7c             	mov    %eax,0x7c(%ebx)
			// printk("allocated ucont to %p\n", (*msk)->ucont_data);
			
			if((*msk)->ucont_data == NULL) {
    ee09:	8b 45 08             	mov    0x8(%ebp),%eax
    ee0c:	8b 00                	mov    (%eax),%eax
    ee0e:	83 78 7c 00          	cmpl   $0x0,0x7c(%eax)
    ee12:	75 15                	jne    ee29 <WireTrickleRequest_extract+0x3e1>
#if 0
				if(trickles_ratelimit()) {
					printk("WireTrickleRequest_extract: Out of memory while copying ucont\n");
				}
#endif
				*error = ENOMEM;
    ee14:	8b 45 10             	mov    0x10(%ebp),%eax
    ee17:	c7 00 0c 00 00 00    	movl   $0xc,(%eax)
				return NULL;
    ee1d:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
    ee24:	e9 81 01 00 00       	jmp    efaa <WireTrickleRequest_extract+0x562>
			}
			char *pkt_ucont_data;
			memcpy((*msk)->ucont_data, pkt_ucont_data = (char*)skb->data, (*msk)->ucont_len);
    ee29:	8b 45 08             	mov    0x8(%ebp),%eax
    ee2c:	8b 00                	mov    (%eax),%eax
    ee2e:	8b 40 78             	mov    0x78(%eax),%eax
    ee31:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    ee35:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee38:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
    ee3e:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    ee41:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ee45:	8b 45 08             	mov    0x8(%ebp),%eax
    ee48:	8b 00                	mov    (%eax),%eax
    ee4a:	8b 40 7c             	mov    0x7c(%eax),%eax
    ee4d:	89 04 24             	mov    %eax,(%esp,1)
    ee50:	e8 a2 25 00 00       	call   113f7 <__memcpy>
			__skb_pull(skb, (*msk)->ucont_len);
    ee55:	8b 45 08             	mov    0x8(%ebp),%eax
    ee58:	8b 00                	mov    (%eax),%eax
    ee5a:	8b 40 78             	mov    0x78(%eax),%eax
    ee5d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ee61:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee64:	89 04 24             	mov    %eax,(%esp,1)
    ee67:	e8 3b 26 00 00       	call   114a7 <__skb_pull>
    ee6c:	eb 26                	jmp    ee94 <WireTrickleRequest_extract+0x44c>

#ifdef RECORD_UCONT_OFFSET
			(*msk)->rcv_ucont_offset = skb->h.th->seq;
			(*msk)->ucont_offset = (char*)pkt_ucont_data - (char*)req;
#endif
		} else {
			(*msk)->ucont_data = NULL;
    ee6e:	8b 45 08             	mov    0x8(%ebp),%eax
    ee71:	8b 00                	mov    (%eax),%eax
    ee73:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
    ee7a:	eb 18                	jmp    ee94 <WireTrickleRequest_extract+0x44c>
		}
	} else {
		(*msk)->ucont_len = 0;
    ee7c:	8b 45 08             	mov    0x8(%ebp),%eax
    ee7f:	8b 00                	mov    (%eax),%eax
    ee81:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
		(*msk)->ucont_data = NULL;
    ee88:	8b 45 08             	mov    0x8(%ebp),%eax
    ee8b:	8b 00                	mov    (%eax),%eax
    ee8d:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	}

	BUG_TRAP(skb->len >= 0);
	if(!SIMULATION_MODE((*msk)->sk)) {
    ee94:	8b 45 08             	mov    0x8(%ebp),%eax
    ee97:	8b 00                	mov    (%eax),%eax
    ee99:	8b 40 20             	mov    0x20(%eax),%eax
    ee9c:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    eea2:	83 e0 01             	and    $0x1,%eax
    eea5:	85 c0                	test   %eax,%eax
    eea7:	74 28                	je     eed1 <WireTrickleRequest_extract+0x489>
    eea9:	8b 45 08             	mov    0x8(%ebp),%eax
    eeac:	8b 00                	mov    (%eax),%eax
    eeae:	8b 50 20             	mov    0x20(%eax),%edx
    eeb1:	8b 45 08             	mov    0x8(%ebp),%eax
    eeb4:	8b 00                	mov    (%eax),%eax
    eeb6:	8b 40 20             	mov    0x20(%eax),%eax
    eeb9:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    eebf:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
    eec5:	83 e0 08             	and    $0x8,%eax
    eec8:	85 c0                	test   %eax,%eax
    eeca:	75 05                	jne    eed1 <WireTrickleRequest_extract+0x489>
    eecc:	e9 ac 00 00 00       	jmp    ef7d <WireTrickleRequest_extract+0x535>
		(*msk)->input_len = skb->len;
    eed1:	8b 45 08             	mov    0x8(%ebp),%eax
    eed4:	8b 10                	mov    (%eax),%edx
    eed6:	8b 45 0c             	mov    0xc(%ebp),%eax
    eed9:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    eedf:	89 82 94 00 00 00    	mov    %eax,0x94(%edx)
		//printk("input len = %d @ %d\n", (*msk)->input_len, (char*)&(*msk)->input_len - (char*)(*msk));
		if((*msk)->input_len > 0) {
    eee5:	8b 45 08             	mov    0x8(%ebp),%eax
    eee8:	8b 00                	mov    (%eax),%eax
    eeea:	83 b8 94 00 00 00 00 	cmpl   $0x0,0x94(%eax)
    eef1:	7e 79                	jle    ef6c <WireTrickleRequest_extract+0x524>
			(*msk)->input = tmalloc(skb->sk, (*msk)->input_len);
    eef3:	8b 45 08             	mov    0x8(%ebp),%eax
    eef6:	8b 18                	mov    (%eax),%ebx
    eef8:	8b 45 08             	mov    0x8(%ebp),%eax
    eefb:	8b 00                	mov    (%eax),%eax
    eefd:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    ef03:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ef07:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef0a:	8b 40 0c             	mov    0xc(%eax),%eax
    ef0d:	89 04 24             	mov    %eax,(%esp,1)
    ef10:	e8 fc ff ff ff       	call   ef11 <WireTrickleRequest_extract+0x4c9>
    ef15:	89 83 98 00 00 00    	mov    %eax,0x98(%ebx)
			// printk("allocated input to %p\n", (*msk)->input);
			if((*msk)->input == NULL) {
    ef1b:	8b 45 08             	mov    0x8(%ebp),%eax
    ef1e:	8b 00                	mov    (%eax),%eax
    ef20:	83 b8 98 00 00 00 00 	cmpl   $0x0,0x98(%eax)
    ef27:	75 12                	jne    ef3b <WireTrickleRequest_extract+0x4f3>
#if 0
				if(trickles_ratelimit()) {
					printk("WireTrickleRequest_extract: Out of memory while copying Conversion data\n");
				}
#endif
				*error = ENOMEM;
    ef29:	8b 45 10             	mov    0x10(%ebp),%eax
    ef2c:	c7 00 0c 00 00 00    	movl   $0xc,(%eax)
				return NULL;
    ef32:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
    ef39:	eb 6f                	jmp    efaa <WireTrickleRequest_extract+0x562>
			}
			memcpy((*msk)->input, (char*)skb->data, (*msk)->input_len);
    ef3b:	8b 45 08             	mov    0x8(%ebp),%eax
    ef3e:	8b 00                	mov    (%eax),%eax
    ef40:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    ef46:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    ef4a:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef4d:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
    ef53:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    ef57:	8b 45 08             	mov    0x8(%ebp),%eax
    ef5a:	8b 00                	mov    (%eax),%eax
    ef5c:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
    ef62:	89 04 24             	mov    %eax,(%esp,1)
    ef65:	e8 8d 24 00 00       	call   113f7 <__memcpy>
    ef6a:	eb 2f                	jmp    ef9b <WireTrickleRequest_extract+0x553>
		} else {
			(*msk)->input = NULL;
    ef6c:	8b 45 08             	mov    0x8(%ebp),%eax
    ef6f:	8b 00                	mov    (%eax),%eax
    ef71:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
    ef78:	00 00 00 
    ef7b:	eb 1e                	jmp    ef9b <WireTrickleRequest_extract+0x553>
		}
	} else {
		(*msk)->input_len = 0;
    ef7d:	8b 45 08             	mov    0x8(%ebp),%eax
    ef80:	8b 00                	mov    (%eax),%eax
    ef82:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
    ef89:	00 00 00 
		(*msk)->input = NULL;
    ef8c:	8b 45 08             	mov    0x8(%ebp),%eax
    ef8f:	8b 00                	mov    (%eax),%eax
    ef91:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
    ef98:	00 00 00 
	}
	//printk("(*msk)->input_len = %d\n", (*msk)->input_len);
	*error = 0;
    ef9b:	8b 45 10             	mov    0x10(%ebp),%eax
    ef9e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return req;
    efa4:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    efa7:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
}
    efaa:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
    efad:	83 c4 30             	add    $0x30,%esp
    efb0:	5b                   	pop    %ebx
    efb1:	5d                   	pop    %ebp
    efb2:	c3                   	ret    

0000efb3 <DoUpcall>:

static inline void pre_init_sock(struct cminisock *msk, struct sk_buff *skb) {
	/* save the fields necessary for a later init_sock */
	if(!SIMULATION_MODE(msk->sk)) {
		msk->saddr = skb->nh.iph->daddr;
		msk->source = skb->h.th->dest;

		msk->daddr = skb->nh.iph->saddr;
		msk->dest = skb->h.th->source;
	}
}

#ifndef USERTEST
void DoUpcall(struct cminisock *msk, enum cminisock_event_tag event) {
    efb3:	55                   	push   %ebp
    efb4:	89 e5                	mov    %esp,%ebp
    efb6:	56                   	push   %esi
    efb7:	53                   	push   %ebx
    efb8:	83 ec 38             	sub    $0x38,%esp
	int i;
	struct NonceCtx ctx;
	if(!SIMULATION_MODE(msk->sk)) {
    efbb:	8b 45 08             	mov    0x8(%ebp),%eax
    efbe:	8b 40 20             	mov    0x20(%eax),%eax
    efc1:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    efc7:	83 e0 01             	and    $0x1,%eax
    efca:	85 c0                	test   %eax,%eax
    efcc:	74 24                	je     eff2 <DoUpcall+0x3f>
    efce:	8b 45 08             	mov    0x8(%ebp),%eax
    efd1:	8b 50 20             	mov    0x20(%eax),%edx
    efd4:	8b 45 08             	mov    0x8(%ebp),%eax
    efd7:	8b 40 20             	mov    0x20(%eax),%eax
    efda:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    efe0:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
    efe6:	83 e0 08             	and    $0x8,%eax
    efe9:	85 c0                	test   %eax,%eax
    efeb:	75 05                	jne    eff2 <DoUpcall+0x3f>
    efed:	e9 1d 01 00 00       	jmp    f10f <DoUpcall+0x15c>
		int responseLen = 0;
    eff2:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
		ctx.new = 1;
    eff9:	c7 45 d4 01 00 00 00 	movl   $0x1,0xffffffd4(%ebp)
		for(i=0; i < msk->num_packets; i++) {
    f000:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
    f007:	8b 55 08             	mov    0x8(%ebp),%edx
    f00a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    f00d:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
    f013:	7c 05                	jl     f01a <DoUpcall+0x67>
    f015:	e9 b2 00 00 00       	jmp    f0cc <DoUpcall+0x119>
			msk->packets[i].nonce = generateSingleNonce(msk->sk, msk->packets[i].seq, &ctx);
    f01a:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f01d:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    f020:	89 d0                	mov    %edx,%eax
    f022:	c1 e0 03             	shl    $0x3,%eax
    f025:	01 d0                	add    %edx,%eax
    f027:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    f02e:	8b b1 ec 00 00 00    	mov    0xec(%ecx),%esi
    f034:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
    f037:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    f03b:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f03e:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    f041:	89 d0                	mov    %edx,%eax
    f043:	c1 e0 03             	shl    $0x3,%eax
    f046:	01 d0                	add    %edx,%eax
    f048:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    f04f:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
    f055:	8b 44 10 04          	mov    0x4(%eax,%edx,1),%eax
    f059:	ba 00 00 00 00       	mov    $0x0,%edx
    f05e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f062:	89 54 24 08          	mov    %edx,0x8(%esp,1)
    f066:	8b 45 08             	mov    0x8(%ebp),%eax
    f069:	8b 40 20             	mov    0x20(%eax),%eax
    f06c:	89 04 24             	mov    %eax,(%esp,1)
    f06f:	e8 fc ff ff ff       	call   f070 <DoUpcall+0xbd>
    f074:	89 04 1e             	mov    %eax,(%esi,%ebx,1)
			msk->packets[i].ucontLen = 0;
    f077:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f07a:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    f07d:	89 d0                	mov    %edx,%eax
    f07f:	c1 e0 03             	shl    $0x3,%eax
    f082:	01 d0                	add    %edx,%eax
    f084:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    f08b:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
    f091:	c7 44 10 10 00 00 00 	movl   $0x0,0x10(%eax,%edx,1)
    f098:	00 
			msk->packets[i].ucontData = NULL;
    f099:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f09c:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    f09f:	89 d0                	mov    %edx,%eax
    f0a1:	c1 e0 03             	shl    $0x3,%eax
    f0a4:	01 d0                	add    %edx,%eax
    f0a6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    f0ad:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
    f0b3:	c7 44 10 14 00 00 00 	movl   $0x0,0x14(%eax,%edx,1)
    f0ba:	00 
#ifdef CHECK_MINRESPONSELEN
			responseLen += msk->packets[i].len;
#else
			// touch responseLen to suppress compiler warnings
			responseLen = 0;
    f0bb:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
    f0c2:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
    f0c5:	ff 00                	incl   (%eax)
    f0c7:	e9 3b ff ff ff       	jmp    f007 <DoUpcall+0x54>
#endif
		}
#ifdef CHECK_MINRESPONSELEN
		EQ_TEST(msk->simulationLen, responseLen);
		EQ_TEST(msk->simulationNumPackets, 
			msk->num_packets);
#if 0
		printk("len = %d,%d num_packets = %d,%d\n", 
		       msk->simulationLen, responseLen,
		       msk->simulationNumPackets, msk->num_packets);
#endif
#endif

		LOG_PACKET_CONTONLY(msk);
		
		queue_upcall_prealloc(msk->sk,event,msk);
    f0cc:	8b 45 08             	mov    0x8(%ebp),%eax
    f0cf:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    f0d3:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0d6:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f0da:	8b 45 08             	mov    0x8(%ebp),%eax
    f0dd:	8b 40 20             	mov    0x20(%eax),%eax
    f0e0:	89 04 24             	mov    %eax,(%esp,1)
    f0e3:	e8 fc ff ff ff       	call   f0e4 <DoUpcall+0x131>
		queue_upcall(event,msk);
    f0e8:	8b 45 08             	mov    0x8(%ebp),%eax
    f0eb:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f0ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0f2:	89 04 24             	mov    %eax,(%esp,1)
    f0f5:	e8 fc ff ff ff       	call   f0f6 <DoUpcall+0x143>
		queue_upcall_deliver(msk->sk,msk);
    f0fa:	8b 45 08             	mov    0x8(%ebp),%eax
    f0fd:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f101:	8b 45 08             	mov    0x8(%ebp),%eax
    f104:	8b 40 20             	mov    0x20(%eax),%eax
    f107:	89 04 24             	mov    %eax,(%esp,1)
    f10a:	e8 fc ff ff ff       	call   f10b <DoUpcall+0x158>
	}
 }
    f10f:	83 c4 38             	add    $0x38,%esp
    f112:	5b                   	pop    %ebx
    f113:	5e                   	pop    %esi
    f114:	5d                   	pop    %ebp
    f115:	c3                   	ret    

0000f116 <server_rcv_impl>:
#endif

static inline int doInitialCwnd(struct cminisock *msk, enum cminisock_event_tag tag, int seqno, int num_packets) {
	if(tag == SYN) {
		msk->ucont_len = 0;
		//printk("syn processing input_len = %d\n", msk->input_len);

		msk->clientState = 0;
		msk->mrtt = 0;

		// these values (firstLoss, firstBootstrapSeq) are not used in normal state ( syn/ack )
		msk->firstLoss = 0x1055;
		msk->firstBootstrapSeq = 0xb007;
		
		msk->ssthresh = 0x3fff; // small enough to prevent overflow when squaring
	}
	msk->TCPBase = seqno;

	if(!alloc_msk_packets(msk, num_packets)) {
		return -ENOMEM;
	}
	int i, first = 1;
	for(i=0; i < num_packets; i++) {
		__u32 seq = seqno + i;
		//printk("syn making seq %d\n", seq);
		makePacket(&msk->packets[i], seq, 1, TRICKLES_MSS, 
			   (first ? PTYPE_FIRST : 0) | PACKET_NORMAL, CONTTYPE_FULL1,
			   1 * TRICKLES_MSS,  -1, 1);
		first = 0;
	}
	msk->num_packets = num_packets;
	DoUpcall(msk, tag);
	return 0;
}

int server_rcv_impl(struct sock *sk, struct sk_buff *in_skb) {
    f116:	55                   	push   %ebp
    f117:	89 e5                	mov    %esp,%ebp
    f119:	53                   	push   %ebx
    f11a:	83 ec 2c             	sub    $0x2c,%esp
	int rval = -EINVAL;
    f11d:	c7 45 f8 ea ff ff ff 	movl   $0xffffffea,0xfffffff8(%ebp)
	struct tcphdr *ith = in_skb->h.th;
    f124:	8b 45 0c             	mov    0xc(%ebp),%eax
    f127:	8b 40 20             	mov    0x20(%eax),%eax
    f12a:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
    f12d:	8b 45 08             	mov    0x8(%ebp),%eax
    f130:	05 bc 00 00 00       	add    $0xbc,%eax
    f135:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	struct cminisock *msk;

	if(0 && !SIMULATION_MODE(sk)) {
		static int count;
		printk("server_rcv_impl: %d\n", count++);
	}

	TIMING_CTX_DEF0("server_rcv_impl", "");
	TIMING_CTX_DEF1(4);
	reinitTimingCtx(&ctx);
	recordSample(&ctx,0);

	if(!SIMULATION_MODE(sk) && !TRICKLES_USERAPI_CONFIGURED_TP(tp)) {
    f138:	8b 45 08             	mov    0x8(%ebp),%eax
    f13b:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    f141:	83 e0 01             	and    $0x1,%eax
    f144:	85 c0                	test   %eax,%eax
    f146:	74 1b                	je     f163 <server_rcv_impl+0x4d>
    f148:	8b 55 08             	mov    0x8(%ebp),%edx
    f14b:	8b 45 08             	mov    0x8(%ebp),%eax
    f14e:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    f154:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
    f15a:	83 e0 08             	and    $0x8,%eax
    f15d:	85 c0                	test   %eax,%eax
    f15f:	75 02                	jne    f163 <server_rcv_impl+0x4d>
    f161:	eb 1d                	jmp    f180 <server_rcv_impl+0x6a>
    f163:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    f166:	83 b8 d0 01 00 00 00 	cmpl   $0x0,0x1d0(%eax)
    f16d:	75 11                	jne    f180 <server_rcv_impl+0x6a>
		printk("Not configured\n");
    f16f:	c7 04 24 b5 47 00 00 	movl   $0x47b5,(%esp,1)
    f176:	e8 fc ff ff ff       	call   f177 <server_rcv_impl+0x61>
		goto out;
    f17b:	e9 62 02 00 00       	jmp    f3e2 <server_rcv_impl+0x2cc>
	}

	msk = alloc_trickles_msk(sk);
    f180:	8b 45 08             	mov    0x8(%ebp),%eax
    f183:	89 04 24             	mov    %eax,(%esp,1)
    f186:	e8 15 2d 00 00       	call   11ea0 <alloc_trickles_msk>
    f18b:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	msk->serverSK = sk;
    f18e:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    f191:	8b 45 08             	mov    0x8(%ebp),%eax
    f194:	89 82 f8 00 00 00    	mov    %eax,0xf8(%edx)

        if(msk == NULL) {
    f19a:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
    f19e:	75 05                	jne    f1a5 <server_rcv_impl+0x8f>
		if(trickles_ratelimit())
			printk("could not allocate minisock\n");
		goto out;
    f1a0:	e9 3d 02 00 00       	jmp    f3e2 <server_rcv_impl+0x2cc>
        }

	msk->sk = sk;
    f1a5:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    f1a8:	8b 45 08             	mov    0x8(%ebp),%eax
    f1ab:	89 42 20             	mov    %eax,0x20(%edx)
	in_skb->sk = sk;
    f1ae:	8b 55 0c             	mov    0xc(%ebp),%edx
    f1b1:	8b 45 08             	mov    0x8(%ebp),%eax
    f1b4:	89 42 0c             	mov    %eax,0xc(%edx)

	pre_init_sock(msk,in_skb);
    f1b7:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1ba:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f1be:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    f1c1:	89 04 24             	mov    %eax,(%esp,1)
    f1c4:	e8 cb 30 00 00       	call   12294 <pre_init_sock>

	recordSample(&ctx,0);
	if(SIMULATION_MODE(sk)) {
    f1c9:	8b 45 08             	mov    0x8(%ebp),%eax
    f1cc:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    f1d2:	83 e0 01             	and    $0x1,%eax
    f1d5:	85 c0                	test   %eax,%eax
    f1d7:	74 1e                	je     f1f7 <server_rcv_impl+0xe1>
    f1d9:	8b 55 08             	mov    0x8(%ebp),%edx
    f1dc:	8b 45 08             	mov    0x8(%ebp),%eax
    f1df:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    f1e5:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
    f1eb:	83 e0 08             	and    $0x8,%eax
    f1ee:	85 c0                	test   %eax,%eax
    f1f0:	75 05                	jne    f1f7 <server_rcv_impl+0xe1>
		goto normal;
    f1f2:	e9 93 01 00 00       	jmp    f38a <server_rcv_impl+0x274>
	}
	if(ith->syn) {
    f1f7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    f1fa:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    f1fe:	24 02                	and    $0x2,%al
    f200:	84 c0                	test   %al,%al
    f202:	0f 84 35 01 00 00    	je     f33d <server_rcv_impl+0x227>
		__u32 firstSeq;
		/* SYN packet format:
		 * Initial request continuation immediately follows TCP
		 * header
		 */
		if(ith->ack) {
    f208:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    f20b:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    f20f:	24 10                	and    $0x10,%al
    f211:	84 c0                	test   %al,%al
    f213:	74 0c                	je     f221 <server_rcv_impl+0x10b>
			printk("warning: trickles server cannot handle syn/ack\n");
    f215:	c7 04 24 e0 47 00 00 	movl   $0x47e0,(%esp,1)
    f21c:	e8 fc ff ff ff       	call   f21d <server_rcv_impl+0x107>
		}
		firstSeq = 1; // XXX Should be randomized
    f221:	c7 45 e8 01 00 00 00 	movl   $0x1,0xffffffe8(%ebp)

		msk->tokenCounterBase = tp->bigTokenCounter;
    f228:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
    f22b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    f22e:	8b 90 f4 01 00 00    	mov    0x1f4(%eax),%edx
    f234:	8b 80 f0 01 00 00    	mov    0x1f0(%eax),%eax
    f23a:	89 41 70             	mov    %eax,0x70(%ecx)
    f23d:	89 51 74             	mov    %edx,0x74(%ecx)
		tp->bigTokenCounter += ((__u64) 1)  << 32;
    f240:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
    f243:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    f246:	8b 90 f4 01 00 00    	mov    0x1f4(%eax),%edx
    f24c:	8b 80 f0 01 00 00    	mov    0x1f0(%eax),%eax
    f252:	83 c0 00             	add    $0x0,%eax
    f255:	83 d2 01             	adc    $0x1,%edx
    f258:	89 81 f0 01 00 00    	mov    %eax,0x1f0(%ecx)
    f25e:	89 91 f4 01 00 00    	mov    %edx,0x1f4(%ecx)

		int num_packets;

		msk->input_len = in_skb->len;
    f264:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    f267:	8b 45 0c             	mov    0xc(%ebp),%eax
    f26a:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    f270:	89 82 94 00 00 00    	mov    %eax,0x94(%edx)
		//printk("msk->input_len = %d\n", msk->input_len);
		if(msk->input_len > 0) {
    f276:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    f279:	83 b8 94 00 00 00 00 	cmpl   $0x0,0x94(%eax)
    f280:	7e 73                	jle    f2f5 <server_rcv_impl+0x1df>
			// piggybacked data
			msk->input = tmalloc(in_skb->sk, msk->input_len);
    f282:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
    f285:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    f288:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    f28e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f292:	8b 45 0c             	mov    0xc(%ebp),%eax
    f295:	8b 40 0c             	mov    0xc(%eax),%eax
    f298:	89 04 24             	mov    %eax,(%esp,1)
    f29b:	e8 fc ff ff ff       	call   f29c <server_rcv_impl+0x186>
    f2a0:	89 83 98 00 00 00    	mov    %eax,0x98(%ebx)
			// printk("allocated piggy input to %p\n", msk->input);
			if(msk->input == NULL) {
    f2a6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    f2a9:	83 b8 98 00 00 00 00 	cmpl   $0x0,0x98(%eax)
    f2b0:	75 05                	jne    f2b7 <server_rcv_impl+0x1a1>
				if(trickles_ratelimit()) {
					printk("Could not allocate memory for SYN, len = %d\n", msk->input_len);
				}
				goto out;
    f2b2:	e9 2b 01 00 00       	jmp    f3e2 <server_rcv_impl+0x2cc>
			}
			memcpy(msk->input, (char*)in_skb->data, msk->input_len);
    f2b7:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    f2ba:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    f2c0:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    f2c4:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2c7:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
    f2cd:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f2d1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    f2d4:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
    f2da:	89 04 24             	mov    %eax,(%esp,1)
    f2dd:	e8 15 21 00 00       	call   113f7 <__memcpy>
			num_packets = msk->startCwnd = INITIAL_CWND;
    f2e2:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    f2e5:	c7 40 64 03 00 00 00 	movl   $0x3,0x64(%eax)
    f2ec:	c7 45 e4 03 00 00 00 	movl   $0x3,0xffffffe4(%ebp)
    f2f3:	eb 1e                	jmp    f313 <server_rcv_impl+0x1fd>
		} else {
			// not piggybacked data
			msk->input = NULL;
    f2f5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    f2f8:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
    f2ff:	00 00 00 
			num_packets = 1;
    f302:	c7 45 e4 01 00 00 00 	movl   $0x1,0xffffffe4(%ebp)
			SET_DEFERRED_INITIALCWND(msk);
    f309:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    f30c:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
		}
		if(doInitialCwnd(msk, SYN, firstSeq, num_packets) != 0)
    f313:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
    f316:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    f31a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    f31d:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    f321:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    f328:	00 
    f329:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    f32c:	89 04 24             	mov    %eax,(%esp,1)
    f32f:	e8 d8 2f 00 00       	call   1230c <doInitialCwnd>
    f334:	85 c0                	test   %eax,%eax
    f336:	74 77                	je     f3af <server_rcv_impl+0x299>
			goto out;
    f338:	e9 a5 00 00 00       	jmp    f3e2 <server_rcv_impl+0x2cc>
	} else if(ith->fin) {
    f33d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    f340:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    f344:	24 01                	and    $0x1,%al
    f346:	84 c0                	test   %al,%al
    f348:	74 31                	je     f37b <server_rcv_impl+0x265>
		/* FIN packet format:
		   WireTrickleRequest */
		/* Sequence number generation */
		recordSample(&ctx,0);
		printk("FIN execute trickle\n");
    f34a:	c7 04 24 10 48 00 00 	movl   $0x4810,(%esp,1)
    f351:	e8 fc ff ff ff       	call   f352 <server_rcv_impl+0x23c>
		if((rval = ExecuteTrickle(&msk, in_skb, FIN))) {
    f356:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp,1)
    f35d:	00 
    f35e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f361:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f365:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
    f368:	89 04 24             	mov    %eax,(%esp,1)
    f36b:	e8 81 00 00 00       	call   f3f1 <ExecuteTrickle>
    f370:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    f373:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    f377:	74 36                	je     f3af <server_rcv_impl+0x299>
			goto out_dealloc_msk;
    f379:	eb 3d                	jmp    f3b8 <server_rcv_impl+0x2a2>
		}
	} else if(ith->rst) {
    f37b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    f37e:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    f382:	24 04                	and    $0x4,%al
    f384:	84 c0                	test   %al,%al
    f386:	74 02                	je     f38a <server_rcv_impl+0x274>
		/* TODO: Implement reset handling */
		goto out_dealloc_msk;	
    f388:	eb 2e                	jmp    f3b8 <server_rcv_impl+0x2a2>
	} else {
	normal:
		//printk("Normal execute trickle\n");
		/* normal operation */
		recordSample(&ctx,0);
		if((rval = ExecuteTrickle(&msk, in_skb, ACK))) {
    f38a:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp,1)
    f391:	00 
    f392:	8b 45 0c             	mov    0xc(%ebp),%eax
    f395:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f399:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
    f39c:	89 04 24             	mov    %eax,(%esp,1)
    f39f:	e8 4d 00 00 00       	call   f3f1 <ExecuteTrickle>
    f3a4:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    f3a7:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
    f3ab:	74 02                	je     f3af <server_rcv_impl+0x299>
			goto out_dealloc_msk;
    f3ad:	eb 09                	jmp    f3b8 <server_rcv_impl+0x2a2>
		}
	}
	recordSample(&ctx,0);
	//printTimings(&ctx);
	return 0;
    f3af:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
    f3b6:	eb 30                	jmp    f3e8 <server_rcv_impl+0x2d2>
 out_dealloc_msk:
	if(rval != -ENOMEM) {
    f3b8:	83 7d f8 f4          	cmpl   $0xfffffff4,0xfffffff8(%ebp)
    f3bc:	74 24                	je     f3e2 <server_rcv_impl+0x2cc>
		// ENOMEM deallocates msk in callees. This is a hostorical artifact
		free_trickles_msk(sk,msk);
    f3be:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    f3c1:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f3c5:	8b 45 08             	mov    0x8(%ebp),%eax
    f3c8:	89 04 24             	mov    %eax,(%esp,1)
    f3cb:	e8 c5 ea ff ff       	call   de95 <free_trickles_msk>
		free_trickles_msk_finish(sk,msk);
    f3d0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
    f3d3:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f3d7:	8b 45 08             	mov    0x8(%ebp),%eax
    f3da:	89 04 24             	mov    %eax,(%esp,1)
    f3dd:	e8 51 eb ff ff       	call   df33 <free_trickles_msk_finish>
	}
 out:
	return rval;
    f3e2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    f3e5:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
}
    f3e8:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    f3eb:	83 c4 2c             	add    $0x2c,%esp
    f3ee:	5b                   	pop    %ebx
    f3ef:	5d                   	pop    %ebp
    f3f0:	c3                   	ret    

0000f3f1 <ExecuteTrickle>:

#if 0
#define SIMULATIONMODE_INIT() int simPrintCount = 0
#define SIMULATIONMODE_PRINT() if(SIMULATION_MODE(skb->sk)) /*printk("simulation mode : %d\n", simPrintCount++)*/ 
#else
#define SIMULATIONMODE_INIT()
#define SIMULATIONMODE_PRINT()
#endif

#if 0
#define DUMP_INPUTLEN()   printk("cont input len = %d @ %s:%d\n", (*cont)->input_len, __FILE__, __LINE__)
#else
#define DUMP_INPUTLEN()
#endif

static int ExecuteTrickle(struct cminisock **cont, struct sk_buff *skb, enum cminisock_event_tag event) {
    f3f1:	55                   	push   %ebp
    f3f2:	89 e5                	mov    %esp,%ebp
    f3f4:	53                   	push   %ebx
    f3f5:	81 ec 48 03 00 00    	sub    $0x348,%esp
	//printk("executeTrickle ServerDebugLevel = %d\n", serverDebugLevel);
  int rval = -EINVAL;
    f3fb:	c7 45 f8 ea ff ff ff 	movl   $0xffffffea,0xfffffff8(%ebp)

  int error;
  AckProof ackProof;
  WireTrickleRequest *treq_hdr = WireTrickleRequest_extract(cont, skb, &error);
    f402:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
    f405:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    f409:	8b 45 0c             	mov    0xc(%ebp),%eax
    f40c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f410:	8b 45 08             	mov    0x8(%ebp),%eax
    f413:	89 04 24             	mov    %eax,(%esp,1)
    f416:	e8 fc ff ff ff       	call   f417 <ExecuteTrickle+0x26>
    f41b:	89 85 e0 fc ff ff    	mov    %eax,0xfffffce0(%ebp)
  enum CheckRangeResult rangeCheck;
  DUMP_INPUTLEN();

  SIMULATIONMODE_INIT();

  TIMING_CTX_DEF0("ExecuteTrickle", "");
  TIMING_CTX_DEF1(7);
  reinitTimingCtx(&ctx);
  recordSample(&ctx,0);
  (*cont)->executionTrace = 0;
    f421:	8b 45 08             	mov    0x8(%ebp),%eax
    f424:	8b 00                	mov    (%eax),%eax
    f426:	c7 80 dc 00 00 00 00 	movl   $0x0,0xdc(%eax)
    f42d:	00 00 00 

  if(treq_hdr == NULL) {
    f430:	83 bd e0 fc ff ff 00 	cmpl   $0x0,0xfffffce0(%ebp)
    f437:	75 3e                	jne    f477 <ExecuteTrickle+0x86>
    if(error == EINVAL) {
    f439:	83 7d f4 16          	cmpl   $0x16,0xfffffff4(%ebp)
    f43d:	75 0f                	jne    f44e <ExecuteTrickle+0x5d>
      if(trickles_ratelimit()) {
	printk("ExecuteTrickle: Could not find request header, or mac failed\n");
      }
      return -EINVAL;
    f43f:	c7 85 d4 fc ff ff ea 	movl   $0xffffffea,0xfffffcd4(%ebp)
    f446:	ff ff ff 
    f449:	e9 ea 05 00 00       	jmp    fa38 <ExecuteTrickle+0x647>
    } else {
      BUG_TRAP(error == ENOMEM);
    f44e:	83 7d f4 0c          	cmpl   $0xc,0xfffffff4(%ebp)
    f452:	74 14                	je     f468 <ExecuteTrickle+0x77>
    f454:	c7 44 24 04 5a 03 00 	movl   $0x35a,0x4(%esp,1)
    f45b:	00 
    f45c:	c7 04 24 40 48 00 00 	movl   $0x4840,(%esp,1)
    f463:	e8 fc ff ff ff       	call   f464 <ExecuteTrickle+0x73>
      return -ENOMEM;
    f468:	c7 85 d4 fc ff ff f4 	movl   $0xfffffff4,0xfffffcd4(%ebp)
    f46f:	ff ff ff 
    f472:	e9 c1 05 00 00       	jmp    fa38 <ExecuteTrickle+0x647>
    }
  }
  
#ifdef PROPAGATE_ACKSEQ
  if(!SIMULATION_MODE((*cont)->sk)) {
    f477:	8b 45 08             	mov    0x8(%ebp),%eax
    f47a:	8b 00                	mov    (%eax),%eax
    f47c:	8b 40 20             	mov    0x20(%eax),%eax
    f47f:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    f485:	83 e0 01             	and    $0x1,%eax
    f488:	85 c0                	test   %eax,%eax
    f48a:	74 25                	je     f4b1 <ExecuteTrickle+0xc0>
    f48c:	8b 45 08             	mov    0x8(%ebp),%eax
    f48f:	8b 00                	mov    (%eax),%eax
    f491:	8b 50 20             	mov    0x20(%eax),%edx
    f494:	8b 45 08             	mov    0x8(%ebp),%eax
    f497:	8b 00                	mov    (%eax),%eax
    f499:	8b 40 20             	mov    0x20(%eax),%eax
    f49c:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    f4a2:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
    f4a8:	83 e0 08             	and    $0x8,%eax
    f4ab:	85 c0                	test   %eax,%eax
    f4ad:	75 02                	jne    f4b1 <ExecuteTrickle+0xc0>
    f4af:	eb 24                	jmp    f4d5 <ExecuteTrickle+0xe4>
	  (*cont)->ack_seq = skb->h.th->ack_seq;
    f4b1:	8b 45 08             	mov    0x8(%ebp),%eax
    f4b4:	8b 10                	mov    (%eax),%edx
    f4b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4b9:	8b 40 20             	mov    0x20(%eax),%eax
    f4bc:	8b 40 08             	mov    0x8(%eax),%eax
    f4bf:	89 82 80 00 00 00    	mov    %eax,0x80(%edx)
#ifdef CHECK_MINRESPONSELEN
	DECODE_SIMULATION_RESULT(skb->h.th->seq,
				 &(*cont)->simulationLen,
				 &(*cont)->simulationNumPackets);
#endif
	  (*cont)->dbg_timestamp = jiffies;
    f4c5:	8b 45 08             	mov    0x8(%ebp),%eax
    f4c8:	8b 10                	mov    (%eax),%edx
    f4ca:	a1 00 00 00 00       	mov    0x0,%eax
    f4cf:	89 82 8c 00 00 00    	mov    %eax,0x8c(%edx)
  }
#endif

  recordSample(&ctx,0);
  SIMULATIONMODE_PRINT();
  unmarshallAckProof(&ackProof, &treq_hdr->ackProof);
    f4d5:	8b 85 e0 fc ff ff    	mov    0xfffffce0(%ebp),%eax
    f4db:	83 c0 4d             	add    $0x4d,%eax
    f4de:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f4e2:	8d 85 e4 fc ff ff    	lea    0xfffffce4(%ebp),%eax
    f4e8:	89 04 24             	mov    %eax,(%esp,1)
    f4eb:	e8 a3 27 00 00       	call   11c93 <unmarshallAckProof>
  DUMP_INPUTLEN();
  ackProof.cont = *cont;
    f4f0:	8b 45 08             	mov    0x8(%ebp),%eax
    f4f3:	8b 00                	mov    (%eax),%eax
    f4f5:	89 85 e8 fc ff ff    	mov    %eax,0xfffffce8(%ebp)
  recordSample(&ctx,0);
  if(!SIMULATION_MODE((*cont)->sk) && !AckProof_validate(&ackProof)) {
    f4fb:	8b 45 08             	mov    0x8(%ebp),%eax
    f4fe:	8b 00                	mov    (%eax),%eax
    f500:	8b 40 20             	mov    0x20(%eax),%eax
    f503:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    f509:	83 e0 01             	and    $0x1,%eax
    f50c:	85 c0                	test   %eax,%eax
    f50e:	74 25                	je     f535 <ExecuteTrickle+0x144>
    f510:	8b 45 08             	mov    0x8(%ebp),%eax
    f513:	8b 00                	mov    (%eax),%eax
    f515:	8b 50 20             	mov    0x20(%eax),%edx
    f518:	8b 45 08             	mov    0x8(%ebp),%eax
    f51b:	8b 00                	mov    (%eax),%eax
    f51d:	8b 40 20             	mov    0x20(%eax),%eax
    f520:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    f526:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
    f52c:	83 e0 08             	and    $0x8,%eax
    f52f:	85 c0                	test   %eax,%eax
    f531:	75 02                	jne    f535 <ExecuteTrickle+0x144>
    f533:	eb 68                	jmp    f59d <ExecuteTrickle+0x1ac>
    f535:	8d 85 e4 fc ff ff    	lea    0xfffffce4(%ebp),%eax
    f53b:	89 04 24             	mov    %eax,(%esp,1)
    f53e:	e8 fc ff ff ff       	call   f53f <ExecuteTrickle+0x14e>
    f543:	85 c0                	test   %eax,%eax
    f545:	75 56                	jne    f59d <ExecuteTrickle+0x1ac>
    /* Bad nonce, or doesn't start at TCPBase */
    if(SIMULATION_MODE(skb->sk)  && debugSimulation)
    f547:	8b 45 0c             	mov    0xc(%ebp),%eax
    f54a:	8b 40 0c             	mov    0xc(%eax),%eax
    f54d:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    f553:	83 e0 01             	and    $0x1,%eax
    f556:	85 c0                	test   %eax,%eax
    f558:	74 34                	je     f58e <ExecuteTrickle+0x19d>
    f55a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f55d:	8b 50 0c             	mov    0xc(%eax),%edx
    f560:	8b 45 0c             	mov    0xc(%ebp),%eax
    f563:	8b 40 0c             	mov    0xc(%eax),%eax
    f566:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
    f56c:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
    f572:	83 e0 08             	and    $0x8,%eax
    f575:	85 c0                	test   %eax,%eax
    f577:	75 15                	jne    f58e <ExecuteTrickle+0x19d>
    f579:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    f580:	74 0c                	je     f58e <ExecuteTrickle+0x19d>
      printk("ackproof validation failed\n");
    f582:	c7 04 24 85 48 00 00 	movl   $0x4885,(%esp,1)
    f589:	e8 fc ff ff ff       	call   f58a <ExecuteTrickle+0x199>
    return -EINVAL;
    f58e:	c7 85 d4 fc ff ff ea 	movl   $0xffffffea,0xfffffcd4(%ebp)
    f595:	ff ff ff 
    f598:	e9 9b 04 00 00       	jmp    fa38 <ExecuteTrickle+0x647>
  }

  SIMULATIONMODE_PRINT();
  recordSample(&ctx,0);
  if(serverDebugLevel >= 2) {
    f59d:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    f5a4:	7e 26                	jle    f5cc <ExecuteTrickle+0x1db>
    printk("Server processing: %u\n", (*cont)->seq);
    f5a6:	8b 45 08             	mov    0x8(%ebp),%eax
    f5a9:	8b 00                	mov    (%eax),%eax
    f5ab:	8b 40 30             	mov    0x30(%eax),%eax
    f5ae:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f5b2:	c7 04 24 a1 48 00 00 	movl   $0x48a1,(%esp,1)
    f5b9:	e8 fc ff ff ff       	call   f5ba <ExecuteTrickle+0x1c9>
    AckProof_dump(&ackProof);
    f5be:	8d 85 e4 fc ff ff    	lea    0xfffffce4(%ebp),%eax
    f5c4:	89 04 24             	mov    %eax,(%esp,1)
    f5c7:	e8 fc ff ff ff       	call   f5c8 <ExecuteTrickle+0x1d7>
  }

  /* Determine continuation mode */
  SIMULATIONMODE_PRINT();
  rangeCheck = AckProof_checkRange(&ackProof, (*cont)->TCPBase, (*cont)->seq);
    f5cc:	8b 45 08             	mov    0x8(%ebp),%eax
    f5cf:	8b 00                	mov    (%eax),%eax
    f5d1:	8b 40 30             	mov    0x30(%eax),%eax
    f5d4:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    f5d8:	8b 45 08             	mov    0x8(%ebp),%eax
    f5db:	8b 00                	mov    (%eax),%eax
    f5dd:	8b 40 6c             	mov    0x6c(%eax),%eax
    f5e0:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f5e4:	8d 85 e4 fc ff ff    	lea    0xfffffce4(%ebp),%eax
    f5ea:	89 04 24             	mov    %eax,(%esp,1)
    f5ed:	e8 fc ff ff ff       	call   f5ee <ExecuteTrickle+0x1fd>
    f5f2:	89 85 dc fc ff ff    	mov    %eax,0xfffffcdc(%ebp)
  recordSample(&ctx,0);

  //printk("RequestType %d\n", treq_hdr->type);
  switch((enum TrickleRequestType)treq_hdr->type) {
    f5f8:	8b 85 e0 fc ff ff    	mov    0xfffffce0(%ebp),%eax
    f5fe:	0f b6 00             	movzbl (%eax),%eax
    f601:	89 85 c4 fc ff ff    	mov    %eax,0xfffffcc4(%ebp)
    f607:	83 bd c4 fc ff ff 00 	cmpl   $0x0,0xfffffcc4(%ebp)
    f60e:	74 12                	je     f622 <ExecuteTrickle+0x231>
    f610:	83 bd c4 fc ff ff 01 	cmpl   $0x1,0xfffffcc4(%ebp)
    f617:	0f 84 4a 03 00 00    	je     f967 <ExecuteTrickle+0x576>
    f61d:	e9 01 04 00 00       	jmp    fa23 <ExecuteTrickle+0x632>
  case TREQ_NORMAL: {
    // mrtt_1 = mrtt_0 * 7/8 + delta * 1/8
    (*cont)->mrtt -= (*cont)->mrtt >> 3;
    f622:	8b 45 08             	mov    0x8(%ebp),%eax
    f625:	8b 18                	mov    (%eax),%ebx
    f627:	8b 45 08             	mov    0x8(%ebp),%eax
    f62a:	8b 08                	mov    (%eax),%ecx
    f62c:	8b 45 08             	mov    0x8(%ebp),%eax
    f62f:	8b 00                	mov    (%eax),%eax
    f631:	8b 40 50             	mov    0x50(%eax),%eax
    f634:	89 c2                	mov    %eax,%edx
    f636:	c1 ea 03             	shr    $0x3,%edx
    f639:	8b 41 50             	mov    0x50(%ecx),%eax
    f63c:	29 d0                	sub    %edx,%eax
    f63e:	89 43 50             	mov    %eax,0x50(%ebx)
    (*cont)->mrtt += jiffies - (*cont)->timestamp;
    f641:	8b 45 08             	mov    0x8(%ebp),%eax
    f644:	8b 18                	mov    (%eax),%ebx
    f646:	8b 45 08             	mov    0x8(%ebp),%eax
    f649:	8b 08                	mov    (%eax),%ecx
    f64b:	8b 45 08             	mov    0x8(%ebp),%eax
    f64e:	8b 10                	mov    (%eax),%edx
    f650:	a1 00 00 00 00       	mov    0x0,%eax
    f655:	2b 42 48             	sub    0x48(%edx),%eax
    f658:	03 41 50             	add    0x50(%ecx),%eax
    f65b:	89 43 50             	mov    %eax,0x50(%ebx)

#ifdef RTT_INCLUDES_USER
    UPDATE_TIMESTAMP(*cont);
    f65e:	8b 45 08             	mov    0x8(%ebp),%eax
    f661:	8b 10                	mov    (%eax),%edx
    f663:	a1 00 00 00 00       	mov    0x0,%eax
    f668:	89 42 48             	mov    %eax,0x48(%edx)
#endif

  DUMP_INPUTLEN();
    switch((*cont)->state) {
    f66b:	8b 45 08             	mov    0x8(%ebp),%eax
    f66e:	8b 00                	mov    (%eax),%eax
    f670:	8b 40 54             	mov    0x54(%eax),%eax
    f673:	89 85 c8 fc ff ff    	mov    %eax,0xfffffcc8(%ebp)
    f679:	83 bd c8 fc ff ff 01 	cmpl   $0x1,0xfffffcc8(%ebp)
    f680:	0f 84 ec 00 00 00    	je     f772 <ExecuteTrickle+0x381>
    f686:	83 bd c8 fc ff ff 01 	cmpl   $0x1,0xfffffcc8(%ebp)
    f68d:	72 12                	jb     f6a1 <ExecuteTrickle+0x2b0>
    f68f:	83 bd c8 fc ff ff 02 	cmpl   $0x2,0xfffffcc8(%ebp)
    f696:	0f 84 f6 00 00 00    	je     f792 <ExecuteTrickle+0x3a1>
    f69c:	e9 8e 03 00 00       	jmp    fa2f <ExecuteTrickle+0x63e>
    case CONT_NORMAL:
      if(serverDebugLevel >= 2)
    f6a1:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    f6a8:	7e 0c                	jle    f6b6 <ExecuteTrickle+0x2c5>
        printk("Normal request => Normal state\n");
    f6aa:	c7 04 24 c0 48 00 00 	movl   $0x48c0,(%esp,1)
    f6b1:	e8 fc ff ff ff       	call   f6b2 <ExecuteTrickle+0x2c1>
      switch(rangeCheck) {
    f6b6:	8b 85 dc fc ff ff    	mov    0xfffffcdc(%ebp),%eax
    f6bc:	89 85 d0 fc ff ff    	mov    %eax,0xfffffcd0(%ebp)
    f6c2:	83 bd d0 fc ff ff ff 	cmpl   $0xffffffff,0xfffffcd0(%ebp)
    f6c9:	0f 8c 60 03 00 00    	jl     fa2f <ExecuteTrickle+0x63e>
    f6cf:	83 bd d0 fc ff ff 00 	cmpl   $0x0,0xfffffcd0(%ebp)
    f6d6:	7e 47                	jle    f71f <ExecuteTrickle+0x32e>
    f6d8:	83 bd d0 fc ff ff 01 	cmpl   $0x1,0xfffffcd0(%ebp)
    f6df:	74 05                	je     f6e6 <ExecuteTrickle+0x2f5>
    f6e1:	e9 49 03 00 00       	jmp    fa2f <ExecuteTrickle+0x63e>
      case NORMALRANGE:
	if(serverDebugLevel >= 2)
    f6e6:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    f6ed:	7e 0c                	jle    f6fb <ExecuteTrickle+0x30a>
	  printk("  Normal Range\n");
    f6ef:	c7 04 24 e0 48 00 00 	movl   $0x48e0,(%esp,1)
    f6f6:	e8 fc ff ff ff       	call   f6f7 <ExecuteTrickle+0x306>
	SIMULATIONMODE_PRINT();
#ifdef STOMP_CONNECTIONS
#define STOMP()								\
	if(!SIMULATION_MODE(skb->sk) &&					\
           (*cont)->seq - (*cont)->TCPBase >= STOMP_CONNECTIONS) {	\
	/* if(trickles_ratelimit()) {				\
		  printk("Stomping connection from %X:%d\n", (*cont)->daddr, (*cont)->dest); \
	  } */							\
	  return -EINVAL;							\
	}
#else
#define STOMP()
#endif
        STOMP();
	rval = DoNormalStep(cont, &ackProof, event);
    f6fb:	8b 45 10             	mov    0x10(%ebp),%eax
    f6fe:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    f702:	8d 85 e4 fc ff ff    	lea    0xfffffce4(%ebp),%eax
    f708:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f70c:	8b 45 08             	mov    0x8(%ebp),%eax
    f70f:	89 04 24             	mov    %eax,(%esp,1)
    f712:	e8 8b 08 00 00       	call   ffa2 <DoNormalStep>
    f717:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	recordSample(&ctx,0);
	break;
    f71a:	e9 10 03 00 00       	jmp    fa2f <ExecuteTrickle+0x63e>
      case POISONEDRANGE:
      case BADRANGE:
	if(serverDebugLevel >= 2) {
    f71f:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
    f726:	7e 26                	jle    f74e <ExecuteTrickle+0x35d>
	  printk("  Bad or poisoned Range (ack # %u)\n", (*cont)->seq);
    f728:	8b 45 08             	mov    0x8(%ebp),%eax
    f72b:	8b 00                	mov    (%eax),%eax
    f72d:	8b 40 30             	mov    0x30(%eax),%eax
    f730:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f734:	c7 04 24 00 49 00 00 	movl   $0x4900,(%esp,1)
    f73b:	e8 fc ff ff ff       	call   f73c <ExecuteTrickle+0x34b>
	  AckProof_dump(&ackProof);
    f740:	8d 85 e4 fc ff ff    	lea    0xfffffce4(%ebp),%eax
    f746:	89 04 24             	mov    %eax,(%esp,1)
    f749:	e8 fc ff ff ff       	call   f74a <ExecuteTrickle+0x359>
	}
	rval = DoRecoveryStep(cont, &ackProof, event);
    f74e:	8b 45 10             	mov    0x10(%ebp),%eax
    f751:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    f755:	8d 85 e4 fc ff ff    	lea    0xfffffce4(%ebp),%eax
    f75b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f75f:	8b 45 08             	mov    0x8(%ebp),%eax
    f762:	89 04 24             	mov    %eax,(%esp,1)
    f765:	e8 5f 0d 00 00       	call   104c9 <DoRecoveryStep>
    f76a:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	break;
    f76d:	e9 bd 02 00 00       	jmp    fa2f <ExecuteTrickle+0x63e>
      }
      break;
    case CONT_RECOVERY:
      if(serverDebugLevel >= 1)
    f772:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    f779:	7e 0c                	jle    f787 <ExecuteTrickle+0x396>
	printk("Normal request => Recovery state\n");
    f77b:	c7 04 24 40 49 00 00 	movl   $0x4940,(%esp,1)
    f782:	e8 fc ff ff ff       	call   f783 <ExecuteTrickle+0x392>
      gNumRecoveryStates++;
    f787:	ff 05 00 00 00 00    	incl   0x0
      switch(rangeCheck) {
      default:
	// no action
	break;
      }
      break;
    f78d:	e9 9d 02 00 00       	jmp    fa2f <ExecuteTrickle+0x63e>
    case CONT_BOOTSTRAP:
      if(serverDebugLevel >= 1)
    f792:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    f799:	7e 0c                	jle    f7a7 <ExecuteTrickle+0x3b6>
	printk("Normal request => Bootstrap state\n");
    f79b:	c7 04 24 80 49 00 00 	movl   $0x4980,(%esp,1)
    f7a2:	e8 fc ff ff ff       	call   f7a3 <ExecuteTrickle+0x3b2>
      gNumBootstrapStates++;
    f7a7:	ff 05 00 00 00 00    	incl   0x0
      switch(rangeCheck) {
    f7ad:	8b 85 dc fc ff ff    	mov    0xfffffcdc(%ebp),%eax
    f7b3:	89 85 cc fc ff ff    	mov    %eax,0xfffffccc(%ebp)
    f7b9:	83 bd cc fc ff ff 00 	cmpl   $0x0,0xfffffccc(%ebp)
    f7c0:	0f 84 2a 01 00 00    	je     f8f0 <ExecuteTrickle+0x4ff>
    f7c6:	83 bd cc fc ff ff 00 	cmpl   $0x0,0xfffffccc(%ebp)
    f7cd:	7f 0e                	jg     f7dd <ExecuteTrickle+0x3ec>
    f7cf:	83 bd cc fc ff ff ff 	cmpl   $0xffffffff,0xfffffccc(%ebp)
    f7d6:	74 17                	je     f7ef <ExecuteTrickle+0x3fe>
    f7d8:	e9 6f 01 00 00       	jmp    f94c <ExecuteTrickle+0x55b>
    f7dd:	83 bd cc fc ff ff 01 	cmpl   $0x1,0xfffffccc(%ebp)
    f7e4:	0f 84 84 00 00 00    	je     f86e <ExecuteTrickle+0x47d>
    f7ea:	e9 5d 01 00 00       	jmp    f94c <ExecuteTrickle+0x55b>
      case POISONEDRANGE:
	if(serverDebugLevel >= 1)
    f7ef:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    f7f6:	7e 0c                	jle    f804 <ExecuteTrickle+0x413>
	  printk("  Poisoned Range\n");
    f7f8:	c7 04 24 a3 49 00 00 	movl   $0x49a3,(%esp,1)
    f7ff:	e8 fc ff ff ff       	call   f800 <ExecuteTrickle+0x40f>
	// check that poison is only during recovery interval
	if(!(AckProof_checkRange(&ackProof, (*cont)->TCPBase, (*cont)->firstLoss-1) == NORMALRANGE
    f804:	8b 45 08             	mov    0x8(%ebp),%eax
    f807:	8b 00                	mov    (%eax),%eax
    f809:	8b 40 5c             	mov    0x5c(%eax),%eax
    f80c:	48                   	dec    %eax
    f80d:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    f811:	8b 45 08             	mov    0x8(%ebp),%eax
    f814:	8b 00                	mov    (%eax),%eax
    f816:	8b 40 6c             	mov    0x6c(%eax),%eax
    f819:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f81d:	8d 85 e4 fc ff ff    	lea    0xfffffce4(%ebp),%eax
    f823:	89 04 24             	mov    %eax,(%esp,1)
    f826:	e8 fc ff ff ff       	call   f827 <ExecuteTrickle+0x436>
    f82b:	83 f8 01             	cmp    $0x1,%eax
    f82e:	75 2d                	jne    f85d <ExecuteTrickle+0x46c>
    f830:	8b 45 08             	mov    0x8(%ebp),%eax
    f833:	8b 00                	mov    (%eax),%eax
    f835:	8b 40 30             	mov    0x30(%eax),%eax
    f838:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    f83c:	8b 45 08             	mov    0x8(%ebp),%eax
    f83f:	8b 00                	mov    (%eax),%eax
    f841:	8b 40 60             	mov    0x60(%eax),%eax
    f844:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f848:	8d 85 e4 fc ff ff    	lea    0xfffffce4(%ebp),%eax
    f84e:	89 04 24             	mov    %eax,(%esp,1)
    f851:	e8 fc ff ff ff       	call   f852 <ExecuteTrickle+0x461>
    f856:	83 f8 01             	cmp    $0x1,%eax
    f859:	75 02                	jne    f85d <ExecuteTrickle+0x46c>
    f85b:	eb 11                	jmp    f86e <ExecuteTrickle+0x47d>
	     && AckProof_checkRange(&ackProof, (*cont)->firstBootstrapSeq, (*cont)->seq) == NORMALRANGE)) {
	  ERROR("poisoned packets where normal packets should be\n");
    f85d:	c7 04 24 c0 49 00 00 	movl   $0x49c0,(%esp,1)
    f864:	e8 fc ff ff ff       	call   f865 <ExecuteTrickle+0x474>
	  goto slow_start;
    f869:	e9 97 00 00 00       	jmp    f905 <ExecuteTrickle+0x514>
	}
      case NORMALRANGE:
	if(serverDebugLevel >= 1)
    f86e:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    f875:	7e 0c                	jle    f883 <ExecuteTrickle+0x492>
	  printk("  Normal Range\n");
    f877:	c7 04 24 e0 48 00 00 	movl   $0x48e0,(%esp,1)
    f87e:	e8 fc ff ff ff       	call   f87f <ExecuteTrickle+0x48e>
	(*cont)->TCPBase = (*cont)->firstBootstrapSeq;
    f883:	8b 45 08             	mov    0x8(%ebp),%eax
    f886:	8b 10                	mov    (%eax),%edx
    f888:	8b 45 08             	mov    0x8(%ebp),%eax
    f88b:	8b 00                	mov    (%eax),%eax
    f88d:	8b 40 60             	mov    0x60(%eax),%eax
    f890:	89 42 6c             	mov    %eax,0x6c(%edx)
	if(serverDebugLevel >= 1)
    f893:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    f89a:	7e 30                	jle    f8cc <ExecuteTrickle+0x4db>
	  printk("Bootstrap: TCPBase = %u CWND = %u SSTHRESH = %u\n", (*cont)->TCPBase, (*cont)->startCwnd, (*cont)->ssthresh);
    f89c:	8b 45 08             	mov    0x8(%ebp),%eax
    f89f:	8b 00                	mov    (%eax),%eax
    f8a1:	8b 40 68             	mov    0x68(%eax),%eax
    f8a4:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    f8a8:	8b 45 08             	mov    0x8(%ebp),%eax
    f8ab:	8b 00                	mov    (%eax),%eax
    f8ad:	8b 40 64             	mov    0x64(%eax),%eax
    f8b0:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    f8b4:	8b 45 08             	mov    0x8(%ebp),%eax
    f8b7:	8b 00                	mov    (%eax),%eax
    f8b9:	8b 40 6c             	mov    0x6c(%eax),%eax
    f8bc:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f8c0:	c7 04 24 00 4a 00 00 	movl   $0x4a00,(%esp,1)
    f8c7:	e8 fc ff ff ff       	call   f8c8 <ExecuteTrickle+0x4d7>
	STOMP();
	rval = DoNormalStep(cont, &ackProof, event);
    f8cc:	8b 45 10             	mov    0x10(%ebp),%eax
    f8cf:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    f8d3:	8d 85 e4 fc ff ff    	lea    0xfffffce4(%ebp),%eax
    f8d9:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f8dd:	8b 45 08             	mov    0x8(%ebp),%eax
    f8e0:	89 04 24             	mov    %eax,(%esp,1)
    f8e3:	e8 ba 06 00 00       	call   ffa2 <DoNormalStep>
    f8e8:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	break;
    f8eb:	e9 3f 01 00 00       	jmp    fa2f <ExecuteTrickle+0x63e>
      case BADRANGE:
	if(serverDebugLevel >= 1)
    f8f0:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    f8f7:	7e 0c                	jle    f905 <ExecuteTrickle+0x514>
	  printk("  Bad Range\n");
    f8f9:	c7 04 24 31 4a 00 00 	movl   $0x4a31,(%esp,1)
    f900:	e8 fc ff ff ff       	call   f901 <ExecuteTrickle+0x510>
      slow_start:
	if(serverDebugLevel >= 1) {
    f905:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    f90c:	7e 1a                	jle    f928 <ExecuteTrickle+0x537>
		printk("slow start bad range: ");
    f90e:	c7 04 24 3e 4a 00 00 	movl   $0x4a3e,(%esp,1)
    f915:	e8 fc ff ff ff       	call   f916 <ExecuteTrickle+0x525>
		AckProof_dump(&ackProof);
    f91a:	8d 85 e4 fc ff ff    	lea    0xfffffce4(%ebp),%eax
    f920:	89 04 24             	mov    %eax,(%esp,1)
    f923:	e8 fc ff ff ff       	call   f924 <ExecuteTrickle+0x533>
	}
	rval = DoRecoveryStep(cont, &ackProof, event);
    f928:	8b 45 10             	mov    0x10(%ebp),%eax
    f92b:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    f92f:	8d 85 e4 fc ff ff    	lea    0xfffffce4(%ebp),%eax
    f935:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f939:	8b 45 08             	mov    0x8(%ebp),%eax
    f93c:	89 04 24             	mov    %eax,(%esp,1)
    f93f:	e8 85 0b 00 00       	call   104c9 <DoRecoveryStep>
    f944:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	break;
    f947:	e9 e3 00 00 00       	jmp    fa2f <ExecuteTrickle+0x63e>
      default:
	printk("  unknown state\n");
    f94c:	c7 04 24 55 4a 00 00 	movl   $0x4a55,(%esp,1)
    f953:	e8 fc ff ff ff       	call   f954 <ExecuteTrickle+0x563>
	return -EINVAL;
    f958:	c7 85 d4 fc ff ff ea 	movl   $0xffffffea,0xfffffcd4(%ebp)
    f95f:	ff ff ff 
    f962:	e9 d1 00 00 00       	jmp    fa38 <ExecuteTrickle+0x647>
      }
      break;
    }
    break;
  }
  case TREQ_SLOWSTART: {
    __u32 seq;
    (*cont)->mrtt = (jiffies - (*cont)->timestamp) << 3;
    f967:	8b 45 08             	mov    0x8(%ebp),%eax
    f96a:	8b 08                	mov    (%eax),%ecx
    f96c:	8b 45 08             	mov    0x8(%ebp),%eax
    f96f:	8b 10                	mov    (%eax),%edx
    f971:	a1 00 00 00 00       	mov    0x0,%eax
    f976:	2b 42 48             	sub    0x48(%edx),%eax
    f979:	c1 e0 03             	shl    $0x3,%eax
    f97c:	89 41 50             	mov    %eax,0x50(%ecx)

#ifdef RTT_INCLUDES_USER
    UPDATE_TIMESTAMP(*cont);
    f97f:	8b 45 08             	mov    0x8(%ebp),%eax
    f982:	8b 10                	mov    (%eax),%edx
    f984:	a1 00 00 00 00       	mov    0x0,%eax
    f989:	89 42 48             	mov    %eax,0x48(%edx)
#endif

    if(serverDebugLevel >= 1) {
    f98c:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    f993:	7e 1a                	jle    f9af <ExecuteTrickle+0x5be>
      printk("Slow Start request => \n");
    f995:	c7 04 24 66 4a 00 00 	movl   $0x4a66,(%esp,1)
    f99c:	e8 fc ff ff ff       	call   f99d <ExecuteTrickle+0x5ac>
      AckProof_dump(&ackProof);
    f9a1:	8d 85 e4 fc ff ff    	lea    0xfffffce4(%ebp),%eax
    f9a7:	89 04 24             	mov    %eax,(%esp,1)
    f9aa:	e8 fc ff ff ff       	call   f9ab <ExecuteTrickle+0x5ba>
    }
    seq = AckProof_findRight(&ackProof, (*cont)->TCPBase);
    f9af:	8b 45 08             	mov    0x8(%ebp),%eax
    f9b2:	8b 00                	mov    (%eax),%eax
    f9b4:	8b 40 6c             	mov    0x6c(%eax),%eax
    f9b7:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    f9bb:	8d 85 e4 fc ff ff    	lea    0xfffffce4(%ebp),%eax
    f9c1:	89 04 24             	mov    %eax,(%esp,1)
    f9c4:	e8 fc ff ff ff       	call   f9c5 <ExecuteTrickle+0x5d4>
    f9c9:	89 85 d8 fc ff ff    	mov    %eax,0xfffffcd8(%ebp)
    if(seq < (*cont)->TCPBase) {
    f9cf:	8b 45 08             	mov    0x8(%ebp),%eax
    f9d2:	8b 10                	mov    (%eax),%edx
    f9d4:	8b 85 d8 fc ff ff    	mov    0xfffffcd8(%ebp),%eax
    f9da:	3b 42 6c             	cmp    0x6c(%edx),%eax
    f9dd:	73 18                	jae    f9f7 <ExecuteTrickle+0x606>
	    printk("  SlowStart: seq < (*cont)->TCPBase\n");
    f9df:	c7 04 24 80 4a 00 00 	movl   $0x4a80,(%esp,1)
    f9e6:	e8 fc ff ff ff       	call   f9e7 <ExecuteTrickle+0x5f6>
	    return -EINVAL;
    f9eb:	c7 85 d4 fc ff ff ea 	movl   $0xffffffea,0xfffffcd4(%ebp)
    f9f2:	ff ff ff 
    f9f5:	eb 41                	jmp    fa38 <ExecuteTrickle+0x647>
    }
    rval = DoSlowStartStep(cont, &ackProof, seq + 1, event);
    f9f7:	8b 45 10             	mov    0x10(%ebp),%eax
    f9fa:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    f9fe:	8b 85 d8 fc ff ff    	mov    0xfffffcd8(%ebp),%eax
    fa04:	40                   	inc    %eax
    fa05:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    fa09:	8d 85 e4 fc ff ff    	lea    0xfffffce4(%ebp),%eax
    fa0f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    fa13:	8b 45 08             	mov    0x8(%ebp),%eax
    fa16:	89 04 24             	mov    %eax,(%esp,1)
    fa19:	e8 3e 15 00 00       	call   10f5c <DoSlowStartStep>
    fa1e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    break;
    fa21:	eb 0c                	jmp    fa2f <ExecuteTrickle+0x63e>
  }
  default:
    printk("  unknown request type\n");
    fa23:	c7 04 24 a5 4a 00 00 	movl   $0x4aa5,(%esp,1)
    fa2a:	e8 fc ff ff ff       	call   fa2b <ExecuteTrickle+0x63a>
  }

  recordSample(&ctx,0);
  //printTimings(&ctx);
  return rval;
    fa2f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    fa32:	89 85 d4 fc ff ff    	mov    %eax,0xfffffcd4(%ebp)
}
    fa38:	8b 85 d4 fc ff ff    	mov    0xfffffcd4(%ebp),%eax
    fa3e:	81 c4 48 03 00 00    	add    $0x348,%esp
    fa44:	5b                   	pop    %ebx
    fa45:	5d                   	pop    %ebp
    fa46:	c3                   	ret    

0000fa47 <msk_transmit_skb>:

int msk_transmit_skb(struct cminisock *msk, struct sk_buff *skb, int packet_num) {
    fa47:	55                   	push   %ebp
    fa48:	89 e5                	mov    %esp,%ebp
    fa4a:	53                   	push   %ebx
    fa4b:	83 ec 58             	sub    $0x58,%esp
	//DO_SANITY_CHECK_MSK(msk);
	static int packetID = 0;

	int tcp_header_size;
	struct tcphdr *th;
	struct sock *sk;

#ifdef FORCE_MSK_TRANSMIT_REORDERING
	static struct sk_buff *reorder_skb = NULL;
#endif

#ifndef USERTEST
	struct tcp_func *af = &ipv4_specific;
    fa4e:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
#endif

	struct WireTrickleResponse *resp_hdr;
	int err;
	struct cminisock_packet *packet = &msk->packets[packet_num];
    fa55:	8b 4d 08             	mov    0x8(%ebp),%ecx
    fa58:	8b 55 10             	mov    0x10(%ebp),%edx
    fa5b:	89 d0                	mov    %edx,%eax
    fa5d:	c1 e0 03             	shl    $0x3,%eax
    fa60:	01 d0                	add    %edx,%eax
    fa62:	c1 e0 02             	shl    $0x2,%eax
    fa65:	03 81 ec 00 00 00    	add    0xec(%ecx),%eax
    fa6b:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
	int ucontLen = packet->ucontLen;
    fa6e:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    fa71:	8b 40 10             	mov    0x10(%eax),%eax
    fa74:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
	int origSkbLen = skb->len;
    fa77:	8b 45 0c             	mov    0xc(%ebp),%eax
    fa7a:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    fa80:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)

#ifdef SANITY_CHECK_RANGEHEADER
	//printk("sanity checking range header\n");
	int printedoutput = 0;
	static int lastChunkID = -999;
	if(dbgBadChunk && ucontLen == 0 && skb->len >= sizeof(struct DataChunk)) {
		struct DataChunk *chunk = (struct DataChunk*)skb->data;
		int dataLen = DATA_LEN(chunk);
		if(dataLen > skb->len) {
			printk("Warning: Data chunk length exceeds skb length\n");
			printk("Packet %d(%d : id=%d) Chunk ID %d lastChunkID = %d => length %d ", 
			       packet_num, skb->len, packetID, 
#ifdef CHUNKID
			       chunk->chunkID, 
#else
			       -1,
#endif
			       lastChunkID,
			       dataLen);
			printk("skb_len = %d type = %d\n", skb->len, packet->type);
			//hexdump(chunk, (char*)skb->tail - (char*)chunk);
		}
		//printk("Packet %d(%d : id=%d) Chunk ID %d => length %d\n", packet_num, skb->len, packetID, /* chunk->chunkID */ -1, dataLen);
		printedoutput = 1;
#ifdef CHUNKID
		lastChunkID = chunk->chunkID;
#endif
	}
	if(ucontLen > 0) {
		//printk("Packet id=%d: ucont_len = %d\n", packetID, ucontLen);
		printedoutput = 1;
	}
	if(dbgBadChunk && !printedoutput) {
		int inferred_type = msk->tag;
		printk("Packet id=%d: no output, len = %d, inferred_type = %d\n", packetID, skb->len, inferred_type);
	}
#endif

	//printk("msk_transmit ucontLen[%d] = %d\n", packet_num, ucontLen);

	sk = skb->sk = msk->sk;
    fa83:	8b 55 0c             	mov    0xc(%ebp),%edx
    fa86:	8b 45 08             	mov    0x8(%ebp),%eax
    fa89:	8b 40 20             	mov    0x20(%eax),%eax
    fa8c:	89 42 0c             	mov    %eax,0xc(%edx)
    fa8f:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

	//printk("msk_transmit_skb: skb len(%d) stcp len(%d)\n", skb->len, tcb->stcp_len);
	if(userapi_time_spew)
    fa92:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    fa99:	74 15                	je     fab0 <msk_transmit_skb+0x69>
		printk("transmit time: %lu\n", jiffies);
    fa9b:	a1 00 00 00 00       	mov    0x0,%eax
    faa0:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    faa4:	c7 04 24 bd 4a 00 00 	movl   $0x4abd,(%esp,1)
    faab:	e8 fc ff ff ff       	call   faac <msk_transmit_skb+0x65>
#ifndef RTT_INCLUDES_USER
	msk->timestamp = jiffies;
#endif

	/* UCONT handling */
	BUG_TRAP(ucontLen >= 0);
    fab0:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
    fab4:	79 14                	jns    faca <msk_transmit_skb+0x83>
    fab6:	c7 44 24 04 4a 04 00 	movl   $0x44a,0x4(%esp,1)
    fabd:	00 
    fabe:	c7 04 24 e0 4a 00 00 	movl   $0x4ae0,(%esp,1)
    fac5:	e8 fc ff ff ff       	call   fac6 <msk_transmit_skb+0x7f>
	if(ucontLen > 0) {
    faca:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
    face:	7e 36                	jle    fb06 <msk_transmit_skb+0xbf>
		if(packet->ucontData != NULL) {
    fad0:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    fad3:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
    fad7:	74 2d                	je     fb06 <msk_transmit_skb+0xbf>
			memcpy(skb_push(skb, ucontLen),
			       packet->ucontData, ucontLen);
    fad9:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    fadc:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    fae0:	8b 45 0c             	mov    0xc(%ebp),%eax
    fae3:	89 04 24             	mov    %eax,(%esp,1)
    fae6:	e8 4b 19 00 00       	call   11436 <skb_push>
    faeb:	89 c2                	mov    %eax,%edx
    faed:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
    faf0:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    faf4:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    faf7:	8b 40 14             	mov    0x14(%eax),%eax
    fafa:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    fafe:	89 14 24             	mov    %edx,(%esp,1)
    fb01:	e8 f1 18 00 00       	call   113f7 <__memcpy>
		} else {
			// Do nothing; already in the packet
		}
	}

	if(packet->contType & CONTTYPE_HASHCOMPRESSED) {
    fb06:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    fb09:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
    fb0d:	c0 e8 03             	shr    $0x3,%al
    fb10:	24 07                	and    $0x7,%al
    fb12:	24 80                	and    $0x80,%al
    fb14:	84 c0                	test   %al,%al
    fb16:	74 36                	je     fb4e <msk_transmit_skb+0x107>
#ifdef ENABLE_HASHCOMPRESS
		int fullType;
		struct WireContinuation *wcont;
		static struct WireContinuation scratch[NR_CPUS]; // avoid stack allocation (which risks stack overflow), and kmalloc, which is inefficient
		struct WireContinuation *wc_scratch = &scratch[smp_processor_id()];

		resp_hdr = (WireTrickleResponse*)skb_push(skb, RESPONSELEN_HASHCOMPRESS);
		wcont = &resp_hdr->cont;
		
		/* mask off hashcompressed bit to verify type */
		packet->contType &= ~CONTTYPE_HASHCOMPRESSED;
		fullType = packet->contType == CONTTYPE_FULL1 ||
			packet->contType == CONTTYPE_FULL2;
		BUG_TRAP(fullType ||
			 packet->contType == CONTTYPE_MINIMAL);
		// restore hashcompressed bit
		packet->contType |= CONTTYPE_HASHCOMPRESSED;

		wcont->continuationType = packet->contType;
		wcont->hash.timestamp = htonl(msk->timestamp);
		wcont->hash.mrtt = htonl(msk->mrtt);
		wcont->hash.parentSeq = msk->seq;
		wcont->hash.clientState = msk->clientState;
		wcont->hash.position = packet_num;

		// marshall continuation to get mac value
		if(fullType) {
			// do this for all "FULL" continuation types
			packet->contType &= ~CONTTYPE_HASHCOMPRESSED;
			marshallContinuationServer(sk, wc_scratch, msk, packet_num);
			packet->contType |= CONTTYPE_HASHCOMPRESSED;

			memcpy(wcont->hash.mac, wc_scratch->mac, HMACLEN);
		}
#else
		printk("msk_transmit_skb: hash compress not enabled\n");
    fb18:	c7 04 24 40 4b 00 00 	movl   $0x4b40,(%esp,1)
    fb1f:	e8 fc ff ff ff       	call   fb20 <msk_transmit_skb+0xd9>
		BUG();
    fb24:	c7 44 24 04 19 45 00 	movl   $0x4519,0x4(%esp,1)
    fb2b:	00 
    fb2c:	c7 04 24 1d 45 00 00 	movl   $0x451d,(%esp,1)
    fb33:	e8 fc ff ff ff       	call   fb34 <msk_transmit_skb+0xed>
    fb38:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    fb3f:	e8 fc ff ff ff       	call   fb40 <msk_transmit_skb+0xf9>
    fb44:	e8 fc ff ff ff       	call   fb45 <msk_transmit_skb+0xfe>
    fb49:	e9 4a 01 00 00       	jmp    fc98 <msk_transmit_skb+0x251>
#endif
	} else {
		//printk("%d:msk_transmit_skb(%d), %d\n", (int)jiffies, skb->len, packet->seq);
		switch(packet->contType) {
    fb4e:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    fb51:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
    fb55:	c0 e8 03             	shr    $0x3,%al
    fb58:	24 07                	and    $0x7,%al
    fb5a:	0f b6 c0             	movzbl %al,%eax
    fb5d:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
    fb60:	83 7d d0 00          	cmpl   $0x0,0xffffffd0(%ebp)
    fb64:	74 16                	je     fb7c <msk_transmit_skb+0x135>
    fb66:	83 7d d0 00          	cmpl   $0x0,0xffffffd0(%ebp)
    fb6a:	0f 88 fc 00 00 00    	js     fc6c <msk_transmit_skb+0x225>
    fb70:	83 7d d0 02          	cmpl   $0x2,0xffffffd0(%ebp)
    fb74:	0f 8f f2 00 00 00    	jg     fc6c <msk_transmit_skb+0x225>
    fb7a:	eb 5a                	jmp    fbd6 <msk_transmit_skb+0x18f>
		case CONTTYPE_MINIMAL:
			resp_hdr = (WireTrickleResponse*)skb_push(skb, RESPONSELEN_MINIMAL);
    fb7c:	c7 44 24 04 1d 00 00 	movl   $0x1d,0x4(%esp,1)
    fb83:	00 
    fb84:	8b 45 0c             	mov    0xc(%ebp),%eax
    fb87:	89 04 24             	mov    %eax,(%esp,1)
    fb8a:	e8 a7 18 00 00       	call   11436 <skb_push>
    fb8f:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
			resp_hdr->cont.seq = htonl(packet->seq);
    fb92:	8b 5d e8             	mov    0xffffffe8(%ebp),%ebx
    fb95:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    fb98:	8b 40 04             	mov    0x4(%eax),%eax
    fb9b:	89 04 24             	mov    %eax,(%esp,1)
    fb9e:	e8 fc ff ff ff       	call   fb9f <msk_transmit_skb+0x158>
    fba3:	89 43 09             	mov    %eax,0x9(%ebx)
			resp_hdr->cont.continuationType = CONTTYPE_MINIMAL;
    fba6:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    fba9:	c6 40 08 00          	movb   $0x0,0x8(%eax)
			resp_hdr->cont.clientState = msk->clientState;
    fbad:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    fbb0:	8b 45 08             	mov    0x8(%ebp),%eax
    fbb3:	8b 40 38             	mov    0x38(%eax),%eax
    fbb6:	89 42 11             	mov    %eax,0x11(%edx)
			resp_hdr->cont.parent = msk->parent;
    fbb9:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    fbbc:	8b 45 08             	mov    0x8(%ebp),%eax
    fbbf:	8b 40 3c             	mov    0x3c(%eax),%eax
    fbc2:	89 42 15             	mov    %eax,0x15(%edx)
			resp_hdr->cont.clientTimestamp = msk->clientTimestamp;
    fbc5:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    fbc8:	8b 45 08             	mov    0x8(%ebp),%eax
    fbcb:	8b 40 4c             	mov    0x4c(%eax),%eax
    fbce:	89 42 19             	mov    %eax,0x19(%edx)
			break;
    fbd1:	e9 c2 00 00 00       	jmp    fc98 <msk_transmit_skb+0x251>
		case CONTTYPE_FULL1:
		case CONTTYPE_FULL2:
			/* Generate Trickle header */
			resp_hdr = (WireTrickleResponse*)skb_push(skb, sizeof(WireTrickleResponse));
    fbd6:	c7 44 24 04 52 00 00 	movl   $0x52,0x4(%esp,1)
    fbdd:	00 
    fbde:	8b 45 0c             	mov    0xc(%ebp),%eax
    fbe1:	89 04 24             	mov    %eax,(%esp,1)
    fbe4:	e8 4d 18 00 00       	call   11436 <skb_push>
    fbe9:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
			marshallContinuationServer(sk, &resp_hdr->cont, msk, packet_num);
    fbec:	8b 45 10             	mov    0x10(%ebp),%eax
    fbef:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    fbf3:	8b 45 08             	mov    0x8(%ebp),%eax
    fbf6:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    fbfa:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    fbfd:	83 c0 08             	add    $0x8,%eax
    fc00:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    fc04:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    fc07:	89 04 24             	mov    %eax,(%esp,1)
    fc0a:	e8 40 1b 00 00       	call   1174f <marshallContinuationServer>
			printk("sent seq %d\n", ntohl(resp_hdr->cont.seq));
    fc0f:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
    fc12:	8b 40 09             	mov    0x9(%eax),%eax
    fc15:	89 04 24             	mov    %eax,(%esp,1)
    fc18:	e8 fc ff ff ff       	call   fc19 <msk_transmit_skb+0x1d2>
    fc1d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    fc21:	c7 04 24 6d 4b 00 00 	movl   $0x4b6d,(%esp,1)
    fc28:	e8 fc ff ff ff       	call   fc29 <msk_transmit_skb+0x1e2>
	// Insert continuation into continuation cache

	/* NOTE:
	   The design here is a bit tricky.
	   
	   We want to reuse the existing msk where possible.  However,
	   we need to keep it unmodified until we're completely done
	   generating results. We record some position where the recycled
	   msk should be used (cacheRecycleIndex), and patch this up
	   in the caller (the {f,t}iov handler)
	*/
			if(sysctl_trickles_Continuation_enable) {
    fc2d:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    fc34:	74 62                	je     fc98 <msk_transmit_skb+0x251>
				if(HAS_VALID_CACHERECYCLEINDEX(msk)) {
    fc36:	8b 45 08             	mov    0x8(%ebp),%eax
    fc39:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)
    fc40:	78 1c                	js     fc5e <msk_transmit_skb+0x217>
					cminisock_cache_child(msk, packet_num, CACHE_CHILD_COPY | CACHE_CHILD_CLEAR);
    fc42:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp,1)
    fc49:	00 
    fc4a:	8b 45 10             	mov    0x10(%ebp),%eax
    fc4d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    fc51:	8b 45 08             	mov    0x8(%ebp),%eax
    fc54:	89 04 24             	mov    %eax,(%esp,1)
    fc57:	e8 fc ff ff ff       	call   fc58 <msk_transmit_skb+0x211>
    fc5c:	eb 3a                	jmp    fc98 <msk_transmit_skb+0x251>
				} else {
					// delay reuse until later
					msk->cacheRecycleIndex = packet_num;
    fc5e:	8b 55 08             	mov    0x8(%ebp),%edx
    fc61:	8b 45 10             	mov    0x10(%ebp),%eax
    fc64:	89 82 f4 00 00 00    	mov    %eax,0xf4(%edx)
				}
			}
			break;
    fc6a:	eb 2c                	jmp    fc98 <msk_transmit_skb+0x251>
		default:
			resp_hdr = NULL;
    fc6c:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
			BUG();
    fc73:	c7 44 24 04 19 45 00 	movl   $0x4519,0x4(%esp,1)
    fc7a:	00 
    fc7b:	c7 04 24 1d 45 00 00 	movl   $0x451d,(%esp,1)
    fc82:	e8 fc ff ff ff       	call   fc83 <msk_transmit_skb+0x23c>
    fc87:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    fc8e:	e8 fc ff ff ff       	call   fc8f <msk_transmit_skb+0x248>
    fc93:	e8 fc ff ff ff       	call   fc94 <msk_transmit_skb+0x24d>
		}
	}
	resp_hdr->nonce = packet->nonce;
    fc98:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    fc9b:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    fc9e:	8b 00                	mov    (%eax),%eax
    fca0:	89 02                	mov    %eax,(%edx)

	resp_hdr->ucont_len = htons((short)ucontLen);
    fca2:	8b 5d e8             	mov    0xffffffe8(%ebp),%ebx
    fca5:	0f b7 45 dc          	movzwl 0xffffffdc(%ebp),%eax
    fca9:	89 04 24             	mov    %eax,(%esp,1)
    fcac:	e8 fc ff ff ff       	call   fcad <msk_transmit_skb+0x266>
    fcb1:	66 89 43 06          	mov    %ax,0x6(%ebx)
	//printk("resphdr->ucont_len = %d\n", resp_hdr->ucont_len);
	resp_hdr->numSiblings = packet->numSiblings;
    fcb5:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    fcb8:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    fcbb:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    fcbf:	88 42 04             	mov    %al,0x4(%edx)
	resp_hdr->position = packet->position;
    fcc2:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
    fcc5:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    fcc8:	0f b6 40 0e          	movzbl 0xe(%eax),%eax
    fccc:	88 42 05             	mov    %al,0x5(%edx)

	// ByteNum in data chunks are now constructed at user level
	// E.G., the chunk descriptors are inlined with the data

	//printk("transmit_skb - resp_hdr: %p, ucont_len\n", &resp_hdr->cont, ntohs(resp_hdr->ucont_len));

	tcp_header_size = sizeof(struct tcphdr) + TCPOLEN_TRICKLES;
    fccf:	c7 45 f8 18 00 00 00 	movl   $0x18,0xfffffff8(%ebp)
	th = (struct tcphdr *) skb_push(skb, tcp_header_size);
    fcd6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    fcd9:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    fcdd:	8b 45 0c             	mov    0xc(%ebp),%eax
    fce0:	89 04 24             	mov    %eax,(%esp,1)
    fce3:	e8 4e 17 00 00       	call   11436 <skb_push>
    fce8:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	skb->h.th = th;
    fceb:	8b 55 0c             	mov    0xc(%ebp),%edx
    fcee:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    fcf1:	89 42 20             	mov    %eax,0x20(%edx)
	th->source = sk->sport;
    fcf4:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    fcf7:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    fcfa:	0f b7 40 22          	movzwl 0x22(%eax),%eax
    fcfe:	66 89 02             	mov    %ax,(%edx)
	th->dest = msk->dest;
    fd01:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    fd04:	8b 45 08             	mov    0x8(%ebp),%eax
    fd07:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
    fd0b:	66 89 42 02          	mov    %ax,0x2(%edx)

	th->seq = htonl(msk->seq);
    fd0f:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
    fd12:	8b 45 08             	mov    0x8(%ebp),%eax
    fd15:	8b 40 30             	mov    0x30(%eax),%eax
    fd18:	89 04 24             	mov    %eax,(%esp,1)
    fd1b:	e8 fc ff ff ff       	call   fd1c <msk_transmit_skb+0x2d5>
    fd20:	89 43 04             	mov    %eax,0x4(%ebx)

	// 0615 - mark each packet with a unique identifier so we know exactly how many packets were sent
	static int gSendPacketNumber = 0;
	// save debugging information
	if(sysctl_dbg_cwnd) {
    fd23:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
    fd2a:	74 6b                	je     fd97 <msk_transmit_skb+0x350>
		trickles_logCwnd_hook(CWND_RECORD, 
    fd2c:	8b 45 08             	mov    0x8(%ebp),%eax
    fd2f:	8b 40 50             	mov    0x50(%eax),%eax
    fd32:	89 44 24 24          	mov    %eax,0x24(%esp,1)
    fd36:	8b 45 08             	mov    0x8(%ebp),%eax
    fd39:	8b 40 50             	mov    0x50(%eax),%eax
    fd3c:	89 44 24 20          	mov    %eax,0x20(%esp,1)
    fd40:	8b 45 08             	mov    0x8(%ebp),%eax
    fd43:	8b 40 68             	mov    0x68(%eax),%eax
    fd46:	89 44 24 1c          	mov    %eax,0x1c(%esp,1)
    fd4a:	8b 45 08             	mov    0x8(%ebp),%eax
    fd4d:	8b 80 e4 00 00 00    	mov    0xe4(%eax),%eax
    fd53:	89 44 24 18          	mov    %eax,0x18(%esp,1)
    fd57:	8b 45 08             	mov    0x8(%ebp),%eax
    fd5a:	8b 40 64             	mov    0x64(%eax),%eax
    fd5d:	89 44 24 14          	mov    %eax,0x14(%esp,1)
    fd61:	a1 f8 00 00 00       	mov    0xf8,%eax
    fd66:	89 44 24 10          	mov    %eax,0x10(%esp,1)
    fd6a:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
    fd6d:	8b 40 04             	mov    0x4(%eax),%eax
    fd70:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
    fd74:	8b 45 08             	mov    0x8(%ebp),%eax
    fd77:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
    fd7b:	89 44 24 08          	mov    %eax,0x8(%esp,1)
    fd7f:	8b 45 08             	mov    0x8(%ebp),%eax
    fd82:	8b 40 18             	mov    0x18(%eax),%eax
    fd85:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    fd89:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
    fd90:	a1 00 00 00 00       	mov    0x0,%eax
    fd95:	ff d0                	call   *%eax
				      msk->daddr, msk->dest, packet->seq,
				      gSendPacketNumber,
				      msk->startCwnd, msk->mark /* effCwnd */, msk->ssthresh,
				      msk->mrtt, msk->mrtt);
	}
	th->ack_seq = packetID;
    fd97:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    fd9a:	a1 f4 00 00 00       	mov    0xf4,%eax
    fd9f:	89 42 08             	mov    %eax,0x8(%edx)
	//LOG_PACKET(sk, th->ack_seq);
	packetID++;
    fda2:	ff 05 f4 00 00 00    	incl   0xf4

	// set tcp header size and zero out flags 
	th->doff = tcp_header_size >> 2;
    fda8:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
    fdab:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
    fdae:	89 c2                	mov    %eax,%edx
    fdb0:	c1 fa 02             	sar    $0x2,%edx
    fdb3:	0f b6 41 0c          	movzbl 0xc(%ecx),%eax
    fdb7:	c0 e2 04             	shl    $0x4,%dl
    fdba:	24 0f                	and    $0xf,%al
    fdbc:	08 d0                	or     %dl,%al
    fdbe:	88 41 0c             	mov    %al,0xc(%ecx)
	th->res1= 0;
    fdc1:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
    fdc4:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
    fdc8:	24 f0                	and    $0xf0,%al
    fdca:	88 42 0c             	mov    %al,0xc(%edx)
	th->cwr = 0;
    fdcd:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    fdd0:	80 60 0d 7f          	andb   $0x7f,0xd(%eax)
	th->ece = 0;
    fdd4:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    fdd7:	80 60 0d bf          	andb   $0xbf,0xd(%eax)
	th->urg = 0;
    fddb:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    fdde:	80 60 0d df          	andb   $0xdf,0xd(%eax)

	th->ack = 1;
    fde2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    fde5:	80 48 0d 10          	orb    $0x10,0xd(%eax)
	th->psh = 0;
    fde9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    fdec:	80 60 0d f7          	andb   $0xf7,0xd(%eax)
	th->rst = 0;
    fdf0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    fdf3:	80 60 0d fb          	andb   $0xfb,0xd(%eax)
	th->syn = 0;
    fdf7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    fdfa:	80 60 0d fd          	andb   $0xfd,0xd(%eax)
	th->fin = 0;
    fdfe:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    fe01:	80 60 0d fe          	andb   $0xfe,0xd(%eax)

	// TODO: Find uses for window, urg_ptr fields
	th->window = 0;
    fe05:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    fe08:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%eax)
	th->check = 0;
    fe0e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    fe11:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
	th->urg_ptr = 0;
    fe17:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    fe1a:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
	*(__u32*)(th+1) = htonl((TCPOPT_TRICKLES << 24)  | 
    fe20:	8b 45 08             	mov    0x8(%ebp),%eax
    fe23:	0f b7 40 78          	movzwl 0x78(%eax),%eax
    fe27:	83 c0 52             	add    $0x52,%eax
    fe2a:	0f b7 c0             	movzwl %ax,%eax
    fe2d:	0d 00 00 04 0b       	or     $0xb040000,%eax
    fe32:	89 04 24             	mov    %eax,(%esp,1)
    fe35:	e8 fc ff ff ff       	call   fe36 <msk_transmit_skb+0x3ef>
    fe3a:	89 c2                	mov    %eax,%edx
    fe3c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    fe3f:	83 c0 14             	add    $0x14,%eax
    fe42:	89 10                	mov    %edx,(%eax)
				(TCPOLEN_TRICKLES << 16) |
				((__u16)(sizeof(WireTrickleResponse) + msk->ucont_len)));

	switch(msk->tag) {
    fe44:	8b 45 08             	mov    0x8(%ebp),%eax
    fe47:	8b 40 10             	mov    0x10(%eax),%eax
    fe4a:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    fe4d:	83 7d cc 01          	cmpl   $0x1,0xffffffcc(%ebp)
    fe51:	74 39                	je     fe8c <msk_transmit_skb+0x445>
    fe53:	83 7d cc 01          	cmpl   $0x1,0xffffffcc(%ebp)
    fe57:	72 08                	jb     fe61 <msk_transmit_skb+0x41a>
    fe59:	83 7d cc 02          	cmpl   $0x2,0xffffffcc(%ebp)
    fe5d:	74 18                	je     fe77 <msk_transmit_skb+0x430>
    fe5f:	eb 34                	jmp    fe95 <msk_transmit_skb+0x44e>
	case SYN:
		if(packet_num == 0) {
    fe61:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    fe65:	75 25                	jne    fe8c <msk_transmit_skb+0x445>
			th->syn = 1; // send syn/ack
    fe67:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    fe6a:	80 48 0d 02          	orb    $0x2,0xd(%eax)
			th->ack = 1;
    fe6e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    fe71:	80 48 0d 10          	orb    $0x10,0xd(%eax)
    fe75:	eb 2a                	jmp    fea1 <msk_transmit_skb+0x45a>
		} else {
			//printk("Not first packet of syn: %d\n", packet_num);
			goto ack;
		}
		break;
	case FIN:
		printk("sending fin\n");
    fe77:	c7 04 24 7a 4b 00 00 	movl   $0x4b7a,(%esp,1)
    fe7e:	e8 fc ff ff ff       	call   fe7f <msk_transmit_skb+0x438>
		th->fin = 1;
    fe83:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    fe86:	80 48 0d 01          	orb    $0x1,0xd(%eax)
		break;
    fe8a:	eb 15                	jmp    fea1 <msk_transmit_skb+0x45a>
	case ACK:
	ack:
		th->ack = 1;
    fe8c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
    fe8f:	80 48 0d 10          	orb    $0x10,0xd(%eax)
		break;
    fe93:	eb 0c                	jmp    fea1 <msk_transmit_skb+0x45a>
	default:
		printk("msk_transmit_skb: unsupported event tag\n");
    fe95:	c7 04 24 a0 4b 00 00 	movl   $0x4ba0,(%esp,1)
    fe9c:	e8 fc ff ff ff       	call   fe9d <msk_transmit_skb+0x456>
	}

	numTxPackets++;
    fea1:	83 05 00 00 00 00 01 	addl   $0x1,0x0
    fea8:	83 15 04 00 00 00 00 	adcl   $0x0,0x4
	numTxBytes += skb->len;
    feaf:	8b 45 0c             	mov    0xc(%ebp),%eax
    feb2:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    feb8:	ba 00 00 00 00       	mov    $0x0,%edx
    febd:	01 05 00 00 00 00    	add    %eax,0x0
    fec3:	11 15 04 00 00 00    	adc    %edx,0x4

#ifndef USERTEST
	trickles_checksum(skb, skb->len - origSkbLen);
    fec9:	8b 45 0c             	mov    0xc(%ebp),%eax
    fecc:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
    fecf:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
    fed5:	29 d0                	sub    %edx,%eax
    fed7:	89 44 24 04          	mov    %eax,0x4(%esp,1)
    fedb:	8b 45 0c             	mov    0xc(%ebp),%eax
    fede:	89 04 24             	mov    %eax,(%esp,1)
    fee1:	e8 80 17 00 00       	call   11666 <trickles_checksum>
	if(sk->protocol == IPPROTO_TCP) {
    fee6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    fee9:	80 b8 5b 0b 00 00 06 	cmpb   $0x6,0xb5b(%eax)
    fef0:	75 1d                	jne    ff0f <msk_transmit_skb+0x4c8>
#ifndef FORCE_MSK_TRANSMIT_REORDERING
		err = af->queue_xmit(skb, 0);
    fef2:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    fef5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    fefc:	00 
    fefd:	8b 45 0c             	mov    0xc(%ebp),%eax
    ff00:	89 04 24             	mov    %eax,(%esp,1)
    ff03:	8b 02                	mov    (%edx),%eax
    ff05:	ff d0                	call   *%eax
    ff07:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    ff0a:	e9 85 00 00 00       	jmp    ff94 <msk_transmit_skb+0x54d>
#else
		if(reorder_skb == NULL) {
			reorder_skb = skb;
			err = 0;
		} else {
			err = af->queue_xmit(skb, 0);
			err = af->queue_xmit(reorder_skb, 0) | err;
		}
#endif
	} else {
		struct udphdr *udp_hdr;
		BUG_TRAP(sk->protocol == IPPROTO_UDP);
    ff0f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    ff12:	80 b8 5b 0b 00 00 11 	cmpb   $0x11,0xb5b(%eax)
    ff19:	74 14                	je     ff2f <msk_transmit_skb+0x4e8>
    ff1b:	c7 44 24 04 05 05 00 	movl   $0x505,0x4(%esp,1)
    ff22:	00 
    ff23:	c7 04 24 e0 4b 00 00 	movl   $0x4be0,(%esp,1)
    ff2a:	e8 fc ff ff ff       	call   ff2b <msk_transmit_skb+0x4e4>
		udp_hdr = (struct udphdr*) 
    ff2f:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp,1)
    ff36:	00 
    ff37:	8b 45 0c             	mov    0xc(%ebp),%eax
    ff3a:	89 04 24             	mov    %eax,(%esp,1)
    ff3d:	e8 f4 14 00 00       	call   11436 <skb_push>
    ff42:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
			skb_push(skb, sizeof(struct udphdr));
		udp_hdr->source = sk->sport;
    ff45:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
    ff48:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    ff4b:	0f b7 40 22          	movzwl 0x22(%eax),%eax
    ff4f:	66 89 02             	mov    %ax,(%edx)
		udp_hdr->dest = sk->dport;
    ff52:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
    ff55:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
    ff58:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    ff5c:	66 89 42 02          	mov    %ax,0x2(%edx)
		udp_hdr->len = htons(sizeof(struct udphdr));
    ff60:	8b 5d d4             	mov    0xffffffd4(%ebp),%ebx
    ff63:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp,1)
    ff6a:	e8 fc ff ff ff       	call   ff6b <msk_transmit_skb+0x524>
    ff6f:	66 89 43 04          	mov    %ax,0x4(%ebx)
		udp_hdr->check = 0;
    ff73:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
    ff76:	66 c7 40 06 00 00    	movw   $0x0,0x6(%eax)
		err = af->queue_xmit(skb, 0);
    ff7c:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
    ff7f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
    ff86:	00 
    ff87:	8b 45 0c             	mov    0xc(%ebp),%eax
    ff8a:	89 04 24             	mov    %eax,(%esp,1)
    ff8d:	8b 02                	mov    (%edx),%eax
    ff8f:	ff d0                	call   *%eax
    ff91:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
	}
#else
	err = 0;
	skb->nh.iph = (struct iphdr*)skb_push(skb, sizeof(struct iphdr));
	skb->nh.iph->daddr = msk->daddr;
	skb->nh.iph->saddr = msk->saddr;
	sendtoclient(skb);
#endif // USERTEST
	return err;
    ff94:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
}
    ff97:	83 c4 58             	add    $0x58,%esp
    ff9a:	5b                   	pop    %ebx
    ff9b:	5d                   	pop    %ebp
    ff9c:	c3                   	ret    

0000ff9d <NormalizeContinuation>:



/*
  Sequence #
  State
  **Recovery:
  firstLoss
  firstBootstrapSeq

  **AckTCPCwnd
  startCwnd
  ssthresh
  TCPBase */

void NormalizeContinuation(CONTINUATION_TYPE *cont, AckProof *ackProof) {
    ff9d:	55                   	push   %ebp
    ff9e:	89 e5                	mov    %esp,%ebp
#if 0
  // TODO: Disabled normalization code for now because Normalization complicates TCP update calculation
	unsigned seq = cont->seq;
	if(seq - cont->TCPBase > MAX_CWND * MAX_CWND) {
		int cwnd;
		// make sure normalization of parallel threads results in the same new TCPBase
		__u32 right = AckProof_findRight(ackProof, cont->TCPBase),
			newSeq = cont->TCPBase + MAX_CWND * MAX_CWND;
		BUG_TRAP(right >= cont->TCPBase);
		BUG_TRAP(newSeq <= right);
		cwnd = AckTCPCwndScalar(newSeq, cont);
		if(cwnd < 0) {
			printk("Bad CWND in normalizeContinuation\n");
			return;
		}
		cont->startCwnd = cwnd;
		cont->TCPBase = newSeq;
		printk("Warning: Normalization is not correct yet!\n");
	}
#endif
}
    ffa0:	5d                   	pop    %ebp
    ffa1:	c3                   	ret    

0000ffa2 <DoNormalStep>:

#ifdef USE_INCREMENTAL_CWND
 __u32 AckTCPHint(__u32 prevCwnd, __u32 *hint, __u32 seq, CONTINUATION_TYPE *cont) {
	__u32 currCwnd;
	// Updates result for next call to AckTCPHint
	if(*hint != -1) {
		/* Compute update starting from hint */
		currCwnd = prevCwnd;
		if(seq >= *hint) {
			int delta = seq  - *hint, ticks = 0;
			currCwnd = CLAMP(currCwnd + 1);
			if(currCwnd < cont->ssthresh) {
				currCwnd = CLAMP(MIN(cont->ssthresh, 
						     currCwnd + delta));
				delta -= currCwnd - prevCwnd;
			}
			while(delta >= currCwnd) {
				ticks++;
				BUG_TRAP(currCwnd >= cont->ssthresh);
				delta -= currCwnd;
				currCwnd = CLAMP(currCwnd + 1);
			}
			if(currCwnd < cont->ssthresh) {
				*hint = seq + 1;
			} else {
				*hint = seq + (-delta);
			}
		}
	} else {
		/* Compute from scratch */
		currCwnd = AckTCPCwndScalar(cont->seq, cont);
	}
	return currCwnd;
}
#endif // USE_INCREMENTAL_CWND

#define FIRST_ACKSEQ(CONTTYPE, SEQ)			\
    ((CONTTYPE) == CONTTYPE_FULL2 ? (SEQ) - 1 : (SEQ))
static int DoNormalStep(CONTINUATION_TYPE **cont, 
			 AckProof *ackProof, 
			 enum cminisock_event_tag event) {
    ffa2:	55                   	push   %ebp
    ffa3:	89 e5                	mov    %esp,%ebp
    ffa5:	81 ec 88 00 00 00    	sub    $0x88,%esp
  //printk("doNormalStep ServerDebugLevel = %d\n", serverDebugLevel);
  int i, numPackets = 0;
    ffab:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  __u32 first_ack_seq = 
    ffb2:	8b 45 08             	mov    0x8(%ebp),%eax
    ffb5:	8b 00                	mov    (%eax),%eax
    ffb7:	8b 40 30             	mov    0x30(%eax),%eax
    ffba:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
    ffbd:	8b 45 08             	mov    0x8(%ebp),%eax
    ffc0:	8b 00                	mov    (%eax),%eax
    ffc2:	83 78 34 02          	cmpl   $0x2,0x34(%eax)
    ffc6:	75 03                	jne    ffcb <DoNormalStep+0x29>
    ffc8:	ff 4d b4             	decl   0xffffffb4(%ebp)
    ffcb:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
    ffce:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    FIRST_ACKSEQ((*cont)->continuationType, 
		 (*cont)->seq), firstResponseSeq;
  int prevCwnd, currCwnd;
  int numOutput;
  int first = 1, thisResponseLen = 0, hint;
    ffd1:	c7 45 e0 01 00 00 00 	movl   $0x1,0xffffffe0(%ebp)
    ffd8:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  __u32 offset;

  if(IS_DEFERRED_INITIALCWND(*cont)) {
    ffdf:	8b 45 08             	mov    0x8(%ebp),%eax
    ffe2:	8b 00                	mov    (%eax),%eax
    ffe4:	83 78 64 00          	cmpl   $0x0,0x64(%eax)
    ffe8:	75 41                	jne    1002b <DoNormalStep+0x89>
	  //printk("deferred\n");
	  (*cont)->startCwnd = INITIAL_CWND;
    ffea:	8b 45 08             	mov    0x8(%ebp),%eax
    ffed:	8b 00                	mov    (%eax),%eax
    ffef:	c7 40 64 03 00 00 00 	movl   $0x3,0x64(%eax)
	  return doInitialCwnd(*cont, event, (*cont)->seq + 1, (*cont)->startCwnd);
    fff6:	8b 45 08             	mov    0x8(%ebp),%eax
    fff9:	8b 00                	mov    (%eax),%eax
    fffb:	8b 40 64             	mov    0x64(%eax),%eax
    fffe:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   10002:	8b 45 08             	mov    0x8(%ebp),%eax
   10005:	8b 00                	mov    (%eax),%eax
   10007:	8b 40 30             	mov    0x30(%eax),%eax
   1000a:	40                   	inc    %eax
   1000b:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1000f:	8b 45 10             	mov    0x10(%ebp),%eax
   10012:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10016:	8b 45 08             	mov    0x8(%ebp),%eax
   10019:	8b 00                	mov    (%eax),%eax
   1001b:	89 04 24             	mov    %eax,(%esp,1)
   1001e:	e8 e9 22 00 00       	call   1230c <doInitialCwnd>
   10023:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
   10026:	e9 19 04 00 00       	jmp    10444 <DoNormalStep+0x4a2>
  }

  (*cont)->executionTrace = 1;
   1002b:	8b 45 08             	mov    0x8(%ebp),%eax
   1002e:	8b 00                	mov    (%eax),%eax
   10030:	c7 80 dc 00 00 00 01 	movl   $0x1,0xdc(%eax)
   10037:	00 00 00 

  TIMING_CTX_DEF0("DoNormalStep", "");
  TIMING_CTX_DEF1(7);
  reinitTimingCtx(&ctx);
  recordSample(&ctx,0);

  prevCwnd = (first_ack_seq == (*cont)->TCPBase) ? 
   1003a:	8b 45 08             	mov    0x8(%ebp),%eax
   1003d:	8b 10                	mov    (%eax),%edx
   1003f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   10042:	3b 42 6c             	cmp    0x6c(%edx),%eax
   10045:	75 0d                	jne    10054 <DoNormalStep+0xb2>
   10047:	8b 45 08             	mov    0x8(%ebp),%eax
   1004a:	8b 00                	mov    (%eax),%eax
   1004c:	8b 40 64             	mov    0x64(%eax),%eax
   1004f:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
   10052:	eb 1f                	jmp    10073 <DoNormalStep+0xd1>
   10054:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   10057:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1005b:	8b 45 08             	mov    0x8(%ebp),%eax
   1005e:	8b 00                	mov    (%eax),%eax
   10060:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10064:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   10067:	48                   	dec    %eax
   10068:	89 04 24             	mov    %eax,(%esp,1)
   1006b:	e8 fc ff ff ff       	call   1006c <DoNormalStep+0xca>
   10070:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
   10073:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
   10076:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    (*cont)->startCwnd : 
    AckTCPCwnd(first_ack_seq - 1, (*cont), &hint);
  recordSample(&ctx,0);

#ifndef USE_INCREMENTAL_CWND
  currCwnd = AckTCPCwndScalar((*cont)->seq, (*cont));
   10079:	8b 45 08             	mov    0x8(%ebp),%eax
   1007c:	8b 00                	mov    (%eax),%eax
   1007e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10082:	8b 45 08             	mov    0x8(%ebp),%eax
   10085:	8b 00                	mov    (%eax),%eax
   10087:	8b 40 30             	mov    0x30(%eax),%eax
   1008a:	89 04 24             	mov    %eax,(%esp,1)
   1008d:	e8 fc ff ff ff       	call   1008e <DoNormalStep+0xec>
   10092:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
#else
  currCwnd = AckTCPHint(prevCwnd, &hint, (*cont)->seq, (*cont));
#endif
  (*cont)->actualCwnd = currCwnd;
   10095:	8b 45 08             	mov    0x8(%ebp),%eax
   10098:	8b 10                	mov    (%eax),%edx
   1009a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1009d:	89 82 e0 00 00 00    	mov    %eax,0xe0(%edx)

  //printk("prevCwnd: %u currCwnd: %u - ", prevCwnd, currCwnd);
  recordSample(&ctx,0);
  numOutput = MAX(0, currCwnd - (int)prevCwnd);
   100a3:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   100a6:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   100a9:	29 d0                	sub    %edx,%eax
   100ab:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
   100ae:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
   100b5:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   100b8:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
   100bb:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   100be:	89 45 ac             	mov    %eax,0xffffffac(%ebp)
   100c1:	8b 45 ac             	mov    0xffffffac(%ebp),%eax
   100c4:	3b 45 cc             	cmp    0xffffffcc(%ebp),%eax
   100c7:	7d 06                	jge    100cf <DoNormalStep+0x12d>
   100c9:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
   100cc:	89 45 ac             	mov    %eax,0xffffffac(%ebp)
   100cf:	8b 45 ac             	mov    0xffffffac(%ebp),%eax
   100d2:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)

  switch((*cont)->continuationType) {
   100d5:	8b 45 08             	mov    0x8(%ebp),%eax
   100d8:	8b 00                	mov    (%eax),%eax
   100da:	8b 40 34             	mov    0x34(%eax),%eax
   100dd:	89 45 a8             	mov    %eax,0xffffffa8(%ebp)
   100e0:	83 7d a8 01          	cmpl   $0x1,0xffffffa8(%ebp)
   100e4:	74 08                	je     100ee <DoNormalStep+0x14c>
   100e6:	83 7d a8 02          	cmpl   $0x2,0xffffffa8(%ebp)
   100ea:	74 09                	je     100f5 <DoNormalStep+0x153>
   100ec:	eb 0f                	jmp    100fd <DoNormalStep+0x15b>
  case CONTTYPE_FULL1:
    numOutput += 1;
   100ee:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   100f1:	ff 00                	incl   (%eax)
    break;
   100f3:	eb 2d                	jmp    10122 <DoNormalStep+0x180>
  case CONTTYPE_FULL2:
    numOutput += 2;
   100f5:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   100f8:	83 00 02             	addl   $0x2,(%eax)
    break;
   100fb:	eb 25                	jmp    10122 <DoNormalStep+0x180>
  default:
    BUG();
   100fd:	c7 44 24 04 19 45 00 	movl   $0x4519,0x4(%esp,1)
   10104:	00 
   10105:	c7 04 24 1d 45 00 00 	movl   $0x451d,(%esp,1)
   1010c:	e8 fc ff ff ff       	call   1010d <DoNormalStep+0x16b>
   10111:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   10118:	e8 fc ff ff ff       	call   10119 <DoNormalStep+0x177>
   1011d:	e8 fc ff ff ff       	call   1011e <DoNormalStep+0x17c>
  }

  if(prevCwnd < 0 || currCwnd < 0) {
   10122:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
   10126:	78 08                	js     10130 <DoNormalStep+0x18e>
   10128:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
   1012c:	78 02                	js     10130 <DoNormalStep+0x18e>
   1012e:	eb 3e                	jmp    1016e <DoNormalStep+0x1cc>
    /* error in AckTCPCwnd; return without generating output */
    if(trickles_ratelimit()) {
	    ERROR("Error in acktcpcwnd base = %d %d=>%d %d=>%d\n", 
		  (*cont)->TCPBase,
		  first_ack_seq - 1, prevCwnd, 
		  (*cont)->seq, currCwnd);
    }
    free_trickles_msk((*cont)->sk,*cont);
   10130:	8b 45 08             	mov    0x8(%ebp),%eax
   10133:	8b 00                	mov    (%eax),%eax
   10135:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10139:	8b 45 08             	mov    0x8(%ebp),%eax
   1013c:	8b 00                	mov    (%eax),%eax
   1013e:	8b 40 20             	mov    0x20(%eax),%eax
   10141:	89 04 24             	mov    %eax,(%esp,1)
   10144:	e8 4c dd ff ff       	call   de95 <free_trickles_msk>
    free_trickles_msk_finish((*cont)->sk,*cont);
   10149:	8b 45 08             	mov    0x8(%ebp),%eax
   1014c:	8b 00                	mov    (%eax),%eax
   1014e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10152:	8b 45 08             	mov    0x8(%ebp),%eax
   10155:	8b 00                	mov    (%eax),%eax
   10157:	8b 40 20             	mov    0x20(%eax),%eax
   1015a:	89 04 24             	mov    %eax,(%esp,1)
   1015d:	e8 d1 dd ff ff       	call   df33 <free_trickles_msk_finish>
    return -EINVAL;
   10162:	c7 45 b8 ea ff ff ff 	movl   $0xffffffea,0xffffffb8(%ebp)
   10169:	e9 d6 02 00 00       	jmp    10444 <DoNormalStep+0x4a2>
  }
  if(numOutput < 0) {
   1016e:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
   10172:	79 13                	jns    10187 <DoNormalStep+0x1e5>
    ERROR("Decrease in AckTCPCwnd\n");
   10174:	c7 04 24 31 4c 00 00 	movl   $0x4c31,(%esp,1)
   1017b:	e8 fc ff ff ff       	call   1017c <DoNormalStep+0x1da>
    numOutput = 0;
   10180:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  }
  if(numOutput > 5) {
   10187:	83 7d e4 05          	cmpl   $0x5,0xffffffe4(%ebp)
   1018b:	7e 7c                	jle    10209 <DoNormalStep+0x267>
    printk("bug in cwnd generation: ack_seq = %u-%u, TCPBase = %u, "
   1018d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   10190:	89 44 24 14          	mov    %eax,0x14(%esp,1)
   10194:	8b 45 08             	mov    0x8(%ebp),%eax
   10197:	8b 00                	mov    (%eax),%eax
   10199:	8b 40 64             	mov    0x64(%eax),%eax
   1019c:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   101a0:	8b 45 08             	mov    0x8(%ebp),%eax
   101a3:	8b 00                	mov    (%eax),%eax
   101a5:	8b 40 6c             	mov    0x6c(%eax),%eax
   101a8:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   101ac:	8b 45 08             	mov    0x8(%ebp),%eax
   101af:	8b 00                	mov    (%eax),%eax
   101b1:	8b 40 30             	mov    0x30(%eax),%eax
   101b4:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   101b8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   101bb:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   101bf:	c7 04 24 60 4c 00 00 	movl   $0x4c60,(%esp,1)
   101c6:	e8 fc ff ff ff       	call   101c7 <DoNormalStep+0x225>
	   "cwnd = %u, numOutput = %u, \n",
	   first_ack_seq, (*cont)->seq, (*cont)->TCPBase, 
	   (*cont)->startCwnd, numOutput);
    
    free_trickles_msk((*cont)->sk,(*cont));
   101cb:	8b 45 08             	mov    0x8(%ebp),%eax
   101ce:	8b 00                	mov    (%eax),%eax
   101d0:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   101d4:	8b 45 08             	mov    0x8(%ebp),%eax
   101d7:	8b 00                	mov    (%eax),%eax
   101d9:	8b 40 20             	mov    0x20(%eax),%eax
   101dc:	89 04 24             	mov    %eax,(%esp,1)
   101df:	e8 b1 dc ff ff       	call   de95 <free_trickles_msk>
    free_trickles_msk_finish((*cont)->sk,(*cont));
   101e4:	8b 45 08             	mov    0x8(%ebp),%eax
   101e7:	8b 00                	mov    (%eax),%eax
   101e9:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   101ed:	8b 45 08             	mov    0x8(%ebp),%eax
   101f0:	8b 00                	mov    (%eax),%eax
   101f2:	8b 40 20             	mov    0x20(%eax),%eax
   101f5:	89 04 24             	mov    %eax,(%esp,1)
   101f8:	e8 36 dd ff ff       	call   df33 <free_trickles_msk_finish>
    return -EINVAL;
   101fd:	c7 45 b8 ea ff ff ff 	movl   $0xffffffea,0xffffffb8(%ebp)
   10204:	e9 3b 02 00 00       	jmp    10444 <DoNormalStep+0x4a2>
  }
  recordSample(&ctx,0);
  NormalizeContinuation(*cont,ackProof);
   10209:	8b 45 0c             	mov    0xc(%ebp),%eax
   1020c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10210:	8b 45 08             	mov    0x8(%ebp),%eax
   10213:	8b 00                	mov    (%eax),%eax
   10215:	89 04 24             	mov    %eax,(%esp,1)
   10218:	e8 fc ff ff ff       	call   10219 <DoNormalStep+0x277>
  recordSample(&ctx,0);
  firstResponseSeq = first_ack_seq + prevCwnd;
   1021d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   10220:	03 45 f4             	add    0xfffffff4(%ebp),%eax
   10223:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  //printk("%d: normal: %d + %d\n", (int)jiffies, first_ack_seq, prevCwnd);

  // allocate space for packets
  if(!alloc_msk_packets((*cont), numOutput)) {
   10226:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   10229:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1022d:	8b 45 08             	mov    0x8(%ebp),%eax
   10230:	8b 00                	mov    (%eax),%eax
   10232:	89 04 24             	mov    %eax,(%esp,1)
   10235:	e8 6a 1b 00 00       	call   11da4 <alloc_msk_packets>
   1023a:	85 c0                	test   %eax,%eax
   1023c:	75 3e                	jne    1027c <DoNormalStep+0x2da>
    free_trickles_msk((*cont)->sk,(*cont));
   1023e:	8b 45 08             	mov    0x8(%ebp),%eax
   10241:	8b 00                	mov    (%eax),%eax
   10243:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10247:	8b 45 08             	mov    0x8(%ebp),%eax
   1024a:	8b 00                	mov    (%eax),%eax
   1024c:	8b 40 20             	mov    0x20(%eax),%eax
   1024f:	89 04 24             	mov    %eax,(%esp,1)
   10252:	e8 3e dc ff ff       	call   de95 <free_trickles_msk>
    free_trickles_msk_finish((*cont)->sk,(*cont));
   10257:	8b 45 08             	mov    0x8(%ebp),%eax
   1025a:	8b 00                	mov    (%eax),%eax
   1025c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10260:	8b 45 08             	mov    0x8(%ebp),%eax
   10263:	8b 00                	mov    (%eax),%eax
   10265:	8b 40 20             	mov    0x20(%eax),%eax
   10268:	89 04 24             	mov    %eax,(%esp,1)
   1026b:	e8 c3 dc ff ff       	call   df33 <free_trickles_msk_finish>
    return -ENOMEM;
   10270:	c7 45 b8 f4 ff ff ff 	movl   $0xfffffff4,0xffffffb8(%ebp)
   10277:	e9 c8 01 00 00       	jmp    10444 <DoNormalStep+0x4a2>
  }
  for(i=0; i < numOutput; i++) {
   1027c:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   10283:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   10286:	3b 45 e4             	cmp    0xffffffe4(%ebp),%eax
   10289:	7c 05                	jl     10290 <DoNormalStep+0x2ee>
   1028b:	e9 6f 01 00 00       	jmp    103ff <DoNormalStep+0x45d>
    __u32 seq = firstResponseSeq + i;
   10290:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   10293:	03 45 f0             	add    0xfffffff0(%ebp),%eax
   10296:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
    int thisMSS, nextResponseLen = 0, firstChild = -1, 
   10299:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
   102a0:	c7 45 c4 ff ff ff ff 	movl   $0xffffffff,0xffffffc4(%ebp)
      numChildren = -1, contType;
   102a7:	c7 45 c0 ff ff ff ff 	movl   $0xffffffff,0xffffffc0(%ebp)
    if(serverDebugLevel >= 1) {
   102ae:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
   102b5:	7e 1e                	jle    102d5 <DoNormalStep+0x333>
      if((*cont)->state == CONT_BOOTSTRAP) {
   102b7:	8b 45 08             	mov    0x8(%ebp),%eax
   102ba:	8b 00                	mov    (%eax),%eax
   102bc:	83 78 54 02          	cmpl   $0x2,0x54(%eax)
   102c0:	75 13                	jne    102d5 <DoNormalStep+0x333>
	printk("  %u\n", seq);
   102c2:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   102c5:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   102c9:	c7 04 24 b4 4c 00 00 	movl   $0x4cb4,(%esp,1)
   102d0:	e8 fc ff ff ff       	call   102d1 <DoNormalStep+0x32f>
      }
    }
    // Algorithm choices here affect normalize continuation
    offset = seq - (*cont)->TCPBase;
   102d5:	8b 45 08             	mov    0x8(%ebp),%eax
   102d8:	8b 00                	mov    (%eax),%eax
   102da:	8b 50 6c             	mov    0x6c(%eax),%edx
   102dd:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   102e0:	29 d0                	sub    %edx,%eax
   102e2:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)

#if 1 // 0901 -- switch to minimal continuation as soon as possible. Was <= 8
    // the <2 test is a work around the initialcwnd restricted to 1 bug. we really need startcwnd = 2
    //#define FULL1_INTERVAL (2)
#define FULL1_INTERVAL (8)
#define CONTTYPE(OFFSET) (((OFFSET) < FULL1_INTERVAL) ? CONTTYPE_FULL1 : \
			  ((((OFFSET)) % 2 == 0) ? CONTTYPE_FULL2 : \
			   CONTTYPE_MINIMAL))
#else
#define CONTTYPE(OFFSET) (((OFFSET) - SLOWSTART_CWND < 8) ? CONTTYPE_FULL1 : \
			  ((((OFFSET) - SLOWSTART_CWND) % 2 == 0) ? CONTTYPE_FULL2 : \
			   CONTTYPE_MINIMAL))
#endif 

    /* calculate number of packets in successor*/
    contType = CONTTYPE(offset);
   102e5:	83 7d d4 07          	cmpl   $0x7,0xffffffd4(%ebp)
   102e9:	76 1c                	jbe    10307 <DoNormalStep+0x365>
   102eb:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   102ee:	83 e0 01             	and    $0x1,%eax
   102f1:	85 c0                	test   %eax,%eax
   102f3:	75 09                	jne    102fe <DoNormalStep+0x35c>
   102f5:	c7 45 a4 02 00 00 00 	movl   $0x2,0xffffffa4(%ebp)
   102fc:	eb 10                	jmp    1030e <DoNormalStep+0x36c>
   102fe:	c7 45 a4 00 00 00 00 	movl   $0x0,0xffffffa4(%ebp)
   10305:	eb 07                	jmp    1030e <DoNormalStep+0x36c>
   10307:	c7 45 a4 01 00 00 00 	movl   $0x1,0xffffffa4(%ebp)
   1030e:	8b 45 a4             	mov    0xffffffa4(%ebp),%eax
   10311:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)

#ifdef ENABLE_HASHCOMPRESS
    switch(contType) {
    case CONTTYPE_FULL1:
    case CONTTYPE_FULL2:
	    thisMSS = CONTTYPE_HASHCOMPRESS_MSS;
	    break;
    case CONTTYPE_MINIMAL:
	    thisMSS = CONTTYPE_HASHCOMPRESS_MSS;
	    break;
    default:
	    thisMSS = -1;
	    BUG();
    }
    contType |= CONTTYPE_HASHCOMPRESSED;
#else
    switch(contType) {
   10314:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
   10317:	89 45 a0             	mov    %eax,0xffffffa0(%ebp)
   1031a:	83 7d a0 00          	cmpl   $0x0,0xffffffa0(%ebp)
   1031e:	74 16                	je     10336 <DoNormalStep+0x394>
   10320:	83 7d a0 00          	cmpl   $0x0,0xffffffa0(%ebp)
   10324:	78 1d                	js     10343 <DoNormalStep+0x3a1>
   10326:	83 7d a0 02          	cmpl   $0x2,0xffffffa0(%ebp)
   1032a:	7f 17                	jg     10343 <DoNormalStep+0x3a1>
    case CONTTYPE_FULL1:
    case CONTTYPE_FULL2:
	    thisMSS = CONTTYPE_FULL_MSS;
   1032c:	a1 00 00 00 00       	mov    0x0,%eax
   10331:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
	    break;
   10334:	eb 39                	jmp    1036f <DoNormalStep+0x3cd>
    case CONTTYPE_MINIMAL:
	    thisMSS = CONTTYPE_MINIMAL_MSS;
   10336:	a1 00 00 00 00       	mov    0x0,%eax
   1033b:	83 c0 35             	add    $0x35,%eax
   1033e:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
	    break;
   10341:	eb 2c                	jmp    1036f <DoNormalStep+0x3cd>
    default:
	    thisMSS = -1;
   10343:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,0xffffffcc(%ebp)
	    BUG();
   1034a:	c7 44 24 04 19 45 00 	movl   $0x4519,0x4(%esp,1)
   10351:	00 
   10352:	c7 04 24 1d 45 00 00 	movl   $0x451d,(%esp,1)
   10359:	e8 fc ff ff ff       	call   1035a <DoNormalStep+0x3b8>
   1035e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   10365:	e8 fc ff ff ff       	call   10366 <DoNormalStep+0x3c4>
   1036a:	e8 fc ff ff ff       	call   1036b <DoNormalStep+0x3c9>
    }
#endif
    thisResponseLen += thisMSS;
   1036f:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
   10372:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   10375:	01 10                	add    %edx,(%eax)
    makePacket(&(*cont)->packets[numPackets], seq, 0xdeadbeef, thisMSS, (first ? PTYPE_FIRST : 0) | PACKET_NORMAL, contType, nextResponseLen,
   10377:	0f b6 45 c0          	movzbl 0xffffffc0(%ebp),%eax
   1037b:	89 44 24 20          	mov    %eax,0x20(%esp,1)
   1037f:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
   10382:	89 44 24 1c          	mov    %eax,0x1c(%esp,1)
   10386:	0f b7 45 d0          	movzwl 0xffffffd0(%ebp),%eax
   1038a:	89 44 24 18          	mov    %eax,0x18(%esp,1)
   1038e:	0f b6 45 bc          	movzbl 0xffffffbc(%ebp),%eax
   10392:	89 44 24 14          	mov    %eax,0x14(%esp,1)
   10396:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
   1039a:	74 09                	je     103a5 <DoNormalStep+0x403>
   1039c:	c7 45 9c 80 00 00 00 	movl   $0x80,0xffffff9c(%ebp)
   103a3:	eb 07                	jmp    103ac <DoNormalStep+0x40a>
   103a5:	c7 45 9c 00 00 00 00 	movl   $0x0,0xffffff9c(%ebp)
   103ac:	8b 45 9c             	mov    0xffffff9c(%ebp),%eax
   103af:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   103b3:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
   103b6:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   103ba:	c7 44 24 08 ef be ad 	movl   $0xdeadbeef,0x8(%esp,1)
   103c1:	de 
   103c2:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   103c5:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   103c9:	8b 45 08             	mov    0x8(%ebp),%eax
   103cc:	8b 08                	mov    (%eax),%ecx
   103ce:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   103d1:	89 d0                	mov    %edx,%eax
   103d3:	c1 e0 03             	shl    $0x3,%eax
   103d6:	01 d0                	add    %edx,%eax
   103d8:	c1 e0 02             	shl    $0x2,%eax
   103db:	03 81 ec 00 00 00    	add    0xec(%ecx),%eax
   103e1:	89 04 24             	mov    %eax,(%esp,1)
   103e4:	e8 d0 11 00 00       	call   115b9 <makePacket>
	       firstChild, numChildren);


    first = 0;
   103e9:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
    numPackets++;
   103f0:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
   103f3:	ff 00                	incl   (%eax)
   103f5:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
   103f8:	ff 00                	incl   (%eax)
   103fa:	e9 84 fe ff ff       	jmp    10283 <DoNormalStep+0x2e1>
  }
  (*cont)->num_packets = numPackets;
   103ff:	8b 45 08             	mov    0x8(%ebp),%eax
   10402:	8b 10                	mov    (%eax),%edx
   10404:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   10407:	89 82 e8 00 00 00    	mov    %eax,0xe8(%edx)
  BUG_TRAP(numPackets <= numOutput);
   1040d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   10410:	3b 45 e4             	cmp    0xffffffe4(%ebp),%eax
   10413:	7e 14                	jle    10429 <DoNormalStep+0x487>
   10415:	c7 44 24 04 fe 05 00 	movl   $0x5fe,0x4(%esp,1)
   1041c:	00 
   1041d:	c7 04 24 c0 4c 00 00 	movl   $0x4cc0,(%esp,1)
   10424:	e8 fc ff ff ff       	call   10425 <DoNormalStep+0x483>
  recordSample(&ctx,0);

  DO_SANITY_CHECK_MSK(*cont);
  DoUpcall((*cont), event);
   10429:	8b 45 10             	mov    0x10(%ebp),%eax
   1042c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10430:	8b 45 08             	mov    0x8(%ebp),%eax
   10433:	8b 00                	mov    (%eax),%eax
   10435:	89 04 24             	mov    %eax,(%esp,1)
   10438:	e8 fc ff ff ff       	call   10439 <DoNormalStep+0x497>
  recordSample(&ctx,0);
  //printTimings(&ctx);
  return 0;
   1043d:	c7 45 b8 00 00 00 00 	movl   $0x0,0xffffffb8(%ebp)
}
   10444:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
   10447:	c9                   	leave  
   10448:	c3                   	ret    

00010449 <intersect>:


static int intersect(int start0, int end0, int start1, int end1) {
   10449:	55                   	push   %ebp
   1044a:	89 e5                	mov    %esp,%ebp
   1044c:	83 ec 20             	sub    $0x20,%esp
  int start = MAX(start0,start1),
   1044f:	8b 45 10             	mov    0x10(%ebp),%eax
   10452:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   10455:	8b 45 08             	mov    0x8(%ebp),%eax
   10458:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1045b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1045e:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   10461:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   10464:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   10467:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1046a:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
   1046d:	7d 06                	jge    10475 <intersect+0x2c>
   1046f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   10472:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   10475:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   10478:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    end = MIN(end0,end1);
   1047b:	8b 45 14             	mov    0x14(%ebp),%eax
   1047e:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   10481:	8b 45 0c             	mov    0xc(%ebp),%eax
   10484:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   10487:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1048a:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1048d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   10490:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   10493:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   10496:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
   10499:	7e 06                	jle    104a1 <intersect+0x58>
   1049b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1049e:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   104a1:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   104a4:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  if(start <= end) {
   104a7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   104aa:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
   104ad:	7f 0e                	jg     104bd <intersect+0x74>
    /* intersection */
    return end - start + 1;
   104af:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   104b2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   104b5:	29 d0                	sub    %edx,%eax
   104b7:	40                   	inc    %eax
   104b8:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   104bb:	eb 07                	jmp    104c4 <intersect+0x7b>
  } else {
    return 0;
   104bd:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  }
}
   104c4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   104c7:	c9                   	leave  
   104c8:	c3                   	ret    

000104c9 <DoRecoveryStep>:

#ifdef USERTEST
#if 0
#define serverDebugLevel recoveryDebugLevel
static int recoveryDebugLevel = 99; // temporary use in userspace debugging to print only recovery handler debugging information
#endif
#endif

static int DoRecoveryStep(CONTINUATION_TYPE **cont, AckProof *ackProof, 
			  enum cminisock_event_tag event) {
   104c9:	55                   	push   %ebp
   104ca:	89 e5                	mov    %esp,%ebp
   104cc:	53                   	push   %ebx
   104cd:	81 ec ac 00 00 00    	sub    $0xac,%esp
	BUG_TRAP(!IS_DEFERRED_INITIALCWND(*cont));
   104d3:	8b 45 08             	mov    0x8(%ebp),%eax
   104d6:	8b 00                	mov    (%eax),%eax
   104d8:	83 78 64 00          	cmpl   $0x0,0x64(%eax)
   104dc:	75 14                	jne    104f2 <DoRecoveryStep+0x29>
   104de:	c7 44 24 04 1d 06 00 	movl   $0x61d,0x4(%esp,1)
   104e5:	00 
   104e6:	c7 04 24 20 4d 00 00 	movl   $0x4d20,(%esp,1)
   104ed:	e8 fc ff ff ff       	call   104ee <DoRecoveryStep+0x25>
	//printk("doRecoveryStep ServerDebugLevel = %d\n", serverDebugLevel);
  int i;
  Sack *sacks = ackProof->sacks;
   104f2:	8b 45 0c             	mov    0xc(%ebp),%eax
   104f5:	83 c0 08             	add    $0x8,%eax
   104f8:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  // XXX INTMAX suppresses "uninitialized variable" harmless warnings in gcc
  int numLosses = 0, numBootstrapLosses = 0, bootstrapStart, bootstrapEnd, 
   104fb:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
   10502:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
	  afterGap = 0,gapLeft = INT_MAX, gapRight = INT_MAX;
   10509:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
   10510:	c7 45 dc ff ff ff 7f 	movl   $0x7fffffff,0xffffffdc(%ebp)
   10517:	c7 45 d8 ff ff ff 7f 	movl   $0x7fffffff,0xffffffd8(%ebp)
  unsigned numPackets = 0;
   1051e:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
  int origCwnd, origCwndPred = INT_MAX, newCwnd;
   10525:	c7 45 cc ff ff ff 7f 	movl   $0x7fffffff,0xffffffcc(%ebp)
  int gaplen = INT_MAX;
   1052c:	c7 45 c4 ff ff ff 7f 	movl   $0x7fffffff,0xffffffc4(%ebp)
  int adj = INT_MAX;
   10533:	c7 45 c0 ff ff ff 7f 	movl   $0x7fffffff,0xffffffc0(%ebp)
  __u32 ack_seq;
  __u32 lastRegularPacket;

  int numPacketsSendable;
  int numPacketsAllocated;

  int bootstrapIntersectStart, 
    bootstrapIntersectLast;

  (*cont)->executionTrace = 2;
   1053a:	8b 45 08             	mov    0x8(%ebp),%eax
   1053d:	8b 00                	mov    (%eax),%eax
   1053f:	c7 80 dc 00 00 00 02 	movl   $0x2,0xdc(%eax)
   10546:	00 00 00 

  origCwnd = AckTCPCwndScalar(AckProof_firstLoss(ackProof), (*cont));
   10549:	8b 45 0c             	mov    0xc(%ebp),%eax
   1054c:	89 04 24             	mov    %eax,(%esp,1)
   1054f:	e8 fc ff ff ff       	call   10550 <DoRecoveryStep+0x87>
   10554:	89 c2                	mov    %eax,%edx
   10556:	8b 45 08             	mov    0x8(%ebp),%eax
   10559:	8b 00                	mov    (%eax),%eax
   1055b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1055f:	89 14 24             	mov    %edx,(%esp,1)
   10562:	e8 fc ff ff ff       	call   10563 <DoRecoveryStep+0x9a>
   10567:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
  if(origCwnd < 0) {
   1056a:	83 7d d0 00          	cmpl   $0x0,0xffffffd0(%ebp)
   1056e:	79 53                	jns    105c3 <DoRecoveryStep+0xfa>
	  if(!disableSevereErrors)
   10570:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
   10577:	75 0c                	jne    10585 <DoRecoveryStep+0xbc>
		  printk("recoveryStep: OrigCwnd undefined\n");
   10579:	c7 04 24 80 4d 00 00 	movl   $0x4d80,(%esp,1)
   10580:	e8 fc ff ff ff       	call   10581 <DoRecoveryStep+0xb8>
	  free_trickles_msk((*cont)->sk,(*cont));
   10585:	8b 45 08             	mov    0x8(%ebp),%eax
   10588:	8b 00                	mov    (%eax),%eax
   1058a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1058e:	8b 45 08             	mov    0x8(%ebp),%eax
   10591:	8b 00                	mov    (%eax),%eax
   10593:	8b 40 20             	mov    0x20(%eax),%eax
   10596:	89 04 24             	mov    %eax,(%esp,1)
   10599:	e8 f7 d8 ff ff       	call   de95 <free_trickles_msk>
	  free_trickles_msk_finish((*cont)->sk,(*cont));
   1059e:	8b 45 08             	mov    0x8(%ebp),%eax
   105a1:	8b 00                	mov    (%eax),%eax
   105a3:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   105a7:	8b 45 08             	mov    0x8(%ebp),%eax
   105aa:	8b 00                	mov    (%eax),%eax
   105ac:	8b 40 20             	mov    0x20(%eax),%eax
   105af:	89 04 24             	mov    %eax,(%esp,1)
   105b2:	e8 7c d9 ff ff       	call   df33 <free_trickles_msk_finish>
	  return -EINVAL;
   105b7:	c7 45 8c ea ff ff ff 	movl   $0xffffffea,0xffffff8c(%ebp)
   105be:	e9 8d 09 00 00       	jmp    10f50 <DoRecoveryStep+0xa87>
  }
  (*cont)->state = CONT_RECOVERY;
   105c3:	8b 45 08             	mov    0x8(%ebp),%eax
   105c6:	8b 00                	mov    (%eax),%eax
   105c8:	c7 40 54 01 00 00 00 	movl   $0x1,0x54(%eax)
  (*cont)->firstLoss = AckProof_firstLoss(ackProof);
   105cf:	8b 45 08             	mov    0x8(%ebp),%eax
   105d2:	8b 18                	mov    (%eax),%ebx
   105d4:	8b 45 0c             	mov    0xc(%ebp),%eax
   105d7:	89 04 24             	mov    %eax,(%esp,1)
   105da:	e8 fc ff ff ff       	call   105db <DoRecoveryStep+0x112>
   105df:	89 43 5c             	mov    %eax,0x5c(%ebx)
  switch(CONTTYPE((*cont)->firstLoss - (*cont)->TCPBase)) {
   105e2:	8b 45 08             	mov    0x8(%ebp),%eax
   105e5:	8b 08                	mov    (%eax),%ecx
   105e7:	8b 45 08             	mov    0x8(%ebp),%eax
   105ea:	8b 00                	mov    (%eax),%eax
   105ec:	8b 50 6c             	mov    0x6c(%eax),%edx
   105ef:	8b 41 5c             	mov    0x5c(%ecx),%eax
   105f2:	29 d0                	sub    %edx,%eax
   105f4:	83 f8 07             	cmp    $0x7,%eax
   105f7:	76 2b                	jbe    10624 <DoRecoveryStep+0x15b>
   105f9:	8b 45 08             	mov    0x8(%ebp),%eax
   105fc:	8b 08                	mov    (%eax),%ecx
   105fe:	8b 45 08             	mov    0x8(%ebp),%eax
   10601:	8b 00                	mov    (%eax),%eax
   10603:	8b 50 6c             	mov    0x6c(%eax),%edx
   10606:	8b 41 5c             	mov    0x5c(%ecx),%eax
   10609:	29 d0                	sub    %edx,%eax
   1060b:	83 e0 01             	and    $0x1,%eax
   1060e:	85 c0                	test   %eax,%eax
   10610:	75 09                	jne    1061b <DoRecoveryStep+0x152>
   10612:	c7 45 88 02 00 00 00 	movl   $0x2,0xffffff88(%ebp)
   10619:	eb 10                	jmp    1062b <DoRecoveryStep+0x162>
   1061b:	c7 45 88 00 00 00 00 	movl   $0x0,0xffffff88(%ebp)
   10622:	eb 07                	jmp    1062b <DoRecoveryStep+0x162>
   10624:	c7 45 88 01 00 00 00 	movl   $0x1,0xffffff88(%ebp)
   1062b:	83 7d 88 00          	cmpl   $0x0,0xffffff88(%ebp)
   1062f:	78 62                	js     10693 <DoRecoveryStep+0x1ca>
   10631:	83 7d 88 01          	cmpl   $0x1,0xffffff88(%ebp)
   10635:	7e 08                	jle    1063f <DoRecoveryStep+0x176>
   10637:	83 7d 88 02          	cmpl   $0x2,0xffffff88(%ebp)
   1063b:	74 2d                	je     1066a <DoRecoveryStep+0x1a1>
   1063d:	eb 54                	jmp    10693 <DoRecoveryStep+0x1ca>
  case CONTTYPE_FULL1: // fall-through
  case CONTTYPE_MINIMAL:
    origCwndPred = AckTCPCwndScalar(AckProof_firstLoss(ackProof)-1, (*cont));
   1063f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10642:	89 04 24             	mov    %eax,(%esp,1)
   10645:	e8 fc ff ff ff       	call   10646 <DoRecoveryStep+0x17d>
   1064a:	8d 50 ff             	lea    0xffffffff(%eax),%edx
   1064d:	8b 45 08             	mov    0x8(%ebp),%eax
   10650:	8b 00                	mov    (%eax),%eax
   10652:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10656:	89 14 24             	mov    %edx,(%esp,1)
   10659:	e8 fc ff ff ff       	call   1065a <DoRecoveryStep+0x191>
   1065e:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    adj = 0;
   10661:	c7 45 c0 00 00 00 00 	movl   $0x0,0xffffffc0(%ebp)
    break;
   10668:	eb 29                	jmp    10693 <DoRecoveryStep+0x1ca>
  case CONTTYPE_FULL2:
    origCwndPred = AckTCPCwndScalar(AckProof_firstLoss(ackProof)-2, (*cont));
   1066a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1066d:	89 04 24             	mov    %eax,(%esp,1)
   10670:	e8 fc ff ff ff       	call   10671 <DoRecoveryStep+0x1a8>
   10675:	8d 50 fe             	lea    0xfffffffe(%eax),%edx
   10678:	8b 45 08             	mov    0x8(%ebp),%eax
   1067b:	8b 00                	mov    (%eax),%eax
   1067d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10681:	89 14 24             	mov    %edx,(%esp,1)
   10684:	e8 fc ff ff ff       	call   10685 <DoRecoveryStep+0x1bc>
   10689:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
    adj = -1;
   1068c:	c7 45 c0 ff ff ff ff 	movl   $0xffffffff,0xffffffc0(%ebp)
    break;
  }
  if(origCwnd < origCwndPred) {
   10693:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   10696:	3b 45 cc             	cmp    0xffffffcc(%ebp),%eax
   10699:	7d 4a                	jge    106e5 <DoRecoveryStep+0x21c>
    printk("recoveryStep: OrigCwnd < OrigCwndPred\n");
   1069b:	c7 04 24 c0 4d 00 00 	movl   $0x4dc0,(%esp,1)
   106a2:	e8 fc ff ff ff       	call   106a3 <DoRecoveryStep+0x1da>
    free_trickles_msk((*cont)->sk,(*cont));
   106a7:	8b 45 08             	mov    0x8(%ebp),%eax
   106aa:	8b 00                	mov    (%eax),%eax
   106ac:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   106b0:	8b 45 08             	mov    0x8(%ebp),%eax
   106b3:	8b 00                	mov    (%eax),%eax
   106b5:	8b 40 20             	mov    0x20(%eax),%eax
   106b8:	89 04 24             	mov    %eax,(%esp,1)
   106bb:	e8 d5 d7 ff ff       	call   de95 <free_trickles_msk>
    free_trickles_msk_finish((*cont)->sk,(*cont));
   106c0:	8b 45 08             	mov    0x8(%ebp),%eax
   106c3:	8b 00                	mov    (%eax),%eax
   106c5:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   106c9:	8b 45 08             	mov    0x8(%ebp),%eax
   106cc:	8b 00                	mov    (%eax),%eax
   106ce:	8b 40 20             	mov    0x20(%eax),%eax
   106d1:	89 04 24             	mov    %eax,(%esp,1)
   106d4:	e8 5a d8 ff ff       	call   df33 <free_trickles_msk_finish>
    return -EINVAL;
   106d9:	c7 45 8c ea ff ff ff 	movl   $0xffffffea,0xffffff8c(%ebp)
   106e0:	e9 6b 08 00 00       	jmp    10f50 <DoRecoveryStep+0xa87>
  }
  lastRegularPacket =  ((*cont)->firstLoss - 1 + adj) + origCwndPred;
   106e5:	8b 45 08             	mov    0x8(%ebp),%eax
   106e8:	8b 10                	mov    (%eax),%edx
   106ea:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
   106ed:	03 42 5c             	add    0x5c(%edx),%eax
   106f0:	03 45 cc             	add    0xffffffcc(%ebp),%eax
   106f3:	48                   	dec    %eax
   106f4:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
  (*cont)->num_packets = 0;
   106f7:	8b 45 08             	mov    0x8(%ebp),%eax
   106fa:	8b 00                	mov    (%eax),%eax
   106fc:	c7 80 e8 00 00 00 00 	movl   $0x0,0xe8(%eax)
   10703:	00 00 00 

#if 0  // 0615
  printk("EffCwnd (recoverystep): %d\n", origCwnd);
#endif

  newCwnd = origCwnd / MULT_FACTOR;
   10706:	8b 55 d0             	mov    0xffffffd0(%ebp),%edx
   10709:	89 d0                	mov    %edx,%eax
   1070b:	c1 f8 1f             	sar    $0x1f,%eax
   1070e:	c1 e8 1f             	shr    $0x1f,%eax
   10711:	8d 04 10             	lea    (%eax,%edx,1),%eax
   10714:	d1 f8                	sar    %eax
   10716:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)

  (*cont)->actualCwnd = newCwnd;
   10719:	8b 45 08             	mov    0x8(%ebp),%eax
   1071c:	8b 10                	mov    (%eax),%edx
   1071e:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   10721:	89 82 e0 00 00 00    	mov    %eax,0xe0(%edx)

  // FIXME: should allow 2 different TCPBase in CMinisock, since
  // bootstrap and rtx ought to have different TCPBase
  (*cont)->TCPBase = (*cont)->firstBootstrapSeq = lastRegularPacket + 1;
   10727:	8b 45 08             	mov    0x8(%ebp),%eax
   1072a:	8b 08                	mov    (%eax),%ecx
   1072c:	8b 45 08             	mov    0x8(%ebp),%eax
   1072f:	8b 10                	mov    (%eax),%edx
   10731:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
   10734:	40                   	inc    %eax
   10735:	89 42 60             	mov    %eax,0x60(%edx)
   10738:	8b 42 60             	mov    0x60(%edx),%eax
   1073b:	89 41 6c             	mov    %eax,0x6c(%ecx)
  (*cont)->startCwnd = newCwnd;
   1073e:	8b 45 08             	mov    0x8(%ebp),%eax
   10741:	8b 10                	mov    (%eax),%edx
   10743:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   10746:	89 42 64             	mov    %eax,0x64(%edx)
#ifndef ZERO_SSTHRESH_PROTECTION_HACK
  (*cont)->ssthresh = newCwnd;
#else
  if(newCwnd == 0)
   10749:	83 7d c8 00          	cmpl   $0x0,0xffffffc8(%ebp)
   1074d:	75 14                	jne    10763 <DoRecoveryStep+0x29a>
    (*cont)->ssthresh /= MULT_FACTOR;
   1074f:	8b 45 08             	mov    0x8(%ebp),%eax
   10752:	8b 10                	mov    (%eax),%edx
   10754:	8b 45 08             	mov    0x8(%ebp),%eax
   10757:	8b 00                	mov    (%eax),%eax
   10759:	8b 40 68             	mov    0x68(%eax),%eax
   1075c:	d1 e8                	shr    %eax
   1075e:	89 42 68             	mov    %eax,0x68(%edx)
   10761:	eb 0b                	jmp    1076e <DoRecoveryStep+0x2a5>
  else
    (*cont)->ssthresh = newCwnd;
   10763:	8b 45 08             	mov    0x8(%ebp),%eax
   10766:	8b 10                	mov    (%eax),%edx
   10768:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   1076b:	89 42 68             	mov    %eax,0x68(%edx)
#endif

  bootstrapStart = lastRegularPacket - newCwnd;
   1076e:	8b 55 c8             	mov    0xffffffc8(%ebp),%edx
   10771:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
   10774:	29 d0                	sub    %edx,%eax
   10776:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  bootstrapEnd = bootstrapStart + newCwnd - 1;
   10779:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   1077c:	03 45 e8             	add    0xffffffe8(%ebp),%eax
   1077f:	48                   	dec    %eax
   10780:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)

  //printk("Bootstrap range = [%d,%d)\n", bootstrapStart, bootstrapEnd);

  // XXX 0427 TODO: Remove first transport child processing

  /* Find the number of gaps */
  for(i=0; i < ackProof->numSacks; i++) {
   10783:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
   1078a:	8b 55 0c             	mov    0xc(%ebp),%edx
   1078d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   10790:	3b 02                	cmp    (%edx),%eax
   10792:	7c 05                	jl     10799 <DoRecoveryStep+0x2d0>
   10794:	e9 96 01 00 00       	jmp    1092f <DoRecoveryStep+0x466>
    int cursorgap = 0;
   10799:	c7 45 a4 00 00 00 00 	movl   $0x0,0xffffffa4(%ebp)
    if(i > 0 && !Sack_adjacent(&sacks[i-1], &sacks[i])) {
   107a0:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
   107a4:	0f 8e c2 00 00 00    	jle    1086c <DoRecoveryStep+0x3a3>
   107aa:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   107ad:	89 d0                	mov    %edx,%eax
   107af:	01 c0                	add    %eax,%eax
   107b1:	01 d0                	add    %edx,%eax
   107b3:	c1 e0 02             	shl    $0x2,%eax
   107b6:	03 45 f4             	add    0xfffffff4(%ebp),%eax
   107b9:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   107bd:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   107c0:	89 d0                	mov    %edx,%eax
   107c2:	01 c0                	add    %eax,%eax
   107c4:	01 d0                	add    %edx,%eax
   107c6:	c1 e0 02             	shl    $0x2,%eax
   107c9:	03 45 f4             	add    0xfffffff4(%ebp),%eax
   107cc:	83 e8 0c             	sub    $0xc,%eax
   107cf:	89 04 24             	mov    %eax,(%esp,1)
   107d2:	e8 fc ff ff ff       	call   107d3 <DoRecoveryStep+0x30a>
   107d7:	85 c0                	test   %eax,%eax
   107d9:	0f 85 8d 00 00 00    	jne    1086c <DoRecoveryStep+0x3a3>
      gaplen = Sack_gapLen(&sacks[i-1], &sacks[i]);
   107df:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   107e2:	89 d0                	mov    %edx,%eax
   107e4:	01 c0                	add    %eax,%eax
   107e6:	01 d0                	add    %edx,%eax
   107e8:	c1 e0 02             	shl    $0x2,%eax
   107eb:	03 45 f4             	add    0xfffffff4(%ebp),%eax
   107ee:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   107f2:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   107f5:	89 d0                	mov    %edx,%eax
   107f7:	01 c0                	add    %eax,%eax
   107f9:	01 d0                	add    %edx,%eax
   107fb:	c1 e0 02             	shl    $0x2,%eax
   107fe:	03 45 f4             	add    0xfffffff4(%ebp),%eax
   10801:	83 e8 0c             	sub    $0xc,%eax
   10804:	89 04 24             	mov    %eax,(%esp,1)
   10807:	e8 fc ff ff ff       	call   10808 <DoRecoveryStep+0x33f>
   1080c:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
      cursorgap = 1;
   1080f:	c7 45 a4 01 00 00 00 	movl   $0x1,0xffffffa4(%ebp)
      numLosses += gaplen;
   10816:	8b 55 c4             	mov    0xffffffc4(%ebp),%edx
   10819:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   1081c:	01 10                	add    %edx,(%eax)
      numBootstrapLosses += 
   1081e:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   10821:	89 d0                	mov    %edx,%eax
   10823:	01 c0                	add    %eax,%eax
   10825:	01 d0                	add    %edx,%eax
   10827:	c1 e0 02             	shl    $0x2,%eax
   1082a:	03 45 f4             	add    0xfffffff4(%ebp),%eax
   1082d:	83 e8 0c             	sub    $0xc,%eax
   10830:	8b 48 04             	mov    0x4(%eax),%ecx
   10833:	41                   	inc    %ecx
   10834:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   10837:	89 d0                	mov    %edx,%eax
   10839:	01 c0                	add    %eax,%eax
   1083b:	01 d0                	add    %edx,%eax
   1083d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10844:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   10847:	8b 14 10             	mov    (%eax,%edx,1),%edx
   1084a:	4a                   	dec    %edx
   1084b:	89 4c 24 0c          	mov    %ecx,0xc(%esp,1)
   1084f:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   10852:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   10856:	89 54 24 04          	mov    %edx,0x4(%esp,1)
   1085a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1085d:	89 04 24             	mov    %eax,(%esp,1)
   10860:	e8 e4 fb ff ff       	call   10449 <intersect>
   10865:	89 c2                	mov    %eax,%edx
   10867:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   1086a:	01 10                	add    %edx,(%eax)
	intersect(bootstrapStart, sacks[i].left-1,
		  bootstrapEnd, sacks[i-1].right+1);
    }
    if(Sack_contains(&ackProof->sacks[i], (*cont)->seq)) {
   1086c:	8b 45 08             	mov    0x8(%ebp),%eax
   1086f:	8b 00                	mov    (%eax),%eax
   10871:	8b 40 30             	mov    0x30(%eax),%eax
   10874:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10878:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   1087b:	89 d0                	mov    %edx,%eax
   1087d:	01 c0                	add    %eax,%eax
   1087f:	01 d0                	add    %edx,%eax
   10881:	c1 e0 02             	shl    $0x2,%eax
   10884:	03 45 0c             	add    0xc(%ebp),%eax
   10887:	83 c0 08             	add    $0x8,%eax
   1088a:	89 04 24             	mov    %eax,(%esp,1)
   1088d:	e8 fc ff ff ff       	call   1088e <DoRecoveryStep+0x3c5>
   10892:	85 c0                	test   %eax,%eax
   10894:	0f 84 8b 00 00 00    	je     10925 <DoRecoveryStep+0x45c>
      if(((*cont)->seq == sacks[i].left || 
   1089a:	8b 45 08             	mov    0x8(%ebp),%eax
   1089d:	8b 18                	mov    (%eax),%ebx
   1089f:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   108a2:	89 d0                	mov    %edx,%eax
   108a4:	01 c0                	add    %eax,%eax
   108a6:	01 d0                	add    %edx,%eax
   108a8:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   108af:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   108b2:	8b 43 30             	mov    0x30(%ebx),%eax
   108b5:	3b 04 0a             	cmp    (%edx,%ecx,1),%eax
   108b8:	74 2e                	je     108e8 <DoRecoveryStep+0x41f>
   108ba:	8b 45 08             	mov    0x8(%ebp),%eax
   108bd:	8b 00                	mov    (%eax),%eax
   108bf:	83 78 34 02          	cmpl   $0x2,0x34(%eax)
   108c3:	75 60                	jne    10925 <DoRecoveryStep+0x45c>
   108c5:	8b 45 08             	mov    0x8(%ebp),%eax
   108c8:	8b 00                	mov    (%eax),%eax
   108ca:	8b 48 30             	mov    0x30(%eax),%ecx
   108cd:	49                   	dec    %ecx
   108ce:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   108d1:	89 d0                	mov    %edx,%eax
   108d3:	01 c0                	add    %eax,%eax
   108d5:	01 d0                	add    %edx,%eax
   108d7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   108de:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   108e1:	3b 0c 10             	cmp    (%eax,%edx,1),%ecx
   108e4:	74 02                	je     108e8 <DoRecoveryStep+0x41f>
   108e6:	eb 3d                	jmp    10925 <DoRecoveryStep+0x45c>
   108e8:	83 7d a4 00          	cmpl   $0x0,0xffffffa4(%ebp)
   108ec:	74 37                	je     10925 <DoRecoveryStep+0x45c>
	  ((*cont)->continuationType == CONTTYPE_FULL2 && (*cont)->seq - 1 == sacks[i].left))
	  && cursorgap) {
	/* detected gap; measure size of gap */
	afterGap = 1;
   108ee:	c7 45 e0 01 00 00 00 	movl   $0x1,0xffffffe0(%ebp)
	gapLeft = ackProof->sacks[i-1].right + 1,
   108f5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   108f8:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   108fb:	89 d0                	mov    %edx,%eax
   108fd:	01 c0                	add    %eax,%eax
   108ff:	01 d0                	add    %edx,%eax
   10901:	c1 e0 02             	shl    $0x2,%eax
   10904:	8b 04 01             	mov    (%ecx,%eax,1),%eax
   10907:	40                   	inc    %eax
   10908:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
   1090b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1090e:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   10911:	89 d0                	mov    %edx,%eax
   10913:	01 c0                	add    %eax,%eax
   10915:	01 d0                	add    %edx,%eax
   10917:	c1 e0 02             	shl    $0x2,%eax
   1091a:	01 c8                	add    %ecx,%eax
   1091c:	83 c0 08             	add    $0x8,%eax
   1091f:	8b 00                	mov    (%eax),%eax
   10921:	48                   	dec    %eax
   10922:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
   10925:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
   10928:	ff 00                	incl   (%eax)
   1092a:	e9 5b fe ff ff       	jmp    1078a <DoRecoveryStep+0x2c1>
	  gapRight = ackProof->sacks[i].left - 1;
      }
    }
  }

  if(serverDebugLevel >= 2) {
   1092f:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
   10936:	7e 17                	jle    1094f <DoRecoveryStep+0x486>
	  printk("RecoveryStep\n");
   10938:	c7 04 24 e7 4d 00 00 	movl   $0x4de7,(%esp,1)
   1093f:	e8 fc ff ff ff       	call   10940 <DoRecoveryStep+0x477>
	  AckProof_dump(ackProof);
   10944:	8b 45 0c             	mov    0xc(%ebp),%eax
   10947:	89 04 24             	mov    %eax,(%esp,1)
   1094a:	e8 fc ff ff ff       	call   1094b <DoRecoveryStep+0x482>
  }

  // Preallocate space for all packets that we are going to generate
  numPacketsSendable = 0;
   1094f:	c7 45 b4 00 00 00 00 	movl   $0x0,0xffffffb4(%ebp)
  numPacketsAllocated = 0;
   10956:	c7 45 b0 00 00 00 00 	movl   $0x0,0xffffffb0(%ebp)
  if(afterGap) {
   1095d:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
   10961:	74 7e                	je     109e1 <DoRecoveryStep+0x518>
    int start, end;
    numPacketsAllocated += (gapRight - gapLeft) + 1; // range is inclusive
   10963:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   10966:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   10969:	29 d0                	sub    %edx,%eax
   1096b:	03 45 b0             	add    0xffffffb0(%ebp),%eax
   1096e:	40                   	inc    %eax
   1096f:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
    /* intersect bootstrap range with gap */
    start = MAX(gapLeft, bootstrapStart);
   10972:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   10975:	89 45 9c             	mov    %eax,0xffffff9c(%ebp)
   10978:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   1097b:	89 45 98             	mov    %eax,0xffffff98(%ebp)
   1097e:	8b 45 9c             	mov    0xffffff9c(%ebp),%eax
   10981:	89 45 94             	mov    %eax,0xffffff94(%ebp)
   10984:	8b 45 94             	mov    0xffffff94(%ebp),%eax
   10987:	89 45 84             	mov    %eax,0xffffff84(%ebp)
   1098a:	8b 45 84             	mov    0xffffff84(%ebp),%eax
   1098d:	3b 45 98             	cmp    0xffffff98(%ebp),%eax
   10990:	7d 06                	jge    10998 <DoRecoveryStep+0x4cf>
   10992:	8b 45 98             	mov    0xffffff98(%ebp),%eax
   10995:	89 45 84             	mov    %eax,0xffffff84(%ebp)
   10998:	8b 45 84             	mov    0xffffff84(%ebp),%eax
   1099b:	89 45 a4             	mov    %eax,0xffffffa4(%ebp)
    end = MIN(gapRight, bootstrapEnd);
   1099e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   109a1:	89 45 94             	mov    %eax,0xffffff94(%ebp)
   109a4:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   109a7:	89 45 98             	mov    %eax,0xffffff98(%ebp)
   109aa:	8b 45 94             	mov    0xffffff94(%ebp),%eax
   109ad:	89 45 9c             	mov    %eax,0xffffff9c(%ebp)
   109b0:	8b 45 9c             	mov    0xffffff9c(%ebp),%eax
   109b3:	89 45 80             	mov    %eax,0xffffff80(%ebp)
   109b6:	8b 45 80             	mov    0xffffff80(%ebp),%eax
   109b9:	3b 45 98             	cmp    0xffffff98(%ebp),%eax
   109bc:	7e 06                	jle    109c4 <DoRecoveryStep+0x4fb>
   109be:	8b 45 98             	mov    0xffffff98(%ebp),%eax
   109c1:	89 45 80             	mov    %eax,0xffffff80(%ebp)
   109c4:	8b 45 80             	mov    0xffffff80(%ebp),%eax
   109c7:	89 45 a0             	mov    %eax,0xffffffa0(%ebp)
    if(start <= end) {
   109ca:	8b 45 a4             	mov    0xffffffa4(%ebp),%eax
   109cd:	3b 45 a0             	cmp    0xffffffa0(%ebp),%eax
   109d0:	7f 0f                	jg     109e1 <DoRecoveryStep+0x518>
      numPacketsAllocated += (end - start) + 1; // range is inclusive
   109d2:	8b 55 a4             	mov    0xffffffa4(%ebp),%edx
   109d5:	8b 45 a0             	mov    0xffffffa0(%ebp),%eax
   109d8:	29 d0                	sub    %edx,%eax
   109da:	03 45 b0             	add    0xffffffb0(%ebp),%eax
   109dd:	40                   	inc    %eax
   109de:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
    }
  }
  {
    /* intersect ack ack range with bootstrap range */
    bootstrapIntersectStart = MAX(FIRST_ACKSEQ((*cont)->continuationType, (*cont)->seq),
				  bootstrapStart);
   109e1:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   109e4:	89 45 94             	mov    %eax,0xffffff94(%ebp)
   109e7:	8b 45 08             	mov    0x8(%ebp),%eax
   109ea:	8b 00                	mov    (%eax),%eax
   109ec:	8b 40 30             	mov    0x30(%eax),%eax
   109ef:	89 85 7c ff ff ff    	mov    %eax,0xffffff7c(%ebp)
   109f5:	8b 45 08             	mov    0x8(%ebp),%eax
   109f8:	8b 00                	mov    (%eax),%eax
   109fa:	83 78 34 02          	cmpl   $0x2,0x34(%eax)
   109fe:	75 06                	jne    10a06 <DoRecoveryStep+0x53d>
   10a00:	ff 8d 7c ff ff ff    	decl   0xffffff7c(%ebp)
   10a06:	8b 85 7c ff ff ff    	mov    0xffffff7c(%ebp),%eax
   10a0c:	89 45 98             	mov    %eax,0xffffff98(%ebp)
   10a0f:	8b 45 94             	mov    0xffffff94(%ebp),%eax
   10a12:	89 45 9c             	mov    %eax,0xffffff9c(%ebp)
   10a15:	8b 45 9c             	mov    0xffffff9c(%ebp),%eax
   10a18:	89 85 78 ff ff ff    	mov    %eax,0xffffff78(%ebp)
   10a1e:	8b 85 78 ff ff ff    	mov    0xffffff78(%ebp),%eax
   10a24:	3b 45 98             	cmp    0xffffff98(%ebp),%eax
   10a27:	73 09                	jae    10a32 <DoRecoveryStep+0x569>
   10a29:	8b 45 98             	mov    0xffffff98(%ebp),%eax
   10a2c:	89 85 78 ff ff ff    	mov    %eax,0xffffff78(%ebp)
   10a32:	8b 85 78 ff ff ff    	mov    0xffffff78(%ebp),%eax
   10a38:	89 45 ac             	mov    %eax,0xffffffac(%ebp)
    bootstrapIntersectLast = MIN((*cont)->seq,
				 bootstrapEnd);
   10a3b:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   10a3e:	89 45 94             	mov    %eax,0xffffff94(%ebp)
   10a41:	8b 45 08             	mov    0x8(%ebp),%eax
   10a44:	8b 00                	mov    (%eax),%eax
   10a46:	8b 40 30             	mov    0x30(%eax),%eax
   10a49:	89 45 98             	mov    %eax,0xffffff98(%ebp)
   10a4c:	8b 45 94             	mov    0xffffff94(%ebp),%eax
   10a4f:	89 45 9c             	mov    %eax,0xffffff9c(%ebp)
   10a52:	8b 45 9c             	mov    0xffffff9c(%ebp),%eax
   10a55:	89 85 74 ff ff ff    	mov    %eax,0xffffff74(%ebp)
   10a5b:	8b 85 74 ff ff ff    	mov    0xffffff74(%ebp),%eax
   10a61:	3b 45 98             	cmp    0xffffff98(%ebp),%eax
   10a64:	76 09                	jbe    10a6f <DoRecoveryStep+0x5a6>
   10a66:	8b 45 98             	mov    0xffffff98(%ebp),%eax
   10a69:	89 85 74 ff ff ff    	mov    %eax,0xffffff74(%ebp)
   10a6f:	8b 85 74 ff ff ff    	mov    0xffffff74(%ebp),%eax
   10a75:	89 45 a8             	mov    %eax,0xffffffa8(%ebp)
    if(bootstrapIntersectStart <= bootstrapIntersectLast) {
   10a78:	8b 45 ac             	mov    0xffffffac(%ebp),%eax
   10a7b:	3b 45 a8             	cmp    0xffffffa8(%ebp),%eax
   10a7e:	7f 0f                	jg     10a8f <DoRecoveryStep+0x5c6>
      numPacketsAllocated += 
   10a80:	8b 55 ac             	mov    0xffffffac(%ebp),%edx
   10a83:	8b 45 a8             	mov    0xffffffa8(%ebp),%eax
   10a86:	29 d0                	sub    %edx,%eax
   10a88:	03 45 b0             	add    0xffffffb0(%ebp),%eax
   10a8b:	40                   	inc    %eax
   10a8c:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
	bootstrapIntersectLast - bootstrapIntersectStart + 1; // range is inclusive
    }
  }
  if(numPacketsAllocated == 0) {
   10a8f:	83 7d b0 00          	cmpl   $0x0,0xffffffb0(%ebp)
   10a93:	75 3e                	jne    10ad3 <DoRecoveryStep+0x60a>
    free_trickles_msk((*cont)->sk,(*cont));
   10a95:	8b 45 08             	mov    0x8(%ebp),%eax
   10a98:	8b 00                	mov    (%eax),%eax
   10a9a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10a9e:	8b 45 08             	mov    0x8(%ebp),%eax
   10aa1:	8b 00                	mov    (%eax),%eax
   10aa3:	8b 40 20             	mov    0x20(%eax),%eax
   10aa6:	89 04 24             	mov    %eax,(%esp,1)
   10aa9:	e8 e7 d3 ff ff       	call   de95 <free_trickles_msk>
    free_trickles_msk_finish((*cont)->sk,(*cont));
   10aae:	8b 45 08             	mov    0x8(%ebp),%eax
   10ab1:	8b 00                	mov    (%eax),%eax
   10ab3:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10ab7:	8b 45 08             	mov    0x8(%ebp),%eax
   10aba:	8b 00                	mov    (%eax),%eax
   10abc:	8b 40 20             	mov    0x20(%eax),%eax
   10abf:	89 04 24             	mov    %eax,(%esp,1)
   10ac2:	e8 6c d4 ff ff       	call   df33 <free_trickles_msk_finish>
    //printk("recovery no packets\n");
    return 0;
   10ac7:	c7 45 8c 00 00 00 00 	movl   $0x0,0xffffff8c(%ebp)
   10ace:	e9 7d 04 00 00       	jmp    10f50 <DoRecoveryStep+0xa87>
  }
  if(!alloc_msk_packets((*cont), numPacketsAllocated)) {
   10ad3:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
   10ad6:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10ada:	8b 45 08             	mov    0x8(%ebp),%eax
   10add:	8b 00                	mov    (%eax),%eax
   10adf:	89 04 24             	mov    %eax,(%esp,1)
   10ae2:	e8 bd 12 00 00       	call   11da4 <alloc_msk_packets>
   10ae7:	85 c0                	test   %eax,%eax
   10ae9:	75 4a                	jne    10b35 <DoRecoveryStep+0x66c>
    free_trickles_msk((*cont)->sk,(*cont));
   10aeb:	8b 45 08             	mov    0x8(%ebp),%eax
   10aee:	8b 00                	mov    (%eax),%eax
   10af0:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10af4:	8b 45 08             	mov    0x8(%ebp),%eax
   10af7:	8b 00                	mov    (%eax),%eax
   10af9:	8b 40 20             	mov    0x20(%eax),%eax
   10afc:	89 04 24             	mov    %eax,(%esp,1)
   10aff:	e8 91 d3 ff ff       	call   de95 <free_trickles_msk>
    free_trickles_msk_finish((*cont)->sk,(*cont));
   10b04:	8b 45 08             	mov    0x8(%ebp),%eax
   10b07:	8b 00                	mov    (%eax),%eax
   10b09:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10b0d:	8b 45 08             	mov    0x8(%ebp),%eax
   10b10:	8b 00                	mov    (%eax),%eax
   10b12:	8b 40 20             	mov    0x20(%eax),%eax
   10b15:	89 04 24             	mov    %eax,(%esp,1)
   10b18:	e8 16 d4 ff ff       	call   df33 <free_trickles_msk_finish>
    printk("recovery nomem\n");
   10b1d:	c7 04 24 f5 4d 00 00 	movl   $0x4df5,(%esp,1)
   10b24:	e8 fc ff ff ff       	call   10b25 <DoRecoveryStep+0x65c>
    return -ENOMEM;
   10b29:	c7 45 8c f4 ff ff ff 	movl   $0xfffffff4,0xffffff8c(%ebp)
   10b30:	e9 1b 04 00 00       	jmp    10f50 <DoRecoveryStep+0xa87>
  }

  if(afterGap) {
   10b35:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
   10b39:	0f 84 32 02 00 00    	je     10d71 <DoRecoveryStep+0x8a8>
    __u32 seq;
    if(serverDebugLevel >= 1) {
   10b3f:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
   10b46:	7e 34                	jle    10b7c <DoRecoveryStep+0x6b3>
      printk("  Bootstrap [%d - %d], newCwnd %d\n", bootstrapStart, bootstrapEnd, newCwnd);
   10b48:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   10b4b:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   10b4f:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   10b52:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   10b56:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   10b59:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10b5d:	c7 04 24 20 4e 00 00 	movl   $0x4e20,(%esp,1)
   10b64:	e8 fc ff ff ff       	call   10b65 <DoRecoveryStep+0x69c>
      printk("  Gaplen = %d (after gap)\n", gaplen);
   10b69:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
   10b6c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10b70:	c7 04 24 43 4e 00 00 	movl   $0x4e43,(%esp,1)
   10b77:	e8 fc ff ff ff       	call   10b78 <DoRecoveryStep+0x6af>
    }
    /* Generate retransmits */
    if(gapRight - gapLeft > MAX_GAPSIZE) {
   10b7c:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   10b7f:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   10b82:	29 c2                	sub    %eax,%edx
   10b84:	89 d0                	mov    %edx,%eax
   10b86:	83 f8 14             	cmp    $0x14,%eax
   10b89:	7e 3e                	jle    10bc9 <DoRecoveryStep+0x700>
          //printk("recoveryStep: gap too large (%u-%u)\n", gapLeft, gapRight);
	  free_trickles_msk((*cont)->sk,(*cont));
   10b8b:	8b 45 08             	mov    0x8(%ebp),%eax
   10b8e:	8b 00                	mov    (%eax),%eax
   10b90:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10b94:	8b 45 08             	mov    0x8(%ebp),%eax
   10b97:	8b 00                	mov    (%eax),%eax
   10b99:	8b 40 20             	mov    0x20(%eax),%eax
   10b9c:	89 04 24             	mov    %eax,(%esp,1)
   10b9f:	e8 f1 d2 ff ff       	call   de95 <free_trickles_msk>
	  free_trickles_msk_finish((*cont)->sk,(*cont));
   10ba4:	8b 45 08             	mov    0x8(%ebp),%eax
   10ba7:	8b 00                	mov    (%eax),%eax
   10ba9:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10bad:	8b 45 08             	mov    0x8(%ebp),%eax
   10bb0:	8b 00                	mov    (%eax),%eax
   10bb2:	8b 40 20             	mov    0x20(%eax),%eax
   10bb5:	89 04 24             	mov    %eax,(%esp,1)
   10bb8:	e8 76 d3 ff ff       	call   df33 <free_trickles_msk_finish>
	  if(trickles_ratelimit())
		  printk("recovery gapsize too big - %d\n", gapRight -  gapLeft);
	  return -EINVAL;
   10bbd:	c7 45 8c ea ff ff ff 	movl   $0xffffffea,0xffffff8c(%ebp)
   10bc4:	e9 87 03 00 00       	jmp    10f50 <DoRecoveryStep+0xa87>
    }
    for(seq = gapLeft; seq <= gapRight; seq++) {
   10bc9:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   10bcc:	89 45 94             	mov    %eax,0xffffff94(%ebp)
   10bcf:	8b 45 94             	mov    0xffffff94(%ebp),%eax
   10bd2:	3b 45 d8             	cmp    0xffffffd8(%ebp),%eax
   10bd5:	76 05                	jbe    10bdc <DoRecoveryStep+0x713>
   10bd7:	e9 77 01 00 00       	jmp    10d53 <DoRecoveryStep+0x88a>
      if(serverDebugLevel >= 1) {
	      //printk("  Gap rtx %u\n", seq);
      }
      //printk("retrans template %d\n", seq);
      makePacket(&(*cont)->packets[numPackets], seq, 0xdeadbeef, CONTTYPE_MINIMAL_MSS, PACKET_RETRANS, CONTTYPE_MINIMAL, CONTTYPE_MINIMAL_MSS, 
   10bdc:	c7 44 24 20 ff 00 00 	movl   $0xff,0x20(%esp,1)
   10be3:	00 
   10be4:	c7 44 24 1c ff ff ff 	movl   $0xffffffff,0x1c(%esp,1)
   10beb:	ff 
   10bec:	0f b7 05 00 00 00 00 	movzwl 0x0,%eax
   10bf3:	83 c0 35             	add    $0x35,%eax
   10bf6:	0f b7 c0             	movzwl %ax,%eax
   10bf9:	89 44 24 18          	mov    %eax,0x18(%esp,1)
   10bfd:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp,1)
   10c04:	00 
   10c05:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp,1)
   10c0c:	00 
   10c0d:	a1 00 00 00 00       	mov    0x0,%eax
   10c12:	83 c0 35             	add    $0x35,%eax
   10c15:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   10c19:	c7 44 24 08 ef be ad 	movl   $0xdeadbeef,0x8(%esp,1)
   10c20:	de 
   10c21:	8b 45 94             	mov    0xffffff94(%ebp),%eax
   10c24:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10c28:	8b 45 08             	mov    0x8(%ebp),%eax
   10c2b:	8b 08                	mov    (%eax),%ecx
   10c2d:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
   10c30:	89 d0                	mov    %edx,%eax
   10c32:	c1 e0 03             	shl    $0x3,%eax
   10c35:	01 d0                	add    %edx,%eax
   10c37:	c1 e0 02             	shl    $0x2,%eax
   10c3a:	03 81 ec 00 00 00    	add    0xec(%ecx),%eax
   10c40:	89 04 24             	mov    %eax,(%esp,1)
   10c43:	e8 71 09 00 00       	call   115b9 <makePacket>
			 -1, -1);
      numPackets++;
   10c48:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   10c4b:	ff 00                	incl   (%eax)
      /* retransmit bootstrap packets that should have been clocked out by missing packets */
      /* xxx: merge with identical code below */
      if(seq >= bootstrapStart && seq <= bootstrapEnd) {
   10c4d:	8b 45 94             	mov    0xffffff94(%ebp),%eax
   10c50:	3b 45 e8             	cmp    0xffffffe8(%ebp),%eax
   10c53:	0f 82 f0 00 00 00    	jb     10d49 <DoRecoveryStep+0x880>
   10c59:	8b 45 94             	mov    0xffffff94(%ebp),%eax
   10c5c:	3b 45 e4             	cmp    0xffffffe4(%ebp),%eax
   10c5f:	0f 87 e4 00 00 00    	ja     10d49 <DoRecoveryStep+0x880>
	      gNumBootstrapResponses++;
   10c65:	ff 05 00 00 00 00    	incl   0x0
	__u32 bootstrap_seq = lastRegularPacket + 1 + (seq - bootstrapStart);
   10c6b:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   10c6e:	8b 45 94             	mov    0xffffff94(%ebp),%eax
   10c71:	29 d0                	sub    %edx,%eax
   10c73:	03 45 b8             	add    0xffffffb8(%ebp),%eax
   10c76:	40                   	inc    %eax
   10c77:	89 45 98             	mov    %eax,0xffffff98(%ebp)
	unsigned firstChild;
	int numChildren, prevCwnd, currCwnd;
	if(serverDebugLevel >= 1) {
		//printk("  Gap bootstrap %u\n", bootstrap_seq);
	}
	if(seq == bootstrapStart) {
		// XXX Record number of bootstrap ranges here
	}
	if(bootstrap_seq == (*cont)->TCPBase) {
   10c7a:	8b 45 08             	mov    0x8(%ebp),%eax
   10c7d:	8b 10                	mov    (%eax),%edx
   10c7f:	8b 45 98             	mov    0xffffff98(%ebp),%eax
   10c82:	3b 42 6c             	cmp    0x6c(%edx),%eax
   10c85:	75 17                	jne    10c9e <DoRecoveryStep+0x7d5>
		// corner case
		firstChild = bootstrap_seq + (*cont)->startCwnd;
   10c87:	8b 45 08             	mov    0x8(%ebp),%eax
   10c8a:	8b 00                	mov    (%eax),%eax
   10c8c:	8b 40 64             	mov    0x64(%eax),%eax
   10c8f:	03 45 98             	add    0xffffff98(%ebp),%eax
   10c92:	89 45 9c             	mov    %eax,0xffffff9c(%ebp)
		numChildren = 1;
   10c95:	c7 45 a0 01 00 00 00 	movl   $0x1,0xffffffa0(%ebp)
   10c9c:	eb 44                	jmp    10ce2 <DoRecoveryStep+0x819>
	} else {
		prevCwnd = AckTCPCwndScalar(bootstrap_seq - 1, *cont);
   10c9e:	8b 45 08             	mov    0x8(%ebp),%eax
   10ca1:	8b 00                	mov    (%eax),%eax
   10ca3:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10ca7:	8b 45 98             	mov    0xffffff98(%ebp),%eax
   10caa:	48                   	dec    %eax
   10cab:	89 04 24             	mov    %eax,(%esp,1)
   10cae:	e8 fc ff ff ff       	call   10caf <DoRecoveryStep+0x7e6>
   10cb3:	89 45 a4             	mov    %eax,0xffffffa4(%ebp)
		currCwnd = AckTCPCwndScalar(bootstrap_seq, *cont);
   10cb6:	8b 45 08             	mov    0x8(%ebp),%eax
   10cb9:	8b 00                	mov    (%eax),%eax
   10cbb:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10cbf:	8b 45 98             	mov    0xffffff98(%ebp),%eax
   10cc2:	89 04 24             	mov    %eax,(%esp,1)
   10cc5:	e8 fc ff ff ff       	call   10cc6 <DoRecoveryStep+0x7fd>
   10cca:	89 45 90             	mov    %eax,0xffffff90(%ebp)
		firstChild = bootstrap_seq + prevCwnd;
   10ccd:	8b 45 a4             	mov    0xffffffa4(%ebp),%eax
   10cd0:	03 45 98             	add    0xffffff98(%ebp),%eax
   10cd3:	89 45 9c             	mov    %eax,0xffffff9c(%ebp)
		numChildren = currCwnd - prevCwnd + 1;
   10cd6:	8b 55 a4             	mov    0xffffffa4(%ebp),%edx
   10cd9:	8b 45 90             	mov    0xffffff90(%ebp),%eax
   10cdc:	29 d0                	sub    %edx,%eax
   10cde:	40                   	inc    %eax
   10cdf:	89 45 a0             	mov    %eax,0xffffffa0(%ebp)
	}

	//printk("0: bootstrap packet template %d\n", seq);
	makePacket(&(*cont)->packets[numPackets],
   10ce2:	0f b6 45 a0          	movzbl 0xffffffa0(%ebp),%eax
   10ce6:	89 44 24 20          	mov    %eax,0x20(%esp,1)
   10cea:	8b 45 9c             	mov    0xffffff9c(%ebp),%eax
   10ced:	89 44 24 1c          	mov    %eax,0x1c(%esp,1)
   10cf1:	0f b7 05 00 00 00 00 	movzwl 0x0,%eax
   10cf8:	89 44 24 18          	mov    %eax,0x18(%esp,1)
   10cfc:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp,1)
   10d03:	00 
   10d04:	c7 44 24 10 02 00 00 	movl   $0x2,0x10(%esp,1)
   10d0b:	00 
   10d0c:	a1 00 00 00 00       	mov    0x0,%eax
   10d11:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   10d15:	c7 44 24 08 ef be ad 	movl   $0xdeadbeef,0x8(%esp,1)
   10d1c:	de 
   10d1d:	8b 45 98             	mov    0xffffff98(%ebp),%eax
   10d20:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10d24:	8b 45 08             	mov    0x8(%ebp),%eax
   10d27:	8b 08                	mov    (%eax),%ecx
   10d29:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
   10d2c:	89 d0                	mov    %edx,%eax
   10d2e:	c1 e0 03             	shl    $0x3,%eax
   10d31:	01 d0                	add    %edx,%eax
   10d33:	c1 e0 02             	shl    $0x2,%eax
   10d36:	03 81 ec 00 00 00    	add    0xec(%ecx),%eax
   10d3c:	89 04 24             	mov    %eax,(%esp,1)
   10d3f:	e8 75 08 00 00       	call   115b9 <makePacket>
		   bootstrap_seq, 0xdeadbeef, CONTTYPE_FULL_MSS,
		   PACKET_BOOTSTRAP, CONTTYPE_FULL1, CONTTYPE_FULL_MSS,
		   firstChild, numChildren);
	numPackets++;
   10d44:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   10d47:	ff 00                	incl   (%eax)
   10d49:	8d 45 94             	lea    0xffffff94(%ebp),%eax
   10d4c:	ff 00                	incl   (%eax)
   10d4e:	e9 7c fe ff ff       	jmp    10bcf <DoRecoveryStep+0x706>
      }
    }
    if(serverDebugLevel >= 1) {
   10d53:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
   10d5a:	7e 2a                	jle    10d86 <DoRecoveryStep+0x8bd>
      printk("  After RTX: %u packets\n", numPackets);
   10d5c:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   10d5f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10d63:	c7 04 24 5e 4e 00 00 	movl   $0x4e5e,(%esp,1)
   10d6a:	e8 fc ff ff ff       	call   10d6b <DoRecoveryStep+0x8a2>
   10d6f:	eb 15                	jmp    10d86 <DoRecoveryStep+0x8bd>
    }
  } else {
    if(serverDebugLevel >= 2) {
   10d71:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
   10d78:	7e 0c                	jle    10d86 <DoRecoveryStep+0x8bd>
      printk("  Not after gap\n");
   10d7a:	c7 04 24 77 4e 00 00 	movl   $0x4e77,(%esp,1)
   10d81:	e8 fc ff ff ff       	call   10d82 <DoRecoveryStep+0x8b9>
    }
  }
  /* Transmit bootstrap packets in 2nd half of recovery interval */
  BUG_TRAP((*cont)->continuationType == CONTTYPE_FULL1 ||
	   (*cont)->continuationType == CONTTYPE_FULL2);
   10d86:	8b 45 08             	mov    0x8(%ebp),%eax
   10d89:	8b 00                	mov    (%eax),%eax
   10d8b:	83 78 34 01          	cmpl   $0x1,0x34(%eax)
   10d8f:	74 1f                	je     10db0 <DoRecoveryStep+0x8e7>
   10d91:	8b 45 08             	mov    0x8(%ebp),%eax
   10d94:	8b 00                	mov    (%eax),%eax
   10d96:	83 78 34 02          	cmpl   $0x2,0x34(%eax)
   10d9a:	74 14                	je     10db0 <DoRecoveryStep+0x8e7>
   10d9c:	c7 44 24 04 ef 06 00 	movl   $0x6ef,0x4(%esp,1)
   10da3:	00 
   10da4:	c7 04 24 a0 4e 00 00 	movl   $0x4ea0,(%esp,1)
   10dab:	e8 fc ff ff ff       	call   10dac <DoRecoveryStep+0x8e3>
  for(ack_seq = bootstrapIntersectStart;
   10db0:	8b 45 ac             	mov    0xffffffac(%ebp),%eax
   10db3:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
   10db6:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
   10db9:	3b 45 a8             	cmp    0xffffffa8(%ebp),%eax
   10dbc:	76 05                	jbe    10dc3 <DoRecoveryStep+0x8fa>
   10dbe:	e9 20 01 00 00       	jmp    10ee3 <DoRecoveryStep+0xa1a>
      ack_seq <= bootstrapIntersectLast;
      ack_seq++) {
    /* Eventually, clock out newCwnd bootstrap packets. Clock out one
       here */
    __u32 seq = lastRegularPacket + 1 + (ack_seq - bootstrapStart);
   10dc3:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   10dc6:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
   10dc9:	29 d0                	sub    %edx,%eax
   10dcb:	03 45 b8             	add    0xffffffb8(%ebp),%eax
   10dce:	40                   	inc    %eax
   10dcf:	89 45 90             	mov    %eax,0xffffff90(%ebp)
    unsigned firstChild;
    int numChildren, prevCwnd, currCwnd;

    if(serverDebugLevel >= 1)
   10dd2:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
   10dd9:	7e 13                	jle    10dee <DoRecoveryStep+0x925>
      printk("  Bootstrap %u\n", seq);
   10ddb:	8b 45 90             	mov    0xffffff90(%ebp),%eax
   10dde:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10de2:	c7 04 24 30 4f 00 00 	movl   $0x4f30,(%esp,1)
   10de9:	e8 fc ff ff ff       	call   10dea <DoRecoveryStep+0x921>

    /* copied from above */
    if(seq == (*cont)->TCPBase) {
   10dee:	8b 45 08             	mov    0x8(%ebp),%eax
   10df1:	8b 10                	mov    (%eax),%edx
   10df3:	8b 45 90             	mov    0xffffff90(%ebp),%eax
   10df6:	3b 42 6c             	cmp    0x6c(%edx),%eax
   10df9:	75 17                	jne    10e12 <DoRecoveryStep+0x949>
      // corner case
      firstChild = seq + (*cont)->startCwnd;
   10dfb:	8b 45 08             	mov    0x8(%ebp),%eax
   10dfe:	8b 00                	mov    (%eax),%eax
   10e00:	8b 40 64             	mov    0x64(%eax),%eax
   10e03:	03 45 90             	add    0xffffff90(%ebp),%eax
   10e06:	89 45 98             	mov    %eax,0xffffff98(%ebp)
      numChildren = 1;
   10e09:	c7 45 9c 01 00 00 00 	movl   $0x1,0xffffff9c(%ebp)
   10e10:	eb 44                	jmp    10e56 <DoRecoveryStep+0x98d>
    } else {
      prevCwnd = AckTCPCwndScalar(seq - 1, *cont);
   10e12:	8b 45 08             	mov    0x8(%ebp),%eax
   10e15:	8b 00                	mov    (%eax),%eax
   10e17:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10e1b:	8b 45 90             	mov    0xffffff90(%ebp),%eax
   10e1e:	48                   	dec    %eax
   10e1f:	89 04 24             	mov    %eax,(%esp,1)
   10e22:	e8 fc ff ff ff       	call   10e23 <DoRecoveryStep+0x95a>
   10e27:	89 45 a0             	mov    %eax,0xffffffa0(%ebp)
      currCwnd = AckTCPCwndScalar(seq, *cont);
   10e2a:	8b 45 08             	mov    0x8(%ebp),%eax
   10e2d:	8b 00                	mov    (%eax),%eax
   10e2f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10e33:	8b 45 90             	mov    0xffffff90(%ebp),%eax
   10e36:	89 04 24             	mov    %eax,(%esp,1)
   10e39:	e8 fc ff ff ff       	call   10e3a <DoRecoveryStep+0x971>
   10e3e:	89 45 a4             	mov    %eax,0xffffffa4(%ebp)
      firstChild = seq + prevCwnd;
   10e41:	8b 45 a0             	mov    0xffffffa0(%ebp),%eax
   10e44:	03 45 90             	add    0xffffff90(%ebp),%eax
   10e47:	89 45 98             	mov    %eax,0xffffff98(%ebp)
      numChildren = currCwnd - prevCwnd + 1;
   10e4a:	8b 55 a0             	mov    0xffffffa0(%ebp),%edx
   10e4d:	8b 45 a4             	mov    0xffffffa4(%ebp),%eax
   10e50:	29 d0                	sub    %edx,%eax
   10e52:	40                   	inc    %eax
   10e53:	89 45 9c             	mov    %eax,0xffffff9c(%ebp)
    }

    //printk("1: bootstrap packet template %d\n", seq);
    makePacket(&(*cont)->packets[numPackets], seq, 0xdeadbeef, CONTTYPE_FULL_MSS /* len */ , 
   10e56:	0f b6 45 9c          	movzbl 0xffffff9c(%ebp),%eax
   10e5a:	89 44 24 20          	mov    %eax,0x20(%esp,1)
   10e5e:	8b 45 98             	mov    0xffffff98(%ebp),%eax
   10e61:	89 44 24 1c          	mov    %eax,0x1c(%esp,1)
   10e65:	0f b7 05 00 00 00 00 	movzwl 0x0,%eax
   10e6c:	89 44 24 18          	mov    %eax,0x18(%esp,1)
   10e70:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp,1)
   10e77:	00 
   10e78:	c7 44 24 10 02 00 00 	movl   $0x2,0x10(%esp,1)
   10e7f:	00 
   10e80:	a1 00 00 00 00       	mov    0x0,%eax
   10e85:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   10e89:	c7 44 24 08 ef be ad 	movl   $0xdeadbeef,0x8(%esp,1)
   10e90:	de 
   10e91:	8b 45 90             	mov    0xffffff90(%ebp),%eax
   10e94:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10e98:	8b 45 08             	mov    0x8(%ebp),%eax
   10e9b:	8b 08                	mov    (%eax),%ecx
   10e9d:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
   10ea0:	89 d0                	mov    %edx,%eax
   10ea2:	c1 e0 03             	shl    $0x3,%eax
   10ea5:	01 d0                	add    %edx,%eax
   10ea7:	c1 e0 02             	shl    $0x2,%eax
   10eaa:	03 81 ec 00 00 00    	add    0xec(%ecx),%eax
   10eb0:	89 04 24             	mov    %eax,(%esp,1)
   10eb3:	e8 01 07 00 00       	call   115b9 <makePacket>
	       PACKET_BOOTSTRAP, CONTTYPE_FULL1, CONTTYPE_FULL_MSS, firstChild, numChildren);
    numPackets++;
   10eb8:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   10ebb:	ff 00                	incl   (%eax)
    if(serverDebugLevel >= 1) {
   10ebd:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
   10ec4:	7e 13                	jle    10ed9 <DoRecoveryStep+0xa10>
      printk("  After bootstrap: %u packets\n", numPackets);
   10ec6:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   10ec9:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10ecd:	c7 04 24 40 4f 00 00 	movl   $0x4f40,(%esp,1)
   10ed4:	e8 fc ff ff ff       	call   10ed5 <DoRecoveryStep+0xa0c>
   10ed9:	8d 45 bc             	lea    0xffffffbc(%ebp),%eax
   10edc:	ff 00                	incl   (%eax)
   10ede:	e9 d3 fe ff ff       	jmp    10db6 <DoRecoveryStep+0x8ed>
    }
  }
  numPacketsSendable = numPackets;
   10ee3:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   10ee6:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
  (*cont)->num_packets = numPackets;
   10ee9:	8b 45 08             	mov    0x8(%ebp),%eax
   10eec:	8b 10                	mov    (%eax),%edx
   10eee:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   10ef1:	89 82 e8 00 00 00    	mov    %eax,0xe8(%edx)
  if(numPacketsSendable > numPacketsAllocated) {
   10ef7:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
   10efa:	3b 45 b0             	cmp    0xffffffb0(%ebp),%eax
   10efd:	7e 36                	jle    10f35 <DoRecoveryStep+0xa6c>
    printk("Sendable = %d, allocated = %d\n", numPacketsSendable, numPacketsAllocated);
   10eff:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
   10f02:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   10f06:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
   10f09:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10f0d:	c7 04 24 60 4f 00 00 	movl   $0x4f60,(%esp,1)
   10f14:	e8 fc ff ff ff       	call   10f15 <DoRecoveryStep+0xa4c>
    BUG_TRAP(numPacketsSendable <= numPacketsAllocated);
   10f19:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
   10f1c:	3b 45 b0             	cmp    0xffffffb0(%ebp),%eax
   10f1f:	7e 14                	jle    10f35 <DoRecoveryStep+0xa6c>
   10f21:	c7 44 24 04 14 07 00 	movl   $0x714,0x4(%esp,1)
   10f28:	00 
   10f29:	c7 04 24 80 4f 00 00 	movl   $0x4f80,(%esp,1)
   10f30:	e8 fc ff ff ff       	call   10f31 <DoRecoveryStep+0xa68>
  }

  LOG_PACKET_RECOVERYEVENT(*cont);
#if 0
  if(numPacketsSendable > 0) {
	  printk("recovery packet will generate %d response  packets\n", numPacketsSendable);
  }
#endif
  //printk("recovery upcall\n");
  DO_SANITY_CHECK_MSK(*cont);
  DoUpcall((*cont), event);
   10f35:	8b 45 10             	mov    0x10(%ebp),%eax
   10f38:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10f3c:	8b 45 08             	mov    0x8(%ebp),%eax
   10f3f:	8b 00                	mov    (%eax),%eax
   10f41:	89 04 24             	mov    %eax,(%esp,1)
   10f44:	e8 fc ff ff ff       	call   10f45 <DoRecoveryStep+0xa7c>
  return 0;
   10f49:	c7 45 8c 00 00 00 00 	movl   $0x0,0xffffff8c(%ebp)
}
   10f50:	8b 45 8c             	mov    0xffffff8c(%ebp),%eax
   10f53:	81 c4 ac 00 00 00    	add    $0xac,%esp
   10f59:	5b                   	pop    %ebx
   10f5a:	5d                   	pop    %ebp
   10f5b:	c3                   	ret    

00010f5c <DoSlowStartStep>:

static int DoSlowStartStep(CONTINUATION_TYPE **cont, AckProof *ackProof, __u32 newBase, enum cminisock_event_tag event) {
   10f5c:	55                   	push   %ebp
   10f5d:	89 e5                	mov    %esp,%ebp
   10f5f:	83 ec 40             	sub    $0x40,%esp
	//printk("SSStep ServerDebugLevel = %d\n", serverDebugLevel);
	if((*cont)->startCwnd == 0) {
   10f62:	8b 45 08             	mov    0x8(%ebp),%eax
   10f65:	8b 00                	mov    (%eax),%eax
   10f67:	83 78 64 00          	cmpl   $0x0,0x64(%eax)
   10f6b:	75 0c                	jne    10f79 <DoSlowStartStep+0x1d>
		(*cont)->startCwnd = 1;
   10f6d:	8b 45 08             	mov    0x8(%ebp),%eax
   10f70:	8b 00                	mov    (%eax),%eax
   10f72:	c7 40 64 01 00 00 00 	movl   $0x1,0x64(%eax)
	}
  (*cont)->executionTrace = 3;
   10f79:	8b 45 08             	mov    0x8(%ebp),%eax
   10f7c:	8b 00                	mov    (%eax),%eax
   10f7e:	c7 80 dc 00 00 00 03 	movl   $0x3,0xdc(%eax)
   10f85:	00 00 00 

  int right = AckProof_findRight(ackProof, (*cont)->TCPBase);
   10f88:	8b 45 08             	mov    0x8(%ebp),%eax
   10f8b:	8b 00                	mov    (%eax),%eax
   10f8d:	8b 40 6c             	mov    0x6c(%eax),%eax
   10f90:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10f94:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f97:	89 04 24             	mov    %eax,(%esp,1)
   10f9a:	e8 fc ff ff ff       	call   10f9b <DoSlowStartStep+0x3f>
   10f9f:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  int effCwnd = AckTCPCwndScalar(right, (*cont));
   10fa2:	8b 45 08             	mov    0x8(%ebp),%eax
   10fa5:	8b 00                	mov    (%eax),%eax
   10fa7:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   10fab:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   10fae:	89 04 24             	mov    %eax,(%esp,1)
   10fb1:	e8 fc ff ff ff       	call   10fb2 <DoSlowStartStep+0x56>
   10fb6:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

  (*cont)->actualCwnd = effCwnd;
   10fb9:	8b 45 08             	mov    0x8(%ebp),%eax
   10fbc:	8b 10                	mov    (%eax),%edx
   10fbe:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   10fc1:	89 82 e0 00 00 00    	mov    %eax,0xe0(%edx)
  LOG_PACKET_TIMEOUTEVENT0(*cont);
  

#ifndef ZERO_SSTHRESH_PROTECTION_HACK
  (*cont)->ssthresh = effCwnd / MULT_FACTOR;
#else
  if(effCwnd >= MULT_FACTOR) {
   10fc7:	83 7d f8 01          	cmpl   $0x1,0xfffffff8(%ebp)
   10fcb:	7e 1a                	jle    10fe7 <DoSlowStartStep+0x8b>
    (*cont)->ssthresh = effCwnd / MULT_FACTOR;
   10fcd:	8b 45 08             	mov    0x8(%ebp),%eax
   10fd0:	8b 08                	mov    (%eax),%ecx
   10fd2:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   10fd5:	89 d0                	mov    %edx,%eax
   10fd7:	c1 f8 1f             	sar    $0x1f,%eax
   10fda:	c1 e8 1f             	shr    $0x1f,%eax
   10fdd:	8d 04 10             	lea    (%eax,%edx,1),%eax
   10fe0:	d1 f8                	sar    %eax
   10fe2:	89 41 68             	mov    %eax,0x68(%ecx)
   10fe5:	eb 12                	jmp    10ff9 <DoSlowStartStep+0x9d>
  } else {
    (*cont)->ssthresh /= 2;
   10fe7:	8b 45 08             	mov    0x8(%ebp),%eax
   10fea:	8b 10                	mov    (%eax),%edx
   10fec:	8b 45 08             	mov    0x8(%ebp),%eax
   10fef:	8b 00                	mov    (%eax),%eax
   10ff1:	8b 40 68             	mov    0x68(%eax),%eax
   10ff4:	d1 e8                	shr    %eax
   10ff6:	89 42 68             	mov    %eax,0x68(%edx)
  }
#endif

  (*cont)->TCPBase = newBase;
   10ff9:	8b 45 08             	mov    0x8(%ebp),%eax
   10ffc:	8b 10                	mov    (%eax),%edx
   10ffe:	8b 45 10             	mov    0x10(%ebp),%eax
   11001:	89 42 6c             	mov    %eax,0x6c(%edx)
  (*cont)->startCwnd = SLOWSTART_CWND;
   11004:	8b 45 08             	mov    0x8(%ebp),%eax
   11007:	8b 00                	mov    (%eax),%eax
   11009:	c7 40 64 02 00 00 00 	movl   $0x2,0x64(%eax)

  (*cont)->actualCwnd = (*cont)->startCwnd;
   11010:	8b 45 08             	mov    0x8(%ebp),%eax
   11013:	8b 10                	mov    (%eax),%edx
   11015:	8b 45 08             	mov    0x8(%ebp),%eax
   11018:	8b 00                	mov    (%eax),%eax
   1101a:	8b 40 64             	mov    0x64(%eax),%eax
   1101d:	89 82 e0 00 00 00    	mov    %eax,0xe0(%edx)

#if 1 // startcwnd = k
  if(!alloc_msk_packets((*cont), (*cont)->startCwnd)) {
   11023:	8b 45 08             	mov    0x8(%ebp),%eax
   11026:	8b 00                	mov    (%eax),%eax
   11028:	8b 40 64             	mov    0x64(%eax),%eax
   1102b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1102f:	8b 45 08             	mov    0x8(%ebp),%eax
   11032:	8b 00                	mov    (%eax),%eax
   11034:	89 04 24             	mov    %eax,(%esp,1)
   11037:	e8 68 0d 00 00       	call   11da4 <alloc_msk_packets>
   1103c:	85 c0                	test   %eax,%eax
   1103e:	75 3e                	jne    1107e <DoSlowStartStep+0x122>
	  free_trickles_msk((*cont)->sk, (*cont));
   11040:	8b 45 08             	mov    0x8(%ebp),%eax
   11043:	8b 00                	mov    (%eax),%eax
   11045:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   11049:	8b 45 08             	mov    0x8(%ebp),%eax
   1104c:	8b 00                	mov    (%eax),%eax
   1104e:	8b 40 20             	mov    0x20(%eax),%eax
   11051:	89 04 24             	mov    %eax,(%esp,1)
   11054:	e8 3c ce ff ff       	call   de95 <free_trickles_msk>
	  free_trickles_msk_finish((*cont)->sk, (*cont));
   11059:	8b 45 08             	mov    0x8(%ebp),%eax
   1105c:	8b 00                	mov    (%eax),%eax
   1105e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   11062:	8b 45 08             	mov    0x8(%ebp),%eax
   11065:	8b 00                	mov    (%eax),%eax
   11067:	8b 40 20             	mov    0x20(%eax),%eax
   1106a:	89 04 24             	mov    %eax,(%esp,1)
   1106d:	e8 c1 ce ff ff       	call   df33 <free_trickles_msk_finish>
	  return -ENOMEM;
   11072:	c7 45 e8 f4 ff ff ff 	movl   $0xfffffff4,0xffffffe8(%ebp)
   11079:	e9 11 01 00 00       	jmp    1118f <DoSlowStartStep+0x233>
  }
  (*cont)->num_packets = (*cont)->startCwnd;
   1107e:	8b 45 08             	mov    0x8(%ebp),%eax
   11081:	8b 10                	mov    (%eax),%edx
   11083:	8b 45 08             	mov    0x8(%ebp),%eax
   11086:	8b 00                	mov    (%eax),%eax
   11088:	8b 40 64             	mov    0x64(%eax),%eax
   1108b:	89 82 e8 00 00 00    	mov    %eax,0xe8(%edx)
  int i;
  for(i=0; i < (*cont)->num_packets; i++) {
   11091:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
   11098:	8b 45 08             	mov    0x8(%ebp),%eax
   1109b:	8b 10                	mov    (%eax),%edx
   1109d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   110a0:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
   110a6:	7c 05                	jl     110ad <DoSlowStartStep+0x151>
   110a8:	e9 94 00 00 00       	jmp    11141 <DoSlowStartStep+0x1e5>
#if 0
	  int full = i % 2 == 0;
	  int type = full ? CONTTYPE_FULL2 : CONTTYPE_MINIMAL;
	  int len = full ? CONTTYPE_FULL_MSS : CONTTYPE_MINIMAL_MSS;
#else
	  int type = CONTTYPE_FULL1;
   110ad:	c7 45 f0 01 00 00 00 	movl   $0x1,0xfffffff0(%ebp)
	  int len = CONTTYPE_FULL_MSS;
   110b4:	a1 00 00 00 00       	mov    0x0,%eax
   110b9:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
#endif
	  makePacket(&(*cont)->packets[i], (*cont)->TCPBase + i, 0xdeadbeef, len,
   110bc:	c7 44 24 20 ff 00 00 	movl   $0xff,0x20(%esp,1)
   110c3:	00 
   110c4:	c7 44 24 1c ff ff ff 	movl   $0xffffffff,0x1c(%esp,1)
   110cb:	ff 
   110cc:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp,1)
   110d3:	00 
   110d4:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
   110d8:	89 44 24 14          	mov    %eax,0x14(%esp,1)
   110dc:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
   110e0:	75 09                	jne    110eb <DoSlowStartStep+0x18f>
   110e2:	c7 45 e4 80 00 00 00 	movl   $0x80,0xffffffe4(%ebp)
   110e9:	eb 07                	jmp    110f2 <DoSlowStartStep+0x196>
   110eb:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
   110f2:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   110f5:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   110f9:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   110fc:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   11100:	c7 44 24 08 ef be ad 	movl   $0xdeadbeef,0x8(%esp,1)
   11107:	de 
   11108:	8b 45 08             	mov    0x8(%ebp),%eax
   1110b:	8b 10                	mov    (%eax),%edx
   1110d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   11110:	03 42 6c             	add    0x6c(%edx),%eax
   11113:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   11117:	8b 45 08             	mov    0x8(%ebp),%eax
   1111a:	8b 08                	mov    (%eax),%ecx
   1111c:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   1111f:	89 d0                	mov    %edx,%eax
   11121:	c1 e0 03             	shl    $0x3,%eax
   11124:	01 d0                	add    %edx,%eax
   11126:	c1 e0 02             	shl    $0x2,%eax
   11129:	03 81 ec 00 00 00    	add    0xec(%ecx),%eax
   1112f:	89 04 24             	mov    %eax,(%esp,1)
   11132:	e8 82 04 00 00       	call   115b9 <makePacket>
   11137:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   1113a:	ff 00                	incl   (%eax)
   1113c:	e9 57 ff ff ff       	jmp    11098 <DoSlowStartStep+0x13c>
		     (i == 0 ? PTYPE_FIRST : 0) | PACKET_NORMAL, type,
		     0,  -1, -1);
  }
#else
#if 1 // startcwnd = 1
  if(!alloc_msk_packets((*cont), 1)) {
	  free_trickles_msk((*cont)->sk, (*cont));
	  free_trickles_msk_finish((*cont)->sk, (*cont));
	  return -ENOMEM;
  }
  makePacket(&(*cont)->packets[0], (*cont)->TCPBase, 0xdeadbeef, CONTTYPE_FULL_MSS /* len */,
	     PTYPE_FIRST | PACKET_NORMAL, CONTTYPE_FULL1, 
	     CONTTYPE_FULL_MSS, (*cont)->TCPBase + 1, 1);
#else // startcwnd = 2
  if(!alloc_msk_packets((*cont), 2)) {
	  free_trickles_msk((*cont)->sk, (*cont));
	  free_trickles_msk_finish((*cont)->sk, (*cont));
	  return -ENOMEM;
  }
  makePacket(&(*cont)->packets[0], (*cont)->TCPBase, 0xdeadbeef, CONTTYPE_FULL_MSS /* len */,
	     PTYPE_FIRST | PACKET_NORMAL, CONTTYPE_FULL1, 
	     CONTTYPE_FULL_MSS, (*cont)->TCPBase + 1, 1);
  makePacket(&(*cont)->packets[1], (*cont)->TCPBase, 0xdeadbeef, CONTTYPE_FULL_MSS  /* len */,
	     PACKET_NORMAL, CONTTYPE_FULL1, 
	     CONTTYPE_FULL_MSS, (*cont)->TCPBase + 2, 1);
#endif
#endif

  if(serverDebugLevel >= 1)
   11141:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
   11148:	7e 2a                	jle    11174 <DoSlowStartStep+0x218>
	  printk("slow start step TCPBase - %u seq - %u\n", (*cont)->TCPBase, 
   1114a:	8b 45 08             	mov    0x8(%ebp),%eax
   1114d:	8b 00                	mov    (%eax),%eax
   1114f:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
   11155:	8b 40 04             	mov    0x4(%eax),%eax
   11158:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1115c:	8b 45 08             	mov    0x8(%ebp),%eax
   1115f:	8b 00                	mov    (%eax),%eax
   11161:	8b 40 6c             	mov    0x6c(%eax),%eax
   11164:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   11168:	c7 04 24 e0 4f 00 00 	movl   $0x4fe0,(%esp,1)
   1116f:	e8 fc ff ff ff       	call   11170 <DoSlowStartStep+0x214>
		 (*cont)->packets[0].seq);

  LOG_PACKET_TIMEOUTEVENT1(*cont);
  DO_SANITY_CHECK_MSK(*cont);
  DoUpcall((*cont), event);
   11174:	8b 45 14             	mov    0x14(%ebp),%eax
   11177:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1117b:	8b 45 08             	mov    0x8(%ebp),%eax
   1117e:	8b 00                	mov    (%eax),%eax
   11180:	89 04 24             	mov    %eax,(%esp,1)
   11183:	e8 fc ff ff ff       	call   11184 <DoSlowStartStep+0x228>
  return 0;
   11188:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
}
   1118f:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   11192:	c9                   	leave  
   11193:	c3                   	ret    

00011194 <cminisock_cache_child>:

inline void cminisock_cache_child(struct cminisock *msk, int packet_number, int flags) {
   11194:	55                   	push   %ebp
   11195:	89 e5                	mov    %esp,%ebp
   11197:	53                   	push   %ebx
   11198:	83 ec 14             	sub    $0x14,%esp
	struct cminisock *newMsk;
	int new = 0;
   1119b:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
	if(flags & CACHE_CHILD_COPY) {
   111a2:	8b 45 10             	mov    0x10(%ebp),%eax
   111a5:	83 e0 01             	and    $0x1,%eax
   111a8:	85 c0                	test   %eax,%eax
   111aa:	74 2f                	je     111db <cminisock_cache_child+0x47>
		newMsk = shallow_copy_msk(msk->serverSK, msk);
   111ac:	8b 45 08             	mov    0x8(%ebp),%eax
   111af:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   111b3:	8b 45 08             	mov    0x8(%ebp),%eax
   111b6:	8b 80 f8 00 00 00    	mov    0xf8(%eax),%eax
   111bc:	89 04 24             	mov    %eax,(%esp,1)
   111bf:	e8 57 0e 00 00       	call   1201b <shallow_copy_msk>
   111c4:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
		if(newMsk == NULL) {
   111c7:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
   111cb:	75 05                	jne    111d2 <cminisock_cache_child+0x3e>
			if(trickles_ratelimit()) {
				printk("out of memory\n");
			}
			return;
   111cd:	e9 1f 02 00 00       	jmp    113f1 <cminisock_cache_child+0x25d>
		}
		new = 1;
   111d2:	c7 45 f4 01 00 00 00 	movl   $0x1,0xfffffff4(%ebp)
   111d9:	eb 06                	jmp    111e1 <cminisock_cache_child+0x4d>
	} else {
		newMsk = msk;
   111db:	8b 45 08             	mov    0x8(%ebp),%eax
   111de:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	}
	// precondition: refcnt == 1
	BUG_TRAP(newMsk->refCnt == 1);
   111e1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   111e4:	83 b8 f0 00 00 00 01 	cmpl   $0x1,0xf0(%eax)
   111eb:	74 14                	je     11201 <cminisock_cache_child+0x6d>
   111ed:	c7 44 24 04 88 07 00 	movl   $0x788,0x4(%esp,1)
   111f4:	00 
   111f5:	c7 04 24 20 50 00 00 	movl   $0x5020,(%esp,1)
   111fc:	e8 fc ff ff ff       	call   111fd <cminisock_cache_child+0x69>
	if(newMsk != NULL) {
   11201:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
   11205:	0f 84 e6 01 00 00    	je     113f1 <cminisock_cache_child+0x25d>
		if(!new) {
   1120b:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
   1120f:	75 0a                	jne    1121b <cminisock_cache_child+0x87>
			newMsk->ctl = ALLOC_PENDING;
   11211:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   11214:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
		}
		BUG_TRAP(newMsk->ctl == ALLOC_PENDING);
   1121b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1121e:	83 78 0c 02          	cmpl   $0x2,0xc(%eax)
   11222:	74 14                	je     11238 <cminisock_cache_child+0xa4>
   11224:	c7 44 24 04 8d 07 00 	movl   $0x78d,0x4(%esp,1)
   1122b:	00 
   1122c:	c7 04 24 80 50 00 00 	movl   $0x5080,(%esp,1)
   11233:	e8 fc ff ff ff       	call   11234 <cminisock_cache_child+0xa0>

		// seq ; firstChild ; state
		MARSHALL_PACKET_FIELDS(newMsk, msk, packet_number, 
				       /* no conversion function */);
   11238:	8b 5d f8             	mov    0xfffffff8(%ebp),%ebx
   1123b:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1123e:	8b 55 0c             	mov    0xc(%ebp),%edx
   11241:	89 d0                	mov    %edx,%eax
   11243:	c1 e0 03             	shl    $0x3,%eax
   11246:	01 d0                	add    %edx,%eax
   11248:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1124f:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   11255:	8b 44 10 04          	mov    0x4(%eax,%edx,1),%eax
   11259:	89 43 30             	mov    %eax,0x30(%ebx)
   1125c:	8b 5d f8             	mov    0xfffffff8(%ebp),%ebx
   1125f:	8b 4d 08             	mov    0x8(%ebp),%ecx
   11262:	8b 55 0c             	mov    0xc(%ebp),%edx
   11265:	89 d0                	mov    %edx,%eax
   11267:	c1 e0 03             	shl    $0x3,%eax
   1126a:	01 d0                	add    %edx,%eax
   1126c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11273:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   11279:	0f b6 44 10 0c       	movzbl 0xc(%eax,%edx,1),%eax
   1127e:	c0 e8 03             	shr    $0x3,%al
   11281:	24 07                	and    $0x7,%al
   11283:	0f b6 c0             	movzbl %al,%eax
   11286:	89 43 34             	mov    %eax,0x34(%ebx)
   11289:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1128c:	8b 55 0c             	mov    0xc(%ebp),%edx
   1128f:	89 d0                	mov    %edx,%eax
   11291:	c1 e0 03             	shl    $0x3,%eax
   11294:	01 d0                	add    %edx,%eax
   11296:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1129d:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   112a3:	0f b6 44 10 0c       	movzbl 0xc(%eax,%edx,1),%eax
   112a8:	24 07                	and    $0x7,%al
   112aa:	24 80                	and    $0x80,%al
   112ac:	84 c0                	test   %al,%al
   112ae:	74 0c                	je     112bc <cminisock_cache_child+0x128>
   112b0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   112b3:	c7 40 58 01 00 00 00 	movl   $0x1,0x58(%eax)
   112ba:	eb 0a                	jmp    112c6 <cminisock_cache_child+0x132>
   112bc:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   112bf:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
   112c6:	8b 4d 08             	mov    0x8(%ebp),%ecx
   112c9:	8b 55 0c             	mov    0xc(%ebp),%edx
   112cc:	89 d0                	mov    %edx,%eax
   112ce:	c1 e0 03             	shl    $0x3,%eax
   112d1:	01 d0                	add    %edx,%eax
   112d3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   112da:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   112e0:	0f b6 44 10 0c       	movzbl 0xc(%eax,%edx,1),%eax
   112e5:	24 07                	and    $0x7,%al
   112e7:	24 03                	and    $0x3,%al
   112e9:	0f b6 c0             	movzbl %al,%eax
   112ec:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   112ef:	83 7d f0 02          	cmpl   $0x2,0xfffffff0(%ebp)
   112f3:	7e 25                	jle    1131a <cminisock_cache_child+0x186>
   112f5:	c7 44 24 04 19 45 00 	movl   $0x4519,0x4(%esp,1)
   112fc:	00 
   112fd:	c7 04 24 1d 45 00 00 	movl   $0x451d,(%esp,1)
   11304:	e8 fc ff ff ff       	call   11305 <cminisock_cache_child+0x171>
   11309:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   11310:	e8 fc ff ff ff       	call   11311 <cminisock_cache_child+0x17d>
   11315:	e8 fc ff ff ff       	call   11316 <cminisock_cache_child+0x182>
   1131a:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   1131d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   11320:	8b 04 85 08 50 00 00 	mov    0x5008(,%eax,4),%eax
   11327:	89 42 54             	mov    %eax,0x54(%edx)

		// initialization based on unmarshallContinuation
		newMsk->sk = NULL;
   1132a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1132d:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
		newMsk->rawTimestamp = htonl(newMsk->timestamp);
   11334:	8b 5d f8             	mov    0xfffffff8(%ebp),%ebx
   11337:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1133a:	8b 40 48             	mov    0x48(%eax),%eax
   1133d:	89 04 24             	mov    %eax,(%esp,1)
   11340:	e8 fc ff ff ff       	call   11341 <cminisock_cache_child+0x1ad>
   11345:	89 43 40             	mov    %eax,0x40(%ebx)
		newMsk->rawMrtt = htonl(newMsk->mrtt);
   11348:	8b 5d f8             	mov    0xfffffff8(%ebp),%ebx
   1134b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1134e:	8b 40 50             	mov    0x50(%eax),%eax
   11351:	89 04 24             	mov    %eax,(%esp,1)
   11354:	e8 fc ff ff ff       	call   11355 <cminisock_cache_child+0x1c1>
   11359:	89 43 44             	mov    %eax,0x44(%ebx)
		newMsk->num_packets = 0;
   1135c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1135f:	c7 80 e8 00 00 00 00 	movl   $0x0,0xe8(%eax)
   11366:	00 00 00 
		newMsk->numChildrenReceived = 0;
   11369:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1136c:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%eax)
   11373:	00 00 00 
		newMsk->parentMSK = NULL;
   11376:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   11379:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%eax)
   11380:	00 00 00 

		if(flags & CACHE_CHILD_CLEAR) {
   11383:	8b 45 10             	mov    0x10(%ebp),%eax
   11386:	83 e0 02             	and    $0x2,%eax
   11389:	85 c0                	test   %eax,%eax
   1138b:	74 0b                	je     11398 <cminisock_cache_child+0x204>
			msk_clear_fields(newMsk);
   1138d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   11390:	89 04 24             	mov    %eax,(%esp,1)
   11393:	e8 bf 09 00 00       	call   11d57 <msk_clear_fields>
		}

		printk("inserted %u\n", newMsk->seq);
   11398:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1139b:	8b 40 30             	mov    0x30(%eax),%eax
   1139e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   113a2:	c7 04 24 d2 50 00 00 	movl   $0x50d2,(%esp,1)
   113a9:	e8 fc ff ff ff       	call   113aa <cminisock_cache_child+0x216>
		cminisock_insert(newMsk);
   113ae:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   113b1:	89 04 24             	mov    %eax,(%esp,1)
   113b4:	e8 fc ff ff ff       	call   113b5 <cminisock_cache_child+0x221>
		// refcnt now 2
		msk_release(newMsk->serverSK, newMsk);
   113b9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   113bc:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   113c0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   113c3:	8b 80 f8 00 00 00    	mov    0xf8(%eax),%eax
   113c9:	89 04 24             	mov    %eax,(%esp,1)
   113cc:	e8 e3 0c 00 00       	call   120b4 <msk_release>
		BUG_TRAP(newMsk->refCnt == 1);
   113d1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   113d4:	83 b8 f0 00 00 00 01 	cmpl   $0x1,0xf0(%eax)
   113db:	74 14                	je     113f1 <cminisock_cache_child+0x25d>
   113dd:	c7 44 24 04 a3 07 00 	movl   $0x7a3,0x4(%esp,1)
   113e4:	00 
   113e5:	c7 04 24 20 50 00 00 	movl   $0x5020,(%esp,1)
   113ec:	e8 fc ff ff ff       	call   113ed <cminisock_cache_child+0x259>
		//printk("new(%d) newMsk->refCnt[2] = %d\n", new, newMsk->refCnt);
	}
 }
   113f1:	83 c4 14             	add    $0x14,%esp
   113f4:	5b                   	pop    %ebx
   113f5:	5d                   	pop    %ebp
   113f6:	c3                   	ret    

000113f7 <__memcpy>:
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
   113f7:	55                   	push   %ebp
   113f8:	89 e5                	mov    %esp,%ebp
   113fa:	57                   	push   %edi
   113fb:	56                   	push   %esi
   113fc:	83 ec 0c             	sub    $0xc,%esp
int d0, d1, d2;
__asm__ __volatile__(
   113ff:	8b 45 10             	mov    0x10(%ebp),%eax
   11402:	89 c1                	mov    %eax,%ecx
   11404:	c1 e9 02             	shr    $0x2,%ecx
   11407:	8b 45 10             	mov    0x10(%ebp),%eax
   1140a:	8b 7d 08             	mov    0x8(%ebp),%edi
   1140d:	8b 75 0c             	mov    0xc(%ebp),%esi
   11410:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   11412:	a8 02                	test   $0x2,%al
   11414:	74 02                	je     11418 <__memcpy+0x21>
   11416:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
   11418:	a8 01                	test   $0x1,%al
   1141a:	74 01                	je     1141d <__memcpy+0x26>
   1141c:	a4                   	movsb  %ds:(%esi),%es:(%edi)
   1141d:	89 c8                	mov    %ecx,%eax
   1141f:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   11422:	89 f8                	mov    %edi,%eax
   11424:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   11427:	89 f0                	mov    %esi,%eax
   11429:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	"rep ; movsl\n\t"
	"testb $2,%b4\n\t"
	"je 1f\n\t"
	"movsw\n"
	"1:\ttestb $1,%b4\n\t"
	"je 2f\n\t"
	"movsb\n"
	"2:"
	: "=&c" (d0), "=&D" (d1), "=&S" (d2)
	:"0" (n/4), "q" (n),"1" ((long) to),"2" ((long) from)
	: "memory");
return (to);
   1142c:	8b 45 08             	mov    0x8(%ebp),%eax
}
   1142f:	83 c4 0c             	add    $0xc,%esp
   11432:	5e                   	pop    %esi
   11433:	5f                   	pop    %edi
   11434:	5d                   	pop    %ebp
   11435:	c3                   	ret    

00011436 <skb_push>:
 *	panic. A pointer to the first byte of the extra data is returned.
 */

static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
{
   11436:	55                   	push   %ebp
   11437:	89 e5                	mov    %esp,%ebp
   11439:	83 ec 10             	sub    $0x10,%esp
	skb->data-=len;
   1143c:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1143f:	8b 45 08             	mov    0x8(%ebp),%eax
   11442:	8b 55 0c             	mov    0xc(%ebp),%edx
   11445:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   1144b:	29 d0                	sub    %edx,%eax
   1144d:	89 81 b8 00 00 00    	mov    %eax,0xb8(%ecx)
	skb->len+=len;
   11453:	8b 4d 08             	mov    0x8(%ebp),%ecx
   11456:	8b 55 08             	mov    0x8(%ebp),%edx
   11459:	8b 45 0c             	mov    0xc(%ebp),%eax
   1145c:	03 82 94 00 00 00    	add    0x94(%edx),%eax
   11462:	89 81 94 00 00 00    	mov    %eax,0x94(%ecx)
	if(skb->data<skb->head) {
   11468:	8b 45 08             	mov    0x8(%ebp),%eax
   1146b:	8b 55 08             	mov    0x8(%ebp),%edx
   1146e:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   11474:	3b 82 b4 00 00 00    	cmp    0xb4(%edx),%eax
   1147a:	73 20                	jae    1149c <skb_push+0x66>
		skb_under_panic(skb, len, current_text_addr());
   1147c:	c7 45 fc 83 14 01 00 	movl   $0x11483,0xfffffffc(%ebp)
   11483:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   11486:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1148a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1148d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   11491:	8b 45 08             	mov    0x8(%ebp),%eax
   11494:	89 04 24             	mov    %eax,(%esp,1)
   11497:	e8 fc ff ff ff       	call   11498 <skb_push+0x62>
	}
	return skb->data;
   1149c:	8b 45 08             	mov    0x8(%ebp),%eax
   1149f:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
}
   114a5:	c9                   	leave  
   114a6:	c3                   	ret    

000114a7 <__skb_pull>:

static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
   114a7:	55                   	push   %ebp
   114a8:	89 e5                	mov    %esp,%ebp
   114aa:	83 ec 04             	sub    $0x4,%esp
	skb->len-=len;
   114ad:	8b 4d 08             	mov    0x8(%ebp),%ecx
   114b0:	8b 45 08             	mov    0x8(%ebp),%eax
   114b3:	8b 55 0c             	mov    0xc(%ebp),%edx
   114b6:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   114bc:	29 d0                	sub    %edx,%eax
   114be:	89 81 94 00 00 00    	mov    %eax,0x94(%ecx)
	if (skb->len < skb->data_len)
   114c4:	8b 45 08             	mov    0x8(%ebp),%eax
   114c7:	8b 55 08             	mov    0x8(%ebp),%edx
   114ca:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   114d0:	3b 82 98 00 00 00    	cmp    0x98(%edx),%eax
   114d6:	73 0c                	jae    114e4 <__skb_pull+0x3d>
		out_of_line_bug();
   114d8:	c7 04 24 4c 03 00 00 	movl   $0x34c,(%esp,1)
   114df:	e8 fc ff ff ff       	call   114e0 <__skb_pull+0x39>
	return 	skb->data+=len;
   114e4:	8b 4d 08             	mov    0x8(%ebp),%ecx
   114e7:	8b 55 08             	mov    0x8(%ebp),%edx
   114ea:	8b 45 0c             	mov    0xc(%ebp),%eax
   114ed:	03 82 b8 00 00 00    	add    0xb8(%edx),%eax
   114f3:	89 81 b8 00 00 00    	mov    %eax,0xb8(%ecx)
   114f9:	8b 81 b8 00 00 00    	mov    0xb8(%ecx),%eax
}
   114ff:	c9                   	leave  
   11500:	c3                   	ret    

00011501 <pskb_may_pull>:

/**
 *	skb_pull - remove data from the start of a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to remove
 *
 *	This function removes data from the start of a buffer, returning
 *	the memory to the headroom. A pointer to the next data in the buffer
 *	is returned. Once the data has been pulled future pushes will overwrite
 *	the old data.
 */

static inline unsigned char * skb_pull(struct sk_buff *skb, unsigned int len)
{	
	if (len > skb->len)
		return NULL;
	return __skb_pull(skb,len);
}

extern unsigned char * __pskb_pull_tail(struct sk_buff *skb, int delta);

static inline char *__pskb_pull(struct sk_buff *skb, unsigned int len)
{
	if (len > skb_headlen(skb) &&
	    __pskb_pull_tail(skb, len-skb_headlen(skb)) == NULL)
		return NULL;
	skb->len -= len;
	return 	skb->data += len;
}

static inline unsigned char * pskb_pull(struct sk_buff *skb, unsigned int len)
{	
	if (len > skb->len)
		return NULL;
	return __pskb_pull(skb,len);
}

static inline int pskb_may_pull(struct sk_buff *skb, unsigned int len)
{
   11501:	55                   	push   %ebp
   11502:	89 e5                	mov    %esp,%ebp
   11504:	83 ec 10             	sub    $0x10,%esp
	if (len <= skb_headlen(skb))
   11507:	8b 45 08             	mov    0x8(%ebp),%eax
   1150a:	89 04 24             	mov    %eax,(%esp,1)
   1150d:	e8 42 0f 00 00       	call   12454 <skb_headlen>
   11512:	39 45 0c             	cmp    %eax,0xc(%ebp)
   11515:	77 09                	ja     11520 <pskb_may_pull+0x1f>
		return 1;
   11517:	c7 45 fc 01 00 00 00 	movl   $0x1,0xfffffffc(%ebp)
   1151e:	eb 4e                	jmp    1156e <pskb_may_pull+0x6d>
	if (len > skb->len)
   11520:	8b 55 08             	mov    0x8(%ebp),%edx
   11523:	8b 45 0c             	mov    0xc(%ebp),%eax
   11526:	3b 82 94 00 00 00    	cmp    0x94(%edx),%eax
   1152c:	76 09                	jbe    11537 <pskb_may_pull+0x36>
		return 0;
   1152e:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   11535:	eb 37                	jmp    1156e <pskb_may_pull+0x6d>
	return (__pskb_pull_tail(skb, len-skb_headlen(skb)) != NULL);
   11537:	8b 45 08             	mov    0x8(%ebp),%eax
   1153a:	89 04 24             	mov    %eax,(%esp,1)
   1153d:	e8 12 0f 00 00       	call   12454 <skb_headlen>
   11542:	89 c2                	mov    %eax,%edx
   11544:	8b 45 0c             	mov    0xc(%ebp),%eax
   11547:	29 d0                	sub    %edx,%eax
   11549:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1154d:	8b 45 08             	mov    0x8(%ebp),%eax
   11550:	89 04 24             	mov    %eax,(%esp,1)
   11553:	e8 fc ff ff ff       	call   11554 <pskb_may_pull+0x53>
   11558:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   1155b:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
   1155f:	0f 95 c0             	setne  %al
   11562:	0f b6 c0             	movzbl %al,%eax
   11565:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   11568:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1156b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
}
   1156e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   11571:	c9                   	leave  
   11572:	c3                   	ret    

00011573 <unlink>:
	head->len++;
#endif
}

static inline void unlink(struct alloc_head *elem) {
   11573:	55                   	push   %ebp
   11574:	89 e5                	mov    %esp,%ebp
#ifdef DEBUG_LIST
	if(elem->list == (struct alloc_head_list*) elem) {
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
   11576:	8b 45 08             	mov    0x8(%ebp),%eax
   11579:	8b 50 04             	mov    0x4(%eax),%edx
   1157c:	8b 45 08             	mov    0x8(%ebp),%eax
   1157f:	8b 00                	mov    (%eax),%eax
   11581:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
   11583:	8b 45 08             	mov    0x8(%ebp),%eax
   11586:	8b 10                	mov    (%eax),%edx
   11588:	8b 45 08             	mov    0x8(%ebp),%eax
   1158b:	8b 40 04             	mov    0x4(%eax),%eax
   1158e:	89 42 04             	mov    %eax,0x4(%edx)
	elem->prev = elem->next = NULL;
   11591:	8b 55 08             	mov    0x8(%ebp),%edx
   11594:	8b 45 08             	mov    0x8(%ebp),%eax
   11597:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   1159e:	c7 02 00 00 00 00    	movl   $0x0,(%edx)

	elem->list->len--;
   115a4:	8b 45 08             	mov    0x8(%ebp),%eax
   115a7:	8b 40 08             	mov    0x8(%eax),%eax
   115aa:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
   115ad:	8b 45 08             	mov    0x8(%ebp),%eax
   115b0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
   115b7:	5d                   	pop    %ebp
   115b8:	c3                   	ret    

000115b9 <makePacket>:

static inline void insert(struct alloc_head *elem, struct alloc_head *prev, struct alloc_head *next) {
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
	if(prev->next != next || next->prev != prev) {
		BUG();
	}
#endif

	if(!(elem->next == NULL && elem->prev == NULL)) BUG();
	elem->next = prev->next;
	prev->next = elem;

	elem->prev = prev;
	next->prev = elem;

	elem->list = prev->list;
	elem->list->len++;
}

#define alloc_head_walk(queue, elem) \
		for (elem = (typeof(elem))(queue)->next;	\
		     (elem != (typeof(elem))(queue));	\
		     elem=(typeof(elem))elem->next)

#define alloc_head_reverse_walk(queue, elem) \
		for (elem = (typeof(elem))(queue)->prev;	\
		     (elem != (typeof(elem))(queue));	\
		     elem=(typeof(elem))elem->prev)

#endif // __KERNEL__

struct cminisock_packet {
	__u32 nonce; // pregenerate nonces in batch
	__u32 seq;
	//__u32 ack_seq; // XXX probably vestigial
	__u32 len; // XXX Vestigial?

#define PTYPE_FIRST     (0x80)
#define PTYPE_STATEMASK (0x3)
#define PACKET_NORMAL    (0)
#define PACKET_RETRANS   (1)
#define PACKET_BOOTSTRAP (2)
	__u8 type : 3;
	__u8 contType : 3;

#define INVALID_POSITION (0xff)
	__u8 numSiblings; // UC-level number of siblings
	__u8 position; // UC position within sibling list. If packet looks like a data packet, and position == INVALID_POSITION, then client will ignore the packet

	// If ucontLen > 0 and ucontData == NULL, then the ucont is already present in the skbuff
	int ucontLen;
	char *ucontData; // kmalloc'd

	__u16 minResponseLen;
	__u32 firstTransportChild;
	__u8 numTransportChildren;

#ifdef USERTEST
	char *sentData;
	int dataLen;
#endif // USERTEST
};

static inline void makePacket(struct cminisock_packet *pkt, 
			      __u32 seq, 
			      __u32 ack_seq,
			      __u32 len, 
			      __u8 type, 
			      __u8 contType, 
			      __u16 minResponseLen,
			      __u32 firstTransportChild, 
			      __u8 numTransportChildren) {
   115b9:	55                   	push   %ebp
   115ba:	89 e5                	mov    %esp,%ebp
   115bc:	53                   	push   %ebx
   115bd:	83 ec 08             	sub    $0x8,%esp
   115c0:	8b 45 18             	mov    0x18(%ebp),%eax
   115c3:	8b 55 1c             	mov    0x1c(%ebp),%edx
   115c6:	8b 4d 20             	mov    0x20(%ebp),%ecx
   115c9:	8b 5d 28             	mov    0x28(%ebp),%ebx
   115cc:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
   115cf:	88 55 fa             	mov    %dl,0xfffffffa(%ebp)
   115d2:	66 89 4d f8          	mov    %cx,0xfffffff8(%ebp)
   115d6:	88 5d f7             	mov    %bl,0xfffffff7(%ebp)
  pkt->nonce = -1;
   115d9:	8b 45 08             	mov    0x8(%ebp),%eax
   115dc:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
  pkt->seq = seq;
   115e2:	8b 55 08             	mov    0x8(%ebp),%edx
   115e5:	8b 45 0c             	mov    0xc(%ebp),%eax
   115e8:	89 42 04             	mov    %eax,0x4(%edx)
  //pkt->ack_seq = ack_seq;
  pkt->len = len;
   115eb:	8b 55 08             	mov    0x8(%ebp),%edx
   115ee:	8b 45 14             	mov    0x14(%ebp),%eax
   115f1:	89 42 08             	mov    %eax,0x8(%edx)
  pkt->type = type;
   115f4:	8b 4d 08             	mov    0x8(%ebp),%ecx
   115f7:	0f b6 41 0c          	movzbl 0xc(%ecx),%eax
   115fb:	0f b6 55 fb          	movzbl 0xfffffffb(%ebp),%edx
   115ff:	80 e2 07             	and    $0x7,%dl
   11602:	24 f8                	and    $0xf8,%al
   11604:	08 d0                	or     %dl,%al
   11606:	88 41 0c             	mov    %al,0xc(%ecx)
  pkt->contType = contType;
   11609:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1160c:	0f b6 41 0c          	movzbl 0xc(%ecx),%eax
   11610:	0f b6 55 fa          	movzbl 0xfffffffa(%ebp),%edx
   11614:	80 e2 07             	and    $0x7,%dl
   11617:	c0 e2 03             	shl    $0x3,%dl
   1161a:	24 c7                	and    $0xc7,%al
   1161c:	08 d0                	or     %dl,%al
   1161e:	88 41 0c             	mov    %al,0xc(%ecx)
  pkt->minResponseLen = minResponseLen;
   11621:	8b 55 08             	mov    0x8(%ebp),%edx
   11624:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   11627:	66 89 42 18          	mov    %ax,0x18(%edx)
  pkt->firstTransportChild = firstTransportChild;
   1162b:	8b 55 08             	mov    0x8(%ebp),%edx
   1162e:	8b 45 24             	mov    0x24(%ebp),%eax
   11631:	89 42 1c             	mov    %eax,0x1c(%edx)
  pkt->numTransportChildren = numTransportChildren;
   11634:	8b 55 08             	mov    0x8(%ebp),%edx
   11637:	0f b6 45 f7          	movzbl 0xfffffff7(%ebp),%eax
   1163b:	88 42 20             	mov    %al,0x20(%edx)
  pkt->ucontLen = 0;
   1163e:	8b 45 08             	mov    0x8(%ebp),%eax
   11641:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  pkt->ucontData = NULL;
   11648:	8b 45 08             	mov    0x8(%ebp),%eax
   1164b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  pkt->numSiblings = -1;
   11652:	8b 45 08             	mov    0x8(%ebp),%eax
   11655:	c6 40 0d ff          	movb   $0xff,0xd(%eax)
  pkt->position = INVALID_POSITION;
   11659:	8b 45 08             	mov    0x8(%ebp),%eax
   1165c:	c6 40 0e ff          	movb   $0xff,0xe(%eax)
}
   11660:	83 c4 08             	add    $0x8,%esp
   11663:	5b                   	pop    %ebx
   11664:	5d                   	pop    %ebp
   11665:	c3                   	ret    

00011666 <trickles_checksum>:

#define MINISOCK_LEN(RO_LEN) ((RO_LEN) / 2)

#ifndef USERTEST
static inline void trickles_checksum(struct sk_buff *skb, int headerLen) {
   11666:	55                   	push   %ebp
   11667:	89 e5                	mov    %esp,%ebp
   11669:	53                   	push   %ebx
   1166a:	83 ec 18             	sub    $0x18,%esp
	struct sock *sk = skb->sk;
   1166d:	8b 45 08             	mov    0x8(%ebp),%eax
   11670:	8b 40 0c             	mov    0xc(%eax),%eax
   11673:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	if(skb->ip_summed == CHECKSUM_HW) {
   11676:	8b 45 08             	mov    0x8(%ebp),%eax
   11679:	80 b8 a3 00 00 00 01 	cmpb   $0x1,0xa3(%eax)
   11680:	75 5d                	jne    116df <trickles_checksum+0x79>
		skb->h.th->check = 0;
   11682:	8b 45 08             	mov    0x8(%ebp),%eax
   11685:	8b 40 20             	mov    0x20(%eax),%eax
   11688:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
		skb->h.th->check = ~tcp_v4_check(skb->h.th, skb->len, sk->saddr, sk->daddr,
   1168e:	8b 45 08             	mov    0x8(%ebp),%eax
   11691:	8b 58 20             	mov    0x20(%eax),%ebx
   11694:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp,1)
   1169b:	00 
   1169c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1169f:	8b 00                	mov    (%eax),%eax
   116a1:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   116a5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   116a8:	8b 40 70             	mov    0x70(%eax),%eax
   116ab:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   116af:	8b 45 08             	mov    0x8(%ebp),%eax
   116b2:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   116b8:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   116bc:	8b 45 08             	mov    0x8(%ebp),%eax
   116bf:	8b 40 20             	mov    0x20(%eax),%eax
   116c2:	89 04 24             	mov    %eax,(%esp,1)
   116c5:	e8 96 0e 00 00       	call   12560 <tcp_v4_check>
   116ca:	f7 d0                	not    %eax
   116cc:	66 89 43 10          	mov    %ax,0x10(%ebx)
					 0);
		skb->csum = offsetof(struct tcphdr, check);
   116d0:	8b 45 08             	mov    0x8(%ebp),%eax
   116d3:	c7 80 9c 00 00 00 10 	movl   $0x10,0x9c(%eax)
   116da:	00 00 00 
   116dd:	eb 6a                	jmp    11749 <trickles_checksum+0xe3>
	} else {
		skb->h.th->check = 0;
   116df:	8b 45 08             	mov    0x8(%ebp),%eax
   116e2:	8b 40 20             	mov    0x20(%eax),%eax
   116e5:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
		skb->h.th->check = tcp_v4_check(skb->h.th, skb->len, sk->saddr, sk->daddr,
   116eb:	8b 45 08             	mov    0x8(%ebp),%eax
   116ee:	8b 58 20             	mov    0x20(%eax),%ebx
   116f1:	8b 45 08             	mov    0x8(%ebp),%eax
   116f4:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
   116fa:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   116fe:	8b 45 0c             	mov    0xc(%ebp),%eax
   11701:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   11705:	8b 45 08             	mov    0x8(%ebp),%eax
   11708:	8b 40 20             	mov    0x20(%eax),%eax
   1170b:	89 04 24             	mov    %eax,(%esp,1)
   1170e:	e8 fc ff ff ff       	call   1170f <trickles_checksum+0xa9>
   11713:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   11717:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1171a:	8b 00                	mov    (%eax),%eax
   1171c:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   11720:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   11723:	8b 40 70             	mov    0x70(%eax),%eax
   11726:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1172a:	8b 45 08             	mov    0x8(%ebp),%eax
   1172d:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   11733:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   11737:	8b 45 08             	mov    0x8(%ebp),%eax
   1173a:	8b 40 20             	mov    0x20(%eax),%eax
   1173d:	89 04 24             	mov    %eax,(%esp,1)
   11740:	e8 1b 0e 00 00       	call   12560 <tcp_v4_check>
   11745:	66 89 43 10          	mov    %ax,0x10(%ebx)
					 csum_partial((char*)skb->h.th, headerLen, skb->csum));
	}
}
   11749:	83 c4 18             	add    $0x18,%esp
   1174c:	5b                   	pop    %ebx
   1174d:	5d                   	pop    %ebp
   1174e:	c3                   	ret    

0001174f <marshallContinuationServer>:
  do{						\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

MARSHALL_CONTINUATION(Server, 1, SERVER_COMPUTE_MAC)
   1174f:	55                   	push   %ebp
   11750:	89 e5                	mov    %esp,%ebp
   11752:	53                   	push   %ebx
   11753:	83 ec 34             	sub    $0x34,%esp
   11756:	8b 55 0c             	mov    0xc(%ebp),%edx
   11759:	8b 45 10             	mov    0x10(%ebp),%eax
   1175c:	8b 40 38             	mov    0x38(%eax),%eax
   1175f:	89 42 09             	mov    %eax,0x9(%edx)
   11762:	8b 55 0c             	mov    0xc(%ebp),%edx
   11765:	8b 45 10             	mov    0x10(%ebp),%eax
   11768:	8b 40 3c             	mov    0x3c(%eax),%eax
   1176b:	89 42 0d             	mov    %eax,0xd(%edx)
   1176e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   11771:	8b 4d 10             	mov    0x10(%ebp),%ecx
   11774:	8b 55 14             	mov    0x14(%ebp),%edx
   11777:	89 d0                	mov    %edx,%eax
   11779:	c1 e0 03             	shl    $0x3,%eax
   1177c:	01 d0                	add    %edx,%eax
   1177e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11785:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   1178b:	8b 44 10 04          	mov    0x4(%eax,%edx,1),%eax
   1178f:	89 04 24             	mov    %eax,(%esp,1)
   11792:	e8 fc ff ff ff       	call   11793 <marshallContinuationServer+0x44>
   11797:	89 43 01             	mov    %eax,0x1(%ebx)
   1179a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   1179d:	8b 4d 10             	mov    0x10(%ebp),%ecx
   117a0:	8b 55 14             	mov    0x14(%ebp),%edx
   117a3:	89 d0                	mov    %edx,%eax
   117a5:	c1 e0 03             	shl    $0x3,%eax
   117a8:	01 d0                	add    %edx,%eax
   117aa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   117b1:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   117b7:	0f b6 44 10 0c       	movzbl 0xc(%eax,%edx,1),%eax
   117bc:	c0 e8 03             	shr    $0x3,%al
   117bf:	24 07                	and    $0x7,%al
   117c1:	88 03                	mov    %al,(%ebx)
   117c3:	8b 4d 10             	mov    0x10(%ebp),%ecx
   117c6:	8b 55 14             	mov    0x14(%ebp),%edx
   117c9:	89 d0                	mov    %edx,%eax
   117cb:	c1 e0 03             	shl    $0x3,%eax
   117ce:	01 d0                	add    %edx,%eax
   117d0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   117d7:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   117dd:	0f b6 44 10 0c       	movzbl 0xc(%eax,%edx,1),%eax
   117e2:	24 07                	and    $0x7,%al
   117e4:	24 80                	and    $0x80,%al
   117e6:	84 c0                	test   %al,%al
   117e8:	74 09                	je     117f3 <marshallContinuationServer+0xa4>
   117ea:	8b 45 0c             	mov    0xc(%ebp),%eax
   117ed:	c6 40 05 01          	movb   $0x1,0x5(%eax)
   117f1:	eb 07                	jmp    117fa <marshallContinuationServer+0xab>
   117f3:	8b 45 0c             	mov    0xc(%ebp),%eax
   117f6:	c6 40 05 00          	movb   $0x0,0x5(%eax)
   117fa:	8b 4d 10             	mov    0x10(%ebp),%ecx
   117fd:	8b 55 14             	mov    0x14(%ebp),%edx
   11800:	89 d0                	mov    %edx,%eax
   11802:	c1 e0 03             	shl    $0x3,%eax
   11805:	01 d0                	add    %edx,%eax
   11807:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1180e:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   11814:	0f b6 44 10 0c       	movzbl 0xc(%eax,%edx,1),%eax
   11819:	24 07                	and    $0x7,%al
   1181b:	24 03                	and    $0x3,%al
   1181d:	0f b6 c0             	movzbl %al,%eax
   11820:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   11823:	83 7d f8 02          	cmpl   $0x2,0xfffffff8(%ebp)
   11827:	7e 25                	jle    1184e <marshallContinuationServer+0xff>
   11829:	c7 44 24 04 19 45 00 	movl   $0x4519,0x4(%esp,1)
   11830:	00 
   11831:	c7 04 24 1d 45 00 00 	movl   $0x451d,(%esp,1)
   11838:	e8 fc ff ff ff       	call   11839 <marshallContinuationServer+0xea>
   1183d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   11844:	e8 fc ff ff ff       	call   11845 <marshallContinuationServer+0xf6>
   11849:	e8 fc ff ff ff       	call   1184a <marshallContinuationServer+0xfb>
   1184e:	8b 55 0c             	mov    0xc(%ebp),%edx
   11851:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   11854:	0f b6 04 85 e8 44 00 	movzbl 0x44e8(,%eax,4),%eax
   1185b:	00 
   1185c:	88 42 2d             	mov    %al,0x2d(%edx)
   1185f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   11862:	8b 45 10             	mov    0x10(%ebp),%eax
   11865:	8b 40 48             	mov    0x48(%eax),%eax
   11868:	89 04 24             	mov    %eax,(%esp,1)
   1186b:	e8 fc ff ff ff       	call   1186c <marshallContinuationServer+0x11d>
   11870:	89 43 25             	mov    %eax,0x25(%ebx)
   11873:	8b 55 0c             	mov    0xc(%ebp),%edx
   11876:	8b 45 10             	mov    0x10(%ebp),%eax
   11879:	8b 40 4c             	mov    0x4c(%eax),%eax
   1187c:	89 42 11             	mov    %eax,0x11(%edx)
   1187f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   11882:	8b 45 10             	mov    0x10(%ebp),%eax
   11885:	8b 40 50             	mov    0x50(%eax),%eax
   11888:	89 04 24             	mov    %eax,(%esp,1)
   1188b:	e8 fc ff ff ff       	call   1188c <marshallContinuationServer+0x13d>
   11890:	89 43 29             	mov    %eax,0x29(%ebx)
   11893:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   11896:	8b 45 10             	mov    0x10(%ebp),%eax
   11899:	8b 40 5c             	mov    0x5c(%eax),%eax
   1189c:	89 04 24             	mov    %eax,(%esp,1)
   1189f:	e8 fc ff ff ff       	call   118a0 <marshallContinuationServer+0x151>
   118a4:	89 43 2e             	mov    %eax,0x2e(%ebx)
   118a7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   118aa:	8b 45 10             	mov    0x10(%ebp),%eax
   118ad:	8b 40 60             	mov    0x60(%eax),%eax
   118b0:	89 04 24             	mov    %eax,(%esp,1)
   118b3:	e8 fc ff ff ff       	call   118b4 <marshallContinuationServer+0x165>
   118b8:	89 43 32             	mov    %eax,0x32(%ebx)
   118bb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   118be:	8b 45 10             	mov    0x10(%ebp),%eax
   118c1:	8b 40 64             	mov    0x64(%eax),%eax
   118c4:	89 04 24             	mov    %eax,(%esp,1)
   118c7:	e8 fc ff ff ff       	call   118c8 <marshallContinuationServer+0x179>
   118cc:	89 43 36             	mov    %eax,0x36(%ebx)
   118cf:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   118d2:	8b 45 10             	mov    0x10(%ebp),%eax
   118d5:	8b 40 68             	mov    0x68(%eax),%eax
   118d8:	89 04 24             	mov    %eax,(%esp,1)
   118db:	e8 fc ff ff ff       	call   118dc <marshallContinuationServer+0x18d>
   118e0:	89 43 3a             	mov    %eax,0x3a(%ebx)
   118e3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   118e6:	8b 45 10             	mov    0x10(%ebp),%eax
   118e9:	8b 40 6c             	mov    0x6c(%eax),%eax
   118ec:	89 04 24             	mov    %eax,(%esp,1)
   118ef:	e8 fc ff ff ff       	call   118f0 <marshallContinuationServer+0x1a1>
   118f4:	89 43 3e             	mov    %eax,0x3e(%ebx)
   118f7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   118fa:	8b 45 10             	mov    0x10(%ebp),%eax
   118fd:	8b 50 74             	mov    0x74(%eax),%edx
   11900:	8b 40 70             	mov    0x70(%eax),%eax
   11903:	89 41 42             	mov    %eax,0x42(%ecx)
   11906:	89 51 46             	mov    %edx,0x46(%ecx)
   11909:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   1190c:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   1190f:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   11912:	8b 45 0c             	mov    0xc(%ebp),%eax
   11915:	8b 40 01             	mov    0x1(%eax),%eax
   11918:	89 02                	mov    %eax,(%edx)
   1191a:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   1191d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11920:	0f b6 00             	movzbl (%eax),%eax
   11923:	88 42 04             	mov    %al,0x4(%edx)
   11926:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   11929:	8b 45 0c             	mov    0xc(%ebp),%eax
   1192c:	80 78 05 00          	cmpb   $0x0,0x5(%eax)
   11930:	0f 95 c0             	setne  %al
   11933:	88 42 05             	mov    %al,0x5(%edx)
   11936:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   11939:	8b 45 10             	mov    0x10(%ebp),%eax
   1193c:	8b 40 14             	mov    0x14(%eax),%eax
   1193f:	89 42 06             	mov    %eax,0x6(%edx)
   11942:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   11945:	8b 45 10             	mov    0x10(%ebp),%eax
   11948:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
   1194c:	66 89 42 0a          	mov    %ax,0xa(%edx)
   11950:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   11953:	8b 45 10             	mov    0x10(%ebp),%eax
   11956:	8b 40 18             	mov    0x18(%eax),%eax
   11959:	89 42 0c             	mov    %eax,0xc(%edx)
   1195c:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   1195f:	8b 45 10             	mov    0x10(%ebp),%eax
   11962:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
   11966:	66 89 42 10          	mov    %ax,0x10(%edx)
   1196a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1196d:	83 c0 15             	add    $0x15,%eax
   11970:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   11974:	8b 45 0c             	mov    0xc(%ebp),%eax
   11977:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1197b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1197e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   11982:	8b 45 08             	mov    0x8(%ebp),%eax
   11985:	89 04 24             	mov    %eax,(%esp,1)
   11988:	e8 fc ff ff ff       	call   11989 <marshallContinuationServer+0x23a>
   1198d:	83 c4 34             	add    $0x34,%esp
   11990:	5b                   	pop    %ebx
   11991:	5d                   	pop    %ebp
   11992:	c3                   	ret    

00011993 <unmarshallContinuationServer>:
MARSHALL_CONTINUATION(ServerCopyMAC, 1, CLIENT_COMPUTE_MAC)
MARSHALL_CONTINUATION(Client, 0, CLIENT_COMPUTE_MAC)
#undef SERVER_COMPUTE_MAC
#undef CLIENT_COMPUTE_MAC
#undef HNCONVERTLONG

static inline void marshallAckProof(WireAckProof *dproof, const AckProof *sproof) {
#define HNCONVERTLONG(X) dproof->X = htonl(sproof->X);
#define COPYLONG(X) dproof->X = sproof->X
  int i;
  dproof->numSacks = MIN(sproof->numSacks, MAXSACKS);
  for(i=0; i < dproof->numSacks; i++) {
    HNCONVERTLONG(sacks[i].left);
    HNCONVERTLONG(sacks[i].right);
    COPYLONG(sacks[i].nonceSummary);
  }
#undef HNCONVERTLONG
#undef COPYLONG
}

#define NHCONVERTLONG(X) dcont->X = ntohl(scont->X);
#define COPYLONG(X) dcont->X = scont->X

struct sk_buff;
/* skb is used to initialize connection endpoint variables */

#define UNMARSHALL_CONTINUATION(SUFFIX, COMPUTE_MAC)			\
  static inline int unmarshallContinuation ## SUFFIX(struct sk_buff *skb, CONTINUATION_TYPE *dcont, const WireContinuation *scont) { \
    COMPUTE_MAC();							\
  dcont->continuationType = scont->continuationType;			\
  NHCONVERTLONG(seq); /* printk("dcont->seq = %d\n", dcont->seq); */	\
									\
  dcont->clientState = scont->clientState;				\
  dcont->parent = scont->parent;					\
									\
  dcont->rawTimestamp = scont->timestamp;				\
  dcont->timestamp = ntohl(scont->timestamp);				\
  dcont->clientTimestamp = scont->clientTimestamp;			\
  dcont->rawMrtt = scont->mrtt;						\
									\
  dcont->mrtt = ntohl(scont->mrtt);					\
  dcont->state = scont->state;						\
  dcont->firstChild = scont->firstChild;				\
									\
  /* printk("unmarshall - firstLoss: %p\n", &dcont->firstLoss); */	\
  NHCONVERTLONG(firstLoss);						\
  NHCONVERTLONG(firstBootstrapSeq);					\
  NHCONVERTLONG(startCwnd);						\
  NHCONVERTLONG(ssthresh);						\
  NHCONVERTLONG(TCPBase);						\
									\
  if(unlikely(!SIMULATION_MODE(skb->sk))) {				\
	  dcont->saddr = skb->nh.iph->daddr;				\
	  dcont->daddr = skb->nh.iph->saddr;				\
	  dcont->source = skb->h.th->dest;				\
	  dcont->dest = skb->h.th->source;				\
  }									\
  dcont->num_packets = 0;						\
									\
  dcont->tokenCounterBase = scont->tokenCounterBase;			\
									\
  dcont->numChildrenReceived = 0;					\
  dcont->parentMSK = NULL;						\
									\
  return 1;								\
}

#define MAC_VERIFY_PHDR()			\
	phdr->seq = scont->seq;					\
	phdr->type = scont->continuationType;			\
	phdr->first = scont->firstChild;			\
	phdr->serverAddr = skb->nh.iph->daddr;			\
	phdr->serverPort = skb->h.th->dest;			\
	phdr->clientAddr = skb->nh.iph->saddr;			\
	phdr->clientPort = skb->h.th->source

#define SERVER_COMPUTE_MAC()			\
do {						\
    if(unlikely(!SIMULATION_MODE(skb->sk))) {	\
	    char mac[HMACLEN];						\
	    PseudoHeader hdr, *phdr = &hdr;				\
	    MAC_VERIFY_PHDR();						\
									\
	    computeMAC(skb->sk, phdr, scont, mac);			\
	    if(memcmp(mac, scont->mac, HMACLEN)) {			\
		    printk("failed hmac comparison\n"); return 0;	\
	    }								\
    }						\
} while(0);

#define CLIENT_COMPUTE_MAC()			\
  do {					\
    memcpy(dcont->mac, scont->mac, HMACLEN);	\
  } while(0)

UNMARSHALL_CONTINUATION(Server, SERVER_COMPUTE_MAC);
   11993:	55                   	push   %ebp
   11994:	89 e5                	mov    %esp,%ebp
   11996:	57                   	push   %edi
   11997:	56                   	push   %esi
   11998:	53                   	push   %ebx
   11999:	83 ec 5c             	sub    $0x5c,%esp
   1199c:	c7 45 b8 00 00 00 00 	movl   $0x0,0xffffffb8(%ebp)
   119a3:	8b 45 08             	mov    0x8(%ebp),%eax
   119a6:	8b 40 0c             	mov    0xc(%eax),%eax
   119a9:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   119af:	83 e0 01             	and    $0x1,%eax
   119b2:	85 c0                	test   %eax,%eax
   119b4:	74 21                	je     119d7 <unmarshallContinuationServer+0x44>
   119b6:	8b 45 08             	mov    0x8(%ebp),%eax
   119b9:	8b 50 0c             	mov    0xc(%eax),%edx
   119bc:	8b 45 08             	mov    0x8(%ebp),%eax
   119bf:	8b 40 0c             	mov    0xc(%eax),%eax
   119c2:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   119c8:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
   119ce:	83 e0 08             	and    $0x8,%eax
   119d1:	85 c0                	test   %eax,%eax
   119d3:	75 02                	jne    119d7 <unmarshallContinuationServer+0x44>
   119d5:	eb 07                	jmp    119de <unmarshallContinuationServer+0x4b>
   119d7:	c7 45 b8 01 00 00 00 	movl   $0x1,0xffffffb8(%ebp)
   119de:	83 7d b8 00          	cmpl   $0x0,0xffffffb8(%ebp)
   119e2:	0f 84 d7 00 00 00    	je     11abf <unmarshallContinuationServer+0x12c>
   119e8:	8d 45 c4             	lea    0xffffffc4(%ebp),%eax
   119eb:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
   119ee:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
   119f1:	8b 45 10             	mov    0x10(%ebp),%eax
   119f4:	8b 40 01             	mov    0x1(%eax),%eax
   119f7:	89 02                	mov    %eax,(%edx)
   119f9:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
   119fc:	8b 45 10             	mov    0x10(%ebp),%eax
   119ff:	0f b6 00             	movzbl (%eax),%eax
   11a02:	88 42 04             	mov    %al,0x4(%edx)
   11a05:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
   11a08:	8b 45 10             	mov    0x10(%ebp),%eax
   11a0b:	0f b6 40 05          	movzbl 0x5(%eax),%eax
   11a0f:	88 42 05             	mov    %al,0x5(%edx)
   11a12:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
   11a15:	8b 45 08             	mov    0x8(%ebp),%eax
   11a18:	8b 40 24             	mov    0x24(%eax),%eax
   11a1b:	8b 40 10             	mov    0x10(%eax),%eax
   11a1e:	89 42 06             	mov    %eax,0x6(%edx)
   11a21:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
   11a24:	8b 45 08             	mov    0x8(%ebp),%eax
   11a27:	8b 40 20             	mov    0x20(%eax),%eax
   11a2a:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   11a2e:	66 89 42 0a          	mov    %ax,0xa(%edx)
   11a32:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
   11a35:	8b 45 08             	mov    0x8(%ebp),%eax
   11a38:	8b 40 24             	mov    0x24(%eax),%eax
   11a3b:	8b 40 0c             	mov    0xc(%eax),%eax
   11a3e:	89 42 0c             	mov    %eax,0xc(%edx)
   11a41:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
   11a44:	8b 45 08             	mov    0x8(%ebp),%eax
   11a47:	8b 40 20             	mov    0x20(%eax),%eax
   11a4a:	0f b7 00             	movzwl (%eax),%eax
   11a4d:	66 89 42 10          	mov    %ax,0x10(%edx)
   11a51:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   11a54:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   11a58:	8b 45 10             	mov    0x10(%ebp),%eax
   11a5b:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   11a5f:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
   11a62:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   11a66:	8b 45 08             	mov    0x8(%ebp),%eax
   11a69:	8b 40 0c             	mov    0xc(%eax),%eax
   11a6c:	89 04 24             	mov    %eax,(%esp,1)
   11a6f:	e8 fc ff ff ff       	call   11a70 <unmarshallContinuationServer+0xdd>
   11a74:	8b 45 10             	mov    0x10(%ebp),%eax
   11a77:	83 c0 15             	add    $0x15,%eax
   11a7a:	8d 55 e4             	lea    0xffffffe4(%ebp),%edx
   11a7d:	89 55 b4             	mov    %edx,0xffffffb4(%ebp)
   11a80:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
   11a83:	c7 45 ac 10 00 00 00 	movl   $0x10,0xffffffac(%ebp)
   11a8a:	fc                   	cld    
   11a8b:	8b 75 b4             	mov    0xffffffb4(%ebp),%esi
   11a8e:	8b 7d b0             	mov    0xffffffb0(%ebp),%edi
   11a91:	8b 4d ac             	mov    0xffffffac(%ebp),%ecx
   11a94:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
   11a96:	0f 97 c2             	seta   %dl
   11a99:	0f 92 c0             	setb   %al
   11a9c:	28 c2                	sub    %al,%dl
   11a9e:	88 d0                	mov    %dl,%al
   11aa0:	0f be c0             	movsbl %al,%eax
   11aa3:	85 c0                	test   %eax,%eax
   11aa5:	74 18                	je     11abf <unmarshallContinuationServer+0x12c>
   11aa7:	c7 04 24 df 50 00 00 	movl   $0x50df,(%esp,1)
   11aae:	e8 fc ff ff ff       	call   11aaf <unmarshallContinuationServer+0x11c>
   11ab3:	c7 45 bc 00 00 00 00 	movl   $0x0,0xffffffbc(%ebp)
   11aba:	e9 c9 01 00 00       	jmp    11c88 <unmarshallContinuationServer+0x2f5>
   11abf:	8b 55 0c             	mov    0xc(%ebp),%edx
   11ac2:	8b 45 10             	mov    0x10(%ebp),%eax
   11ac5:	0f b6 00             	movzbl (%eax),%eax
   11ac8:	89 42 34             	mov    %eax,0x34(%edx)
   11acb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   11ace:	8b 45 10             	mov    0x10(%ebp),%eax
   11ad1:	8b 40 01             	mov    0x1(%eax),%eax
   11ad4:	89 04 24             	mov    %eax,(%esp,1)
   11ad7:	e8 fc ff ff ff       	call   11ad8 <unmarshallContinuationServer+0x145>
   11adc:	89 43 30             	mov    %eax,0x30(%ebx)
   11adf:	8b 55 0c             	mov    0xc(%ebp),%edx
   11ae2:	8b 45 10             	mov    0x10(%ebp),%eax
   11ae5:	8b 40 09             	mov    0x9(%eax),%eax
   11ae8:	89 42 38             	mov    %eax,0x38(%edx)
   11aeb:	8b 55 0c             	mov    0xc(%ebp),%edx
   11aee:	8b 45 10             	mov    0x10(%ebp),%eax
   11af1:	8b 40 0d             	mov    0xd(%eax),%eax
   11af4:	89 42 3c             	mov    %eax,0x3c(%edx)
   11af7:	8b 55 0c             	mov    0xc(%ebp),%edx
   11afa:	8b 45 10             	mov    0x10(%ebp),%eax
   11afd:	8b 40 25             	mov    0x25(%eax),%eax
   11b00:	89 42 40             	mov    %eax,0x40(%edx)
   11b03:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   11b06:	8b 45 10             	mov    0x10(%ebp),%eax
   11b09:	8b 40 25             	mov    0x25(%eax),%eax
   11b0c:	89 04 24             	mov    %eax,(%esp,1)
   11b0f:	e8 fc ff ff ff       	call   11b10 <unmarshallContinuationServer+0x17d>
   11b14:	89 43 48             	mov    %eax,0x48(%ebx)
   11b17:	8b 55 0c             	mov    0xc(%ebp),%edx
   11b1a:	8b 45 10             	mov    0x10(%ebp),%eax
   11b1d:	8b 40 11             	mov    0x11(%eax),%eax
   11b20:	89 42 4c             	mov    %eax,0x4c(%edx)
   11b23:	8b 55 0c             	mov    0xc(%ebp),%edx
   11b26:	8b 45 10             	mov    0x10(%ebp),%eax
   11b29:	8b 40 29             	mov    0x29(%eax),%eax
   11b2c:	89 42 44             	mov    %eax,0x44(%edx)
   11b2f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   11b32:	8b 45 10             	mov    0x10(%ebp),%eax
   11b35:	8b 40 29             	mov    0x29(%eax),%eax
   11b38:	89 04 24             	mov    %eax,(%esp,1)
   11b3b:	e8 fc ff ff ff       	call   11b3c <unmarshallContinuationServer+0x1a9>
   11b40:	89 43 50             	mov    %eax,0x50(%ebx)
   11b43:	8b 55 0c             	mov    0xc(%ebp),%edx
   11b46:	8b 45 10             	mov    0x10(%ebp),%eax
   11b49:	0f b6 40 2d          	movzbl 0x2d(%eax),%eax
   11b4d:	89 42 54             	mov    %eax,0x54(%edx)
   11b50:	8b 55 0c             	mov    0xc(%ebp),%edx
   11b53:	8b 45 10             	mov    0x10(%ebp),%eax
   11b56:	0f b6 40 05          	movzbl 0x5(%eax),%eax
   11b5a:	89 42 58             	mov    %eax,0x58(%edx)
   11b5d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   11b60:	8b 45 10             	mov    0x10(%ebp),%eax
   11b63:	8b 40 2e             	mov    0x2e(%eax),%eax
   11b66:	89 04 24             	mov    %eax,(%esp,1)
   11b69:	e8 fc ff ff ff       	call   11b6a <unmarshallContinuationServer+0x1d7>
   11b6e:	89 43 5c             	mov    %eax,0x5c(%ebx)
   11b71:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   11b74:	8b 45 10             	mov    0x10(%ebp),%eax
   11b77:	8b 40 32             	mov    0x32(%eax),%eax
   11b7a:	89 04 24             	mov    %eax,(%esp,1)
   11b7d:	e8 fc ff ff ff       	call   11b7e <unmarshallContinuationServer+0x1eb>
   11b82:	89 43 60             	mov    %eax,0x60(%ebx)
   11b85:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   11b88:	8b 45 10             	mov    0x10(%ebp),%eax
   11b8b:	8b 40 36             	mov    0x36(%eax),%eax
   11b8e:	89 04 24             	mov    %eax,(%esp,1)
   11b91:	e8 fc ff ff ff       	call   11b92 <unmarshallContinuationServer+0x1ff>
   11b96:	89 43 64             	mov    %eax,0x64(%ebx)
   11b99:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   11b9c:	8b 45 10             	mov    0x10(%ebp),%eax
   11b9f:	8b 40 3a             	mov    0x3a(%eax),%eax
   11ba2:	89 04 24             	mov    %eax,(%esp,1)
   11ba5:	e8 fc ff ff ff       	call   11ba6 <unmarshallContinuationServer+0x213>
   11baa:	89 43 68             	mov    %eax,0x68(%ebx)
   11bad:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   11bb0:	8b 45 10             	mov    0x10(%ebp),%eax
   11bb3:	8b 40 3e             	mov    0x3e(%eax),%eax
   11bb6:	89 04 24             	mov    %eax,(%esp,1)
   11bb9:	e8 fc ff ff ff       	call   11bba <unmarshallContinuationServer+0x227>
   11bbe:	89 43 6c             	mov    %eax,0x6c(%ebx)
   11bc1:	c7 45 a8 00 00 00 00 	movl   $0x0,0xffffffa8(%ebp)
   11bc8:	8b 45 08             	mov    0x8(%ebp),%eax
   11bcb:	8b 40 0c             	mov    0xc(%eax),%eax
   11bce:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   11bd4:	83 e0 01             	and    $0x1,%eax
   11bd7:	85 c0                	test   %eax,%eax
   11bd9:	74 21                	je     11bfc <unmarshallContinuationServer+0x269>
   11bdb:	8b 45 08             	mov    0x8(%ebp),%eax
   11bde:	8b 50 0c             	mov    0xc(%eax),%edx
   11be1:	8b 45 08             	mov    0x8(%ebp),%eax
   11be4:	8b 40 0c             	mov    0xc(%eax),%eax
   11be7:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   11bed:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
   11bf3:	83 e0 08             	and    $0x8,%eax
   11bf6:	85 c0                	test   %eax,%eax
   11bf8:	75 02                	jne    11bfc <unmarshallContinuationServer+0x269>
   11bfa:	eb 07                	jmp    11c03 <unmarshallContinuationServer+0x270>
   11bfc:	c7 45 a8 01 00 00 00 	movl   $0x1,0xffffffa8(%ebp)
   11c03:	83 7d a8 00          	cmpl   $0x0,0xffffffa8(%ebp)
   11c07:	74 3f                	je     11c48 <unmarshallContinuationServer+0x2b5>
   11c09:	8b 55 0c             	mov    0xc(%ebp),%edx
   11c0c:	8b 45 08             	mov    0x8(%ebp),%eax
   11c0f:	8b 40 24             	mov    0x24(%eax),%eax
   11c12:	8b 40 10             	mov    0x10(%eax),%eax
   11c15:	89 42 14             	mov    %eax,0x14(%edx)
   11c18:	8b 55 0c             	mov    0xc(%ebp),%edx
   11c1b:	8b 45 08             	mov    0x8(%ebp),%eax
   11c1e:	8b 40 24             	mov    0x24(%eax),%eax
   11c21:	8b 40 0c             	mov    0xc(%eax),%eax
   11c24:	89 42 18             	mov    %eax,0x18(%edx)
   11c27:	8b 55 0c             	mov    0xc(%ebp),%edx
   11c2a:	8b 45 08             	mov    0x8(%ebp),%eax
   11c2d:	8b 40 20             	mov    0x20(%eax),%eax
   11c30:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   11c34:	66 89 42 1c          	mov    %ax,0x1c(%edx)
   11c38:	8b 55 0c             	mov    0xc(%ebp),%edx
   11c3b:	8b 45 08             	mov    0x8(%ebp),%eax
   11c3e:	8b 40 20             	mov    0x20(%eax),%eax
   11c41:	0f b7 00             	movzwl (%eax),%eax
   11c44:	66 89 42 1e          	mov    %ax,0x1e(%edx)
   11c48:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c4b:	c7 80 e8 00 00 00 00 	movl   $0x0,0xe8(%eax)
   11c52:	00 00 00 
   11c55:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   11c58:	8b 45 10             	mov    0x10(%ebp),%eax
   11c5b:	8b 50 46             	mov    0x46(%eax),%edx
   11c5e:	8b 40 42             	mov    0x42(%eax),%eax
   11c61:	89 41 70             	mov    %eax,0x70(%ecx)
   11c64:	89 51 74             	mov    %edx,0x74(%ecx)
   11c67:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c6a:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%eax)
   11c71:	00 00 00 
   11c74:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c77:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%eax)
   11c7e:	00 00 00 
   11c81:	c7 45 bc 01 00 00 00 	movl   $0x1,0xffffffbc(%ebp)
   11c88:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
   11c8b:	83 c4 5c             	add    $0x5c,%esp
   11c8e:	5b                   	pop    %ebx
   11c8f:	5e                   	pop    %esi
   11c90:	5f                   	pop    %edi
   11c91:	5d                   	pop    %ebp
   11c92:	c3                   	ret    

00011c93 <unmarshallAckProof>:
UNMARSHALL_CONTINUATION(Client, CLIENT_COMPUTE_MAC);

#undef SERVER_COMPUTE_MAC
#undef CLIENT_COMPUTE_MAC
#undef NHCONVERTLONG
#undef COPYLONG

extern int numContinuations;

#ifndef USERTEST
extern kmem_cache_t *clientSideContinuation_cache;
#endif


// Simulation accessors
#define SIMULATION_PACKETS(CONT)  (((CONT)+1)->packets)
#define SIMULATION_NUM_PACKETS(CONT)  (((CONT)+1)->num_packets)

static inline int SIMULATION_TOTAL_LEN(struct cminisock *cont) {
	int i;
	int total = 0;

	for(i=0; i < SIMULATION_NUM_PACKETS(cont); i++) {
		total += SIMULATION_PACKETS(cont)[i].len;
	}

	return total;
}

#define ENCODE_SIMULATION_RESULT(CONT)		\
	((SIMULATION_TOTAL_LEN(CONT) & 0xffff) |	\
	 SIMULATION_NUM_PACKETS(CONT) << 16)

static inline void DECODE_SIMULATION_RESULT(__u32 value, int *pTotalLen, int *pNumPackets) {
	*pTotalLen = value & 0xffff;
	*pNumPackets = (value >> 16) & 0xffff;
}

#define USESLAB
#define INIT2

#define CLIENTSIDE_CONTINUATION_SIZE (2 * sizeof(CONTINUATION_TYPE))
static inline CONTINUATION_TYPE *newClientSide_Continuation(int flags) {
  int i;
#ifdef USERTEST
  CONTINUATION_TYPE *rval = kmalloc(CLIENTSIDE_CONTINUATION_SIZE, flags);
#else
  CONTINUATION_TYPE *rval = kmem_cache_alloc(clientSideContinuation_cache, GFP_ATOMIC);
#endif

#ifdef DEBUG_TRICKLES_ALLOCATION // 0418
  numContinuations++;
#endif

  if(rval == NULL) {
    printk("out of memory while allocating continuation\n");
    return NULL;
  }

  rval->prev = rval->next = NULL;
  rval->list = NULL;
#ifdef INIT2 // 0502 - initialize only the first one (simulation is off)
  for(i=0; i < 2; i++) {
#else
  for(i=0; i < 1; i++) {
#endif
	  (rval+i)->ucont_len = 0;
	  (rval+i)->ucont_data = NULL;
	  (rval+i)->input_len = 0;
	  (rval+i)->input = NULL;
	  // 0429 null mark
	  (rval+i)->mark = 0;
	  (rval+i)->simulated = 0;
  }
  rval->sk = NULL;
  return rval;
}

static inline void *kmalloc_dup(void *src, int len, unsigned gfp) {
	char *ptr = kmalloc(len, gfp);
	if(ptr == NULL) {
		printk("out of memory in kmalloc_dup\n");
		return NULL;
	}
	memcpy(ptr, src, len);
	return ptr;
}

static inline CONTINUATION_TYPE *copyClientSide_Continuation(CONTINUATION_TYPE *cont, int flags) {
  int i;
#ifdef USERTEST
  CONTINUATION_TYPE *rval = kmalloc(2 * sizeof(CONTINUATION_TYPE), flags);
#else  //0426 - change kernel to slab cache
  CONTINUATION_TYPE *rval = kmem_cache_alloc(clientSideContinuation_cache, GFP_ATOMIC);
#endif

#ifdef DEBUG_TRICKLES_ALLOCATION // 0418
  numContinuations++;
#endif

  // 0501 - attempting to track down corruption bug
#ifdef DEBUG_ALLOC
#ifndef USERTEST
  if(((int)rval) & 0xfff) {
	  printk("incorrect alignment\n");
	  BUG();
  }
#endif // USERTEST
#endif // DEBUG_ALLOC

  if(rval == NULL) {
    printk("out of memory while allocating continuation to copy\n");
    return NULL;
  }
  rval->prev = rval->next = NULL;
  rval->list = NULL;

  memcpy(rval, cont, (int)((CONTINUATION_TYPE *)0)->clientside_copy_end);
  for(i=0; i < 2; i++) {
#if 0 // 0812 - copy makes the code very slow, so rewrite to avoid the copy
	  (rval+i)->ucont_len = (cont+i)->ucont_len;
	  char *src_ucont = (cont+i)->ucont_data;
	  if(src_ucont != NULL) {
		  (rval+i)->ucont_data = kmalloc_dup(src_ucont, (rval+i)->ucont_len, GFP_ATOMIC);
	  } else {
		  (rval+i)->ucont_data = NULL;
	  }
#else
	  (rval+i)->ucont_len = 0;
	  (rval+i)->ucont_data = NULL;
#endif
	  (rval+i)->input_len = 0;
	  (rval+i)->input = NULL;
	  // 0429 null mark
	  (rval+i)->mark = 0;
	  (rval+i)->simulated = 0;
	  (rval+i)->num_packets = 0;
	  (rval+i)->actualCwnd = 0;
  }
  //printk("copy rval = %p, input = %p\n", rval, cont);
  return rval;
}

#ifndef TRACE_FREE
static inline void freeClientSide_Continuation(CONTINUATION_TYPE *cont) {

#if 0
}
#endif

#else
#define CONT_POISON ((void*)0x7FFFFFFF)
#warning "Paranoid freeclientside continuation"

#define freeClientSide_Continuation(CONT) freeClientSide_ContinuationHelper((CONT), __FILE__, __LINE__)
 static inline void freeClientSide_ContinuationHelper(CONTINUATION_TYPE *cont, char *file, int lineno) {

#endif
#ifdef TRACE_FREE
  printk("freeingclientside %p @ (%s:%d)\n", cont, file, lineno);
#endif

  int i;

#ifdef TRACE_FREE
  if(cont->sk == CONT_POISON) {
	  printk("Warning: Continuation poisoned\n");
	  BUG();
  }
#endif // TRACE_FREE

#ifdef DEBUG_TRICKLES_ALLOCATION // 0418
  numContinuations--;
#endif
#ifdef DEBUG_ALLOC
#ifndef USERTEST
  if((int)cont & 0xfff) {
	  BUG();
  }
#endif // USERTEST
#endif // DEBUG_ALLOC

  if(cont->list) {
	  BUG();
  }

  for(i=0; i < 2; i++) {
    if((cont+i)->ucont_data)
      kfree((cont+i)->ucont_data);
    if((cont+i)->input)
      kfree((cont+i)->input);
  }
  // poison
#ifdef TRACE_FREE
  cont->sk = CONT_POISON;
#endif // TRACE_FREE

#ifdef USERTEST
  kfree(cont);
#else  //0426 - change kernel to slab cache
#ifdef DEBUG_ALLOC
  zap_virt(cont);
  //memset(cont, 0x3e, sizeof(*cont));
#else
#ifndef USESLAB
  kfree(cont);  // 0502 maybe slab cache usage is buggy
#else
  kmem_cache_free(clientSideContinuation_cache, cont);
#endif
#endif
#endif
}

static inline void unmarshallAckProof(AckProof *dproof, const WireAckProof *sproof) {
   11c93:	55                   	push   %ebp
   11c94:	89 e5                	mov    %esp,%ebp
   11c96:	53                   	push   %ebx
   11c97:	83 ec 08             	sub    $0x8,%esp
#define NHCONVERTLONG(X) dproof->X = ntohl(sproof->X);
#define COPYLONG(X) dproof->X = sproof->X
  int i;
  dproof->numSacks = sproof->numSacks;
   11c9a:	8b 45 08             	mov    0x8(%ebp),%eax
   11c9d:	8b 55 0c             	mov    0xc(%ebp),%edx
   11ca0:	0f b6 12             	movzbl (%edx),%edx
   11ca3:	89 10                	mov    %edx,(%eax)
  for(i=0; i < sproof->numSacks; i++) {
   11ca5:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
   11cac:	8b 45 0c             	mov    0xc(%ebp),%eax
   11caf:	0f b6 00             	movzbl (%eax),%eax
   11cb2:	39 45 f8             	cmp    %eax,0xfffffff8(%ebp)
   11cb5:	7c 05                	jl     11cbc <unmarshallAckProof+0x29>
   11cb7:	e9 95 00 00 00       	jmp    11d51 <unmarshallAckProof+0xbe>
    NHCONVERTLONG(sacks[i].left);
   11cbc:	8b 4d 08             	mov    0x8(%ebp),%ecx
   11cbf:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   11cc2:	89 d0                	mov    %edx,%eax
   11cc4:	01 c0                	add    %eax,%eax
   11cc6:	01 d0                	add    %edx,%eax
   11cc8:	c1 e0 02             	shl    $0x2,%eax
   11ccb:	01 c8                	add    %ecx,%eax
   11ccd:	8d 58 08             	lea    0x8(%eax),%ebx
   11cd0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   11cd3:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   11cd6:	89 d0                	mov    %edx,%eax
   11cd8:	01 c0                	add    %eax,%eax
   11cda:	01 d0                	add    %edx,%eax
   11cdc:	c1 e0 02             	shl    $0x2,%eax
   11cdf:	8b 44 01 01          	mov    0x1(%ecx,%eax,1),%eax
   11ce3:	89 04 24             	mov    %eax,(%esp,1)
   11ce6:	e8 fc ff ff ff       	call   11ce7 <unmarshallAckProof+0x54>
   11ceb:	89 03                	mov    %eax,(%ebx)
    NHCONVERTLONG(sacks[i].right);
   11ced:	8b 4d 08             	mov    0x8(%ebp),%ecx
   11cf0:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   11cf3:	89 d0                	mov    %edx,%eax
   11cf5:	01 c0                	add    %eax,%eax
   11cf7:	01 d0                	add    %edx,%eax
   11cf9:	c1 e0 02             	shl    $0x2,%eax
   11cfc:	01 c8                	add    %ecx,%eax
   11cfe:	8d 58 0c             	lea    0xc(%eax),%ebx
   11d01:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   11d04:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   11d07:	89 d0                	mov    %edx,%eax
   11d09:	01 c0                	add    %eax,%eax
   11d0b:	01 d0                	add    %edx,%eax
   11d0d:	c1 e0 02             	shl    $0x2,%eax
   11d10:	8b 44 01 05          	mov    0x5(%ecx,%eax,1),%eax
   11d14:	89 04 24             	mov    %eax,(%esp,1)
   11d17:	e8 fc ff ff ff       	call   11d18 <unmarshallAckProof+0x85>
   11d1c:	89 03                	mov    %eax,(%ebx)
    COPYLONG(sacks[i].nonceSummary);
   11d1e:	8b 4d 08             	mov    0x8(%ebp),%ecx
   11d21:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   11d24:	89 d0                	mov    %edx,%eax
   11d26:	01 c0                	add    %eax,%eax
   11d28:	01 d0                	add    %edx,%eax
   11d2a:	c1 e0 02             	shl    $0x2,%eax
   11d2d:	01 c8                	add    %ecx,%eax
   11d2f:	8d 58 10             	lea    0x10(%eax),%ebx
   11d32:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   11d35:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   11d38:	89 d0                	mov    %edx,%eax
   11d3a:	01 c0                	add    %eax,%eax
   11d3c:	01 d0                	add    %edx,%eax
   11d3e:	c1 e0 02             	shl    $0x2,%eax
   11d41:	8b 44 01 09          	mov    0x9(%ecx,%eax,1),%eax
   11d45:	89 03                	mov    %eax,(%ebx)
   11d47:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
   11d4a:	ff 00                	incl   (%eax)
   11d4c:	e9 5b ff ff ff       	jmp    11cac <unmarshallAckProof+0x19>
  }
#undef NHCONVERTLONG
#undef COPYLONG
}
   11d51:	83 c4 08             	add    $0x8,%esp
   11d54:	5b                   	pop    %ebx
   11d55:	5d                   	pop    %ebp
   11d56:	c3                   	ret    

00011d57 <msk_clear_fields>:
static inline void msk_free_fields(struct sock *sk, struct cminisock *msk) {
	free_minisock(sk, msk);
}

static inline void msk_clear_fields(struct cminisock *msk) {
   11d57:	55                   	push   %ebp
   11d58:	89 e5                	mov    %esp,%ebp
	msk->num_packets = 0;
   11d5a:	8b 45 08             	mov    0x8(%ebp),%eax
   11d5d:	c7 80 e8 00 00 00 00 	movl   $0x0,0xe8(%eax)
   11d64:	00 00 00 
	msk->packets = NULL;
   11d67:	8b 45 08             	mov    0x8(%ebp),%eax
   11d6a:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%eax)
   11d71:	00 00 00 

	msk->ucont_len = 0;
   11d74:	8b 45 08             	mov    0x8(%ebp),%eax
   11d77:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
	msk->ucont_data = NULL;
   11d7e:	8b 45 08             	mov    0x8(%ebp),%eax
   11d81:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)

	msk->input_len = 0;
   11d88:	8b 45 08             	mov    0x8(%ebp),%eax
   11d8b:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
   11d92:	00 00 00 
	msk->input = NULL;
   11d95:	8b 45 08             	mov    0x8(%ebp),%eax
   11d98:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
   11d9f:	00 00 00 
}
   11da2:	5d                   	pop    %ebp
   11da3:	c3                   	ret    

00011da4 <alloc_msk_packets>:

#endif

#ifndef USERTEST

static inline int alloc_msk_packets(struct cminisock *msk, int numPackets) {
   11da4:	55                   	push   %ebp
   11da5:	89 e5                	mov    %esp,%ebp
   11da7:	53                   	push   %ebx
   11da8:	83 ec 0c             	sub    $0xc,%esp
	BUG_TRAP(msk->num_packets == 0);
   11dab:	8b 45 08             	mov    0x8(%ebp),%eax
   11dae:	83 b8 e8 00 00 00 00 	cmpl   $0x0,0xe8(%eax)
   11db5:	74 14                	je     11dcb <alloc_msk_packets+0x27>
   11db7:	c7 44 24 04 4b 00 00 	movl   $0x4b,0x4(%esp,1)
   11dbe:	00 
   11dbf:	c7 04 24 00 51 00 00 	movl   $0x5100,(%esp,1)
   11dc6:	e8 fc ff ff ff       	call   11dc7 <alloc_msk_packets+0x23>
	BUG_TRAP(numPackets >= 0);
   11dcb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11dcf:	79 14                	jns    11de5 <alloc_msk_packets+0x41>
   11dd1:	c7 44 24 04 4c 00 00 	movl   $0x4c,0x4(%esp,1)
   11dd8:	00 
   11dd9:	c7 04 24 80 51 00 00 	movl   $0x5180,(%esp,1)
   11de0:	e8 fc ff ff ff       	call   11de1 <alloc_msk_packets+0x3d>
#define MAX_NUM_SIMULATION_PACKETS (8000)
	static struct cminisock_packet packets[NR_CPUS][MAX_NUM_SIMULATION_PACKETS];
	if(!SIMULATION_MODE(msk->sk)) {
   11de5:	8b 45 08             	mov    0x8(%ebp),%eax
   11de8:	8b 40 20             	mov    0x20(%eax),%eax
   11deb:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   11df1:	83 e0 01             	and    $0x1,%eax
   11df4:	85 c0                	test   %eax,%eax
   11df6:	74 21                	je     11e19 <alloc_msk_packets+0x75>
   11df8:	8b 45 08             	mov    0x8(%ebp),%eax
   11dfb:	8b 50 20             	mov    0x20(%eax),%edx
   11dfe:	8b 45 08             	mov    0x8(%ebp),%eax
   11e01:	8b 40 20             	mov    0x20(%eax),%eax
   11e04:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   11e0a:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
   11e10:	83 e0 08             	and    $0x8,%eax
   11e13:	85 c0                	test   %eax,%eax
   11e15:	75 02                	jne    11e19 <alloc_msk_packets+0x75>
   11e17:	eb 3d                	jmp    11e56 <alloc_msk_packets+0xb2>
		msk->packets = tmalloc(msk->sk, sizeof(struct cminisock_packet) * numPackets);
   11e19:	8b 5d 08             	mov    0x8(%ebp),%ebx
   11e1c:	8b 55 0c             	mov    0xc(%ebp),%edx
   11e1f:	89 d0                	mov    %edx,%eax
   11e21:	c1 e0 03             	shl    $0x3,%eax
   11e24:	01 d0                	add    %edx,%eax
   11e26:	c1 e0 02             	shl    $0x2,%eax
   11e29:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   11e2d:	8b 45 08             	mov    0x8(%ebp),%eax
   11e30:	8b 40 20             	mov    0x20(%eax),%eax
   11e33:	89 04 24             	mov    %eax,(%esp,1)
   11e36:	e8 fc ff ff ff       	call   11e37 <alloc_msk_packets+0x93>
   11e3b:	89 83 ec 00 00 00    	mov    %eax,0xec(%ebx)

		// printk("allocated packets to %p\n", msk->packets);

		if(msk->packets == NULL) {
   11e41:	8b 45 08             	mov    0x8(%ebp),%eax
   11e44:	83 b8 ec 00 00 00 00 	cmpl   $0x0,0xec(%eax)
   11e4b:	75 37                	jne    11e84 <alloc_msk_packets+0xe0>
			if(trickles_ratelimit()) {
				printk("out of memory while tmalloc()'ing space for packets\n");
			}
			return 0;
   11e4d:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
   11e54:	eb 41                	jmp    11e97 <alloc_msk_packets+0xf3>
		}
	} else {
		// avoid malloc
		if(numPackets <= MAX_NUM_SIMULATION_PACKETS) {
   11e56:	81 7d 0c 40 1f 00 00 	cmpl   $0x1f40,0xc(%ebp)
   11e5d:	7f 0f                	jg     11e6e <alloc_msk_packets+0xca>
			msk->packets = packets[smp_processor_id()];
   11e5f:	8b 45 08             	mov    0x8(%ebp),%eax
   11e62:	c7 80 ec 00 00 00 80 	movl   $0x8d880,0xec(%eax)
   11e69:	d8 08 00 
   11e6c:	eb 16                	jmp    11e84 <alloc_msk_packets+0xe0>
		} else {
			msk->packets = NULL;
   11e6e:	8b 45 08             	mov    0x8(%ebp),%eax
   11e71:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%eax)
   11e78:	00 00 00 
			if(trickles_ratelimit()) {
				printk("Too many packets requested during simulation\n");
			}
			return 0;
   11e7b:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
   11e82:	eb 13                	jmp    11e97 <alloc_msk_packets+0xf3>
		}
	}
	msk->num_packets = numPackets;
   11e84:	8b 55 08             	mov    0x8(%ebp),%edx
   11e87:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e8a:	89 82 e8 00 00 00    	mov    %eax,0xe8(%edx)
	return 1;
   11e90:	c7 45 f8 01 00 00 00 	movl   $0x1,0xfffffff8(%ebp)
}
   11e97:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   11e9a:	83 c4 0c             	add    $0xc,%esp
   11e9d:	5b                   	pop    %ebx
   11e9e:	5d                   	pop    %ebp
   11e9f:	c3                   	ret    

00011ea0 <alloc_trickles_msk>:

static inline
int can_alloc_trickles_msk(struct sock *sk) {
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
	struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
	struct cminisock *curr =
		(struct cminisock *)head->next;
	while((struct alloc_head_list*)curr != head && curr->ctl == ALLOC_PROCESSING) {
		//printk("alloc_head loop\n");
		curr = curr->next;
	}
	return (struct alloc_head_list*)curr != head;
}

static inline struct cminisock *alloc_trickles_msk(struct sock *sk) {
   11ea0:	55                   	push   %ebp
   11ea1:	89 e5                	mov    %esp,%ebp
   11ea3:	83 ec 1c             	sub    $0x1c,%esp
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
   11ea6:	8b 45 08             	mov    0x8(%ebp),%eax
   11ea9:	05 bc 00 00 00       	add    $0xbc,%eax
   11eae:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
   11eb1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   11eb4:	05 d4 01 00 00       	add    $0x1d4,%eax
   11eb9:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	struct cminisock *rval = NULL, *curr = (struct cminisock *)tp->cminisock_api_config.msk_freelist.next;
   11ebc:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
   11ec3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   11ec6:	8b 80 d8 01 00 00    	mov    0x1d8(%eax),%eax
   11ecc:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

	if(!SIMULATION_MODE(sk)) {
   11ecf:	8b 45 08             	mov    0x8(%ebp),%eax
   11ed2:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   11ed8:	83 e0 01             	and    $0x1,%eax
   11edb:	85 c0                	test   %eax,%eax
   11edd:	74 1b                	je     11efa <alloc_trickles_msk+0x5a>
   11edf:	8b 55 08             	mov    0x8(%ebp),%edx
   11ee2:	8b 45 08             	mov    0x8(%ebp),%eax
   11ee5:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   11eeb:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
   11ef1:	83 e0 08             	and    $0x8,%eax
   11ef4:	85 c0                	test   %eax,%eax
   11ef6:	75 02                	jne    11efa <alloc_trickles_msk+0x5a>
   11ef8:	eb 52                	jmp    11f4c <alloc_trickles_msk+0xac>
		while((struct alloc_head_list*)curr != head && curr->ctl == ALLOC_PROCESSING) {
   11efa:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   11efd:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
   11f00:	74 16                	je     11f18 <alloc_trickles_msk+0x78>
   11f02:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   11f05:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
   11f09:	74 02                	je     11f0d <alloc_trickles_msk+0x6d>
   11f0b:	eb 0b                	jmp    11f18 <alloc_trickles_msk+0x78>
			//printk("alloc_head loop\n");
			curr = curr->next;
   11f0d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   11f10:	8b 40 04             	mov    0x4(%eax),%eax
   11f13:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   11f16:	eb e2                	jmp    11efa <alloc_trickles_msk+0x5a>
		}
		//printk("out of alloc_head loop\n");

		if((struct alloc_head_list *)curr == head) return NULL;
   11f18:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   11f1b:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
   11f1e:	75 0c                	jne    11f2c <alloc_trickles_msk+0x8c>
   11f20:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
   11f27:	e9 ea 00 00 00       	jmp    12016 <alloc_trickles_msk+0x176>

		rval = curr;
   11f2c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   11f2f:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		unlink((struct alloc_head*)rval);
   11f32:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   11f35:	89 04 24             	mov    %eax,(%esp,1)
   11f38:	e8 36 f6 ff ff       	call   11573 <unlink>
		rval->ctl = ALLOC_PENDING;
   11f3d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   11f40:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
   11f47:	e9 b9 00 00 00       	jmp    12005 <alloc_trickles_msk+0x165>
	} else {
		if(tp->t.responseCount == 0) {
   11f4c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   11f4f:	83 b8 7c 0a 00 00 00 	cmpl   $0x0,0xa7c(%eax)
   11f56:	75 2b                	jne    11f83 <alloc_trickles_msk+0xe3>
			rval = tp->t.responseMSK;
   11f58:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   11f5b:	8b 80 64 0a 00 00    	mov    0xa64(%eax),%eax
   11f61:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
			rval->list = NULL;
   11f64:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   11f67:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
			rval->next = rval->prev = NULL;
   11f6e:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   11f71:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   11f74:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   11f7a:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
   11f81:	eb 66                	jmp    11fe9 <alloc_trickles_msk+0x149>
		} else {
			rval = kmalloc(sizeof (struct cminisock), GFP_ATOMIC);
   11f83:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
   11f8a:	00 
   11f8b:	c7 04 24 fc 00 00 00 	movl   $0xfc,(%esp,1)
   11f92:	e8 fc ff ff ff       	call   11f93 <alloc_trickles_msk+0xf3>
   11f97:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
			if(rval == NULL) {
   11f9a:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
   11f9e:	75 15                	jne    11fb5 <alloc_trickles_msk+0x115>
				printk("out of memory during compatibility mode\n");
   11fa0:	c7 04 24 00 52 00 00 	movl   $0x5200,(%esp,1)
   11fa7:	e8 fc ff ff ff       	call   11fa8 <alloc_trickles_msk+0x108>
				return NULL;
   11fac:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
   11fb3:	eb 61                	jmp    12016 <alloc_trickles_msk+0x176>
			}
			rval->next = rval->prev = NULL;
   11fb5:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   11fb8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   11fbb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   11fc1:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
			rval->list = NULL;
   11fc8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   11fcb:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
			insert_tail(&tp->t.responseList, (struct alloc_head*)rval);
   11fd2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   11fd5:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   11fd9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   11fdc:	05 68 0a 00 00       	add    $0xa68,%eax
   11fe1:	89 04 24             	mov    %eax,(%esp,1)
   11fe4:	e8 ff 04 00 00       	call   124e8 <insert_tail>
		}
		tp->t.responseCount++;
   11fe9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   11fec:	ff 80 7c 0a 00 00    	incl   0xa7c(%eax)

		rval->sk = sk;
   11ff2:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   11ff5:	8b 45 08             	mov    0x8(%ebp),%eax
   11ff8:	89 42 20             	mov    %eax,0x20(%edx)
		rval->ctl = ALLOC_PENDING;
   11ffb:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   11ffe:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	}

	init_minisock(rval);
   12005:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   12008:	89 04 24             	mov    %eax,(%esp,1)
   1200b:	e8 84 05 00 00       	call   12594 <init_minisock>

	return rval;
   12010:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   12013:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
}
   12016:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   12019:	c9                   	leave  
   1201a:	c3                   	ret    

0001201b <shallow_copy_msk>:

static inline void msk_hold(struct cminisock *msk) {
	msk->refCnt++;
}

#endif // USERTEST

static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk);
static inline void free_trickles_msk_finish(struct sock *sk, struct cminisock *msk);

static inline struct cminisock *
shallow_copy_msk(struct sock *sk, struct cminisock *msk) {
   1201b:	55                   	push   %ebp
   1201c:	89 e5                	mov    %esp,%ebp
   1201e:	57                   	push   %edi
   1201f:	56                   	push   %esi
   12020:	83 ec 1c             	sub    $0x1c,%esp
	struct cminisock *rval = alloc_trickles_msk(sk);
   12023:	8b 45 08             	mov    0x8(%ebp),%eax
   12026:	89 04 24             	mov    %eax,(%esp,1)
   12029:	e8 72 fe ff ff       	call   11ea0 <alloc_trickles_msk>
   1202e:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

	struct alloc_head head;

	if(rval == NULL) {
   12031:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
   12035:	75 15                	jne    1204c <shallow_copy_msk+0x31>
		printk("out of memory while copying msk\n");
   12037:	c7 04 24 40 52 00 00 	movl   $0x5240,(%esp,1)
   1203e:	e8 fc ff ff ff       	call   1203f <shallow_copy_msk+0x24>
		return NULL;
   12043:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
   1204a:	eb 5e                	jmp    120aa <shallow_copy_msk+0x8f>
	}
	/* save & restore alloc head */
	head = *(struct alloc_head*)rval;
   1204c:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   1204f:	8b 02                	mov    (%edx),%eax
   12051:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   12054:	8b 42 04             	mov    0x4(%edx),%eax
   12057:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1205a:	8b 42 08             	mov    0x8(%edx),%eax
   1205d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   12060:	8b 42 0c             	mov    0xc(%edx),%eax
   12063:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	*rval = *msk;
   12066:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   12069:	8b 55 0c             	mov    0xc(%ebp),%edx
   1206c:	89 c7                	mov    %eax,%edi
   1206e:	89 d6                	mov    %edx,%esi
   12070:	b8 fc 00 00 00       	mov    $0xfc,%eax
   12075:	fc                   	cld    
   12076:	89 c1                	mov    %eax,%ecx
   12078:	c1 e9 02             	shr    $0x2,%ecx
   1207b:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
	*(struct alloc_head*)rval = head;
   1207d:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   12080:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   12083:	89 02                	mov    %eax,(%edx)
   12085:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   12088:	89 42 04             	mov    %eax,0x4(%edx)
   1208b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1208e:	89 42 08             	mov    %eax,0x8(%edx)
   12091:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   12094:	89 42 0c             	mov    %eax,0xc(%edx)

	rval->refCnt = 1;
   12097:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1209a:	c7 80 f0 00 00 00 01 	movl   $0x1,0xf0(%eax)
   120a1:	00 00 00 

	return rval;
   120a4:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   120a7:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
}
   120aa:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   120ad:	83 c4 1c             	add    $0x1c,%esp
   120b0:	5e                   	pop    %esi
   120b1:	5f                   	pop    %edi
   120b2:	5d                   	pop    %ebp
   120b3:	c3                   	ret    

000120b4 <msk_release>:


#ifdef CAN_USE_TFREE
static inline struct cminisock *copy_msk(struct sock *sk, struct cminisock *msk) {
	// Copy everything except for per-packet information.

	printk("CopyMSK\n");
#if 0
	struct cminisock *rval = alloc_trickles_msk(sk);
	struct alloc_head head;
	if(rval == NULL) {
		printk("out of memory while copying msk\n");
		return NULL;
	}
	/* save & restore alloc head */
	head = *(struct alloc_head*)rval;
	*rval = *msk;
	*(struct alloc_head*)rval = head;
#else
	struct cminisock *rval = shallow_copy_msk(sk, msk);
	if(rval == NULL) {
		printk("out of memory while copying msk\n");
		return NULL;
	}
#endif

	rval->num_packets = 0;
	rval->packets = NULL;

	if(rval->ucont_len > 0) {
		rval->ucont_data = tmalloc(sk,rval->ucont_len);
		// printk("copymsk: tmalloc ucontdata\n");
		if(rval->ucont_data == NULL) {
			printk("out of tmalloc memory while copying msk (len = %d)\n", rval->ucont_len);
			free_trickles_msk(sk,rval);
			free_trickles_msk_finish(sk,rval);
			return NULL;
		}
	} else {
		rval->ucont_data = NULL;
	}
	if(rval->input_len > 0) {
		rval->input = tmalloc(sk,rval->input_len);
		// printk("copymsk: tmalloc inputlen\n");
		if(rval->input == NULL) {
			printk("out of tmalloc memory while copying msk (len = %d)\n", rval->input_len);
			tfree(sk,rval->ucont_data);
			free_trickles_msk(sk,rval);
			free_trickles_msk_finish(sk,rval);
			return NULL;
		}
	} else {
		rval->input = NULL;
	}
	if(rval->ucont_data)
		memcpy(rval->ucont_data,msk->ucont_data,rval->ucont_len);
	if(rval->input)
		memcpy(rval->input,msk->input,rval->input_len);

	rval->executionTrace |= 0x80;
	return rval;
}
#endif // CAN_USE_TFREE

/* Two phase free: first phase disconnects socket from event list,
   sets to ALLOC_PROCESSING; second phase adds the socket to free
   list, sets to ALLOC_FREE and ready for reuse */
#ifndef USERTEST
static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk) {
	if(!SIMULATION_MODE(sk)) {
		if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) {
			printk("double free\n");
			BUG();
		}
		if(msk->ctl == ALLOC_READY && msk->prev != NULL) {
			unlink((struct alloc_head *)msk);
		}
		msk->ctl = ALLOC_PROCESSING;
	}
}

static inline void msk_release(struct sock *sk, struct cminisock *msk) {
   120b4:	55                   	push   %ebp
   120b5:	89 e5                	mov    %esp,%ebp
   120b7:	83 ec 10             	sub    $0x10,%esp
	// Perform actual deallocation. This function is common to
	// state cache and event queue
	msk->refCnt--;
   120ba:	8b 45 0c             	mov    0xc(%ebp),%eax
   120bd:	ff 88 f0 00 00 00    	decl   0xf0(%eax)
	BUG_TRAP(msk->refCnt >= 0);
   120c3:	8b 45 0c             	mov    0xc(%ebp),%eax
   120c6:	83 b8 f0 00 00 00 00 	cmpl   $0x0,0xf0(%eax)
   120cd:	79 14                	jns    120e3 <msk_release+0x2f>
   120cf:	c7 44 24 04 13 01 00 	movl   $0x113,0x4(%esp,1)
   120d6:	00 
   120d7:	c7 04 24 80 52 00 00 	movl   $0x5280,(%esp,1)
   120de:	e8 fc ff ff ff       	call   120df <msk_release+0x2b>
	if(msk->refCnt == 0) {
   120e3:	8b 45 0c             	mov    0xc(%ebp),%eax
   120e6:	83 b8 f0 00 00 00 00 	cmpl   $0x0,0xf0(%eax)
   120ed:	0f 85 a0 00 00 00    	jne    12193 <msk_release+0xdf>
		// printk("release: refcnt %p\n", msk);
		struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
   120f3:	8b 45 08             	mov    0x8(%ebp),%eax
   120f6:	05 bc 00 00 00       	add    $0xbc,%eax
   120fb:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
		struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
   120fe:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   12101:	05 d4 01 00 00       	add    $0x1d4,%eax
   12106:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

		free_minisock(sk,msk);
   12109:	8b 45 0c             	mov    0xc(%ebp),%eax
   1210c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12110:	8b 45 08             	mov    0x8(%ebp),%eax
   12113:	89 04 24             	mov    %eax,(%esp,1)
   12116:	e8 ed 04 00 00       	call   12608 <free_minisock>
		if(!SIMULATION_MODE(sk)) {
   1211b:	8b 45 08             	mov    0x8(%ebp),%eax
   1211e:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   12124:	83 e0 01             	and    $0x1,%eax
   12127:	85 c0                	test   %eax,%eax
   12129:	74 1b                	je     12146 <msk_release+0x92>
   1212b:	8b 55 08             	mov    0x8(%ebp),%edx
   1212e:	8b 45 08             	mov    0x8(%ebp),%eax
   12131:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   12137:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
   1213d:	83 e0 08             	and    $0x8,%eax
   12140:	85 c0                	test   %eax,%eax
   12142:	75 02                	jne    12146 <msk_release+0x92>
   12144:	eb 1e                	jmp    12164 <msk_release+0xb0>
			insert_head(head, (struct alloc_head *)msk);
   12146:	8b 45 0c             	mov    0xc(%ebp),%eax
   12149:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1214d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   12150:	89 04 24             	mov    %eax,(%esp,1)
   12153:	e8 15 03 00 00       	call   1246d <insert_head>
			msk->ctl = ALLOC_FREE;
   12158:	8b 45 0c             	mov    0xc(%ebp),%eax
   1215b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
   12162:	eb 2f                	jmp    12193 <msk_release+0xdf>
		} else {
			if(msk == tp->t.responseMSK) {
   12164:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   12167:	8b 45 0c             	mov    0xc(%ebp),%eax
   1216a:	3b 82 64 0a 00 00    	cmp    0xa64(%edx),%eax
   12170:	75 02                	jne    12174 <msk_release+0xc0>
   12172:	eb 16                	jmp    1218a <msk_release+0xd6>
			} else {
				// overflow
				unlink((struct alloc_head*)msk);
   12174:	8b 45 0c             	mov    0xc(%ebp),%eax
   12177:	89 04 24             	mov    %eax,(%esp,1)
   1217a:	e8 f4 f3 ff ff       	call   11573 <unlink>
				kfree(msk);
   1217f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12182:	89 04 24             	mov    %eax,(%esp,1)
   12185:	e8 fc ff ff ff       	call   12186 <msk_release+0xd2>
			}
			tp->t.responseCount--;
   1218a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1218d:	ff 88 7c 0a 00 00    	decl   0xa7c(%eax)
		}
	} else {
		//printk("release: refcnt == %d\n", msk->refCnt);
	}
}
   12193:	c9                   	leave  
   12194:	c3                   	ret    

00012195 <byte_diff>:
	ASSERT_OR_RETURN(count == list->len);
	return 1;
}

static inline void byte_diff(const void *_a, const void *_b, int len) {
   12195:	55                   	push   %ebp
   12196:	89 e5                	mov    %esp,%ebp
   12198:	83 ec 24             	sub    $0x24,%esp
	int i;
	int state = 0;
   1219b:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
	int runStart = -1;
   121a2:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,0xfffffff4(%ebp)
	const unsigned char *a = _a, *b = _b;
   121a9:	8b 45 08             	mov    0x8(%ebp),%eax
   121ac:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   121af:	8b 45 0c             	mov    0xc(%ebp),%eax
   121b2:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	for(i=0; i < len; i++) {
   121b5:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   121bc:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   121bf:	3b 45 10             	cmp    0x10(%ebp),%eax
   121c2:	7c 05                	jl     121c9 <byte_diff+0x34>
   121c4:	e9 c9 00 00 00       	jmp    12292 <byte_diff+0xfd>
		if(state == 0) {
   121c9:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
   121cd:	75 2d                	jne    121fc <byte_diff+0x67>
			if(a[i] != b[i]) {
   121cf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   121d2:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
   121d5:	01 c1                	add    %eax,%ecx
   121d7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   121da:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   121dd:	01 c2                	add    %eax,%edx
   121df:	0f b6 01             	movzbl (%ecx),%eax
   121e2:	3a 02                	cmp    (%edx),%al
   121e4:	0f 84 9e 00 00 00    	je     12288 <byte_diff+0xf3>
				runStart = i;
   121ea:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   121ed:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
				state = 1;
   121f0:	c7 45 f8 01 00 00 00 	movl   $0x1,0xfffffff8(%ebp)
   121f7:	e9 8c 00 00 00       	jmp    12288 <byte_diff+0xf3>
			}
		} else if(state == 1) {
   121fc:	83 7d f8 01          	cmpl   $0x1,0xfffffff8(%ebp)
   12200:	0f 85 82 00 00 00    	jne    12288 <byte_diff+0xf3>
			if(a[i] == b[i]) {
   12206:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   12209:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
   1220c:	01 c1                	add    %eax,%ecx
   1220e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   12211:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   12214:	01 c2                	add    %eax,%edx
   12216:	0f b6 01             	movzbl (%ecx),%eax
   12219:	3a 02                	cmp    (%edx),%al
   1221b:	75 6b                	jne    12288 <byte_diff+0xf3>
				printk("[%d-%d]: ", runStart, i - 1);
   1221d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   12220:	48                   	dec    %eax
   12221:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   12225:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   12228:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1222c:	c7 04 24 f3 52 00 00 	movl   $0x52f3,(%esp,1)
   12233:	e8 fc ff ff ff       	call   12234 <byte_diff+0x9f>
				int j;
				for(j=runStart; j < i; j++) {
   12238:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1223b:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1223e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   12241:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
   12244:	7c 02                	jl     12248 <byte_diff+0xb3>
   12246:	eb 2d                	jmp    12275 <byte_diff+0xe0>
					printk("%02X,%02X ", a[j], b[j]);
   12248:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1224b:	03 45 ec             	add    0xffffffec(%ebp),%eax
   1224e:	0f b6 00             	movzbl (%eax),%eax
   12251:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   12255:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   12258:	03 45 f0             	add    0xfffffff0(%ebp),%eax
   1225b:	0f b6 00             	movzbl (%eax),%eax
   1225e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12262:	c7 04 24 fd 52 00 00 	movl   $0x52fd,(%esp,1)
   12269:	e8 fc ff ff ff       	call   1226a <byte_diff+0xd5>
   1226e:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   12271:	ff 00                	incl   (%eax)
   12273:	eb c9                	jmp    1223e <byte_diff+0xa9>
				}
				printk("\n");
   12275:	c7 04 24 2a 46 00 00 	movl   $0x462a,(%esp,1)
   1227c:	e8 fc ff ff ff       	call   1227d <byte_diff+0xe8>
				state = 0;
   12281:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
   12288:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
   1228b:	ff 00                	incl   (%eax)
   1228d:	e9 2a ff ff ff       	jmp    121bc <byte_diff+0x27>
			}
		}
	}
}
   12292:	c9                   	leave  
   12293:	c3                   	ret    

00012294 <pre_init_sock>:
   12294:	55                   	push   %ebp
   12295:	89 e5                	mov    %esp,%ebp
   12297:	8b 45 08             	mov    0x8(%ebp),%eax
   1229a:	8b 40 20             	mov    0x20(%eax),%eax
   1229d:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   122a3:	83 e0 01             	and    $0x1,%eax
   122a6:	85 c0                	test   %eax,%eax
   122a8:	74 21                	je     122cb <pre_init_sock+0x37>
   122aa:	8b 45 08             	mov    0x8(%ebp),%eax
   122ad:	8b 50 20             	mov    0x20(%eax),%edx
   122b0:	8b 45 08             	mov    0x8(%ebp),%eax
   122b3:	8b 40 20             	mov    0x20(%eax),%eax
   122b6:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   122bc:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
   122c2:	83 e0 08             	and    $0x8,%eax
   122c5:	85 c0                	test   %eax,%eax
   122c7:	75 02                	jne    122cb <pre_init_sock+0x37>
   122c9:	eb 3f                	jmp    1230a <pre_init_sock+0x76>
   122cb:	8b 55 08             	mov    0x8(%ebp),%edx
   122ce:	8b 45 0c             	mov    0xc(%ebp),%eax
   122d1:	8b 40 24             	mov    0x24(%eax),%eax
   122d4:	8b 40 10             	mov    0x10(%eax),%eax
   122d7:	89 42 14             	mov    %eax,0x14(%edx)
   122da:	8b 55 08             	mov    0x8(%ebp),%edx
   122dd:	8b 45 0c             	mov    0xc(%ebp),%eax
   122e0:	8b 40 20             	mov    0x20(%eax),%eax
   122e3:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   122e7:	66 89 42 1c          	mov    %ax,0x1c(%edx)
   122eb:	8b 55 08             	mov    0x8(%ebp),%edx
   122ee:	8b 45 0c             	mov    0xc(%ebp),%eax
   122f1:	8b 40 24             	mov    0x24(%eax),%eax
   122f4:	8b 40 0c             	mov    0xc(%eax),%eax
   122f7:	89 42 18             	mov    %eax,0x18(%edx)
   122fa:	8b 55 08             	mov    0x8(%ebp),%edx
   122fd:	8b 45 0c             	mov    0xc(%ebp),%eax
   12300:	8b 40 20             	mov    0x20(%eax),%eax
   12303:	0f b7 00             	movzwl (%eax),%eax
   12306:	66 89 42 1e          	mov    %ax,0x1e(%edx)
   1230a:	5d                   	pop    %ebp
   1230b:	c3                   	ret    

0001230c <doInitialCwnd>:
   1230c:	55                   	push   %ebp
   1230d:	89 e5                	mov    %esp,%ebp
   1230f:	83 ec 38             	sub    $0x38,%esp
   12312:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   12316:	75 3c                	jne    12354 <doInitialCwnd+0x48>
   12318:	8b 45 08             	mov    0x8(%ebp),%eax
   1231b:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
   12322:	8b 45 08             	mov    0x8(%ebp),%eax
   12325:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
   1232c:	8b 45 08             	mov    0x8(%ebp),%eax
   1232f:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
   12336:	8b 45 08             	mov    0x8(%ebp),%eax
   12339:	c7 40 5c 55 10 00 00 	movl   $0x1055,0x5c(%eax)
   12340:	8b 45 08             	mov    0x8(%ebp),%eax
   12343:	c7 40 60 07 b0 00 00 	movl   $0xb007,0x60(%eax)
   1234a:	8b 45 08             	mov    0x8(%ebp),%eax
   1234d:	c7 40 68 ff 3f 00 00 	movl   $0x3fff,0x68(%eax)
   12354:	8b 55 08             	mov    0x8(%ebp),%edx
   12357:	8b 45 10             	mov    0x10(%ebp),%eax
   1235a:	89 42 6c             	mov    %eax,0x6c(%edx)
   1235d:	8b 45 14             	mov    0x14(%ebp),%eax
   12360:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12364:	8b 45 08             	mov    0x8(%ebp),%eax
   12367:	89 04 24             	mov    %eax,(%esp,1)
   1236a:	e8 35 fa ff ff       	call   11da4 <alloc_msk_packets>
   1236f:	85 c0                	test   %eax,%eax
   12371:	75 0c                	jne    1237f <doInitialCwnd+0x73>
   12373:	c7 45 f0 f4 ff ff ff 	movl   $0xfffffff4,0xfffffff0(%ebp)
   1237a:	e9 d0 00 00 00       	jmp    1244f <doInitialCwnd+0x143>
   1237f:	c7 45 f8 01 00 00 00 	movl   $0x1,0xfffffff8(%ebp)
   12386:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   1238d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   12390:	3b 45 14             	cmp    0x14(%ebp),%eax
   12393:	7c 05                	jl     1239a <doInitialCwnd+0x8e>
   12395:	e9 90 00 00 00       	jmp    1242a <doInitialCwnd+0x11e>
   1239a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1239d:	03 45 10             	add    0x10(%ebp),%eax
   123a0:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   123a3:	c7 44 24 20 01 00 00 	movl   $0x1,0x20(%esp,1)
   123aa:	00 
   123ab:	c7 44 24 1c ff ff ff 	movl   $0xffffffff,0x1c(%esp,1)
   123b2:	ff 
   123b3:	0f b7 05 00 00 00 00 	movzwl 0x0,%eax
   123ba:	89 44 24 18          	mov    %eax,0x18(%esp,1)
   123be:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp,1)
   123c5:	00 
   123c6:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
   123ca:	74 09                	je     123d5 <doInitialCwnd+0xc9>
   123cc:	c7 45 ec 80 00 00 00 	movl   $0x80,0xffffffec(%ebp)
   123d3:	eb 07                	jmp    123dc <doInitialCwnd+0xd0>
   123d5:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
   123dc:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   123df:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   123e3:	a1 00 00 00 00       	mov    0x0,%eax
   123e8:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   123ec:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp,1)
   123f3:	00 
   123f4:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   123f7:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   123fb:	8b 4d 08             	mov    0x8(%ebp),%ecx
   123fe:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   12401:	89 d0                	mov    %edx,%eax
   12403:	c1 e0 03             	shl    $0x3,%eax
   12406:	01 d0                	add    %edx,%eax
   12408:	c1 e0 02             	shl    $0x2,%eax
   1240b:	03 81 ec 00 00 00    	add    0xec(%ecx),%eax
   12411:	89 04 24             	mov    %eax,(%esp,1)
   12414:	e8 a0 f1 ff ff       	call   115b9 <makePacket>
   12419:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
   12420:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
   12423:	ff 00                	incl   (%eax)
   12425:	e9 63 ff ff ff       	jmp    1238d <doInitialCwnd+0x81>
   1242a:	8b 55 08             	mov    0x8(%ebp),%edx
   1242d:	8b 45 14             	mov    0x14(%ebp),%eax
   12430:	89 82 e8 00 00 00    	mov    %eax,0xe8(%edx)
   12436:	8b 45 0c             	mov    0xc(%ebp),%eax
   12439:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1243d:	8b 45 08             	mov    0x8(%ebp),%eax
   12440:	89 04 24             	mov    %eax,(%esp,1)
   12443:	e8 fc ff ff ff       	call   12444 <doInitialCwnd+0x138>
   12448:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
   1244f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   12452:	c9                   	leave  
   12453:	c3                   	ret    

00012454 <skb_headlen>:
	return skb->data_len;
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
   12454:	55                   	push   %ebp
   12455:	89 e5                	mov    %esp,%ebp
	return skb->len - skb->data_len;
   12457:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1245a:	8b 45 08             	mov    0x8(%ebp),%eax
   1245d:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
   12463:	8b 81 94 00 00 00    	mov    0x94(%ecx),%eax
   12469:	29 d0                	sub    %edx,%eax
}
   1246b:	5d                   	pop    %ebp
   1246c:	c3                   	ret    

0001246d <insert_head>:
#endif

//#define DEBUG_LIST

static inline void insert_head(struct alloc_head_list *head, struct alloc_head *elem) {
   1246d:	55                   	push   %ebp
   1246e:	89 e5                	mov    %esp,%ebp
   12470:	83 ec 08             	sub    $0x8,%esp
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
#endif
	if(head->next == elem /* || elem->prev != NULL || elem->next != NULL */) {
   12473:	8b 45 08             	mov    0x8(%ebp),%eax
   12476:	8b 40 04             	mov    0x4(%eax),%eax
   12479:	3b 45 0c             	cmp    0xc(%ebp),%eax
   1247c:	75 31                	jne    124af <insert_head+0x42>
		BUG();
   1247e:	c7 44 24 04 19 45 00 	movl   $0x4519,0x4(%esp,1)
   12485:	00 
   12486:	c7 04 24 1d 45 00 00 	movl   $0x451d,(%esp,1)
   1248d:	e8 fc ff ff ff       	call   1248e <insert_head+0x21>
   12492:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   12499:	e8 fc ff ff ff       	call   1249a <insert_head+0x2d>
   1249e:	e8 fc ff ff ff       	call   1249f <insert_head+0x32>
		show_stack(NULL);	
   124a3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   124aa:	e8 fc ff ff ff       	call   124ab <insert_head+0x3e>
	}
	elem->next = head->next;
   124af:	8b 55 0c             	mov    0xc(%ebp),%edx
   124b2:	8b 45 08             	mov    0x8(%ebp),%eax
   124b5:	8b 40 04             	mov    0x4(%eax),%eax
   124b8:	89 42 04             	mov    %eax,0x4(%edx)
	head->next->prev = elem;
   124bb:	8b 45 08             	mov    0x8(%ebp),%eax
   124be:	8b 50 04             	mov    0x4(%eax),%edx
   124c1:	8b 45 0c             	mov    0xc(%ebp),%eax
   124c4:	89 02                	mov    %eax,(%edx)

	elem->prev = (struct alloc_head*)head;
   124c6:	8b 55 0c             	mov    0xc(%ebp),%edx
   124c9:	8b 45 08             	mov    0x8(%ebp),%eax
   124cc:	89 02                	mov    %eax,(%edx)
	head->next = elem;
   124ce:	8b 55 08             	mov    0x8(%ebp),%edx
   124d1:	8b 45 0c             	mov    0xc(%ebp),%eax
   124d4:	89 42 04             	mov    %eax,0x4(%edx)

	elem->list = head;
   124d7:	8b 55 0c             	mov    0xc(%ebp),%edx
   124da:	8b 45 08             	mov    0x8(%ebp),%eax
   124dd:	89 42 08             	mov    %eax,0x8(%edx)
	head->len++;
   124e0:	8b 45 08             	mov    0x8(%ebp),%eax
   124e3:	ff 40 10             	incl   0x10(%eax)
}
   124e6:	c9                   	leave  
   124e7:	c3                   	ret    

000124e8 <insert_tail>:

static inline void insert_tail(struct alloc_head_list *head, struct alloc_head *elem) {
   124e8:	55                   	push   %ebp
   124e9:	89 e5                	mov    %esp,%ebp
   124eb:	83 ec 08             	sub    $0x8,%esp
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
   124ee:	8b 45 08             	mov    0x8(%ebp),%eax
   124f1:	8b 00                	mov    (%eax),%eax
   124f3:	3b 45 0c             	cmp    0xc(%ebp),%eax
   124f6:	75 31                	jne    12529 <insert_tail+0x41>
		BUG();
   124f8:	c7 44 24 04 19 45 00 	movl   $0x4519,0x4(%esp,1)
   124ff:	00 
   12500:	c7 04 24 1d 45 00 00 	movl   $0x451d,(%esp,1)
   12507:	e8 fc ff ff ff       	call   12508 <insert_tail+0x20>
   1250c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   12513:	e8 fc ff ff ff       	call   12514 <insert_tail+0x2c>
   12518:	e8 fc ff ff ff       	call   12519 <insert_tail+0x31>
		show_stack(NULL);
   1251d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   12524:	e8 fc ff ff ff       	call   12525 <insert_tail+0x3d>
	}
#if 1 // 10-01: moved next pointer up to make consistent with mb version
	elem->next = (struct alloc_head*)head;
   12529:	8b 55 0c             	mov    0xc(%ebp),%edx
   1252c:	8b 45 08             	mov    0x8(%ebp),%eax
   1252f:	89 42 04             	mov    %eax,0x4(%edx)
#endif
	elem->prev = head->prev;
   12532:	8b 55 0c             	mov    0xc(%ebp),%edx
   12535:	8b 45 08             	mov    0x8(%ebp),%eax
   12538:	8b 00                	mov    (%eax),%eax
   1253a:	89 02                	mov    %eax,(%edx)

	head->prev->next = elem;
   1253c:	8b 45 08             	mov    0x8(%ebp),%eax
   1253f:	8b 10                	mov    (%eax),%edx
   12541:	8b 45 0c             	mov    0xc(%ebp),%eax
   12544:	89 42 04             	mov    %eax,0x4(%edx)

	elem->list = head;
   12547:	8b 55 0c             	mov    0xc(%ebp),%edx
   1254a:	8b 45 08             	mov    0x8(%ebp),%eax
   1254d:	89 42 08             	mov    %eax,0x8(%edx)
	head->prev = elem;
   12550:	8b 55 08             	mov    0x8(%ebp),%edx
   12553:	8b 45 0c             	mov    0xc(%ebp),%eax
   12556:	89 02                	mov    %eax,(%edx)
	head->len++;
   12558:	8b 45 08             	mov    0x8(%ebp),%eax
   1255b:	ff 40 10             	incl   0x10(%eax)
}
   1255e:	c9                   	leave  
   1255f:	c3                   	ret    

00012560 <tcp_v4_check>:
 */
static __inline__ u16 tcp_v4_check(struct tcphdr *th, int len,
				   unsigned long saddr, unsigned long daddr, 
				   unsigned long base)
{
   12560:	55                   	push   %ebp
   12561:	89 e5                	mov    %esp,%ebp
   12563:	83 ec 14             	sub    $0x14,%esp
	return csum_tcpudp_magic(saddr,daddr,len,IPPROTO_TCP,base);
   12566:	8b 45 18             	mov    0x18(%ebp),%eax
   12569:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   1256d:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp,1)
   12574:	00 
   12575:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
   12579:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1257d:	8b 45 14             	mov    0x14(%ebp),%eax
   12580:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12584:	8b 45 10             	mov    0x10(%ebp),%eax
   12587:	89 04 24             	mov    %eax,(%esp,1)
   1258a:	e8 bf 01 00 00       	call   1274e <csum_tcpudp_magic>
   1258f:	0f b7 c0             	movzwl %ax,%eax
}
   12592:	c9                   	leave  
   12593:	c3                   	ret    

00012594 <init_minisock>:
#ifndef _IN_TRICKLES_H
	#error "File can only be included from trickles.h"
#endif // _IN_TRICKLES_H 

static inline void init_minisock(struct cminisock *msk) {
   12594:	55                   	push   %ebp
   12595:	89 e5                	mov    %esp,%ebp
	msk->num_packets = 0;
   12597:	8b 45 08             	mov    0x8(%ebp),%eax
   1259a:	c7 80 e8 00 00 00 00 	movl   $0x0,0xe8(%eax)
   125a1:	00 00 00 
	msk->ucont_len = 0;
   125a4:	8b 45 08             	mov    0x8(%ebp),%eax
   125a7:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
	msk->ucont_data = NULL;
   125ae:	8b 45 08             	mov    0x8(%ebp),%eax
   125b1:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	msk->input_len = 0;
   125b8:	8b 45 08             	mov    0x8(%ebp),%eax
   125bb:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
   125c2:	00 00 00 
	msk->input = NULL;
   125c5:	8b 45 08             	mov    0x8(%ebp),%eax
   125c8:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
   125cf:	00 00 00 
	msk->packets = NULL;
   125d2:	8b 45 08             	mov    0x8(%ebp),%eax
   125d5:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%eax)
   125dc:	00 00 00 

	msk->refCnt = 1;
   125df:	8b 45 08             	mov    0x8(%ebp),%eax
   125e2:	c7 80 f0 00 00 00 01 	movl   $0x1,0xf0(%eax)
   125e9:	00 00 00 
#define HAS_VALID_CACHERECYCLEINDEX(MSK) ((MSK)->cacheRecycleIndex >= 0)
	msk->cacheRecycleIndex = -1; // invalid index
   125ec:	8b 45 08             	mov    0x8(%ebp),%eax
   125ef:	c7 80 f4 00 00 00 ff 	movl   $0xffffffff,0xf4(%eax)
   125f6:	ff ff ff 
	msk->serverSK = NULL;
   125f9:	8b 45 08             	mov    0x8(%ebp),%eax
   125fc:	c7 80 f8 00 00 00 00 	movl   $0x0,0xf8(%eax)
   12603:	00 00 00 
}
   12606:	5d                   	pop    %ebp
   12607:	c3                   	ret    

00012608 <free_minisock>:

#ifdef CAN_USE_TFREE
static inline void free_minisock(struct sock *sk, struct cminisock *msk) {
   12608:	55                   	push   %ebp
   12609:	89 e5                	mov    %esp,%ebp
   1260b:	83 ec 0c             	sub    $0xc,%esp
	int i;
	/*
	printk("msk summary (%p [%d]) (%p [%d]) (%p [%d])\n", 
	       msk->packets, msk->num_packets,
	       msk->ucont_data, msk->ucont_len,
	       msk->input, msk->input_len);
	*/
	for(i=0; i < msk->num_packets; i++) {
   1260e:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   12615:	8b 55 0c             	mov    0xc(%ebp),%edx
   12618:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1261b:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
   12621:	7c 02                	jl     12625 <free_minisock+0x1d>
   12623:	eb 4e                	jmp    12673 <free_minisock+0x6b>
		if(msk->packets[i].ucontData != NULL) {
   12625:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   12628:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1262b:	89 d0                	mov    %edx,%eax
   1262d:	c1 e0 03             	shl    $0x3,%eax
   12630:	01 d0                	add    %edx,%eax
   12632:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   12639:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   1263f:	83 7c 10 14 00       	cmpl   $0x0,0x14(%eax,%edx,1)
   12644:	74 26                	je     1266c <free_minisock+0x64>
			kfree(msk->packets[i].ucontData);
   12646:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   12649:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1264c:	89 d0                	mov    %edx,%eax
   1264e:	c1 e0 03             	shl    $0x3,%eax
   12651:	01 d0                	add    %edx,%eax
   12653:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1265a:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   12660:	8b 44 10 14          	mov    0x14(%eax,%edx,1),%eax
   12664:	89 04 24             	mov    %eax,(%esp,1)
   12667:	e8 fc ff ff ff       	call   12668 <free_minisock+0x60>
   1266c:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
   1266f:	ff 00                	incl   (%eax)
   12671:	eb a2                	jmp    12615 <free_minisock+0xd>
		}
	}
	// printk("done with packet data\n");
	if(!SIMULATION_MODE(sk) && msk->packets) {
   12673:	8b 45 08             	mov    0x8(%ebp),%eax
   12676:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   1267c:	83 e0 01             	and    $0x1,%eax
   1267f:	85 c0                	test   %eax,%eax
   12681:	74 1b                	je     1269e <free_minisock+0x96>
   12683:	8b 55 08             	mov    0x8(%ebp),%edx
   12686:	8b 45 08             	mov    0x8(%ebp),%eax
   12689:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   1268f:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
   12695:	83 e0 08             	and    $0x8,%eax
   12698:	85 c0                	test   %eax,%eax
   1269a:	75 02                	jne    1269e <free_minisock+0x96>
   1269c:	eb 31                	jmp    126cf <free_minisock+0xc7>
   1269e:	8b 45 0c             	mov    0xc(%ebp),%eax
   126a1:	83 b8 ec 00 00 00 00 	cmpl   $0x0,0xec(%eax)
   126a8:	74 25                	je     126cf <free_minisock+0xc7>
		tfree(sk,msk->packets);
   126aa:	8b 45 0c             	mov    0xc(%ebp),%eax
   126ad:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
   126b3:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   126b7:	8b 45 08             	mov    0x8(%ebp),%eax
   126ba:	89 04 24             	mov    %eax,(%esp,1)
   126bd:	e8 fc ff ff ff       	call   126be <free_minisock+0xb6>
		msk->packets = NULL;
   126c2:	8b 45 0c             	mov    0xc(%ebp),%eax
   126c5:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%eax)
   126cc:	00 00 00 
	}
	// printk("done with packet array\n");
	msk->num_packets = 0;
   126cf:	8b 45 0c             	mov    0xc(%ebp),%eax
   126d2:	c7 80 e8 00 00 00 00 	movl   $0x0,0xe8(%eax)
   126d9:	00 00 00 

	if(msk->ucont_data != NULL) {
   126dc:	8b 45 0c             	mov    0xc(%ebp),%eax
   126df:	83 78 7c 00          	cmpl   $0x0,0x7c(%eax)
   126e3:	74 1f                	je     12704 <free_minisock+0xfc>
		tfree(sk,msk->ucont_data);
   126e5:	8b 45 0c             	mov    0xc(%ebp),%eax
   126e8:	8b 40 7c             	mov    0x7c(%eax),%eax
   126eb:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   126ef:	8b 45 08             	mov    0x8(%ebp),%eax
   126f2:	89 04 24             	mov    %eax,(%esp,1)
   126f5:	e8 fc ff ff ff       	call   126f6 <free_minisock+0xee>
		msk->ucont_data = NULL;
   126fa:	8b 45 0c             	mov    0xc(%ebp),%eax
   126fd:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	}
	// printk("done with ucont data\n");
	msk->ucont_len = 0;
   12704:	8b 45 0c             	mov    0xc(%ebp),%eax
   12707:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
	if(msk->input != NULL) {
   1270e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12711:	83 b8 98 00 00 00 00 	cmpl   $0x0,0x98(%eax)
   12718:	74 25                	je     1273f <free_minisock+0x137>
		tfree(sk,msk->input);
   1271a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1271d:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   12723:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12727:	8b 45 08             	mov    0x8(%ebp),%eax
   1272a:	89 04 24             	mov    %eax,(%esp,1)
   1272d:	e8 fc ff ff ff       	call   1272e <free_minisock+0x126>
		msk->input = NULL;
   12732:	8b 45 0c             	mov    0xc(%ebp),%eax
   12735:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
   1273c:	00 00 00 
	}
	// printk("done with input len\n");
	msk->input_len = 0;
   1273f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12742:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
   12749:	00 00 00 
}
   1274c:	c9                   	leave  
   1274d:	c3                   	ret    

0001274e <csum_tcpudp_magic>:
						   unsigned long daddr,
						   unsigned short len,
						   unsigned short proto,
						   unsigned int sum)
{
   1274e:	55                   	push   %ebp
   1274f:	89 e5                	mov    %esp,%ebp
   12751:	83 ec 18             	sub    $0x18,%esp
   12754:	8b 45 10             	mov    0x10(%ebp),%eax
   12757:	8b 55 14             	mov    0x14(%ebp),%edx
   1275a:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
   1275e:	66 89 55 fc          	mov    %dx,0xfffffffc(%ebp)
	return csum_fold(csum_tcpudp_nofold(saddr,daddr,len,proto,sum));
   12762:	8b 45 18             	mov    0x18(%ebp),%eax
   12765:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   12769:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
   1276d:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   12771:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
   12775:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   12779:	8b 45 0c             	mov    0xc(%ebp),%eax
   1277c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12780:	8b 45 08             	mov    0x8(%ebp),%eax
   12783:	89 04 24             	mov    %eax,(%esp,1)
   12786:	e8 34 00 00 00       	call   127bf <csum_tcpudp_nofold>
   1278b:	89 04 24             	mov    %eax,(%esp,1)
   1278e:	e8 05 00 00 00       	call   12798 <csum_fold>
   12793:	0f b7 c0             	movzwl %ax,%eax
}
   12796:	c9                   	leave  
   12797:	c3                   	ret    

00012798 <csum_fold>:
   12798:	55                   	push   %ebp
   12799:	89 e5                	mov    %esp,%ebp
   1279b:	8b 45 08             	mov    0x8(%ebp),%eax
   1279e:	89 c2                	mov    %eax,%edx
   127a0:	c1 e2 10             	shl    $0x10,%edx
   127a3:	8b 45 08             	mov    0x8(%ebp),%eax
   127a6:	25 00 00 ff ff       	and    $0xffff0000,%eax
   127ab:	01 d0                	add    %edx,%eax
   127ad:	15 ff ff 00 00       	adc    $0xffff,%eax
   127b2:	89 45 08             	mov    %eax,0x8(%ebp)
   127b5:	8b 45 08             	mov    0x8(%ebp),%eax
   127b8:	f7 d0                	not    %eax
   127ba:	c1 e8 10             	shr    $0x10,%eax
   127bd:	5d                   	pop    %ebp
   127be:	c3                   	ret    

000127bf <csum_tcpudp_nofold>:
   127bf:	55                   	push   %ebp
   127c0:	89 e5                	mov    %esp,%ebp
   127c2:	83 ec 08             	sub    $0x8,%esp
   127c5:	8b 45 10             	mov    0x10(%ebp),%eax
   127c8:	8b 55 14             	mov    0x14(%ebp),%edx
   127cb:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
   127cf:	66 89 55 fc          	mov    %dx,0xfffffffc(%ebp)
   127d3:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
   127d7:	89 04 24             	mov    %eax,(%esp,1)
   127da:	e8 fc ff ff ff       	call   127db <csum_tcpudp_nofold+0x1c>
   127df:	0f b7 c0             	movzwl %ax,%eax
   127e2:	89 c2                	mov    %eax,%edx
   127e4:	c1 e2 10             	shl    $0x10,%edx
   127e7:	0f b7 45 fc          	movzwl 0xfffffffc(%ebp),%eax
   127eb:	c1 e0 08             	shl    $0x8,%eax
   127ee:	01 c2                	add    %eax,%edx
   127f0:	8b 45 18             	mov    0x18(%ebp),%eax
   127f3:	03 45 0c             	add    0xc(%ebp),%eax
   127f6:	13 45 08             	adc    0x8(%ebp),%eax
   127f9:	11 d0                	adc    %edx,%eax
   127fb:	83 d0 00             	adc    $0x0,%eax
   127fe:	89 45 18             	mov    %eax,0x18(%ebp)
   12801:	8b 45 18             	mov    0x18(%ebp),%eax
   12804:	c9                   	leave  
   12805:	c3                   	ret    
   12806:	90                   	nop    
   12807:	90                   	nop    

00012808 <record_transfer_skb>:
void record_free_skb_head(struct sk_buff *skb) {
}

static inline 
void record_transfer_skb(struct sk_buff *skb, int newType) {
   12808:	55                   	push   %ebp
   12809:	89 e5                	mov    %esp,%ebp
}
   1280b:	5d                   	pop    %ebp
   1280c:	c3                   	ret    

0001280d <free_trickles_msk>:
/* Two phase free: first phase disconnects socket from event list,
   sets to ALLOC_PROCESSING; second phase adds the socket to free
   list, sets to ALLOC_FREE and ready for reuse */
#ifndef USERTEST
static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk) {
   1280d:	55                   	push   %ebp
   1280e:	89 e5                	mov    %esp,%ebp
   12810:	83 ec 08             	sub    $0x8,%esp
	if(!SIMULATION_MODE(sk)) {
   12813:	8b 45 08             	mov    0x8(%ebp),%eax
   12816:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   1281c:	83 e0 01             	and    $0x1,%eax
   1281f:	85 c0                	test   %eax,%eax
   12821:	74 1b                	je     1283e <free_trickles_msk+0x31>
   12823:	8b 55 08             	mov    0x8(%ebp),%edx
   12826:	8b 45 08             	mov    0x8(%ebp),%eax
   12829:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   1282f:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
   12835:	83 e0 08             	and    $0x8,%eax
   12838:	85 c0                	test   %eax,%eax
   1283a:	75 02                	jne    1283e <free_trickles_msk+0x31>
   1283c:	eb 6b                	jmp    128a9 <free_trickles_msk+0x9c>
		if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) {
   1283e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12841:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
   12845:	74 0b                	je     12852 <free_trickles_msk+0x45>
   12847:	8b 45 0c             	mov    0xc(%ebp),%eax
   1284a:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
   1284e:	74 02                	je     12852 <free_trickles_msk+0x45>
   12850:	eb 31                	jmp    12883 <free_trickles_msk+0x76>
			printk("double free\n");
   12852:	c7 04 24 4c 53 00 00 	movl   $0x534c,(%esp,1)
   12859:	e8 fc ff ff ff       	call   1285a <free_trickles_msk+0x4d>
			BUG();
   1285e:	c7 44 24 04 59 53 00 	movl   $0x5359,0x4(%esp,1)
   12865:	00 
   12866:	c7 04 24 5d 53 00 00 	movl   $0x535d,(%esp,1)
   1286d:	e8 fc ff ff ff       	call   1286e <free_trickles_msk+0x61>
   12872:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   12879:	e8 fc ff ff ff       	call   1287a <free_trickles_msk+0x6d>
   1287e:	e8 fc ff ff ff       	call   1287f <free_trickles_msk+0x72>
		}
		if(msk->ctl == ALLOC_READY && msk->prev != NULL) {
   12883:	8b 45 0c             	mov    0xc(%ebp),%eax
   12886:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
   1288a:	75 13                	jne    1289f <free_trickles_msk+0x92>
   1288c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1288f:	83 38 00             	cmpl   $0x0,(%eax)
   12892:	74 0b                	je     1289f <free_trickles_msk+0x92>
			unlink((struct alloc_head *)msk);
   12894:	8b 45 0c             	mov    0xc(%ebp),%eax
   12897:	89 04 24             	mov    %eax,(%esp,1)
   1289a:	e8 ac 7d 00 00       	call   1a64b <unlink>
		}
		msk->ctl = ALLOC_PROCESSING;
   1289f:	8b 45 0c             	mov    0xc(%ebp),%eax
   128a2:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
	}
}
   128a9:	c9                   	leave  
   128aa:	c3                   	ret    

000128ab <free_trickles_msk_finish>:

static inline void msk_release(struct sock *sk, struct cminisock *msk) {
	// Perform actual deallocation. This function is common to
	// state cache and event queue
	msk->refCnt--;
	BUG_TRAP(msk->refCnt >= 0);
	if(msk->refCnt == 0) {
		// printk("release: refcnt %p\n", msk);
		struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
		struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;

		free_minisock(sk,msk);
		if(!SIMULATION_MODE(sk)) {
			insert_head(head, (struct alloc_head *)msk);
			msk->ctl = ALLOC_FREE;
		} else {
			if(msk == tp->t.responseMSK) {
			} else {
				// overflow
				unlink((struct alloc_head*)msk);
				kfree(msk);
			}
			tp->t.responseCount--;
		}
	} else {
		//printk("release: refcnt == %d\n", msk->refCnt);
	}
}

static inline void free_trickles_msk_finish(struct sock *sk, struct cminisock *msk) {
   128ab:	55                   	push   %ebp
   128ac:	89 e5                	mov    %esp,%ebp
   128ae:	83 ec 08             	sub    $0x8,%esp
	if(!SIMULATION_MODE(sk)) {
   128b1:	8b 45 08             	mov    0x8(%ebp),%eax
   128b4:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   128ba:	83 e0 01             	and    $0x1,%eax
   128bd:	85 c0                	test   %eax,%eax
   128bf:	74 1b                	je     128dc <free_trickles_msk_finish+0x31>
   128c1:	8b 55 08             	mov    0x8(%ebp),%edx
   128c4:	8b 45 08             	mov    0x8(%ebp),%eax
   128c7:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   128cd:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
   128d3:	83 e0 08             	and    $0x8,%eax
   128d6:	85 c0                	test   %eax,%eax
   128d8:	75 02                	jne    128dc <free_trickles_msk_finish+0x31>
   128da:	eb 4d                	jmp    12929 <free_trickles_msk_finish+0x7e>
		if(msk->ctl != ALLOC_PROCESSING && msk->ctl != ALLOC_HALFFREE) {
   128dc:	8b 45 0c             	mov    0xc(%ebp),%eax
   128df:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
   128e3:	74 44                	je     12929 <free_trickles_msk_finish+0x7e>
   128e5:	8b 45 0c             	mov    0xc(%ebp),%eax
   128e8:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
   128ec:	74 3b                	je     12929 <free_trickles_msk_finish+0x7e>
			printk("(free_trickles_msk_finish) without corresponding free_trickles_msk: msk->ctl = %d\n", msk->ctl);
   128ee:	8b 45 0c             	mov    0xc(%ebp),%eax
   128f1:	8b 40 0c             	mov    0xc(%eax),%eax
   128f4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   128f8:	c7 04 24 80 53 00 00 	movl   $0x5380,(%esp,1)
   128ff:	e8 fc ff ff ff       	call   12900 <free_trickles_msk_finish+0x55>
			BUG();
   12904:	c7 44 24 04 59 53 00 	movl   $0x5359,0x4(%esp,1)
   1290b:	00 
   1290c:	c7 04 24 5d 53 00 00 	movl   $0x535d,(%esp,1)
   12913:	e8 fc ff ff ff       	call   12914 <free_trickles_msk_finish+0x69>
   12918:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1291f:	e8 fc ff ff ff       	call   12920 <free_trickles_msk_finish+0x75>
   12924:	e8 fc ff ff ff       	call   12925 <free_trickles_msk_finish+0x7a>
		}
	}
	msk_release(sk,msk);
   12929:	8b 45 0c             	mov    0xc(%ebp),%eax
   1292c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12930:	8b 45 08             	mov    0x8(%ebp),%eax
   12933:	89 04 24             	mov    %eax,(%esp,1)
   12936:	e8 01 83 00 00       	call   1ac3c <msk_release>
}
   1293b:	c9                   	leave  
   1293c:	c3                   	ret    

0001293d <dump_socket_stats>:

static inline int analyze_msk_list_helper(struct sock *sk, int print);

inline
void dump_socket_stats(struct sock *sk) {
   1293d:	55                   	push   %ebp
   1293e:	89 e5                	mov    %esp,%ebp
   12940:	83 ec 18             	sub    $0x18,%esp
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
   12943:	8b 45 08             	mov    0x8(%ebp),%eax
   12946:	05 bc 00 00 00       	add    $0xbc,%eax
   1294b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	printk("   tp->rcv_nxt = %d\n", tp->rcv_nxt);
   1294e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   12951:	8b 40 08             	mov    0x8(%eax),%eax
   12954:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12958:	c7 04 24 d3 53 00 00 	movl   $0x53d3,(%esp,1)
   1295f:	e8 fc ff ff ff       	call   12960 <dump_socket_stats+0x23>
	printk("   Recv queue len = %d\n", sk->receive_queue.qlen);
   12964:	8b 45 08             	mov    0x8(%ebp),%eax
   12967:	8b 40 50             	mov    0x50(%eax),%eax
   1296a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1296e:	c7 04 24 e8 53 00 00 	movl   $0x53e8,(%esp,1)
   12975:	e8 fc ff ff ff       	call   12976 <dump_socket_stats+0x39>
	printk("   Trickles state = %d\n", tp->t.state);
   1297a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1297d:	8b 80 cc 02 00 00    	mov    0x2cc(%eax),%eax
   12983:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12987:	c7 04 24 00 54 00 00 	movl   $0x5400,(%esp,1)
   1298e:	e8 fc ff ff ff       	call   1298f <dump_socket_stats+0x52>
	DUMP_RTO(sk);
   12993:	8b 45 08             	mov    0x8(%ebp),%eax
   12996:	05 bc 00 00 00       	add    $0xbc,%eax
   1299b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   1299e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   129a1:	8b 80 d8 02 00 00    	mov    0x2d8(%eax),%eax
   129a7:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   129ab:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   129ae:	8b 80 d4 02 00 00    	mov    0x2d4(%eax),%eax
   129b4:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   129b8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   129bb:	8b 80 d0 02 00 00    	mov    0x2d0(%eax),%eax
   129c1:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   129c5:	c7 04 24 18 54 00 00 	movl   $0x5418,(%esp,1)
   129cc:	e8 fc ff ff ff       	call   129cd <dump_socket_stats+0x90>
	printk("   Ofo_queue len = %d\n", tp->t.ofo_queue.qlen);
   129d1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   129d4:	8b 80 f0 02 00 00    	mov    0x2f0(%eax),%eax
   129da:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   129de:	c7 04 24 31 54 00 00 	movl   $0x5431,(%esp,1)
   129e5:	e8 fc ff ff ff       	call   129e6 <dump_socket_stats+0xa9>
	printk("   data_ofo_queue len = %d\n", tp->t.data_ofo_queue.qlen);
   129ea:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   129ed:	8b 80 80 09 00 00    	mov    0x980(%eax),%eax
   129f3:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   129f7:	c7 04 24 48 54 00 00 	movl   $0x5448,(%esp,1)
   129fe:	e8 fc ff ff ff       	call   129ff <dump_socket_stats+0xc2>
	printk("   request_ofo_queue len = %d\n", tp->t.request_ofo_queue.len);
   12a03:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   12a06:	8b 80 74 09 00 00    	mov    0x974(%eax),%eax
   12a0c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12a10:	c7 04 24 80 54 00 00 	movl   $0x5480,(%esp,1)
   12a17:	e8 fc ff ff ff       	call   12a18 <dump_socket_stats+0xdb>
}
   12a1c:	c9                   	leave  
   12a1d:	c3                   	ret    

00012a1e <skb_add_data>:

static inline
void dump_datachunks(char *ptr, int len) {
	int chunknum = 0;
	struct DataChunk *chunk = (struct DataChunk *)ptr;
	printk("Total dump len = %d ", len);
	while((char*)(chunk+1) - ptr < len && chunknum < 5) {
		printk("Chunk %d(%d) - %d @ %d\n", chunknum,
#ifdef CHUNK_ID
		       chunk->chunkID,
#else
		       -1,
#endif
		       DATA_LEN(chunk),
		       (char*)chunk->data - ptr);
		chunk = NEXT_CHUNK_ADDR(chunk);
		chunknum++;
	}
}

/* begin functions copied from tcp.c */

static inline void
fill_page_desc(struct sk_buff *skb, int i, struct page *page, int off, int size)
{
	skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
	frag->page = page;
	frag->page_offset = off;
	frag->size = size;
	skb_shinfo(skb)->nr_frags = i+1;
}

extern int total_csum_bytes;

static ALWAYS_INLINE int
skb_add_data(struct sk_buff *skb, char *from, int copy)
{
   12a1e:	55                   	push   %ebp
   12a1f:	89 e5                	mov    %esp,%ebp
   12a21:	53                   	push   %ebx
   12a22:	83 ec 28             	sub    $0x28,%esp
	int err = 0;
   12a25:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
	unsigned int csum;
	int off = skb->len;
   12a2c:	8b 45 08             	mov    0x8(%ebp),%eax
   12a2f:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   12a35:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	char *dest = skb_put(skb, copy);
   12a38:	8b 45 10             	mov    0x10(%ebp),%eax
   12a3b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12a3f:	8b 45 08             	mov    0x8(%ebp),%eax
   12a42:	89 04 24             	mov    %eax,(%esp,1)
   12a45:	e8 4b 76 00 00       	call   1a095 <skb_put>
   12a4a:	89 45 ec             	mov    %eax,0xffffffec(%ebp)

	total_csum_bytes += copy;
   12a4d:	8b 45 10             	mov    0x10(%ebp),%eax
   12a50:	01 05 00 00 00 00    	add    %eax,0x0
	csum = csum_and_copy_from_user(from, dest, copy, 0, &err);
   12a56:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
   12a59:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   12a5d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp,1)
   12a64:	00 
   12a65:	8b 45 10             	mov    0x10(%ebp),%eax
   12a68:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   12a6c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   12a6f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12a73:	8b 45 0c             	mov    0xc(%ebp),%eax
   12a76:	89 04 24             	mov    %eax,(%esp,1)
   12a79:	e8 0d 7e 00 00       	call   1a88b <csum_and_copy_from_user>
   12a7e:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	if (!err) {
   12a81:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
   12a85:	75 31                	jne    12ab8 <skb_add_data+0x9a>
		skb->csum = csum_block_add(skb->csum, csum, off);
   12a87:	8b 5d 08             	mov    0x8(%ebp),%ebx
   12a8a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   12a8d:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   12a91:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   12a94:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12a98:	8b 45 08             	mov    0x8(%ebp),%eax
   12a9b:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
   12aa1:	89 04 24             	mov    %eax,(%esp,1)
   12aa4:	e8 4c 7e 00 00       	call   1a8f5 <csum_block_add>
   12aa9:	89 83 9c 00 00 00    	mov    %eax,0x9c(%ebx)
#ifdef GREP_FOR_RANGEHEADER
		//printk("Grepping for range header (e.g., non-zero bytes)\n");
		int i;
#if 0
		for(i=0; i < copy; i++) {
			if(dest[i] != 0) {
				printk("Non zero byte at %d\n",
				       dest - (char*)skb->head);
				break;
			}
		}
#endif
		int count;
		if((count = validateDataChunks(dest, copy)) < 0) {
			printk("Data chunk validation failed at %d, count = %d\n",
			       dest - (char*)skb->head, count);
			return -EFAULT;
		}
#endif
		return 0;
   12aaf:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
   12ab6:	eb 19                	jmp    12ad1 <skb_add_data+0xb3>
	}

	__skb_trim(skb, off);
   12ab8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   12abb:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12abf:	8b 45 08             	mov    0x8(%ebp),%eax
   12ac2:	89 04 24             	mov    %eax,(%esp,1)
   12ac5:	e8 8a 76 00 00       	call   1a154 <__skb_trim>
	return -EFAULT;
   12aca:	c7 45 e8 f2 ff ff ff 	movl   $0xfffffff2,0xffffffe8(%ebp)
}
   12ad1:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   12ad4:	83 c4 28             	add    $0x28,%esp
   12ad7:	5b                   	pop    %ebx
   12ad8:	5d                   	pop    %ebp
   12ad9:	c3                   	ret    

00012ada <virt_to_kseg>:

/* end functions copied from tcp.c */

static inline void init_sock(struct cminisock *msk, struct sock *sk) {
	msk->sk = sk;
	msk->sk->dst_cache = NULL;
	msk->sk->protinfo.af_inet.opt = NULL;
	msk->sk->protinfo.af_inet.ttl = 255;
	msk->sk->protocol = IPPROTO_TCP;
	msk->sk->protinfo.af_inet.tos = 0;
	msk->sk->tp_pinfo.af_tcp.trickles_opt = 0;
	msk->sk->localroute = 0;
        if (ipv4_config.no_pmtu_disc)
                msk->sk->protinfo.af_inet.pmtudisc = IP_PMTUDISC_DONT;
        else
                msk->sk->protinfo.af_inet.pmtudisc = IP_PMTUDISC_WANT;
	/* following hack won't work correctly for complex socket binding config on the master socket */
	msk->sk->bound_dev_if = 0;

	msk->sk->saddr = msk->saddr;
	msk->sk->sport = msk->source;
	msk->sk->daddr = msk->daddr;
	msk->sk->dport = msk->dest;
}


static int upcall_seqnum = 0;

static volatile void *virt_to_kseg(volatile void *address)
{
   12ada:	55                   	push   %ebp
   12adb:	89 e5                	mov    %esp,%ebp
   12add:	53                   	push   %ebx
   12ade:	83 ec 20             	sub    $0x20,%esp
        pgd_t *pgd; pmd_t *pmd; pte_t *ptep, pte;
	unsigned long va, ret = 0UL;
   12ae1:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)

	va=VMALLOC_VMADDR((unsigned long)address);
   12ae8:	8b 45 08             	mov    0x8(%ebp),%eax
   12aeb:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)

	/* get the page directory. Use the kernel memory map. */
	pgd = pgd_offset_k(va);
   12aee:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   12af1:	c1 e8 16             	shr    $0x16,%eax
   12af4:	25 ff 03 00 00       	and    $0x3ff,%eax
   12af9:	c1 e0 02             	shl    $0x2,%eax
   12afc:	03 05 0c 00 00 00    	add    0xc,%eax
   12b02:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

	/* check whether we found an entry */
	if (!pgd_none(*pgd))
   12b05:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   12b08:	8b 00                	mov    (%eax),%eax
   12b0a:	89 04 24             	mov    %eax,(%esp,1)
   12b0d:	e8 54 74 00 00       	call   19f66 <pgd_none>
   12b12:	85 c0                	test   %eax,%eax
   12b14:	0f 85 f6 00 00 00    	jne    12c10 <virt_to_kseg+0x136>
        {
	      /* get the page middle directory */
	      pmd = pmd_offset(pgd, va);
   12b1a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   12b1d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12b21:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   12b24:	89 04 24             	mov    %eax,(%esp,1)
   12b27:	e8 44 74 00 00       	call   19f70 <pmd_offset>
   12b2c:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	      /* check whether we found an entry */
	      if (!pmd_none(*pmd))
   12b2f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   12b32:	83 38 00             	cmpl   $0x0,(%eax)
   12b35:	0f 84 d5 00 00 00    	je     12c10 <virt_to_kseg+0x136>
              {
		  /* get a pointer to the page table entry */
	          ptep = pte_offset(pmd, va);
   12b3b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   12b3e:	8b 10                	mov    (%eax),%edx
   12b40:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
   12b46:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   12b49:	c1 e8 0c             	shr    $0xc,%eax
   12b4c:	25 ff 03 00 00       	and    $0x3ff,%eax
   12b51:	c1 e0 02             	shl    $0x2,%eax
   12b54:	8d 04 10             	lea    (%eax,%edx,1),%eax
   12b57:	2d 00 00 00 40       	sub    $0x40000000,%eax
   12b5c:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	          pte = *ptep;
   12b5f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   12b62:	8b 00                	mov    (%eax),%eax
   12b64:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
		  /* check for a valid page */
	          if (pte_present(pte))
   12b67:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
   12b6b:	24 81                	and    $0x81,%al
   12b6d:	84 c0                	test   %al,%al
   12b6f:	0f 84 9b 00 00 00    	je     12c10 <virt_to_kseg+0x136>
                  {
		        /* get the address the page is refering to */
		        ret = (unsigned long)page_address(pte_page(pte));
   12b75:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   12b78:	89 c2                	mov    %eax,%edx
   12b7a:	c1 ea 0c             	shr    $0xc,%edx
   12b7d:	89 d0                	mov    %edx,%eax
   12b7f:	c1 e0 02             	shl    $0x2,%eax
   12b82:	01 d0                	add    %edx,%eax
   12b84:	01 c0                	add    %eax,%eax
   12b86:	01 d0                	add    %edx,%eax
   12b88:	c1 e0 02             	shl    $0x2,%eax
   12b8b:	89 c3                	mov    %eax,%ebx
   12b8d:	03 1d 00 00 00 00    	add    0x0,%ebx
   12b93:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   12b96:	89 c2                	mov    %eax,%edx
   12b98:	c1 ea 0c             	shr    $0xc,%edx
   12b9b:	89 d0                	mov    %edx,%eax
   12b9d:	c1 e0 02             	shl    $0x2,%eax
   12ba0:	01 d0                	add    %edx,%eax
   12ba2:	01 c0                	add    %eax,%eax
   12ba4:	01 d0                	add    %edx,%eax
   12ba6:	c1 e0 02             	shl    $0x2,%eax
   12ba9:	03 05 00 00 00 00    	add    0x0,%eax
   12baf:	89 04 24             	mov    %eax,(%esp,1)
   12bb2:	e8 c1 73 00 00       	call   19f78 <page_zone>
   12bb7:	2b 98 c0 00 00 00    	sub    0xc0(%eax),%ebx
   12bbd:	89 d8                	mov    %ebx,%eax
   12bbf:	c1 f8 02             	sar    $0x2,%eax
   12bc2:	69 c0 a3 8b 2e ba    	imul   $0xba2e8ba3,%eax,%eax
   12bc8:	89 c3                	mov    %eax,%ebx
   12bca:	c1 e3 0c             	shl    $0xc,%ebx
   12bcd:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   12bd0:	89 c2                	mov    %eax,%edx
   12bd2:	c1 ea 0c             	shr    $0xc,%edx
   12bd5:	89 d0                	mov    %edx,%eax
   12bd7:	c1 e0 02             	shl    $0x2,%eax
   12bda:	01 d0                	add    %edx,%eax
   12bdc:	01 c0                	add    %eax,%eax
   12bde:	01 d0                	add    %edx,%eax
   12be0:	c1 e0 02             	shl    $0x2,%eax
   12be3:	03 05 00 00 00 00    	add    0x0,%eax
   12be9:	89 04 24             	mov    %eax,(%esp,1)
   12bec:	e8 87 73 00 00       	call   19f78 <page_zone>
   12bf1:	8b 90 c4 00 00 00    	mov    0xc4(%eax),%edx
   12bf7:	8d 04 1a             	lea    (%edx,%ebx,1),%eax
   12bfa:	2d 00 00 00 40       	sub    $0x40000000,%eax
   12bff:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
			/* add the offset within the page to the page address */
			ret |= (va & (PAGE_SIZE -1));
   12c02:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   12c05:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
   12c0b:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   12c0e:	09 10                	or     %edx,(%eax)
		  }
	      }
	}
	return((volatile void *)ret);
   12c10:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
}
   12c13:	83 c4 20             	add    $0x20,%esp
   12c16:	5b                   	pop    %ebx
   12c17:	5d                   	pop    %ebp
   12c18:	c3                   	ret    

00012c19 <queue_upcall_prealloc>:

inline void queue_upcall_prealloc(struct sock *sk, enum cminisock_event_tag tag, struct cminisock *msk) {
   12c19:	55                   	push   %ebp
   12c1a:	89 e5                	mov    %esp,%ebp
   12c1c:	83 ec 0c             	sub    $0xc,%esp
	//BREAKOUT();
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
   12c1f:	8b 45 08             	mov    0x8(%ebp),%eax
   12c22:	05 bc 00 00 00       	add    $0xbc,%eax
   12c27:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	switch(tag) {
   12c2a:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c2d:	83 f8 03             	cmp    $0x3,%eax
   12c30:	77 1d                	ja     12c4f <queue_upcall_prealloc+0x36>
	case SYN:
	case RST:
	case FIN:
	case ACK:
		/* enqueue at the end */
		insert_tail_mb(&tp->cminisock_api_config.cfg.ctl->msk_eventlist, (struct alloc_head *)msk);
   12c32:	8b 45 10             	mov    0x10(%ebp),%eax
   12c35:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12c39:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   12c3c:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
   12c42:	83 c0 28             	add    $0x28,%eax
   12c45:	89 04 24             	mov    %eax,(%esp,1)
   12c48:	e8 80 79 00 00       	call   1a5cd <insert_tail_mb>
		break;
   12c4d:	eb 0c                	jmp    12c5b <queue_upcall_prealloc+0x42>
	default:
		printk("Unsupported tag for preallocation\n");
   12c4f:	c7 04 24 a0 54 00 00 	movl   $0x54a0,(%esp,1)
   12c56:	e8 fc ff ff ff       	call   12c57 <queue_upcall_prealloc+0x3e>
	}
}
   12c5b:	c9                   	leave  
   12c5c:	c3                   	ret    

00012c5d <queue_upcall>:

inline void queue_upcall(enum cminisock_event_tag tag, struct cminisock *msk) {
   12c5d:	55                   	push   %ebp
   12c5e:	89 e5                	mov    %esp,%ebp
   12c60:	56                   	push   %esi
   12c61:	53                   	push   %ebx
   12c62:	83 ec 14             	sub    $0x14,%esp
	//DO_SANITY_CHECK_MSK(msk);
	//printk("Queuing %p : input_len %d\n", msk, msk->input_len);
	msk->tag = tag;
   12c65:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c68:	8b 55 08             	mov    0x8(%ebp),%edx
   12c6b:	89 50 10             	mov    %edx,0x10(%eax)
	switch(tag) {
   12c6e:	8b 45 08             	mov    0x8(%ebp),%eax
   12c71:	83 f8 03             	cmp    $0x3,%eax
   12c74:	0f 87 c4 00 00 00    	ja     12d3e <queue_upcall+0xe1>
	case SYN:
	case RST:
	case FIN:
	case ACK:
		msk->ctl = ALLOC_READY;
   12c7a:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c7d:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
		{
			msk->seqnum = upcall_seqnum++;
   12c84:	8b 55 0c             	mov    0xc(%ebp),%edx
   12c87:	a1 fc 00 00 00       	mov    0xfc,%eax
   12c8c:	89 82 d4 00 00 00    	mov    %eax,0xd4(%edx)
   12c92:	ff 05 fc 00 00 00    	incl   0xfc
		}
		if(userapi_pkt_spew) {
   12c98:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
   12c9f:	0f 84 a5 00 00 00    	je     12d4a <queue_upcall+0xed>
			int i;
			for(i=0; i < msk->num_packets; i++) {
   12ca5:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
   12cac:	8b 55 0c             	mov    0xc(%ebp),%edx
   12caf:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   12cb2:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
   12cb8:	7c 05                	jl     12cbf <queue_upcall+0x62>
   12cba:	e9 8b 00 00 00       	jmp    12d4a <queue_upcall+0xed>
				printk("upcall pkts[%d]: %u-%u\n", i, msk->packets[i].seq, msk->packets[i].seq + msk->packets[i].len);
   12cbf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   12cc2:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   12cc5:	89 d0                	mov    %edx,%eax
   12cc7:	c1 e0 03             	shl    $0x3,%eax
   12cca:	01 d0                	add    %edx,%eax
   12ccc:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
   12cd3:	8b b1 ec 00 00 00    	mov    0xec(%ecx),%esi
   12cd9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   12cdc:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   12cdf:	89 d0                	mov    %edx,%eax
   12ce1:	c1 e0 03             	shl    $0x3,%eax
   12ce4:	01 d0                	add    %edx,%eax
   12ce6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   12ced:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   12cf3:	8b 44 10 08          	mov    0x8(%eax,%edx,1),%eax
   12cf7:	03 44 1e 04          	add    0x4(%esi,%ebx,1),%eax
   12cfb:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   12cff:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   12d02:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   12d05:	89 d0                	mov    %edx,%eax
   12d07:	c1 e0 03             	shl    $0x3,%eax
   12d0a:	01 d0                	add    %edx,%eax
   12d0c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   12d13:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   12d19:	8b 44 10 04          	mov    0x4(%eax,%edx,1),%eax
   12d1d:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   12d21:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   12d24:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12d28:	c7 04 24 c3 54 00 00 	movl   $0x54c3,(%esp,1)
   12d2f:	e8 fc ff ff ff       	call   12d30 <queue_upcall+0xd3>
   12d34:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   12d37:	ff 00                	incl   (%eax)
   12d39:	e9 6e ff ff ff       	jmp    12cac <queue_upcall+0x4f>
			}
		}

		break;
	default:
		printk("queue_upcall: invalid tag\n");
   12d3e:	c7 04 24 db 54 00 00 	movl   $0x54db,(%esp,1)
   12d45:	e8 fc ff ff ff       	call   12d46 <queue_upcall+0xe9>
	}
}
   12d4a:	83 c4 14             	add    $0x14,%esp
   12d4d:	5b                   	pop    %ebx
   12d4e:	5e                   	pop    %esi
   12d4f:	5d                   	pop    %ebp
   12d50:	c3                   	ret    

00012d51 <queue_upcall_deliver>:

static inline
void new_event(struct sock *sk) {
	wake_up_interruptible(sk->sleep);
	if (!sk->dead) {
		/* clear select and other blocking operations */
		sk->data_ready(sk, 0);
	}
	atomic_inc(&sk->tp_pinfo.af_tcp.cminisock_api_config.cfg.ctl->update_since_poll);
 }

inline void queue_upcall_deliver(struct sock *sk, struct cminisock *msk) {
   12d51:	55                   	push   %ebp
   12d52:	89 e5                	mov    %esp,%ebp
   12d54:	83 ec 04             	sub    $0x4,%esp
	//DO_SANITY_CHECK_MSK(msk);
	new_event(sk);
   12d57:	8b 45 08             	mov    0x8(%ebp),%eax
   12d5a:	89 04 24             	mov    %eax,(%esp,1)
   12d5d:	e8 56 80 00 00       	call   1adb8 <new_event>
}
   12d62:	c9                   	leave  
   12d63:	c3                   	ret    

00012d64 <tcp_prequeue_process>:

static void tcp_prequeue_process(struct sock *sk)
{
   12d64:	55                   	push   %ebp
   12d65:	89 e5                	mov    %esp,%ebp
   12d67:	83 ec 14             	sub    $0x14,%esp
	struct sk_buff *skb;
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
   12d6a:	8b 45 08             	mov    0x8(%ebp),%eax
   12d6d:	05 bc 00 00 00       	add    $0xbc,%eax
   12d72:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

	net_statistics[smp_processor_id()*2+1].TCPPrequeued += skb_queue_len(&tp->ucopy.prequeue);
   12d75:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   12d78:	83 c0 34             	add    $0x34,%eax
   12d7b:	89 04 24             	mov    %eax,(%esp,1)
   12d7e:	e8 55 72 00 00       	call   19fd8 <skb_queue_len>
   12d83:	01 05 74 01 00 00    	add    %eax,0x174

	/* RX process wants to run with disabled BHs, though it is not necessary */
	local_bh_disable();
   12d89:	ff 05 08 00 00 00    	incl   0x8
   12d8f:	90                   	nop    
	while ((skb = __skb_dequeue(&tp->ucopy.prequeue)) != NULL)
   12d90:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   12d93:	83 c0 34             	add    $0x34,%eax
   12d96:	89 04 24             	mov    %eax,(%esp,1)
   12d99:	e8 8d 72 00 00       	call   1a02b <__skb_dequeue>
   12d9e:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   12da1:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
   12da5:	75 02                	jne    12da9 <tcp_prequeue_process+0x45>
   12da7:	eb 1a                	jmp    12dc3 <tcp_prequeue_process+0x5f>
		sk->backlog_rcv(sk, skb);
   12da9:	8b 55 08             	mov    0x8(%ebp),%edx
   12dac:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   12daf:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12db3:	8b 45 08             	mov    0x8(%ebp),%eax
   12db6:	89 04 24             	mov    %eax,(%esp,1)
   12db9:	8b 82 e0 0b 00 00    	mov    0xbe0(%edx),%eax
   12dbf:	ff d0                	call   *%eax
   12dc1:	eb cd                	jmp    12d90 <tcp_prequeue_process+0x2c>
	local_bh_enable();
   12dc3:	c7 45 f4 08 00 00 00 	movl   $0x8,0xfffffff4(%ebp)
   12dca:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   12dcd:	ff 08                	decl   (%eax)
   12dcf:	83 38 00             	cmpl   $0x0,(%eax)
   12dd2:	75 0d                	jne    12de1 <tcp_prequeue_process+0x7d>
   12dd4:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   12dd7:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   12ddb:	0f 85 8f 91 00 00    	jne    1bf70 <.text.lock.tmalloc>

	/* Clear memory counter. */
	tp->ucopy.memory = 0;
   12de1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   12de4:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
}
   12deb:	c9                   	leave  
   12dec:	c3                   	ret    

00012ded <finishTransmitHelper>:

static int trickles_poll(struct sock *sk);

/* precondition: msk already 1/2 freed, and address verified */
#define SENDMSG_INSTANCE(SUFF, HANDLER)					\
static inline int trickles_do_sendmsg_ ## SUFF				\
		(struct sock *sk, struct cminisock *msk, void *vec, int veclen) { \
								\
	int rval = 0;						\
	struct sock dummysk;						\
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp),			\
	  *dummy_tp = &(dummysk.tp_pinfo.af_tcp);			\
	struct sk_buff *skb;						\
									\
	/* dummysk = kmalloc(sizeof(struct sock), GFP_KERNEL); */	\
	dummy_tp->trickles_opt = tp->trickles_opt;			\
	dummy_tp->t.hmacCTX = tp->t.hmacCTX;				\
	dummy_tp->t.nonceCTX = tp->t.nonceCTX;				\
									\
	init_sock(msk, &dummysk);					\
	msk->serverSK = sk;						\
									\
	{								\
		static int last;					\
		if(msk->seqnum != last+1) {				\
			/* printk("missing downcall: out of sequence\n"); */ \
		}							\
		last = msk->seqnum;					\
	}								\
									\
	if(msk->tag == SYN || msk->tag == ACK || msk->tag == FIN) { \
		HANDLER(sk,msk,vec,veclen);				\
	} else {							\
		struct tcp_skb_cb *tcb;					\
		skb = recycle(sk);					\
		if(skb == NULL) {					\
			skb = alloc_skb(TRICKLES_TX_SKB_LEN, GFP_KERNEL); \
		}							\
		if(skb == NULL) {					\
			printk("could not allocate skb\n");		\
			goto out;					\
		}							\
		tcb = TCP_SKB_CB(skb);					\
		skb->csum = 0;						\
		skb->ip_summed = CHECKSUM_HW;				\
		skb_reserve(skb, MAX_TCP_HEADER + MAX_TRICKLES_SERVER_HDR_LEN + TRICKLES_MSS); \
									\
		switch(msk->tag) {					\
		case SYN:						\
			BUG(); break;					\
		case RST:						\
			/* todo: find out what the proper semantics in response to rst are */ \
			kfree_skb(skb);					\
			goto out;					\
		default:						\
			kfree_skb(skb);					\
			BUG_TRAP(0);					\
			goto out;					\
		}							\
		int i;							\
		for(i=0; i < msk->num_packets; i++) {			\
			struct sk_buff *skb1 = skb_clone(skb, GFP_ATOMIC); \
			skb1->csum = 0;					\
			skb1->ip_summed = CHECKSUM_HW;			\
			msk_transmit_skb(msk, skb1, i);			\
			msk->tag = ACK;					\
			/* printk("SYN %d\n", i); */			\
		}							\
		kfree_skb(skb);						\
	}								\
 out:									\
	if(sysctl_trickles_Continuation_enable && HAS_VALID_CACHERECYCLEINDEX(msk)) {				\
		/* must cache before deallocating, since we still need the packet field */ \
		msk_hold(msk);						\
		free_trickles_msk_finish(sk,msk);			\
		cminisock_cache_child(msk, msk->cacheRecycleIndex, 0);	\
		msk_free_fields(sk, msk);				\
	} else {							\
		free_trickles_msk_finish(sk,msk);			\
									\
	}								\
	return rval;							\
}

static inline int tiov_handler(struct sock *origSK, struct cminisock *msk, struct tiovec *tiov, int tiovlen);
SENDMSG_INSTANCE(tiov,tiov_handler);
static inline int fiov_handler(struct sock *origSK, struct cminisock *msk, struct fiovec *fiov, int fiovlen);
SENDMSG_INSTANCE(fiov,fiov_handler);

#ifdef SETUCONT_COMMAND
static inline
int containsUContDesc(struct cminisock_packet *cpkt) {
	return cpkt->ucontLen < 0;
}

static inline
void extractUContDesc(struct cminisock_packet *cpkt, int *ucontLen, char **user_src) {
	*ucontLen = cpkt->ucontLen = -cpkt->ucontLen;
	*user_src = cpkt->ucontData;
	cpkt->ucontData = NULL;
}

static inline
void insertUContDesc(struct cminisock_packet *cpkt, int ucontLen, char *user_src) {
	BUG_TRAP(cpkt->ucontLen == 0);
	cpkt->ucontLen = -ucontLen;
	cpkt->ucontData = user_src;
}

static inline
int setupUCont(struct cminisock *msk, struct ucontdesc *udesc, int udesclen,
		int udescstride) {
	int i;
	struct cminisock_packet *pkts = msk->packets;
	int packetNum = 0;

	for(i=0; i < udesclen; i++) {
		struct ucontdesc *curr_tiov =
			(struct ucontdesc *) ((char*)udesc + udescstride * i);
		int ucontLen = curr_tiov->ucont_len;
		if(ucontLen > 0) {
			if(packetNum >= msk->num_packets) {
				printk("Too many uconts specified in list\n");
				return 0;
			}
			if(pkts[packetNum].ucontLen > 0) {
				printk("UContLen > 0!!!, ptr = %p\n", pkts[packetNum].ucontData);
				return -1;
			}
			insertUContDesc(&pkts[packetNum], ucontLen, curr_tiov->ucont_base);
			packetNum++;
		}
	}
	return 0;
}

static inline
int copyUCont(struct sk_buff *skb, struct cminisock_packet *cpkt) {
	if(containsUContDesc(cpkt) < 0) {
		int error = 0;
		int ucontLen;
		char *user_src;
		extractUContDesc(cpkt, &ucontLen, &user_src);
		skb->csum =
			csum_and_copy_from_user(user_src, skb_push(skb, ucontLen),
						ucontLen, skb->csum, &error);
		if(error) {
			printk("csum error on ucont\n");
			return error;
		}
	}
	return 0;
}
#else

#define containsUContDesc(X) (0)

#define extractUContDesc(X,Y,Z) do { BUG_TRAP(0); } while(0)

#define insertUContDesc(X,Y,Z) do { BUG_TRAP(0); } while(0)

#define setupUCont(A,B,C,D) (0)

#define copyUCont(X,Y) (0)

#endif // SETUCONT_COMMAND

static inline
void free_remaining(struct sk_buff **skbs, int offset, int total) {
	for(; offset < total; offset++) {
		kfree_skb(skbs[offset]);
	}
}

#ifdef SETUCONT_COMMAND
#define FINISH_TRANSMIT(MSK,SKBS,NUM_DATA_PACKETS,UDESC,UDESCLEN,UDESCSTRIDE) \
	finishTransmitHelper(MSK,SKBS,NUM_DATA_PACKETS,UDESC,UDESCLEN,UDESCSTRIDE)
#else
#define FINISH_TRANSMIT(MSK,SKBS,NUM_DATA_PACKETS,UDESC,UDESCLEN,UDESCSTRIDE) \
	finishTransmitHelper(MSK,SKBS,NUM_DATA_PACKETS,NULL,0,0)
#endif

static
void finishTransmitHelper(struct cminisock *msk, struct sk_buff *skbs[],
		    int numDataPackets, struct ucontdesc *udesc,
		    int udesclen, int udescstride) {
   12ded:	55                   	push   %ebp
   12dee:	89 e5                	mov    %esp,%ebp
   12df0:	83 ec 28             	sub    $0x28,%esp
#define REALCHILD(PKT) ((PKT).ucontLen != 0)
	struct cminisock_packet *pkts = msk->packets;
   12df3:	8b 45 08             	mov    0x8(%ebp),%eax
   12df6:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
   12dfc:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	int numUCChildPackets = numDataPackets;
   12dff:	8b 45 10             	mov    0x10(%ebp),%eax
   12e02:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	int i, j, UCposition;
	struct sk_buff *skb;

	if(setupUCont(msk, udesc, udesclen, udescstride)) {
		free_remaining(skbs, 0, numDataPackets);
		// failure
		return;
	}
	for(i=numUCChildPackets; i < msk->num_packets; i++) {
   12e05:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   12e08:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   12e0b:	8b 55 08             	mov    0x8(%ebp),%edx
   12e0e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   12e11:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
   12e17:	7c 02                	jl     12e1b <finishTransmitHelper+0x2e>
   12e19:	eb 27                	jmp    12e42 <finishTransmitHelper+0x55>
		// find more child packets (e.g., ucont_len > 0)
		if(REALCHILD(pkts[i])) {
   12e1b:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   12e1e:	89 d0                	mov    %edx,%eax
   12e20:	c1 e0 03             	shl    $0x3,%eax
   12e23:	01 d0                	add    %edx,%eax
   12e25:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   12e2c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   12e2f:	83 7c 10 10 00       	cmpl   $0x0,0x10(%eax,%edx,1)
   12e34:	74 05                	je     12e3b <finishTransmitHelper+0x4e>
			numUCChildPackets++;
   12e36:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
   12e39:	ff 00                	incl   (%eax)
   12e3b:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   12e3e:	ff 00                	incl   (%eax)
   12e40:	eb c9                	jmp    12e0b <finishTransmitHelper+0x1e>
		}
	}
	for(i=0; i < msk->num_packets; i++) {
   12e42:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
   12e49:	8b 55 08             	mov    0x8(%ebp),%edx
   12e4c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   12e4f:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
   12e55:	7c 02                	jl     12e59 <finishTransmitHelper+0x6c>
   12e57:	eb 23                	jmp    12e7c <finishTransmitHelper+0x8f>
		pkts[i].numSiblings = numUCChildPackets;
   12e59:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   12e5c:	89 d0                	mov    %edx,%eax
   12e5e:	c1 e0 03             	shl    $0x3,%eax
   12e61:	01 d0                	add    %edx,%eax
   12e63:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   12e6a:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   12e6d:	0f b6 45 f8          	movzbl 0xfffffff8(%ebp),%eax
   12e71:	88 44 0a 0d          	mov    %al,0xd(%edx,%ecx,1)
   12e75:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   12e78:	ff 00                	incl   (%eax)
   12e7a:	eb cd                	jmp    12e49 <finishTransmitHelper+0x5c>
	}
	UCposition = 0;
   12e7c:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
	for(j=0; j < numDataPackets; j++) {
   12e83:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
   12e8a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   12e8d:	3b 45 10             	cmp    0x10(%ebp),%eax
   12e90:	7c 02                	jl     12e94 <finishTransmitHelper+0xa7>
   12e92:	eb 4d                	jmp    12ee1 <finishTransmitHelper+0xf4>
		pkts[j].position = UCposition++;
   12e94:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   12e97:	89 d0                	mov    %edx,%eax
   12e99:	c1 e0 03             	shl    $0x3,%eax
   12e9c:	01 d0                	add    %edx,%eax
   12e9e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   12ea5:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   12ea8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   12eab:	88 44 0a 0e          	mov    %al,0xe(%edx,%ecx,1)
   12eaf:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   12eb2:	ff 00                	incl   (%eax)
		if(copyUCont(skbs[j], &pkts[j]) != 0) {
			free_remaining(skbs, j, numDataPackets);
			return;
		}
#if 0
		// Analyze headers of data packets
		dump_datachunks(skbs[j]->data, skbs[j]->len);
#endif
		msk_transmit_skb(msk, skbs[j], j);
   12eb4:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   12eb7:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   12ebb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   12ebe:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   12ec5:	8b 45 0c             	mov    0xc(%ebp),%eax
   12ec8:	8b 04 10             	mov    (%eax,%edx,1),%eax
   12ecb:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12ecf:	8b 45 08             	mov    0x8(%ebp),%eax
   12ed2:	89 04 24             	mov    %eax,(%esp,1)
   12ed5:	e8 fc ff ff ff       	call   12ed6 <finishTransmitHelper+0xe9>
   12eda:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   12edd:	ff 00                	incl   (%eax)
   12edf:	eb a9                	jmp    12e8a <finishTransmitHelper+0x9d>
	}
	for(i = numDataPackets; i < msk->num_packets; i++) {
   12ee1:	8b 45 10             	mov    0x10(%ebp),%eax
   12ee4:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   12ee7:	8b 55 08             	mov    0x8(%ebp),%edx
   12eea:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   12eed:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
   12ef3:	7c 05                	jl     12efa <finishTransmitHelper+0x10d>
   12ef5:	e9 e7 00 00 00       	jmp    12fe1 <finishTransmitHelper+0x1f4>
		if(REALCHILD(pkts[i])) {
   12efa:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   12efd:	89 d0                	mov    %edx,%eax
   12eff:	c1 e0 03             	shl    $0x3,%eax
   12f02:	01 d0                	add    %edx,%eax
   12f04:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   12f0b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   12f0e:	83 7c 10 10 00       	cmpl   $0x0,0x10(%eax,%edx,1)
   12f13:	74 22                	je     12f37 <finishTransmitHelper+0x14a>
			pkts[i].position = UCposition++;
   12f15:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   12f18:	89 d0                	mov    %edx,%eax
   12f1a:	c1 e0 03             	shl    $0x3,%eax
   12f1d:	01 d0                	add    %edx,%eax
   12f1f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   12f26:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   12f29:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   12f2c:	88 44 0a 0e          	mov    %al,0xe(%edx,%ecx,1)
   12f30:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   12f33:	ff 00                	incl   (%eax)
   12f35:	eb 19                	jmp    12f50 <finishTransmitHelper+0x163>
		} else {
			pkts[i].position = INVALID_POSITION;
   12f37:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   12f3a:	89 d0                	mov    %edx,%eax
   12f3c:	c1 e0 03             	shl    $0x3,%eax
   12f3f:	01 d0                	add    %edx,%eax
   12f41:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   12f48:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   12f4b:	c6 44 10 0e ff       	movb   $0xff,0xe(%eax,%edx,1)
		}
		/* Send out all remaining packets to placate transport level */
		// XXX Should piggyback all of these packets into a single packet

		int ucontLen;
#ifdef SETUCONT_COMMAND
		ucontLen = abs(pkts[i].ucontLen);
#else
		ucontLen = pkts[i].ucontLen;
   12f50:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   12f53:	89 d0                	mov    %edx,%eax
   12f55:	c1 e0 03             	shl    $0x3,%eax
   12f58:	01 d0                	add    %edx,%eax
   12f5a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   12f61:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   12f64:	8b 44 10 10          	mov    0x10(%eax,%edx,1),%eax
   12f68:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
#endif // SETUCONT_COMMAND
		skb = alloc_skb(MAX_TCP_HEADER + MAX_TRICKLES_SERVER_HDR_LEN + ucontLen, GFP_KERNEL);
   12f6b:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
   12f72:	00 
   12f73:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   12f76:	05 f2 00 00 00       	add    $0xf2,%eax
   12f7b:	89 04 24             	mov    %eax,(%esp,1)
   12f7e:	e8 fc ff ff ff       	call   12f7f <finishTransmitHelper+0x192>
   12f83:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
		if(skb == NULL) {
   12f86:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
   12f8a:	75 0e                	jne    12f9a <finishTransmitHelper+0x1ad>
			printk("out of memory during finishTransmit\n");
   12f8c:	c7 04 24 00 55 00 00 	movl   $0x5500,(%esp,1)
   12f93:	e8 fc ff ff ff       	call   12f94 <finishTransmitHelper+0x1a7>
			return;
   12f98:	eb 47                	jmp    12fe1 <finishTransmitHelper+0x1f4>
		}
		skb_reserve(skb, MAX_TCP_HEADER + MAX_TRICKLES_SERVER_HDR_LEN + ucontLen);
   12f9a:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   12f9d:	05 f2 00 00 00       	add    $0xf2,%eax
   12fa2:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12fa6:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   12fa9:	89 04 24             	mov    %eax,(%esp,1)
   12fac:	e8 74 71 00 00       	call   1a125 <skb_reserve>
		skb->csum = 0;
   12fb1:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   12fb4:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
   12fbb:	00 00 00 
		if(copyUCont(skb, &pkts[i])) {
			return;
		}
		msk_transmit_skb(msk, skb, i);
   12fbe:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   12fc1:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   12fc5:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   12fc8:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   12fcc:	8b 45 08             	mov    0x8(%ebp),%eax
   12fcf:	89 04 24             	mov    %eax,(%esp,1)
   12fd2:	e8 fc ff ff ff       	call   12fd3 <finishTransmitHelper+0x1e6>
   12fd7:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   12fda:	ff 00                	incl   (%eax)
   12fdc:	e9 06 ff ff ff       	jmp    12ee7 <finishTransmitHelper+0xfa>
	}
#undef  REALCHILD
}
   12fe1:	c9                   	leave  
   12fe2:	c3                   	ret    

00012fe3 <tiov_handler>:

static inline int tiov_handler(struct sock *origSK, struct cminisock *msk, struct tiovec *tiov, int tiovlen) {
   12fe3:	55                   	push   %ebp
   12fe4:	89 e5                	mov    %esp,%ebp
   12fe6:	53                   	push   %ebx
   12fe7:	83 c4 80             	add    $0xffffff80,%esp
	//BREAKOUT();
	int i, numDataPackets = 0, totallen = 0, tiov_pos = 0, tiov_offs = 0;
   12fea:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
   12ff1:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
   12ff8:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
   12fff:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
	struct cminisock_packet *pkts;
	int rval = 0;
   13006:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
#define MAX_SKBS (4)
	struct sk_buff *skb_body[MAX_SKBS];
	struct sk_buff **skbs, *skb;
	if(msk->num_packets > MAX_SKBS) {
   1300d:	8b 45 0c             	mov    0xc(%ebp),%eax
   13010:	83 b8 e8 00 00 00 04 	cmpl   $0x4,0xe8(%eax)
   13017:	7e 21                	jle    1303a <tiov_handler+0x57>
		skbs = kmalloc(sizeof(struct sk_buff *) * msk->num_packets, GFP_USER);
   13019:	c7 44 24 04 d0 01 00 	movl   $0x1d0,0x4(%esp,1)
   13020:	00 
   13021:	8b 45 0c             	mov    0xc(%ebp),%eax
   13024:	8b 80 e8 00 00 00    	mov    0xe8(%eax),%eax
   1302a:	c1 e0 02             	shl    $0x2,%eax
   1302d:	89 04 24             	mov    %eax,(%esp,1)
   13030:	e8 fc ff ff ff       	call   13031 <tiov_handler+0x4e>
   13035:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
   13038:	eb 26                	jmp    13060 <tiov_handler+0x7d>
	} else {
		BUG_TRAP(msk->num_packets >= 0);
   1303a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1303d:	83 b8 e8 00 00 00 00 	cmpl   $0x0,0xe8(%eax)
   13044:	79 14                	jns    1305a <tiov_handler+0x77>
   13046:	c7 44 24 04 ed 01 00 	movl   $0x1ed,0x4(%esp,1)
   1304d:	00 
   1304e:	c7 04 24 40 55 00 00 	movl   $0x5540,(%esp,1)
   13055:	e8 fc ff ff ff       	call   13056 <tiov_handler+0x73>
		skbs = skb_body;
   1305a:	8d 45 d0             	lea    0xffffffd0(%ebp),%eax
   1305d:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
	}
	int maxLen = 0;
   13060:	c7 45 c4 00 00 00 00 	movl   $0x0,0xffffffc4(%ebp)

	if(skbs == NULL)
   13067:	83 7d cc 00          	cmpl   $0x0,0xffffffcc(%ebp)
   1306b:	75 05                	jne    13072 <tiov_handler+0x8f>
		goto out;
   1306d:	e9 89 04 00 00       	jmp    134fb <tiov_handler+0x518>

	pkts = msk->packets;
   13072:	8b 45 0c             	mov    0xc(%ebp),%eax
   13075:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
   1307b:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)

	for(i=0; i < tiovlen; i++) {
   1307e:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
   13085:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13088:	3b 45 14             	cmp    0x14(%ebp),%eax
   1308b:	7c 02                	jl     1308f <tiov_handler+0xac>
   1308d:	eb 1d                	jmp    130ac <tiov_handler+0xc9>
		totallen += tiov[i].iov_len;
   1308f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13092:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   13099:	8b 45 10             	mov    0x10(%ebp),%eax
   1309c:	8b 54 10 04          	mov    0x4(%eax,%edx,1),%edx
   130a0:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   130a3:	01 10                	add    %edx,(%eax)
   130a5:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
   130a8:	ff 00                	incl   (%eax)
   130aa:	eb d9                	jmp    13085 <tiov_handler+0xa2>
	}
	for(i=0; i < msk->num_packets; i++) {
   130ac:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
   130b3:	8b 55 0c             	mov    0xc(%ebp),%edx
   130b6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   130b9:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
   130bf:	7c 02                	jl     130c3 <tiov_handler+0xe0>
   130c1:	eb 2a                	jmp    130ed <tiov_handler+0x10a>
		maxLen += msk->packets[i].len;
   130c3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   130c6:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   130c9:	89 d0                	mov    %edx,%eax
   130cb:	c1 e0 03             	shl    $0x3,%eax
   130ce:	01 d0                	add    %edx,%eax
   130d0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   130d7:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   130dd:	8b 54 10 08          	mov    0x8(%eax,%edx,1),%edx
   130e1:	8d 45 c4             	lea    0xffffffc4(%ebp),%eax
   130e4:	01 10                	add    %edx,(%eax)
   130e6:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
   130e9:	ff 00                	incl   (%eax)
   130eb:	eb c6                	jmp    130b3 <tiov_handler+0xd0>
	}
	if(totallen < maxLen) {
   130ed:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   130f0:	3b 45 c4             	cmp    0xffffffc4(%ebp),%eax
   130f3:	7d 24                	jge    13119 <tiov_handler+0x136>
		static int shortCount = 0;
		static int maxCount = 0;
		shortCount++;
   130f5:	ff 05 00 01 00 00    	incl   0x100
		if(msk->dbg_mark == MAX_NUM_DATACHUNKS) {
   130fb:	8b 45 0c             	mov    0xc(%ebp),%eax
   130fe:	83 b8 90 00 00 00 32 	cmpl   $0x32,0x90(%eax)
   13105:	75 06                	jne    1310d <tiov_handler+0x12a>
			maxCount++;
   13107:	ff 05 04 01 00 00    	incl   0x104
		}
		if(trickles_ratelimit()) {
			printk("%d:mark(%d) Short by %d (%d - %d) count=(%d,%d)\n", jiffies, msk->dbg_mark, maxLen - totallen,
			       maxLen, totallen, shortCount, maxCount);
			printk("%p short by input_len = %d\n", msk, msk->input_len);
		}
		static int zerocount = 0;
		if(totallen == 0) {
   1310d:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
   13111:	75 06                	jne    13119 <tiov_handler+0x136>
			zerocount++;
   13113:	ff 05 08 01 00 00    	incl   0x108
			if(trickles_ratelimit()) {
				printk("%d: zero request count: %d\n", jiffies, zerocount);
			}
		}
	}
	//BREAKOUT();
	for(i=0; i < msk->num_packets; i++) {
   13119:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
   13120:	8b 55 0c             	mov    0xc(%ebp),%edx
   13123:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13126:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
   1312c:	7c 05                	jl     13133 <tiov_handler+0x150>
   1312e:	e9 97 03 00 00       	jmp    134ca <tiov_handler+0x4e7>
		int pkt_remain;
		int short_pkt = 0;
   13133:	c7 45 bc 00 00 00 00 	movl   $0x0,0xffffffbc(%ebp)

		if(pkts[i].len > totallen) {
   1313a:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   1313d:	89 d0                	mov    %edx,%eax
   1313f:	c1 e0 03             	shl    $0x3,%eax
   13142:	01 d0                	add    %edx,%eax
   13144:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1314b:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1314e:	8b 44 10 08          	mov    0x8(%eax,%edx,1),%eax
   13152:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
   13155:	76 07                	jbe    1315e <tiov_handler+0x17b>
			short_pkt = 1;
   13157:	c7 45 bc 01 00 00 00 	movl   $0x1,0xffffffbc(%ebp)
		}
		pkt_remain = pkts[i].len = MIN(pkts[i].len, totallen);
   1315e:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   13161:	89 d0                	mov    %edx,%eax
   13163:	c1 e0 03             	shl    $0x3,%eax
   13166:	01 d0                	add    %edx,%eax
   13168:	c1 e0 02             	shl    $0x2,%eax
   1316b:	89 45 a8             	mov    %eax,0xffffffa8(%ebp)
   1316e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   13171:	89 45 a4             	mov    %eax,0xffffffa4(%ebp)
   13174:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   13177:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
   1317a:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   1317d:	89 d0                	mov    %edx,%eax
   1317f:	c1 e0 03             	shl    $0x3,%eax
   13182:	01 d0                	add    %edx,%eax
   13184:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1318b:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1318e:	8b 44 10 08          	mov    0x8(%eax,%edx,1),%eax
   13192:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
   13195:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
   13198:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
   1319b:	8b 55 b0             	mov    0xffffffb0(%ebp),%edx
   1319e:	89 55 a0             	mov    %edx,0xffffffa0(%ebp)
   131a1:	8b 4d a0             	mov    0xffffffa0(%ebp),%ecx
   131a4:	3b 4d b4             	cmp    0xffffffb4(%ebp),%ecx
   131a7:	76 06                	jbe    131af <tiov_handler+0x1cc>
   131a9:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
   131ac:	89 45 a0             	mov    %eax,0xffffffa0(%ebp)
   131af:	8b 45 a0             	mov    0xffffffa0(%ebp),%eax
   131b2:	8b 55 a8             	mov    0xffffffa8(%ebp),%edx
   131b5:	8b 4d a4             	mov    0xffffffa4(%ebp),%ecx
   131b8:	89 44 11 08          	mov    %eax,0x8(%ecx,%edx,1)
   131bc:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
		skb = skbs[i] = recycle(origSK);
   131bf:	8b 45 08             	mov    0x8(%ebp),%eax
   131c2:	89 04 24             	mov    %eax,(%esp,1)
   131c5:	e8 53 7b 00 00       	call   1ad1d <recycle>
   131ca:	89 c1                	mov    %eax,%ecx
   131cc:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   131cf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   131d6:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
   131d9:	89 0c 10             	mov    %ecx,(%eax,%edx,1)
   131dc:	8b 04 10             	mov    (%eax,%edx,1),%eax
   131df:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
		if(skb == NULL) {
   131e2:	83 7d c8 00          	cmpl   $0x0,0xffffffc8(%ebp)
   131e6:	75 5d                	jne    13245 <tiov_handler+0x262>
			skb = skbs[i] = alloc_skb(MAX_TCP_HEADER + MAX_TRICKLES_SERVER_HDR_LEN + pkts[i].ucontLen + pkts[i].len, GFP_KERNEL);
   131e8:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
   131ef:	00 
   131f0:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   131f3:	89 d0                	mov    %edx,%eax
   131f5:	c1 e0 03             	shl    $0x3,%eax
   131f8:	01 d0                	add    %edx,%eax
   131fa:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   13201:	8b 5d e4             	mov    0xffffffe4(%ebp),%ebx
   13204:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   13207:	89 d0                	mov    %edx,%eax
   13209:	c1 e0 03             	shl    $0x3,%eax
   1320c:	01 d0                	add    %edx,%eax
   1320e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   13215:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   13218:	8b 44 10 08          	mov    0x8(%eax,%edx,1),%eax
   1321c:	03 44 0b 10          	add    0x10(%ebx,%ecx,1),%eax
   13220:	05 f2 00 00 00       	add    $0xf2,%eax
   13225:	89 04 24             	mov    %eax,(%esp,1)
   13228:	e8 fc ff ff ff       	call   13229 <tiov_handler+0x246>
   1322d:	89 c1                	mov    %eax,%ecx
   1322f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13232:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   13239:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
   1323c:	89 0c 10             	mov    %ecx,(%eax,%edx,1)
   1323f:	8b 04 10             	mov    (%eax,%edx,1),%eax
   13242:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
		}
		numDataPackets = i+1;
   13245:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13248:	40                   	inc    %eax
   13249:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		if(skb == NULL) {
   1324c:	83 7d c8 00          	cmpl   $0x0,0xffffffc8(%ebp)
   13250:	75 11                	jne    13263 <tiov_handler+0x280>
			printk("could not allocate skb\n");
   13252:	c7 04 24 8c 55 00 00 	movl   $0x558c,(%esp,1)
   13259:	e8 fc ff ff ff       	call   1325a <tiov_handler+0x277>
			goto out;
   1325e:	e9 98 02 00 00       	jmp    134fb <tiov_handler+0x518>
		}
		skb_reserve(skb, MAX_TCP_HEADER + MAX_TRICKLES_SERVER_HDR_LEN + pkts[i].ucontLen);
   13263:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   13266:	89 d0                	mov    %edx,%eax
   13268:	c1 e0 03             	shl    $0x3,%eax
   1326b:	01 d0                	add    %edx,%eax
   1326d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   13274:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   13277:	8b 44 10 10          	mov    0x10(%eax,%edx,1),%eax
   1327b:	05 f2 00 00 00       	add    $0xf2,%eax
   13280:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   13284:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   13287:	89 04 24             	mov    %eax,(%esp,1)
   1328a:	e8 96 6e 00 00       	call   1a125 <skb_reserve>

		skb->csum = 0;
   1328f:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   13292:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
   13299:	00 00 00 
		skb->ip_summed = CHECKSUM_HW;
   1329c:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   1329f:	c6 80 a3 00 00 00 01 	movb   $0x1,0xa3(%eax)
		while(tiov_pos < tiovlen) {
   132a6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   132a9:	3b 45 14             	cmp    0x14(%ebp),%eax
   132ac:	7c 05                	jl     132b3 <tiov_handler+0x2d0>
   132ae:	e9 1c 01 00 00       	jmp    133cf <tiov_handler+0x3ec>
			int amt = MIN(pkt_remain, tiov[tiov_pos].iov_len - tiov_offs);
   132b3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   132b6:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
   132bd:	8b 45 10             	mov    0x10(%ebp),%eax
   132c0:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   132c3:	8b 44 08 04          	mov    0x4(%eax,%ecx,1),%eax
   132c7:	29 d0                	sub    %edx,%eax
   132c9:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
   132cc:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
   132cf:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
   132d2:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
   132d5:	89 45 ac             	mov    %eax,0xffffffac(%ebp)
   132d8:	8b 45 ac             	mov    0xffffffac(%ebp),%eax
   132db:	89 45 9c             	mov    %eax,0xffffff9c(%ebp)
   132de:	8b 55 9c             	mov    0xffffff9c(%ebp),%edx
   132e1:	3b 55 b8             	cmp    0xffffffb8(%ebp),%edx
   132e4:	7e 06                	jle    132ec <tiov_handler+0x309>
   132e6:	8b 4d b8             	mov    0xffffffb8(%ebp),%ecx
   132e9:	89 4d 9c             	mov    %ecx,0xffffff9c(%ebp)
   132ec:	8b 45 9c             	mov    0xffffff9c(%ebp),%eax
   132ef:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
			int err = 0;
   132f2:	c7 45 ac 00 00 00 00 	movl   $0x0,0xffffffac(%ebp)
			char *src = tiov[tiov_pos].iov_base + tiov_offs;
   132f9:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   132fc:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
   13303:	8b 55 10             	mov    0x10(%ebp),%edx
   13306:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   13309:	03 04 0a             	add    (%edx,%ecx,1),%eax
   1330c:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
			//printk("tiov copy loop, copying %d\n", amt);

			err = skb_add_data(skb,src,amt);
   1330f:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
   13312:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   13316:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
   13319:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1331d:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   13320:	89 04 24             	mov    %eax,(%esp,1)
   13323:	e8 f6 f6 ff ff       	call   12a1e <skb_add_data>
   13328:	89 45 ac             	mov    %eax,0xffffffac(%ebp)
			//printk("tiov[%d].tiov_base (%p) + tiov_offs (%u) = %p, data = %p, amt = %d, skb->csum = %x, tail = %p, tailroom = %u, tiov_len = %u, &err=%p\n", tiov_pos, tiov[tiov_pos].tiov_base, tiov_offs, tiov[tiov_pos].tiov_base + tiov_offs, data, amt, skb->csum, skb->tail, skb_tailroom(skb), tiov[tiov_pos].iov_len, &err);
			if(err) {
   1332b:	83 7d ac 00          	cmpl   $0x0,0xffffffac(%ebp)
   1332f:	74 5a                	je     1338b <tiov_handler+0x3a8>
				printk("error while csum/copy, base = %p amt = %d, msk state = %d, (seq,base,delta) = (%d,%d,%d)\n", src, amt, msk->state, msk->seq, msk->TCPBase, msk->seq - msk->TCPBase);
   13331:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   13334:	8b 45 0c             	mov    0xc(%ebp),%eax
   13337:	8b 50 6c             	mov    0x6c(%eax),%edx
   1333a:	8b 41 30             	mov    0x30(%ecx),%eax
   1333d:	29 d0                	sub    %edx,%eax
   1333f:	89 44 24 18          	mov    %eax,0x18(%esp,1)
   13343:	8b 45 0c             	mov    0xc(%ebp),%eax
   13346:	8b 40 6c             	mov    0x6c(%eax),%eax
   13349:	89 44 24 14          	mov    %eax,0x14(%esp,1)
   1334d:	8b 45 0c             	mov    0xc(%ebp),%eax
   13350:	8b 40 30             	mov    0x30(%eax),%eax
   13353:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   13357:	8b 45 0c             	mov    0xc(%ebp),%eax
   1335a:	8b 40 54             	mov    0x54(%eax),%eax
   1335d:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   13361:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
   13364:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   13368:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
   1336b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1336f:	c7 04 24 c0 55 00 00 	movl   $0x55c0,(%esp,1)
   13376:	e8 fc ff ff ff       	call   13377 <tiov_handler+0x394>

				kfree_skb(skb);
   1337b:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   1337e:	89 04 24             	mov    %eax,(%esp,1)
   13381:	e8 1a 6c 00 00       	call   19fa0 <kfree_skb>
				goto out;
   13386:	e9 70 01 00 00       	jmp    134fb <tiov_handler+0x518>
			}

			totallen -= amt;
   1338b:	8b 55 b0             	mov    0xffffffb0(%ebp),%edx
   1338e:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   13391:	29 10                	sub    %edx,(%eax)
			pkt_remain -= amt;
   13393:	8b 55 b0             	mov    0xffffffb0(%ebp),%edx
   13396:	8d 45 c0             	lea    0xffffffc0(%ebp),%eax
   13399:	29 10                	sub    %edx,(%eax)
			tiov_offs += amt;
   1339b:	8b 55 b0             	mov    0xffffffb0(%ebp),%edx
   1339e:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   133a1:	01 10                	add    %edx,(%eax)
			if(tiov_offs == tiov[tiov_pos].iov_len) {
   133a3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   133a6:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
   133ad:	8b 55 10             	mov    0x10(%ebp),%edx
   133b0:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   133b3:	3b 44 0a 04          	cmp    0x4(%edx,%ecx,1),%eax
   133b7:	75 0c                	jne    133c5 <tiov_handler+0x3e2>
				tiov_offs = 0;
   133b9:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
				tiov_pos++;
   133c0:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   133c3:	ff 00                	incl   (%eax)
			}
			if(pkt_remain == 0) break;
   133c5:	83 7d c0 00          	cmpl   $0x0,0xffffffc0(%ebp)
   133c9:	0f 85 d7 fe ff ff    	jne    132a6 <tiov_handler+0x2c3>
		}
		BUG_TRAP(pkt_remain == 0);
   133cf:	83 7d c0 00          	cmpl   $0x0,0xffffffc0(%ebp)
   133d3:	74 14                	je     133e9 <tiov_handler+0x406>
   133d5:	c7 44 24 04 3f 02 00 	movl   $0x23f,0x4(%esp,1)
   133dc:	00 
   133dd:	c7 04 24 20 56 00 00 	movl   $0x5620,(%esp,1)
   133e4:	e8 fc ff ff ff       	call   133e5 <tiov_handler+0x402>

		if(userapi_pkt_spew) {
   133e9:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
   133f0:	74 63                	je     13455 <tiov_handler+0x472>
			printk("sending pkts[%d] %u-%u\n", i, pkts[i].seq, pkts[i].seq + pkts[i].len);
   133f2:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   133f5:	89 d0                	mov    %edx,%eax
   133f7:	c1 e0 03             	shl    $0x3,%eax
   133fa:	01 d0                	add    %edx,%eax
   133fc:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   13403:	8b 5d e4             	mov    0xffffffe4(%ebp),%ebx
   13406:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   13409:	89 d0                	mov    %edx,%eax
   1340b:	c1 e0 03             	shl    $0x3,%eax
   1340e:	01 d0                	add    %edx,%eax
   13410:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   13417:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1341a:	8b 44 10 08          	mov    0x8(%eax,%edx,1),%eax
   1341e:	03 44 0b 04          	add    0x4(%ebx,%ecx,1),%eax
   13422:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   13426:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   13429:	89 d0                	mov    %edx,%eax
   1342b:	c1 e0 03             	shl    $0x3,%eax
   1342e:	01 d0                	add    %edx,%eax
   13430:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   13437:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1343a:	8b 44 10 04          	mov    0x4(%eax,%edx,1),%eax
   1343e:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   13442:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13445:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   13449:	c7 04 24 66 56 00 00 	movl   $0x5666,(%esp,1)
   13450:	e8 fc ff ff ff       	call   13451 <tiov_handler+0x46e>
		}

		// on last packet, set the tag to FIN
		if(totallen == 0 &&
   13455:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
   13459:	75 40                	jne    1349b <tiov_handler+0x4b8>
   1345b:	8b 45 14             	mov    0x14(%ebp),%eax
   1345e:	c1 e0 03             	shl    $0x3,%eax
   13461:	03 45 10             	add    0x10(%ebp),%eax
   13464:	83 e8 08             	sub    $0x8,%eax
   13467:	83 38 ff             	cmpl   $0xffffffff,(%eax)
   1346a:	75 2f                	jne    1349b <tiov_handler+0x4b8>
   1346c:	8b 45 14             	mov    0x14(%ebp),%eax
   1346f:	c1 e0 03             	shl    $0x3,%eax
   13472:	03 45 10             	add    0x10(%ebp),%eax
   13475:	83 e8 08             	sub    $0x8,%eax
   13478:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
   1347c:	75 1d                	jne    1349b <tiov_handler+0x4b8>
		   tiov[tiovlen-1].iov_base == (void*)-1 && tiov[tiovlen-1].iov_len == 0) {
			printk("Fin, iovlen = %d\n", tiovlen);
   1347e:	8b 45 14             	mov    0x14(%ebp),%eax
   13481:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   13485:	c7 04 24 7e 56 00 00 	movl   $0x567e,(%esp,1)
   1348c:	e8 fc ff ff ff       	call   1348d <tiov_handler+0x4aa>
			msk->tag = FIN;
   13491:	8b 45 0c             	mov    0xc(%ebp),%eax
   13494:	c7 40 10 02 00 00 00 	movl   $0x2,0x10(%eax)
		}

		rval += pkts[i].len; // check how much data actually sent?
   1349b:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   1349e:	89 d0                	mov    %edx,%eax
   134a0:	c1 e0 03             	shl    $0x3,%eax
   134a3:	01 d0                	add    %edx,%eax
   134a5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   134ac:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   134af:	8b 54 10 08          	mov    0x8(%eax,%edx,1),%edx
   134b3:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   134b6:	01 10                	add    %edx,(%eax)
		if(totallen == 0) {
   134b8:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
   134bc:	75 02                	jne    134c0 <tiov_handler+0x4dd>
			break;
   134be:	eb 0a                	jmp    134ca <tiov_handler+0x4e7>
   134c0:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
   134c3:	ff 00                	incl   (%eax)
   134c5:	e9 56 fc ff ff       	jmp    13120 <tiov_handler+0x13d>
		}
	}

	FINISH_TRANSMIT(msk, skbs, numDataPackets,
		       (struct ucontdesc *)&tiov[0].ucont_base, tiovlen,
		       sizeof(*tiov));
   134ca:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp,1)
   134d1:	00 
   134d2:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp,1)
   134d9:	00 
   134da:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp,1)
   134e1:	00 
   134e2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   134e5:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   134e9:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
   134ec:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   134f0:	8b 45 0c             	mov    0xc(%ebp),%eax
   134f3:	89 04 24             	mov    %eax,(%esp,1)
   134f6:	e8 f2 f8 ff ff       	call   12ded <finishTransmitHelper>
	//BREAKOUT();
	if(totallen > 0) {
		if(trickles_ratelimit()) {
			int i;
			printk("too much data for downcall: %d left, trace = %d\n",
			       totallen, msk->executionTrace);
			for(i=0; i < tiovlen; i++) {
				printk("tiov[%d] = {base = %p, len = %d}\n", i,
				       tiov[i].iov_base, tiov[i].iov_len);
			}
		}
#if 0
		printk("pre showing stack\n");
		show_stack(NULL);
		printk("done showing stack\n");
#endif
	}
 out:
	if(skbs != skb_body) {
   134fb:	8d 45 d0             	lea    0xffffffd0(%ebp),%eax
   134fe:	39 45 cc             	cmp    %eax,0xffffffcc(%ebp)
   13501:	74 0b                	je     1350e <tiov_handler+0x52b>
		//printk("pre disabled kfree %d\n", msk->num_packets);
		kfree(skbs);
   13503:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
   13506:	89 04 24             	mov    %eax,(%esp,1)
   13509:	e8 fc ff ff ff       	call   1350a <tiov_handler+0x527>
	}
	return rval;
   1350e:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
}
   13511:	83 ec 80             	sub    $0xffffff80,%esp
   13514:	5b                   	pop    %ebx
   13515:	5d                   	pop    %ebp
   13516:	c3                   	ret    

00013517 <trickles_close>:

void trickles_close(struct sock *sk, long timeout) {
   13517:	55                   	push   %ebp
   13518:	89 e5                	mov    %esp,%ebp
   1351a:	83 ec 14             	sub    $0x14,%esp
	/* Based on TCP_CLOSE.
	   Zap connections as fast as possible
	*/
	struct sk_buff *skb;
	int data_was_unread = 0;
   1351d:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
#if 1 // 0502 - moving receive queue drain inside bh-safe portion
	// orig
	lock_sock(sk);
   13524:	ff 05 08 00 00 00    	incl   0x8
   1352a:	8b 45 08             	mov    0x8(%ebp),%eax
   1352d:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
   13531:	74 0b                	je     1353e <trickles_close+0x27>
   13533:	8b 45 08             	mov    0x8(%ebp),%eax
   13536:	89 04 24             	mov    %eax,(%esp,1)
   13539:	e8 fc ff ff ff       	call   1353a <trickles_close+0x23>
   1353e:	8b 45 08             	mov    0x8(%ebp),%eax
   13541:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
   13548:	c7 45 f4 08 00 00 00 	movl   $0x8,0xfffffff4(%ebp)
   1354f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   13552:	ff 08                	decl   (%eax)
   13554:	83 38 00             	cmpl   $0x0,(%eax)
   13557:	75 0d                	jne    13566 <trickles_close+0x4f>
   13559:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1355c:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   13560:	0f 85 1a 8a 00 00    	jne    1bf80 <.text.lock.tmalloc+0x10>
	sk->shutdown = SHUTDOWN_MASK;
   13566:	8b 45 08             	mov    0x8(%ebp),%eax
   13569:	c6 40 27 03          	movb   $0x3,0x27(%eax)

	/* drain receive queue */
	while((skb=__skb_dequeue(&sk->receive_queue))!=NULL) {
   1356d:	8b 45 08             	mov    0x8(%ebp),%eax
   13570:	83 c0 48             	add    $0x48,%eax
   13573:	89 04 24             	mov    %eax,(%esp,1)
   13576:	e8 b0 6a 00 00       	call   1a02b <__skb_dequeue>
   1357b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   1357e:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
   13582:	75 02                	jne    13586 <trickles_close+0x6f>
   13584:	eb 43                	jmp    135c9 <trickles_close+0xb2>
		u32 len = TCP_SKB_CB(skb)->end_seq - TCP_SKB_CB(skb)->seq - skb->h.th->fin;
   13586:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
   13589:	83 c1 30             	add    $0x30,%ecx
   1358c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1358f:	83 c0 30             	add    $0x30,%eax
   13592:	8b 50 10             	mov    0x10(%eax),%edx
   13595:	8b 41 14             	mov    0x14(%ecx),%eax
   13598:	29 d0                	sub    %edx,%eax
   1359a:	89 c2                	mov    %eax,%edx
   1359c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1359f:	8b 40 20             	mov    0x20(%eax),%eax
   135a2:	66 0f b6 40 0d       	movzbw 0xd(%eax),%ax
   135a7:	83 e0 01             	and    $0x1,%eax
   135aa:	0f b7 c0             	movzwl %ax,%eax
   135ad:	29 c2                	sub    %eax,%edx
   135af:	89 d0                	mov    %edx,%eax
   135b1:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		data_was_unread += len;
   135b4:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   135b7:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
   135ba:	01 10                	add    %edx,(%eax)
		__kfree_skb(skb);
   135bc:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   135bf:	89 04 24             	mov    %eax,(%esp,1)
   135c2:	e8 fc ff ff ff       	call   135c3 <trickles_close+0xac>
   135c7:	eb a4                	jmp    1356d <trickles_close+0x56>
	}
	// printk("%u bytes unread\n", data_was_unread); // 0418

	tcp_mem_reclaim(sk);
   135c9:	8b 45 08             	mov    0x8(%ebp),%eax
   135cc:	89 04 24             	mov    %eax,(%esp,1)
   135cf:	e8 5a 74 00 00       	call   1aa2e <tcp_mem_reclaim>
	tcp_set_state(sk, TCP_CLOSE);
   135d4:	c7 44 24 04 07 00 00 	movl   $0x7,0x4(%esp,1)
   135db:	00 
   135dc:	8b 45 08             	mov    0x8(%ebp),%eax
   135df:	89 04 24             	mov    %eax,(%esp,1)
   135e2:	e8 50 73 00 00       	call   1a937 <tcp_set_state>

	release_sock(sk);
   135e7:	ff 05 08 00 00 00    	incl   0x8
   135ed:	8b 45 08             	mov    0x8(%ebp),%eax
   135f0:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   135f7:	74 0b                	je     13604 <trickles_close+0xed>
   135f9:	8b 45 08             	mov    0x8(%ebp),%eax
   135fc:	89 04 24             	mov    %eax,(%esp,1)
   135ff:	e8 fc ff ff ff       	call   13600 <trickles_close+0xe9>
   13604:	8b 45 08             	mov    0x8(%ebp),%eax
   13607:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   1360e:	8b 45 08             	mov    0x8(%ebp),%eax
   13611:	83 c0 30             	add    $0x30,%eax
   13614:	89 04 24             	mov    %eax,(%esp,1)
   13617:	e8 c6 66 00 00       	call   19ce2 <waitqueue_active>
   1361c:	85 c0                	test   %eax,%eax
   1361e:	74 15                	je     13635 <trickles_close+0x11e>
   13620:	8b 45 08             	mov    0x8(%ebp),%eax
   13623:	83 c0 30             	add    $0x30,%eax
   13626:	b9 01 00 00 00       	mov    $0x1,%ecx
   1362b:	ba 03 00 00 00       	mov    $0x3,%edx
   13630:	e8 fc ff ff ff       	call   13631 <trickles_close+0x11a>
   13635:	c7 45 f4 08 00 00 00 	movl   $0x8,0xfffffff4(%ebp)
   1363c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1363f:	ff 08                	decl   (%eax)
   13641:	83 38 00             	cmpl   $0x0,(%eax)
   13644:	75 0d                	jne    13653 <trickles_close+0x13c>
   13646:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   13649:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   1364d:	0f 85 3d 89 00 00    	jne    1bf90 <.text.lock.tmalloc+0x20>

	local_bh_disable();
   13653:	ff 05 08 00 00 00    	incl   0x8
	bh_lock_sock(sk);

	sock_hold(sk);
   13659:	8b 45 08             	mov    0x8(%ebp),%eax
   1365c:	89 04 24             	mov    %eax,(%esp,1)
   1365f:	e8 cd 70 00 00       	call   1a731 <sock_hold>
	sock_orphan(sk);
   13664:	8b 45 08             	mov    0x8(%ebp),%eax
   13667:	89 04 24             	mov    %eax,(%esp,1)
   1366a:	e8 fd 70 00 00       	call   1a76c <sock_orphan>
	tcp_destroy_sock(sk);
   1366f:	8b 45 08             	mov    0x8(%ebp),%eax
   13672:	89 04 24             	mov    %eax,(%esp,1)
   13675:	e8 fc ff ff ff       	call   13676 <trickles_close+0x15f>

	bh_unlock_sock(sk);
	local_bh_enable();
   1367a:	c7 45 f4 08 00 00 00 	movl   $0x8,0xfffffff4(%ebp)
   13681:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   13684:	ff 08                	decl   (%eax)
   13686:	83 38 00             	cmpl   $0x0,(%eax)
   13689:	75 0d                	jne    13698 <trickles_close+0x181>
   1368b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1368e:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   13692:	0f 85 08 89 00 00    	jne    1bfa0 <.text.lock.tmalloc+0x30>
	sock_put(sk);
   13698:	8b 45 08             	mov    0x8(%ebp),%eax
   1369b:	89 04 24             	mov    %eax,(%esp,1)
   1369e:	e8 a4 70 00 00       	call   1a747 <sock_put>
#else
	local_bh_disable();
	bh_lock_sock(sk);

	sock_hold(sk);
	sock_orphan(sk);

	sk->shutdown = SHUTDOWN_MASK;

	/* drain receive queue */
	while((skb=__skb_dequeue(&sk->receive_queue))!=NULL) {
		u32 len = TCP_SKB_CB(skb)->end_seq - TCP_SKB_CB(skb)->seq - skb->h.th->fin;
		data_was_unread += len;
		__kfree_skb(skb);
	}
	// printk("%u bytes unread\n", data_was_unread); // 0418

	tcp_mem_reclaim(sk);
	tcp_set_state(sk, TCP_CLOSE);

	tcp_destroy_sock(sk);

	bh_unlock_sock(sk);
	local_bh_enable();
	sock_put(sk);
#endif
}
   136a3:	c9                   	leave  
   136a4:	c3                   	ret    

000136a5 <trickles_init_sock_impl>:

void trickles_init_sock_impl(struct sock *sk, int val) {
   136a5:	55                   	push   %ebp
   136a6:	89 e5                	mov    %esp,%ebp
   136a8:	83 ec 0c             	sub    $0xc,%esp
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
   136ab:	8b 45 08             	mov    0x8(%ebp),%eax
   136ae:	05 bc 00 00 00       	add    $0xbc,%eax
   136b3:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	local_bh_disable();
   136b6:	ff 05 08 00 00 00    	incl   0x8
	release_sock(sk);
   136bc:	ff 05 08 00 00 00    	incl   0x8
   136c2:	8b 45 08             	mov    0x8(%ebp),%eax
   136c5:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   136cc:	74 0b                	je     136d9 <trickles_init_sock_impl+0x34>
   136ce:	8b 45 08             	mov    0x8(%ebp),%eax
   136d1:	89 04 24             	mov    %eax,(%esp,1)
   136d4:	e8 fc ff ff ff       	call   136d5 <trickles_init_sock_impl+0x30>
   136d9:	8b 45 08             	mov    0x8(%ebp),%eax
   136dc:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   136e3:	8b 45 08             	mov    0x8(%ebp),%eax
   136e6:	83 c0 30             	add    $0x30,%eax
   136e9:	89 04 24             	mov    %eax,(%esp,1)
   136ec:	e8 f1 65 00 00       	call   19ce2 <waitqueue_active>
   136f1:	85 c0                	test   %eax,%eax
   136f3:	74 15                	je     1370a <trickles_init_sock_impl+0x65>
   136f5:	8b 45 08             	mov    0x8(%ebp),%eax
   136f8:	83 c0 30             	add    $0x30,%eax
   136fb:	b9 01 00 00 00       	mov    $0x1,%ecx
   13700:	ba 03 00 00 00       	mov    $0x3,%edx
   13705:	e8 fc ff ff ff       	call   13706 <trickles_init_sock_impl+0x61>
   1370a:	c7 45 f8 08 00 00 00 	movl   $0x8,0xfffffff8(%ebp)
   13711:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13714:	ff 08                	decl   (%eax)
   13716:	83 38 00             	cmpl   $0x0,(%eax)
   13719:	75 0d                	jne    13728 <trickles_init_sock_impl+0x83>
   1371b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1371e:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   13722:	0f 85 88 88 00 00    	jne    1bfb0 <.text.lock.tmalloc+0x40>
	bh_lock_sock(sk);
	if(!(tp->trickles_opt & TCP_TRICKLES_ENABLE) &&
   13728:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1372b:	8b 80 ec 01 00 00    	mov    0x1ec(%eax),%eax
   13731:	83 e0 01             	and    $0x1,%eax
   13734:	85 c0                	test   %eax,%eax
   13736:	75 61                	jne    13799 <trickles_init_sock_impl+0xf4>
   13738:	8b 45 0c             	mov    0xc(%ebp),%eax
   1373b:	83 e0 01             	and    $0x1,%eax
   1373e:	85 c0                	test   %eax,%eax
   13740:	74 57                	je     13799 <trickles_init_sock_impl+0xf4>
	   val & TCP_TRICKLES_ENABLE) {
		if(val & TCP_TRICKLES_RSERVER) {
   13742:	8b 45 0c             	mov    0xc(%ebp),%eax
   13745:	83 e0 08             	and    $0x8,%eax
   13748:	85 c0                	test   %eax,%eax
   1374a:	74 1c                	je     13768 <trickles_init_sock_impl+0xc3>
			tp->t.testseq = 1;
   1374c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1374f:	c7 80 30 09 00 00 01 	movl   $0x1,0x930(%eax)
   13756:	00 00 00 
			sk->prot = &trickles_prot;
   13759:	8b 45 08             	mov    0x8(%ebp),%eax
   1375c:	c7 80 b8 00 00 00 00 	movl   $0x0,0xb8(%eax)
   13763:	00 00 00 
   13766:	eb 31                	jmp    13799 <trickles_init_sock_impl+0xf4>

		} else {
			sk->prot = &trickles_client_prot;
   13768:	8b 45 08             	mov    0x8(%ebp),%eax
   1376b:	c7 80 b8 00 00 00 00 	movl   $0x0,0xb8(%eax)
   13772:	00 00 00 
#if 0
			if(val & TCP_TRICKLES_BUFFERDISCARD) {
				sk->rcvbuf = 100000000;
			}
#endif
			/* remember clients so that we can clear timers */
			trickles_add_clientsock(sk);
   13775:	8b 45 08             	mov    0x8(%ebp),%eax
   13778:	89 04 24             	mov    %eax,(%esp,1)
   1377b:	e8 fc ff ff ff       	call   1377c <trickles_init_sock_impl+0xd7>

#ifdef RECORD_LOSS_EVENTS
#define EVENT_RECORD_LEN (8192)
			tp->t.events = kmalloc(EVENT_RECORD_LEN, GFP_ATOMIC);
			tp->t.eventsPos = 0;
			tp->t.eventsSize = EVENT_RECORD_LEN /
				sizeof(struct TricklesLossEvent);
			int i;
			for(i=0; i < tp->t.eventsSize; i++) {
				tp->t.events[i].valid = 0;
			}
#undef EVENT_RECORD_LEN
#endif // RECORD_LOSS_EVENTS

			tp->t.slowstart_timer.function = &slow_start_timer;
   13780:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   13783:	c7 80 58 09 00 00 00 	movl   $0x0,0x958(%eax)
   1378a:	00 00 00 
			tp->t.slowstart_timer.data = (long)sk;
   1378d:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   13790:	8b 45 08             	mov    0x8(%ebp),%eax
   13793:	89 82 54 09 00 00    	mov    %eax,0x954(%edx)
		}
	}
	tp->trickles_opt = val;
   13799:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1379c:	8b 55 0c             	mov    0xc(%ebp),%edx
   1379f:	89 90 ec 01 00 00    	mov    %edx,0x1ec(%eax)
	bh_unlock_sock(sk);
	lock_sock(sk);
   137a5:	ff 05 08 00 00 00    	incl   0x8
   137ab:	8b 45 08             	mov    0x8(%ebp),%eax
   137ae:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
   137b2:	74 0b                	je     137bf <trickles_init_sock_impl+0x11a>
   137b4:	8b 45 08             	mov    0x8(%ebp),%eax
   137b7:	89 04 24             	mov    %eax,(%esp,1)
   137ba:	e8 fc ff ff ff       	call   137bb <trickles_init_sock_impl+0x116>
   137bf:	8b 45 08             	mov    0x8(%ebp),%eax
   137c2:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
   137c9:	c7 45 f8 08 00 00 00 	movl   $0x8,0xfffffff8(%ebp)
   137d0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   137d3:	ff 08                	decl   (%eax)
   137d5:	83 38 00             	cmpl   $0x0,(%eax)
   137d8:	75 0d                	jne    137e7 <trickles_init_sock_impl+0x142>
   137da:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   137dd:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   137e1:	0f 85 d9 87 00 00    	jne    1bfc0 <.text.lock.tmalloc+0x50>
	local_bh_enable();
   137e7:	c7 45 f8 08 00 00 00 	movl   $0x8,0xfffffff8(%ebp)
   137ee:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   137f1:	ff 08                	decl   (%eax)
   137f3:	83 38 00             	cmpl   $0x0,(%eax)
   137f6:	75 0d                	jne    13805 <trickles_init_sock_impl+0x160>
   137f8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   137fb:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   137ff:	0f 85 cb 87 00 00    	jne    1bfd0 <.text.lock.tmalloc+0x60>
}
   13805:	c9                   	leave  
   13806:	c3                   	ret    

00013807 <trickles_sendmsg>:

#define IS_VALID_MSK(SK, MSK)						\
	({								\
		struct tcp_opt *_tp = 	&((SK)->tp_pinfo.af_tcp);	\
		IS_TRICKLES_SOCK_ADDR(_tp,(MSK)) && VALID_MSK_CTL((MSK)); \
	})

int trickles_sendmsg(struct sock *sk, struct msghdr *msg, int size) {
   13807:	55                   	push   %ebp
   13808:	89 e5                	mov    %esp,%ebp
   1380a:	83 ec 38             	sub    $0x38,%esp
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
   1380d:	8b 45 08             	mov    0x8(%ebp),%eax
   13810:	05 bc 00 00 00       	add    $0xbc,%eax
   13815:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	struct cminisock *msk;
	int tiovlen = msg->msg_iovlen;
   13818:	8b 45 0c             	mov    0xc(%ebp),%eax
   1381b:	8b 40 0c             	mov    0xc(%eax),%eax
   1381e:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	int rval = -EINVAL;
   13821:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)

	struct tiovec *tiov = (struct tiovec *)msg->msg_iov;
   13828:	8b 45 0c             	mov    0xc(%ebp),%eax
   1382b:	8b 40 08             	mov    0x8(%eax),%eax
   1382e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	struct cminisock_cmd *cmd = msg->msg_name;
   13831:	8b 45 0c             	mov    0xc(%ebp),%eax
   13834:	8b 00                	mov    (%eax),%eax
   13836:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)

	if(sizeof(*cmd) != msg->msg_namelen || (int)cmd->magic != TRICKLES_MAGIC) {
   13839:	8b 45 0c             	mov    0xc(%ebp),%eax
   1383c:	83 78 04 0c          	cmpl   $0xc,0x4(%eax)
   13840:	75 0d                	jne    1384f <trickles_sendmsg+0x48>
   13842:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   13845:	81 38 3d d3 ad ba    	cmpl   $0xbaadd33d,(%eax)
   1384b:	75 02                	jne    1384f <trickles_sendmsg+0x48>
   1384d:	eb 0c                	jmp    1385b <trickles_sendmsg+0x54>
		return -EINVAL;
   1384f:	c7 45 dc ea ff ff ff 	movl   $0xffffffea,0xffffffdc(%ebp)
   13856:	e9 9e 04 00 00       	jmp    13cf9 <trickles_sendmsg+0x4f2>
	}

	if(cmd->cmd == STARTRCV) {
   1385b:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1385e:	83 78 08 03          	cmpl   $0x3,0x8(%eax)
   13862:	75 18                	jne    1387c <trickles_sendmsg+0x75>
		printk(" StartRcv functionality deprecated\n");
   13864:	c7 04 24 a0 56 00 00 	movl   $0x56a0,(%esp,1)
   1386b:	e8 fc ff ff ff       	call   1386c <trickles_sendmsg+0x65>
		return -EINVAL;
   13870:	c7 45 dc ea ff ff ff 	movl   $0xffffffea,0xffffffdc(%ebp)
   13877:	e9 7d 04 00 00       	jmp    13cf9 <trickles_sendmsg+0x4f2>
	}
	if(!TRICKLES_USERAPI_CONFIGURED_TP(tp)) {
   1387c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1387f:	83 b8 d0 01 00 00 00 	cmpl   $0x0,0x1d0(%eax)
   13886:	75 0c                	jne    13894 <trickles_sendmsg+0x8d>
		return -EINVAL;
   13888:	c7 45 dc ea ff ff ff 	movl   $0xffffffea,0xffffffdc(%ebp)
   1388f:	e9 65 04 00 00       	jmp    13cf9 <trickles_sendmsg+0x4f2>
	}
	if(cmd->cmd == POLL) {
   13894:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   13897:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
   1389b:	0f 85 e4 00 00 00    	jne    13985 <trickles_sendmsg+0x17e>
		int res;
		lock_sock(sk);
   138a1:	ff 05 08 00 00 00    	incl   0x8
   138a7:	8b 45 08             	mov    0x8(%ebp),%eax
   138aa:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
   138ae:	74 0b                	je     138bb <trickles_sendmsg+0xb4>
   138b0:	8b 45 08             	mov    0x8(%ebp),%eax
   138b3:	89 04 24             	mov    %eax,(%esp,1)
   138b6:	e8 fc ff ff ff       	call   138b7 <trickles_sendmsg+0xb0>
   138bb:	8b 45 08             	mov    0x8(%ebp),%eax
   138be:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
   138c5:	c7 45 e0 08 00 00 00 	movl   $0x8,0xffffffe0(%ebp)
   138cc:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   138cf:	ff 08                	decl   (%eax)
   138d1:	83 38 00             	cmpl   $0x0,(%eax)
   138d4:	75 0d                	jne    138e3 <trickles_sendmsg+0xdc>
   138d6:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   138d9:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   138dd:	0f 85 fd 86 00 00    	jne    1bfe0 <.text.lock.tmalloc+0x70>
		if (skb_queue_len(&tp->ucopy.prequeue)) {
   138e3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   138e6:	83 c0 34             	add    $0x34,%eax
   138e9:	89 04 24             	mov    %eax,(%esp,1)
   138ec:	e8 e7 66 00 00       	call   19fd8 <skb_queue_len>
   138f1:	85 c0                	test   %eax,%eax
   138f3:	74 0b                	je     13900 <trickles_sendmsg+0xf9>
			tcp_prequeue_process(sk);
   138f5:	8b 45 08             	mov    0x8(%ebp),%eax
   138f8:	89 04 24             	mov    %eax,(%esp,1)
   138fb:	e8 64 f4 ff ff       	call   12d64 <tcp_prequeue_process>
		}
		res = trickles_poll(sk);
   13900:	8b 45 08             	mov    0x8(%ebp),%eax
   13903:	89 04 24             	mov    %eax,(%esp,1)
   13906:	e8 f3 03 00 00       	call   13cfe <trickles_poll>
   1390b:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
		release_sock(sk);
   1390e:	ff 05 08 00 00 00    	incl   0x8
   13914:	8b 45 08             	mov    0x8(%ebp),%eax
   13917:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   1391e:	74 0b                	je     1392b <trickles_sendmsg+0x124>
   13920:	8b 45 08             	mov    0x8(%ebp),%eax
   13923:	89 04 24             	mov    %eax,(%esp,1)
   13926:	e8 fc ff ff ff       	call   13927 <trickles_sendmsg+0x120>
   1392b:	8b 45 08             	mov    0x8(%ebp),%eax
   1392e:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   13935:	8b 45 08             	mov    0x8(%ebp),%eax
   13938:	83 c0 30             	add    $0x30,%eax
   1393b:	89 04 24             	mov    %eax,(%esp,1)
   1393e:	e8 9f 63 00 00       	call   19ce2 <waitqueue_active>
   13943:	85 c0                	test   %eax,%eax
   13945:	74 15                	je     1395c <trickles_sendmsg+0x155>
   13947:	8b 45 08             	mov    0x8(%ebp),%eax
   1394a:	83 c0 30             	add    $0x30,%eax
   1394d:	b9 01 00 00 00       	mov    $0x1,%ecx
   13952:	ba 03 00 00 00       	mov    $0x3,%edx
   13957:	e8 fc ff ff ff       	call   13958 <trickles_sendmsg+0x151>
   1395c:	c7 45 e0 08 00 00 00 	movl   $0x8,0xffffffe0(%ebp)
   13963:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   13966:	ff 08                	decl   (%eax)
   13968:	83 38 00             	cmpl   $0x0,(%eax)
   1396b:	75 0d                	jne    1397a <trickles_sendmsg+0x173>
   1396d:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   13970:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   13974:	0f 85 76 86 00 00    	jne    1bff0 <.text.lock.tmalloc+0x80>
		return res;
   1397a:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1397d:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
   13980:	e9 74 03 00 00       	jmp    13cf9 <trickles_sendmsg+0x4f2>
	}

	/* XXX: perhaps allow multiple sockets to be passed down at a time */
	msk = cmd->socket;
   13985:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   13988:	8b 40 04             	mov    0x4(%eax),%eax
   1398b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

	/* TODO: try to get rid of this silly lock ? */
	lock_sock(sk);
   1398e:	ff 05 08 00 00 00    	incl   0x8
   13994:	8b 45 08             	mov    0x8(%ebp),%eax
   13997:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
   1399b:	74 0b                	je     139a8 <trickles_sendmsg+0x1a1>
   1399d:	8b 45 08             	mov    0x8(%ebp),%eax
   139a0:	89 04 24             	mov    %eax,(%esp,1)
   139a3:	e8 fc ff ff ff       	call   139a4 <trickles_sendmsg+0x19d>
   139a8:	8b 45 08             	mov    0x8(%ebp),%eax
   139ab:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
   139b2:	c7 45 e0 08 00 00 00 	movl   $0x8,0xffffffe0(%ebp)
   139b9:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   139bc:	ff 08                	decl   (%eax)
   139be:	83 38 00             	cmpl   $0x0,(%eax)
   139c1:	75 0d                	jne    139d0 <trickles_sendmsg+0x1c9>
   139c3:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   139c6:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   139ca:	0f 85 30 86 00 00    	jne    1c000 <.text.lock.tmalloc+0x90>
	if(!TRICKLES_USERAPI_CONFIGURED_TP(tp)) {
   139d0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   139d3:	83 b8 d0 01 00 00 00 	cmpl   $0x0,0x1d0(%eax)
   139da:	0f 85 88 00 00 00    	jne    13a68 <trickles_sendmsg+0x261>
		printk("Socket not configured\n");
   139e0:	c7 04 24 c4 56 00 00 	movl   $0x56c4,(%esp,1)
   139e7:	e8 fc ff ff ff       	call   139e8 <trickles_sendmsg+0x1e1>
		rval = -EINVAL;
   139ec:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
		release_sock(sk);
   139f3:	ff 05 08 00 00 00    	incl   0x8
   139f9:	8b 45 08             	mov    0x8(%ebp),%eax
   139fc:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   13a03:	74 0b                	je     13a10 <trickles_sendmsg+0x209>
   13a05:	8b 45 08             	mov    0x8(%ebp),%eax
   13a08:	89 04 24             	mov    %eax,(%esp,1)
   13a0b:	e8 fc ff ff ff       	call   13a0c <trickles_sendmsg+0x205>
   13a10:	8b 45 08             	mov    0x8(%ebp),%eax
   13a13:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   13a1a:	8b 45 08             	mov    0x8(%ebp),%eax
   13a1d:	83 c0 30             	add    $0x30,%eax
   13a20:	89 04 24             	mov    %eax,(%esp,1)
   13a23:	e8 ba 62 00 00       	call   19ce2 <waitqueue_active>
   13a28:	85 c0                	test   %eax,%eax
   13a2a:	74 15                	je     13a41 <trickles_sendmsg+0x23a>
   13a2c:	8b 45 08             	mov    0x8(%ebp),%eax
   13a2f:	83 c0 30             	add    $0x30,%eax
   13a32:	b9 01 00 00 00       	mov    $0x1,%ecx
   13a37:	ba 03 00 00 00       	mov    $0x3,%edx
   13a3c:	e8 fc ff ff ff       	call   13a3d <trickles_sendmsg+0x236>
   13a41:	c7 45 e0 08 00 00 00 	movl   $0x8,0xffffffe0(%ebp)
   13a48:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   13a4b:	ff 08                	decl   (%eax)
   13a4d:	83 38 00             	cmpl   $0x0,(%eax)
   13a50:	0f 85 9d 02 00 00    	jne    13cf3 <trickles_sendmsg+0x4ec>
   13a56:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   13a59:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   13a5d:	0f 85 ad 85 00 00    	jne    1c010 <.text.lock.tmalloc+0xa0>
		goto out;
   13a63:	e9 8b 02 00 00       	jmp    13cf3 <trickles_sendmsg+0x4ec>
	}

	if(!IS_VALID_MSK(sk,msk)) {
   13a68:	8b 45 08             	mov    0x8(%ebp),%eax
   13a6b:	05 bc 00 00 00       	add    $0xbc,%eax
   13a70:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   13a73:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
   13a7a:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   13a7d:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
   13a83:	8b 50 0c             	mov    0xc(%eax),%edx
   13a86:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13a89:	89 c1                	mov    %eax,%ecx
   13a8b:	29 d1                	sub    %edx,%ecx
   13a8d:	89 ca                	mov    %ecx,%edx
   13a8f:	c1 ea 02             	shr    $0x2,%edx
   13a92:	b8 21 08 82 20       	mov    $0x20820821,%eax
   13a97:	f7 e2                	mul    %edx
   13a99:	c1 ea 03             	shr    $0x3,%edx
   13a9c:	89 d0                	mov    %edx,%eax
   13a9e:	c1 e0 06             	shl    $0x6,%eax
   13aa1:	29 d0                	sub    %edx,%eax
   13aa3:	c1 e0 02             	shl    $0x2,%eax
   13aa6:	29 c1                	sub    %eax,%ecx
   13aa8:	89 c8                	mov    %ecx,%eax
   13aaa:	85 c0                	test   %eax,%eax
   13aac:	75 42                	jne    13af0 <trickles_sendmsg+0x2e9>
   13aae:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   13ab1:	8b 90 cc 01 00 00    	mov    0x1cc(%eax),%edx
   13ab7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13aba:	3b 42 0c             	cmp    0xc(%edx),%eax
   13abd:	72 31                	jb     13af0 <trickles_sendmsg+0x2e9>
   13abf:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13ac2:	05 fc 00 00 00       	add    $0xfc,%eax
   13ac7:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   13aca:	8b 92 cc 01 00 00    	mov    0x1cc(%edx),%edx
   13ad0:	3b 42 10             	cmp    0x10(%edx),%eax
   13ad3:	77 1b                	ja     13af0 <trickles_sendmsg+0x2e9>
   13ad5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13ad8:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
   13adc:	74 0b                	je     13ae9 <trickles_sendmsg+0x2e2>
   13ade:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13ae1:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
   13ae5:	74 02                	je     13ae9 <trickles_sendmsg+0x2e2>
   13ae7:	eb 07                	jmp    13af0 <trickles_sendmsg+0x2e9>
   13ae9:	c7 45 d8 01 00 00 00 	movl   $0x1,0xffffffd8(%ebp)
   13af0:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
   13af4:	0f 85 17 01 00 00    	jne    13c11 <trickles_sendmsg+0x40a>
		printk("bad minisocket %d %d\n", !IS_TRICKLES_SOCK_ADDR(tp,msk), !(VALID_MSK_CTL(msk)));
   13afa:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
   13b01:	00 
   13b02:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13b05:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
   13b09:	74 11                	je     13b1c <trickles_sendmsg+0x315>
   13b0b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13b0e:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
   13b12:	74 08                	je     13b1c <trickles_sendmsg+0x315>
   13b14:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp,1)
   13b1b:	00 
   13b1c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
   13b23:	00 
   13b24:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   13b27:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
   13b2d:	8b 50 0c             	mov    0xc(%eax),%edx
   13b30:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13b33:	89 c1                	mov    %eax,%ecx
   13b35:	29 d1                	sub    %edx,%ecx
   13b37:	89 ca                	mov    %ecx,%edx
   13b39:	c1 ea 02             	shr    $0x2,%edx
   13b3c:	b8 21 08 82 20       	mov    $0x20820821,%eax
   13b41:	f7 e2                	mul    %edx
   13b43:	c1 ea 03             	shr    $0x3,%edx
   13b46:	89 d0                	mov    %edx,%eax
   13b48:	c1 e0 06             	shl    $0x6,%eax
   13b4b:	29 d0                	sub    %edx,%eax
   13b4d:	c1 e0 02             	shl    $0x2,%eax
   13b50:	29 c1                	sub    %eax,%ecx
   13b52:	89 c8                	mov    %ecx,%eax
   13b54:	85 c0                	test   %eax,%eax
   13b56:	75 29                	jne    13b81 <trickles_sendmsg+0x37a>
   13b58:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   13b5b:	8b 90 cc 01 00 00    	mov    0x1cc(%eax),%edx
   13b61:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13b64:	3b 42 0c             	cmp    0xc(%edx),%eax
   13b67:	72 18                	jb     13b81 <trickles_sendmsg+0x37a>
   13b69:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13b6c:	05 fc 00 00 00       	add    $0xfc,%eax
   13b71:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   13b74:	8b 92 cc 01 00 00    	mov    0x1cc(%edx),%edx
   13b7a:	3b 42 10             	cmp    0x10(%edx),%eax
   13b7d:	77 02                	ja     13b81 <trickles_sendmsg+0x37a>
   13b7f:	eb 08                	jmp    13b89 <trickles_sendmsg+0x382>
   13b81:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
   13b88:	00 
   13b89:	c7 04 24 db 56 00 00 	movl   $0x56db,(%esp,1)
   13b90:	e8 fc ff ff ff       	call   13b91 <trickles_sendmsg+0x38a>
		rval = -EINVAL;
   13b95:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
		release_sock(sk);
   13b9c:	ff 05 08 00 00 00    	incl   0x8
   13ba2:	8b 45 08             	mov    0x8(%ebp),%eax
   13ba5:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   13bac:	74 0b                	je     13bb9 <trickles_sendmsg+0x3b2>
   13bae:	8b 45 08             	mov    0x8(%ebp),%eax
   13bb1:	89 04 24             	mov    %eax,(%esp,1)
   13bb4:	e8 fc ff ff ff       	call   13bb5 <trickles_sendmsg+0x3ae>
   13bb9:	8b 45 08             	mov    0x8(%ebp),%eax
   13bbc:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   13bc3:	8b 45 08             	mov    0x8(%ebp),%eax
   13bc6:	83 c0 30             	add    $0x30,%eax
   13bc9:	89 04 24             	mov    %eax,(%esp,1)
   13bcc:	e8 11 61 00 00       	call   19ce2 <waitqueue_active>
   13bd1:	85 c0                	test   %eax,%eax
   13bd3:	74 15                	je     13bea <trickles_sendmsg+0x3e3>
   13bd5:	8b 45 08             	mov    0x8(%ebp),%eax
   13bd8:	83 c0 30             	add    $0x30,%eax
   13bdb:	b9 01 00 00 00       	mov    $0x1,%ecx
   13be0:	ba 03 00 00 00       	mov    $0x3,%edx
   13be5:	e8 fc ff ff ff       	call   13be6 <trickles_sendmsg+0x3df>
   13bea:	c7 45 e0 08 00 00 00 	movl   $0x8,0xffffffe0(%ebp)
   13bf1:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   13bf4:	ff 08                	decl   (%eax)
   13bf6:	83 38 00             	cmpl   $0x0,(%eax)
   13bf9:	0f 85 f4 00 00 00    	jne    13cf3 <trickles_sendmsg+0x4ec>
   13bff:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   13c02:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   13c06:	0f 85 14 84 00 00    	jne    1c020 <.text.lock.tmalloc+0xb0>
		goto out;
   13c0c:	e9 e2 00 00 00       	jmp    13cf3 <trickles_sendmsg+0x4ec>
	}
	free_trickles_msk(sk,msk);
   13c11:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13c14:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   13c18:	8b 45 08             	mov    0x8(%ebp),%eax
   13c1b:	89 04 24             	mov    %eax,(%esp,1)
   13c1e:	e8 ea eb ff ff       	call   1280d <free_trickles_msk>

	if(cmd->cmd == DROP) {
   13c23:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   13c26:	83 78 08 02          	cmpl   $0x2,0x8(%eax)
   13c2a:	75 1b                	jne    13c47 <trickles_sendmsg+0x440>
		rval = 0;
   13c2c:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
		free_trickles_msk_finish(sk,msk);
   13c33:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13c36:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   13c3a:	8b 45 08             	mov    0x8(%ebp),%eax
   13c3d:	89 04 24             	mov    %eax,(%esp,1)
   13c40:	e8 66 ec ff ff       	call   128ab <free_trickles_msk_finish>
		goto out_put;
   13c45:	eb 40                	jmp    13c87 <trickles_sendmsg+0x480>
	}

	if(cmd->cmd != PROCESS) {
   13c47:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   13c4a:	83 78 08 01          	cmpl   $0x1,0x8(%eax)
   13c4e:	74 14                	je     13c64 <trickles_sendmsg+0x45d>
		free_trickles_msk_finish(sk,msk);
   13c50:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13c53:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   13c57:	8b 45 08             	mov    0x8(%ebp),%eax
   13c5a:	89 04 24             	mov    %eax,(%esp,1)
   13c5d:	e8 49 ec ff ff       	call   128ab <free_trickles_msk_finish>
		goto out_put;
   13c62:	eb 23                	jmp    13c87 <trickles_sendmsg+0x480>
	}

	rval = trickles_do_sendmsg_tiov(sk,msk,tiov,tiovlen);
   13c64:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   13c67:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   13c6b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   13c6e:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   13c72:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13c75:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   13c79:	8b 45 08             	mov    0x8(%ebp),%eax
   13c7c:	89 04 24             	mov    %eax,(%esp,1)
   13c7f:	e8 8c 71 00 00       	call   1ae10 <trickles_do_sendmsg_tiov>
   13c84:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

 out_put:
	release_sock(sk);
   13c87:	ff 05 08 00 00 00    	incl   0x8
   13c8d:	8b 45 08             	mov    0x8(%ebp),%eax
   13c90:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   13c97:	74 0b                	je     13ca4 <trickles_sendmsg+0x49d>
   13c99:	8b 45 08             	mov    0x8(%ebp),%eax
   13c9c:	89 04 24             	mov    %eax,(%esp,1)
   13c9f:	e8 fc ff ff ff       	call   13ca0 <trickles_sendmsg+0x499>
   13ca4:	8b 45 08             	mov    0x8(%ebp),%eax
   13ca7:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   13cae:	8b 45 08             	mov    0x8(%ebp),%eax
   13cb1:	83 c0 30             	add    $0x30,%eax
   13cb4:	89 04 24             	mov    %eax,(%esp,1)
   13cb7:	e8 26 60 00 00       	call   19ce2 <waitqueue_active>
   13cbc:	85 c0                	test   %eax,%eax
   13cbe:	74 15                	je     13cd5 <trickles_sendmsg+0x4ce>
   13cc0:	8b 45 08             	mov    0x8(%ebp),%eax
   13cc3:	83 c0 30             	add    $0x30,%eax
   13cc6:	b9 01 00 00 00       	mov    $0x1,%ecx
   13ccb:	ba 03 00 00 00       	mov    $0x3,%edx
   13cd0:	e8 fc ff ff ff       	call   13cd1 <trickles_sendmsg+0x4ca>
   13cd5:	c7 45 e0 08 00 00 00 	movl   $0x8,0xffffffe0(%ebp)
   13cdc:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   13cdf:	ff 08                	decl   (%eax)
   13ce1:	83 38 00             	cmpl   $0x0,(%eax)
   13ce4:	75 0d                	jne    13cf3 <trickles_sendmsg+0x4ec>
   13ce6:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   13ce9:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   13ced:	0f 85 3d 83 00 00    	jne    1c030 <.text.lock.tmalloc+0xc0>
 out:
	return rval;
   13cf3:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   13cf6:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
}
   13cf9:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   13cfc:	c9                   	leave  
   13cfd:	c3                   	ret    

00013cfe <trickles_poll>:

static int trickles_poll(struct sock *sk) {
   13cfe:	55                   	push   %ebp
   13cff:	89 e5                	mov    %esp,%ebp
   13d01:	83 ec 4c             	sub    $0x4c,%esp
	int err = 0;
   13d04:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
	/* Algorithm: perform sleep, then return when done */
	//struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);

	/* don't cache a pointer, since the configuration could change
	   under us */

#define NO_EVENT()  (trickles_sock_poll_impl(NULL, &sock, NULL) == 0)

	struct socket sock;
	sock.sk = sk;
   13d0b:	8b 45 08             	mov    0x8(%ebp),%eax
   13d0e:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
	if(NO_EVENT()) {
   13d11:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
   13d18:	00 
   13d19:	8d 45 cc             	lea    0xffffffcc(%ebp),%eax
   13d1c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   13d20:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   13d27:	e8 fc ff ff ff       	call   13d28 <trickles_poll+0x2a>
   13d2c:	85 c0                	test   %eax,%eax
   13d2e:	0f 85 29 01 00 00    	jne    13e5d <trickles_poll+0x15f>
#define MAX_TIMEOUT (100*HZ)
		int timeout = MAX_TIMEOUT;
   13d34:	c7 45 c8 10 27 00 00 	movl   $0x2710,0xffffffc8(%ebp)
		int in_time = jiffies;
   13d3b:	a1 00 00 00 00       	mov    0x0,%eax
   13d40:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
		release_sock(sk);
   13d43:	ff 05 08 00 00 00    	incl   0x8
   13d49:	8b 45 08             	mov    0x8(%ebp),%eax
   13d4c:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   13d53:	74 0b                	je     13d60 <trickles_poll+0x62>
   13d55:	8b 45 08             	mov    0x8(%ebp),%eax
   13d58:	89 04 24             	mov    %eax,(%esp,1)
   13d5b:	e8 fc ff ff ff       	call   13d5c <trickles_poll+0x5e>
   13d60:	8b 45 08             	mov    0x8(%ebp),%eax
   13d63:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   13d6a:	8b 45 08             	mov    0x8(%ebp),%eax
   13d6d:	83 c0 30             	add    $0x30,%eax
   13d70:	89 04 24             	mov    %eax,(%esp,1)
   13d73:	e8 6a 5f 00 00       	call   19ce2 <waitqueue_active>
   13d78:	85 c0                	test   %eax,%eax
   13d7a:	74 15                	je     13d91 <trickles_poll+0x93>
   13d7c:	8b 45 08             	mov    0x8(%ebp),%eax
   13d7f:	83 c0 30             	add    $0x30,%eax
   13d82:	b9 01 00 00 00       	mov    $0x1,%ecx
   13d87:	ba 03 00 00 00       	mov    $0x3,%edx
   13d8c:	e8 fc ff ff ff       	call   13d8d <trickles_poll+0x8f>
   13d91:	c7 45 c0 08 00 00 00 	movl   $0x8,0xffffffc0(%ebp)
   13d98:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
   13d9b:	ff 08                	decl   (%eax)
   13d9d:	83 38 00             	cmpl   $0x0,(%eax)
   13da0:	75 0d                	jne    13daf <trickles_poll+0xb1>
   13da2:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
   13da5:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   13da9:	0f 85 91 82 00 00    	jne    1c040 <.text.lock.tmalloc+0xd0>
		interruptible_sleep_on_timeout(sk->sleep, timeout);
   13daf:	8b 55 c8             	mov    0xffffffc8(%ebp),%edx
   13db2:	8b 45 08             	mov    0x8(%ebp),%eax
   13db5:	8b 40 3c             	mov    0x3c(%eax),%eax
   13db8:	e8 fc ff ff ff       	call   13db9 <trickles_poll+0xbb>
		lock_sock(sk);
   13dbd:	ff 05 08 00 00 00    	incl   0x8
   13dc3:	8b 45 08             	mov    0x8(%ebp),%eax
   13dc6:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
   13dca:	74 0b                	je     13dd7 <trickles_poll+0xd9>
   13dcc:	8b 45 08             	mov    0x8(%ebp),%eax
   13dcf:	89 04 24             	mov    %eax,(%esp,1)
   13dd2:	e8 fc ff ff ff       	call   13dd3 <trickles_poll+0xd5>
   13dd7:	8b 45 08             	mov    0x8(%ebp),%eax
   13dda:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
   13de1:	c7 45 c0 08 00 00 00 	movl   $0x8,0xffffffc0(%ebp)
   13de8:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
   13deb:	ff 08                	decl   (%eax)
   13ded:	83 38 00             	cmpl   $0x0,(%eax)
   13df0:	75 0d                	jne    13dff <trickles_poll+0x101>
   13df2:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
   13df5:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   13df9:	0f 85 51 82 00 00    	jne    1c050 <.text.lock.tmalloc+0xe0>
		if(!NO_EVENT()) {
   13dff:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
   13e06:	00 
   13e07:	8d 45 cc             	lea    0xffffffcc(%ebp),%eax
   13e0a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   13e0e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   13e15:	e8 fc ff ff ff       	call   13e16 <trickles_poll+0x118>
   13e1a:	85 c0                	test   %eax,%eax
   13e1c:	74 20                	je     13e3e <trickles_poll+0x140>
			if(userapi_time_spew)
   13e1e:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
   13e25:	74 36                	je     13e5d <trickles_poll+0x15f>
				printk("wakeup time (user): %lu\n", jiffies);
   13e27:	a1 00 00 00 00       	mov    0x0,%eax
   13e2c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   13e30:	c7 04 24 f1 56 00 00 	movl   $0x56f1,(%esp,1)
   13e37:	e8 fc ff ff ff       	call   13e38 <trickles_poll+0x13a>
   13e3c:	eb 1f                	jmp    13e5d <trickles_poll+0x15f>
		} else {
			printk("timeout expired %d\n", jiffies - in_time);
   13e3e:	a1 00 00 00 00       	mov    0x0,%eax
   13e43:	2b 45 c4             	sub    0xffffffc4(%ebp),%eax
   13e46:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   13e4a:	c7 04 24 0a 57 00 00 	movl   $0x570a,(%esp,1)
   13e51:	e8 fc ff ff ff       	call   13e52 <trickles_poll+0x154>
			err = -EAGAIN;
   13e56:	c7 45 fc f5 ff ff ff 	movl   $0xfffffff5,0xfffffffc(%ebp)
		}
	}

	goto out; // suppress warning
 out:
	return err;
   13e5d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
#undef NO_EVENT
}
   13e60:	c9                   	leave  
   13e61:	c3                   	ret    

00013e62 <trickles_sock_poll_impl>:

int trickles_sock_poll_impl(struct file * file, struct socket *sock, poll_table *wait) {
   13e62:	55                   	push   %ebp
   13e63:	89 e5                	mov    %esp,%ebp
   13e65:	83 ec 18             	sub    $0x18,%esp
    struct sock *sk = sock->sk;
   13e68:	8b 45 0c             	mov    0xc(%ebp),%eax
   13e6b:	8b 40 18             	mov    0x18(%eax),%eax
   13e6e:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
    struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
   13e71:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   13e74:	05 bc 00 00 00       	add    $0xbc,%eax
   13e79:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
    extern int gUpdateSincePollTotal;
    extern int gUpdateSincePollCount;
    int mask = 0;
   13e7c:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
    if(TRICKLES_USERAPI_CONFIGURED_TP(tp)) {
   13e83:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13e86:	83 b8 d0 01 00 00 00 	cmpl   $0x0,0x1d0(%eax)
   13e8d:	0f 84 9a 00 00 00    	je     13f2d <trickles_sock_poll_impl+0xcb>
	    int poll_value = atomic_read(&tp->cminisock_api_config.cfg.ctl->update_since_poll);
   13e93:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13e96:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
   13e9c:	83 c0 3c             	add    $0x3c,%eax
   13e9f:	8b 00                	mov    (%eax),%eax
   13ea1:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	    if((!(tp->trickles_opt & TCP_TRICKLES_EDGE)  && !empty(&tp->cminisock_api_config.cfg.ctl->msk_eventlist)) ||
   13ea4:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   13ea7:	b0 80                	mov    $0x80,%al
   13ea9:	22 82 ec 01 00 00    	and    0x1ec(%edx),%al
   13eaf:	84 c0                	test   %al,%al
   13eb1:	75 1a                	jne    13ecd <trickles_sock_poll_impl+0x6b>
   13eb3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13eb6:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
   13ebc:	83 c0 28             	add    $0x28,%eax
   13ebf:	89 04 24             	mov    %eax,(%esp,1)
   13ec2:	e8 54 66 00 00       	call   1a51b <empty>
   13ec7:	85 c0                	test   %eax,%eax
   13ec9:	75 02                	jne    13ecd <trickles_sock_poll_impl+0x6b>
   13ecb:	eb 2f                	jmp    13efc <trickles_sock_poll_impl+0x9a>
   13ecd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13ed0:	b2 80                	mov    $0x80,%dl
   13ed2:	22 90 ec 01 00 00    	and    0x1ec(%eax),%dl
   13ed8:	88 d0                	mov    %dl,%al
   13eda:	84 c0                	test   %al,%al
   13edc:	74 4f                	je     13f2d <trickles_sock_poll_impl+0xcb>
   13ede:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
   13ee2:	7e 49                	jle    13f2d <trickles_sock_poll_impl+0xcb>
   13ee4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13ee7:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
   13eed:	83 c0 28             	add    $0x28,%eax
   13ef0:	89 04 24             	mov    %eax,(%esp,1)
   13ef3:	e8 23 66 00 00       	call   1a51b <empty>
   13ef8:	85 c0                	test   %eax,%eax
   13efa:	75 31                	jne    13f2d <trickles_sock_poll_impl+0xcb>
	       ((tp->trickles_opt & TCP_TRICKLES_EDGE) &&
		poll_value > 0 &&
		!empty(&tp->cminisock_api_config.cfg.ctl->msk_eventlist))) {
		    mask = POLLIN;
   13efc:	c7 45 f4 01 00 00 00 	movl   $0x1,0xfffffff4(%ebp)
		    gUpdateSincePollTotal += poll_value;
   13f03:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   13f06:	01 05 00 00 00 00    	add    %eax,0x0
		    gUpdateSincePollCount++;
   13f0c:	ff 05 00 00 00 00    	incl   0x0
		    atomic_sub(poll_value, &tp->cminisock_api_config.cfg.ctl->update_since_poll);
   13f12:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13f15:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
   13f1b:	83 c0 3c             	add    $0x3c,%eax
   13f1e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   13f22:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   13f25:	89 04 24             	mov    %eax,(%esp,1)
   13f28:	e8 db 5d 00 00       	call   19d08 <atomic_sub>
	    }
    }
    return mask;
   13f2d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
}
   13f30:	c9                   	leave  
   13f31:	c3                   	ret    

00013f32 <vfree_helper>:

/*
 *
 * MMAP support
 *
 */

void vfree_helper(void *ptr) {
   13f32:	55                   	push   %ebp
   13f33:	89 e5                	mov    %esp,%ebp
   13f35:	83 ec 04             	sub    $0x4,%esp
	printk("Delayed deallocation\n");
   13f38:	c7 04 24 1e 57 00 00 	movl   $0x571e,(%esp,1)
   13f3f:	e8 fc ff ff ff       	call   13f40 <vfree_helper+0xe>
	vfree(ptr);
   13f44:	8b 45 08             	mov    0x8(%ebp),%eax
   13f47:	89 04 24             	mov    %eax,(%esp,1)
   13f4a:	e8 fc ff ff ff       	call   13f4b <vfree_helper+0x19>
}
   13f4f:	c9                   	leave  
   13f50:	c3                   	ret    

00013f51 <trickles_vma_nopage>:

static struct page * trickles_vma_nopage(struct vm_area_struct * area, unsigned long address, int unused) {
   13f51:	55                   	push   %ebp
   13f52:	89 e5                	mov    %esp,%ebp
   13f54:	83 ec 18             	sub    $0x18,%esp
	unsigned long offset;
	struct page *page;
	struct trickles_kconfig *api_config = (struct trickles_kconfig*)area->vm_private_data;
   13f57:	8b 45 08             	mov    0x8(%ebp),%eax
   13f5a:	8b 40 40             	mov    0x40(%eax),%eax
   13f5d:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	if(api_config == NULL) return NULL;
   13f60:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
   13f64:	75 0c                	jne    13f72 <trickles_vma_nopage+0x21>
   13f66:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
   13f6d:	e9 86 00 00 00       	jmp    13ff8 <trickles_vma_nopage+0xa7>

	void *base = api_config->cfg.ctl->ro_base;
   13f72:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   13f75:	8b 40 04             	mov    0x4(%eax),%eax
   13f78:	8b 40 18             	mov    0x18(%eax),%eax
   13f7b:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	offset = address - (unsigned long)area->vm_start;
   13f7e:	8b 45 08             	mov    0x8(%ebp),%eax
   13f81:	8b 50 04             	mov    0x4(%eax),%edx
   13f84:	8b 45 0c             	mov    0xc(%ebp),%eax
   13f87:	29 d0                	sub    %edx,%eax
   13f89:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	if(offset >= api_config->cfg.ctl->ro_len) {
   13f8c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   13f8f:	8b 50 04             	mov    0x4(%eax),%edx
   13f92:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   13f95:	3b 42 24             	cmp    0x24(%edx),%eax
   13f98:	72 15                	jb     13faf <trickles_vma_nopage+0x5e>
		printk("error, vm_nopage offset >= ro_len\n");
   13f9a:	c7 04 24 40 57 00 00 	movl   $0x5740,(%esp,1)
   13fa1:	e8 fc ff ff ff       	call   13fa2 <trickles_vma_nopage+0x51>
		return NULL;
   13fa6:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
   13fad:	eb 49                	jmp    13ff8 <trickles_vma_nopage+0xa7>
	}
	page = virt_to_page(virt_to_kseg((char *)base + offset));
   13faf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   13fb2:	03 45 f0             	add    0xfffffff0(%ebp),%eax
   13fb5:	89 04 24             	mov    %eax,(%esp,1)
   13fb8:	e8 1d eb ff ff       	call   12ada <virt_to_kseg>
   13fbd:	05 00 00 00 40       	add    $0x40000000,%eax
   13fc2:	89 c2                	mov    %eax,%edx
   13fc4:	c1 ea 0c             	shr    $0xc,%edx
   13fc7:	89 d0                	mov    %edx,%eax
   13fc9:	c1 e0 02             	shl    $0x2,%eax
   13fcc:	01 d0                	add    %edx,%eax
   13fce:	01 c0                	add    %eax,%eax
   13fd0:	01 d0                	add    %edx,%eax
   13fd2:	c1 e0 02             	shl    $0x2,%eax
   13fd5:	03 05 00 00 00 00    	add    0x0,%eax
   13fdb:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	if(page)
   13fde:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
   13fe2:	74 0e                	je     13ff2 <trickles_vma_nopage+0xa1>
		get_page(page);
   13fe4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13fe7:	83 c0 14             	add    $0x14,%eax
   13fea:	89 04 24             	mov    %eax,(%esp,1)
   13fed:	e8 26 5d 00 00       	call   19d18 <atomic_inc>
	return page;
   13ff2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   13ff5:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
}
   13ff8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   13ffb:	c9                   	leave  
   13ffc:	c3                   	ret    

00013ffd <cminisock_config_pipe_impl>:

struct vm_operations_struct trickles_vm_ops = {
	nopage: trickles_vma_nopage,
	open:  NULL,
	close: NULL
};

int cminisock_config_pipe_impl(struct sock *sk, char *optdata, int optlen, int direction) {
   13ffd:	55                   	push   %ebp
   13ffe:	89 e5                	mov    %esp,%ebp
   14000:	53                   	push   %ebx
   14001:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
   14007:	8b 45 08             	mov    0x8(%ebp),%eax
   1400a:	05 bc 00 00 00       	add    $0xbc,%eax
   1400f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	struct trickles_config new_config;
	struct trickles_mmap_ctl *ctl;
	struct alloc_head_list *head;
	unsigned int mmap_len;
	int error;
	struct cminisock *msk;

	if(direction == CMINISOCK_IN) {
   14012:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   14016:	0f 85 e9 05 00 00    	jne    14605 <cminisock_config_pipe_impl+0x608>
		unsigned minisock_len;
		/* big socket lock already acquired; however, we might need to sleep & hold off if a transaction is pending */
		/* 1) Sleep until transaction complete
		   2) Perform a vmalloc
		   3) Split the new area into read-only and read-write sections */
		while(tp->cminisock_api_config.pending_delivery) {
   1401c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1401f:	83 b8 e8 01 00 00 00 	cmpl   $0x0,0x1e8(%eax)
   14026:	75 05                	jne    1402d <cminisock_config_pipe_impl+0x30>
   14028:	e9 e0 00 00 00       	jmp    1410d <cminisock_config_pipe_impl+0x110>
			int timeout = HZ/4;
   1402d:	c7 45 cc 19 00 00 00 	movl   $0x19,0xffffffcc(%ebp)
			printk("config loop\n");
   14034:	c7 04 24 63 57 00 00 	movl   $0x5763,(%esp,1)
   1403b:	e8 fc ff ff ff       	call   1403c <cminisock_config_pipe_impl+0x3f>
			__set_task_state(current, TASK_INTERRUPTIBLE);
   14040:	e8 fa 5e 00 00       	call   19f3f <get_current>
   14045:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

			release_sock(sk);
   1404b:	ff 05 08 00 00 00    	incl   0x8
   14051:	8b 45 08             	mov    0x8(%ebp),%eax
   14054:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   1405b:	74 0b                	je     14068 <cminisock_config_pipe_impl+0x6b>
   1405d:	8b 45 08             	mov    0x8(%ebp),%eax
   14060:	89 04 24             	mov    %eax,(%esp,1)
   14063:	e8 fc ff ff ff       	call   14064 <cminisock_config_pipe_impl+0x67>
   14068:	8b 45 08             	mov    0x8(%ebp),%eax
   1406b:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   14072:	8b 45 08             	mov    0x8(%ebp),%eax
   14075:	83 c0 30             	add    $0x30,%eax
   14078:	89 04 24             	mov    %eax,(%esp,1)
   1407b:	e8 62 5c 00 00       	call   19ce2 <waitqueue_active>
   14080:	85 c0                	test   %eax,%eax
   14082:	74 15                	je     14099 <cminisock_config_pipe_impl+0x9c>
   14084:	8b 45 08             	mov    0x8(%ebp),%eax
   14087:	83 c0 30             	add    $0x30,%eax
   1408a:	b9 01 00 00 00       	mov    $0x1,%ecx
   1408f:	ba 03 00 00 00       	mov    $0x3,%edx
   14094:	e8 fc ff ff ff       	call   14095 <cminisock_config_pipe_impl+0x98>
   14099:	c7 45 c8 08 00 00 00 	movl   $0x8,0xffffffc8(%ebp)
   140a0:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   140a3:	ff 08                	decl   (%eax)
   140a5:	83 38 00             	cmpl   $0x0,(%eax)
   140a8:	75 0d                	jne    140b7 <cminisock_config_pipe_impl+0xba>
   140aa:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   140ad:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   140b1:	0f 85 a9 7f 00 00    	jne    1c060 <.text.lock.tmalloc+0xf0>
			timeout = schedule_timeout(timeout);
   140b7:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
   140ba:	e8 fc ff ff ff       	call   140bb <cminisock_config_pipe_impl+0xbe>
   140bf:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
			lock_sock(sk);
   140c2:	ff 05 08 00 00 00    	incl   0x8
   140c8:	8b 45 08             	mov    0x8(%ebp),%eax
   140cb:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
   140cf:	74 0b                	je     140dc <cminisock_config_pipe_impl+0xdf>
   140d1:	8b 45 08             	mov    0x8(%ebp),%eax
   140d4:	89 04 24             	mov    %eax,(%esp,1)
   140d7:	e8 fc ff ff ff       	call   140d8 <cminisock_config_pipe_impl+0xdb>
   140dc:	8b 45 08             	mov    0x8(%ebp),%eax
   140df:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
   140e6:	c7 45 c8 08 00 00 00 	movl   $0x8,0xffffffc8(%ebp)
   140ed:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   140f0:	ff 08                	decl   (%eax)
   140f2:	83 38 00             	cmpl   $0x0,(%eax)
   140f5:	0f 85 21 ff ff ff    	jne    1401c <cminisock_config_pipe_impl+0x1f>
   140fb:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   140fe:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   14102:	0f 85 68 7f 00 00    	jne    1c070 <.text.lock.tmalloc+0x100>
   14108:	e9 0f ff ff ff       	jmp    1401c <cminisock_config_pipe_impl+0x1f>

		}
		__set_task_state(current, TASK_RUNNING);
   1410d:	e8 2d 5e 00 00       	call   19f3f <get_current>
   14112:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

		if(optlen != sizeof(new_config)) {
   14118:	83 7d 10 0c          	cmpl   $0xc,0x10(%ebp)
   1411c:	74 18                	je     14136 <cminisock_config_pipe_impl+0x139>
			printk("optlen != sizeof(new_config)\n");
   1411e:	c7 04 24 70 57 00 00 	movl   $0x5770,(%esp,1)
   14125:	e8 fc ff ff ff       	call   14126 <cminisock_config_pipe_impl+0x129>
			error = -EINVAL;
   1412a:	c7 45 d8 ea ff ff ff 	movl   $0xffffffea,0xffffffd8(%ebp)
			goto out;
   14131:	e9 d0 05 00 00       	jmp    14706 <cminisock_config_pipe_impl+0x709>
		}
		error = copy_from_user(&new_config,optdata,sizeof(new_config));
   14136:	c7 44 24 08 0c 00 00 	movl   $0xc,0x8(%esp,1)
   1413d:	00 
   1413e:	8b 45 0c             	mov    0xc(%ebp),%eax
   14141:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   14145:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   14148:	89 04 24             	mov    %eax,(%esp,1)
   1414b:	e8 49 61 00 00       	call   1a299 <__constant_copy_from_user>
   14150:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
		if(error) {
   14153:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
   14157:	74 18                	je     14171 <cminisock_config_pipe_impl+0x174>
		  printk("copy from user error\n");
   14159:	c7 04 24 8e 57 00 00 	movl   $0x578e,(%esp,1)
   14160:	e8 fc ff ff ff       	call   14161 <cminisock_config_pipe_impl+0x164>
			error = -EFAULT;
   14165:	c7 45 d8 f2 ff ff ff 	movl   $0xfffffff2,0xffffffd8(%ebp)
			goto out;
   1416c:	e9 95 05 00 00       	jmp    14706 <cminisock_config_pipe_impl+0x709>
		}

		if((mmap_len = new_config.mmap_len) > MAX_TRICKLES_SHMEM_SIZE) {
   14171:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   14174:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
   14177:	3d 00 00 00 10       	cmp    $0x10000000,%eax
   1417c:	76 18                	jbe    14196 <cminisock_config_pipe_impl+0x199>
			printk("requested mmap area too large\n");
   1417e:	c7 04 24 c0 57 00 00 	movl   $0x57c0,(%esp,1)
   14185:	e8 fc ff ff ff       	call   14186 <cminisock_config_pipe_impl+0x189>
			error = -EINVAL;
   1418a:	c7 45 d8 ea ff ff ff 	movl   $0xffffffea,0xffffffd8(%ebp)
			goto out;
   14191:	e9 70 05 00 00       	jmp    14706 <cminisock_config_pipe_impl+0x709>
		}
		new_config.mmap_base = vmalloc(mmap_len);
   14196:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   14199:	89 04 24             	mov    %eax,(%esp,1)
   1419c:	e8 a5 6b 00 00       	call   1ad46 <vmalloc>
   141a1:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
		printk("mmap_base: %p\n", new_config.mmap_base);
   141a4:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   141a7:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   141ab:	c7 04 24 df 57 00 00 	movl   $0x57df,(%esp,1)
   141b2:	e8 fc ff ff ff       	call   141b3 <cminisock_config_pipe_impl+0x1b6>
		if(new_config.mmap_base == NULL) {
   141b7:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
   141bb:	75 18                	jne    141d5 <cminisock_config_pipe_impl+0x1d8>
			printk("could not mmap enough memory\n");
   141bd:	c7 04 24 ee 57 00 00 	movl   $0x57ee,(%esp,1)
   141c4:	e8 fc ff ff ff       	call   141c5 <cminisock_config_pipe_impl+0x1c8>
			error = -ENOMEM;
   141c9:	c7 45 d8 f4 ff ff ff 	movl   $0xfffffff4,0xffffffd8(%ebp)
			goto out;
   141d0:	e9 31 05 00 00       	jmp    14706 <cminisock_config_pipe_impl+0x709>
		}

		/* Split the area */
		ctl = new_config.mmap_base;
   141d5:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   141d8:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
		new_config.ctl = ctl;
   141db:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   141de:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
		BUG_TRAP(sizeof(*ctl) + sizeof(struct work_struct) < PAGE_SIZE);
		ctl->ro_base = new_config.mmap_base;
   141e1:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   141e4:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   141e7:	89 42 18             	mov    %eax,0x18(%edx)
		ctl->ro_len = PAGE_ALIGN(mmap_len / 4);
   141ea:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   141ed:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   141f0:	c1 e8 02             	shr    $0x2,%eax
   141f3:	05 ff 0f 00 00       	add    $0xfff,%eax
   141f8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
   141fd:	89 42 24             	mov    %eax,0x24(%edx)
		ctl->ro_offs = (char*)ctl->ro_base - (char*)new_config.mmap_base;
   14200:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
   14203:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   14206:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   14209:	8b 40 18             	mov    0x18(%eax),%eax
   1420c:	29 d0                	sub    %edx,%eax
   1420e:	89 41 1c             	mov    %eax,0x1c(%ecx)
		ctl->rw_base = (__u8*)ctl->ro_base + ctl->ro_len;
   14211:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
   14214:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   14217:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1421a:	8b 40 24             	mov    0x24(%eax),%eax
   1421d:	03 42 18             	add    0x18(%edx),%eax
   14220:	89 01                	mov    %eax,(%ecx)
		ctl->rw_len = PAGE_ALIGN(mmap_len - ((char*)ctl->rw_base - (char*)new_config.mmap_base)) - PAGE_SIZE;
   14222:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
   14225:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   14228:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   1422b:	8b 00                	mov    (%eax),%eax
   1422d:	29 d0                	sub    %edx,%eax
   1422f:	89 c2                	mov    %eax,%edx
   14231:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   14234:	29 d0                	sub    %edx,%eax
   14236:	05 ff 0f 00 00       	add    $0xfff,%eax
   1423b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
   14240:	2d 00 10 00 00       	sub    $0x1000,%eax
   14245:	89 41 08             	mov    %eax,0x8(%ecx)
		ctl->rw_offs = (char*)ctl->rw_base - (char*)new_config.mmap_base;
   14248:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
   1424b:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1424e:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   14251:	8b 00                	mov    (%eax),%eax
   14253:	29 d0                	sub    %edx,%eax
   14255:	89 41 04             	mov    %eax,0x4(%ecx)
		atomic_set(&ctl->update_since_poll, 0);
   14258:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1425b:	83 c0 3c             	add    $0x3c,%eax
   1425e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		INIT_WORK((struct work_struct *)(ctl+1), vfree_helper, new_config.mmap_base);
   14264:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   14267:	83 c2 40             	add    $0x40,%edx
   1426a:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1426d:	83 c0 40             	add    $0x40,%eax
   14270:	89 02                	mov    %eax,(%edx)
   14272:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   14275:	83 c2 40             	add    $0x40,%edx
   14278:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1427b:	83 c0 40             	add    $0x40,%eax
   1427e:	89 42 04             	mov    %eax,0x4(%edx)
   14281:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   14284:	83 c0 40             	add    $0x40,%eax
   14287:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   1428e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   14291:	83 c0 40             	add    $0x40,%eax
   14294:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
   1429b:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   1429e:	83 c2 40             	add    $0x40,%edx
   142a1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   142a4:	89 42 10             	mov    %eax,0x10(%edx)
		BUG_TRAP(ctl->rw_len > 0);
   142a7:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   142aa:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
   142ae:	75 14                	jne    142c4 <cminisock_config_pipe_impl+0x2c7>
   142b0:	c7 44 24 04 be 03 00 	movl   $0x3be,0x4(%esp,1)
   142b7:	00 
   142b8:	c7 04 24 20 58 00 00 	movl   $0x5820,(%esp,1)
   142bf:	e8 fc ff ff ff       	call   142c0 <cminisock_config_pipe_impl+0x2c3>
		BUG_TRAP(ctl->ro_len > 0);
   142c4:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   142c7:	83 78 24 00          	cmpl   $0x0,0x24(%eax)
   142cb:	75 14                	jne    142e1 <cminisock_config_pipe_impl+0x2e4>
   142cd:	c7 44 24 04 bf 03 00 	movl   $0x3bf,0x4(%esp,1)
   142d4:	00 
   142d5:	c7 04 24 80 58 00 00 	movl   $0x5880,(%esp,1)
   142dc:	e8 fc ff ff ff       	call   142dd <cminisock_config_pipe_impl+0x2e0>
		BUG_TRAP((char*)ctl->ro_base < (char*)new_config.mmap_base + mmap_len);
   142e1:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   142e4:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   142e7:	03 55 f0             	add    0xfffffff0(%ebp),%edx
   142ea:	39 50 18             	cmp    %edx,0x18(%eax)
   142ed:	72 14                	jb     14303 <cminisock_config_pipe_impl+0x306>
   142ef:	c7 44 24 04 c0 03 00 	movl   $0x3c0,0x4(%esp,1)
   142f6:	00 
   142f7:	c7 04 24 e0 58 00 00 	movl   $0x58e0,(%esp,1)
   142fe:	e8 fc ff ff ff       	call   142ff <cminisock_config_pipe_impl+0x302>

		init_head(&ctl->msk_eventlist);
   14303:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   14306:	83 c0 28             	add    $0x28,%eax
   14309:	89 04 24             	mov    %eax,(%esp,1)
   1430c:	e8 1e 62 00 00       	call   1a52f <init_head>

		tp->cminisock_api_config.cfg = new_config;
   14311:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   14314:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   14317:	89 82 c8 01 00 00    	mov    %eax,0x1c8(%edx)
   1431d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   14320:	89 82 cc 01 00 00    	mov    %eax,0x1cc(%edx)
   14326:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   14329:	89 82 d0 01 00 00    	mov    %eax,0x1d0(%edx)
		new_config.ctl = NULL;
   1432f:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)

		/* Initialize minisockets */
		head = &tp->cminisock_api_config.msk_freelist;
   14336:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14339:	05 d4 01 00 00       	add    $0x1d4,%eax
   1433e:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
		init_head(head);
   14341:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   14344:	89 04 24             	mov    %eax,(%esp,1)
   14347:	e8 e3 61 00 00       	call   1a52f <init_head>

		msk = (struct cminisock *)((char*)ctl->ro_base + PAGE_SIZE);
   1434c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1434f:	8b 40 18             	mov    0x18(%eax),%eax
   14352:	05 00 10 00 00       	add    $0x1000,%eax
   14357:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
		ctl->minisock_base = msk;
   1435a:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   1435d:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   14360:	89 42 0c             	mov    %eax,0xc(%edx)
		ctl->minisock_offs = (char*)ctl->minisock_base - (char*)new_config.mmap_base;
   14363:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
   14366:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   14369:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   1436c:	8b 40 0c             	mov    0xc(%eax),%eax
   1436f:	29 d0                	sub    %edx,%eax
   14371:	89 41 20             	mov    %eax,0x20(%ecx)

		msk->ctl = ALLOC_FREE;
   14374:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   14377:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
		msk->prev = msk->next = NULL;
   1437e:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
   14381:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   14384:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   1438b:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
		msk->list = NULL;
   14391:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   14394:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		insert_tail(head, (struct alloc_head*)msk);
   1439b:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1439e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   143a2:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   143a5:	89 04 24             	mov    %eax,(%esp,1)
   143a8:	e8 a8 61 00 00       	call   1a555 <insert_tail>
		//printk("added %p\n", msk);
		msk++;
   143ad:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   143b0:	81 00 fc 00 00 00    	addl   $0xfc,(%eax)
		minisock_len = MINISOCK_LEN(ctl->ro_len);
   143b6:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   143b9:	8b 40 24             	mov    0x24(%eax),%eax
   143bc:	d1 e8                	shr    %eax
   143be:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
		ctl->minisock_limit = (char*)ctl->ro_base + minisock_len;
   143c1:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
   143c4:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   143c7:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   143ca:	03 42 18             	add    0x18(%edx),%eax
   143cd:	89 41 10             	mov    %eax,0x10(%ecx)
		BUG_TRAP(minisock_len > 0);
   143d0:	83 7d d0 00          	cmpl   $0x0,0xffffffd0(%ebp)
   143d4:	75 14                	jne    143ea <cminisock_config_pipe_impl+0x3ed>
   143d6:	c7 44 24 04 d7 03 00 	movl   $0x3d7,0x4(%esp,1)
   143dd:	00 
   143de:	c7 04 24 60 59 00 00 	movl   $0x5960,(%esp,1)
   143e5:	e8 fc ff ff ff       	call   143e6 <cminisock_config_pipe_impl+0x3e9>
   143ea:	90                   	nop    
		while((char*)(msk + 1) <= ctl->minisock_limit) {
   143eb:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
   143ee:	81 c2 fc 00 00 00    	add    $0xfc,%edx
   143f4:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   143f7:	3b 50 10             	cmp    0x10(%eax),%edx
   143fa:	76 02                	jbe    143fe <cminisock_config_pipe_impl+0x401>
   143fc:	eb 6a                	jmp    14468 <cminisock_config_pipe_impl+0x46b>
			memset(msk, 0x3a, sizeof(*msk));
   143fe:	c7 44 24 08 fc 00 00 	movl   $0xfc,0x8(%esp,1)
   14405:	00 
   14406:	c7 44 24 04 3a 3a 3a 	movl   $0x3a3a3a3a,0x4(%esp,1)
   1440d:	3a 
   1440e:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   14411:	89 04 24             	mov    %eax,(%esp,1)
   14414:	e8 71 59 00 00       	call   19d8a <__constant_c_and_count_memset>
			msk->ctl = ALLOC_FREE;
   14419:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1441c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
			msk->prev = msk->next = NULL;
   14423:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
   14426:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   14429:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   14430:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
			msk->list = NULL;
   14436:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   14439:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
			init_minisock(msk);
   14440:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   14443:	89 04 24             	mov    %eax,(%esp,1)
   14446:	e8 02 66 00 00       	call   1aa4d <init_minisock>
			insert_tail(head, (struct alloc_head*)msk);
   1444b:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1444e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   14452:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   14455:	89 04 24             	mov    %eax,(%esp,1)
   14458:	e8 f8 60 00 00       	call   1a555 <insert_tail>
			//printk("added %p\n", msk);
			msk++;
   1445d:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   14460:	81 00 fc 00 00 00    	addl   $0xfc,(%eax)
   14466:	eb 83                	jmp    143eb <cminisock_config_pipe_impl+0x3ee>
		}
		/* Initialize heap */
		ctl->heap_base = (char*)ctl->minisock_base + minisock_len;
   14468:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
   1446b:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   1446e:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   14471:	03 42 0c             	add    0xc(%edx),%eax
   14474:	89 41 14             	mov    %eax,0x14(%ecx)
		tp->t.heapbytesize = ctl->ro_len - minisock_len;
   14477:	8b 4d f8             	mov    0xfffffff8(%ebp),%ecx
   1447a:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1447d:	8b 55 d0             	mov    0xffffffd0(%ebp),%edx
   14480:	8b 40 24             	mov    0x24(%eax),%eax
   14483:	29 d0                	sub    %edx,%eax
   14485:	89 81 1c 02 00 00    	mov    %eax,0x21c(%ecx)

		error = copy_to_user(optdata,&new_config,sizeof(new_config));
   1448b:	c7 44 24 08 0c 00 00 	movl   $0xc,0x8(%esp,1)
   14492:	00 
   14493:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   14496:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1449a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1449d:	89 04 24             	mov    %eax,(%esp,1)
   144a0:	e8 00 5d 00 00       	call   1a1a5 <__constant_copy_to_user>
   144a5:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
		if(error) {
   144a8:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
   144ac:	74 18                	je     144c6 <cminisock_config_pipe_impl+0x4c9>
			printk("copy to user error\n");
   144ae:	c7 04 24 a7 59 00 00 	movl   $0x59a7,(%esp,1)
   144b5:	e8 fc ff ff ff       	call   144b6 <cminisock_config_pipe_impl+0x4b9>
			error = -EINVAL;
   144ba:	c7 45 d8 ea ff ff ff 	movl   $0xffffffea,0xffffffd8(%ebp)
			goto out_dealloc;
   144c1:	e9 4b 02 00 00       	jmp    14711 <cminisock_config_pipe_impl+0x714>
		}

		// Set up Crypto
		if(generateHMAC) {
   144c6:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
   144cd:	0f 84 8b 00 00 00    	je     1455e <cminisock_config_pipe_impl+0x561>
#ifndef FIXED_CRYPTO_KEYS
			__u8 hmac_key[HMAC_KEYLEN];
			get_random_bytes(hmac_key, HMAC_KEYLEN);
#else
#warning "Fixed hmac key"
			__u8 hmac_key[HMAC_KEYLEN+1] = "\00\01\02\03\04\05\06\07\010\011\012\013\014\015\016\017\020\021\022\023\024";
   144d3:	a1 bb 59 00 00       	mov    0x59bb,%eax
   144d8:	89 45 a8             	mov    %eax,0xffffffa8(%ebp)
   144db:	a1 bf 59 00 00       	mov    0x59bf,%eax
   144e0:	89 45 ac             	mov    %eax,0xffffffac(%ebp)
   144e3:	a1 c3 59 00 00       	mov    0x59c3,%eax
   144e8:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
   144eb:	a1 c7 59 00 00       	mov    0x59c7,%eax
   144f0:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
   144f3:	0f b6 05 cb 59 00 00 	movzbl 0x59cb,%eax
   144fa:	88 45 b8             	mov    %al,0xffffffb8(%ebp)
#endif
#if OPENSSL_HMAC
#warning "OpenSSL HMAC"
			tp->t.hmacCTX = kmalloc(sizeof(*tp->t.hmacCTX), GFP_KERNEL);
   144fd:	8b 5d f8             	mov    0xfffffff8(%ebp),%ebx
   14500:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
   14507:	00 
   14508:	c7 04 24 58 01 00 00 	movl   $0x158,(%esp,1)
   1450f:	e8 fc ff ff ff       	call   14510 <cminisock_config_pipe_impl+0x513>
   14514:	89 83 28 0a 00 00    	mov    %eax,0xa28(%ebx)
			if(tp->t.hmacCTX == NULL) {
   1451a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1451d:	83 b8 28 0a 00 00 00 	cmpl   $0x0,0xa28(%eax)
   14524:	75 18                	jne    1453e <cminisock_config_pipe_impl+0x541>
				printk("hmac kmalloc error\n");
   14526:	c7 04 24 d1 59 00 00 	movl   $0x59d1,(%esp,1)
   1452d:	e8 fc ff ff ff       	call   1452e <cminisock_config_pipe_impl+0x531>
				error = -ENOMEM;
   14532:	c7 45 d8 f4 ff ff ff 	movl   $0xfffffff4,0xffffffd8(%ebp)
				goto out_dealloc;
   14539:	e9 d3 01 00 00       	jmp    14711 <cminisock_config_pipe_impl+0x714>
			}
			hmac_setup(tp->t.hmacCTX, hmac_key, HMAC_KEYLEN);
   1453e:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp,1)
   14545:	00 
   14546:	8d 45 a8             	lea    0xffffffa8(%ebp),%eax
   14549:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1454d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14550:	8b 80 28 0a 00 00    	mov    0xa28(%eax),%eax
   14556:	89 04 24             	mov    %eax,(%esp,1)
   14559:	e8 fc ff ff ff       	call   1455a <cminisock_config_pipe_impl+0x55d>
#else
			BUG_TRAP(HMAC_KEYLEN <= HMACLEN);
			memcpy(tp->t.hmacKey, hmac_key, HMAC_KEYLEN);
#endif
		}
		if(generateNonces) {
   1455e:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
   14565:	0f 84 8b 00 00 00    	je     145f6 <cminisock_config_pipe_impl+0x5f9>
#ifndef FIXED_CRYPTO_KEYS
			__u8 nonce_key[NONCE_KEYLEN];
			get_random_bytes(nonce_key, NONCE_KEYLEN);
#else
			__u8 nonce_key[NONCE_KEYLEN+1] = "\00\01\02\03\04\05\06\07\010\011\012\013\014\015\016\017\020\021\022\023\024";
   1456b:	a1 bb 59 00 00       	mov    0x59bb,%eax
   14570:	89 45 88             	mov    %eax,0xffffff88(%ebp)
   14573:	a1 bf 59 00 00       	mov    0x59bf,%eax
   14578:	89 45 8c             	mov    %eax,0xffffff8c(%ebp)
   1457b:	a1 c3 59 00 00       	mov    0x59c3,%eax
   14580:	89 45 90             	mov    %eax,0xffffff90(%ebp)
   14583:	a1 c7 59 00 00       	mov    0x59c7,%eax
   14588:	89 45 94             	mov    %eax,0xffffff94(%ebp)
   1458b:	0f b6 05 cb 59 00 00 	movzbl 0x59cb,%eax
   14592:	88 45 98             	mov    %al,0xffffff98(%ebp)
#endif
			tp->t.nonceCTX = kmalloc(sizeof(*tp->t.nonceCTX), GFP_KERNEL);
   14595:	8b 5d f8             	mov    0xfffffff8(%ebp),%ebx
   14598:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
   1459f:	00 
   145a0:	c7 04 24 f4 00 00 00 	movl   $0xf4,(%esp,1)
   145a7:	e8 fc ff ff ff       	call   145a8 <cminisock_config_pipe_impl+0x5ab>
   145ac:	89 83 3c 0a 00 00    	mov    %eax,0xa3c(%ebx)
			if(tp->t.nonceCTX == NULL) {
   145b2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   145b5:	83 b8 3c 0a 00 00 00 	cmpl   $0x0,0xa3c(%eax)
   145bc:	75 18                	jne    145d6 <cminisock_config_pipe_impl+0x5d9>
				printk("nonce kmalloc error\n");
   145be:	c7 04 24 e5 59 00 00 	movl   $0x59e5,(%esp,1)
   145c5:	e8 fc ff ff ff       	call   145c6 <cminisock_config_pipe_impl+0x5c9>
				error = -ENOMEM;
   145ca:	c7 45 d8 f4 ff ff ff 	movl   $0xfffffff4,0xffffffd8(%ebp)
				goto out_dealloc;
   145d1:	e9 3b 01 00 00       	jmp    14711 <cminisock_config_pipe_impl+0x714>
			}
			aes_encrypt_key(nonce_key, NONCE_KEYLEN, tp->t.nonceCTX);
   145d6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   145d9:	8b 80 3c 0a 00 00    	mov    0xa3c(%eax),%eax
   145df:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   145e3:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp,1)
   145ea:	00 
   145eb:	8d 45 88             	lea    0xffffff88(%ebp),%eax
   145ee:	89 04 24             	mov    %eax,(%esp,1)
   145f1:	e8 fc ff ff ff       	call   145f2 <cminisock_config_pipe_impl+0x5f5>
		}

		return 0;
   145f6:	c7 85 7c ff ff ff 00 	movl   $0x0,0xffffff7c(%ebp)
   145fd:	00 00 00 
   14600:	e9 27 01 00 00       	jmp    1472c <cminisock_config_pipe_impl+0x72f>
	} else {
		int len;
		if(get_user(len, (int*)optlen)) {
   14605:	8b 45 10             	mov    0x10(%ebp),%eax
   14608:	e8 fc ff ff ff       	call   14609 <cminisock_config_pipe_impl+0x60c>
   1460d:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
   14610:	89 d0                	mov    %edx,%eax
   14612:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
   14615:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   14618:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
   1461b:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
   1461e:	85 c0                	test   %eax,%eax
   14620:	74 1b                	je     1463d <cminisock_config_pipe_impl+0x640>
			printk("pipe parameter readout: get optlen fault\n");
   14622:	c7 04 24 00 5a 00 00 	movl   $0x5a00,(%esp,1)
   14629:	e8 fc ff ff ff       	call   1462a <cminisock_config_pipe_impl+0x62d>
			return -EFAULT;
   1462e:	c7 85 7c ff ff ff f2 	movl   $0xfffffff2,0xffffff7c(%ebp)
   14635:	ff ff ff 
   14638:	e9 ef 00 00 00       	jmp    1472c <cminisock_config_pipe_impl+0x72f>
		}
		error = copy_to_user(optdata,&tp->cminisock_api_config.cfg,sizeof(tp->cminisock_api_config.cfg));
   1463d:	c7 44 24 08 0c 00 00 	movl   $0xc,0x8(%esp,1)
   14644:	00 
   14645:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14648:	05 c8 01 00 00       	add    $0x1c8,%eax
   1464d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   14651:	8b 45 0c             	mov    0xc(%ebp),%eax
   14654:	89 04 24             	mov    %eax,(%esp,1)
   14657:	e8 49 5b 00 00       	call   1a1a5 <__constant_copy_to_user>
   1465c:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
		if(error) {
   1465f:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
   14663:	74 1b                	je     14680 <cminisock_config_pipe_impl+0x683>
			printk("pipe parameter readout: copy out fault\n");
   14665:	c7 04 24 40 5a 00 00 	movl   $0x5a40,(%esp,1)
   1466c:	e8 fc ff ff ff       	call   1466d <cminisock_config_pipe_impl+0x670>
			return -EINVAL;
   14671:	c7 85 7c ff ff ff ea 	movl   $0xffffffea,0xffffff7c(%ebp)
   14678:	ff ff ff 
   1467b:	e9 ac 00 00 00       	jmp    1472c <cminisock_config_pipe_impl+0x72f>
		}
		if(put_user(len, (int*)optlen)) {
   14680:	c7 45 cc f2 ff ff ff 	movl   $0xfffffff2,0xffffffcc(%ebp)
   14687:	8b 45 10             	mov    0x10(%ebp),%eax
   1468a:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
   1468d:	8b 5d d0             	mov    0xffffffd0(%ebp),%ebx
   14690:	e8 aa 58 00 00       	call   19f3f <get_current>
   14695:	89 da                	mov    %ebx,%edx
   14697:	83 c2 04             	add    $0x4,%edx
   1469a:	19 c9                	sbb    %ecx,%ecx
   1469c:	39 50 0c             	cmp    %edx,0xc(%eax)
   1469f:	83 d9 00             	sbb    $0x0,%ecx
   146a2:	89 c8                	mov    %ecx,%eax
   146a4:	89 45 84             	mov    %eax,0xffffff84(%ebp)
   146a7:	89 d0                	mov    %edx,%eax
   146a9:	89 45 80             	mov    %eax,0xffffff80(%ebp)
   146ac:	8b 45 84             	mov    0xffffff84(%ebp),%eax
   146af:	85 c0                	test   %eax,%eax
   146b1:	75 15                	jne    146c8 <cminisock_config_pipe_impl+0x6cb>
   146b3:	c7 45 cc 00 00 00 00 	movl   $0x0,0xffffffcc(%ebp)
   146ba:	8b 4d c8             	mov    0xffffffc8(%ebp),%ecx
   146bd:	8b 55 d0             	mov    0xffffffd0(%ebp),%edx
   146c0:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
   146c3:	89 0a                	mov    %ecx,(%edx)
   146c5:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
   146c8:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
   146cb:	85 c0                	test   %eax,%eax
   146cd:	74 18                	je     146e7 <cminisock_config_pipe_impl+0x6ea>
			printk("pipe parameter readout: set optlen fault\n");
   146cf:	c7 04 24 80 5a 00 00 	movl   $0x5a80,(%esp,1)
   146d6:	e8 fc ff ff ff       	call   146d7 <cminisock_config_pipe_impl+0x6da>
			return -EFAULT;
   146db:	c7 85 7c ff ff ff f2 	movl   $0xfffffff2,0xffffff7c(%ebp)
   146e2:	ff ff ff 
   146e5:	eb 45                	jmp    1472c <cminisock_config_pipe_impl+0x72f>
		}
		printk("socket %p configured\n", sk);
   146e7:	8b 45 08             	mov    0x8(%ebp),%eax
   146ea:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   146ee:	c7 04 24 aa 5a 00 00 	movl   $0x5aaa,(%esp,1)
   146f5:	e8 fc ff ff ff       	call   146f6 <cminisock_config_pipe_impl+0x6f9>
		return 0;
   146fa:	c7 85 7c ff ff ff 00 	movl   $0x0,0xffffff7c(%ebp)
   14701:	00 00 00 
   14704:	eb 26                	jmp    1472c <cminisock_config_pipe_impl+0x72f>
	}

 out:
	return error;
   14706:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   14709:	89 85 7c ff ff ff    	mov    %eax,0xffffff7c(%ebp)
   1470f:	eb 1b                	jmp    1472c <cminisock_config_pipe_impl+0x72f>
 out_dealloc:
	vfree(new_config.mmap_base);
   14711:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   14714:	89 04 24             	mov    %eax,(%esp,1)
   14717:	e8 fc ff ff ff       	call   14718 <cminisock_config_pipe_impl+0x71b>
	new_config.mmap_base = NULL;
   1471c:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
	return error;
   14723:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   14726:	89 85 7c ff ff ff    	mov    %eax,0xffffff7c(%ebp)
}
   1472c:	8b 85 7c ff ff ff    	mov    0xffffff7c(%ebp),%eax
   14732:	81 c4 8c 00 00 00    	add    $0x8c,%esp
   14738:	5b                   	pop    %ebx
   14739:	5d                   	pop    %ebp
   1473a:	c3                   	ret    

0001473b <trickles_getsockopt_impl>:

int trickles_getsockopt_impl(struct sock *sk, int level, int optname, char *optval, int *optlen) {
   1473b:	55                   	push   %ebp
   1473c:	89 e5                	mov    %esp,%ebp
   1473e:	53                   	push   %ebx
   1473f:	83 ec 2c             	sub    $0x2c,%esp
	extern void analyze_msk_list(struct sock *sk);

	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
   14742:	8b 45 08             	mov    0x8(%ebp),%eax
   14745:	05 bc 00 00 00       	add    $0xbc,%eax
   1474a:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	int outputLen, len, rval;
	if(level != SOL_TCP) {
   1474d:	83 7d 0c 06          	cmpl   $0x6,0xc(%ebp)
   14751:	74 0c                	je     1475f <trickles_getsockopt_impl+0x24>
		return -EINVAL;
   14753:	c7 45 d8 ea ff ff ff 	movl   $0xffffffea,0xffffffd8(%ebp)
   1475a:	e9 63 01 00 00       	jmp    148c2 <trickles_getsockopt_impl+0x187>
	}
	switch(optname) {
   1475f:	8b 45 10             	mov    0x10(%ebp),%eax
   14762:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   14765:	83 7d d4 13          	cmpl   $0x13,0xffffffd4(%ebp)
   14769:	74 28                	je     14793 <trickles_getsockopt_impl+0x58>
   1476b:	83 7d d4 13          	cmpl   $0x13,0xffffffd4(%ebp)
   1476f:	7f 08                	jg     14779 <trickles_getsockopt_impl+0x3e>
   14771:	83 7d d4 12          	cmpl   $0x12,0xffffffd4(%ebp)
   14775:	74 0a                	je     14781 <trickles_getsockopt_impl+0x46>
   14777:	eb 4a                	jmp    147c3 <trickles_getsockopt_impl+0x88>
   14779:	83 7d d4 16          	cmpl   $0x16,0xffffffd4(%ebp)
   1477d:	74 29                	je     147a8 <trickles_getsockopt_impl+0x6d>
   1477f:	eb 42                	jmp    147c3 <trickles_getsockopt_impl+0x88>
	case TCP_TRICKLES_CWND:
		outputLen = sizeof(int);
   14781:	c7 45 f4 04 00 00 00 	movl   $0x4,0xfffffff4(%ebp)
		rval = tp->snd_wnd;
   14788:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1478b:	8b 40 54             	mov    0x54(%eax),%eax
   1478e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
		break;
   14791:	eb 3c                	jmp    147cf <trickles_getsockopt_impl+0x94>
	case TCP_TRICKLES_SSTHRESH:
		outputLen = sizeof(int);
   14793:	c7 45 f4 04 00 00 00 	movl   $0x4,0xfffffff4(%ebp)
		rval = tp->snd_ssthresh;
   1479a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1479d:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
   147a3:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
		break;
   147a6:	eb 27                	jmp    147cf <trickles_getsockopt_impl+0x94>
	case TCP_TRICKLES_DUMP:
		// dump stats
		//printk("Dumping socket stats for %p\n", sk);
		//dump_socket_stats(sk);
		analyze_msk_list(sk);
   147a8:	8b 45 08             	mov    0x8(%ebp),%eax
   147ab:	89 04 24             	mov    %eax,(%esp,1)
   147ae:	e8 fc ff ff ff       	call   147af <trickles_getsockopt_impl+0x74>
		outputLen = sizeof(int);
   147b3:	c7 45 f4 04 00 00 00 	movl   $0x4,0xfffffff4(%ebp)
		rval = 0;
   147ba:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
		break;
   147c1:	eb 0c                	jmp    147cf <trickles_getsockopt_impl+0x94>
	default:
		return -ENOPROTOOPT;
   147c3:	c7 45 d8 a4 ff ff ff 	movl   $0xffffffa4,0xffffffd8(%ebp)
   147ca:	e9 f3 00 00 00       	jmp    148c2 <trickles_getsockopt_impl+0x187>
	}
	if(get_user(len,optlen)) {
   147cf:	8b 45 18             	mov    0x18(%ebp),%eax
   147d2:	e8 fc ff ff ff       	call   147d3 <trickles_getsockopt_impl+0x98>
   147d7:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   147da:	89 d0                	mov    %edx,%eax
   147dc:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   147df:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   147e2:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   147e5:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   147e8:	85 c0                	test   %eax,%eax
   147ea:	74 0c                	je     147f8 <trickles_getsockopt_impl+0xbd>
		return -EFAULT;
   147ec:	c7 45 d8 f2 ff ff ff 	movl   $0xfffffff2,0xffffffd8(%ebp)
   147f3:	e9 ca 00 00 00       	jmp    148c2 <trickles_getsockopt_impl+0x187>
	}
	if(len < sizeof(int)) {
   147f8:	83 7d f0 03          	cmpl   $0x3,0xfffffff0(%ebp)
   147fc:	77 0c                	ja     1480a <trickles_getsockopt_impl+0xcf>
		return -EFAULT;
   147fe:	c7 45 d8 f2 ff ff ff 	movl   $0xfffffff2,0xffffffd8(%ebp)
   14805:	e9 b8 00 00 00       	jmp    148c2 <trickles_getsockopt_impl+0x187>
	}
	if(put_user(outputLen,optlen)) {
   1480a:	c7 45 e4 f2 ff ff ff 	movl   $0xfffffff2,0xffffffe4(%ebp)
   14811:	8b 45 18             	mov    0x18(%ebp),%eax
   14814:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   14817:	8b 5d e8             	mov    0xffffffe8(%ebp),%ebx
   1481a:	e8 20 57 00 00       	call   19f3f <get_current>
   1481f:	89 da                	mov    %ebx,%edx
   14821:	83 c2 04             	add    $0x4,%edx
   14824:	19 c9                	sbb    %ecx,%ecx
   14826:	39 50 0c             	cmp    %edx,0xc(%eax)
   14829:	83 d9 00             	sbb    $0x0,%ecx
   1482c:	89 c8                	mov    %ecx,%eax
   1482e:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   14831:	89 d0                	mov    %edx,%eax
   14833:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
   14836:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   14839:	85 c0                	test   %eax,%eax
   1483b:	75 15                	jne    14852 <trickles_getsockopt_impl+0x117>
   1483d:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
   14844:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
   14847:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   1484a:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1484d:	89 0a                	mov    %ecx,(%edx)
   1484f:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   14852:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   14855:	85 c0                	test   %eax,%eax
   14857:	74 09                	je     14862 <trickles_getsockopt_impl+0x127>
		return -EFAULT;
   14859:	c7 45 d8 f2 ff ff ff 	movl   $0xfffffff2,0xffffffd8(%ebp)
   14860:	eb 60                	jmp    148c2 <trickles_getsockopt_impl+0x187>
	}
	if(put_user(rval,optval)) {
   14862:	c7 45 dc f2 ff ff ff 	movl   $0xfffffff2,0xffffffdc(%ebp)
   14869:	8b 45 14             	mov    0x14(%ebp),%eax
   1486c:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   1486f:	8b 5d e0             	mov    0xffffffe0(%ebp),%ebx
   14872:	e8 c8 56 00 00       	call   19f3f <get_current>
   14877:	89 da                	mov    %ebx,%edx
   14879:	83 c2 01             	add    $0x1,%edx
   1487c:	19 c9                	sbb    %ecx,%ecx
   1487e:	39 50 0c             	cmp    %edx,0xc(%eax)
   14881:	83 d9 00             	sbb    $0x0,%ecx
   14884:	89 c8                	mov    %ecx,%eax
   14886:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   14889:	89 d0                	mov    %edx,%eax
   1488b:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1488e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   14891:	85 c0                	test   %eax,%eax
   14893:	75 16                	jne    148ab <trickles_getsockopt_impl+0x170>
   14895:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
   1489c:	0f b6 4d ec          	movzbl 0xffffffec(%ebp),%ecx
   148a0:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   148a3:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   148a6:	88 0a                	mov    %cl,(%edx)
   148a8:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
   148ab:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   148ae:	85 c0                	test   %eax,%eax
   148b0:	74 09                	je     148bb <trickles_getsockopt_impl+0x180>
		return -EFAULT;
   148b2:	c7 45 d8 f2 ff ff ff 	movl   $0xfffffff2,0xffffffd8(%ebp)
   148b9:	eb 07                	jmp    148c2 <trickles_getsockopt_impl+0x187>
	}
	return 0;
   148bb:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
}
   148c2:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   148c5:	83 c4 2c             	add    $0x2c,%esp
   148c8:	5b                   	pop    %ebx
   148c9:	5d                   	pop    %ebp
   148ca:	c3                   	ret    

000148cb <trickles_sendv_impl>:

static __inline__ void sockfd_put(struct socket *sock)
{
        fput(sock->file);
}

/* syscall */
int trickles_sendv_impl(int fd, struct cminisock *msk, struct tiovec *user_tiov, int tiovlen) {
   148cb:	55                   	push   %ebp
   148cc:	89 e5                	mov    %esp,%ebp
   148ce:	83 ec 30             	sub    $0x30,%esp
	struct socket *sock;
	struct sock *sk;
	struct tcp_opt *tp;
	int err;

	struct tiovec *tiov;
	int tiov_size;

	extern int gNumSendv;
	gNumSendv++;
   148d1:	ff 05 00 00 00 00    	incl   0x0

	err = -EINVAL;
   148d7:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
	if (tiovlen < 0 || tiovlen > UIO_MAXIOV) {
   148de:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   148e2:	0f 88 e8 03 00 00    	js     14cd0 <trickles_sendv_impl+0x405>
   148e8:	81 7d 14 00 04 00 00 	cmpl   $0x400,0x14(%ebp)
   148ef:	0f 8f db 03 00 00    	jg     14cd0 <trickles_sendv_impl+0x405>
		goto out;
	}
	err = -ENOMEM;
   148f5:	c7 45 f0 f4 ff ff ff 	movl   $0xfffffff4,0xfffffff0(%ebp)
	tiov_size = sizeof(struct tiovec) * tiovlen;
   148fc:	8b 45 14             	mov    0x14(%ebp),%eax
   148ff:	c1 e0 03             	shl    $0x3,%eax
   14902:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
	if(tiov_size > 0) {
   14905:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
   14909:	7e 4a                	jle    14955 <trickles_sendv_impl+0x8a>
		tiov = kmalloc(tiov_size, GFP_KERNEL);
   1490b:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
   14912:	00 
   14913:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   14916:	89 04 24             	mov    %eax,(%esp,1)
   14919:	e8 fc ff ff ff       	call   1491a <trickles_sendv_impl+0x4f>
   1491e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
		if(tiov == NULL) {
   14921:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
   14925:	75 05                	jne    1492c <trickles_sendv_impl+0x61>
			goto out;
   14927:	e9 a4 03 00 00       	jmp    14cd0 <trickles_sendv_impl+0x405>
		}
		err = -EFAULT;
   1492c:	c7 45 f0 f2 ff ff ff 	movl   $0xfffffff2,0xfffffff0(%ebp)
		if(copy_from_user(tiov, user_tiov, tiov_size)) {
   14933:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   14936:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1493a:	8b 45 10             	mov    0x10(%ebp),%eax
   1493d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   14941:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   14944:	89 04 24             	mov    %eax,(%esp,1)
   14947:	e8 fc ff ff ff       	call   14948 <trickles_sendv_impl+0x7d>
   1494c:	85 c0                	test   %eax,%eax
   1494e:	74 0c                	je     1495c <trickles_sendv_impl+0x91>
			goto out_freeiov;
   14950:	e9 6a 03 00 00       	jmp    14cbf <trickles_sendv_impl+0x3f4>
		}
	} else {
		tiov = NULL;
   14955:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
	}

	sock = sockfd_lookup(fd, &err);
   1495c:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   1495f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   14963:	8b 45 08             	mov    0x8(%ebp),%eax
   14966:	89 04 24             	mov    %eax,(%esp,1)
   14969:	e8 fc ff ff ff       	call   1496a <trickles_sendv_impl+0x9f>
   1496e:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	if (!sock)
   14971:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
   14975:	75 05                	jne    1497c <trickles_sendv_impl+0xb1>
		goto out_freeiov;
   14977:	e9 43 03 00 00       	jmp    14cbf <trickles_sendv_impl+0x3f4>

	sk = sock->sk;
   1497c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1497f:	8b 40 18             	mov    0x18(%eax),%eax
   14982:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	tp = &(sk->tp_pinfo.af_tcp);
   14985:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14988:	05 bc 00 00 00       	add    $0xbc,%eax
   1498d:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

	lock_sock(sk);
   14990:	ff 05 08 00 00 00    	incl   0x8
   14996:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14999:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
   1499d:	74 0b                	je     149aa <trickles_sendv_impl+0xdf>
   1499f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   149a2:	89 04 24             	mov    %eax,(%esp,1)
   149a5:	e8 fc ff ff ff       	call   149a6 <trickles_sendv_impl+0xdb>
   149aa:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   149ad:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
   149b4:	c7 45 e4 08 00 00 00 	movl   $0x8,0xffffffe4(%ebp)
   149bb:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   149be:	ff 08                	decl   (%eax)
   149c0:	83 38 00             	cmpl   $0x0,(%eax)
   149c3:	75 0d                	jne    149d2 <trickles_sendv_impl+0x107>
   149c5:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   149c8:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   149cc:	0f 85 ae 76 00 00    	jne    1c080 <.text.lock.tmalloc+0x110>
	if(!TRICKLES_USERAPI_CONFIGURED_TP(tp)) {
   149d2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   149d5:	83 b8 d0 01 00 00 00 	cmpl   $0x0,0x1d0(%eax)
   149dc:	0f 85 88 00 00 00    	jne    14a6a <trickles_sendv_impl+0x19f>
		printk("Socket not configured\n");
   149e2:	c7 04 24 c4 56 00 00 	movl   $0x56c4,(%esp,1)
   149e9:	e8 fc ff ff ff       	call   149ea <trickles_sendv_impl+0x11f>
		err = -EINVAL;
   149ee:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
		release_sock(sk);
   149f5:	ff 05 08 00 00 00    	incl   0x8
   149fb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   149fe:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   14a05:	74 0b                	je     14a12 <trickles_sendv_impl+0x147>
   14a07:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14a0a:	89 04 24             	mov    %eax,(%esp,1)
   14a0d:	e8 fc ff ff ff       	call   14a0e <trickles_sendv_impl+0x143>
   14a12:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14a15:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   14a1c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14a1f:	83 c0 30             	add    $0x30,%eax
   14a22:	89 04 24             	mov    %eax,(%esp,1)
   14a25:	e8 b8 52 00 00       	call   19ce2 <waitqueue_active>
   14a2a:	85 c0                	test   %eax,%eax
   14a2c:	74 15                	je     14a43 <trickles_sendv_impl+0x178>
   14a2e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14a31:	83 c0 30             	add    $0x30,%eax
   14a34:	b9 01 00 00 00       	mov    $0x1,%ecx
   14a39:	ba 03 00 00 00       	mov    $0x3,%edx
   14a3e:	e8 fc ff ff ff       	call   14a3f <trickles_sendv_impl+0x174>
   14a43:	c7 45 e4 08 00 00 00 	movl   $0x8,0xffffffe4(%ebp)
   14a4a:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   14a4d:	ff 08                	decl   (%eax)
   14a4f:	83 38 00             	cmpl   $0x0,(%eax)
   14a52:	0f 85 5c 02 00 00    	jne    14cb4 <trickles_sendv_impl+0x3e9>
   14a58:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   14a5b:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   14a5f:	0f 85 2b 76 00 00    	jne    1c090 <.text.lock.tmalloc+0x120>
		goto out_put;
   14a65:	e9 4a 02 00 00       	jmp    14cb4 <trickles_sendv_impl+0x3e9>
	}
	if(!IS_VALID_MSK(sk,msk)) {
   14a6a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14a6d:	05 bc 00 00 00       	add    $0xbc,%eax
   14a72:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   14a75:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
   14a7c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   14a7f:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
   14a85:	8b 50 0c             	mov    0xc(%eax),%edx
   14a88:	8b 45 0c             	mov    0xc(%ebp),%eax
   14a8b:	89 c1                	mov    %eax,%ecx
   14a8d:	29 d1                	sub    %edx,%ecx
   14a8f:	89 ca                	mov    %ecx,%edx
   14a91:	c1 ea 02             	shr    $0x2,%edx
   14a94:	b8 21 08 82 20       	mov    $0x20820821,%eax
   14a99:	f7 e2                	mul    %edx
   14a9b:	c1 ea 03             	shr    $0x3,%edx
   14a9e:	89 d0                	mov    %edx,%eax
   14aa0:	c1 e0 06             	shl    $0x6,%eax
   14aa3:	29 d0                	sub    %edx,%eax
   14aa5:	c1 e0 02             	shl    $0x2,%eax
   14aa8:	29 c1                	sub    %eax,%ecx
   14aaa:	89 c8                	mov    %ecx,%eax
   14aac:	85 c0                	test   %eax,%eax
   14aae:	75 42                	jne    14af2 <trickles_sendv_impl+0x227>
   14ab0:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   14ab3:	8b 90 cc 01 00 00    	mov    0x1cc(%eax),%edx
   14ab9:	8b 45 0c             	mov    0xc(%ebp),%eax
   14abc:	3b 42 0c             	cmp    0xc(%edx),%eax
   14abf:	72 31                	jb     14af2 <trickles_sendv_impl+0x227>
   14ac1:	8b 45 0c             	mov    0xc(%ebp),%eax
   14ac4:	05 fc 00 00 00       	add    $0xfc,%eax
   14ac9:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   14acc:	8b 92 cc 01 00 00    	mov    0x1cc(%edx),%edx
   14ad2:	3b 42 10             	cmp    0x10(%edx),%eax
   14ad5:	77 1b                	ja     14af2 <trickles_sendv_impl+0x227>
   14ad7:	8b 45 0c             	mov    0xc(%ebp),%eax
   14ada:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
   14ade:	74 0b                	je     14aeb <trickles_sendv_impl+0x220>
   14ae0:	8b 45 0c             	mov    0xc(%ebp),%eax
   14ae3:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
   14ae7:	74 02                	je     14aeb <trickles_sendv_impl+0x220>
   14ae9:	eb 07                	jmp    14af2 <trickles_sendv_impl+0x227>
   14aeb:	c7 45 e0 01 00 00 00 	movl   $0x1,0xffffffe0(%ebp)
   14af2:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
   14af6:	0f 85 17 01 00 00    	jne    14c13 <trickles_sendv_impl+0x348>
		printk("bad minisocket %d %d\n", !IS_TRICKLES_SOCK_ADDR(tp,msk), !(VALID_MSK_CTL(msk)));
   14afc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
   14b03:	00 
   14b04:	8b 45 0c             	mov    0xc(%ebp),%eax
   14b07:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
   14b0b:	74 11                	je     14b1e <trickles_sendv_impl+0x253>
   14b0d:	8b 45 0c             	mov    0xc(%ebp),%eax
   14b10:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
   14b14:	74 08                	je     14b1e <trickles_sendv_impl+0x253>
   14b16:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp,1)
   14b1d:	00 
   14b1e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
   14b25:	00 
   14b26:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   14b29:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
   14b2f:	8b 50 0c             	mov    0xc(%eax),%edx
   14b32:	8b 45 0c             	mov    0xc(%ebp),%eax
   14b35:	89 c1                	mov    %eax,%ecx
   14b37:	29 d1                	sub    %edx,%ecx
   14b39:	89 ca                	mov    %ecx,%edx
   14b3b:	c1 ea 02             	shr    $0x2,%edx
   14b3e:	b8 21 08 82 20       	mov    $0x20820821,%eax
   14b43:	f7 e2                	mul    %edx
   14b45:	c1 ea 03             	shr    $0x3,%edx
   14b48:	89 d0                	mov    %edx,%eax
   14b4a:	c1 e0 06             	shl    $0x6,%eax
   14b4d:	29 d0                	sub    %edx,%eax
   14b4f:	c1 e0 02             	shl    $0x2,%eax
   14b52:	29 c1                	sub    %eax,%ecx
   14b54:	89 c8                	mov    %ecx,%eax
   14b56:	85 c0                	test   %eax,%eax
   14b58:	75 29                	jne    14b83 <trickles_sendv_impl+0x2b8>
   14b5a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   14b5d:	8b 90 cc 01 00 00    	mov    0x1cc(%eax),%edx
   14b63:	8b 45 0c             	mov    0xc(%ebp),%eax
   14b66:	3b 42 0c             	cmp    0xc(%edx),%eax
   14b69:	72 18                	jb     14b83 <trickles_sendv_impl+0x2b8>
   14b6b:	8b 45 0c             	mov    0xc(%ebp),%eax
   14b6e:	05 fc 00 00 00       	add    $0xfc,%eax
   14b73:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   14b76:	8b 92 cc 01 00 00    	mov    0x1cc(%edx),%edx
   14b7c:	3b 42 10             	cmp    0x10(%edx),%eax
   14b7f:	77 02                	ja     14b83 <trickles_sendv_impl+0x2b8>
   14b81:	eb 08                	jmp    14b8b <trickles_sendv_impl+0x2c0>
   14b83:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
   14b8a:	00 
   14b8b:	c7 04 24 db 56 00 00 	movl   $0x56db,(%esp,1)
   14b92:	e8 fc ff ff ff       	call   14b93 <trickles_sendv_impl+0x2c8>
		err = -EINVAL;
   14b97:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
		release_sock(sk);
   14b9e:	ff 05 08 00 00 00    	incl   0x8
   14ba4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14ba7:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   14bae:	74 0b                	je     14bbb <trickles_sendv_impl+0x2f0>
   14bb0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14bb3:	89 04 24             	mov    %eax,(%esp,1)
   14bb6:	e8 fc ff ff ff       	call   14bb7 <trickles_sendv_impl+0x2ec>
   14bbb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14bbe:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   14bc5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14bc8:	83 c0 30             	add    $0x30,%eax
   14bcb:	89 04 24             	mov    %eax,(%esp,1)
   14bce:	e8 0f 51 00 00       	call   19ce2 <waitqueue_active>
   14bd3:	85 c0                	test   %eax,%eax
   14bd5:	74 15                	je     14bec <trickles_sendv_impl+0x321>
   14bd7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14bda:	83 c0 30             	add    $0x30,%eax
   14bdd:	b9 01 00 00 00       	mov    $0x1,%ecx
   14be2:	ba 03 00 00 00       	mov    $0x3,%edx
   14be7:	e8 fc ff ff ff       	call   14be8 <trickles_sendv_impl+0x31d>
   14bec:	c7 45 e4 08 00 00 00 	movl   $0x8,0xffffffe4(%ebp)
   14bf3:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   14bf6:	ff 08                	decl   (%eax)
   14bf8:	83 38 00             	cmpl   $0x0,(%eax)
   14bfb:	0f 85 b3 00 00 00    	jne    14cb4 <trickles_sendv_impl+0x3e9>
   14c01:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   14c04:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   14c08:	0f 85 92 74 00 00    	jne    1c0a0 <.text.lock.tmalloc+0x130>
		goto out_put;
   14c0e:	e9 a1 00 00 00       	jmp    14cb4 <trickles_sendv_impl+0x3e9>
	}

	free_trickles_msk(sk,msk);
   14c13:	8b 45 0c             	mov    0xc(%ebp),%eax
   14c16:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   14c1a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14c1d:	89 04 24             	mov    %eax,(%esp,1)
   14c20:	e8 e8 db ff ff       	call   1280d <free_trickles_msk>

	err = trickles_do_sendmsg_tiov(sk,msk,tiov,tiovlen);
   14c25:	8b 45 14             	mov    0x14(%ebp),%eax
   14c28:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   14c2c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   14c2f:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   14c33:	8b 45 0c             	mov    0xc(%ebp),%eax
   14c36:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   14c3a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14c3d:	89 04 24             	mov    %eax,(%esp,1)
   14c40:	e8 cb 61 00 00       	call   1ae10 <trickles_do_sendmsg_tiov>
   14c45:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

	release_sock(sk);
   14c48:	ff 05 08 00 00 00    	incl   0x8
   14c4e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14c51:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   14c58:	74 0b                	je     14c65 <trickles_sendv_impl+0x39a>
   14c5a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14c5d:	89 04 24             	mov    %eax,(%esp,1)
   14c60:	e8 fc ff ff ff       	call   14c61 <trickles_sendv_impl+0x396>
   14c65:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14c68:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   14c6f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14c72:	83 c0 30             	add    $0x30,%eax
   14c75:	89 04 24             	mov    %eax,(%esp,1)
   14c78:	e8 65 50 00 00       	call   19ce2 <waitqueue_active>
   14c7d:	85 c0                	test   %eax,%eax
   14c7f:	74 15                	je     14c96 <trickles_sendv_impl+0x3cb>
   14c81:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14c84:	83 c0 30             	add    $0x30,%eax
   14c87:	b9 01 00 00 00       	mov    $0x1,%ecx
   14c8c:	ba 03 00 00 00       	mov    $0x3,%edx
   14c91:	e8 fc ff ff ff       	call   14c92 <trickles_sendv_impl+0x3c7>
   14c96:	c7 45 e4 08 00 00 00 	movl   $0x8,0xffffffe4(%ebp)
   14c9d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   14ca0:	ff 08                	decl   (%eax)
   14ca2:	83 38 00             	cmpl   $0x0,(%eax)
   14ca5:	75 0d                	jne    14cb4 <trickles_sendv_impl+0x3e9>
   14ca7:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   14caa:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   14cae:	0f 85 fc 73 00 00    	jne    1c0b0 <.text.lock.tmalloc+0x140>

out_put:
	sockfd_put(sock);
   14cb4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   14cb7:	89 04 24             	mov    %eax,(%esp,1)
   14cba:	e8 83 67 00 00       	call   1b442 <sockfd_put>
 out_freeiov:
	if(tiov_size > 0)
   14cbf:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
   14cc3:	7e 0b                	jle    14cd0 <trickles_sendv_impl+0x405>
		kfree(tiov);
   14cc5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   14cc8:	89 04 24             	mov    %eax,(%esp,1)
   14ccb:	e8 fc ff ff ff       	call   14ccc <trickles_sendv_impl+0x401>
 out:
	return err;
   14cd0:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
}
   14cd3:	c9                   	leave  
   14cd4:	c3                   	ret    

00014cd5 <skb_fillpage_actor>:

// copied from filemap.c
static int skb_fillpage_actor(read_descriptor_t * desc, struct page *page, unsigned long offset , unsigned long size)
{
   14cd5:	55                   	push   %ebp
   14cd6:	89 e5                	mov    %esp,%ebp
   14cd8:	83 ec 24             	sub    $0x24,%esp
	ssize_t written;
	unsigned long count = desc->count;
   14cdb:	8b 45 08             	mov    0x8(%ebp),%eax
   14cde:	8b 40 04             	mov    0x4(%eax),%eax
   14ce1:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	struct sk_buff *skb = (struct sk_buff *) desc->buf;
   14ce4:	8b 45 08             	mov    0x8(%ebp),%eax
   14ce7:	8b 40 08             	mov    0x8(%eax),%eax
   14cea:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	int i = skb_shinfo(skb)->nr_frags;
   14ced:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   14cf0:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   14cf6:	8b 40 04             	mov    0x4(%eax),%eax
   14cf9:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

	if (size > count)
   14cfc:	8b 45 14             	mov    0x14(%ebp),%eax
   14cff:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
   14d02:	76 06                	jbe    14d0a <skb_fillpage_actor+0x35>
		size = count;
   14d04:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14d07:	89 45 14             	mov    %eax,0x14(%ebp)

	if(i >= MAX_SKB_FRAGS) {
   14d0a:	83 7d f0 05          	cmpl   $0x5,0xfffffff0(%ebp)
   14d0e:	7e 15                	jle    14d25 <skb_fillpage_actor+0x50>
		printk("too many fragments\n");
   14d10:	c7 04 24 c0 5a 00 00 	movl   $0x5ac0,(%esp,1)
   14d17:	e8 fc ff ff ff       	call   14d18 <skb_fillpage_actor+0x43>
		written = -EINVAL;
   14d1c:	c7 45 fc ea ff ff ff 	movl   $0xffffffea,0xfffffffc(%ebp)
   14d23:	eb 65                	jmp    14d8a <skb_fillpage_actor+0xb5>
	} else {
		get_page(page);
   14d25:	8b 45 0c             	mov    0xc(%ebp),%eax
   14d28:	83 c0 14             	add    $0x14,%eax
   14d2b:	89 04 24             	mov    %eax,(%esp,1)
   14d2e:	e8 e5 4f 00 00       	call   19d18 <atomic_inc>
		fill_page_desc(skb,i,page,offset,size);
   14d33:	8b 45 14             	mov    0x14(%ebp),%eax
   14d36:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   14d3a:	8b 45 10             	mov    0x10(%ebp),%eax
   14d3d:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   14d41:	8b 45 0c             	mov    0xc(%ebp),%eax
   14d44:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   14d48:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   14d4b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   14d4f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   14d52:	89 04 24             	mov    %eax,(%esp,1)
   14d55:	e8 15 60 00 00       	call   1ad6f <fill_page_desc>
		written = size;
   14d5a:	8b 45 14             	mov    0x14(%ebp),%eax
   14d5d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
		skb->len += size;
   14d60:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
   14d63:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   14d66:	8b 45 14             	mov    0x14(%ebp),%eax
   14d69:	03 82 94 00 00 00    	add    0x94(%edx),%eax
   14d6f:	89 81 94 00 00 00    	mov    %eax,0x94(%ecx)
		skb->data_len += size;
   14d75:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
   14d78:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   14d7b:	8b 45 14             	mov    0x14(%ebp),%eax
   14d7e:	03 82 98 00 00 00    	add    0x98(%edx),%eax
   14d84:	89 81 98 00 00 00    	mov    %eax,0x98(%ecx)
	}
	if (written < 0) {
   14d8a:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
   14d8e:	79 10                	jns    14da0 <skb_fillpage_actor+0xcb>
		desc->error = written;
   14d90:	8b 55 08             	mov    0x8(%ebp),%edx
   14d93:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   14d96:	89 42 0c             	mov    %eax,0xc(%edx)
		written = 0;
   14d99:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
	}
	desc->count = count - written;
   14da0:	8b 4d 08             	mov    0x8(%ebp),%ecx
   14da3:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   14da6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14da9:	29 d0                	sub    %edx,%eax
   14dab:	89 41 04             	mov    %eax,0x4(%ecx)
	desc->written += written;
   14dae:	8b 4d 08             	mov    0x8(%ebp),%ecx
   14db1:	8b 55 08             	mov    0x8(%ebp),%edx
   14db4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   14db7:	03 02                	add    (%edx),%eax
   14db9:	89 01                	mov    %eax,(%ecx)
	return written;
   14dbb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
   14dbe:	c9                   	leave  
   14dbf:	c3                   	ret    

00014dc0 <file_insertpages>:

/* Insert file pages into sk_buff */
static ssize_t file_insertpages(struct sk_buff *skb, int in_fd, loff_t offset, size_t count)
{
   14dc0:	55                   	push   %ebp
   14dc1:	89 e5                	mov    %esp,%ebp
   14dc3:	83 ec 3c             	sub    $0x3c,%esp
   14dc6:	8b 45 10             	mov    0x10(%ebp),%eax
   14dc9:	8b 55 14             	mov    0x14(%ebp),%edx
   14dcc:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   14dcf:	89 55 fc             	mov    %edx,0xfffffffc(%ebp)
	ssize_t retval;
	struct file * in_file;
	struct inode * in_inode;

	/*
	 * Get input file, and verify that it is ok..
	 */
	retval = -EBADF;
   14dd2:	c7 45 f4 f7 ff ff ff 	movl   $0xfffffff7,0xfffffff4(%ebp)
	in_file = fget(in_fd);
   14dd9:	8b 45 0c             	mov    0xc(%ebp),%eax
   14ddc:	e8 fc ff ff ff       	call   14ddd <file_insertpages+0x1d>
   14de1:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	if (!in_file)
   14de4:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
   14de8:	75 05                	jne    14def <file_insertpages+0x2f>
		goto out;
   14dea:	e9 e8 00 00 00       	jmp    14ed7 <file_insertpages+0x117>
	if (!(in_file->f_mode & FMODE_READ))
   14def:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   14df2:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
   14df6:	83 e0 01             	and    $0x1,%eax
   14df9:	66 85 c0             	test   %ax,%ax
   14dfc:	75 05                	jne    14e03 <file_insertpages+0x43>
		goto fput_in;
   14dfe:	e9 cc 00 00 00       	jmp    14ecf <file_insertpages+0x10f>
	retval = -EINVAL;
   14e03:	c7 45 f4 ea ff ff ff 	movl   $0xffffffea,0xfffffff4(%ebp)
	in_inode = in_file->f_dentry->d_inode;
   14e0a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   14e0d:	8b 40 08             	mov    0x8(%eax),%eax
   14e10:	8b 40 08             	mov    0x8(%eax),%eax
   14e13:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	if (!in_inode)
   14e16:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
   14e1a:	75 05                	jne    14e21 <file_insertpages+0x61>
		goto fput_in;
   14e1c:	e9 ae 00 00 00       	jmp    14ecf <file_insertpages+0x10f>
	if (!in_inode->i_mapping->a_ops->readpage)
   14e21:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   14e24:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
   14e2a:	8b 40 1c             	mov    0x1c(%eax),%eax
   14e2d:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
   14e31:	75 05                	jne    14e38 <file_insertpages+0x78>
		goto fput_in;
   14e33:	e9 97 00 00 00       	jmp    14ecf <file_insertpages+0x10f>
	retval = locks_verify_area(FLOCK_VERIFY_READ, in_inode, in_file, in_file->f_pos, count);
   14e38:	8b 45 18             	mov    0x18(%ebp),%eax
   14e3b:	89 44 24 14          	mov    %eax,0x14(%esp,1)
   14e3f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   14e42:	8b 50 24             	mov    0x24(%eax),%edx
   14e45:	8b 40 20             	mov    0x20(%eax),%eax
   14e48:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   14e4c:	89 54 24 10          	mov    %edx,0x10(%esp,1)
   14e50:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   14e53:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   14e57:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   14e5a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   14e5e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp,1)
   14e65:	e8 53 50 00 00       	call   19ebd <locks_verify_area>
   14e6a:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	if (retval)
   14e6d:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
   14e71:	74 02                	je     14e75 <file_insertpages+0xb5>
		goto fput_in;
   14e73:	eb 5a                	jmp    14ecf <file_insertpages+0x10f>

	retval = 0;
   14e75:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
	if (count) {
   14e7c:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
   14e80:	74 4d                	je     14ecf <file_insertpages+0x10f>
		read_descriptor_t desc;

		desc.written = 0;
   14e82:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
		desc.count = count;
   14e89:	8b 45 18             	mov    0x18(%ebp),%eax
   14e8c:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
		desc.buf = (char *) skb;
   14e8f:	8b 45 08             	mov    0x8(%ebp),%eax
   14e92:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
		desc.error = 0;
   14e95:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
		do_generic_file_read(in_file, &offset, &desc, skb_fillpage_actor);
   14e9c:	c7 44 24 0c d5 4c 01 	movl   $0x14cd5,0xc(%esp,1)
   14ea3:	00 
   14ea4:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   14ea7:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   14eab:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
   14eae:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   14eb2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   14eb5:	89 04 24             	mov    %eax,(%esp,1)
   14eb8:	e8 fc ff ff ff       	call   14eb9 <file_insertpages+0xf9>

		retval = desc.written;
   14ebd:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   14ec0:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		if (!retval)
   14ec3:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
   14ec7:	75 06                	jne    14ecf <file_insertpages+0x10f>
			retval = desc.error;
   14ec9:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   14ecc:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	}

fput_in:
	fput(in_file);
   14ecf:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   14ed2:	e8 fc ff ff ff       	call   14ed3 <file_insertpages+0x113>
out:
	return retval;
   14ed7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
}
   14eda:	c9                   	leave  
   14edb:	c3                   	ret    

00014edc <fiov_handler>:

/* same structure as iov_handler */
static inline int fiov_handler(struct sock *origSK, struct cminisock *msk, struct fiovec *fiov, int fiovlen) {
   14edc:	55                   	push   %ebp
   14edd:	89 e5                	mov    %esp,%ebp
   14edf:	83 ec 58             	sub    $0x58,%esp
	printk("returning prematurely\n");
   14ee2:	c7 04 24 d4 5a 00 00 	movl   $0x5ad4,(%esp,1)
   14ee9:	e8 fc ff ff ff       	call   14eea <fiov_handler+0xe>
	return 0;
   14eee:	b8 00 00 00 00       	mov    $0x0,%eax
	int numDataPackets = 0;
	int i, totallen = 0, fiov_pos = 0, fiov_offs = 0;
	struct cminisock_packet *pkts;
	int rval = 0;
	struct sk_buff **skbs =
		kmalloc(sizeof(struct sk_buff *) * msk->num_packets, GFP_USER),
		*skb;

	if(skbs == NULL) {
		goto out;
	}
	pkts = msk->packets;

	for(i=0; i < fiovlen; i++) {
		totallen += fiov[i].len;
	}
	for(i=0; i < msk->num_packets; i++) {
		int pkt_remain;
		int short_pkt = 0;
		int copying = 1; /* initial state: allow copies. After first sendfile() request, can no longer copy */

		if(pkts[i].len > totallen) {
			short_pkt = 1;
		}
		pkt_remain = pkts[i].len = MIN(pkts[i].len, totallen);
		skb = skbs[i] = recycle(origSK);
		if(skb == NULL) {
			skb = skbs[i] = alloc_skb(MAX_TCP_HEADER + MAX_TRICKLES_SERVER_HDR_LEN + pkts[i].ucontLen + pkts[i].len, GFP_KERNEL);
		}
		numDataPackets = i+1;
		if(skb == NULL) {
			printk("could not allocate skb\n");
			goto out;
		}
		skb_reserve(skb, MAX_TCP_HEADER + MAX_TRICKLES_SERVER_HDR_LEN + pkts[i].ucontLen);

		skb->csum = 0;
		skb->ip_summed = CHECKSUM_HW;
		while(fiov_pos < fiovlen) {
			int amt = MIN(pkt_remain, fiov[fiov_pos].len - fiov_offs);
			int err = 0;
			//printk("iov copy loop, copying %d\n", amt);

			if(fiov[fiov_pos].fd == -2) {
				if(!copying) {
					printk("cannot copy; after first page fragment of packet\n");
					kfree_skb(skb);
					goto out;
				}
				/* not 64 bit safe */
				if(fiov[fiov_pos].offset + fiov_offs >= (0x1ULL << 32ULL)) {
					printk("trickles does not handle file offsets > 32 bits\n");
				}
				char *src = (char*)fiov[fiov_pos].offset + fiov_offs;
				err = skb_add_data(skb,src,amt);
				if(err) {
					printk("error while csum/copy, base = %p amt = %d pkt_type = %d\n", src, amt, msk->packets[i].type);
					kfree_skb(skb);
					rval = -EINVAL;
					goto out;
				}
			} else {
				int res;
				copying = 0;
				res = file_insertpages(skb,fiov[fiov_pos].fd, fiov[fiov_pos].offset + fiov_offs, amt);
				if(res < 0) {
					rval = res;
					printk("could not insert pages\n");
					goto out;
				}
				if(res != amt) {
					rval = res;
					printk("insufficient file data for insertion\n");
					goto out;
				}
			}
			//printk("iov[%d].iov_base (%p) + iov_offs (%u) = %p, data = %p, amt = %d, skb->csum = %x, tail = %p, tailroom = %u, iov_len = %u, &err=%p\n", iov_pos, iov[iov_pos].iov_base, iov_offs, iov[iov_pos].iov_base + iov_offs, data, amt, skb->csum, skb->tail, skb_tailroom(skb), iov[iov_pos].iov_len, &err);
			if(err) {
				printk("error while csum/copy\n");
				kfree_skb(skb);
				goto out;
			}

			totallen -= amt;
			pkt_remain -= amt;
			fiov_offs += amt;
			if(fiov_offs == fiov[fiov_pos].len) {
				fiov_offs = 0;
				fiov_pos++;
			}
			if(pkt_remain == 0) break;
		}
		BUG_TRAP(pkt_remain == 0);

		if(userapi_pkt_spew) {
			printk("sending pkts[%d] %u-%u\n", i, pkts[i].seq, pkts[i].seq + pkts[i].len);
		}
		// on last packet, set the tag to FIN
		if(totallen == 0 &&
		   fiov[fiovlen-1].offset == 0 && fiov[fiovlen-1].len == 0) {
			msk->tag = FIN;
		}

		rval += pkts[i].len; // check how much data actually sent?
		if(totallen == 0) break;
	}
	FINISH_TRANSMIT(msk, skbs, numDataPackets, NULL, 0, 0);
	// end code copied from iov_handler
	if(totallen > 0) {
		if(trickles_ratelimit())
			printk("too much data for downcall\n");
	}
 out:
	kfree(skbs);
	return rval;
}
   14ef3:	c9                   	leave  
   14ef4:	c3                   	ret    

00014ef5 <trickles_sendfilev_impl>:

int trickles_sendfilev_impl(int fd, struct cminisock *msk, struct fiovec *user_fiov, int fiovlen) {
   14ef5:	55                   	push   %ebp
   14ef6:	89 e5                	mov    %esp,%ebp
   14ef8:	83 ec 2c             	sub    $0x2c,%esp
	struct socket *sock;
	struct sock *sk;
	struct tcp_opt *tp;
	int err;
	struct fiovec *fiov;

	err = -EINVAL;
   14efb:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
	if (fiovlen < 0 || fiovlen > UIO_MAXIOV) {
   14f02:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   14f06:	0f 88 e4 03 00 00    	js     152f0 <trickles_sendfilev_impl+0x3fb>
   14f0c:	81 7d 14 00 04 00 00 	cmpl   $0x400,0x14(%ebp)
   14f13:	0f 8f d7 03 00 00    	jg     152f0 <trickles_sendfilev_impl+0x3fb>
		goto out;
	}
	{
		int fiov_size;
		err = -ENOMEM;
   14f19:	c7 45 f0 f4 ff ff ff 	movl   $0xfffffff4,0xfffffff0(%ebp)
		fiov_size = sizeof(struct fiovec) * fiovlen;
   14f20:	8b 45 14             	mov    0x14(%ebp),%eax
   14f23:	c1 e0 04             	shl    $0x4,%eax
   14f26:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
		if(fiov_size > 0) {
   14f29:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
   14f2d:	7e 4a                	jle    14f79 <trickles_sendfilev_impl+0x84>
			fiov = kmalloc(fiov_size, GFP_KERNEL);
   14f2f:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
   14f36:	00 
   14f37:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   14f3a:	89 04 24             	mov    %eax,(%esp,1)
   14f3d:	e8 fc ff ff ff       	call   14f3e <trickles_sendfilev_impl+0x49>
   14f42:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
			if(fiov == NULL) {
   14f45:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
   14f49:	75 05                	jne    14f50 <trickles_sendfilev_impl+0x5b>
				goto out;
   14f4b:	e9 a0 03 00 00       	jmp    152f0 <trickles_sendfilev_impl+0x3fb>
			}
			err = -EFAULT;
   14f50:	c7 45 f0 f2 ff ff ff 	movl   $0xfffffff2,0xfffffff0(%ebp)
			if(copy_from_user(fiov, user_fiov, fiov_size)) {
   14f57:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   14f5a:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   14f5e:	8b 45 10             	mov    0x10(%ebp),%eax
   14f61:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   14f65:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   14f68:	89 04 24             	mov    %eax,(%esp,1)
   14f6b:	e8 fc ff ff ff       	call   14f6c <trickles_sendfilev_impl+0x77>
   14f70:	85 c0                	test   %eax,%eax
   14f72:	74 0c                	je     14f80 <trickles_sendfilev_impl+0x8b>
				goto out_freefiov;
   14f74:	e9 66 03 00 00       	jmp    152df <trickles_sendfilev_impl+0x3ea>
			}
		} else {
			fiov = NULL;
   14f79:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
		}
	}

	sock = sockfd_lookup(fd, &err);
   14f80:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   14f83:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   14f87:	8b 45 08             	mov    0x8(%ebp),%eax
   14f8a:	89 04 24             	mov    %eax,(%esp,1)
   14f8d:	e8 fc ff ff ff       	call   14f8e <trickles_sendfilev_impl+0x99>
   14f92:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	if (!sock)
   14f95:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
   14f99:	75 05                	jne    14fa0 <trickles_sendfilev_impl+0xab>
		goto out_freefiov;
   14f9b:	e9 3f 03 00 00       	jmp    152df <trickles_sendfilev_impl+0x3ea>

	sk = sock->sk;
   14fa0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   14fa3:	8b 40 18             	mov    0x18(%eax),%eax
   14fa6:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	tp = &(sk->tp_pinfo.af_tcp);
   14fa9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14fac:	05 bc 00 00 00       	add    $0xbc,%eax
   14fb1:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

	lock_sock(sk);
   14fb4:	ff 05 08 00 00 00    	incl   0x8
   14fba:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14fbd:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
   14fc1:	74 0b                	je     14fce <trickles_sendfilev_impl+0xd9>
   14fc3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14fc6:	89 04 24             	mov    %eax,(%esp,1)
   14fc9:	e8 fc ff ff ff       	call   14fca <trickles_sendfilev_impl+0xd5>
   14fce:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   14fd1:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
   14fd8:	c7 45 e8 08 00 00 00 	movl   $0x8,0xffffffe8(%ebp)
   14fdf:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   14fe2:	ff 08                	decl   (%eax)
   14fe4:	83 38 00             	cmpl   $0x0,(%eax)
   14fe7:	75 0d                	jne    14ff6 <trickles_sendfilev_impl+0x101>
   14fe9:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   14fec:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   14ff0:	0f 85 ca 70 00 00    	jne    1c0c0 <.text.lock.tmalloc+0x150>
	if(!TRICKLES_USERAPI_CONFIGURED_TP(tp)) {
   14ff6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   14ff9:	83 b8 d0 01 00 00 00 	cmpl   $0x0,0x1d0(%eax)
   15000:	0f 85 84 00 00 00    	jne    1508a <trickles_sendfilev_impl+0x195>
		printk("Socket not configured\n");
   15006:	c7 04 24 c4 56 00 00 	movl   $0x56c4,(%esp,1)
   1500d:	e8 fc ff ff ff       	call   1500e <trickles_sendfilev_impl+0x119>
		release_sock(sk);
   15012:	ff 05 08 00 00 00    	incl   0x8
   15018:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1501b:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   15022:	74 0b                	je     1502f <trickles_sendfilev_impl+0x13a>
   15024:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15027:	89 04 24             	mov    %eax,(%esp,1)
   1502a:	e8 fc ff ff ff       	call   1502b <trickles_sendfilev_impl+0x136>
   1502f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15032:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   15039:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1503c:	83 c0 30             	add    $0x30,%eax
   1503f:	89 04 24             	mov    %eax,(%esp,1)
   15042:	e8 9b 4c 00 00       	call   19ce2 <waitqueue_active>
   15047:	85 c0                	test   %eax,%eax
   15049:	74 15                	je     15060 <trickles_sendfilev_impl+0x16b>
   1504b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1504e:	83 c0 30             	add    $0x30,%eax
   15051:	b9 01 00 00 00       	mov    $0x1,%ecx
   15056:	ba 03 00 00 00       	mov    $0x3,%edx
   1505b:	e8 fc ff ff ff       	call   1505c <trickles_sendfilev_impl+0x167>
   15060:	c7 45 e8 08 00 00 00 	movl   $0x8,0xffffffe8(%ebp)
   15067:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1506a:	ff 08                	decl   (%eax)
   1506c:	83 38 00             	cmpl   $0x0,(%eax)
   1506f:	75 0d                	jne    1507e <trickles_sendfilev_impl+0x189>
   15071:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   15074:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   15078:	0f 85 52 70 00 00    	jne    1c0d0 <.text.lock.tmalloc+0x160>
		err = -EINVAL;
   1507e:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
		goto out_put;
   15085:	e9 4a 02 00 00       	jmp    152d4 <trickles_sendfilev_impl+0x3df>
	}
	if(!IS_VALID_MSK(sk,msk)) {
   1508a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1508d:	05 bc 00 00 00       	add    $0xbc,%eax
   15092:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   15095:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
   1509c:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1509f:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
   150a5:	8b 50 0c             	mov    0xc(%eax),%edx
   150a8:	8b 45 0c             	mov    0xc(%ebp),%eax
   150ab:	89 c1                	mov    %eax,%ecx
   150ad:	29 d1                	sub    %edx,%ecx
   150af:	89 ca                	mov    %ecx,%edx
   150b1:	c1 ea 02             	shr    $0x2,%edx
   150b4:	b8 21 08 82 20       	mov    $0x20820821,%eax
   150b9:	f7 e2                	mul    %edx
   150bb:	c1 ea 03             	shr    $0x3,%edx
   150be:	89 d0                	mov    %edx,%eax
   150c0:	c1 e0 06             	shl    $0x6,%eax
   150c3:	29 d0                	sub    %edx,%eax
   150c5:	c1 e0 02             	shl    $0x2,%eax
   150c8:	29 c1                	sub    %eax,%ecx
   150ca:	89 c8                	mov    %ecx,%eax
   150cc:	85 c0                	test   %eax,%eax
   150ce:	75 42                	jne    15112 <trickles_sendfilev_impl+0x21d>
   150d0:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   150d3:	8b 90 cc 01 00 00    	mov    0x1cc(%eax),%edx
   150d9:	8b 45 0c             	mov    0xc(%ebp),%eax
   150dc:	3b 42 0c             	cmp    0xc(%edx),%eax
   150df:	72 31                	jb     15112 <trickles_sendfilev_impl+0x21d>
   150e1:	8b 45 0c             	mov    0xc(%ebp),%eax
   150e4:	05 fc 00 00 00       	add    $0xfc,%eax
   150e9:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   150ec:	8b 92 cc 01 00 00    	mov    0x1cc(%edx),%edx
   150f2:	3b 42 10             	cmp    0x10(%edx),%eax
   150f5:	77 1b                	ja     15112 <trickles_sendfilev_impl+0x21d>
   150f7:	8b 45 0c             	mov    0xc(%ebp),%eax
   150fa:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
   150fe:	74 0b                	je     1510b <trickles_sendfilev_impl+0x216>
   15100:	8b 45 0c             	mov    0xc(%ebp),%eax
   15103:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
   15107:	74 02                	je     1510b <trickles_sendfilev_impl+0x216>
   15109:	eb 07                	jmp    15112 <trickles_sendfilev_impl+0x21d>
   1510b:	c7 45 e4 01 00 00 00 	movl   $0x1,0xffffffe4(%ebp)
   15112:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
   15116:	0f 85 17 01 00 00    	jne    15233 <trickles_sendfilev_impl+0x33e>
		printk("bad minisocket %d %d\n", !IS_TRICKLES_SOCK_ADDR(tp,msk), !(VALID_MSK_CTL(msk)));
   1511c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
   15123:	00 
   15124:	8b 45 0c             	mov    0xc(%ebp),%eax
   15127:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
   1512b:	74 11                	je     1513e <trickles_sendfilev_impl+0x249>
   1512d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15130:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
   15134:	74 08                	je     1513e <trickles_sendfilev_impl+0x249>
   15136:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp,1)
   1513d:	00 
   1513e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
   15145:	00 
   15146:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   15149:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
   1514f:	8b 50 0c             	mov    0xc(%eax),%edx
   15152:	8b 45 0c             	mov    0xc(%ebp),%eax
   15155:	89 c1                	mov    %eax,%ecx
   15157:	29 d1                	sub    %edx,%ecx
   15159:	89 ca                	mov    %ecx,%edx
   1515b:	c1 ea 02             	shr    $0x2,%edx
   1515e:	b8 21 08 82 20       	mov    $0x20820821,%eax
   15163:	f7 e2                	mul    %edx
   15165:	c1 ea 03             	shr    $0x3,%edx
   15168:	89 d0                	mov    %edx,%eax
   1516a:	c1 e0 06             	shl    $0x6,%eax
   1516d:	29 d0                	sub    %edx,%eax
   1516f:	c1 e0 02             	shl    $0x2,%eax
   15172:	29 c1                	sub    %eax,%ecx
   15174:	89 c8                	mov    %ecx,%eax
   15176:	85 c0                	test   %eax,%eax
   15178:	75 29                	jne    151a3 <trickles_sendfilev_impl+0x2ae>
   1517a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1517d:	8b 90 cc 01 00 00    	mov    0x1cc(%eax),%edx
   15183:	8b 45 0c             	mov    0xc(%ebp),%eax
   15186:	3b 42 0c             	cmp    0xc(%edx),%eax
   15189:	72 18                	jb     151a3 <trickles_sendfilev_impl+0x2ae>
   1518b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1518e:	05 fc 00 00 00       	add    $0xfc,%eax
   15193:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   15196:	8b 92 cc 01 00 00    	mov    0x1cc(%edx),%edx
   1519c:	3b 42 10             	cmp    0x10(%edx),%eax
   1519f:	77 02                	ja     151a3 <trickles_sendfilev_impl+0x2ae>
   151a1:	eb 08                	jmp    151ab <trickles_sendfilev_impl+0x2b6>
   151a3:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
   151aa:	00 
   151ab:	c7 04 24 db 56 00 00 	movl   $0x56db,(%esp,1)
   151b2:	e8 fc ff ff ff       	call   151b3 <trickles_sendfilev_impl+0x2be>
		err = -EINVAL;
   151b7:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
		release_sock(sk);
   151be:	ff 05 08 00 00 00    	incl   0x8
   151c4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   151c7:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   151ce:	74 0b                	je     151db <trickles_sendfilev_impl+0x2e6>
   151d0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   151d3:	89 04 24             	mov    %eax,(%esp,1)
   151d6:	e8 fc ff ff ff       	call   151d7 <trickles_sendfilev_impl+0x2e2>
   151db:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   151de:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   151e5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   151e8:	83 c0 30             	add    $0x30,%eax
   151eb:	89 04 24             	mov    %eax,(%esp,1)
   151ee:	e8 ef 4a 00 00       	call   19ce2 <waitqueue_active>
   151f3:	85 c0                	test   %eax,%eax
   151f5:	74 15                	je     1520c <trickles_sendfilev_impl+0x317>
   151f7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   151fa:	83 c0 30             	add    $0x30,%eax
   151fd:	b9 01 00 00 00       	mov    $0x1,%ecx
   15202:	ba 03 00 00 00       	mov    $0x3,%edx
   15207:	e8 fc ff ff ff       	call   15208 <trickles_sendfilev_impl+0x313>
   1520c:	c7 45 e8 08 00 00 00 	movl   $0x8,0xffffffe8(%ebp)
   15213:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   15216:	ff 08                	decl   (%eax)
   15218:	83 38 00             	cmpl   $0x0,(%eax)
   1521b:	0f 85 b3 00 00 00    	jne    152d4 <trickles_sendfilev_impl+0x3df>
   15221:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   15224:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   15228:	0f 85 b2 6e 00 00    	jne    1c0e0 <.text.lock.tmalloc+0x170>
		goto out_put;
   1522e:	e9 a1 00 00 00       	jmp    152d4 <trickles_sendfilev_impl+0x3df>
	}

	free_trickles_msk(sk,msk);
   15233:	8b 45 0c             	mov    0xc(%ebp),%eax
   15236:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1523a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1523d:	89 04 24             	mov    %eax,(%esp,1)
   15240:	e8 c8 d5 ff ff       	call   1280d <free_trickles_msk>

	{
		err = trickles_do_sendmsg_fiov(sk,msk,fiov,fiovlen);
   15245:	8b 45 14             	mov    0x14(%ebp),%eax
   15248:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   1524c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1524f:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   15253:	8b 45 0c             	mov    0xc(%ebp),%eax
   15256:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1525a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1525d:	89 04 24             	mov    %eax,(%esp,1)
   15260:	e8 c4 5e 00 00       	call   1b129 <trickles_do_sendmsg_fiov>
   15265:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	}

	release_sock(sk);
   15268:	ff 05 08 00 00 00    	incl   0x8
   1526e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15271:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   15278:	74 0b                	je     15285 <trickles_sendfilev_impl+0x390>
   1527a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1527d:	89 04 24             	mov    %eax,(%esp,1)
   15280:	e8 fc ff ff ff       	call   15281 <trickles_sendfilev_impl+0x38c>
   15285:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15288:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   1528f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15292:	83 c0 30             	add    $0x30,%eax
   15295:	89 04 24             	mov    %eax,(%esp,1)
   15298:	e8 45 4a 00 00       	call   19ce2 <waitqueue_active>
   1529d:	85 c0                	test   %eax,%eax
   1529f:	74 15                	je     152b6 <trickles_sendfilev_impl+0x3c1>
   152a1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   152a4:	83 c0 30             	add    $0x30,%eax
   152a7:	b9 01 00 00 00       	mov    $0x1,%ecx
   152ac:	ba 03 00 00 00       	mov    $0x3,%edx
   152b1:	e8 fc ff ff ff       	call   152b2 <trickles_sendfilev_impl+0x3bd>
   152b6:	c7 45 e8 08 00 00 00 	movl   $0x8,0xffffffe8(%ebp)
   152bd:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   152c0:	ff 08                	decl   (%eax)
   152c2:	83 38 00             	cmpl   $0x0,(%eax)
   152c5:	75 0d                	jne    152d4 <trickles_sendfilev_impl+0x3df>
   152c7:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   152ca:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   152ce:	0f 85 1c 6e 00 00    	jne    1c0f0 <.text.lock.tmalloc+0x180>
 out_put:
	sockfd_put(sock);
   152d4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   152d7:	89 04 24             	mov    %eax,(%esp,1)
   152da:	e8 63 61 00 00       	call   1b442 <sockfd_put>
 out_freefiov:
	if(fiovlen > 0)
   152df:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   152e3:	7e 0b                	jle    152f0 <trickles_sendfilev_impl+0x3fb>
		kfree(fiov);
   152e5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   152e8:	89 04 24             	mov    %eax,(%esp,1)
   152eb:	e8 fc ff ff ff       	call   152ec <trickles_sendfilev_impl+0x3f7>
 out:
	return err;
   152f0:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
}
   152f3:	c9                   	leave  
   152f4:	c3                   	ret    

000152f5 <trickles_send_impl>:

int trickles_send_impl(int fd, struct cminisock *msk, char *buf, int len) {
   152f5:	55                   	push   %ebp
   152f6:	89 e5                	mov    %esp,%ebp
   152f8:	83 ec 30             	sub    $0x30,%esp
	struct socket *sock;
	struct sock *sk;
	struct tcp_opt *tp;
	int err;
	struct tiovec iov = {iov_base: buf, iov_len: len,
   152fb:	8b 45 10             	mov    0x10(%ebp),%eax
   152fe:	8b 55 14             	mov    0x14(%ebp),%edx
   15301:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   15304:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
#ifdef SETUCONT_COMMAND
			     ucont_base: NULL,
			     ucont_len: 0
#endif // SETUCONT_COMMAND
	};

	sock = sockfd_lookup(fd, &err);
   15307:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   1530a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1530e:	8b 45 08             	mov    0x8(%ebp),%eax
   15311:	89 04 24             	mov    %eax,(%esp,1)
   15314:	e8 fc ff ff ff       	call   15315 <trickles_send_impl+0x20>
   15319:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	if (!sock)
   1531c:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
   15320:	75 05                	jne    15327 <trickles_send_impl+0x32>
		goto out;
   15322:	e9 8d 03 00 00       	jmp    156b4 <trickles_send_impl+0x3bf>

	sk = sock->sk;
   15327:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1532a:	8b 40 18             	mov    0x18(%eax),%eax
   1532d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	tp = &(sk->tp_pinfo.af_tcp);
   15330:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15333:	05 bc 00 00 00       	add    $0xbc,%eax
   15338:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

	lock_sock(sk);
   1533b:	ff 05 08 00 00 00    	incl   0x8
   15341:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15344:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
   15348:	74 0b                	je     15355 <trickles_send_impl+0x60>
   1534a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1534d:	89 04 24             	mov    %eax,(%esp,1)
   15350:	e8 fc ff ff ff       	call   15351 <trickles_send_impl+0x5c>
   15355:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15358:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
   1535f:	c7 45 e4 08 00 00 00 	movl   $0x8,0xffffffe4(%ebp)
   15366:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   15369:	ff 08                	decl   (%eax)
   1536b:	83 38 00             	cmpl   $0x0,(%eax)
   1536e:	75 0d                	jne    1537d <trickles_send_impl+0x88>
   15370:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   15373:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   15377:	0f 85 83 6d 00 00    	jne    1c100 <.text.lock.tmalloc+0x190>
	if(!TRICKLES_USERAPI_CONFIGURED_TP(tp)) {
   1537d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   15380:	83 b8 d0 01 00 00 00 	cmpl   $0x0,0x1d0(%eax)
   15387:	0f 85 84 00 00 00    	jne    15411 <trickles_send_impl+0x11c>
		printk("Socket not configured\n");
   1538d:	c7 04 24 c4 56 00 00 	movl   $0x56c4,(%esp,1)
   15394:	e8 fc ff ff ff       	call   15395 <trickles_send_impl+0xa0>
		release_sock(sk);
   15399:	ff 05 08 00 00 00    	incl   0x8
   1539f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   153a2:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   153a9:	74 0b                	je     153b6 <trickles_send_impl+0xc1>
   153ab:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   153ae:	89 04 24             	mov    %eax,(%esp,1)
   153b1:	e8 fc ff ff ff       	call   153b2 <trickles_send_impl+0xbd>
   153b6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   153b9:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   153c0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   153c3:	83 c0 30             	add    $0x30,%eax
   153c6:	89 04 24             	mov    %eax,(%esp,1)
   153c9:	e8 14 49 00 00       	call   19ce2 <waitqueue_active>
   153ce:	85 c0                	test   %eax,%eax
   153d0:	74 15                	je     153e7 <trickles_send_impl+0xf2>
   153d2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   153d5:	83 c0 30             	add    $0x30,%eax
   153d8:	b9 01 00 00 00       	mov    $0x1,%ecx
   153dd:	ba 03 00 00 00       	mov    $0x3,%edx
   153e2:	e8 fc ff ff ff       	call   153e3 <trickles_send_impl+0xee>
   153e7:	c7 45 e4 08 00 00 00 	movl   $0x8,0xffffffe4(%ebp)
   153ee:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   153f1:	ff 08                	decl   (%eax)
   153f3:	83 38 00             	cmpl   $0x0,(%eax)
   153f6:	75 0d                	jne    15405 <trickles_send_impl+0x110>
   153f8:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   153fb:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   153ff:	0f 85 0b 6d 00 00    	jne    1c110 <.text.lock.tmalloc+0x1a0>
		err = -EINVAL;
   15405:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
		goto out_put;
   1540c:	e9 98 02 00 00       	jmp    156a9 <trickles_send_impl+0x3b4>
	}
	if(!IS_VALID_MSK(sk,msk)) {
   15411:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15414:	05 bc 00 00 00       	add    $0xbc,%eax
   15419:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   1541c:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
   15423:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   15426:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
   1542c:	8b 50 0c             	mov    0xc(%eax),%edx
   1542f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15432:	89 c1                	mov    %eax,%ecx
   15434:	29 d1                	sub    %edx,%ecx
   15436:	89 ca                	mov    %ecx,%edx
   15438:	c1 ea 02             	shr    $0x2,%edx
   1543b:	b8 21 08 82 20       	mov    $0x20820821,%eax
   15440:	f7 e2                	mul    %edx
   15442:	c1 ea 03             	shr    $0x3,%edx
   15445:	89 d0                	mov    %edx,%eax
   15447:	c1 e0 06             	shl    $0x6,%eax
   1544a:	29 d0                	sub    %edx,%eax
   1544c:	c1 e0 02             	shl    $0x2,%eax
   1544f:	29 c1                	sub    %eax,%ecx
   15451:	89 c8                	mov    %ecx,%eax
   15453:	85 c0                	test   %eax,%eax
   15455:	75 42                	jne    15499 <trickles_send_impl+0x1a4>
   15457:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1545a:	8b 90 cc 01 00 00    	mov    0x1cc(%eax),%edx
   15460:	8b 45 0c             	mov    0xc(%ebp),%eax
   15463:	3b 42 0c             	cmp    0xc(%edx),%eax
   15466:	72 31                	jb     15499 <trickles_send_impl+0x1a4>
   15468:	8b 45 0c             	mov    0xc(%ebp),%eax
   1546b:	05 fc 00 00 00       	add    $0xfc,%eax
   15470:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   15473:	8b 92 cc 01 00 00    	mov    0x1cc(%edx),%edx
   15479:	3b 42 10             	cmp    0x10(%edx),%eax
   1547c:	77 1b                	ja     15499 <trickles_send_impl+0x1a4>
   1547e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15481:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
   15485:	74 0b                	je     15492 <trickles_send_impl+0x19d>
   15487:	8b 45 0c             	mov    0xc(%ebp),%eax
   1548a:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
   1548e:	74 02                	je     15492 <trickles_send_impl+0x19d>
   15490:	eb 07                	jmp    15499 <trickles_send_impl+0x1a4>
   15492:	c7 45 e0 01 00 00 00 	movl   $0x1,0xffffffe0(%ebp)
   15499:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
   1549d:	0f 85 f5 00 00 00    	jne    15598 <trickles_send_impl+0x2a3>
		printk("bad minisocket %d\n", !IS_TRICKLES_SOCK_ADDR(tp,msk));
   154a3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
   154aa:	00 
   154ab:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   154ae:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
   154b4:	8b 50 0c             	mov    0xc(%eax),%edx
   154b7:	8b 45 0c             	mov    0xc(%ebp),%eax
   154ba:	89 c1                	mov    %eax,%ecx
   154bc:	29 d1                	sub    %edx,%ecx
   154be:	89 ca                	mov    %ecx,%edx
   154c0:	c1 ea 02             	shr    $0x2,%edx
   154c3:	b8 21 08 82 20       	mov    $0x20820821,%eax
   154c8:	f7 e2                	mul    %edx
   154ca:	c1 ea 03             	shr    $0x3,%edx
   154cd:	89 d0                	mov    %edx,%eax
   154cf:	c1 e0 06             	shl    $0x6,%eax
   154d2:	29 d0                	sub    %edx,%eax
   154d4:	c1 e0 02             	shl    $0x2,%eax
   154d7:	29 c1                	sub    %eax,%ecx
   154d9:	89 c8                	mov    %ecx,%eax
   154db:	85 c0                	test   %eax,%eax
   154dd:	75 29                	jne    15508 <trickles_send_impl+0x213>
   154df:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   154e2:	8b 90 cc 01 00 00    	mov    0x1cc(%eax),%edx
   154e8:	8b 45 0c             	mov    0xc(%ebp),%eax
   154eb:	3b 42 0c             	cmp    0xc(%edx),%eax
   154ee:	72 18                	jb     15508 <trickles_send_impl+0x213>
   154f0:	8b 45 0c             	mov    0xc(%ebp),%eax
   154f3:	05 fc 00 00 00       	add    $0xfc,%eax
   154f8:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   154fb:	8b 92 cc 01 00 00    	mov    0x1cc(%edx),%edx
   15501:	3b 42 10             	cmp    0x10(%edx),%eax
   15504:	77 02                	ja     15508 <trickles_send_impl+0x213>
   15506:	eb 08                	jmp    15510 <trickles_send_impl+0x21b>
   15508:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
   1550f:	00 
   15510:	c7 04 24 eb 5a 00 00 	movl   $0x5aeb,(%esp,1)
   15517:	e8 fc ff ff ff       	call   15518 <trickles_send_impl+0x223>
		err = -EINVAL;
   1551c:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
		release_sock(sk);
   15523:	ff 05 08 00 00 00    	incl   0x8
   15529:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1552c:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   15533:	74 0b                	je     15540 <trickles_send_impl+0x24b>
   15535:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15538:	89 04 24             	mov    %eax,(%esp,1)
   1553b:	e8 fc ff ff ff       	call   1553c <trickles_send_impl+0x247>
   15540:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15543:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   1554a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1554d:	83 c0 30             	add    $0x30,%eax
   15550:	89 04 24             	mov    %eax,(%esp,1)
   15553:	e8 8a 47 00 00       	call   19ce2 <waitqueue_active>
   15558:	85 c0                	test   %eax,%eax
   1555a:	74 15                	je     15571 <trickles_send_impl+0x27c>
   1555c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1555f:	83 c0 30             	add    $0x30,%eax
   15562:	b9 01 00 00 00       	mov    $0x1,%ecx
   15567:	ba 03 00 00 00       	mov    $0x3,%edx
   1556c:	e8 fc ff ff ff       	call   1556d <trickles_send_impl+0x278>
   15571:	c7 45 e4 08 00 00 00 	movl   $0x8,0xffffffe4(%ebp)
   15578:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1557b:	ff 08                	decl   (%eax)
   1557d:	83 38 00             	cmpl   $0x0,(%eax)
   15580:	0f 85 23 01 00 00    	jne    156a9 <trickles_send_impl+0x3b4>
   15586:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   15589:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   1558d:	0f 85 8d 6b 00 00    	jne    1c120 <.text.lock.tmalloc+0x1b0>
		goto out_put;
   15593:	e9 11 01 00 00       	jmp    156a9 <trickles_send_impl+0x3b4>
	}
	free_trickles_msk(sk,msk);
   15598:	8b 45 0c             	mov    0xc(%ebp),%eax
   1559b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1559f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   155a2:	89 04 24             	mov    %eax,(%esp,1)
   155a5:	e8 63 d2 ff ff       	call   1280d <free_trickles_msk>

	if(iov.iov_len == -1) {
   155aa:	83 7d ec ff          	cmpl   $0xffffffff,0xffffffec(%ebp)
   155ae:	75 1b                	jne    155cb <trickles_send_impl+0x2d6>
		free_trickles_msk_finish(sk,msk);
   155b0:	8b 45 0c             	mov    0xc(%ebp),%eax
   155b3:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   155b7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   155ba:	89 04 24             	mov    %eax,(%esp,1)
   155bd:	e8 e9 d2 ff ff       	call   128ab <free_trickles_msk_finish>
		err = 0;
   155c2:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
   155c9:	eb 72                	jmp    1563d <trickles_send_impl+0x348>
	} else if(iov.iov_len == -2) {
   155cb:	83 7d ec fe          	cmpl   $0xfffffffe,0xffffffec(%ebp)
   155cf:	75 31                	jne    15602 <trickles_send_impl+0x30d>
		if(msk->ctl != ALLOC_HALFFREE) {
   155d1:	8b 45 0c             	mov    0xc(%ebp),%eax
   155d4:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
   155d8:	74 13                	je     155ed <trickles_send_impl+0x2f8>
			msk->ctl = ALLOC_HALFFREE;
   155da:	8b 45 0c             	mov    0xc(%ebp),%eax
   155dd:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
			// Remove from list, but dont deallocate
			err = 0;
   155e4:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
   155eb:	eb 50                	jmp    1563d <trickles_send_impl+0x348>
		} else {
			/* already half-freed ! */
			printk("already half freed\n");
   155ed:	c7 04 24 fe 5a 00 00 	movl   $0x5afe,(%esp,1)
   155f4:	e8 fc ff ff ff       	call   155f5 <trickles_send_impl+0x300>
			err = -EINVAL;
   155f9:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
   15600:	eb 3b                	jmp    1563d <trickles_send_impl+0x348>
		}
	} else if(iov.iov_len == -3) {
   15602:	83 7d ec fd          	cmpl   $0xfffffffd,0xffffffec(%ebp)
   15606:	75 11                	jne    15619 <trickles_send_impl+0x324>
		msk->tag = FIN;
   15608:	8b 45 0c             	mov    0xc(%ebp),%eax
   1560b:	c7 40 10 02 00 00 00 	movl   $0x2,0x10(%eax)
		iov.iov_len = 0;
   15612:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
		goto more;
	} else {
	more:
		err = trickles_do_sendmsg_tiov(sk,msk,&iov,1);
   15619:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp,1)
   15620:	00 
   15621:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   15624:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   15628:	8b 45 0c             	mov    0xc(%ebp),%eax
   1562b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1562f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15632:	89 04 24             	mov    %eax,(%esp,1)
   15635:	e8 d6 57 00 00       	call   1ae10 <trickles_do_sendmsg_tiov>
   1563a:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	}

	release_sock(sk);
   1563d:	ff 05 08 00 00 00    	incl   0x8
   15643:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15646:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   1564d:	74 0b                	je     1565a <trickles_send_impl+0x365>
   1564f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15652:	89 04 24             	mov    %eax,(%esp,1)
   15655:	e8 fc ff ff ff       	call   15656 <trickles_send_impl+0x361>
   1565a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1565d:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   15664:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15667:	83 c0 30             	add    $0x30,%eax
   1566a:	89 04 24             	mov    %eax,(%esp,1)
   1566d:	e8 70 46 00 00       	call   19ce2 <waitqueue_active>
   15672:	85 c0                	test   %eax,%eax
   15674:	74 15                	je     1568b <trickles_send_impl+0x396>
   15676:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15679:	83 c0 30             	add    $0x30,%eax
   1567c:	b9 01 00 00 00       	mov    $0x1,%ecx
   15681:	ba 03 00 00 00       	mov    $0x3,%edx
   15686:	e8 fc ff ff ff       	call   15687 <trickles_send_impl+0x392>
   1568b:	c7 45 e4 08 00 00 00 	movl   $0x8,0xffffffe4(%ebp)
   15692:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   15695:	ff 08                	decl   (%eax)
   15697:	83 38 00             	cmpl   $0x0,(%eax)
   1569a:	75 0d                	jne    156a9 <trickles_send_impl+0x3b4>
   1569c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1569f:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   156a3:	0f 85 87 6a 00 00    	jne    1c130 <.text.lock.tmalloc+0x1c0>
out_put:
	sockfd_put(sock);
   156a9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   156ac:	89 04 24             	mov    %eax,(%esp,1)
   156af:	e8 8e 5d 00 00       	call   1b442 <sockfd_put>
 out:
	return err;
   156b4:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
}
   156b7:	c9                   	leave  
   156b8:	c3                   	ret    

000156b9 <trickles_mmap_impl>:

int trickles_mmap_impl(struct file *file, struct socket *sock, struct vm_area_struct *vma) {
   156b9:	55                   	push   %ebp
   156ba:	89 e5                	mov    %esp,%ebp
   156bc:	83 ec 10             	sub    $0x10,%esp
	struct sock *sk = sock->sk;
   156bf:	8b 45 0c             	mov    0xc(%ebp),%eax
   156c2:	8b 40 18             	mov    0x18(%eax),%eax
   156c5:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
   156c8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   156cb:	05 bc 00 00 00       	add    $0xbc,%eax
   156d0:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

	if(!TRICKLES_USERAPI_CONFIGURED_TP(tp)) {
   156d3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   156d6:	83 b8 d0 01 00 00 00 	cmpl   $0x0,0x1d0(%eax)
   156dd:	75 15                	jne    156f4 <trickles_mmap_impl+0x3b>
		printk("mmap before configuration\n");
   156df:	c7 04 24 12 5b 00 00 	movl   $0x5b12,(%esp,1)
   156e6:	e8 fc ff ff ff       	call   156e7 <trickles_mmap_impl+0x2e>
		return -EINVAL;
   156eb:	c7 45 f4 ea ff ff ff 	movl   $0xffffffea,0xfffffff4(%ebp)
   156f2:	eb 2b                	jmp    1571f <trickles_mmap_impl+0x66>
	}
	printk("trickles mmap called\n");
   156f4:	c7 04 24 2d 5b 00 00 	movl   $0x5b2d,(%esp,1)
   156fb:	e8 fc ff ff ff       	call   156fc <trickles_mmap_impl+0x43>
	vma->vm_ops = &trickles_vm_ops;
   15700:	8b 45 10             	mov    0x10(%ebp),%eax
   15703:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
	vma->vm_private_data = &tp->cminisock_api_config;
   1570a:	8b 55 10             	mov    0x10(%ebp),%edx
   1570d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15710:	05 c8 01 00 00       	add    $0x1c8,%eax
   15715:	89 42 40             	mov    %eax,0x40(%edx)
	return 0;
   15718:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
}
   1571f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   15722:	c9                   	leave  
   15723:	c3                   	ret    

00015724 <trickles_setucont_impl>:

int trickles_setucont_impl(int fd, struct cminisock *msk, int pkt_num,
			   char *user_ucont, unsigned ucont_len) {
   15724:	55                   	push   %ebp
   15725:	89 e5                	mov    %esp,%ebp
   15727:	83 ec 28             	sub    $0x28,%esp
	struct socket *sock;
	struct sock *sk;
	struct tcp_opt *tp;
	int err;
	char *buf;

	extern int gNumSetUCont;
	gNumSetUCont++;
   1572a:	ff 05 00 00 00 00    	incl   0x0

	sock = sockfd_lookup(fd, &err);
   15730:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   15733:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   15737:	8b 45 08             	mov    0x8(%ebp),%eax
   1573a:	89 04 24             	mov    %eax,(%esp,1)
   1573d:	e8 fc ff ff ff       	call   1573e <trickles_setucont_impl+0x1a>
   15742:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	if (!sock)
   15745:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
   15749:	75 05                	jne    15750 <trickles_setucont_impl+0x2c>
		goto out;
   1574b:	e9 62 05 00 00       	jmp    15cb2 <trickles_setucont_impl+0x58e>

	sk = sock->sk;
   15750:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   15753:	8b 40 18             	mov    0x18(%eax),%eax
   15756:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	tp = &(sk->tp_pinfo.af_tcp);
   15759:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1575c:	05 bc 00 00 00       	add    $0xbc,%eax
   15761:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

	lock_sock(sk);
   15764:	ff 05 08 00 00 00    	incl   0x8
   1576a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1576d:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
   15771:	74 0b                	je     1577e <trickles_setucont_impl+0x5a>
   15773:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15776:	89 04 24             	mov    %eax,(%esp,1)
   15779:	e8 fc ff ff ff       	call   1577a <trickles_setucont_impl+0x56>
   1577e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15781:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
   15788:	c7 45 e8 08 00 00 00 	movl   $0x8,0xffffffe8(%ebp)
   1578f:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   15792:	ff 08                	decl   (%eax)
   15794:	83 38 00             	cmpl   $0x0,(%eax)
   15797:	75 0d                	jne    157a6 <trickles_setucont_impl+0x82>
   15799:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1579c:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   157a0:	0f 85 9a 69 00 00    	jne    1c140 <.text.lock.tmalloc+0x1d0>
	if(!TRICKLES_USERAPI_CONFIGURED_TP(tp)) {
   157a6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   157a9:	83 b8 d0 01 00 00 00 	cmpl   $0x0,0x1d0(%eax)
   157b0:	0f 85 84 00 00 00    	jne    1583a <trickles_setucont_impl+0x116>
		printk("Socket not configured\n");
   157b6:	c7 04 24 c4 56 00 00 	movl   $0x56c4,(%esp,1)
   157bd:	e8 fc ff ff ff       	call   157be <trickles_setucont_impl+0x9a>
		release_sock(sk);
   157c2:	ff 05 08 00 00 00    	incl   0x8
   157c8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   157cb:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   157d2:	74 0b                	je     157df <trickles_setucont_impl+0xbb>
   157d4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   157d7:	89 04 24             	mov    %eax,(%esp,1)
   157da:	e8 fc ff ff ff       	call   157db <trickles_setucont_impl+0xb7>
   157df:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   157e2:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   157e9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   157ec:	83 c0 30             	add    $0x30,%eax
   157ef:	89 04 24             	mov    %eax,(%esp,1)
   157f2:	e8 eb 44 00 00       	call   19ce2 <waitqueue_active>
   157f7:	85 c0                	test   %eax,%eax
   157f9:	74 15                	je     15810 <trickles_setucont_impl+0xec>
   157fb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   157fe:	83 c0 30             	add    $0x30,%eax
   15801:	b9 01 00 00 00       	mov    $0x1,%ecx
   15806:	ba 03 00 00 00       	mov    $0x3,%edx
   1580b:	e8 fc ff ff ff       	call   1580c <trickles_setucont_impl+0xe8>
   15810:	c7 45 e8 08 00 00 00 	movl   $0x8,0xffffffe8(%ebp)
   15817:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1581a:	ff 08                	decl   (%eax)
   1581c:	83 38 00             	cmpl   $0x0,(%eax)
   1581f:	75 0d                	jne    1582e <trickles_setucont_impl+0x10a>
   15821:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   15824:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   15828:	0f 85 22 69 00 00    	jne    1c150 <.text.lock.tmalloc+0x1e0>
		err = -EINVAL;
   1582e:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
		goto out_put;
   15835:	e9 6d 04 00 00       	jmp    15ca7 <trickles_setucont_impl+0x583>
	}
	if(!IS_VALID_MSK(sk,msk)) {
   1583a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1583d:	05 bc 00 00 00       	add    $0xbc,%eax
   15842:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   15845:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
   1584c:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1584f:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
   15855:	8b 50 0c             	mov    0xc(%eax),%edx
   15858:	8b 45 0c             	mov    0xc(%ebp),%eax
   1585b:	89 c1                	mov    %eax,%ecx
   1585d:	29 d1                	sub    %edx,%ecx
   1585f:	89 ca                	mov    %ecx,%edx
   15861:	c1 ea 02             	shr    $0x2,%edx
   15864:	b8 21 08 82 20       	mov    $0x20820821,%eax
   15869:	f7 e2                	mul    %edx
   1586b:	c1 ea 03             	shr    $0x3,%edx
   1586e:	89 d0                	mov    %edx,%eax
   15870:	c1 e0 06             	shl    $0x6,%eax
   15873:	29 d0                	sub    %edx,%eax
   15875:	c1 e0 02             	shl    $0x2,%eax
   15878:	29 c1                	sub    %eax,%ecx
   1587a:	89 c8                	mov    %ecx,%eax
   1587c:	85 c0                	test   %eax,%eax
   1587e:	75 42                	jne    158c2 <trickles_setucont_impl+0x19e>
   15880:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   15883:	8b 90 cc 01 00 00    	mov    0x1cc(%eax),%edx
   15889:	8b 45 0c             	mov    0xc(%ebp),%eax
   1588c:	3b 42 0c             	cmp    0xc(%edx),%eax
   1588f:	72 31                	jb     158c2 <trickles_setucont_impl+0x19e>
   15891:	8b 45 0c             	mov    0xc(%ebp),%eax
   15894:	05 fc 00 00 00       	add    $0xfc,%eax
   15899:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   1589c:	8b 92 cc 01 00 00    	mov    0x1cc(%edx),%edx
   158a2:	3b 42 10             	cmp    0x10(%edx),%eax
   158a5:	77 1b                	ja     158c2 <trickles_setucont_impl+0x19e>
   158a7:	8b 45 0c             	mov    0xc(%ebp),%eax
   158aa:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
   158ae:	74 0b                	je     158bb <trickles_setucont_impl+0x197>
   158b0:	8b 45 0c             	mov    0xc(%ebp),%eax
   158b3:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
   158b7:	74 02                	je     158bb <trickles_setucont_impl+0x197>
   158b9:	eb 07                	jmp    158c2 <trickles_setucont_impl+0x19e>
   158bb:	c7 45 e4 01 00 00 00 	movl   $0x1,0xffffffe4(%ebp)
   158c2:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
   158c6:	0f 85 17 01 00 00    	jne    159e3 <trickles_setucont_impl+0x2bf>
		printk("bad minisocket %d %d\n", !IS_TRICKLES_SOCK_ADDR(tp,msk), !(VALID_MSK_CTL(msk)));
   158cc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
   158d3:	00 
   158d4:	8b 45 0c             	mov    0xc(%ebp),%eax
   158d7:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
   158db:	74 11                	je     158ee <trickles_setucont_impl+0x1ca>
   158dd:	8b 45 0c             	mov    0xc(%ebp),%eax
   158e0:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
   158e4:	74 08                	je     158ee <trickles_setucont_impl+0x1ca>
   158e6:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp,1)
   158ed:	00 
   158ee:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
   158f5:	00 
   158f6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   158f9:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
   158ff:	8b 50 0c             	mov    0xc(%eax),%edx
   15902:	8b 45 0c             	mov    0xc(%ebp),%eax
   15905:	89 c1                	mov    %eax,%ecx
   15907:	29 d1                	sub    %edx,%ecx
   15909:	89 ca                	mov    %ecx,%edx
   1590b:	c1 ea 02             	shr    $0x2,%edx
   1590e:	b8 21 08 82 20       	mov    $0x20820821,%eax
   15913:	f7 e2                	mul    %edx
   15915:	c1 ea 03             	shr    $0x3,%edx
   15918:	89 d0                	mov    %edx,%eax
   1591a:	c1 e0 06             	shl    $0x6,%eax
   1591d:	29 d0                	sub    %edx,%eax
   1591f:	c1 e0 02             	shl    $0x2,%eax
   15922:	29 c1                	sub    %eax,%ecx
   15924:	89 c8                	mov    %ecx,%eax
   15926:	85 c0                	test   %eax,%eax
   15928:	75 29                	jne    15953 <trickles_setucont_impl+0x22f>
   1592a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1592d:	8b 90 cc 01 00 00    	mov    0x1cc(%eax),%edx
   15933:	8b 45 0c             	mov    0xc(%ebp),%eax
   15936:	3b 42 0c             	cmp    0xc(%edx),%eax
   15939:	72 18                	jb     15953 <trickles_setucont_impl+0x22f>
   1593b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1593e:	05 fc 00 00 00       	add    $0xfc,%eax
   15943:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   15946:	8b 92 cc 01 00 00    	mov    0x1cc(%edx),%edx
   1594c:	3b 42 10             	cmp    0x10(%edx),%eax
   1594f:	77 02                	ja     15953 <trickles_setucont_impl+0x22f>
   15951:	eb 08                	jmp    1595b <trickles_setucont_impl+0x237>
   15953:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
   1595a:	00 
   1595b:	c7 04 24 db 56 00 00 	movl   $0x56db,(%esp,1)
   15962:	e8 fc ff ff ff       	call   15963 <trickles_setucont_impl+0x23f>
		err = -EINVAL;
   15967:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
		release_sock(sk);
   1596e:	ff 05 08 00 00 00    	incl   0x8
   15974:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15977:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   1597e:	74 0b                	je     1598b <trickles_setucont_impl+0x267>
   15980:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15983:	89 04 24             	mov    %eax,(%esp,1)
   15986:	e8 fc ff ff ff       	call   15987 <trickles_setucont_impl+0x263>
   1598b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1598e:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   15995:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15998:	83 c0 30             	add    $0x30,%eax
   1599b:	89 04 24             	mov    %eax,(%esp,1)
   1599e:	e8 3f 43 00 00       	call   19ce2 <waitqueue_active>
   159a3:	85 c0                	test   %eax,%eax
   159a5:	74 15                	je     159bc <trickles_setucont_impl+0x298>
   159a7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   159aa:	83 c0 30             	add    $0x30,%eax
   159ad:	b9 01 00 00 00       	mov    $0x1,%ecx
   159b2:	ba 03 00 00 00       	mov    $0x3,%edx
   159b7:	e8 fc ff ff ff       	call   159b8 <trickles_setucont_impl+0x294>
   159bc:	c7 45 e8 08 00 00 00 	movl   $0x8,0xffffffe8(%ebp)
   159c3:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   159c6:	ff 08                	decl   (%eax)
   159c8:	83 38 00             	cmpl   $0x0,(%eax)
   159cb:	0f 85 d6 02 00 00    	jne    15ca7 <trickles_setucont_impl+0x583>
   159d1:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   159d4:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   159d8:	0f 85 82 67 00 00    	jne    1c160 <.text.lock.tmalloc+0x1f0>
		goto out_put;
   159de:	e9 c4 02 00 00       	jmp    15ca7 <trickles_setucont_impl+0x583>
	}
	if(pkt_num < 0 || pkt_num >= msk->num_packets) {
   159e3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   159e7:	78 13                	js     159fc <trickles_setucont_impl+0x2d8>
   159e9:	8b 55 0c             	mov    0xc(%ebp),%edx
   159ec:	8b 45 10             	mov    0x10(%ebp),%eax
   159ef:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
   159f5:	7d 05                	jge    159fc <trickles_setucont_impl+0x2d8>
   159f7:	e9 88 00 00 00       	jmp    15a84 <trickles_setucont_impl+0x360>
		printk("invalid packet #\n");
   159fc:	c7 04 24 43 5b 00 00 	movl   $0x5b43,(%esp,1)
   15a03:	e8 fc ff ff ff       	call   15a04 <trickles_setucont_impl+0x2e0>
		err = -EINVAL;
   15a08:	c7 45 f0 ea ff ff ff 	movl   $0xffffffea,0xfffffff0(%ebp)
		release_sock(sk);
   15a0f:	ff 05 08 00 00 00    	incl   0x8
   15a15:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15a18:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   15a1f:	74 0b                	je     15a2c <trickles_setucont_impl+0x308>
   15a21:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15a24:	89 04 24             	mov    %eax,(%esp,1)
   15a27:	e8 fc ff ff ff       	call   15a28 <trickles_setucont_impl+0x304>
   15a2c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15a2f:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   15a36:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15a39:	83 c0 30             	add    $0x30,%eax
   15a3c:	89 04 24             	mov    %eax,(%esp,1)
   15a3f:	e8 9e 42 00 00       	call   19ce2 <waitqueue_active>
   15a44:	85 c0                	test   %eax,%eax
   15a46:	74 15                	je     15a5d <trickles_setucont_impl+0x339>
   15a48:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15a4b:	83 c0 30             	add    $0x30,%eax
   15a4e:	b9 01 00 00 00       	mov    $0x1,%ecx
   15a53:	ba 03 00 00 00       	mov    $0x3,%edx
   15a58:	e8 fc ff ff ff       	call   15a59 <trickles_setucont_impl+0x335>
   15a5d:	c7 45 e8 08 00 00 00 	movl   $0x8,0xffffffe8(%ebp)
   15a64:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   15a67:	ff 08                	decl   (%eax)
   15a69:	83 38 00             	cmpl   $0x0,(%eax)
   15a6c:	0f 85 35 02 00 00    	jne    15ca7 <trickles_setucont_impl+0x583>
   15a72:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   15a75:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   15a79:	0f 85 f1 66 00 00    	jne    1c170 <.text.lock.tmalloc+0x200>
		goto out_put;
   15a7f:	e9 23 02 00 00       	jmp    15ca7 <trickles_setucont_impl+0x583>
	}
	if(ucont_len > 0) {
   15a84:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
   15a88:	0f 84 51 01 00 00    	je     15bdf <trickles_setucont_impl+0x4bb>
		buf = kmalloc(ucont_len, GFP_KERNEL);
   15a8e:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
   15a95:	00 
   15a96:	8b 45 18             	mov    0x18(%ebp),%eax
   15a99:	89 04 24             	mov    %eax,(%esp,1)
   15a9c:	e8 fc ff ff ff       	call   15a9d <trickles_setucont_impl+0x379>
   15aa1:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
		if(buf == NULL) {
   15aa4:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
   15aa8:	0f 85 88 00 00 00    	jne    15b36 <trickles_setucont_impl+0x412>
			printk("set_ucont: out of memory\n");
   15aae:	c7 04 24 55 5b 00 00 	movl   $0x5b55,(%esp,1)
   15ab5:	e8 fc ff ff ff       	call   15ab6 <trickles_setucont_impl+0x392>
			err = -ENOMEM;
   15aba:	c7 45 f0 f4 ff ff ff 	movl   $0xfffffff4,0xfffffff0(%ebp)
			release_sock(sk);
   15ac1:	ff 05 08 00 00 00    	incl   0x8
   15ac7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15aca:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   15ad1:	74 0b                	je     15ade <trickles_setucont_impl+0x3ba>
   15ad3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15ad6:	89 04 24             	mov    %eax,(%esp,1)
   15ad9:	e8 fc ff ff ff       	call   15ada <trickles_setucont_impl+0x3b6>
   15ade:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15ae1:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   15ae8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15aeb:	83 c0 30             	add    $0x30,%eax
   15aee:	89 04 24             	mov    %eax,(%esp,1)
   15af1:	e8 ec 41 00 00       	call   19ce2 <waitqueue_active>
   15af6:	85 c0                	test   %eax,%eax
   15af8:	74 15                	je     15b0f <trickles_setucont_impl+0x3eb>
   15afa:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15afd:	83 c0 30             	add    $0x30,%eax
   15b00:	b9 01 00 00 00       	mov    $0x1,%ecx
   15b05:	ba 03 00 00 00       	mov    $0x3,%edx
   15b0a:	e8 fc ff ff ff       	call   15b0b <trickles_setucont_impl+0x3e7>
   15b0f:	c7 45 e8 08 00 00 00 	movl   $0x8,0xffffffe8(%ebp)
   15b16:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   15b19:	ff 08                	decl   (%eax)
   15b1b:	83 38 00             	cmpl   $0x0,(%eax)
   15b1e:	0f 85 83 01 00 00    	jne    15ca7 <trickles_setucont_impl+0x583>
   15b24:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   15b27:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   15b2b:	0f 85 4f 66 00 00    	jne    1c180 <.text.lock.tmalloc+0x210>
			goto out_put;
   15b31:	e9 71 01 00 00       	jmp    15ca7 <trickles_setucont_impl+0x583>
		}
		if(copy_from_user(buf,user_ucont,ucont_len)) {
   15b36:	8b 45 18             	mov    0x18(%ebp),%eax
   15b39:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   15b3d:	8b 45 14             	mov    0x14(%ebp),%eax
   15b40:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   15b44:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   15b47:	89 04 24             	mov    %eax,(%esp,1)
   15b4a:	e8 fc ff ff ff       	call   15b4b <trickles_setucont_impl+0x427>
   15b4f:	85 c0                	test   %eax,%eax
   15b51:	0f 84 8f 00 00 00    	je     15be6 <trickles_setucont_impl+0x4c2>
			printk("set_ucont: fault while copying\n");
   15b57:	c7 04 24 80 5b 00 00 	movl   $0x5b80,(%esp,1)
   15b5e:	e8 fc ff ff ff       	call   15b5f <trickles_setucont_impl+0x43b>
			err = -EFAULT;
   15b63:	c7 45 f0 f2 ff ff ff 	movl   $0xfffffff2,0xfffffff0(%ebp)
			release_sock(sk);
   15b6a:	ff 05 08 00 00 00    	incl   0x8
   15b70:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15b73:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   15b7a:	74 0b                	je     15b87 <trickles_setucont_impl+0x463>
   15b7c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15b7f:	89 04 24             	mov    %eax,(%esp,1)
   15b82:	e8 fc ff ff ff       	call   15b83 <trickles_setucont_impl+0x45f>
   15b87:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15b8a:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   15b91:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15b94:	83 c0 30             	add    $0x30,%eax
   15b97:	89 04 24             	mov    %eax,(%esp,1)
   15b9a:	e8 43 41 00 00       	call   19ce2 <waitqueue_active>
   15b9f:	85 c0                	test   %eax,%eax
   15ba1:	74 15                	je     15bb8 <trickles_setucont_impl+0x494>
   15ba3:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15ba6:	83 c0 30             	add    $0x30,%eax
   15ba9:	b9 01 00 00 00       	mov    $0x1,%ecx
   15bae:	ba 03 00 00 00       	mov    $0x3,%edx
   15bb3:	e8 fc ff ff ff       	call   15bb4 <trickles_setucont_impl+0x490>
   15bb8:	c7 45 e8 08 00 00 00 	movl   $0x8,0xffffffe8(%ebp)
   15bbf:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   15bc2:	ff 08                	decl   (%eax)
   15bc4:	83 38 00             	cmpl   $0x0,(%eax)
   15bc7:	0f 85 da 00 00 00    	jne    15ca7 <trickles_setucont_impl+0x583>
   15bcd:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   15bd0:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   15bd4:	0f 85 b6 65 00 00    	jne    1c190 <.text.lock.tmalloc+0x220>
			goto out_put;
   15bda:	e9 c8 00 00 00       	jmp    15ca7 <trickles_setucont_impl+0x583>
		}
	} else {
		buf = NULL;
   15bdf:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
	}
	BUG_TRAP(pkt_num < msk->num_packets);
   15be6:	8b 55 0c             	mov    0xc(%ebp),%edx
   15be9:	8b 45 10             	mov    0x10(%ebp),%eax
   15bec:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
   15bf2:	7c 14                	jl     15c08 <trickles_setucont_impl+0x4e4>
   15bf4:	c7 44 24 04 2f 06 00 	movl   $0x62f,0x4(%esp,1)
   15bfb:	00 
   15bfc:	c7 04 24 a0 5b 00 00 	movl   $0x5ba0,(%esp,1)
   15c03:	e8 fc ff ff ff       	call   15c04 <trickles_setucont_impl+0x4e0>
	setPacketUCont(&msk->packets[pkt_num], buf, ucont_len);
   15c08:	8b 45 18             	mov    0x18(%ebp),%eax
   15c0b:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   15c0f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   15c12:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   15c16:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   15c19:	8b 55 10             	mov    0x10(%ebp),%edx
   15c1c:	89 d0                	mov    %edx,%eax
   15c1e:	c1 e0 03             	shl    $0x3,%eax
   15c21:	01 d0                	add    %edx,%eax
   15c23:	c1 e0 02             	shl    $0x2,%eax
   15c26:	03 81 ec 00 00 00    	add    0xec(%ecx),%eax
   15c2c:	89 04 24             	mov    %eax,(%esp,1)
   15c2f:	e8 5d 4a 00 00       	call   1a691 <setPacketUCont>
	err = 0;
   15c34:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
	release_sock(sk);
   15c3b:	ff 05 08 00 00 00    	incl   0x8
   15c41:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15c44:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   15c4b:	74 0b                	je     15c58 <trickles_setucont_impl+0x534>
   15c4d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15c50:	89 04 24             	mov    %eax,(%esp,1)
   15c53:	e8 fc ff ff ff       	call   15c54 <trickles_setucont_impl+0x530>
   15c58:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15c5b:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   15c62:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15c65:	83 c0 30             	add    $0x30,%eax
   15c68:	89 04 24             	mov    %eax,(%esp,1)
   15c6b:	e8 72 40 00 00       	call   19ce2 <waitqueue_active>
   15c70:	85 c0                	test   %eax,%eax
   15c72:	74 15                	je     15c89 <trickles_setucont_impl+0x565>
   15c74:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15c77:	83 c0 30             	add    $0x30,%eax
   15c7a:	b9 01 00 00 00       	mov    $0x1,%ecx
   15c7f:	ba 03 00 00 00       	mov    $0x3,%edx
   15c84:	e8 fc ff ff ff       	call   15c85 <trickles_setucont_impl+0x561>
   15c89:	c7 45 e8 08 00 00 00 	movl   $0x8,0xffffffe8(%ebp)
   15c90:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   15c93:	ff 08                	decl   (%eax)
   15c95:	83 38 00             	cmpl   $0x0,(%eax)
   15c98:	75 0d                	jne    15ca7 <trickles_setucont_impl+0x583>
   15c9a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   15c9d:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   15ca1:	0f 85 f9 64 00 00    	jne    1c1a0 <.text.lock.tmalloc+0x230>

 out_put:
	sockfd_put(sock);
   15ca7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   15caa:	89 04 24             	mov    %eax,(%esp,1)
   15cad:	e8 90 57 00 00       	call   1b442 <sockfd_put>
 out:
	return err;
   15cb2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
}
   15cb5:	c9                   	leave  
   15cb6:	c3                   	ret    

00015cb7 <trickles_write_memory_free>:
#endif // USERTEST

/*
 *
 * COMPATIBILITY LAYER
 * This code is responsible for implementing the bytestream conversion protocol
 *
 */


static int trickles_write_memory_free(struct sock *sk) {
   15cb7:	55                   	push   %ebp
   15cb8:	89 e5                	mov    %esp,%ebp
   15cba:	83 ec 08             	sub    $0x8,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
   15cbd:	8b 45 08             	mov    0x8(%ebp),%eax
   15cc0:	05 bc 00 00 00       	add    $0xbc,%eax
   15cc5:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	return tp->t.write_seq - tp->t.snd_una < sk->sndbuf;
   15cc8:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
   15ccb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   15cce:	8b 90 e0 09 00 00    	mov    0x9e0(%eax),%edx
   15cd4:	8b 81 e8 09 00 00    	mov    0x9e8(%ecx),%eax
   15cda:	29 d0                	sub    %edx,%eax
   15cdc:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   15cdf:	8b 45 08             	mov    0x8(%ebp),%eax
   15ce2:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   15ce5:	3b 50 78             	cmp    0x78(%eax),%edx
   15ce8:	0f 92 c0             	setb   %al
   15ceb:	0f b6 c0             	movzbl %al,%eax
   15cee:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   15cf1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
}
   15cf4:	c9                   	leave  
   15cf5:	c3                   	ret    

00015cf6 <wait_for_write_memory>:

#ifndef USERTEST
/*
 *	Wait for more write memory
 */
static int wait_for_write_memory(struct sock * sk, long *timeo)
{
   15cf6:	55                   	push   %ebp
   15cf7:	89 e5                	mov    %esp,%ebp
   15cf9:	83 ec 3c             	sub    $0x3c,%esp
  /* copied from standard TCP version */
	int err = 0;
   15cfc:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
	long vm_wait = 0;
   15d03:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
	long current_timeo = *timeo;
   15d0a:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d0d:	8b 00                	mov    (%eax),%eax
   15d0f:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	DECLARE_WAITQUEUE(wait, current);
   15d12:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
   15d19:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
   15d20:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
   15d27:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
   15d2e:	e8 0c 42 00 00       	call   19f3f <get_current>
   15d33:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
   15d36:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   15d39:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   15d3c:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   15d3f:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   15d42:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   15d45:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   15d48:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   15d4b:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

	if (trickles_write_memory_free(sk))
   15d4e:	8b 45 08             	mov    0x8(%ebp),%eax
   15d51:	89 04 24             	mov    %eax,(%esp,1)
   15d54:	e8 5e ff ff ff       	call   15cb7 <trickles_write_memory_free>
   15d59:	85 c0                	test   %eax,%eax
   15d5b:	74 2b                	je     15d88 <wait_for_write_memory+0x92>
		current_timeo = vm_wait = (net_random()%(HZ/5))+2;
   15d5d:	e8 fc ff ff ff       	call   15d5e <wait_for_write_memory+0x68>
   15d62:	89 c1                	mov    %eax,%ecx
   15d64:	b8 cd cc cc cc       	mov    $0xcccccccd,%eax
   15d69:	f7 e1                	mul    %ecx
   15d6b:	c1 ea 04             	shr    $0x4,%edx
   15d6e:	89 d0                	mov    %edx,%eax
   15d70:	c1 e0 02             	shl    $0x2,%eax
   15d73:	01 d0                	add    %edx,%eax
   15d75:	c1 e0 02             	shl    $0x2,%eax
   15d78:	29 c1                	sub    %eax,%ecx
   15d7a:	89 c8                	mov    %ecx,%eax
   15d7c:	83 c0 02             	add    $0x2,%eax
   15d7f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   15d82:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15d85:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

	add_wait_queue(sk->sleep, &wait);
   15d88:	8d 55 e4             	lea    0xffffffe4(%ebp),%edx
   15d8b:	8b 45 08             	mov    0x8(%ebp),%eax
   15d8e:	8b 40 3c             	mov    0x3c(%eax),%eax
   15d91:	e8 fc ff ff ff       	call   15d92 <wait_for_write_memory+0x9c>
	for (;;) {
		set_bit(SOCK_ASYNC_NOSPACE, &sk->socket->flags);
   15d96:	8b 45 08             	mov    0x8(%ebp),%eax
   15d99:	8b 80 c8 0b 00 00    	mov    0xbc8(%eax),%eax
   15d9f:	83 c0 04             	add    $0x4,%eax
   15da2:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   15da6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   15dad:	e8 14 3f 00 00       	call   19cc6 <set_bit>

		set_current_state(TASK_INTERRUPTIBLE);
   15db2:	e8 88 41 00 00       	call   19f3f <get_current>
   15db7:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

		if (sk->err || (sk->shutdown & SEND_SHUTDOWN))
   15dbd:	8b 45 08             	mov    0x8(%ebp),%eax
   15dc0:	83 b8 48 0b 00 00 00 	cmpl   $0x0,0xb48(%eax)
   15dc7:	0f 85 c0 01 00 00    	jne    15f8d <wait_for_write_memory+0x297>
   15dcd:	8b 45 08             	mov    0x8(%ebp),%eax
   15dd0:	0f b6 40 27          	movzbl 0x27(%eax),%eax
   15dd4:	24 02                	and    $0x2,%al
   15dd6:	84 c0                	test   %al,%al
   15dd8:	0f 85 af 01 00 00    	jne    15f8d <wait_for_write_memory+0x297>
			goto do_error;
		if (!*timeo)
   15dde:	8b 45 0c             	mov    0xc(%ebp),%eax
   15de1:	83 38 00             	cmpl   $0x0,(%eax)
   15de4:	75 05                	jne    15deb <wait_for_write_memory+0xf5>
			goto do_nonblock;
   15de6:	e9 ab 01 00 00       	jmp    15f96 <wait_for_write_memory+0x2a0>
		if (signal_pending(current))
   15deb:	e8 4f 41 00 00       	call   19f3f <get_current>
   15df0:	89 04 24             	mov    %eax,(%esp,1)
   15df3:	e8 5c 41 00 00       	call   19f54 <signal_pending>
   15df8:	85 c0                	test   %eax,%eax
   15dfa:	74 05                	je     15e01 <wait_for_write_memory+0x10b>
			goto do_interrupted;
   15dfc:	e9 9e 01 00 00       	jmp    15f9f <wait_for_write_memory+0x2a9>
		clear_bit(SOCK_ASYNC_NOSPACE, &sk->socket->flags);
   15e01:	8b 45 08             	mov    0x8(%ebp),%eax
   15e04:	8b 80 c8 0b 00 00    	mov    0xbc8(%eax),%eax
   15e0a:	83 c0 04             	add    $0x4,%eax
   15e0d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   15e11:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   15e18:	e8 b7 3e 00 00       	call   19cd4 <clear_bit>
		if (trickles_write_memory_free(sk) && !vm_wait)
   15e1d:	8b 45 08             	mov    0x8(%ebp),%eax
   15e20:	89 04 24             	mov    %eax,(%esp,1)
   15e23:	e8 8f fe ff ff       	call   15cb7 <trickles_write_memory_free>
   15e28:	85 c0                	test   %eax,%eax
   15e2a:	74 0b                	je     15e37 <wait_for_write_memory+0x141>
   15e2c:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
   15e30:	75 05                	jne    15e37 <wait_for_write_memory+0x141>
			break;
   15e32:	e9 35 01 00 00       	jmp    15f6c <wait_for_write_memory+0x276>

		set_bit(SOCK_NOSPACE, &sk->socket->flags);
   15e37:	8b 45 08             	mov    0x8(%ebp),%eax
   15e3a:	8b 80 c8 0b 00 00    	mov    0xbc8(%eax),%eax
   15e40:	83 c0 04             	add    $0x4,%eax
   15e43:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   15e47:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp,1)
   15e4e:	e8 73 3e 00 00       	call   19cc6 <set_bit>
		release_sock(sk);
   15e53:	ff 05 08 00 00 00    	incl   0x8
   15e59:	8b 45 08             	mov    0x8(%ebp),%eax
   15e5c:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   15e63:	74 0b                	je     15e70 <wait_for_write_memory+0x17a>
   15e65:	8b 45 08             	mov    0x8(%ebp),%eax
   15e68:	89 04 24             	mov    %eax,(%esp,1)
   15e6b:	e8 fc ff ff ff       	call   15e6c <wait_for_write_memory+0x176>
   15e70:	8b 45 08             	mov    0x8(%ebp),%eax
   15e73:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   15e7a:	8b 45 08             	mov    0x8(%ebp),%eax
   15e7d:	83 c0 30             	add    $0x30,%eax
   15e80:	89 04 24             	mov    %eax,(%esp,1)
   15e83:	e8 5a 3e 00 00       	call   19ce2 <waitqueue_active>
   15e88:	85 c0                	test   %eax,%eax
   15e8a:	74 15                	je     15ea1 <wait_for_write_memory+0x1ab>
   15e8c:	8b 45 08             	mov    0x8(%ebp),%eax
   15e8f:	83 c0 30             	add    $0x30,%eax
   15e92:	b9 01 00 00 00       	mov    $0x1,%ecx
   15e97:	ba 03 00 00 00       	mov    $0x3,%edx
   15e9c:	e8 fc ff ff ff       	call   15e9d <wait_for_write_memory+0x1a7>
   15ea1:	c7 45 d0 08 00 00 00 	movl   $0x8,0xffffffd0(%ebp)
   15ea8:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   15eab:	ff 08                	decl   (%eax)
   15ead:	83 38 00             	cmpl   $0x0,(%eax)
   15eb0:	75 0d                	jne    15ebf <wait_for_write_memory+0x1c9>
   15eb2:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   15eb5:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   15eb9:	0f 85 f1 62 00 00    	jne    1c1b0 <.text.lock.tmalloc+0x240>
		if (!trickles_write_memory_free(sk) || vm_wait)
   15ebf:	8b 45 08             	mov    0x8(%ebp),%eax
   15ec2:	89 04 24             	mov    %eax,(%esp,1)
   15ec5:	e8 ed fd ff ff       	call   15cb7 <trickles_write_memory_free>
   15eca:	85 c0                	test   %eax,%eax
   15ecc:	74 08                	je     15ed6 <wait_for_write_memory+0x1e0>
   15ece:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
   15ed2:	75 02                	jne    15ed6 <wait_for_write_memory+0x1e0>
   15ed4:	eb 0b                	jmp    15ee1 <wait_for_write_memory+0x1eb>
			current_timeo = schedule_timeout(current_timeo);
   15ed6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   15ed9:	e8 fc ff ff ff       	call   15eda <wait_for_write_memory+0x1e4>
   15ede:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		lock_sock(sk);
   15ee1:	ff 05 08 00 00 00    	incl   0x8
   15ee7:	8b 45 08             	mov    0x8(%ebp),%eax
   15eea:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
   15eee:	74 0b                	je     15efb <wait_for_write_memory+0x205>
   15ef0:	8b 45 08             	mov    0x8(%ebp),%eax
   15ef3:	89 04 24             	mov    %eax,(%esp,1)
   15ef6:	e8 fc ff ff ff       	call   15ef7 <wait_for_write_memory+0x201>
   15efb:	8b 45 08             	mov    0x8(%ebp),%eax
   15efe:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
   15f05:	c7 45 d0 08 00 00 00 	movl   $0x8,0xffffffd0(%ebp)
   15f0c:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   15f0f:	ff 08                	decl   (%eax)
   15f11:	83 38 00             	cmpl   $0x0,(%eax)
   15f14:	75 0d                	jne    15f23 <wait_for_write_memory+0x22d>
   15f16:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   15f19:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   15f1d:	0f 85 9d 62 00 00    	jne    1c1c0 <.text.lock.tmalloc+0x250>

		if (vm_wait) {
   15f23:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
   15f27:	74 36                	je     15f5f <wait_for_write_memory+0x269>
			vm_wait -= current_timeo;
   15f29:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   15f2c:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
   15f2f:	29 10                	sub    %edx,(%eax)
			current_timeo = *timeo;
   15f31:	8b 45 0c             	mov    0xc(%ebp),%eax
   15f34:	8b 00                	mov    (%eax),%eax
   15f36:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
			if (current_timeo != MAX_SCHEDULE_TIMEOUT &&
   15f39:	81 7d f4 ff ff ff 7f 	cmpl   $0x7fffffff,0xfffffff4(%ebp)
   15f40:	74 16                	je     15f58 <wait_for_write_memory+0x262>
   15f42:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   15f45:	8d 55 f4             	lea    0xfffffff4(%ebp),%edx
   15f48:	29 02                	sub    %eax,(%edx)
   15f4a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   15f4d:	85 c0                	test   %eax,%eax
   15f4f:	79 07                	jns    15f58 <wait_for_write_memory+0x262>
			    (current_timeo -= vm_wait) < 0)
				current_timeo = 0;
   15f51:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
			vm_wait = 0;
   15f58:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
		}
		*timeo = current_timeo;
   15f5f:	8b 55 0c             	mov    0xc(%ebp),%edx
   15f62:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   15f65:	89 02                	mov    %eax,(%edx)
   15f67:	e9 2a fe ff ff       	jmp    15d96 <wait_for_write_memory+0xa0>
	}
out:
	current->state = TASK_RUNNING;
   15f6c:	e8 ce 3f 00 00       	call   19f3f <get_current>
   15f71:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	remove_wait_queue(sk->sleep, &wait);
   15f77:	8d 55 e4             	lea    0xffffffe4(%ebp),%edx
   15f7a:	8b 45 08             	mov    0x8(%ebp),%eax
   15f7d:	8b 40 3c             	mov    0x3c(%eax),%eax
   15f80:	e8 fc ff ff ff       	call   15f81 <wait_for_write_memory+0x28b>
	return err;
   15f85:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   15f88:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
   15f8b:	eb 24                	jmp    15fb1 <wait_for_write_memory+0x2bb>

do_error:
	err = -EPIPE;
   15f8d:	c7 45 fc e0 ff ff ff 	movl   $0xffffffe0,0xfffffffc(%ebp)
	goto out;
   15f94:	eb d6                	jmp    15f6c <wait_for_write_memory+0x276>
do_nonblock:
	err = -EAGAIN;
   15f96:	c7 45 fc f5 ff ff ff 	movl   $0xfffffff5,0xfffffffc(%ebp)
	goto out;
   15f9d:	eb cd                	jmp    15f6c <wait_for_write_memory+0x276>
do_interrupted:
	err = sock_intr_errno(*timeo);
   15f9f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15fa2:	8b 00                	mov    (%eax),%eax
   15fa4:	89 04 24             	mov    %eax,(%esp,1)
   15fa7:	e8 bb 48 00 00       	call   1a867 <sock_intr_errno>
   15fac:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	goto out;
   15faf:	eb bb                	jmp    15f6c <wait_for_write_memory+0x276>
}
   15fb1:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
   15fb4:	c9                   	leave  
   15fb5:	c3                   	ret    

00015fb6 <trickles_client_sendmsg>:
#else
static int wait_for_write_memory(struct sock * sk, long *timeo) {
  printk("Not implemented for userspace test\n");
  assert(0);
}
#endif // USERTEST

int trickles_client_sendmsg(struct sock *sk, struct msghdr *msg, int size) {
   15fb6:	55                   	push   %ebp
   15fb7:	89 e5                	mov    %esp,%ebp
   15fb9:	53                   	push   %ebx
   15fba:	83 ec 5c             	sub    $0x5c,%esp
	//printk("client_sendmsg(0)\n");
	int i;
	int iovlen, totalLen = 0, skb_spaceleft = 0, result = 0, position = 0;
   15fbd:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
   15fc4:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
   15fcb:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
   15fd2:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
	// NOT tiovec: these are mapped to send()
	struct iovec *iov;
	struct sk_buff *skb = NULL;
   15fd9:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
   15fe0:	8b 45 08             	mov    0x8(%ebp),%eax
   15fe3:	05 bc 00 00 00       	add    $0xbc,%eax
   15fe8:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
	iov = msg->msg_iov;
   15feb:	8b 45 0c             	mov    0xc(%ebp),%eax
   15fee:	8b 40 08             	mov    0x8(%eax),%eax
   15ff1:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
	iovlen = msg->msg_iovlen;
   15ff4:	8b 45 0c             	mov    0xc(%ebp),%eax
   15ff7:	8b 40 0c             	mov    0xc(%eax),%eax
   15ffa:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

	for(i=0; i < iovlen; i++) {
   15ffd:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
   16004:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16007:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
   1600a:	7c 02                	jl     1600e <trickles_client_sendmsg+0x58>
   1600c:	eb 1d                	jmp    1602b <trickles_client_sendmsg+0x75>
		totalLen += iov[i].iov_len;
   1600e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16011:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   16018:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   1601b:	8b 54 10 04          	mov    0x4(%eax,%edx,1),%edx
   1601f:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   16022:	01 10                	add    %edx,(%eax)
   16024:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
   16027:	ff 00                	incl   (%eax)
   16029:	eb d9                	jmp    16004 <trickles_client_sendmsg+0x4e>
	}
	// Sleep if not enough space
	lock_sock(sk);
   1602b:	ff 05 08 00 00 00    	incl   0x8
   16031:	8b 45 08             	mov    0x8(%ebp),%eax
   16034:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
   16038:	74 0b                	je     16045 <trickles_client_sendmsg+0x8f>
   1603a:	8b 45 08             	mov    0x8(%ebp),%eax
   1603d:	89 04 24             	mov    %eax,(%esp,1)
   16040:	e8 fc ff ff ff       	call   16041 <trickles_client_sendmsg+0x8b>
   16045:	8b 45 08             	mov    0x8(%ebp),%eax
   16048:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
   1604f:	c7 45 d4 08 00 00 00 	movl   $0x8,0xffffffd4(%ebp)
   16056:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   16059:	ff 08                	decl   (%eax)
   1605b:	83 38 00             	cmpl   $0x0,(%eax)
   1605e:	75 0d                	jne    1606d <trickles_client_sendmsg+0xb7>
   16060:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   16063:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   16067:	0f 85 63 61 00 00    	jne    1c1d0 <.text.lock.tmalloc+0x260>

	for(i=0; i < iovlen; i++) {
   1606d:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
   16074:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16077:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
   1607a:	7c 05                	jl     16081 <trickles_client_sendmsg+0xcb>
   1607c:	e9 26 02 00 00       	jmp    162a7 <trickles_client_sendmsg+0x2f1>
		char *buf;
		int iov_position = 0;
   16081:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
		//printk("client_sendmsg(3)\n");
		while(iov_position < iov[i].iov_len) {
   16088:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1608b:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
   16092:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   16095:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   16098:	3b 44 0a 04          	cmp    0x4(%edx,%ecx,1),%eax
   1609c:	72 05                	jb     160a3 <trickles_client_sendmsg+0xed>
   1609e:	e9 fa 01 00 00       	jmp    1629d <trickles_client_sendmsg+0x2e7>
			//printk("client_sendmsg(4)\n");
			int copyLen;
			if(skb_spaceleft == 0) {
   160a3:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
   160a7:	0f 85 3a 01 00 00    	jne    161e7 <trickles_client_sendmsg+0x231>
				if(skb != NULL) {
   160ad:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
   160b1:	74 44                	je     160f7 <trickles_client_sendmsg+0x141>
					// queue previous skb
					tp->t.write_seq += skb->len;
   160b3:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
   160b6:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   160b9:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   160bc:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   160c2:	03 82 e8 09 00 00    	add    0x9e8(%edx),%eax
   160c8:	89 81 e8 09 00 00    	mov    %eax,0x9e8(%ecx)
					TCP_SKB_CB(skb)->end_seq = tp->t.write_seq;
   160ce:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   160d1:	83 c2 30             	add    $0x30,%edx
   160d4:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   160d7:	8b 80 e8 09 00 00    	mov    0x9e8(%eax),%eax
   160dd:	89 42 14             	mov    %eax,0x14(%edx)
					__skb_queue_tail(&tp->t.requestBytes, skb);
   160e0:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   160e3:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   160e7:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   160ea:	05 ec 09 00 00       	add    $0x9ec,%eax
   160ef:	89 04 24             	mov    %eax,(%esp,1)
   160f2:	e8 ec 3e 00 00       	call   19fe3 <__skb_queue_tail>
				}
				if(!TRICKLES_HAS_SENDSPACE(sk)) {
   160f7:	8b 4d 08             	mov    0x8(%ebp),%ecx
   160fa:	8b 55 08             	mov    0x8(%ebp),%edx
   160fd:	8b 45 08             	mov    0x8(%ebp),%eax
   16100:	8b 40 78             	mov    0x78(%eax),%eax
   16103:	03 82 9c 0a 00 00    	add    0xa9c(%edx),%eax
   16109:	39 81 a4 0a 00 00    	cmp    %eax,0xaa4(%ecx)
   1610f:	72 19                	jb     1612a <trickles_client_sendmsg+0x174>
					long timeout;
				sleep:
					timeout = HZ/10;
   16111:	c7 45 c8 0a 00 00 00 	movl   $0xa,0xffffffc8(%ebp)
					wait_for_write_memory(sk, &timeout);
   16118:	8d 45 c8             	lea    0xffffffc8(%ebp),%eax
   1611b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1611f:	8b 45 08             	mov    0x8(%ebp),%eax
   16122:	89 04 24             	mov    %eax,(%esp,1)
   16125:	e8 cc fb ff ff       	call   15cf6 <wait_for_write_memory>
				}
				BUG_TRAP(tp->t.write_seq - tp->t.snd_una <= sk->sndbuf);
   1612a:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
   1612d:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   16130:	8b 90 e0 09 00 00    	mov    0x9e0(%eax),%edx
   16136:	8b 81 e8 09 00 00    	mov    0x9e8(%ecx),%eax
   1613c:	29 d0                	sub    %edx,%eax
   1613e:	89 c2                	mov    %eax,%edx
   16140:	8b 45 08             	mov    0x8(%ebp),%eax
   16143:	3b 50 78             	cmp    0x78(%eax),%edx
   16146:	76 14                	jbe    1615c <trickles_client_sendmsg+0x1a6>
   16148:	c7 44 24 04 b2 06 00 	movl   $0x6b2,0x4(%esp,1)
   1614f:	00 
   16150:	c7 04 24 00 5c 00 00 	movl   $0x5c00,(%esp,1)
   16157:	e8 fc ff ff ff       	call   16158 <trickles_client_sendmsg+0x1a2>
				skb_spaceleft = MIN(sk->sndbuf - (tp->t.write_seq - tp->t.snd_una), totalLen - position);
   1615c:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   1615f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   16162:	29 d0                	sub    %edx,%eax
   16164:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
   16167:	8b 5d 08             	mov    0x8(%ebp),%ebx
   1616a:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
   1616d:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   16170:	8b 90 e0 09 00 00    	mov    0x9e0(%eax),%edx
   16176:	8b 81 e8 09 00 00    	mov    0x9e8(%ecx),%eax
   1617c:	29 d0                	sub    %edx,%eax
   1617e:	89 c2                	mov    %eax,%edx
   16180:	8b 43 78             	mov    0x78(%ebx),%eax
   16183:	29 d0                	sub    %edx,%eax
   16185:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
   16188:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
   1618b:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
   1618e:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
   16191:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
   16194:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
   16197:	3b 45 c0             	cmp    0xffffffc0(%ebp),%eax
   1619a:	76 06                	jbe    161a2 <trickles_client_sendmsg+0x1ec>
   1619c:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
   1619f:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
   161a2:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
   161a5:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
				//skb = alloc_skb(skb_spaceleft, GFP_KERNEL);
				skb = alloc_skb(skb_spaceleft, GFP_ATOMIC);
   161a8:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
   161af:	00 
   161b0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   161b3:	89 04 24             	mov    %eax,(%esp,1)
   161b6:	e8 fc ff ff ff       	call   161b7 <trickles_client_sendmsg+0x201>
   161bb:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
				if(skb == NULL) {
   161be:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
   161c2:	75 11                	jne    161d5 <trickles_client_sendmsg+0x21f>
					printk("Trickles_client_sendmsg: out of memory\n");
   161c4:	c7 04 24 80 5c 00 00 	movl   $0x5c80,(%esp,1)
   161cb:	e8 fc ff ff ff       	call   161cc <trickles_client_sendmsg+0x216>
					goto sleep;
   161d0:	e9 3c ff ff ff       	jmp    16111 <trickles_client_sendmsg+0x15b>
				}
				TCP_SKB_CB(skb)->seq = tp->t.write_seq;
   161d5:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   161d8:	83 c0 30             	add    $0x30,%eax
   161db:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   161de:	8b 92 e8 09 00 00    	mov    0x9e8(%edx),%edx
   161e4:	89 50 10             	mov    %edx,0x10(%eax)
			}
			copyLen = MIN(iov[i].iov_len - iov_position, skb_spaceleft);
   161e7:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   161ea:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
   161ed:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   161f0:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
   161f7:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   161fa:	8b 55 d0             	mov    0xffffffd0(%ebp),%edx
   161fd:	8b 44 08 04          	mov    0x4(%eax,%ecx,1),%eax
   16201:	29 d0                	sub    %edx,%eax
   16203:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
   16206:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
   16209:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
   1620c:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
   1620f:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
   16212:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
   16215:	3b 45 c0             	cmp    0xffffffc0(%ebp),%eax
   16218:	76 06                	jbe    16220 <trickles_client_sendmsg+0x26a>
   1621a:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
   1621d:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
   16220:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
   16223:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
			buf = skb_put(skb, copyLen);
   16226:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
   16229:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1622d:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16230:	89 04 24             	mov    %eax,(%esp,1)
   16233:	e8 5d 3e 00 00       	call   1a095 <skb_put>
   16238:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
			if(copy_from_user(buf, iov[i].iov_base + iov_position, copyLen)) {
   1623b:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
   1623e:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   16242:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16245:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
   1624c:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
   1624f:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   16252:	03 04 0a             	add    (%edx,%ecx,1),%eax
   16255:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   16259:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   1625c:	89 04 24             	mov    %eax,(%esp,1)
   1625f:	e8 fc ff ff ff       	call   16260 <trickles_client_sendmsg+0x2aa>
   16264:	85 c0                	test   %eax,%eax
   16266:	74 18                	je     16280 <trickles_client_sendmsg+0x2ca>
				printk("Trickles_client_sendmsg: fault while copying from client\n");
   16268:	c7 04 24 c0 5c 00 00 	movl   $0x5cc0,(%esp,1)
   1626f:	e8 fc ff ff ff       	call   16270 <trickles_client_sendmsg+0x2ba>
				result = -EFAULT;
   16274:	c7 45 e8 f2 ff ff ff 	movl   $0xfffffff2,0xffffffe8(%ebp)
				goto out_dealloc;
   1627b:	e9 83 01 00 00       	jmp    16403 <trickles_client_sendmsg+0x44d>
			}
			skb_spaceleft -= copyLen;
   16280:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
   16283:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   16286:	29 10                	sub    %edx,(%eax)
			position += copyLen;
   16288:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
   1628b:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   1628e:	01 10                	add    %edx,(%eax)
			iov_position += copyLen;
   16290:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
   16293:	8d 45 d0             	lea    0xffffffd0(%ebp),%eax
   16296:	01 10                	add    %edx,(%eax)
   16298:	e9 eb fd ff ff       	jmp    16088 <trickles_client_sendmsg+0xd2>
   1629d:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
   162a0:	ff 00                	incl   (%eax)
   162a2:	e9 cd fd ff ff       	jmp    16074 <trickles_client_sendmsg+0xbe>
		}
	}
	BUG_TRAP(skb_spaceleft == 0);
   162a7:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
   162ab:	74 14                	je     162c1 <trickles_client_sendmsg+0x30b>
   162ad:	c7 44 24 04 c8 06 00 	movl   $0x6c8,0x4(%esp,1)
   162b4:	00 
   162b5:	c7 04 24 00 5d 00 00 	movl   $0x5d00,(%esp,1)
   162bc:	e8 fc ff ff ff       	call   162bd <trickles_client_sendmsg+0x307>
	if(skb != NULL) {
   162c1:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
   162c5:	74 44                	je     1630b <trickles_client_sendmsg+0x355>
		// queue previous skb
		tp->t.write_seq += skb->len;
   162c7:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
   162ca:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   162cd:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   162d0:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   162d6:	03 82 e8 09 00 00    	add    0x9e8(%edx),%eax
   162dc:	89 81 e8 09 00 00    	mov    %eax,0x9e8(%ecx)
		TCP_SKB_CB(skb)->end_seq = tp->t.write_seq;
   162e2:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   162e5:	83 c2 30             	add    $0x30,%edx
   162e8:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   162eb:	8b 80 e8 09 00 00    	mov    0x9e8(%eax),%eax
   162f1:	89 42 14             	mov    %eax,0x14(%edx)
		__skb_queue_tail(&tp->t.requestBytes, skb);
   162f4:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   162f7:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   162fb:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   162fe:	05 ec 09 00 00       	add    $0x9ec,%eax
   16303:	89 04 24             	mov    %eax,(%esp,1)
   16306:	e8 d8 3c 00 00       	call   19fe3 <__skb_queue_tail>
	}

	if(tp->t.write_seq - tp->t.snd_una > 0) {
   1630b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   1630e:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   16311:	8b 80 e8 09 00 00    	mov    0x9e8(%eax),%eax
   16317:	3b 82 e0 09 00 00    	cmp    0x9e0(%edx),%eax
   1631d:	74 70                	je     1638f <trickles_client_sendmsg+0x3d9>
		switch(tp->t.conversionState) {
   1631f:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   16322:	8b 80 dc 09 00 00    	mov    0x9dc(%eax),%eax
   16328:	89 45 ac             	mov    %eax,0xffffffac(%ebp)
   1632b:	83 7d ac 01          	cmpl   $0x1,0xffffffac(%ebp)
   1632f:	74 5e                	je     1638f <trickles_client_sendmsg+0x3d9>
   16331:	83 7d ac 01          	cmpl   $0x1,0xffffffac(%ebp)
   16335:	7f 08                	jg     1633f <trickles_client_sendmsg+0x389>
   16337:	83 7d ac 00          	cmpl   $0x0,0xffffffac(%ebp)
   1633b:	74 0a                	je     16347 <trickles_client_sendmsg+0x391>
   1633d:	eb 50                	jmp    1638f <trickles_client_sendmsg+0x3d9>
   1633f:	83 7d ac 02          	cmpl   $0x2,0xffffffac(%ebp)
   16343:	74 27                	je     1636c <trickles_client_sendmsg+0x3b6>
   16345:	eb 48                	jmp    1638f <trickles_client_sendmsg+0x3d9>
		case CONVERSION_IDLE:
			queueConversionRequests(sk);
   16347:	8b 45 08             	mov    0x8(%ebp),%eax
   1634a:	89 04 24             	mov    %eax,(%esp,1)
   1634d:	e8 fc ff ff ff       	call   1634e <trickles_client_sendmsg+0x398>
			tp->t.conversionState = CONVERSION_WAITFORSERVER;
   16352:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   16355:	c7 80 dc 09 00 00 01 	movl   $0x1,0x9dc(%eax)
   1635c:	00 00 00 
			pushRequests(sk);
   1635f:	8b 45 08             	mov    0x8(%ebp),%eax
   16362:	89 04 24             	mov    %eax,(%esp,1)
   16365:	e8 fc ff ff ff       	call   16366 <trickles_client_sendmsg+0x3b0>
			//printk("trickles_sendmsg(0) set conversion state to waitforserver\n");
			break;
   1636a:	eb 23                	jmp    1638f <trickles_client_sendmsg+0x3d9>
		case CONVERSION_WAITFORUSER:
			finishIncompleteRequest(sk);
   1636c:	8b 45 08             	mov    0x8(%ebp),%eax
   1636f:	89 04 24             	mov    %eax,(%esp,1)
   16372:	e8 fc ff ff ff       	call   16373 <trickles_client_sendmsg+0x3bd>
			tp->t.conversionState = CONVERSION_WAITFORSERVER;
   16377:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   1637a:	c7 80 dc 09 00 00 01 	movl   $0x1,0x9dc(%eax)
   16381:	00 00 00 
			pushRequests(sk);
   16384:	8b 45 08             	mov    0x8(%ebp),%eax
   16387:	89 04 24             	mov    %eax,(%esp,1)
   1638a:	e8 fc ff ff ff       	call   1638b <trickles_client_sendmsg+0x3d5>
			//printk("trickles_sendmsg(1) set conversion state to waitforserver\n");
			break;
		case CONVERSION_WAITFORSERVER:
			// do nothing, since the new data may need to be appended to an existing conversion
			break;
		}
	}

#if 0
	printk("trickles_client_sendmsg (%p): iov[0] = %d@%p, snd_una = %d write_seq = %d\n",
	       sk,
	       iov[0].iov_len, iov[0].iov_base,
	       tp->t.snd_una, tp->t.write_seq);
#endif
	release_sock(sk);
   1638f:	ff 05 08 00 00 00    	incl   0x8
   16395:	8b 45 08             	mov    0x8(%ebp),%eax
   16398:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   1639f:	74 0b                	je     163ac <trickles_client_sendmsg+0x3f6>
   163a1:	8b 45 08             	mov    0x8(%ebp),%eax
   163a4:	89 04 24             	mov    %eax,(%esp,1)
   163a7:	e8 fc ff ff ff       	call   163a8 <trickles_client_sendmsg+0x3f2>
   163ac:	8b 45 08             	mov    0x8(%ebp),%eax
   163af:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   163b6:	8b 45 08             	mov    0x8(%ebp),%eax
   163b9:	83 c0 30             	add    $0x30,%eax
   163bc:	89 04 24             	mov    %eax,(%esp,1)
   163bf:	e8 1e 39 00 00       	call   19ce2 <waitqueue_active>
   163c4:	85 c0                	test   %eax,%eax
   163c6:	74 15                	je     163dd <trickles_client_sendmsg+0x427>
   163c8:	8b 45 08             	mov    0x8(%ebp),%eax
   163cb:	83 c0 30             	add    $0x30,%eax
   163ce:	b9 01 00 00 00       	mov    $0x1,%ecx
   163d3:	ba 03 00 00 00       	mov    $0x3,%edx
   163d8:	e8 fc ff ff ff       	call   163d9 <trickles_client_sendmsg+0x423>
   163dd:	c7 45 bc 08 00 00 00 	movl   $0x8,0xffffffbc(%ebp)
   163e4:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
   163e7:	ff 08                	decl   (%eax)
   163e9:	83 38 00             	cmpl   $0x0,(%eax)
   163ec:	75 0d                	jne    163fb <trickles_client_sendmsg+0x445>
   163ee:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
   163f1:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   163f5:	0f 85 e5 5d 00 00    	jne    1c1e0 <.text.lock.tmalloc+0x270>
	//printk("client_sendmsg(1)\n");
	return totalLen;
   163fb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   163fe:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
   16401:	eb 7d                	jmp    16480 <trickles_client_sendmsg+0x4ca>

 out_dealloc:
	kfree_skb(skb);
   16403:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16406:	89 04 24             	mov    %eax,(%esp,1)
   16409:	e8 92 3b 00 00       	call   19fa0 <kfree_skb>
	release_sock(sk);
   1640e:	ff 05 08 00 00 00    	incl   0x8
   16414:	8b 45 08             	mov    0x8(%ebp),%eax
   16417:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   1641e:	74 0b                	je     1642b <trickles_client_sendmsg+0x475>
   16420:	8b 45 08             	mov    0x8(%ebp),%eax
   16423:	89 04 24             	mov    %eax,(%esp,1)
   16426:	e8 fc ff ff ff       	call   16427 <trickles_client_sendmsg+0x471>
   1642b:	8b 45 08             	mov    0x8(%ebp),%eax
   1642e:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   16435:	8b 45 08             	mov    0x8(%ebp),%eax
   16438:	83 c0 30             	add    $0x30,%eax
   1643b:	89 04 24             	mov    %eax,(%esp,1)
   1643e:	e8 9f 38 00 00       	call   19ce2 <waitqueue_active>
   16443:	85 c0                	test   %eax,%eax
   16445:	74 15                	je     1645c <trickles_client_sendmsg+0x4a6>
   16447:	8b 45 08             	mov    0x8(%ebp),%eax
   1644a:	83 c0 30             	add    $0x30,%eax
   1644d:	b9 01 00 00 00       	mov    $0x1,%ecx
   16452:	ba 03 00 00 00       	mov    $0x3,%edx
   16457:	e8 fc ff ff ff       	call   16458 <trickles_client_sendmsg+0x4a2>
   1645c:	c7 45 bc 08 00 00 00 	movl   $0x8,0xffffffbc(%ebp)
   16463:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
   16466:	ff 08                	decl   (%eax)
   16468:	83 38 00             	cmpl   $0x0,(%eax)
   1646b:	75 0d                	jne    1647a <trickles_client_sendmsg+0x4c4>
   1646d:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
   16470:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   16474:	0f 85 76 5d 00 00    	jne    1c1f0 <.text.lock.tmalloc+0x280>
	//printk("client_sendmsg(2)\n");
	return result;
   1647a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1647d:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
}
   16480:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
   16483:	83 c4 5c             	add    $0x5c,%esp
   16486:	5b                   	pop    %ebx
   16487:	5d                   	pop    %ebp
   16488:	c3                   	ret    

00016489 <trickles_syn_piggyback_impl>:

void trickles_syn_piggyback_impl(struct sock *sk, struct sk_buff *skb) {
   16489:	55                   	push   %ebp
   1648a:	89 e5                	mov    %esp,%ebp
   1648c:	83 ec 48             	sub    $0x48,%esp
	//printk("Piggyback impl\n");
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
   1648f:	8b 45 08             	mov    0x8(%ebp),%eax
   16492:	05 bc 00 00 00       	add    $0xbc,%eax
   16497:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	int sendBufLen = tp->t.write_seq - tp->t.snd_una;
   1649a:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
   1649d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   164a0:	8b 90 e0 09 00 00    	mov    0x9e0(%eax),%edx
   164a6:	8b 81 e8 09 00 00    	mov    0x9e8(%ecx),%eax
   164ac:	29 d0                	sub    %edx,%eax
   164ae:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	//printk("sendBufLen = %d\n", sendBufLen);
	if(sendBufLen > 0) {
   164b1:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
   164b5:	0f 8e 4d 01 00 00    	jle    16608 <trickles_syn_piggyback_impl+0x17f>
		int copyLen =
			MIN(sendBufLen, TRICKLES_MSS - MAX_TCP_HEADER);
   164bb:	a1 00 00 00 00       	mov    0x0,%eax
   164c0:	2d a0 00 00 00       	sub    $0xa0,%eax
   164c5:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   164c8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   164cb:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   164ce:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   164d1:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   164d4:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   164d7:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   164da:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   164dd:	3b 45 ec             	cmp    0xffffffec(%ebp),%eax
   164e0:	7e 06                	jle    164e8 <trickles_syn_piggyback_impl+0x5f>
   164e2:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   164e5:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   164e8:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   164eb:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		struct sk_buff *input_skb = tp->t.requestBytes.next;
   164ee:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   164f1:	8b 80 ec 09 00 00    	mov    0x9ec(%eax),%eax
   164f7:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
		int csum = 0;
   164fa:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
		while(copyLen > 0) {
   16501:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
   16505:	7f 05                	jg     1650c <trickles_syn_piggyback_impl+0x83>
   16507:	e9 f0 00 00 00       	jmp    165fc <trickles_syn_piggyback_impl+0x173>
			BUG_TRAP(input_skb != &tp->t.requestBytes);
   1650c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1650f:	05 ec 09 00 00       	add    $0x9ec,%eax
   16514:	39 45 e8             	cmp    %eax,0xffffffe8(%ebp)
   16517:	75 14                	jne    1652d <trickles_syn_piggyback_impl+0xa4>
   16519:	c7 44 24 04 00 07 00 	movl   $0x700,0x4(%esp,1)
   16520:	00 
   16521:	c7 04 24 60 5d 00 00 	movl   $0x5d60,(%esp,1)
   16528:	e8 fc ff ff ff       	call   16529 <trickles_syn_piggyback_impl+0xa0>
			unsigned pieceLen = MIN(input_skb->len, copyLen);
   1652d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16530:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   16533:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   16536:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   1653c:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   1653f:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   16542:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
   16545:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16548:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
   1654b:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   1654e:	3b 45 e0             	cmp    0xffffffe0(%ebp),%eax
   16551:	76 06                	jbe    16559 <trickles_syn_piggyback_impl+0xd0>
   16553:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   16556:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
   16559:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   1655c:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
			char *dst = skb_put(skb, pieceLen),
   1655f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   16562:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   16566:	8b 45 0c             	mov    0xc(%ebp),%eax
   16569:	89 04 24             	mov    %eax,(%esp,1)
   1656c:	e8 24 3b 00 00       	call   1a095 <skb_put>
   16571:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
				*src = input_skb->data;
   16574:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   16577:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   1657d:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
			int srcErr = 0, dstErr = 0;
   16580:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
   16587:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
			csum = csum_partial_copy_generic(src, dst, pieceLen, csum,
   1658e:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
   16591:	89 44 24 14          	mov    %eax,0x14(%esp,1)
   16595:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   16598:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   1659c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1659f:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   165a3:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   165a6:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   165aa:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   165ad:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   165b1:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   165b4:	89 04 24             	mov    %eax,(%esp,1)
   165b7:	e8 fc ff ff ff       	call   165b8 <trickles_syn_piggyback_impl+0x12f>
   165bc:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
							 &srcErr, &dstErr);
			if(srcErr || dstErr) {
   165bf:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
   165c3:	75 08                	jne    165cd <trickles_syn_piggyback_impl+0x144>
   165c5:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
   165c9:	75 02                	jne    165cd <trickles_syn_piggyback_impl+0x144>
   165cb:	eb 1a                	jmp    165e7 <trickles_syn_piggyback_impl+0x15e>
				printk("error while piggybacking data on SYN\n : %d %d\n",
   165cd:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   165d0:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   165d4:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   165d7:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   165db:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp,1)
   165e2:	e8 fc ff ff ff       	call   165e3 <trickles_syn_piggyback_impl+0x15a>
				       srcErr, dstErr);
			}
			copyLen -= pieceLen;
   165e7:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   165ea:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   165ed:	29 10                	sub    %edx,(%eax)
			input_skb = input_skb->next;
   165ef:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   165f2:	8b 00                	mov    (%eax),%eax
   165f4:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   165f7:	e9 05 ff ff ff       	jmp    16501 <trickles_syn_piggyback_impl+0x78>
		}
		skb->csum = csum;
   165fc:	8b 55 0c             	mov    0xc(%ebp),%edx
   165ff:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16602:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
	}
}
   16608:	c9                   	leave  
   16609:	c3                   	ret    

0001660a <tcp_data_wait>:

#ifndef USERTEST
/* tcp_data_wait: copied from tcp.c */

static long tcp_data_wait(struct sock *sk, long timeo)
{
   1660a:	55                   	push   %ebp
   1660b:	89 e5                	mov    %esp,%ebp
   1660d:	83 ec 2c             	sub    $0x2c,%esp
	DECLARE_WAITQUEUE(wait, current);
   16610:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
   16617:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
   1661e:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
   16625:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
   1662c:	e8 0e 39 00 00       	call   19f3f <get_current>
   16631:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   16634:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   16637:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1663a:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1663d:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   16640:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   16643:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   16646:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16649:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

	add_wait_queue(sk->sleep, &wait);
   1664c:	8d 55 f0             	lea    0xfffffff0(%ebp),%edx
   1664f:	8b 45 08             	mov    0x8(%ebp),%eax
   16652:	8b 40 3c             	mov    0x3c(%eax),%eax
   16655:	e8 fc ff ff ff       	call   16656 <tcp_data_wait+0x4c>

	__set_current_state(TASK_INTERRUPTIBLE);
   1665a:	e8 e0 38 00 00       	call   19f3f <get_current>
   1665f:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

	set_bit(SOCK_ASYNC_WAITDATA, &sk->socket->flags);
   16665:	8b 45 08             	mov    0x8(%ebp),%eax
   16668:	8b 80 c8 0b 00 00    	mov    0xbc8(%eax),%eax
   1666e:	83 c0 04             	add    $0x4,%eax
   16671:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   16675:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp,1)
   1667c:	e8 45 36 00 00       	call   19cc6 <set_bit>
	release_sock(sk);
   16681:	ff 05 08 00 00 00    	incl   0x8
   16687:	8b 45 08             	mov    0x8(%ebp),%eax
   1668a:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   16691:	74 0b                	je     1669e <tcp_data_wait+0x94>
   16693:	8b 45 08             	mov    0x8(%ebp),%eax
   16696:	89 04 24             	mov    %eax,(%esp,1)
   16699:	e8 fc ff ff ff       	call   1669a <tcp_data_wait+0x90>
   1669e:	8b 45 08             	mov    0x8(%ebp),%eax
   166a1:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   166a8:	8b 45 08             	mov    0x8(%ebp),%eax
   166ab:	83 c0 30             	add    $0x30,%eax
   166ae:	89 04 24             	mov    %eax,(%esp,1)
   166b1:	e8 2c 36 00 00       	call   19ce2 <waitqueue_active>
   166b6:	85 c0                	test   %eax,%eax
   166b8:	74 15                	je     166cf <tcp_data_wait+0xc5>
   166ba:	8b 45 08             	mov    0x8(%ebp),%eax
   166bd:	83 c0 30             	add    $0x30,%eax
   166c0:	b9 01 00 00 00       	mov    $0x1,%ecx
   166c5:	ba 03 00 00 00       	mov    $0x3,%edx
   166ca:	e8 fc ff ff ff       	call   166cb <tcp_data_wait+0xc1>
   166cf:	c7 45 dc 08 00 00 00 	movl   $0x8,0xffffffdc(%ebp)
   166d6:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   166d9:	ff 08                	decl   (%eax)
   166db:	83 38 00             	cmpl   $0x0,(%eax)
   166de:	75 0d                	jne    166ed <tcp_data_wait+0xe3>
   166e0:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   166e3:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   166e7:	0f 85 13 5b 00 00    	jne    1c200 <.text.lock.tmalloc+0x290>

	if (skb_queue_empty(&sk->receive_queue))
   166ed:	8b 45 08             	mov    0x8(%ebp),%eax
   166f0:	83 c0 48             	add    $0x48,%eax
   166f3:	89 04 24             	mov    %eax,(%esp,1)
   166f6:	e8 92 38 00 00       	call   19f8d <skb_queue_empty>
   166fb:	85 c0                	test   %eax,%eax
   166fd:	74 0b                	je     1670a <tcp_data_wait+0x100>
		timeo = schedule_timeout(timeo);
   166ff:	8b 45 0c             	mov    0xc(%ebp),%eax
   16702:	e8 fc ff ff ff       	call   16703 <tcp_data_wait+0xf9>
   16707:	89 45 0c             	mov    %eax,0xc(%ebp)

	lock_sock(sk);
   1670a:	ff 05 08 00 00 00    	incl   0x8
   16710:	8b 45 08             	mov    0x8(%ebp),%eax
   16713:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
   16717:	74 0b                	je     16724 <tcp_data_wait+0x11a>
   16719:	8b 45 08             	mov    0x8(%ebp),%eax
   1671c:	89 04 24             	mov    %eax,(%esp,1)
   1671f:	e8 fc ff ff ff       	call   16720 <tcp_data_wait+0x116>
   16724:	8b 45 08             	mov    0x8(%ebp),%eax
   16727:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
   1672e:	c7 45 dc 08 00 00 00 	movl   $0x8,0xffffffdc(%ebp)
   16735:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16738:	ff 08                	decl   (%eax)
   1673a:	83 38 00             	cmpl   $0x0,(%eax)
   1673d:	75 0d                	jne    1674c <tcp_data_wait+0x142>
   1673f:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16742:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   16746:	0f 85 c4 5a 00 00    	jne    1c210 <.text.lock.tmalloc+0x2a0>
	clear_bit(SOCK_ASYNC_WAITDATA, &sk->socket->flags);
   1674c:	8b 45 08             	mov    0x8(%ebp),%eax
   1674f:	8b 80 c8 0b 00 00    	mov    0xbc8(%eax),%eax
   16755:	83 c0 04             	add    $0x4,%eax
   16758:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1675c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp,1)
   16763:	e8 6c 35 00 00       	call   19cd4 <clear_bit>

	remove_wait_queue(sk->sleep, &wait);
   16768:	8d 55 f0             	lea    0xfffffff0(%ebp),%edx
   1676b:	8b 45 08             	mov    0x8(%ebp),%eax
   1676e:	8b 40 3c             	mov    0x3c(%eax),%eax
   16771:	e8 fc ff ff ff       	call   16772 <tcp_data_wait+0x168>
	__set_current_state(TASK_RUNNING);
   16776:	e8 c4 37 00 00       	call   19f3f <get_current>
   1677b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return timeo;
   16781:	8b 45 0c             	mov    0xc(%ebp),%eax
}
   16784:	c9                   	leave  
   16785:	c3                   	ret    

00016786 <trickles_client_recvmsg>:

int trickles_client_recvmsg(struct sock *sk, struct msghdr *msg,
			    int len, int nonblock, int flags, int *addr_len) {
   16786:	55                   	push   %ebp
   16787:	89 e5                	mov    %esp,%ebp
   16789:	83 ec 40             	sub    $0x40,%esp
	/* XXX Support all socket API semantics? */
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
   1678c:	8b 45 08             	mov    0x8(%ebp),%eax
   1678f:	05 bc 00 00 00       	add    $0xbc,%eax
   16794:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	int result = 0;
   16797:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
	int target;		/* Read at least this many bytes */
	long timeo;

	lock_sock(sk);
   1679e:	ff 05 08 00 00 00    	incl   0x8
   167a4:	8b 45 08             	mov    0x8(%ebp),%eax
   167a7:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
   167ab:	74 0b                	je     167b8 <trickles_client_recvmsg+0x32>
   167ad:	8b 45 08             	mov    0x8(%ebp),%eax
   167b0:	89 04 24             	mov    %eax,(%esp,1)
   167b3:	e8 fc ff ff ff       	call   167b4 <trickles_client_recvmsg+0x2e>
   167b8:	8b 45 08             	mov    0x8(%ebp),%eax
   167bb:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
   167c2:	c7 45 ec 08 00 00 00 	movl   $0x8,0xffffffec(%ebp)
   167c9:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   167cc:	ff 08                	decl   (%eax)
   167ce:	83 38 00             	cmpl   $0x0,(%eax)
   167d1:	75 0d                	jne    167e0 <trickles_client_recvmsg+0x5a>
   167d3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   167d6:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   167da:	0f 85 40 5a 00 00    	jne    1c220 <.text.lock.tmalloc+0x2b0>
	if(!(tp->trickles_opt & TCP_TRICKLES_RCV_START)) {
   167e0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   167e3:	8b 80 ec 01 00 00    	mov    0x1ec(%eax),%eax
   167e9:	83 e0 10             	and    $0x10,%eax
   167ec:	85 c0                	test   %eax,%eax
   167ee:	75 15                	jne    16805 <trickles_client_recvmsg+0x7f>
		// also needed in trickles_poll
#if 0 // 0424 - changing client program instead of hacking rcv_start functionality into client
		bh_lock_sock(sk);
		trickles_send_ack_hook(sk);
		bh_unlock_sock(sk);#
#endif
		tp->trickles_opt |= TCP_TRICKLES_RCV_START;
   167f0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   167f3:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   167f6:	8b 92 ec 01 00 00    	mov    0x1ec(%edx),%edx
   167fc:	83 ca 10             	or     $0x10,%edx
   167ff:	89 90 ec 01 00 00    	mov    %edx,0x1ec(%eax)
	}

	if(!(tp->trickles_opt & TCP_TRICKLES_BUFFERDISCARD)) {
   16805:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   16808:	8b 80 ec 01 00 00    	mov    0x1ec(%eax),%eax
   1680e:	83 e0 40             	and    $0x40,%eax
   16811:	85 c0                	test   %eax,%eax
   16813:	0f 85 a2 00 00 00    	jne    168bb <trickles_client_recvmsg+0x135>
		/* Normal case: deliver actual data to client */
		release_sock(sk);
   16819:	ff 05 08 00 00 00    	incl   0x8
   1681f:	8b 45 08             	mov    0x8(%ebp),%eax
   16822:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   16829:	74 0b                	je     16836 <trickles_client_recvmsg+0xb0>
   1682b:	8b 45 08             	mov    0x8(%ebp),%eax
   1682e:	89 04 24             	mov    %eax,(%esp,1)
   16831:	e8 fc ff ff ff       	call   16832 <trickles_client_recvmsg+0xac>
   16836:	8b 45 08             	mov    0x8(%ebp),%eax
   16839:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   16840:	8b 45 08             	mov    0x8(%ebp),%eax
   16843:	83 c0 30             	add    $0x30,%eax
   16846:	89 04 24             	mov    %eax,(%esp,1)
   16849:	e8 94 34 00 00       	call   19ce2 <waitqueue_active>
   1684e:	85 c0                	test   %eax,%eax
   16850:	74 15                	je     16867 <trickles_client_recvmsg+0xe1>
   16852:	8b 45 08             	mov    0x8(%ebp),%eax
   16855:	83 c0 30             	add    $0x30,%eax
   16858:	b9 01 00 00 00       	mov    $0x1,%ecx
   1685d:	ba 03 00 00 00       	mov    $0x3,%edx
   16862:	e8 fc ff ff ff       	call   16863 <trickles_client_recvmsg+0xdd>
   16867:	c7 45 ec 08 00 00 00 	movl   $0x8,0xffffffec(%ebp)
   1686e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16871:	ff 08                	decl   (%eax)
   16873:	83 38 00             	cmpl   $0x0,(%eax)
   16876:	75 0d                	jne    16885 <trickles_client_recvmsg+0xff>
   16878:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1687b:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   1687f:	0f 85 ab 59 00 00    	jne    1c230 <.text.lock.tmalloc+0x2c0>
		return tcp_recvmsg(sk,msg,len,nonblock,flags,addr_len);
   16885:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16888:	89 44 24 14          	mov    %eax,0x14(%esp,1)
   1688c:	8b 45 18             	mov    0x18(%ebp),%eax
   1688f:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   16893:	8b 45 14             	mov    0x14(%ebp),%eax
   16896:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   1689a:	8b 45 10             	mov    0x10(%ebp),%eax
   1689d:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   168a1:	8b 45 0c             	mov    0xc(%ebp),%eax
   168a4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   168a8:	8b 45 08             	mov    0x8(%ebp),%eax
   168ab:	89 04 24             	mov    %eax,(%esp,1)
   168ae:	e8 fc ff ff ff       	call   168af <trickles_client_recvmsg+0x129>
   168b3:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   168b6:	e9 62 02 00 00       	jmp    16b1d <trickles_client_recvmsg+0x397>
	}

	// Else, generate fake data (correlated with the network: data
	// is returned from this routine only if data was received on
	// the network. However, the actual network data was discarded)

	result = -ENOTCONN;
   168bb:	c7 45 f8 95 ff ff ff 	movl   $0xffffff95,0xfffffff8(%ebp)

	if(flags & (MSG_OOB | MSG_PEEK)) {
   168c2:	8b 45 18             	mov    0x18(%ebp),%eax
   168c5:	83 e0 03             	and    $0x3,%eax
   168c8:	85 c0                	test   %eax,%eax
   168ca:	74 0c                	je     168d8 <trickles_client_recvmsg+0x152>
		result = -EINVAL;
   168cc:	c7 45 f8 ea ff ff ff 	movl   $0xffffffea,0xfffffff8(%ebp)
		goto done;
   168d3:	e9 d3 01 00 00       	jmp    16aab <trickles_client_recvmsg+0x325>
	}

	timeo = sock_rcvtimeo(sk, nonblock);
   168d8:	8b 45 14             	mov    0x14(%ebp),%eax
   168db:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   168df:	8b 45 08             	mov    0x8(%ebp),%eax
   168e2:	89 04 24             	mov    %eax,(%esp,1)
   168e5:	e8 ff 3e 00 00       	call   1a7e9 <sock_rcvtimeo>
   168ea:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	target = sock_rcvlowat(sk, flags & MSG_WAITALL, len);
   168ed:	8b 45 10             	mov    0x10(%ebp),%eax
   168f0:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   168f4:	8b 45 18             	mov    0x18(%ebp),%eax
   168f7:	25 00 01 00 00       	and    $0x100,%eax
   168fc:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   16900:	8b 45 08             	mov    0x8(%ebp),%eax
   16903:	89 04 24             	mov    %eax,(%esp,1)
   16906:	e8 04 3f 00 00       	call   1a80f <sock_rcvlowat>
   1690b:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

	while(1) {
		if(tp->rcv_nxt - tp->copied_seq >= target) {
   1690e:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
   16911:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   16914:	8b 90 fc 00 00 00    	mov    0xfc(%eax),%edx
   1691a:	8b 41 08             	mov    0x8(%ecx),%eax
   1691d:	29 d0                	sub    %edx,%eax
   1691f:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
   16922:	72 66                	jb     1698a <trickles_client_recvmsg+0x204>
			result = MIN(len, tp->rcv_nxt - tp->copied_seq); // 0503 - changed from min to MIN to suppress compilation warning
   16924:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
   16927:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1692a:	8b 90 fc 00 00 00    	mov    0xfc(%eax),%edx
   16930:	8b 41 08             	mov    0x8(%ecx),%eax
   16933:	29 d0                	sub    %edx,%eax
   16935:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   16938:	8b 45 10             	mov    0x10(%ebp),%eax
   1693b:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1693e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16941:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   16944:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   16947:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
   1694a:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   1694d:	3b 45 e8             	cmp    0xffffffe8(%ebp),%eax
   16950:	7e 06                	jle    16958 <trickles_client_recvmsg+0x1d2>
   16952:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   16955:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
   16958:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   1695b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
			tp->copied_seq += result;
   1695e:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
   16961:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   16964:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16967:	03 82 fc 00 00 00    	add    0xfc(%edx),%eax
   1696d:	89 81 fc 00 00 00    	mov    %eax,0xfc(%ecx)
			cleanup_rbuf(sk, result);
   16973:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16976:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1697a:	8b 45 08             	mov    0x8(%ebp),%eax
   1697d:	89 04 24             	mov    %eax,(%esp,1)
   16980:	e8 fc ff ff ff       	call   16981 <trickles_client_recvmsg+0x1fb>
			break;
   16985:	e9 21 01 00 00       	jmp    16aab <trickles_client_recvmsg+0x325>
		} else if(timeo == 0) {
   1698a:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
   1698e:	75 66                	jne    169f6 <trickles_client_recvmsg+0x270>
			/* NOWAIT */
			result = MIN(target, tp->rcv_nxt - tp->copied_seq); // 0503 - changed from min to MIN to suppress compilation warning
   16990:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
   16993:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   16996:	8b 90 fc 00 00 00    	mov    0xfc(%eax),%edx
   1699c:	8b 41 08             	mov    0x8(%ecx),%eax
   1699f:	29 d0                	sub    %edx,%eax
   169a1:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   169a4:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   169a7:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   169aa:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   169ad:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   169b0:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   169b3:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
   169b6:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   169b9:	3b 45 e8             	cmp    0xffffffe8(%ebp),%eax
   169bc:	7e 06                	jle    169c4 <trickles_client_recvmsg+0x23e>
   169be:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   169c1:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
   169c4:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   169c7:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
			tp->copied_seq += result;
   169ca:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
   169cd:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   169d0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   169d3:	03 82 fc 00 00 00    	add    0xfc(%edx),%eax
   169d9:	89 81 fc 00 00 00    	mov    %eax,0xfc(%ecx)
			cleanup_rbuf(sk, result);
   169df:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   169e2:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   169e6:	8b 45 08             	mov    0x8(%ebp),%eax
   169e9:	89 04 24             	mov    %eax,(%esp,1)
   169ec:	e8 fc ff ff ff       	call   169ed <trickles_client_recvmsg+0x267>
			break;
   169f1:	e9 b5 00 00 00       	jmp    16aab <trickles_client_recvmsg+0x325>
		} else {
			/* wait until enough new data is available */
			printk("waiting for data\n");
   169f6:	c7 04 24 ef 5d 00 00 	movl   $0x5def,(%esp,1)
   169fd:	e8 fc ff ff ff       	call   169fe <trickles_client_recvmsg+0x278>
			timeo = tcp_data_wait(sk, timeo);
   16a02:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   16a05:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   16a09:	8b 45 08             	mov    0x8(%ebp),%eax
   16a0c:	89 04 24             	mov    %eax,(%esp,1)
   16a0f:	e8 f6 fb ff ff       	call   1660a <tcp_data_wait>
   16a14:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
		}
		if(tp->rcv_nxt - tp->copied_seq == 0) {
   16a17:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   16a1a:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   16a1d:	8b 40 08             	mov    0x8(%eax),%eax
   16a20:	3b 82 fc 00 00 00    	cmp    0xfc(%edx),%eax
   16a26:	75 6c                	jne    16a94 <trickles_client_recvmsg+0x30e>
			/* check to see why tcp_data_wait returned without new data. Copied from tcp_recvmsg */
			if (sk->done)
   16a28:	8b 45 08             	mov    0x8(%ebp),%eax
   16a2b:	0f b6 80 81 00 00 00 	movzbl 0x81(%eax),%eax
   16a32:	84 c0                	test   %al,%al
   16a34:	74 02                	je     16a38 <trickles_client_recvmsg+0x2b2>
				break;
   16a36:	eb 73                	jmp    16aab <trickles_client_recvmsg+0x325>

			if (sk->err) {
   16a38:	8b 45 08             	mov    0x8(%ebp),%eax
   16a3b:	83 b8 48 0b 00 00 00 	cmpl   $0x0,0xb48(%eax)
   16a42:	74 10                	je     16a54 <trickles_client_recvmsg+0x2ce>
				result = sock_error(sk);
   16a44:	8b 45 08             	mov    0x8(%ebp),%eax
   16a47:	89 04 24             	mov    %eax,(%esp,1)
   16a4a:	e8 6a 3d 00 00       	call   1a7b9 <sock_error>
   16a4f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
				break;
   16a52:	eb 57                	jmp    16aab <trickles_client_recvmsg+0x325>
			}

			if (sk->shutdown & RCV_SHUTDOWN)
   16a54:	8b 45 08             	mov    0x8(%ebp),%eax
   16a57:	0f b6 40 27          	movzbl 0x27(%eax),%eax
   16a5b:	24 01                	and    $0x1,%al
   16a5d:	84 c0                	test   %al,%al
   16a5f:	74 02                	je     16a63 <trickles_client_recvmsg+0x2dd>
				break;
   16a61:	eb 48                	jmp    16aab <trickles_client_recvmsg+0x325>

			if (sk->state == TCP_CLOSE) {
   16a63:	8b 45 08             	mov    0x8(%ebp),%eax
   16a66:	0f b6 40 20          	movzbl 0x20(%eax),%eax
   16a6a:	3c 07                	cmp    $0x7,%al
   16a6c:	75 17                	jne    16a85 <trickles_client_recvmsg+0x2ff>
				if (!sk->done) {
   16a6e:	8b 45 08             	mov    0x8(%ebp),%eax
   16a71:	0f b6 80 81 00 00 00 	movzbl 0x81(%eax),%eax
   16a78:	84 c0                	test   %al,%al
   16a7a:	75 2f                	jne    16aab <trickles_client_recvmsg+0x325>
					/* This occurs when user tries to read
					 * from never connected socket.
					 */
					result = -ENOTCONN;
   16a7c:	c7 45 f8 95 ff ff ff 	movl   $0xffffff95,0xfffffff8(%ebp)
					break;
   16a83:	eb 26                	jmp    16aab <trickles_client_recvmsg+0x325>
				}
				break;
			}

			if (!timeo) {
   16a85:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
   16a89:	75 09                	jne    16a94 <trickles_client_recvmsg+0x30e>
				result = -EAGAIN;
   16a8b:	c7 45 f8 f5 ff ff ff 	movl   $0xfffffff5,0xfffffff8(%ebp)
				break;
   16a92:	eb 17                	jmp    16aab <trickles_client_recvmsg+0x325>
			}
		}
		cleanup_rbuf(sk, result);
   16a94:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16a97:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   16a9b:	8b 45 08             	mov    0x8(%ebp),%eax
   16a9e:	89 04 24             	mov    %eax,(%esp,1)
   16aa1:	e8 fc ff ff ff       	call   16aa2 <trickles_client_recvmsg+0x31c>
   16aa6:	e9 63 fe ff ff       	jmp    1690e <trickles_client_recvmsg+0x188>
	}
	done:
	release_sock(sk);
   16aab:	ff 05 08 00 00 00    	incl   0x8
   16ab1:	8b 45 08             	mov    0x8(%ebp),%eax
   16ab4:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   16abb:	74 0b                	je     16ac8 <trickles_client_recvmsg+0x342>
   16abd:	8b 45 08             	mov    0x8(%ebp),%eax
   16ac0:	89 04 24             	mov    %eax,(%esp,1)
   16ac3:	e8 fc ff ff ff       	call   16ac4 <trickles_client_recvmsg+0x33e>
   16ac8:	8b 45 08             	mov    0x8(%ebp),%eax
   16acb:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   16ad2:	8b 45 08             	mov    0x8(%ebp),%eax
   16ad5:	83 c0 30             	add    $0x30,%eax
   16ad8:	89 04 24             	mov    %eax,(%esp,1)
   16adb:	e8 02 32 00 00       	call   19ce2 <waitqueue_active>
   16ae0:	85 c0                	test   %eax,%eax
   16ae2:	74 15                	je     16af9 <trickles_client_recvmsg+0x373>
   16ae4:	8b 45 08             	mov    0x8(%ebp),%eax
   16ae7:	83 c0 30             	add    $0x30,%eax
   16aea:	b9 01 00 00 00       	mov    $0x1,%ecx
   16aef:	ba 03 00 00 00       	mov    $0x3,%edx
   16af4:	e8 fc ff ff ff       	call   16af5 <trickles_client_recvmsg+0x36f>
   16af9:	c7 45 e4 08 00 00 00 	movl   $0x8,0xffffffe4(%ebp)
   16b00:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   16b03:	ff 08                	decl   (%eax)
   16b05:	83 38 00             	cmpl   $0x0,(%eax)
   16b08:	75 0d                	jne    16b17 <trickles_client_recvmsg+0x391>
   16b0a:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   16b0d:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   16b11:	0f 85 29 57 00 00    	jne    1c240 <.text.lock.tmalloc+0x2d0>
	return result;
   16b17:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16b1a:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
}
   16b1d:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   16b20:	c9                   	leave  
   16b21:	c3                   	ret    

00016b22 <trickles_sendbulk_impl>:

#if 0
	struct mskdesc {
		struct cminisock *msk;
		int tiov_num;
		// tiovec is appended to mskdesc
		struct  tiovec tiov[0];
	};

	struct tiovec {
		// field names are compatible with iov
		void *iov_base;
		int iov_len;

		UCONT_DESC;
	};
#endif

static inline void dump_tiov(struct tiovec *tiov) {
	printk("tiov_base = %p\ntiov_len = %d", tiov->iov_base, tiov->iov_len);
}

static inline void dump_mskdesc(struct mskdesc *mskd) {
	printk("msk = %p, num =  %d\n", mskd->msk, mskd->tiov_num);
	dump_tiov(mskd->tiov);
}

int trickles_sendbulk_impl(int fd, struct mskdesc *user_descbuf, int descbuf_len) {
   16b22:	55                   	push   %ebp
   16b23:	89 e5                	mov    %esp,%ebp
   16b25:	83 ec 3c             	sub    $0x3c,%esp
	struct socket *sock;
	struct sock *sk;
	struct tcp_opt *tp;
	struct mskdesc *descbuf;
	int err;

	extern int gNumSendbulk;
	extern int gNumSendbulkDesc;
	gNumSendbulk++;
   16b28:	ff 05 00 00 00 00    	incl   0x0

	if(descbuf_len <= 0) {
   16b2e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   16b32:	7f 0c                	jg     16b40 <trickles_sendbulk_impl+0x1e>
		err = -EINVAL;
   16b34:	c7 45 ec ea ff ff ff 	movl   $0xffffffea,0xffffffec(%ebp)
		goto out;
   16b3b:	e9 79 03 00 00       	jmp    16eb9 <trickles_sendbulk_impl+0x397>
	}

	sock = sockfd_lookup(fd, &err);
   16b40:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   16b43:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   16b47:	8b 45 08             	mov    0x8(%ebp),%eax
   16b4a:	89 04 24             	mov    %eax,(%esp,1)
   16b4d:	e8 fc ff ff ff       	call   16b4e <trickles_sendbulk_impl+0x2c>
   16b52:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	if (!sock)
   16b55:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
   16b59:	75 05                	jne    16b60 <trickles_sendbulk_impl+0x3e>
		goto out;
   16b5b:	e9 59 03 00 00       	jmp    16eb9 <trickles_sendbulk_impl+0x397>

	sk = sock->sk;
   16b60:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   16b63:	8b 40 18             	mov    0x18(%eax),%eax
   16b66:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	tp = &(sk->tp_pinfo.af_tcp);
   16b69:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16b6c:	05 bc 00 00 00       	add    $0xbc,%eax
   16b71:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

	//if(copy_from_user(buf, iov[i].iov_base + iov_position, copyLen)) {
	descbuf = kmalloc(descbuf_len, GFP_KERNEL);
   16b74:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
   16b7b:	00 
   16b7c:	8b 45 10             	mov    0x10(%ebp),%eax
   16b7f:	89 04 24             	mov    %eax,(%esp,1)
   16b82:	e8 fc ff ff ff       	call   16b83 <trickles_sendbulk_impl+0x61>
   16b87:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	if(descbuf == NULL) {
   16b8a:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
   16b8e:	75 11                	jne    16ba1 <trickles_sendbulk_impl+0x7f>
		printk("trickles_sendbulk_impl: user desc buf out of memory\n");
   16b90:	c7 04 24 20 5e 00 00 	movl   $0x5e20,(%esp,1)
   16b97:	e8 fc ff ff ff       	call   16b98 <trickles_sendbulk_impl+0x76>
		goto out_put;
   16b9c:	e9 0d 03 00 00       	jmp    16eae <trickles_sendbulk_impl+0x38c>
	}
	if((err = copy_from_user(descbuf,user_descbuf,descbuf_len))) {
   16ba1:	8b 45 10             	mov    0x10(%ebp),%eax
   16ba4:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   16ba8:	8b 45 0c             	mov    0xc(%ebp),%eax
   16bab:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   16baf:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   16bb2:	89 04 24             	mov    %eax,(%esp,1)
   16bb5:	e8 fc ff ff ff       	call   16bb6 <trickles_sendbulk_impl+0x94>
   16bba:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   16bbd:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16bc0:	85 c0                	test   %eax,%eax
   16bc2:	74 1f                	je     16be3 <trickles_sendbulk_impl+0xc1>
		printk("trickles_sendbulk_impl: copy_from_user returned %d\n", err);
   16bc4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   16bc7:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   16bcb:	c7 04 24 60 5e 00 00 	movl   $0x5e60,(%esp,1)
   16bd2:	e8 fc ff ff ff       	call   16bd3 <trickles_sendbulk_impl+0xb1>
		err = -EFAULT;
   16bd7:	c7 45 ec f2 ff ff ff 	movl   $0xfffffff2,0xffffffec(%ebp)
		goto out_dealloc;
   16bde:	e9 c0 02 00 00       	jmp    16ea3 <trickles_sendbulk_impl+0x381>
	}
	void *tail = (char*)descbuf + descbuf_len;
   16be3:	8b 45 10             	mov    0x10(%ebp),%eax
   16be6:	03 45 f0             	add    0xfffffff0(%ebp),%eax
   16be9:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
	struct mskdesc *curr_desc = descbuf;
   16bec:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   16bef:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)

	lock_sock(sk);
   16bf2:	ff 05 08 00 00 00    	incl   0x8
   16bf8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16bfb:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
   16bff:	74 0b                	je     16c0c <trickles_sendbulk_impl+0xea>
   16c01:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16c04:	89 04 24             	mov    %eax,(%esp,1)
   16c07:	e8 fc ff ff ff       	call   16c08 <trickles_sendbulk_impl+0xe6>
   16c0c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16c0f:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
   16c16:	c7 45 e0 08 00 00 00 	movl   $0x8,0xffffffe0(%ebp)
   16c1d:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   16c20:	ff 08                	decl   (%eax)
   16c22:	83 38 00             	cmpl   $0x0,(%eax)
   16c25:	75 0d                	jne    16c34 <trickles_sendbulk_impl+0x112>
   16c27:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   16c2a:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   16c2e:	0f 85 1c 56 00 00    	jne    1c250 <.text.lock.tmalloc+0x2e0>
	int descnum = 0;
   16c34:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
	while(curr_desc < (struct mskdesc *)tail) {
   16c3b:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   16c3e:	3b 45 e8             	cmp    0xffffffe8(%ebp),%eax
   16c41:	72 05                	jb     16c48 <trickles_sendbulk_impl+0x126>
   16c43:	e9 ab 01 00 00       	jmp    16df3 <trickles_sendbulk_impl+0x2d1>
		struct cminisock *msk = curr_desc->msk;
   16c48:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   16c4b:	8b 00                	mov    (%eax),%eax
   16c4d:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
		//printk("Minisocket %d = %p\n", descnum, msk);
		if(!IS_VALID_MSK(sk, msk)) {
   16c50:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16c53:	05 bc 00 00 00       	add    $0xbc,%eax
   16c58:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
   16c5b:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
   16c62:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   16c65:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
   16c6b:	8b 50 0c             	mov    0xc(%eax),%edx
   16c6e:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16c71:	89 c1                	mov    %eax,%ecx
   16c73:	29 d1                	sub    %edx,%ecx
   16c75:	89 ca                	mov    %ecx,%edx
   16c77:	c1 ea 02             	shr    $0x2,%edx
   16c7a:	b8 21 08 82 20       	mov    $0x20820821,%eax
   16c7f:	f7 e2                	mul    %edx
   16c81:	c1 ea 03             	shr    $0x3,%edx
   16c84:	89 d0                	mov    %edx,%eax
   16c86:	c1 e0 06             	shl    $0x6,%eax
   16c89:	29 d0                	sub    %edx,%eax
   16c8b:	c1 e0 02             	shl    $0x2,%eax
   16c8e:	29 c1                	sub    %eax,%ecx
   16c90:	89 c8                	mov    %ecx,%eax
   16c92:	85 c0                	test   %eax,%eax
   16c94:	75 42                	jne    16cd8 <trickles_sendbulk_impl+0x1b6>
   16c96:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   16c99:	8b 90 cc 01 00 00    	mov    0x1cc(%eax),%edx
   16c9f:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16ca2:	3b 42 0c             	cmp    0xc(%edx),%eax
   16ca5:	72 31                	jb     16cd8 <trickles_sendbulk_impl+0x1b6>
   16ca7:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16caa:	05 fc 00 00 00       	add    $0xfc,%eax
   16caf:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   16cb2:	8b 92 cc 01 00 00    	mov    0x1cc(%edx),%edx
   16cb8:	3b 42 10             	cmp    0x10(%edx),%eax
   16cbb:	77 1b                	ja     16cd8 <trickles_sendbulk_impl+0x1b6>
   16cbd:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16cc0:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
   16cc4:	74 0b                	je     16cd1 <trickles_sendbulk_impl+0x1af>
   16cc6:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16cc9:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
   16ccd:	74 02                	je     16cd1 <trickles_sendbulk_impl+0x1af>
   16ccf:	eb 07                	jmp    16cd8 <trickles_sendbulk_impl+0x1b6>
   16cd1:	c7 45 d4 01 00 00 00 	movl   $0x1,0xffffffd4(%ebp)
   16cd8:	83 7d d4 00          	cmpl   $0x0,0xffffffd4(%ebp)
   16cdc:	0f 85 ae 00 00 00    	jne    16d90 <trickles_sendbulk_impl+0x26e>
			printk("trickles_sendbulk_impl: bad minisocket %d %d @ %d\n",
   16ce2:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   16ce5:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   16ce9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
   16cf0:	00 
   16cf1:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16cf4:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
   16cf8:	74 11                	je     16d0b <trickles_sendbulk_impl+0x1e9>
   16cfa:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16cfd:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
   16d01:	74 08                	je     16d0b <trickles_sendbulk_impl+0x1e9>
   16d03:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp,1)
   16d0a:	00 
   16d0b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
   16d12:	00 
   16d13:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16d16:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
   16d1c:	8b 50 0c             	mov    0xc(%eax),%edx
   16d1f:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16d22:	89 c1                	mov    %eax,%ecx
   16d24:	29 d1                	sub    %edx,%ecx
   16d26:	89 ca                	mov    %ecx,%edx
   16d28:	c1 ea 02             	shr    $0x2,%edx
   16d2b:	b8 21 08 82 20       	mov    $0x20820821,%eax
   16d30:	f7 e2                	mul    %edx
   16d32:	c1 ea 03             	shr    $0x3,%edx
   16d35:	89 d0                	mov    %edx,%eax
   16d37:	c1 e0 06             	shl    $0x6,%eax
   16d3a:	29 d0                	sub    %edx,%eax
   16d3c:	c1 e0 02             	shl    $0x2,%eax
   16d3f:	29 c1                	sub    %eax,%ecx
   16d41:	89 c8                	mov    %ecx,%eax
   16d43:	85 c0                	test   %eax,%eax
   16d45:	75 29                	jne    16d70 <trickles_sendbulk_impl+0x24e>
   16d47:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16d4a:	8b 90 cc 01 00 00    	mov    0x1cc(%eax),%edx
   16d50:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16d53:	3b 42 0c             	cmp    0xc(%edx),%eax
   16d56:	72 18                	jb     16d70 <trickles_sendbulk_impl+0x24e>
   16d58:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16d5b:	05 fc 00 00 00       	add    $0xfc,%eax
   16d60:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   16d63:	8b 92 cc 01 00 00    	mov    0x1cc(%edx),%edx
   16d69:	3b 42 10             	cmp    0x10(%edx),%eax
   16d6c:	77 02                	ja     16d70 <trickles_sendbulk_impl+0x24e>
   16d6e:	eb 08                	jmp    16d78 <trickles_sendbulk_impl+0x256>
   16d70:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
   16d77:	00 
   16d78:	c7 04 24 a0 5e 00 00 	movl   $0x5ea0,(%esp,1)
   16d7f:	e8 fc ff ff ff       	call   16d80 <trickles_sendbulk_impl+0x25e>
			       !IS_TRICKLES_SOCK_ADDR(tp,msk), !(VALID_MSK_CTL(msk)),
			       descnum);
			err = -EINVAL;
   16d84:	c7 45 ec ea ff ff ff 	movl   $0xffffffea,0xffffffec(%ebp)
			goto out_release;
   16d8b:	e9 a7 00 00 00       	jmp    16e37 <trickles_sendbulk_impl+0x315>
		}
		free_trickles_msk(sk,msk);
   16d90:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16d93:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   16d97:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16d9a:	89 04 24             	mov    %eax,(%esp,1)
   16d9d:	e8 6b ba ff ff       	call   1280d <free_trickles_msk>
		msk->dbg_mark = curr_desc->dbg_mark;
   16da2:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   16da5:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   16da8:	8b 40 08             	mov    0x8(%eax),%eax
   16dab:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)

		//printk("Desc %d, len = %d\n", descnum, curr_desc->tiov[0].iov_len);
		trickles_do_sendmsg_tiov(sk, msk, curr_desc->tiov, curr_desc->tiov_num);
   16db1:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   16db4:	8b 40 04             	mov    0x4(%eax),%eax
   16db7:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   16dbb:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   16dbe:	83 c0 0c             	add    $0xc,%eax
   16dc1:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   16dc5:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   16dc8:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   16dcc:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16dcf:	89 04 24             	mov    %eax,(%esp,1)
   16dd2:	e8 39 40 00 00       	call   1ae10 <trickles_do_sendmsg_tiov>
		curr_desc = NEXT_MSKDESC(curr_desc);
   16dd7:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   16dda:	8b 40 04             	mov    0x4(%eax),%eax
   16ddd:	c1 e0 03             	shl    $0x3,%eax
   16de0:	03 45 e4             	add    0xffffffe4(%ebp),%eax
   16de3:	83 c0 0c             	add    $0xc,%eax
   16de6:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
		descnum++;
   16de9:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   16dec:	ff 00                	incl   (%eax)
   16dee:	e9 48 fe ff ff       	jmp    16c3b <trickles_sendbulk_impl+0x119>
#if 0
		// Check prequeue
		if (skb_queue_len(&tp->ucopy.prequeue)) {
			tcp_prequeue_process(sk);
		}
#endif
	}
	gNumSendbulkDesc += descnum;
   16df3:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   16df6:	01 05 00 00 00 00    	add    %eax,0x0

	if(tp->trickles_opt & TCP_TRICKLES_BULKPOLL) {
   16dfc:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16dff:	8b 80 ec 01 00 00    	mov    0x1ec(%eax),%eax
   16e05:	25 00 01 00 00       	and    $0x100,%eax
   16e0a:	85 c0                	test   %eax,%eax
   16e0c:	74 29                	je     16e37 <trickles_sendbulk_impl+0x315>
		//printk("bulk poll %d\n", tp->trickles_opt);
		if((err = trickles_poll(sk)) >= 0) {
   16e0e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16e11:	89 04 24             	mov    %eax,(%esp,1)
   16e14:	e8 e5 ce ff ff       	call   13cfe <trickles_poll>
   16e19:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   16e1c:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
   16e20:	78 02                	js     16e24 <trickles_sendbulk_impl+0x302>
   16e22:	eb 13                	jmp    16e37 <trickles_sendbulk_impl+0x315>
			//printk("err = %d\n", err);
		} else {
			printk("err = EAGAIN\n");
   16e24:	c7 04 24 d3 5e 00 00 	movl   $0x5ed3,(%esp,1)
   16e2b:	e8 fc ff ff ff       	call   16e2c <trickles_sendbulk_impl+0x30a>
			err = -EAGAIN;
   16e30:	c7 45 ec f5 ff ff ff 	movl   $0xfffffff5,0xffffffec(%ebp)
		}
	}
 out_release:
	release_sock(sk);
   16e37:	ff 05 08 00 00 00    	incl   0x8
   16e3d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16e40:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   16e47:	74 0b                	je     16e54 <trickles_sendbulk_impl+0x332>
   16e49:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16e4c:	89 04 24             	mov    %eax,(%esp,1)
   16e4f:	e8 fc ff ff ff       	call   16e50 <trickles_sendbulk_impl+0x32e>
   16e54:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16e57:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   16e5e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16e61:	83 c0 30             	add    $0x30,%eax
   16e64:	89 04 24             	mov    %eax,(%esp,1)
   16e67:	e8 76 2e 00 00       	call   19ce2 <waitqueue_active>
   16e6c:	85 c0                	test   %eax,%eax
   16e6e:	74 15                	je     16e85 <trickles_sendbulk_impl+0x363>
   16e70:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16e73:	83 c0 30             	add    $0x30,%eax
   16e76:	b9 01 00 00 00       	mov    $0x1,%ecx
   16e7b:	ba 03 00 00 00       	mov    $0x3,%edx
   16e80:	e8 fc ff ff ff       	call   16e81 <trickles_sendbulk_impl+0x35f>
   16e85:	c7 45 d8 08 00 00 00 	movl   $0x8,0xffffffd8(%ebp)
   16e8c:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   16e8f:	ff 08                	decl   (%eax)
   16e91:	83 38 00             	cmpl   $0x0,(%eax)
   16e94:	75 0d                	jne    16ea3 <trickles_sendbulk_impl+0x381>
   16e96:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   16e99:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   16e9d:	0f 85 bd 53 00 00    	jne    1c260 <.text.lock.tmalloc+0x2f0>
 out_dealloc:
	kfree(descbuf);
   16ea3:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   16ea6:	89 04 24             	mov    %eax,(%esp,1)
   16ea9:	e8 fc ff ff ff       	call   16eaa <trickles_sendbulk_impl+0x388>
 out_put:
	sockfd_put(sock);
   16eae:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   16eb1:	89 04 24             	mov    %eax,(%esp,1)
   16eb4:	e8 89 45 00 00       	call   1b442 <sockfd_put>
 out:
	return err;
   16eb9:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
   16ebc:	c9                   	leave  
   16ebd:	c3                   	ret    

00016ebe <trickles_read_proc>:

/* Bulk debugging output interface */

struct alloc_head_list tricklesProcLogHead;

#if 0
ctl_table trickles_table[] = {
  {DEV_PM_ON, "on", &on, sizeof(on), 0644, NULL, pm_sysctl_handler},
  {0}
};

ctl_table trickles_trickles_table[] = {
  {DEV_PM, "pm", NULL, 0, 0555, pm_table},
  {0}
};

ctl_table trickles_root_table[] = {
  {CTL_DEV, "dev", NULL, 0, 0555, pm_pm_table},
  {0}
};
#endif

int trickles_read_proc(char *page, char **start, off_t offset, int count,
		       int *eof, void *data)
{
   16ebe:	55                   	push   %ebp
   16ebf:	89 e5                	mov    %esp,%ebp
   16ec1:	53                   	push   %ebx
   16ec2:	81 ec a8 10 00 00    	sub    $0x10a8,%esp
    struct TricklesProcLogEntry *logEntry;
    int i, pos = 0, done = 1;
   16ec8:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
   16ecf:	c7 45 ec 01 00 00 00 	movl   $0x1,0xffffffec(%ebp)

    local_bh_disable();
   16ed6:	ff 05 08 00 00 00    	incl   0x8
    alloc_head_walk(&tricklesProcLogHead, logEntry) {
   16edc:	a1 04 00 00 00       	mov    0x4,%eax
   16ee1:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   16ee4:	81 7d f8 00 00 00 00 	cmpl   $0x0,0xfffffff8(%ebp)
   16eeb:	75 05                	jne    16ef2 <trickles_read_proc+0x34>
   16eed:	e9 89 04 00 00       	jmp    1737b <trickles_read_proc+0x4bd>
	    char tempBody[4096], *temp = tempBody;
   16ef2:	8d 85 ec ef ff ff    	lea    0xffffefec(%ebp),%eax
   16ef8:	89 85 e8 ef ff ff    	mov    %eax,0xffffefe8(%ebp)
	    int first = logEntry->returnedEvents == 0;
   16efe:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16f01:	83 78 24 00          	cmpl   $0x0,0x24(%eax)
   16f05:	0f 94 c0             	sete   %al
   16f08:	0f b6 c0             	movzbl %al,%eax
   16f0b:	89 85 e4 ef ff ff    	mov    %eax,0xffffefe4(%ebp)
	    if(first) {
   16f11:	83 bd e4 ef ff ff 00 	cmpl   $0x0,0xffffefe4(%ebp)
   16f18:	0f 84 c0 00 00 00    	je     16fde <trickles_read_proc+0x120>
		    int count = 0;
   16f1e:	c7 85 e0 ef ff ff 00 	movl   $0x0,0xffffefe0(%ebp)
   16f25:	00 00 00 
		    for(i=logEntry->returnedEvents; i < logEntry->size; i++) {
   16f28:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16f2b:	8b 40 24             	mov    0x24(%eax),%eax
   16f2e:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   16f31:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   16f34:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16f37:	3b 42 20             	cmp    0x20(%edx),%eax
   16f3a:	7c 02                	jl     16f3e <trickles_read_proc+0x80>
   16f3c:	eb 2a                	jmp    16f68 <trickles_read_proc+0xaa>
			    if(logEntry->events[i].valid)
   16f3e:	8b 4d f8             	mov    0xfffffff8(%ebp),%ecx
   16f41:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   16f44:	89 d0                	mov    %edx,%eax
   16f46:	c1 e0 02             	shl    $0x2,%eax
   16f49:	01 d0                	add    %edx,%eax
   16f4b:	8b 51 1c             	mov    0x1c(%ecx),%edx
   16f4e:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
   16f52:	83 e0 01             	and    $0x1,%eax
   16f55:	85 c0                	test   %eax,%eax
   16f57:	74 08                	je     16f61 <trickles_read_proc+0xa3>
				    count++;
   16f59:	8d 85 e0 ef ff ff    	lea    0xffffefe0(%ebp),%eax
   16f5f:	ff 00                	incl   (%eax)
   16f61:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   16f64:	ff 00                	incl   (%eax)
   16f66:	eb c9                	jmp    16f31 <trickles_read_proc+0x73>
		    }
		    sprintf(temp, "Socket (daddr=%X port=%d) (rcv_nxt=%u,trcv_nxt=%u) [%d]\n",
   16f68:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16f6b:	0f b7 40 10          	movzwl 0x10(%eax),%eax
   16f6f:	89 04 24             	mov    %eax,(%esp,1)
   16f72:	e8 fc ff ff ff       	call   16f73 <trickles_read_proc+0xb5>
   16f77:	0f b7 d8             	movzwl %ax,%ebx
   16f7a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16f7d:	8b 40 0c             	mov    0xc(%eax),%eax
   16f80:	89 04 24             	mov    %eax,(%esp,1)
   16f83:	e8 fc ff ff ff       	call   16f84 <trickles_read_proc+0xc6>
   16f88:	89 c2                	mov    %eax,%edx
   16f8a:	8b 85 e0 ef ff ff    	mov    0xffffefe0(%ebp),%eax
   16f90:	89 44 24 18          	mov    %eax,0x18(%esp,1)
   16f94:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16f97:	8b 40 18             	mov    0x18(%eax),%eax
   16f9a:	89 44 24 14          	mov    %eax,0x14(%esp,1)
   16f9e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16fa1:	8b 40 14             	mov    0x14(%eax),%eax
   16fa4:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   16fa8:	89 5c 24 0c          	mov    %ebx,0xc(%esp,1)
   16fac:	89 54 24 08          	mov    %edx,0x8(%esp,1)
   16fb0:	c7 44 24 04 00 5f 00 	movl   $0x5f00,0x4(%esp,1)
   16fb7:	00 
   16fb8:	8b 85 e8 ef ff ff    	mov    0xffffefe8(%ebp),%eax
   16fbe:	89 04 24             	mov    %eax,(%esp,1)
   16fc1:	e8 fc ff ff ff       	call   16fc2 <trickles_read_proc+0x104>
			    htonl(logEntry->addr), htons(logEntry->port),
			    logEntry->rcv_nxt, logEntry->t_rcv_nxt, count);
		    temp += strlen(temp);
   16fc6:	8b 85 e8 ef ff ff    	mov    0xffffefe8(%ebp),%eax
   16fcc:	89 04 24             	mov    %eax,(%esp,1)
   16fcf:	e8 51 2d 00 00       	call   19d25 <strlen>
   16fd4:	89 c2                	mov    %eax,%edx
   16fd6:	8d 85 e8 ef ff ff    	lea    0xffffefe8(%ebp),%eax
   16fdc:	01 10                	add    %edx,(%eax)
	    }
	    for(i=logEntry->returnedEvents; i < logEntry->size; i++) {
   16fde:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   16fe1:	8b 40 24             	mov    0x24(%eax),%eax
   16fe4:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   16fe7:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   16fea:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   16fed:	3b 42 20             	cmp    0x20(%edx),%eax
   16ff0:	7c 05                	jl     16ff7 <trickles_read_proc+0x139>
   16ff2:	e9 27 03 00 00       	jmp    1731e <trickles_read_proc+0x460>
		    struct TricklesLossEvent *event = &logEntry->events[i];
   16ff7:	8b 4d f8             	mov    0xfffffff8(%ebp),%ecx
   16ffa:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   16ffd:	89 d0                	mov    %edx,%eax
   16fff:	c1 e0 02             	shl    $0x2,%eax
   17002:	01 d0                	add    %edx,%eax
   17004:	03 41 1c             	add    0x1c(%ecx),%eax
   17007:	89 85 e0 ef ff ff    	mov    %eax,0xffffefe0(%ebp)
		    char locationBuf[64];
		    char *saveLocation;
		    char *state;
		    if(!event->valid) continue;
   1700d:	8b 85 e0 ef ff ff    	mov    0xffffefe0(%ebp),%eax
   17013:	0f b6 00             	movzbl (%eax),%eax
   17016:	83 e0 01             	and    $0x1,%eax
   17019:	85 c0                	test   %eax,%eax
   1701b:	75 05                	jne    17022 <trickles_read_proc+0x164>
   1701d:	e9 f2 02 00 00       	jmp    17314 <trickles_read_proc+0x456>
		    done = 0;
   17022:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
		    switch(event->extra) {
   17029:	8b 85 e0 ef ff ff    	mov    0xffffefe0(%ebp),%eax
   1702f:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   17033:	83 e0 1f             	and    $0x1f,%eax
   17036:	89 85 7c ef ff ff    	mov    %eax,0xffffef7c(%ebp)
   1703c:	83 bd 7c ef ff ff 02 	cmpl   $0x2,0xffffef7c(%ebp)
   17043:	74 34                	je     17079 <trickles_read_proc+0x1bb>
   17045:	83 bd 7c ef ff ff 02 	cmpl   $0x2,0xffffef7c(%ebp)
   1704c:	7f 0b                	jg     17059 <trickles_read_proc+0x19b>
   1704e:	83 bd 7c ef ff ff 01 	cmpl   $0x1,0xffffef7c(%ebp)
   17055:	74 16                	je     1706d <trickles_read_proc+0x1af>
   17057:	eb 44                	jmp    1709d <trickles_read_proc+0x1df>
   17059:	83 bd 7c ef ff ff 03 	cmpl   $0x3,0xffffef7c(%ebp)
   17060:	74 23                	je     17085 <trickles_read_proc+0x1c7>
   17062:	83 bd 7c ef ff ff 04 	cmpl   $0x4,0xffffef7c(%ebp)
   17069:	74 26                	je     17091 <trickles_read_proc+0x1d3>
   1706b:	eb 30                	jmp    1709d <trickles_read_proc+0x1df>
		    case EVENT_EXTRA_SEND:
			    saveLocation = "sendStateChange";
   1706d:	c7 85 9c ef ff ff 39 	movl   $0x5f39,0xffffef9c(%ebp)
   17074:	5f 00 00 
			    break;
   17077:	eb 57                	jmp    170d0 <trickles_read_proc+0x212>
		    case EVENT_EXTRA_RECV:
			    saveLocation = "recv";
   17079:	c7 85 9c ef ff ff 49 	movl   $0x5f49,0xffffef9c(%ebp)
   17080:	5f 00 00 
			    break;
   17083:	eb 4b                	jmp    170d0 <trickles_read_proc+0x212>
		    case EVENT_EXTRA_SAMPLE0:
			    saveLocation = "contList sample0";
   17085:	c7 85 9c ef ff ff 4e 	movl   $0x5f4e,0xffffef9c(%ebp)
   1708c:	5f 00 00 
			    break;
   1708f:	eb 3f                	jmp    170d0 <trickles_read_proc+0x212>
		    case EVENT_EXTRA_SAMPLE1:
			    saveLocation = "contList sample1";
   17091:	c7 85 9c ef ff ff 5f 	movl   $0x5f5f,0xffffef9c(%ebp)
   17098:	5f 00 00 
			    break;
   1709b:	eb 33                	jmp    170d0 <trickles_read_proc+0x212>
		    default:
			    sprintf(locationBuf, "(bad location %d)", event->extra);
   1709d:	8b 85 e0 ef ff ff    	mov    0xffffefe0(%ebp),%eax
   170a3:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   170a7:	83 e0 1f             	and    $0x1f,%eax
   170aa:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   170ae:	c7 44 24 04 70 5f 00 	movl   $0x5f70,0x4(%esp,1)
   170b5:	00 
   170b6:	8d 85 a0 ef ff ff    	lea    0xffffefa0(%ebp),%eax
   170bc:	89 04 24             	mov    %eax,(%esp,1)
   170bf:	e8 fc ff ff ff       	call   170c0 <trickles_read_proc+0x202>
			    saveLocation = locationBuf;
   170c4:	8d 85 a0 ef ff ff    	lea    0xffffefa0(%ebp),%eax
   170ca:	89 85 9c ef ff ff    	mov    %eax,0xffffef9c(%ebp)
		    }
		    switch(event->state) {
   170d0:	8b 85 e0 ef ff ff    	mov    0xffffefe0(%ebp),%eax
   170d6:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   170da:	c0 e8 05             	shr    $0x5,%al
   170dd:	0f b6 c0             	movzbl %al,%eax
   170e0:	89 85 78 ef ff ff    	mov    %eax,0xffffef78(%ebp)
   170e6:	83 bd 78 ef ff ff 02 	cmpl   $0x2,0xffffef78(%ebp)
   170ed:	74 34                	je     17123 <trickles_read_proc+0x265>
   170ef:	83 bd 78 ef ff ff 02 	cmpl   $0x2,0xffffef78(%ebp)
   170f6:	7f 0b                	jg     17103 <trickles_read_proc+0x245>
   170f8:	83 bd 78 ef ff ff 01 	cmpl   $0x1,0xffffef78(%ebp)
   170ff:	74 16                	je     17117 <trickles_read_proc+0x259>
   17101:	eb 44                	jmp    17147 <trickles_read_proc+0x289>
   17103:	83 bd 78 ef ff ff 03 	cmpl   $0x3,0xffffef78(%ebp)
   1710a:	74 23                	je     1712f <trickles_read_proc+0x271>
   1710c:	83 bd 78 ef ff ff 04 	cmpl   $0x4,0xffffef78(%ebp)
   17113:	74 26                	je     1713b <trickles_read_proc+0x27d>
   17115:	eb 30                	jmp    17147 <trickles_read_proc+0x289>
		    case TRICKLES_CLIENT_NORMAL:
			    state = "(normal)";
   17117:	c7 85 98 ef ff ff 82 	movl   $0x5f82,0xffffef98(%ebp)
   1711e:	5f 00 00 
			    break;
   17121:	eb 2e                	jmp    17151 <trickles_read_proc+0x293>
		    case TRICKLES_CLIENT_RECOVERY:
			    state = "(recovery)";
   17123:	c7 85 98 ef ff ff 8b 	movl   $0x5f8b,0xffffef98(%ebp)
   1712a:	5f 00 00 
			    break;
   1712d:	eb 22                	jmp    17151 <trickles_read_proc+0x293>
		    case TRICKLES_CLIENT_SLOWSTART:
			    state = "(slowstart)";
   1712f:	c7 85 98 ef ff ff 96 	movl   $0x5f96,0xffffef98(%ebp)
   17136:	5f 00 00 
			    break;
   17139:	eb 16                	jmp    17151 <trickles_read_proc+0x293>
		    case TRICKLES_CLIENT_SYNACK:
			    state = "(synack)";
   1713b:	c7 85 98 ef ff ff a2 	movl   $0x5fa2,0xffffef98(%ebp)
   17142:	5f 00 00 
			    break;
   17145:	eb 0a                	jmp    17151 <trickles_read_proc+0x293>
		    default:
			    state = "(bad state)";
   17147:	c7 85 98 ef ff ff ab 	movl   $0x5fab,0xffffef98(%ebp)
   1714e:	5f 00 00 
		    }
		    sprintf(temp, "%s: cwnd=%d state=%s time=%d\n", saveLocation,
   17151:	8b 95 e0 ef ff ff    	mov    0xffffefe0(%ebp),%edx
   17157:	0f b6 4a 02          	movzbl 0x2(%edx),%ecx
   1715b:	0f b6 42 03          	movzbl 0x3(%edx),%eax
   1715f:	c1 e0 08             	shl    $0x8,%eax
   17162:	09 c1                	or     %eax,%ecx
   17164:	0f b6 42 04          	movzbl 0x4(%edx),%eax
   17168:	c1 e0 10             	shl    $0x10,%eax
   1716b:	09 c8                	or     %ecx,%eax
   1716d:	89 44 24 14          	mov    %eax,0x14(%esp,1)
   17171:	8b 85 98 ef ff ff    	mov    0xffffef98(%ebp),%eax
   17177:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   1717b:	8b 85 e0 ef ff ff    	mov    0xffffefe0(%ebp),%eax
   17181:	0f b6 00             	movzbl (%eax),%eax
   17184:	d0 e8                	shr    %al
   17186:	0f b6 c0             	movzbl %al,%eax
   17189:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   1718d:	8b 85 9c ef ff ff    	mov    0xffffef9c(%ebp),%eax
   17193:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   17197:	c7 44 24 04 b7 5f 00 	movl   $0x5fb7,0x4(%esp,1)
   1719e:	00 
   1719f:	8b 85 e8 ef ff ff    	mov    0xffffefe8(%ebp),%eax
   171a5:	89 04 24             	mov    %eax,(%esp,1)
   171a8:	e8 fc ff ff ff       	call   171a9 <trickles_read_proc+0x2eb>
			    (int)event->cwnd, state, event->time);
		    if(first) {
   171ad:	83 bd e4 ef ff ff 00 	cmpl   $0x0,0xffffefe4(%ebp)
   171b4:	74 16                	je     171cc <trickles_read_proc+0x30e>
			    temp = tempBody;
   171b6:	8d 85 ec ef ff ff    	lea    0xffffefec(%ebp),%eax
   171bc:	89 85 e8 ef ff ff    	mov    %eax,0xffffefe8(%ebp)
			    first = 0;
   171c2:	c7 85 e4 ef ff ff 00 	movl   $0x0,0xffffefe4(%ebp)
   171c9:	00 00 00 
		    }
		    temp += logEntry->sentAmount;
   171cc:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   171cf:	8b 50 28             	mov    0x28(%eax),%edx
   171d2:	8d 85 e8 ef ff ff    	lea    0xffffefe8(%ebp),%eax
   171d8:	01 10                	add    %edx,(%eax)
		    int copyLen = MAX(MIN((int)strlen(temp), count - pos), 0);
   171da:	c7 85 90 ef ff ff 00 	movl   $0x0,0xffffef90(%ebp)
   171e1:	00 00 00 
   171e4:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   171e7:	8b 45 14             	mov    0x14(%ebp),%eax
   171ea:	29 d0                	sub    %edx,%eax
   171ec:	89 85 88 ef ff ff    	mov    %eax,0xffffef88(%ebp)
   171f2:	8b 85 e8 ef ff ff    	mov    0xffffefe8(%ebp),%eax
   171f8:	89 04 24             	mov    %eax,(%esp,1)
   171fb:	e8 25 2b 00 00       	call   19d25 <strlen>
   17200:	89 85 84 ef ff ff    	mov    %eax,0xffffef84(%ebp)
   17206:	8b 85 88 ef ff ff    	mov    0xffffef88(%ebp),%eax
   1720c:	89 85 80 ef ff ff    	mov    %eax,0xffffef80(%ebp)
   17212:	8b 85 80 ef ff ff    	mov    0xffffef80(%ebp),%eax
   17218:	89 85 74 ef ff ff    	mov    %eax,0xffffef74(%ebp)
   1721e:	8b 85 74 ef ff ff    	mov    0xffffef74(%ebp),%eax
   17224:	3b 85 84 ef ff ff    	cmp    0xffffef84(%ebp),%eax
   1722a:	7e 0c                	jle    17238 <trickles_read_proc+0x37a>
   1722c:	8b 85 84 ef ff ff    	mov    0xffffef84(%ebp),%eax
   17232:	89 85 74 ef ff ff    	mov    %eax,0xffffef74(%ebp)
   17238:	8b 85 74 ef ff ff    	mov    0xffffef74(%ebp),%eax
   1723e:	89 85 8c ef ff ff    	mov    %eax,0xffffef8c(%ebp)
   17244:	8b 85 90 ef ff ff    	mov    0xffffef90(%ebp),%eax
   1724a:	89 85 80 ef ff ff    	mov    %eax,0xffffef80(%ebp)
   17250:	8b 85 80 ef ff ff    	mov    0xffffef80(%ebp),%eax
   17256:	89 85 70 ef ff ff    	mov    %eax,0xffffef70(%ebp)
   1725c:	8b 85 70 ef ff ff    	mov    0xffffef70(%ebp),%eax
   17262:	3b 85 8c ef ff ff    	cmp    0xffffef8c(%ebp),%eax
   17268:	7d 0c                	jge    17276 <trickles_read_proc+0x3b8>
   1726a:	8b 85 8c ef ff ff    	mov    0xffffef8c(%ebp),%eax
   17270:	89 85 70 ef ff ff    	mov    %eax,0xffffef70(%ebp)
   17276:	8b 85 70 ef ff ff    	mov    0xffffef70(%ebp),%eax
   1727c:	89 85 94 ef ff ff    	mov    %eax,0xffffef94(%ebp)
		    if(copyLen == strlen(temp)) {
   17282:	8b 85 e8 ef ff ff    	mov    0xffffefe8(%ebp),%eax
   17288:	89 04 24             	mov    %eax,(%esp,1)
   1728b:	e8 95 2a 00 00       	call   19d25 <strlen>
   17290:	39 85 94 ef ff ff    	cmp    %eax,0xffffef94(%ebp)
   17296:	75 07                	jne    1729f <trickles_read_proc+0x3e1>
			    done = 1;
   17298:	c7 45 ec 01 00 00 00 	movl   $0x1,0xffffffec(%ebp)
		    }
		    memcpy(page + pos, temp, copyLen);
   1729f:	8b 85 94 ef ff ff    	mov    0xffffef94(%ebp),%eax
   172a5:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   172a9:	8b 85 e8 ef ff ff    	mov    0xffffefe8(%ebp),%eax
   172af:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   172b3:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   172b6:	03 45 08             	add    0x8(%ebp),%eax
   172b9:	89 04 24             	mov    %eax,(%esp,1)
   172bc:	e8 8a 2a 00 00       	call   19d4b <__memcpy>
		    pos += copyLen;
   172c1:	8b 95 94 ef ff ff    	mov    0xffffef94(%ebp),%edx
   172c7:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   172ca:	01 10                	add    %edx,(%eax)
		    if(done) {
   172cc:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
   172d0:	74 12                	je     172e4 <trickles_read_proc+0x426>
			    logEntry->returnedEvents++;
   172d2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   172d5:	ff 40 24             	incl   0x24(%eax)
			    logEntry->sentAmount = 0;
   172d8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   172db:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
   172e2:	eb 30                	jmp    17314 <trickles_read_proc+0x456>
		    } else {
			    logEntry->sentAmount += copyLen;
   172e4:	8b 4d f8             	mov    0xfffffff8(%ebp),%ecx
   172e7:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   172ea:	8b 85 94 ef ff ff    	mov    0xffffef94(%ebp),%eax
   172f0:	03 42 28             	add    0x28(%edx),%eax
   172f3:	89 41 28             	mov    %eax,0x28(%ecx)
			    //printk("sentamount = %d\n", logEntry->sentAmount);
			    BUG_TRAP(pos == count);
   172f6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   172f9:	3b 45 14             	cmp    0x14(%ebp),%eax
   172fc:	74 7d                	je     1737b <trickles_read_proc+0x4bd>
   172fe:	c7 44 24 04 5a 08 00 	movl   $0x85a,0x4(%esp,1)
   17305:	00 
   17306:	c7 04 24 e0 5f 00 00 	movl   $0x5fe0,(%esp,1)
   1730d:	e8 fc ff ff ff       	call   1730e <trickles_read_proc+0x450>
			    goto done;
   17312:	eb 67                	jmp    1737b <trickles_read_proc+0x4bd>
   17314:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   17317:	ff 00                	incl   (%eax)
   17319:	e9 c9 fc ff ff       	jmp    16fe7 <trickles_read_proc+0x129>
		    }
	    }
	    if(done && (i == logEntry->size)) {
   1731e:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
   17322:	74 49                	je     1736d <trickles_read_proc+0x4af>
   17324:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   17327:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1732a:	3b 42 20             	cmp    0x20(%edx),%eax
   1732d:	75 3e                	jne    1736d <trickles_read_proc+0x4af>
		    struct TricklesProcLogEntry *clean = logEntry;
   1732f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   17332:	89 85 80 ef ff ff    	mov    %eax,0xffffef80(%ebp)
		    logEntry = (struct TricklesProcLogEntry *)logEntry->prev;
   17338:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1733b:	8b 00                	mov    (%eax),%eax
   1733d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
		    unlink((struct alloc_head*)clean);
   17340:	8b 85 80 ef ff ff    	mov    0xffffef80(%ebp),%eax
   17346:	89 04 24             	mov    %eax,(%esp,1)
   17349:	e8 fd 32 00 00       	call   1a64b <unlink>
		    kfree(clean->events);
   1734e:	8b 85 80 ef ff ff    	mov    0xffffef80(%ebp),%eax
   17354:	8b 40 1c             	mov    0x1c(%eax),%eax
   17357:	89 04 24             	mov    %eax,(%esp,1)
   1735a:	e8 fc ff ff ff       	call   1735b <trickles_read_proc+0x49d>
		    kfree(clean);
   1735f:	8b 85 80 ef ff ff    	mov    0xffffef80(%ebp),%eax
   17365:	89 04 24             	mov    %eax,(%esp,1)
   17368:	e8 fc ff ff ff       	call   17369 <trickles_read_proc+0x4ab>
   1736d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   17370:	8b 40 04             	mov    0x4(%eax),%eax
   17373:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   17376:	e9 69 fb ff ff       	jmp    16ee4 <trickles_read_proc+0x26>
	    }
    }
 done:
    if(empty(&tricklesProcLogHead)) {
   1737b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   17382:	e8 94 31 00 00       	call   1a51b <empty>
   17387:	85 c0                	test   %eax,%eax
   17389:	74 0b                	je     17396 <trickles_read_proc+0x4d8>
	    *eof = 1;
   1738b:	8b 45 18             	mov    0x18(%ebp),%eax
   1738e:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
   17394:	eb 09                	jmp    1739f <trickles_read_proc+0x4e1>
    } else {
	    *eof = 0;
   17396:	8b 45 18             	mov    0x18(%ebp),%eax
   17399:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    local_bh_enable();
   1739f:	c7 85 80 ef ff ff 08 	movl   $0x8,0xffffef80(%ebp)
   173a6:	00 00 00 
   173a9:	8b 85 80 ef ff ff    	mov    0xffffef80(%ebp),%eax
   173af:	ff 08                	decl   (%eax)
   173b1:	83 38 00             	cmpl   $0x0,(%eax)
   173b4:	75 10                	jne    173c6 <trickles_read_proc+0x508>
   173b6:	8b 85 80 ef ff ff    	mov    0xffffef80(%ebp),%eax
   173bc:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   173c0:	0f 85 aa 4e 00 00    	jne    1c270 <.text.lock.tmalloc+0x300>
    *start = page;
   173c6:	8b 55 0c             	mov    0xc(%ebp),%edx
   173c9:	8b 45 08             	mov    0x8(%ebp),%eax
   173cc:	89 02                	mov    %eax,(%edx)
    //printk("pos=%d, count=%d\n", pos, count);
    return pos;
   173ce:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
}
   173d1:	81 c4 a8 10 00 00    	add    $0x10a8,%esp
   173d7:	5b                   	pop    %ebx
   173d8:	5d                   	pop    %ebp
   173d9:	c3                   	ret    

000173da <bb_init>:

struct alloc_head_list tricklesCwndProcLogHead;

struct BoundedBuffer {
	char *dest;
	int len;
	int curPos;
};

void bb_init(struct BoundedBuffer *bb, char *buffer, int len) {
   173da:	55                   	push   %ebp
   173db:	89 e5                	mov    %esp,%ebp
	bb->dest = buffer;
   173dd:	8b 55 08             	mov    0x8(%ebp),%edx
   173e0:	8b 45 0c             	mov    0xc(%ebp),%eax
   173e3:	89 02                	mov    %eax,(%edx)
	bb->len = len;
   173e5:	8b 55 08             	mov    0x8(%ebp),%edx
   173e8:	8b 45 10             	mov    0x10(%ebp),%eax
   173eb:	89 42 04             	mov    %eax,0x4(%edx)
	bb->curPos = 0;
   173ee:	8b 45 08             	mov    0x8(%ebp),%eax
   173f1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

	//printk("bbinit: %p %d %d\n", bb->dest, bb->len, bb->curPos);
}
   173f8:	5d                   	pop    %ebp
   173f9:	c3                   	ret    

000173fa <bb_write>:

int bb_write(struct BoundedBuffer *bb, const char *data, int len) {
   173fa:	55                   	push   %ebp
   173fb:	89 e5                	mov    %esp,%ebp
   173fd:	83 ec 28             	sub    $0x28,%esp
	int prevPos = bb->curPos;
   17400:	8b 45 08             	mov    0x8(%ebp),%eax
   17403:	8b 40 08             	mov    0x8(%eax),%eax
   17406:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	int copyLen;
	bb->curPos = MIN(prevPos+len, bb->len);
   17409:	8b 45 08             	mov    0x8(%ebp),%eax
   1740c:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1740f:	8b 45 08             	mov    0x8(%ebp),%eax
   17412:	8b 40 04             	mov    0x4(%eax),%eax
   17415:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   17418:	8b 45 10             	mov    0x10(%ebp),%eax
   1741b:	03 45 fc             	add    0xfffffffc(%ebp),%eax
   1741e:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   17421:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   17424:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   17427:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   1742a:	89 55 e4             	mov    %edx,0xffffffe4(%ebp)
   1742d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   17430:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
   17433:	7e 06                	jle    1743b <bb_write+0x41>
   17435:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   17438:	89 55 e4             	mov    %edx,0xffffffe4(%ebp)
   1743b:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   1743e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   17441:	89 50 08             	mov    %edx,0x8(%eax)
	copyLen = bb->curPos - prevPos;
   17444:	8b 45 08             	mov    0x8(%ebp),%eax
   17447:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1744a:	8b 40 08             	mov    0x8(%eax),%eax
   1744d:	29 d0                	sub    %edx,%eax
   1744f:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

	memcpy(bb->dest + prevPos, data, copyLen);
   17452:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   17455:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   17459:	8b 45 0c             	mov    0xc(%ebp),%eax
   1745c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   17460:	8b 55 08             	mov    0x8(%ebp),%edx
   17463:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   17466:	03 02                	add    (%edx),%eax
   17468:	89 04 24             	mov    %eax,(%esp,1)
   1746b:	e8 db 28 00 00       	call   19d4b <__memcpy>
	return copyLen;
   17470:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
}
   17473:	c9                   	leave  
   17474:	c3                   	ret    

00017475 <trickles_logCwnd_impl>:

spinlock_t cwndLogLock = SPIN_LOCK_UNLOCKED;

void trickles_logCwnd_impl(enum LogCwndType type, int addr, int port, int seq, int ack_seq,
			   int startCwnd, int effCwnd, int ssthresh,
			   int rtt, int srtt) {
   17475:	55                   	push   %ebp
   17476:	89 e5                	mov    %esp,%ebp
#ifdef LOG_CWND_ENABLE
	struct TricklesCwndProcLogEntry *logentry =
		kmalloc(sizeof(struct TricklesCwndProcLogEntry), GFP_ATOMIC);
	if(logentry != NULL) {
		logentry->prev = logentry->next = NULL;
		logentry->list = NULL;

		logentry->type = type;

		logentry->addr = addr;
		logentry->port = port;
		logentry->seq  = seq;
		logentry->ack_seq = ack_seq;
		logentry->startCwnd= startCwnd;
		logentry->effCwnd  = effCwnd;
		logentry->ssthresh = ssthresh;
		logentry->sentAmount = 0;
#if 0
		logentry->timestamp = jiffies;
#else
		// high resolution timestamp
		struct timeval tv;
		do_gettimeofday(&tv);
		// s, us
		logentry->s = tv.tv_sec;
		logentry->us = tv.tv_usec;
#endif
		logentry->rtt = rtt;
		logentry->srtt = srtt;
		spin_lock(&cwndLogLock);
		insert_tail(&tricklesCwndProcLogHead, (struct alloc_head*)logentry);
		spin_unlock(&cwndLogLock);
	}
#endif
}
   17478:	5d                   	pop    %ebp
   17479:	c3                   	ret    

0001747a <trickles_cwnd_read_proc>:

int trickles_cwnd_read_proc(char *page, char **start, off_t offset, int count,
			    int *eof, void *data)
{
   1747a:	55                   	push   %ebp
   1747b:	89 e5                	mov    %esp,%ebp
   1747d:	81 ec 58 04 00 00    	sub    $0x458,%esp
    struct TricklesCwndProcLogEntry *logEntry;
    struct BoundedBuffer bb;
    bb_init(&bb, page, count);
   17483:	8b 45 14             	mov    0x14(%ebp),%eax
   17486:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1748a:	8b 45 08             	mov    0x8(%ebp),%eax
   1748d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   17491:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   17494:	89 04 24             	mov    %eax,(%esp,1)
   17497:	e8 fc ff ff ff       	call   17498 <trickles_cwnd_read_proc+0x1e>

#define TRICKLES_CWND_READ_DISABLE_BH
#ifdef TRICKLES_CWND_READ_DISABLE_BH
    local_bh_disable();
   1749c:	ff 05 08 00 00 00    	incl   0x8
#else
    #warning "Local bh not disabled while reading from cwnd log"
#endif
    alloc_head_walk(&tricklesCwndProcLogHead, logEntry) {
   174a2:	a1 04 00 00 00       	mov    0x4,%eax
   174a7:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   174aa:	81 7d fc 00 00 00 00 	cmpl   $0x0,0xfffffffc(%ebp)
   174b1:	75 05                	jne    174b8 <trickles_cwnd_read_proc+0x3e>
   174b3:	e9 ff 02 00 00       	jmp    177b7 <trickles_cwnd_read_proc+0x33d>
	    if(1) {
		    char tempbuf[1024];
		    int wrlen, real_wrlen;
		    //sprintf(tempbuf, "%8.8X:%d:%d:%d = %d/%d/%d @ %d s %d us %d rtt0 %d rtt1\n",
		    //sprintf(tempbuf, "%8.8X:%d:%d:%d = %d/%d/%d @ %d s %d us %d TCPBase %d rtt1\n",
		    switch(logEntry->type) {
   174b8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   174bb:	8b 40 0c             	mov    0xc(%eax),%eax
   174be:	89 85 d8 fb ff ff    	mov    %eax,0xfffffbd8(%ebp)
   174c4:	83 bd d8 fb ff ff 02 	cmpl   $0x2,0xfffffbd8(%ebp)
   174cb:	0f 84 13 01 00 00    	je     175e4 <trickles_cwnd_read_proc+0x16a>
   174d1:	83 bd d8 fb ff ff 02 	cmpl   $0x2,0xfffffbd8(%ebp)
   174d8:	77 12                	ja     174ec <trickles_cwnd_read_proc+0x72>
   174da:	83 bd d8 fb ff ff 01 	cmpl   $0x1,0xfffffbd8(%ebp)
   174e1:	0f 84 88 00 00 00    	je     1756f <trickles_cwnd_read_proc+0xf5>
   174e7:	e9 02 02 00 00       	jmp    176ee <trickles_cwnd_read_proc+0x274>
   174ec:	83 bd d8 fb ff ff 03 	cmpl   $0x3,0xfffffbd8(%ebp)
   174f3:	74 05                	je     174fa <trickles_cwnd_read_proc+0x80>
   174f5:	e9 f4 01 00 00       	jmp    176ee <trickles_cwnd_read_proc+0x274>
		    case PACKET_RECORD:
			    sprintf(tempbuf, "pkt - %d:%d = %d/%d/%d @ %d s %d us %d rtt0 %d rtt1\n",
   174fa:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   174fd:	8b 40 38             	mov    0x38(%eax),%eax
   17500:	89 44 24 28          	mov    %eax,0x28(%esp,1)
   17504:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   17507:	8b 40 34             	mov    0x34(%eax),%eax
   1750a:	89 44 24 24          	mov    %eax,0x24(%esp,1)
   1750e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   17511:	8b 40 30             	mov    0x30(%eax),%eax
   17514:	89 44 24 20          	mov    %eax,0x20(%esp,1)
   17518:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1751b:	8b 40 2c             	mov    0x2c(%eax),%eax
   1751e:	89 44 24 1c          	mov    %eax,0x1c(%esp,1)
   17522:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   17525:	8b 40 28             	mov    0x28(%eax),%eax
   17528:	89 44 24 18          	mov    %eax,0x18(%esp,1)
   1752c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1752f:	8b 40 24             	mov    0x24(%eax),%eax
   17532:	89 44 24 14          	mov    %eax,0x14(%esp,1)
   17536:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   17539:	8b 40 20             	mov    0x20(%eax),%eax
   1753c:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   17540:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   17543:	8b 40 1c             	mov    0x1c(%eax),%eax
   17546:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   1754a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1754d:	8b 40 18             	mov    0x18(%eax),%eax
   17550:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   17554:	c7 44 24 04 40 60 00 	movl   $0x6040,0x4(%esp,1)
   1755b:	00 
   1755c:	8d 85 ec fb ff ff    	lea    0xfffffbec(%ebp),%eax
   17562:	89 04 24             	mov    %eax,(%esp,1)
   17565:	e8 fc ff ff ff       	call   17566 <trickles_cwnd_read_proc+0xec>
				    logEntry->seq, logEntry->ack_seq,
				    logEntry->startCwnd, logEntry->effCwnd, logEntry->ssthresh,
				    logEntry->s, logEntry->us,
				    logEntry->rtt,
				    logEntry->srtt);
			    break;
   1756a:	e9 95 01 00 00       	jmp    17704 <trickles_cwnd_read_proc+0x28a>
		    case CONTINUATION_RECORD:
			    sprintf(tempbuf, "cont - %d:%d = %d/%d/%d TCPBase: %d @ %d s %d us rtt1: %d \n",
   1756f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   17572:	8b 40 38             	mov    0x38(%eax),%eax
   17575:	89 44 24 28          	mov    %eax,0x28(%esp,1)
   17579:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1757c:	8b 40 30             	mov    0x30(%eax),%eax
   1757f:	89 44 24 24          	mov    %eax,0x24(%esp,1)
   17583:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   17586:	8b 40 2c             	mov    0x2c(%eax),%eax
   17589:	89 44 24 20          	mov    %eax,0x20(%esp,1)
   1758d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   17590:	8b 40 34             	mov    0x34(%eax),%eax
   17593:	89 44 24 1c          	mov    %eax,0x1c(%esp,1)
   17597:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1759a:	8b 40 28             	mov    0x28(%eax),%eax
   1759d:	89 44 24 18          	mov    %eax,0x18(%esp,1)
   175a1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   175a4:	8b 40 24             	mov    0x24(%eax),%eax
   175a7:	89 44 24 14          	mov    %eax,0x14(%esp,1)
   175ab:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   175ae:	8b 40 20             	mov    0x20(%eax),%eax
   175b1:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   175b5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   175b8:	8b 40 1c             	mov    0x1c(%eax),%eax
   175bb:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   175bf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   175c2:	8b 40 18             	mov    0x18(%eax),%eax
   175c5:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   175c9:	c7 44 24 04 80 60 00 	movl   $0x6080,0x4(%esp,1)
   175d0:	00 
   175d1:	8d 85 ec fb ff ff    	lea    0xfffffbec(%ebp),%eax
   175d7:	89 04 24             	mov    %eax,(%esp,1)
   175da:	e8 fc ff ff ff       	call   175db <trickles_cwnd_read_proc+0x161>
				    logEntry->seq, logEntry->ack_seq,
				    logEntry->startCwnd, logEntry->effCwnd, logEntry->ssthresh,
				    logEntry->rtt,
				    logEntry->s, logEntry->us,
				    logEntry->srtt);
			    break;
   175df:	e9 20 01 00 00       	jmp    17704 <trickles_cwnd_read_proc+0x28a>
		    case EVENT_RECORD: {
			    int eventtype = logEntry->seq;
   175e4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   175e7:	8b 40 18             	mov    0x18(%eax),%eax
   175ea:	89 85 e0 fb ff ff    	mov    %eax,0xfffffbe0(%ebp)
			    char *eventTypeStr = "(undef0)";
   175f0:	c7 85 dc fb ff ff bc 	movl   $0x60bc,0xfffffbdc(%ebp)
   175f7:	60 00 00 
			    switch(eventtype) {
   175fa:	83 bd e0 fb ff ff 07 	cmpl   $0x7,0xfffffbe0(%ebp)
   17601:	77 65                	ja     17668 <trickles_cwnd_read_proc+0x1ee>
   17603:	8b 85 e0 fb ff ff    	mov    0xfffffbe0(%ebp),%eax
   17609:	c1 e0 02             	shl    $0x2,%eax
   1760c:	8b 80 68 61 00 00    	mov    0x6168(%eax),%eax
   17612:	ff e0                	jmp    *%eax
			    case RECOVERYEVENT:
				    eventTypeStr = "Recovery";
   17614:	c7 85 dc fb ff ff c5 	movl   $0x60c5,0xfffffbdc(%ebp)
   1761b:	60 00 00 
				    break;
   1761e:	eb 52                	jmp    17672 <trickles_cwnd_read_proc+0x1f8>
			    case TIMEOUTEVENT0:
				    eventTypeStr = "Timeout0";
   17620:	c7 85 dc fb ff ff ce 	movl   $0x60ce,0xfffffbdc(%ebp)
   17627:	60 00 00 
				    break;
   1762a:	eb 46                	jmp    17672 <trickles_cwnd_read_proc+0x1f8>
			    case TIMEOUTEVENT1:
				    eventTypeStr = "Timeout1";
   1762c:	c7 85 dc fb ff ff d7 	movl   $0x60d7,0xfffffbdc(%ebp)
   17633:	60 00 00 
				    break;
   17636:	eb 3a                	jmp    17672 <trickles_cwnd_read_proc+0x1f8>
			    case USERBLOCKEVENT:
				    eventTypeStr = "UserBlock";
   17638:	c7 85 dc fb ff ff e0 	movl   $0x60e0,0xfffffbdc(%ebp)
   1763f:	60 00 00 
				    break;
   17642:	eb 2e                	jmp    17672 <trickles_cwnd_read_proc+0x1f8>
			    case USERUNBLOCKEVENT:
				    eventTypeStr = "UserUnblock";
   17644:	c7 85 dc fb ff ff ea 	movl   $0x60ea,0xfffffbdc(%ebp)
   1764b:	60 00 00 
				    break;
   1764e:	eb 22                	jmp    17672 <trickles_cwnd_read_proc+0x1f8>
			    case USERBADUNBLOCKEVENT:
				    eventTypeStr = "UserBadUnblock";
   17650:	c7 85 dc fb ff ff f6 	movl   $0x60f6,0xfffffbdc(%ebp)
   17657:	60 00 00 
				    break;
   1765a:	eb 16                	jmp    17672 <trickles_cwnd_read_proc+0x1f8>
			    case INSEQEVENT:
				    eventTypeStr = "InSeq";
   1765c:	c7 85 dc fb ff ff 05 	movl   $0x6105,0xfffffbdc(%ebp)
   17663:	61 00 00 
				    break;
   17666:	eb 0a                	jmp    17672 <trickles_cwnd_read_proc+0x1f8>
			    default:
				    eventTypeStr = "UNKNOWN";
   17668:	c7 85 dc fb ff ff 0b 	movl   $0x610b,0xfffffbdc(%ebp)
   1766f:	61 00 00 
			    }
			    sprintf(tempbuf, "%s:%d(%d-%d) = %d/%d/%d TCPBase: %d @ %d s %d us\n", eventTypeStr, logEntry->ack_seq,
   17672:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   17675:	8b 40 30             	mov    0x30(%eax),%eax
   17678:	89 44 24 2c          	mov    %eax,0x2c(%esp,1)
   1767c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1767f:	8b 40 2c             	mov    0x2c(%eax),%eax
   17682:	89 44 24 28          	mov    %eax,0x28(%esp,1)
   17686:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   17689:	8b 40 34             	mov    0x34(%eax),%eax
   1768c:	89 44 24 24          	mov    %eax,0x24(%esp,1)
   17690:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   17693:	8b 40 28             	mov    0x28(%eax),%eax
   17696:	89 44 24 20          	mov    %eax,0x20(%esp,1)
   1769a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1769d:	8b 40 24             	mov    0x24(%eax),%eax
   176a0:	89 44 24 1c          	mov    %eax,0x1c(%esp,1)
   176a4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   176a7:	8b 40 20             	mov    0x20(%eax),%eax
   176aa:	89 44 24 18          	mov    %eax,0x18(%esp,1)
   176ae:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   176b1:	8b 40 14             	mov    0x14(%eax),%eax
   176b4:	89 44 24 14          	mov    %eax,0x14(%esp,1)
   176b8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   176bb:	8b 40 10             	mov    0x10(%eax),%eax
   176be:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   176c2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   176c5:	8b 40 1c             	mov    0x1c(%eax),%eax
   176c8:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   176cc:	8b 85 dc fb ff ff    	mov    0xfffffbdc(%ebp),%eax
   176d2:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   176d6:	c7 44 24 04 20 61 00 	movl   $0x6120,0x4(%esp,1)
   176dd:	00 
   176de:	8d 85 ec fb ff ff    	lea    0xfffffbec(%ebp),%eax
   176e4:	89 04 24             	mov    %eax,(%esp,1)
   176e7:	e8 fc ff ff ff       	call   176e8 <trickles_cwnd_read_proc+0x26e>
				    logEntry->addr, logEntry->port,
				    logEntry->startCwnd, logEntry->effCwnd, logEntry->ssthresh,
				    logEntry->rtt,
				    logEntry->s, logEntry->us);

			    break;
   176ec:	eb 16                	jmp    17704 <trickles_cwnd_read_proc+0x28a>
		      }
		    default:
			    sprintf(tempbuf, "unknown record type\n");
   176ee:	c7 44 24 04 52 61 00 	movl   $0x6152,0x4(%esp,1)
   176f5:	00 
   176f6:	8d 85 ec fb ff ff    	lea    0xfffffbec(%ebp),%eax
   176fc:	89 04 24             	mov    %eax,(%esp,1)
   176ff:	e8 fc ff ff ff       	call   17700 <trickles_cwnd_read_proc+0x286>
		    }
		    // , logEntry->timestamp);
		    char *src = tempbuf + logEntry->sentAmount;
   17704:	8d 95 ec fb ff ff    	lea    0xfffffbec(%ebp),%edx
   1770a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1770d:	8b 48 3c             	mov    0x3c(%eax),%ecx
   17710:	8d 04 11             	lea    (%ecx,%edx,1),%eax
   17713:	89 85 dc fb ff ff    	mov    %eax,0xfffffbdc(%ebp)
		    real_wrlen = bb_write(&bb, src, wrlen = strlen(src));
   17719:	8b 85 dc fb ff ff    	mov    0xfffffbdc(%ebp),%eax
   1771f:	89 04 24             	mov    %eax,(%esp,1)
   17722:	e8 fe 25 00 00       	call   19d25 <strlen>
   17727:	89 85 e8 fb ff ff    	mov    %eax,0xfffffbe8(%ebp)
   1772d:	8b 85 e8 fb ff ff    	mov    0xfffffbe8(%ebp),%eax
   17733:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   17737:	8b 85 dc fb ff ff    	mov    0xfffffbdc(%ebp),%eax
   1773d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   17741:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   17744:	89 04 24             	mov    %eax,(%esp,1)
   17747:	e8 fc ff ff ff       	call   17748 <trickles_cwnd_read_proc+0x2ce>
   1774c:	89 85 e4 fb ff ff    	mov    %eax,0xfffffbe4(%ebp)
		    logEntry->sentAmount = real_wrlen;
   17752:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   17755:	8b 85 e4 fb ff ff    	mov    0xfffffbe4(%ebp),%eax
   1775b:	89 42 3c             	mov    %eax,0x3c(%edx)

		    if(real_wrlen < wrlen) {
   1775e:	8b 85 e4 fb ff ff    	mov    0xfffffbe4(%ebp),%eax
   17764:	3b 85 e8 fb ff ff    	cmp    0xfffffbe8(%ebp),%eax
   1776a:	7d 02                	jge    1776e <trickles_cwnd_read_proc+0x2f4>
			    break;
   1776c:	eb 49                	jmp    177b7 <trickles_cwnd_read_proc+0x33d>
		    }
		    if(real_wrlen == wrlen) {
   1776e:	8b 85 e4 fb ff ff    	mov    0xfffffbe4(%ebp),%eax
   17774:	3b 85 e8 fb ff ff    	cmp    0xfffffbe8(%ebp),%eax
   1777a:	75 2d                	jne    177a9 <trickles_cwnd_read_proc+0x32f>
			    struct TricklesCwndProcLogEntry *clean;
			    clean = logEntry;
   1777c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1777f:	89 85 e0 fb ff ff    	mov    %eax,0xfffffbe0(%ebp)
			    logEntry = (struct TricklesCwndProcLogEntry*)logEntry->prev;
   17785:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   17788:	8b 00                	mov    (%eax),%eax
   1778a:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
			    unlink((struct alloc_head*)clean);
   1778d:	8b 85 e0 fb ff ff    	mov    0xfffffbe0(%ebp),%eax
   17793:	89 04 24             	mov    %eax,(%esp,1)
   17796:	e8 b0 2e 00 00       	call   1a64b <unlink>
			    kfree(clean);
   1779b:	8b 85 e0 fb ff ff    	mov    0xfffffbe0(%ebp),%eax
   177a1:	89 04 24             	mov    %eax,(%esp,1)
   177a4:	e8 fc ff ff ff       	call   177a5 <trickles_cwnd_read_proc+0x32b>
   177a9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   177ac:	8b 40 04             	mov    0x4(%eax),%eax
   177af:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   177b2:	e9 f3 fc ff ff       	jmp    174aa <trickles_cwnd_read_proc+0x30>
		    }

	    }
    }
    if(empty(&tricklesCwndProcLogHead)) {
   177b7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   177be:	e8 58 2d 00 00       	call   1a51b <empty>
   177c3:	85 c0                	test   %eax,%eax
   177c5:	74 0b                	je     177d2 <trickles_cwnd_read_proc+0x358>
	    // done with all entries
	    //printk("eof\n");
	    *eof = 1;
   177c7:	8b 45 18             	mov    0x18(%ebp),%eax
   177ca:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
   177d0:	eb 09                	jmp    177db <trickles_cwnd_read_proc+0x361>
    } else {
	    *eof = 0;
   177d2:	8b 45 18             	mov    0x18(%ebp),%eax
   177d5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
#ifdef TRICKLES_CWND_READ_DISABLE_BH
    local_bh_enable();
   177db:	c7 85 dc fb ff ff 08 	movl   $0x8,0xfffffbdc(%ebp)
   177e2:	00 00 00 
   177e5:	8b 85 dc fb ff ff    	mov    0xfffffbdc(%ebp),%eax
   177eb:	ff 08                	decl   (%eax)
   177ed:	83 38 00             	cmpl   $0x0,(%eax)
   177f0:	75 10                	jne    17802 <trickles_cwnd_read_proc+0x388>
   177f2:	8b 85 dc fb ff ff    	mov    0xfffffbdc(%ebp),%eax
   177f8:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   177fc:	0f 85 7e 4a 00 00    	jne    1c280 <.text.lock.tmalloc+0x310>
#endif

    //printk("curpos = %d %d\n", bb.curPos, loop_count);

    *start = page;
   17802:	8b 55 0c             	mov    0xc(%ebp),%edx
   17805:	8b 45 08             	mov    0x8(%ebp),%eax
   17808:	89 02                	mov    %eax,(%edx)
    return bb.curPos;
   1780a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
}
   1780d:	c9                   	leave  
   1780e:	c3                   	ret    

0001780f <DeferralContext_init>:

#undef memcpy
#define memcpy __copy_to_user
#include "array.h"
#include "bounded_buffer.h"
#undef memcpy

#define PATCH_FROM_FIELD(TYPE,FIELD)		\
	{offset: OFFSET_OF(TYPE,FIELD),	\
	width: WIDTH_OF(TYPE,FIELD) }

struct patch_desc {
	int offset;
	int width;
};

#define IS_OUTPUT(DIR) (DIR == out)

#define GEN_COPY_PATCH_HMAC_UPDATE(DIR)					\
static inline void copy_patch_hmac_update_##DIR(struct HMAC_CTX *hmac_ctx, void *user_addr, void *kernel_addr, \
					  int len, void (*const generator)(const void *const context, int num, struct patch_desc *patch), \
					  const void *const gen_ctx, int numDescs) { \
	const int in=1, out=2;						\
	int i;								\
	int lastOffset = 0;						\
	if(IS_OUTPUT(DIR)) {						\
		for(i=0; i < numDescs; i++) {				\
			struct patch_desc patch;			\
			/* Generator generates descriptors in-sequence */ \
			generator(gen_ctx, i, &patch);			\
			if(patch.offset < lastOffset) {			\
				BUG();					\
			}						\
			int hmacStart = lastOffset;			\
			int hmacEnd = patch.offset;			\
			__copy_to_user(user_addr + hmacStart, kernel_addr + hmacStart, hmacEnd - hmacStart); \
			hmac_update(hmac_ctx, (char*)kernel_addr + hmacStart, hmacEnd - hmacStart); \
			int zero = 0;					\
			BUG_TRAP(patch.width <= sizeof(zero));		\
			__copy_to_user(user_addr + patch.offset, &zero, patch.width); \
			hmac_update(hmac_ctx, &zero, patch.width); \
			lastOffset = patch.offset + patch.width;	\
		}							\
	} else {							\
		__copy_from_user(kernel_addr, user_addr, len);		\
									\
		/* N.B. Input processing does not need to insert zeros */ \
		for(i=0; i < numDescs; i++) {				\
			int zero = 0;					\
			struct patch_desc patch;			\
			/* Generator generates descriptors in-sequence */ \
			generator(gen_ctx, i, &patch);			\
			if(patch.offset < lastOffset) {			\
				BUG();					\
			}						\
			BUG_TRAP(patch.offset + patch.width <= len);	\
			/* printk("checking @ %p ", user_addr + patch.offset); */ \
			BUG_TRAP(memcmp(kernel_addr + patch.offset, &zero, patch.width) == 0); \
			memset(kernel_addr + patch.offset, 0, patch.width); \
		}							\
	}								\
	/* Finish off hmac */						\
	BUG_TRAP(len >= lastOffset);					\
	__copy_to_user(user_addr + lastOffset, kernel_addr + lastOffset, len - lastOffset); \
	if(IS_OUTPUT(DIR)) {						\
		hmac_update(hmac_ctx, (char*)kernel_addr + lastOffset, len - lastOffset); \
	}								\
}

GEN_COPY_PATCH_HMAC_UPDATE(in);
GEN_COPY_PATCH_HMAC_UPDATE(out);

static inline void arrayPatchGenerator(const void * const context, int num, struct patch_desc *patch) {
	struct patch_desc *array = (struct patch_desc*) context;
	*patch = array[num];
}

static inline void packetPatchGenerator(const void * const context, int num, struct patch_desc *patch) {
	patch->offset = num * sizeof(struct cminisock_packet) +
		OFFSET_OF(struct cminisock_packet, ucontData);
	patch->width = WIDTH_OF(struct cminisock_packet, ucontData);
}

struct DeferralContext {
#define MAX_NUM_DEFERRALS_PER_CONTEXT (16)
	int numDeferrals;
	int data[MAX_NUM_DEFERRALS_PER_CONTEXT];
	struct DeferralContext *next;
};

void DeferralContext_init(struct DeferralContext *ctx) {
   1780f:	55                   	push   %ebp
   17810:	89 e5                	mov    %esp,%ebp
	ctx->numDeferrals = 0;
   17812:	8b 45 08             	mov    0x8(%ebp),%eax
   17815:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	ctx->next = NULL;
   1781b:	8b 45 08             	mov    0x8(%ebp),%eax
   1781e:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
   17825:	5d                   	pop    %ebp
   17826:	c3                   	ret    

00017827 <DeferralContext_free>:

void DeferralContext_free(struct DeferralContext *ctx) {
   17827:	55                   	push   %ebp
   17828:	89 e5                	mov    %esp,%ebp
   1782a:	83 ec 04             	sub    $0x4,%esp
	if(ctx->next != NULL) {
   1782d:	8b 45 08             	mov    0x8(%ebp),%eax
   17830:	83 78 44 00          	cmpl   $0x0,0x44(%eax)
   17834:	74 0e                	je     17844 <DeferralContext_free+0x1d>
		DeferralContext_free(ctx->next);
   17836:	8b 45 08             	mov    0x8(%ebp),%eax
   17839:	8b 40 44             	mov    0x44(%eax),%eax
   1783c:	89 04 24             	mov    %eax,(%esp,1)
   1783f:	e8 fc ff ff ff       	call   17840 <DeferralContext_free+0x19>
	}
	kfree(ctx);
   17844:	8b 45 08             	mov    0x8(%ebp),%eax
   17847:	89 04 24             	mov    %eax,(%esp,1)
   1784a:	e8 fc ff ff ff       	call   1784b <DeferralContext_free+0x24>
}
   1784f:	c9                   	leave  
   17850:	c3                   	ret    

00017851 <defer>:

int defer(struct DeferralContext *ctx, int value) {
   17851:	55                   	push   %ebp
   17852:	89 e5                	mov    %esp,%ebp
   17854:	53                   	push   %ebx
   17855:	83 ec 0c             	sub    $0xc,%esp
   17858:	90                   	nop    
	while(ctx->next != NULL) {
   17859:	8b 45 08             	mov    0x8(%ebp),%eax
   1785c:	83 78 44 00          	cmpl   $0x0,0x44(%eax)
   17860:	75 02                	jne    17864 <defer+0x13>
   17862:	eb 27                	jmp    1788b <defer+0x3a>
		BUG_TRAP(ctx->numDeferrals == MAX_NUM_DEFERRALS_PER_CONTEXT);
   17864:	8b 45 08             	mov    0x8(%ebp),%eax
   17867:	83 38 10             	cmpl   $0x10,(%eax)
   1786a:	74 14                	je     17880 <defer+0x2f>
   1786c:	c7 44 24 04 8a 09 00 	movl   $0x98a,0x4(%esp,1)
   17873:	00 
   17874:	c7 04 24 a0 61 00 00 	movl   $0x61a0,(%esp,1)
   1787b:	e8 fc ff ff ff       	call   1787c <defer+0x2b>
		ctx = ctx->next;
   17880:	8b 45 08             	mov    0x8(%ebp),%eax
   17883:	8b 40 44             	mov    0x44(%eax),%eax
   17886:	89 45 08             	mov    %eax,0x8(%ebp)
   17889:	eb ce                	jmp    17859 <defer+0x8>
	}
	if(ctx->numDeferrals == MAX_NUM_DEFERRALS_PER_CONTEXT) {
   1788b:	8b 45 08             	mov    0x8(%ebp),%eax
   1788e:	83 38 10             	cmpl   $0x10,(%eax)
   17891:	75 41                	jne    178d4 <defer+0x83>
		ctx->next = kmalloc(sizeof(struct DeferralContext), GFP_KERNEL);
   17893:	8b 5d 08             	mov    0x8(%ebp),%ebx
   17896:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
   1789d:	00 
   1789e:	c7 04 24 48 00 00 00 	movl   $0x48,(%esp,1)
   178a5:	e8 fc ff ff ff       	call   178a6 <defer+0x55>
   178aa:	89 43 44             	mov    %eax,0x44(%ebx)
		if(ctx->next == NULL) {
   178ad:	8b 45 08             	mov    0x8(%ebp),%eax
   178b0:	83 78 44 00          	cmpl   $0x0,0x44(%eax)
   178b4:	75 15                	jne    178cb <defer+0x7a>
			printk("Out of memory while allocating deferral spillb lock\n");
   178b6:	c7 04 24 20 62 00 00 	movl   $0x6220,(%esp,1)
   178bd:	e8 fc ff ff ff       	call   178be <defer+0x6d>
			return -1;
   178c2:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,0xfffffff8(%ebp)
   178c9:	eb 23                	jmp    178ee <defer+0x9d>
		}
		ctx = ctx->next;
   178cb:	8b 45 08             	mov    0x8(%ebp),%eax
   178ce:	8b 40 44             	mov    0x44(%eax),%eax
   178d1:	89 45 08             	mov    %eax,0x8(%ebp)
	}
	ctx->data[ctx->numDeferrals++] = value;
   178d4:	8b 5d 08             	mov    0x8(%ebp),%ebx
   178d7:	8b 55 08             	mov    0x8(%ebp),%edx
   178da:	8b 02                	mov    (%edx),%eax
   178dc:	89 c1                	mov    %eax,%ecx
   178de:	8b 45 0c             	mov    0xc(%ebp),%eax
   178e1:	89 44 8b 04          	mov    %eax,0x4(%ebx,%ecx,4)
   178e5:	ff 02                	incl   (%edx)
	return 0;
   178e7:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
}
   178ee:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   178f1:	83 c4 0c             	add    $0xc,%esp
   178f4:	5b                   	pop    %ebx
   178f5:	5d                   	pop    %ebp
   178f6:	c3                   	ret    

000178f7 <apply_deferrals>:

// Apply deferrals updates the HMAC with actual pointer information
void apply_deferrals(struct HMAC_CTX *hmac_ctx, struct DeferralContext *deferral_ctx) {
   178f7:	55                   	push   %ebp
   178f8:	89 e5                	mov    %esp,%ebp
   178fa:	83 ec 08             	sub    $0x8,%esp
	BUG();
   178fd:	c7 44 24 04 59 53 00 	movl   $0x5359,0x4(%esp,1)
   17904:	00 
   17905:	c7 04 24 5d 53 00 00 	movl   $0x535d,(%esp,1)
   1790c:	e8 fc ff ff ff       	call   1790d <apply_deferrals+0x16>
   17911:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   17918:	e8 fc ff ff ff       	call   17919 <apply_deferrals+0x22>
   1791d:	e8 fc ff ff ff       	call   1791e <apply_deferrals+0x27>
#if 0
	int first = 1;
	while(deferral_ctx != NULL) {
		hmac_update(hmac_ctx, (char *) &deferral_ctx->data[0],
			    deferral_ctx->numDeferrals * sizeof(deferral_ctx->data[0]));

		struct DeferralContext *toFree = deferral_ctx;
		deferral_ctx = deferral_ctx->next;
		if(!first) {
			kfree(toFree);
		}
		first = 0;
	}
#endif
}
   17922:	c9                   	leave  
   17923:	c3                   	ret    

00017924 <convertMSK_in>:

// Support functions

// yes, this is a hack to avoid allocating on output instance
void *(* const tmalloc_helperout)(struct sock *sk, int len) = NULL;
void *(* const kmalloc_helperout)(struct sock *sk, int len) = NULL;

static inline void *tmalloc_helperin(struct sock *sk, int len) {
	printk("tmalloc_helperin'ing %d\n", len);
	return tmalloc(sk, len);
}

static inline void *kmalloc_helperin(struct sock *sk, int len) {
	//printk("kmalloc'ing %d\n", len);
	return kmalloc(len, GFP_KERNEL);
}

#define DEFERRED_HMAC(VALUE)						\
	do { if(defer(&deferral_ctx, (VALUE)) != 0) goto convert_error; } while(0)

#define RESERVE_COPY_PATCH_HMAC(DIR, ALLOC_FUNC, 	MSKTHINGO, LEN, DESC, DESCCTX, DESCLEN, PATCH_TYPE, PATCH_FIELD) \
	({								\
		if((LEN) == 0) {					\
			/* Do nothing */				\
		} else {						\
			int _len = (LEN);				\
			char *_dest_name = "user_" #MSKTHINGO;		\
			void *_tempdest = lbb_reserve(lbb, _len);	\
			if(_tempdest == NULL) {				\
				printk("result overflow - %s\n", _dest_name); \
				err = LBB_ERROR;			\
				goto convert_error;			\
			}						\
			if(ALLOC_FUNC ## DIR != NULL) {			\
				void *alloc_ptr = ALLOC_FUNC ## DIR(sk, LEN); \
				if(alloc_ptr == NULL) {			\
					printk("Out of memory ("#ALLOC_FUNC # DIR ") during copy_patch_hmac\n"); \
					err = LBB_ERROR;		\
					goto convert_error;		\
				}					\
				/* printk(#MSKTHINGO "("#ALLOC_FUNC # DIR ")  = %p\n", alloc_ptr);*/ \
				MSKTHINGO = alloc_ptr;			\
			}						\
			copy_patch_hmac_update_##DIR(hmac_ctx, _tempdest, (MSKTHINGO), \
						     _len, DESC, DESCCTX, DESCLEN); \
			if(IS_OUTPUT(DIR)) __put_user((char*)_tempdest - currStart, &((PATCH_TYPE*)_tempdest)->PATCH_FIELD); \
			/* DEFERRED_HMAC((char*)_tempdest - currStart); */ \
		}							\
	})

#ifdef DEBUG_LENGTHS
#define DUMP_DESCLEN() do { printk("desclen[%d] = %d\n", desclen_num++, desc_len - prevDescLen); prevDescLen = desc_len; } while(0)
#define DUMP_DELTA()				\
	do { printk("Delta[%d] = %d\n", deltaNum++, lbb_get_offset(lbb) - prevDeltaLen); prevDeltaLen = lbb_get_offset(lbb);} while(0)
#else

#define DUMP_DESCLEN()
#define DUMP_DELTA()

#endif

#define DELAY(X) do { int i; int j; volatile int counter = 0; for(i=0; i < (X); i++) for(j=0;j<100000000;j++) counter++; } while(0)

#define LBB_ERROR (-1)
#define MSK_ERROR (-2)
#define GEN_CONVERTMSK(DIR)						\
static ALWAYS_INLINE int convertMSK_##DIR(struct sock *sk, struct HMAC_CTX *hmac_ctx, struct cminisock *msk, struct linear_bounded_buffer *lbb, int *count) { \
	const int in = 1, out = 2;					\
	int i, err = 0;							\
	/* int prevDeltaLen = 0, deltaNum = 0, prevDescLen = 0, desclen_num = 0; */ \
	int startLen = lbb_get_offset(lbb);				\
	struct DeferralContext deferral_ctx;				\
	DeferralContext_init(&deferral_ctx);				\
									\
	/* Precompute length */						\
	int desc_len = -1;							\
	if(IS_OUTPUT(DIR)) {						\
		/* printk("output, precomputing desc_len\n"); */	\
		desc_len = sizeof(struct extract_mskdesc_out);		\
		DUMP_DESCLEN();						\
		desc_len += msk->ucont_len;				\
		DUMP_DESCLEN();						\
		desc_len += msk->input_len;				\
		DUMP_DESCLEN();						\
		desc_len += msk->num_packets * sizeof(struct cminisock_packet);	\
		DUMP_DESCLEN();						\
		for(i=0; i < msk->num_packets; i++) {			\
			desc_len += msk->packets[i].ucontLen;		\
		DUMP_DESCLEN();						\
		}							\
	}								\
									\
	/* Shared - reserve space for descriptor length */		\
	int *len = (int*)lbb_reserve(lbb, sizeof(int));		\
	char *currStart = (char*)len;					\
	struct cminisock *user_msk = (struct cminisock *)		\
		lbb_reserve(lbb, sizeof(*msk));			\
	if(currStart == NULL || user_msk == NULL) {			\
		printk(#DIR ": Result overflow on currStart or output_msk\n");	\
		err = LBB_ERROR;					\
		goto convert_error;					\
	}								\
	if(IS_OUTPUT(DIR)) {						\
		__put_user(desc_len, len);				\
		hmac_update(hmac_ctx, &desc_len, sizeof(desc_len)); \
		/* printk("output, inserting desc_len %d @ (%d,%p)\n", desc_len, lbb_get_pos(lbb), len); */  \
	} else {							\
		__get_user(desc_len, len);				\
		/* printk("input, extracting desc_len %d @ (%p,%d)\n", desc_len, lbb_get_pos(lbb), len); */ /* DELAY(1); */ \
	}								\
									\
	const struct patch_desc const mskPatchArray[] = {			\
		PATCH_FROM_FIELD(struct cminisock, sk),		\
		PATCH_FROM_FIELD(struct cminisock, ucont_data),		\
		PATCH_FROM_FIELD(struct cminisock, input),		\
		PATCH_FROM_FIELD(struct cminisock, packets)		\
	};								\
	DUMP_DELTA();								\
	copy_patch_hmac_update_##DIR(hmac_ctx, user_msk, msk, sizeof(*msk),  \
				     arrayPatchGenerator, mskPatchArray, ARRAY_LEN(mskPatchArray)); \
									\
	/* Copy ucont_data */						\
	RESERVE_COPY_PATCH_HMAC(DIR, tmalloc_helper, msk->ucont_data, \
				msk->ucont_len,				\
				NULL, NULL, 0,				\
				struct cminisock, ucont_data);		\
									\
	DUMP_DELTA();						\
	/* Copy input */						\
	RESERVE_COPY_PATCH_HMAC(DIR, tmalloc_helper, msk->input, \
				msk->input_len,				\
				NULL, NULL, 0,				\
				struct cminisock, input);		\
									\
	DUMP_DELTA();						\
	/* copy packets */						\
	int packets_len = msk->num_packets * sizeof(struct cminisock_packet); \
	RESERVE_COPY_PATCH_HMAC(DIR, tmalloc_helper, msk->packets, \
				packets_len, \
				packetPatchGenerator, NULL,		\
				msk->num_packets,			\
				struct cminisock, packets);		\
	DUMP_DELTA();						\
	/* Copy packets[*]->ucontData */				\
	for(i=0; i < msk->num_packets; i++) {				\
		RESERVE_COPY_PATCH_HMAC(DIR, kmalloc_helper, msk->packets[i].ucontData, \
					msk->packets[i].ucontLen,	\
					NULL, NULL, 0,			\
					struct cminisock_packet, ucontData); \
	DUMP_DELTA();						\
	}								\
									\
	if(IS_OUTPUT(DIR)) {						\
		/* FINALIZE */						\
		int check_len = lbb_get_offset(lbb) - startLen;			\
		if(!(desc_len == check_len)) { BUG_TRAP(desc_len == check_len); printk("%d %d\n", desc_len, check_len); } \
		__put_user(check_len, len);				\
	} else {							\
		int actual_len = lbb_get_offset(lbb) - startLen;			\
		int desc_len1;						\
		__get_user(desc_len1, len); BUG_TRAP(desc_len1 == desc_len); \
		if(!(desc_len == actual_len)) { BUG_TRAP(desc_len == actual_len); printk("%d %d\n", desc_len, actual_len); } \
	}								\
									\
	/* Apply deferrals -- Deferrals are not needed yet */			\
	/* apply_deferrals(hmac_ctx, &deferral_ctx); */			\
	(*count)++;							\
	if(0) { /* don't execute this code block except during exceptions */ \
	convert_error:							\
		if(deferral_ctx.next != NULL)				\
			DeferralContext_free(deferral_ctx.next);	\
		return -EINVAL;						\
	}								\
	return 0;							\
}

GEN_CONVERTMSK(in);
   17924:	55                   	push   %ebp
   17925:	89 e5                	mov    %esp,%ebp
   17927:	53                   	push   %ebx
   17928:	81 ec cc 00 00 00    	sub    $0xcc,%esp
   1792e:	c7 45 f8 01 00 00 00 	movl   $0x1,0xfffffff8(%ebp)
   17935:	c7 45 f4 02 00 00 00 	movl   $0x2,0xfffffff4(%ebp)
   1793c:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
   17943:	8b 45 14             	mov    0x14(%ebp),%eax
   17946:	89 04 24             	mov    %eax,(%esp,1)
   17949:	e8 14 3b 00 00       	call   1b462 <lbb_get_offset>
   1794e:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   17951:	8d 45 98             	lea    0xffffff98(%ebp),%eax
   17954:	89 04 24             	mov    %eax,(%esp,1)
   17957:	e8 fc ff ff ff       	call   17958 <convertMSK_in+0x34>
   1795c:	c7 45 94 ff ff ff ff 	movl   $0xffffffff,0xffffff94(%ebp)
   17963:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   17966:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
   17969:	75 7d                	jne    179e8 <convertMSK_in+0xc4>
   1796b:	c7 45 94 00 01 00 00 	movl   $0x100,0xffffff94(%ebp)
   17972:	8b 45 10             	mov    0x10(%ebp),%eax
   17975:	8b 50 78             	mov    0x78(%eax),%edx
   17978:	8d 45 94             	lea    0xffffff94(%ebp),%eax
   1797b:	01 10                	add    %edx,(%eax)
   1797d:	8b 45 10             	mov    0x10(%ebp),%eax
   17980:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
   17986:	8d 45 94             	lea    0xffffff94(%ebp),%eax
   17989:	01 10                	add    %edx,(%eax)
   1798b:	8b 45 10             	mov    0x10(%ebp),%eax
   1798e:	8b 90 e8 00 00 00    	mov    0xe8(%eax),%edx
   17994:	89 d0                	mov    %edx,%eax
   17996:	c1 e0 03             	shl    $0x3,%eax
   17999:	01 d0                	add    %edx,%eax
   1799b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   179a2:	8d 45 94             	lea    0xffffff94(%ebp),%eax
   179a5:	01 10                	add    %edx,(%eax)
   179a7:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
   179ae:	8b 55 10             	mov    0x10(%ebp),%edx
   179b1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   179b4:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
   179ba:	7c 02                	jl     179be <convertMSK_in+0x9a>
   179bc:	eb 2a                	jmp    179e8 <convertMSK_in+0xc4>
   179be:	8b 4d 10             	mov    0x10(%ebp),%ecx
   179c1:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   179c4:	89 d0                	mov    %edx,%eax
   179c6:	c1 e0 03             	shl    $0x3,%eax
   179c9:	01 d0                	add    %edx,%eax
   179cb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   179d2:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   179d8:	8b 54 10 10          	mov    0x10(%eax,%edx,1),%edx
   179dc:	8d 45 94             	lea    0xffffff94(%ebp),%eax
   179df:	01 10                	add    %edx,(%eax)
   179e1:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   179e4:	ff 00                	incl   (%eax)
   179e6:	eb c6                	jmp    179ae <convertMSK_in+0x8a>
   179e8:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp,1)
   179ef:	00 
   179f0:	8b 45 14             	mov    0x14(%ebp),%eax
   179f3:	89 04 24             	mov    %eax,(%esp,1)
   179f6:	e8 84 3a 00 00       	call   1b47f <lbb_reserve>
   179fb:	89 45 90             	mov    %eax,0xffffff90(%ebp)
   179fe:	8b 45 90             	mov    0xffffff90(%ebp),%eax
   17a01:	89 45 8c             	mov    %eax,0xffffff8c(%ebp)
   17a04:	c7 44 24 04 fc 00 00 	movl   $0xfc,0x4(%esp,1)
   17a0b:	00 
   17a0c:	8b 45 14             	mov    0x14(%ebp),%eax
   17a0f:	89 04 24             	mov    %eax,(%esp,1)
   17a12:	e8 68 3a 00 00       	call   1b47f <lbb_reserve>
   17a17:	89 45 88             	mov    %eax,0xffffff88(%ebp)
   17a1a:	83 7d 8c 00          	cmpl   $0x0,0xffffff8c(%ebp)
   17a1e:	74 06                	je     17a26 <convertMSK_in+0x102>
   17a20:	83 7d 88 00          	cmpl   $0x0,0xffffff88(%ebp)
   17a24:	75 18                	jne    17a3e <convertMSK_in+0x11a>
   17a26:	c7 04 24 60 62 00 00 	movl   $0x6260,(%esp,1)
   17a2d:	e8 fc ff ff ff       	call   17a2e <convertMSK_in+0x10a>
   17a32:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
   17a39:	e9 6a 07 00 00       	jmp    181a8 <convertMSK_in+0x884>
   17a3e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   17a41:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
   17a44:	75 31                	jne    17a77 <convertMSK_in+0x153>
   17a46:	c7 45 84 00 00 00 00 	movl   $0x0,0xffffff84(%ebp)
   17a4d:	8b 4d 94             	mov    0xffffff94(%ebp),%ecx
   17a50:	8b 55 90             	mov    0xffffff90(%ebp),%edx
   17a53:	8b 45 84             	mov    0xffffff84(%ebp),%eax
   17a56:	89 0a                	mov    %ecx,(%edx)
   17a58:	89 45 84             	mov    %eax,0xffffff84(%ebp)
   17a5b:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp,1)
   17a62:	00 
   17a63:	8d 45 94             	lea    0xffffff94(%ebp),%eax
   17a66:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   17a6a:	8b 45 0c             	mov    0xc(%ebp),%eax
   17a6d:	89 04 24             	mov    %eax,(%esp,1)
   17a70:	e8 fc ff ff ff       	call   17a71 <convertMSK_in+0x14d>
   17a75:	eb 1d                	jmp    17a94 <convertMSK_in+0x170>
   17a77:	c7 45 84 00 00 00 00 	movl   $0x0,0xffffff84(%ebp)
   17a7e:	8b 55 90             	mov    0xffffff90(%ebp),%edx
   17a81:	8b 45 84             	mov    0xffffff84(%ebp),%eax
   17a84:	8b 12                	mov    (%edx),%edx
   17a86:	89 45 84             	mov    %eax,0xffffff84(%ebp)
   17a89:	89 d0                	mov    %edx,%eax
   17a8b:	89 45 80             	mov    %eax,0xffffff80(%ebp)
   17a8e:	8b 45 80             	mov    0xffffff80(%ebp),%eax
   17a91:	89 45 94             	mov    %eax,0xffffff94(%ebp)
   17a94:	c7 85 60 ff ff ff 20 	movl   $0x20,0xffffff60(%ebp)
   17a9b:	00 00 00 
   17a9e:	c7 85 64 ff ff ff 04 	movl   $0x4,0xffffff64(%ebp)
   17aa5:	00 00 00 
   17aa8:	c7 85 68 ff ff ff 7c 	movl   $0x7c,0xffffff68(%ebp)
   17aaf:	00 00 00 
   17ab2:	c7 85 6c ff ff ff 04 	movl   $0x4,0xffffff6c(%ebp)
   17ab9:	00 00 00 
   17abc:	c7 85 70 ff ff ff 98 	movl   $0x98,0xffffff70(%ebp)
   17ac3:	00 00 00 
   17ac6:	c7 85 74 ff ff ff 04 	movl   $0x4,0xffffff74(%ebp)
   17acd:	00 00 00 
   17ad0:	c7 85 78 ff ff ff ec 	movl   $0xec,0xffffff78(%ebp)
   17ad7:	00 00 00 
   17ada:	c7 85 7c ff ff ff 04 	movl   $0x4,0xffffff7c(%ebp)
   17ae1:	00 00 00 
   17ae4:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp,1)
   17aeb:	00 
   17aec:	8d 85 60 ff ff ff    	lea    0xffffff60(%ebp),%eax
   17af2:	89 44 24 14          	mov    %eax,0x14(%esp,1)
   17af6:	c7 44 24 10 12 b9 01 	movl   $0x1b912,0x10(%esp,1)
   17afd:	00 
   17afe:	c7 44 24 0c fc 00 00 	movl   $0xfc,0xc(%esp,1)
   17b05:	00 
   17b06:	8b 45 10             	mov    0x10(%ebp),%eax
   17b09:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   17b0d:	8b 45 88             	mov    0xffffff88(%ebp),%eax
   17b10:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   17b14:	8b 45 0c             	mov    0xc(%ebp),%eax
   17b17:	89 04 24             	mov    %eax,(%esp,1)
   17b1a:	e8 a8 39 00 00       	call   1b4c7 <copy_patch_hmac_update_in>
   17b1f:	8b 45 10             	mov    0x10(%ebp),%eax
   17b22:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
   17b26:	75 05                	jne    17b2d <convertMSK_in+0x209>
   17b28:	e9 15 01 00 00       	jmp    17c42 <convertMSK_in+0x31e>
   17b2d:	8b 45 10             	mov    0x10(%ebp),%eax
   17b30:	8b 40 78             	mov    0x78(%eax),%eax
   17b33:	89 45 80             	mov    %eax,0xffffff80(%ebp)
   17b36:	c7 45 84 90 62 00 00 	movl   $0x6290,0xffffff84(%ebp)
   17b3d:	8b 45 80             	mov    0xffffff80(%ebp),%eax
   17b40:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   17b44:	8b 45 14             	mov    0x14(%ebp),%eax
   17b47:	89 04 24             	mov    %eax,(%esp,1)
   17b4a:	e8 30 39 00 00       	call   1b47f <lbb_reserve>
   17b4f:	89 85 5c ff ff ff    	mov    %eax,0xffffff5c(%ebp)
   17b55:	83 bd 5c ff ff ff 00 	cmpl   $0x0,0xffffff5c(%ebp)
   17b5c:	75 1f                	jne    17b7d <convertMSK_in+0x259>
   17b5e:	8b 45 84             	mov    0xffffff84(%ebp),%eax
   17b61:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   17b65:	c7 04 24 a5 62 00 00 	movl   $0x62a5,(%esp,1)
   17b6c:	e8 fc ff ff ff       	call   17b6d <convertMSK_in+0x249>
   17b71:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
   17b78:	e9 2b 06 00 00       	jmp    181a8 <convertMSK_in+0x884>
   17b7d:	b8 61 b9 01 00       	mov    $0x1b961,%eax
   17b82:	85 c0                	test   %eax,%eax
   17b84:	74 48                	je     17bce <convertMSK_in+0x2aa>
   17b86:	8b 45 10             	mov    0x10(%ebp),%eax
   17b89:	8b 40 78             	mov    0x78(%eax),%eax
   17b8c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   17b90:	8b 45 08             	mov    0x8(%ebp),%eax
   17b93:	89 04 24             	mov    %eax,(%esp,1)
   17b96:	e8 c6 3d 00 00       	call   1b961 <tmalloc_helperin>
   17b9b:	89 85 58 ff ff ff    	mov    %eax,0xffffff58(%ebp)
   17ba1:	83 bd 58 ff ff ff 00 	cmpl   $0x0,0xffffff58(%ebp)
   17ba8:	75 18                	jne    17bc2 <convertMSK_in+0x29e>
   17baa:	c7 04 24 c0 62 00 00 	movl   $0x62c0,(%esp,1)
   17bb1:	e8 fc ff ff ff       	call   17bb2 <convertMSK_in+0x28e>
   17bb6:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
   17bbd:	e9 e6 05 00 00       	jmp    181a8 <convertMSK_in+0x884>
   17bc2:	8b 55 10             	mov    0x10(%ebp),%edx
   17bc5:	8b 85 58 ff ff ff    	mov    0xffffff58(%ebp),%eax
   17bcb:	89 42 7c             	mov    %eax,0x7c(%edx)
   17bce:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp,1)
   17bd5:	00 
   17bd6:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp,1)
   17bdd:	00 
   17bde:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp,1)
   17be5:	00 
   17be6:	8b 45 80             	mov    0xffffff80(%ebp),%eax
   17be9:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   17bed:	8b 45 10             	mov    0x10(%ebp),%eax
   17bf0:	8b 40 7c             	mov    0x7c(%eax),%eax
   17bf3:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   17bf7:	8b 85 5c ff ff ff    	mov    0xffffff5c(%ebp),%eax
   17bfd:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   17c01:	8b 45 0c             	mov    0xc(%ebp),%eax
   17c04:	89 04 24             	mov    %eax,(%esp,1)
   17c07:	e8 bb 38 00 00       	call   1b4c7 <copy_patch_hmac_update_in>
   17c0c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   17c0f:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
   17c12:	75 2e                	jne    17c42 <convertMSK_in+0x31e>
   17c14:	c7 85 54 ff ff ff 00 	movl   $0x0,0xffffff54(%ebp)
   17c1b:	00 00 00 
   17c1e:	8b 55 8c             	mov    0xffffff8c(%ebp),%edx
   17c21:	8b 85 5c ff ff ff    	mov    0xffffff5c(%ebp),%eax
   17c27:	89 c1                	mov    %eax,%ecx
   17c29:	29 d1                	sub    %edx,%ecx
   17c2b:	8b 95 5c ff ff ff    	mov    0xffffff5c(%ebp),%edx
   17c31:	83 c2 7c             	add    $0x7c,%edx
   17c34:	8b 85 54 ff ff ff    	mov    0xffffff54(%ebp),%eax
   17c3a:	89 0a                	mov    %ecx,(%edx)
   17c3c:	89 85 54 ff ff ff    	mov    %eax,0xffffff54(%ebp)
   17c42:	8b 45 10             	mov    0x10(%ebp),%eax
   17c45:	83 b8 94 00 00 00 00 	cmpl   $0x0,0x94(%eax)
   17c4c:	75 05                	jne    17c53 <convertMSK_in+0x32f>
   17c4e:	e9 21 01 00 00       	jmp    17d74 <convertMSK_in+0x450>
   17c53:	8b 45 10             	mov    0x10(%ebp),%eax
   17c56:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   17c5c:	89 85 54 ff ff ff    	mov    %eax,0xffffff54(%ebp)
   17c62:	c7 85 58 ff ff ff f9 	movl   $0x62f9,0xffffff58(%ebp)
   17c69:	62 00 00 
   17c6c:	8b 85 54 ff ff ff    	mov    0xffffff54(%ebp),%eax
   17c72:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   17c76:	8b 45 14             	mov    0x14(%ebp),%eax
   17c79:	89 04 24             	mov    %eax,(%esp,1)
   17c7c:	e8 fe 37 00 00       	call   1b47f <lbb_reserve>
   17c81:	89 85 5c ff ff ff    	mov    %eax,0xffffff5c(%ebp)
   17c87:	83 bd 5c ff ff ff 00 	cmpl   $0x0,0xffffff5c(%ebp)
   17c8e:	75 22                	jne    17cb2 <convertMSK_in+0x38e>
   17c90:	8b 85 58 ff ff ff    	mov    0xffffff58(%ebp),%eax
   17c96:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   17c9a:	c7 04 24 a5 62 00 00 	movl   $0x62a5,(%esp,1)
   17ca1:	e8 fc ff ff ff       	call   17ca2 <convertMSK_in+0x37e>
   17ca6:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
   17cad:	e9 f6 04 00 00       	jmp    181a8 <convertMSK_in+0x884>
   17cb2:	b8 61 b9 01 00       	mov    $0x1b961,%eax
   17cb7:	85 c0                	test   %eax,%eax
   17cb9:	74 45                	je     17d00 <convertMSK_in+0x3dc>
   17cbb:	8b 45 10             	mov    0x10(%ebp),%eax
   17cbe:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   17cc4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   17cc8:	8b 45 08             	mov    0x8(%ebp),%eax
   17ccb:	89 04 24             	mov    %eax,(%esp,1)
   17cce:	e8 8e 3c 00 00       	call   1b961 <tmalloc_helperin>
   17cd3:	89 45 80             	mov    %eax,0xffffff80(%ebp)
   17cd6:	83 7d 80 00          	cmpl   $0x0,0xffffff80(%ebp)
   17cda:	75 18                	jne    17cf4 <convertMSK_in+0x3d0>
   17cdc:	c7 04 24 c0 62 00 00 	movl   $0x62c0,(%esp,1)
   17ce3:	e8 fc ff ff ff       	call   17ce4 <convertMSK_in+0x3c0>
   17ce8:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
   17cef:	e9 b4 04 00 00       	jmp    181a8 <convertMSK_in+0x884>
   17cf4:	8b 55 10             	mov    0x10(%ebp),%edx
   17cf7:	8b 45 80             	mov    0xffffff80(%ebp),%eax
   17cfa:	89 82 98 00 00 00    	mov    %eax,0x98(%edx)
   17d00:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp,1)
   17d07:	00 
   17d08:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp,1)
   17d0f:	00 
   17d10:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp,1)
   17d17:	00 
   17d18:	8b 85 54 ff ff ff    	mov    0xffffff54(%ebp),%eax
   17d1e:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   17d22:	8b 45 10             	mov    0x10(%ebp),%eax
   17d25:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   17d2b:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   17d2f:	8b 85 5c ff ff ff    	mov    0xffffff5c(%ebp),%eax
   17d35:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   17d39:	8b 45 0c             	mov    0xc(%ebp),%eax
   17d3c:	89 04 24             	mov    %eax,(%esp,1)
   17d3f:	e8 83 37 00 00       	call   1b4c7 <copy_patch_hmac_update_in>
   17d44:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   17d47:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
   17d4a:	75 28                	jne    17d74 <convertMSK_in+0x450>
   17d4c:	c7 45 84 00 00 00 00 	movl   $0x0,0xffffff84(%ebp)
   17d53:	8b 55 8c             	mov    0xffffff8c(%ebp),%edx
   17d56:	8b 85 5c ff ff ff    	mov    0xffffff5c(%ebp),%eax
   17d5c:	89 c1                	mov    %eax,%ecx
   17d5e:	29 d1                	sub    %edx,%ecx
   17d60:	8b 95 5c ff ff ff    	mov    0xffffff5c(%ebp),%edx
   17d66:	81 c2 98 00 00 00    	add    $0x98,%edx
   17d6c:	8b 45 84             	mov    0xffffff84(%ebp),%eax
   17d6f:	89 0a                	mov    %ecx,(%edx)
   17d71:	89 45 84             	mov    %eax,0xffffff84(%ebp)
   17d74:	8b 45 10             	mov    0x10(%ebp),%eax
   17d77:	8b 90 e8 00 00 00    	mov    0xe8(%eax),%edx
   17d7d:	89 d0                	mov    %edx,%eax
   17d7f:	c1 e0 03             	shl    $0x3,%eax
   17d82:	01 d0                	add    %edx,%eax
   17d84:	c1 e0 02             	shl    $0x2,%eax
   17d87:	89 85 54 ff ff ff    	mov    %eax,0xffffff54(%ebp)
   17d8d:	83 bd 54 ff ff ff 00 	cmpl   $0x0,0xffffff54(%ebp)
   17d94:	75 05                	jne    17d9b <convertMSK_in+0x477>
   17d96:	e9 1a 01 00 00       	jmp    17eb5 <convertMSK_in+0x591>
   17d9b:	8b 85 54 ff ff ff    	mov    0xffffff54(%ebp),%eax
   17da1:	89 85 58 ff ff ff    	mov    %eax,0xffffff58(%ebp)
   17da7:	c7 85 5c ff ff ff 09 	movl   $0x6309,0xffffff5c(%ebp)
   17dae:	63 00 00 
   17db1:	8b 85 58 ff ff ff    	mov    0xffffff58(%ebp),%eax
   17db7:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   17dbb:	8b 45 14             	mov    0x14(%ebp),%eax
   17dbe:	89 04 24             	mov    %eax,(%esp,1)
   17dc1:	e8 b9 36 00 00       	call   1b47f <lbb_reserve>
   17dc6:	89 45 80             	mov    %eax,0xffffff80(%ebp)
   17dc9:	83 7d 80 00          	cmpl   $0x0,0xffffff80(%ebp)
   17dcd:	75 22                	jne    17df1 <convertMSK_in+0x4cd>
   17dcf:	8b 85 5c ff ff ff    	mov    0xffffff5c(%ebp),%eax
   17dd5:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   17dd9:	c7 04 24 a5 62 00 00 	movl   $0x62a5,(%esp,1)
   17de0:	e8 fc ff ff ff       	call   17de1 <convertMSK_in+0x4bd>
   17de5:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
   17dec:	e9 b7 03 00 00       	jmp    181a8 <convertMSK_in+0x884>
   17df1:	b8 61 b9 01 00       	mov    $0x1b961,%eax
   17df6:	85 c0                	test   %eax,%eax
   17df8:	74 42                	je     17e3c <convertMSK_in+0x518>
   17dfa:	8b 85 54 ff ff ff    	mov    0xffffff54(%ebp),%eax
   17e00:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   17e04:	8b 45 08             	mov    0x8(%ebp),%eax
   17e07:	89 04 24             	mov    %eax,(%esp,1)
   17e0a:	e8 52 3b 00 00       	call   1b961 <tmalloc_helperin>
   17e0f:	89 45 84             	mov    %eax,0xffffff84(%ebp)
   17e12:	83 7d 84 00          	cmpl   $0x0,0xffffff84(%ebp)
   17e16:	75 18                	jne    17e30 <convertMSK_in+0x50c>
   17e18:	c7 04 24 c0 62 00 00 	movl   $0x62c0,(%esp,1)
   17e1f:	e8 fc ff ff ff       	call   17e20 <convertMSK_in+0x4fc>
   17e24:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
   17e2b:	e9 78 03 00 00       	jmp    181a8 <convertMSK_in+0x884>
   17e30:	8b 55 10             	mov    0x10(%ebp),%edx
   17e33:	8b 45 84             	mov    0xffffff84(%ebp),%eax
   17e36:	89 82 ec 00 00 00    	mov    %eax,0xec(%edx)
   17e3c:	8b 45 10             	mov    0x10(%ebp),%eax
   17e3f:	8b 80 e8 00 00 00    	mov    0xe8(%eax),%eax
   17e45:	89 44 24 18          	mov    %eax,0x18(%esp,1)
   17e49:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp,1)
   17e50:	00 
   17e51:	c7 44 24 10 3d b9 01 	movl   $0x1b93d,0x10(%esp,1)
   17e58:	00 
   17e59:	8b 85 58 ff ff ff    	mov    0xffffff58(%ebp),%eax
   17e5f:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   17e63:	8b 45 10             	mov    0x10(%ebp),%eax
   17e66:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
   17e6c:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   17e70:	8b 45 80             	mov    0xffffff80(%ebp),%eax
   17e73:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   17e77:	8b 45 0c             	mov    0xc(%ebp),%eax
   17e7a:	89 04 24             	mov    %eax,(%esp,1)
   17e7d:	e8 45 36 00 00       	call   1b4c7 <copy_patch_hmac_update_in>
   17e82:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   17e85:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
   17e88:	75 2b                	jne    17eb5 <convertMSK_in+0x591>
   17e8a:	c7 85 50 ff ff ff 00 	movl   $0x0,0xffffff50(%ebp)
   17e91:	00 00 00 
   17e94:	8b 55 8c             	mov    0xffffff8c(%ebp),%edx
   17e97:	8b 45 80             	mov    0xffffff80(%ebp),%eax
   17e9a:	89 c1                	mov    %eax,%ecx
   17e9c:	29 d1                	sub    %edx,%ecx
   17e9e:	8b 55 80             	mov    0xffffff80(%ebp),%edx
   17ea1:	81 c2 ec 00 00 00    	add    $0xec,%edx
   17ea7:	8b 85 50 ff ff ff    	mov    0xffffff50(%ebp),%eax
   17ead:	89 0a                	mov    %ecx,(%edx)
   17eaf:	89 85 50 ff ff ff    	mov    %eax,0xffffff50(%ebp)
   17eb5:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
   17ebc:	8b 55 10             	mov    0x10(%ebp),%edx
   17ebf:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   17ec2:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
   17ec8:	7c 05                	jl     17ecf <convertMSK_in+0x5ab>
   17eca:	e9 a2 01 00 00       	jmp    18071 <convertMSK_in+0x74d>
   17ecf:	8b 4d 10             	mov    0x10(%ebp),%ecx
   17ed2:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   17ed5:	89 d0                	mov    %edx,%eax
   17ed7:	c1 e0 03             	shl    $0x3,%eax
   17eda:	01 d0                	add    %edx,%eax
   17edc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   17ee3:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   17ee9:	83 7c 10 10 00       	cmpl   $0x0,0x10(%eax,%edx,1)
   17eee:	75 05                	jne    17ef5 <convertMSK_in+0x5d1>
   17ef0:	e9 72 01 00 00       	jmp    18067 <convertMSK_in+0x743>
   17ef5:	8b 4d 10             	mov    0x10(%ebp),%ecx
   17ef8:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   17efb:	89 d0                	mov    %edx,%eax
   17efd:	c1 e0 03             	shl    $0x3,%eax
   17f00:	01 d0                	add    %edx,%eax
   17f02:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   17f09:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   17f0f:	8b 44 10 10          	mov    0x10(%eax,%edx,1),%eax
   17f13:	89 85 50 ff ff ff    	mov    %eax,0xffffff50(%ebp)
   17f19:	c7 85 58 ff ff ff 20 	movl   $0x6320,0xffffff58(%ebp)
   17f20:	63 00 00 
   17f23:	8b 85 50 ff ff ff    	mov    0xffffff50(%ebp),%eax
   17f29:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   17f2d:	8b 45 14             	mov    0x14(%ebp),%eax
   17f30:	89 04 24             	mov    %eax,(%esp,1)
   17f33:	e8 47 35 00 00       	call   1b47f <lbb_reserve>
   17f38:	89 85 5c ff ff ff    	mov    %eax,0xffffff5c(%ebp)
   17f3e:	83 bd 5c ff ff ff 00 	cmpl   $0x0,0xffffff5c(%ebp)
   17f45:	75 22                	jne    17f69 <convertMSK_in+0x645>
   17f47:	8b 85 58 ff ff ff    	mov    0xffffff58(%ebp),%eax
   17f4d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   17f51:	c7 04 24 a5 62 00 00 	movl   $0x62a5,(%esp,1)
   17f58:	e8 fc ff ff ff       	call   17f59 <convertMSK_in+0x635>
   17f5d:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
   17f64:	e9 3f 02 00 00       	jmp    181a8 <convertMSK_in+0x884>
   17f69:	b8 8e b9 01 00       	mov    $0x1b98e,%eax
   17f6e:	85 c0                	test   %eax,%eax
   17f70:	74 6f                	je     17fe1 <convertMSK_in+0x6bd>
   17f72:	8b 4d 10             	mov    0x10(%ebp),%ecx
   17f75:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   17f78:	89 d0                	mov    %edx,%eax
   17f7a:	c1 e0 03             	shl    $0x3,%eax
   17f7d:	01 d0                	add    %edx,%eax
   17f7f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   17f86:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   17f8c:	8b 44 10 10          	mov    0x10(%eax,%edx,1),%eax
   17f90:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   17f94:	8b 45 08             	mov    0x8(%ebp),%eax
   17f97:	89 04 24             	mov    %eax,(%esp,1)
   17f9a:	e8 ef 39 00 00       	call   1b98e <kmalloc_helperin>
   17f9f:	89 45 80             	mov    %eax,0xffffff80(%ebp)
   17fa2:	83 7d 80 00          	cmpl   $0x0,0xffffff80(%ebp)
   17fa6:	75 18                	jne    17fc0 <convertMSK_in+0x69c>
   17fa8:	c7 04 24 40 63 00 00 	movl   $0x6340,(%esp,1)
   17faf:	e8 fc ff ff ff       	call   17fb0 <convertMSK_in+0x68c>
   17fb4:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
   17fbb:	e9 e8 01 00 00       	jmp    181a8 <convertMSK_in+0x884>
   17fc0:	8b 5d 10             	mov    0x10(%ebp),%ebx
   17fc3:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   17fc6:	89 d0                	mov    %edx,%eax
   17fc8:	c1 e0 03             	shl    $0x3,%eax
   17fcb:	01 d0                	add    %edx,%eax
   17fcd:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   17fd4:	8b 93 ec 00 00 00    	mov    0xec(%ebx),%edx
   17fda:	8b 45 80             	mov    0xffffff80(%ebp),%eax
   17fdd:	89 44 0a 14          	mov    %eax,0x14(%edx,%ecx,1)
   17fe1:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp,1)
   17fe8:	00 
   17fe9:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp,1)
   17ff0:	00 
   17ff1:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp,1)
   17ff8:	00 
   17ff9:	8b 85 50 ff ff ff    	mov    0xffffff50(%ebp),%eax
   17fff:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   18003:	8b 4d 10             	mov    0x10(%ebp),%ecx
   18006:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   18009:	89 d0                	mov    %edx,%eax
   1800b:	c1 e0 03             	shl    $0x3,%eax
   1800e:	01 d0                	add    %edx,%eax
   18010:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   18017:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   1801d:	8b 44 10 14          	mov    0x14(%eax,%edx,1),%eax
   18021:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   18025:	8b 85 5c ff ff ff    	mov    0xffffff5c(%ebp),%eax
   1802b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1802f:	8b 45 0c             	mov    0xc(%ebp),%eax
   18032:	89 04 24             	mov    %eax,(%esp,1)
   18035:	e8 8d 34 00 00       	call   1b4c7 <copy_patch_hmac_update_in>
   1803a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1803d:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
   18040:	75 25                	jne    18067 <convertMSK_in+0x743>
   18042:	c7 45 84 00 00 00 00 	movl   $0x0,0xffffff84(%ebp)
   18049:	8b 55 8c             	mov    0xffffff8c(%ebp),%edx
   1804c:	8b 85 5c ff ff ff    	mov    0xffffff5c(%ebp),%eax
   18052:	89 c1                	mov    %eax,%ecx
   18054:	29 d1                	sub    %edx,%ecx
   18056:	8b 95 5c ff ff ff    	mov    0xffffff5c(%ebp),%edx
   1805c:	83 c2 14             	add    $0x14,%edx
   1805f:	8b 45 84             	mov    0xffffff84(%ebp),%eax
   18062:	89 0a                	mov    %ecx,(%edx)
   18064:	89 45 84             	mov    %eax,0xffffff84(%ebp)
   18067:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   1806a:	ff 00                	incl   (%eax)
   1806c:	e9 4b fe ff ff       	jmp    17ebc <convertMSK_in+0x598>
   18071:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   18074:	3b 45 f4             	cmp    0xfffffff4(%ebp),%eax
   18077:	0f 85 81 00 00 00    	jne    180fe <convertMSK_in+0x7da>
   1807d:	8b 45 14             	mov    0x14(%ebp),%eax
   18080:	89 04 24             	mov    %eax,(%esp,1)
   18083:	e8 da 33 00 00       	call   1b462 <lbb_get_offset>
   18088:	2b 45 e8             	sub    0xffffffe8(%ebp),%eax
   1808b:	89 85 50 ff ff ff    	mov    %eax,0xffffff50(%ebp)
   18091:	8b 45 94             	mov    0xffffff94(%ebp),%eax
   18094:	3b 85 50 ff ff ff    	cmp    0xffffff50(%ebp),%eax
   1809a:	74 3c                	je     180d8 <convertMSK_in+0x7b4>
   1809c:	8b 45 94             	mov    0xffffff94(%ebp),%eax
   1809f:	3b 85 50 ff ff ff    	cmp    0xffffff50(%ebp),%eax
   180a5:	74 14                	je     180bb <convertMSK_in+0x797>
   180a7:	c7 44 24 04 5b 0a 00 	movl   $0xa5b,0x4(%esp,1)
   180ae:	00 
   180af:	c7 04 24 80 63 00 00 	movl   $0x6380,(%esp,1)
   180b6:	e8 fc ff ff ff       	call   180b7 <convertMSK_in+0x793>
   180bb:	8b 85 50 ff ff ff    	mov    0xffffff50(%ebp),%eax
   180c1:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   180c5:	8b 45 94             	mov    0xffffff94(%ebp),%eax
   180c8:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   180cc:	c7 04 24 cc 63 00 00 	movl   $0x63cc,(%esp,1)
   180d3:	e8 fc ff ff ff       	call   180d4 <convertMSK_in+0x7b0>
   180d8:	c7 85 58 ff ff ff 00 	movl   $0x0,0xffffff58(%ebp)
   180df:	00 00 00 
   180e2:	8b 8d 50 ff ff ff    	mov    0xffffff50(%ebp),%ecx
   180e8:	8b 55 90             	mov    0xffffff90(%ebp),%edx
   180eb:	8b 85 58 ff ff ff    	mov    0xffffff58(%ebp),%eax
   180f1:	89 0a                	mov    %ecx,(%edx)
   180f3:	89 85 58 ff ff ff    	mov    %eax,0xffffff58(%ebp)
   180f9:	e9 a3 00 00 00       	jmp    181a1 <convertMSK_in+0x87d>
   180fe:	8b 45 14             	mov    0x14(%ebp),%eax
   18101:	89 04 24             	mov    %eax,(%esp,1)
   18104:	e8 59 33 00 00       	call   1b462 <lbb_get_offset>
   18109:	2b 45 e8             	sub    0xffffffe8(%ebp),%eax
   1810c:	89 85 50 ff ff ff    	mov    %eax,0xffffff50(%ebp)
   18112:	c7 85 5c ff ff ff 00 	movl   $0x0,0xffffff5c(%ebp)
   18119:	00 00 00 
   1811c:	8b 55 90             	mov    0xffffff90(%ebp),%edx
   1811f:	8b 85 5c ff ff ff    	mov    0xffffff5c(%ebp),%eax
   18125:	8b 12                	mov    (%edx),%edx
   18127:	89 85 5c ff ff ff    	mov    %eax,0xffffff5c(%ebp)
   1812d:	89 d0                	mov    %edx,%eax
   1812f:	89 45 80             	mov    %eax,0xffffff80(%ebp)
   18132:	8b 45 80             	mov    0xffffff80(%ebp),%eax
   18135:	89 85 58 ff ff ff    	mov    %eax,0xffffff58(%ebp)
   1813b:	8b 85 58 ff ff ff    	mov    0xffffff58(%ebp),%eax
   18141:	3b 45 94             	cmp    0xffffff94(%ebp),%eax
   18144:	74 14                	je     1815a <convertMSK_in+0x836>
   18146:	c7 44 24 04 5b 0a 00 	movl   $0xa5b,0x4(%esp,1)
   1814d:	00 
   1814e:	c7 04 24 e0 63 00 00 	movl   $0x63e0,(%esp,1)
   18155:	e8 fc ff ff ff       	call   18156 <convertMSK_in+0x832>
   1815a:	8b 45 94             	mov    0xffffff94(%ebp),%eax
   1815d:	3b 85 50 ff ff ff    	cmp    0xffffff50(%ebp),%eax
   18163:	74 3c                	je     181a1 <convertMSK_in+0x87d>
   18165:	8b 45 94             	mov    0xffffff94(%ebp),%eax
   18168:	3b 85 50 ff ff ff    	cmp    0xffffff50(%ebp),%eax
   1816e:	74 14                	je     18184 <convertMSK_in+0x860>
   18170:	c7 44 24 04 5b 0a 00 	movl   $0xa5b,0x4(%esp,1)
   18177:	00 
   18178:	c7 04 24 40 64 00 00 	movl   $0x6440,(%esp,1)
   1817f:	e8 fc ff ff ff       	call   18180 <convertMSK_in+0x85c>
   18184:	8b 85 50 ff ff ff    	mov    0xffffff50(%ebp),%eax
   1818a:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1818e:	8b 45 94             	mov    0xffffff94(%ebp),%eax
   18191:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   18195:	c7 04 24 cc 63 00 00 	movl   $0x63cc,(%esp,1)
   1819c:	e8 fc ff ff ff       	call   1819d <convertMSK_in+0x879>
   181a1:	8b 45 18             	mov    0x18(%ebp),%eax
   181a4:	ff 00                	incl   (%eax)
   181a6:	eb 1d                	jmp    181c5 <convertMSK_in+0x8a1>
   181a8:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
   181ac:	74 0b                	je     181b9 <convertMSK_in+0x895>
   181ae:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   181b1:	89 04 24             	mov    %eax,(%esp,1)
   181b4:	e8 fc ff ff ff       	call   181b5 <convertMSK_in+0x891>
   181b9:	c7 85 4c ff ff ff ea 	movl   $0xffffffea,0xffffff4c(%ebp)
   181c0:	ff ff ff 
   181c3:	eb 0a                	jmp    181cf <convertMSK_in+0x8ab>
   181c5:	c7 85 4c ff ff ff 00 	movl   $0x0,0xffffff4c(%ebp)
   181cc:	00 00 00 
   181cf:	8b 85 4c ff ff ff    	mov    0xffffff4c(%ebp),%eax
   181d5:	81 c4 cc 00 00 00    	add    $0xcc,%esp
   181db:	5b                   	pop    %ebx
   181dc:	5d                   	pop    %ebp
   181dd:	c3                   	ret    

000181de <convertMSK_out>:
GEN_CONVERTMSK(out);
   181de:	55                   	push   %ebp
   181df:	89 e5                	mov    %esp,%ebp
   181e1:	53                   	push   %ebx
   181e2:	81 ec cc 00 00 00    	sub    $0xcc,%esp
   181e8:	c7 45 f8 01 00 00 00 	movl   $0x1,0xfffffff8(%ebp)
   181ef:	c7 45 f4 02 00 00 00 	movl   $0x2,0xfffffff4(%ebp)
   181f6:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
   181fd:	8b 45 14             	mov    0x14(%ebp),%eax
   18200:	89 04 24             	mov    %eax,(%esp,1)
   18203:	e8 5a 32 00 00       	call   1b462 <lbb_get_offset>
   18208:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1820b:	8d 45 98             	lea    0xffffff98(%ebp),%eax
   1820e:	89 04 24             	mov    %eax,(%esp,1)
   18211:	e8 fc ff ff ff       	call   18212 <convertMSK_out+0x34>
   18216:	c7 45 94 ff ff ff ff 	movl   $0xffffffff,0xffffff94(%ebp)
   1821d:	c7 45 94 00 01 00 00 	movl   $0x100,0xffffff94(%ebp)
   18224:	8b 45 10             	mov    0x10(%ebp),%eax
   18227:	8b 50 78             	mov    0x78(%eax),%edx
   1822a:	8d 45 94             	lea    0xffffff94(%ebp),%eax
   1822d:	01 10                	add    %edx,(%eax)
   1822f:	8b 45 10             	mov    0x10(%ebp),%eax
   18232:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
   18238:	8d 45 94             	lea    0xffffff94(%ebp),%eax
   1823b:	01 10                	add    %edx,(%eax)
   1823d:	8b 45 10             	mov    0x10(%ebp),%eax
   18240:	8b 90 e8 00 00 00    	mov    0xe8(%eax),%edx
   18246:	89 d0                	mov    %edx,%eax
   18248:	c1 e0 03             	shl    $0x3,%eax
   1824b:	01 d0                	add    %edx,%eax
   1824d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   18254:	8d 45 94             	lea    0xffffff94(%ebp),%eax
   18257:	01 10                	add    %edx,(%eax)
   18259:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
   18260:	8b 55 10             	mov    0x10(%ebp),%edx
   18263:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   18266:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
   1826c:	7c 02                	jl     18270 <convertMSK_out+0x92>
   1826e:	eb 2a                	jmp    1829a <convertMSK_out+0xbc>
   18270:	8b 4d 10             	mov    0x10(%ebp),%ecx
   18273:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   18276:	89 d0                	mov    %edx,%eax
   18278:	c1 e0 03             	shl    $0x3,%eax
   1827b:	01 d0                	add    %edx,%eax
   1827d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   18284:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   1828a:	8b 54 10 10          	mov    0x10(%eax,%edx,1),%edx
   1828e:	8d 45 94             	lea    0xffffff94(%ebp),%eax
   18291:	01 10                	add    %edx,(%eax)
   18293:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   18296:	ff 00                	incl   (%eax)
   18298:	eb c6                	jmp    18260 <convertMSK_out+0x82>
   1829a:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp,1)
   182a1:	00 
   182a2:	8b 45 14             	mov    0x14(%ebp),%eax
   182a5:	89 04 24             	mov    %eax,(%esp,1)
   182a8:	e8 d2 31 00 00       	call   1b47f <lbb_reserve>
   182ad:	89 45 90             	mov    %eax,0xffffff90(%ebp)
   182b0:	8b 45 90             	mov    0xffffff90(%ebp),%eax
   182b3:	89 45 8c             	mov    %eax,0xffffff8c(%ebp)
   182b6:	c7 44 24 04 fc 00 00 	movl   $0xfc,0x4(%esp,1)
   182bd:	00 
   182be:	8b 45 14             	mov    0x14(%ebp),%eax
   182c1:	89 04 24             	mov    %eax,(%esp,1)
   182c4:	e8 b6 31 00 00       	call   1b47f <lbb_reserve>
   182c9:	89 45 88             	mov    %eax,0xffffff88(%ebp)
   182cc:	83 7d 8c 00          	cmpl   $0x0,0xffffff8c(%ebp)
   182d0:	74 06                	je     182d8 <convertMSK_out+0xfa>
   182d2:	83 7d 88 00          	cmpl   $0x0,0xffffff88(%ebp)
   182d6:	75 18                	jne    182f0 <convertMSK_out+0x112>
   182d8:	c7 04 24 a0 64 00 00 	movl   $0x64a0,(%esp,1)
   182df:	e8 fc ff ff ff       	call   182e0 <convertMSK_out+0x102>
   182e4:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
   182eb:	e9 77 06 00 00       	jmp    18967 <convertMSK_out+0x789>
   182f0:	c7 45 84 00 00 00 00 	movl   $0x0,0xffffff84(%ebp)
   182f7:	8b 4d 94             	mov    0xffffff94(%ebp),%ecx
   182fa:	8b 55 90             	mov    0xffffff90(%ebp),%edx
   182fd:	8b 45 84             	mov    0xffffff84(%ebp),%eax
   18300:	89 0a                	mov    %ecx,(%edx)
   18302:	89 45 84             	mov    %eax,0xffffff84(%ebp)
   18305:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp,1)
   1830c:	00 
   1830d:	8d 45 94             	lea    0xffffff94(%ebp),%eax
   18310:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   18314:	8b 45 0c             	mov    0xc(%ebp),%eax
   18317:	89 04 24             	mov    %eax,(%esp,1)
   1831a:	e8 fc ff ff ff       	call   1831b <convertMSK_out+0x13d>
   1831f:	c7 85 60 ff ff ff 20 	movl   $0x20,0xffffff60(%ebp)
   18326:	00 00 00 
   18329:	c7 85 64 ff ff ff 04 	movl   $0x4,0xffffff64(%ebp)
   18330:	00 00 00 
   18333:	c7 85 68 ff ff ff 7c 	movl   $0x7c,0xffffff68(%ebp)
   1833a:	00 00 00 
   1833d:	c7 85 6c ff ff ff 04 	movl   $0x4,0xffffff6c(%ebp)
   18344:	00 00 00 
   18347:	c7 85 70 ff ff ff 98 	movl   $0x98,0xffffff70(%ebp)
   1834e:	00 00 00 
   18351:	c7 85 74 ff ff ff 04 	movl   $0x4,0xffffff74(%ebp)
   18358:	00 00 00 
   1835b:	c7 85 78 ff ff ff ec 	movl   $0xec,0xffffff78(%ebp)
   18362:	00 00 00 
   18365:	c7 85 7c ff ff ff 04 	movl   $0x4,0xffffff7c(%ebp)
   1836c:	00 00 00 
   1836f:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp,1)
   18376:	00 
   18377:	8d 85 60 ff ff ff    	lea    0xffffff60(%ebp),%eax
   1837d:	89 44 24 14          	mov    %eax,0x14(%esp,1)
   18381:	c7 44 24 10 12 b9 01 	movl   $0x1b912,0x10(%esp,1)
   18388:	00 
   18389:	c7 44 24 0c fc 00 00 	movl   $0xfc,0xc(%esp,1)
   18390:	00 
   18391:	8b 45 10             	mov    0x10(%ebp),%eax
   18394:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   18398:	8b 45 88             	mov    0xffffff88(%ebp),%eax
   1839b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1839f:	8b 45 0c             	mov    0xc(%ebp),%eax
   183a2:	89 04 24             	mov    %eax,(%esp,1)
   183a5:	e8 d6 33 00 00       	call   1b780 <copy_patch_hmac_update_out>
   183aa:	8b 45 10             	mov    0x10(%ebp),%eax
   183ad:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
   183b1:	75 05                	jne    183b8 <convertMSK_out+0x1da>
   183b3:	e9 0f 01 00 00       	jmp    184c7 <convertMSK_out+0x2e9>
   183b8:	8b 45 10             	mov    0x10(%ebp),%eax
   183bb:	8b 40 78             	mov    0x78(%eax),%eax
   183be:	89 45 80             	mov    %eax,0xffffff80(%ebp)
   183c1:	c7 45 84 90 62 00 00 	movl   $0x6290,0xffffff84(%ebp)
   183c8:	8b 45 80             	mov    0xffffff80(%ebp),%eax
   183cb:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   183cf:	8b 45 14             	mov    0x14(%ebp),%eax
   183d2:	89 04 24             	mov    %eax,(%esp,1)
   183d5:	e8 a5 30 00 00       	call   1b47f <lbb_reserve>
   183da:	89 85 5c ff ff ff    	mov    %eax,0xffffff5c(%ebp)
   183e0:	83 bd 5c ff ff ff 00 	cmpl   $0x0,0xffffff5c(%ebp)
   183e7:	75 1f                	jne    18408 <convertMSK_out+0x22a>
   183e9:	8b 45 84             	mov    0xffffff84(%ebp),%eax
   183ec:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   183f0:	c7 04 24 a5 62 00 00 	movl   $0x62a5,(%esp,1)
   183f7:	e8 fc ff ff ff       	call   183f8 <convertMSK_out+0x21a>
   183fc:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
   18403:	e9 5f 05 00 00       	jmp    18967 <convertMSK_out+0x789>
   18408:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
   1840f:	74 4a                	je     1845b <convertMSK_out+0x27d>
   18411:	8b 45 10             	mov    0x10(%ebp),%eax
   18414:	8b 40 78             	mov    0x78(%eax),%eax
   18417:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1841b:	8b 45 08             	mov    0x8(%ebp),%eax
   1841e:	89 04 24             	mov    %eax,(%esp,1)
   18421:	a1 00 00 00 00       	mov    0x0,%eax
   18426:	ff d0                	call   *%eax
   18428:	89 85 58 ff ff ff    	mov    %eax,0xffffff58(%ebp)
   1842e:	83 bd 58 ff ff ff 00 	cmpl   $0x0,0xffffff58(%ebp)
   18435:	75 18                	jne    1844f <convertMSK_out+0x271>
   18437:	c7 04 24 e0 64 00 00 	movl   $0x64e0,(%esp,1)
   1843e:	e8 fc ff ff ff       	call   1843f <convertMSK_out+0x261>
   18443:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
   1844a:	e9 18 05 00 00       	jmp    18967 <convertMSK_out+0x789>
   1844f:	8b 55 10             	mov    0x10(%ebp),%edx
   18452:	8b 85 58 ff ff ff    	mov    0xffffff58(%ebp),%eax
   18458:	89 42 7c             	mov    %eax,0x7c(%edx)
   1845b:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp,1)
   18462:	00 
   18463:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp,1)
   1846a:	00 
   1846b:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp,1)
   18472:	00 
   18473:	8b 45 80             	mov    0xffffff80(%ebp),%eax
   18476:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   1847a:	8b 45 10             	mov    0x10(%ebp),%eax
   1847d:	8b 40 7c             	mov    0x7c(%eax),%eax
   18480:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   18484:	8b 85 5c ff ff ff    	mov    0xffffff5c(%ebp),%eax
   1848a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1848e:	8b 45 0c             	mov    0xc(%ebp),%eax
   18491:	89 04 24             	mov    %eax,(%esp,1)
   18494:	e8 e7 32 00 00       	call   1b780 <copy_patch_hmac_update_out>
   18499:	c7 85 54 ff ff ff 00 	movl   $0x0,0xffffff54(%ebp)
   184a0:	00 00 00 
   184a3:	8b 55 8c             	mov    0xffffff8c(%ebp),%edx
   184a6:	8b 85 5c ff ff ff    	mov    0xffffff5c(%ebp),%eax
   184ac:	89 c1                	mov    %eax,%ecx
   184ae:	29 d1                	sub    %edx,%ecx
   184b0:	8b 95 5c ff ff ff    	mov    0xffffff5c(%ebp),%edx
   184b6:	83 c2 7c             	add    $0x7c,%edx
   184b9:	8b 85 54 ff ff ff    	mov    0xffffff54(%ebp),%eax
   184bf:	89 0a                	mov    %ecx,(%edx)
   184c1:	89 85 54 ff ff ff    	mov    %eax,0xffffff54(%ebp)
   184c7:	8b 45 10             	mov    0x10(%ebp),%eax
   184ca:	83 b8 94 00 00 00 00 	cmpl   $0x0,0x94(%eax)
   184d1:	75 05                	jne    184d8 <convertMSK_out+0x2fa>
   184d3:	e9 1b 01 00 00       	jmp    185f3 <convertMSK_out+0x415>
   184d8:	8b 45 10             	mov    0x10(%ebp),%eax
   184db:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   184e1:	89 85 54 ff ff ff    	mov    %eax,0xffffff54(%ebp)
   184e7:	c7 85 58 ff ff ff f9 	movl   $0x62f9,0xffffff58(%ebp)
   184ee:	62 00 00 
   184f1:	8b 85 54 ff ff ff    	mov    0xffffff54(%ebp),%eax
   184f7:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   184fb:	8b 45 14             	mov    0x14(%ebp),%eax
   184fe:	89 04 24             	mov    %eax,(%esp,1)
   18501:	e8 79 2f 00 00       	call   1b47f <lbb_reserve>
   18506:	89 85 5c ff ff ff    	mov    %eax,0xffffff5c(%ebp)
   1850c:	83 bd 5c ff ff ff 00 	cmpl   $0x0,0xffffff5c(%ebp)
   18513:	75 22                	jne    18537 <convertMSK_out+0x359>
   18515:	8b 85 58 ff ff ff    	mov    0xffffff58(%ebp),%eax
   1851b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1851f:	c7 04 24 a5 62 00 00 	movl   $0x62a5,(%esp,1)
   18526:	e8 fc ff ff ff       	call   18527 <convertMSK_out+0x349>
   1852b:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
   18532:	e9 30 04 00 00       	jmp    18967 <convertMSK_out+0x789>
   18537:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
   1853e:	74 47                	je     18587 <convertMSK_out+0x3a9>
   18540:	8b 45 10             	mov    0x10(%ebp),%eax
   18543:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   18549:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1854d:	8b 45 08             	mov    0x8(%ebp),%eax
   18550:	89 04 24             	mov    %eax,(%esp,1)
   18553:	a1 00 00 00 00       	mov    0x0,%eax
   18558:	ff d0                	call   *%eax
   1855a:	89 45 80             	mov    %eax,0xffffff80(%ebp)
   1855d:	83 7d 80 00          	cmpl   $0x0,0xffffff80(%ebp)
   18561:	75 18                	jne    1857b <convertMSK_out+0x39d>
   18563:	c7 04 24 e0 64 00 00 	movl   $0x64e0,(%esp,1)
   1856a:	e8 fc ff ff ff       	call   1856b <convertMSK_out+0x38d>
   1856f:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
   18576:	e9 ec 03 00 00       	jmp    18967 <convertMSK_out+0x789>
   1857b:	8b 55 10             	mov    0x10(%ebp),%edx
   1857e:	8b 45 80             	mov    0xffffff80(%ebp),%eax
   18581:	89 82 98 00 00 00    	mov    %eax,0x98(%edx)
   18587:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp,1)
   1858e:	00 
   1858f:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp,1)
   18596:	00 
   18597:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp,1)
   1859e:	00 
   1859f:	8b 85 54 ff ff ff    	mov    0xffffff54(%ebp),%eax
   185a5:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   185a9:	8b 45 10             	mov    0x10(%ebp),%eax
   185ac:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   185b2:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   185b6:	8b 85 5c ff ff ff    	mov    0xffffff5c(%ebp),%eax
   185bc:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   185c0:	8b 45 0c             	mov    0xc(%ebp),%eax
   185c3:	89 04 24             	mov    %eax,(%esp,1)
   185c6:	e8 b5 31 00 00       	call   1b780 <copy_patch_hmac_update_out>
   185cb:	c7 45 84 00 00 00 00 	movl   $0x0,0xffffff84(%ebp)
   185d2:	8b 55 8c             	mov    0xffffff8c(%ebp),%edx
   185d5:	8b 85 5c ff ff ff    	mov    0xffffff5c(%ebp),%eax
   185db:	89 c1                	mov    %eax,%ecx
   185dd:	29 d1                	sub    %edx,%ecx
   185df:	8b 95 5c ff ff ff    	mov    0xffffff5c(%ebp),%edx
   185e5:	81 c2 98 00 00 00    	add    $0x98,%edx
   185eb:	8b 45 84             	mov    0xffffff84(%ebp),%eax
   185ee:	89 0a                	mov    %ecx,(%edx)
   185f0:	89 45 84             	mov    %eax,0xffffff84(%ebp)
   185f3:	8b 45 10             	mov    0x10(%ebp),%eax
   185f6:	8b 90 e8 00 00 00    	mov    0xe8(%eax),%edx
   185fc:	89 d0                	mov    %edx,%eax
   185fe:	c1 e0 03             	shl    $0x3,%eax
   18601:	01 d0                	add    %edx,%eax
   18603:	c1 e0 02             	shl    $0x2,%eax
   18606:	89 85 54 ff ff ff    	mov    %eax,0xffffff54(%ebp)
   1860c:	83 bd 54 ff ff ff 00 	cmpl   $0x0,0xffffff54(%ebp)
   18613:	75 05                	jne    1861a <convertMSK_out+0x43c>
   18615:	e9 14 01 00 00       	jmp    1872e <convertMSK_out+0x550>
   1861a:	8b 85 54 ff ff ff    	mov    0xffffff54(%ebp),%eax
   18620:	89 85 58 ff ff ff    	mov    %eax,0xffffff58(%ebp)
   18626:	c7 85 5c ff ff ff 09 	movl   $0x6309,0xffffff5c(%ebp)
   1862d:	63 00 00 
   18630:	8b 85 58 ff ff ff    	mov    0xffffff58(%ebp),%eax
   18636:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1863a:	8b 45 14             	mov    0x14(%ebp),%eax
   1863d:	89 04 24             	mov    %eax,(%esp,1)
   18640:	e8 3a 2e 00 00       	call   1b47f <lbb_reserve>
   18645:	89 45 80             	mov    %eax,0xffffff80(%ebp)
   18648:	83 7d 80 00          	cmpl   $0x0,0xffffff80(%ebp)
   1864c:	75 22                	jne    18670 <convertMSK_out+0x492>
   1864e:	8b 85 5c ff ff ff    	mov    0xffffff5c(%ebp),%eax
   18654:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   18658:	c7 04 24 a5 62 00 00 	movl   $0x62a5,(%esp,1)
   1865f:	e8 fc ff ff ff       	call   18660 <convertMSK_out+0x482>
   18664:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
   1866b:	e9 f7 02 00 00       	jmp    18967 <convertMSK_out+0x789>
   18670:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
   18677:	74 44                	je     186bd <convertMSK_out+0x4df>
   18679:	8b 85 54 ff ff ff    	mov    0xffffff54(%ebp),%eax
   1867f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   18683:	8b 45 08             	mov    0x8(%ebp),%eax
   18686:	89 04 24             	mov    %eax,(%esp,1)
   18689:	a1 00 00 00 00       	mov    0x0,%eax
   1868e:	ff d0                	call   *%eax
   18690:	89 45 84             	mov    %eax,0xffffff84(%ebp)
   18693:	83 7d 84 00          	cmpl   $0x0,0xffffff84(%ebp)
   18697:	75 18                	jne    186b1 <convertMSK_out+0x4d3>
   18699:	c7 04 24 e0 64 00 00 	movl   $0x64e0,(%esp,1)
   186a0:	e8 fc ff ff ff       	call   186a1 <convertMSK_out+0x4c3>
   186a5:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
   186ac:	e9 b6 02 00 00       	jmp    18967 <convertMSK_out+0x789>
   186b1:	8b 55 10             	mov    0x10(%ebp),%edx
   186b4:	8b 45 84             	mov    0xffffff84(%ebp),%eax
   186b7:	89 82 ec 00 00 00    	mov    %eax,0xec(%edx)
   186bd:	8b 45 10             	mov    0x10(%ebp),%eax
   186c0:	8b 80 e8 00 00 00    	mov    0xe8(%eax),%eax
   186c6:	89 44 24 18          	mov    %eax,0x18(%esp,1)
   186ca:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp,1)
   186d1:	00 
   186d2:	c7 44 24 10 3d b9 01 	movl   $0x1b93d,0x10(%esp,1)
   186d9:	00 
   186da:	8b 85 58 ff ff ff    	mov    0xffffff58(%ebp),%eax
   186e0:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   186e4:	8b 45 10             	mov    0x10(%ebp),%eax
   186e7:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
   186ed:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   186f1:	8b 45 80             	mov    0xffffff80(%ebp),%eax
   186f4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   186f8:	8b 45 0c             	mov    0xc(%ebp),%eax
   186fb:	89 04 24             	mov    %eax,(%esp,1)
   186fe:	e8 7d 30 00 00       	call   1b780 <copy_patch_hmac_update_out>
   18703:	c7 85 50 ff ff ff 00 	movl   $0x0,0xffffff50(%ebp)
   1870a:	00 00 00 
   1870d:	8b 55 8c             	mov    0xffffff8c(%ebp),%edx
   18710:	8b 45 80             	mov    0xffffff80(%ebp),%eax
   18713:	89 c1                	mov    %eax,%ecx
   18715:	29 d1                	sub    %edx,%ecx
   18717:	8b 55 80             	mov    0xffffff80(%ebp),%edx
   1871a:	81 c2 ec 00 00 00    	add    $0xec,%edx
   18720:	8b 85 50 ff ff ff    	mov    0xffffff50(%ebp),%eax
   18726:	89 0a                	mov    %ecx,(%edx)
   18728:	89 85 50 ff ff ff    	mov    %eax,0xffffff50(%ebp)
   1872e:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
   18735:	8b 55 10             	mov    0x10(%ebp),%edx
   18738:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1873b:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
   18741:	7c 05                	jl     18748 <convertMSK_out+0x56a>
   18743:	e9 9c 01 00 00       	jmp    188e4 <convertMSK_out+0x706>
   18748:	8b 4d 10             	mov    0x10(%ebp),%ecx
   1874b:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   1874e:	89 d0                	mov    %edx,%eax
   18750:	c1 e0 03             	shl    $0x3,%eax
   18753:	01 d0                	add    %edx,%eax
   18755:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1875c:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   18762:	83 7c 10 10 00       	cmpl   $0x0,0x10(%eax,%edx,1)
   18767:	75 05                	jne    1876e <convertMSK_out+0x590>
   18769:	e9 6c 01 00 00       	jmp    188da <convertMSK_out+0x6fc>
   1876e:	8b 4d 10             	mov    0x10(%ebp),%ecx
   18771:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   18774:	89 d0                	mov    %edx,%eax
   18776:	c1 e0 03             	shl    $0x3,%eax
   18779:	01 d0                	add    %edx,%eax
   1877b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   18782:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   18788:	8b 44 10 10          	mov    0x10(%eax,%edx,1),%eax
   1878c:	89 85 50 ff ff ff    	mov    %eax,0xffffff50(%ebp)
   18792:	c7 85 58 ff ff ff 20 	movl   $0x6320,0xffffff58(%ebp)
   18799:	63 00 00 
   1879c:	8b 85 50 ff ff ff    	mov    0xffffff50(%ebp),%eax
   187a2:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   187a6:	8b 45 14             	mov    0x14(%ebp),%eax
   187a9:	89 04 24             	mov    %eax,(%esp,1)
   187ac:	e8 ce 2c 00 00       	call   1b47f <lbb_reserve>
   187b1:	89 85 5c ff ff ff    	mov    %eax,0xffffff5c(%ebp)
   187b7:	83 bd 5c ff ff ff 00 	cmpl   $0x0,0xffffff5c(%ebp)
   187be:	75 22                	jne    187e2 <convertMSK_out+0x604>
   187c0:	8b 85 58 ff ff ff    	mov    0xffffff58(%ebp),%eax
   187c6:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   187ca:	c7 04 24 a5 62 00 00 	movl   $0x62a5,(%esp,1)
   187d1:	e8 fc ff ff ff       	call   187d2 <convertMSK_out+0x5f4>
   187d6:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
   187dd:	e9 85 01 00 00       	jmp    18967 <convertMSK_out+0x789>
   187e2:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
   187e9:	74 71                	je     1885c <convertMSK_out+0x67e>
   187eb:	8b 4d 10             	mov    0x10(%ebp),%ecx
   187ee:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   187f1:	89 d0                	mov    %edx,%eax
   187f3:	c1 e0 03             	shl    $0x3,%eax
   187f6:	01 d0                	add    %edx,%eax
   187f8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   187ff:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   18805:	8b 44 10 10          	mov    0x10(%eax,%edx,1),%eax
   18809:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1880d:	8b 45 08             	mov    0x8(%ebp),%eax
   18810:	89 04 24             	mov    %eax,(%esp,1)
   18813:	a1 00 00 00 00       	mov    0x0,%eax
   18818:	ff d0                	call   *%eax
   1881a:	89 45 80             	mov    %eax,0xffffff80(%ebp)
   1881d:	83 7d 80 00          	cmpl   $0x0,0xffffff80(%ebp)
   18821:	75 18                	jne    1883b <convertMSK_out+0x65d>
   18823:	c7 04 24 20 65 00 00 	movl   $0x6520,(%esp,1)
   1882a:	e8 fc ff ff ff       	call   1882b <convertMSK_out+0x64d>
   1882f:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
   18836:	e9 2c 01 00 00       	jmp    18967 <convertMSK_out+0x789>
   1883b:	8b 5d 10             	mov    0x10(%ebp),%ebx
   1883e:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   18841:	89 d0                	mov    %edx,%eax
   18843:	c1 e0 03             	shl    $0x3,%eax
   18846:	01 d0                	add    %edx,%eax
   18848:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   1884f:	8b 93 ec 00 00 00    	mov    0xec(%ebx),%edx
   18855:	8b 45 80             	mov    0xffffff80(%ebp),%eax
   18858:	89 44 0a 14          	mov    %eax,0x14(%edx,%ecx,1)
   1885c:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp,1)
   18863:	00 
   18864:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp,1)
   1886b:	00 
   1886c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp,1)
   18873:	00 
   18874:	8b 85 50 ff ff ff    	mov    0xffffff50(%ebp),%eax
   1887a:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   1887e:	8b 4d 10             	mov    0x10(%ebp),%ecx
   18881:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   18884:	89 d0                	mov    %edx,%eax
   18886:	c1 e0 03             	shl    $0x3,%eax
   18889:	01 d0                	add    %edx,%eax
   1888b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   18892:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   18898:	8b 44 10 14          	mov    0x14(%eax,%edx,1),%eax
   1889c:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   188a0:	8b 85 5c ff ff ff    	mov    0xffffff5c(%ebp),%eax
   188a6:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   188aa:	8b 45 0c             	mov    0xc(%ebp),%eax
   188ad:	89 04 24             	mov    %eax,(%esp,1)
   188b0:	e8 cb 2e 00 00       	call   1b780 <copy_patch_hmac_update_out>
   188b5:	c7 45 84 00 00 00 00 	movl   $0x0,0xffffff84(%ebp)
   188bc:	8b 55 8c             	mov    0xffffff8c(%ebp),%edx
   188bf:	8b 85 5c ff ff ff    	mov    0xffffff5c(%ebp),%eax
   188c5:	89 c1                	mov    %eax,%ecx
   188c7:	29 d1                	sub    %edx,%ecx
   188c9:	8b 95 5c ff ff ff    	mov    0xffffff5c(%ebp),%edx
   188cf:	83 c2 14             	add    $0x14,%edx
   188d2:	8b 45 84             	mov    0xffffff84(%ebp),%eax
   188d5:	89 0a                	mov    %ecx,(%edx)
   188d7:	89 45 84             	mov    %eax,0xffffff84(%ebp)
   188da:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   188dd:	ff 00                	incl   (%eax)
   188df:	e9 51 fe ff ff       	jmp    18735 <convertMSK_out+0x557>
   188e4:	8b 45 14             	mov    0x14(%ebp),%eax
   188e7:	89 04 24             	mov    %eax,(%esp,1)
   188ea:	e8 73 2b 00 00       	call   1b462 <lbb_get_offset>
   188ef:	2b 45 e8             	sub    0xffffffe8(%ebp),%eax
   188f2:	89 85 50 ff ff ff    	mov    %eax,0xffffff50(%ebp)
   188f8:	8b 45 94             	mov    0xffffff94(%ebp),%eax
   188fb:	3b 85 50 ff ff ff    	cmp    0xffffff50(%ebp),%eax
   18901:	74 3c                	je     1893f <convertMSK_out+0x761>
   18903:	8b 45 94             	mov    0xffffff94(%ebp),%eax
   18906:	3b 85 50 ff ff ff    	cmp    0xffffff50(%ebp),%eax
   1890c:	74 14                	je     18922 <convertMSK_out+0x744>
   1890e:	c7 44 24 04 5c 0a 00 	movl   $0xa5c,0x4(%esp,1)
   18915:	00 
   18916:	c7 04 24 80 63 00 00 	movl   $0x6380,(%esp,1)
   1891d:	e8 fc ff ff ff       	call   1891e <convertMSK_out+0x740>
   18922:	8b 85 50 ff ff ff    	mov    0xffffff50(%ebp),%eax
   18928:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1892c:	8b 45 94             	mov    0xffffff94(%ebp),%eax
   1892f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   18933:	c7 04 24 cc 63 00 00 	movl   $0x63cc,(%esp,1)
   1893a:	e8 fc ff ff ff       	call   1893b <convertMSK_out+0x75d>
   1893f:	c7 85 58 ff ff ff 00 	movl   $0x0,0xffffff58(%ebp)
   18946:	00 00 00 
   18949:	8b 8d 50 ff ff ff    	mov    0xffffff50(%ebp),%ecx
   1894f:	8b 55 90             	mov    0xffffff90(%ebp),%edx
   18952:	8b 85 58 ff ff ff    	mov    0xffffff58(%ebp),%eax
   18958:	89 0a                	mov    %ecx,(%edx)
   1895a:	89 85 58 ff ff ff    	mov    %eax,0xffffff58(%ebp)
   18960:	8b 45 18             	mov    0x18(%ebp),%eax
   18963:	ff 00                	incl   (%eax)
   18965:	eb 1d                	jmp    18984 <convertMSK_out+0x7a6>
   18967:	83 7d dc 00          	cmpl   $0x0,0xffffffdc(%ebp)
   1896b:	74 0b                	je     18978 <convertMSK_out+0x79a>
   1896d:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   18970:	89 04 24             	mov    %eax,(%esp,1)
   18973:	e8 fc ff ff ff       	call   18974 <convertMSK_out+0x796>
   18978:	c7 85 4c ff ff ff ea 	movl   $0xffffffea,0xffffff4c(%ebp)
   1897f:	ff ff ff 
   18982:	eb 0a                	jmp    1898e <convertMSK_out+0x7b0>
   18984:	c7 85 4c ff ff ff 00 	movl   $0x0,0xffffff4c(%ebp)
   1898b:	00 00 00 
   1898e:	8b 85 4c ff ff ff    	mov    0xffffff4c(%ebp),%eax
   18994:	81 c4 cc 00 00 00    	add    $0xcc,%esp
   1899a:	5b                   	pop    %ebx
   1899b:	5d                   	pop    %ebp
   1899c:	c3                   	ret    

0001899d <trickles_extract_events_impl>:

static inline
int extract_MSKs_from_lbb(struct sock *sk, struct alloc_head_list *new_msk_list,
			   struct HMAC_CTX *hmac_ctx,
			   struct linear_bounded_buffer *lbb);


static inline void msk_force_free(struct sock *sk, struct cminisock *msk) {
	msk->ctl = ALLOC_READY;
	free_trickles_msk(sk,msk);
	free_trickles_msk_finish(sk,msk);
 }

#ifdef CHECK_INVALID
#define CHECK_INVALID_0()					\
	int origInvalidCount = analyze_msk_list_helper(sk, 0);

#define CHECK_INVALID_1()						\
	do { int newInvalidCount = analyze_msk_list_helper(sk, 0);	\
	if(newInvalidCount > 0 || origInvalidCount > 0) {		\
		printk("Invalid counts @ %d: %d=>%d\n", __LINE__, origInvalidCount, newInvalidCount); \
	} } while(0);
#else
#define CHECK_INVALID_0()
#define CHECK_INVALID_1()
#endif


/* "Ideal" Error semantics
   If error occurs due to lack of space in output, then the output is guaranteed to be in a usable state
   E.g., hmac and msk_collection are valid for the truncated output

   - Unfortunately, this is challenging to do efficiently given the way HMAC is computed. Punt.
*/
int trickles_extract_events_impl(int fd, struct extract_mskdesc_in *descbuf, int descbuf_len, struct msk_collection *dest, int *destLen) {
   1899d:	55                   	push   %ebp
   1899e:	89 e5                	mov    %esp,%ebp
   189a0:	57                   	push   %edi
   189a1:	56                   	push   %esi
   189a2:	53                   	push   %ebx
   189a3:	81 ec 94 03 00 00    	sub    $0x394,%esp
	int hitFreeLoop = 0;
   189a9:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
	/*
	   1. For each descbuf
	      a. Verify MD5
	      b. Allocate msk and tmalloc() structures
	      c. Link into event list
	*/
	struct socket *sock;
	struct sock *sk = NULL;
   189b0:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
	struct tcp_opt *tp;
	int err;
	int hmac_input_len;

	if(descbuf_len <= 0) {
   189b7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   189bb:	7f 0c                	jg     189c9 <trickles_extract_events_impl+0x2c>
		err = -EINVAL;
   189bd:	c7 45 e0 ea ff ff ff 	movl   $0xffffffea,0xffffffe0(%ebp)
		goto out;
   189c4:	e9 33 09 00 00       	jmp    192fc <trickles_extract_events_impl+0x95f>
	}

	sock = sockfd_lookup(fd, &err);
   189c9:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   189cc:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   189d0:	8b 45 08             	mov    0x8(%ebp),%eax
   189d3:	89 04 24             	mov    %eax,(%esp,1)
   189d6:	e8 fc ff ff ff       	call   189d7 <trickles_extract_events_impl+0x3a>
   189db:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	if (!sock)
   189de:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
   189e2:	75 05                	jne    189e9 <trickles_extract_events_impl+0x4c>
		goto out;
   189e4:	e9 13 09 00 00       	jmp    192fc <trickles_extract_events_impl+0x95f>

	sk = sock->sk;
   189e9:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   189ec:	8b 40 18             	mov    0x18(%eax),%eax
   189ef:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)

	lock_sock(sk);
   189f2:	ff 05 08 00 00 00    	incl   0x8
   189f8:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   189fb:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
   189ff:	74 0b                	je     18a0c <trickles_extract_events_impl+0x6f>
   18a01:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18a04:	89 04 24             	mov    %eax,(%esp,1)
   18a07:	e8 fc ff ff ff       	call   18a08 <trickles_extract_events_impl+0x6b>
   18a0c:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18a0f:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
   18a16:	c7 45 d8 08 00 00 00 	movl   $0x8,0xffffffd8(%ebp)
   18a1d:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   18a20:	ff 08                	decl   (%eax)
   18a22:	83 38 00             	cmpl   $0x0,(%eax)
   18a25:	75 0d                	jne    18a34 <trickles_extract_events_impl+0x97>
   18a27:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   18a2a:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   18a2e:	0f 85 5c 38 00 00    	jne    1c290 <.text.lock.tmalloc+0x320>

	if(!IS_TRICKLES_SERVER(sk)) {
   18a34:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18a37:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   18a3d:	83 e0 01             	and    $0x1,%eax
   18a40:	85 c0                	test   %eax,%eax
   18a42:	74 0d                	je     18a51 <trickles_extract_events_impl+0xb4>
   18a44:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18a47:	0f b6 40 20          	movzbl 0x20(%eax),%eax
   18a4b:	3c 0a                	cmp    $0xa,%al
   18a4d:	75 02                	jne    18a51 <trickles_extract_events_impl+0xb4>
   18a4f:	eb 18                	jmp    18a69 <trickles_extract_events_impl+0xcc>
		printk("Not trickles server\n");
   18a51:	c7 04 24 5a 65 00 00 	movl   $0x655a,(%esp,1)
   18a58:	e8 fc ff ff ff       	call   18a59 <trickles_extract_events_impl+0xbc>
		err = -EINVAL;
   18a5d:	c7 45 e0 ea ff ff ff 	movl   $0xffffffea,0xffffffe0(%ebp)
		goto out_put;
   18a64:	e9 13 08 00 00       	jmp    1927c <trickles_extract_events_impl+0x8df>
	}

	tp = &(sk->tp_pinfo.af_tcp);
   18a69:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18a6c:	05 bc 00 00 00       	add    $0xbc,%eax
   18a71:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
	CHECK_INVALID_0();

	int origFreeLen = tp->cminisock_api_config.msk_freelist.len;
   18a74:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   18a77:	8b 80 e4 01 00 00    	mov    0x1e4(%eax),%eax
   18a7d:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)

	if(!access_ok(VERIFY_READ, descbuf, descbuf_len)) {
   18a80:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   18a83:	e8 b7 14 00 00       	call   19f3f <get_current>
   18a88:	89 da                	mov    %ebx,%edx
   18a8a:	03 55 10             	add    0x10(%ebp),%edx
   18a8d:	19 c9                	sbb    %ecx,%ecx
   18a8f:	39 50 0c             	cmp    %edx,0xc(%eax)
   18a92:	83 d9 00             	sbb    $0x0,%ecx
   18a95:	89 c8                	mov    %ecx,%eax
   18a97:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   18a9a:	89 d0                	mov    %edx,%eax
   18a9c:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
   18a9f:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   18aa2:	85 c0                	test   %eax,%eax
   18aa4:	74 18                	je     18abe <trickles_extract_events_impl+0x121>
		printk("descbuf not readable\n");
   18aa6:	c7 04 24 6f 65 00 00 	movl   $0x656f,(%esp,1)
   18aad:	e8 fc ff ff ff       	call   18aae <trickles_extract_events_impl+0x111>
		err = -EFAULT;
   18ab2:	c7 45 e0 f2 ff ff ff 	movl   $0xfffffff2,0xffffffe0(%ebp)
		goto out_put;
   18ab9:	e9 be 07 00 00       	jmp    1927c <trickles_extract_events_impl+0x8df>
	}
	if(!access_ok(VERIFY_WRITE, dest, *destLen)) {
   18abe:	8b 75 14             	mov    0x14(%ebp),%esi
   18ac1:	8b 5d 18             	mov    0x18(%ebp),%ebx
   18ac4:	e8 76 14 00 00       	call   19f3f <get_current>
   18ac9:	89 f2                	mov    %esi,%edx
   18acb:	03 13                	add    (%ebx),%edx
   18acd:	19 ff                	sbb    %edi,%edi
   18acf:	39 50 0c             	cmp    %edx,0xc(%eax)
   18ad2:	83 df 00             	sbb    $0x0,%edi
   18ad5:	89 f8                	mov    %edi,%eax
   18ad7:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
   18ada:	89 d0                	mov    %edx,%eax
   18adc:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   18adf:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   18ae2:	85 c0                	test   %eax,%eax
   18ae4:	74 18                	je     18afe <trickles_extract_events_impl+0x161>
		printk("destination not writable\n");
   18ae6:	c7 04 24 85 65 00 00 	movl   $0x6585,(%esp,1)
   18aed:	e8 fc ff ff ff       	call   18aee <trickles_extract_events_impl+0x151>
		err = -EFAULT;
   18af2:	c7 45 e0 f2 ff ff ff 	movl   $0xfffffff2,0xffffffe0(%ebp)
		goto out_put;
   18af9:	e9 7e 07 00 00       	jmp    1927c <trickles_extract_events_impl+0x8df>
	}

	struct linear_bounded_buffer lbb = {
   18afe:	8b 45 14             	mov    0x14(%ebp),%eax
   18b01:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
   18b04:	8b 45 14             	mov    0x14(%ebp),%eax
   18b07:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
   18b0a:	8b 45 18             	mov    0x18(%ebp),%eax
   18b0d:	8b 00                	mov    (%eax),%eax
   18b0f:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
   18b12:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
   18b15:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
   18b18:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
   18b1b:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
   18b1e:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
   18b21:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
		start : (char*)dest,
		curr : (char*)dest,
		limit : *destLen
	};


	struct extract_mskdesc_in *currentInputDesc = descbuf;
   18b24:	8b 45 0c             	mov    0xc(%ebp),%eax
   18b27:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
	struct msk_collection *outputCollection = dest;
   18b2a:	8b 45 14             	mov    0x14(%ebp),%eax
   18b2d:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
	lbb_reserve(&lbb, sizeof(struct msk_collection));
   18b30:	c7 44 24 04 18 00 00 	movl   $0x18,0x4(%esp,1)
   18b37:	00 
   18b38:	8d 45 c0             	lea    0xffffffc0(%ebp),%eax
   18b3b:	89 04 24             	mov    %eax,(%esp,1)
   18b3e:	e8 3c 29 00 00       	call   1b47f <lbb_reserve>

	char hmac[HMACLEN];
	struct HMAC_CTX hmac_ctx = *tp->t.hmacCTX;
   18b43:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   18b46:	8b 80 28 0a 00 00    	mov    0xa28(%eax),%eax
   18b4c:	8d 95 50 fe ff ff    	lea    0xfffffe50(%ebp),%edx
   18b52:	89 95 98 fc ff ff    	mov    %edx,0xfffffc98(%ebp)
   18b58:	89 85 94 fc ff ff    	mov    %eax,0xfffffc94(%ebp)
   18b5e:	c7 85 90 fc ff ff 58 	movl   $0x158,0xfffffc90(%ebp)
   18b65:	01 00 00 
   18b68:	8b 85 98 fc ff ff    	mov    0xfffffc98(%ebp),%eax
   18b6e:	83 e0 04             	and    $0x4,%eax
   18b71:	85 c0                	test   %eax,%eax
   18b73:	74 25                	je     18b9a <trickles_extract_events_impl+0x1fd>
   18b75:	8b 8d 94 fc ff ff    	mov    0xfffffc94(%ebp),%ecx
   18b7b:	8b 01                	mov    (%ecx),%eax
   18b7d:	8b b5 98 fc ff ff    	mov    0xfffffc98(%ebp),%esi
   18b83:	89 06                	mov    %eax,(%esi)
   18b85:	83 85 98 fc ff ff 04 	addl   $0x4,0xfffffc98(%ebp)
   18b8c:	83 85 94 fc ff ff 04 	addl   $0x4,0xfffffc94(%ebp)
   18b93:	83 ad 90 fc ff ff 04 	subl   $0x4,0xfffffc90(%ebp)
   18b9a:	fc                   	cld    
   18b9b:	8b 8d 90 fc ff ff    	mov    0xfffffc90(%ebp),%ecx
   18ba1:	c1 e9 02             	shr    $0x2,%ecx
   18ba4:	8b bd 98 fc ff ff    	mov    0xfffffc98(%ebp),%edi
   18baa:	8b b5 94 fc ff ff    	mov    0xfffffc94(%ebp),%esi
   18bb0:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
	hmac_init(&hmac_ctx);
   18bb2:	8d 85 50 fe ff ff    	lea    0xfffffe50(%ebp),%eax
   18bb8:	89 04 24             	mov    %eax,(%esp,1)
   18bbb:	e8 fc ff ff ff       	call   18bbc <trickles_extract_events_impl+0x21f>

	*destLen = 0;
   18bc0:	8b 45 18             	mov    0x18(%ebp),%eax
   18bc3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int numCopies = 0;
   18bc9:	c7 85 4c fe ff ff 00 	movl   $0x0,0xfffffe4c(%ebp)
   18bd0:	00 00 00 
	/* N.B.
	   All embedded pointer offsets are appended to HMAC
	   Initially, pointer offsets are populated as 0
	*/
	while((char*)currentInputDesc -  (char*) descbuf < descbuf_len) {
   18bd3:	8b 45 0c             	mov    0xc(%ebp),%eax
   18bd6:	8b 55 d0             	mov    0xffffffd0(%ebp),%edx
   18bd9:	29 c2                	sub    %eax,%edx
   18bdb:	89 d0                	mov    %edx,%eax
   18bdd:	3b 45 10             	cmp    0x10(%ebp),%eax
   18be0:	7c 05                	jl     18be7 <trickles_extract_events_impl+0x24a>
   18be2:	e9 2f 03 00 00       	jmp    18f16 <trickles_extract_events_impl+0x579>
		struct extract_mskdesc_in mskdesc;
		__copy_from_user(&mskdesc, currentInputDesc, sizeof(mskdesc));
   18be7:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp,1)
   18bee:	00 
   18bef:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   18bf2:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   18bf6:	8d 85 44 fe ff ff    	lea    0xfffffe44(%ebp),%eax
   18bfc:	89 04 24             	mov    %eax,(%esp,1)
   18bff:	e8 5a 18 00 00       	call   1a45e <__constant_copy_from_user_nocheck>
		struct cminisock *msk = mskdesc.msk;
   18c04:	8b 85 44 fe ff ff    	mov    0xfffffe44(%ebp),%eax
   18c0a:	89 85 40 fe ff ff    	mov    %eax,0xfffffe40(%ebp)

		//printk("Requesting msk=%p & %p\n", msk, &currentInputDesc->msk);

		if(!IS_VALID_MSK(sk,msk)) {
   18c10:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18c13:	05 bc 00 00 00       	add    $0xbc,%eax
   18c18:	89 85 3c fe ff ff    	mov    %eax,0xfffffe3c(%ebp)
   18c1e:	c7 85 8c fc ff ff 00 	movl   $0x0,0xfffffc8c(%ebp)
   18c25:	00 00 00 
   18c28:	8b 85 3c fe ff ff    	mov    0xfffffe3c(%ebp),%eax
   18c2e:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
   18c34:	8b 50 0c             	mov    0xc(%eax),%edx
   18c37:	8b 85 40 fe ff ff    	mov    0xfffffe40(%ebp),%eax
   18c3d:	89 c1                	mov    %eax,%ecx
   18c3f:	29 d1                	sub    %edx,%ecx
   18c41:	89 ca                	mov    %ecx,%edx
   18c43:	c1 ea 02             	shr    $0x2,%edx
   18c46:	b8 21 08 82 20       	mov    $0x20820821,%eax
   18c4b:	f7 e2                	mul    %edx
   18c4d:	c1 ea 03             	shr    $0x3,%edx
   18c50:	89 d0                	mov    %edx,%eax
   18c52:	c1 e0 06             	shl    $0x6,%eax
   18c55:	29 d0                	sub    %edx,%eax
   18c57:	c1 e0 02             	shl    $0x2,%eax
   18c5a:	29 c1                	sub    %eax,%ecx
   18c5c:	89 c8                	mov    %ecx,%eax
   18c5e:	85 c0                	test   %eax,%eax
   18c60:	75 57                	jne    18cb9 <trickles_extract_events_impl+0x31c>
   18c62:	8b 85 3c fe ff ff    	mov    0xfffffe3c(%ebp),%eax
   18c68:	8b 90 cc 01 00 00    	mov    0x1cc(%eax),%edx
   18c6e:	8b 85 40 fe ff ff    	mov    0xfffffe40(%ebp),%eax
   18c74:	3b 42 0c             	cmp    0xc(%edx),%eax
   18c77:	72 40                	jb     18cb9 <trickles_extract_events_impl+0x31c>
   18c79:	8b 85 40 fe ff ff    	mov    0xfffffe40(%ebp),%eax
   18c7f:	05 fc 00 00 00       	add    $0xfc,%eax
   18c84:	8b 95 3c fe ff ff    	mov    0xfffffe3c(%ebp),%edx
   18c8a:	8b 92 cc 01 00 00    	mov    0x1cc(%edx),%edx
   18c90:	3b 42 10             	cmp    0x10(%edx),%eax
   18c93:	77 24                	ja     18cb9 <trickles_extract_events_impl+0x31c>
   18c95:	8b 85 40 fe ff ff    	mov    0xfffffe40(%ebp),%eax
   18c9b:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
   18c9f:	74 0e                	je     18caf <trickles_extract_events_impl+0x312>
   18ca1:	8b 85 40 fe ff ff    	mov    0xfffffe40(%ebp),%eax
   18ca7:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
   18cab:	74 02                	je     18caf <trickles_extract_events_impl+0x312>
   18cad:	eb 0a                	jmp    18cb9 <trickles_extract_events_impl+0x31c>
   18caf:	c7 85 8c fc ff ff 01 	movl   $0x1,0xfffffc8c(%ebp)
   18cb6:	00 00 00 
   18cb9:	83 bd 8c fc ff ff 00 	cmpl   $0x0,0xfffffc8c(%ebp)
   18cc0:	0f 85 1a 01 00 00    	jne    18de0 <trickles_extract_events_impl+0x443>
			printk("Invalid msk in descbuf list, %d %d\n", IS_TRICKLES_SOCK_ADDR(tp,(msk)), IS_TRICKLES_SOCK_ADDR(tp,(msk)) && VALID_MSK_CTL((msk)));
   18cc6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
   18ccd:	00 
   18cce:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   18cd1:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
   18cd7:	8b 50 0c             	mov    0xc(%eax),%edx
   18cda:	8b 85 40 fe ff ff    	mov    0xfffffe40(%ebp),%eax
   18ce0:	89 c1                	mov    %eax,%ecx
   18ce2:	29 d1                	sub    %edx,%ecx
   18ce4:	89 ca                	mov    %ecx,%edx
   18ce6:	c1 ea 02             	shr    $0x2,%edx
   18ce9:	b8 21 08 82 20       	mov    $0x20820821,%eax
   18cee:	f7 e2                	mul    %edx
   18cf0:	c1 ea 03             	shr    $0x3,%edx
   18cf3:	89 d0                	mov    %edx,%eax
   18cf5:	c1 e0 06             	shl    $0x6,%eax
   18cf8:	29 d0                	sub    %edx,%eax
   18cfa:	c1 e0 02             	shl    $0x2,%eax
   18cfd:	29 c1                	sub    %eax,%ecx
   18cff:	89 c8                	mov    %ecx,%eax
   18d01:	85 c0                	test   %eax,%eax
   18d03:	75 4f                	jne    18d54 <trickles_extract_events_impl+0x3b7>
   18d05:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   18d08:	8b 90 cc 01 00 00    	mov    0x1cc(%eax),%edx
   18d0e:	8b 85 40 fe ff ff    	mov    0xfffffe40(%ebp),%eax
   18d14:	3b 42 0c             	cmp    0xc(%edx),%eax
   18d17:	72 3b                	jb     18d54 <trickles_extract_events_impl+0x3b7>
   18d19:	8b 85 40 fe ff ff    	mov    0xfffffe40(%ebp),%eax
   18d1f:	05 fc 00 00 00       	add    $0xfc,%eax
   18d24:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   18d27:	8b 92 cc 01 00 00    	mov    0x1cc(%edx),%edx
   18d2d:	3b 42 10             	cmp    0x10(%edx),%eax
   18d30:	77 22                	ja     18d54 <trickles_extract_events_impl+0x3b7>
   18d32:	8b 85 40 fe ff ff    	mov    0xfffffe40(%ebp),%eax
   18d38:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
   18d3c:	74 0e                	je     18d4c <trickles_extract_events_impl+0x3af>
   18d3e:	8b 85 40 fe ff ff    	mov    0xfffffe40(%ebp),%eax
   18d44:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
   18d48:	74 02                	je     18d4c <trickles_extract_events_impl+0x3af>
   18d4a:	eb 08                	jmp    18d54 <trickles_extract_events_impl+0x3b7>
   18d4c:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp,1)
   18d53:	00 
   18d54:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
   18d5b:	00 
   18d5c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   18d5f:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
   18d65:	8b 50 0c             	mov    0xc(%eax),%edx
   18d68:	8b 85 40 fe ff ff    	mov    0xfffffe40(%ebp),%eax
   18d6e:	89 c1                	mov    %eax,%ecx
   18d70:	29 d1                	sub    %edx,%ecx
   18d72:	89 ca                	mov    %ecx,%edx
   18d74:	c1 ea 02             	shr    $0x2,%edx
   18d77:	b8 21 08 82 20       	mov    $0x20820821,%eax
   18d7c:	f7 e2                	mul    %edx
   18d7e:	c1 ea 03             	shr    $0x3,%edx
   18d81:	89 d0                	mov    %edx,%eax
   18d83:	c1 e0 06             	shl    $0x6,%eax
   18d86:	29 d0                	sub    %edx,%eax
   18d88:	c1 e0 02             	shl    $0x2,%eax
   18d8b:	29 c1                	sub    %eax,%ecx
   18d8d:	89 c8                	mov    %ecx,%eax
   18d8f:	85 c0                	test   %eax,%eax
   18d91:	75 35                	jne    18dc8 <trickles_extract_events_impl+0x42b>
   18d93:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   18d96:	8b 90 cc 01 00 00    	mov    0x1cc(%eax),%edx
   18d9c:	8b 85 40 fe ff ff    	mov    0xfffffe40(%ebp),%eax
   18da2:	3b 42 0c             	cmp    0xc(%edx),%eax
   18da5:	72 21                	jb     18dc8 <trickles_extract_events_impl+0x42b>
   18da7:	8b 85 40 fe ff ff    	mov    0xfffffe40(%ebp),%eax
   18dad:	05 fc 00 00 00       	add    $0xfc,%eax
   18db2:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   18db5:	8b 92 cc 01 00 00    	mov    0x1cc(%edx),%edx
   18dbb:	3b 42 10             	cmp    0x10(%edx),%eax
   18dbe:	77 08                	ja     18dc8 <trickles_extract_events_impl+0x42b>
   18dc0:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp,1)
   18dc7:	00 
   18dc8:	c7 04 24 a0 65 00 00 	movl   $0x65a0,(%esp,1)
   18dcf:	e8 fc ff ff ff       	call   18dd0 <trickles_extract_events_impl+0x433>
			err = -EINVAL;
   18dd4:	c7 45 e0 ea ff ff ff 	movl   $0xffffffea,0xffffffe0(%ebp)
			goto out_put;
   18ddb:	e9 9c 04 00 00       	jmp    1927c <trickles_extract_events_impl+0x8df>
		}
		if(msk->ctl != ALLOC_READY) {
   18de0:	8b 85 40 fe ff ff    	mov    0xfffffe40(%ebp),%eax
   18de6:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
   18dea:	74 18                	je     18e04 <trickles_extract_events_impl+0x467>
			printk("Only alloc_ready packets are allowed to be extracted. alloc_halffree packets have no convenient access path on the destination\n");
   18dec:	c7 04 24 e0 65 00 00 	movl   $0x65e0,(%esp,1)
   18df3:	e8 fc ff ff ff       	call   18df4 <trickles_extract_events_impl+0x457>
			err = -EINVAL;
   18df8:	c7 45 e0 ea ff ff ff 	movl   $0xffffffea,0xffffffe0(%ebp)
			goto out_put;
   18dff:	e9 78 04 00 00       	jmp    1927c <trickles_extract_events_impl+0x8df>
		}
		if(mskdesc.operation & EVENT_COPYOUT) {
   18e04:	8b 85 48 fe ff ff    	mov    0xfffffe48(%ebp),%eax
   18e0a:	83 e0 01             	and    $0x1,%eax
   18e0d:	85 c0                	test   %eax,%eax
   18e0f:	0f 84 81 00 00 00    	je     18e96 <trickles_extract_events_impl+0x4f9>
			//char *start_pos = lbb_get_pos(&lbb);
			if((err = convertMSK_out(sk, &hmac_ctx, msk, &lbb, &numCopies)) != 0) {
   18e15:	8d 85 4c fe ff ff    	lea    0xfffffe4c(%ebp),%eax
   18e1b:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   18e1f:	8d 45 c0             	lea    0xffffffc0(%ebp),%eax
   18e22:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   18e26:	8b 85 40 fe ff ff    	mov    0xfffffe40(%ebp),%eax
   18e2c:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   18e30:	8d 85 50 fe ff ff    	lea    0xfffffe50(%ebp),%eax
   18e36:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   18e3a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18e3d:	89 04 24             	mov    %eax,(%esp,1)
   18e40:	e8 99 f3 ff ff       	call   181de <convertMSK_out>
   18e45:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   18e48:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
   18e4c:	74 48                	je     18e96 <trickles_extract_events_impl+0x4f9>
				printk("Output conversion failed\n");
   18e4e:	c7 04 24 60 66 00 00 	movl   $0x6660,(%esp,1)
   18e55:	e8 fc ff ff ff       	call   18e56 <trickles_extract_events_impl+0x4b9>
				if(err == LBB_ERROR) {
   18e5a:	83 7d e0 ff          	cmpl   $0xffffffff,0xffffffe0(%ebp)
   18e5e:	75 11                	jne    18e71 <trickles_extract_events_impl+0x4d4>
					printk("Better output error semantics (valid truncation) not implemented!\n");
   18e60:	c7 04 24 80 66 00 00 	movl   $0x6680,(%esp,1)
   18e67:	e8 fc ff ff ff       	call   18e68 <trickles_extract_events_impl+0x4cb>
#if 0
					lbb.curr = start_pos;
					goto truncated_output;
#else
					goto out_put;
   18e6c:	e9 0b 04 00 00       	jmp    1927c <trickles_extract_events_impl+0x8df>
#endif
				}
				BUG_TRAP(err == MSK_ERROR);
   18e71:	83 7d e0 fe          	cmpl   $0xfffffffe,0xffffffe0(%ebp)
   18e75:	74 14                	je     18e8b <trickles_extract_events_impl+0x4ee>
   18e77:	c7 44 24 04 e3 0a 00 	movl   $0xae3,0x4(%esp,1)
   18e7e:	00 
   18e7f:	c7 04 24 e0 66 00 00 	movl   $0x66e0,(%esp,1)
   18e86:	e8 fc ff ff ff       	call   18e87 <trickles_extract_events_impl+0x4ea>
				if(err == MSK_ERROR) {
   18e8b:	83 7d e0 fe          	cmpl   $0xfffffffe,0xffffffe0(%ebp)
   18e8f:	75 05                	jne    18e96 <trickles_extract_events_impl+0x4f9>
					goto out_put;
   18e91:	e9 e6 03 00 00       	jmp    1927c <trickles_extract_events_impl+0x8df>
				}
			}
		}

		if(mskdesc.operation & EVENT_UNLINK) {
   18e96:	8b 85 48 fe ff ff    	mov    0xfffffe48(%ebp),%eax
   18e9c:	83 e0 02             	and    $0x2,%eax
   18e9f:	85 c0                	test   %eax,%eax
   18ea1:	74 22                	je     18ec5 <trickles_extract_events_impl+0x528>
			free_trickles_msk(sk,msk);
   18ea3:	8b 85 40 fe ff ff    	mov    0xfffffe40(%ebp),%eax
   18ea9:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   18ead:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18eb0:	89 04 24             	mov    %eax,(%esp,1)
   18eb3:	e8 55 99 ff ff       	call   1280d <free_trickles_msk>
			msk->ctl = ALLOC_HALFFREE;
   18eb8:	8b 85 40 fe ff ff    	mov    0xfffffe40(%ebp),%eax
   18ebe:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
		}
		if(mskdesc.operation & EVENT_DEALLOC) {
   18ec5:	8b 85 48 fe ff ff    	mov    0xfffffe48(%ebp),%eax
   18ecb:	83 e0 04             	and    $0x4,%eax
   18ece:	85 c0                	test   %eax,%eax
   18ed0:	74 39                	je     18f0b <trickles_extract_events_impl+0x56e>
			if(msk->ctl != ALLOC_HALFFREE) {
   18ed2:	8b 85 40 fe ff ff    	mov    0xfffffe40(%ebp),%eax
   18ed8:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
   18edc:	74 18                	je     18ef6 <trickles_extract_events_impl+0x559>
				printk("Dealloc called on an msk that is not half-freed\n");
   18ede:	c7 04 24 40 67 00 00 	movl   $0x6740,(%esp,1)
   18ee5:	e8 fc ff ff ff       	call   18ee6 <trickles_extract_events_impl+0x549>
				err = -EINVAL;
   18eea:	c7 45 e0 ea ff ff ff 	movl   $0xffffffea,0xffffffe0(%ebp)
				goto out_put;
   18ef1:	e9 86 03 00 00       	jmp    1927c <trickles_extract_events_impl+0x8df>
			}
			free_trickles_msk_finish(sk,msk);
   18ef6:	8b 85 40 fe ff ff    	mov    0xfffffe40(%ebp),%eax
   18efc:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   18f00:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   18f03:	89 04 24             	mov    %eax,(%esp,1)
   18f06:	e8 a0 99 ff ff       	call   128ab <free_trickles_msk_finish>
		}
		currentInputDesc = MSKDESC_IN_NEXT(currentInputDesc);
   18f0b:	8d 45 d0             	lea    0xffffffd0(%ebp),%eax
   18f0e:	83 00 08             	addl   $0x8,(%eax)
   18f11:	e9 bd fc ff ff       	jmp    18bd3 <trickles_extract_events_impl+0x236>
	}
	goto truncated_output; // suppress error
 truncated_output:

	hmac_input_len = hmac_ctx.len;
   18f16:	8b 45 a4             	mov    0xffffffa4(%ebp),%eax
   18f19:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
	hmac_final(&hmac_ctx, hmac);
   18f1c:	8d 45 b0             	lea    0xffffffb0(%ebp),%eax
   18f1f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   18f23:	8d 85 50 fe ff ff    	lea    0xfffffe50(%ebp),%eax
   18f29:	89 04 24             	mov    %eax,(%esp,1)
   18f2c:	e8 fc ff ff ff       	call   18f2d <trickles_extract_events_impl+0x590>
	__copy_to_user(outputCollection->hmac, hmac, HMACLEN);
   18f31:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp,1)
   18f38:	00 
   18f39:	8d 45 b0             	lea    0xffffffb0(%ebp),%eax
   18f3c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   18f40:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   18f43:	89 04 24             	mov    %eax,(%esp,1)
   18f46:	e8 56 14 00 00       	call   1a3a1 <__constant_copy_to_user_nocheck>
	outputCollection->len = *destLen = lbb.curr - lbb.start;
   18f4b:	8b 5d d4             	mov    0xffffffd4(%ebp),%ebx
   18f4e:	8b 4d 18             	mov    0x18(%ebp),%ecx
   18f51:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
   18f54:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
   18f57:	29 d0                	sub    %edx,%eax
   18f59:	89 01                	mov    %eax,(%ecx)
   18f5b:	8b 01                	mov    (%ecx),%eax
   18f5d:	89 43 14             	mov    %eax,0x14(%ebx)

	CHECK_INVALID_1();

#if 1 // instant self-test

	printk("Starting instant self-test\n");
   18f60:	c7 04 24 71 67 00 00 	movl   $0x6771,(%esp,1)
   18f67:	e8 fc ff ff ff       	call   18f68 <trickles_extract_events_impl+0x5cb>

	int test_numIn;
	struct alloc_head_list new_msk_list;
	init_head(&new_msk_list);
   18f6c:	8d 85 1c fe ff ff    	lea    0xfffffe1c(%ebp),%eax
   18f72:	89 04 24             	mov    %eax,(%esp,1)
   18f75:	e8 b5 15 00 00       	call   1a52f <init_head>

	lbb.limit = lbb_get_offset(&lbb);
   18f7a:	8d 45 c0             	lea    0xffffffc0(%ebp),%eax
   18f7d:	89 04 24             	mov    %eax,(%esp,1)
   18f80:	e8 dd 24 00 00       	call   1b462 <lbb_get_offset>
   18f85:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
	lbb.curr = lbb.start;
   18f88:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
   18f8b:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)

	BUG_TRAP(lbb_get_offset(&lbb) == 0);
   18f8e:	8d 45 c0             	lea    0xffffffc0(%ebp),%eax
   18f91:	89 04 24             	mov    %eax,(%esp,1)
   18f94:	e8 c9 24 00 00       	call   1b462 <lbb_get_offset>
   18f99:	85 c0                	test   %eax,%eax
   18f9b:	74 14                	je     18fb1 <trickles_extract_events_impl+0x614>
   18f9d:	c7 44 24 04 0d 0b 00 	movl   $0xb0d,0x4(%esp,1)
   18fa4:	00 
   18fa5:	c7 04 24 a0 67 00 00 	movl   $0x67a0,(%esp,1)
   18fac:	e8 fc ff ff ff       	call   18fad <trickles_extract_events_impl+0x610>
	struct msk_collection *inputCollection = (struct msk_collection *)lbb_reserve(&lbb, sizeof(struct msk_collection));
   18fb1:	c7 44 24 04 18 00 00 	movl   $0x18,0x4(%esp,1)
   18fb8:	00 
   18fb9:	8d 45 c0             	lea    0xffffffc0(%ebp),%eax
   18fbc:	89 04 24             	mov    %eax,(%esp,1)
   18fbf:	e8 bb 24 00 00       	call   1b47f <lbb_reserve>
   18fc4:	89 85 40 fe ff ff    	mov    %eax,0xfffffe40(%ebp)
	EQ_TEST(inputCollection, outputCollection);
   18fca:	8b 85 40 fe ff ff    	mov    0xfffffe40(%ebp),%eax
   18fd0:	3b 45 d4             	cmp    0xffffffd4(%ebp),%eax
   18fd3:	74 1d                	je     18ff2 <trickles_extract_events_impl+0x655>
   18fd5:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   18fd8:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   18fdc:	8b 85 40 fe ff ff    	mov    0xfffffe40(%ebp),%eax
   18fe2:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   18fe6:	c7 04 24 00 68 00 00 	movl   $0x6800,(%esp,1)
   18fed:	e8 fc ff ff ff       	call   18fee <trickles_extract_events_impl+0x651>

	struct HMAC_CTX test_hmac_ctx = *tp->t.hmacCTX;
   18ff2:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   18ff5:	8b 80 28 0a 00 00    	mov    0xa28(%eax),%eax
   18ffb:	8d 95 bc fc ff ff    	lea    0xfffffcbc(%ebp),%edx
   19001:	89 95 88 fc ff ff    	mov    %edx,0xfffffc88(%ebp)
   19007:	89 85 84 fc ff ff    	mov    %eax,0xfffffc84(%ebp)
   1900d:	c7 85 80 fc ff ff 58 	movl   $0x158,0xfffffc80(%ebp)
   19014:	01 00 00 
   19017:	8b 85 88 fc ff ff    	mov    0xfffffc88(%ebp),%eax
   1901d:	83 e0 04             	and    $0x4,%eax
   19020:	85 c0                	test   %eax,%eax
   19022:	74 25                	je     19049 <trickles_extract_events_impl+0x6ac>
   19024:	8b 8d 84 fc ff ff    	mov    0xfffffc84(%ebp),%ecx
   1902a:	8b 01                	mov    (%ecx),%eax
   1902c:	8b b5 88 fc ff ff    	mov    0xfffffc88(%ebp),%esi
   19032:	89 06                	mov    %eax,(%esi)
   19034:	83 85 88 fc ff ff 04 	addl   $0x4,0xfffffc88(%ebp)
   1903b:	83 85 84 fc ff ff 04 	addl   $0x4,0xfffffc84(%ebp)
   19042:	83 ad 80 fc ff ff 04 	subl   $0x4,0xfffffc80(%ebp)
   19049:	fc                   	cld    
   1904a:	8b 8d 80 fc ff ff    	mov    0xfffffc80(%ebp),%ecx
   19050:	c1 e9 02             	shr    $0x2,%ecx
   19053:	8b bd 88 fc ff ff    	mov    0xfffffc88(%ebp),%edi
   19059:	8b b5 84 fc ff ff    	mov    0xfffffc84(%ebp),%esi
   1905f:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
	char test_hmac[HMACLEN];
	//int test_hmac_input_len0 = lbb_get_end(&lbb) - lbb_get_pos(&lbb);

	char *hmac_start = lbb_get_pos(&lbb);
   19061:	8d 45 c0             	lea    0xffffffc0(%ebp),%eax
   19064:	89 04 24             	mov    %eax,(%esp,1)
   19067:	e8 08 24 00 00       	call   1b474 <lbb_get_pos>
   1906c:	89 85 a8 fc ff ff    	mov    %eax,0xfffffca8(%ebp)
	int hmac_len = lbb_get_end(&lbb) - lbb_get_pos(&lbb);
   19072:	8d 45 c0             	lea    0xffffffc0(%ebp),%eax
   19075:	89 04 24             	mov    %eax,(%esp,1)
   19078:	e8 d5 23 00 00       	call   1b452 <lbb_get_end>
   1907d:	89 c3                	mov    %eax,%ebx
   1907f:	8d 45 c0             	lea    0xffffffc0(%ebp),%eax
   19082:	89 04 24             	mov    %eax,(%esp,1)
   19085:	e8 ea 23 00 00       	call   1b474 <lbb_get_pos>
   1908a:	29 c3                	sub    %eax,%ebx
   1908c:	89 d8                	mov    %ebx,%eax
   1908e:	89 85 a4 fc ff ff    	mov    %eax,0xfffffca4(%ebp)
	hmac_init(&test_hmac_ctx);
   19094:	8d 85 bc fc ff ff    	lea    0xfffffcbc(%ebp),%eax
   1909a:	89 04 24             	mov    %eax,(%esp,1)
   1909d:	e8 fc ff ff ff       	call   1909e <trickles_extract_events_impl+0x701>
	hmac_update(&test_hmac_ctx, hmac_start, hmac_len);
   190a2:	8b 85 a4 fc ff ff    	mov    0xfffffca4(%ebp),%eax
   190a8:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   190ac:	8b 85 a8 fc ff ff    	mov    0xfffffca8(%ebp),%eax
   190b2:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   190b6:	8d 85 bc fc ff ff    	lea    0xfffffcbc(%ebp),%eax
   190bc:	89 04 24             	mov    %eax,(%esp,1)
   190bf:	e8 fc ff ff ff       	call   190c0 <trickles_extract_events_impl+0x723>
	//int test_hmac_input_len = test_hmac_ctx.len;
	hmac_final(&test_hmac_ctx, test_hmac);
   190c4:	8d 85 ac fc ff ff    	lea    0xfffffcac(%ebp),%eax
   190ca:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   190ce:	8d 85 bc fc ff ff    	lea    0xfffffcbc(%ebp),%eax
   190d4:	89 04 24             	mov    %eax,(%esp,1)
   190d7:	e8 fc ff ff ff       	call   190d8 <trickles_extract_events_impl+0x73b>

	printk("instant Hmac computed on %d @%p\n", hmac_len, hmac_start);
   190dc:	8b 85 a8 fc ff ff    	mov    0xfffffca8(%ebp),%eax
   190e2:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   190e6:	8b 85 a4 fc ff ff    	mov    0xfffffca4(%ebp),%eax
   190ec:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   190f0:	c7 04 24 40 68 00 00 	movl   $0x6840,(%esp,1)
   190f7:	e8 fc ff ff ff       	call   190f8 <trickles_extract_events_impl+0x75b>

	int memcmp_result = memcmp(test_hmac, hmac, HMACLEN);
   190fc:	8d 85 ac fc ff ff    	lea    0xfffffcac(%ebp),%eax
   19102:	89 85 7c fc ff ff    	mov    %eax,0xfffffc7c(%ebp)
   19108:	8d 55 b0             	lea    0xffffffb0(%ebp),%edx
   1910b:	89 95 78 fc ff ff    	mov    %edx,0xfffffc78(%ebp)
   19111:	c7 85 74 fc ff ff 10 	movl   $0x10,0xfffffc74(%ebp)
   19118:	00 00 00 
   1911b:	fc                   	cld    
   1911c:	8b b5 7c fc ff ff    	mov    0xfffffc7c(%ebp),%esi
   19122:	8b bd 78 fc ff ff    	mov    0xfffffc78(%ebp),%edi
   19128:	8b 8d 74 fc ff ff    	mov    0xfffffc74(%ebp),%ecx
   1912e:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
   19130:	0f 97 c2             	seta   %dl
   19133:	0f 92 c0             	setb   %al
   19136:	28 c2                	sub    %al,%dl
   19138:	88 d0                	mov    %dl,%al
   1913a:	0f be c0             	movsbl %al,%eax
   1913d:	89 85 a0 fc ff ff    	mov    %eax,0xfffffca0(%ebp)
	EQ_TEST(memcmp_result, 0);
   19143:	83 bd a0 fc ff ff 00 	cmpl   $0x0,0xfffffca0(%ebp)
   1914a:	74 1e                	je     1916a <trickles_extract_events_impl+0x7cd>
   1914c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
   19153:	00 
   19154:	8b 85 a0 fc ff ff    	mov    0xfffffca0(%ebp),%eax
   1915a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1915e:	c7 04 24 61 68 00 00 	movl   $0x6861,(%esp,1)
   19165:	e8 fc ff ff ff       	call   19166 <trickles_extract_events_impl+0x7c9>

#if 0
	printk("TEST_HMAC %d %d\n", test_hmac_input_len0, test_hmac_input_len);
	hexdump(test_hmac, HMACLEN);
	printk("\n");
	printk("HMAC  %d\n", hmac_input_len);
	hexdump(hmac, HMACLEN);
	printk("\n");
#endif

	if((test_numIn = extract_MSKs_from_lbb(sk, &new_msk_list, &test_hmac_ctx, &lbb)) < 0) {
   1916a:	8d 45 c0             	lea    0xffffffc0(%ebp),%eax
   1916d:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   19171:	8d 85 bc fc ff ff    	lea    0xfffffcbc(%ebp),%eax
   19177:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1917b:	8d 85 1c fe ff ff    	lea    0xfffffe1c(%ebp),%eax
   19181:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   19185:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   19188:	89 04 24             	mov    %eax,(%esp,1)
   1918b:	e8 ca 09 00 00       	call   19b5a <extract_MSKs_from_lbb>
   19190:	89 85 3c fe ff ff    	mov    %eax,0xfffffe3c(%ebp)
   19196:	83 bd 3c fe ff ff 00 	cmpl   $0x0,0xfffffe3c(%ebp)
   1919d:	79 18                	jns    191b7 <trickles_extract_events_impl+0x81a>
		printk("test_numIn < 0: %d\n", test_numIn);
   1919f:	8b 85 3c fe ff ff    	mov    0xfffffe3c(%ebp),%eax
   191a5:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   191a9:	c7 04 24 7d 68 00 00 	movl   $0x687d,(%esp,1)
   191b0:	e8 fc ff ff ff       	call   191b1 <trickles_extract_events_impl+0x814>
   191b5:	eb 5c                	jmp    19213 <trickles_extract_events_impl+0x876>
	} else {
		EQ_TEST(test_numIn, numCopies);
   191b7:	8b 85 3c fe ff ff    	mov    0xfffffe3c(%ebp),%eax
   191bd:	3b 85 4c fe ff ff    	cmp    0xfffffe4c(%ebp),%eax
   191c3:	74 20                	je     191e5 <trickles_extract_events_impl+0x848>
   191c5:	8b 85 4c fe ff ff    	mov    0xfffffe4c(%ebp),%eax
   191cb:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   191cf:	8b 85 3c fe ff ff    	mov    0xfffffe3c(%ebp),%eax
   191d5:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   191d9:	c7 04 24 a0 68 00 00 	movl   $0x68a0,(%esp,1)
   191e0:	e8 fc ff ff ff       	call   191e1 <trickles_extract_events_impl+0x844>
		EQ_TEST(new_msk_list.len, test_numIn);
   191e5:	8b 85 2c fe ff ff    	mov    0xfffffe2c(%ebp),%eax
   191eb:	3b 85 3c fe ff ff    	cmp    0xfffffe3c(%ebp),%eax
   191f1:	74 20                	je     19213 <trickles_extract_events_impl+0x876>
   191f3:	8b 85 3c fe ff ff    	mov    0xfffffe3c(%ebp),%eax
   191f9:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   191fd:	8b 85 2c fe ff ff    	mov    0xfffffe2c(%ebp),%eax
   19203:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   19207:	c7 04 24 e0 68 00 00 	movl   $0x68e0,(%esp,1)
   1920e:	e8 fc ff ff ff       	call   1920f <trickles_extract_events_impl+0x872>
	}

	hitFreeLoop = 1;
   19213:	c7 45 f0 01 00 00 00 	movl   $0x1,0xfffffff0(%ebp)
	if(new_msk_list.len > 0) {
   1921a:	83 bd 2c fe ff ff 00 	cmpl   $0x0,0xfffffe2c(%ebp)
   19221:	7e 50                	jle    19273 <trickles_extract_events_impl+0x8d6>
		while(new_msk_list.len > 0) {
   19223:	83 bd 2c fe ff ff 00 	cmpl   $0x0,0xfffffe2c(%ebp)
   1922a:	7f 02                	jg     1922e <trickles_extract_events_impl+0x891>
   1922c:	eb 45                	jmp    19273 <trickles_extract_events_impl+0x8d6>
			struct cminisock *toFree = (struct cminisock *)new_msk_list.next;
   1922e:	8b 85 20 fe ff ff    	mov    0xfffffe20(%ebp),%eax
   19234:	89 85 9c fc ff ff    	mov    %eax,0xfffffc9c(%ebp)
			BUG_TRAP(toFree != (struct cminisock*)&new_msk_list);
   1923a:	8d 85 1c fe ff ff    	lea    0xfffffe1c(%ebp),%eax
   19240:	39 85 9c fc ff ff    	cmp    %eax,0xfffffc9c(%ebp)
   19246:	75 14                	jne    1925c <trickles_extract_events_impl+0x8bf>
   19248:	c7 44 24 04 35 0b 00 	movl   $0xb35,0x4(%esp,1)
   1924f:	00 
   19250:	c7 04 24 20 69 00 00 	movl   $0x6920,(%esp,1)
   19257:	e8 fc ff ff ff       	call   19258 <trickles_extract_events_impl+0x8bb>
			msk_force_free(sk, toFree);
   1925c:	8b 85 9c fc ff ff    	mov    0xfffffc9c(%ebp),%eax
   19262:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   19266:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   19269:	89 04 24             	mov    %eax,(%esp,1)
   1926c:	e8 38 27 00 00       	call   1b9a9 <msk_force_free>
   19271:	eb b0                	jmp    19223 <trickles_extract_events_impl+0x886>
			//printk("post free len = %d %d\n", new_msk_list.len, tp->cminisock_api_config.msk_freelist.len);
		}
	}
#endif

	err = numCopies;
   19273:	8b 85 4c fe ff ff    	mov    0xfffffe4c(%ebp),%eax
   19279:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
 out_put:
	release_sock(sk);
   1927c:	ff 05 08 00 00 00    	incl   0x8
   19282:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   19285:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   1928c:	74 0b                	je     19299 <trickles_extract_events_impl+0x8fc>
   1928e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   19291:	89 04 24             	mov    %eax,(%esp,1)
   19294:	e8 fc ff ff ff       	call   19295 <trickles_extract_events_impl+0x8f8>
   19299:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1929c:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   192a3:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   192a6:	83 c0 30             	add    $0x30,%eax
   192a9:	89 04 24             	mov    %eax,(%esp,1)
   192ac:	e8 31 0a 00 00       	call   19ce2 <waitqueue_active>
   192b1:	85 c0                	test   %eax,%eax
   192b3:	74 15                	je     192ca <trickles_extract_events_impl+0x92d>
   192b5:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   192b8:	83 c0 30             	add    $0x30,%eax
   192bb:	b9 01 00 00 00       	mov    $0x1,%ecx
   192c0:	ba 03 00 00 00       	mov    $0x3,%edx
   192c5:	e8 fc ff ff ff       	call   192c6 <trickles_extract_events_impl+0x929>
   192ca:	c7 85 9c fc ff ff 08 	movl   $0x8,0xfffffc9c(%ebp)
   192d1:	00 00 00 
   192d4:	8b 85 9c fc ff ff    	mov    0xfffffc9c(%ebp),%eax
   192da:	ff 08                	decl   (%eax)
   192dc:	83 38 00             	cmpl   $0x0,(%eax)
   192df:	75 10                	jne    192f1 <trickles_extract_events_impl+0x954>
   192e1:	8b 85 9c fc ff ff    	mov    0xfffffc9c(%ebp),%eax
   192e7:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   192eb:	0f 85 af 2f 00 00    	jne    1c2a0 <.text.lock.tmalloc+0x330>
	sockfd_put(sock);
   192f1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   192f4:	89 04 24             	mov    %eax,(%esp,1)
   192f7:	e8 46 21 00 00       	call   1b442 <sockfd_put>
 out:
	if(sk) {
   192fc:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
   19300:	74 2e                	je     19330 <trickles_extract_events_impl+0x993>
		printk("FreeLoop(%d %d) After extract free list length %d=>%d\n", hitFreeLoop, err, origFreeLen, tp->cminisock_api_config.msk_freelist.len);
   19302:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   19305:	8b 80 e4 01 00 00    	mov    0x1e4(%eax),%eax
   1930b:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   1930f:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   19312:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   19316:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   19319:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1931d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   19320:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   19324:	c7 04 24 a0 69 00 00 	movl   $0x69a0,(%esp,1)
   1932b:	e8 fc ff ff ff       	call   1932c <trickles_extract_events_impl+0x98f>
		CHECK_INVALID_1();
	}
	return err;
   19330:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
}
   19333:	81 c4 94 03 00 00    	add    $0x394,%esp
   19339:	5b                   	pop    %ebx
   1933a:	5e                   	pop    %esi
   1933b:	5f                   	pop    %edi
   1933c:	5d                   	pop    %ebp
   1933d:	c3                   	ret    

0001933e <trickles_install_events_impl>:

#define CHECK_RESERVE_SUCCESS(VAR) do {					\
	if((VAR) == NULL) {						\
		printk("install_event -- descbuf too short for " #VAR "\n"); \
		err = -EINVAL;						\
		goto out_put;						\
	}								\
} while(0)


// trickles_install_events_impl can handle multiple consecutive collections

#define MSK_IS_ON_VALID_LIST(TP,MSK)				\
	((MSK)->list == &(TP)->cminisock_api_config.msk_freelist ||		\
	 (MSK)->list == &(TP)->cminisock_api_config.cfg.ctl->msk_eventlist)

int trickles_install_events_impl(int fd, struct msk_collection *descbuf, int descbuf_len) {
   1933e:	55                   	push   %ebp
   1933f:	89 e5                	mov    %esp,%ebp
   19341:	57                   	push   %edi
   19342:	56                   	push   %esi
   19343:	53                   	push   %ebx
   19344:	81 ec 18 02 00 00    	sub    $0x218,%esp
	struct socket *sock;
	struct sock *sk = NULL;
   1934a:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
	struct tcp_opt *tp;
	int err = -1;
   19351:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,0xffffffe4(%ebp)

	struct alloc_head_list new_msk_list;
	init_head(&new_msk_list);
   19358:	8d 45 c4             	lea    0xffffffc4(%ebp),%eax
   1935b:	89 04 24             	mov    %eax,(%esp,1)
   1935e:	e8 cc 11 00 00       	call   1a52f <init_head>

	if(descbuf_len <= 0) {
   19363:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   19367:	7f 0c                	jg     19375 <trickles_install_events_impl+0x37>
		err = -EINVAL;
   19369:	c7 45 e4 ea ff ff ff 	movl   $0xffffffea,0xffffffe4(%ebp)
		goto out;
   19370:	e9 cc 06 00 00       	jmp    19a41 <trickles_install_events_impl+0x703>
	}

	sock = sockfd_lookup(fd, &err);
   19375:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
   19378:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1937c:	8b 45 08             	mov    0x8(%ebp),%eax
   1937f:	89 04 24             	mov    %eax,(%esp,1)
   19382:	e8 fc ff ff ff       	call   19383 <trickles_install_events_impl+0x45>
   19387:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	if (!sock) {
   1938a:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
   1938e:	75 0c                	jne    1939c <trickles_install_events_impl+0x5e>
		err = -EINVAL;
   19390:	c7 45 e4 ea ff ff ff 	movl   $0xffffffea,0xffffffe4(%ebp)
		goto out;
   19397:	e9 a5 06 00 00       	jmp    19a41 <trickles_install_events_impl+0x703>
	}

	sk = sock->sk;
   1939c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1939f:	8b 40 18             	mov    0x18(%eax),%eax
   193a2:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	lock_sock(sk);
   193a5:	ff 05 08 00 00 00    	incl   0x8
   193ab:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   193ae:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
   193b2:	74 0b                	je     193bf <trickles_install_events_impl+0x81>
   193b4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   193b7:	89 04 24             	mov    %eax,(%esp,1)
   193ba:	e8 fc ff ff ff       	call   193bb <trickles_install_events_impl+0x7d>
   193bf:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   193c2:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
   193c9:	c7 45 c0 08 00 00 00 	movl   $0x8,0xffffffc0(%ebp)
   193d0:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
   193d3:	ff 08                	decl   (%eax)
   193d5:	83 38 00             	cmpl   $0x0,(%eax)
   193d8:	75 0d                	jne    193e7 <trickles_install_events_impl+0xa9>
   193da:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
   193dd:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   193e1:	0f 85 c9 2e 00 00    	jne    1c2b0 <.text.lock.tmalloc+0x340>

	if(!IS_TRICKLES_SERVER(sk)) {
   193e7:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   193ea:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   193f0:	83 e0 01             	and    $0x1,%eax
   193f3:	85 c0                	test   %eax,%eax
   193f5:	74 0d                	je     19404 <trickles_install_events_impl+0xc6>
   193f7:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   193fa:	0f b6 40 20          	movzbl 0x20(%eax),%eax
   193fe:	3c 0a                	cmp    $0xa,%al
   19400:	75 02                	jne    19404 <trickles_install_events_impl+0xc6>
   19402:	eb 18                	jmp    1941c <trickles_install_events_impl+0xde>
		printk("Not trickles server\n");
   19404:	c7 04 24 5a 65 00 00 	movl   $0x655a,(%esp,1)
   1940b:	e8 fc ff ff ff       	call   1940c <trickles_install_events_impl+0xce>
		err = -EINVAL;
   19410:	c7 45 e4 ea ff ff ff 	movl   $0xffffffea,0xffffffe4(%ebp)
		goto out_put;
   19417:	e9 a5 05 00 00       	jmp    199c1 <trickles_install_events_impl+0x683>
	}

	tp = &(sk->tp_pinfo.af_tcp);
   1941c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1941f:	05 bc 00 00 00       	add    $0xbc,%eax
   19424:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
	int origFreeLen = tp->cminisock_api_config.msk_freelist.len;
   19427:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1942a:	8b 80 e4 01 00 00    	mov    0x1e4(%eax),%eax
   19430:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)

	CHECK_INVALID_0();

	if(!access_ok(VERIFY_READ, descbuf, descbuf_len)) {
   19433:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   19436:	e8 04 0b 00 00       	call   19f3f <get_current>
   1943b:	89 da                	mov    %ebx,%edx
   1943d:	03 55 10             	add    0x10(%ebp),%edx
   19440:	19 c9                	sbb    %ecx,%ecx
   19442:	39 50 0c             	cmp    %edx,0xc(%eax)
   19445:	83 d9 00             	sbb    $0x0,%ecx
   19448:	89 c8                	mov    %ecx,%eax
   1944a:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
   1944d:	89 d0                	mov    %edx,%eax
   1944f:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
   19452:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
   19455:	85 c0                	test   %eax,%eax
   19457:	74 18                	je     19471 <trickles_install_events_impl+0x133>
		printk("descbuf not readable\n");
   19459:	c7 04 24 6f 65 00 00 	movl   $0x656f,(%esp,1)
   19460:	e8 fc ff ff ff       	call   19461 <trickles_install_events_impl+0x123>
		err = -EFAULT;
   19465:	c7 45 e4 f2 ff ff ff 	movl   $0xfffffff2,0xffffffe4(%ebp)
		goto out_put;
   1946c:	e9 50 05 00 00       	jmp    199c1 <trickles_install_events_impl+0x683>
	}

	char *inputPosition = (char*)descbuf;
   19471:	8b 45 0c             	mov    0xc(%ebp),%eax
   19474:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
	int numCollections = 0;
   19477:	c7 45 bc 00 00 00 00 	movl   $0x0,0xffffffbc(%ebp)
	int totalNumIn = 0;
   1947e:	c7 45 b4 00 00 00 00 	movl   $0x0,0xffffffb4(%ebp)
	printk("Input position = %p, length = %d\n", descbuf, descbuf_len);
   19485:	8b 45 10             	mov    0x10(%ebp),%eax
   19488:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1948c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1948f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   19493:	c7 04 24 e0 69 00 00 	movl   $0x69e0,(%esp,1)
   1949a:	e8 fc ff ff ff       	call   1949b <trickles_install_events_impl+0x15d>
	while(inputPosition < (char*)descbuf + descbuf_len) {
   1949f:	8b 45 10             	mov    0x10(%ebp),%eax
   194a2:	03 45 0c             	add    0xc(%ebp),%eax
   194a5:	39 45 b8             	cmp    %eax,0xffffffb8(%ebp)
   194a8:	72 05                	jb     194af <trickles_install_events_impl+0x171>
   194aa:	e9 e0 02 00 00       	jmp    1978f <trickles_install_events_impl+0x451>
		int remaining = descbuf_len - (inputPosition - (char*)descbuf);
   194af:	8b 55 0c             	mov    0xc(%ebp),%edx
   194b2:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
   194b5:	29 d0                	sub    %edx,%eax
   194b7:	89 c2                	mov    %eax,%edx
   194b9:	8b 45 10             	mov    0x10(%ebp),%eax
   194bc:	29 d0                	sub    %edx,%eax
   194be:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
		printk("remaining = %d, %p %p\n", remaining, inputPosition, (char*)descbuf + descbuf_len);
   194c1:	8b 45 10             	mov    0x10(%ebp),%eax
   194c4:	03 45 0c             	add    0xc(%ebp),%eax
   194c7:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   194cb:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
   194ce:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   194d2:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
   194d5:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   194d9:	c7 04 24 02 6a 00 00 	movl   $0x6a02,(%esp,1)
   194e0:	e8 fc ff ff ff       	call   194e1 <trickles_install_events_impl+0x1a3>
		struct linear_bounded_buffer lbb = {
   194e5:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
   194e8:	89 45 a0             	mov    %eax,0xffffffa0(%ebp)
   194eb:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
   194ee:	89 45 a4             	mov    %eax,0xffffffa4(%ebp)
   194f1:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
   194f4:	89 45 a8             	mov    %eax,0xffffffa8(%ebp)
			start : (char*)inputPosition,
			curr : (char*)inputPosition,
			limit : remaining
		};
		struct msk_collection *inputCollection = (struct msk_collection *)lbb_reserve(&lbb, sizeof(struct msk_collection));
   194f7:	c7 44 24 04 18 00 00 	movl   $0x18,0x4(%esp,1)
   194fe:	00 
   194ff:	8d 45 a0             	lea    0xffffffa0(%ebp),%eax
   19502:	89 04 24             	mov    %eax,(%esp,1)
   19505:	e8 75 1f 00 00       	call   1b47f <lbb_reserve>
   1950a:	89 45 9c             	mov    %eax,0xffffff9c(%ebp)
		CHECK_RESERVE_SUCCESS(inputCollection);
   1950d:	83 7d 9c 00          	cmpl   $0x0,0xffffff9c(%ebp)
   19511:	75 18                	jne    1952b <trickles_install_events_impl+0x1ed>
   19513:	c7 04 24 20 6a 00 00 	movl   $0x6a20,(%esp,1)
   1951a:	e8 fc ff ff ff       	call   1951b <trickles_install_events_impl+0x1dd>
   1951f:	c7 45 e4 ea ff ff ff 	movl   $0xffffffea,0xffffffe4(%ebp)
   19526:	e9 96 04 00 00       	jmp    199c1 <trickles_install_events_impl+0x683>
		//printk("passed reserve success, remaining = %d\n", remaining);
		BUG_TRAP(&inputCollection->descs[0] == lbb_get_pos(&lbb));
   1952b:	8b 5d 9c             	mov    0xffffff9c(%ebp),%ebx
   1952e:	83 c3 18             	add    $0x18,%ebx
   19531:	8d 45 a0             	lea    0xffffffa0(%ebp),%eax
   19534:	89 04 24             	mov    %eax,(%esp,1)
   19537:	e8 38 1f 00 00       	call   1b474 <lbb_get_pos>
   1953c:	39 c3                	cmp    %eax,%ebx
   1953e:	74 14                	je     19554 <trickles_install_events_impl+0x216>
   19540:	c7 44 24 04 8e 0b 00 	movl   $0xb8e,0x4(%esp,1)
   19547:	00 
   19548:	c7 04 24 60 6a 00 00 	movl   $0x6a60,(%esp,1)
   1954f:	e8 fc ff ff ff       	call   19550 <trickles_install_events_impl+0x212>

		int collectionLen;
		//printk("Address of input collection length = %p\n", &inputCollection->len);

		__get_user(collectionLen, &inputCollection->len);
   19554:	c7 45 94 00 00 00 00 	movl   $0x0,0xffffff94(%ebp)
   1955b:	8b 55 9c             	mov    0xffffff9c(%ebp),%edx
   1955e:	83 c2 14             	add    $0x14,%edx
   19561:	8b 45 94             	mov    0xffffff94(%ebp),%eax
   19564:	8b 12                	mov    (%edx),%edx
   19566:	89 45 94             	mov    %eax,0xffffff94(%ebp)
   19569:	89 d0                	mov    %edx,%eax
   1956b:	89 45 90             	mov    %eax,0xffffff90(%ebp)
   1956e:	8b 45 90             	mov    0xffffff90(%ebp),%eax
   19571:	89 45 98             	mov    %eax,0xffffff98(%ebp)
		if(inputPosition + collectionLen > (char*)descbuf + descbuf_len) {
   19574:	8b 45 98             	mov    0xffffff98(%ebp),%eax
   19577:	8b 55 b8             	mov    0xffffffb8(%ebp),%edx
   1957a:	01 c2                	add    %eax,%edx
   1957c:	8b 45 10             	mov    0x10(%ebp),%eax
   1957f:	03 45 0c             	add    0xc(%ebp),%eax
   19582:	39 c2                	cmp    %eax,%edx
   19584:	76 1f                	jbe    195a5 <trickles_install_events_impl+0x267>
			printk("Not enough space for collection %d\n", numCollections);
   19586:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
   19589:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1958d:	c7 04 24 e0 6a 00 00 	movl   $0x6ae0,(%esp,1)
   19594:	e8 fc ff ff ff       	call   19595 <trickles_install_events_impl+0x257>
			err = -EINVAL;
   19599:	c7 45 e4 ea ff ff ff 	movl   $0xffffffea,0xffffffe4(%ebp)
			goto out_put;
   195a0:	e9 1c 04 00 00       	jmp    199c1 <trickles_install_events_impl+0x683>
		}
		lbb.limit = collectionLen;
   195a5:	8b 45 98             	mov    0xffffff98(%ebp),%eax
   195a8:	89 45 a8             	mov    %eax,0xffffffa8(%ebp)
		//printk("collectionLen = %d\n", collectionLen);

		int numIn;

		char input_hmac[HMACLEN];
		__copy_from_user(input_hmac, inputCollection->hmac, HMACLEN);
   195ab:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp,1)
   195b2:	00 
   195b3:	8b 45 9c             	mov    0xffffff9c(%ebp),%eax
   195b6:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   195ba:	8d 45 80             	lea    0xffffff80(%ebp),%eax
   195bd:	89 04 24             	mov    %eax,(%esp,1)
   195c0:	e8 99 0e 00 00       	call   1a45e <__constant_copy_from_user_nocheck>

		struct HMAC_CTX hmac_ctx = *tp->t.hmacCTX;
   195c5:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   195c8:	8b 80 28 0a 00 00    	mov    0xa28(%eax),%eax
   195ce:	8d b5 20 fe ff ff    	lea    0xfffffe20(%ebp),%esi
   195d4:	89 b5 08 fe ff ff    	mov    %esi,0xfffffe08(%ebp)
   195da:	89 85 04 fe ff ff    	mov    %eax,0xfffffe04(%ebp)
   195e0:	c7 85 00 fe ff ff 58 	movl   $0x158,0xfffffe00(%ebp)
   195e7:	01 00 00 
   195ea:	8b 85 08 fe ff ff    	mov    0xfffffe08(%ebp),%eax
   195f0:	83 e0 04             	and    $0x4,%eax
   195f3:	85 c0                	test   %eax,%eax
   195f5:	74 25                	je     1961c <trickles_install_events_impl+0x2de>
   195f7:	8b bd 04 fe ff ff    	mov    0xfffffe04(%ebp),%edi
   195fd:	8b 07                	mov    (%edi),%eax
   195ff:	8b 95 08 fe ff ff    	mov    0xfffffe08(%ebp),%edx
   19605:	89 02                	mov    %eax,(%edx)
   19607:	83 85 08 fe ff ff 04 	addl   $0x4,0xfffffe08(%ebp)
   1960e:	83 85 04 fe ff ff 04 	addl   $0x4,0xfffffe04(%ebp)
   19615:	83 ad 00 fe ff ff 04 	subl   $0x4,0xfffffe00(%ebp)
   1961c:	fc                   	cld    
   1961d:	8b 8d 00 fe ff ff    	mov    0xfffffe00(%ebp),%ecx
   19623:	c1 e9 02             	shr    $0x2,%ecx
   19626:	8b bd 08 fe ff ff    	mov    0xfffffe08(%ebp),%edi
   1962c:	8b b5 04 fe ff ff    	mov    0xfffffe04(%ebp),%esi
   19632:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
		char hmac[HMACLEN];
		char *hmac_start = lbb_get_pos(&lbb);
   19634:	8d 45 a0             	lea    0xffffffa0(%ebp),%eax
   19637:	89 04 24             	mov    %eax,(%esp,1)
   1963a:	e8 35 1e 00 00       	call   1b474 <lbb_get_pos>
   1963f:	89 45 94             	mov    %eax,0xffffff94(%ebp)
		int hmac_len = lbb_get_end(&lbb) - lbb_get_pos(&lbb);
   19642:	8d 45 a0             	lea    0xffffffa0(%ebp),%eax
   19645:	89 04 24             	mov    %eax,(%esp,1)
   19648:	e8 05 1e 00 00       	call   1b452 <lbb_get_end>
   1964d:	89 c3                	mov    %eax,%ebx
   1964f:	8d 45 a0             	lea    0xffffffa0(%ebp),%eax
   19652:	89 04 24             	mov    %eax,(%esp,1)
   19655:	e8 1a 1e 00 00       	call   1b474 <lbb_get_pos>
   1965a:	29 c3                	sub    %eax,%ebx
   1965c:	89 d8                	mov    %ebx,%eax
   1965e:	89 85 0c fe ff ff    	mov    %eax,0xfffffe0c(%ebp)
		hmac_init(&hmac_ctx);
   19664:	8d 85 20 fe ff ff    	lea    0xfffffe20(%ebp),%eax
   1966a:	89 04 24             	mov    %eax,(%esp,1)
   1966d:	e8 fc ff ff ff       	call   1966e <trickles_install_events_impl+0x330>
		hmac_update(&hmac_ctx, hmac_start, hmac_len);
   19672:	8b 85 0c fe ff ff    	mov    0xfffffe0c(%ebp),%eax
   19678:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1967c:	8b 45 94             	mov    0xffffff94(%ebp),%eax
   1967f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   19683:	8d 85 20 fe ff ff    	lea    0xfffffe20(%ebp),%eax
   19689:	89 04 24             	mov    %eax,(%esp,1)
   1968c:	e8 fc ff ff ff       	call   1968d <trickles_install_events_impl+0x34f>
		hmac_final(&hmac_ctx, hmac);
   19691:	8d 85 10 fe ff ff    	lea    0xfffffe10(%ebp),%eax
   19697:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1969b:	8d 85 20 fe ff ff    	lea    0xfffffe20(%ebp),%eax
   196a1:	89 04 24             	mov    %eax,(%esp,1)
   196a4:	e8 fc ff ff ff       	call   196a5 <trickles_install_events_impl+0x367>

		//printk("Input hmac computed on %d @%p\n", hmac_len, hmac_start);

		if(memcmp(hmac, input_hmac, HMACLEN) != 0) {
   196a9:	8d 85 10 fe ff ff    	lea    0xfffffe10(%ebp),%eax
   196af:	89 85 fc fd ff ff    	mov    %eax,0xfffffdfc(%ebp)
   196b5:	8d 55 80             	lea    0xffffff80(%ebp),%edx
   196b8:	89 95 f8 fd ff ff    	mov    %edx,0xfffffdf8(%ebp)
   196be:	c7 85 f4 fd ff ff 10 	movl   $0x10,0xfffffdf4(%ebp)
   196c5:	00 00 00 
   196c8:	fc                   	cld    
   196c9:	8b b5 fc fd ff ff    	mov    0xfffffdfc(%ebp),%esi
   196cf:	8b bd f8 fd ff ff    	mov    0xfffffdf8(%ebp),%edi
   196d5:	8b 8d f4 fd ff ff    	mov    0xfffffdf4(%ebp),%ecx
   196db:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
   196dd:	0f 97 c2             	seta   %dl
   196e0:	0f 92 c0             	setb   %al
   196e3:	28 c2                	sub    %al,%dl
   196e5:	88 d0                	mov    %dl,%al
   196e7:	0f be c0             	movsbl %al,%eax
   196ea:	85 c0                	test   %eax,%eax
   196ec:	74 1f                	je     1970d <trickles_install_events_impl+0x3cf>
			printk("input_events[%d]: Hmac verify failed\n", numCollections);
   196ee:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
   196f1:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   196f5:	c7 04 24 20 6b 00 00 	movl   $0x6b20,(%esp,1)
   196fc:	e8 fc ff ff ff       	call   196fd <trickles_install_events_impl+0x3bf>
			err = -EINVAL;
   19701:	c7 45 e4 ea ff ff ff 	movl   $0xffffffea,0xffffffe4(%ebp)
			goto out_put;
   19708:	e9 b4 02 00 00       	jmp    199c1 <trickles_install_events_impl+0x683>
		}
		if((numIn = extract_MSKs_from_lbb(sk, &new_msk_list, &hmac_ctx, &lbb)) < 0) {
   1970d:	8d 45 a0             	lea    0xffffffa0(%ebp),%eax
   19710:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   19714:	8d 85 20 fe ff ff    	lea    0xfffffe20(%ebp),%eax
   1971a:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1971e:	8d 45 c4             	lea    0xffffffc4(%ebp),%eax
   19721:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   19725:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   19728:	89 04 24             	mov    %eax,(%esp,1)
   1972b:	e8 2a 04 00 00       	call   19b5a <extract_MSKs_from_lbb>
   19730:	89 45 90             	mov    %eax,0xffffff90(%ebp)
   19733:	83 7d 90 00          	cmpl   $0x0,0xffffff90(%ebp)
   19737:	79 18                	jns    19751 <trickles_install_events_impl+0x413>
			printk("Could not extract msks\n");
   19739:	c7 04 24 46 6b 00 00 	movl   $0x6b46,(%esp,1)
   19740:	e8 fc ff ff ff       	call   19741 <trickles_install_events_impl+0x403>
			err = -EINVAL;
   19745:	c7 45 e4 ea ff ff ff 	movl   $0xffffffea,0xffffffe4(%ebp)
			goto out_put;
   1974c:	e9 70 02 00 00       	jmp    199c1 <trickles_install_events_impl+0x683>
		}
		numCollections++;
   19751:	8d 45 bc             	lea    0xffffffbc(%ebp),%eax
   19754:	ff 00                	incl   (%eax)
		inputPosition += collectionLen;
   19756:	8b 55 98             	mov    0xffffff98(%ebp),%edx
   19759:	8d 45 b8             	lea    0xffffffb8(%ebp),%eax
   1975c:	01 10                	add    %edx,(%eax)
		BUG_TRAP(inputPosition == lbb_get_pos(&lbb));
   1975e:	8d 45 a0             	lea    0xffffffa0(%ebp),%eax
   19761:	89 04 24             	mov    %eax,(%esp,1)
   19764:	e8 0b 1d 00 00       	call   1b474 <lbb_get_pos>
   19769:	39 45 b8             	cmp    %eax,0xffffffb8(%ebp)
   1976c:	74 14                	je     19782 <trickles_install_events_impl+0x444>
   1976e:	c7 44 24 04 b7 0b 00 	movl   $0xbb7,0x4(%esp,1)
   19775:	00 
   19776:	c7 04 24 60 6b 00 00 	movl   $0x6b60,(%esp,1)
   1977d:	e8 fc ff ff ff       	call   1977e <trickles_install_events_impl+0x440>
		totalNumIn += numIn;
   19782:	8b 55 90             	mov    0xffffff90(%ebp),%edx
   19785:	8d 45 b4             	lea    0xffffffb4(%ebp),%eax
   19788:	01 10                	add    %edx,(%eax)
   1978a:	e9 10 fd ff ff       	jmp    1949f <trickles_install_events_impl+0x161>
	}
	printk("%d collections processed\n", numCollections);
   1978f:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
   19792:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   19796:	c7 04 24 b9 6b 00 00 	movl   $0x6bb9,(%esp,1)
   1979d:	e8 fc ff ff ff       	call   1979e <trickles_install_events_impl+0x460>

	// List header handling is tricky. We need to put the msk on the right list depending on its current state
	while(new_msk_list.len > 0) {
   197a2:	83 7d d4 00          	cmpl   $0x0,0xffffffd4(%ebp)
   197a6:	7f 05                	jg     197ad <trickles_install_events_impl+0x46f>
   197a8:	e9 0e 02 00 00       	jmp    199bb <trickles_install_events_impl+0x67d>
		struct cminisock *relink = (struct cminisock *)new_msk_list.next;
   197ad:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   197b0:	89 85 0c fe ff ff    	mov    %eax,0xfffffe0c(%ebp)
		BUG_TRAP(relink != (struct cminisock*)&new_msk_list);
   197b6:	8d 45 c4             	lea    0xffffffc4(%ebp),%eax
   197b9:	39 85 0c fe ff ff    	cmp    %eax,0xfffffe0c(%ebp)
   197bf:	75 14                	jne    197d5 <trickles_install_events_impl+0x497>
   197c1:	c7 44 24 04 bf 0b 00 	movl   $0xbbf,0x4(%esp,1)
   197c8:	00 
   197c9:	c7 04 24 e0 6b 00 00 	movl   $0x6be0,(%esp,1)
   197d0:	e8 fc ff ff ff       	call   197d1 <trickles_install_events_impl+0x493>
		unlink((struct alloc_head*)relink);
   197d5:	8b 85 0c fe ff ff    	mov    0xfffffe0c(%ebp),%eax
   197db:	89 04 24             	mov    %eax,(%esp,1)
   197de:	e8 68 0e 00 00       	call   1a64b <unlink>

		relink->sk = sk;
   197e3:	8b 95 0c fe ff ff    	mov    0xfffffe0c(%ebp),%edx
   197e9:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   197ec:	89 42 20             	mov    %eax,0x20(%edx)
		BUG_TRAP(IS_VALID_MSK(sk, relink));
   197ef:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   197f2:	05 bc 00 00 00       	add    $0xbc,%eax
   197f7:	89 45 90             	mov    %eax,0xffffff90(%ebp)
   197fa:	c7 85 f0 fd ff ff 00 	movl   $0x0,0xfffffdf0(%ebp)
   19801:	00 00 00 
   19804:	8b 45 90             	mov    0xffffff90(%ebp),%eax
   19807:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
   1980d:	8b 50 0c             	mov    0xc(%eax),%edx
   19810:	8b 85 0c fe ff ff    	mov    0xfffffe0c(%ebp),%eax
   19816:	89 c1                	mov    %eax,%ecx
   19818:	29 d1                	sub    %edx,%ecx
   1981a:	89 ca                	mov    %ecx,%edx
   1981c:	c1 ea 02             	shr    $0x2,%edx
   1981f:	b8 21 08 82 20       	mov    $0x20820821,%eax
   19824:	f7 e2                	mul    %edx
   19826:	c1 ea 03             	shr    $0x3,%edx
   19829:	89 d0                	mov    %edx,%eax
   1982b:	c1 e0 06             	shl    $0x6,%eax
   1982e:	29 d0                	sub    %edx,%eax
   19830:	c1 e0 02             	shl    $0x2,%eax
   19833:	29 c1                	sub    %eax,%ecx
   19835:	89 c8                	mov    %ecx,%eax
   19837:	85 c0                	test   %eax,%eax
   19839:	75 51                	jne    1988c <trickles_install_events_impl+0x54e>
   1983b:	8b 45 90             	mov    0xffffff90(%ebp),%eax
   1983e:	8b 90 cc 01 00 00    	mov    0x1cc(%eax),%edx
   19844:	8b 85 0c fe ff ff    	mov    0xfffffe0c(%ebp),%eax
   1984a:	3b 42 0c             	cmp    0xc(%edx),%eax
   1984d:	72 3d                	jb     1988c <trickles_install_events_impl+0x54e>
   1984f:	8b 85 0c fe ff ff    	mov    0xfffffe0c(%ebp),%eax
   19855:	05 fc 00 00 00       	add    $0xfc,%eax
   1985a:	8b 55 90             	mov    0xffffff90(%ebp),%edx
   1985d:	8b 92 cc 01 00 00    	mov    0x1cc(%edx),%edx
   19863:	3b 42 10             	cmp    0x10(%edx),%eax
   19866:	77 24                	ja     1988c <trickles_install_events_impl+0x54e>
   19868:	8b 85 0c fe ff ff    	mov    0xfffffe0c(%ebp),%eax
   1986e:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
   19872:	74 0e                	je     19882 <trickles_install_events_impl+0x544>
   19874:	8b 85 0c fe ff ff    	mov    0xfffffe0c(%ebp),%eax
   1987a:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
   1987e:	74 02                	je     19882 <trickles_install_events_impl+0x544>
   19880:	eb 0a                	jmp    1988c <trickles_install_events_impl+0x54e>
   19882:	c7 85 f0 fd ff ff 01 	movl   $0x1,0xfffffdf0(%ebp)
   19889:	00 00 00 
   1988c:	83 bd f0 fd ff ff 00 	cmpl   $0x0,0xfffffdf0(%ebp)
   19893:	75 14                	jne    198a9 <trickles_install_events_impl+0x56b>
   19895:	c7 44 24 04 c3 0b 00 	movl   $0xbc3,0x4(%esp,1)
   1989c:	00 
   1989d:	c7 04 24 60 6c 00 00 	movl   $0x6c60,(%esp,1)
   198a4:	e8 fc ff ff ff       	call   198a5 <trickles_install_events_impl+0x567>
		switch(relink->ctl) {
   198a9:	8b 85 0c fe ff ff    	mov    0xfffffe0c(%ebp),%eax
   198af:	8b 40 0c             	mov    0xc(%eax),%eax
   198b2:	89 85 ec fd ff ff    	mov    %eax,0xfffffdec(%ebp)
   198b8:	83 bd ec fd ff ff 01 	cmpl   $0x1,0xfffffdec(%ebp)
   198bf:	74 0b                	je     198cc <trickles_install_events_impl+0x58e>
   198c1:	83 bd ec fd ff ff 04 	cmpl   $0x4,0xfffffdec(%ebp)
   198c8:	74 2d                	je     198f7 <trickles_install_events_impl+0x5b9>
   198ca:	eb 5e                	jmp    1992a <trickles_install_events_impl+0x5ec>
		case ALLOC_READY:
			insert_tail(&tp->cminisock_api_config.cfg.ctl->msk_eventlist, (struct alloc_head *)relink);
   198cc:	8b 85 0c fe ff ff    	mov    0xfffffe0c(%ebp),%eax
   198d2:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   198d6:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   198d9:	8b 80 cc 01 00 00    	mov    0x1cc(%eax),%eax
   198df:	83 c0 28             	add    $0x28,%eax
   198e2:	89 04 24             	mov    %eax,(%esp,1)
   198e5:	e8 6b 0c 00 00       	call   1a555 <insert_tail>
			new_event(sk);
   198ea:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   198ed:	89 04 24             	mov    %eax,(%esp,1)
   198f0:	e8 c3 14 00 00       	call   1adb8 <new_event>
			break;
   198f5:	eb 6a                	jmp    19961 <trickles_install_events_impl+0x623>
		case ALLOC_HALFFREE:
			printk("No reliable access path to halffree msks!!!\n");
   198f7:	c7 04 24 c0 6c 00 00 	movl   $0x6cc0,(%esp,1)
   198fe:	e8 fc ff ff ff       	call   198ff <trickles_install_events_impl+0x5c1>
			BUG();
   19903:	c7 44 24 04 59 53 00 	movl   $0x5359,0x4(%esp,1)
   1990a:	00 
   1990b:	c7 04 24 5d 53 00 00 	movl   $0x535d,(%esp,1)
   19912:	e8 fc ff ff ff       	call   19913 <trickles_install_events_impl+0x5d5>
   19917:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1991e:	e8 fc ff ff ff       	call   1991f <trickles_install_events_impl+0x5e1>
   19923:	e8 fc ff ff ff       	call   19924 <trickles_install_events_impl+0x5e6>
			// don't re-insert on list
			break;
   19928:	eb 37                	jmp    19961 <trickles_install_events_impl+0x623>
		default:
			printk("Unhandled ctl state %d in installed event\n", relink->ctl);
   1992a:	8b 85 0c fe ff ff    	mov    0xfffffe0c(%ebp),%eax
   19930:	8b 40 0c             	mov    0xc(%eax),%eax
   19933:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   19937:	c7 04 24 00 6d 00 00 	movl   $0x6d00,(%esp,1)
   1993e:	e8 fc ff ff ff       	call   1993f <trickles_install_events_impl+0x601>
			// can't use msk_force_free because we aren't on any list
			free_trickles_msk_finish(sk,relink);
   19943:	8b 85 0c fe ff ff    	mov    0xfffffe0c(%ebp),%eax
   19949:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1994d:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   19950:	89 04 24             	mov    %eax,(%esp,1)
   19953:	e8 53 8f ff ff       	call   128ab <free_trickles_msk_finish>
			err = -EINVAL;
   19958:	c7 45 e4 ea ff ff ff 	movl   $0xffffffea,0xffffffe4(%ebp)
			goto out_put;
   1995f:	eb 60                	jmp    199c1 <trickles_install_events_impl+0x683>
		}
		if(!MSK_IS_ON_VALID_LIST(tp,relink)) {
   19961:	8b 95 0c fe ff ff    	mov    0xfffffe0c(%ebp),%edx
   19967:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1996a:	05 d4 01 00 00       	add    $0x1d4,%eax
   1996f:	39 42 08             	cmp    %eax,0x8(%edx)
   19972:	0f 84 2a fe ff ff    	je     197a2 <trickles_install_events_impl+0x464>
   19978:	8b 85 0c fe ff ff    	mov    0xfffffe0c(%ebp),%eax
   1997e:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   19981:	8b 92 cc 01 00 00    	mov    0x1cc(%edx),%edx
   19987:	83 c2 28             	add    $0x28,%edx
   1998a:	39 50 08             	cmp    %edx,0x8(%eax)
   1998d:	0f 84 0f fe ff ff    	je     197a2 <trickles_install_events_impl+0x464>
			printk("Relink Msk %p not on valid list (list = %p)\n", relink, relink->list);
   19993:	8b 85 0c fe ff ff    	mov    0xfffffe0c(%ebp),%eax
   19999:	8b 40 08             	mov    0x8(%eax),%eax
   1999c:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   199a0:	8b 85 0c fe ff ff    	mov    0xfffffe0c(%ebp),%eax
   199a6:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   199aa:	c7 04 24 40 6d 00 00 	movl   $0x6d40,(%esp,1)
   199b1:	e8 fc ff ff ff       	call   199b2 <trickles_install_events_impl+0x674>
   199b6:	e9 e7 fd ff ff       	jmp    197a2 <trickles_install_events_impl+0x464>
		}
	}
	err = totalNumIn;
   199bb:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
   199be:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
 out_put:
	release_sock(sk);
   199c1:	ff 05 08 00 00 00    	incl   0x8
   199c7:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   199ca:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
   199d1:	74 0b                	je     199de <trickles_install_events_impl+0x6a0>
   199d3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   199d6:	89 04 24             	mov    %eax,(%esp,1)
   199d9:	e8 fc ff ff ff       	call   199da <trickles_install_events_impl+0x69c>
   199de:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   199e1:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
   199e8:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   199eb:	83 c0 30             	add    $0x30,%eax
   199ee:	89 04 24             	mov    %eax,(%esp,1)
   199f1:	e8 ec 02 00 00       	call   19ce2 <waitqueue_active>
   199f6:	85 c0                	test   %eax,%eax
   199f8:	74 15                	je     19a0f <trickles_install_events_impl+0x6d1>
   199fa:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   199fd:	83 c0 30             	add    $0x30,%eax
   19a00:	b9 01 00 00 00       	mov    $0x1,%ecx
   19a05:	ba 03 00 00 00       	mov    $0x3,%edx
   19a0a:	e8 fc ff ff ff       	call   19a0b <trickles_install_events_impl+0x6cd>
   19a0f:	c7 85 0c fe ff ff 08 	movl   $0x8,0xfffffe0c(%ebp)
   19a16:	00 00 00 
   19a19:	8b 85 0c fe ff ff    	mov    0xfffffe0c(%ebp),%eax
   19a1f:	ff 08                	decl   (%eax)
   19a21:	83 38 00             	cmpl   $0x0,(%eax)
   19a24:	75 10                	jne    19a36 <trickles_install_events_impl+0x6f8>
   19a26:	8b 85 0c fe ff ff    	mov    0xfffffe0c(%ebp),%eax
   19a2c:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   19a30:	0f 85 8a 28 00 00    	jne    1c2c0 <.text.lock.tmalloc+0x350>
	sockfd_put(sock);
   19a36:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   19a39:	89 04 24             	mov    %eax,(%esp,1)
   19a3c:	e8 01 1a 00 00       	call   1b442 <sockfd_put>
 out:
	if(sk) {
   19a41:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
   19a45:	0f 84 01 01 00 00    	je     19b4c <trickles_install_events_impl+0x80e>
		printk("New_msk_list = %p\n", &new_msk_list);
   19a4b:	8d 45 c4             	lea    0xffffffc4(%ebp),%eax
   19a4e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   19a52:	c7 04 24 6d 6d 00 00 	movl   $0x6d6d,(%esp,1)
   19a59:	e8 fc ff ff ff       	call   19a5a <trickles_install_events_impl+0x71c>
		if(new_msk_list.len > 0) {
   19a5e:	83 7d d4 00          	cmpl   $0x0,0xffffffd4(%ebp)
   19a62:	0f 8e ab 00 00 00    	jle    19b13 <trickles_install_events_impl+0x7d5>
			printk("Freeing msk still on new_msk_list %d\n", new_msk_list.len);
   19a68:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   19a6b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   19a6f:	c7 04 24 80 6d 00 00 	movl   $0x6d80,(%esp,1)
   19a76:	e8 fc ff ff ff       	call   19a77 <trickles_install_events_impl+0x739>
			while(new_msk_list.len > 0) {
   19a7b:	83 7d d4 00          	cmpl   $0x0,0xffffffd4(%ebp)
   19a7f:	7f 05                	jg     19a86 <trickles_install_events_impl+0x748>
   19a81:	e9 8d 00 00 00       	jmp    19b13 <trickles_install_events_impl+0x7d5>
				struct cminisock *toFree = (struct cminisock *)new_msk_list.next;
   19a86:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   19a89:	89 85 0c fe ff ff    	mov    %eax,0xfffffe0c(%ebp)
				BUG_TRAP(toFree != (struct cminisock*)&new_msk_list);
   19a8f:	8d 45 c4             	lea    0xffffffc4(%ebp),%eax
   19a92:	39 85 0c fe ff ff    	cmp    %eax,0xfffffe0c(%ebp)
   19a98:	75 14                	jne    19aae <trickles_install_events_impl+0x770>
   19a9a:	c7 44 24 04 e4 0b 00 	movl   $0xbe4,0x4(%esp,1)
   19aa1:	00 
   19aa2:	c7 04 24 20 69 00 00 	movl   $0x6920,(%esp,1)
   19aa9:	e8 fc ff ff ff       	call   19aaa <trickles_install_events_impl+0x76c>

				if(toFree->list != &new_msk_list) {
   19aae:	8b 95 0c fe ff ff    	mov    0xfffffe0c(%ebp),%edx
   19ab4:	8d 45 c4             	lea    0xffffffc4(%ebp),%eax
   19ab7:	39 42 08             	cmp    %eax,0x8(%edx)
   19aba:	74 16                	je     19ad2 <trickles_install_events_impl+0x794>
					printk("toFree Msk %p not on new_msk_list\n", toFree);
   19abc:	8b 85 0c fe ff ff    	mov    0xfffffe0c(%ebp),%eax
   19ac2:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   19ac6:	c7 04 24 c0 6d 00 00 	movl   $0x6dc0,(%esp,1)
   19acd:	e8 fc ff ff ff       	call   19ace <trickles_install_events_impl+0x790>
				}

				msk_force_free(sk,toFree);
   19ad2:	8b 85 0c fe ff ff    	mov    0xfffffe0c(%ebp),%eax
   19ad8:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   19adc:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   19adf:	89 04 24             	mov    %eax,(%esp,1)
   19ae2:	e8 c2 1e 00 00       	call   1b9a9 <msk_force_free>
				//printk("post free len = %d %d\n", new_msk_list.len, tp->cminisock_api_config.msk_freelist.len);
				BUG_TRAP(toFree->list == &tp->cminisock_api_config.msk_freelist);
   19ae7:	8b 95 0c fe ff ff    	mov    0xfffffe0c(%ebp),%edx
   19aed:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   19af0:	05 d4 01 00 00       	add    $0x1d4,%eax
   19af5:	39 42 08             	cmp    %eax,0x8(%edx)
   19af8:	74 81                	je     19a7b <trickles_install_events_impl+0x73d>
   19afa:	c7 44 24 04 ec 0b 00 	movl   $0xbec,0x4(%esp,1)
   19b01:	00 
   19b02:	c7 04 24 00 6e 00 00 	movl   $0x6e00,(%esp,1)
   19b09:	e8 fc ff ff ff       	call   19b0a <trickles_install_events_impl+0x7cc>
   19b0e:	e9 68 ff ff ff       	jmp    19a7b <trickles_install_events_impl+0x73d>
			}
		}
		printk("Free list length %d\n", tp->cminisock_api_config.msk_freelist.len);
   19b13:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   19b16:	8b 80 e4 01 00 00    	mov    0x1e4(%eax),%eax
   19b1c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   19b20:	c7 04 24 6d 6e 00 00 	movl   $0x6e6d,(%esp,1)
   19b27:	e8 fc ff ff ff       	call   19b28 <trickles_install_events_impl+0x7ea>
		printk("After insert free list length %d=>%d\n", origFreeLen, tp->cminisock_api_config.msk_freelist.len);
   19b2c:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   19b2f:	8b 80 e4 01 00 00    	mov    0x1e4(%eax),%eax
   19b35:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   19b39:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
   19b3c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   19b40:	c7 04 24 a0 6e 00 00 	movl   $0x6ea0,(%esp,1)
   19b47:	e8 fc ff ff ff       	call   19b48 <trickles_install_events_impl+0x80a>

		CHECK_INVALID_1();
	}
	return err;
   19b4c:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
}
   19b4f:	81 c4 18 02 00 00    	add    $0x218,%esp
   19b55:	5b                   	pop    %ebx
   19b56:	5e                   	pop    %esi
   19b57:	5f                   	pop    %edi
   19b58:	5d                   	pop    %ebp
   19b59:	c3                   	ret    

00019b5a <extract_MSKs_from_lbb>:

static inline
int extract_MSKs_from_lbb(struct sock *sk, struct alloc_head_list *new_msk_list,
			   struct HMAC_CTX *hmac_ctx,
			   struct linear_bounded_buffer *lbb) {
   19b5a:	55                   	push   %ebp
   19b5b:	89 e5                	mov    %esp,%ebp
   19b5d:	83 ec 2c             	sub    $0x2c,%esp
	int err;
	char *desc_end = lbb_get_end(lbb);
   19b60:	8b 45 14             	mov    0x14(%ebp),%eax
   19b63:	89 04 24             	mov    %eax,(%esp,1)
   19b66:	e8 e7 18 00 00       	call   1b452 <lbb_get_end>
   19b6b:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	int numIn = 0;
   19b6e:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)

	while((char*)lbb_get_pos(lbb) < desc_end) {
   19b75:	8b 45 14             	mov    0x14(%ebp),%eax
   19b78:	89 04 24             	mov    %eax,(%esp,1)
   19b7b:	e8 f4 18 00 00       	call   1b474 <lbb_get_pos>
   19b80:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
   19b83:	72 05                	jb     19b8a <extract_MSKs_from_lbb+0x30>
   19b85:	e9 d8 00 00 00       	jmp    19c62 <extract_MSKs_from_lbb+0x108>
		//printk("At %p < %p,%d:  ", lbb_get_pos(lbb), desc_end, lbb_get_offset(lbb));

		int foo;
		struct cminisock *msk = alloc_trickles_msk(sk);
   19b8a:	8b 45 08             	mov    0x8(%ebp),%eax
   19b8d:	89 04 24             	mov    %eax,(%esp,1)
   19b90:	e8 2c 0f 00 00       	call   1aac1 <alloc_trickles_msk>
   19b95:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
		if(msk == NULL) {
   19b98:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
   19b9c:	75 18                	jne    19bb6 <extract_MSKs_from_lbb+0x5c>
			printk("could not allocate msk\n");
   19b9e:	c7 04 24 c6 6e 00 00 	movl   $0x6ec6,(%esp,1)
   19ba5:	e8 fc ff ff ff       	call   19ba6 <extract_MSKs_from_lbb+0x4c>
			err = -ENOMEM;
   19baa:	c7 45 fc f4 ff ff ff 	movl   $0xfffffff4,0xfffffffc(%ebp)
			goto out_put;
   19bb1:	e9 00 01 00 00       	jmp    19cb6 <extract_MSKs_from_lbb+0x15c>
		}
		if(convertMSK_in(sk, NULL, msk, lbb, &foo) != 0) {
   19bb6:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
   19bb9:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   19bbd:	8b 45 14             	mov    0x14(%ebp),%eax
   19bc0:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   19bc4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   19bc7:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   19bcb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
   19bd2:	00 
   19bd3:	8b 45 08             	mov    0x8(%ebp),%eax
   19bd6:	89 04 24             	mov    %eax,(%esp,1)
   19bd9:	e8 46 dd ff ff       	call   17924 <convertMSK_in>
   19bde:	85 c0                	test   %eax,%eax
   19be0:	74 47                	je     19c29 <extract_MSKs_from_lbb+0xcf>
			printk("Input conversion failed\n");
   19be2:	c7 04 24 de 6e 00 00 	movl   $0x6ede,(%esp,1)
   19be9:	e8 fc ff ff ff       	call   19bea <extract_MSKs_from_lbb+0x90>
			/* TRICKY! At this point msk header pointers have not yet been adjusted */
			msk->prev = NULL;
   19bee:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   19bf1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			msk->next = NULL;
   19bf7:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   19bfa:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
			msk->list = NULL;
   19c01:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   19c04:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

			// can't use msk_force_free because we aren't on any list
			free_trickles_msk_finish(sk,msk);
   19c0b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   19c0e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   19c12:	8b 45 08             	mov    0x8(%ebp),%eax
   19c15:	89 04 24             	mov    %eax,(%esp,1)
   19c18:	e8 8e 8c ff ff       	call   128ab <free_trickles_msk_finish>
			err = -EINVAL;
   19c1d:	c7 45 fc ea ff ff ff 	movl   $0xffffffea,0xfffffffc(%ebp)
			goto out_put;
   19c24:	e9 8d 00 00 00       	jmp    19cb6 <extract_MSKs_from_lbb+0x15c>
		}
		msk->prev = NULL;
   19c29:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   19c2c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		msk->next = NULL;
   19c32:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   19c35:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		msk->list = NULL;
   19c3c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   19c3f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		insert_tail(new_msk_list, (struct alloc_head*)msk);
   19c46:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   19c49:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   19c4d:	8b 45 0c             	mov    0xc(%ebp),%eax
   19c50:	89 04 24             	mov    %eax,(%esp,1)
   19c53:	e8 fd 08 00 00       	call   1a555 <insert_tail>
		numIn++;
   19c58:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   19c5b:	ff 00                	incl   (%eax)
   19c5d:	e9 13 ff ff ff       	jmp    19b75 <extract_MSKs_from_lbb+0x1b>
	}

	char *actual_end = lbb_get_pos(lbb);
   19c62:	8b 45 14             	mov    0x14(%ebp),%eax
   19c65:	89 04 24             	mov    %eax,(%esp,1)
   19c68:	e8 07 18 00 00       	call   1b474 <lbb_get_pos>
   19c6d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	BUG_TRAP(actual_end <= desc_end);
   19c70:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   19c73:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
   19c76:	76 14                	jbe    19c8c <extract_MSKs_from_lbb+0x132>
   19c78:	c7 44 24 04 1d 0c 00 	movl   $0xc1d,0x4(%esp,1)
   19c7f:	00 
   19c80:	c7 04 24 00 6f 00 00 	movl   $0x6f00,(%esp,1)
   19c87:	e8 fc ff ff ff       	call   19c88 <extract_MSKs_from_lbb+0x12e>
	if(actual_end != desc_end) {
   19c8c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   19c8f:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
   19c92:	74 1a                	je     19cae <extract_MSKs_from_lbb+0x154>
		printk("actual end of descbuf does not match param passed by client: %p %p\n",
   19c94:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   19c97:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   19c9b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   19c9e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   19ca2:	c7 04 24 60 6f 00 00 	movl   $0x6f60,(%esp,1)
   19ca9:	e8 fc ff ff ff       	call   19caa <extract_MSKs_from_lbb+0x150>
		       actual_end, desc_end);
	}
	return numIn;
   19cae:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   19cb1:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   19cb4:	eb 06                	jmp    19cbc <extract_MSKs_from_lbb+0x162>
 out_put:
	return err;
   19cb6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   19cb9:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
}
   19cbc:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   19cbf:	c9                   	leave  
   19cc0:	c3                   	ret    

00019cc1 <analyze_msk_list>:

static inline int analyze_msk_list_helper(struct sock *sk, int print) {
	int numInvalid = 0;
	if(IS_TRICKLES_SERVER(sk)) {
		struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
		struct trickles_mmap_ctl *ctl = tp->cminisock_api_config.cfg.ctl;
		struct cminisock *msk;

		void *freeList = &tp->cminisock_api_config.msk_freelist;
		void *eventList = &ctl->msk_eventlist;
		for(msk = ctl->minisock_base; (void*)(msk+1) < (void*)ctl->minisock_limit; msk++) {
			char *listName = "UnknownList";
			char *ctlName = "UnknownCtl";
			if(msk->list == freeList) {
				listName = "FreeList";
			} else if(msk->list == eventList) {
				listName = "EventList";
			} else {
				numInvalid++;
			}
#define CTL_MAP(NAME) case NAME: ctlName = #NAME; break;
			switch(msk->ctl) {
				CTL_MAP(ALLOC_FREE);
				CTL_MAP(ALLOC_READY);
				CTL_MAP(ALLOC_PENDING);
				CTL_MAP(ALLOC_PROCESSING);
				CTL_MAP(ALLOC_HALFFREE);
			}
			if(print)
				printk("MSK(%p %s) is on %s (%p)\n", msk, ctlName,
				       listName, msk->list);
		}
	}
	return numInvalid;
}

void analyze_msk_list(struct sock *sk) {
   19cc1:	55                   	push   %ebp
   19cc2:	89 e5                	mov    %esp,%ebp
#if 0
	analyze_msk_list_helper(sk, 1);
#endif
}
   19cc4:	5d                   	pop    %ebp
   19cc5:	c3                   	ret    

00019cc6 <set_bit>:
 * Note that @nr may be almost arbitrarily large; this function is not
 * restricted to acting on a single-word quantity.
 */
static __inline__ void set_bit(int nr, volatile void * addr)
{
   19cc6:	55                   	push   %ebp
   19cc7:	89 e5                	mov    %esp,%ebp
	__asm__ __volatile__( LOCK_PREFIX
   19cc9:	8b 55 0c             	mov    0xc(%ebp),%edx
   19ccc:	8b 45 08             	mov    0x8(%ebp),%eax
   19ccf:	0f ab 02             	bts    %eax,(%edx)
		"btsl %1,%0"
		:"=m" (ADDR)
		:"Ir" (nr));
}
   19cd2:	5d                   	pop    %ebp
   19cd3:	c3                   	ret    

00019cd4 <clear_bit>:

/**
 * __set_bit - Set a bit in memory
 * @nr: the bit to set
 * @addr: the address to start counting from
 *
 * Unlike set_bit(), this function is non-atomic and may be reordered.
 * If it's called on the same region of memory simultaneously, the effect
 * may be that only one operation succeeds.
 */
static __inline__ void __set_bit(int nr, volatile void * addr)
{
	__asm__(
		"btsl %1,%0"
		:"=m" (ADDR)
		:"Ir" (nr));
}

/**
 * clear_bit - Clears a bit in memory
 * @nr: Bit to clear
 * @addr: Address to start counting from
 *
 * clear_bit() is atomic and may not be reordered.  However, it does
 * not contain a memory barrier, so if it is used for locking purposes,
 * you should call smp_mb__before_clear_bit() and/or smp_mb__after_clear_bit()
 * in order to ensure changes are visible on other processors.
 */
static __inline__ void clear_bit(int nr, volatile void * addr)
{
   19cd4:	55                   	push   %ebp
   19cd5:	89 e5                	mov    %esp,%ebp
	__asm__ __volatile__( LOCK_PREFIX
   19cd7:	8b 55 0c             	mov    0xc(%ebp),%edx
   19cda:	8b 45 08             	mov    0x8(%ebp),%eax
   19cdd:	0f b3 02             	btr    %eax,(%edx)
		"btrl %1,%0"
		:"=m" (ADDR)
		:"Ir" (nr));
}
   19ce0:	5d                   	pop    %ebp
   19ce1:	c3                   	ret    

00019ce2 <waitqueue_active>:
#endif
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
   19ce2:	55                   	push   %ebp
   19ce3:	89 e5                	mov    %esp,%ebp
   19ce5:	83 ec 08             	sub    $0x8,%esp
#if WAITQUEUE_DEBUG
	if (!q)
		WQ_BUG();
	CHECK_MAGIC_WQHEAD(q);
#endif

	return !list_empty(&q->task_list);
   19ce8:	8b 45 08             	mov    0x8(%ebp),%eax
   19ceb:	89 04 24             	mov    %eax,(%esp,1)
   19cee:	e8 f7 1c 00 00       	call   1b9ea <list_empty>
   19cf3:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   19cf6:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
   19cfa:	0f 94 c0             	sete   %al
   19cfd:	0f b6 c0             	movzbl %al,%eax
   19d00:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   19d03:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
   19d06:	c9                   	leave  
   19d07:	c3                   	ret    

00019d08 <atomic_sub>:
 * Atomically subtracts @i from @v.  Note that the guaranteed
 * useful range of an atomic_t is only 24 bits.
 */
static __inline__ void atomic_sub(int i, atomic_t *v)
{
   19d08:	55                   	push   %ebp
   19d09:	89 e5                	mov    %esp,%ebp
	__asm__ __volatile__(
   19d0b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   19d0e:	8b 55 08             	mov    0x8(%ebp),%edx
   19d11:	8b 45 0c             	mov    0xc(%ebp),%eax
   19d14:	29 11                	sub    %edx,(%ecx)
		LOCK "subl %1,%0"
		:"=m" (v->counter)
		:"ir" (i), "m" (v->counter));
}
   19d16:	5d                   	pop    %ebp
   19d17:	c3                   	ret    

00019d18 <atomic_inc>:

/**
 * atomic_sub_and_test - subtract value from variable and test result
 * @i: integer value to subtract
 * @v: pointer of type atomic_t
 * 
 * Atomically subtracts @i from @v and returns
 * true if the result is zero, or false for all
 * other cases.  Note that the guaranteed
 * useful range of an atomic_t is only 24 bits.
 */
static __inline__ int atomic_sub_and_test(int i, atomic_t *v)
{
	unsigned char c;

	__asm__ __volatile__(
		LOCK "subl %2,%0; sete %1"
		:"=m" (v->counter), "=qm" (c)
		:"ir" (i), "m" (v->counter) : "memory");
	return c;
}

/**
 * atomic_inc - increment atomic variable
 * @v: pointer of type atomic_t
 * 
 * Atomically increments @v by 1.  Note that the guaranteed
 * useful range of an atomic_t is only 24 bits.
 */ 
static __inline__ void atomic_inc(atomic_t *v)
{
   19d18:	55                   	push   %ebp
   19d19:	89 e5                	mov    %esp,%ebp
	__asm__ __volatile__(
   19d1b:	8b 55 08             	mov    0x8(%ebp),%edx
   19d1e:	8b 45 08             	mov    0x8(%ebp),%eax
   19d21:	ff 02                	incl   (%edx)
		LOCK "incl %0"
		:"=m" (v->counter)
		:"m" (v->counter));
}
   19d23:	5d                   	pop    %ebp
   19d24:	c3                   	ret    

00019d25 <strlen>:
}

#define __HAVE_ARCH_STRLEN
static inline size_t strlen(const char * s)
{
   19d25:	55                   	push   %ebp
   19d26:	89 e5                	mov    %esp,%ebp
   19d28:	57                   	push   %edi
   19d29:	83 ec 04             	sub    $0x4,%esp
int d0;
register int __res;
__asm__ __volatile__(
   19d2c:	8b 7d 08             	mov    0x8(%ebp),%edi
   19d2f:	b8 00 00 00 00       	mov    $0x0,%eax
   19d34:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
   19d39:	f2 ae                	repnz scas %es:(%edi),%al
   19d3b:	f7 d1                	not    %ecx
   19d3d:	49                   	dec    %ecx
   19d3e:	89 f8                	mov    %edi,%eax
   19d40:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	"repne\n\t"
	"scasb\n\t"
	"notl %0\n\t"
	"decl %0"
	:"=c" (__res), "=&D" (d0) :"1" (s),"a" (0), "0" (0xffffffff));
return __res;
   19d43:	89 c8                	mov    %ecx,%eax
}
   19d45:	83 c4 04             	add    $0x4,%esp
   19d48:	5f                   	pop    %edi
   19d49:	5d                   	pop    %ebp
   19d4a:	c3                   	ret    

00019d4b <__memcpy>:

static inline void * __memcpy(void * to, const void * from, size_t n)
{
   19d4b:	55                   	push   %ebp
   19d4c:	89 e5                	mov    %esp,%ebp
   19d4e:	57                   	push   %edi
   19d4f:	56                   	push   %esi
   19d50:	83 ec 0c             	sub    $0xc,%esp
int d0, d1, d2;
__asm__ __volatile__(
   19d53:	8b 45 10             	mov    0x10(%ebp),%eax
   19d56:	89 c1                	mov    %eax,%ecx
   19d58:	c1 e9 02             	shr    $0x2,%ecx
   19d5b:	8b 45 10             	mov    0x10(%ebp),%eax
   19d5e:	8b 7d 08             	mov    0x8(%ebp),%edi
   19d61:	8b 75 0c             	mov    0xc(%ebp),%esi
   19d64:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   19d66:	a8 02                	test   $0x2,%al
   19d68:	74 02                	je     19d6c <__memcpy+0x21>
   19d6a:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
   19d6c:	a8 01                	test   $0x1,%al
   19d6e:	74 01                	je     19d71 <__memcpy+0x26>
   19d70:	a4                   	movsb  %ds:(%esi),%es:(%edi)
   19d71:	89 c8                	mov    %ecx,%eax
   19d73:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   19d76:	89 f8                	mov    %edi,%eax
   19d78:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   19d7b:	89 f0                	mov    %esi,%eax
   19d7d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	"rep ; movsl\n\t"
	"testb $2,%b4\n\t"
	"je 1f\n\t"
	"movsw\n"
	"1:\ttestb $1,%b4\n\t"
	"je 2f\n\t"
	"movsb\n"
	"2:"
	: "=&c" (d0), "=&D" (d1), "=&S" (d2)
	:"0" (n/4), "q" (n),"1" ((long) to),"2" ((long) from)
	: "memory");
return (to);
   19d80:	8b 45 08             	mov    0x8(%ebp),%eax
}
   19d83:	83 c4 0c             	add    $0xc,%esp
   19d86:	5e                   	pop    %esi
   19d87:	5f                   	pop    %edi
   19d88:	5d                   	pop    %ebp
   19d89:	c3                   	ret    

00019d8a <__constant_c_and_count_memset>:

/*
 * This looks horribly ugly, but the compiler can optimize it totally,
 * as the count is constant.
 */
static inline void * __constant_memcpy(void * to, const void * from, size_t n)
{
	switch (n) {
		case 0:
			return to;
		case 1:
			*(unsigned char *)to = *(const unsigned char *)from;
			return to;
		case 2:
			*(unsigned short *)to = *(const unsigned short *)from;
			return to;
		case 3:
			*(unsigned short *)to = *(const unsigned short *)from;
			*(2+(unsigned char *)to) = *(2+(const unsigned char *)from);
			return to;
		case 4:
			*(unsigned long *)to = *(const unsigned long *)from;
			return to;
		case 6:	/* for Ethernet addresses */
			*(unsigned long *)to = *(const unsigned long *)from;
			*(2+(unsigned short *)to) = *(2+(const unsigned short *)from);
			return to;
		case 8:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			return to;
		case 12:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
			return to;
		case 16:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
			*(3+(unsigned long *)to) = *(3+(const unsigned long *)from);
			return to;
		case 20:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
			*(3+(unsigned long *)to) = *(3+(const unsigned long *)from);
			*(4+(unsigned long *)to) = *(4+(const unsigned long *)from);
			return to;
	}
#define COMMON(x) \
__asm__ __volatile__( \
	"rep ; movsl" \
	x \
	: "=&c" (d0), "=&D" (d1), "=&S" (d2) \
	: "0" (n/4),"1" ((long) to),"2" ((long) from) \
	: "memory");
{
	int d0, d1, d2;
	switch (n % 4) {
		case 0: COMMON(""); return to;
		case 1: COMMON("\n\tmovsb"); return to;
		case 2: COMMON("\n\tmovsw"); return to;
		default: COMMON("\n\tmovsw\n\tmovsb"); return to;
	}
}
  
#undef COMMON
}

#define __HAVE_ARCH_MEMCPY

#ifdef CONFIG_X86_USE_3DNOW

#include <asm/mmx.h>

/*
 *	This CPU favours 3DNow strongly (eg AMD Athlon)
 */

static inline void * __constant_memcpy3d(void * to, const void * from, size_t len)
{
	if (len < 512)
		return __constant_memcpy(to, from, len);
	return _mmx_memcpy(to, from, len);
}

static __inline__ void *__memcpy3d(void *to, const void *from, size_t len)
{
	if (len < 512)
		return __memcpy(to, from, len);
	return _mmx_memcpy(to, from, len);
}

#define memcpy(t, f, n) \
(__builtin_constant_p(n) ? \
 __constant_memcpy3d((t),(f),(n)) : \
 __memcpy3d((t),(f),(n)))

#else

/*
 *	No 3D Now!
 */
 
#define memcpy(t, f, n) \
(__builtin_constant_p(n) ? \
 __constant_memcpy((t),(f),(n)) : \
 __memcpy((t),(f),(n)))

#endif

/*
 * struct_cpy(x,y), copy structure *x into (matching structure) *y.
 *
 * We get link-time errors if the structure sizes do not match.
 * There is no runtime overhead, it's all optimized away at
 * compile time.
 */
extern void __struct_cpy_bug (void);

#define struct_cpy(x,y) 			\
({						\
	if (sizeof(*(x)) != sizeof(*(y))) 	\
		__struct_cpy_bug;		\
	memcpy(x, y, sizeof(*(x)));		\
})

#define __HAVE_ARCH_MEMMOVE
static inline void * memmove(void * dest,const void * src, size_t n)
{
int d0, d1, d2;
if (dest<src)
__asm__ __volatile__(
	"rep\n\t"
	"movsb"
	: "=&c" (d0), "=&S" (d1), "=&D" (d2)
	:"0" (n),"1" (src),"2" (dest)
	: "memory");
else
__asm__ __volatile__(
	"std\n\t"
	"rep\n\t"
	"movsb\n\t"
	"cld"
	: "=&c" (d0), "=&S" (d1), "=&D" (d2)
	:"0" (n),
	 "1" (n-1+(const char *)src),
	 "2" (n-1+(char *)dest)
	:"memory");
return dest;
}

#define memcmp __builtin_memcmp

#define __HAVE_ARCH_MEMCHR
static inline void * memchr(const void * cs,int c,size_t count)
{
int d0;
register void * __res;
if (!count)
	return NULL;
__asm__ __volatile__(
	"repne\n\t"
	"scasb\n\t"
	"je 1f\n\t"
	"movl $1,%0\n"
	"1:\tdecl %0"
	:"=D" (__res), "=&c" (d0) : "a" (c),"0" (cs),"1" (count));
return __res;
}

static inline void * __memset_generic(void * s, char c,size_t count)
{
int d0, d1;
__asm__ __volatile__(
	"rep\n\t"
	"stosb"
	: "=&c" (d0), "=&D" (d1)
	:"a" (c),"1" (s),"0" (count)
	:"memory");
return s;
}

/* we might want to write optimized versions of these later */
#define __constant_count_memset(s,c,count) __memset_generic((s),(c),(count))

/*
 * memset(x,0,y) is a reasonably common thing to do, so we want to fill
 * things 32 bits at a time even when we don't know the size of the
 * area at compile-time..
 */
static inline void * __constant_c_memset(void * s, unsigned long c, size_t count)
{
int d0, d1;
__asm__ __volatile__(
	"rep ; stosl\n\t"
	"testb $2,%b3\n\t"
	"je 1f\n\t"
	"stosw\n"
	"1:\ttestb $1,%b3\n\t"
	"je 2f\n\t"
	"stosb\n"
	"2:"
	: "=&c" (d0), "=&D" (d1)
	:"a" (c), "q" (count), "0" (count/4), "1" ((long) s)
	:"memory");
return (s);	
}

/* Added by Gertjan van Wingerde to make minix and sysv module work */
#define __HAVE_ARCH_STRNLEN
static inline size_t strnlen(const char * s, size_t count)
{
int d0;
register int __res;
__asm__ __volatile__(
	"movl %2,%0\n\t"
	"jmp 2f\n"
	"1:\tcmpb $0,(%0)\n\t"
	"je 3f\n\t"
	"incl %0\n"
	"2:\tdecl %1\n\t"
	"cmpl $-1,%1\n\t"
	"jne 1b\n"
	"3:\tsubl %2,%0"
	:"=a" (__res), "=&d" (d0)
	:"c" (s),"1" (count));
return __res;
}
/* end of additional stuff */

#define __HAVE_ARCH_STRSTR

extern char *strstr(const char *cs, const char *ct);

/*
 * This looks horribly ugly, but the compiler can optimize it totally,
 * as we by now know that both pattern and count is constant..
 */
static inline void * __constant_c_and_count_memset(void * s, unsigned long pattern, size_t count)
{
   19d8a:	55                   	push   %ebp
   19d8b:	89 e5                	mov    %esp,%ebp
   19d8d:	57                   	push   %edi
   19d8e:	83 ec 10             	sub    $0x10,%esp
	switch (count) {
   19d91:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
   19d95:	77 74                	ja     19e0b <__constant_c_and_count_memset+0x81>
   19d97:	8b 45 10             	mov    0x10(%ebp),%eax
   19d9a:	c1 e0 02             	shl    $0x2,%eax
   19d9d:	8b 80 a4 6f 00 00    	mov    0x6fa4(%eax),%eax
   19da3:	ff e0                	jmp    *%eax
		case 0:
			return s;
   19da5:	8b 45 08             	mov    0x8(%ebp),%eax
   19da8:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   19dab:	e9 04 01 00 00       	jmp    19eb4 <__constant_c_and_count_memset+0x12a>
		case 1:
			*(unsigned char *)s = pattern;
   19db0:	8b 45 08             	mov    0x8(%ebp),%eax
   19db3:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
   19db7:	88 10                	mov    %dl,(%eax)
			return s;
   19db9:	8b 45 08             	mov    0x8(%ebp),%eax
   19dbc:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   19dbf:	e9 f0 00 00 00       	jmp    19eb4 <__constant_c_and_count_memset+0x12a>
		case 2:
			*(unsigned short *)s = pattern;
   19dc4:	8b 45 08             	mov    0x8(%ebp),%eax
   19dc7:	8b 55 0c             	mov    0xc(%ebp),%edx
   19dca:	66 89 10             	mov    %dx,(%eax)
			return s;
   19dcd:	8b 45 08             	mov    0x8(%ebp),%eax
   19dd0:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   19dd3:	e9 dc 00 00 00       	jmp    19eb4 <__constant_c_and_count_memset+0x12a>
		case 3:
			*(unsigned short *)s = pattern;
   19dd8:	8b 55 08             	mov    0x8(%ebp),%edx
   19ddb:	8b 45 0c             	mov    0xc(%ebp),%eax
   19dde:	66 89 02             	mov    %ax,(%edx)
			*(2+(unsigned char *)s) = pattern;
   19de1:	8b 55 08             	mov    0x8(%ebp),%edx
   19de4:	83 c2 02             	add    $0x2,%edx
   19de7:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
   19deb:	88 02                	mov    %al,(%edx)
			return s;
   19ded:	8b 45 08             	mov    0x8(%ebp),%eax
   19df0:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   19df3:	e9 bc 00 00 00       	jmp    19eb4 <__constant_c_and_count_memset+0x12a>
		case 4:
			*(unsigned long *)s = pattern;
   19df8:	8b 45 08             	mov    0x8(%ebp),%eax
   19dfb:	8b 55 0c             	mov    0xc(%ebp),%edx
   19dfe:	89 10                	mov    %edx,(%eax)
			return s;
   19e00:	8b 45 08             	mov    0x8(%ebp),%eax
   19e03:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   19e06:	e9 a9 00 00 00       	jmp    19eb4 <__constant_c_and_count_memset+0x12a>
	}
#define COMMON(x) \
__asm__  __volatile__( \
	"rep ; stosl" \
	x \
	: "=&c" (d0), "=&D" (d1) \
	: "a" (pattern),"0" (count/4),"1" ((long) s) \
	: "memory")
{
	int d0, d1;
	switch (count % 4) {
   19e0b:	8b 45 10             	mov    0x10(%ebp),%eax
   19e0e:	83 e0 03             	and    $0x3,%eax
   19e11:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   19e14:	83 7d ec 01          	cmpl   $0x1,0xffffffec(%ebp)
   19e18:	74 30                	je     19e4a <__constant_c_and_count_memset+0xc0>
   19e1a:	83 7d ec 01          	cmpl   $0x1,0xffffffec(%ebp)
   19e1e:	72 08                	jb     19e28 <__constant_c_and_count_memset+0x9e>
   19e20:	83 7d ec 02          	cmpl   $0x2,0xffffffec(%ebp)
   19e24:	74 47                	je     19e6d <__constant_c_and_count_memset+0xe3>
   19e26:	eb 69                	jmp    19e91 <__constant_c_and_count_memset+0x107>
		case 0: COMMON(""); return s;
   19e28:	8b 45 0c             	mov    0xc(%ebp),%eax
   19e2b:	8b 55 10             	mov    0x10(%ebp),%edx
   19e2e:	89 d1                	mov    %edx,%ecx
   19e30:	c1 e9 02             	shr    $0x2,%ecx
   19e33:	8b 7d 08             	mov    0x8(%ebp),%edi
   19e36:	f3 ab                	repz stos %eax,%es:(%edi)
   19e38:	89 c8                	mov    %ecx,%eax
   19e3a:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   19e3d:	89 f8                	mov    %edi,%eax
   19e3f:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   19e42:	8b 45 08             	mov    0x8(%ebp),%eax
   19e45:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   19e48:	eb 6a                	jmp    19eb4 <__constant_c_and_count_memset+0x12a>
		case 1: COMMON("\n\tstosb"); return s;
   19e4a:	8b 45 0c             	mov    0xc(%ebp),%eax
   19e4d:	8b 55 10             	mov    0x10(%ebp),%edx
   19e50:	89 d1                	mov    %edx,%ecx
   19e52:	c1 e9 02             	shr    $0x2,%ecx
   19e55:	8b 7d 08             	mov    0x8(%ebp),%edi
   19e58:	f3 ab                	repz stos %eax,%es:(%edi)
   19e5a:	aa                   	stos   %al,%es:(%edi)
   19e5b:	89 c8                	mov    %ecx,%eax
   19e5d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   19e60:	89 f8                	mov    %edi,%eax
   19e62:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   19e65:	8b 45 08             	mov    0x8(%ebp),%eax
   19e68:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   19e6b:	eb 47                	jmp    19eb4 <__constant_c_and_count_memset+0x12a>
		case 2: COMMON("\n\tstosw"); return s;
   19e6d:	8b 45 0c             	mov    0xc(%ebp),%eax
   19e70:	8b 55 10             	mov    0x10(%ebp),%edx
   19e73:	89 d1                	mov    %edx,%ecx
   19e75:	c1 e9 02             	shr    $0x2,%ecx
   19e78:	8b 7d 08             	mov    0x8(%ebp),%edi
   19e7b:	f3 ab                	repz stos %eax,%es:(%edi)
   19e7d:	66 ab                	stos   %ax,%es:(%edi)
   19e7f:	89 c8                	mov    %ecx,%eax
   19e81:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   19e84:	89 f8                	mov    %edi,%eax
   19e86:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   19e89:	8b 45 08             	mov    0x8(%ebp),%eax
   19e8c:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   19e8f:	eb 23                	jmp    19eb4 <__constant_c_and_count_memset+0x12a>
		default: COMMON("\n\tstosw\n\tstosb"); return s;
   19e91:	8b 45 0c             	mov    0xc(%ebp),%eax
   19e94:	8b 55 10             	mov    0x10(%ebp),%edx
   19e97:	89 d1                	mov    %edx,%ecx
   19e99:	c1 e9 02             	shr    $0x2,%ecx
   19e9c:	8b 7d 08             	mov    0x8(%ebp),%edi
   19e9f:	f3 ab                	repz stos %eax,%es:(%edi)
   19ea1:	66 ab                	stos   %ax,%es:(%edi)
   19ea3:	aa                   	stos   %al,%es:(%edi)
   19ea4:	89 c8                	mov    %ecx,%eax
   19ea6:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   19ea9:	89 f8                	mov    %edi,%eax
   19eab:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   19eae:	8b 45 08             	mov    0x8(%ebp),%eax
   19eb1:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	}
}
  
#undef COMMON
}
   19eb4:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   19eb7:	83 c4 10             	add    $0x10,%esp
   19eba:	5f                   	pop    %edi
   19ebb:	5d                   	pop    %ebp
   19ebc:	c3                   	ret    

00019ebd <locks_verify_area>:

static inline int locks_verify_area(int read_write, struct inode *inode,
				    struct file *filp, loff_t offset,
				    size_t count)
{
   19ebd:	55                   	push   %ebp
   19ebe:	89 e5                	mov    %esp,%ebp
   19ec0:	83 ec 24             	sub    $0x24,%esp
   19ec3:	8b 45 14             	mov    0x14(%ebp),%eax
   19ec6:	8b 55 18             	mov    0x18(%ebp),%edx
   19ec9:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   19ecc:	89 55 fc             	mov    %edx,0xfffffffc(%ebp)
	if (inode->i_flock && MANDATORY_LOCK(inode))
   19ecf:	8b 45 0c             	mov    0xc(%ebp),%eax
   19ed2:	83 b8 ac 00 00 00 00 	cmpl   $0x0,0xac(%eax)
   19ed9:	74 58                	je     19f33 <locks_verify_area+0x76>
   19edb:	8b 45 0c             	mov    0xc(%ebp),%eax
   19ede:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   19ee4:	8b 40 2c             	mov    0x2c(%eax),%eax
   19ee7:	83 e0 40             	and    $0x40,%eax
   19eea:	85 c0                	test   %eax,%eax
   19eec:	74 45                	je     19f33 <locks_verify_area+0x76>
   19eee:	8b 45 0c             	mov    0xc(%ebp),%eax
   19ef1:	0f b7 40 32          	movzwl 0x32(%eax),%eax
   19ef5:	25 08 04 00 00       	and    $0x408,%eax
   19efa:	66 3d 00 04          	cmp    $0x400,%ax
   19efe:	75 33                	jne    19f33 <locks_verify_area+0x76>
		return locks_mandatory_area(read_write, inode, filp, offset, count);
   19f00:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19f03:	89 44 24 14          	mov    %eax,0x14(%esp,1)
   19f07:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   19f0a:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   19f0d:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   19f11:	89 54 24 10          	mov    %edx,0x10(%esp,1)
   19f15:	8b 45 10             	mov    0x10(%ebp),%eax
   19f18:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   19f1c:	8b 45 0c             	mov    0xc(%ebp),%eax
   19f1f:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   19f23:	8b 45 08             	mov    0x8(%ebp),%eax
   19f26:	89 04 24             	mov    %eax,(%esp,1)
   19f29:	e8 fc ff ff ff       	call   19f2a <locks_verify_area+0x6d>
   19f2e:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   19f31:	eb 07                	jmp    19f3a <locks_verify_area+0x7d>
	return 0;
   19f33:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
}
   19f3a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   19f3d:	c9                   	leave  
   19f3e:	c3                   	ret    

00019f3f <get_current>:

struct task_struct;

static inline struct task_struct * get_current(void)
{
   19f3f:	55                   	push   %ebp
   19f40:	89 e5                	mov    %esp,%ebp
   19f42:	83 ec 04             	sub    $0x4,%esp
	struct task_struct *current;
	__asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
   19f45:	b8 00 e0 ff ff       	mov    $0xffffe000,%eax
   19f4a:	21 e0                	and    %esp,%eax
   19f4c:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	return current;
   19f4f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
 }
   19f52:	c9                   	leave  
   19f53:	c3                   	ret    

00019f54 <signal_pending>:
extern int do_sigaction(int, const struct k_sigaction *, struct k_sigaction *);
extern int do_sigaltstack(const stack_t *, stack_t *, unsigned long);

static inline int signal_pending(struct task_struct *p)
{
   19f54:	55                   	push   %ebp
   19f55:	89 e5                	mov    %esp,%ebp
	return (p->sigpending != 0);
   19f57:	8b 45 08             	mov    0x8(%ebp),%eax
   19f5a:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
   19f5e:	0f 95 c0             	setne  %al
   19f61:	0f b6 c0             	movzbl %al,%eax
}
   19f64:	5d                   	pop    %ebp
   19f65:	c3                   	ret    

00019f66 <pgd_none>:
 * The "pgd_xxx()" functions here are trivial for a folded two-level
 * setup: the pgd is never bad, and a pmd always exists (as it's folded
 * into the pgd entry)
 */
static inline int pgd_none(pgd_t pgd)		{ return 0; }
   19f66:	55                   	push   %ebp
   19f67:	89 e5                	mov    %esp,%ebp
   19f69:	b8 00 00 00 00       	mov    $0x0,%eax
   19f6e:	5d                   	pop    %ebp
   19f6f:	c3                   	ret    

00019f70 <pmd_offset>:
static inline int pgd_bad(pgd_t pgd)		{ return 0; }
static inline int pgd_present(pgd_t pgd)	{ return 1; }
#define pgd_clear(xp)				do { } while (0)

/*
 * Certain architectures need to do special things when PTEs
 * within a page table are directly modified.  Thus, the following
 * hook is made available.
 */
#define set_pte(pteptr, pteval) (*(pteptr) = pteval)
#define set_pte_atomic(pteptr, pteval) (*(pteptr) = pteval)

/*
 * (pmds are folded into pgds so this doesnt get actually called,
 * but the define is needed for a generic inline function.)
 */
#define set_pmd(pmdptr, pmdval) (*(pmdptr) = pmdval)
#define set_pgd(pgdptr, pgdval) (*(pgdptr) = pgdval)

#define pgd_page(pgd) \
((unsigned long) __va(pgd_val(pgd) & PAGE_MASK))

static inline pmd_t * pmd_offset(pgd_t * dir, unsigned long address)
{
   19f70:	55                   	push   %ebp
   19f71:	89 e5                	mov    %esp,%ebp
	return (pmd_t *) dir;
   19f73:	8b 45 08             	mov    0x8(%ebp),%eax
}
   19f76:	5d                   	pop    %ebp
   19f77:	c3                   	ret    

00019f78 <page_zone>:
struct zone_struct;
extern struct zone_struct *zone_table[];

static inline zone_t *page_zone(struct page *page)
{
   19f78:	55                   	push   %ebp
   19f79:	89 e5                	mov    %esp,%ebp
	return zone_table[page->flags >> ZONE_SHIFT];
   19f7b:	8b 45 08             	mov    0x8(%ebp),%eax
   19f7e:	8b 40 18             	mov    0x18(%eax),%eax
   19f81:	c1 e8 18             	shr    $0x18,%eax
   19f84:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
}
   19f8b:	5d                   	pop    %ebp
   19f8c:	c3                   	ret    

00019f8d <skb_queue_empty>:
 *	Returns true if the queue is empty, false otherwise.
 */
 
static inline int skb_queue_empty(struct sk_buff_head *list)
{
   19f8d:	55                   	push   %ebp
   19f8e:	89 e5                	mov    %esp,%ebp
	return (list->next == (struct sk_buff *) list);
   19f90:	8b 45 08             	mov    0x8(%ebp),%eax
   19f93:	8b 00                	mov    (%eax),%eax
   19f95:	3b 45 08             	cmp    0x8(%ebp),%eax
   19f98:	0f 94 c0             	sete   %al
   19f9b:	0f b6 c0             	movzbl %al,%eax
}
   19f9e:	5d                   	pop    %ebp
   19f9f:	c3                   	ret    

00019fa0 <kfree_skb>:

/**
 *	skb_get - reference buffer
 *	@skb: buffer to reference
 *
 *	Makes another reference to a socket buffer and returns a pointer
 *	to the buffer.
 */
 
static inline struct sk_buff *skb_get(struct sk_buff *skb)
{
	atomic_inc(&skb->users);
	return skb;
}

/*
 * If users==1, we are the only owner and are can avoid redundant
 * atomic change.
 */
 
/**
 *	kfree_skb - free an sk_buff
 *	@skb: buffer to free
 *
 *	Drop a reference to the buffer and free it if the usage count has
 *	hit zero.
 */
 
static inline void kfree_skb(struct sk_buff *skb)
{
   19fa0:	55                   	push   %ebp
   19fa1:	89 e5                	mov    %esp,%ebp
   19fa3:	83 ec 04             	sub    $0x4,%esp
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
   19fa6:	8b 45 08             	mov    0x8(%ebp),%eax
   19fa9:	05 a8 00 00 00       	add    $0xa8,%eax
   19fae:	8b 00                	mov    (%eax),%eax
   19fb0:	83 f8 01             	cmp    $0x1,%eax
   19fb3:	74 16                	je     19fcb <kfree_skb+0x2b>
   19fb5:	8b 45 08             	mov    0x8(%ebp),%eax
   19fb8:	05 a8 00 00 00       	add    $0xa8,%eax
   19fbd:	89 04 24             	mov    %eax,(%esp,1)
   19fc0:	e8 8b 1a 00 00       	call   1ba50 <atomic_dec_and_test>
   19fc5:	85 c0                	test   %eax,%eax
   19fc7:	75 02                	jne    19fcb <kfree_skb+0x2b>
   19fc9:	eb 0b                	jmp    19fd6 <kfree_skb+0x36>
		__kfree_skb(skb);
   19fcb:	8b 45 08             	mov    0x8(%ebp),%eax
   19fce:	89 04 24             	mov    %eax,(%esp,1)
   19fd1:	e8 fc ff ff ff       	call   19fd2 <kfree_skb+0x32>
}
   19fd6:	c9                   	leave  
   19fd7:	c3                   	ret    

00019fd8 <skb_queue_len>:

/* Use this if you didn't touch the skb state [for fast switching] */
static inline void kfree_skb_fast(struct sk_buff *skb)
{
	if (atomic_read(&skb->users) == 1 || atomic_dec_and_test(&skb->users))
		kfree_skbmem(skb);	
}

/**
 *	skb_cloned - is the buffer a clone
 *	@skb: buffer to check
 *
 *	Returns true if the buffer was generated with skb_clone() and is
 *	one of multiple shared copies of the buffer. Cloned buffers are
 *	shared data so must not be written to under normal circumstances.
 */

static inline int skb_cloned(struct sk_buff *skb)
{
	return skb->cloned && atomic_read(&skb_shinfo(skb)->dataref) != 1;
}

/**
 *	skb_shared - is the buffer shared
 *	@skb: buffer to check
 *
 *	Returns true if more than one person has a reference to this
 *	buffer.
 */
 
static inline int skb_shared(struct sk_buff *skb)
{
	return (atomic_read(&skb->users) != 1);
}

/** 
 *	skb_share_check - check if buffer is shared and if so clone it
 *	@skb: buffer to check
 *	@pri: priority for memory allocation
 *	
 *	If the buffer is shared the buffer is cloned and the old copy
 *	drops a reference. A new clone with a single reference is returned.
 *	If the buffer is not shared the original buffer is returned. When
 *	being called from interrupt status or with spinlocks held pri must
 *	be GFP_ATOMIC.
 *
 *	NULL is returned on a memory allocation failure.
 */
 
static inline struct sk_buff *skb_share_check(struct sk_buff *skb, int pri)
{
	if (skb_shared(skb)) {
		struct sk_buff *nskb;
		nskb = skb_clone(skb, pri);
		kfree_skb(skb);
		return nskb;
	}
	return skb;
}


/*
 *	Copy shared buffers into a new sk_buff. We effectively do COW on
 *	packets to handle cases where we have a local reader and forward
 *	and a couple of other messy ones. The normal one is tcpdumping
 *	a packet thats being forwarded.
 */
 
/**
 *	skb_unshare - make a copy of a shared buffer
 *	@skb: buffer to check
 *	@pri: priority for memory allocation
 *
 *	If the socket buffer is a clone then this function creates a new
 *	copy of the data, drops a reference count on the old copy and returns
 *	the new copy with the reference count at 1. If the buffer is not a clone
 *	the original buffer is returned. When called with a spinlock held or
 *	from interrupt state @pri must be %GFP_ATOMIC
 *
 *	%NULL is returned on a memory allocation failure.
 */
 
static inline struct sk_buff *skb_unshare(struct sk_buff *skb, int pri)
{
	struct sk_buff *nskb;
	if(!skb_cloned(skb))
		return skb;
	nskb=skb_copy(skb, pri);
	kfree_skb(skb);		/* Free our shared copy */
	return nskb;
}

/**
 *	skb_peek
 *	@list_: list to peek at
 *
 *	Peek an &sk_buff. Unlike most other operations you _MUST_
 *	be careful with this one. A peek leaves the buffer on the
 *	list and someone else may run off with it. You must hold
 *	the appropriate locks or have a private queue to do this.
 *
 *	Returns %NULL for an empty list or a pointer to the head element.
 *	The reference count is not incremented and the reference is therefore
 *	volatile. Use with caution.
 */
 
static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
{
	struct sk_buff *list = ((struct sk_buff *)list_)->next;
	if (list == (struct sk_buff *)list_)
		list = NULL;
	return list;
}

/**
 *	skb_peek_tail
 *	@list_: list to peek at
 *
 *	Peek an &sk_buff. Unlike most other operations you _MUST_
 *	be careful with this one. A peek leaves the buffer on the
 *	list and someone else may run off with it. You must hold
 *	the appropriate locks or have a private queue to do this.
 *
 *	Returns %NULL for an empty list or a pointer to the tail element.
 *	The reference count is not incremented and the reference is therefore
 *	volatile. Use with caution.
 */

static inline struct sk_buff *skb_peek_tail(struct sk_buff_head *list_)
{
	struct sk_buff *list = ((struct sk_buff *)list_)->prev;
	if (list == (struct sk_buff *)list_)
		list = NULL;
	return list;
}

/**
 *	skb_queue_len	- get queue length
 *	@list_: list to measure
 *
 *	Return the length of an &sk_buff queue. 
 */
 
static inline __u32 skb_queue_len(struct sk_buff_head *list_)
{
   19fd8:	55                   	push   %ebp
   19fd9:	89 e5                	mov    %esp,%ebp
	return(list_->qlen);
   19fdb:	8b 45 08             	mov    0x8(%ebp),%eax
   19fde:	8b 40 08             	mov    0x8(%eax),%eax
}
   19fe1:	5d                   	pop    %ebp
   19fe2:	c3                   	ret    

00019fe3 <__skb_queue_tail>:

static inline void skb_queue_head_init(struct sk_buff_head *list)
{
	spin_lock_init(&list->lock);
	list->prev = (struct sk_buff *)list;
	list->next = (struct sk_buff *)list;
	list->qlen = 0;
}

/*
 *	Insert an sk_buff at the start of a list.
 *
 *	The "__skb_xxxx()" functions are the non-atomic ones that
 *	can only be called with interrupts disabled.
 */

/**
 *	__skb_queue_head - queue a buffer at the list head
 *	@list: list to use
 *	@newsk: buffer to queue
 *
 *	Queue a buffer at the start of a list. This function takes no locks
 *	and you must therefore hold required locks before calling it.
 *
 *	A buffer cannot be placed on two lists at the same time.
 */	
 
static inline void __skb_queue_head(struct sk_buff_head *list, struct sk_buff *newsk)
{
	struct sk_buff *prev, *next;

	newsk->list = list;
	list->qlen++;
	prev = (struct sk_buff *)list;
	next = prev->next;
	newsk->next = next;
	newsk->prev = prev;
	next->prev = newsk;
	prev->next = newsk;
}


/**
 *	skb_queue_head - queue a buffer at the list head
 *	@list: list to use
 *	@newsk: buffer to queue
 *
 *	Queue a buffer at the start of the list. This function takes the
 *	list lock and can be used safely with other locking &sk_buff functions
 *	safely.
 *
 *	A buffer cannot be placed on two lists at the same time.
 */	

static inline void skb_queue_head(struct sk_buff_head *list, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&list->lock, flags);
	__skb_queue_head(list, newsk);
	spin_unlock_irqrestore(&list->lock, flags);
}

/**
 *	__skb_queue_tail - queue a buffer at the list tail
 *	@list: list to use
 *	@newsk: buffer to queue
 *
 *	Queue a buffer at the end of a list. This function takes no locks
 *	and you must therefore hold required locks before calling it.
 *
 *	A buffer cannot be placed on two lists at the same time.
 */	
 

static inline void __skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
   19fe3:	55                   	push   %ebp
   19fe4:	89 e5                	mov    %esp,%ebp
   19fe6:	83 ec 08             	sub    $0x8,%esp
	struct sk_buff *prev, *next;

	newsk->list = list;
   19fe9:	8b 55 0c             	mov    0xc(%ebp),%edx
   19fec:	8b 45 08             	mov    0x8(%ebp),%eax
   19fef:	89 42 08             	mov    %eax,0x8(%edx)
	list->qlen++;
   19ff2:	8b 45 08             	mov    0x8(%ebp),%eax
   19ff5:	ff 40 08             	incl   0x8(%eax)
	next = (struct sk_buff *)list;
   19ff8:	8b 45 08             	mov    0x8(%ebp),%eax
   19ffb:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	prev = next->prev;
   19ffe:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1a001:	8b 40 04             	mov    0x4(%eax),%eax
   1a004:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	newsk->next = next;
   1a007:	8b 55 0c             	mov    0xc(%ebp),%edx
   1a00a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1a00d:	89 02                	mov    %eax,(%edx)
	newsk->prev = prev;
   1a00f:	8b 55 0c             	mov    0xc(%ebp),%edx
   1a012:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1a015:	89 42 04             	mov    %eax,0x4(%edx)
	next->prev = newsk;
   1a018:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   1a01b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a01e:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = newsk;
   1a021:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1a024:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a027:	89 02                	mov    %eax,(%edx)
}
   1a029:	c9                   	leave  
   1a02a:	c3                   	ret    

0001a02b <__skb_dequeue>:

/**
 *	skb_queue_tail - queue a buffer at the list tail
 *	@list: list to use
 *	@newsk: buffer to queue
 *
 *	Queue a buffer at the tail of the list. This function takes the
 *	list lock and can be used safely with other locking &sk_buff functions
 *	safely.
 *
 *	A buffer cannot be placed on two lists at the same time.
 */	

static inline void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&list->lock, flags);
	__skb_queue_tail(list, newsk);
	spin_unlock_irqrestore(&list->lock, flags);
}

/**
 *	__skb_dequeue - remove from the head of the queue
 *	@list: list to dequeue from
 *
 *	Remove the head of the list. This function does not take any locks
 *	so must be used with appropriate locks held only. The head item is
 *	returned or %NULL if the list is empty.
 */

static inline struct sk_buff *__skb_dequeue(struct sk_buff_head *list)
{
   1a02b:	55                   	push   %ebp
   1a02c:	89 e5                	mov    %esp,%ebp
   1a02e:	83 ec 0c             	sub    $0xc,%esp
	struct sk_buff *next, *prev, *result;

	prev = (struct sk_buff *) list;
   1a031:	8b 45 08             	mov    0x8(%ebp),%eax
   1a034:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	next = prev->next;
   1a037:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1a03a:	8b 00                	mov    (%eax),%eax
   1a03c:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	result = NULL;
   1a03f:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
	if (next != prev) {
   1a046:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1a049:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
   1a04c:	74 42                	je     1a090 <__skb_dequeue+0x65>
		result = next;
   1a04e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1a051:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		next = next->next;
   1a054:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1a057:	8b 00                	mov    (%eax),%eax
   1a059:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
		list->qlen--;
   1a05c:	8b 45 08             	mov    0x8(%ebp),%eax
   1a05f:	ff 48 08             	decl   0x8(%eax)
		next->prev = prev;
   1a062:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1a065:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1a068:	89 42 04             	mov    %eax,0x4(%edx)
		prev->next = next;
   1a06b:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   1a06e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1a071:	89 02                	mov    %eax,(%edx)
		result->next = NULL;
   1a073:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1a076:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		result->prev = NULL;
   1a07c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1a07f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		result->list = NULL;
   1a086:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1a089:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	}
	return result;
   1a090:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
}
   1a093:	c9                   	leave  
   1a094:	c3                   	ret    

0001a095 <skb_put>:

/**
 *	skb_dequeue - remove from the head of the queue
 *	@list: list to dequeue from
 *
 *	Remove the head of the list. The list lock is taken so the function
 *	may be used safely with other locking list functions. The head item is
 *	returned or %NULL if the list is empty.
 */

static inline struct sk_buff *skb_dequeue(struct sk_buff_head *list)
{
	unsigned long flags;
	struct sk_buff *result;

	spin_lock_irqsave(&list->lock, flags);
	result = __skb_dequeue(list);
	spin_unlock_irqrestore(&list->lock, flags);
	return result;
}

/*
 *	Insert a packet on a list.
 */

static inline void __skb_insert(struct sk_buff *newsk,
	struct sk_buff * prev, struct sk_buff *next,
	struct sk_buff_head * list)
{
	newsk->next = next;
	newsk->prev = prev;
	next->prev = newsk;
	prev->next = newsk;
	newsk->list = list;
	list->qlen++;
}

/**
 *	skb_insert	-	insert a buffer
 *	@old: buffer to insert before
 *	@newsk: buffer to insert
 *
 *	Place a packet before a given packet in a list. The list locks are taken
 *	and this function is atomic with respect to other list locked calls
 *	A buffer cannot be placed on two lists at the same time.
 */

static inline void skb_insert(struct sk_buff *old, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&old->list->lock, flags);
	__skb_insert(newsk, old->prev, old, old->list);
	spin_unlock_irqrestore(&old->list->lock, flags);
}

/*
 *	Place a packet after a given packet in a list.
 */

static inline void __skb_append(struct sk_buff *old, struct sk_buff *newsk)
{
	__skb_insert(newsk, old, old->next, old->list);
}

/**
 *	skb_append	-	append a buffer
 *	@old: buffer to insert after
 *	@newsk: buffer to insert
 *
 *	Place a packet after a given packet in a list. The list locks are taken
 *	and this function is atomic with respect to other list locked calls.
 *	A buffer cannot be placed on two lists at the same time.
 */


static inline void skb_append(struct sk_buff *old, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&old->list->lock, flags);
	__skb_append(old, newsk);
	spin_unlock_irqrestore(&old->list->lock, flags);
}

/*
 * remove sk_buff from list. _Must_ be called atomically, and with
 * the list known..
 */
 
static inline void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
{
	struct sk_buff * next, * prev;

	list->qlen--;
	next = skb->next;
	prev = skb->prev;
	skb->next = NULL;
	skb->prev = NULL;
	skb->list = NULL;
	next->prev = prev;
	prev->next = next;
}

/**
 *	skb_unlink	-	remove a buffer from a list
 *	@skb: buffer to remove
 *
 *	Place a packet after a given packet in a list. The list locks are taken
 *	and this function is atomic with respect to other list locked calls
 *	
 *	Works even without knowing the list it is sitting on, which can be 
 *	handy at times. It also means that THE LIST MUST EXIST when you 
 *	unlink. Thus a list must have its contents unlinked before it is
 *	destroyed.
 */

static inline void skb_unlink(struct sk_buff *skb)
{
	struct sk_buff_head *list = skb->list;

	if(list) {
		unsigned long flags;

		spin_lock_irqsave(&list->lock, flags);
		if(skb->list == list)
			__skb_unlink(skb, skb->list);
		spin_unlock_irqrestore(&list->lock, flags);
	}
}

/* XXX: more streamlined implementation */

/**
 *	__skb_dequeue_tail - remove from the tail of the queue
 *	@list: list to dequeue from
 *
 *	Remove the tail of the list. This function does not take any locks
 *	so must be used with appropriate locks held only. The tail item is
 *	returned or %NULL if the list is empty.
 */

static inline struct sk_buff *__skb_dequeue_tail(struct sk_buff_head *list)
{
	struct sk_buff *skb = skb_peek_tail(list); 
	if (skb)
		__skb_unlink(skb, list);
	return skb;
}

/**
 *	skb_dequeue - remove from the head of the queue
 *	@list: list to dequeue from
 *
 *	Remove the head of the list. The list lock is taken so the function
 *	may be used safely with other locking list functions. The tail item is
 *	returned or %NULL if the list is empty.
 */

static inline struct sk_buff *skb_dequeue_tail(struct sk_buff_head *list)
{
	unsigned long flags;
	struct sk_buff *result;

	spin_lock_irqsave(&list->lock, flags);
	result = __skb_dequeue_tail(list);
	spin_unlock_irqrestore(&list->lock, flags);
	return result;
}

static inline int skb_is_nonlinear(const struct sk_buff *skb)
{
	return skb->data_len;
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
	return skb->len - skb->data_len;
}

#define SKB_PAGE_ASSERT(skb) do { if (skb_shinfo(skb)->nr_frags) out_of_line_bug(); } while (0)
#define SKB_FRAG_ASSERT(skb) do { if (skb_shinfo(skb)->frag_list) out_of_line_bug(); } while (0)
#define SKB_LINEAR_ASSERT(skb) do { if (skb_is_nonlinear(skb)) out_of_line_bug(); } while (0)

/*
 *	Add data to an sk_buff
 */
 
static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	return tmp;
}

/**
 *	skb_put - add data to a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer. If this would
 *	exceed the total buffer size the kernel will panic. A pointer to the
 *	first byte of the extra data is returned.
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
   1a095:	55                   	push   %ebp
   1a096:	89 e5                	mov    %esp,%ebp
   1a098:	83 ec 14             	sub    $0x14,%esp
	unsigned char *tmp=skb->tail;
   1a09b:	8b 45 08             	mov    0x8(%ebp),%eax
   1a09e:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   1a0a4:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	SKB_LINEAR_ASSERT(skb);
   1a0a7:	8b 45 08             	mov    0x8(%ebp),%eax
   1a0aa:	89 04 24             	mov    %eax,(%esp,1)
   1a0ad:	e8 29 1a 00 00       	call   1badb <skb_is_nonlinear>
   1a0b2:	85 c0                	test   %eax,%eax
   1a0b4:	74 0c                	je     1a0c2 <skb_put+0x2d>
   1a0b6:	c7 04 24 24 03 00 00 	movl   $0x324,(%esp,1)
   1a0bd:	e8 fc ff ff ff       	call   1a0be <skb_put+0x29>
	skb->tail+=len;
   1a0c2:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1a0c5:	8b 55 08             	mov    0x8(%ebp),%edx
   1a0c8:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a0cb:	03 82 bc 00 00 00    	add    0xbc(%edx),%eax
   1a0d1:	89 81 bc 00 00 00    	mov    %eax,0xbc(%ecx)
	skb->len+=len;
   1a0d7:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1a0da:	8b 55 08             	mov    0x8(%ebp),%edx
   1a0dd:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a0e0:	03 82 94 00 00 00    	add    0x94(%edx),%eax
   1a0e6:	89 81 94 00 00 00    	mov    %eax,0x94(%ecx)
	if(skb->tail>skb->end) {
   1a0ec:	8b 45 08             	mov    0x8(%ebp),%eax
   1a0ef:	8b 55 08             	mov    0x8(%ebp),%edx
   1a0f2:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   1a0f8:	3b 82 c0 00 00 00    	cmp    0xc0(%edx),%eax
   1a0fe:	76 20                	jbe    1a120 <skb_put+0x8b>
		skb_over_panic(skb, len, current_text_addr());
   1a100:	c7 45 f8 07 a1 01 00 	movl   $0x1a107,0xfffffff8(%ebp)
   1a107:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1a10a:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1a10e:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a111:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1a115:	8b 45 08             	mov    0x8(%ebp),%eax
   1a118:	89 04 24             	mov    %eax,(%esp,1)
   1a11b:	e8 fc ff ff ff       	call   1a11c <skb_put+0x87>
	}
	return tmp;
   1a120:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
   1a123:	c9                   	leave  
   1a124:	c3                   	ret    

0001a125 <skb_reserve>:

static inline unsigned char *__skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
	skb->len+=len;
	return skb->data;
}

/**
 *	skb_push - add data to the start of a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer at the buffer
 *	start. If this would exceed the total buffer headroom the kernel will
 *	panic. A pointer to the first byte of the extra data is returned.
 */

static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
	skb->len+=len;
	if(skb->data<skb->head) {
		skb_under_panic(skb, len, current_text_addr());
	}
	return skb->data;
}

static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
	skb->len-=len;
	if (skb->len < skb->data_len)
		out_of_line_bug();
	return 	skb->data+=len;
}

/**
 *	skb_pull - remove data from the start of a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to remove
 *
 *	This function removes data from the start of a buffer, returning
 *	the memory to the headroom. A pointer to the next data in the buffer
 *	is returned. Once the data has been pulled future pushes will overwrite
 *	the old data.
 */

static inline unsigned char * skb_pull(struct sk_buff *skb, unsigned int len)
{	
	if (len > skb->len)
		return NULL;
	return __skb_pull(skb,len);
}

extern unsigned char * __pskb_pull_tail(struct sk_buff *skb, int delta);

static inline char *__pskb_pull(struct sk_buff *skb, unsigned int len)
{
	if (len > skb_headlen(skb) &&
	    __pskb_pull_tail(skb, len-skb_headlen(skb)) == NULL)
		return NULL;
	skb->len -= len;
	return 	skb->data += len;
}

static inline unsigned char * pskb_pull(struct sk_buff *skb, unsigned int len)
{	
	if (len > skb->len)
		return NULL;
	return __pskb_pull(skb,len);
}

static inline int pskb_may_pull(struct sk_buff *skb, unsigned int len)
{
	if (len <= skb_headlen(skb))
		return 1;
	if (len > skb->len)
		return 0;
	return (__pskb_pull_tail(skb, len-skb_headlen(skb)) != NULL);
}

/**
 *	skb_headroom - bytes at buffer head
 *	@skb: buffer to check
 *
 *	Return the number of bytes of free space at the head of an &sk_buff.
 */
 
static inline int skb_headroom(const struct sk_buff *skb)
{
	return skb->data-skb->head;
}

/**
 *	skb_tailroom - bytes at buffer end
 *	@skb: buffer to check
 *
 *	Return the number of bytes of free space at the tail of an sk_buff
 */

static inline int skb_tailroom(const struct sk_buff *skb)
{
	return skb_is_nonlinear(skb) ? 0 : skb->end-skb->tail;
}

/**
 *	skb_reserve - adjust headroom
 *	@skb: buffer to alter
 *	@len: bytes to move
 *
 *	Increase the headroom of an empty &sk_buff by reducing the tail
 *	room. This is only allowed for an empty buffer.
 */

static inline void skb_reserve(struct sk_buff *skb, unsigned int len)
{
   1a125:	55                   	push   %ebp
   1a126:	89 e5                	mov    %esp,%ebp
	skb->data+=len;
   1a128:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1a12b:	8b 55 08             	mov    0x8(%ebp),%edx
   1a12e:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a131:	03 82 b8 00 00 00    	add    0xb8(%edx),%eax
   1a137:	89 81 b8 00 00 00    	mov    %eax,0xb8(%ecx)
	skb->tail+=len;
   1a13d:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1a140:	8b 55 08             	mov    0x8(%ebp),%edx
   1a143:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a146:	03 82 bc 00 00 00    	add    0xbc(%edx),%eax
   1a14c:	89 81 bc 00 00 00    	mov    %eax,0xbc(%ecx)
}
   1a152:	5d                   	pop    %ebp
   1a153:	c3                   	ret    

0001a154 <__skb_trim>:

extern int ___pskb_trim(struct sk_buff *skb, unsigned int len, int realloc);

static inline void __skb_trim(struct sk_buff *skb, unsigned int len)
{
   1a154:	55                   	push   %ebp
   1a155:	89 e5                	mov    %esp,%ebp
   1a157:	83 ec 0c             	sub    $0xc,%esp
	if (!skb->data_len) {
   1a15a:	8b 45 08             	mov    0x8(%ebp),%eax
   1a15d:	83 b8 98 00 00 00 00 	cmpl   $0x0,0x98(%eax)
   1a164:	75 23                	jne    1a189 <__skb_trim+0x35>
		skb->len = len;
   1a166:	8b 55 08             	mov    0x8(%ebp),%edx
   1a169:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a16c:	89 82 94 00 00 00    	mov    %eax,0x94(%edx)
		skb->tail = skb->data+len;
   1a172:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1a175:	8b 55 08             	mov    0x8(%ebp),%edx
   1a178:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a17b:	03 82 b8 00 00 00    	add    0xb8(%edx),%eax
   1a181:	89 81 bc 00 00 00    	mov    %eax,0xbc(%ecx)
   1a187:	eb 1a                	jmp    1a1a3 <__skb_trim+0x4f>
	} else {
		___pskb_trim(skb, len, 0);
   1a189:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
   1a190:	00 
   1a191:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a194:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1a198:	8b 45 08             	mov    0x8(%ebp),%eax
   1a19b:	89 04 24             	mov    %eax,(%esp,1)
   1a19e:	e8 fc ff ff ff       	call   1a19f <__skb_trim+0x4b>
	}
}
   1a1a3:	c9                   	leave  
   1a1a4:	c3                   	ret    

0001a1a5 <__constant_copy_to_user>:
unsigned long __generic_copy_from_user(void *, const void *, unsigned long);

static inline unsigned long
__constant_copy_to_user(void *to, const void *from, unsigned long n)
{
   1a1a5:	55                   	push   %ebp
   1a1a6:	89 e5                	mov    %esp,%ebp
   1a1a8:	57                   	push   %edi
   1a1a9:	56                   	push   %esi
   1a1aa:	53                   	push   %ebx
   1a1ab:	83 ec 10             	sub    $0x10,%esp
	prefetch(from);
   1a1ae:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a1b1:	89 04 24             	mov    %eax,(%esp,1)
   1a1b4:	e8 26 18 00 00       	call   1b9df <prefetch>
	if (access_ok(VERIFY_WRITE, to, n))
   1a1b9:	8b 5d 08             	mov    0x8(%ebp),%ebx
   1a1bc:	e8 7e fd ff ff       	call   19f3f <get_current>
   1a1c1:	89 da                	mov    %ebx,%edx
   1a1c3:	03 55 10             	add    0x10(%ebp),%edx
   1a1c6:	19 c9                	sbb    %ecx,%ecx
   1a1c8:	39 50 0c             	cmp    %edx,0xc(%eax)
   1a1cb:	83 d9 00             	sbb    $0x0,%ecx
   1a1ce:	89 c8                	mov    %ecx,%eax
   1a1d0:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1a1d3:	89 d0                	mov    %edx,%eax
   1a1d5:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1a1d8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1a1db:	85 c0                	test   %eax,%eax
   1a1dd:	0f 85 ab 00 00 00    	jne    1a28e <__constant_copy_to_user+0xe9>
		__constant_copy_user(to,from,n);
   1a1e3:	8b 45 10             	mov    0x10(%ebp),%eax
   1a1e6:	83 e0 03             	and    $0x3,%eax
   1a1e9:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1a1ec:	83 7d e8 02          	cmpl   $0x2,0xffffffe8(%ebp)
   1a1f0:	74 57                	je     1a249 <__constant_copy_to_user+0xa4>
   1a1f2:	83 7d e8 02          	cmpl   $0x2,0xffffffe8(%ebp)
   1a1f6:	77 08                	ja     1a200 <__constant_copy_to_user+0x5b>
   1a1f8:	83 7d e8 01          	cmpl   $0x1,0xffffffe8(%ebp)
   1a1fc:	74 29                	je     1a227 <__constant_copy_to_user+0x82>
   1a1fe:	eb 06                	jmp    1a206 <__constant_copy_to_user+0x61>
   1a200:	83 7d e8 03          	cmpl   $0x3,0xffffffe8(%ebp)
   1a204:	74 66                	je     1a26c <__constant_copy_to_user+0xc7>
   1a206:	8b 75 0c             	mov    0xc(%ebp),%esi
   1a209:	8b 7d 08             	mov    0x8(%ebp),%edi
   1a20c:	8b 45 10             	mov    0x10(%ebp),%eax
   1a20f:	89 c1                	mov    %eax,%ecx
   1a211:	c1 e9 02             	shr    $0x2,%ecx
   1a214:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   1a216:	89 c8                	mov    %ecx,%eax
   1a218:	89 45 10             	mov    %eax,0x10(%ebp)
   1a21b:	89 f0                	mov    %esi,%eax
   1a21d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1a220:	89 f8                	mov    %edi,%eax
   1a222:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1a225:	eb 67                	jmp    1a28e <__constant_copy_to_user+0xe9>
   1a227:	8b 75 0c             	mov    0xc(%ebp),%esi
   1a22a:	8b 7d 08             	mov    0x8(%ebp),%edi
   1a22d:	8b 45 10             	mov    0x10(%ebp),%eax
   1a230:	89 c1                	mov    %eax,%ecx
   1a232:	c1 e9 02             	shr    $0x2,%ecx
   1a235:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   1a237:	a4                   	movsb  %ds:(%esi),%es:(%edi)
   1a238:	89 c8                	mov    %ecx,%eax
   1a23a:	89 45 10             	mov    %eax,0x10(%ebp)
   1a23d:	89 f0                	mov    %esi,%eax
   1a23f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1a242:	89 f8                	mov    %edi,%eax
   1a244:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1a247:	eb 45                	jmp    1a28e <__constant_copy_to_user+0xe9>
   1a249:	8b 75 0c             	mov    0xc(%ebp),%esi
   1a24c:	8b 7d 08             	mov    0x8(%ebp),%edi
   1a24f:	8b 45 10             	mov    0x10(%ebp),%eax
   1a252:	89 c1                	mov    %eax,%ecx
   1a254:	c1 e9 02             	shr    $0x2,%ecx
   1a257:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   1a259:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
   1a25b:	89 c8                	mov    %ecx,%eax
   1a25d:	89 45 10             	mov    %eax,0x10(%ebp)
   1a260:	89 f0                	mov    %esi,%eax
   1a262:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1a265:	89 f8                	mov    %edi,%eax
   1a267:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1a26a:	eb 22                	jmp    1a28e <__constant_copy_to_user+0xe9>
   1a26c:	8b 75 0c             	mov    0xc(%ebp),%esi
   1a26f:	8b 7d 08             	mov    0x8(%ebp),%edi
   1a272:	8b 45 10             	mov    0x10(%ebp),%eax
   1a275:	89 c1                	mov    %eax,%ecx
   1a277:	c1 e9 02             	shr    $0x2,%ecx
   1a27a:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   1a27c:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
   1a27e:	a4                   	movsb  %ds:(%esi),%es:(%edi)
   1a27f:	89 c8                	mov    %ecx,%eax
   1a281:	89 45 10             	mov    %eax,0x10(%ebp)
   1a284:	89 f0                	mov    %esi,%eax
   1a286:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1a289:	89 f8                	mov    %edi,%eax
   1a28b:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	return n;
   1a28e:	8b 45 10             	mov    0x10(%ebp),%eax
}
   1a291:	83 c4 10             	add    $0x10,%esp
   1a294:	5b                   	pop    %ebx
   1a295:	5e                   	pop    %esi
   1a296:	5f                   	pop    %edi
   1a297:	5d                   	pop    %ebp
   1a298:	c3                   	ret    

0001a299 <__constant_copy_from_user>:

static inline unsigned long
__constant_copy_from_user(void *to, const void *from, unsigned long n)
{
   1a299:	55                   	push   %ebp
   1a29a:	89 e5                	mov    %esp,%ebp
   1a29c:	57                   	push   %edi
   1a29d:	56                   	push   %esi
   1a29e:	53                   	push   %ebx
   1a29f:	83 ec 18             	sub    $0x18,%esp
	if (access_ok(VERIFY_READ, from, n))
   1a2a2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   1a2a5:	e8 95 fc ff ff       	call   19f3f <get_current>
   1a2aa:	89 da                	mov    %ebx,%edx
   1a2ac:	03 55 10             	add    0x10(%ebp),%edx
   1a2af:	19 c9                	sbb    %ecx,%ecx
   1a2b1:	39 50 0c             	cmp    %edx,0xc(%eax)
   1a2b4:	83 d9 00             	sbb    $0x0,%ecx
   1a2b7:	89 c8                	mov    %ecx,%eax
   1a2b9:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1a2bc:	89 d0                	mov    %edx,%eax
   1a2be:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1a2c1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1a2c4:	85 c0                	test   %eax,%eax
   1a2c6:	0f 85 b0 00 00 00    	jne    1a37c <__constant_copy_from_user+0xe3>
		__constant_copy_user_zeroing(to,from,n);
   1a2cc:	8b 45 10             	mov    0x10(%ebp),%eax
   1a2cf:	83 e0 03             	and    $0x3,%eax
   1a2d2:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1a2d5:	83 7d e8 02          	cmpl   $0x2,0xffffffe8(%ebp)
   1a2d9:	74 5a                	je     1a335 <__constant_copy_from_user+0x9c>
   1a2db:	83 7d e8 02          	cmpl   $0x2,0xffffffe8(%ebp)
   1a2df:	77 08                	ja     1a2e9 <__constant_copy_from_user+0x50>
   1a2e1:	83 7d e8 01          	cmpl   $0x1,0xffffffe8(%ebp)
   1a2e5:	74 2c                	je     1a313 <__constant_copy_from_user+0x7a>
   1a2e7:	eb 06                	jmp    1a2ef <__constant_copy_from_user+0x56>
   1a2e9:	83 7d e8 03          	cmpl   $0x3,0xffffffe8(%ebp)
   1a2ed:	74 69                	je     1a358 <__constant_copy_from_user+0xbf>
   1a2ef:	8b 75 0c             	mov    0xc(%ebp),%esi
   1a2f2:	8b 7d 08             	mov    0x8(%ebp),%edi
   1a2f5:	8b 45 10             	mov    0x10(%ebp),%eax
   1a2f8:	89 c1                	mov    %eax,%ecx
   1a2fa:	c1 e9 02             	shr    $0x2,%ecx
   1a2fd:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   1a2ff:	89 c8                	mov    %ecx,%eax
   1a301:	89 45 10             	mov    %eax,0x10(%ebp)
   1a304:	89 f0                	mov    %esi,%eax
   1a306:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1a309:	89 f8                	mov    %edi,%eax
   1a30b:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1a30e:	e9 83 00 00 00       	jmp    1a396 <__constant_copy_from_user+0xfd>
   1a313:	8b 75 0c             	mov    0xc(%ebp),%esi
   1a316:	8b 7d 08             	mov    0x8(%ebp),%edi
   1a319:	8b 45 10             	mov    0x10(%ebp),%eax
   1a31c:	89 c1                	mov    %eax,%ecx
   1a31e:	c1 e9 02             	shr    $0x2,%ecx
   1a321:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   1a323:	a4                   	movsb  %ds:(%esi),%es:(%edi)
   1a324:	89 c8                	mov    %ecx,%eax
   1a326:	89 45 10             	mov    %eax,0x10(%ebp)
   1a329:	89 f0                	mov    %esi,%eax
   1a32b:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1a32e:	89 f8                	mov    %edi,%eax
   1a330:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1a333:	eb 61                	jmp    1a396 <__constant_copy_from_user+0xfd>
   1a335:	8b 75 0c             	mov    0xc(%ebp),%esi
   1a338:	8b 7d 08             	mov    0x8(%ebp),%edi
   1a33b:	8b 45 10             	mov    0x10(%ebp),%eax
   1a33e:	89 c1                	mov    %eax,%ecx
   1a340:	c1 e9 02             	shr    $0x2,%ecx
   1a343:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   1a345:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
   1a347:	89 c8                	mov    %ecx,%eax
   1a349:	89 45 10             	mov    %eax,0x10(%ebp)
   1a34c:	89 f0                	mov    %esi,%eax
   1a34e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1a351:	89 f8                	mov    %edi,%eax
   1a353:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1a356:	eb 3e                	jmp    1a396 <__constant_copy_from_user+0xfd>
   1a358:	8b 75 0c             	mov    0xc(%ebp),%esi
   1a35b:	8b 7d 08             	mov    0x8(%ebp),%edi
   1a35e:	8b 45 10             	mov    0x10(%ebp),%eax
   1a361:	89 c1                	mov    %eax,%ecx
   1a363:	c1 e9 02             	shr    $0x2,%ecx
   1a366:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   1a368:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
   1a36a:	a4                   	movsb  %ds:(%esi),%es:(%edi)
   1a36b:	89 c8                	mov    %ecx,%eax
   1a36d:	89 45 10             	mov    %eax,0x10(%ebp)
   1a370:	89 f0                	mov    %esi,%eax
   1a372:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1a375:	89 f8                	mov    %edi,%eax
   1a377:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1a37a:	eb 1a                	jmp    1a396 <__constant_copy_from_user+0xfd>
	else
		memset(to, 0, n);
   1a37c:	8b 45 10             	mov    0x10(%ebp),%eax
   1a37f:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1a383:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
   1a38a:	00 
   1a38b:	8b 45 08             	mov    0x8(%ebp),%eax
   1a38e:	89 04 24             	mov    %eax,(%esp,1)
   1a391:	e8 d8 16 00 00       	call   1ba6e <__constant_c_memset>
	return n;
   1a396:	8b 45 10             	mov    0x10(%ebp),%eax
}
   1a399:	83 c4 18             	add    $0x18,%esp
   1a39c:	5b                   	pop    %ebx
   1a39d:	5e                   	pop    %esi
   1a39e:	5f                   	pop    %edi
   1a39f:	5d                   	pop    %ebp
   1a3a0:	c3                   	ret    

0001a3a1 <__constant_copy_to_user_nocheck>:

static inline unsigned long
__constant_copy_to_user_nocheck(void *to, const void *from, unsigned long n)
{
   1a3a1:	55                   	push   %ebp
   1a3a2:	89 e5                	mov    %esp,%ebp
   1a3a4:	57                   	push   %edi
   1a3a5:	56                   	push   %esi
   1a3a6:	83 ec 0c             	sub    $0xc,%esp
	__constant_copy_user(to,from,n);
   1a3a9:	8b 45 10             	mov    0x10(%ebp),%eax
   1a3ac:	83 e0 03             	and    $0x3,%eax
   1a3af:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1a3b2:	83 7d ec 02          	cmpl   $0x2,0xffffffec(%ebp)
   1a3b6:	74 57                	je     1a40f <__constant_copy_to_user_nocheck+0x6e>
   1a3b8:	83 7d ec 02          	cmpl   $0x2,0xffffffec(%ebp)
   1a3bc:	77 08                	ja     1a3c6 <__constant_copy_to_user_nocheck+0x25>
   1a3be:	83 7d ec 01          	cmpl   $0x1,0xffffffec(%ebp)
   1a3c2:	74 29                	je     1a3ed <__constant_copy_to_user_nocheck+0x4c>
   1a3c4:	eb 06                	jmp    1a3cc <__constant_copy_to_user_nocheck+0x2b>
   1a3c6:	83 7d ec 03          	cmpl   $0x3,0xffffffec(%ebp)
   1a3ca:	74 66                	je     1a432 <__constant_copy_to_user_nocheck+0x91>
   1a3cc:	8b 75 0c             	mov    0xc(%ebp),%esi
   1a3cf:	8b 7d 08             	mov    0x8(%ebp),%edi
   1a3d2:	8b 45 10             	mov    0x10(%ebp),%eax
   1a3d5:	89 c1                	mov    %eax,%ecx
   1a3d7:	c1 e9 02             	shr    $0x2,%ecx
   1a3da:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   1a3dc:	89 c8                	mov    %ecx,%eax
   1a3de:	89 45 10             	mov    %eax,0x10(%ebp)
   1a3e1:	89 f0                	mov    %esi,%eax
   1a3e3:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1a3e6:	89 f8                	mov    %edi,%eax
   1a3e8:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1a3eb:	eb 67                	jmp    1a454 <__constant_copy_to_user_nocheck+0xb3>
   1a3ed:	8b 75 0c             	mov    0xc(%ebp),%esi
   1a3f0:	8b 7d 08             	mov    0x8(%ebp),%edi
   1a3f3:	8b 45 10             	mov    0x10(%ebp),%eax
   1a3f6:	89 c1                	mov    %eax,%ecx
   1a3f8:	c1 e9 02             	shr    $0x2,%ecx
   1a3fb:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   1a3fd:	a4                   	movsb  %ds:(%esi),%es:(%edi)
   1a3fe:	89 c8                	mov    %ecx,%eax
   1a400:	89 45 10             	mov    %eax,0x10(%ebp)
   1a403:	89 f0                	mov    %esi,%eax
   1a405:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1a408:	89 f8                	mov    %edi,%eax
   1a40a:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1a40d:	eb 45                	jmp    1a454 <__constant_copy_to_user_nocheck+0xb3>
   1a40f:	8b 75 0c             	mov    0xc(%ebp),%esi
   1a412:	8b 7d 08             	mov    0x8(%ebp),%edi
   1a415:	8b 45 10             	mov    0x10(%ebp),%eax
   1a418:	89 c1                	mov    %eax,%ecx
   1a41a:	c1 e9 02             	shr    $0x2,%ecx
   1a41d:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   1a41f:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
   1a421:	89 c8                	mov    %ecx,%eax
   1a423:	89 45 10             	mov    %eax,0x10(%ebp)
   1a426:	89 f0                	mov    %esi,%eax
   1a428:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1a42b:	89 f8                	mov    %edi,%eax
   1a42d:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1a430:	eb 22                	jmp    1a454 <__constant_copy_to_user_nocheck+0xb3>
   1a432:	8b 75 0c             	mov    0xc(%ebp),%esi
   1a435:	8b 7d 08             	mov    0x8(%ebp),%edi
   1a438:	8b 45 10             	mov    0x10(%ebp),%eax
   1a43b:	89 c1                	mov    %eax,%ecx
   1a43d:	c1 e9 02             	shr    $0x2,%ecx
   1a440:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   1a442:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
   1a444:	a4                   	movsb  %ds:(%esi),%es:(%edi)
   1a445:	89 c8                	mov    %ecx,%eax
   1a447:	89 45 10             	mov    %eax,0x10(%ebp)
   1a44a:	89 f0                	mov    %esi,%eax
   1a44c:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1a44f:	89 f8                	mov    %edi,%eax
   1a451:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	return n;
   1a454:	8b 45 10             	mov    0x10(%ebp),%eax
}
   1a457:	83 c4 0c             	add    $0xc,%esp
   1a45a:	5e                   	pop    %esi
   1a45b:	5f                   	pop    %edi
   1a45c:	5d                   	pop    %ebp
   1a45d:	c3                   	ret    

0001a45e <__constant_copy_from_user_nocheck>:

static inline unsigned long
__constant_copy_from_user_nocheck(void *to, const void *from, unsigned long n)
{
   1a45e:	55                   	push   %ebp
   1a45f:	89 e5                	mov    %esp,%ebp
   1a461:	57                   	push   %edi
   1a462:	56                   	push   %esi
   1a463:	83 ec 0c             	sub    $0xc,%esp
	__constant_copy_user_zeroing(to,from,n);
   1a466:	8b 45 10             	mov    0x10(%ebp),%eax
   1a469:	83 e0 03             	and    $0x3,%eax
   1a46c:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1a46f:	83 7d ec 02          	cmpl   $0x2,0xffffffec(%ebp)
   1a473:	74 57                	je     1a4cc <__constant_copy_from_user_nocheck+0x6e>
   1a475:	83 7d ec 02          	cmpl   $0x2,0xffffffec(%ebp)
   1a479:	77 08                	ja     1a483 <__constant_copy_from_user_nocheck+0x25>
   1a47b:	83 7d ec 01          	cmpl   $0x1,0xffffffec(%ebp)
   1a47f:	74 29                	je     1a4aa <__constant_copy_from_user_nocheck+0x4c>
   1a481:	eb 06                	jmp    1a489 <__constant_copy_from_user_nocheck+0x2b>
   1a483:	83 7d ec 03          	cmpl   $0x3,0xffffffec(%ebp)
   1a487:	74 66                	je     1a4ef <__constant_copy_from_user_nocheck+0x91>
   1a489:	8b 75 0c             	mov    0xc(%ebp),%esi
   1a48c:	8b 7d 08             	mov    0x8(%ebp),%edi
   1a48f:	8b 45 10             	mov    0x10(%ebp),%eax
   1a492:	89 c1                	mov    %eax,%ecx
   1a494:	c1 e9 02             	shr    $0x2,%ecx
   1a497:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   1a499:	89 c8                	mov    %ecx,%eax
   1a49b:	89 45 10             	mov    %eax,0x10(%ebp)
   1a49e:	89 f0                	mov    %esi,%eax
   1a4a0:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1a4a3:	89 f8                	mov    %edi,%eax
   1a4a5:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1a4a8:	eb 67                	jmp    1a511 <__constant_copy_from_user_nocheck+0xb3>
   1a4aa:	8b 75 0c             	mov    0xc(%ebp),%esi
   1a4ad:	8b 7d 08             	mov    0x8(%ebp),%edi
   1a4b0:	8b 45 10             	mov    0x10(%ebp),%eax
   1a4b3:	89 c1                	mov    %eax,%ecx
   1a4b5:	c1 e9 02             	shr    $0x2,%ecx
   1a4b8:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   1a4ba:	a4                   	movsb  %ds:(%esi),%es:(%edi)
   1a4bb:	89 c8                	mov    %ecx,%eax
   1a4bd:	89 45 10             	mov    %eax,0x10(%ebp)
   1a4c0:	89 f0                	mov    %esi,%eax
   1a4c2:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1a4c5:	89 f8                	mov    %edi,%eax
   1a4c7:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1a4ca:	eb 45                	jmp    1a511 <__constant_copy_from_user_nocheck+0xb3>
   1a4cc:	8b 75 0c             	mov    0xc(%ebp),%esi
   1a4cf:	8b 7d 08             	mov    0x8(%ebp),%edi
   1a4d2:	8b 45 10             	mov    0x10(%ebp),%eax
   1a4d5:	89 c1                	mov    %eax,%ecx
   1a4d7:	c1 e9 02             	shr    $0x2,%ecx
   1a4da:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   1a4dc:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
   1a4de:	89 c8                	mov    %ecx,%eax
   1a4e0:	89 45 10             	mov    %eax,0x10(%ebp)
   1a4e3:	89 f0                	mov    %esi,%eax
   1a4e5:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1a4e8:	89 f8                	mov    %edi,%eax
   1a4ea:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1a4ed:	eb 22                	jmp    1a511 <__constant_copy_from_user_nocheck+0xb3>
   1a4ef:	8b 75 0c             	mov    0xc(%ebp),%esi
   1a4f2:	8b 7d 08             	mov    0x8(%ebp),%edi
   1a4f5:	8b 45 10             	mov    0x10(%ebp),%eax
   1a4f8:	89 c1                	mov    %eax,%ecx
   1a4fa:	c1 e9 02             	shr    $0x2,%ecx
   1a4fd:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   1a4ff:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
   1a501:	a4                   	movsb  %ds:(%esi),%es:(%edi)
   1a502:	89 c8                	mov    %ecx,%eax
   1a504:	89 45 10             	mov    %eax,0x10(%ebp)
   1a507:	89 f0                	mov    %esi,%eax
   1a509:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1a50c:	89 f8                	mov    %edi,%eax
   1a50e:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	return n;
   1a511:	8b 45 10             	mov    0x10(%ebp),%eax
}
   1a514:	83 c4 0c             	add    $0xc,%esp
   1a517:	5e                   	pop    %esi
   1a518:	5f                   	pop    %edi
   1a519:	5d                   	pop    %ebp
   1a51a:	c3                   	ret    

0001a51b <empty>:
#ifdef __KERNEL__
#define VALID_MSK_CTL(X) ((X)->ctl == ALLOC_READY || \
                          (X)->ctl == ALLOC_HALFFREE)

static inline int empty(struct alloc_head_list *head) {
   1a51b:	55                   	push   %ebp
   1a51c:	89 e5                	mov    %esp,%ebp
	return head->next == (struct alloc_head*)head;
   1a51e:	8b 45 08             	mov    0x8(%ebp),%eax
   1a521:	8b 40 04             	mov    0x4(%eax),%eax
   1a524:	3b 45 08             	cmp    0x8(%ebp),%eax
   1a527:	0f 94 c0             	sete   %al
   1a52a:	0f b6 c0             	movzbl %al,%eax
}
   1a52d:	5d                   	pop    %ebp
   1a52e:	c3                   	ret    

0001a52f <init_head>:

static inline void init_head(struct alloc_head_list *head) {
   1a52f:	55                   	push   %ebp
   1a530:	89 e5                	mov    %esp,%ebp
	head->next = head->prev = (struct alloc_head*)head;
   1a532:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1a535:	8b 55 08             	mov    0x8(%ebp),%edx
   1a538:	8b 45 08             	mov    0x8(%ebp),%eax
   1a53b:	89 02                	mov    %eax,(%edx)
   1a53d:	89 41 04             	mov    %eax,0x4(%ecx)
	head->list = head;
   1a540:	8b 55 08             	mov    0x8(%ebp),%edx
   1a543:	8b 45 08             	mov    0x8(%ebp),%eax
   1a546:	89 42 08             	mov    %eax,0x8(%edx)
	head->len = 0;
   1a549:	8b 45 08             	mov    0x8(%ebp),%eax
   1a54c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
}
   1a553:	5d                   	pop    %ebp
   1a554:	c3                   	ret    

0001a555 <insert_tail>:

#if 0
static inline void unlink_head(struct alloc_head_list *head) {
	struct alloc_head *prev = head->prev;
	head->prev->next = head->next;
	head->next->prev = head->prev;
	head->next = head->prev = NULL;
	if(prev->next == prev && prev->prev != prev) {
		BUG();
		show_stack(NULL);
	}
	head->len--;
}
#endif

//#define DEBUG_LIST

static inline void insert_head(struct alloc_head_list *head, struct alloc_head *elem) {
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
#endif
	if(head->next == elem /* || elem->prev != NULL || elem->next != NULL */) {
		BUG();
		show_stack(NULL);	
	}
	elem->next = head->next;
	head->next->prev = elem;

	elem->prev = (struct alloc_head*)head;
	head->next = elem;

	elem->list = head;
	head->len++;
}

static inline void insert_tail(struct alloc_head_list *head, struct alloc_head *elem) {
   1a555:	55                   	push   %ebp
   1a556:	89 e5                	mov    %esp,%ebp
   1a558:	83 ec 08             	sub    $0x8,%esp
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
   1a55b:	8b 45 08             	mov    0x8(%ebp),%eax
   1a55e:	8b 00                	mov    (%eax),%eax
   1a560:	3b 45 0c             	cmp    0xc(%ebp),%eax
   1a563:	75 31                	jne    1a596 <insert_tail+0x41>
		BUG();
   1a565:	c7 44 24 04 59 53 00 	movl   $0x5359,0x4(%esp,1)
   1a56c:	00 
   1a56d:	c7 04 24 5d 53 00 00 	movl   $0x535d,(%esp,1)
   1a574:	e8 fc ff ff ff       	call   1a575 <insert_tail+0x20>
   1a579:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1a580:	e8 fc ff ff ff       	call   1a581 <insert_tail+0x2c>
   1a585:	e8 fc ff ff ff       	call   1a586 <insert_tail+0x31>
		show_stack(NULL);
   1a58a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1a591:	e8 fc ff ff ff       	call   1a592 <insert_tail+0x3d>
	}
#if 1 // 10-01: moved next pointer up to make consistent with mb version
	elem->next = (struct alloc_head*)head;
   1a596:	8b 55 0c             	mov    0xc(%ebp),%edx
   1a599:	8b 45 08             	mov    0x8(%ebp),%eax
   1a59c:	89 42 04             	mov    %eax,0x4(%edx)
#endif
	elem->prev = head->prev;
   1a59f:	8b 55 0c             	mov    0xc(%ebp),%edx
   1a5a2:	8b 45 08             	mov    0x8(%ebp),%eax
   1a5a5:	8b 00                	mov    (%eax),%eax
   1a5a7:	89 02                	mov    %eax,(%edx)

	head->prev->next = elem;
   1a5a9:	8b 45 08             	mov    0x8(%ebp),%eax
   1a5ac:	8b 10                	mov    (%eax),%edx
   1a5ae:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a5b1:	89 42 04             	mov    %eax,0x4(%edx)

	elem->list = head;
   1a5b4:	8b 55 0c             	mov    0xc(%ebp),%edx
   1a5b7:	8b 45 08             	mov    0x8(%ebp),%eax
   1a5ba:	89 42 08             	mov    %eax,0x8(%edx)
	head->prev = elem;
   1a5bd:	8b 55 08             	mov    0x8(%ebp),%edx
   1a5c0:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a5c3:	89 02                	mov    %eax,(%edx)
	head->len++;
   1a5c5:	8b 45 08             	mov    0x8(%ebp),%eax
   1a5c8:	ff 40 10             	incl   0x10(%eax)
}
   1a5cb:	c9                   	leave  
   1a5cc:	c3                   	ret    

0001a5cd <insert_tail_mb>:

static inline void insert_tail_mb(struct alloc_head_list *head, struct alloc_head *elem) {
   1a5cd:	55                   	push   %ebp
   1a5ce:	89 e5                	mov    %esp,%ebp
   1a5d0:	83 ec 08             	sub    $0x8,%esp
#if 1
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
#endif
	if(head->prev == elem /* || elem->prev != NULL || elem->next != NULL */) {
   1a5d3:	8b 45 08             	mov    0x8(%ebp),%eax
   1a5d6:	8b 00                	mov    (%eax),%eax
   1a5d8:	3b 45 0c             	cmp    0xc(%ebp),%eax
   1a5db:	75 31                	jne    1a60e <insert_tail_mb+0x41>
		BUG();
   1a5dd:	c7 44 24 04 59 53 00 	movl   $0x5359,0x4(%esp,1)
   1a5e4:	00 
   1a5e5:	c7 04 24 5d 53 00 00 	movl   $0x535d,(%esp,1)
   1a5ec:	e8 fc ff ff ff       	call   1a5ed <insert_tail_mb+0x20>
   1a5f1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1a5f8:	e8 fc ff ff ff       	call   1a5f9 <insert_tail_mb+0x2c>
   1a5fd:	e8 fc ff ff ff       	call   1a5fe <insert_tail_mb+0x31>
		show_stack(NULL);
   1a602:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1a609:	e8 fc ff ff ff       	call   1a60a <insert_tail_mb+0x3d>
	}
#define INSERT_TAIL_MB
#ifdef INSERT_TAIL_MB // 10-01: moved next pointer up and added memory barrier to insure that forward walk through element list works properly without locking
	elem->next = (struct alloc_head*)head;
   1a60e:	8b 55 0c             	mov    0xc(%ebp),%edx
   1a611:	8b 45 08             	mov    0x8(%ebp),%eax
   1a614:	89 42 04             	mov    %eax,0x4(%edx)
#endif
	elem->prev = head->prev;
   1a617:	8b 55 0c             	mov    0xc(%ebp),%edx
   1a61a:	8b 45 08             	mov    0x8(%ebp),%eax
   1a61d:	8b 00                	mov    (%eax),%eax
   1a61f:	89 02                	mov    %eax,(%edx)

#ifdef INSERT_TAIL_MB // 10-01
	mb();
   1a621:	f0 83 44 24 00 00    	lock addl $0x0,0x0(%esp,1)
#endif

	head->prev->next = elem;
   1a627:	8b 45 08             	mov    0x8(%ebp),%eax
   1a62a:	8b 10                	mov    (%eax),%edx
   1a62c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a62f:	89 42 04             	mov    %eax,0x4(%edx)

#ifndef INSERT_TAIL_MB
	elem->next = (struct alloc_head*)head;
#endif

	elem->list = head;
   1a632:	8b 55 0c             	mov    0xc(%ebp),%edx
   1a635:	8b 45 08             	mov    0x8(%ebp),%eax
   1a638:	89 42 08             	mov    %eax,0x8(%edx)
	head->prev = elem;
   1a63b:	8b 55 08             	mov    0x8(%ebp),%edx
   1a63e:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a641:	89 02                	mov    %eax,(%edx)
	head->len++;
   1a643:	8b 45 08             	mov    0x8(%ebp),%eax
   1a646:	ff 40 10             	incl   0x10(%eax)
#endif
}
   1a649:	c9                   	leave  
   1a64a:	c3                   	ret    

0001a64b <unlink>:

static inline void unlink(struct alloc_head *elem) {
   1a64b:	55                   	push   %ebp
   1a64c:	89 e5                	mov    %esp,%ebp
#ifdef DEBUG_LIST
	if(elem->list == (struct alloc_head_list*) elem) {
		BUG();
	}
#endif

	elem->next->prev = elem->prev;
   1a64e:	8b 45 08             	mov    0x8(%ebp),%eax
   1a651:	8b 50 04             	mov    0x4(%eax),%edx
   1a654:	8b 45 08             	mov    0x8(%ebp),%eax
   1a657:	8b 00                	mov    (%eax),%eax
   1a659:	89 02                	mov    %eax,(%edx)
	elem->prev->next = elem->next;
   1a65b:	8b 45 08             	mov    0x8(%ebp),%eax
   1a65e:	8b 10                	mov    (%eax),%edx
   1a660:	8b 45 08             	mov    0x8(%ebp),%eax
   1a663:	8b 40 04             	mov    0x4(%eax),%eax
   1a666:	89 42 04             	mov    %eax,0x4(%edx)
	elem->prev = elem->next = NULL;
   1a669:	8b 55 08             	mov    0x8(%ebp),%edx
   1a66c:	8b 45 08             	mov    0x8(%ebp),%eax
   1a66f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   1a676:	c7 02 00 00 00 00    	movl   $0x0,(%edx)

	elem->list->len--;
   1a67c:	8b 45 08             	mov    0x8(%ebp),%eax
   1a67f:	8b 40 08             	mov    0x8(%eax),%eax
   1a682:	ff 48 10             	decl   0x10(%eax)
	elem->list = NULL;
   1a685:	8b 45 08             	mov    0x8(%ebp),%eax
   1a688:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
   1a68f:	5d                   	pop    %ebp
   1a690:	c3                   	ret    

0001a691 <setPacketUCont>:

static inline void insert(struct alloc_head *elem, struct alloc_head *prev, struct alloc_head *next) {
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
	if(prev->next != next || next->prev != prev) {
		BUG();
	}
#endif

	if(!(elem->next == NULL && elem->prev == NULL)) BUG();
	elem->next = prev->next;
	prev->next = elem;

	elem->prev = prev;
	next->prev = elem;

	elem->list = prev->list;
	elem->list->len++;
}

#define alloc_head_walk(queue, elem) \
		for (elem = (typeof(elem))(queue)->next;	\
		     (elem != (typeof(elem))(queue));	\
		     elem=(typeof(elem))elem->next)

#define alloc_head_reverse_walk(queue, elem) \
		for (elem = (typeof(elem))(queue)->prev;	\
		     (elem != (typeof(elem))(queue));	\
		     elem=(typeof(elem))elem->prev)

#endif // __KERNEL__

struct cminisock_packet {
	__u32 nonce; // pregenerate nonces in batch
	__u32 seq;
	//__u32 ack_seq; // XXX probably vestigial
	__u32 len; // XXX Vestigial?

#define PTYPE_FIRST     (0x80)
#define PTYPE_STATEMASK (0x3)
#define PACKET_NORMAL    (0)
#define PACKET_RETRANS   (1)
#define PACKET_BOOTSTRAP (2)
	__u8 type : 3;
	__u8 contType : 3;

#define INVALID_POSITION (0xff)
	__u8 numSiblings; // UC-level number of siblings
	__u8 position; // UC position within sibling list. If packet looks like a data packet, and position == INVALID_POSITION, then client will ignore the packet

	// If ucontLen > 0 and ucontData == NULL, then the ucont is already present in the skbuff
	int ucontLen;
	char *ucontData; // kmalloc'd

	__u16 minResponseLen;
	__u32 firstTransportChild;
	__u8 numTransportChildren;

#ifdef USERTEST
	char *sentData;
	int dataLen;
#endif // USERTEST
};

static inline void makePacket(struct cminisock_packet *pkt, 
			      __u32 seq, 
			      __u32 ack_seq,
			      __u32 len, 
			      __u8 type, 
			      __u8 contType, 
			      __u16 minResponseLen,
			      __u32 firstTransportChild, 
			      __u8 numTransportChildren) {
  pkt->nonce = -1;
  pkt->seq = seq;
  //pkt->ack_seq = ack_seq;
  pkt->len = len;
  pkt->type = type;
  pkt->contType = contType;
  pkt->minResponseLen = minResponseLen;
  pkt->firstTransportChild = firstTransportChild;
  pkt->numTransportChildren = numTransportChildren;
  pkt->ucontLen = 0;
  pkt->ucontData = NULL;
  pkt->numSiblings = -1;
  pkt->position = INVALID_POSITION;
}

#ifdef __KERNEL__
static inline void setPacketUCont(struct cminisock_packet *packet, char *buf, unsigned long len) {
   1a691:	55                   	push   %ebp
   1a692:	89 e5                	mov    %esp,%ebp
   1a694:	53                   	push   %ebx
   1a695:	83 ec 10             	sub    $0x10,%esp
	if(len > packet->len + packet->ucontLen) {
   1a698:	8b 55 08             	mov    0x8(%ebp),%edx
   1a69b:	8b 45 08             	mov    0x8(%ebp),%eax
   1a69e:	8b 40 10             	mov    0x10(%eax),%eax
   1a6a1:	03 42 08             	add    0x8(%edx),%eax
   1a6a4:	39 45 10             	cmp    %eax,0x10(%ebp)
   1a6a7:	76 29                	jbe    1a6d2 <setPacketUCont+0x41>
		printk("Not enough space in packet for ucont %d %d + %d\n", 
   1a6a9:	8b 45 08             	mov    0x8(%ebp),%eax
   1a6ac:	8b 40 10             	mov    0x10(%eax),%eax
   1a6af:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   1a6b3:	8b 45 08             	mov    0x8(%ebp),%eax
   1a6b6:	8b 40 08             	mov    0x8(%eax),%eax
   1a6b9:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1a6bd:	8b 45 10             	mov    0x10(%ebp),%eax
   1a6c0:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1a6c4:	c7 04 24 c0 6f 00 00 	movl   $0x6fc0,(%esp,1)
   1a6cb:	e8 fc ff ff ff       	call   1a6cc <setPacketUCont+0x3b>
		       (int) len, packet->len, packet->ucontLen);
		return;
   1a6d0:	eb 59                	jmp    1a72b <setPacketUCont+0x9a>
	}
	if(packet->ucontData) {
   1a6d2:	8b 45 08             	mov    0x8(%ebp),%eax
   1a6d5:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
   1a6d9:	74 2a                	je     1a705 <setPacketUCont+0x74>
		kfree(packet->ucontData);
   1a6db:	8b 45 08             	mov    0x8(%ebp),%eax
   1a6de:	8b 40 14             	mov    0x14(%eax),%eax
   1a6e1:	89 04 24             	mov    %eax,(%esp,1)
   1a6e4:	e8 fc ff ff ff       	call   1a6e5 <setPacketUCont+0x54>
		packet->len += packet->ucontLen;
   1a6e9:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1a6ec:	8b 55 08             	mov    0x8(%ebp),%edx
   1a6ef:	8b 45 08             	mov    0x8(%ebp),%eax
   1a6f2:	8b 40 10             	mov    0x10(%eax),%eax
   1a6f5:	03 42 08             	add    0x8(%edx),%eax
   1a6f8:	89 41 08             	mov    %eax,0x8(%ecx)
		packet->ucontLen = 0;
   1a6fb:	8b 45 08             	mov    0x8(%ebp),%eax
   1a6fe:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	}
	packet->ucontData = buf;
   1a705:	8b 55 08             	mov    0x8(%ebp),%edx
   1a708:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a70b:	89 42 14             	mov    %eax,0x14(%edx)
	packet->ucontLen = len;
   1a70e:	8b 55 08             	mov    0x8(%ebp),%edx
   1a711:	8b 45 10             	mov    0x10(%ebp),%eax
   1a714:	89 42 10             	mov    %eax,0x10(%edx)
	packet->len -= packet->ucontLen;
   1a717:	8b 5d 08             	mov    0x8(%ebp),%ebx
   1a71a:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1a71d:	8b 45 08             	mov    0x8(%ebp),%eax
   1a720:	8b 50 10             	mov    0x10(%eax),%edx
   1a723:	8b 41 08             	mov    0x8(%ecx),%eax
   1a726:	29 d0                	sub    %edx,%eax
   1a728:	89 43 08             	mov    %eax,0x8(%ebx)
}
   1a72b:	83 c4 10             	add    $0x10,%esp
   1a72e:	5b                   	pop    %ebx
   1a72f:	5d                   	pop    %ebp
   1a730:	c3                   	ret    

0001a731 <sock_hold>:
   modifications.
 */

static inline void sock_hold(struct sock *sk)
{
   1a731:	55                   	push   %ebp
   1a732:	89 e5                	mov    %esp,%ebp
   1a734:	83 ec 04             	sub    $0x4,%esp
	atomic_inc(&sk->refcnt);
   1a737:	8b 45 08             	mov    0x8(%ebp),%eax
   1a73a:	83 c0 28             	add    $0x28,%eax
   1a73d:	89 04 24             	mov    %eax,(%esp,1)
   1a740:	e8 d3 f5 ff ff       	call   19d18 <atomic_inc>
}
   1a745:	c9                   	leave  
   1a746:	c3                   	ret    

0001a747 <sock_put>:

/* Ungrab socket in the context, which assumes that socket refcnt
   cannot hit zero, f.e. it is true in context of any socketcall.
 */
static inline void __sock_put(struct sock *sk)
{
	atomic_dec(&sk->refcnt);
}

/* Ungrab socket and destroy it, if it was the last reference. */
static inline void sock_put(struct sock *sk)
{
   1a747:	55                   	push   %ebp
   1a748:	89 e5                	mov    %esp,%ebp
   1a74a:	83 ec 04             	sub    $0x4,%esp
	if (atomic_dec_and_test(&sk->refcnt))
   1a74d:	8b 45 08             	mov    0x8(%ebp),%eax
   1a750:	83 c0 28             	add    $0x28,%eax
   1a753:	89 04 24             	mov    %eax,(%esp,1)
   1a756:	e8 f5 12 00 00       	call   1ba50 <atomic_dec_and_test>
   1a75b:	85 c0                	test   %eax,%eax
   1a75d:	74 0b                	je     1a76a <sock_put+0x23>
		sk_free(sk);
   1a75f:	8b 45 08             	mov    0x8(%ebp),%eax
   1a762:	89 04 24             	mov    %eax,(%esp,1)
   1a765:	e8 fc ff ff ff       	call   1a766 <sock_put+0x1f>
}
   1a76a:	c9                   	leave  
   1a76b:	c3                   	ret    

0001a76c <sock_orphan>:

/* Detach socket from process context.
 * Announce socket dead, detach it from wait queue and inode.
 * Note that parent inode held reference count on this struct sock,
 * we do not release it in this function, because protocol
 * probably wants some additional cleanups or even continuing
 * to work with this socket (TCP).
 */
static inline void sock_orphan(struct sock *sk)
{
   1a76c:	55                   	push   %ebp
   1a76d:	89 e5                	mov    %esp,%ebp
   1a76f:	83 ec 04             	sub    $0x4,%esp
	write_lock_bh(&sk->callback_lock);
   1a772:	ff 05 08 00 00 00    	incl   0x8
	sk->dead = 1;
   1a778:	8b 45 08             	mov    0x8(%ebp),%eax
   1a77b:	c6 80 80 00 00 00 01 	movb   $0x1,0x80(%eax)
	sk->socket = NULL;
   1a782:	8b 45 08             	mov    0x8(%ebp),%eax
   1a785:	c7 80 c8 0b 00 00 00 	movl   $0x0,0xbc8(%eax)
   1a78c:	00 00 00 
	sk->sleep = NULL;
   1a78f:	8b 45 08             	mov    0x8(%ebp),%eax
   1a792:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
	write_unlock_bh(&sk->callback_lock);
   1a799:	c7 45 fc 08 00 00 00 	movl   $0x8,0xfffffffc(%ebp)
   1a7a0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1a7a3:	ff 08                	decl   (%eax)
   1a7a5:	83 38 00             	cmpl   $0x0,(%eax)
   1a7a8:	75 0d                	jne    1a7b7 <sock_orphan+0x4b>
   1a7aa:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1a7ad:	83 78 f8 00          	cmpl   $0x0,0xfffffff8(%eax)
   1a7b1:	0f 85 19 1b 00 00    	jne    1c2d0 <.text.lock.tmalloc+0x360>
}
   1a7b7:	c9                   	leave  
   1a7b8:	c3                   	ret    

0001a7b9 <sock_error>:

static inline void sock_graft(struct sock *sk, struct socket *parent)
{
	write_lock_bh(&sk->callback_lock);
	sk->sleep = &parent->wait;
	parent->sk = sk;
	sk->socket = parent;
	write_unlock_bh(&sk->callback_lock);
}

static inline int sock_i_uid(struct sock *sk)
{
	int uid;

	read_lock(&sk->callback_lock);
	uid = sk->socket ? sk->socket->inode->i_uid : 0;
	read_unlock(&sk->callback_lock);
	return uid;
}

static inline unsigned long sock_i_ino(struct sock *sk)
{
	unsigned long ino;

	read_lock(&sk->callback_lock);
	ino = sk->socket ? sk->socket->inode->i_ino : 0;
	read_unlock(&sk->callback_lock);
	return ino;
}

static inline struct dst_entry *
__sk_dst_get(struct sock *sk)
{
	return sk->dst_cache;
}

static inline struct dst_entry *
sk_dst_get(struct sock *sk)
{
	struct dst_entry *dst;

	read_lock(&sk->dst_lock);
	dst = sk->dst_cache;
	if (dst)
		dst_hold(dst);
	read_unlock(&sk->dst_lock);
	return dst;
}

static inline void
__sk_dst_set(struct sock *sk, struct dst_entry *dst)
{
	struct dst_entry *old_dst;

	old_dst = sk->dst_cache;
	sk->dst_cache = dst;
	dst_release(old_dst);
}

static inline void
sk_dst_set(struct sock *sk, struct dst_entry *dst)
{
	write_lock(&sk->dst_lock);
	__sk_dst_set(sk, dst);
	write_unlock(&sk->dst_lock);
}

static inline void
__sk_dst_reset(struct sock *sk)
{
	struct dst_entry *old_dst;

	old_dst = sk->dst_cache;
	sk->dst_cache = NULL;
	dst_release(old_dst);
}

static inline void
sk_dst_reset(struct sock *sk)
{
	write_lock(&sk->dst_lock);
	__sk_dst_reset(sk);
	write_unlock(&sk->dst_lock);
}

static inline struct dst_entry *
__sk_dst_check(struct sock *sk, u32 cookie)
{
	struct dst_entry *dst = sk->dst_cache;

	if (dst && dst->obsolete && dst->ops->check(dst, cookie) == NULL) {
		sk->dst_cache = NULL;
		return NULL;
	}

	return dst;
}

static inline struct dst_entry *
sk_dst_check(struct sock *sk, u32 cookie)
{
	struct dst_entry *dst = sk_dst_get(sk);

	if (dst && dst->obsolete && dst->ops->check(dst, cookie) == NULL) {
		sk_dst_reset(sk);
		return NULL;
	}

	return dst;
}


/*
 * 	Queue a received datagram if it will fit. Stream and sequenced
 *	protocols can't normally use this as they need to fit buffers in
 *	and play with them.
 *
 * 	Inlined as it's very short and called for pretty much every
 *	packet ever received.
 */

static inline void skb_set_owner_w(struct sk_buff *skb, struct sock *sk)
{
	sock_hold(sk);
	skb->sk = sk;
	skb->destructor = sock_wfree;
	atomic_add(skb->truesize, &sk->wmem_alloc);
}

static inline void skb_set_owner_r(struct sk_buff *skb, struct sock *sk)
{
	skb->sk = sk;
	skb->destructor = sock_rfree;
	atomic_add(skb->truesize, &sk->rmem_alloc);
}

static inline int sock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)
{
	int err = 0;
	int skb_len;

	/* Cast skb->rcvbuf to unsigned... It's pointless, but reduces
	   number of warnings when compiling with -W --ANK
	 */
	if (atomic_read(&sk->rmem_alloc) + skb->truesize >= (unsigned)sk->rcvbuf) {
		err = -ENOMEM;
		goto out;
	}

	/* It would be deadlock, if sock_queue_rcv_skb is used
	   with socket lock! We assume that users of this
	   function are lock free.
	*/
	err = sk_filter(sk, skb, 1);
	if (err)
		goto out;

	skb->dev = NULL;
	skb_set_owner_r(skb, sk);

	/* Cache the SKB length before we tack it onto the receive
	 * queue.  Once it is added it no longer belongs to us and
	 * may be freed by other threads of control pulling packets
	 * from the queue.
	 */
	skb_len = skb->len;

	skb_queue_tail(&sk->receive_queue, skb);
	if (!sk->dead)
		sk->data_ready(sk,skb_len);
out:
	return err;
}

static inline int sock_queue_err_skb(struct sock *sk, struct sk_buff *skb)
{
	/* Cast skb->rcvbuf to unsigned... It's pointless, but reduces
	   number of warnings when compiling with -W --ANK
	 */
	if (atomic_read(&sk->rmem_alloc) + skb->truesize >= (unsigned)sk->rcvbuf)
		return -ENOMEM;
	skb_set_owner_r(skb, sk);
	skb_queue_tail(&sk->error_queue,skb);
	if (!sk->dead)
		sk->data_ready(sk,skb->len);
	return 0;
}

/*
 *	Recover an error report and clear atomically
 */
 
static inline int sock_error(struct sock *sk)
{
   1a7b9:	55                   	push   %ebp
   1a7ba:	89 e5                	mov    %esp,%ebp
   1a7bc:	83 ec 10             	sub    $0x10,%esp
	int err=xchg(&sk->err,0);
   1a7bf:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp,1)
   1a7c6:	00 
   1a7c7:	8b 45 08             	mov    0x8(%ebp),%eax
   1a7ca:	05 48 0b 00 00       	add    $0xb48,%eax
   1a7cf:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1a7d3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1a7da:	e8 1e 12 00 00       	call   1b9fd <__xchg>
   1a7df:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	return -err;
   1a7e2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1a7e5:	f7 d8                	neg    %eax
}
   1a7e7:	c9                   	leave  
   1a7e8:	c3                   	ret    

0001a7e9 <sock_rcvtimeo>:

static inline unsigned long sock_wspace(struct sock *sk)
{
	int amt = 0;

	if (!(sk->shutdown & SEND_SHUTDOWN)) {
		amt = sk->sndbuf - atomic_read(&sk->wmem_alloc);
		if (amt < 0) 
			amt = 0;
	}
	return amt;
}

static inline void sk_wake_async(struct sock *sk, int how, int band)
{
	if (sk->socket && sk->socket->fasync_list)
		sock_wake_async(sk->socket, how, band);
}

#define SOCK_MIN_SNDBUF 2048
#define SOCK_MIN_RCVBUF 256

/*
 *	Default write policy as shown to user space via poll/select/SIGIO
 */
static inline int sock_writeable(struct sock *sk) 
{
	return atomic_read(&sk->wmem_alloc) < (sk->sndbuf / 2);
}

static inline int gfp_any(void)
{
	return in_softirq() ? GFP_ATOMIC : GFP_KERNEL;
}

static inline long sock_rcvtimeo(struct sock *sk, int noblock)
{
   1a7e9:	55                   	push   %ebp
   1a7ea:	89 e5                	mov    %esp,%ebp
   1a7ec:	83 ec 04             	sub    $0x4,%esp
	return noblock ? 0 : sk->rcvtimeo;
   1a7ef:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1a7f3:	75 0e                	jne    1a803 <sock_rcvtimeo+0x1a>
   1a7f5:	8b 45 08             	mov    0x8(%ebp),%eax
   1a7f8:	8b 80 6c 0b 00 00    	mov    0xb6c(%eax),%eax
   1a7fe:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   1a801:	eb 07                	jmp    1a80a <sock_rcvtimeo+0x21>
   1a803:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   1a80a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
   1a80d:	c9                   	leave  
   1a80e:	c3                   	ret    

0001a80f <sock_rcvlowat>:

static inline long sock_sndtimeo(struct sock *sk, int noblock)
{
	return noblock ? 0 : sk->sndtimeo;
}

static inline int sock_rcvlowat(struct sock *sk, int waitall, int len)
{
   1a80f:	55                   	push   %ebp
   1a810:	89 e5                	mov    %esp,%ebp
   1a812:	83 ec 14             	sub    $0x14,%esp
	return (waitall ? len : min_t(int, sk->rcvlowat, len)) ? : 1;
   1a815:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1a819:	75 2e                	jne    1a849 <sock_rcvlowat+0x3a>
   1a81b:	8b 45 08             	mov    0x8(%ebp),%eax
   1a81e:	8b 80 68 0b 00 00    	mov    0xb68(%eax),%eax
   1a824:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   1a827:	8b 45 10             	mov    0x10(%ebp),%eax
   1a82a:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   1a82d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1a830:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1a833:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1a836:	3b 45 fc             	cmp    0xfffffffc(%ebp),%eax
   1a839:	7e 06                	jle    1a841 <sock_rcvlowat+0x32>
   1a83b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1a83e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1a841:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1a844:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1a847:	eb 06                	jmp    1a84f <sock_rcvlowat+0x40>
   1a849:	8b 45 10             	mov    0x10(%ebp),%eax
   1a84c:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1a84f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1a852:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1a855:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
   1a859:	75 07                	jne    1a862 <sock_rcvlowat+0x53>
   1a85b:	c7 45 f4 01 00 00 00 	movl   $0x1,0xfffffff4(%ebp)
   1a862:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
}
   1a865:	c9                   	leave  
   1a866:	c3                   	ret    

0001a867 <sock_intr_errno>:

/* Alas, with timeout socket operations are not restartable.
 * Compare this to poll().
 */
static inline int sock_intr_errno(long timeo)
{
   1a867:	55                   	push   %ebp
   1a868:	89 e5                	mov    %esp,%ebp
   1a86a:	83 ec 04             	sub    $0x4,%esp
	return timeo == MAX_SCHEDULE_TIMEOUT ? -ERESTARTSYS : -EINTR;
   1a86d:	81 7d 08 ff ff ff 7f 	cmpl   $0x7fffffff,0x8(%ebp)
   1a874:	75 09                	jne    1a87f <sock_intr_errno+0x18>
   1a876:	c7 45 fc 00 fe ff ff 	movl   $0xfffffe00,0xfffffffc(%ebp)
   1a87d:	eb 07                	jmp    1a886 <sock_intr_errno+0x1f>
   1a87f:	c7 45 fc fc ff ff ff 	movl   $0xfffffffc,0xfffffffc(%ebp)
   1a886:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
   1a889:	c9                   	leave  
   1a88a:	c3                   	ret    

0001a88b <csum_and_copy_from_user>:
#ifndef _HAVE_ARCH_COPY_AND_CSUM_FROM_USER
static inline
unsigned int csum_and_copy_from_user (const char *src, char *dst,
				      int len, int sum, int *err_ptr)
{
   1a88b:	55                   	push   %ebp
   1a88c:	89 e5                	mov    %esp,%ebp
   1a88e:	83 ec 18             	sub    $0x18,%esp
	if (verify_area(VERIFY_READ, src, len) == 0)
   1a891:	8b 45 10             	mov    0x10(%ebp),%eax
   1a894:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1a898:	8b 45 08             	mov    0x8(%ebp),%eax
   1a89b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1a89f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1a8a6:	e8 3e 12 00 00       	call   1bae9 <verify_area>
   1a8ab:	85 c0                	test   %eax,%eax
   1a8ad:	75 2c                	jne    1a8db <csum_and_copy_from_user+0x50>
		return csum_partial_copy_from_user(src, dst, len, sum, err_ptr);
   1a8af:	8b 45 18             	mov    0x18(%ebp),%eax
   1a8b2:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   1a8b6:	8b 45 14             	mov    0x14(%ebp),%eax
   1a8b9:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   1a8bd:	8b 45 10             	mov    0x10(%ebp),%eax
   1a8c0:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1a8c4:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a8c7:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1a8cb:	8b 45 08             	mov    0x8(%ebp),%eax
   1a8ce:	89 04 24             	mov    %eax,(%esp,1)
   1a8d1:	e8 4a 13 00 00       	call   1bc20 <csum_partial_copy_from_user>
   1a8d6:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   1a8d9:	eb 15                	jmp    1a8f0 <csum_and_copy_from_user+0x65>

	if (len)
   1a8db:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1a8df:	74 09                	je     1a8ea <csum_and_copy_from_user+0x5f>
		*err_ptr = -EFAULT;
   1a8e1:	8b 45 18             	mov    0x18(%ebp),%eax
   1a8e4:	c7 00 f2 ff ff ff    	movl   $0xfffffff2,(%eax)

	return sum;
   1a8ea:	8b 45 14             	mov    0x14(%ebp),%eax
   1a8ed:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
}
   1a8f0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1a8f3:	c9                   	leave  
   1a8f4:	c3                   	ret    

0001a8f5 <csum_block_add>:
#endif

#ifndef HAVE_CSUM_COPY_USER
static __inline__ unsigned int csum_and_copy_to_user
(const char *src, char *dst, int len, unsigned int sum, int *err_ptr)
{
	sum = csum_partial(src, len, sum);

	if (access_ok(VERIFY_WRITE, dst, len)) {
		if (copy_to_user(dst, src, len) == 0)
			return sum;
	}
	if (len)
		*err_ptr = -EFAULT;

	return -1; /* invalid checksum */
}
#endif

static inline unsigned int csum_add(unsigned int csum, unsigned int addend)
{
	csum += addend;
	return csum + (csum < addend);
}

static inline unsigned int csum_sub(unsigned int csum, unsigned int addend)
{
	return csum_add(csum, ~addend);
}

static inline unsigned int
csum_block_add(unsigned int csum, unsigned int csum2, int offset)
{
   1a8f5:	55                   	push   %ebp
   1a8f6:	89 e5                	mov    %esp,%ebp
   1a8f8:	83 ec 08             	sub    $0x8,%esp
	if (offset&1)
   1a8fb:	8b 45 10             	mov    0x10(%ebp),%eax
   1a8fe:	83 e0 01             	and    $0x1,%eax
   1a901:	85 c0                	test   %eax,%eax
   1a903:	74 1e                	je     1a923 <csum_block_add+0x2e>
		csum2 = ((csum2&0xFF00FF)<<8)+((csum2>>8)&0xFF00FF);
   1a905:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a908:	25 ff 00 ff 00       	and    $0xff00ff,%eax
   1a90d:	89 c2                	mov    %eax,%edx
   1a90f:	c1 e2 08             	shl    $0x8,%edx
   1a912:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a915:	c1 e8 08             	shr    $0x8,%eax
   1a918:	25 ff 00 ff 00       	and    $0xff00ff,%eax
   1a91d:	8d 04 10             	lea    (%eax,%edx,1),%eax
   1a920:	89 45 0c             	mov    %eax,0xc(%ebp)
	return csum_add(csum, csum2);
   1a923:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a926:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1a92a:	8b 45 08             	mov    0x8(%ebp),%eax
   1a92d:	89 04 24             	mov    %eax,(%esp,1)
   1a930:	e8 22 13 00 00       	call   1bc57 <csum_add>
}
   1a935:	c9                   	leave  
   1a936:	c3                   	ret    

0001a937 <tcp_set_state>:
};
#endif

static __inline__ void tcp_set_state(struct sock *sk, int state)
{
   1a937:	55                   	push   %ebp
   1a938:	89 e5                	mov    %esp,%ebp
   1a93a:	83 ec 18             	sub    $0x18,%esp
	int oldstate = sk->state;
   1a93d:	8b 45 08             	mov    0x8(%ebp),%eax
   1a940:	0f b6 40 20          	movzbl 0x20(%eax),%eax
   1a944:	0f b6 c0             	movzbl %al,%eax
   1a947:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

	switch (state) {
   1a94a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a94d:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1a950:	83 7d ec 01          	cmpl   $0x1,0xffffffec(%ebp)
   1a954:	74 0b                	je     1a961 <tcp_set_state+0x2a>
   1a956:	83 7d ec 07          	cmpl   $0x7,0xffffffec(%ebp)
   1a95a:	74 36                	je     1a992 <tcp_set_state+0x5b>
   1a95c:	e9 99 00 00 00       	jmp    1a9fa <tcp_set_state+0xc3>
	case TCP_ESTABLISHED:
		if (oldstate != TCP_ESTABLISHED)
   1a961:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
   1a965:	0f 84 b7 00 00 00    	je     1aa22 <tcp_set_state+0xeb>
			TCP_INC_STATS(TcpCurrEstab);
   1a96b:	83 3d 08 00 00 00 00 	cmpl   $0x0,0x8
   1a972:	75 09                	jne    1a97d <tcp_set_state+0x46>
   1a974:	c7 45 f8 60 00 00 00 	movl   $0x60,0xfffffff8(%ebp)
   1a97b:	eb 07                	jmp    1a984 <tcp_set_state+0x4d>
   1a97d:	c7 45 f8 20 00 00 00 	movl   $0x20,0xfffffff8(%ebp)
   1a984:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1a987:	ff 80 00 00 00 00    	incl   0x0(%eax)
		break;
   1a98d:	e9 90 00 00 00       	jmp    1aa22 <tcp_set_state+0xeb>

	case TCP_CLOSE:
		if (oldstate == TCP_CLOSE_WAIT || oldstate == TCP_ESTABLISHED)
   1a992:	83 7d fc 08          	cmpl   $0x8,0xfffffffc(%ebp)
   1a996:	74 08                	je     1a9a0 <tcp_set_state+0x69>
   1a998:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
   1a99c:	74 02                	je     1a9a0 <tcp_set_state+0x69>
   1a99e:	eb 22                	jmp    1a9c2 <tcp_set_state+0x8b>
			TCP_INC_STATS(TcpEstabResets);
   1a9a0:	83 3d 08 00 00 00 00 	cmpl   $0x0,0x8
   1a9a7:	75 09                	jne    1a9b2 <tcp_set_state+0x7b>
   1a9a9:	c7 45 f4 40 00 00 00 	movl   $0x40,0xfffffff4(%ebp)
   1a9b0:	eb 07                	jmp    1a9b9 <tcp_set_state+0x82>
   1a9b2:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
   1a9b9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1a9bc:	ff 80 1c 00 00 00    	incl   0x1c(%eax)

		sk->prot->unhash(sk);
   1a9c2:	8b 45 08             	mov    0x8(%ebp),%eax
   1a9c5:	8b 90 b8 00 00 00    	mov    0xb8(%eax),%edx
   1a9cb:	8b 45 08             	mov    0x8(%ebp),%eax
   1a9ce:	89 04 24             	mov    %eax,(%esp,1)
   1a9d1:	8b 42 3c             	mov    0x3c(%edx),%eax
   1a9d4:	ff d0                	call   *%eax
		if (sk->prev && !(sk->userlocks&SOCK_BINDPORT_LOCK))
   1a9d6:	8b 45 08             	mov    0x8(%ebp),%eax
   1a9d9:	83 78 7c 00          	cmpl   $0x0,0x7c(%eax)
   1a9dd:	74 1b                	je     1a9fa <tcp_set_state+0xc3>
   1a9df:	8b 45 08             	mov    0x8(%ebp),%eax
   1a9e2:	0f b6 80 8c 00 00 00 	movzbl 0x8c(%eax),%eax
   1a9e9:	24 08                	and    $0x8,%al
   1a9eb:	84 c0                	test   %al,%al
   1a9ed:	75 0b                	jne    1a9fa <tcp_set_state+0xc3>
			tcp_put_port(sk);
   1a9ef:	8b 45 08             	mov    0x8(%ebp),%eax
   1a9f2:	89 04 24             	mov    %eax,(%esp,1)
   1a9f5:	e8 fc ff ff ff       	call   1a9f6 <tcp_set_state+0xbf>
		/* fall through */
	default:
		if (oldstate==TCP_ESTABLISHED)
   1a9fa:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
   1a9fe:	75 22                	jne    1aa22 <tcp_set_state+0xeb>
			tcp_statistics[smp_processor_id()*2+!in_softirq()].TcpCurrEstab--;
   1aa00:	83 3d 08 00 00 00 00 	cmpl   $0x0,0x8
   1aa07:	75 09                	jne    1aa12 <tcp_set_state+0xdb>
   1aa09:	c7 45 f0 60 00 00 00 	movl   $0x60,0xfffffff0(%ebp)
   1aa10:	eb 07                	jmp    1aa19 <tcp_set_state+0xe2>
   1aa12:	c7 45 f0 20 00 00 00 	movl   $0x20,0xfffffff0(%ebp)
   1aa19:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1aa1c:	ff 88 00 00 00 00    	decl   0x0(%eax)
	}

	/* Change state AFTER socket is unhashed to avoid closed
	 * socket sitting in hash tables.
	 */
	sk->state = state;
   1aa22:	8b 55 08             	mov    0x8(%ebp),%edx
   1aa25:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
   1aa29:	88 42 20             	mov    %al,0x20(%edx)

#ifdef STATE_TRACE
	SOCK_DEBUG(sk, "TCP sk=%p, State %s -> %s\n",sk, statename[oldstate],statename[state]);
#endif	
}
   1aa2c:	c9                   	leave  
   1aa2d:	c3                   	ret    

0001aa2e <tcp_mem_reclaim>:

static __inline__ void tcp_done(struct sock *sk)
{
	tcp_set_state(sk, TCP_CLOSE);
	tcp_clear_xmit_timers(sk);

	sk->shutdown = SHUTDOWN_MASK;

	if (!sk->dead)
		sk->state_change(sk);
	else
		tcp_destroy_sock(sk);
}

static __inline__ void tcp_sack_reset(struct tcp_opt *tp)
{
	tp->dsack = 0;
	tp->eff_sacks = 0;
	tp->num_sacks = 0;
}

static __inline__ void tcp_build_and_update_options(__u32 *ptr, struct tcp_opt *tp, __u32 tstamp)
{
	if (tp->tstamp_ok) {
		*ptr++ = __constant_htonl((TCPOPT_NOP << 24) |
					  (TCPOPT_NOP << 16) |
					  (TCPOPT_TIMESTAMP << 8) |
					  TCPOLEN_TIMESTAMP);
		*ptr++ = htonl(tstamp);
		*ptr++ = htonl(tp->ts_recent);
	}
	if (tp->eff_sacks) {
		struct tcp_sack_block *sp = tp->dsack ? tp->duplicate_sack : tp->selective_acks;
		int this_sack;

		*ptr++ = __constant_htonl((TCPOPT_NOP << 24) |
					  (TCPOPT_NOP << 16) |
					  (TCPOPT_SACK << 8) |
					  (TCPOLEN_SACK_BASE +
					   (tp->eff_sacks * TCPOLEN_SACK_PERBLOCK)));
		for(this_sack = 0; this_sack < tp->eff_sacks; this_sack++) {
			*ptr++ = htonl(sp[this_sack].start_seq);
			*ptr++ = htonl(sp[this_sack].end_seq);
		}
		if (tp->dsack) {
			tp->dsack = 0;
			tp->eff_sacks--;
		}
	}
}

/* Construct a tcp options header for a SYN or SYN_ACK packet.
 * If this is every changed make sure to change the definition of
 * MAX_SYN_SIZE to match the new maximum number of options that you
 * can generate.
 */
static inline void tcp_syn_build_options(__u32 *ptr, int mss, int ts, int sack,
					     int offer_wscale, int wscale, __u32 tstamp, __u32 ts_recent)
{
	/* We always get an MSS option.
	 * The option bytes which will be seen in normal data
	 * packets should timestamps be used, must be in the MSS
	 * advertised.  But we subtract them from tp->mss_cache so
	 * that calculations in tcp_sendmsg are simpler etc.
	 * So account for this fact here if necessary.  If we
	 * don't do this correctly, as a receiver we won't
	 * recognize data packets as being full sized when we
	 * should, and thus we won't abide by the delayed ACK
	 * rules correctly.
	 * SACKs don't matter, we never delay an ACK when we
	 * have any of those going out.
	 */
	*ptr++ = htonl((TCPOPT_MSS << 24) | (TCPOLEN_MSS << 16) | mss);
	if (ts) {
		if(sack)
			*ptr++ = __constant_htonl((TCPOPT_SACK_PERM << 24) | (TCPOLEN_SACK_PERM << 16) |
						  (TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP);
		else
			*ptr++ = __constant_htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
						  (TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP);
		*ptr++ = htonl(tstamp);		/* TSVAL */
		*ptr++ = htonl(ts_recent);	/* TSECR */
	} else if(sack)
		*ptr++ = __constant_htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
					  (TCPOPT_SACK_PERM << 8) | TCPOLEN_SACK_PERM);
	if (offer_wscale)
		*ptr++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_WINDOW << 16) | (TCPOLEN_WINDOW << 8) | (wscale));
}

/* Determine a window scaling and initial window to offer.
 * Based on the assumption that the given amount of space
 * will be offered. Store the results in the tp structure.
 * NOTE: for smooth operation initial space offering should
 * be a multiple of mss if possible. We assume here that mss >= 1.
 * This MUST be enforced by all callers.
 */
static inline void tcp_select_initial_window(int __space, __u32 mss,
	__u32 *rcv_wnd,
	__u32 *window_clamp,
	int wscale_ok,
	__u8 *rcv_wscale)
{
	unsigned int space = (__space < 0 ? 0 : __space);

	/* If no clamp set the clamp to the max possible scaled window */
	if (*window_clamp == 0)
		(*window_clamp) = (65535 << 14);
	space = min(*window_clamp, space);

	/* Quantize space offering to a multiple of mss if possible. */
	if (space > mss)
		space = (space / mss) * mss;

	/* NOTE: offering an initial window larger than 32767
	 * will break some buggy TCP stacks. We try to be nice.
	 * If we are not window scaling, then this truncates
	 * our initial window offering to 32k. There should also
	 * be a sysctl option to stop being nice.
	 */
	(*rcv_wnd) = min(space, MAX_TCP_WINDOW);
	(*rcv_wscale) = 0;
	if (wscale_ok) {
		/* See RFC1323 for an explanation of the limit to 14 */
		while (space > 65535 && (*rcv_wscale) < 14) {
			space >>= 1;
			(*rcv_wscale)++;
		}
		if (*rcv_wscale && sysctl_tcp_app_win && space>=mss &&
		    space - max((space>>sysctl_tcp_app_win), mss>>*rcv_wscale) < 65536/2)
			(*rcv_wscale)--;
	}

	/* Set initial window to value enough for senders,
	 * following RFC1414. Senders, not following this RFC,
	 * will be satisfied with 2.
	 */
	if (mss > (1<<*rcv_wscale)) {
		int init_cwnd = 4;
		if (mss > 1460*3)
			init_cwnd = 2;
		else if (mss > 1460)
			init_cwnd = 3;
		if (*rcv_wnd > init_cwnd*mss)
			*rcv_wnd = init_cwnd*mss;
	}
	/* Set the clamp no higher than max representable value */
	(*window_clamp) = min(65535U << (*rcv_wscale), *window_clamp);
}

static inline int tcp_win_from_space(int space)
{
	return sysctl_tcp_adv_win_scale<=0 ?
		(space>>(-sysctl_tcp_adv_win_scale)) :
		space - (space>>sysctl_tcp_adv_win_scale);
}

/* Note: caller must be prepared to deal with negative returns */ 
static inline int tcp_space(struct sock *sk)
{
	return tcp_win_from_space(sk->rcvbuf - atomic_read(&sk->rmem_alloc));
} 

static inline int tcp_full_space( struct sock *sk)
{
	return tcp_win_from_space(sk->rcvbuf); 
}

static inline void tcp_acceptq_removed(struct sock *sk)
{
	sk->ack_backlog--;
}

static inline void tcp_acceptq_added(struct sock *sk)
{
	sk->ack_backlog++;
}

static inline int tcp_acceptq_is_full(struct sock *sk)
{
	return sk->ack_backlog > sk->max_ack_backlog;
}

static inline void tcp_acceptq_queue(struct sock *sk, struct open_request *req,
					 struct sock *child)
{
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;

	req->sk = child;
	tcp_acceptq_added(sk);

	if (!tp->accept_queue_tail) {
		tp->accept_queue = req;
	} else {
		tp->accept_queue_tail->dl_next = req;
	}
	tp->accept_queue_tail = req;
	req->dl_next = NULL;
}

struct tcp_listen_opt
{
	u8			max_qlen_log;	/* log_2 of maximal queued SYNs */
	int			qlen;
	int			qlen_young;
	int			clock_hand;
	u32			hash_rnd;
	struct open_request	*syn_table[TCP_SYNQ_HSIZE];
};

static inline void
tcp_synq_removed(struct sock *sk, struct open_request *req)
{
	struct tcp_listen_opt *lopt = sk->tp_pinfo.af_tcp.listen_opt;

	if (--lopt->qlen == 0)
		tcp_delete_keepalive_timer(sk);
	if (req->retrans == 0)
		lopt->qlen_young--;
}

static inline void tcp_synq_added(struct sock *sk)
{
	struct tcp_listen_opt *lopt = sk->tp_pinfo.af_tcp.listen_opt;

	if (lopt->qlen++ == 0)
		tcp_reset_keepalive_timer(sk, TCP_TIMEOUT_INIT);
	lopt->qlen_young++;
}

static inline int tcp_synq_len(struct sock *sk)
{
	return sk->tp_pinfo.af_tcp.listen_opt->qlen;
}

static inline int tcp_synq_young(struct sock *sk)
{
	return sk->tp_pinfo.af_tcp.listen_opt->qlen_young;
}

static inline int tcp_synq_is_full(struct sock *sk)
{
	return tcp_synq_len(sk)>>sk->tp_pinfo.af_tcp.listen_opt->max_qlen_log;
}

static inline void tcp_synq_unlink(struct tcp_opt *tp, struct open_request *req,
				       struct open_request **prev)
{
	write_lock(&tp->syn_wait_lock);
	*prev = req->dl_next;
	write_unlock(&tp->syn_wait_lock);
}

static inline void tcp_synq_drop(struct sock *sk, struct open_request *req,
				     struct open_request **prev)
{
	tcp_synq_unlink(&sk->tp_pinfo.af_tcp, req, prev);
	tcp_synq_removed(sk, req);
	tcp_openreq_free(req);
}

static __inline__ void tcp_openreq_init(struct open_request *req,
					struct tcp_opt *tp,
					struct sk_buff *skb)
{
	req->rcv_wnd = 0;		/* So that tcp_send_synack() knows! */
	req->rcv_isn = TCP_SKB_CB(skb)->seq;
	req->mss = tp->mss_clamp;
	req->ts_recent = tp->saw_tstamp ? tp->rcv_tsval : 0;
	req->tstamp_ok = tp->tstamp_ok;
	req->sack_ok = tp->sack_ok;
	req->snd_wscale = tp->snd_wscale;
	req->wscale_ok = tp->wscale_ok;
	req->acked = 0;
	req->ecn_ok = 0;
	req->rmt_port = skb->h.th->source;
}

#define TCP_MEM_QUANTUM	((int)PAGE_SIZE)

static inline void tcp_free_skb(struct sock *sk, struct sk_buff *skb)
{
	sk->tp_pinfo.af_tcp.queue_shrunk = 1;
	sk->wmem_queued -= skb->truesize;
	sk->forward_alloc += skb->truesize;
	__kfree_skb(skb);
}

static inline void tcp_charge_skb(struct sock *sk, struct sk_buff *skb)
{
	sk->wmem_queued += skb->truesize;
	sk->forward_alloc -= skb->truesize;
}

extern void __tcp_mem_reclaim(struct sock *sk);
extern int tcp_mem_schedule(struct sock *sk, int size, int kind);

static inline void tcp_mem_reclaim(struct sock *sk)
{
   1aa2e:	55                   	push   %ebp
   1aa2f:	89 e5                	mov    %esp,%ebp
   1aa31:	83 ec 04             	sub    $0x4,%esp
	if (sk->forward_alloc >= TCP_MEM_QUANTUM)
   1aa34:	8b 45 08             	mov    0x8(%ebp),%eax
   1aa37:	81 78 6c ff 0f 00 00 	cmpl   $0xfff,0x6c(%eax)
   1aa3e:	7e 0b                	jle    1aa4b <tcp_mem_reclaim+0x1d>
		__tcp_mem_reclaim(sk);
   1aa40:	8b 45 08             	mov    0x8(%ebp),%eax
   1aa43:	89 04 24             	mov    %eax,(%esp,1)
   1aa46:	e8 fc ff ff ff       	call   1aa47 <tcp_mem_reclaim+0x19>
}
   1aa4b:	c9                   	leave  
   1aa4c:	c3                   	ret    

0001aa4d <init_minisock>:
#ifndef _IN_TRICKLES_H
	#error "File can only be included from trickles.h"
#endif // _IN_TRICKLES_H 

static inline void init_minisock(struct cminisock *msk) {
   1aa4d:	55                   	push   %ebp
   1aa4e:	89 e5                	mov    %esp,%ebp
	msk->num_packets = 0;
   1aa50:	8b 45 08             	mov    0x8(%ebp),%eax
   1aa53:	c7 80 e8 00 00 00 00 	movl   $0x0,0xe8(%eax)
   1aa5a:	00 00 00 
	msk->ucont_len = 0;
   1aa5d:	8b 45 08             	mov    0x8(%ebp),%eax
   1aa60:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
	msk->ucont_data = NULL;
   1aa67:	8b 45 08             	mov    0x8(%ebp),%eax
   1aa6a:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	msk->input_len = 0;
   1aa71:	8b 45 08             	mov    0x8(%ebp),%eax
   1aa74:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
   1aa7b:	00 00 00 
	msk->input = NULL;
   1aa7e:	8b 45 08             	mov    0x8(%ebp),%eax
   1aa81:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
   1aa88:	00 00 00 
	msk->packets = NULL;
   1aa8b:	8b 45 08             	mov    0x8(%ebp),%eax
   1aa8e:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%eax)
   1aa95:	00 00 00 

	msk->refCnt = 1;
   1aa98:	8b 45 08             	mov    0x8(%ebp),%eax
   1aa9b:	c7 80 f0 00 00 00 01 	movl   $0x1,0xf0(%eax)
   1aaa2:	00 00 00 
#define HAS_VALID_CACHERECYCLEINDEX(MSK) ((MSK)->cacheRecycleIndex >= 0)
	msk->cacheRecycleIndex = -1; // invalid index
   1aaa5:	8b 45 08             	mov    0x8(%ebp),%eax
   1aaa8:	c7 80 f4 00 00 00 ff 	movl   $0xffffffff,0xf4(%eax)
   1aaaf:	ff ff ff 
	msk->serverSK = NULL;
   1aab2:	8b 45 08             	mov    0x8(%ebp),%eax
   1aab5:	c7 80 f8 00 00 00 00 	movl   $0x0,0xf8(%eax)
   1aabc:	00 00 00 
}
   1aabf:	5d                   	pop    %ebp
   1aac0:	c3                   	ret    

0001aac1 <alloc_trickles_msk>:

#ifdef CAN_USE_TFREE
static inline void free_minisock(struct sock *sk, struct cminisock *msk) {
	int i;
	/*
	printk("msk summary (%p [%d]) (%p [%d]) (%p [%d])\n", 
	       msk->packets, msk->num_packets,
	       msk->ucont_data, msk->ucont_len,
	       msk->input, msk->input_len);
	*/
	for(i=0; i < msk->num_packets; i++) {
		if(msk->packets[i].ucontData != NULL) {
			kfree(msk->packets[i].ucontData);
		}
	}
	// printk("done with packet data\n");
	if(!SIMULATION_MODE(sk) && msk->packets) {
		tfree(sk,msk->packets);
		msk->packets = NULL;
	}
	// printk("done with packet array\n");
	msk->num_packets = 0;

	if(msk->ucont_data != NULL) {
		tfree(sk,msk->ucont_data);
		msk->ucont_data = NULL;
	}
	// printk("done with ucont data\n");
	msk->ucont_len = 0;
	if(msk->input != NULL) {
		tfree(sk,msk->input);
		msk->input = NULL;
	}
	// printk("done with input len\n");
	msk->input_len = 0;
}

static inline void msk_free_fields(struct sock *sk, struct cminisock *msk) {
	free_minisock(sk, msk);
}

static inline void msk_clear_fields(struct cminisock *msk) {
	msk->num_packets = 0;
	msk->packets = NULL;

	msk->ucont_len = 0;
	msk->ucont_data = NULL;

	msk->input_len = 0;
	msk->input = NULL;
}

#endif

#ifndef USERTEST

static inline int alloc_msk_packets(struct cminisock *msk, int numPackets) {
	BUG_TRAP(msk->num_packets == 0);
	BUG_TRAP(numPackets >= 0);
#define MAX_NUM_SIMULATION_PACKETS (8000)
	static struct cminisock_packet packets[NR_CPUS][MAX_NUM_SIMULATION_PACKETS];
	if(!SIMULATION_MODE(msk->sk)) {
		msk->packets = tmalloc(msk->sk, sizeof(struct cminisock_packet) * numPackets);

		// printk("allocated packets to %p\n", msk->packets);

		if(msk->packets == NULL) {
			if(trickles_ratelimit()) {
				printk("out of memory while tmalloc()'ing space for packets\n");
			}
			return 0;
		}
	} else {
		// avoid malloc
		if(numPackets <= MAX_NUM_SIMULATION_PACKETS) {
			msk->packets = packets[smp_processor_id()];
		} else {
			msk->packets = NULL;
			if(trickles_ratelimit()) {
				printk("Too many packets requested during simulation\n");
			}
			return 0;
		}
	}
	msk->num_packets = numPackets;
	return 1;
}

static inline
int can_alloc_trickles_msk(struct sock *sk) {
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
	struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
	struct cminisock *curr =
		(struct cminisock *)head->next;
	while((struct alloc_head_list*)curr != head && curr->ctl == ALLOC_PROCESSING) {
		//printk("alloc_head loop\n");
		curr = curr->next;
	}
	return (struct alloc_head_list*)curr != head;
}

static inline struct cminisock *alloc_trickles_msk(struct sock *sk) {
   1aac1:	55                   	push   %ebp
   1aac2:	89 e5                	mov    %esp,%ebp
   1aac4:	83 ec 1c             	sub    $0x1c,%esp
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
   1aac7:	8b 45 08             	mov    0x8(%ebp),%eax
   1aaca:	05 bc 00 00 00       	add    $0xbc,%eax
   1aacf:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
   1aad2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1aad5:	05 d4 01 00 00       	add    $0x1d4,%eax
   1aada:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	struct cminisock *rval = NULL, *curr = (struct cminisock *)tp->cminisock_api_config.msk_freelist.next;
   1aadd:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
   1aae4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1aae7:	8b 80 d8 01 00 00    	mov    0x1d8(%eax),%eax
   1aaed:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

	if(!SIMULATION_MODE(sk)) {
   1aaf0:	8b 45 08             	mov    0x8(%ebp),%eax
   1aaf3:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   1aaf9:	83 e0 01             	and    $0x1,%eax
   1aafc:	85 c0                	test   %eax,%eax
   1aafe:	74 1b                	je     1ab1b <alloc_trickles_msk+0x5a>
   1ab00:	8b 55 08             	mov    0x8(%ebp),%edx
   1ab03:	8b 45 08             	mov    0x8(%ebp),%eax
   1ab06:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   1ab0c:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
   1ab12:	83 e0 08             	and    $0x8,%eax
   1ab15:	85 c0                	test   %eax,%eax
   1ab17:	75 02                	jne    1ab1b <alloc_trickles_msk+0x5a>
   1ab19:	eb 52                	jmp    1ab6d <alloc_trickles_msk+0xac>
		while((struct alloc_head_list*)curr != head && curr->ctl == ALLOC_PROCESSING) {
   1ab1b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1ab1e:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
   1ab21:	74 16                	je     1ab39 <alloc_trickles_msk+0x78>
   1ab23:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1ab26:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
   1ab2a:	74 02                	je     1ab2e <alloc_trickles_msk+0x6d>
   1ab2c:	eb 0b                	jmp    1ab39 <alloc_trickles_msk+0x78>
			//printk("alloc_head loop\n");
			curr = curr->next;
   1ab2e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1ab31:	8b 40 04             	mov    0x4(%eax),%eax
   1ab34:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1ab37:	eb e2                	jmp    1ab1b <alloc_trickles_msk+0x5a>
		}
		//printk("out of alloc_head loop\n");

		if((struct alloc_head_list *)curr == head) return NULL;
   1ab39:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1ab3c:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
   1ab3f:	75 0c                	jne    1ab4d <alloc_trickles_msk+0x8c>
   1ab41:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
   1ab48:	e9 ea 00 00 00       	jmp    1ac37 <alloc_trickles_msk+0x176>

		rval = curr;
   1ab4d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1ab50:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		unlink((struct alloc_head*)rval);
   1ab53:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1ab56:	89 04 24             	mov    %eax,(%esp,1)
   1ab59:	e8 ed fa ff ff       	call   1a64b <unlink>
		rval->ctl = ALLOC_PENDING;
   1ab5e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1ab61:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
   1ab68:	e9 b9 00 00 00       	jmp    1ac26 <alloc_trickles_msk+0x165>
	} else {
		if(tp->t.responseCount == 0) {
   1ab6d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1ab70:	83 b8 7c 0a 00 00 00 	cmpl   $0x0,0xa7c(%eax)
   1ab77:	75 2b                	jne    1aba4 <alloc_trickles_msk+0xe3>
			rval = tp->t.responseMSK;
   1ab79:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1ab7c:	8b 80 64 0a 00 00    	mov    0xa64(%eax),%eax
   1ab82:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
			rval->list = NULL;
   1ab85:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1ab88:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
			rval->next = rval->prev = NULL;
   1ab8f:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   1ab92:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1ab95:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1ab9b:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
   1aba2:	eb 66                	jmp    1ac0a <alloc_trickles_msk+0x149>
		} else {
			rval = kmalloc(sizeof (struct cminisock), GFP_ATOMIC);
   1aba4:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
   1abab:	00 
   1abac:	c7 04 24 fc 00 00 00 	movl   $0xfc,(%esp,1)
   1abb3:	e8 fc ff ff ff       	call   1abb4 <alloc_trickles_msk+0xf3>
   1abb8:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
			if(rval == NULL) {
   1abbb:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
   1abbf:	75 15                	jne    1abd6 <alloc_trickles_msk+0x115>
				printk("out of memory during compatibility mode\n");
   1abc1:	c7 04 24 00 70 00 00 	movl   $0x7000,(%esp,1)
   1abc8:	e8 fc ff ff ff       	call   1abc9 <alloc_trickles_msk+0x108>
				return NULL;
   1abcd:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
   1abd4:	eb 61                	jmp    1ac37 <alloc_trickles_msk+0x176>
			}
			rval->next = rval->prev = NULL;
   1abd6:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   1abd9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1abdc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1abe2:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
			rval->list = NULL;
   1abe9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1abec:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
			insert_tail(&tp->t.responseList, (struct alloc_head*)rval);
   1abf3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1abf6:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1abfa:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1abfd:	05 68 0a 00 00       	add    $0xa68,%eax
   1ac02:	89 04 24             	mov    %eax,(%esp,1)
   1ac05:	e8 4b f9 ff ff       	call   1a555 <insert_tail>
		}
		tp->t.responseCount++;
   1ac0a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1ac0d:	ff 80 7c 0a 00 00    	incl   0xa7c(%eax)

		rval->sk = sk;
   1ac13:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   1ac16:	8b 45 08             	mov    0x8(%ebp),%eax
   1ac19:	89 42 20             	mov    %eax,0x20(%edx)
		rval->ctl = ALLOC_PENDING;
   1ac1c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1ac1f:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	}

	init_minisock(rval);
   1ac26:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1ac29:	89 04 24             	mov    %eax,(%esp,1)
   1ac2c:	e8 1c fe ff ff       	call   1aa4d <init_minisock>

	return rval;
   1ac31:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1ac34:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
}
   1ac37:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1ac3a:	c9                   	leave  
   1ac3b:	c3                   	ret    

0001ac3c <msk_release>:

static inline void msk_hold(struct cminisock *msk) {
	msk->refCnt++;
}

#endif // USERTEST

static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk);
static inline void free_trickles_msk_finish(struct sock *sk, struct cminisock *msk);

static inline struct cminisock *
shallow_copy_msk(struct sock *sk, struct cminisock *msk) {
	struct cminisock *rval = alloc_trickles_msk(sk);

	struct alloc_head head;

	if(rval == NULL) {
		printk("out of memory while copying msk\n");
		return NULL;
	}
	/* save & restore alloc head */
	head = *(struct alloc_head*)rval;
	*rval = *msk;
	*(struct alloc_head*)rval = head;

	rval->refCnt = 1;

	return rval;
}


#ifdef CAN_USE_TFREE
static inline struct cminisock *copy_msk(struct sock *sk, struct cminisock *msk) {
	// Copy everything except for per-packet information.

	printk("CopyMSK\n");
#if 0
	struct cminisock *rval = alloc_trickles_msk(sk);
	struct alloc_head head;
	if(rval == NULL) {
		printk("out of memory while copying msk\n");
		return NULL;
	}
	/* save & restore alloc head */
	head = *(struct alloc_head*)rval;
	*rval = *msk;
	*(struct alloc_head*)rval = head;
#else
	struct cminisock *rval = shallow_copy_msk(sk, msk);
	if(rval == NULL) {
		printk("out of memory while copying msk\n");
		return NULL;
	}
#endif

	rval->num_packets = 0;
	rval->packets = NULL;

	if(rval->ucont_len > 0) {
		rval->ucont_data = tmalloc(sk,rval->ucont_len);
		// printk("copymsk: tmalloc ucontdata\n");
		if(rval->ucont_data == NULL) {
			printk("out of tmalloc memory while copying msk (len = %d)\n", rval->ucont_len);
			free_trickles_msk(sk,rval);
			free_trickles_msk_finish(sk,rval);
			return NULL;
		}
	} else {
		rval->ucont_data = NULL;
	}
	if(rval->input_len > 0) {
		rval->input = tmalloc(sk,rval->input_len);
		// printk("copymsk: tmalloc inputlen\n");
		if(rval->input == NULL) {
			printk("out of tmalloc memory while copying msk (len = %d)\n", rval->input_len);
			tfree(sk,rval->ucont_data);
			free_trickles_msk(sk,rval);
			free_trickles_msk_finish(sk,rval);
			return NULL;
		}
	} else {
		rval->input = NULL;
	}
	if(rval->ucont_data)
		memcpy(rval->ucont_data,msk->ucont_data,rval->ucont_len);
	if(rval->input)
		memcpy(rval->input,msk->input,rval->input_len);

	rval->executionTrace |= 0x80;
	return rval;
}
#endif // CAN_USE_TFREE

/* Two phase free: first phase disconnects socket from event list,
   sets to ALLOC_PROCESSING; second phase adds the socket to free
   list, sets to ALLOC_FREE and ready for reuse */
#ifndef USERTEST
static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk) {
	if(!SIMULATION_MODE(sk)) {
		if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) {
			printk("double free\n");
			BUG();
		}
		if(msk->ctl == ALLOC_READY && msk->prev != NULL) {
			unlink((struct alloc_head *)msk);
		}
		msk->ctl = ALLOC_PROCESSING;
	}
}

static inline void msk_release(struct sock *sk, struct cminisock *msk) {
   1ac3c:	55                   	push   %ebp
   1ac3d:	89 e5                	mov    %esp,%ebp
   1ac3f:	83 ec 10             	sub    $0x10,%esp
	// Perform actual deallocation. This function is common to
	// state cache and event queue
	msk->refCnt--;
   1ac42:	8b 45 0c             	mov    0xc(%ebp),%eax
   1ac45:	ff 88 f0 00 00 00    	decl   0xf0(%eax)
	BUG_TRAP(msk->refCnt >= 0);
   1ac4b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1ac4e:	83 b8 f0 00 00 00 00 	cmpl   $0x0,0xf0(%eax)
   1ac55:	79 14                	jns    1ac6b <msk_release+0x2f>
   1ac57:	c7 44 24 04 13 01 00 	movl   $0x113,0x4(%esp,1)
   1ac5e:	00 
   1ac5f:	c7 04 24 40 70 00 00 	movl   $0x7040,(%esp,1)
   1ac66:	e8 fc ff ff ff       	call   1ac67 <msk_release+0x2b>
	if(msk->refCnt == 0) {
   1ac6b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1ac6e:	83 b8 f0 00 00 00 00 	cmpl   $0x0,0xf0(%eax)
   1ac75:	0f 85 a0 00 00 00    	jne    1ad1b <msk_release+0xdf>
		// printk("release: refcnt %p\n", msk);
		struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
   1ac7b:	8b 45 08             	mov    0x8(%ebp),%eax
   1ac7e:	05 bc 00 00 00       	add    $0xbc,%eax
   1ac83:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
		struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
   1ac86:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1ac89:	05 d4 01 00 00       	add    $0x1d4,%eax
   1ac8e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

		free_minisock(sk,msk);
   1ac91:	8b 45 0c             	mov    0xc(%ebp),%eax
   1ac94:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1ac98:	8b 45 08             	mov    0x8(%ebp),%eax
   1ac9b:	89 04 24             	mov    %eax,(%esp,1)
   1ac9e:	e8 d6 0f 00 00       	call   1bc79 <free_minisock>
		if(!SIMULATION_MODE(sk)) {
   1aca3:	8b 45 08             	mov    0x8(%ebp),%eax
   1aca6:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   1acac:	83 e0 01             	and    $0x1,%eax
   1acaf:	85 c0                	test   %eax,%eax
   1acb1:	74 1b                	je     1acce <msk_release+0x92>
   1acb3:	8b 55 08             	mov    0x8(%ebp),%edx
   1acb6:	8b 45 08             	mov    0x8(%ebp),%eax
   1acb9:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   1acbf:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
   1acc5:	83 e0 08             	and    $0x8,%eax
   1acc8:	85 c0                	test   %eax,%eax
   1acca:	75 02                	jne    1acce <msk_release+0x92>
   1accc:	eb 1e                	jmp    1acec <msk_release+0xb0>
			insert_head(head, (struct alloc_head *)msk);
   1acce:	8b 45 0c             	mov    0xc(%ebp),%eax
   1acd1:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1acd5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1acd8:	89 04 24             	mov    %eax,(%esp,1)
   1acdb:	e8 c5 0e 00 00       	call   1bba5 <insert_head>
			msk->ctl = ALLOC_FREE;
   1ace0:	8b 45 0c             	mov    0xc(%ebp),%eax
   1ace3:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
   1acea:	eb 2f                	jmp    1ad1b <msk_release+0xdf>
		} else {
			if(msk == tp->t.responseMSK) {
   1acec:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1acef:	8b 45 0c             	mov    0xc(%ebp),%eax
   1acf2:	3b 82 64 0a 00 00    	cmp    0xa64(%edx),%eax
   1acf8:	75 02                	jne    1acfc <msk_release+0xc0>
   1acfa:	eb 16                	jmp    1ad12 <msk_release+0xd6>
			} else {
				// overflow
				unlink((struct alloc_head*)msk);
   1acfc:	8b 45 0c             	mov    0xc(%ebp),%eax
   1acff:	89 04 24             	mov    %eax,(%esp,1)
   1ad02:	e8 44 f9 ff ff       	call   1a64b <unlink>
				kfree(msk);
   1ad07:	8b 45 0c             	mov    0xc(%ebp),%eax
   1ad0a:	89 04 24             	mov    %eax,(%esp,1)
   1ad0d:	e8 fc ff ff ff       	call   1ad0e <msk_release+0xd2>
			}
			tp->t.responseCount--;
   1ad12:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1ad15:	ff 88 7c 0a 00 00    	decl   0xa7c(%eax)
		}
	} else {
		//printk("release: refcnt == %d\n", msk->refCnt);
	}
}
   1ad1b:	c9                   	leave  
   1ad1c:	c3                   	ret    

0001ad1d <recycle>:
	kfree_skb(skb);
}
#endif

static inline struct sk_buff *recycle(struct sock *sk) {
   1ad1d:	55                   	push   %ebp
   1ad1e:	89 e5                	mov    %esp,%ebp
   1ad20:	83 ec 0c             	sub    $0xc,%esp
	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
   1ad23:	8b 45 08             	mov    0x8(%ebp),%eax
   1ad26:	05 bc 00 00 00       	add    $0xbc,%eax
   1ad2b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	// Attempt to improve cache performance by using most recently enqueued packets first
	struct sk_buff *skb = __skb_dequeue_tail(&tp->t.recycleList);
   1ad2e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1ad31:	05 58 0a 00 00       	add    $0xa58,%eax
   1ad36:	89 04 24             	mov    %eax,(%esp,1)
   1ad39:	e8 6c 0d 00 00       	call   1baaa <__skb_dequeue_tail>
   1ad3e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
#if 0
	if(skb) {
		if(trickles_ratelimit()) {
			printk("recycle successful\n");
		}
	} else {
		if(trickles_ratelimit()) {
			printk("recycle unsuccessful\n");
		}
	}
#endif
	return skb;
   1ad41:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
}
   1ad44:	c9                   	leave  
   1ad45:	c3                   	ret    

0001ad46 <vmalloc>:
 *	Allocate any pages
 */
 
static inline void * vmalloc (unsigned long size)
{
   1ad46:	55                   	push   %ebp
   1ad47:	89 e5                	mov    %esp,%ebp
   1ad49:	83 ec 10             	sub    $0x10,%esp
	return __vmalloc(size, GFP_KERNEL | __GFP_HIGHMEM, PAGE_KERNEL);
   1ad4c:	c7 45 fc 63 01 00 00 	movl   $0x163,0xfffffffc(%ebp)
   1ad53:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1ad56:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1ad5a:	c7 44 24 04 f2 01 00 	movl   $0x1f2,0x4(%esp,1)
   1ad61:	00 
   1ad62:	8b 45 08             	mov    0x8(%ebp),%eax
   1ad65:	89 04 24             	mov    %eax,(%esp,1)
   1ad68:	e8 fc ff ff ff       	call   1ad69 <vmalloc+0x23>
}
   1ad6d:	c9                   	leave  
   1ad6e:	c3                   	ret    

0001ad6f <fill_page_desc>:
   1ad6f:	55                   	push   %ebp
   1ad70:	89 e5                	mov    %esp,%ebp
   1ad72:	83 ec 04             	sub    $0x4,%esp
   1ad75:	8b 55 08             	mov    0x8(%ebp),%edx
   1ad78:	8b 45 0c             	mov    0xc(%ebp),%eax
   1ad7b:	c1 e0 03             	shl    $0x3,%eax
   1ad7e:	03 82 c0 00 00 00    	add    0xc0(%edx),%eax
   1ad84:	83 c0 0c             	add    $0xc,%eax
   1ad87:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   1ad8a:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1ad8d:	8b 45 10             	mov    0x10(%ebp),%eax
   1ad90:	89 02                	mov    %eax,(%edx)
   1ad92:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1ad95:	8b 45 14             	mov    0x14(%ebp),%eax
   1ad98:	66 89 42 04          	mov    %ax,0x4(%edx)
   1ad9c:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1ad9f:	8b 45 18             	mov    0x18(%ebp),%eax
   1ada2:	66 89 42 06          	mov    %ax,0x6(%edx)
   1ada6:	8b 45 08             	mov    0x8(%ebp),%eax
   1ada9:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
   1adaf:	8b 45 0c             	mov    0xc(%ebp),%eax
   1adb2:	40                   	inc    %eax
   1adb3:	89 42 04             	mov    %eax,0x4(%edx)
   1adb6:	c9                   	leave  
   1adb7:	c3                   	ret    

0001adb8 <new_event>:
   1adb8:	55                   	push   %ebp
   1adb9:	89 e5                	mov    %esp,%ebp
   1adbb:	83 ec 08             	sub    $0x8,%esp
   1adbe:	8b 45 08             	mov    0x8(%ebp),%eax
   1adc1:	8b 40 3c             	mov    0x3c(%eax),%eax
   1adc4:	b9 01 00 00 00       	mov    $0x1,%ecx
   1adc9:	ba 01 00 00 00       	mov    $0x1,%edx
   1adce:	e8 fc ff ff ff       	call   1adcf <new_event+0x17>
   1add3:	8b 45 08             	mov    0x8(%ebp),%eax
   1add6:	0f b6 80 80 00 00 00 	movzbl 0x80(%eax),%eax
   1addd:	84 c0                	test   %al,%al
   1addf:	75 19                	jne    1adfa <new_event+0x42>
   1ade1:	8b 45 08             	mov    0x8(%ebp),%eax
   1ade4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
   1adeb:	00 
   1adec:	8b 55 08             	mov    0x8(%ebp),%edx
   1adef:	89 14 24             	mov    %edx,(%esp,1)
   1adf2:	8b 80 d4 0b 00 00    	mov    0xbd4(%eax),%eax
   1adf8:	ff d0                	call   *%eax
   1adfa:	8b 45 08             	mov    0x8(%ebp),%eax
   1adfd:	8b 80 88 02 00 00    	mov    0x288(%eax),%eax
   1ae03:	83 c0 3c             	add    $0x3c,%eax
   1ae06:	89 04 24             	mov    %eax,(%esp,1)
   1ae09:	e8 0a ef ff ff       	call   19d18 <atomic_inc>
   1ae0e:	c9                   	leave  
   1ae0f:	c3                   	ret    

0001ae10 <trickles_do_sendmsg_tiov>:
   1ae10:	55                   	push   %ebp
   1ae11:	89 e5                	mov    %esp,%ebp
   1ae13:	81 ec 20 0c 00 00    	sub    $0xc20,%esp
   1ae19:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   1ae20:	8b 45 08             	mov    0x8(%ebp),%eax
   1ae23:	05 bc 00 00 00       	add    $0xbc,%eax
   1ae28:	89 85 08 f4 ff ff    	mov    %eax,0xfffff408(%ebp)
   1ae2e:	8d 85 0c f4 ff ff    	lea    0xfffff40c(%ebp),%eax
   1ae34:	05 bc 00 00 00       	add    $0xbc,%eax
   1ae39:	89 85 04 f4 ff ff    	mov    %eax,0xfffff404(%ebp)
   1ae3f:	8b 95 04 f4 ff ff    	mov    0xfffff404(%ebp),%edx
   1ae45:	8b 85 08 f4 ff ff    	mov    0xfffff408(%ebp),%eax
   1ae4b:	8b 80 ec 01 00 00    	mov    0x1ec(%eax),%eax
   1ae51:	89 82 ec 01 00 00    	mov    %eax,0x1ec(%edx)
   1ae57:	8b 95 04 f4 ff ff    	mov    0xfffff404(%ebp),%edx
   1ae5d:	8b 85 08 f4 ff ff    	mov    0xfffff408(%ebp),%eax
   1ae63:	8b 80 28 0a 00 00    	mov    0xa28(%eax),%eax
   1ae69:	89 82 28 0a 00 00    	mov    %eax,0xa28(%edx)
   1ae6f:	8b 95 04 f4 ff ff    	mov    0xfffff404(%ebp),%edx
   1ae75:	8b 85 08 f4 ff ff    	mov    0xfffff408(%ebp),%eax
   1ae7b:	8b 80 3c 0a 00 00    	mov    0xa3c(%eax),%eax
   1ae81:	89 82 3c 0a 00 00    	mov    %eax,0xa3c(%edx)
   1ae87:	8d 85 0c f4 ff ff    	lea    0xfffff40c(%ebp),%eax
   1ae8d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1ae91:	8b 45 0c             	mov    0xc(%ebp),%eax
   1ae94:	89 04 24             	mov    %eax,(%esp,1)
   1ae97:	e8 4b 0f 00 00       	call   1bde7 <init_sock>
   1ae9c:	8b 55 0c             	mov    0xc(%ebp),%edx
   1ae9f:	8b 45 08             	mov    0x8(%ebp),%eax
   1aea2:	89 82 f8 00 00 00    	mov    %eax,0xf8(%edx)
   1aea8:	8b 45 0c             	mov    0xc(%ebp),%eax
   1aeab:	8b 80 d4 00 00 00    	mov    0xd4(%eax),%eax
   1aeb1:	a3 a0 a2 11 00       	mov    %eax,0x11a2a0
   1aeb6:	8b 45 0c             	mov    0xc(%ebp),%eax
   1aeb9:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
   1aebd:	74 14                	je     1aed3 <trickles_do_sendmsg_tiov+0xc3>
   1aebf:	8b 45 0c             	mov    0xc(%ebp),%eax
   1aec2:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
   1aec6:	74 0b                	je     1aed3 <trickles_do_sendmsg_tiov+0xc3>
   1aec8:	8b 45 0c             	mov    0xc(%ebp),%eax
   1aecb:	83 78 10 02          	cmpl   $0x2,0x10(%eax)
   1aecf:	74 02                	je     1aed3 <trickles_do_sendmsg_tiov+0xc3>
   1aed1:	eb 25                	jmp    1aef8 <trickles_do_sendmsg_tiov+0xe8>
   1aed3:	8b 45 14             	mov    0x14(%ebp),%eax
   1aed6:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   1aeda:	8b 45 10             	mov    0x10(%ebp),%eax
   1aedd:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1aee1:	8b 45 0c             	mov    0xc(%ebp),%eax
   1aee4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1aee8:	8b 45 08             	mov    0x8(%ebp),%eax
   1aeeb:	89 04 24             	mov    %eax,(%esp,1)
   1aeee:	e8 f0 80 ff ff       	call   12fe3 <tiov_handler>
   1aef3:	e9 b4 01 00 00       	jmp    1b0ac <trickles_do_sendmsg_tiov+0x29c>
   1aef8:	8b 45 08             	mov    0x8(%ebp),%eax
   1aefb:	89 04 24             	mov    %eax,(%esp,1)
   1aefe:	e8 1a fe ff ff       	call   1ad1d <recycle>
   1af03:	89 85 00 f4 ff ff    	mov    %eax,0xfffff400(%ebp)
   1af09:	83 bd 00 f4 ff ff 00 	cmpl   $0x0,0xfffff400(%ebp)
   1af10:	75 20                	jne    1af32 <trickles_do_sendmsg_tiov+0x122>
   1af12:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
   1af19:	00 
   1af1a:	a1 00 00 00 00       	mov    0x0,%eax
   1af1f:	05 f2 00 00 00       	add    $0xf2,%eax
   1af24:	89 04 24             	mov    %eax,(%esp,1)
   1af27:	e8 fc ff ff ff       	call   1af28 <trickles_do_sendmsg_tiov+0x118>
   1af2c:	89 85 00 f4 ff ff    	mov    %eax,0xfffff400(%ebp)
   1af32:	83 bd 00 f4 ff ff 00 	cmpl   $0x0,0xfffff400(%ebp)
   1af39:	75 11                	jne    1af4c <trickles_do_sendmsg_tiov+0x13c>
   1af3b:	c7 04 24 8c 55 00 00 	movl   $0x558c,(%esp,1)
   1af42:	e8 fc ff ff ff       	call   1af43 <trickles_do_sendmsg_tiov+0x133>
   1af47:	e9 60 01 00 00       	jmp    1b0ac <trickles_do_sendmsg_tiov+0x29c>
   1af4c:	8b 85 00 f4 ff ff    	mov    0xfffff400(%ebp),%eax
   1af52:	83 c0 30             	add    $0x30,%eax
   1af55:	89 85 fc f3 ff ff    	mov    %eax,0xfffff3fc(%ebp)
   1af5b:	8b 85 00 f4 ff ff    	mov    0xfffff400(%ebp),%eax
   1af61:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
   1af68:	00 00 00 
   1af6b:	8b 85 00 f4 ff ff    	mov    0xfffff400(%ebp),%eax
   1af71:	c6 80 a3 00 00 00 01 	movb   $0x1,0xa3(%eax)
   1af78:	a1 00 00 00 00       	mov    0x0,%eax
   1af7d:	05 f2 00 00 00       	add    $0xf2,%eax
   1af82:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1af86:	8b 85 00 f4 ff ff    	mov    0xfffff400(%ebp),%eax
   1af8c:	89 04 24             	mov    %eax,(%esp,1)
   1af8f:	e8 91 f1 ff ff       	call   1a125 <skb_reserve>
   1af94:	8b 45 0c             	mov    0xc(%ebp),%eax
   1af97:	8b 40 10             	mov    0x10(%eax),%eax
   1af9a:	89 85 f0 f3 ff ff    	mov    %eax,0xfffff3f0(%ebp)
   1afa0:	83 bd f0 f3 ff ff 00 	cmpl   $0x0,0xfffff3f0(%ebp)
   1afa7:	74 0b                	je     1afb4 <trickles_do_sendmsg_tiov+0x1a4>
   1afa9:	83 bd f0 f3 ff ff 03 	cmpl   $0x3,0xfffff3f0(%ebp)
   1afb0:	74 29                	je     1afdb <trickles_do_sendmsg_tiov+0x1cb>
   1afb2:	eb 3a                	jmp    1afee <trickles_do_sendmsg_tiov+0x1de>
   1afb4:	c7 44 24 04 59 53 00 	movl   $0x5359,0x4(%esp,1)
   1afbb:	00 
   1afbc:	c7 04 24 5d 53 00 00 	movl   $0x535d,(%esp,1)
   1afc3:	e8 fc ff ff ff       	call   1afc4 <trickles_do_sendmsg_tiov+0x1b4>
   1afc8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1afcf:	e8 fc ff ff ff       	call   1afd0 <trickles_do_sendmsg_tiov+0x1c0>
   1afd4:	e8 fc ff ff ff       	call   1afd5 <trickles_do_sendmsg_tiov+0x1c5>
   1afd9:	eb 3a                	jmp    1b015 <trickles_do_sendmsg_tiov+0x205>
   1afdb:	8b 85 00 f4 ff ff    	mov    0xfffff400(%ebp),%eax
   1afe1:	89 04 24             	mov    %eax,(%esp,1)
   1afe4:	e8 b7 ef ff ff       	call   19fa0 <kfree_skb>
   1afe9:	e9 be 00 00 00       	jmp    1b0ac <trickles_do_sendmsg_tiov+0x29c>
   1afee:	8b 85 00 f4 ff ff    	mov    0xfffff400(%ebp),%eax
   1aff4:	89 04 24             	mov    %eax,(%esp,1)
   1aff7:	e8 a4 ef ff ff       	call   19fa0 <kfree_skb>
   1affc:	c7 44 24 04 3e 01 00 	movl   $0x13e,0x4(%esp,1)
   1b003:	00 
   1b004:	c7 04 24 c0 70 00 00 	movl   $0x70c0,(%esp,1)
   1b00b:	e8 fc ff ff ff       	call   1b00c <trickles_do_sendmsg_tiov+0x1fc>
   1b010:	e9 97 00 00 00       	jmp    1b0ac <trickles_do_sendmsg_tiov+0x29c>
   1b015:	c7 85 f8 f3 ff ff 00 	movl   $0x0,0xfffff3f8(%ebp)
   1b01c:	00 00 00 
   1b01f:	8b 55 0c             	mov    0xc(%ebp),%edx
   1b022:	8b 85 f8 f3 ff ff    	mov    0xfffff3f8(%ebp),%eax
   1b028:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
   1b02e:	7c 02                	jl     1b032 <trickles_do_sendmsg_tiov+0x222>
   1b030:	eb 6c                	jmp    1b09e <trickles_do_sendmsg_tiov+0x28e>
   1b032:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
   1b039:	00 
   1b03a:	8b 85 00 f4 ff ff    	mov    0xfffff400(%ebp),%eax
   1b040:	89 04 24             	mov    %eax,(%esp,1)
   1b043:	e8 fc ff ff ff       	call   1b044 <trickles_do_sendmsg_tiov+0x234>
   1b048:	89 85 f4 f3 ff ff    	mov    %eax,0xfffff3f4(%ebp)
   1b04e:	8b 85 f4 f3 ff ff    	mov    0xfffff3f4(%ebp),%eax
   1b054:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
   1b05b:	00 00 00 
   1b05e:	8b 85 f4 f3 ff ff    	mov    0xfffff3f4(%ebp),%eax
   1b064:	c6 80 a3 00 00 00 01 	movb   $0x1,0xa3(%eax)
   1b06b:	8b 85 f8 f3 ff ff    	mov    0xfffff3f8(%ebp),%eax
   1b071:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1b075:	8b 85 f4 f3 ff ff    	mov    0xfffff3f4(%ebp),%eax
   1b07b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b07f:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b082:	89 04 24             	mov    %eax,(%esp,1)
   1b085:	e8 fc ff ff ff       	call   1b086 <trickles_do_sendmsg_tiov+0x276>
   1b08a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b08d:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
   1b094:	8d 85 f8 f3 ff ff    	lea    0xfffff3f8(%ebp),%eax
   1b09a:	ff 00                	incl   (%eax)
   1b09c:	eb 81                	jmp    1b01f <trickles_do_sendmsg_tiov+0x20f>
   1b09e:	8b 85 00 f4 ff ff    	mov    0xfffff400(%ebp),%eax
   1b0a4:	89 04 24             	mov    %eax,(%esp,1)
   1b0a7:	e8 f4 ee ff ff       	call   19fa0 <kfree_skb>
   1b0ac:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
   1b0b3:	74 5d                	je     1b112 <trickles_do_sendmsg_tiov+0x302>
   1b0b5:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b0b8:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)
   1b0bf:	78 51                	js     1b112 <trickles_do_sendmsg_tiov+0x302>
   1b0c1:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b0c4:	89 04 24             	mov    %eax,(%esp,1)
   1b0c7:	e8 0d 0d 00 00       	call   1bdd9 <msk_hold>
   1b0cc:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b0cf:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b0d3:	8b 45 08             	mov    0x8(%ebp),%eax
   1b0d6:	89 04 24             	mov    %eax,(%esp,1)
   1b0d9:	e8 cd 77 ff ff       	call   128ab <free_trickles_msk_finish>
   1b0de:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
   1b0e5:	00 
   1b0e6:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b0e9:	8b 80 f4 00 00 00    	mov    0xf4(%eax),%eax
   1b0ef:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b0f3:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b0f6:	89 04 24             	mov    %eax,(%esp,1)
   1b0f9:	e8 fc ff ff ff       	call   1b0fa <trickles_do_sendmsg_tiov+0x2ea>
   1b0fe:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b101:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b105:	8b 45 08             	mov    0x8(%ebp),%eax
   1b108:	89 04 24             	mov    %eax,(%esp,1)
   1b10b:	e8 af 0c 00 00       	call   1bdbf <msk_free_fields>
   1b110:	eb 12                	jmp    1b124 <trickles_do_sendmsg_tiov+0x314>
   1b112:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b115:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b119:	8b 45 08             	mov    0x8(%ebp),%eax
   1b11c:	89 04 24             	mov    %eax,(%esp,1)
   1b11f:	e8 87 77 ff ff       	call   128ab <free_trickles_msk_finish>
   1b124:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1b127:	c9                   	leave  
   1b128:	c3                   	ret    

0001b129 <trickles_do_sendmsg_fiov>:
   1b129:	55                   	push   %ebp
   1b12a:	89 e5                	mov    %esp,%ebp
   1b12c:	81 ec 20 0c 00 00    	sub    $0xc20,%esp
   1b132:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   1b139:	8b 45 08             	mov    0x8(%ebp),%eax
   1b13c:	05 bc 00 00 00       	add    $0xbc,%eax
   1b141:	89 85 08 f4 ff ff    	mov    %eax,0xfffff408(%ebp)
   1b147:	8d 85 0c f4 ff ff    	lea    0xfffff40c(%ebp),%eax
   1b14d:	05 bc 00 00 00       	add    $0xbc,%eax
   1b152:	89 85 04 f4 ff ff    	mov    %eax,0xfffff404(%ebp)
   1b158:	8b 95 04 f4 ff ff    	mov    0xfffff404(%ebp),%edx
   1b15e:	8b 85 08 f4 ff ff    	mov    0xfffff408(%ebp),%eax
   1b164:	8b 80 ec 01 00 00    	mov    0x1ec(%eax),%eax
   1b16a:	89 82 ec 01 00 00    	mov    %eax,0x1ec(%edx)
   1b170:	8b 95 04 f4 ff ff    	mov    0xfffff404(%ebp),%edx
   1b176:	8b 85 08 f4 ff ff    	mov    0xfffff408(%ebp),%eax
   1b17c:	8b 80 28 0a 00 00    	mov    0xa28(%eax),%eax
   1b182:	89 82 28 0a 00 00    	mov    %eax,0xa28(%edx)
   1b188:	8b 95 04 f4 ff ff    	mov    0xfffff404(%ebp),%edx
   1b18e:	8b 85 08 f4 ff ff    	mov    0xfffff408(%ebp),%eax
   1b194:	8b 80 3c 0a 00 00    	mov    0xa3c(%eax),%eax
   1b19a:	89 82 3c 0a 00 00    	mov    %eax,0xa3c(%edx)
   1b1a0:	8d 85 0c f4 ff ff    	lea    0xfffff40c(%ebp),%eax
   1b1a6:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b1aa:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b1ad:	89 04 24             	mov    %eax,(%esp,1)
   1b1b0:	e8 32 0c 00 00       	call   1bde7 <init_sock>
   1b1b5:	8b 55 0c             	mov    0xc(%ebp),%edx
   1b1b8:	8b 45 08             	mov    0x8(%ebp),%eax
   1b1bb:	89 82 f8 00 00 00    	mov    %eax,0xf8(%edx)
   1b1c1:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b1c4:	8b 80 d4 00 00 00    	mov    0xd4(%eax),%eax
   1b1ca:	a3 a4 a2 11 00       	mov    %eax,0x11a2a4
   1b1cf:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b1d2:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
   1b1d6:	74 14                	je     1b1ec <trickles_do_sendmsg_fiov+0xc3>
   1b1d8:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b1db:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
   1b1df:	74 0b                	je     1b1ec <trickles_do_sendmsg_fiov+0xc3>
   1b1e1:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b1e4:	83 78 10 02          	cmpl   $0x2,0x10(%eax)
   1b1e8:	74 02                	je     1b1ec <trickles_do_sendmsg_fiov+0xc3>
   1b1ea:	eb 25                	jmp    1b211 <trickles_do_sendmsg_fiov+0xe8>
   1b1ec:	8b 45 14             	mov    0x14(%ebp),%eax
   1b1ef:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   1b1f3:	8b 45 10             	mov    0x10(%ebp),%eax
   1b1f6:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1b1fa:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b1fd:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b201:	8b 45 08             	mov    0x8(%ebp),%eax
   1b204:	89 04 24             	mov    %eax,(%esp,1)
   1b207:	e8 d0 9c ff ff       	call   14edc <fiov_handler>
   1b20c:	e9 b4 01 00 00       	jmp    1b3c5 <trickles_do_sendmsg_fiov+0x29c>
   1b211:	8b 45 08             	mov    0x8(%ebp),%eax
   1b214:	89 04 24             	mov    %eax,(%esp,1)
   1b217:	e8 01 fb ff ff       	call   1ad1d <recycle>
   1b21c:	89 85 00 f4 ff ff    	mov    %eax,0xfffff400(%ebp)
   1b222:	83 bd 00 f4 ff ff 00 	cmpl   $0x0,0xfffff400(%ebp)
   1b229:	75 20                	jne    1b24b <trickles_do_sendmsg_fiov+0x122>
   1b22b:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
   1b232:	00 
   1b233:	a1 00 00 00 00       	mov    0x0,%eax
   1b238:	05 f2 00 00 00       	add    $0xf2,%eax
   1b23d:	89 04 24             	mov    %eax,(%esp,1)
   1b240:	e8 fc ff ff ff       	call   1b241 <trickles_do_sendmsg_fiov+0x118>
   1b245:	89 85 00 f4 ff ff    	mov    %eax,0xfffff400(%ebp)
   1b24b:	83 bd 00 f4 ff ff 00 	cmpl   $0x0,0xfffff400(%ebp)
   1b252:	75 11                	jne    1b265 <trickles_do_sendmsg_fiov+0x13c>
   1b254:	c7 04 24 8c 55 00 00 	movl   $0x558c,(%esp,1)
   1b25b:	e8 fc ff ff ff       	call   1b25c <trickles_do_sendmsg_fiov+0x133>
   1b260:	e9 60 01 00 00       	jmp    1b3c5 <trickles_do_sendmsg_fiov+0x29c>
   1b265:	8b 85 00 f4 ff ff    	mov    0xfffff400(%ebp),%eax
   1b26b:	83 c0 30             	add    $0x30,%eax
   1b26e:	89 85 fc f3 ff ff    	mov    %eax,0xfffff3fc(%ebp)
   1b274:	8b 85 00 f4 ff ff    	mov    0xfffff400(%ebp),%eax
   1b27a:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
   1b281:	00 00 00 
   1b284:	8b 85 00 f4 ff ff    	mov    0xfffff400(%ebp),%eax
   1b28a:	c6 80 a3 00 00 00 01 	movb   $0x1,0xa3(%eax)
   1b291:	a1 00 00 00 00       	mov    0x0,%eax
   1b296:	05 f2 00 00 00       	add    $0xf2,%eax
   1b29b:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b29f:	8b 85 00 f4 ff ff    	mov    0xfffff400(%ebp),%eax
   1b2a5:	89 04 24             	mov    %eax,(%esp,1)
   1b2a8:	e8 78 ee ff ff       	call   1a125 <skb_reserve>
   1b2ad:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b2b0:	8b 40 10             	mov    0x10(%eax),%eax
   1b2b3:	89 85 f0 f3 ff ff    	mov    %eax,0xfffff3f0(%ebp)
   1b2b9:	83 bd f0 f3 ff ff 00 	cmpl   $0x0,0xfffff3f0(%ebp)
   1b2c0:	74 0b                	je     1b2cd <trickles_do_sendmsg_fiov+0x1a4>
   1b2c2:	83 bd f0 f3 ff ff 03 	cmpl   $0x3,0xfffff3f0(%ebp)
   1b2c9:	74 29                	je     1b2f4 <trickles_do_sendmsg_fiov+0x1cb>
   1b2cb:	eb 3a                	jmp    1b307 <trickles_do_sendmsg_fiov+0x1de>
   1b2cd:	c7 44 24 04 59 53 00 	movl   $0x5359,0x4(%esp,1)
   1b2d4:	00 
   1b2d5:	c7 04 24 5d 53 00 00 	movl   $0x535d,(%esp,1)
   1b2dc:	e8 fc ff ff ff       	call   1b2dd <trickles_do_sendmsg_fiov+0x1b4>
   1b2e1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1b2e8:	e8 fc ff ff ff       	call   1b2e9 <trickles_do_sendmsg_fiov+0x1c0>
   1b2ed:	e8 fc ff ff ff       	call   1b2ee <trickles_do_sendmsg_fiov+0x1c5>
   1b2f2:	eb 3a                	jmp    1b32e <trickles_do_sendmsg_fiov+0x205>
   1b2f4:	8b 85 00 f4 ff ff    	mov    0xfffff400(%ebp),%eax
   1b2fa:	89 04 24             	mov    %eax,(%esp,1)
   1b2fd:	e8 9e ec ff ff       	call   19fa0 <kfree_skb>
   1b302:	e9 be 00 00 00       	jmp    1b3c5 <trickles_do_sendmsg_fiov+0x29c>
   1b307:	8b 85 00 f4 ff ff    	mov    0xfffff400(%ebp),%eax
   1b30d:	89 04 24             	mov    %eax,(%esp,1)
   1b310:	e8 8b ec ff ff       	call   19fa0 <kfree_skb>
   1b315:	c7 44 24 04 40 01 00 	movl   $0x140,0x4(%esp,1)
   1b31c:	00 
   1b31d:	c7 04 24 c0 70 00 00 	movl   $0x70c0,(%esp,1)
   1b324:	e8 fc ff ff ff       	call   1b325 <trickles_do_sendmsg_fiov+0x1fc>
   1b329:	e9 97 00 00 00       	jmp    1b3c5 <trickles_do_sendmsg_fiov+0x29c>
   1b32e:	c7 85 f8 f3 ff ff 00 	movl   $0x0,0xfffff3f8(%ebp)
   1b335:	00 00 00 
   1b338:	8b 55 0c             	mov    0xc(%ebp),%edx
   1b33b:	8b 85 f8 f3 ff ff    	mov    0xfffff3f8(%ebp),%eax
   1b341:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
   1b347:	7c 02                	jl     1b34b <trickles_do_sendmsg_fiov+0x222>
   1b349:	eb 6c                	jmp    1b3b7 <trickles_do_sendmsg_fiov+0x28e>
   1b34b:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
   1b352:	00 
   1b353:	8b 85 00 f4 ff ff    	mov    0xfffff400(%ebp),%eax
   1b359:	89 04 24             	mov    %eax,(%esp,1)
   1b35c:	e8 fc ff ff ff       	call   1b35d <trickles_do_sendmsg_fiov+0x234>
   1b361:	89 85 f4 f3 ff ff    	mov    %eax,0xfffff3f4(%ebp)
   1b367:	8b 85 f4 f3 ff ff    	mov    0xfffff3f4(%ebp),%eax
   1b36d:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
   1b374:	00 00 00 
   1b377:	8b 85 f4 f3 ff ff    	mov    0xfffff3f4(%ebp),%eax
   1b37d:	c6 80 a3 00 00 00 01 	movb   $0x1,0xa3(%eax)
   1b384:	8b 85 f8 f3 ff ff    	mov    0xfffff3f8(%ebp),%eax
   1b38a:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1b38e:	8b 85 f4 f3 ff ff    	mov    0xfffff3f4(%ebp),%eax
   1b394:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b398:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b39b:	89 04 24             	mov    %eax,(%esp,1)
   1b39e:	e8 fc ff ff ff       	call   1b39f <trickles_do_sendmsg_fiov+0x276>
   1b3a3:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b3a6:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
   1b3ad:	8d 85 f8 f3 ff ff    	lea    0xfffff3f8(%ebp),%eax
   1b3b3:	ff 00                	incl   (%eax)
   1b3b5:	eb 81                	jmp    1b338 <trickles_do_sendmsg_fiov+0x20f>
   1b3b7:	8b 85 00 f4 ff ff    	mov    0xfffff400(%ebp),%eax
   1b3bd:	89 04 24             	mov    %eax,(%esp,1)
   1b3c0:	e8 db eb ff ff       	call   19fa0 <kfree_skb>
   1b3c5:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0
   1b3cc:	74 5d                	je     1b42b <trickles_do_sendmsg_fiov+0x302>
   1b3ce:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b3d1:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)
   1b3d8:	78 51                	js     1b42b <trickles_do_sendmsg_fiov+0x302>
   1b3da:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b3dd:	89 04 24             	mov    %eax,(%esp,1)
   1b3e0:	e8 f4 09 00 00       	call   1bdd9 <msk_hold>
   1b3e5:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b3e8:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b3ec:	8b 45 08             	mov    0x8(%ebp),%eax
   1b3ef:	89 04 24             	mov    %eax,(%esp,1)
   1b3f2:	e8 b4 74 ff ff       	call   128ab <free_trickles_msk_finish>
   1b3f7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
   1b3fe:	00 
   1b3ff:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b402:	8b 80 f4 00 00 00    	mov    0xf4(%eax),%eax
   1b408:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b40c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b40f:	89 04 24             	mov    %eax,(%esp,1)
   1b412:	e8 fc ff ff ff       	call   1b413 <trickles_do_sendmsg_fiov+0x2ea>
   1b417:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b41a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b41e:	8b 45 08             	mov    0x8(%ebp),%eax
   1b421:	89 04 24             	mov    %eax,(%esp,1)
   1b424:	e8 96 09 00 00       	call   1bdbf <msk_free_fields>
   1b429:	eb 12                	jmp    1b43d <trickles_do_sendmsg_fiov+0x314>
   1b42b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b42e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b432:	8b 45 08             	mov    0x8(%ebp),%eax
   1b435:	89 04 24             	mov    %eax,(%esp,1)
   1b438:	e8 6e 74 ff ff       	call   128ab <free_trickles_msk_finish>
   1b43d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1b440:	c9                   	leave  
   1b441:	c3                   	ret    

0001b442 <sockfd_put>:
   1b442:	55                   	push   %ebp
   1b443:	89 e5                	mov    %esp,%ebp
   1b445:	8b 45 08             	mov    0x8(%ebp),%eax
   1b448:	8b 40 14             	mov    0x14(%eax),%eax
   1b44b:	e8 fc ff ff ff       	call   1b44c <sockfd_put+0xa>
   1b450:	5d                   	pop    %ebp
   1b451:	c3                   	ret    

0001b452 <lbb_get_end>:
	int limit;
};

static inline
void *lbb_get_end(struct linear_bounded_buffer *lbb) {
   1b452:	55                   	push   %ebp
   1b453:	89 e5                	mov    %esp,%ebp
	return lbb->start + lbb->limit;
   1b455:	8b 55 08             	mov    0x8(%ebp),%edx
   1b458:	8b 45 08             	mov    0x8(%ebp),%eax
   1b45b:	8b 40 08             	mov    0x8(%eax),%eax
   1b45e:	03 02                	add    (%edx),%eax
}
   1b460:	5d                   	pop    %ebp
   1b461:	c3                   	ret    

0001b462 <lbb_get_offset>:

static inline
int lbb_get_offset(struct linear_bounded_buffer *lbb) {
   1b462:	55                   	push   %ebp
   1b463:	89 e5                	mov    %esp,%ebp
	return lbb->curr - lbb->start;
   1b465:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1b468:	8b 45 08             	mov    0x8(%ebp),%eax
   1b46b:	8b 10                	mov    (%eax),%edx
   1b46d:	8b 41 04             	mov    0x4(%ecx),%eax
   1b470:	29 d0                	sub    %edx,%eax
}
   1b472:	5d                   	pop    %ebp
   1b473:	c3                   	ret    

0001b474 <lbb_get_pos>:

static inline
void *lbb_get_pos(struct linear_bounded_buffer *lbb) {
   1b474:	55                   	push   %ebp
   1b475:	89 e5                	mov    %esp,%ebp
	return lbb->curr;
   1b477:	8b 45 08             	mov    0x8(%ebp),%eax
   1b47a:	8b 40 04             	mov    0x4(%eax),%eax
}
   1b47d:	5d                   	pop    %ebp
   1b47e:	c3                   	ret    

0001b47f <lbb_reserve>:

static inline
int lbb_check_reserve(struct linear_bounded_buffer *lbb, int len) {
	return lbb->curr + len - lbb->start <= lbb->limit;
}

static inline
void *lbb_reserve(struct linear_bounded_buffer *lbb, int len) {
   1b47f:	55                   	push   %ebp
   1b480:	89 e5                	mov    %esp,%ebp
   1b482:	83 ec 10             	sub    $0x10,%esp
	char *rval;
	rval = lbb->curr;
   1b485:	8b 45 08             	mov    0x8(%ebp),%eax
   1b488:	8b 40 04             	mov    0x4(%eax),%eax
   1b48b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

	if(!lbb_check_reserve(lbb,len)) {
   1b48e:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b491:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b495:	8b 45 08             	mov    0x8(%ebp),%eax
   1b498:	89 04 24             	mov    %eax,(%esp,1)
   1b49b:	e8 2d 0a 00 00       	call   1becd <lbb_check_reserve>
   1b4a0:	85 c0                	test   %eax,%eax
   1b4a2:	75 09                	jne    1b4ad <lbb_reserve+0x2e>
		return NULL;
   1b4a4:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
   1b4ab:	eb 15                	jmp    1b4c2 <lbb_reserve+0x43>
	}
	lbb->curr += len;
   1b4ad:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1b4b0:	8b 55 08             	mov    0x8(%ebp),%edx
   1b4b3:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b4b6:	03 42 04             	add    0x4(%edx),%eax
   1b4b9:	89 41 04             	mov    %eax,0x4(%ecx)
	return rval;
   1b4bc:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1b4bf:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
}
   1b4c2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1b4c5:	c9                   	leave  
   1b4c6:	c3                   	ret    

0001b4c7 <copy_patch_hmac_update_in>:
   1b4c7:	55                   	push   %ebp
   1b4c8:	89 e5                	mov    %esp,%ebp
   1b4ca:	57                   	push   %edi
   1b4cb:	56                   	push   %esi
   1b4cc:	83 ec 3c             	sub    $0x3c,%esp
   1b4cf:	c7 45 f4 01 00 00 00 	movl   $0x1,0xfffffff4(%ebp)
   1b4d6:	c7 45 f0 02 00 00 00 	movl   $0x2,0xfffffff0(%ebp)
   1b4dd:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
   1b4e4:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1b4e7:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
   1b4ea:	0f 85 14 01 00 00    	jne    1b604 <copy_patch_hmac_update_in+0x13d>
   1b4f0:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
   1b4f7:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1b4fa:	3b 45 20             	cmp    0x20(%ebp),%eax
   1b4fd:	7c 05                	jl     1b504 <copy_patch_hmac_update_in+0x3d>
   1b4ff:	e9 0c 02 00 00       	jmp    1b710 <copy_patch_hmac_update_in+0x249>
   1b504:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   1b507:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1b50b:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1b50e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b512:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1b515:	89 04 24             	mov    %eax,(%esp,1)
   1b518:	8b 45 18             	mov    0x18(%ebp),%eax
   1b51b:	ff d0                	call   *%eax
   1b51d:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   1b520:	3b 45 e8             	cmp    0xffffffe8(%ebp),%eax
   1b523:	7d 25                	jge    1b54a <copy_patch_hmac_update_in+0x83>
   1b525:	c7 44 24 04 59 53 00 	movl   $0x5359,0x4(%esp,1)
   1b52c:	00 
   1b52d:	c7 04 24 5d 53 00 00 	movl   $0x535d,(%esp,1)
   1b534:	e8 fc ff ff ff       	call   1b535 <copy_patch_hmac_update_in+0x6e>
   1b539:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1b540:	e8 fc ff ff ff       	call   1b541 <copy_patch_hmac_update_in+0x7a>
   1b545:	e8 fc ff ff ff       	call   1b546 <copy_patch_hmac_update_in+0x7f>
   1b54a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1b54d:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
   1b550:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   1b553:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
   1b556:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   1b559:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   1b55c:	29 d0                	sub    %edx,%eax
   1b55e:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1b562:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   1b565:	03 45 10             	add    0x10(%ebp),%eax
   1b568:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b56c:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   1b56f:	03 45 0c             	add    0xc(%ebp),%eax
   1b572:	89 04 24             	mov    %eax,(%esp,1)
   1b575:	e8 f0 05 00 00       	call   1bb6a <__generic_copy_to_user_nocheck>
   1b57a:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
   1b57d:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
   1b580:	29 d0                	sub    %edx,%eax
   1b582:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1b586:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   1b589:	03 45 10             	add    0x10(%ebp),%eax
   1b58c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b590:	8b 45 08             	mov    0x8(%ebp),%eax
   1b593:	89 04 24             	mov    %eax,(%esp,1)
   1b596:	e8 fc ff ff ff       	call   1b597 <copy_patch_hmac_update_in+0xd0>
   1b59b:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
   1b5a2:	83 7d e4 04          	cmpl   $0x4,0xffffffe4(%ebp)
   1b5a6:	76 14                	jbe    1b5bc <copy_patch_hmac_update_in+0xf5>
   1b5a8:	c7 44 24 04 67 09 00 	movl   $0x967,0x4(%esp,1)
   1b5af:	00 
   1b5b0:	c7 04 24 00 71 00 00 	movl   $0x7100,(%esp,1)
   1b5b7:	e8 fc ff ff ff       	call   1b5b8 <copy_patch_hmac_update_in+0xf1>
   1b5bc:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1b5bf:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1b5c3:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   1b5c6:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b5ca:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   1b5cd:	03 45 0c             	add    0xc(%ebp),%eax
   1b5d0:	89 04 24             	mov    %eax,(%esp,1)
   1b5d3:	e8 92 05 00 00       	call   1bb6a <__generic_copy_to_user_nocheck>
   1b5d8:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1b5db:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1b5df:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   1b5e2:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b5e6:	8b 45 08             	mov    0x8(%ebp),%eax
   1b5e9:	89 04 24             	mov    %eax,(%esp,1)
   1b5ec:	e8 fc ff ff ff       	call   1b5ed <copy_patch_hmac_update_in+0x126>
   1b5f1:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1b5f4:	03 45 e0             	add    0xffffffe0(%ebp),%eax
   1b5f7:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1b5fa:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   1b5fd:	ff 00                	incl   (%eax)
   1b5ff:	e9 f3 fe ff ff       	jmp    1b4f7 <copy_patch_hmac_update_in+0x30>
   1b604:	8b 45 14             	mov    0x14(%ebp),%eax
   1b607:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1b60b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b60e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b612:	8b 45 10             	mov    0x10(%ebp),%eax
   1b615:	89 04 24             	mov    %eax,(%esp,1)
   1b618:	e8 12 05 00 00       	call   1bb2f <__generic_copy_from_user_nocheck>
   1b61d:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
   1b624:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1b627:	3b 45 20             	cmp    0x20(%ebp),%eax
   1b62a:	7c 05                	jl     1b631 <copy_patch_hmac_update_in+0x16a>
   1b62c:	e9 df 00 00 00       	jmp    1b710 <copy_patch_hmac_update_in+0x249>
   1b631:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
   1b638:	8d 45 e0             	lea    0xffffffe0(%ebp),%eax
   1b63b:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1b63f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1b642:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b646:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1b649:	89 04 24             	mov    %eax,(%esp,1)
   1b64c:	8b 45 18             	mov    0x18(%ebp),%eax
   1b64f:	ff d0                	call   *%eax
   1b651:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   1b654:	3b 45 e8             	cmp    0xffffffe8(%ebp),%eax
   1b657:	7d 25                	jge    1b67e <copy_patch_hmac_update_in+0x1b7>
   1b659:	c7 44 24 04 59 53 00 	movl   $0x5359,0x4(%esp,1)
   1b660:	00 
   1b661:	c7 04 24 5d 53 00 00 	movl   $0x535d,(%esp,1)
   1b668:	e8 fc ff ff ff       	call   1b669 <copy_patch_hmac_update_in+0x1a2>
   1b66d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1b674:	e8 fc ff ff ff       	call   1b675 <copy_patch_hmac_update_in+0x1ae>
   1b679:	e8 fc ff ff ff       	call   1b67a <copy_patch_hmac_update_in+0x1b3>
   1b67e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1b681:	03 45 e0             	add    0xffffffe0(%ebp),%eax
   1b684:	3b 45 14             	cmp    0x14(%ebp),%eax
   1b687:	7e 14                	jle    1b69d <copy_patch_hmac_update_in+0x1d6>
   1b689:	c7 44 24 04 67 09 00 	movl   $0x967,0x4(%esp,1)
   1b690:	00 
   1b691:	c7 04 24 60 71 00 00 	movl   $0x7160,(%esp,1)
   1b698:	e8 fc ff ff ff       	call   1b699 <copy_patch_hmac_update_in+0x1d2>
   1b69d:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   1b6a0:	03 45 10             	add    0x10(%ebp),%eax
   1b6a3:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
   1b6a6:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
   1b6a9:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
   1b6ac:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
   1b6af:	89 4d c8             	mov    %ecx,0xffffffc8(%ebp)
   1b6b2:	fc                   	cld    
   1b6b3:	8b 75 c8             	mov    0xffffffc8(%ebp),%esi
   1b6b6:	39 75 c8             	cmp    %esi,0xffffffc8(%ebp)
   1b6b9:	8b 75 d0             	mov    0xffffffd0(%ebp),%esi
   1b6bc:	8b 7d cc             	mov    0xffffffcc(%ebp),%edi
   1b6bf:	8b 4d c8             	mov    0xffffffc8(%ebp),%ecx
   1b6c2:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
   1b6c4:	0f 97 c2             	seta   %dl
   1b6c7:	0f 92 c0             	setb   %al
   1b6ca:	28 c2                	sub    %al,%dl
   1b6cc:	88 d0                	mov    %dl,%al
   1b6ce:	0f be c0             	movsbl %al,%eax
   1b6d1:	85 c0                	test   %eax,%eax
   1b6d3:	74 14                	je     1b6e9 <copy_patch_hmac_update_in+0x222>
   1b6d5:	c7 44 24 04 67 09 00 	movl   $0x967,0x4(%esp,1)
   1b6dc:	00 
   1b6dd:	c7 04 24 c0 71 00 00 	movl   $0x71c0,(%esp,1)
   1b6e4:	e8 fc ff ff ff       	call   1b6e5 <copy_patch_hmac_update_in+0x21e>
   1b6e9:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1b6ec:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1b6f0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
   1b6f7:	00 
   1b6f8:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   1b6fb:	03 45 10             	add    0x10(%ebp),%eax
   1b6fe:	89 04 24             	mov    %eax,(%esp,1)
   1b701:	e8 68 03 00 00       	call   1ba6e <__constant_c_memset>
   1b706:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   1b709:	ff 00                	incl   (%eax)
   1b70b:	e9 14 ff ff ff       	jmp    1b624 <copy_patch_hmac_update_in+0x15d>
   1b710:	8b 45 14             	mov    0x14(%ebp),%eax
   1b713:	3b 45 e8             	cmp    0xffffffe8(%ebp),%eax
   1b716:	7d 14                	jge    1b72c <copy_patch_hmac_update_in+0x265>
   1b718:	c7 44 24 04 67 09 00 	movl   $0x967,0x4(%esp,1)
   1b71f:	00 
   1b720:	c7 04 24 40 72 00 00 	movl   $0x7240,(%esp,1)
   1b727:	e8 fc ff ff ff       	call   1b728 <copy_patch_hmac_update_in+0x261>
   1b72c:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   1b72f:	8b 45 14             	mov    0x14(%ebp),%eax
   1b732:	29 d0                	sub    %edx,%eax
   1b734:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1b738:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1b73b:	03 45 10             	add    0x10(%ebp),%eax
   1b73e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b742:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1b745:	03 45 0c             	add    0xc(%ebp),%eax
   1b748:	89 04 24             	mov    %eax,(%esp,1)
   1b74b:	e8 1a 04 00 00       	call   1bb6a <__generic_copy_to_user_nocheck>
   1b750:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1b753:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
   1b756:	75 21                	jne    1b779 <copy_patch_hmac_update_in+0x2b2>
   1b758:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
   1b75b:	8b 45 14             	mov    0x14(%ebp),%eax
   1b75e:	29 d0                	sub    %edx,%eax
   1b760:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1b764:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1b767:	03 45 10             	add    0x10(%ebp),%eax
   1b76a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b76e:	8b 45 08             	mov    0x8(%ebp),%eax
   1b771:	89 04 24             	mov    %eax,(%esp,1)
   1b774:	e8 fc ff ff ff       	call   1b775 <copy_patch_hmac_update_in+0x2ae>
   1b779:	83 c4 3c             	add    $0x3c,%esp
   1b77c:	5e                   	pop    %esi
   1b77d:	5f                   	pop    %edi
   1b77e:	5d                   	pop    %ebp
   1b77f:	c3                   	ret    

0001b780 <copy_patch_hmac_update_out>:
   1b780:	55                   	push   %ebp
   1b781:	89 e5                	mov    %esp,%ebp
   1b783:	83 ec 30             	sub    $0x30,%esp
   1b786:	c7 45 fc 01 00 00 00 	movl   $0x1,0xfffffffc(%ebp)
   1b78d:	c7 45 f8 02 00 00 00 	movl   $0x2,0xfffffff8(%ebp)
   1b794:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
   1b79b:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
   1b7a2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1b7a5:	3b 45 20             	cmp    0x20(%ebp),%eax
   1b7a8:	7c 05                	jl     1b7af <copy_patch_hmac_update_out+0x2f>
   1b7aa:	e9 00 01 00 00       	jmp    1b8af <copy_patch_hmac_update_out+0x12f>
   1b7af:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
   1b7b2:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1b7b6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1b7b9:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b7bd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1b7c0:	89 04 24             	mov    %eax,(%esp,1)
   1b7c3:	8b 45 18             	mov    0x18(%ebp),%eax
   1b7c6:	ff d0                	call   *%eax
   1b7c8:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1b7cb:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
   1b7ce:	7d 25                	jge    1b7f5 <copy_patch_hmac_update_out+0x75>
   1b7d0:	c7 44 24 04 59 53 00 	movl   $0x5359,0x4(%esp,1)
   1b7d7:	00 
   1b7d8:	c7 04 24 5d 53 00 00 	movl   $0x535d,(%esp,1)
   1b7df:	e8 fc ff ff ff       	call   1b7e0 <copy_patch_hmac_update_out+0x60>
   1b7e4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1b7eb:	e8 fc ff ff ff       	call   1b7ec <copy_patch_hmac_update_out+0x6c>
   1b7f0:	e8 fc ff ff ff       	call   1b7f1 <copy_patch_hmac_update_out+0x71>
   1b7f5:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1b7f8:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   1b7fb:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1b7fe:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   1b801:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   1b804:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   1b807:	29 d0                	sub    %edx,%eax
   1b809:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1b80d:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1b810:	03 45 10             	add    0x10(%ebp),%eax
   1b813:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b817:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1b81a:	03 45 0c             	add    0xc(%ebp),%eax
   1b81d:	89 04 24             	mov    %eax,(%esp,1)
   1b820:	e8 45 03 00 00       	call   1bb6a <__generic_copy_to_user_nocheck>
   1b825:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
   1b828:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   1b82b:	29 d0                	sub    %edx,%eax
   1b82d:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1b831:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1b834:	03 45 10             	add    0x10(%ebp),%eax
   1b837:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b83b:	8b 45 08             	mov    0x8(%ebp),%eax
   1b83e:	89 04 24             	mov    %eax,(%esp,1)
   1b841:	e8 fc ff ff ff       	call   1b842 <copy_patch_hmac_update_out+0xc2>
   1b846:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
   1b84d:	83 7d ec 04          	cmpl   $0x4,0xffffffec(%ebp)
   1b851:	76 14                	jbe    1b867 <copy_patch_hmac_update_out+0xe7>
   1b853:	c7 44 24 04 68 09 00 	movl   $0x968,0x4(%esp,1)
   1b85a:	00 
   1b85b:	c7 04 24 00 71 00 00 	movl   $0x7100,(%esp,1)
   1b862:	e8 fc ff ff ff       	call   1b863 <copy_patch_hmac_update_out+0xe3>
   1b867:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1b86a:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1b86e:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   1b871:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b875:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1b878:	03 45 0c             	add    0xc(%ebp),%eax
   1b87b:	89 04 24             	mov    %eax,(%esp,1)
   1b87e:	e8 e7 02 00 00       	call   1bb6a <__generic_copy_to_user_nocheck>
   1b883:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1b886:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1b88a:	8d 45 dc             	lea    0xffffffdc(%ebp),%eax
   1b88d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b891:	8b 45 08             	mov    0x8(%ebp),%eax
   1b894:	89 04 24             	mov    %eax,(%esp,1)
   1b897:	e8 fc ff ff ff       	call   1b898 <copy_patch_hmac_update_out+0x118>
   1b89c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1b89f:	03 45 e8             	add    0xffffffe8(%ebp),%eax
   1b8a2:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1b8a5:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   1b8a8:	ff 00                	incl   (%eax)
   1b8aa:	e9 f3 fe ff ff       	jmp    1b7a2 <copy_patch_hmac_update_out+0x22>
   1b8af:	8b 45 14             	mov    0x14(%ebp),%eax
   1b8b2:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
   1b8b5:	7d 14                	jge    1b8cb <copy_patch_hmac_update_out+0x14b>
   1b8b7:	c7 44 24 04 68 09 00 	movl   $0x968,0x4(%esp,1)
   1b8be:	00 
   1b8bf:	c7 04 24 40 72 00 00 	movl   $0x7240,(%esp,1)
   1b8c6:	e8 fc ff ff ff       	call   1b8c7 <copy_patch_hmac_update_out+0x147>
   1b8cb:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   1b8ce:	8b 45 14             	mov    0x14(%ebp),%eax
   1b8d1:	29 d0                	sub    %edx,%eax
   1b8d3:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1b8d7:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1b8da:	03 45 10             	add    0x10(%ebp),%eax
   1b8dd:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b8e1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1b8e4:	03 45 0c             	add    0xc(%ebp),%eax
   1b8e7:	89 04 24             	mov    %eax,(%esp,1)
   1b8ea:	e8 7b 02 00 00       	call   1bb6a <__generic_copy_to_user_nocheck>
   1b8ef:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   1b8f2:	8b 45 14             	mov    0x14(%ebp),%eax
   1b8f5:	29 d0                	sub    %edx,%eax
   1b8f7:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1b8fb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1b8fe:	03 45 10             	add    0x10(%ebp),%eax
   1b901:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b905:	8b 45 08             	mov    0x8(%ebp),%eax
   1b908:	89 04 24             	mov    %eax,(%esp,1)
   1b90b:	e8 fc ff ff ff       	call   1b90c <copy_patch_hmac_update_out+0x18c>
   1b910:	c9                   	leave  
   1b911:	c3                   	ret    

0001b912 <arrayPatchGenerator>:
   1b912:	55                   	push   %ebp
   1b913:	89 e5                	mov    %esp,%ebp
   1b915:	83 ec 04             	sub    $0x4,%esp
   1b918:	8b 45 08             	mov    0x8(%ebp),%eax
   1b91b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   1b91e:	8b 4d 10             	mov    0x10(%ebp),%ecx
   1b921:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b924:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1b92b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1b92e:	8d 14 10             	lea    (%eax,%edx,1),%edx
   1b931:	8b 02                	mov    (%edx),%eax
   1b933:	8b 52 04             	mov    0x4(%edx),%edx
   1b936:	89 01                	mov    %eax,(%ecx)
   1b938:	89 51 04             	mov    %edx,0x4(%ecx)
   1b93b:	c9                   	leave  
   1b93c:	c3                   	ret    

0001b93d <packetPatchGenerator>:
   1b93d:	55                   	push   %ebp
   1b93e:	89 e5                	mov    %esp,%ebp
   1b940:	8b 4d 10             	mov    0x10(%ebp),%ecx
   1b943:	8b 55 0c             	mov    0xc(%ebp),%edx
   1b946:	89 d0                	mov    %edx,%eax
   1b948:	c1 e0 03             	shl    $0x3,%eax
   1b94b:	01 d0                	add    %edx,%eax
   1b94d:	c1 e0 02             	shl    $0x2,%eax
   1b950:	83 c0 14             	add    $0x14,%eax
   1b953:	89 01                	mov    %eax,(%ecx)
   1b955:	8b 45 10             	mov    0x10(%ebp),%eax
   1b958:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
   1b95f:	5d                   	pop    %ebp
   1b960:	c3                   	ret    

0001b961 <tmalloc_helperin>:
   1b961:	55                   	push   %ebp
   1b962:	89 e5                	mov    %esp,%ebp
   1b964:	83 ec 08             	sub    $0x8,%esp
   1b967:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b96a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b96e:	c7 04 24 88 72 00 00 	movl   $0x7288,(%esp,1)
   1b975:	e8 fc ff ff ff       	call   1b976 <tmalloc_helperin+0x15>
   1b97a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b97d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b981:	8b 45 08             	mov    0x8(%ebp),%eax
   1b984:	89 04 24             	mov    %eax,(%esp,1)
   1b987:	e8 fc ff ff ff       	call   1b988 <tmalloc_helperin+0x27>
   1b98c:	c9                   	leave  
   1b98d:	c3                   	ret    

0001b98e <kmalloc_helperin>:
   1b98e:	55                   	push   %ebp
   1b98f:	89 e5                	mov    %esp,%ebp
   1b991:	83 ec 08             	sub    $0x8,%esp
   1b994:	c7 44 24 04 f0 01 00 	movl   $0x1f0,0x4(%esp,1)
   1b99b:	00 
   1b99c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b99f:	89 04 24             	mov    %eax,(%esp,1)
   1b9a2:	e8 fc ff ff ff       	call   1b9a3 <kmalloc_helperin+0x15>
   1b9a7:	c9                   	leave  
   1b9a8:	c3                   	ret    

0001b9a9 <msk_force_free>:
   1b9a9:	55                   	push   %ebp
   1b9aa:	89 e5                	mov    %esp,%ebp
   1b9ac:	83 ec 08             	sub    $0x8,%esp
   1b9af:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b9b2:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
   1b9b9:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b9bc:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b9c0:	8b 45 08             	mov    0x8(%ebp),%eax
   1b9c3:	89 04 24             	mov    %eax,(%esp,1)
   1b9c6:	e8 42 6e ff ff       	call   1280d <free_trickles_msk>
   1b9cb:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b9ce:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1b9d2:	8b 45 08             	mov    0x8(%ebp),%eax
   1b9d5:	89 04 24             	mov    %eax,(%esp,1)
   1b9d8:	e8 ce 6e ff ff       	call   128ab <free_trickles_msk_finish>
   1b9dd:	c9                   	leave  
   1b9de:	c3                   	ret    

0001b9df <prefetch>:
#if defined(CONFIG_MPENTIUMIII) || defined (CONFIG_MPENTIUM4)

#define ARCH_HAS_PREFETCH
static inline void prefetch(const void *x)
{
   1b9df:	55                   	push   %ebp
   1b9e0:	89 e5                	mov    %esp,%ebp
	__asm__ __volatile__ ("prefetchnta (%0)" : : "r"(x));
   1b9e2:	8b 45 08             	mov    0x8(%ebp),%eax
   1b9e5:	0f 18 00             	prefetchnta (%eax)
}
   1b9e8:	5d                   	pop    %ebp
   1b9e9:	c3                   	ret    

0001b9ea <list_empty>:
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(struct list_head *head)
{
   1b9ea:	55                   	push   %ebp
   1b9eb:	89 e5                	mov    %esp,%ebp
	return head->next == head;
   1b9ed:	8b 45 08             	mov    0x8(%ebp),%eax
   1b9f0:	8b 00                	mov    (%eax),%eax
   1b9f2:	3b 45 08             	cmp    0x8(%ebp),%eax
   1b9f5:	0f 94 c0             	sete   %al
   1b9f8:	0f b6 c0             	movzbl %al,%eax
}
   1b9fb:	5d                   	pop    %ebp
   1b9fc:	c3                   	ret    

0001b9fd <__xchg>:
 * Note 2: xchg has side effect, so that attribute volatile is necessary,
 *	  but generally the primitive is invalid, *ptr is output argument. --ANK
 */
static inline unsigned long __xchg(unsigned long x, volatile void * ptr, int size)
{
   1b9fd:	55                   	push   %ebp
   1b9fe:	89 e5                	mov    %esp,%ebp
   1ba00:	83 ec 04             	sub    $0x4,%esp
	switch (size) {
   1ba03:	8b 45 10             	mov    0x10(%ebp),%eax
   1ba06:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   1ba09:	83 7d fc 02          	cmpl   $0x2,0xfffffffc(%ebp)
   1ba0d:	74 23                	je     1ba32 <__xchg+0x35>
   1ba0f:	83 7d fc 02          	cmpl   $0x2,0xfffffffc(%ebp)
   1ba13:	7f 08                	jg     1ba1d <__xchg+0x20>
   1ba15:	83 7d fc 01          	cmpl   $0x1,0xfffffffc(%ebp)
   1ba19:	74 0a                	je     1ba25 <__xchg+0x28>
   1ba1b:	eb 2e                	jmp    1ba4b <__xchg+0x4e>
   1ba1d:	83 7d fc 04          	cmpl   $0x4,0xfffffffc(%ebp)
   1ba21:	74 1d                	je     1ba40 <__xchg+0x43>
   1ba23:	eb 26                	jmp    1ba4b <__xchg+0x4e>
		case 1:
			__asm__ __volatile__("xchgb %b0,%1"
   1ba25:	8b 55 0c             	mov    0xc(%ebp),%edx
   1ba28:	8b 45 08             	mov    0x8(%ebp),%eax
   1ba2b:	86 02                	xchg   %al,(%edx)
   1ba2d:	89 45 08             	mov    %eax,0x8(%ebp)
				:"=q" (x)
				:"m" (*__xg(ptr)), "0" (x)
				:"memory");
			break;
   1ba30:	eb 19                	jmp    1ba4b <__xchg+0x4e>
		case 2:
			__asm__ __volatile__("xchgw %w0,%1"
   1ba32:	8b 55 0c             	mov    0xc(%ebp),%edx
   1ba35:	8b 45 08             	mov    0x8(%ebp),%eax
   1ba38:	66 87 02             	xchg   %ax,(%edx)
   1ba3b:	89 45 08             	mov    %eax,0x8(%ebp)
				:"=r" (x)
				:"m" (*__xg(ptr)), "0" (x)
				:"memory");
			break;
   1ba3e:	eb 0b                	jmp    1ba4b <__xchg+0x4e>
		case 4:
			__asm__ __volatile__("xchgl %0,%1"
   1ba40:	8b 55 0c             	mov    0xc(%ebp),%edx
   1ba43:	8b 45 08             	mov    0x8(%ebp),%eax
   1ba46:	87 02                	xchg   %eax,(%edx)
   1ba48:	89 45 08             	mov    %eax,0x8(%ebp)
				:"=r" (x)
				:"m" (*__xg(ptr)), "0" (x)
				:"memory");
			break;
	}
	return x;
   1ba4b:	8b 45 08             	mov    0x8(%ebp),%eax
}
   1ba4e:	c9                   	leave  
   1ba4f:	c3                   	ret    

0001ba50 <atomic_dec_and_test>:
 * cases.  Note that the guaranteed
 * useful range of an atomic_t is only 24 bits.
 */ 
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
   1ba50:	55                   	push   %ebp
   1ba51:	89 e5                	mov    %esp,%ebp
   1ba53:	83 ec 04             	sub    $0x4,%esp
	unsigned char c;

	__asm__ __volatile__(
   1ba56:	8b 55 08             	mov    0x8(%ebp),%edx
   1ba59:	8b 45 08             	mov    0x8(%ebp),%eax
   1ba5c:	ff 0a                	decl   (%edx)
   1ba5e:	0f 94 45 ff          	sete   0xffffffff(%ebp)
		LOCK "decl %0; sete %1"
		:"=m" (v->counter), "=qm" (c)
		:"m" (v->counter) : "memory");
	return c != 0;
   1ba62:	80 7d ff 00          	cmpb   $0x0,0xffffffff(%ebp)
   1ba66:	0f 95 c0             	setne  %al
   1ba69:	0f b6 c0             	movzbl %al,%eax
}
   1ba6c:	c9                   	leave  
   1ba6d:	c3                   	ret    

0001ba6e <__constant_c_memset>:
 * things 32 bits at a time even when we don't know the size of the
 * area at compile-time..
 */
static inline void * __constant_c_memset(void * s, unsigned long c, size_t count)
{
   1ba6e:	55                   	push   %ebp
   1ba6f:	89 e5                	mov    %esp,%ebp
   1ba71:	57                   	push   %edi
   1ba72:	53                   	push   %ebx
   1ba73:	83 ec 08             	sub    $0x8,%esp
int d0, d1;
__asm__ __volatile__(
   1ba76:	8b 55 0c             	mov    0xc(%ebp),%edx
   1ba79:	8b 4d 10             	mov    0x10(%ebp),%ecx
   1ba7c:	c1 e9 02             	shr    $0x2,%ecx
   1ba7f:	8b 7d 08             	mov    0x8(%ebp),%edi
   1ba82:	89 d0                	mov    %edx,%eax
   1ba84:	8b 5d 10             	mov    0x10(%ebp),%ebx
   1ba87:	f3 ab                	repz stos %eax,%es:(%edi)
   1ba89:	f6 c3 02             	test   $0x2,%bl
   1ba8c:	74 02                	je     1ba90 <__constant_c_memset+0x22>
   1ba8e:	66 ab                	stos   %ax,%es:(%edi)
   1ba90:	f6 c3 01             	test   $0x1,%bl
   1ba93:	74 01                	je     1ba96 <__constant_c_memset+0x28>
   1ba95:	aa                   	stos   %al,%es:(%edi)
   1ba96:	89 c8                	mov    %ecx,%eax
   1ba98:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1ba9b:	89 f8                	mov    %edi,%eax
   1ba9d:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	"rep ; stosl\n\t"
	"testb $2,%b3\n\t"
	"je 1f\n\t"
	"stosw\n"
	"1:\ttestb $1,%b3\n\t"
	"je 2f\n\t"
	"stosb\n"
	"2:"
	: "=&c" (d0), "=&D" (d1)
	:"a" (c), "q" (count), "0" (count/4), "1" ((long) s)
	:"memory");
return (s);	
   1baa0:	8b 45 08             	mov    0x8(%ebp),%eax
}
   1baa3:	83 c4 08             	add    $0x8,%esp
   1baa6:	5b                   	pop    %ebx
   1baa7:	5f                   	pop    %edi
   1baa8:	5d                   	pop    %ebp
   1baa9:	c3                   	ret    

0001baaa <__skb_dequeue_tail>:
 *	returned or %NULL if the list is empty.
 */

static inline struct sk_buff *__skb_dequeue_tail(struct sk_buff_head *list)
{
   1baaa:	55                   	push   %ebp
   1baab:	89 e5                	mov    %esp,%ebp
   1baad:	83 ec 0c             	sub    $0xc,%esp
	struct sk_buff *skb = skb_peek_tail(list); 
   1bab0:	8b 45 08             	mov    0x8(%ebp),%eax
   1bab3:	89 04 24             	mov    %eax,(%esp,1)
   1bab6:	e8 45 04 00 00       	call   1bf00 <skb_peek_tail>
   1babb:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	if (skb)
   1babe:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
   1bac2:	74 12                	je     1bad6 <__skb_dequeue_tail+0x2c>
		__skb_unlink(skb, list);
   1bac4:	8b 45 08             	mov    0x8(%ebp),%eax
   1bac7:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1bacb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1bace:	89 04 24             	mov    %eax,(%esp,1)
   1bad1:	e8 4d 04 00 00       	call   1bf23 <__skb_unlink>
	return skb;
   1bad6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
   1bad9:	c9                   	leave  
   1bada:	c3                   	ret    

0001badb <skb_is_nonlinear>:

/**
 *	skb_dequeue - remove from the head of the queue
 *	@list: list to dequeue from
 *
 *	Remove the head of the list. The list lock is taken so the function
 *	may be used safely with other locking list functions. The tail item is
 *	returned or %NULL if the list is empty.
 */

static inline struct sk_buff *skb_dequeue_tail(struct sk_buff_head *list)
{
	unsigned long flags;
	struct sk_buff *result;

	spin_lock_irqsave(&list->lock, flags);
	result = __skb_dequeue_tail(list);
	spin_unlock_irqrestore(&list->lock, flags);
	return result;
}

static inline int skb_is_nonlinear(const struct sk_buff *skb)
{
   1badb:	55                   	push   %ebp
   1badc:	89 e5                	mov    %esp,%ebp
	return skb->data_len;
   1bade:	8b 45 08             	mov    0x8(%ebp),%eax
   1bae1:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
}
   1bae7:	5d                   	pop    %ebp
   1bae8:	c3                   	ret    

0001bae9 <verify_area>:
 *
 * See access_ok() for more details.
 */
static inline int verify_area(int type, const void * addr, unsigned long size)
{
   1bae9:	55                   	push   %ebp
   1baea:	89 e5                	mov    %esp,%ebp
   1baec:	53                   	push   %ebx
   1baed:	83 ec 0c             	sub    $0xc,%esp
	return access_ok(type,addr,size) ? 0 : -EFAULT;
   1baf0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   1baf3:	e8 47 e4 ff ff       	call   19f3f <get_current>
   1baf8:	89 da                	mov    %ebx,%edx
   1bafa:	03 55 10             	add    0x10(%ebp),%edx
   1bafd:	19 c9                	sbb    %ecx,%ecx
   1baff:	39 50 0c             	cmp    %edx,0xc(%eax)
   1bb02:	83 d9 00             	sbb    $0x0,%ecx
   1bb05:	89 c8                	mov    %ecx,%eax
   1bb07:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   1bb0a:	89 d0                	mov    %edx,%eax
   1bb0c:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1bb0f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1bb12:	85 c0                	test   %eax,%eax
   1bb14:	74 09                	je     1bb1f <verify_area+0x36>
   1bb16:	c7 45 f0 f2 ff ff ff 	movl   $0xfffffff2,0xfffffff0(%ebp)
   1bb1d:	eb 07                	jmp    1bb26 <verify_area+0x3d>
   1bb1f:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
   1bb26:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
}
   1bb29:	83 c4 0c             	add    $0xc,%esp
   1bb2c:	5b                   	pop    %ebx
   1bb2d:	5d                   	pop    %ebp
   1bb2e:	c3                   	ret    

0001bb2f <__generic_copy_from_user_nocheck>:


/*
 * The exception table consists of pairs of addresses: the first is the
 * address of an instruction that is allowed to fault, and the second is
 * the address at which the program should continue.  No registers are
 * modified, so it is entirely up to the continuation code to figure out
 * what to do.
 *
 * All the routines below use bits of fixup code that are out of line
 * with the main instruction path.  This means when everything is well,
 * we don't even have to jump over them.  Further, they do not intrude
 * on our cache or tlb entries.
 */

struct exception_table_entry
{
	unsigned long insn, fixup;
};

/* Returns 0 if exception not found and fixup otherwise.  */
extern unsigned long search_exception_table(unsigned long);


/*
 * These are the main single-value transfer routines.  They automatically
 * use the right size if we just have the right pointer type.
 *
 * This gets kind of ugly. We want to return _two_ values in "get_user()"
 * and yet we don't want to do any pointers, because that is too much
 * of a performance impact. Thus we have a few rather ugly macros here,
 * and hide all the uglyness from the user.
 *
 * The "__xxx" versions of the user access functions are versions that
 * do not verify the address space, that must have been done previously
 * with a separate "access_ok()" call (this is used when we do multiple
 * accesses to the same area of user memory).
 */

extern void __get_user_1(void);
extern void __get_user_2(void);
extern void __get_user_4(void);

#define __get_user_x(size,ret,x,ptr) \
	__asm__ __volatile__("call __get_user_" #size \
		:"=a" (ret),"=d" (x) \
		:"0" (ptr))


/* Careful: we have to cast the result to the type of the pointer for sign reasons */
/**
 * get_user: - Get a simple variable from user space.
 * @x:   Variable to store result.
 * @ptr: Source address, in user space.
 *
 * Context: User context only.  This function may sleep.
 *
 * This macro copies a single simple variable from user space to kernel
 * space.  It supports simple types like char and int, but not larger
 * data types like structures or arrays.
 *
 * @ptr must have pointer-to-simple-variable type, and the result of
 * dereferencing @ptr must be assignable to @x without a cast.
 *
 * Returns zero on success, or -EFAULT on error.
 * On error, the variable @x is set to zero.
 */
#define get_user(x,ptr)							\
({	int __ret_gu,__val_gu;						\
	switch(sizeof (*(ptr))) {					\
	case 1:  __get_user_x(1,__ret_gu,__val_gu,ptr); break;		\
	case 2:  __get_user_x(2,__ret_gu,__val_gu,ptr); break;		\
	case 4:  __get_user_x(4,__ret_gu,__val_gu,ptr); break;		\
	default: __get_user_x(X,__ret_gu,__val_gu,ptr); break;		\
	}								\
	(x) = (__typeof__(*(ptr)))__val_gu;				\
	__ret_gu;							\
})

extern void __put_user_1(void);
extern void __put_user_2(void);
extern void __put_user_4(void);
extern void __put_user_8(void);

extern void __put_user_bad(void);


/**
 * put_user: - Write a simple value into user space.
 * @x:   Value to copy to user space.
 * @ptr: Destination address, in user space.
 *
 * Context: User context only.  This function may sleep.
 *
 * This macro copies a single simple value from kernel space to user
 * space.  It supports simple types like char and int, but not larger
 * data types like structures or arrays.
 *
 * @ptr must have pointer-to-simple-variable type, and @x must be assignable
 * to the result of dereferencing @ptr.
 *
 * Returns zero on success, or -EFAULT on error.
 */
#define put_user(x,ptr)							\
  __put_user_check((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))


/**
 * __get_user: - Get a simple variable from user space, with less checking.
 * @x:   Variable to store result.
 * @ptr: Source address, in user space.
 *
 * Context: User context only.  This function may sleep.
 *
 * This macro copies a single simple variable from user space to kernel
 * space.  It supports simple types like char and int, but not larger
 * data types like structures or arrays.
 *
 * @ptr must have pointer-to-simple-variable type, and the result of
 * dereferencing @ptr must be assignable to @x without a cast.
 *
 * Caller must check the pointer with access_ok() before calling this
 * function.
 *
 * Returns zero on success, or -EFAULT on error.
 * On error, the variable @x is set to zero.
 */
#define __get_user(x,ptr) \
  __get_user_nocheck((x),(ptr),sizeof(*(ptr)))


/**
 * __put_user: - Write a simple value into user space, with less checking.
 * @x:   Value to copy to user space.
 * @ptr: Destination address, in user space.
 *
 * Context: User context only.  This function may sleep.
 *
 * This macro copies a single simple value from kernel space to user
 * space.  It supports simple types like char and int, but not larger
 * data types like structures or arrays.
 *
 * @ptr must have pointer-to-simple-variable type, and @x must be assignable
 * to the result of dereferencing @ptr.
 *
 * Caller must check the pointer with access_ok() before calling this
 * function.
 *
 * Returns zero on success, or -EFAULT on error.
 */
#define __put_user(x,ptr) \
  __put_user_nocheck((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))

#define __put_user_nocheck(x,ptr,size)			\
({							\
	long __pu_err;					\
	__put_user_size((x),(ptr),(size),__pu_err);	\
	__pu_err;					\
})


#define __put_user_check(x,ptr,size)			\
({							\
	long __pu_err = -EFAULT;					\
	__typeof__(*(ptr)) *__pu_addr = (ptr);		\
	if (access_ok(VERIFY_WRITE,__pu_addr,size))	\
		__put_user_size((x),__pu_addr,(size),__pu_err);	\
	__pu_err;					\
})							

#define __put_user_u64(x, addr, err)				\
	__asm__ __volatile__(					\
		"1:	movl %%eax,0(%2)\n"			\
		"2:	movl %%edx,4(%2)\n"			\
		"3:\n"						\
		".section .fixup,\"ax\"\n"			\
		"4:	movl %3,%0\n"				\
		"	jmp 3b\n"				\
		".previous\n"					\
		".section __ex_table,\"a\"\n"			\
		"	.align 4\n"				\
		"	.long 1b,4b\n"				\
		"	.long 2b,4b\n"				\
		".previous"					\
		: "=r"(err)					\
		: "A" (x), "r" (addr), "i"(-EFAULT), "0"(err))

#define __put_user_size(x,ptr,size,retval)				\
do {									\
	retval = 0;							\
	switch (size) {							\
	  case 1: __put_user_asm(x,ptr,retval,"b","b","iq"); break;	\
	  case 2: __put_user_asm(x,ptr,retval,"w","w","ir"); break;	\
	  case 4: __put_user_asm(x,ptr,retval,"l","","ir"); break;	\
	  case 8: __put_user_u64(x,ptr,retval); break;			\
	  default: __put_user_bad();					\
	}								\
} while (0)

struct __large_struct { unsigned long buf[100]; };
#define __m(x) (*(struct __large_struct *)(x))

/*
 * Tell gcc we read from memory instead of writing: this is because
 * we do not write to any memory gcc knows about, so there are no
 * aliasing issues.
 */
#define __put_user_asm(x, addr, err, itype, rtype, ltype)	\
	__asm__ __volatile__(					\
		"1:	mov"itype" %"rtype"1,%2\n"		\
		"2:\n"						\
		".section .fixup,\"ax\"\n"			\
		"3:	movl %3,%0\n"				\
		"	jmp 2b\n"				\
		".previous\n"					\
		".section __ex_table,\"a\"\n"			\
		"	.align 4\n"				\
		"	.long 1b,3b\n"				\
		".previous"					\
		: "=r"(err)					\
		: ltype (x), "m"(__m(addr)), "i"(-EFAULT), "0"(err))


#define __get_user_nocheck(x,ptr,size)				\
({								\
	long __gu_err, __gu_val;				\
	__get_user_size(__gu_val,(ptr),(size),__gu_err);	\
	(x) = (__typeof__(*(ptr)))__gu_val;			\
	__gu_err;						\
})

extern long __get_user_bad(void);

#define __get_user_size(x,ptr,size,retval)				\
do {									\
	retval = 0;							\
	switch (size) {							\
	  case 1: __get_user_asm(x,ptr,retval,"b","b","=q"); break;	\
	  case 2: __get_user_asm(x,ptr,retval,"w","w","=r"); break;	\
	  case 4: __get_user_asm(x,ptr,retval,"l","","=r"); break;	\
	  default: (x) = __get_user_bad();				\
	}								\
} while (0)

#define __get_user_asm(x, addr, err, itype, rtype, ltype)	\
	__asm__ __volatile__(					\
		"1:	mov"itype" %2,%"rtype"1\n"		\
		"2:\n"						\
		".section .fixup,\"ax\"\n"			\
		"3:	movl %3,%0\n"				\
		"	xor"itype" %"rtype"1,%"rtype"1\n"	\
		"	jmp 2b\n"				\
		".previous\n"					\
		".section __ex_table,\"a\"\n"			\
		"	.align 4\n"				\
		"	.long 1b,3b\n"				\
		".previous"					\
		: "=r"(err), ltype (x)				\
		: "m"(__m(addr)), "i"(-EFAULT), "0"(err))


/*
 * Copy To/From Userspace
 */

/* Generic arbitrary sized copy.  */
#define __copy_user(to,from,size)					\
do {									\
	int __d0, __d1;							\
	__asm__ __volatile__(						\
		"0:	rep; movsl\n"					\
		"	movl %3,%0\n"					\
		"1:	rep; movsb\n"					\
		"2:\n"							\
		".section .fixup,\"ax\"\n"				\
		"3:	lea 0(%3,%0,4),%0\n"				\
		"	jmp 2b\n"					\
		".previous\n"						\
		".section __ex_table,\"a\"\n"				\
		"	.align 4\n"					\
		"	.long 0b,3b\n"					\
		"	.long 1b,2b\n"					\
		".previous"						\
		: "=&c"(size), "=&D" (__d0), "=&S" (__d1)		\
		: "r"(size & 3), "0"(size / 4), "1"(to), "2"(from)	\
		: "memory");						\
} while (0)

#define __copy_user_zeroing(to,from,size)				\
do {									\
	int __d0, __d1;							\
	__asm__ __volatile__(						\
		"0:	rep; movsl\n"					\
		"	movl %3,%0\n"					\
		"1:	rep; movsb\n"					\
		"2:\n"							\
		".section .fixup,\"ax\"\n"				\
		"3:	lea 0(%3,%0,4),%0\n"				\
		"4:	pushl %0\n"					\
		"	pushl %%eax\n"					\
		"	xorl %%eax,%%eax\n"				\
		"	rep; stosb\n"					\
		"	popl %%eax\n"					\
		"	popl %0\n"					\
		"	jmp 2b\n"					\
		".previous\n"						\
		".section __ex_table,\"a\"\n"				\
		"	.align 4\n"					\
		"	.long 0b,3b\n"					\
		"	.long 1b,4b\n"					\
		".previous"						\
		: "=&c"(size), "=&D" (__d0), "=&S" (__d1)		\
		: "r"(size & 3), "0"(size / 4), "1"(to), "2"(from)	\
		: "memory");						\
} while (0)

/* We let the __ versions of copy_from/to_user inline, because they're often
 * used in fast paths and have only a small space overhead.
 */
static inline unsigned long
__generic_copy_from_user_nocheck(void *to, const void *from, unsigned long n)
{
   1bb2f:	55                   	push   %ebp
   1bb30:	89 e5                	mov    %esp,%ebp
   1bb32:	57                   	push   %edi
   1bb33:	56                   	push   %esi
   1bb34:	83 ec 08             	sub    $0x8,%esp
	__copy_user_zeroing(to,from,n);
   1bb37:	8b 45 10             	mov    0x10(%ebp),%eax
   1bb3a:	83 e0 03             	and    $0x3,%eax
   1bb3d:	8b 55 10             	mov    0x10(%ebp),%edx
   1bb40:	89 d1                	mov    %edx,%ecx
   1bb42:	c1 e9 02             	shr    $0x2,%ecx
   1bb45:	8b 7d 08             	mov    0x8(%ebp),%edi
   1bb48:	8b 75 0c             	mov    0xc(%ebp),%esi
   1bb4b:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   1bb4d:	89 c1                	mov    %eax,%ecx
   1bb4f:	f3 a4                	repz movsb %ds:(%esi),%es:(%edi)
   1bb51:	89 c8                	mov    %ecx,%eax
   1bb53:	89 45 10             	mov    %eax,0x10(%ebp)
   1bb56:	89 f8                	mov    %edi,%eax
   1bb58:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1bb5b:	89 f0                	mov    %esi,%eax
   1bb5d:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	return n;
   1bb60:	8b 45 10             	mov    0x10(%ebp),%eax
}
   1bb63:	83 c4 08             	add    $0x8,%esp
   1bb66:	5e                   	pop    %esi
   1bb67:	5f                   	pop    %edi
   1bb68:	5d                   	pop    %ebp
   1bb69:	c3                   	ret    

0001bb6a <__generic_copy_to_user_nocheck>:

static inline unsigned long
__generic_copy_to_user_nocheck(void *to, const void *from, unsigned long n)
{
   1bb6a:	55                   	push   %ebp
   1bb6b:	89 e5                	mov    %esp,%ebp
   1bb6d:	57                   	push   %edi
   1bb6e:	56                   	push   %esi
   1bb6f:	83 ec 08             	sub    $0x8,%esp
	__copy_user(to,from,n);
   1bb72:	8b 45 10             	mov    0x10(%ebp),%eax
   1bb75:	83 e0 03             	and    $0x3,%eax
   1bb78:	8b 55 10             	mov    0x10(%ebp),%edx
   1bb7b:	89 d1                	mov    %edx,%ecx
   1bb7d:	c1 e9 02             	shr    $0x2,%ecx
   1bb80:	8b 7d 08             	mov    0x8(%ebp),%edi
   1bb83:	8b 75 0c             	mov    0xc(%ebp),%esi
   1bb86:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   1bb88:	89 c1                	mov    %eax,%ecx
   1bb8a:	f3 a4                	repz movsb %ds:(%esi),%es:(%edi)
   1bb8c:	89 c8                	mov    %ecx,%eax
   1bb8e:	89 45 10             	mov    %eax,0x10(%ebp)
   1bb91:	89 f8                	mov    %edi,%eax
   1bb93:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1bb96:	89 f0                	mov    %esi,%eax
   1bb98:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	return n;
   1bb9b:	8b 45 10             	mov    0x10(%ebp),%eax
}
   1bb9e:	83 c4 08             	add    $0x8,%esp
   1bba1:	5e                   	pop    %esi
   1bba2:	5f                   	pop    %edi
   1bba3:	5d                   	pop    %ebp
   1bba4:	c3                   	ret    

0001bba5 <insert_head>:
#endif

//#define DEBUG_LIST

static inline void insert_head(struct alloc_head_list *head, struct alloc_head *elem) {
   1bba5:	55                   	push   %ebp
   1bba6:	89 e5                	mov    %esp,%ebp
   1bba8:	83 ec 08             	sub    $0x8,%esp
#ifdef DEBUG_LIST
	if(elem->list) {
		BUG();
	}
#endif
	if(head->next == elem /* || elem->prev != NULL || elem->next != NULL */) {
   1bbab:	8b 45 08             	mov    0x8(%ebp),%eax
   1bbae:	8b 40 04             	mov    0x4(%eax),%eax
   1bbb1:	3b 45 0c             	cmp    0xc(%ebp),%eax
   1bbb4:	75 31                	jne    1bbe7 <insert_head+0x42>
		BUG();
   1bbb6:	c7 44 24 04 59 53 00 	movl   $0x5359,0x4(%esp,1)
   1bbbd:	00 
   1bbbe:	c7 04 24 5d 53 00 00 	movl   $0x535d,(%esp,1)
   1bbc5:	e8 fc ff ff ff       	call   1bbc6 <insert_head+0x21>
   1bbca:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1bbd1:	e8 fc ff ff ff       	call   1bbd2 <insert_head+0x2d>
   1bbd6:	e8 fc ff ff ff       	call   1bbd7 <insert_head+0x32>
		show_stack(NULL);	
   1bbdb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1bbe2:	e8 fc ff ff ff       	call   1bbe3 <insert_head+0x3e>
	}
	elem->next = head->next;
   1bbe7:	8b 55 0c             	mov    0xc(%ebp),%edx
   1bbea:	8b 45 08             	mov    0x8(%ebp),%eax
   1bbed:	8b 40 04             	mov    0x4(%eax),%eax
   1bbf0:	89 42 04             	mov    %eax,0x4(%edx)
	head->next->prev = elem;
   1bbf3:	8b 45 08             	mov    0x8(%ebp),%eax
   1bbf6:	8b 50 04             	mov    0x4(%eax),%edx
   1bbf9:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bbfc:	89 02                	mov    %eax,(%edx)

	elem->prev = (struct alloc_head*)head;
   1bbfe:	8b 55 0c             	mov    0xc(%ebp),%edx
   1bc01:	8b 45 08             	mov    0x8(%ebp),%eax
   1bc04:	89 02                	mov    %eax,(%edx)
	head->next = elem;
   1bc06:	8b 55 08             	mov    0x8(%ebp),%edx
   1bc09:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bc0c:	89 42 04             	mov    %eax,0x4(%edx)

	elem->list = head;
   1bc0f:	8b 55 0c             	mov    0xc(%ebp),%edx
   1bc12:	8b 45 08             	mov    0x8(%ebp),%eax
   1bc15:	89 42 08             	mov    %eax,0x8(%edx)
	head->len++;
   1bc18:	8b 45 08             	mov    0x8(%ebp),%eax
   1bc1b:	ff 40 10             	incl   0x10(%eax)
}
   1bc1e:	c9                   	leave  
   1bc1f:	c3                   	ret    

0001bc20 <csum_partial_copy_from_user>:

static __inline__
unsigned int csum_partial_copy_from_user ( const char *src, char *dst,
						int len, int sum, int *err_ptr)
{
   1bc20:	55                   	push   %ebp
   1bc21:	89 e5                	mov    %esp,%ebp
   1bc23:	83 ec 18             	sub    $0x18,%esp
	return csum_partial_copy_generic ( src, dst, len, sum, err_ptr, NULL);
   1bc26:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp,1)
   1bc2d:	00 
   1bc2e:	8b 45 18             	mov    0x18(%ebp),%eax
   1bc31:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   1bc35:	8b 45 14             	mov    0x14(%ebp),%eax
   1bc38:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   1bc3c:	8b 45 10             	mov    0x10(%ebp),%eax
   1bc3f:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1bc43:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bc46:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1bc4a:	8b 45 08             	mov    0x8(%ebp),%eax
   1bc4d:	89 04 24             	mov    %eax,(%esp,1)
   1bc50:	e8 fc ff ff ff       	call   1bc51 <csum_partial_copy_from_user+0x31>
}
   1bc55:	c9                   	leave  
   1bc56:	c3                   	ret    

0001bc57 <csum_add>:
}
#endif

static inline unsigned int csum_add(unsigned int csum, unsigned int addend)
{
   1bc57:	55                   	push   %ebp
   1bc58:	89 e5                	mov    %esp,%ebp
   1bc5a:	83 ec 04             	sub    $0x4,%esp
	csum += addend;
   1bc5d:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bc60:	01 45 08             	add    %eax,0x8(%ebp)
	return csum + (csum < addend);
   1bc63:	8b 45 08             	mov    0x8(%ebp),%eax
   1bc66:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   1bc69:	8b 45 08             	mov    0x8(%ebp),%eax
   1bc6c:	3b 45 0c             	cmp    0xc(%ebp),%eax
   1bc6f:	73 03                	jae    1bc74 <csum_add+0x1d>
   1bc71:	ff 45 fc             	incl   0xfffffffc(%ebp)
   1bc74:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
   1bc77:	c9                   	leave  
   1bc78:	c3                   	ret    

0001bc79 <free_minisock>:
	msk->serverSK = NULL;
}

#ifdef CAN_USE_TFREE
static inline void free_minisock(struct sock *sk, struct cminisock *msk) {
   1bc79:	55                   	push   %ebp
   1bc7a:	89 e5                	mov    %esp,%ebp
   1bc7c:	83 ec 0c             	sub    $0xc,%esp
	int i;
	/*
	printk("msk summary (%p [%d]) (%p [%d]) (%p [%d])\n", 
	       msk->packets, msk->num_packets,
	       msk->ucont_data, msk->ucont_len,
	       msk->input, msk->input_len);
	*/
	for(i=0; i < msk->num_packets; i++) {
   1bc7f:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   1bc86:	8b 55 0c             	mov    0xc(%ebp),%edx
   1bc89:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1bc8c:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
   1bc92:	7c 02                	jl     1bc96 <free_minisock+0x1d>
   1bc94:	eb 4e                	jmp    1bce4 <free_minisock+0x6b>
		if(msk->packets[i].ucontData != NULL) {
   1bc96:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1bc99:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1bc9c:	89 d0                	mov    %edx,%eax
   1bc9e:	c1 e0 03             	shl    $0x3,%eax
   1bca1:	01 d0                	add    %edx,%eax
   1bca3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1bcaa:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   1bcb0:	83 7c 10 14 00       	cmpl   $0x0,0x14(%eax,%edx,1)
   1bcb5:	74 26                	je     1bcdd <free_minisock+0x64>
			kfree(msk->packets[i].ucontData);
   1bcb7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1bcba:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1bcbd:	89 d0                	mov    %edx,%eax
   1bcbf:	c1 e0 03             	shl    $0x3,%eax
   1bcc2:	01 d0                	add    %edx,%eax
   1bcc4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1bccb:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   1bcd1:	8b 44 10 14          	mov    0x14(%eax,%edx,1),%eax
   1bcd5:	89 04 24             	mov    %eax,(%esp,1)
   1bcd8:	e8 fc ff ff ff       	call   1bcd9 <free_minisock+0x60>
   1bcdd:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
   1bce0:	ff 00                	incl   (%eax)
   1bce2:	eb a2                	jmp    1bc86 <free_minisock+0xd>
		}
	}
	// printk("done with packet data\n");
	if(!SIMULATION_MODE(sk) && msk->packets) {
   1bce4:	8b 45 08             	mov    0x8(%ebp),%eax
   1bce7:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   1bced:	83 e0 01             	and    $0x1,%eax
   1bcf0:	85 c0                	test   %eax,%eax
   1bcf2:	74 1b                	je     1bd0f <free_minisock+0x96>
   1bcf4:	8b 55 08             	mov    0x8(%ebp),%edx
   1bcf7:	8b 45 08             	mov    0x8(%ebp),%eax
   1bcfa:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   1bd00:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
   1bd06:	83 e0 08             	and    $0x8,%eax
   1bd09:	85 c0                	test   %eax,%eax
   1bd0b:	75 02                	jne    1bd0f <free_minisock+0x96>
   1bd0d:	eb 31                	jmp    1bd40 <free_minisock+0xc7>
   1bd0f:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bd12:	83 b8 ec 00 00 00 00 	cmpl   $0x0,0xec(%eax)
   1bd19:	74 25                	je     1bd40 <free_minisock+0xc7>
		tfree(sk,msk->packets);
   1bd1b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bd1e:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
   1bd24:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1bd28:	8b 45 08             	mov    0x8(%ebp),%eax
   1bd2b:	89 04 24             	mov    %eax,(%esp,1)
   1bd2e:	e8 fc ff ff ff       	call   1bd2f <free_minisock+0xb6>
		msk->packets = NULL;
   1bd33:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bd36:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%eax)
   1bd3d:	00 00 00 
	}
	// printk("done with packet array\n");
	msk->num_packets = 0;
   1bd40:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bd43:	c7 80 e8 00 00 00 00 	movl   $0x0,0xe8(%eax)
   1bd4a:	00 00 00 

	if(msk->ucont_data != NULL) {
   1bd4d:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bd50:	83 78 7c 00          	cmpl   $0x0,0x7c(%eax)
   1bd54:	74 1f                	je     1bd75 <free_minisock+0xfc>
		tfree(sk,msk->ucont_data);
   1bd56:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bd59:	8b 40 7c             	mov    0x7c(%eax),%eax
   1bd5c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1bd60:	8b 45 08             	mov    0x8(%ebp),%eax
   1bd63:	89 04 24             	mov    %eax,(%esp,1)
   1bd66:	e8 fc ff ff ff       	call   1bd67 <free_minisock+0xee>
		msk->ucont_data = NULL;
   1bd6b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bd6e:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	}
	// printk("done with ucont data\n");
	msk->ucont_len = 0;
   1bd75:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bd78:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
	if(msk->input != NULL) {
   1bd7f:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bd82:	83 b8 98 00 00 00 00 	cmpl   $0x0,0x98(%eax)
   1bd89:	74 25                	je     1bdb0 <free_minisock+0x137>
		tfree(sk,msk->input);
   1bd8b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bd8e:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   1bd94:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1bd98:	8b 45 08             	mov    0x8(%ebp),%eax
   1bd9b:	89 04 24             	mov    %eax,(%esp,1)
   1bd9e:	e8 fc ff ff ff       	call   1bd9f <free_minisock+0x126>
		msk->input = NULL;
   1bda3:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bda6:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
   1bdad:	00 00 00 
	}
	// printk("done with input len\n");
	msk->input_len = 0;
   1bdb0:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bdb3:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
   1bdba:	00 00 00 
}
   1bdbd:	c9                   	leave  
   1bdbe:	c3                   	ret    

0001bdbf <msk_free_fields>:

static inline void msk_free_fields(struct sock *sk, struct cminisock *msk) {
   1bdbf:	55                   	push   %ebp
   1bdc0:	89 e5                	mov    %esp,%ebp
   1bdc2:	83 ec 08             	sub    $0x8,%esp
	free_minisock(sk, msk);
   1bdc5:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bdc8:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1bdcc:	8b 45 08             	mov    0x8(%ebp),%eax
   1bdcf:	89 04 24             	mov    %eax,(%esp,1)
   1bdd2:	e8 a2 fe ff ff       	call   1bc79 <free_minisock>
}
   1bdd7:	c9                   	leave  
   1bdd8:	c3                   	ret    

0001bdd9 <msk_hold>:

static inline void msk_clear_fields(struct cminisock *msk) {
	msk->num_packets = 0;
	msk->packets = NULL;

	msk->ucont_len = 0;
	msk->ucont_data = NULL;

	msk->input_len = 0;
	msk->input = NULL;
}

#endif

#ifndef USERTEST

static inline int alloc_msk_packets(struct cminisock *msk, int numPackets) {
	BUG_TRAP(msk->num_packets == 0);
	BUG_TRAP(numPackets >= 0);
#define MAX_NUM_SIMULATION_PACKETS (8000)
	static struct cminisock_packet packets[NR_CPUS][MAX_NUM_SIMULATION_PACKETS];
	if(!SIMULATION_MODE(msk->sk)) {
		msk->packets = tmalloc(msk->sk, sizeof(struct cminisock_packet) * numPackets);

		// printk("allocated packets to %p\n", msk->packets);

		if(msk->packets == NULL) {
			if(trickles_ratelimit()) {
				printk("out of memory while tmalloc()'ing space for packets\n");
			}
			return 0;
		}
	} else {
		// avoid malloc
		if(numPackets <= MAX_NUM_SIMULATION_PACKETS) {
			msk->packets = packets[smp_processor_id()];
		} else {
			msk->packets = NULL;
			if(trickles_ratelimit()) {
				printk("Too many packets requested during simulation\n");
			}
			return 0;
		}
	}
	msk->num_packets = numPackets;
	return 1;
}

static inline
int can_alloc_trickles_msk(struct sock *sk) {
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
	struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
	struct cminisock *curr =
		(struct cminisock *)head->next;
	while((struct alloc_head_list*)curr != head && curr->ctl == ALLOC_PROCESSING) {
		//printk("alloc_head loop\n");
		curr = curr->next;
	}
	return (struct alloc_head_list*)curr != head;
}

static inline struct cminisock *alloc_trickles_msk(struct sock *sk) {
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
	struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
	struct cminisock *rval = NULL, *curr = (struct cminisock *)tp->cminisock_api_config.msk_freelist.next;

	if(!SIMULATION_MODE(sk)) {
		while((struct alloc_head_list*)curr != head && curr->ctl == ALLOC_PROCESSING) {
			//printk("alloc_head loop\n");
			curr = curr->next;
		}
		//printk("out of alloc_head loop\n");

		if((struct alloc_head_list *)curr == head) return NULL;

		rval = curr;
		unlink((struct alloc_head*)rval);
		rval->ctl = ALLOC_PENDING;
	} else {
		if(tp->t.responseCount == 0) {
			rval = tp->t.responseMSK;
			rval->list = NULL;
			rval->next = rval->prev = NULL;
		} else {
			rval = kmalloc(sizeof (struct cminisock), GFP_ATOMIC);
			if(rval == NULL) {
				printk("out of memory during compatibility mode\n");
				return NULL;
			}
			rval->next = rval->prev = NULL;
			rval->list = NULL;
			insert_tail(&tp->t.responseList, (struct alloc_head*)rval);
		}
		tp->t.responseCount++;

		rval->sk = sk;
		rval->ctl = ALLOC_PENDING;
	}

	init_minisock(rval);

	return rval;
}

static inline void msk_hold(struct cminisock *msk) {
   1bdd9:	55                   	push   %ebp
   1bdda:	89 e5                	mov    %esp,%ebp
	msk->refCnt++;
   1bddc:	8b 45 08             	mov    0x8(%ebp),%eax
   1bddf:	ff 80 f0 00 00 00    	incl   0xf0(%eax)
}
   1bde5:	5d                   	pop    %ebp
   1bde6:	c3                   	ret    

0001bde7 <init_sock>:
   1bde7:	55                   	push   %ebp
   1bde8:	89 e5                	mov    %esp,%ebp
   1bdea:	8b 55 08             	mov    0x8(%ebp),%edx
   1bded:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bdf0:	89 42 20             	mov    %eax,0x20(%edx)
   1bdf3:	8b 45 08             	mov    0x8(%ebp),%eax
   1bdf6:	8b 40 20             	mov    0x20(%eax),%eax
   1bdf9:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
   1be00:	8b 45 08             	mov    0x8(%ebp),%eax
   1be03:	8b 40 20             	mov    0x20(%eax),%eax
   1be06:	c7 80 84 0b 00 00 00 	movl   $0x0,0xb84(%eax)
   1be0d:	00 00 00 
   1be10:	8b 45 08             	mov    0x8(%ebp),%eax
   1be13:	8b 40 20             	mov    0x20(%eax),%eax
   1be16:	c7 80 78 0b 00 00 ff 	movl   $0xff,0xb78(%eax)
   1be1d:	00 00 00 
   1be20:	8b 45 08             	mov    0x8(%ebp),%eax
   1be23:	8b 40 20             	mov    0x20(%eax),%eax
   1be26:	c6 80 5b 0b 00 00 06 	movb   $0x6,0xb5b(%eax)
   1be2d:	8b 45 08             	mov    0x8(%ebp),%eax
   1be30:	8b 40 20             	mov    0x20(%eax),%eax
   1be33:	c7 80 7c 0b 00 00 00 	movl   $0x0,0xb7c(%eax)
   1be3a:	00 00 00 
   1be3d:	8b 45 08             	mov    0x8(%ebp),%eax
   1be40:	8b 40 20             	mov    0x20(%eax),%eax
   1be43:	c7 80 a8 02 00 00 00 	movl   $0x0,0x2a8(%eax)
   1be4a:	00 00 00 
   1be4d:	8b 45 08             	mov    0x8(%ebp),%eax
   1be50:	8b 40 20             	mov    0x20(%eax),%eax
   1be53:	c6 80 5a 0b 00 00 00 	movb   $0x0,0xb5a(%eax)
   1be5a:	83 3d 08 00 00 00 00 	cmpl   $0x0,0x8
   1be61:	74 0f                	je     1be72 <init_sock+0x8b>
   1be63:	8b 45 08             	mov    0x8(%ebp),%eax
   1be66:	8b 40 20             	mov    0x20(%eax),%eax
   1be69:	c6 80 8e 0b 00 00 00 	movb   $0x0,0xb8e(%eax)
   1be70:	eb 0d                	jmp    1be7f <init_sock+0x98>
   1be72:	8b 45 08             	mov    0x8(%ebp),%eax
   1be75:	8b 40 20             	mov    0x20(%eax),%eax
   1be78:	c6 80 8e 0b 00 00 01 	movb   $0x1,0xb8e(%eax)
   1be7f:	8b 45 08             	mov    0x8(%ebp),%eax
   1be82:	8b 40 20             	mov    0x20(%eax),%eax
   1be85:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
   1be8c:	8b 45 08             	mov    0x8(%ebp),%eax
   1be8f:	8b 50 20             	mov    0x20(%eax),%edx
   1be92:	8b 45 08             	mov    0x8(%ebp),%eax
   1be95:	8b 40 14             	mov    0x14(%eax),%eax
   1be98:	89 42 70             	mov    %eax,0x70(%edx)
   1be9b:	8b 45 08             	mov    0x8(%ebp),%eax
   1be9e:	8b 50 20             	mov    0x20(%eax),%edx
   1bea1:	8b 45 08             	mov    0x8(%ebp),%eax
   1bea4:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
   1bea8:	66 89 42 22          	mov    %ax,0x22(%edx)
   1beac:	8b 45 08             	mov    0x8(%ebp),%eax
   1beaf:	8b 50 20             	mov    0x20(%eax),%edx
   1beb2:	8b 45 08             	mov    0x8(%ebp),%eax
   1beb5:	8b 40 18             	mov    0x18(%eax),%eax
   1beb8:	89 02                	mov    %eax,(%edx)
   1beba:	8b 45 08             	mov    0x8(%ebp),%eax
   1bebd:	8b 50 20             	mov    0x20(%eax),%edx
   1bec0:	8b 45 08             	mov    0x8(%ebp),%eax
   1bec3:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
   1bec7:	66 89 42 08          	mov    %ax,0x8(%edx)
   1becb:	5d                   	pop    %ebp
   1becc:	c3                   	ret    

0001becd <lbb_check_reserve>:
	return lbb->curr;
}

static inline
int lbb_check_reserve(struct linear_bounded_buffer *lbb, int len) {
   1becd:	55                   	push   %ebp
   1bece:	89 e5                	mov    %esp,%ebp
   1bed0:	83 ec 04             	sub    $0x4,%esp
	return lbb->curr + len - lbb->start <= lbb->limit;
   1bed3:	8b 55 08             	mov    0x8(%ebp),%edx
   1bed6:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bed9:	8b 52 04             	mov    0x4(%edx),%edx
   1bedc:	01 c2                	add    %eax,%edx
   1bede:	89 55 fc             	mov    %edx,0xfffffffc(%ebp)
   1bee1:	8b 45 08             	mov    0x8(%ebp),%eax
   1bee4:	8b 10                	mov    (%eax),%edx
   1bee6:	29 55 fc             	sub    %edx,0xfffffffc(%ebp)
   1bee9:	8b 45 08             	mov    0x8(%ebp),%eax
   1beec:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1beef:	3b 50 08             	cmp    0x8(%eax),%edx
   1bef2:	0f 9e c0             	setle  %al
   1bef5:	0f b6 c0             	movzbl %al,%eax
   1bef8:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   1befb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
   1befe:	c9                   	leave  
   1beff:	c3                   	ret    

0001bf00 <skb_peek_tail>:
 *	volatile. Use with caution.
 */

static inline struct sk_buff *skb_peek_tail(struct sk_buff_head *list_)
{
   1bf00:	55                   	push   %ebp
   1bf01:	89 e5                	mov    %esp,%ebp
   1bf03:	83 ec 04             	sub    $0x4,%esp
	struct sk_buff *list = ((struct sk_buff *)list_)->prev;
   1bf06:	8b 45 08             	mov    0x8(%ebp),%eax
   1bf09:	8b 40 04             	mov    0x4(%eax),%eax
   1bf0c:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	if (list == (struct sk_buff *)list_)
   1bf0f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1bf12:	3b 45 08             	cmp    0x8(%ebp),%eax
   1bf15:	75 07                	jne    1bf1e <skb_peek_tail+0x1e>
		list = NULL;
   1bf17:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
	return list;
   1bf1e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
   1bf21:	c9                   	leave  
   1bf22:	c3                   	ret    

0001bf23 <__skb_unlink>:

/**
 *	skb_queue_len	- get queue length
 *	@list_: list to measure
 *
 *	Return the length of an &sk_buff queue. 
 */
 
static inline __u32 skb_queue_len(struct sk_buff_head *list_)
{
	return(list_->qlen);
}

static inline void skb_queue_head_init(struct sk_buff_head *list)
{
	spin_lock_init(&list->lock);
	list->prev = (struct sk_buff *)list;
	list->next = (struct sk_buff *)list;
	list->qlen = 0;
}

/*
 *	Insert an sk_buff at the start of a list.
 *
 *	The "__skb_xxxx()" functions are the non-atomic ones that
 *	can only be called with interrupts disabled.
 */

/**
 *	__skb_queue_head - queue a buffer at the list head
 *	@list: list to use
 *	@newsk: buffer to queue
 *
 *	Queue a buffer at the start of a list. This function takes no locks
 *	and you must therefore hold required locks before calling it.
 *
 *	A buffer cannot be placed on two lists at the same time.
 */	
 
static inline void __skb_queue_head(struct sk_buff_head *list, struct sk_buff *newsk)
{
	struct sk_buff *prev, *next;

	newsk->list = list;
	list->qlen++;
	prev = (struct sk_buff *)list;
	next = prev->next;
	newsk->next = next;
	newsk->prev = prev;
	next->prev = newsk;
	prev->next = newsk;
}


/**
 *	skb_queue_head - queue a buffer at the list head
 *	@list: list to use
 *	@newsk: buffer to queue
 *
 *	Queue a buffer at the start of the list. This function takes the
 *	list lock and can be used safely with other locking &sk_buff functions
 *	safely.
 *
 *	A buffer cannot be placed on two lists at the same time.
 */	

static inline void skb_queue_head(struct sk_buff_head *list, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&list->lock, flags);
	__skb_queue_head(list, newsk);
	spin_unlock_irqrestore(&list->lock, flags);
}

/**
 *	__skb_queue_tail - queue a buffer at the list tail
 *	@list: list to use
 *	@newsk: buffer to queue
 *
 *	Queue a buffer at the end of a list. This function takes no locks
 *	and you must therefore hold required locks before calling it.
 *
 *	A buffer cannot be placed on two lists at the same time.
 */	
 

static inline void __skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
	struct sk_buff *prev, *next;

	newsk->list = list;
	list->qlen++;
	next = (struct sk_buff *)list;
	prev = next->prev;
	newsk->next = next;
	newsk->prev = prev;
	next->prev = newsk;
	prev->next = newsk;
}

/**
 *	skb_queue_tail - queue a buffer at the list tail
 *	@list: list to use
 *	@newsk: buffer to queue
 *
 *	Queue a buffer at the tail of the list. This function takes the
 *	list lock and can be used safely with other locking &sk_buff functions
 *	safely.
 *
 *	A buffer cannot be placed on two lists at the same time.
 */	

static inline void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&list->lock, flags);
	__skb_queue_tail(list, newsk);
	spin_unlock_irqrestore(&list->lock, flags);
}

/**
 *	__skb_dequeue - remove from the head of the queue
 *	@list: list to dequeue from
 *
 *	Remove the head of the list. This function does not take any locks
 *	so must be used with appropriate locks held only. The head item is
 *	returned or %NULL if the list is empty.
 */

static inline struct sk_buff *__skb_dequeue(struct sk_buff_head *list)
{
	struct sk_buff *next, *prev, *result;

	prev = (struct sk_buff *) list;
	next = prev->next;
	result = NULL;
	if (next != prev) {
		result = next;
		next = next->next;
		list->qlen--;
		next->prev = prev;
		prev->next = next;
		result->next = NULL;
		result->prev = NULL;
		result->list = NULL;
	}
	return result;
}

/**
 *	skb_dequeue - remove from the head of the queue
 *	@list: list to dequeue from
 *
 *	Remove the head of the list. The list lock is taken so the function
 *	may be used safely with other locking list functions. The head item is
 *	returned or %NULL if the list is empty.
 */

static inline struct sk_buff *skb_dequeue(struct sk_buff_head *list)
{
	unsigned long flags;
	struct sk_buff *result;

	spin_lock_irqsave(&list->lock, flags);
	result = __skb_dequeue(list);
	spin_unlock_irqrestore(&list->lock, flags);
	return result;
}

/*
 *	Insert a packet on a list.
 */

static inline void __skb_insert(struct sk_buff *newsk,
	struct sk_buff * prev, struct sk_buff *next,
	struct sk_buff_head * list)
{
	newsk->next = next;
	newsk->prev = prev;
	next->prev = newsk;
	prev->next = newsk;
	newsk->list = list;
	list->qlen++;
}

/**
 *	skb_insert	-	insert a buffer
 *	@old: buffer to insert before
 *	@newsk: buffer to insert
 *
 *	Place a packet before a given packet in a list. The list locks are taken
 *	and this function is atomic with respect to other list locked calls
 *	A buffer cannot be placed on two lists at the same time.
 */

static inline void skb_insert(struct sk_buff *old, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&old->list->lock, flags);
	__skb_insert(newsk, old->prev, old, old->list);
	spin_unlock_irqrestore(&old->list->lock, flags);
}

/*
 *	Place a packet after a given packet in a list.
 */

static inline void __skb_append(struct sk_buff *old, struct sk_buff *newsk)
{
	__skb_insert(newsk, old, old->next, old->list);
}

/**
 *	skb_append	-	append a buffer
 *	@old: buffer to insert after
 *	@newsk: buffer to insert
 *
 *	Place a packet after a given packet in a list. The list locks are taken
 *	and this function is atomic with respect to other list locked calls.
 *	A buffer cannot be placed on two lists at the same time.
 */


static inline void skb_append(struct sk_buff *old, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&old->list->lock, flags);
	__skb_append(old, newsk);
	spin_unlock_irqrestore(&old->list->lock, flags);
}

/*
 * remove sk_buff from list. _Must_ be called atomically, and with
 * the list known..
 */
 
static inline void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
{
   1bf23:	55                   	push   %ebp
   1bf24:	89 e5                	mov    %esp,%ebp
   1bf26:	83 ec 08             	sub    $0x8,%esp
	struct sk_buff * next, * prev;

	list->qlen--;
   1bf29:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bf2c:	ff 48 08             	decl   0x8(%eax)
	next = skb->next;
   1bf2f:	8b 45 08             	mov    0x8(%ebp),%eax
   1bf32:	8b 00                	mov    (%eax),%eax
   1bf34:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	prev = skb->prev;
   1bf37:	8b 45 08             	mov    0x8(%ebp),%eax
   1bf3a:	8b 40 04             	mov    0x4(%eax),%eax
   1bf3d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	skb->next = NULL;
   1bf40:	8b 45 08             	mov    0x8(%ebp),%eax
   1bf43:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	skb->prev = NULL;
   1bf49:	8b 45 08             	mov    0x8(%ebp),%eax
   1bf4c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	skb->list = NULL;
   1bf53:	8b 45 08             	mov    0x8(%ebp),%eax
   1bf56:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	next->prev = prev;
   1bf5d:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1bf60:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1bf63:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   1bf66:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   1bf69:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1bf6c:	89 02                	mov    %eax,(%edx)
}
   1bf6e:	c9                   	leave  
   1bf6f:	c3                   	ret    

0001bf70 <.text.lock.tmalloc>:
   1bf70:	50                   	push   %eax
   1bf71:	51                   	push   %ecx
   1bf72:	52                   	push   %edx
   1bf73:	e8 fc ff ff ff       	call   1bf74 <.text.lock.tmalloc+0x4>
   1bf78:	5a                   	pop    %edx
   1bf79:	59                   	pop    %ecx
   1bf7a:	58                   	pop    %eax
   1bf7b:	e9 61 6e ff ff       	jmp    12de1 <tcp_prequeue_process+0x7d>
   1bf80:	50                   	push   %eax
   1bf81:	51                   	push   %ecx
   1bf82:	52                   	push   %edx
   1bf83:	e8 fc ff ff ff       	call   1bf84 <.text.lock.tmalloc+0x14>
   1bf88:	5a                   	pop    %edx
   1bf89:	59                   	pop    %ecx
   1bf8a:	58                   	pop    %eax
   1bf8b:	e9 d6 75 ff ff       	jmp    13566 <trickles_close+0x4f>
   1bf90:	50                   	push   %eax
   1bf91:	51                   	push   %ecx
   1bf92:	52                   	push   %edx
   1bf93:	e8 fc ff ff ff       	call   1bf94 <.text.lock.tmalloc+0x24>
   1bf98:	5a                   	pop    %edx
   1bf99:	59                   	pop    %ecx
   1bf9a:	58                   	pop    %eax
   1bf9b:	e9 b3 76 ff ff       	jmp    13653 <trickles_close+0x13c>
   1bfa0:	50                   	push   %eax
   1bfa1:	51                   	push   %ecx
   1bfa2:	52                   	push   %edx
   1bfa3:	e8 fc ff ff ff       	call   1bfa4 <.text.lock.tmalloc+0x34>
   1bfa8:	5a                   	pop    %edx
   1bfa9:	59                   	pop    %ecx
   1bfaa:	58                   	pop    %eax
   1bfab:	e9 e8 76 ff ff       	jmp    13698 <trickles_close+0x181>
   1bfb0:	50                   	push   %eax
   1bfb1:	51                   	push   %ecx
   1bfb2:	52                   	push   %edx
   1bfb3:	e8 fc ff ff ff       	call   1bfb4 <.text.lock.tmalloc+0x44>
   1bfb8:	5a                   	pop    %edx
   1bfb9:	59                   	pop    %ecx
   1bfba:	58                   	pop    %eax
   1bfbb:	e9 68 77 ff ff       	jmp    13728 <trickles_init_sock_impl+0x83>
   1bfc0:	50                   	push   %eax
   1bfc1:	51                   	push   %ecx
   1bfc2:	52                   	push   %edx
   1bfc3:	e8 fc ff ff ff       	call   1bfc4 <.text.lock.tmalloc+0x54>
   1bfc8:	5a                   	pop    %edx
   1bfc9:	59                   	pop    %ecx
   1bfca:	58                   	pop    %eax
   1bfcb:	e9 17 78 ff ff       	jmp    137e7 <trickles_init_sock_impl+0x142>
   1bfd0:	50                   	push   %eax
   1bfd1:	51                   	push   %ecx
   1bfd2:	52                   	push   %edx
   1bfd3:	e8 fc ff ff ff       	call   1bfd4 <.text.lock.tmalloc+0x64>
   1bfd8:	5a                   	pop    %edx
   1bfd9:	59                   	pop    %ecx
   1bfda:	58                   	pop    %eax
   1bfdb:	e9 25 78 ff ff       	jmp    13805 <trickles_init_sock_impl+0x160>
   1bfe0:	50                   	push   %eax
   1bfe1:	51                   	push   %ecx
   1bfe2:	52                   	push   %edx
   1bfe3:	e8 fc ff ff ff       	call   1bfe4 <.text.lock.tmalloc+0x74>
   1bfe8:	5a                   	pop    %edx
   1bfe9:	59                   	pop    %ecx
   1bfea:	58                   	pop    %eax
   1bfeb:	e9 f3 78 ff ff       	jmp    138e3 <trickles_sendmsg+0xdc>
   1bff0:	50                   	push   %eax
   1bff1:	51                   	push   %ecx
   1bff2:	52                   	push   %edx
   1bff3:	e8 fc ff ff ff       	call   1bff4 <.text.lock.tmalloc+0x84>
   1bff8:	5a                   	pop    %edx
   1bff9:	59                   	pop    %ecx
   1bffa:	58                   	pop    %eax
   1bffb:	e9 7a 79 ff ff       	jmp    1397a <trickles_sendmsg+0x173>
   1c000:	50                   	push   %eax
   1c001:	51                   	push   %ecx
   1c002:	52                   	push   %edx
   1c003:	e8 fc ff ff ff       	call   1c004 <.text.lock.tmalloc+0x94>
   1c008:	5a                   	pop    %edx
   1c009:	59                   	pop    %ecx
   1c00a:	58                   	pop    %eax
   1c00b:	e9 c0 79 ff ff       	jmp    139d0 <trickles_sendmsg+0x1c9>
   1c010:	50                   	push   %eax
   1c011:	51                   	push   %ecx
   1c012:	52                   	push   %edx
   1c013:	e8 fc ff ff ff       	call   1c014 <.text.lock.tmalloc+0xa4>
   1c018:	5a                   	pop    %edx
   1c019:	59                   	pop    %ecx
   1c01a:	58                   	pop    %eax
   1c01b:	e9 43 7a ff ff       	jmp    13a63 <trickles_sendmsg+0x25c>
   1c020:	50                   	push   %eax
   1c021:	51                   	push   %ecx
   1c022:	52                   	push   %edx
   1c023:	e8 fc ff ff ff       	call   1c024 <.text.lock.tmalloc+0xb4>
   1c028:	5a                   	pop    %edx
   1c029:	59                   	pop    %ecx
   1c02a:	58                   	pop    %eax
   1c02b:	e9 dc 7b ff ff       	jmp    13c0c <trickles_sendmsg+0x405>
   1c030:	50                   	push   %eax
   1c031:	51                   	push   %ecx
   1c032:	52                   	push   %edx
   1c033:	e8 fc ff ff ff       	call   1c034 <.text.lock.tmalloc+0xc4>
   1c038:	5a                   	pop    %edx
   1c039:	59                   	pop    %ecx
   1c03a:	58                   	pop    %eax
   1c03b:	e9 b3 7c ff ff       	jmp    13cf3 <trickles_sendmsg+0x4ec>
   1c040:	50                   	push   %eax
   1c041:	51                   	push   %ecx
   1c042:	52                   	push   %edx
   1c043:	e8 fc ff ff ff       	call   1c044 <.text.lock.tmalloc+0xd4>
   1c048:	5a                   	pop    %edx
   1c049:	59                   	pop    %ecx
   1c04a:	58                   	pop    %eax
   1c04b:	e9 5f 7d ff ff       	jmp    13daf <trickles_poll+0xb1>
   1c050:	50                   	push   %eax
   1c051:	51                   	push   %ecx
   1c052:	52                   	push   %edx
   1c053:	e8 fc ff ff ff       	call   1c054 <.text.lock.tmalloc+0xe4>
   1c058:	5a                   	pop    %edx
   1c059:	59                   	pop    %ecx
   1c05a:	58                   	pop    %eax
   1c05b:	e9 9f 7d ff ff       	jmp    13dff <trickles_poll+0x101>
   1c060:	50                   	push   %eax
   1c061:	51                   	push   %ecx
   1c062:	52                   	push   %edx
   1c063:	e8 fc ff ff ff       	call   1c064 <.text.lock.tmalloc+0xf4>
   1c068:	5a                   	pop    %edx
   1c069:	59                   	pop    %ecx
   1c06a:	58                   	pop    %eax
   1c06b:	e9 47 80 ff ff       	jmp    140b7 <cminisock_config_pipe_impl+0xba>
   1c070:	50                   	push   %eax
   1c071:	51                   	push   %ecx
   1c072:	52                   	push   %edx
   1c073:	e8 fc ff ff ff       	call   1c074 <.text.lock.tmalloc+0x104>
   1c078:	5a                   	pop    %edx
   1c079:	59                   	pop    %ecx
   1c07a:	58                   	pop    %eax
   1c07b:	e9 88 80 ff ff       	jmp    14108 <cminisock_config_pipe_impl+0x10b>
   1c080:	50                   	push   %eax
   1c081:	51                   	push   %ecx
   1c082:	52                   	push   %edx
   1c083:	e8 fc ff ff ff       	call   1c084 <.text.lock.tmalloc+0x114>
   1c088:	5a                   	pop    %edx
   1c089:	59                   	pop    %ecx
   1c08a:	58                   	pop    %eax
   1c08b:	e9 42 89 ff ff       	jmp    149d2 <trickles_sendv_impl+0x107>
   1c090:	50                   	push   %eax
   1c091:	51                   	push   %ecx
   1c092:	52                   	push   %edx
   1c093:	e8 fc ff ff ff       	call   1c094 <.text.lock.tmalloc+0x124>
   1c098:	5a                   	pop    %edx
   1c099:	59                   	pop    %ecx
   1c09a:	58                   	pop    %eax
   1c09b:	e9 c5 89 ff ff       	jmp    14a65 <trickles_sendv_impl+0x19a>
   1c0a0:	50                   	push   %eax
   1c0a1:	51                   	push   %ecx
   1c0a2:	52                   	push   %edx
   1c0a3:	e8 fc ff ff ff       	call   1c0a4 <.text.lock.tmalloc+0x134>
   1c0a8:	5a                   	pop    %edx
   1c0a9:	59                   	pop    %ecx
   1c0aa:	58                   	pop    %eax
   1c0ab:	e9 5e 8b ff ff       	jmp    14c0e <trickles_sendv_impl+0x343>
   1c0b0:	50                   	push   %eax
   1c0b1:	51                   	push   %ecx
   1c0b2:	52                   	push   %edx
   1c0b3:	e8 fc ff ff ff       	call   1c0b4 <.text.lock.tmalloc+0x144>
   1c0b8:	5a                   	pop    %edx
   1c0b9:	59                   	pop    %ecx
   1c0ba:	58                   	pop    %eax
   1c0bb:	e9 f4 8b ff ff       	jmp    14cb4 <trickles_sendv_impl+0x3e9>
   1c0c0:	50                   	push   %eax
   1c0c1:	51                   	push   %ecx
   1c0c2:	52                   	push   %edx
   1c0c3:	e8 fc ff ff ff       	call   1c0c4 <.text.lock.tmalloc+0x154>
   1c0c8:	5a                   	pop    %edx
   1c0c9:	59                   	pop    %ecx
   1c0ca:	58                   	pop    %eax
   1c0cb:	e9 26 8f ff ff       	jmp    14ff6 <trickles_sendfilev_impl+0x101>
   1c0d0:	50                   	push   %eax
   1c0d1:	51                   	push   %ecx
   1c0d2:	52                   	push   %edx
   1c0d3:	e8 fc ff ff ff       	call   1c0d4 <.text.lock.tmalloc+0x164>
   1c0d8:	5a                   	pop    %edx
   1c0d9:	59                   	pop    %ecx
   1c0da:	58                   	pop    %eax
   1c0db:	e9 9e 8f ff ff       	jmp    1507e <trickles_sendfilev_impl+0x189>
   1c0e0:	50                   	push   %eax
   1c0e1:	51                   	push   %ecx
   1c0e2:	52                   	push   %edx
   1c0e3:	e8 fc ff ff ff       	call   1c0e4 <.text.lock.tmalloc+0x174>
   1c0e8:	5a                   	pop    %edx
   1c0e9:	59                   	pop    %ecx
   1c0ea:	58                   	pop    %eax
   1c0eb:	e9 3e 91 ff ff       	jmp    1522e <trickles_sendfilev_impl+0x339>
   1c0f0:	50                   	push   %eax
   1c0f1:	51                   	push   %ecx
   1c0f2:	52                   	push   %edx
   1c0f3:	e8 fc ff ff ff       	call   1c0f4 <.text.lock.tmalloc+0x184>
   1c0f8:	5a                   	pop    %edx
   1c0f9:	59                   	pop    %ecx
   1c0fa:	58                   	pop    %eax
   1c0fb:	e9 d4 91 ff ff       	jmp    152d4 <trickles_sendfilev_impl+0x3df>
   1c100:	50                   	push   %eax
   1c101:	51                   	push   %ecx
   1c102:	52                   	push   %edx
   1c103:	e8 fc ff ff ff       	call   1c104 <.text.lock.tmalloc+0x194>
   1c108:	5a                   	pop    %edx
   1c109:	59                   	pop    %ecx
   1c10a:	58                   	pop    %eax
   1c10b:	e9 6d 92 ff ff       	jmp    1537d <trickles_send_impl+0x88>
   1c110:	50                   	push   %eax
   1c111:	51                   	push   %ecx
   1c112:	52                   	push   %edx
   1c113:	e8 fc ff ff ff       	call   1c114 <.text.lock.tmalloc+0x1a4>
   1c118:	5a                   	pop    %edx
   1c119:	59                   	pop    %ecx
   1c11a:	58                   	pop    %eax
   1c11b:	e9 e5 92 ff ff       	jmp    15405 <trickles_send_impl+0x110>
   1c120:	50                   	push   %eax
   1c121:	51                   	push   %ecx
   1c122:	52                   	push   %edx
   1c123:	e8 fc ff ff ff       	call   1c124 <.text.lock.tmalloc+0x1b4>
   1c128:	5a                   	pop    %edx
   1c129:	59                   	pop    %ecx
   1c12a:	58                   	pop    %eax
   1c12b:	e9 63 94 ff ff       	jmp    15593 <trickles_send_impl+0x29e>
   1c130:	50                   	push   %eax
   1c131:	51                   	push   %ecx
   1c132:	52                   	push   %edx
   1c133:	e8 fc ff ff ff       	call   1c134 <.text.lock.tmalloc+0x1c4>
   1c138:	5a                   	pop    %edx
   1c139:	59                   	pop    %ecx
   1c13a:	58                   	pop    %eax
   1c13b:	e9 69 95 ff ff       	jmp    156a9 <trickles_send_impl+0x3b4>
   1c140:	50                   	push   %eax
   1c141:	51                   	push   %ecx
   1c142:	52                   	push   %edx
   1c143:	e8 fc ff ff ff       	call   1c144 <.text.lock.tmalloc+0x1d4>
   1c148:	5a                   	pop    %edx
   1c149:	59                   	pop    %ecx
   1c14a:	58                   	pop    %eax
   1c14b:	e9 56 96 ff ff       	jmp    157a6 <trickles_setucont_impl+0x82>
   1c150:	50                   	push   %eax
   1c151:	51                   	push   %ecx
   1c152:	52                   	push   %edx
   1c153:	e8 fc ff ff ff       	call   1c154 <.text.lock.tmalloc+0x1e4>
   1c158:	5a                   	pop    %edx
   1c159:	59                   	pop    %ecx
   1c15a:	58                   	pop    %eax
   1c15b:	e9 ce 96 ff ff       	jmp    1582e <trickles_setucont_impl+0x10a>
   1c160:	50                   	push   %eax
   1c161:	51                   	push   %ecx
   1c162:	52                   	push   %edx
   1c163:	e8 fc ff ff ff       	call   1c164 <.text.lock.tmalloc+0x1f4>
   1c168:	5a                   	pop    %edx
   1c169:	59                   	pop    %ecx
   1c16a:	58                   	pop    %eax
   1c16b:	e9 6e 98 ff ff       	jmp    159de <trickles_setucont_impl+0x2ba>
   1c170:	50                   	push   %eax
   1c171:	51                   	push   %ecx
   1c172:	52                   	push   %edx
   1c173:	e8 fc ff ff ff       	call   1c174 <.text.lock.tmalloc+0x204>
   1c178:	5a                   	pop    %edx
   1c179:	59                   	pop    %ecx
   1c17a:	58                   	pop    %eax
   1c17b:	e9 ff 98 ff ff       	jmp    15a7f <trickles_setucont_impl+0x35b>
   1c180:	50                   	push   %eax
   1c181:	51                   	push   %ecx
   1c182:	52                   	push   %edx
   1c183:	e8 fc ff ff ff       	call   1c184 <.text.lock.tmalloc+0x214>
   1c188:	5a                   	pop    %edx
   1c189:	59                   	pop    %ecx
   1c18a:	58                   	pop    %eax
   1c18b:	e9 a1 99 ff ff       	jmp    15b31 <trickles_setucont_impl+0x40d>
   1c190:	50                   	push   %eax
   1c191:	51                   	push   %ecx
   1c192:	52                   	push   %edx
   1c193:	e8 fc ff ff ff       	call   1c194 <.text.lock.tmalloc+0x224>
   1c198:	5a                   	pop    %edx
   1c199:	59                   	pop    %ecx
   1c19a:	58                   	pop    %eax
   1c19b:	e9 3a 9a ff ff       	jmp    15bda <trickles_setucont_impl+0x4b6>
   1c1a0:	50                   	push   %eax
   1c1a1:	51                   	push   %ecx
   1c1a2:	52                   	push   %edx
   1c1a3:	e8 fc ff ff ff       	call   1c1a4 <.text.lock.tmalloc+0x234>
   1c1a8:	5a                   	pop    %edx
   1c1a9:	59                   	pop    %ecx
   1c1aa:	58                   	pop    %eax
   1c1ab:	e9 f7 9a ff ff       	jmp    15ca7 <trickles_setucont_impl+0x583>
   1c1b0:	50                   	push   %eax
   1c1b1:	51                   	push   %ecx
   1c1b2:	52                   	push   %edx
   1c1b3:	e8 fc ff ff ff       	call   1c1b4 <.text.lock.tmalloc+0x244>
   1c1b8:	5a                   	pop    %edx
   1c1b9:	59                   	pop    %ecx
   1c1ba:	58                   	pop    %eax
   1c1bb:	e9 ff 9c ff ff       	jmp    15ebf <wait_for_write_memory+0x1c9>
   1c1c0:	50                   	push   %eax
   1c1c1:	51                   	push   %ecx
   1c1c2:	52                   	push   %edx
   1c1c3:	e8 fc ff ff ff       	call   1c1c4 <.text.lock.tmalloc+0x254>
   1c1c8:	5a                   	pop    %edx
   1c1c9:	59                   	pop    %ecx
   1c1ca:	58                   	pop    %eax
   1c1cb:	e9 53 9d ff ff       	jmp    15f23 <wait_for_write_memory+0x22d>
   1c1d0:	50                   	push   %eax
   1c1d1:	51                   	push   %ecx
   1c1d2:	52                   	push   %edx
   1c1d3:	e8 fc ff ff ff       	call   1c1d4 <.text.lock.tmalloc+0x264>
   1c1d8:	5a                   	pop    %edx
   1c1d9:	59                   	pop    %ecx
   1c1da:	58                   	pop    %eax
   1c1db:	e9 8d 9e ff ff       	jmp    1606d <trickles_client_sendmsg+0xb7>
   1c1e0:	50                   	push   %eax
   1c1e1:	51                   	push   %ecx
   1c1e2:	52                   	push   %edx
   1c1e3:	e8 fc ff ff ff       	call   1c1e4 <.text.lock.tmalloc+0x274>
   1c1e8:	5a                   	pop    %edx
   1c1e9:	59                   	pop    %ecx
   1c1ea:	58                   	pop    %eax
   1c1eb:	e9 0b a2 ff ff       	jmp    163fb <trickles_client_sendmsg+0x445>
   1c1f0:	50                   	push   %eax
   1c1f1:	51                   	push   %ecx
   1c1f2:	52                   	push   %edx
   1c1f3:	e8 fc ff ff ff       	call   1c1f4 <.text.lock.tmalloc+0x284>
   1c1f8:	5a                   	pop    %edx
   1c1f9:	59                   	pop    %ecx
   1c1fa:	58                   	pop    %eax
   1c1fb:	e9 7a a2 ff ff       	jmp    1647a <trickles_client_sendmsg+0x4c4>
   1c200:	50                   	push   %eax
   1c201:	51                   	push   %ecx
   1c202:	52                   	push   %edx
   1c203:	e8 fc ff ff ff       	call   1c204 <.text.lock.tmalloc+0x294>
   1c208:	5a                   	pop    %edx
   1c209:	59                   	pop    %ecx
   1c20a:	58                   	pop    %eax
   1c20b:	e9 dd a4 ff ff       	jmp    166ed <tcp_data_wait+0xe3>
   1c210:	50                   	push   %eax
   1c211:	51                   	push   %ecx
   1c212:	52                   	push   %edx
   1c213:	e8 fc ff ff ff       	call   1c214 <.text.lock.tmalloc+0x2a4>
   1c218:	5a                   	pop    %edx
   1c219:	59                   	pop    %ecx
   1c21a:	58                   	pop    %eax
   1c21b:	e9 2c a5 ff ff       	jmp    1674c <tcp_data_wait+0x142>
   1c220:	50                   	push   %eax
   1c221:	51                   	push   %ecx
   1c222:	52                   	push   %edx
   1c223:	e8 fc ff ff ff       	call   1c224 <.text.lock.tmalloc+0x2b4>
   1c228:	5a                   	pop    %edx
   1c229:	59                   	pop    %ecx
   1c22a:	58                   	pop    %eax
   1c22b:	e9 b0 a5 ff ff       	jmp    167e0 <trickles_client_recvmsg+0x5a>
   1c230:	50                   	push   %eax
   1c231:	51                   	push   %ecx
   1c232:	52                   	push   %edx
   1c233:	e8 fc ff ff ff       	call   1c234 <.text.lock.tmalloc+0x2c4>
   1c238:	5a                   	pop    %edx
   1c239:	59                   	pop    %ecx
   1c23a:	58                   	pop    %eax
   1c23b:	e9 45 a6 ff ff       	jmp    16885 <trickles_client_recvmsg+0xff>
   1c240:	50                   	push   %eax
   1c241:	51                   	push   %ecx
   1c242:	52                   	push   %edx
   1c243:	e8 fc ff ff ff       	call   1c244 <.text.lock.tmalloc+0x2d4>
   1c248:	5a                   	pop    %edx
   1c249:	59                   	pop    %ecx
   1c24a:	58                   	pop    %eax
   1c24b:	e9 c7 a8 ff ff       	jmp    16b17 <trickles_client_recvmsg+0x391>
   1c250:	50                   	push   %eax
   1c251:	51                   	push   %ecx
   1c252:	52                   	push   %edx
   1c253:	e8 fc ff ff ff       	call   1c254 <.text.lock.tmalloc+0x2e4>
   1c258:	5a                   	pop    %edx
   1c259:	59                   	pop    %ecx
   1c25a:	58                   	pop    %eax
   1c25b:	e9 d4 a9 ff ff       	jmp    16c34 <trickles_sendbulk_impl+0x112>
   1c260:	50                   	push   %eax
   1c261:	51                   	push   %ecx
   1c262:	52                   	push   %edx
   1c263:	e8 fc ff ff ff       	call   1c264 <.text.lock.tmalloc+0x2f4>
   1c268:	5a                   	pop    %edx
   1c269:	59                   	pop    %ecx
   1c26a:	58                   	pop    %eax
   1c26b:	e9 33 ac ff ff       	jmp    16ea3 <trickles_sendbulk_impl+0x381>
   1c270:	50                   	push   %eax
   1c271:	51                   	push   %ecx
   1c272:	52                   	push   %edx
   1c273:	e8 fc ff ff ff       	call   1c274 <.text.lock.tmalloc+0x304>
   1c278:	5a                   	pop    %edx
   1c279:	59                   	pop    %ecx
   1c27a:	58                   	pop    %eax
   1c27b:	e9 46 b1 ff ff       	jmp    173c6 <trickles_read_proc+0x508>
   1c280:	50                   	push   %eax
   1c281:	51                   	push   %ecx
   1c282:	52                   	push   %edx
   1c283:	e8 fc ff ff ff       	call   1c284 <.text.lock.tmalloc+0x314>
   1c288:	5a                   	pop    %edx
   1c289:	59                   	pop    %ecx
   1c28a:	58                   	pop    %eax
   1c28b:	e9 72 b5 ff ff       	jmp    17802 <trickles_cwnd_read_proc+0x388>
   1c290:	50                   	push   %eax
   1c291:	51                   	push   %ecx
   1c292:	52                   	push   %edx
   1c293:	e8 fc ff ff ff       	call   1c294 <.text.lock.tmalloc+0x324>
   1c298:	5a                   	pop    %edx
   1c299:	59                   	pop    %ecx
   1c29a:	58                   	pop    %eax
   1c29b:	e9 94 c7 ff ff       	jmp    18a34 <trickles_extract_events_impl+0x97>
   1c2a0:	50                   	push   %eax
   1c2a1:	51                   	push   %ecx
   1c2a2:	52                   	push   %edx
   1c2a3:	e8 fc ff ff ff       	call   1c2a4 <.text.lock.tmalloc+0x334>
   1c2a8:	5a                   	pop    %edx
   1c2a9:	59                   	pop    %ecx
   1c2aa:	58                   	pop    %eax
   1c2ab:	e9 41 d0 ff ff       	jmp    192f1 <trickles_extract_events_impl+0x954>
   1c2b0:	50                   	push   %eax
   1c2b1:	51                   	push   %ecx
   1c2b2:	52                   	push   %edx
   1c2b3:	e8 fc ff ff ff       	call   1c2b4 <.text.lock.tmalloc+0x344>
   1c2b8:	5a                   	pop    %edx
   1c2b9:	59                   	pop    %ecx
   1c2ba:	58                   	pop    %eax
   1c2bb:	e9 27 d1 ff ff       	jmp    193e7 <trickles_install_events_impl+0xa9>
   1c2c0:	50                   	push   %eax
   1c2c1:	51                   	push   %ecx
   1c2c2:	52                   	push   %edx
   1c2c3:	e8 fc ff ff ff       	call   1c2c4 <.text.lock.tmalloc+0x354>
   1c2c8:	5a                   	pop    %edx
   1c2c9:	59                   	pop    %ecx
   1c2ca:	58                   	pop    %eax
   1c2cb:	e9 66 d7 ff ff       	jmp    19a36 <trickles_install_events_impl+0x6f8>
   1c2d0:	50                   	push   %eax
   1c2d1:	51                   	push   %ecx
   1c2d2:	52                   	push   %edx
   1c2d3:	e8 fc ff ff ff       	call   1c2d4 <.text.lock.tmalloc+0x364>
   1c2d8:	5a                   	pop    %edx
   1c2d9:	59                   	pop    %ecx
   1c2da:	58                   	pop    %eax
   1c2db:	e9 d7 e4 ff ff       	jmp    1a7b7 <sock_orphan+0x4b>

0001c2e0 <record_transfer_skb>:

/**
 *	skb_unlink	-	remove a buffer from a list
 *	@skb: buffer to remove
 *
 *	Place a packet after a given packet in a list. The list locks are taken
 *	and this function is atomic with respect to other list locked calls
 *	
 *	Works even without knowing the list it is sitting on, which can be 
 *	handy at times. It also means that THE LIST MUST EXIST when you 
 *	unlink. Thus a list must have its contents unlinked before it is
 *	destroyed.
 */

static inline void skb_unlink(struct sk_buff *skb)
{
	struct sk_buff_head *list = skb->list;

	if(list) {
		unsigned long flags;

		spin_lock_irqsave(&list->lock, flags);
		if(skb->list == list)
			__skb_unlink(skb, skb->list);
		spin_unlock_irqrestore(&list->lock, flags);
	}
}

/* XXX: more streamlined implementation */

/**
 *	__skb_dequeue_tail - remove from the tail of the queue
 *	@list: list to dequeue from
 *
 *	Remove the tail of the list. This function does not take any locks
 *	so must be used with appropriate locks held only. The tail item is
 *	returned or %NULL if the list is empty.
 */

static inline struct sk_buff *__skb_dequeue_tail(struct sk_buff_head *list)
{
	struct sk_buff *skb = skb_peek_tail(list); 
	if (skb)
		__skb_unlink(skb, list);
	return skb;
}

/**
 *	skb_dequeue - remove from the head of the queue
 *	@list: list to dequeue from
 *
 *	Remove the head of the list. The list lock is taken so the function
 *	may be used safely with other locking list functions. The tail item is
 *	returned or %NULL if the list is empty.
 */

static inline struct sk_buff *skb_dequeue_tail(struct sk_buff_head *list)
{
	unsigned long flags;
	struct sk_buff *result;

	spin_lock_irqsave(&list->lock, flags);
	result = __skb_dequeue_tail(list);
	spin_unlock_irqrestore(&list->lock, flags);
	return result;
}

static inline int skb_is_nonlinear(const struct sk_buff *skb)
{
	return skb->data_len;
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
	return skb->len - skb->data_len;
}

#define SKB_PAGE_ASSERT(skb) do { if (skb_shinfo(skb)->nr_frags) out_of_line_bug(); } while (0)
#define SKB_FRAG_ASSERT(skb) do { if (skb_shinfo(skb)->frag_list) out_of_line_bug(); } while (0)
#define SKB_LINEAR_ASSERT(skb) do { if (skb_is_nonlinear(skb)) out_of_line_bug(); } while (0)

/*
 *	Add data to an sk_buff
 */
 
static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	return tmp;
}

/**
 *	skb_put - add data to a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer. If this would
 *	exceed the total buffer size the kernel will panic. A pointer to the
 *	first byte of the extra data is returned.
 */
 
static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp=skb->tail;
	SKB_LINEAR_ASSERT(skb);
	skb->tail+=len;
	skb->len+=len;
	if(skb->tail>skb->end) {
		skb_over_panic(skb, len, current_text_addr());
	}
	return tmp;
}

static inline unsigned char *__skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
	skb->len+=len;
	return skb->data;
}

/**
 *	skb_push - add data to the start of a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer at the buffer
 *	start. If this would exceed the total buffer headroom the kernel will
 *	panic. A pointer to the first byte of the extra data is returned.
 */

static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data-=len;
	skb->len+=len;
	if(skb->data<skb->head) {
		skb_under_panic(skb, len, current_text_addr());
	}
	return skb->data;
}

static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
	skb->len-=len;
	if (skb->len < skb->data_len)
		out_of_line_bug();
	return 	skb->data+=len;
}

/**
 *	skb_pull - remove data from the start of a buffer
 *	@skb: buffer to use 
 *	@len: amount of data to remove
 *
 *	This function removes data from the start of a buffer, returning
 *	the memory to the headroom. A pointer to the next data in the buffer
 *	is returned. Once the data has been pulled future pushes will overwrite
 *	the old data.
 */

static inline unsigned char * skb_pull(struct sk_buff *skb, unsigned int len)
{	
	if (len > skb->len)
		return NULL;
	return __skb_pull(skb,len);
}

extern unsigned char * __pskb_pull_tail(struct sk_buff *skb, int delta);

static inline char *__pskb_pull(struct sk_buff *skb, unsigned int len)
{
	if (len > skb_headlen(skb) &&
	    __pskb_pull_tail(skb, len-skb_headlen(skb)) == NULL)
		return NULL;
	skb->len -= len;
	return 	skb->data += len;
}

static inline unsigned char * pskb_pull(struct sk_buff *skb, unsigned int len)
{	
	if (len > skb->len)
		return NULL;
	return __pskb_pull(skb,len);
}

static inline int pskb_may_pull(struct sk_buff *skb, unsigned int len)
{
	if (len <= skb_headlen(skb))
		return 1;
	if (len > skb->len)
		return 0;
	return (__pskb_pull_tail(skb, len-skb_headlen(skb)) != NULL);
}

/**
 *	skb_headroom - bytes at buffer head
 *	@skb: buffer to check
 *
 *	Return the number of bytes of free space at the head of an &sk_buff.
 */
 
static inline int skb_headroom(const struct sk_buff *skb)
{
	return skb->data-skb->head;
}

/**
 *	skb_tailroom - bytes at buffer end
 *	@skb: buffer to check
 *
 *	Return the number of bytes of free space at the tail of an sk_buff
 */

static inline int skb_tailroom(const struct sk_buff *skb)
{
	return skb_is_nonlinear(skb) ? 0 : skb->end-skb->tail;
}

/**
 *	skb_reserve - adjust headroom
 *	@skb: buffer to alter
 *	@len: bytes to move
 *
 *	Increase the headroom of an empty &sk_buff by reducing the tail
 *	room. This is only allowed for an empty buffer.
 */

static inline void skb_reserve(struct sk_buff *skb, unsigned int len)
{
	skb->data+=len;
	skb->tail+=len;
}

extern int ___pskb_trim(struct sk_buff *skb, unsigned int len, int realloc);

static inline void __skb_trim(struct sk_buff *skb, unsigned int len)
{
	if (!skb->data_len) {
		skb->len = len;
		skb->tail = skb->data+len;
	} else {
		___pskb_trim(skb, len, 0);
	}
}

/**
 *	skb_trim - remove end from a buffer
 *	@skb: buffer to alter
 *	@len: new length
 *
 *	Cut the length of a buffer down by removing data from the tail. If
 *	the buffer is already under the length specified it is not modified.
 */

static inline void skb_trim(struct sk_buff *skb, unsigned int len)
{
	if (skb->len > len) {
		__skb_trim(skb, len);
	}
}


static inline int __pskb_trim(struct sk_buff *skb, unsigned int len)
{
	if (!skb->data_len) {
		skb->len = len;
		skb->tail = skb->data+len;
		return 0;
	} else {
		return ___pskb_trim(skb, len, 1);
	}
}

static inline int pskb_trim(struct sk_buff *skb, unsigned int len)
{
	if (len < skb->len)
		return __pskb_trim(skb, len);
	return 0;
}

/**
 *	skb_orphan - orphan a buffer
 *	@skb: buffer to orphan
 *
 *	If a buffer currently has an owner then we call the owner's
 *	destructor function and make the @skb unowned. The buffer continues
 *	to exist but is no longer charged to its former owner.
 */


static inline void skb_orphan(struct sk_buff *skb)
{
	if (skb->destructor)
		skb->destructor(skb);
	skb->destructor = NULL;
	skb->sk = NULL;
}

/**
 *	skb_purge - empty a list
 *	@list: list to empty
 *
 *	Delete all buffers on an &sk_buff list. Each buffer is removed from
 *	the list and one reference dropped. This function takes the list
 *	lock and is atomic with respect to other list locking functions.
 */


static inline void skb_queue_purge(struct sk_buff_head *list)
{
	struct sk_buff *skb;
	while ((skb=skb_dequeue(list))!=NULL)
		kfree_skb(skb);
}

/**
 *	__skb_purge - empty a list
 *	@list: list to empty
 *
 *	Delete all buffers on an &sk_buff list. Each buffer is removed from
 *	the list and one reference dropped. This function does not take the
 *	list lock and the caller must hold the relevant locks to use it.
 */


static inline void __skb_queue_purge(struct sk_buff_head *list)
{
	struct sk_buff *skb;
	while ((skb=__skb_dequeue(list))!=NULL)
		kfree_skb(skb);
}

/**
 *	__dev_alloc_skb - allocate an skbuff for sending
 *	@length: length to allocate
 *	@gfp_mask: get_free_pages mask, passed to alloc_skb
 *
 *	Allocate a new &sk_buff and assign it a usage count of one. The
 *	buffer has unspecified headroom built in. Users should allocate
 *	the headroom they think they need without accounting for the
 *	built in space. The built in space is used for optimisations.
 *
 *	%NULL is returned in there is no free memory.
 */
 
static inline struct sk_buff *__dev_alloc_skb(unsigned int length,
					      int gfp_mask)
{
	struct sk_buff *skb;

	skb = alloc_skb(length+16, gfp_mask);
	if (skb) {
		record_transfer_skb(skb, RECORD_DEV_SKB);
		skb_reserve(skb,16);
	}
	return skb;
}

/**
 *	dev_alloc_skb - allocate an skbuff for sending
 *	@length: length to allocate
 *
 *	Allocate a new &sk_buff and assign it a usage count of one. The
 *	buffer has unspecified headroom built in. Users should allocate
 *	the headroom they think they need without accounting for the
 *	built in space. The built in space is used for optimisations.
 *
 *	%NULL is returned in there is no free memory. Although this function
 *	allocates memory it can be called from an interrupt.
 */
 
static inline struct sk_buff *dev_alloc_skb(unsigned int length)
{
	return __dev_alloc_skb(length, GFP_ATOMIC);
}

/**
 *	skb_cow - copy header of skb when it is required
 *	@skb: buffer to cow
 *	@headroom: needed headroom
 *
 *	If the skb passed lacks sufficient headroom or its data part
 *	is shared, data is reallocated. If reallocation fails, an error
 *	is returned and original skb is not changed.
 *
 *	The result is skb with writable area skb->head...skb->tail
 *	and at least @headroom of space at head.
 */

static inline int
skb_cow(struct sk_buff *skb, unsigned int headroom)
{
	int delta = (headroom > 16 ? headroom : 16) - skb_headroom(skb);

	if (delta < 0)
		delta = 0;

	if (delta || skb_cloned(skb))
		return pskb_expand_head(skb, (delta+15)&~15, 0, GFP_ATOMIC);
	return 0;
}

/**
 *	skb_padto	- pad an skbuff up to a minimal size
 *	@skb: buffer to pad
 *	@len: minimal length
 *
 *	Pads up a buffer to ensure the trailing bytes exist and are
 *	blanked. If the buffer already contains sufficient data it
 *	is untouched. Returns the buffer, which may be a replacement
 *	for the original, or NULL for out of memory - in which case
 *	the original buffer is still freed.
 */
 
static inline struct sk_buff *skb_padto(struct sk_buff *skb, unsigned int len)
{
	unsigned int size = skb->len;
	if(likely(size >= len))
		return skb;
	return skb_pad(skb, len-size);
}

/**
 *	skb_linearize - convert paged skb to linear one
 *	@skb: buffer to linarize
 *	@gfp: allocation mode
 *
 *	If there is no free memory -ENOMEM is returned, otherwise zero
 *	is returned and the old skb data released.  */
int skb_linearize(struct sk_buff *skb, int gfp);

static inline void *kmap_skb_frag(const skb_frag_t *frag)
{
#ifdef CONFIG_HIGHMEM
	if (in_irq())
		out_of_line_bug();

	local_bh_disable();
#endif
	return kmap_atomic(frag->page, KM_SKB_DATA_SOFTIRQ);
}

static inline void kunmap_skb_frag(void *vaddr)
{
	kunmap_atomic(vaddr, KM_SKB_DATA_SOFTIRQ);
#ifdef CONFIG_HIGHMEM
	local_bh_enable();
#endif
}

#define skb_queue_walk(queue, skb) \
		for (skb = (queue)->next;			\
		     (skb != (struct sk_buff *)(queue));	\
		     skb=skb->next)


extern struct sk_buff *		skb_recv_datagram(struct sock *sk,unsigned flags,int noblock, int *err);
extern unsigned int		datagram_poll(struct file *file, struct socket *sock, struct poll_table_struct *wait);
extern int			skb_copy_datagram(const struct sk_buff *from, int offset, char *to,int size);
extern int			skb_copy_datagram_iovec(const struct sk_buff *from, int offset, struct iovec *to,int size);
extern int			skb_copy_and_csum_datagram(const struct sk_buff *skb, int offset, u8 *to, int len, unsigned int *csump);
extern int			skb_copy_and_csum_datagram_iovec(const struct sk_buff *skb, int hlen, struct iovec *iov);
extern void			skb_free_datagram(struct sock * sk, struct sk_buff *skb);

extern unsigned int		skb_checksum(const struct sk_buff *skb, int offset, int len, unsigned int csum);
extern int			skb_copy_bits(const struct sk_buff *skb, int offset, void *to, int len);
extern unsigned int		skb_copy_and_csum_bits(const struct sk_buff *skb, int offset, u8 *to, int len, unsigned int csum);
extern void			skb_copy_and_csum_dev(const struct sk_buff *skb, u8 *to);

extern void skb_init(void);
extern void skb_add_mtu(int mtu);

#ifdef CONFIG_NETFILTER
static inline void
nf_conntrack_put(struct nf_ct_info *nfct)
{
	if (nfct && atomic_dec_and_test(&nfct->master->use))
		nfct->master->destroy(nfct->master);
}
static inline void
nf_conntrack_get(struct nf_ct_info *nfct)
{
	if (nfct)
		atomic_inc(&nfct->master->use);
}
#endif

extern atomic_t g_device_skb;
extern atomic_t g_device_skb_num;
extern atomic_t g_other_skb;
extern atomic_t g_other_skb_num;

#ifdef RECORD_SKB
static inline 
atomic_t *record_skb_type_to_counter(int type, atomic_t **counter2) {
	atomic_t *counter;
	if(type == RECORD_DEV_SKB) {
		counter = &g_device_skb;
		*counter2 = &g_device_skb_num;
	} else {
		if(type != RECORD_OTHER_SKB) {
			BUG();
		}
		counter = &g_other_skb;
		*counter2 = &g_other_skb_num;
	}
	return counter;
}

static inline
void record_new_skb(struct sk_buff *skb, int type, int include_body) {
	atomic_t *num_counter, *counter = record_skb_type_to_counter(type, &num_counter);
	atomic_add(sizeof(*skb), counter);
	atomic_inc(num_counter);
	if(include_body) {
		int addlen = skb->end - skb->head;
		atomic_add(addlen, counter);
	}
	skb->alloc_pool = type;
}

static inline 
void record_free_skb_body(struct sk_buff *skb) {
	atomic_t *ignored, *counter = record_skb_type_to_counter(skb->alloc_pool, &ignored);
	atomic_sub(skb->end - skb->head, counter);
}

static inline 
void record_free_skb_head(struct sk_buff *skb) {
	atomic_t *num_counter, *counter = record_skb_type_to_counter(skb->alloc_pool, &num_counter);
	atomic_sub(sizeof(*skb), counter);
	atomic_dec(num_counter);
}

static inline 
void record_transfer_skb(struct sk_buff *skb, int newType) {
	// XXX Transfer does not work properly for cloned skbs
	record_free_skb_head(skb);
	record_free_skb_body(skb);
	record_new_skb(skb, newType, 1);
}
#else
static inline
void record_new_skb(struct sk_buff *skb, int type, int include_body) {
}

static inline 
void record_free_skb_body(struct sk_buff *skb) {
}

static inline 
void record_free_skb_head(struct sk_buff *skb) {
}
   1c2e0:	55                   	push   %ebp
   1c2e1:	89 e5                	mov    %esp,%ebp

   1c2e3:	5d                   	pop    %ebp
   1c2e4:	c3                   	ret    

0001c2e5 <free_trickles_msk>:
		rval->input = NULL;
	}
	if(rval->ucont_data)
		memcpy(rval->ucont_data,msk->ucont_data,rval->ucont_len);
	if(rval->input)
   1c2e5:	55                   	push   %ebp
   1c2e6:	89 e5                	mov    %esp,%ebp
   1c2e8:	83 ec 08             	sub    $0x8,%esp
		memcpy(rval->input,msk->input,rval->input_len);
   1c2eb:	8b 45 08             	mov    0x8(%ebp),%eax
   1c2ee:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   1c2f4:	83 e0 01             	and    $0x1,%eax
   1c2f7:	85 c0                	test   %eax,%eax
   1c2f9:	74 1b                	je     1c316 <free_trickles_msk+0x31>
   1c2fb:	8b 55 08             	mov    0x8(%ebp),%edx
   1c2fe:	8b 45 08             	mov    0x8(%ebp),%eax
   1c301:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   1c307:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
   1c30d:	83 e0 08             	and    $0x8,%eax
   1c310:	85 c0                	test   %eax,%eax
   1c312:	75 02                	jne    1c316 <free_trickles_msk+0x31>
   1c314:	eb 6b                	jmp    1c381 <free_trickles_msk+0x9c>

   1c316:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c319:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
   1c31d:	74 0b                	je     1c32a <free_trickles_msk+0x45>
   1c31f:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c322:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
   1c326:	74 02                	je     1c32a <free_trickles_msk+0x45>
   1c328:	eb 31                	jmp    1c35b <free_trickles_msk+0x76>
	rval->executionTrace |= 0x80;
   1c32a:	c7 04 24 ec 72 00 00 	movl   $0x72ec,(%esp,1)
   1c331:	e8 fc ff ff ff       	call   1c332 <free_trickles_msk+0x4d>
	return rval;
   1c336:	c7 44 24 04 f9 72 00 	movl   $0x72f9,0x4(%esp,1)
   1c33d:	00 
   1c33e:	c7 04 24 fd 72 00 00 	movl   $0x72fd,(%esp,1)
   1c345:	e8 fc ff ff ff       	call   1c346 <free_trickles_msk+0x61>
   1c34a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1c351:	e8 fc ff ff ff       	call   1c352 <free_trickles_msk+0x6d>
   1c356:	e8 fc ff ff ff       	call   1c357 <free_trickles_msk+0x72>
}
#endif // CAN_USE_TFREE
   1c35b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c35e:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
   1c362:	75 13                	jne    1c377 <free_trickles_msk+0x92>
   1c364:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c367:	83 38 00             	cmpl   $0x0,(%eax)
   1c36a:	74 0b                	je     1c377 <free_trickles_msk+0x92>

   1c36c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c36f:	89 04 24             	mov    %eax,(%esp,1)
   1c372:	e8 85 0a 00 00       	call   1cdfc <unlink>
/* Two phase free: first phase disconnects socket from event list,
   sets to ALLOC_PROCESSING; second phase adds the socket to free
   1c377:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c37a:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
   list, sets to ALLOC_FREE and ready for reuse */
#ifndef USERTEST
   1c381:	c9                   	leave  
   1c382:	c3                   	ret    

0001c383 <free_trickles_msk_finish>:
static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk) {
	if(!SIMULATION_MODE(sk)) {
		if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) {
			printk("double free\n");
			BUG();
		}
		if(msk->ctl == ALLOC_READY && msk->prev != NULL) {
			unlink((struct alloc_head *)msk);
		}
		msk->ctl = ALLOC_PROCESSING;
	}
}

static inline void msk_release(struct sock *sk, struct cminisock *msk) {
	// Perform actual deallocation. This function is common to
	// state cache and event queue
	msk->refCnt--;
	BUG_TRAP(msk->refCnt >= 0);
	if(msk->refCnt == 0) {
		// printk("release: refcnt %p\n", msk);
		struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
		struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
   1c383:	55                   	push   %ebp
   1c384:	89 e5                	mov    %esp,%ebp
   1c386:	83 ec 08             	sub    $0x8,%esp

   1c389:	8b 45 08             	mov    0x8(%ebp),%eax
   1c38c:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   1c392:	83 e0 01             	and    $0x1,%eax
   1c395:	85 c0                	test   %eax,%eax
   1c397:	74 1b                	je     1c3b4 <free_trickles_msk_finish+0x31>
   1c399:	8b 55 08             	mov    0x8(%ebp),%edx
   1c39c:	8b 45 08             	mov    0x8(%ebp),%eax
   1c39f:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   1c3a5:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
   1c3ab:	83 e0 08             	and    $0x8,%eax
   1c3ae:	85 c0                	test   %eax,%eax
   1c3b0:	75 02                	jne    1c3b4 <free_trickles_msk_finish+0x31>
   1c3b2:	eb 4d                	jmp    1c401 <free_trickles_msk_finish+0x7e>
		free_minisock(sk,msk);
   1c3b4:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c3b7:	83 78 0c 03          	cmpl   $0x3,0xc(%eax)
   1c3bb:	74 44                	je     1c401 <free_trickles_msk_finish+0x7e>
   1c3bd:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c3c0:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
   1c3c4:	74 3b                	je     1c401 <free_trickles_msk_finish+0x7e>
		if(!SIMULATION_MODE(sk)) {
   1c3c6:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c3c9:	8b 40 0c             	mov    0xc(%eax),%eax
   1c3cc:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1c3d0:	c7 04 24 20 73 00 00 	movl   $0x7320,(%esp,1)
   1c3d7:	e8 fc ff ff ff       	call   1c3d8 <free_trickles_msk_finish+0x55>
			insert_head(head, (struct alloc_head *)msk);
   1c3dc:	c7 44 24 04 f9 72 00 	movl   $0x72f9,0x4(%esp,1)
   1c3e3:	00 
   1c3e4:	c7 04 24 fd 72 00 00 	movl   $0x72fd,(%esp,1)
   1c3eb:	e8 fc ff ff ff       	call   1c3ec <free_trickles_msk_finish+0x69>
   1c3f0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1c3f7:	e8 fc ff ff ff       	call   1c3f8 <free_trickles_msk_finish+0x75>
   1c3fc:	e8 fc ff ff ff       	call   1c3fd <free_trickles_msk_finish+0x7a>
			msk->ctl = ALLOC_FREE;
		} else {
			if(msk == tp->t.responseMSK) {
   1c401:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c404:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1c408:	8b 45 08             	mov    0x8(%ebp),%eax
   1c40b:	89 04 24             	mov    %eax,(%esp,1)
   1c40e:	e8 3d 0a 00 00       	call   1ce50 <msk_release>
			} else {
   1c413:	c9                   	leave  
   1c414:	c3                   	ret    

0001c415 <ParsedCMinisock_evictOne>:
}

void WireContinuation_insert(struct WireContinuation *wcont, const CONTINUATION_TYPE *scont) {
	CachedWireContinuationKey key = seqnoToKey(wcont->seq);
	struct Continuation_cell *cell = Continuation_insert_helper(&key);
   1c415:	55                   	push   %ebp
   1c416:	89 e5                	mov    %esp,%ebp
   1c418:	83 ec 20             	sub    $0x20,%esp
	if(cell != NULL) {
   1c41b:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
		WireContinuation_copyIn(&cell->elem, wcont, scont);
	}
   1c422:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1c425:	83 b8 10 50 00 00 00 	cmpl   $0x0,0x5010(%eax)
   1c42c:	7f 75                	jg     1c4a3 <ParsedCMinisock_evictOne+0x8e>
}
   1c42e:	c7 44 24 10 58 00 00 	movl   $0x58,0x10(%esp,1)
   1c435:	00 
   1c436:	c7 44 24 0c 73 73 00 	movl   $0x7373,0xc(%esp,1)
   1c43d:	00 
   1c43e:	c7 44 24 08 8c 73 00 	movl   $0x738c,0x8(%esp,1)
   1c445:	00 
   1c446:	c7 44 24 04 9a 73 00 	movl   $0x739a,0x4(%esp,1)
   1c44d:	00 
   1c44e:	c7 04 24 b3 73 00 00 	movl   $0x73b3,(%esp,1)
   1c455:	e8 fc ff ff ff       	call   1c456 <ParsedCMinisock_evictOne+0x41>

void dump_cache_stats(void) {
	PRINT_STATS(ParsedCMinisock);
   1c45a:	c7 44 24 0c 58 00 00 	movl   $0x58,0xc(%esp,1)
   1c461:	00 
   1c462:	c7 44 24 08 73 73 00 	movl   $0x7373,0x8(%esp,1)
   1c469:	00 
   1c46a:	c7 44 24 04 8c 73 00 	movl   $0x738c,0x4(%esp,1)
   1c471:	00 
   1c472:	c7 04 24 ce 73 00 00 	movl   $0x73ce,(%esp,1)
   1c479:	e8 fc ff ff ff       	call   1c47a <ParsedCMinisock_evictOne+0x65>
	PRINT_STATS(Continuation);
}

   1c47e:	c7 44 24 04 f9 72 00 	movl   $0x72f9,0x4(%esp,1)
   1c485:	00 
   1c486:	c7 04 24 fd 72 00 00 	movl   $0x72fd,(%esp,1)
   1c48d:	e8 fc ff ff ff       	call   1c48e <ParsedCMinisock_evictOne+0x79>
// USER LEVEL SELF-TEST
   1c492:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1c499:	e8 fc ff ff ff       	call   1c49a <ParsedCMinisock_evictOne+0x85>

   1c49e:	e8 fc ff ff ff       	call   1c49f <ParsedCMinisock_evictOne+0x8a>
#ifdef SELF_TEST
#ifdef PROTOCOL_TRACE_TEST

struct WireContinuationElement {
	struct alloc_head *prev;
	struct alloc_head *next;
	struct alloc_head_list *list;

	struct WireContinuation cont;

	// propagate ack proof to the next element
	int ackProof;
   1c4a3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1c4a6:	8b 80 04 50 00 00    	mov    0x5004(%eax),%eax
   1c4ac:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
	int left, right;
   1c4af:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1c4b2:	83 e8 0c             	sub    $0xc,%eax
   1c4b5:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
};
   1c4b8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1c4bb:	89 04 24             	mov    %eax,(%esp,1)
   1c4be:	e8 a6 0b 00 00       	call   1d069 <ParsedCMinisock_unlinkCell>

   1c4c3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1c4c6:	83 c0 28             	add    $0x28,%eax
   1c4c9:	89 04 24             	mov    %eax,(%esp,1)
   1c4cc:	e8 1c 0b 00 00       	call   1cfed <cminisock_evict>
#endif // PROTOCOL_TRACE_TEST
   1c4d1:	8b 55 08             	mov    0x8(%ebp),%edx
   1c4d4:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1c4d7:	89 02                	mov    %eax,(%edx)

   1c4d9:	c9                   	leave  
   1c4da:	c3                   	ret    

0001c4db <ParsedCMinisock_evict>:
void nonceFunc(__u64 seqno, char *output) {
   1c4db:	55                   	push   %ebp
   1c4dc:	89 e5                	mov    %esp,%ebp
   1c4de:	83 ec 10             	sub    $0x10,%esp
	// output is NONCE_BLOCKSIZE long
	(NONCE_BLOCKSIZE % sizeof(__u64) == 0)|| die();
   1c4e1:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
	for(i=0; i < NONCE_BLOCKSIZE)
   1c4e8:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
}
   1c4ef:	81 7d f8 f0 af ff ff 	cmpl   $0xffffaff0,0xfffffff8(%ebp)
   1c4f6:	74 34                	je     1c52c <ParsedCMinisock_evict+0x51>
   1c4f8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1c4fc:	7e 2e                	jle    1c52c <ParsedCMinisock_evict+0x51>
   1c4fe:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1c501:	83 b8 14 50 00 00 00 	cmpl   $0x0,0x5014(%eax)
   1c508:	7f 02                	jg     1c50c <ParsedCMinisock_evict+0x31>
   1c50a:	eb 20                	jmp    1c52c <ParsedCMinisock_evict+0x51>

__u32 generateNonce(__u64 seqno) {
   1c50c:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   1c50f:	89 04 24             	mov    %eax,(%esp,1)
   1c512:	e8 fe fe ff ff       	call   1c415 <ParsedCMinisock_evictOne>
	// generate nonce uses the nonce cache
   1c517:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1c51a:	89 04 24             	mov    %eax,(%esp,1)
   1c51d:	e8 fc ff ff ff       	call   1c51e <ParsedCMinisock_evict+0x43>

   1c522:	ff 4d 08             	decl   0x8(%ebp)
	// make sure that the cache returns the correct value
   1c525:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
   1c528:	ff 00                	incl   (%eax)
   1c52a:	eb c3                	jmp    1c4ef <ParsedCMinisock_evict+0x14>
	if(found) {
		if(value != nonceFunc(xxx)) {
			die();
   1c52c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
		}
   1c52f:	c9                   	leave  
   1c530:	c3                   	ret    

0001c531 <ParsedCMinisock_newCell>:
	}
   1c531:	55                   	push   %ebp
   1c532:	89 e5                	mov    %esp,%ebp
   1c534:	83 ec 18             	sub    $0x18,%esp
}
   1c537:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
   1c53e:	00 
   1c53f:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp,1)
   1c546:	e8 fc ff ff ff       	call   1c547 <ParsedCMinisock_newCell+0x16>
   1c54b:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

   1c54e:	83 05 28 50 00 00 2c 	addl   $0x2c,0x5028
// stress tests: manipulate the number of buckets and the number of elements

   1c555:	a1 2c 50 00 00       	mov    0x502c,%eax
   1c55a:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
int main() {
   1c55d:	a1 28 50 00 00       	mov    0x5028,%eax
   1c562:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	StateCache_init();

   1c565:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1c568:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1c56b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1c56e:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
   1c571:	7d 06                	jge    1c579 <ParsedCMinisock_newCell+0x48>
   1c573:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1c576:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1c579:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1c57c:	a3 2c 50 00 00       	mov    %eax,0x502c
	// base functionality test -- insertion, deletion
	int leak_count; // run the test multiple times to test for leaks
	for(leak_count = 0; leak_count < NUM_LEAK_LOOPS; leak_count++) {
   1c581:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
#define TESTVEC_LEN (32)
   1c584:	c9                   	leave  
   1c585:	c3                   	ret    

0001c586 <ParsedCMinisock_freeCell>:
		int testvec_key[TESTVEC_LEN] = {
   1c586:	55                   	push   %ebp
   1c587:	89 e5                	mov    %esp,%ebp
   1c589:	83 ec 04             	sub    $0x4,%esp
			1, 103, 1233, 2794, 5528, 4302, 8038, 8301, 4884, 1879, 5608, 8106, 6695, 4484, 4449, 1783, 6025, 2903, 7114, 7215, 9785, 7665, 5413, 6642, 7781, 1981, 2019, 6686, 8439, 5386, 3462, 3974
   1c58c:	83 2d 28 50 00 00 2c 	subl   $0x2c,0x5028
		};
   1c593:	8b 45 08             	mov    0x8(%ebp),%eax
   1c596:	89 04 24             	mov    %eax,(%esp,1)
   1c599:	e8 fc ff ff ff       	call   1c59a <ParsedCMinisock_freeCell+0x14>
		struct WireContinuation insertions[TESTVEC_LEN]; // int insertion tests
   1c59e:	c9                   	leave  
   1c59f:	c3                   	ret    

0001c5a0 <cminisock_lookup>:
   1c5a0:	55                   	push   %ebp
   1c5a1:	89 e5                	mov    %esp,%ebp
   1c5a3:	83 ec 18             	sub    $0x18,%esp
   1c5a6:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c5a9:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   1c5ac:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c5af:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1c5b3:	c7 04 24 e3 73 00 00 	movl   $0x73e3,(%esp,1)
   1c5ba:	e8 fc ff ff ff       	call   1c5bb <cminisock_lookup+0x1b>
   1c5bf:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
   1c5c2:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1c5c6:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
   1c5c9:	89 04 24             	mov    %eax,(%esp,1)
   1c5cc:	e8 e6 0c 00 00       	call   1d2b7 <ParsedCMinisock_find_helper>
   1c5d1:	85 c0                	test   %eax,%eax
   1c5d3:	74 3c                	je     1c611 <cminisock_lookup+0x71>
   1c5d5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1c5d8:	8b 40 28             	mov    0x28(%eax),%eax
   1c5db:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1c5de:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1c5e1:	83 b8 f0 00 00 00 01 	cmpl   $0x1,0xf0(%eax)
   1c5e8:	74 14                	je     1c5fe <cminisock_lookup+0x5e>
   1c5ea:	c7 44 24 04 74 00 00 	movl   $0x74,0x4(%esp,1)
   1c5f1:	00 
   1c5f2:	c7 04 24 00 74 00 00 	movl   $0x7400,(%esp,1)
   1c5f9:	e8 fc ff ff ff       	call   1c5fa <cminisock_lookup+0x5a>
   1c5fe:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1c601:	89 04 24             	mov    %eax,(%esp,1)
   1c604:	e8 35 0d 00 00       	call   1d33e <ParsedCMinisock_deleteCell>
   1c609:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1c60c:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1c60f:	eb 07                	jmp    1c618 <cminisock_lookup+0x78>
   1c611:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
   1c618:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1c61b:	c9                   	leave  
   1c61c:	c3                   	ret    

0001c61d <cminisock_insert>:
   1c61d:	55                   	push   %ebp
   1c61e:	89 e5                	mov    %esp,%ebp
   1c620:	83 ec 14             	sub    $0x14,%esp
   1c623:	8b 45 08             	mov    0x8(%ebp),%eax
   1c626:	83 b8 f0 00 00 00 00 	cmpl   $0x0,0xf0(%eax)
   1c62d:	7f 14                	jg     1c643 <cminisock_insert+0x26>
   1c62f:	c7 44 24 04 80 00 00 	movl   $0x80,0x4(%esp,1)
   1c636:	00 
   1c637:	c7 04 24 60 74 00 00 	movl   $0x7460,(%esp,1)
   1c63e:	e8 fc ff ff ff       	call   1c63f <cminisock_insert+0x22>
   1c643:	8b 45 08             	mov    0x8(%ebp),%eax
   1c646:	8b 40 30             	mov    0x30(%eax),%eax
   1c649:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   1c64c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1c64f:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1c653:	8b 45 08             	mov    0x8(%ebp),%eax
   1c656:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1c65a:	c7 04 24 a2 74 00 00 	movl   $0x74a2,(%esp,1)
   1c661:	e8 fc ff ff ff       	call   1c662 <cminisock_insert+0x45>
   1c666:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
   1c669:	89 04 24             	mov    %eax,(%esp,1)
   1c66c:	e8 12 0b 00 00       	call   1d183 <ParsedCMinisock_insert_helper>
   1c671:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   1c674:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
   1c678:	74 14                	je     1c68e <cminisock_insert+0x71>
   1c67a:	8b 45 08             	mov    0x8(%ebp),%eax
   1c67d:	89 04 24             	mov    %eax,(%esp,1)
   1c680:	e8 bd 07 00 00       	call   1ce42 <msk_hold>
   1c685:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   1c688:	8b 45 08             	mov    0x8(%ebp),%eax
   1c68b:	89 42 28             	mov    %eax,0x28(%edx)
   1c68e:	c9                   	leave  
   1c68f:	c3                   	ret    

0001c690 <Continuation_evictOne>:
 }
 ;
 return found;
 }
 static inline void Continuation_evictOne(struct Continuation_cell **cell) {
   1c690:	55                   	push   %ebp
   1c691:	89 e5                	mov    %esp,%ebp
   1c693:	83 ec 20             	sub    $0x20,%esp
 struct Continuation_cache_root *cache = &Continuation_cache;
   1c696:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
 do {
 if(!(cache->algorithm.len > 0)) {
   1c69d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1c6a0:	83 b8 10 50 00 00 00 	cmpl   $0x0,0x5010(%eax)
   1c6a7:	7f 75                	jg     1c71e <Continuation_evictOne+0x8e>
 printk("(%s) failed at %s:%s():%d\n", "cache->algorithm.len > 0", "state_cache.c", __PRETTY_FUNCTION__, 213);
   1c6a9:	c7 44 24 10 d5 00 00 	movl   $0xd5,0x10(%esp,1)
   1c6b0:	00 
   1c6b1:	c7 44 24 0c bc 74 00 	movl   $0x74bc,0xc(%esp,1)
   1c6b8:	00 
   1c6b9:	c7 44 24 08 8c 73 00 	movl   $0x738c,0x8(%esp,1)
   1c6c0:	00 
   1c6c1:	c7 44 24 04 9a 73 00 	movl   $0x739a,0x4(%esp,1)
   1c6c8:	00 
   1c6c9:	c7 04 24 b3 73 00 00 	movl   $0x73b3,(%esp,1)
   1c6d0:	e8 fc ff ff ff       	call   1c6d1 <Continuation_evictOne+0x41>
 ({
 do {
 printk("dying at %s:%s():%d\n", "state_cache.c", __PRETTY_FUNCTION__, 213);
   1c6d5:	c7 44 24 0c d5 00 00 	movl   $0xd5,0xc(%esp,1)
   1c6dc:	00 
   1c6dd:	c7 44 24 08 bc 74 00 	movl   $0x74bc,0x8(%esp,1)
   1c6e4:	00 
   1c6e5:	c7 44 24 04 8c 73 00 	movl   $0x738c,0x4(%esp,1)
   1c6ec:	00 
   1c6ed:	c7 04 24 ce 73 00 00 	movl   $0x73ce,(%esp,1)
   1c6f4:	e8 fc ff ff ff       	call   1c6f5 <Continuation_evictOne+0x65>
 do {
 if (!(0)) {
 printk("kgdb assertion failed: %s\n", "BUG");
   1c6f9:	c7 44 24 04 f9 72 00 	movl   $0x72f9,0x4(%esp,1)
   1c700:	00 
   1c701:	c7 04 24 fd 72 00 00 	movl   $0x72fd,(%esp,1)
   1c708:	e8 fc ff ff ff       	call   1c709 <Continuation_evictOne+0x79>
 show_stack(((void *)0));
   1c70d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1c714:	e8 fc ff ff ff       	call   1c715 <Continuation_evictOne+0x85>
 breakpoint();
   1c719:	e8 fc ff ff ff       	call   1c71a <Continuation_evictOne+0x8a>
 }
 }
 while (0);
 }
 while(0) ;
 1 ;
 }
);
 }
 }
 while(0);
 struct list_link *algorithm = (struct list_link *)cache->algorithm.next;
   1c71e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1c721:	8b 80 04 50 00 00    	mov    0x5004(%eax),%eax
   1c727:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
 struct Continuation_cell *cell0 = ((struct Continuation_cell*) (((char*) algorithm) - ((char*) &((struct Continuation_cell*)0)->algorithm)));
   1c72a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1c72d:	83 e8 0c             	sub    $0xc,%eax
   1c730:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
 Continuation_unlinkCell(cell0);
   1c733:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1c736:	89 04 24             	mov    %eax,(%esp,1)
   1c739:	e8 5e 0c 00 00       	call   1d39c <Continuation_unlinkCell>
 CachedWireContinuation_evict(&cell0->elem);
   1c73e:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1c741:	83 c0 28             	add    $0x28,%eax
   1c744:	89 04 24             	mov    %eax,(%esp,1)
   1c747:	e8 23 0c 00 00       	call   1d36f <CachedWireContinuation_evict>
 *cell = cell0;
   1c74c:	8b 55 08             	mov    0x8(%ebp),%edx
   1c74f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1c752:	89 02                	mov    %eax,(%edx)
 }
   1c754:	c9                   	leave  
   1c755:	c3                   	ret    

0001c756 <Continuation_evict>:
 static inline int Continuation_evict(int toEvict) {
   1c756:	55                   	push   %ebp
   1c757:	89 e5                	mov    %esp,%ebp
   1c759:	83 ec 10             	sub    $0x10,%esp
 ;
 int execCount = 0;
   1c75c:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
 struct Continuation_cache_root *cache = &Continuation_cache;
   1c763:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
 while((struct alloc_head *)&cache->algorithm.len > 0 && toEvict > 0 && cache->count > 0) {
   1c76a:	81 7d f8 f0 af ff ff 	cmpl   $0xffffaff0,0xfffffff8(%ebp)
   1c771:	74 34                	je     1c7a7 <Continuation_evict+0x51>
   1c773:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1c777:	7e 2e                	jle    1c7a7 <Continuation_evict+0x51>
   1c779:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1c77c:	83 b8 14 50 00 00 00 	cmpl   $0x0,0x5014(%eax)
   1c783:	7f 02                	jg     1c787 <Continuation_evict+0x31>
   1c785:	eb 20                	jmp    1c7a7 <Continuation_evict+0x51>
 struct Continuation_cell *cell;
 Continuation_evictOne(&cell);
   1c787:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   1c78a:	89 04 24             	mov    %eax,(%esp,1)
   1c78d:	e8 fe fe ff ff       	call   1c690 <Continuation_evictOne>
 kfree(cell);
   1c792:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1c795:	89 04 24             	mov    %eax,(%esp,1)
   1c798:	e8 fc ff ff ff       	call   1c799 <Continuation_evict+0x43>
 toEvict--;
   1c79d:	ff 4d 08             	decl   0x8(%ebp)
 execCount++;
   1c7a0:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
   1c7a3:	ff 00                	incl   (%eax)
   1c7a5:	eb c3                	jmp    1c76a <Continuation_evict+0x14>
 }
 ;
 return execCount;
   1c7a7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
 }
   1c7aa:	c9                   	leave  
   1c7ab:	c3                   	ret    

0001c7ac <Continuation_newCell>:
 static inline struct Continuation_cell *Continuation_newCell() {
   1c7ac:	55                   	push   %ebp
   1c7ad:	89 e5                	mov    %esp,%ebp
   1c7af:	83 ec 18             	sub    $0x18,%esp
 struct Continuation_cell *cell = kmalloc(sizeof(struct Continuation_cell), (0x20));
   1c7b2:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
   1c7b9:	00 
   1c7ba:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp,1)
   1c7c1:	e8 fc ff ff ff       	call   1c7c2 <Continuation_newCell+0x16>
   1c7c6:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
 Continuation_cache.cellMem += sizeof(*cell);
   1c7c9:	83 05 28 50 00 00 60 	addl   $0x60,0x5028
 Continuation_cache.maxCellMem = ({
 const typeof(Continuation_cache.maxCellMem) _x = (Continuation_cache.maxCellMem);
   1c7d0:	a1 2c 50 00 00       	mov    0x502c,%eax
   1c7d5:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
 const typeof(Continuation_cache.cellMem) _y = (Continuation_cache.cellMem);
   1c7d8:	a1 28 50 00 00       	mov    0x5028,%eax
   1c7dd:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
 (void) (&_x == &_y);
 _x > _y ? _x : _y;
   1c7e0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1c7e3:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1c7e6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1c7e9:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
   1c7ec:	7d 06                	jge    1c7f4 <Continuation_newCell+0x48>
   1c7ee:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1c7f1:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1c7f4:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1c7f7:	a3 2c 50 00 00       	mov    %eax,0x502c
 }
);
 return cell;
   1c7fc:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
 }
   1c7ff:	c9                   	leave  
   1c800:	c3                   	ret    

0001c801 <Continuation_freeCell>:
 static inline void Continuation_freeCell(struct Continuation_cell *cell) {
   1c801:	55                   	push   %ebp
   1c802:	89 e5                	mov    %esp,%ebp
   1c804:	83 ec 04             	sub    $0x4,%esp
 Continuation_cache.cellMem -= sizeof(*cell);
   1c807:	83 2d 28 50 00 00 60 	subl   $0x60,0x5028
 kfree(cell);
   1c80e:	8b 45 08             	mov    0x8(%ebp),%eax
   1c811:	89 04 24             	mov    %eax,(%esp,1)
   1c814:	e8 fc ff ff ff       	call   1c815 <Continuation_freeCell+0x14>
 }
   1c819:	c9                   	leave  
   1c81a:	c3                   	ret    

0001c81b <NonceKey_integrityCheck>:
;
# 16729 "state_cache_2.c"
struct NonceKey_cell {
 struct list_link lookup;
 struct list_link algorithm;
 struct list_link free;
 __u64 key;
 struct NonceMap elem;
 }
;
 struct NonceKey_bucket {
 struct alloc_head *prev;
 struct alloc_head *next;
 struct alloc_head_list *list;
 enum cminisock_ctl ignore;
 int len;
 }
;
 struct NonceKey_cache_root {
 struct NonceKey_bucket buckets[(32)];
 struct alloc_head_list algorithm;
 int count;
 int numBuckets;
 int maxCount;
 int hitCount;
 int total;
 int cellMem;
 int maxCellMem;
 struct alloc_head_list free_list;
 struct NonceKey_cell *cells;
 }
 NonceKey_cache;
 static inline struct NonceKey_cell *NonceKey_newCell(void);
 static inline int NonceKey_integrityCheck(void);
 static inline void NonceKey_unlinkCell(struct NonceKey_cell *cell);
 static inline void NonceKey_evictOne(struct NonceKey_cell **cell);
 static inline int NonceKey_evict(int toEvict);
 static inline void NonceKey_cache_init(void) {
 struct NonceKey_cache_root *cache = &NonceKey_cache;
 cache->count = 0;
 cache->numBuckets = (32);
 cache->maxCount = (100);
 cache->hitCount = 0;
 cache->total = 0;
 cache->cellMem = 0;
 cache->maxCellMem = 0;
 init_head((struct alloc_head_list*) &cache->algorithm);
 int i;
 for(i=0;
 i < cache->numBuckets;
 i++) {
 init_head((struct alloc_head_list*) &cache->buckets[i]);
 }
 init_head((struct alloc_head_list*) &cache->free_list);
 if((0) >= (2)) {
 NonceKey_integrityCheck() || ({
 do {
 printk("dying at %s:%s():%d\n", "state_cache.c", __PRETTY_FUNCTION__, 230);
 do {
 if (!(0)) {
 printk("kgdb assertion failed: %s\n", "BUG");
 show_stack(((void *)0));
 breakpoint();
 }
 }
 while (0);
 }
 while(0) ;
 1 ;
 }
);
 }
;
 }
 static inline void NonceKey_cache_destroy(void) {
 struct NonceKey_cache_root *cache = &NonceKey_cache;
 NonceKey_evict(cache->count);
 }
 static inline int NonceKey_getCount(void) {
 if((0) >= (2)) {
 NonceKey_integrityCheck() || ({
 do {
 printk("dying at %s:%s():%d\n", "state_cache.c", __PRETTY_FUNCTION__, 230);
 do {
 if (!(0)) {
 printk("kgdb assertion failed: %s\n", "BUG");
 show_stack(((void *)0));
 breakpoint();
 }
 }
 while (0);
 }
 while(0) ;
 1 ;
 }
);
 }
;
 return NonceKey_cache.count;
 }
 static inline int NonceKey_integrityCheck(void) {
   1c81b:	55                   	push   %ebp
   1c81c:	89 e5                	mov    %esp,%ebp
   1c81e:	83 ec 38             	sub    $0x38,%esp
 struct NonceKey_cache_root *cache = &NonceKey_cache;
   1c821:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
 (cache->hitCount >= 0 && cache->total >= 0 && cache->hitCount <= cache->total) || ((({
   1c828:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1c82b:	83 b8 a0 02 00 00 00 	cmpl   $0x0,0x2a0(%eax)
   1c832:	78 20                	js     1c854 <NonceKey_integrityCheck+0x39>
   1c834:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1c837:	83 b8 a4 02 00 00 00 	cmpl   $0x0,0x2a4(%eax)
   1c83e:	78 14                	js     1c854 <NonceKey_integrityCheck+0x39>
   1c840:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1c843:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1c846:	8b 80 a0 02 00 00    	mov    0x2a0(%eax),%eax
   1c84c:	3b 82 a4 02 00 00    	cmp    0x2a4(%edx),%eax
   1c852:	7e 18                	jle    1c86c <NonceKey_integrityCheck+0x51>
 printk("stat integrity" "\n");
   1c854:	c7 04 24 d2 74 00 00 	movl   $0x74d2,(%esp,1)
   1c85b:	e8 fc ff ff ff       	call   1c85c <NonceKey_integrityCheck+0x41>
 1;
 }
)) && ({
 return(0);
   1c860:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
   1c867:	e9 b7 02 00 00       	jmp    1cb23 <NonceKey_integrityCheck+0x308>
 1;
 }
));
 int lookupCount = 0;
   1c86c:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
 int algorithmCount = 0;
   1c873:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
 struct list_link *algorithm;
 do {
 if(!(list_integrityCheck((struct alloc_head_list*) &cache->algorithm))) {
   1c87a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1c87d:	05 80 02 00 00       	add    $0x280,%eax
   1c882:	89 04 24             	mov    %eax,(%esp,1)
   1c885:	e8 a7 06 00 00       	call   1cf31 <list_integrityCheck>
   1c88a:	85 c0                	test   %eax,%eax
   1c88c:	75 38                	jne    1c8c6 <NonceKey_integrityCheck+0xab>
 printk("(%s) failed at %s:%s():%d\n", "list_integrityCheck((struct alloc_head_list*) &cache->algorithm)", "state_cache.c", __PRETTY_FUNCTION__, 230);
   1c88e:	c7 44 24 10 e6 00 00 	movl   $0xe6,0x10(%esp,1)
   1c895:	00 
   1c896:	c7 44 24 0c e2 74 00 	movl   $0x74e2,0xc(%esp,1)
   1c89d:	00 
   1c89e:	c7 44 24 08 8c 73 00 	movl   $0x738c,0x8(%esp,1)
   1c8a5:	00 
   1c8a6:	c7 44 24 04 00 75 00 	movl   $0x7500,0x4(%esp,1)
   1c8ad:	00 
   1c8ae:	c7 04 24 b3 73 00 00 	movl   $0x73b3,(%esp,1)
   1c8b5:	e8 fc ff ff ff       	call   1c8b6 <NonceKey_integrityCheck+0x9b>
 return 0;
   1c8ba:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
   1c8c1:	e9 5d 02 00 00       	jmp    1cb23 <NonceKey_integrityCheck+0x308>
 }
 }
 while(0);
 for (algorithm = (typeof(algorithm))(&cache->algorithm)->next;
   1c8c6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1c8c9:	05 80 02 00 00       	add    $0x280,%eax
   1c8ce:	8b 40 04             	mov    0x4(%eax),%eax
   1c8d1:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1c8d4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1c8d7:	05 80 02 00 00       	add    $0x280,%eax
   1c8dc:	39 45 f0             	cmp    %eax,0xfffffff0(%ebp)
   1c8df:	75 02                	jne    1c8e3 <NonceKey_integrityCheck+0xc8>
   1c8e1:	eb 10                	jmp    1c8f3 <NonceKey_integrityCheck+0xd8>
 (algorithm != (typeof(algorithm))(&cache->algorithm));
 algorithm=(typeof(algorithm))algorithm->next) {
 algorithmCount++;
   1c8e3:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   1c8e6:	ff 00                	incl   (%eax)
   1c8e8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1c8eb:	8b 40 04             	mov    0x4(%eax),%eax
   1c8ee:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1c8f1:	eb e1                	jmp    1c8d4 <NonceKey_integrityCheck+0xb9>
 }
 int i;
 for(i=0;
   1c8f3:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
   1c8fa:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1c8fd:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   1c900:	3b 82 98 02 00 00    	cmp    0x298(%edx),%eax
   1c906:	7c 05                	jl     1c90d <NonceKey_integrityCheck+0xf2>
   1c908:	e9 c3 00 00 00       	jmp    1c9d0 <NonceKey_integrityCheck+0x1b5>
 i < cache->numBuckets;
 i++) {
 struct list_link *lookup;
 struct NonceKey_bucket *bucket = &cache->buckets[i];
   1c90d:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   1c910:	89 d0                	mov    %edx,%eax
   1c912:	c1 e0 02             	shl    $0x2,%eax
   1c915:	01 d0                	add    %edx,%eax
   1c917:	c1 e0 02             	shl    $0x2,%eax
   1c91a:	03 45 fc             	add    0xfffffffc(%ebp),%eax
   1c91d:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
 do {
 if(!(list_integrityCheck((struct alloc_head_list*) bucket))) {
   1c920:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1c923:	89 04 24             	mov    %eax,(%esp,1)
   1c926:	e8 06 06 00 00       	call   1cf31 <list_integrityCheck>
   1c92b:	85 c0                	test   %eax,%eax
   1c92d:	75 38                	jne    1c967 <NonceKey_integrityCheck+0x14c>
 printk("(%s) failed at %s:%s():%d\n", "list_integrityCheck((struct alloc_head_list*) bucket)", "state_cache.c", __PRETTY_FUNCTION__, 230);
   1c92f:	c7 44 24 10 e6 00 00 	movl   $0xe6,0x10(%esp,1)
   1c936:	00 
   1c937:	c7 44 24 0c e2 74 00 	movl   $0x74e2,0xc(%esp,1)
   1c93e:	00 
   1c93f:	c7 44 24 08 8c 73 00 	movl   $0x738c,0x8(%esp,1)
   1c946:	00 
   1c947:	c7 44 24 04 60 75 00 	movl   $0x7560,0x4(%esp,1)
   1c94e:	00 
   1c94f:	c7 04 24 b3 73 00 00 	movl   $0x73b3,(%esp,1)
   1c956:	e8 fc ff ff ff       	call   1c957 <NonceKey_integrityCheck+0x13c>
 return 0;
   1c95b:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
   1c962:	e9 bc 01 00 00       	jmp    1cb23 <NonceKey_integrityCheck+0x308>
 }
 }
 while(0);
 for (lookup = (typeof(lookup))(bucket)->next;
   1c967:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
   1c96a:	8b 40 04             	mov    0x4(%eax),%eax
   1c96d:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1c970:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1c973:	3b 45 e4             	cmp    0xffffffe4(%ebp),%eax
   1c976:	75 02                	jne    1c97a <NonceKey_integrityCheck+0x15f>
   1c978:	eb 4c                	jmp    1c9c6 <NonceKey_integrityCheck+0x1ab>
 (lookup != (typeof(lookup))(bucket));
 lookup=(typeof(lookup))lookup->next) {
 struct NonceKey_cell *cell = ((struct NonceKey_cell*) (((char*) lookup) - ((char*) &((struct NonceKey_cell*)0)->lookup)));
   1c97a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1c97d:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
 ( (nonce_hash(&cell->key) % NonceKey_cache.numBuckets) == i ) || ( (({
   1c980:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   1c983:	83 c0 24             	add    $0x24,%eax
   1c986:	89 04 24             	mov    %eax,(%esp,1)
   1c989:	e8 e6 09 00 00       	call   1d374 <nonce_hash>
   1c98e:	ba 00 00 00 00       	mov    $0x0,%edx
   1c993:	f7 35 98 02 00 00    	divl   0x298
   1c999:	3b 55 ec             	cmp    0xffffffec(%ebp),%edx
   1c99c:	74 18                	je     1c9b6 <NonceKey_integrityCheck+0x19b>
 printk("hash index integrity" "\n");
   1c99e:	c7 04 24 96 75 00 00 	movl   $0x7596,(%esp,1)
   1c9a5:	e8 fc ff ff ff       	call   1c9a6 <NonceKey_integrityCheck+0x18b>
 1;
 }
)) && ({
 return(0);
   1c9aa:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
   1c9b1:	e9 6d 01 00 00       	jmp    1cb23 <NonceKey_integrityCheck+0x308>
 1;
 }
) );
 lookupCount++;
   1c9b6:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
   1c9b9:	ff 00                	incl   (%eax)
   1c9bb:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1c9be:	8b 40 04             	mov    0x4(%eax),%eax
   1c9c1:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1c9c4:	eb aa                	jmp    1c970 <NonceKey_integrityCheck+0x155>
   1c9c6:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   1c9c9:	ff 00                	incl   (%eax)
   1c9cb:	e9 2a ff ff ff       	jmp    1c8fa <NonceKey_integrityCheck+0xdf>
 }
 }
 do {
 if(!(algorithmCount <= cache->count)) {
   1c9d0:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1c9d3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1c9d6:	3b 82 94 02 00 00    	cmp    0x294(%edx),%eax
   1c9dc:	7e 38                	jle    1ca16 <NonceKey_integrityCheck+0x1fb>
 printk("(%s) failed at %s:%s():%d\n", "algorithmCount <= cache->count", "state_cache.c", __PRETTY_FUNCTION__, 230);
   1c9de:	c7 44 24 10 e6 00 00 	movl   $0xe6,0x10(%esp,1)
   1c9e5:	00 
   1c9e6:	c7 44 24 0c e2 74 00 	movl   $0x74e2,0xc(%esp,1)
   1c9ed:	00 
   1c9ee:	c7 44 24 08 8c 73 00 	movl   $0x738c,0x8(%esp,1)
   1c9f5:	00 
   1c9f6:	c7 44 24 04 c0 75 00 	movl   $0x75c0,0x4(%esp,1)
   1c9fd:	00 
   1c9fe:	c7 04 24 b3 73 00 00 	movl   $0x73b3,(%esp,1)
   1ca05:	e8 fc ff ff ff       	call   1ca06 <NonceKey_integrityCheck+0x1eb>
 return 0;
   1ca0a:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
   1ca11:	e9 0d 01 00 00       	jmp    1cb23 <NonceKey_integrityCheck+0x308>
 }
 }
 while(0);
 do {
 if(!(lookupCount <= cache->count)) {
   1ca16:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1ca19:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1ca1c:	3b 82 94 02 00 00    	cmp    0x294(%edx),%eax
   1ca22:	7e 38                	jle    1ca5c <NonceKey_integrityCheck+0x241>
 printk("(%s) failed at %s:%s():%d\n", "lookupCount <= cache->count", "state_cache.c", __PRETTY_FUNCTION__, 230);
   1ca24:	c7 44 24 10 e6 00 00 	movl   $0xe6,0x10(%esp,1)
   1ca2b:	00 
   1ca2c:	c7 44 24 0c e2 74 00 	movl   $0x74e2,0xc(%esp,1)
   1ca33:	00 
   1ca34:	c7 44 24 08 8c 73 00 	movl   $0x738c,0x8(%esp,1)
   1ca3b:	00 
   1ca3c:	c7 44 24 04 df 75 00 	movl   $0x75df,0x4(%esp,1)
   1ca43:	00 
   1ca44:	c7 04 24 b3 73 00 00 	movl   $0x73b3,(%esp,1)
   1ca4b:	e8 fc ff ff ff       	call   1ca4c <NonceKey_integrityCheck+0x231>
 return 0;
   1ca50:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
   1ca57:	e9 c7 00 00 00       	jmp    1cb23 <NonceKey_integrityCheck+0x308>
 }
 }
 while(0);
 do {
 if(!(cache->count <= cache->maxCount)) {
   1ca5c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1ca5f:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1ca62:	8b 80 94 02 00 00    	mov    0x294(%eax),%eax
   1ca68:	3b 82 9c 02 00 00    	cmp    0x29c(%edx),%eax
   1ca6e:	7e 35                	jle    1caa5 <NonceKey_integrityCheck+0x28a>
 printk("(%s) failed at %s:%s():%d\n", "cache->count <= cache->maxCount", "state_cache.c", __PRETTY_FUNCTION__, 230);
   1ca70:	c7 44 24 10 e6 00 00 	movl   $0xe6,0x10(%esp,1)
   1ca77:	00 
   1ca78:	c7 44 24 0c e2 74 00 	movl   $0x74e2,0xc(%esp,1)
   1ca7f:	00 
   1ca80:	c7 44 24 08 8c 73 00 	movl   $0x738c,0x8(%esp,1)
   1ca87:	00 
   1ca88:	c7 44 24 04 00 76 00 	movl   $0x7600,0x4(%esp,1)
   1ca8f:	00 
   1ca90:	c7 04 24 b3 73 00 00 	movl   $0x73b3,(%esp,1)
   1ca97:	e8 fc ff ff ff       	call   1ca98 <NonceKey_integrityCheck+0x27d>
 return 0;
   1ca9c:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
   1caa3:	eb 7e                	jmp    1cb23 <NonceKey_integrityCheck+0x308>
 }
 }
 while(0);
 for(i = cache->numBuckets;
   1caa5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1caa8:	8b 80 98 02 00 00    	mov    0x298(%eax),%eax
   1caae:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1cab1:	83 7d ec 1f          	cmpl   $0x1f,0xffffffec(%ebp)
   1cab5:	7e 02                	jle    1cab9 <NonceKey_integrityCheck+0x29e>
   1cab7:	eb 63                	jmp    1cb1c <NonceKey_integrityCheck+0x301>
 i < (32);
 i++) {
 struct NonceKey_bucket *bucket = &cache->buckets[i];
   1cab9:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
   1cabc:	89 d0                	mov    %edx,%eax
   1cabe:	c1 e0 02             	shl    $0x2,%eax
   1cac1:	01 d0                	add    %edx,%eax
   1cac3:	c1 e0 02             	shl    $0x2,%eax
   1cac6:	03 45 fc             	add    0xfffffffc(%ebp),%eax
   1cac9:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
 list_integrityCheck((struct alloc_head_list*) bucket);
   1cacc:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   1cacf:	89 04 24             	mov    %eax,(%esp,1)
   1cad2:	e8 5a 04 00 00       	call   1cf31 <list_integrityCheck>
 do {
 if(!(bucket->len == 0)) {
   1cad7:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   1cada:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
   1cade:	74 35                	je     1cb15 <NonceKey_integrityCheck+0x2fa>
 printk("(%s) failed at %s:%s():%d\n", "bucket->len == 0", "state_cache.c", __PRETTY_FUNCTION__, 230);
   1cae0:	c7 44 24 10 e6 00 00 	movl   $0xe6,0x10(%esp,1)
   1cae7:	00 
   1cae8:	c7 44 24 0c e2 74 00 	movl   $0x74e2,0xc(%esp,1)
   1caef:	00 
   1caf0:	c7 44 24 08 8c 73 00 	movl   $0x738c,0x8(%esp,1)
   1caf7:	00 
   1caf8:	c7 44 24 04 20 76 00 	movl   $0x7620,0x4(%esp,1)
   1caff:	00 
   1cb00:	c7 04 24 b3 73 00 00 	movl   $0x73b3,(%esp,1)
   1cb07:	e8 fc ff ff ff       	call   1cb08 <NonceKey_integrityCheck+0x2ed>
 return 0;
   1cb0c:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
   1cb13:	eb 0e                	jmp    1cb23 <NonceKey_integrityCheck+0x308>
   1cb15:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
   1cb18:	ff 00                	incl   (%eax)
   1cb1a:	eb 95                	jmp    1cab1 <NonceKey_integrityCheck+0x296>
 }
 }
 while(0);
 }
 return 1;
   1cb1c:	c7 45 dc 01 00 00 00 	movl   $0x1,0xffffffdc(%ebp)
 }
   1cb23:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   1cb26:	c9                   	leave  
   1cb27:	c3                   	ret    

0001cb28 <NonceKey_evictOne>:
 static inline void NonceKey_resetStats(void) {
 struct NonceKey_cache_root *cache = &NonceKey_cache;
 cache->hitCount = 0;
 cache->total = 0;
 }
 static inline struct NonceKey_cell *NonceKey_findLoop(struct NonceKey_bucket *bucket, __u64 *key) {
 struct list_link *lookup;
 for (lookup = (typeof(lookup))(bucket)->next;
 (lookup != (typeof(lookup))(bucket));
 lookup=(typeof(lookup))lookup->next) {
 struct NonceKey_cell *cell = ((struct NonceKey_cell*) (((char*) lookup) - ((char*) &((struct NonceKey_cell*)0)->lookup)));
 if(nonce_cmp(key, ((void *)0), &cell->key, &cell->elem)) {
 return cell;
 }
 }
 return ((void *)0);
 }
 static inline struct NonceKey_cell *NonceKey_insert_helper(__u64 *key) {
 struct NonceKey_cache_root *cache = &NonceKey_cache;
 struct NonceKey_bucket *bucket = &cache->buckets[nonce_hash(key) % cache->numBuckets];
 struct NonceKey_cell *cell = ((void *)0);
 if(cache->count == cache->maxCount) {
 NonceKey_evictOne(&cell);
 cache->count++;
 (cache->count == cache->maxCount) || ({
 do {
 printk("dying at %s:%s():%d\n", "state_cache.c", __PRETTY_FUNCTION__, 230);
 do {
 if (!(0)) {
 printk("kgdb assertion failed: %s\n", "BUG");
 show_stack(((void *)0));
 breakpoint();
 }
 }
 while (0);
 }
 while(0) ;
 1 ;
 }
);
 }
 else {
 cache->count++;
 }
 if(cell == ((void *)0)) {
 cell = NonceKey_newCell();
 }
 list_link_init(&cell->lookup);
 list_link_init(&cell->algorithm);
 insert_head((struct alloc_head_list *) bucket, (struct alloc_head*) &cell->lookup);
 insert_tail(&cache->algorithm, (struct alloc_head*) &cell->algorithm);
 inserted_cell: cell->key = *key;
 return cell;
 }
 static inline void NonceKey_insert(struct NonceMap *elem) {
 if((0) >= (2)) {
 NonceKey_integrityCheck() || ({
 do {
 printk("dying at %s:%s():%d\n", "state_cache.c", __PRETTY_FUNCTION__, 230);
 do {
 if (!(0)) {
 printk("kgdb assertion failed: %s\n", "BUG");
 show_stack(((void *)0));
 breakpoint();
 }
 }
 while (0);
 }
 while(0) ;
 1 ;
 }
);
 }
;
 __u64 key = nonce_toKey(elem);
 struct NonceKey_cell *cell = NonceKey_insert_helper(&key);
 cell->elem = *elem;
 if((0) >= (2)) {
 NonceKey_integrityCheck() || ({
 do {
 printk("dying at %s:%s():%d\n", "state_cache.c", __PRETTY_FUNCTION__, 230);
 do {
 if (!(0)) {
 printk("kgdb assertion failed: %s\n", "BUG");
 show_stack(((void *)0));
 breakpoint();
 }
 }
 while (0);
 }
 while(0) ;
 1 ;
 }
);
 }
;
 }
 static inline int NonceKey_find_helper(__u64 *key, struct NonceKey_cell **hint) {
 struct NonceKey_cache_root *cache = &NonceKey_cache;
 struct NonceKey_bucket *bucket = &cache->buckets[nonce_hash(key) % cache->numBuckets];
 struct NonceKey_cell *lookup;
 lookup = NonceKey_findLoop(bucket, key);
 if(lookup != ((void *)0)) {
 *hint = lookup;
 }
 if((0) >= (2)) {
 NonceKey_integrityCheck() || ({
 do {
 printk("dying at %s:%s():%d\n", "state_cache.c", __PRETTY_FUNCTION__, 230);
 do {
 if (!(0)) {
 printk("kgdb assertion failed: %s\n", "BUG");
 show_stack(((void *)0));
 breakpoint();
 }
 }
 while (0);
 }
 while(0) ;
 1 ;
 }
);
 }
;
 int found = lookup != ((void *)0);
 if(found) {
 cache->hitCount++;
 }
 cache->total++;
 return found;
 }
 static inline int NonceKey_find(__u64 *key, struct NonceMap *result) {
 struct NonceKey_cell *cell = ((void *)0);
 int found = NonceKey_find_helper(key, &cell);
 if(found) {
 *result = cell->elem;
 }
 if((0) >= (2)) {
 NonceKey_integrityCheck() || ({
 do {
 printk("dying at %s:%s():%d\n", "state_cache.c", __PRETTY_FUNCTION__, 230);
 do {
 if (!(0)) {
 printk("kgdb assertion failed: %s\n", "BUG");
 show_stack(((void *)0));
 breakpoint();
 }
 }
 while (0);
 }
 while(0) ;
 1 ;
 }
);
 }
;
 return found;
 }
 static inline void NonceKey_unlinkCell(struct NonceKey_cell *cell) {
 struct NonceKey_cache_root *cache = &NonceKey_cache;
 unlink((struct alloc_head*) &cell->lookup);
 if(cell->algorithm.list != ((void *)0)) {
 unlink((struct alloc_head*) &cell->algorithm);
 }
 cache->count--;
 }
 static inline void NonceKey_freeCell(struct NonceKey_cell *cell);
 static inline void NonceKey_deleteCell(struct NonceKey_cell *cell) {
 NonceKey_unlinkCell(cell);
 NonceKey_freeCell(cell);
 }
 static inline int NonceKey_delete(__u64 *key) {
 struct NonceKey_cell *cell = ((void *)0);
 int found = NonceKey_find_helper(key, &cell);
 if(found) {
 NonceKey_deleteCell(cell);
 }
 if((0) >= (2)) {
 NonceKey_integrityCheck() || ({
 do {
 printk("dying at %s:%s():%d\n", "state_cache.c", __PRETTY_FUNCTION__, 230);
 do {
 if (!(0)) {
 printk("kgdb assertion failed: %s\n", "BUG");
 show_stack(((void *)0));
 breakpoint();
 }
 }
 while (0);
 }
 while(0) ;
 1 ;
 }
);
 }
;
 return found;
 }
 static inline void NonceKey_evictOne(struct NonceKey_cell **cell) {
   1cb28:	55                   	push   %ebp
   1cb29:	89 e5                	mov    %esp,%ebp
   1cb2b:	83 ec 20             	sub    $0x20,%esp
 struct NonceKey_cache_root *cache = &NonceKey_cache;
   1cb2e:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
 do {
 if(!(cache->algorithm.len > 0)) {
   1cb35:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1cb38:	83 b8 90 02 00 00 00 	cmpl   $0x0,0x290(%eax)
   1cb3f:	7f 75                	jg     1cbb6 <NonceKey_evictOne+0x8e>
 printk("(%s) failed at %s:%s():%d\n", "cache->algorithm.len > 0", "state_cache.c", __PRETTY_FUNCTION__, 230);
   1cb41:	c7 44 24 10 e6 00 00 	movl   $0xe6,0x10(%esp,1)
   1cb48:	00 
   1cb49:	c7 44 24 0c 31 76 00 	movl   $0x7631,0xc(%esp,1)
   1cb50:	00 
   1cb51:	c7 44 24 08 8c 73 00 	movl   $0x738c,0x8(%esp,1)
   1cb58:	00 
   1cb59:	c7 44 24 04 9a 73 00 	movl   $0x739a,0x4(%esp,1)
   1cb60:	00 
   1cb61:	c7 04 24 b3 73 00 00 	movl   $0x73b3,(%esp,1)
   1cb68:	e8 fc ff ff ff       	call   1cb69 <NonceKey_evictOne+0x41>
 ({
 do {
 printk("dying at %s:%s():%d\n", "state_cache.c", __PRETTY_FUNCTION__, 230);
   1cb6d:	c7 44 24 0c e6 00 00 	movl   $0xe6,0xc(%esp,1)
   1cb74:	00 
   1cb75:	c7 44 24 08 31 76 00 	movl   $0x7631,0x8(%esp,1)
   1cb7c:	00 
   1cb7d:	c7 44 24 04 8c 73 00 	movl   $0x738c,0x4(%esp,1)
   1cb84:	00 
   1cb85:	c7 04 24 ce 73 00 00 	movl   $0x73ce,(%esp,1)
   1cb8c:	e8 fc ff ff ff       	call   1cb8d <NonceKey_evictOne+0x65>
 do {
 if (!(0)) {
 printk("kgdb assertion failed: %s\n", "BUG");
   1cb91:	c7 44 24 04 f9 72 00 	movl   $0x72f9,0x4(%esp,1)
   1cb98:	00 
   1cb99:	c7 04 24 fd 72 00 00 	movl   $0x72fd,(%esp,1)
   1cba0:	e8 fc ff ff ff       	call   1cba1 <NonceKey_evictOne+0x79>
 show_stack(((void *)0));
   1cba5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1cbac:	e8 fc ff ff ff       	call   1cbad <NonceKey_evictOne+0x85>
 breakpoint();
   1cbb1:	e8 fc ff ff ff       	call   1cbb2 <NonceKey_evictOne+0x8a>
 }
 }
 while (0);
 }
 while(0) ;
 1 ;
 }
);
 }
 }
 while(0);
 struct list_link *algorithm = (struct list_link *)cache->algorithm.next;
   1cbb6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1cbb9:	8b 80 84 02 00 00    	mov    0x284(%eax),%eax
   1cbbf:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
 struct NonceKey_cell *cell0 = ((struct NonceKey_cell*) (((char*) algorithm) - ((char*) &((struct NonceKey_cell*)0)->algorithm)));
   1cbc2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1cbc5:	83 e8 0c             	sub    $0xc,%eax
   1cbc8:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
 NonceKey_unlinkCell(cell0);
   1cbcb:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1cbce:	89 04 24             	mov    %eax,(%esp,1)
   1cbd1:	e8 b9 0a 00 00       	call   1d68f <NonceKey_unlinkCell>
 nonce_evict(&cell0->elem);
   1cbd6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1cbd9:	83 c0 2c             	add    $0x2c,%eax
   1cbdc:	89 04 24             	mov    %eax,(%esp,1)
   1cbdf:	e8 b3 07 00 00       	call   1d397 <nonce_evict>
 *cell = cell0;
   1cbe4:	8b 55 08             	mov    0x8(%ebp),%edx
   1cbe7:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1cbea:	89 02                	mov    %eax,(%edx)
 }
   1cbec:	c9                   	leave  
   1cbed:	c3                   	ret    

0001cbee <NonceKey_evict>:
 static inline int NonceKey_evict(int toEvict) {
   1cbee:	55                   	push   %ebp
   1cbef:	89 e5                	mov    %esp,%ebp
   1cbf1:	83 ec 1c             	sub    $0x1c,%esp
 if((0) >= (2)) {
 NonceKey_integrityCheck() || ({
 do {
 printk("dying at %s:%s():%d\n", "state_cache.c", __PRETTY_FUNCTION__, 230);
 do {
 if (!(0)) {
 printk("kgdb assertion failed: %s\n", "BUG");
 show_stack(((void *)0));
 breakpoint();
 }
 }
 while (0);
 }
 while(0) ;
 1 ;
 }
);
 }
;
 int execCount = 0;
   1cbf4:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
 struct NonceKey_cache_root *cache = &NonceKey_cache;
   1cbfb:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
 while((struct alloc_head *)&cache->algorithm.len > 0 && toEvict > 0 && cache->count > 0) {
   1cc02:	81 7d f8 70 fd ff ff 	cmpl   $0xfffffd70,0xfffffff8(%ebp)
   1cc09:	74 34                	je     1cc3f <NonceKey_evict+0x51>
   1cc0b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1cc0f:	7e 2e                	jle    1cc3f <NonceKey_evict+0x51>
   1cc11:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1cc14:	83 b8 94 02 00 00 00 	cmpl   $0x0,0x294(%eax)
   1cc1b:	7f 02                	jg     1cc1f <NonceKey_evict+0x31>
   1cc1d:	eb 20                	jmp    1cc3f <NonceKey_evict+0x51>
 struct NonceKey_cell *cell;
 NonceKey_evictOne(&cell);
   1cc1f:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   1cc22:	89 04 24             	mov    %eax,(%esp,1)
   1cc25:	e8 fe fe ff ff       	call   1cb28 <NonceKey_evictOne>
 kfree(cell);
   1cc2a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1cc2d:	89 04 24             	mov    %eax,(%esp,1)
   1cc30:	e8 fc ff ff ff       	call   1cc31 <NonceKey_evict+0x43>
 toEvict--;
   1cc35:	ff 4d 08             	decl   0x8(%ebp)
 execCount++;
   1cc38:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
   1cc3b:	ff 00                	incl   (%eax)
   1cc3d:	eb c3                	jmp    1cc02 <NonceKey_evict+0x14>
 }
 if((0) >= (2)) {
 NonceKey_integrityCheck() || ({
 do {
 printk("dying at %s:%s():%d\n", "state_cache.c", __PRETTY_FUNCTION__, 230);
 do {
 if (!(0)) {
 printk("kgdb assertion failed: %s\n", "BUG");
 show_stack(((void *)0));
 breakpoint();
 }
 }
 while (0);
 }
 while(0) ;
 1 ;
 }
);
 }
;
 return execCount;
   1cc3f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
 }
   1cc42:	c9                   	leave  
   1cc43:	c3                   	ret    

0001cc44 <NonceKey_newCell>:
 static inline struct NonceKey_cell *NonceKey_newCell() {
   1cc44:	55                   	push   %ebp
   1cc45:	89 e5                	mov    %esp,%ebp
   1cc47:	83 ec 18             	sub    $0x18,%esp
 struct NonceKey_cell *cell = kmalloc(sizeof(struct NonceKey_cell), (0x20));
   1cc4a:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp,1)
   1cc51:	00 
   1cc52:	c7 04 24 44 00 00 00 	movl   $0x44,(%esp,1)
   1cc59:	e8 fc ff ff ff       	call   1cc5a <NonceKey_newCell+0x16>
   1cc5e:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
 NonceKey_cache.cellMem += sizeof(*cell);
   1cc61:	83 05 a8 02 00 00 44 	addl   $0x44,0x2a8
 NonceKey_cache.maxCellMem = ({
 const typeof(NonceKey_cache.maxCellMem) _x = (NonceKey_cache.maxCellMem);
   1cc68:	a1 ac 02 00 00       	mov    0x2ac,%eax
   1cc6d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
 const typeof(NonceKey_cache.cellMem) _y = (NonceKey_cache.cellMem);
   1cc70:	a1 a8 02 00 00       	mov    0x2a8,%eax
   1cc75:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
 (void) (&_x == &_y);
 _x > _y ? _x : _y;
   1cc78:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1cc7b:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1cc7e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1cc81:	3b 45 f8             	cmp    0xfffffff8(%ebp),%eax
   1cc84:	7d 06                	jge    1cc8c <NonceKey_newCell+0x48>
   1cc86:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1cc89:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1cc8c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1cc8f:	a3 ac 02 00 00       	mov    %eax,0x2ac
 }
);
 return cell;
   1cc94:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
 }
   1cc97:	c9                   	leave  
   1cc98:	c3                   	ret    

0001cc99 <NonceKey_freeCell>:
 static inline void NonceKey_freeCell(struct NonceKey_cell *cell) {
   1cc99:	55                   	push   %ebp
   1cc9a:	89 e5                	mov    %esp,%ebp
   1cc9c:	83 ec 04             	sub    $0x4,%esp
 NonceKey_cache.cellMem -= sizeof(*cell);
   1cc9f:	83 2d a8 02 00 00 44 	subl   $0x44,0x2a8
 kfree(cell);
   1cca6:	8b 45 08             	mov    0x8(%ebp),%eax
   1cca9:	89 04 24             	mov    %eax,(%esp,1)
   1ccac:	e8 fc ff ff ff       	call   1ccad <NonceKey_freeCell+0x14>
 }
   1ccb1:	c9                   	leave  
   1ccb2:	c3                   	ret    

0001ccb3 <StateCache_init>:
   1ccb3:	55                   	push   %ebp
   1ccb4:	89 e5                	mov    %esp,%ebp
   1ccb6:	e8 e8 03 00 00       	call   1d0a3 <ParsedCMinisock_cache_init>
   1ccbb:	e8 16 07 00 00       	call   1d3d6 <Continuation_cache_init>
   1ccc0:	e8 04 0a 00 00       	call   1d6c9 <NonceKey_cache_init>
   1ccc5:	5d                   	pop    %ebp
   1ccc6:	c3                   	ret    

0001ccc7 <StateCache_destroy>:
   1ccc7:	55                   	push   %ebp
   1ccc8:	89 e5                	mov    %esp,%ebp
   1ccca:	e8 94 04 00 00       	call   1d163 <ParsedCMinisock_cache_destroy>
   1cccf:	e8 c2 07 00 00       	call   1d496 <Continuation_cache_destroy>
   1ccd4:	e8 b0 0a 00 00       	call   1d789 <NonceKey_cache_destroy>
   1ccd9:	5d                   	pop    %ebp
   1ccda:	c3                   	ret    

0001ccdb <WireContinuation_lookup>:
   1ccdb:	55                   	push   %ebp
   1ccdc:	89 e5                	mov    %esp,%ebp
   1ccde:	83 ec 1c             	sub    $0x1c,%esp
   1cce1:	8b 45 08             	mov    0x8(%ebp),%eax
   1cce4:	8b 40 01             	mov    0x1(%eax),%eax
   1cce7:	89 04 24             	mov    %eax,(%esp,1)
   1ccea:	e8 6d 06 00 00       	call   1d35c <seqnoToKey>
   1ccef:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   1ccf2:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
   1ccf5:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1ccf9:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
   1ccfc:	89 04 24             	mov    %eax,(%esp,1)
   1ccff:	e8 e6 08 00 00       	call   1d5ea <Continuation_find_helper>
   1cd04:	85 c0                	test   %eax,%eax
   1cd06:	74 37                	je     1cd3f <WireContinuation_lookup+0x64>
   1cd08:	8b 45 10             	mov    0x10(%ebp),%eax
   1cd0b:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   1cd0f:	8b 45 0c             	mov    0xc(%ebp),%eax
   1cd12:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1cd16:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1cd19:	83 c0 28             	add    $0x28,%eax
   1cd1c:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1cd20:	8b 45 08             	mov    0x8(%ebp),%eax
   1cd23:	89 04 24             	mov    %eax,(%esp,1)
   1cd26:	e8 07 0b 00 00       	call   1d832 <WireContinuation_checkAndCopyOut>
   1cd2b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1cd2e:	89 04 24             	mov    %eax,(%esp,1)
   1cd31:	e8 3b 09 00 00       	call   1d671 <Continuation_deleteCell>
   1cd36:	c7 45 f4 01 00 00 00 	movl   $0x1,0xfffffff4(%ebp)
   1cd3d:	eb 07                	jmp    1cd46 <WireContinuation_lookup+0x6b>
   1cd3f:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
   1cd46:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1cd49:	c9                   	leave  
   1cd4a:	c3                   	ret    

0001cd4b <WireContinuation_insert>:
   1cd4b:	55                   	push   %ebp
   1cd4c:	89 e5                	mov    %esp,%ebp
   1cd4e:	83 ec 14             	sub    $0x14,%esp
   1cd51:	8b 45 08             	mov    0x8(%ebp),%eax
   1cd54:	8b 40 01             	mov    0x1(%eax),%eax
   1cd57:	89 04 24             	mov    %eax,(%esp,1)
   1cd5a:	e8 fd 05 00 00       	call   1d35c <seqnoToKey>
   1cd5f:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   1cd62:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
   1cd65:	89 04 24             	mov    %eax,(%esp,1)
   1cd68:	e8 49 07 00 00       	call   1d4b6 <Continuation_insert_helper>
   1cd6d:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   1cd70:	83 7d f8 00          	cmpl   $0x0,0xfffffff8(%ebp)
   1cd74:	74 1c                	je     1cd92 <WireContinuation_insert+0x47>
   1cd76:	8b 45 0c             	mov    0xc(%ebp),%eax
   1cd79:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1cd7d:	8b 45 08             	mov    0x8(%ebp),%eax
   1cd80:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1cd84:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1cd87:	83 c0 28             	add    $0x28,%eax
   1cd8a:	89 04 24             	mov    %eax,(%esp,1)
   1cd8d:	e8 17 0a 00 00       	call   1d7a9 <WireContinuation_copyIn>
   1cd92:	c9                   	leave  
   1cd93:	c3                   	ret    

0001cd94 <dump_cache_stats>:
   1cd94:	55                   	push   %ebp
   1cd95:	89 e5                	mov    %esp,%ebp
   1cd97:	83 ec 14             	sub    $0x14,%esp
   1cd9a:	a1 2c 50 00 00       	mov    0x502c,%eax
   1cd9f:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   1cda3:	a1 28 50 00 00       	mov    0x5028,%eax
   1cda8:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   1cdac:	a1 24 50 00 00       	mov    0x5024,%eax
   1cdb1:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1cdb5:	a1 20 50 00 00       	mov    0x5020,%eax
   1cdba:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1cdbe:	c7 04 24 60 76 00 00 	movl   $0x7660,(%esp,1)
   1cdc5:	e8 fc ff ff ff       	call   1cdc6 <dump_cache_stats+0x32>
   1cdca:	a1 2c 50 00 00       	mov    0x502c,%eax
   1cdcf:	89 44 24 10          	mov    %eax,0x10(%esp,1)
   1cdd3:	a1 28 50 00 00       	mov    0x5028,%eax
   1cdd8:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   1cddc:	a1 24 50 00 00       	mov    0x5024,%eax
   1cde1:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1cde5:	a1 20 50 00 00       	mov    0x5020,%eax
   1cdea:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1cdee:	c7 04 24 a0 76 00 00 	movl   $0x76a0,(%esp,1)
   1cdf5:	e8 fc ff ff ff       	call   1cdf6 <dump_cache_stats+0x62>
   1cdfa:	c9                   	leave  
   1cdfb:	c3                   	ret    

0001cdfc <unlink>:
	elem->prev = head->prev;

	head->prev->next = elem;

	elem->list = head;
   1cdfc:	55                   	push   %ebp
   1cdfd:	89 e5                	mov    %esp,%ebp
	head->prev = elem;
   1cdff:	8b 45 08             	mov    0x8(%ebp),%eax
   1ce02:	8b 50 04             	mov    0x4(%eax),%edx
   1ce05:	8b 45 08             	mov    0x8(%ebp),%eax
   1ce08:	8b 00                	mov    (%eax),%eax
   1ce0a:	89 02                	mov    %eax,(%edx)
	head->len++;
   1ce0c:	8b 45 08             	mov    0x8(%ebp),%eax
   1ce0f:	8b 10                	mov    (%eax),%edx
   1ce11:	8b 45 08             	mov    0x8(%ebp),%eax
   1ce14:	8b 40 04             	mov    0x4(%eax),%eax
   1ce17:	89 42 04             	mov    %eax,0x4(%edx)
}
   1ce1a:	8b 55 08             	mov    0x8(%ebp),%edx
   1ce1d:	8b 45 08             	mov    0x8(%ebp),%eax
   1ce20:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   1ce27:	c7 02 00 00 00 00    	movl   $0x0,(%edx)

   1ce2d:	8b 45 08             	mov    0x8(%ebp),%eax
   1ce30:	8b 40 08             	mov    0x8(%eax),%eax
   1ce33:	ff 48 10             	decl   0x10(%eax)
static inline void insert_tail_mb(struct alloc_head_list *head, struct alloc_head *elem) {
   1ce36:	8b 45 08             	mov    0x8(%ebp),%eax
   1ce39:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
#if 1
   1ce40:	5d                   	pop    %ebp
   1ce41:	c3                   	ret    

0001ce42 <msk_hold>:
		//printk("alloc_head loop\n");
		curr = curr->next;
	}
	return (struct alloc_head_list*)curr != head;
}
   1ce42:	55                   	push   %ebp
   1ce43:	89 e5                	mov    %esp,%ebp

   1ce45:	8b 45 08             	mov    0x8(%ebp),%eax
   1ce48:	ff 80 f0 00 00 00    	incl   0xf0(%eax)
static inline struct cminisock *alloc_trickles_msk(struct sock *sk) {
   1ce4e:	5d                   	pop    %ebp
   1ce4f:	c3                   	ret    

0001ce50 <msk_release>:
	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
	struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;
	struct cminisock *rval = NULL, *curr = (struct cminisock *)tp->cminisock_api_config.msk_freelist.next;

	if(!SIMULATION_MODE(sk)) {
		while((struct alloc_head_list*)curr != head && curr->ctl == ALLOC_PROCESSING) {
			//printk("alloc_head loop\n");
			curr = curr->next;
		}
		//printk("out of alloc_head loop\n");

		if((struct alloc_head_list *)curr == head) return NULL;

		rval = curr;
		unlink((struct alloc_head*)rval);
		rval->ctl = ALLOC_PENDING;
	} else {
		if(tp->t.responseCount == 0) {
			rval = tp->t.responseMSK;
			rval->list = NULL;
			rval->next = rval->prev = NULL;
		} else {
			rval = kmalloc(sizeof (struct cminisock), GFP_ATOMIC);
			if(rval == NULL) {
				printk("out of memory during compatibility mode\n");
				return NULL;
			}
			rval->next = rval->prev = NULL;
			rval->list = NULL;
			insert_tail(&tp->t.responseList, (struct alloc_head*)rval);
		}
		tp->t.responseCount++;

		rval->sk = sk;
		rval->ctl = ALLOC_PENDING;
	}

	init_minisock(rval);

	return rval;
}

static inline void msk_hold(struct cminisock *msk) {
	msk->refCnt++;
}

#endif // USERTEST

static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk);
static inline void free_trickles_msk_finish(struct sock *sk, struct cminisock *msk);

static inline struct cminisock *
shallow_copy_msk(struct sock *sk, struct cminisock *msk) {
	struct cminisock *rval = alloc_trickles_msk(sk);

	struct alloc_head head;

	if(rval == NULL) {
		printk("out of memory while copying msk\n");
		return NULL;
	}
	/* save & restore alloc head */
	head = *(struct alloc_head*)rval;
	*rval = *msk;
	*(struct alloc_head*)rval = head;

	rval->refCnt = 1;

	return rval;
}


#ifdef CAN_USE_TFREE
static inline struct cminisock *copy_msk(struct sock *sk, struct cminisock *msk) {
	// Copy everything except for per-packet information.

	printk("CopyMSK\n");
#if 0
	struct cminisock *rval = alloc_trickles_msk(sk);
	struct alloc_head head;
	if(rval == NULL) {
		printk("out of memory while copying msk\n");
		return NULL;
	}
	/* save & restore alloc head */
	head = *(struct alloc_head*)rval;
	*rval = *msk;
	*(struct alloc_head*)rval = head;
#else
	struct cminisock *rval = shallow_copy_msk(sk, msk);
	if(rval == NULL) {
		printk("out of memory while copying msk\n");
		return NULL;
	}
#endif

	rval->num_packets = 0;
	rval->packets = NULL;

	if(rval->ucont_len > 0) {
		rval->ucont_data = tmalloc(sk,rval->ucont_len);
		// printk("copymsk: tmalloc ucontdata\n");
		if(rval->ucont_data == NULL) {
			printk("out of tmalloc memory while copying msk (len = %d)\n", rval->ucont_len);
			free_trickles_msk(sk,rval);
			free_trickles_msk_finish(sk,rval);
			return NULL;
		}
	} else {
		rval->ucont_data = NULL;
	}
	if(rval->input_len > 0) {
		rval->input = tmalloc(sk,rval->input_len);
		// printk("copymsk: tmalloc inputlen\n");
		if(rval->input == NULL) {
			printk("out of tmalloc memory while copying msk (len = %d)\n", rval->input_len);
			tfree(sk,rval->ucont_data);
			free_trickles_msk(sk,rval);
			free_trickles_msk_finish(sk,rval);
			return NULL;
		}
	} else {
		rval->input = NULL;
	}
	if(rval->ucont_data)
		memcpy(rval->ucont_data,msk->ucont_data,rval->ucont_len);
	if(rval->input)
		memcpy(rval->input,msk->input,rval->input_len);

	rval->executionTrace |= 0x80;
	return rval;
}
#endif // CAN_USE_TFREE

/* Two phase free: first phase disconnects socket from event list,
   sets to ALLOC_PROCESSING; second phase adds the socket to free
   list, sets to ALLOC_FREE and ready for reuse */
#ifndef USERTEST
static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk) {
   1ce50:	55                   	push   %ebp
   1ce51:	89 e5                	mov    %esp,%ebp
   1ce53:	83 ec 10             	sub    $0x10,%esp
	if(!SIMULATION_MODE(sk)) {
   1ce56:	8b 45 0c             	mov    0xc(%ebp),%eax
   1ce59:	ff 88 f0 00 00 00    	decl   0xf0(%eax)
		if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) {
   1ce5f:	8b 45 0c             	mov    0xc(%ebp),%eax
   1ce62:	83 b8 f0 00 00 00 00 	cmpl   $0x0,0xf0(%eax)
   1ce69:	79 14                	jns    1ce7f <msk_release+0x2f>
   1ce6b:	c7 44 24 04 13 01 00 	movl   $0x113,0x4(%esp,1)
   1ce72:	00 
   1ce73:	c7 04 24 e0 76 00 00 	movl   $0x76e0,(%esp,1)
   1ce7a:	e8 fc ff ff ff       	call   1ce7b <msk_release+0x2b>
			printk("double free\n");
   1ce7f:	8b 45 0c             	mov    0xc(%ebp),%eax
   1ce82:	83 b8 f0 00 00 00 00 	cmpl   $0x0,0xf0(%eax)
   1ce89:	0f 85 a0 00 00 00    	jne    1cf2f <msk_release+0xdf>
			BUG();
   1ce8f:	8b 45 08             	mov    0x8(%ebp),%eax
   1ce92:	05 bc 00 00 00       	add    $0xbc,%eax
   1ce97:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
		}
   1ce9a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1ce9d:	05 d4 01 00 00       	add    $0x1d4,%eax
   1cea2:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
		if(msk->ctl == ALLOC_READY && msk->prev != NULL) {
   1cea5:	8b 45 0c             	mov    0xc(%ebp),%eax
   1cea8:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1ceac:	8b 45 08             	mov    0x8(%ebp),%eax
   1ceaf:	89 04 24             	mov    %eax,(%esp,1)
   1ceb2:	e8 d8 0d 00 00       	call   1dc8f <free_minisock>
			unlink((struct alloc_head *)msk);
   1ceb7:	8b 45 08             	mov    0x8(%ebp),%eax
   1ceba:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   1cec0:	83 e0 01             	and    $0x1,%eax
   1cec3:	85 c0                	test   %eax,%eax
   1cec5:	74 1b                	je     1cee2 <msk_release+0x92>
   1cec7:	8b 55 08             	mov    0x8(%ebp),%edx
   1ceca:	8b 45 08             	mov    0x8(%ebp),%eax
   1cecd:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   1ced3:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
   1ced9:	83 e0 08             	and    $0x8,%eax
   1cedc:	85 c0                	test   %eax,%eax
   1cede:	75 02                	jne    1cee2 <msk_release+0x92>
   1cee0:	eb 1e                	jmp    1cf00 <msk_release+0xb0>
		}
   1cee2:	8b 45 0c             	mov    0xc(%ebp),%eax
   1cee5:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1cee9:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1ceec:	89 04 24             	mov    %eax,(%esp,1)
   1ceef:	e8 a8 0c 00 00       	call   1db9c <insert_head>
		msk->ctl = ALLOC_PROCESSING;
   1cef4:	8b 45 0c             	mov    0xc(%ebp),%eax
   1cef7:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
   1cefe:	eb 2f                	jmp    1cf2f <msk_release+0xdf>
	}
}
   1cf00:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1cf03:	8b 45 0c             	mov    0xc(%ebp),%eax
   1cf06:	3b 82 64 0a 00 00    	cmp    0xa64(%edx),%eax
   1cf0c:	75 02                	jne    1cf10 <msk_release+0xc0>
   1cf0e:	eb 16                	jmp    1cf26 <msk_release+0xd6>

static inline void msk_release(struct sock *sk, struct cminisock *msk) {
   1cf10:	8b 45 0c             	mov    0xc(%ebp),%eax
   1cf13:	89 04 24             	mov    %eax,(%esp,1)
   1cf16:	e8 e1 fe ff ff       	call   1cdfc <unlink>
	// Perform actual deallocation. This function is common to
   1cf1b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1cf1e:	89 04 24             	mov    %eax,(%esp,1)
   1cf21:	e8 fc ff ff ff       	call   1cf22 <msk_release+0xd2>
	// state cache and event queue
	msk->refCnt--;
   1cf26:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1cf29:	ff 88 7c 0a 00 00    	decl   0xa7c(%eax)
	BUG_TRAP(msk->refCnt >= 0);
	if(msk->refCnt == 0) {
		// printk("release: refcnt %p\n", msk);
		struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
   1cf2f:	c9                   	leave  
   1cf30:	c3                   	ret    

0001cf31 <list_integrityCheck>:
	struct alloc_head_list *list;
};

static inline void list_link_init(struct list_link *head) {
	head->next = head->prev = NULL;
   1cf31:	55                   	push   %ebp
   1cf32:	89 e5                	mov    %esp,%ebp
   1cf34:	83 ec 20             	sub    $0x20,%esp
	head->list = NULL;
   1cf37:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
}

   1cf3e:	8b 45 08             	mov    0x8(%ebp),%eax
   1cf41:	8b 40 04             	mov    0x4(%eax),%eax
   1cf44:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   1cf47:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1cf4a:	3b 45 08             	cmp    0x8(%ebp),%eax
   1cf4d:	75 02                	jne    1cf51 <list_integrityCheck+0x20>
   1cf4f:	eb 50                	jmp    1cfa1 <list_integrityCheck+0x70>
static inline int list_integrityCheck(struct alloc_head_list *list) {
   1cf51:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1cf54:	8b 40 08             	mov    0x8(%eax),%eax
   1cf57:	3b 45 08             	cmp    0x8(%ebp),%eax
   1cf5a:	74 35                	je     1cf91 <list_integrityCheck+0x60>
   1cf5c:	c7 44 24 10 79 00 00 	movl   $0x79,0x10(%esp,1)
   1cf63:	00 
   1cf64:	c7 44 24 0c 53 77 00 	movl   $0x7753,0xc(%esp,1)
   1cf6b:	00 
   1cf6c:	c7 44 24 08 67 77 00 	movl   $0x7767,0x8(%esp,1)
   1cf73:	00 
   1cf74:	c7 44 24 04 74 77 00 	movl   $0x7774,0x4(%esp,1)
   1cf7b:	00 
   1cf7c:	c7 04 24 b3 73 00 00 	movl   $0x73b3,(%esp,1)
   1cf83:	e8 fc ff ff ff       	call   1cf84 <list_integrityCheck+0x53>
   1cf88:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
   1cf8f:	eb 57                	jmp    1cfe8 <list_integrityCheck+0xb7>
	int count = 0;
   1cf91:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
   1cf94:	ff 00                	incl   (%eax)
   1cf96:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1cf99:	8b 40 04             	mov    0x4(%eax),%eax
   1cf9c:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   1cf9f:	eb a6                	jmp    1cf47 <list_integrityCheck+0x16>
	struct alloc_head *elem;
	alloc_head_walk(list, elem) {
   1cfa1:	8b 55 08             	mov    0x8(%ebp),%edx
   1cfa4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1cfa7:	3b 42 10             	cmp    0x10(%edx),%eax
   1cfaa:	74 35                	je     1cfe1 <list_integrityCheck+0xb0>
   1cfac:	c7 44 24 10 7c 00 00 	movl   $0x7c,0x10(%esp,1)
   1cfb3:	00 
   1cfb4:	c7 44 24 0c 53 77 00 	movl   $0x7753,0xc(%esp,1)
   1cfbb:	00 
   1cfbc:	c7 44 24 08 67 77 00 	movl   $0x7767,0x8(%esp,1)
   1cfc3:	00 
   1cfc4:	c7 44 24 04 87 77 00 	movl   $0x7787,0x4(%esp,1)
   1cfcb:	00 
   1cfcc:	c7 04 24 b3 73 00 00 	movl   $0x73b3,(%esp,1)
   1cfd3:	e8 fc ff ff ff       	call   1cfd4 <list_integrityCheck+0xa3>
   1cfd8:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
   1cfdf:	eb 07                	jmp    1cfe8 <list_integrityCheck+0xb7>
		ASSERT_OR_RETURN(elem->list == list);
   1cfe1:	c7 45 f4 01 00 00 00 	movl   $0x1,0xfffffff4(%ebp)
		count++;
   1cfe8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1cfeb:	c9                   	leave  
   1cfec:	c3                   	ret    

0001cfed <cminisock_evict>:
   1cfed:	55                   	push   %ebp
   1cfee:	89 e5                	mov    %esp,%ebp
   1cff0:	83 ec 08             	sub    $0x8,%esp
   1cff3:	8b 45 08             	mov    0x8(%ebp),%eax
   1cff6:	83 38 00             	cmpl   $0x0,(%eax)
   1cff9:	75 25                	jne    1d020 <cminisock_evict+0x33>
   1cffb:	c7 44 24 04 f9 72 00 	movl   $0x72f9,0x4(%esp,1)
   1d002:	00 
   1d003:	c7 04 24 fd 72 00 00 	movl   $0x72fd,(%esp,1)
   1d00a:	e8 fc ff ff ff       	call   1d00b <cminisock_evict+0x1e>
   1d00f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1d016:	e8 fc ff ff ff       	call   1d017 <cminisock_evict+0x2a>
   1d01b:	e8 fc ff ff ff       	call   1d01c <cminisock_evict+0x2f>
   1d020:	8b 45 08             	mov    0x8(%ebp),%eax
   1d023:	8b 00                	mov    (%eax),%eax
   1d025:	83 b8 f0 00 00 00 00 	cmpl   $0x0,0xf0(%eax)
   1d02c:	7f 14                	jg     1d042 <cminisock_evict+0x55>
   1d02e:	c7 44 24 04 4a 00 00 	movl   $0x4a,0x4(%esp,1)
   1d035:	00 
   1d036:	c7 04 24 a0 77 00 00 	movl   $0x77a0,(%esp,1)
   1d03d:	e8 fc ff ff ff       	call   1d03e <cminisock_evict+0x51>
   1d042:	8b 45 08             	mov    0x8(%ebp),%eax
   1d045:	8b 00                	mov    (%eax),%eax
   1d047:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1d04b:	8b 45 08             	mov    0x8(%ebp),%eax
   1d04e:	8b 00                	mov    (%eax),%eax
   1d050:	8b 80 f8 00 00 00    	mov    0xf8(%eax),%eax
   1d056:	89 04 24             	mov    %eax,(%esp,1)
   1d059:	e8 f2 fd ff ff       	call   1ce50 <msk_release>
   1d05e:	8b 45 08             	mov    0x8(%ebp),%eax
   1d061:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1d067:	c9                   	leave  
   1d068:	c3                   	ret    

0001d069 <ParsedCMinisock_unlinkCell>:
   1d069:	55                   	push   %ebp
   1d06a:	89 e5                	mov    %esp,%ebp
   1d06c:	83 ec 08             	sub    $0x8,%esp
   1d06f:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   1d076:	8b 45 08             	mov    0x8(%ebp),%eax
   1d079:	89 04 24             	mov    %eax,(%esp,1)
   1d07c:	e8 7b fd ff ff       	call   1cdfc <unlink>
   1d081:	8b 45 08             	mov    0x8(%ebp),%eax
   1d084:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
   1d088:	74 0e                	je     1d098 <ParsedCMinisock_unlinkCell+0x2f>
   1d08a:	8b 45 08             	mov    0x8(%ebp),%eax
   1d08d:	83 c0 0c             	add    $0xc,%eax
   1d090:	89 04 24             	mov    %eax,(%esp,1)
   1d093:	e8 64 fd ff ff       	call   1cdfc <unlink>
   1d098:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d09b:	ff 88 14 50 00 00    	decl   0x5014(%eax)
   1d0a1:	c9                   	leave  
   1d0a2:	c3                   	ret    

0001d0a3 <ParsedCMinisock_cache_init>:
   1d0a3:	55                   	push   %ebp
   1d0a4:	89 e5                	mov    %esp,%ebp
   1d0a6:	83 ec 0c             	sub    $0xc,%esp
   1d0a9:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   1d0b0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d0b3:	c7 80 14 50 00 00 00 	movl   $0x0,0x5014(%eax)
   1d0ba:	00 00 00 
   1d0bd:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d0c0:	c7 80 18 50 00 00 00 	movl   $0x400,0x5018(%eax)
   1d0c7:	04 00 00 
   1d0ca:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d0cd:	c7 80 1c 50 00 00 00 	movl   $0x400,0x501c(%eax)
   1d0d4:	04 00 00 
   1d0d7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d0da:	c7 80 20 50 00 00 00 	movl   $0x0,0x5020(%eax)
   1d0e1:	00 00 00 
   1d0e4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d0e7:	c7 80 24 50 00 00 00 	movl   $0x0,0x5024(%eax)
   1d0ee:	00 00 00 
   1d0f1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d0f4:	c7 80 28 50 00 00 00 	movl   $0x0,0x5028(%eax)
   1d0fb:	00 00 00 
   1d0fe:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d101:	c7 80 2c 50 00 00 00 	movl   $0x0,0x502c(%eax)
   1d108:	00 00 00 
   1d10b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d10e:	05 00 50 00 00       	add    $0x5000,%eax
   1d113:	89 04 24             	mov    %eax,(%esp,1)
   1d116:	e8 5b 0a 00 00       	call   1db76 <init_head>
   1d11b:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
   1d122:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1d125:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1d128:	3b 82 18 50 00 00    	cmp    0x5018(%edx),%eax
   1d12e:	7c 02                	jl     1d132 <ParsedCMinisock_cache_init+0x8f>
   1d130:	eb 1f                	jmp    1d151 <ParsedCMinisock_cache_init+0xae>
   1d132:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   1d135:	89 d0                	mov    %edx,%eax
   1d137:	c1 e0 02             	shl    $0x2,%eax
   1d13a:	01 d0                	add    %edx,%eax
   1d13c:	c1 e0 02             	shl    $0x2,%eax
   1d13f:	03 45 fc             	add    0xfffffffc(%ebp),%eax
   1d142:	89 04 24             	mov    %eax,(%esp,1)
   1d145:	e8 2c 0a 00 00       	call   1db76 <init_head>
   1d14a:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
   1d14d:	ff 00                	incl   (%eax)
   1d14f:	eb d1                	jmp    1d122 <ParsedCMinisock_cache_init+0x7f>
   1d151:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d154:	05 30 50 00 00       	add    $0x5030,%eax
   1d159:	89 04 24             	mov    %eax,(%esp,1)
   1d15c:	e8 15 0a 00 00       	call   1db76 <init_head>
   1d161:	c9                   	leave  
   1d162:	c3                   	ret    

0001d163 <ParsedCMinisock_cache_destroy>:
   1d163:	55                   	push   %ebp
   1d164:	89 e5                	mov    %esp,%ebp
   1d166:	83 ec 08             	sub    $0x8,%esp
   1d169:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   1d170:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d173:	8b 80 14 50 00 00    	mov    0x5014(%eax),%eax
   1d179:	89 04 24             	mov    %eax,(%esp,1)
   1d17c:	e8 5a f3 ff ff       	call   1c4db <ParsedCMinisock_evict>
   1d181:	c9                   	leave  
   1d182:	c3                   	ret    

0001d183 <ParsedCMinisock_insert_helper>:
   1d183:	55                   	push   %ebp
   1d184:	89 e5                	mov    %esp,%ebp
   1d186:	83 ec 20             	sub    $0x20,%esp
   1d189:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   1d190:	8b 45 08             	mov    0x8(%ebp),%eax
   1d193:	89 04 24             	mov    %eax,(%esp,1)
   1d196:	e8 47 0f 00 00       	call   1e0e2 <cminisock_hash>
   1d19b:	89 c2                	mov    %eax,%edx
   1d19d:	89 d0                	mov    %edx,%eax
   1d19f:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
   1d1a2:	ba 00 00 00 00       	mov    $0x0,%edx
   1d1a7:	f7 b1 18 50 00 00    	divl   0x5018(%ecx)
   1d1ad:	89 d0                	mov    %edx,%eax
   1d1af:	c1 e0 02             	shl    $0x2,%eax
   1d1b2:	01 d0                	add    %edx,%eax
   1d1b4:	c1 e0 02             	shl    $0x2,%eax
   1d1b7:	03 45 fc             	add    0xfffffffc(%ebp),%eax
   1d1ba:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   1d1bd:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
   1d1c4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d1c7:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1d1ca:	8b 80 14 50 00 00    	mov    0x5014(%eax),%eax
   1d1d0:	3b 82 1c 50 00 00    	cmp    0x501c(%edx),%eax
   1d1d6:	75 73                	jne    1d24b <ParsedCMinisock_insert_helper+0xc8>
   1d1d8:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   1d1db:	89 04 24             	mov    %eax,(%esp,1)
   1d1de:	e8 32 f2 ff ff       	call   1c415 <ParsedCMinisock_evictOne>
   1d1e3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d1e6:	ff 80 14 50 00 00    	incl   0x5014(%eax)
   1d1ec:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d1ef:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1d1f2:	8b 80 14 50 00 00    	mov    0x5014(%eax),%eax
   1d1f8:	3b 82 1c 50 00 00    	cmp    0x501c(%edx),%eax
   1d1fe:	74 54                	je     1d254 <ParsedCMinisock_insert_helper+0xd1>
   1d200:	c7 44 24 0c 58 00 00 	movl   $0x58,0xc(%esp,1)
   1d207:	00 
   1d208:	c7 44 24 08 e8 77 00 	movl   $0x77e8,0x8(%esp,1)
   1d20f:	00 
   1d210:	c7 44 24 04 8c 73 00 	movl   $0x738c,0x4(%esp,1)
   1d217:	00 
   1d218:	c7 04 24 ce 73 00 00 	movl   $0x73ce,(%esp,1)
   1d21f:	e8 fc ff ff ff       	call   1d220 <ParsedCMinisock_insert_helper+0x9d>
   1d224:	c7 44 24 04 f9 72 00 	movl   $0x72f9,0x4(%esp,1)
   1d22b:	00 
   1d22c:	c7 04 24 fd 72 00 00 	movl   $0x72fd,(%esp,1)
   1d233:	e8 fc ff ff ff       	call   1d234 <ParsedCMinisock_insert_helper+0xb1>
   1d238:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1d23f:	e8 fc ff ff ff       	call   1d240 <ParsedCMinisock_insert_helper+0xbd>
   1d244:	e8 fc ff ff ff       	call   1d245 <ParsedCMinisock_insert_helper+0xc2>
   1d249:	eb 09                	jmp    1d254 <ParsedCMinisock_insert_helper+0xd1>
   1d24b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d24e:	ff 80 14 50 00 00    	incl   0x5014(%eax)
   1d254:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
   1d258:	75 08                	jne    1d262 <ParsedCMinisock_insert_helper+0xdf>
   1d25a:	e8 d2 f2 ff ff       	call   1c531 <ParsedCMinisock_newCell>
   1d25f:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1d262:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1d265:	89 04 24             	mov    %eax,(%esp,1)
   1d268:	e8 53 0e 00 00       	call   1e0c0 <list_link_init>
   1d26d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1d270:	83 c0 0c             	add    $0xc,%eax
   1d273:	89 04 24             	mov    %eax,(%esp,1)
   1d276:	e8 45 0e 00 00       	call   1e0c0 <list_link_init>
   1d27b:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1d27e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1d282:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1d285:	89 04 24             	mov    %eax,(%esp,1)
   1d288:	e8 0f 09 00 00       	call   1db9c <insert_head>
   1d28d:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1d290:	83 c0 0c             	add    $0xc,%eax
   1d293:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1d297:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d29a:	05 00 50 00 00       	add    $0x5000,%eax
   1d29f:	89 04 24             	mov    %eax,(%esp,1)
   1d2a2:	e8 70 09 00 00       	call   1dc17 <insert_tail>
   1d2a7:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   1d2aa:	8b 45 08             	mov    0x8(%ebp),%eax
   1d2ad:	8b 00                	mov    (%eax),%eax
   1d2af:	89 42 24             	mov    %eax,0x24(%edx)
   1d2b2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1d2b5:	c9                   	leave  
   1d2b6:	c3                   	ret    

0001d2b7 <ParsedCMinisock_find_helper>:
   1d2b7:	55                   	push   %ebp
   1d2b8:	89 e5                	mov    %esp,%ebp
   1d2ba:	83 ec 1c             	sub    $0x1c,%esp
   1d2bd:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   1d2c4:	8b 45 08             	mov    0x8(%ebp),%eax
   1d2c7:	89 04 24             	mov    %eax,(%esp,1)
   1d2ca:	e8 13 0e 00 00       	call   1e0e2 <cminisock_hash>
   1d2cf:	89 c2                	mov    %eax,%edx
   1d2d1:	89 d0                	mov    %edx,%eax
   1d2d3:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
   1d2d6:	ba 00 00 00 00       	mov    $0x0,%edx
   1d2db:	f7 b1 18 50 00 00    	divl   0x5018(%ecx)
   1d2e1:	89 d0                	mov    %edx,%eax
   1d2e3:	c1 e0 02             	shl    $0x2,%eax
   1d2e6:	01 d0                	add    %edx,%eax
   1d2e8:	c1 e0 02             	shl    $0x2,%eax
   1d2eb:	03 45 fc             	add    0xfffffffc(%ebp),%eax
   1d2ee:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   1d2f1:	8b 45 08             	mov    0x8(%ebp),%eax
   1d2f4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1d2f8:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1d2fb:	89 04 24             	mov    %eax,(%esp,1)
   1d2fe:	e8 02 0e 00 00       	call   1e105 <ParsedCMinisock_findLoop>
   1d303:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1d306:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
   1d30a:	74 08                	je     1d314 <ParsedCMinisock_find_helper+0x5d>
   1d30c:	8b 55 0c             	mov    0xc(%ebp),%edx
   1d30f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1d312:	89 02                	mov    %eax,(%edx)
   1d314:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
   1d318:	0f 95 c0             	setne  %al
   1d31b:	0f b6 c0             	movzbl %al,%eax
   1d31e:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1d321:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
   1d325:	74 09                	je     1d330 <ParsedCMinisock_find_helper+0x79>
   1d327:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d32a:	ff 80 20 50 00 00    	incl   0x5020(%eax)
   1d330:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d333:	ff 80 24 50 00 00    	incl   0x5024(%eax)
   1d339:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1d33c:	c9                   	leave  
   1d33d:	c3                   	ret    

0001d33e <ParsedCMinisock_deleteCell>:
   1d33e:	55                   	push   %ebp
   1d33f:	89 e5                	mov    %esp,%ebp
   1d341:	83 ec 04             	sub    $0x4,%esp
   1d344:	8b 45 08             	mov    0x8(%ebp),%eax
   1d347:	89 04 24             	mov    %eax,(%esp,1)
   1d34a:	e8 1a fd ff ff       	call   1d069 <ParsedCMinisock_unlinkCell>
   1d34f:	8b 45 08             	mov    0x8(%ebp),%eax
   1d352:	89 04 24             	mov    %eax,(%esp,1)
   1d355:	e8 2c f2 ff ff       	call   1c586 <ParsedCMinisock_freeCell>
   1d35a:	c9                   	leave  
   1d35b:	c3                   	ret    

0001d35c <seqnoToKey>:
   1d35c:	55                   	push   %ebp
   1d35d:	89 e5                	mov    %esp,%ebp
   1d35f:	83 ec 04             	sub    $0x4,%esp
   1d362:	8b 45 08             	mov    0x8(%ebp),%eax
   1d365:	89 04 24             	mov    %eax,(%esp,1)
   1d368:	e8 fc ff ff ff       	call   1d369 <seqnoToKey+0xd>
   1d36d:	c9                   	leave  
   1d36e:	c3                   	ret    

0001d36f <CachedWireContinuation_evict>:
   1d36f:	55                   	push   %ebp
   1d370:	89 e5                	mov    %esp,%ebp
   1d372:	5d                   	pop    %ebp
   1d373:	c3                   	ret    

0001d374 <nonce_hash>:
   1d374:	55                   	push   %ebp
   1d375:	89 e5                	mov    %esp,%ebp
   1d377:	83 ec 0c             	sub    $0xc,%esp
   1d37a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
   1d381:	00 
   1d382:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp,1)
   1d389:	00 
   1d38a:	8b 45 08             	mov    0x8(%ebp),%eax
   1d38d:	89 04 24             	mov    %eax,(%esp,1)
   1d390:	e8 40 0a 00 00       	call   1ddd5 <hash>
   1d395:	c9                   	leave  
   1d396:	c3                   	ret    

0001d397 <nonce_evict>:
   1d397:	55                   	push   %ebp
   1d398:	89 e5                	mov    %esp,%ebp
   1d39a:	5d                   	pop    %ebp
   1d39b:	c3                   	ret    

0001d39c <Continuation_unlinkCell>:
   1d39c:	55                   	push   %ebp
   1d39d:	89 e5                	mov    %esp,%ebp
   1d39f:	83 ec 08             	sub    $0x8,%esp
   1d3a2:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   1d3a9:	8b 45 08             	mov    0x8(%ebp),%eax
   1d3ac:	89 04 24             	mov    %eax,(%esp,1)
   1d3af:	e8 48 fa ff ff       	call   1cdfc <unlink>
   1d3b4:	8b 45 08             	mov    0x8(%ebp),%eax
   1d3b7:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
   1d3bb:	74 0e                	je     1d3cb <Continuation_unlinkCell+0x2f>
   1d3bd:	8b 45 08             	mov    0x8(%ebp),%eax
   1d3c0:	83 c0 0c             	add    $0xc,%eax
   1d3c3:	89 04 24             	mov    %eax,(%esp,1)
   1d3c6:	e8 31 fa ff ff       	call   1cdfc <unlink>
   1d3cb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d3ce:	ff 88 14 50 00 00    	decl   0x5014(%eax)
   1d3d4:	c9                   	leave  
   1d3d5:	c3                   	ret    

0001d3d6 <Continuation_cache_init>:
   1d3d6:	55                   	push   %ebp
   1d3d7:	89 e5                	mov    %esp,%ebp
   1d3d9:	83 ec 0c             	sub    $0xc,%esp
   1d3dc:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   1d3e3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d3e6:	c7 80 14 50 00 00 00 	movl   $0x0,0x5014(%eax)
   1d3ed:	00 00 00 
   1d3f0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d3f3:	c7 80 18 50 00 00 00 	movl   $0x400,0x5018(%eax)
   1d3fa:	04 00 00 
   1d3fd:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d400:	c7 80 1c 50 00 00 00 	movl   $0x400,0x501c(%eax)
   1d407:	04 00 00 
   1d40a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d40d:	c7 80 20 50 00 00 00 	movl   $0x0,0x5020(%eax)
   1d414:	00 00 00 
   1d417:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d41a:	c7 80 24 50 00 00 00 	movl   $0x0,0x5024(%eax)
   1d421:	00 00 00 
   1d424:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d427:	c7 80 28 50 00 00 00 	movl   $0x0,0x5028(%eax)
   1d42e:	00 00 00 
   1d431:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d434:	c7 80 2c 50 00 00 00 	movl   $0x0,0x502c(%eax)
   1d43b:	00 00 00 
   1d43e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d441:	05 00 50 00 00       	add    $0x5000,%eax
   1d446:	89 04 24             	mov    %eax,(%esp,1)
   1d449:	e8 28 07 00 00       	call   1db76 <init_head>
   1d44e:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
   1d455:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1d458:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1d45b:	3b 82 18 50 00 00    	cmp    0x5018(%edx),%eax
   1d461:	7c 02                	jl     1d465 <Continuation_cache_init+0x8f>
   1d463:	eb 1f                	jmp    1d484 <Continuation_cache_init+0xae>
   1d465:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   1d468:	89 d0                	mov    %edx,%eax
   1d46a:	c1 e0 02             	shl    $0x2,%eax
   1d46d:	01 d0                	add    %edx,%eax
   1d46f:	c1 e0 02             	shl    $0x2,%eax
   1d472:	03 45 fc             	add    0xfffffffc(%ebp),%eax
   1d475:	89 04 24             	mov    %eax,(%esp,1)
   1d478:	e8 f9 06 00 00       	call   1db76 <init_head>
   1d47d:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
   1d480:	ff 00                	incl   (%eax)
   1d482:	eb d1                	jmp    1d455 <Continuation_cache_init+0x7f>
   1d484:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d487:	05 30 50 00 00       	add    $0x5030,%eax
   1d48c:	89 04 24             	mov    %eax,(%esp,1)
   1d48f:	e8 e2 06 00 00       	call   1db76 <init_head>
   1d494:	c9                   	leave  
   1d495:	c3                   	ret    

0001d496 <Continuation_cache_destroy>:
   1d496:	55                   	push   %ebp
   1d497:	89 e5                	mov    %esp,%ebp
   1d499:	83 ec 08             	sub    $0x8,%esp
   1d49c:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   1d4a3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d4a6:	8b 80 14 50 00 00    	mov    0x5014(%eax),%eax
   1d4ac:	89 04 24             	mov    %eax,(%esp,1)
   1d4af:	e8 a2 f2 ff ff       	call   1c756 <Continuation_evict>
   1d4b4:	c9                   	leave  
   1d4b5:	c3                   	ret    

0001d4b6 <Continuation_insert_helper>:
   1d4b6:	55                   	push   %ebp
   1d4b7:	89 e5                	mov    %esp,%ebp
   1d4b9:	83 ec 20             	sub    $0x20,%esp
   1d4bc:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   1d4c3:	8b 45 08             	mov    0x8(%ebp),%eax
   1d4c6:	89 04 24             	mov    %eax,(%esp,1)
   1d4c9:	e8 a0 0c 00 00       	call   1e16e <CachedWireContinuation_hash>
   1d4ce:	89 c2                	mov    %eax,%edx
   1d4d0:	89 d0                	mov    %edx,%eax
   1d4d2:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
   1d4d5:	ba 00 00 00 00       	mov    $0x0,%edx
   1d4da:	f7 b1 18 50 00 00    	divl   0x5018(%ecx)
   1d4e0:	89 d0                	mov    %edx,%eax
   1d4e2:	c1 e0 02             	shl    $0x2,%eax
   1d4e5:	01 d0                	add    %edx,%eax
   1d4e7:	c1 e0 02             	shl    $0x2,%eax
   1d4ea:	03 45 fc             	add    0xfffffffc(%ebp),%eax
   1d4ed:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   1d4f0:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
   1d4f7:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d4fa:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1d4fd:	8b 80 14 50 00 00    	mov    0x5014(%eax),%eax
   1d503:	3b 82 1c 50 00 00    	cmp    0x501c(%edx),%eax
   1d509:	75 73                	jne    1d57e <Continuation_insert_helper+0xc8>
   1d50b:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
   1d50e:	89 04 24             	mov    %eax,(%esp,1)
   1d511:	e8 7a f1 ff ff       	call   1c690 <Continuation_evictOne>
   1d516:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d519:	ff 80 14 50 00 00    	incl   0x5014(%eax)
   1d51f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d522:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1d525:	8b 80 14 50 00 00    	mov    0x5014(%eax),%eax
   1d52b:	3b 82 1c 50 00 00    	cmp    0x501c(%edx),%eax
   1d531:	74 54                	je     1d587 <Continuation_insert_helper+0xd1>
   1d533:	c7 44 24 0c d5 00 00 	movl   $0xd5,0xc(%esp,1)
   1d53a:	00 
   1d53b:	c7 44 24 08 06 78 00 	movl   $0x7806,0x8(%esp,1)
   1d542:	00 
   1d543:	c7 44 24 04 8c 73 00 	movl   $0x738c,0x4(%esp,1)
   1d54a:	00 
   1d54b:	c7 04 24 ce 73 00 00 	movl   $0x73ce,(%esp,1)
   1d552:	e8 fc ff ff ff       	call   1d553 <Continuation_insert_helper+0x9d>
   1d557:	c7 44 24 04 f9 72 00 	movl   $0x72f9,0x4(%esp,1)
   1d55e:	00 
   1d55f:	c7 04 24 fd 72 00 00 	movl   $0x72fd,(%esp,1)
   1d566:	e8 fc ff ff ff       	call   1d567 <Continuation_insert_helper+0xb1>
   1d56b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1d572:	e8 fc ff ff ff       	call   1d573 <Continuation_insert_helper+0xbd>
   1d577:	e8 fc ff ff ff       	call   1d578 <Continuation_insert_helper+0xc2>
   1d57c:	eb 09                	jmp    1d587 <Continuation_insert_helper+0xd1>
   1d57e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d581:	ff 80 14 50 00 00    	incl   0x5014(%eax)
   1d587:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
   1d58b:	75 08                	jne    1d595 <Continuation_insert_helper+0xdf>
   1d58d:	e8 1a f2 ff ff       	call   1c7ac <Continuation_newCell>
   1d592:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1d595:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1d598:	89 04 24             	mov    %eax,(%esp,1)
   1d59b:	e8 20 0b 00 00       	call   1e0c0 <list_link_init>
   1d5a0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1d5a3:	83 c0 0c             	add    $0xc,%eax
   1d5a6:	89 04 24             	mov    %eax,(%esp,1)
   1d5a9:	e8 12 0b 00 00       	call   1e0c0 <list_link_init>
   1d5ae:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1d5b1:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1d5b5:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1d5b8:	89 04 24             	mov    %eax,(%esp,1)
   1d5bb:	e8 dc 05 00 00       	call   1db9c <insert_head>
   1d5c0:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1d5c3:	83 c0 0c             	add    $0xc,%eax
   1d5c6:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1d5ca:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d5cd:	05 00 50 00 00       	add    $0x5000,%eax
   1d5d2:	89 04 24             	mov    %eax,(%esp,1)
   1d5d5:	e8 3d 06 00 00       	call   1dc17 <insert_tail>
   1d5da:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   1d5dd:	8b 45 08             	mov    0x8(%ebp),%eax
   1d5e0:	8b 00                	mov    (%eax),%eax
   1d5e2:	89 42 24             	mov    %eax,0x24(%edx)
   1d5e5:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1d5e8:	c9                   	leave  
   1d5e9:	c3                   	ret    

0001d5ea <Continuation_find_helper>:
   1d5ea:	55                   	push   %ebp
   1d5eb:	89 e5                	mov    %esp,%ebp
   1d5ed:	83 ec 1c             	sub    $0x1c,%esp
   1d5f0:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   1d5f7:	8b 45 08             	mov    0x8(%ebp),%eax
   1d5fa:	89 04 24             	mov    %eax,(%esp,1)
   1d5fd:	e8 6c 0b 00 00       	call   1e16e <CachedWireContinuation_hash>
   1d602:	89 c2                	mov    %eax,%edx
   1d604:	89 d0                	mov    %edx,%eax
   1d606:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
   1d609:	ba 00 00 00 00       	mov    $0x0,%edx
   1d60e:	f7 b1 18 50 00 00    	divl   0x5018(%ecx)
   1d614:	89 d0                	mov    %edx,%eax
   1d616:	c1 e0 02             	shl    $0x2,%eax
   1d619:	01 d0                	add    %edx,%eax
   1d61b:	c1 e0 02             	shl    $0x2,%eax
   1d61e:	03 45 fc             	add    0xfffffffc(%ebp),%eax
   1d621:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   1d624:	8b 45 08             	mov    0x8(%ebp),%eax
   1d627:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1d62b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1d62e:	89 04 24             	mov    %eax,(%esp,1)
   1d631:	e8 5b 0b 00 00       	call   1e191 <Continuation_findLoop>
   1d636:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1d639:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
   1d63d:	74 08                	je     1d647 <Continuation_find_helper+0x5d>
   1d63f:	8b 55 0c             	mov    0xc(%ebp),%edx
   1d642:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1d645:	89 02                	mov    %eax,(%edx)
   1d647:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
   1d64b:	0f 95 c0             	setne  %al
   1d64e:	0f b6 c0             	movzbl %al,%eax
   1d651:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1d654:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
   1d658:	74 09                	je     1d663 <Continuation_find_helper+0x79>
   1d65a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d65d:	ff 80 20 50 00 00    	incl   0x5020(%eax)
   1d663:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d666:	ff 80 24 50 00 00    	incl   0x5024(%eax)
   1d66c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1d66f:	c9                   	leave  
   1d670:	c3                   	ret    

0001d671 <Continuation_deleteCell>:
   1d671:	55                   	push   %ebp
   1d672:	89 e5                	mov    %esp,%ebp
   1d674:	83 ec 04             	sub    $0x4,%esp
   1d677:	8b 45 08             	mov    0x8(%ebp),%eax
   1d67a:	89 04 24             	mov    %eax,(%esp,1)
   1d67d:	e8 1a fd ff ff       	call   1d39c <Continuation_unlinkCell>
   1d682:	8b 45 08             	mov    0x8(%ebp),%eax
   1d685:	89 04 24             	mov    %eax,(%esp,1)
   1d688:	e8 74 f1 ff ff       	call   1c801 <Continuation_freeCell>
   1d68d:	c9                   	leave  
   1d68e:	c3                   	ret    

0001d68f <NonceKey_unlinkCell>:
   1d68f:	55                   	push   %ebp
   1d690:	89 e5                	mov    %esp,%ebp
   1d692:	83 ec 08             	sub    $0x8,%esp
   1d695:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   1d69c:	8b 45 08             	mov    0x8(%ebp),%eax
   1d69f:	89 04 24             	mov    %eax,(%esp,1)
   1d6a2:	e8 55 f7 ff ff       	call   1cdfc <unlink>
   1d6a7:	8b 45 08             	mov    0x8(%ebp),%eax
   1d6aa:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
   1d6ae:	74 0e                	je     1d6be <NonceKey_unlinkCell+0x2f>
   1d6b0:	8b 45 08             	mov    0x8(%ebp),%eax
   1d6b3:	83 c0 0c             	add    $0xc,%eax
   1d6b6:	89 04 24             	mov    %eax,(%esp,1)
   1d6b9:	e8 3e f7 ff ff       	call   1cdfc <unlink>
   1d6be:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d6c1:	ff 88 94 02 00 00    	decl   0x294(%eax)
   1d6c7:	c9                   	leave  
   1d6c8:	c3                   	ret    

0001d6c9 <NonceKey_cache_init>:
   1d6c9:	55                   	push   %ebp
   1d6ca:	89 e5                	mov    %esp,%ebp
   1d6cc:	83 ec 18             	sub    $0x18,%esp
   1d6cf:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   1d6d6:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d6d9:	c7 80 94 02 00 00 00 	movl   $0x0,0x294(%eax)
   1d6e0:	00 00 00 
   1d6e3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d6e6:	c7 80 98 02 00 00 20 	movl   $0x20,0x298(%eax)
   1d6ed:	00 00 00 
   1d6f0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d6f3:	c7 80 9c 02 00 00 64 	movl   $0x64,0x29c(%eax)
   1d6fa:	00 00 00 
   1d6fd:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d700:	c7 80 a0 02 00 00 00 	movl   $0x0,0x2a0(%eax)
   1d707:	00 00 00 
   1d70a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d70d:	c7 80 a4 02 00 00 00 	movl   $0x0,0x2a4(%eax)
   1d714:	00 00 00 
   1d717:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d71a:	c7 80 a8 02 00 00 00 	movl   $0x0,0x2a8(%eax)
   1d721:	00 00 00 
   1d724:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d727:	c7 80 ac 02 00 00 00 	movl   $0x0,0x2ac(%eax)
   1d72e:	00 00 00 
   1d731:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d734:	05 80 02 00 00       	add    $0x280,%eax
   1d739:	89 04 24             	mov    %eax,(%esp,1)
   1d73c:	e8 35 04 00 00       	call   1db76 <init_head>
   1d741:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
   1d748:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1d74b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1d74e:	3b 82 98 02 00 00    	cmp    0x298(%edx),%eax
   1d754:	7c 02                	jl     1d758 <NonceKey_cache_init+0x8f>
   1d756:	eb 1f                	jmp    1d777 <NonceKey_cache_init+0xae>
   1d758:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   1d75b:	89 d0                	mov    %edx,%eax
   1d75d:	c1 e0 02             	shl    $0x2,%eax
   1d760:	01 d0                	add    %edx,%eax
   1d762:	c1 e0 02             	shl    $0x2,%eax
   1d765:	03 45 fc             	add    0xfffffffc(%ebp),%eax
   1d768:	89 04 24             	mov    %eax,(%esp,1)
   1d76b:	e8 06 04 00 00       	call   1db76 <init_head>
   1d770:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
   1d773:	ff 00                	incl   (%eax)
   1d775:	eb d1                	jmp    1d748 <NonceKey_cache_init+0x7f>
   1d777:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d77a:	05 b0 02 00 00       	add    $0x2b0,%eax
   1d77f:	89 04 24             	mov    %eax,(%esp,1)
   1d782:	e8 ef 03 00 00       	call   1db76 <init_head>
   1d787:	c9                   	leave  
   1d788:	c3                   	ret    

0001d789 <NonceKey_cache_destroy>:
   1d789:	55                   	push   %ebp
   1d78a:	89 e5                	mov    %esp,%ebp
   1d78c:	83 ec 08             	sub    $0x8,%esp
   1d78f:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   1d796:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1d799:	8b 80 94 02 00 00    	mov    0x294(%eax),%eax
   1d79f:	89 04 24             	mov    %eax,(%esp,1)
   1d7a2:	e8 47 f4 ff ff       	call   1cbee <NonceKey_evict>
   1d7a7:	c9                   	leave  
   1d7a8:	c3                   	ret    

0001d7a9 <WireContinuation_copyIn>:
   1d7a9:	55                   	push   %ebp
   1d7aa:	89 e5                	mov    %esp,%ebp
   1d7ac:	83 ec 10             	sub    $0x10,%esp
   1d7af:	8b 45 08             	mov    0x8(%ebp),%eax
   1d7b2:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   1d7b5:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1d7b8:	8b 45 0c             	mov    0xc(%ebp),%eax
   1d7bb:	8b 40 01             	mov    0x1(%eax),%eax
   1d7be:	89 02                	mov    %eax,(%edx)
   1d7c0:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1d7c3:	8b 45 0c             	mov    0xc(%ebp),%eax
   1d7c6:	0f b6 00             	movzbl (%eax),%eax
   1d7c9:	88 42 04             	mov    %al,0x4(%edx)
   1d7cc:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1d7cf:	8b 45 0c             	mov    0xc(%ebp),%eax
   1d7d2:	80 78 05 00          	cmpb   $0x0,0x5(%eax)
   1d7d6:	0f 95 c0             	setne  %al
   1d7d9:	88 42 05             	mov    %al,0x5(%edx)
   1d7dc:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1d7df:	8b 45 10             	mov    0x10(%ebp),%eax
   1d7e2:	8b 40 14             	mov    0x14(%eax),%eax
   1d7e5:	89 42 06             	mov    %eax,0x6(%edx)
   1d7e8:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1d7eb:	8b 45 10             	mov    0x10(%ebp),%eax
   1d7ee:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
   1d7f2:	66 89 42 0a          	mov    %ax,0xa(%edx)
   1d7f6:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1d7f9:	8b 45 10             	mov    0x10(%ebp),%eax
   1d7fc:	8b 40 18             	mov    0x18(%eax),%eax
   1d7ff:	89 42 0c             	mov    %eax,0xc(%edx)
   1d802:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1d805:	8b 45 10             	mov    0x10(%ebp),%eax
   1d808:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
   1d80c:	66 89 42 10          	mov    %ax,0x10(%edx)
   1d810:	c7 44 24 08 25 00 00 	movl   $0x25,0x8(%esp,1)
   1d817:	00 
   1d818:	8b 45 0c             	mov    0xc(%ebp),%eax
   1d81b:	83 c0 25             	add    $0x25,%eax
   1d81e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1d822:	8b 45 08             	mov    0x8(%ebp),%eax
   1d825:	83 c0 12             	add    $0x12,%eax
   1d828:	89 04 24             	mov    %eax,(%esp,1)
   1d82b:	e8 cf 00 00 00       	call   1d8ff <__constant_memcpy>
   1d830:	c9                   	leave  
   1d831:	c3                   	ret    

0001d832 <WireContinuation_checkAndCopyOut>:
   1d832:	55                   	push   %ebp
   1d833:	89 e5                	mov    %esp,%ebp
   1d835:	53                   	push   %ebx
   1d836:	83 ec 14             	sub    $0x14,%esp
   1d839:	8b 45 0c             	mov    0xc(%ebp),%eax
   1d83c:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   1d83f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1d842:	8b 55 08             	mov    0x8(%ebp),%edx
   1d845:	8b 00                	mov    (%eax),%eax
   1d847:	3b 42 01             	cmp    0x1(%edx),%eax
   1d84a:	0f 85 9f 00 00 00    	jne    1d8ef <WireContinuation_checkAndCopyOut+0xbd>
   1d850:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1d853:	8b 55 08             	mov    0x8(%ebp),%edx
   1d856:	0f b6 40 04          	movzbl 0x4(%eax),%eax
   1d85a:	3a 02                	cmp    (%edx),%al
   1d85c:	0f 85 8d 00 00 00    	jne    1d8ef <WireContinuation_checkAndCopyOut+0xbd>
   1d862:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1d865:	8b 55 08             	mov    0x8(%ebp),%edx
   1d868:	0f b6 40 05          	movzbl 0x5(%eax),%eax
   1d86c:	3a 42 05             	cmp    0x5(%edx),%al
   1d86f:	75 7e                	jne    1d8ef <WireContinuation_checkAndCopyOut+0xbd>
   1d871:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1d874:	8b 55 10             	mov    0x10(%ebp),%edx
   1d877:	8b 40 06             	mov    0x6(%eax),%eax
   1d87a:	3b 42 10             	cmp    0x10(%edx),%eax
   1d87d:	75 70                	jne    1d8ef <WireContinuation_checkAndCopyOut+0xbd>
   1d87f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1d882:	8b 55 14             	mov    0x14(%ebp),%edx
   1d885:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
   1d889:	66 3b 42 02          	cmp    0x2(%edx),%ax
   1d88d:	75 60                	jne    1d8ef <WireContinuation_checkAndCopyOut+0xbd>
   1d88f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1d892:	8b 55 10             	mov    0x10(%ebp),%edx
   1d895:	8b 40 0c             	mov    0xc(%eax),%eax
   1d898:	3b 42 0c             	cmp    0xc(%edx),%eax
   1d89b:	75 52                	jne    1d8ef <WireContinuation_checkAndCopyOut+0xbd>
   1d89d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1d8a0:	8b 55 14             	mov    0x14(%ebp),%edx
   1d8a3:	0f b7 40 10          	movzwl 0x10(%eax),%eax
   1d8a7:	66 3b 02             	cmp    (%edx),%ax
   1d8aa:	75 43                	jne    1d8ef <WireContinuation_checkAndCopyOut+0xbd>
   1d8ac:	8b 45 08             	mov    0x8(%ebp),%eax
   1d8af:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1d8b2:	8b 50 46             	mov    0x46(%eax),%edx
   1d8b5:	8b 40 42             	mov    0x42(%eax),%eax
   1d8b8:	89 d3                	mov    %edx,%ebx
   1d8ba:	33 59 33             	xor    0x33(%ecx),%ebx
   1d8bd:	33 41 2f             	xor    0x2f(%ecx),%eax
   1d8c0:	09 d8                	or     %ebx,%eax
   1d8c2:	85 c0                	test   %eax,%eax
   1d8c4:	75 29                	jne    1d8ef <WireContinuation_checkAndCopyOut+0xbd>
   1d8c6:	c7 44 24 08 25 00 00 	movl   $0x25,0x8(%esp,1)
   1d8cd:	00 
   1d8ce:	8b 45 0c             	mov    0xc(%ebp),%eax
   1d8d1:	83 c0 12             	add    $0x12,%eax
   1d8d4:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1d8d8:	8b 45 08             	mov    0x8(%ebp),%eax
   1d8db:	83 c0 25             	add    $0x25,%eax
   1d8de:	89 04 24             	mov    %eax,(%esp,1)
   1d8e1:	e8 19 00 00 00       	call   1d8ff <__constant_memcpy>
   1d8e6:	c7 45 f4 01 00 00 00 	movl   $0x1,0xfffffff4(%ebp)
   1d8ed:	eb 07                	jmp    1d8f6 <WireContinuation_checkAndCopyOut+0xc4>
   1d8ef:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
   1d8f6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1d8f9:	83 c4 14             	add    $0x14,%esp
   1d8fc:	5b                   	pop    %ebx
   1d8fd:	5d                   	pop    %ebp
   1d8fe:	c3                   	ret    

0001d8ff <__constant_memcpy>:
return __res;
}

static inline void * __memcpy(void * to, const void * from, size_t n)
{
   1d8ff:	55                   	push   %ebp
   1d900:	89 e5                	mov    %esp,%ebp
   1d902:	57                   	push   %edi
   1d903:	56                   	push   %esi
   1d904:	83 ec 14             	sub    $0x14,%esp
int d0, d1, d2;
   1d907:	83 7d 10 14          	cmpl   $0x14,0x10(%ebp)
   1d90b:	0f 87 9e 01 00 00    	ja     1daaf <__constant_memcpy+0x1b0>
   1d911:	8b 45 10             	mov    0x10(%ebp),%eax
   1d914:	c1 e0 02             	shl    $0x2,%eax
   1d917:	8b 80 24 78 00 00    	mov    0x7824(%eax),%eax
   1d91d:	ff e0                	jmp    *%eax
__asm__ __volatile__(
	"rep ; movsl\n\t"
   1d91f:	8b 45 08             	mov    0x8(%ebp),%eax
   1d922:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1d925:	e9 42 02 00 00       	jmp    1db6c <__constant_memcpy+0x26d>
	"testb $2,%b4\n\t"
	"je 1f\n\t"
   1d92a:	8b 55 08             	mov    0x8(%ebp),%edx
   1d92d:	8b 45 0c             	mov    0xc(%ebp),%eax
   1d930:	0f b6 00             	movzbl (%eax),%eax
   1d933:	88 02                	mov    %al,(%edx)
	"movsw\n"
   1d935:	8b 45 08             	mov    0x8(%ebp),%eax
   1d938:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1d93b:	e9 2c 02 00 00       	jmp    1db6c <__constant_memcpy+0x26d>
	"1:\ttestb $1,%b4\n\t"
	"je 2f\n\t"
   1d940:	8b 55 08             	mov    0x8(%ebp),%edx
   1d943:	8b 45 0c             	mov    0xc(%ebp),%eax
   1d946:	0f b7 00             	movzwl (%eax),%eax
   1d949:	66 89 02             	mov    %ax,(%edx)
	"movsb\n"
   1d94c:	8b 45 08             	mov    0x8(%ebp),%eax
   1d94f:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1d952:	e9 15 02 00 00       	jmp    1db6c <__constant_memcpy+0x26d>
	"2:"
	: "=&c" (d0), "=&D" (d1), "=&S" (d2)
   1d957:	8b 55 08             	mov    0x8(%ebp),%edx
   1d95a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1d95d:	0f b7 00             	movzwl (%eax),%eax
   1d960:	66 89 02             	mov    %ax,(%edx)
	:"0" (n/4), "q" (n),"1" ((long) to),"2" ((long) from)
   1d963:	8b 55 08             	mov    0x8(%ebp),%edx
   1d966:	83 c2 02             	add    $0x2,%edx
   1d969:	8b 45 0c             	mov    0xc(%ebp),%eax
   1d96c:	83 c0 02             	add    $0x2,%eax
   1d96f:	0f b6 00             	movzbl (%eax),%eax
   1d972:	88 02                	mov    %al,(%edx)
	: "memory");
   1d974:	8b 45 08             	mov    0x8(%ebp),%eax
   1d977:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1d97a:	e9 ed 01 00 00       	jmp    1db6c <__constant_memcpy+0x26d>
return (to);
}
   1d97f:	8b 55 08             	mov    0x8(%ebp),%edx
   1d982:	8b 45 0c             	mov    0xc(%ebp),%eax
   1d985:	8b 00                	mov    (%eax),%eax
   1d987:	89 02                	mov    %eax,(%edx)

   1d989:	8b 45 08             	mov    0x8(%ebp),%eax
   1d98c:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1d98f:	e9 d8 01 00 00       	jmp    1db6c <__constant_memcpy+0x26d>
/*
 * This looks horribly ugly, but the compiler can optimize it totally,
   1d994:	8b 55 08             	mov    0x8(%ebp),%edx
   1d997:	8b 45 0c             	mov    0xc(%ebp),%eax
   1d99a:	8b 00                	mov    (%eax),%eax
   1d99c:	89 02                	mov    %eax,(%edx)
 * as the count is constant.
   1d99e:	8b 55 08             	mov    0x8(%ebp),%edx
   1d9a1:	83 c2 04             	add    $0x4,%edx
   1d9a4:	8b 45 0c             	mov    0xc(%ebp),%eax
   1d9a7:	83 c0 04             	add    $0x4,%eax
   1d9aa:	0f b7 00             	movzwl (%eax),%eax
   1d9ad:	66 89 02             	mov    %ax,(%edx)
 */
   1d9b0:	8b 45 08             	mov    0x8(%ebp),%eax
   1d9b3:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1d9b6:	e9 b1 01 00 00       	jmp    1db6c <__constant_memcpy+0x26d>
static inline void * __constant_memcpy(void * to, const void * from, size_t n)
{
   1d9bb:	8b 55 08             	mov    0x8(%ebp),%edx
   1d9be:	8b 45 0c             	mov    0xc(%ebp),%eax
   1d9c1:	8b 00                	mov    (%eax),%eax
   1d9c3:	89 02                	mov    %eax,(%edx)
	switch (n) {
   1d9c5:	8b 55 08             	mov    0x8(%ebp),%edx
   1d9c8:	83 c2 04             	add    $0x4,%edx
   1d9cb:	8b 45 0c             	mov    0xc(%ebp),%eax
   1d9ce:	83 c0 04             	add    $0x4,%eax
   1d9d1:	8b 00                	mov    (%eax),%eax
   1d9d3:	89 02                	mov    %eax,(%edx)
		case 0:
   1d9d5:	8b 45 08             	mov    0x8(%ebp),%eax
   1d9d8:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1d9db:	e9 8c 01 00 00       	jmp    1db6c <__constant_memcpy+0x26d>
			return to;
		case 1:
   1d9e0:	8b 55 08             	mov    0x8(%ebp),%edx
   1d9e3:	8b 45 0c             	mov    0xc(%ebp),%eax
   1d9e6:	8b 00                	mov    (%eax),%eax
   1d9e8:	89 02                	mov    %eax,(%edx)
			*(unsigned char *)to = *(const unsigned char *)from;
   1d9ea:	8b 55 08             	mov    0x8(%ebp),%edx
   1d9ed:	83 c2 04             	add    $0x4,%edx
   1d9f0:	8b 45 0c             	mov    0xc(%ebp),%eax
   1d9f3:	83 c0 04             	add    $0x4,%eax
   1d9f6:	8b 00                	mov    (%eax),%eax
   1d9f8:	89 02                	mov    %eax,(%edx)
			return to;
   1d9fa:	8b 55 08             	mov    0x8(%ebp),%edx
   1d9fd:	83 c2 08             	add    $0x8,%edx
   1da00:	8b 45 0c             	mov    0xc(%ebp),%eax
   1da03:	83 c0 08             	add    $0x8,%eax
   1da06:	8b 00                	mov    (%eax),%eax
   1da08:	89 02                	mov    %eax,(%edx)
		case 2:
   1da0a:	8b 45 08             	mov    0x8(%ebp),%eax
   1da0d:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1da10:	e9 57 01 00 00       	jmp    1db6c <__constant_memcpy+0x26d>
			*(unsigned short *)to = *(const unsigned short *)from;
			return to;
   1da15:	8b 55 08             	mov    0x8(%ebp),%edx
   1da18:	8b 45 0c             	mov    0xc(%ebp),%eax
   1da1b:	8b 00                	mov    (%eax),%eax
   1da1d:	89 02                	mov    %eax,(%edx)
		case 3:
   1da1f:	8b 55 08             	mov    0x8(%ebp),%edx
   1da22:	83 c2 04             	add    $0x4,%edx
   1da25:	8b 45 0c             	mov    0xc(%ebp),%eax
   1da28:	83 c0 04             	add    $0x4,%eax
   1da2b:	8b 00                	mov    (%eax),%eax
   1da2d:	89 02                	mov    %eax,(%edx)
			*(unsigned short *)to = *(const unsigned short *)from;
   1da2f:	8b 55 08             	mov    0x8(%ebp),%edx
   1da32:	83 c2 08             	add    $0x8,%edx
   1da35:	8b 45 0c             	mov    0xc(%ebp),%eax
   1da38:	83 c0 08             	add    $0x8,%eax
   1da3b:	8b 00                	mov    (%eax),%eax
   1da3d:	89 02                	mov    %eax,(%edx)
			*(2+(unsigned char *)to) = *(2+(const unsigned char *)from);
   1da3f:	8b 55 08             	mov    0x8(%ebp),%edx
   1da42:	83 c2 0c             	add    $0xc,%edx
   1da45:	8b 45 0c             	mov    0xc(%ebp),%eax
   1da48:	83 c0 0c             	add    $0xc,%eax
   1da4b:	8b 00                	mov    (%eax),%eax
   1da4d:	89 02                	mov    %eax,(%edx)
			return to;
   1da4f:	8b 45 08             	mov    0x8(%ebp),%eax
   1da52:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1da55:	e9 12 01 00 00       	jmp    1db6c <__constant_memcpy+0x26d>
		case 4:
			*(unsigned long *)to = *(const unsigned long *)from;
   1da5a:	8b 55 08             	mov    0x8(%ebp),%edx
   1da5d:	8b 45 0c             	mov    0xc(%ebp),%eax
   1da60:	8b 00                	mov    (%eax),%eax
   1da62:	89 02                	mov    %eax,(%edx)
			return to;
   1da64:	8b 55 08             	mov    0x8(%ebp),%edx
   1da67:	83 c2 04             	add    $0x4,%edx
   1da6a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1da6d:	83 c0 04             	add    $0x4,%eax
   1da70:	8b 00                	mov    (%eax),%eax
   1da72:	89 02                	mov    %eax,(%edx)
		case 6:	/* for Ethernet addresses */
   1da74:	8b 55 08             	mov    0x8(%ebp),%edx
   1da77:	83 c2 08             	add    $0x8,%edx
   1da7a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1da7d:	83 c0 08             	add    $0x8,%eax
   1da80:	8b 00                	mov    (%eax),%eax
   1da82:	89 02                	mov    %eax,(%edx)
			*(unsigned long *)to = *(const unsigned long *)from;
   1da84:	8b 55 08             	mov    0x8(%ebp),%edx
   1da87:	83 c2 0c             	add    $0xc,%edx
   1da8a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1da8d:	83 c0 0c             	add    $0xc,%eax
   1da90:	8b 00                	mov    (%eax),%eax
   1da92:	89 02                	mov    %eax,(%edx)
			*(2+(unsigned short *)to) = *(2+(const unsigned short *)from);
   1da94:	8b 55 08             	mov    0x8(%ebp),%edx
   1da97:	83 c2 10             	add    $0x10,%edx
   1da9a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1da9d:	83 c0 10             	add    $0x10,%eax
   1daa0:	8b 00                	mov    (%eax),%eax
   1daa2:	89 02                	mov    %eax,(%edx)
			return to;
   1daa4:	8b 45 08             	mov    0x8(%ebp),%eax
   1daa7:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1daaa:	e9 bd 00 00 00       	jmp    1db6c <__constant_memcpy+0x26d>
		case 8:
			*(unsigned long *)to = *(const unsigned long *)from;
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
			return to;
   1daaf:	8b 45 10             	mov    0x10(%ebp),%eax
   1dab2:	83 e0 03             	and    $0x3,%eax
   1dab5:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   1dab8:	83 7d e4 01          	cmpl   $0x1,0xffffffe4(%ebp)
   1dabc:	74 35                	je     1daf3 <__constant_memcpy+0x1f4>
   1dabe:	83 7d e4 01          	cmpl   $0x1,0xffffffe4(%ebp)
   1dac2:	72 08                	jb     1dacc <__constant_memcpy+0x1cd>
   1dac4:	83 7d e4 02          	cmpl   $0x2,0xffffffe4(%ebp)
   1dac8:	74 51                	je     1db1b <__constant_memcpy+0x21c>
   1daca:	eb 78                	jmp    1db44 <__constant_memcpy+0x245>
		case 12:
   1dacc:	8b 45 10             	mov    0x10(%ebp),%eax
   1dacf:	89 c1                	mov    %eax,%ecx
   1dad1:	c1 e9 02             	shr    $0x2,%ecx
   1dad4:	8b 7d 08             	mov    0x8(%ebp),%edi
   1dad7:	8b 75 0c             	mov    0xc(%ebp),%esi
   1dada:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   1dadc:	89 c8                	mov    %ecx,%eax
   1dade:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1dae1:	89 f8                	mov    %edi,%eax
   1dae3:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1dae6:	89 f0                	mov    %esi,%eax
   1dae8:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1daeb:	8b 45 08             	mov    0x8(%ebp),%eax
   1daee:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1daf1:	eb 79                	jmp    1db6c <__constant_memcpy+0x26d>
			*(unsigned long *)to = *(const unsigned long *)from;
   1daf3:	8b 45 10             	mov    0x10(%ebp),%eax
   1daf6:	89 c1                	mov    %eax,%ecx
   1daf8:	c1 e9 02             	shr    $0x2,%ecx
   1dafb:	8b 7d 08             	mov    0x8(%ebp),%edi
   1dafe:	8b 75 0c             	mov    0xc(%ebp),%esi
   1db01:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   1db03:	a4                   	movsb  %ds:(%esi),%es:(%edi)
   1db04:	89 c8                	mov    %ecx,%eax
   1db06:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1db09:	89 f8                	mov    %edi,%eax
   1db0b:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1db0e:	89 f0                	mov    %esi,%eax
   1db10:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1db13:	8b 45 08             	mov    0x8(%ebp),%eax
   1db16:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1db19:	eb 51                	jmp    1db6c <__constant_memcpy+0x26d>
			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
   1db1b:	8b 45 10             	mov    0x10(%ebp),%eax
   1db1e:	89 c1                	mov    %eax,%ecx
   1db20:	c1 e9 02             	shr    $0x2,%ecx
   1db23:	8b 7d 08             	mov    0x8(%ebp),%edi
   1db26:	8b 75 0c             	mov    0xc(%ebp),%esi
   1db29:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   1db2b:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
   1db2d:	89 c8                	mov    %ecx,%eax
   1db2f:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1db32:	89 f8                	mov    %edi,%eax
   1db34:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1db37:	89 f0                	mov    %esi,%eax
   1db39:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1db3c:	8b 45 08             	mov    0x8(%ebp),%eax
   1db3f:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   1db42:	eb 28                	jmp    1db6c <__constant_memcpy+0x26d>
			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
   1db44:	8b 45 10             	mov    0x10(%ebp),%eax
   1db47:	89 c1                	mov    %eax,%ecx
   1db49:	c1 e9 02             	shr    $0x2,%ecx
   1db4c:	8b 7d 08             	mov    0x8(%ebp),%edi
   1db4f:	8b 75 0c             	mov    0xc(%ebp),%esi
   1db52:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
   1db54:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
   1db56:	a4                   	movsb  %ds:(%esi),%es:(%edi)
   1db57:	89 c8                	mov    %ecx,%eax
   1db59:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1db5c:	89 f8                	mov    %edi,%eax
   1db5e:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   1db61:	89 f0                	mov    %esi,%eax
   1db63:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   1db66:	8b 45 08             	mov    0x8(%ebp),%eax
   1db69:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
			return to;
		case 16:
			*(unsigned long *)to = *(const unsigned long *)from;
   1db6c:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
   1db6f:	83 c4 14             	add    $0x14,%esp
   1db72:	5e                   	pop    %esi
   1db73:	5f                   	pop    %edi
   1db74:	5d                   	pop    %ebp
   1db75:	c3                   	ret    

0001db76 <init_head>:
	kfree(vec->elems);
	kfree(vec);
}
static inline void vector_append(struct vector *vec, void *newElem) {
	if(vec->num == vec->size) {
   1db76:	55                   	push   %ebp
   1db77:	89 e5                	mov    %esp,%ebp
		void **newElems;
   1db79:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1db7c:	8b 55 08             	mov    0x8(%ebp),%edx
   1db7f:	8b 45 08             	mov    0x8(%ebp),%eax
   1db82:	89 02                	mov    %eax,(%edx)
   1db84:	89 41 04             	mov    %eax,0x4(%ecx)
		vec->size *= 2;
   1db87:	8b 55 08             	mov    0x8(%ebp),%edx
   1db8a:	8b 45 08             	mov    0x8(%ebp),%eax
   1db8d:	89 42 08             	mov    %eax,0x8(%edx)
		newElems = kmalloc(vec->size * sizeof(newElems[0]), GFP_ATOMIC);
   1db90:	8b 45 08             	mov    0x8(%ebp),%eax
   1db93:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		if(newElems == NULL) {
   1db9a:	5d                   	pop    %ebp
   1db9b:	c3                   	ret    

0001db9c <insert_head>:
			printk("Not enough memory while resizing vector\n");
			// TODO: Throw proper exception
			BUG();
			return;
		}
	}
	vec->elems[vec->num++] = newElem;
}

#endif // __KERNEL__

#ifdef __KERNEL__
#define VALID_MSK_CTL(X) ((X)->ctl == ALLOC_READY || \
                          (X)->ctl == ALLOC_HALFFREE)

static inline int empty(struct alloc_head_list *head) {
	return head->next == (struct alloc_head*)head;
}

static inline void init_head(struct alloc_head_list *head) {
	head->next = head->prev = (struct alloc_head*)head;
	head->list = head;
	head->len = 0;
}

#if 0
static inline void unlink_head(struct alloc_head_list *head) {
	struct alloc_head *prev = head->prev;
	head->prev->next = head->next;
	head->next->prev = head->prev;
	head->next = head->prev = NULL;
	if(prev->next == prev && prev->prev != prev) {
		BUG();
		show_stack(NULL);
	}
	head->len--;
}
#endif

//#define DEBUG_LIST

static inline void insert_head(struct alloc_head_list *head, struct alloc_head *elem) {
   1db9c:	55                   	push   %ebp
   1db9d:	89 e5                	mov    %esp,%ebp
   1db9f:	83 ec 08             	sub    $0x8,%esp
#ifdef DEBUG_LIST
   1dba2:	8b 45 08             	mov    0x8(%ebp),%eax
   1dba5:	8b 40 04             	mov    0x4(%eax),%eax
   1dba8:	3b 45 0c             	cmp    0xc(%ebp),%eax
   1dbab:	75 31                	jne    1dbde <insert_head+0x42>
	if(elem->list) {
   1dbad:	c7 44 24 04 f9 72 00 	movl   $0x72f9,0x4(%esp,1)
   1dbb4:	00 
   1dbb5:	c7 04 24 fd 72 00 00 	movl   $0x72fd,(%esp,1)
   1dbbc:	e8 fc ff ff ff       	call   1dbbd <insert_head+0x21>
   1dbc1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1dbc8:	e8 fc ff ff ff       	call   1dbc9 <insert_head+0x2d>
   1dbcd:	e8 fc ff ff ff       	call   1dbce <insert_head+0x32>
		BUG();
   1dbd2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1dbd9:	e8 fc ff ff ff       	call   1dbda <insert_head+0x3e>
	}
#endif
   1dbde:	8b 55 0c             	mov    0xc(%ebp),%edx
   1dbe1:	8b 45 08             	mov    0x8(%ebp),%eax
   1dbe4:	8b 40 04             	mov    0x4(%eax),%eax
   1dbe7:	89 42 04             	mov    %eax,0x4(%edx)
	if(head->next == elem /* || elem->prev != NULL || elem->next != NULL */) {
   1dbea:	8b 45 08             	mov    0x8(%ebp),%eax
   1dbed:	8b 50 04             	mov    0x4(%eax),%edx
   1dbf0:	8b 45 0c             	mov    0xc(%ebp),%eax
   1dbf3:	89 02                	mov    %eax,(%edx)
		BUG();
   1dbf5:	8b 55 0c             	mov    0xc(%ebp),%edx
   1dbf8:	8b 45 08             	mov    0x8(%ebp),%eax
   1dbfb:	89 02                	mov    %eax,(%edx)
		show_stack(NULL);	
   1dbfd:	8b 55 08             	mov    0x8(%ebp),%edx
   1dc00:	8b 45 0c             	mov    0xc(%ebp),%eax
   1dc03:	89 42 04             	mov    %eax,0x4(%edx)
	}
   1dc06:	8b 55 0c             	mov    0xc(%ebp),%edx
   1dc09:	8b 45 08             	mov    0x8(%ebp),%eax
   1dc0c:	89 42 08             	mov    %eax,0x8(%edx)
	elem->next = head->next;
   1dc0f:	8b 45 08             	mov    0x8(%ebp),%eax
   1dc12:	ff 40 10             	incl   0x10(%eax)
	head->next->prev = elem;
   1dc15:	c9                   	leave  
   1dc16:	c3                   	ret    

0001dc17 <insert_tail>:

   1dc17:	55                   	push   %ebp
   1dc18:	89 e5                	mov    %esp,%ebp
   1dc1a:	83 ec 08             	sub    $0x8,%esp
	elem->prev = (struct alloc_head*)head;
   1dc1d:	8b 45 08             	mov    0x8(%ebp),%eax
   1dc20:	8b 00                	mov    (%eax),%eax
   1dc22:	3b 45 0c             	cmp    0xc(%ebp),%eax
   1dc25:	75 31                	jne    1dc58 <insert_tail+0x41>
	head->next = elem;
   1dc27:	c7 44 24 04 f9 72 00 	movl   $0x72f9,0x4(%esp,1)
   1dc2e:	00 
   1dc2f:	c7 04 24 fd 72 00 00 	movl   $0x72fd,(%esp,1)
   1dc36:	e8 fc ff ff ff       	call   1dc37 <insert_tail+0x20>
   1dc3b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1dc42:	e8 fc ff ff ff       	call   1dc43 <insert_tail+0x2c>
   1dc47:	e8 fc ff ff ff       	call   1dc48 <insert_tail+0x31>

   1dc4c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp,1)
   1dc53:	e8 fc ff ff ff       	call   1dc54 <insert_tail+0x3d>
	elem->list = head;
	head->len++;
   1dc58:	8b 55 0c             	mov    0xc(%ebp),%edx
   1dc5b:	8b 45 08             	mov    0x8(%ebp),%eax
   1dc5e:	89 42 04             	mov    %eax,0x4(%edx)
}
   1dc61:	8b 55 0c             	mov    0xc(%ebp),%edx
   1dc64:	8b 45 08             	mov    0x8(%ebp),%eax
   1dc67:	8b 00                	mov    (%eax),%eax
   1dc69:	89 02                	mov    %eax,(%edx)

   1dc6b:	8b 45 08             	mov    0x8(%ebp),%eax
   1dc6e:	8b 10                	mov    (%eax),%edx
   1dc70:	8b 45 0c             	mov    0xc(%ebp),%eax
   1dc73:	89 42 04             	mov    %eax,0x4(%edx)
static inline void insert_tail(struct alloc_head_list *head, struct alloc_head *elem) {
   1dc76:	8b 55 0c             	mov    0xc(%ebp),%edx
   1dc79:	8b 45 08             	mov    0x8(%ebp),%eax
   1dc7c:	89 42 08             	mov    %eax,0x8(%edx)
#ifdef DEBUG_LIST
   1dc7f:	8b 55 08             	mov    0x8(%ebp),%edx
   1dc82:	8b 45 0c             	mov    0xc(%ebp),%eax
   1dc85:	89 02                	mov    %eax,(%edx)
	if(elem->list) {
   1dc87:	8b 45 08             	mov    0x8(%ebp),%eax
   1dc8a:	ff 40 10             	incl   0x10(%eax)
		BUG();
   1dc8d:	c9                   	leave  
   1dc8e:	c3                   	ret    

0001dc8f <free_minisock>:
	msk->ucont_data = NULL;
	msk->input_len = 0;
	msk->input = NULL;
	msk->packets = NULL;

   1dc8f:	55                   	push   %ebp
   1dc90:	89 e5                	mov    %esp,%ebp
   1dc92:	83 ec 0c             	sub    $0xc,%esp
	msk->refCnt = 1;
#define HAS_VALID_CACHERECYCLEINDEX(MSK) ((MSK)->cacheRecycleIndex >= 0)
   1dc95:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
   1dc9c:	8b 55 0c             	mov    0xc(%ebp),%edx
   1dc9f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1dca2:	3b 82 e8 00 00 00    	cmp    0xe8(%edx),%eax
   1dca8:	7c 02                	jl     1dcac <free_minisock+0x1d>
   1dcaa:	eb 4e                	jmp    1dcfa <free_minisock+0x6b>
	msk->cacheRecycleIndex = -1; // invalid index
   1dcac:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1dcaf:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1dcb2:	89 d0                	mov    %edx,%eax
   1dcb4:	c1 e0 03             	shl    $0x3,%eax
   1dcb7:	01 d0                	add    %edx,%eax
   1dcb9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1dcc0:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   1dcc6:	83 7c 10 14 00       	cmpl   $0x0,0x14(%eax,%edx,1)
   1dccb:	74 26                	je     1dcf3 <free_minisock+0x64>
	msk->serverSK = NULL;
   1dccd:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1dcd0:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
   1dcd3:	89 d0                	mov    %edx,%eax
   1dcd5:	c1 e0 03             	shl    $0x3,%eax
   1dcd8:	01 d0                	add    %edx,%eax
   1dcda:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1dce1:	8b 81 ec 00 00 00    	mov    0xec(%ecx),%eax
   1dce7:	8b 44 10 14          	mov    0x14(%eax,%edx,1),%eax
   1dceb:	89 04 24             	mov    %eax,(%esp,1)
   1dcee:	e8 fc ff ff ff       	call   1dcef <free_minisock+0x60>
   1dcf3:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
   1dcf6:	ff 00                	incl   (%eax)
   1dcf8:	eb a2                	jmp    1dc9c <free_minisock+0xd>
}

#ifdef CAN_USE_TFREE
   1dcfa:	8b 45 08             	mov    0x8(%ebp),%eax
   1dcfd:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   1dd03:	83 e0 01             	and    $0x1,%eax
   1dd06:	85 c0                	test   %eax,%eax
   1dd08:	74 1b                	je     1dd25 <free_minisock+0x96>
   1dd0a:	8b 55 08             	mov    0x8(%ebp),%edx
   1dd0d:	8b 45 08             	mov    0x8(%ebp),%eax
   1dd10:	8b 80 a8 02 00 00    	mov    0x2a8(%eax),%eax
   1dd16:	23 82 a8 02 00 00    	and    0x2a8(%edx),%eax
   1dd1c:	83 e0 08             	and    $0x8,%eax
   1dd1f:	85 c0                	test   %eax,%eax
   1dd21:	75 02                	jne    1dd25 <free_minisock+0x96>
   1dd23:	eb 31                	jmp    1dd56 <free_minisock+0xc7>
   1dd25:	8b 45 0c             	mov    0xc(%ebp),%eax
   1dd28:	83 b8 ec 00 00 00 00 	cmpl   $0x0,0xec(%eax)
   1dd2f:	74 25                	je     1dd56 <free_minisock+0xc7>
static inline void free_minisock(struct sock *sk, struct cminisock *msk) {
   1dd31:	8b 45 0c             	mov    0xc(%ebp),%eax
   1dd34:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
   1dd3a:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1dd3e:	8b 45 08             	mov    0x8(%ebp),%eax
   1dd41:	89 04 24             	mov    %eax,(%esp,1)
   1dd44:	e8 fc ff ff ff       	call   1dd45 <free_minisock+0xb6>
	int i;
   1dd49:	8b 45 0c             	mov    0xc(%ebp),%eax
   1dd4c:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%eax)
   1dd53:	00 00 00 
	/*
	printk("msk summary (%p [%d]) (%p [%d]) (%p [%d])\n", 
   1dd56:	8b 45 0c             	mov    0xc(%ebp),%eax
   1dd59:	c7 80 e8 00 00 00 00 	movl   $0x0,0xe8(%eax)
   1dd60:	00 00 00 
	       msk->packets, msk->num_packets,
   1dd63:	8b 45 0c             	mov    0xc(%ebp),%eax
   1dd66:	83 78 7c 00          	cmpl   $0x0,0x7c(%eax)
   1dd6a:	74 1f                	je     1dd8b <free_minisock+0xfc>
	       msk->ucont_data, msk->ucont_len,
   1dd6c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1dd6f:	8b 40 7c             	mov    0x7c(%eax),%eax
   1dd72:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1dd76:	8b 45 08             	mov    0x8(%ebp),%eax
   1dd79:	89 04 24             	mov    %eax,(%esp,1)
   1dd7c:	e8 fc ff ff ff       	call   1dd7d <free_minisock+0xee>
	       msk->input, msk->input_len);
   1dd81:	8b 45 0c             	mov    0xc(%ebp),%eax
   1dd84:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	*/
	for(i=0; i < msk->num_packets; i++) {
   1dd8b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1dd8e:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
		if(msk->packets[i].ucontData != NULL) {
   1dd95:	8b 45 0c             	mov    0xc(%ebp),%eax
   1dd98:	83 b8 98 00 00 00 00 	cmpl   $0x0,0x98(%eax)
   1dd9f:	74 25                	je     1ddc6 <free_minisock+0x137>
			kfree(msk->packets[i].ucontData);
   1dda1:	8b 45 0c             	mov    0xc(%ebp),%eax
   1dda4:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   1ddaa:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1ddae:	8b 45 08             	mov    0x8(%ebp),%eax
   1ddb1:	89 04 24             	mov    %eax,(%esp,1)
   1ddb4:	e8 fc ff ff ff       	call   1ddb5 <free_minisock+0x126>
		}
   1ddb9:	8b 45 0c             	mov    0xc(%ebp),%eax
   1ddbc:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
   1ddc3:	00 00 00 
	}
	// printk("done with packet data\n");
   1ddc6:	8b 45 0c             	mov    0xc(%ebp),%eax
   1ddc9:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
   1ddd0:	00 00 00 
	if(!SIMULATION_MODE(sk) && msk->packets) {
   1ddd3:	c9                   	leave  
   1ddd4:	c3                   	ret    

0001ddd5 <hash>:
     register u1 *k,        /* the key */
	u4           length,   /* the length of the key in bytes */
	u4           initval  /* the previous hash, or an arbitrary value */
     )
{
   1ddd5:	55                   	push   %ebp
   1ddd6:	89 e5                	mov    %esp,%ebp
   1ddd8:	83 ec 10             	sub    $0x10,%esp
   register u4 a,b,c;  /* the internal state */
   u4          len;    /* how many key bytes still need mixing */

   1dddb:	8b 45 0c             	mov    0xc(%ebp),%eax
   1ddde:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   /* Set up the internal state */
   1dde1:	c7 45 f4 b9 79 37 9e 	movl   $0x9e3779b9,0xfffffff4(%ebp)
   1dde8:	c7 45 f8 b9 79 37 9e 	movl   $0x9e3779b9,0xfffffff8(%ebp)
   len = length;
   1ddef:	8b 45 10             	mov    0x10(%ebp),%eax
   1ddf2:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   a = b = 0x9e3779b9;  /* the golden ratio; an arbitrary value */
   1ddf5:	83 7d fc 0b          	cmpl   $0xb,0xfffffffc(%ebp)
   1ddf9:	77 05                	ja     1de00 <hash+0x2b>
   1ddfb:	e9 58 01 00 00       	jmp    1df58 <hash+0x183>
   c = initval;         /* variable initialization of internal state */

   1de00:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1de03:	0f b6 11             	movzbl (%ecx),%edx
   1de06:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1de09:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
   1de0d:	c1 e0 08             	shl    $0x8,%eax
   1de10:	01 c2                	add    %eax,%edx
   1de12:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1de15:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
   1de19:	c1 e0 10             	shl    $0x10,%eax
   1de1c:	01 c2                	add    %eax,%edx
   1de1e:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1de21:	0f b6 41 03          	movzbl 0x3(%ecx),%eax
   1de25:	c1 e0 18             	shl    $0x18,%eax
   1de28:	8d 04 10             	lea    (%eax,%edx,1),%eax
   1de2b:	01 45 f8             	add    %eax,0xfffffff8(%ebp)
   /*---------------------------------------- handle most of the key */
   1de2e:	8b 45 08             	mov    0x8(%ebp),%eax
   1de31:	0f b6 50 04          	movzbl 0x4(%eax),%edx
   1de35:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1de38:	0f b6 41 05          	movzbl 0x5(%ecx),%eax
   1de3c:	c1 e0 08             	shl    $0x8,%eax
   1de3f:	01 c2                	add    %eax,%edx
   1de41:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1de44:	0f b6 41 06          	movzbl 0x6(%ecx),%eax
   1de48:	c1 e0 10             	shl    $0x10,%eax
   1de4b:	01 c2                	add    %eax,%edx
   1de4d:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1de50:	0f b6 41 07          	movzbl 0x7(%ecx),%eax
   1de54:	c1 e0 18             	shl    $0x18,%eax
   1de57:	8d 04 10             	lea    (%eax,%edx,1),%eax
   1de5a:	01 45 f4             	add    %eax,0xfffffff4(%ebp)
   while (len >= 12)
   1de5d:	8b 45 08             	mov    0x8(%ebp),%eax
   1de60:	0f b6 50 08          	movzbl 0x8(%eax),%edx
   1de64:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1de67:	0f b6 41 09          	movzbl 0x9(%ecx),%eax
   1de6b:	c1 e0 08             	shl    $0x8,%eax
   1de6e:	01 c2                	add    %eax,%edx
   1de70:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1de73:	0f b6 41 0a          	movzbl 0xa(%ecx),%eax
   1de77:	c1 e0 10             	shl    $0x10,%eax
   1de7a:	01 c2                	add    %eax,%edx
   1de7c:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1de7f:	0f b6 41 0b          	movzbl 0xb(%ecx),%eax
   1de83:	c1 e0 18             	shl    $0x18,%eax
   1de86:	8d 04 10             	lea    (%eax,%edx,1),%eax
   1de89:	01 45 f0             	add    %eax,0xfffffff0(%ebp)
   {
   1de8c:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1de8f:	29 45 f8             	sub    %eax,0xfffffff8(%ebp)
   1de92:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   1de95:	29 55 f8             	sub    %edx,0xfffffff8(%ebp)
   1de98:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1de9b:	c1 e8 0d             	shr    $0xd,%eax
   1de9e:	31 45 f8             	xor    %eax,0xfffffff8(%ebp)
   1dea1:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
   1dea4:	29 4d f4             	sub    %ecx,0xfffffff4(%ebp)
   1dea7:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1deaa:	29 45 f4             	sub    %eax,0xfffffff4(%ebp)
   1dead:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1deb0:	c1 e0 08             	shl    $0x8,%eax
   1deb3:	31 45 f4             	xor    %eax,0xfffffff4(%ebp)
   1deb6:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   1deb9:	29 55 f0             	sub    %edx,0xfffffff0(%ebp)
   1debc:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
   1debf:	29 4d f0             	sub    %ecx,0xfffffff0(%ebp)
   1dec2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1dec5:	c1 e8 0d             	shr    $0xd,%eax
   1dec8:	31 45 f0             	xor    %eax,0xfffffff0(%ebp)
   1decb:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1dece:	29 45 f8             	sub    %eax,0xfffffff8(%ebp)
   1ded1:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   1ded4:	29 55 f8             	sub    %edx,0xfffffff8(%ebp)
   1ded7:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1deda:	c1 e8 0c             	shr    $0xc,%eax
   1dedd:	31 45 f8             	xor    %eax,0xfffffff8(%ebp)
   1dee0:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
   1dee3:	29 4d f4             	sub    %ecx,0xfffffff4(%ebp)
   1dee6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1dee9:	29 45 f4             	sub    %eax,0xfffffff4(%ebp)
   1deec:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1deef:	c1 e0 10             	shl    $0x10,%eax
   1def2:	31 45 f4             	xor    %eax,0xfffffff4(%ebp)
   1def5:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   1def8:	29 55 f0             	sub    %edx,0xfffffff0(%ebp)
   1defb:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
   1defe:	29 4d f0             	sub    %ecx,0xfffffff0(%ebp)
   1df01:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1df04:	c1 e8 05             	shr    $0x5,%eax
   1df07:	31 45 f0             	xor    %eax,0xfffffff0(%ebp)
   1df0a:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1df0d:	29 45 f8             	sub    %eax,0xfffffff8(%ebp)
   1df10:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   1df13:	29 55 f8             	sub    %edx,0xfffffff8(%ebp)
   1df16:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1df19:	c1 e8 03             	shr    $0x3,%eax
   1df1c:	31 45 f8             	xor    %eax,0xfffffff8(%ebp)
   1df1f:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
   1df22:	29 4d f4             	sub    %ecx,0xfffffff4(%ebp)
   1df25:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1df28:	29 45 f4             	sub    %eax,0xfffffff4(%ebp)
   1df2b:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1df2e:	c1 e0 0a             	shl    $0xa,%eax
   1df31:	31 45 f4             	xor    %eax,0xfffffff4(%ebp)
   1df34:	8b 55 f8             	mov    0xfffffff8(%ebp),%edx
   1df37:	29 55 f0             	sub    %edx,0xfffffff0(%ebp)
   1df3a:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
   1df3d:	29 4d f0             	sub    %ecx,0xfffffff0(%ebp)
   1df40:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1df43:	c1 e8 0f             	shr    $0xf,%eax
   1df46:	31 45 f0             	xor    %eax,0xfffffff0(%ebp)
      a=a+(k[0]+((u4)k[1]<<8)+((u4)k[2]<<16) +((u4)k[3]<<24));
   1df49:	83 45 08 0c          	addl   $0xc,0x8(%ebp)
   1df4d:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
   1df50:	83 28 0c             	subl   $0xc,(%eax)
   1df53:	e9 9d fe ff ff       	jmp    1ddf5 <hash+0x20>
      b=b+(k[4]+((u4)k[5]<<8)+((u4)k[6]<<16) +((u4)k[7]<<24));
      c=c+(k[8]+((u4)k[9]<<8)+((u4)k[10]<<16)+((u4)k[11]<<24));
   1df58:	8b 45 0c             	mov    0xc(%ebp),%eax
   1df5b:	01 45 f0             	add    %eax,0xfffffff0(%ebp)
      mix(a,b,c);
   1df5e:	83 7d fc 0b          	cmpl   $0xb,0xfffffffc(%ebp)
   1df62:	0f 87 96 00 00 00    	ja     1dffe <hash+0x229>
   1df68:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1df6b:	c1 e0 02             	shl    $0x2,%eax
   1df6e:	8b 80 78 78 00 00    	mov    0x7878(%eax),%eax
   1df74:	ff e0                	jmp    *%eax
      k = k+12; len = len-12;
   }
   1df76:	8b 55 08             	mov    0x8(%ebp),%edx
   1df79:	0f b6 42 0a          	movzbl 0xa(%edx),%eax
   1df7d:	c1 e0 18             	shl    $0x18,%eax
   1df80:	01 45 f0             	add    %eax,0xfffffff0(%ebp)

   1df83:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1df86:	0f b6 41 09          	movzbl 0x9(%ecx),%eax
   1df8a:	c1 e0 10             	shl    $0x10,%eax
   1df8d:	01 45 f0             	add    %eax,0xfffffff0(%ebp)
   /*------------------------------------- handle the last 11 bytes */
   1df90:	8b 55 08             	mov    0x8(%ebp),%edx
   1df93:	0f b6 42 08          	movzbl 0x8(%edx),%eax
   1df97:	c1 e0 08             	shl    $0x8,%eax
   1df9a:	01 45 f0             	add    %eax,0xfffffff0(%ebp)
   c = c+length;
   1df9d:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1dfa0:	0f b6 41 07          	movzbl 0x7(%ecx),%eax
   1dfa4:	c1 e0 18             	shl    $0x18,%eax
   1dfa7:	01 45 f4             	add    %eax,0xfffffff4(%ebp)
   switch(len)              /* all the case statements fall through */
   1dfaa:	8b 55 08             	mov    0x8(%ebp),%edx
   1dfad:	0f b6 42 06          	movzbl 0x6(%edx),%eax
   1dfb1:	c1 e0 10             	shl    $0x10,%eax
   1dfb4:	01 45 f4             	add    %eax,0xfffffff4(%ebp)
   {
   1dfb7:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1dfba:	0f b6 41 05          	movzbl 0x5(%ecx),%eax
   1dfbe:	c1 e0 08             	shl    $0x8,%eax
   1dfc1:	01 45 f4             	add    %eax,0xfffffff4(%ebp)
   case 11: c=c+((u4)k[10]<<24);
   1dfc4:	8b 55 08             	mov    0x8(%ebp),%edx
   1dfc7:	0f b6 42 04          	movzbl 0x4(%edx),%eax
   1dfcb:	01 45 f4             	add    %eax,0xfffffff4(%ebp)
   case 10: c=c+((u4)k[9]<<16);
   1dfce:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1dfd1:	0f b6 41 03          	movzbl 0x3(%ecx),%eax
   1dfd5:	c1 e0 18             	shl    $0x18,%eax
   1dfd8:	01 45 f8             	add    %eax,0xfffffff8(%ebp)
   case 9 : c=c+((u4)k[8]<<8);
   1dfdb:	8b 55 08             	mov    0x8(%ebp),%edx
   1dfde:	0f b6 42 02          	movzbl 0x2(%edx),%eax
   1dfe2:	c1 e0 10             	shl    $0x10,%eax
   1dfe5:	01 45 f8             	add    %eax,0xfffffff8(%ebp)
      /* the first byte of c is reserved for the length */
   1dfe8:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1dfeb:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
   1dfef:	c1 e0 08             	shl    $0x8,%eax
   1dff2:	01 45 f8             	add    %eax,0xfffffff8(%ebp)
   case 8 : b=b+((u4)k[7]<<24);
   1dff5:	8b 55 08             	mov    0x8(%ebp),%edx
   1dff8:	0f b6 02             	movzbl (%edx),%eax
   1dffb:	01 45 f8             	add    %eax,0xfffffff8(%ebp)
   case 7 : b=b+((u4)k[6]<<16);
   case 6 : b=b+((u4)k[5]<<8);
   1dffe:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
   1e001:	29 4d f8             	sub    %ecx,0xfffffff8(%ebp)
   1e004:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1e007:	29 45 f8             	sub    %eax,0xfffffff8(%ebp)
   1e00a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1e00d:	c1 e8 0d             	shr    $0xd,%eax
   1e010:	31 45 f8             	xor    %eax,0xfffffff8(%ebp)
   1e013:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   1e016:	29 55 f4             	sub    %edx,0xfffffff4(%ebp)
   1e019:	8b 4d f8             	mov    0xfffffff8(%ebp),%ecx
   1e01c:	29 4d f4             	sub    %ecx,0xfffffff4(%ebp)
   1e01f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1e022:	c1 e0 08             	shl    $0x8,%eax
   1e025:	31 45 f4             	xor    %eax,0xfffffff4(%ebp)
   1e028:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1e02b:	29 45 f0             	sub    %eax,0xfffffff0(%ebp)
   1e02e:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   1e031:	29 55 f0             	sub    %edx,0xfffffff0(%ebp)
   1e034:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1e037:	c1 e8 0d             	shr    $0xd,%eax
   1e03a:	31 45 f0             	xor    %eax,0xfffffff0(%ebp)
   1e03d:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
   1e040:	29 4d f8             	sub    %ecx,0xfffffff8(%ebp)
   1e043:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1e046:	29 45 f8             	sub    %eax,0xfffffff8(%ebp)
   1e049:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1e04c:	c1 e8 0c             	shr    $0xc,%eax
   1e04f:	31 45 f8             	xor    %eax,0xfffffff8(%ebp)
   1e052:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   1e055:	29 55 f4             	sub    %edx,0xfffffff4(%ebp)
   1e058:	8b 4d f8             	mov    0xfffffff8(%ebp),%ecx
   1e05b:	29 4d f4             	sub    %ecx,0xfffffff4(%ebp)
   1e05e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1e061:	c1 e0 10             	shl    $0x10,%eax
   1e064:	31 45 f4             	xor    %eax,0xfffffff4(%ebp)
   1e067:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1e06a:	29 45 f0             	sub    %eax,0xfffffff0(%ebp)
   1e06d:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   1e070:	29 55 f0             	sub    %edx,0xfffffff0(%ebp)
   1e073:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1e076:	c1 e8 05             	shr    $0x5,%eax
   1e079:	31 45 f0             	xor    %eax,0xfffffff0(%ebp)
   1e07c:	8b 4d f4             	mov    0xfffffff4(%ebp),%ecx
   1e07f:	29 4d f8             	sub    %ecx,0xfffffff8(%ebp)
   1e082:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1e085:	29 45 f8             	sub    %eax,0xfffffff8(%ebp)
   1e088:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1e08b:	c1 e8 03             	shr    $0x3,%eax
   1e08e:	31 45 f8             	xor    %eax,0xfffffff8(%ebp)
   1e091:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   1e094:	29 55 f4             	sub    %edx,0xfffffff4(%ebp)
   1e097:	8b 4d f8             	mov    0xfffffff8(%ebp),%ecx
   1e09a:	29 4d f4             	sub    %ecx,0xfffffff4(%ebp)
   1e09d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1e0a0:	c1 e0 0a             	shl    $0xa,%eax
   1e0a3:	31 45 f4             	xor    %eax,0xfffffff4(%ebp)
   1e0a6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1e0a9:	29 45 f0             	sub    %eax,0xfffffff0(%ebp)
   1e0ac:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
   1e0af:	29 55 f0             	sub    %edx,0xfffffff0(%ebp)
   1e0b2:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1e0b5:	c1 e8 0f             	shr    $0xf,%eax
   1e0b8:	31 45 f0             	xor    %eax,0xfffffff0(%ebp)
   case 5 : b=b+k[4];
   1e0bb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   case 4 : a=a+((u4)k[3]<<24);
   1e0be:	c9                   	leave  
   1e0bf:	c3                   	ret    

0001e0c0 <list_link_init>:
   case 3 : a=a+((u4)k[2]<<16);
   case 2 : a=a+((u4)k[1]<<8);
   case 1 : a=a+k[0];
     /* case 0: nothing left to add */
   }
   mix(a,b,c);
   /*-------------------------------------------- report the result */
   return c;
}


#define die() ({ do { printk("dying at %s:%s():%d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__); BUG(); } while(0) ; 1 ; })

#define RETURN(V) ({ return(V); 1; })

#define PRINTK(S, ...) ({ printk(S,##__VA_ARGS__); 1; })

#undef ERROR
#define ERROR(S,...) (PRINTK(S "\n",##__VA_ARGS__))

#define ENCLOSING(S,F,V) ((S*) (((char*) V) - ((char*) &((S*)0)->F)))

#define ASSERT_OR_RETURN(E)						\
do {									\
	if(!(E)) {							\
		printk("(%s) failed at %s:%s():%d\n",			\
			#E, __FILE__, __PRETTY_FUNCTION__, __LINE__);	\
		return 0;						\
	}								\
} while(0)

#define ASSERT_OR_DIE(E)						\
do {									\
	if(!(E)) {							\
		printk("(%s) failed at %s:%s():%d\n",			\
			#E, __FILE__, __PRETTY_FUNCTION__, __LINE__);	\
		die();							\
	}								\
} while(0)

struct list_link { // link for a particular list
	// order must match alloc head link slots

	struct alloc_head *prev;
	struct alloc_head *next;
	struct alloc_head_list *list;
   1e0c0:	55                   	push   %ebp
   1e0c1:	89 e5                	mov    %esp,%ebp
};
   1e0c3:	8b 45 08             	mov    0x8(%ebp),%eax
   1e0c6:	8b 55 08             	mov    0x8(%ebp),%edx
   1e0c9:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
   1e0cf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

   1e0d6:	8b 45 08             	mov    0x8(%ebp),%eax
   1e0d9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
static inline void list_link_init(struct list_link *head) {
   1e0e0:	5d                   	pop    %ebp
   1e0e1:	c3                   	ret    

0001e0e2 <cminisock_hash>:
   1e0e2:	55                   	push   %ebp
   1e0e3:	89 e5                	mov    %esp,%ebp
   1e0e5:	83 ec 0c             	sub    $0xc,%esp
   1e0e8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
   1e0ef:	00 
   1e0f0:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp,1)
   1e0f7:	00 
   1e0f8:	8b 45 08             	mov    0x8(%ebp),%eax
   1e0fb:	89 04 24             	mov    %eax,(%esp,1)
   1e0fe:	e8 d2 fc ff ff       	call   1ddd5 <hash>
   1e103:	c9                   	leave  
   1e104:	c3                   	ret    

0001e105 <ParsedCMinisock_findLoop>:
   1e105:	55                   	push   %ebp
   1e106:	89 e5                	mov    %esp,%ebp
   1e108:	83 ec 1c             	sub    $0x1c,%esp
   1e10b:	8b 45 08             	mov    0x8(%ebp),%eax
   1e10e:	8b 40 04             	mov    0x4(%eax),%eax
   1e111:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   1e114:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1e117:	3b 45 08             	cmp    0x8(%ebp),%eax
   1e11a:	75 02                	jne    1e11e <ParsedCMinisock_findLoop+0x19>
   1e11c:	eb 44                	jmp    1e162 <ParsedCMinisock_findLoop+0x5d>
   1e11e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1e121:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   1e124:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1e127:	83 c0 28             	add    $0x28,%eax
   1e12a:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   1e12e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1e131:	83 c0 24             	add    $0x24,%eax
   1e134:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1e138:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
   1e13f:	00 
   1e140:	8b 45 0c             	mov    0xc(%ebp),%eax
   1e143:	89 04 24             	mov    %eax,(%esp,1)
   1e146:	e8 af 00 00 00       	call   1e1fa <cminisock_cmp>
   1e14b:	85 c0                	test   %eax,%eax
   1e14d:	74 08                	je     1e157 <ParsedCMinisock_findLoop+0x52>
   1e14f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1e152:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1e155:	eb 12                	jmp    1e169 <ParsedCMinisock_findLoop+0x64>
   1e157:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1e15a:	8b 40 04             	mov    0x4(%eax),%eax
   1e15d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   1e160:	eb b2                	jmp    1e114 <ParsedCMinisock_findLoop+0xf>
   1e162:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
   1e169:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1e16c:	c9                   	leave  
   1e16d:	c3                   	ret    

0001e16e <CachedWireContinuation_hash>:
   1e16e:	55                   	push   %ebp
   1e16f:	89 e5                	mov    %esp,%ebp
   1e171:	83 ec 0c             	sub    $0xc,%esp
   1e174:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp,1)
   1e17b:	00 
   1e17c:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp,1)
   1e183:	00 
   1e184:	8b 45 08             	mov    0x8(%ebp),%eax
   1e187:	89 04 24             	mov    %eax,(%esp,1)
   1e18a:	e8 46 fc ff ff       	call   1ddd5 <hash>
   1e18f:	c9                   	leave  
   1e190:	c3                   	ret    

0001e191 <Continuation_findLoop>:
   1e191:	55                   	push   %ebp
   1e192:	89 e5                	mov    %esp,%ebp
   1e194:	83 ec 1c             	sub    $0x1c,%esp
   1e197:	8b 45 08             	mov    0x8(%ebp),%eax
   1e19a:	8b 40 04             	mov    0x4(%eax),%eax
   1e19d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   1e1a0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1e1a3:	3b 45 08             	cmp    0x8(%ebp),%eax
   1e1a6:	75 02                	jne    1e1aa <Continuation_findLoop+0x19>
   1e1a8:	eb 44                	jmp    1e1ee <Continuation_findLoop+0x5d>
   1e1aa:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1e1ad:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
   1e1b0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1e1b3:	83 c0 28             	add    $0x28,%eax
   1e1b6:	89 44 24 0c          	mov    %eax,0xc(%esp,1)
   1e1ba:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1e1bd:	83 c0 24             	add    $0x24,%eax
   1e1c0:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1e1c4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp,1)
   1e1cb:	00 
   1e1cc:	8b 45 0c             	mov    0xc(%ebp),%eax
   1e1cf:	89 04 24             	mov    %eax,(%esp,1)
   1e1d2:	e8 59 00 00 00       	call   1e230 <CachedWireContinuation_cache_cmp>
   1e1d7:	85 c0                	test   %eax,%eax
   1e1d9:	74 08                	je     1e1e3 <Continuation_findLoop+0x52>
   1e1db:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
   1e1de:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
   1e1e1:	eb 12                	jmp    1e1f5 <Continuation_findLoop+0x64>
   1e1e3:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
   1e1e6:	8b 40 04             	mov    0x4(%eax),%eax
   1e1e9:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
   1e1ec:	eb b2                	jmp    1e1a0 <Continuation_findLoop+0xf>
   1e1ee:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
   1e1f5:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
   1e1f8:	c9                   	leave  
   1e1f9:	c3                   	ret    

0001e1fa <cminisock_cmp>:
   1e1fa:	55                   	push   %ebp
   1e1fb:	89 e5                	mov    %esp,%ebp
   1e1fd:	83 ec 0c             	sub    $0xc,%esp
   1e200:	8b 45 10             	mov    0x10(%ebp),%eax
   1e203:	8b 00                	mov    (%eax),%eax
   1e205:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   1e209:	8b 45 08             	mov    0x8(%ebp),%eax
   1e20c:	8b 00                	mov    (%eax),%eax
   1e20e:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   1e212:	c7 04 24 a8 78 00 00 	movl   $0x78a8,(%esp,1)
   1e219:	e8 fc ff ff ff       	call   1e21a <cminisock_cmp+0x20>
   1e21e:	8b 45 08             	mov    0x8(%ebp),%eax
   1e221:	8b 55 10             	mov    0x10(%ebp),%edx
   1e224:	8b 00                	mov    (%eax),%eax
   1e226:	3b 02                	cmp    (%edx),%eax
   1e228:	0f 94 c0             	sete   %al
   1e22b:	0f b6 c0             	movzbl %al,%eax
   1e22e:	c9                   	leave  
   1e22f:	c3                   	ret    

0001e230 <CachedWireContinuation_cache_cmp>:
   1e230:	55                   	push   %ebp
   1e231:	89 e5                	mov    %esp,%ebp
   1e233:	8b 45 08             	mov    0x8(%ebp),%eax
   1e236:	8b 55 10             	mov    0x10(%ebp),%edx
   1e239:	8b 00                	mov    (%eax),%eax
   1e23b:	3b 02                	cmp    (%edx),%eax
   1e23d:	0f 94 c0             	sete   %al
   1e240:	0f b6 c0             	movzbl %al,%eax
   1e243:	5d                   	pop    %ebp
   1e244:	c3                   	ret    
   1e245:	90                   	nop    
   1e246:	90                   	nop    
   1e247:	90                   	nop    
   1e248:	90                   	nop    
   1e249:	90                   	nop    
   1e24a:	90                   	nop    
   1e24b:	90                   	nop    
   1e24c:	90                   	nop    
   1e24d:	90                   	nop    
   1e24e:	90                   	nop    
   1e24f:	90                   	nop    

0001e250 <aes_encrypt>:
   1e250:	83 ec 18             	sub    $0x18,%esp
   1e253:	89 6c 24 14          	mov    %ebp,0x14(%esp,1)
   1e257:	89 5c 24 10          	mov    %ebx,0x10(%esp,1)
   1e25b:	89 74 24 0c          	mov    %esi,0xc(%esp,1)
   1e25f:	89 7c 24 08          	mov    %edi,0x8(%esp,1)
   1e263:	8b 4c 24 1c          	mov    0x1c(%esp,1),%ecx
   1e267:	8b 6c 24 24          	mov    0x24(%esp,1),%ebp
   1e26b:	8b 01                	mov    (%ecx),%eax
   1e26d:	8b 59 04             	mov    0x4(%ecx),%ebx
   1e270:	33 45 00             	xor    0x0(%ebp),%eax
   1e273:	33 5d 04             	xor    0x4(%ebp),%ebx
   1e276:	8b 71 08             	mov    0x8(%ecx),%esi
   1e279:	8b 79 0c             	mov    0xc(%ecx),%edi
   1e27c:	33 75 08             	xor    0x8(%ebp),%esi
   1e27f:	33 7d 0c             	xor    0xc(%ebp),%edi
   1e282:	8b 8d f0 00 00 00    	mov    0xf0(%ebp),%ecx
   1e288:	83 f9 0a             	cmp    $0xa,%ecx
   1e28b:	0f 84 46 03 00 00    	je     1e5d7 <aes_encrypt.3>
   1e291:	8d 6d 20             	lea    0x20(%ebp),%ebp
   1e294:	83 f9 0c             	cmp    $0xc,%ecx
   1e297:	0f 84 a6 01 00 00    	je     1e443 <aes_encrypt.2>
   1e29d:	8d 6d 20             	lea    0x20(%ebp),%ebp
   1e2a0:	83 f9 0e             	cmp    $0xe,%ecx
   1e2a3:	74 0a                	je     1e2af <aes_encrypt.1>
   1e2a5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1e2aa:	e9 42 0b 00 00       	jmp    1edf1 <aes_encrypt.4>

0001e2af <aes_encrypt.1>:
   1e2af:	89 c1                	mov    %eax,%ecx
   1e2b1:	89 34 24             	mov    %esi,(%esp,1)
   1e2b4:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1e2b8:	0f b6 d1             	movzbl %cl,%edx
   1e2bb:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   1e2be:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1e2c5:	0f b6 d5             	movzbl %ch,%edx
   1e2c8:	c1 e9 10             	shr    $0x10,%ecx
   1e2cb:	8b 7d dc             	mov    0xffffffdc(%ebp),%edi
   1e2ce:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1e2d5:	0f b6 d1             	movzbl %cl,%edx
   1e2d8:	8b 75 d8             	mov    0xffffffd8(%ebp),%esi
   1e2db:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1e2e2:	0f b6 d5             	movzbl %ch,%edx
   1e2e5:	89 d9                	mov    %ebx,%ecx
   1e2e7:	8b 5d d4             	mov    0xffffffd4(%ebp),%ebx
   1e2ea:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1e2f1:	0f b6 d1             	movzbl %cl,%edx
   1e2f4:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1e2fb:	0f b6 d5             	movzbl %ch,%edx
   1e2fe:	c1 e9 10             	shr    $0x10,%ecx
   1e301:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1e308:	0f b6 d1             	movzbl %cl,%edx
   1e30b:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1e312:	0f b6 d5             	movzbl %ch,%edx
   1e315:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1e31c:	8b 0c 24             	mov    (%esp,1),%ecx
   1e31f:	0f b6 d1             	movzbl %cl,%edx
   1e322:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1e329:	0f b6 d5             	movzbl %ch,%edx
   1e32c:	c1 e9 10             	shr    $0x10,%ecx
   1e32f:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1e336:	0f b6 d1             	movzbl %cl,%edx
   1e339:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1e340:	0f b6 d5             	movzbl %ch,%edx
   1e343:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1e34a:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1e34e:	0f b6 d1             	movzbl %cl,%edx
   1e351:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1e358:	0f b6 d5             	movzbl %ch,%edx
   1e35b:	c1 e9 10             	shr    $0x10,%ecx
   1e35e:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1e365:	0f b6 d1             	movzbl %cl,%edx
   1e368:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1e36f:	0f b6 d5             	movzbl %ch,%edx
   1e372:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1e379:	89 c1                	mov    %eax,%ecx
   1e37b:	89 34 24             	mov    %esi,(%esp,1)
   1e37e:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1e382:	0f b6 d1             	movzbl %cl,%edx
   1e385:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   1e388:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1e38f:	0f b6 d5             	movzbl %ch,%edx
   1e392:	c1 e9 10             	shr    $0x10,%ecx
   1e395:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
   1e398:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1e39f:	0f b6 d1             	movzbl %cl,%edx
   1e3a2:	8b 75 e8             	mov    0xffffffe8(%ebp),%esi
   1e3a5:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1e3ac:	0f b6 d5             	movzbl %ch,%edx
   1e3af:	89 d9                	mov    %ebx,%ecx
   1e3b1:	8b 5d e4             	mov    0xffffffe4(%ebp),%ebx
   1e3b4:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1e3bb:	0f b6 d1             	movzbl %cl,%edx
   1e3be:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1e3c5:	0f b6 d5             	movzbl %ch,%edx
   1e3c8:	c1 e9 10             	shr    $0x10,%ecx
   1e3cb:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1e3d2:	0f b6 d1             	movzbl %cl,%edx
   1e3d5:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1e3dc:	0f b6 d5             	movzbl %ch,%edx
   1e3df:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1e3e6:	8b 0c 24             	mov    (%esp,1),%ecx
   1e3e9:	0f b6 d1             	movzbl %cl,%edx
   1e3ec:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1e3f3:	0f b6 d5             	movzbl %ch,%edx
   1e3f6:	c1 e9 10             	shr    $0x10,%ecx
   1e3f9:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1e400:	0f b6 d1             	movzbl %cl,%edx
   1e403:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1e40a:	0f b6 d5             	movzbl %ch,%edx
   1e40d:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1e414:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1e418:	0f b6 d1             	movzbl %cl,%edx
   1e41b:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1e422:	0f b6 d5             	movzbl %ch,%edx
   1e425:	c1 e9 10             	shr    $0x10,%ecx
   1e428:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1e42f:	0f b6 d1             	movzbl %cl,%edx
   1e432:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1e439:	0f b6 d5             	movzbl %ch,%edx
   1e43c:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax

0001e443 <aes_encrypt.2>:
   1e443:	89 c1                	mov    %eax,%ecx
   1e445:	89 34 24             	mov    %esi,(%esp,1)
   1e448:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1e44c:	0f b6 d1             	movzbl %cl,%edx
   1e44f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1e452:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1e459:	0f b6 d5             	movzbl %ch,%edx
   1e45c:	c1 e9 10             	shr    $0x10,%ecx
   1e45f:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
   1e462:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1e469:	0f b6 d1             	movzbl %cl,%edx
   1e46c:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
   1e46f:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1e476:	0f b6 d5             	movzbl %ch,%edx
   1e479:	89 d9                	mov    %ebx,%ecx
   1e47b:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
   1e47e:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1e485:	0f b6 d1             	movzbl %cl,%edx
   1e488:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1e48f:	0f b6 d5             	movzbl %ch,%edx
   1e492:	c1 e9 10             	shr    $0x10,%ecx
   1e495:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1e49c:	0f b6 d1             	movzbl %cl,%edx
   1e49f:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1e4a6:	0f b6 d5             	movzbl %ch,%edx
   1e4a9:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1e4b0:	8b 0c 24             	mov    (%esp,1),%ecx
   1e4b3:	0f b6 d1             	movzbl %cl,%edx
   1e4b6:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1e4bd:	0f b6 d5             	movzbl %ch,%edx
   1e4c0:	c1 e9 10             	shr    $0x10,%ecx
   1e4c3:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1e4ca:	0f b6 d1             	movzbl %cl,%edx
   1e4cd:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1e4d4:	0f b6 d5             	movzbl %ch,%edx
   1e4d7:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1e4de:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1e4e2:	0f b6 d1             	movzbl %cl,%edx
   1e4e5:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1e4ec:	0f b6 d5             	movzbl %ch,%edx
   1e4ef:	c1 e9 10             	shr    $0x10,%ecx
   1e4f2:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1e4f9:	0f b6 d1             	movzbl %cl,%edx
   1e4fc:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1e503:	0f b6 d5             	movzbl %ch,%edx
   1e506:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1e50d:	89 c1                	mov    %eax,%ecx
   1e50f:	89 34 24             	mov    %esi,(%esp,1)
   1e512:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1e516:	0f b6 d1             	movzbl %cl,%edx
   1e519:	8b 45 00             	mov    0x0(%ebp),%eax
   1e51c:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1e523:	0f b6 d5             	movzbl %ch,%edx
   1e526:	c1 e9 10             	shr    $0x10,%ecx
   1e529:	8b 7d 0c             	mov    0xc(%ebp),%edi
   1e52c:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1e533:	0f b6 d1             	movzbl %cl,%edx
   1e536:	8b 75 08             	mov    0x8(%ebp),%esi
   1e539:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1e540:	0f b6 d5             	movzbl %ch,%edx
   1e543:	89 d9                	mov    %ebx,%ecx
   1e545:	8b 5d 04             	mov    0x4(%ebp),%ebx
   1e548:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1e54f:	0f b6 d1             	movzbl %cl,%edx
   1e552:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1e559:	0f b6 d5             	movzbl %ch,%edx
   1e55c:	c1 e9 10             	shr    $0x10,%ecx
   1e55f:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1e566:	0f b6 d1             	movzbl %cl,%edx
   1e569:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1e570:	0f b6 d5             	movzbl %ch,%edx
   1e573:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1e57a:	8b 0c 24             	mov    (%esp,1),%ecx
   1e57d:	0f b6 d1             	movzbl %cl,%edx
   1e580:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1e587:	0f b6 d5             	movzbl %ch,%edx
   1e58a:	c1 e9 10             	shr    $0x10,%ecx
   1e58d:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1e594:	0f b6 d1             	movzbl %cl,%edx
   1e597:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1e59e:	0f b6 d5             	movzbl %ch,%edx
   1e5a1:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1e5a8:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1e5ac:	0f b6 d1             	movzbl %cl,%edx
   1e5af:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1e5b6:	0f b6 d5             	movzbl %ch,%edx
   1e5b9:	c1 e9 10             	shr    $0x10,%ecx
   1e5bc:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1e5c3:	0f b6 d1             	movzbl %cl,%edx
   1e5c6:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1e5cd:	0f b6 d5             	movzbl %ch,%edx
   1e5d0:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax

0001e5d7 <aes_encrypt.3>:
   1e5d7:	89 c1                	mov    %eax,%ecx
   1e5d9:	89 34 24             	mov    %esi,(%esp,1)
   1e5dc:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1e5e0:	0f b6 d1             	movzbl %cl,%edx
   1e5e3:	8b 45 10             	mov    0x10(%ebp),%eax
   1e5e6:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1e5ed:	0f b6 d5             	movzbl %ch,%edx
   1e5f0:	c1 e9 10             	shr    $0x10,%ecx
   1e5f3:	8b 7d 1c             	mov    0x1c(%ebp),%edi
   1e5f6:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1e5fd:	0f b6 d1             	movzbl %cl,%edx
   1e600:	8b 75 18             	mov    0x18(%ebp),%esi
   1e603:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1e60a:	0f b6 d5             	movzbl %ch,%edx
   1e60d:	89 d9                	mov    %ebx,%ecx
   1e60f:	8b 5d 14             	mov    0x14(%ebp),%ebx
   1e612:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1e619:	0f b6 d1             	movzbl %cl,%edx
   1e61c:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1e623:	0f b6 d5             	movzbl %ch,%edx
   1e626:	c1 e9 10             	shr    $0x10,%ecx
   1e629:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1e630:	0f b6 d1             	movzbl %cl,%edx
   1e633:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1e63a:	0f b6 d5             	movzbl %ch,%edx
   1e63d:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1e644:	8b 0c 24             	mov    (%esp,1),%ecx
   1e647:	0f b6 d1             	movzbl %cl,%edx
   1e64a:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1e651:	0f b6 d5             	movzbl %ch,%edx
   1e654:	c1 e9 10             	shr    $0x10,%ecx
   1e657:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1e65e:	0f b6 d1             	movzbl %cl,%edx
   1e661:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1e668:	0f b6 d5             	movzbl %ch,%edx
   1e66b:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1e672:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1e676:	0f b6 d1             	movzbl %cl,%edx
   1e679:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1e680:	0f b6 d5             	movzbl %ch,%edx
   1e683:	c1 e9 10             	shr    $0x10,%ecx
   1e686:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1e68d:	0f b6 d1             	movzbl %cl,%edx
   1e690:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1e697:	0f b6 d5             	movzbl %ch,%edx
   1e69a:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1e6a1:	89 c1                	mov    %eax,%ecx
   1e6a3:	89 34 24             	mov    %esi,(%esp,1)
   1e6a6:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1e6aa:	0f b6 d1             	movzbl %cl,%edx
   1e6ad:	8b 45 20             	mov    0x20(%ebp),%eax
   1e6b0:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1e6b7:	0f b6 d5             	movzbl %ch,%edx
   1e6ba:	c1 e9 10             	shr    $0x10,%ecx
   1e6bd:	8b 7d 2c             	mov    0x2c(%ebp),%edi
   1e6c0:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1e6c7:	0f b6 d1             	movzbl %cl,%edx
   1e6ca:	8b 75 28             	mov    0x28(%ebp),%esi
   1e6cd:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1e6d4:	0f b6 d5             	movzbl %ch,%edx
   1e6d7:	89 d9                	mov    %ebx,%ecx
   1e6d9:	8b 5d 24             	mov    0x24(%ebp),%ebx
   1e6dc:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1e6e3:	0f b6 d1             	movzbl %cl,%edx
   1e6e6:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1e6ed:	0f b6 d5             	movzbl %ch,%edx
   1e6f0:	c1 e9 10             	shr    $0x10,%ecx
   1e6f3:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1e6fa:	0f b6 d1             	movzbl %cl,%edx
   1e6fd:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1e704:	0f b6 d5             	movzbl %ch,%edx
   1e707:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1e70e:	8b 0c 24             	mov    (%esp,1),%ecx
   1e711:	0f b6 d1             	movzbl %cl,%edx
   1e714:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1e71b:	0f b6 d5             	movzbl %ch,%edx
   1e71e:	c1 e9 10             	shr    $0x10,%ecx
   1e721:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1e728:	0f b6 d1             	movzbl %cl,%edx
   1e72b:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1e732:	0f b6 d5             	movzbl %ch,%edx
   1e735:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1e73c:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1e740:	0f b6 d1             	movzbl %cl,%edx
   1e743:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1e74a:	0f b6 d5             	movzbl %ch,%edx
   1e74d:	c1 e9 10             	shr    $0x10,%ecx
   1e750:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1e757:	0f b6 d1             	movzbl %cl,%edx
   1e75a:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1e761:	0f b6 d5             	movzbl %ch,%edx
   1e764:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1e76b:	89 c1                	mov    %eax,%ecx
   1e76d:	89 34 24             	mov    %esi,(%esp,1)
   1e770:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1e774:	0f b6 d1             	movzbl %cl,%edx
   1e777:	8b 45 30             	mov    0x30(%ebp),%eax
   1e77a:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1e781:	0f b6 d5             	movzbl %ch,%edx
   1e784:	c1 e9 10             	shr    $0x10,%ecx
   1e787:	8b 7d 3c             	mov    0x3c(%ebp),%edi
   1e78a:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1e791:	0f b6 d1             	movzbl %cl,%edx
   1e794:	8b 75 38             	mov    0x38(%ebp),%esi
   1e797:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1e79e:	0f b6 d5             	movzbl %ch,%edx
   1e7a1:	89 d9                	mov    %ebx,%ecx
   1e7a3:	8b 5d 34             	mov    0x34(%ebp),%ebx
   1e7a6:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1e7ad:	0f b6 d1             	movzbl %cl,%edx
   1e7b0:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1e7b7:	0f b6 d5             	movzbl %ch,%edx
   1e7ba:	c1 e9 10             	shr    $0x10,%ecx
   1e7bd:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1e7c4:	0f b6 d1             	movzbl %cl,%edx
   1e7c7:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1e7ce:	0f b6 d5             	movzbl %ch,%edx
   1e7d1:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1e7d8:	8b 0c 24             	mov    (%esp,1),%ecx
   1e7db:	0f b6 d1             	movzbl %cl,%edx
   1e7de:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1e7e5:	0f b6 d5             	movzbl %ch,%edx
   1e7e8:	c1 e9 10             	shr    $0x10,%ecx
   1e7eb:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1e7f2:	0f b6 d1             	movzbl %cl,%edx
   1e7f5:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1e7fc:	0f b6 d5             	movzbl %ch,%edx
   1e7ff:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1e806:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1e80a:	0f b6 d1             	movzbl %cl,%edx
   1e80d:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1e814:	0f b6 d5             	movzbl %ch,%edx
   1e817:	c1 e9 10             	shr    $0x10,%ecx
   1e81a:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1e821:	0f b6 d1             	movzbl %cl,%edx
   1e824:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1e82b:	0f b6 d5             	movzbl %ch,%edx
   1e82e:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1e835:	89 c1                	mov    %eax,%ecx
   1e837:	89 34 24             	mov    %esi,(%esp,1)
   1e83a:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1e83e:	0f b6 d1             	movzbl %cl,%edx
   1e841:	8b 45 40             	mov    0x40(%ebp),%eax
   1e844:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1e84b:	0f b6 d5             	movzbl %ch,%edx
   1e84e:	c1 e9 10             	shr    $0x10,%ecx
   1e851:	8b 7d 4c             	mov    0x4c(%ebp),%edi
   1e854:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1e85b:	0f b6 d1             	movzbl %cl,%edx
   1e85e:	8b 75 48             	mov    0x48(%ebp),%esi
   1e861:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1e868:	0f b6 d5             	movzbl %ch,%edx
   1e86b:	89 d9                	mov    %ebx,%ecx
   1e86d:	8b 5d 44             	mov    0x44(%ebp),%ebx
   1e870:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1e877:	0f b6 d1             	movzbl %cl,%edx
   1e87a:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1e881:	0f b6 d5             	movzbl %ch,%edx
   1e884:	c1 e9 10             	shr    $0x10,%ecx
   1e887:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1e88e:	0f b6 d1             	movzbl %cl,%edx
   1e891:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1e898:	0f b6 d5             	movzbl %ch,%edx
   1e89b:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1e8a2:	8b 0c 24             	mov    (%esp,1),%ecx
   1e8a5:	0f b6 d1             	movzbl %cl,%edx
   1e8a8:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1e8af:	0f b6 d5             	movzbl %ch,%edx
   1e8b2:	c1 e9 10             	shr    $0x10,%ecx
   1e8b5:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1e8bc:	0f b6 d1             	movzbl %cl,%edx
   1e8bf:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1e8c6:	0f b6 d5             	movzbl %ch,%edx
   1e8c9:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1e8d0:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1e8d4:	0f b6 d1             	movzbl %cl,%edx
   1e8d7:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1e8de:	0f b6 d5             	movzbl %ch,%edx
   1e8e1:	c1 e9 10             	shr    $0x10,%ecx
   1e8e4:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1e8eb:	0f b6 d1             	movzbl %cl,%edx
   1e8ee:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1e8f5:	0f b6 d5             	movzbl %ch,%edx
   1e8f8:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1e8ff:	89 c1                	mov    %eax,%ecx
   1e901:	89 34 24             	mov    %esi,(%esp,1)
   1e904:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1e908:	0f b6 d1             	movzbl %cl,%edx
   1e90b:	8b 45 50             	mov    0x50(%ebp),%eax
   1e90e:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1e915:	0f b6 d5             	movzbl %ch,%edx
   1e918:	c1 e9 10             	shr    $0x10,%ecx
   1e91b:	8b 7d 5c             	mov    0x5c(%ebp),%edi
   1e91e:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1e925:	0f b6 d1             	movzbl %cl,%edx
   1e928:	8b 75 58             	mov    0x58(%ebp),%esi
   1e92b:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1e932:	0f b6 d5             	movzbl %ch,%edx
   1e935:	89 d9                	mov    %ebx,%ecx
   1e937:	8b 5d 54             	mov    0x54(%ebp),%ebx
   1e93a:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1e941:	0f b6 d1             	movzbl %cl,%edx
   1e944:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1e94b:	0f b6 d5             	movzbl %ch,%edx
   1e94e:	c1 e9 10             	shr    $0x10,%ecx
   1e951:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1e958:	0f b6 d1             	movzbl %cl,%edx
   1e95b:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1e962:	0f b6 d5             	movzbl %ch,%edx
   1e965:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1e96c:	8b 0c 24             	mov    (%esp,1),%ecx
   1e96f:	0f b6 d1             	movzbl %cl,%edx
   1e972:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1e979:	0f b6 d5             	movzbl %ch,%edx
   1e97c:	c1 e9 10             	shr    $0x10,%ecx
   1e97f:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1e986:	0f b6 d1             	movzbl %cl,%edx
   1e989:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1e990:	0f b6 d5             	movzbl %ch,%edx
   1e993:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1e99a:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1e99e:	0f b6 d1             	movzbl %cl,%edx
   1e9a1:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1e9a8:	0f b6 d5             	movzbl %ch,%edx
   1e9ab:	c1 e9 10             	shr    $0x10,%ecx
   1e9ae:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1e9b5:	0f b6 d1             	movzbl %cl,%edx
   1e9b8:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1e9bf:	0f b6 d5             	movzbl %ch,%edx
   1e9c2:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1e9c9:	89 c1                	mov    %eax,%ecx
   1e9cb:	89 34 24             	mov    %esi,(%esp,1)
   1e9ce:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1e9d2:	0f b6 d1             	movzbl %cl,%edx
   1e9d5:	8b 45 60             	mov    0x60(%ebp),%eax
   1e9d8:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1e9df:	0f b6 d5             	movzbl %ch,%edx
   1e9e2:	c1 e9 10             	shr    $0x10,%ecx
   1e9e5:	8b 7d 6c             	mov    0x6c(%ebp),%edi
   1e9e8:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1e9ef:	0f b6 d1             	movzbl %cl,%edx
   1e9f2:	8b 75 68             	mov    0x68(%ebp),%esi
   1e9f5:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1e9fc:	0f b6 d5             	movzbl %ch,%edx
   1e9ff:	89 d9                	mov    %ebx,%ecx
   1ea01:	8b 5d 64             	mov    0x64(%ebp),%ebx
   1ea04:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1ea0b:	0f b6 d1             	movzbl %cl,%edx
   1ea0e:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1ea15:	0f b6 d5             	movzbl %ch,%edx
   1ea18:	c1 e9 10             	shr    $0x10,%ecx
   1ea1b:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1ea22:	0f b6 d1             	movzbl %cl,%edx
   1ea25:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1ea2c:	0f b6 d5             	movzbl %ch,%edx
   1ea2f:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1ea36:	8b 0c 24             	mov    (%esp,1),%ecx
   1ea39:	0f b6 d1             	movzbl %cl,%edx
   1ea3c:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1ea43:	0f b6 d5             	movzbl %ch,%edx
   1ea46:	c1 e9 10             	shr    $0x10,%ecx
   1ea49:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1ea50:	0f b6 d1             	movzbl %cl,%edx
   1ea53:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1ea5a:	0f b6 d5             	movzbl %ch,%edx
   1ea5d:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1ea64:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1ea68:	0f b6 d1             	movzbl %cl,%edx
   1ea6b:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1ea72:	0f b6 d5             	movzbl %ch,%edx
   1ea75:	c1 e9 10             	shr    $0x10,%ecx
   1ea78:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1ea7f:	0f b6 d1             	movzbl %cl,%edx
   1ea82:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1ea89:	0f b6 d5             	movzbl %ch,%edx
   1ea8c:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1ea93:	89 c1                	mov    %eax,%ecx
   1ea95:	89 34 24             	mov    %esi,(%esp,1)
   1ea98:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1ea9c:	0f b6 d1             	movzbl %cl,%edx
   1ea9f:	8b 45 70             	mov    0x70(%ebp),%eax
   1eaa2:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1eaa9:	0f b6 d5             	movzbl %ch,%edx
   1eaac:	c1 e9 10             	shr    $0x10,%ecx
   1eaaf:	8b 7d 7c             	mov    0x7c(%ebp),%edi
   1eab2:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1eab9:	0f b6 d1             	movzbl %cl,%edx
   1eabc:	8b 75 78             	mov    0x78(%ebp),%esi
   1eabf:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1eac6:	0f b6 d5             	movzbl %ch,%edx
   1eac9:	89 d9                	mov    %ebx,%ecx
   1eacb:	8b 5d 74             	mov    0x74(%ebp),%ebx
   1eace:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1ead5:	0f b6 d1             	movzbl %cl,%edx
   1ead8:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1eadf:	0f b6 d5             	movzbl %ch,%edx
   1eae2:	c1 e9 10             	shr    $0x10,%ecx
   1eae5:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1eaec:	0f b6 d1             	movzbl %cl,%edx
   1eaef:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1eaf6:	0f b6 d5             	movzbl %ch,%edx
   1eaf9:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1eb00:	8b 0c 24             	mov    (%esp,1),%ecx
   1eb03:	0f b6 d1             	movzbl %cl,%edx
   1eb06:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1eb0d:	0f b6 d5             	movzbl %ch,%edx
   1eb10:	c1 e9 10             	shr    $0x10,%ecx
   1eb13:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1eb1a:	0f b6 d1             	movzbl %cl,%edx
   1eb1d:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1eb24:	0f b6 d5             	movzbl %ch,%edx
   1eb27:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1eb2e:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1eb32:	0f b6 d1             	movzbl %cl,%edx
   1eb35:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1eb3c:	0f b6 d5             	movzbl %ch,%edx
   1eb3f:	c1 e9 10             	shr    $0x10,%ecx
   1eb42:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1eb49:	0f b6 d1             	movzbl %cl,%edx
   1eb4c:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1eb53:	0f b6 d5             	movzbl %ch,%edx
   1eb56:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1eb5d:	89 c1                	mov    %eax,%ecx
   1eb5f:	89 34 24             	mov    %esi,(%esp,1)
   1eb62:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1eb66:	0f b6 d1             	movzbl %cl,%edx
   1eb69:	8b 85 80 00 00 00    	mov    0x80(%ebp),%eax
   1eb6f:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1eb76:	0f b6 d5             	movzbl %ch,%edx
   1eb79:	c1 e9 10             	shr    $0x10,%ecx
   1eb7c:	8b bd 8c 00 00 00    	mov    0x8c(%ebp),%edi
   1eb82:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1eb89:	0f b6 d1             	movzbl %cl,%edx
   1eb8c:	8b b5 88 00 00 00    	mov    0x88(%ebp),%esi
   1eb92:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1eb99:	0f b6 d5             	movzbl %ch,%edx
   1eb9c:	89 d9                	mov    %ebx,%ecx
   1eb9e:	8b 9d 84 00 00 00    	mov    0x84(%ebp),%ebx
   1eba4:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1ebab:	0f b6 d1             	movzbl %cl,%edx
   1ebae:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1ebb5:	0f b6 d5             	movzbl %ch,%edx
   1ebb8:	c1 e9 10             	shr    $0x10,%ecx
   1ebbb:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1ebc2:	0f b6 d1             	movzbl %cl,%edx
   1ebc5:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1ebcc:	0f b6 d5             	movzbl %ch,%edx
   1ebcf:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1ebd6:	8b 0c 24             	mov    (%esp,1),%ecx
   1ebd9:	0f b6 d1             	movzbl %cl,%edx
   1ebdc:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1ebe3:	0f b6 d5             	movzbl %ch,%edx
   1ebe6:	c1 e9 10             	shr    $0x10,%ecx
   1ebe9:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1ebf0:	0f b6 d1             	movzbl %cl,%edx
   1ebf3:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1ebfa:	0f b6 d5             	movzbl %ch,%edx
   1ebfd:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1ec04:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1ec08:	0f b6 d1             	movzbl %cl,%edx
   1ec0b:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1ec12:	0f b6 d5             	movzbl %ch,%edx
   1ec15:	c1 e9 10             	shr    $0x10,%ecx
   1ec18:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1ec1f:	0f b6 d1             	movzbl %cl,%edx
   1ec22:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1ec29:	0f b6 d5             	movzbl %ch,%edx
   1ec2c:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1ec33:	89 c1                	mov    %eax,%ecx
   1ec35:	89 34 24             	mov    %esi,(%esp,1)
   1ec38:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1ec3c:	0f b6 d1             	movzbl %cl,%edx
   1ec3f:	8b 85 90 00 00 00    	mov    0x90(%ebp),%eax
   1ec45:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1ec4c:	0f b6 d5             	movzbl %ch,%edx
   1ec4f:	c1 e9 10             	shr    $0x10,%ecx
   1ec52:	8b bd 9c 00 00 00    	mov    0x9c(%ebp),%edi
   1ec58:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1ec5f:	0f b6 d1             	movzbl %cl,%edx
   1ec62:	8b b5 98 00 00 00    	mov    0x98(%ebp),%esi
   1ec68:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1ec6f:	0f b6 d5             	movzbl %ch,%edx
   1ec72:	89 d9                	mov    %ebx,%ecx
   1ec74:	8b 9d 94 00 00 00    	mov    0x94(%ebp),%ebx
   1ec7a:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1ec81:	0f b6 d1             	movzbl %cl,%edx
   1ec84:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1ec8b:	0f b6 d5             	movzbl %ch,%edx
   1ec8e:	c1 e9 10             	shr    $0x10,%ecx
   1ec91:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1ec98:	0f b6 d1             	movzbl %cl,%edx
   1ec9b:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1eca2:	0f b6 d5             	movzbl %ch,%edx
   1eca5:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1ecac:	8b 0c 24             	mov    (%esp,1),%ecx
   1ecaf:	0f b6 d1             	movzbl %cl,%edx
   1ecb2:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1ecb9:	0f b6 d5             	movzbl %ch,%edx
   1ecbc:	c1 e9 10             	shr    $0x10,%ecx
   1ecbf:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1ecc6:	0f b6 d1             	movzbl %cl,%edx
   1ecc9:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1ecd0:	0f b6 d5             	movzbl %ch,%edx
   1ecd3:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1ecda:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1ecde:	0f b6 d1             	movzbl %cl,%edx
   1ece1:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1ece8:	0f b6 d5             	movzbl %ch,%edx
   1eceb:	c1 e9 10             	shr    $0x10,%ecx
   1ecee:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1ecf5:	0f b6 d1             	movzbl %cl,%edx
   1ecf8:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1ecff:	0f b6 d5             	movzbl %ch,%edx
   1ed02:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1ed09:	89 c1                	mov    %eax,%ecx
   1ed0b:	89 34 24             	mov    %esi,(%esp,1)
   1ed0e:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1ed12:	0f b6 d1             	movzbl %cl,%edx
   1ed15:	8b 85 a0 00 00 00    	mov    0xa0(%ebp),%eax
   1ed1b:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1ed22:	0f b6 d5             	movzbl %ch,%edx
   1ed25:	c1 e9 10             	shr    $0x10,%ecx
   1ed28:	8b bd ac 00 00 00    	mov    0xac(%ebp),%edi
   1ed2e:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1ed35:	0f b6 d1             	movzbl %cl,%edx
   1ed38:	8b b5 a8 00 00 00    	mov    0xa8(%ebp),%esi
   1ed3e:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1ed45:	0f b6 d5             	movzbl %ch,%edx
   1ed48:	89 d9                	mov    %ebx,%ecx
   1ed4a:	8b 9d a4 00 00 00    	mov    0xa4(%ebp),%ebx
   1ed50:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1ed57:	0f b6 d1             	movzbl %cl,%edx
   1ed5a:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1ed61:	0f b6 d5             	movzbl %ch,%edx
   1ed64:	c1 e9 10             	shr    $0x10,%ecx
   1ed67:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1ed6e:	0f b6 d1             	movzbl %cl,%edx
   1ed71:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1ed78:	0f b6 d5             	movzbl %ch,%edx
   1ed7b:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1ed82:	8b 0c 24             	mov    (%esp,1),%ecx
   1ed85:	0f b6 d1             	movzbl %cl,%edx
   1ed88:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1ed8f:	0f b6 d5             	movzbl %ch,%edx
   1ed92:	c1 e9 10             	shr    $0x10,%ecx
   1ed95:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1ed9c:	0f b6 d1             	movzbl %cl,%edx
   1ed9f:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1eda6:	0f b6 d5             	movzbl %ch,%edx
   1eda9:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1edb0:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1edb4:	0f b6 d1             	movzbl %cl,%edx
   1edb7:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1edbe:	0f b6 d5             	movzbl %ch,%edx
   1edc1:	c1 e9 10             	shr    $0x10,%ecx
   1edc4:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1edcb:	0f b6 d1             	movzbl %cl,%edx
   1edce:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1edd5:	0f b6 d5             	movzbl %ch,%edx
   1edd8:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1eddf:	8b 6c 24 20          	mov    0x20(%esp,1),%ebp
   1ede3:	89 7d 0c             	mov    %edi,0xc(%ebp)
   1ede6:	89 75 08             	mov    %esi,0x8(%ebp)
   1ede9:	89 5d 04             	mov    %ebx,0x4(%ebp)
   1edec:	89 45 00             	mov    %eax,0x0(%ebp)
   1edef:	31 c0                	xor    %eax,%eax

0001edf1 <aes_encrypt.4>:
   1edf1:	8b 6c 24 14          	mov    0x14(%esp,1),%ebp
   1edf5:	8b 5c 24 10          	mov    0x10(%esp,1),%ebx
   1edf9:	8b 74 24 0c          	mov    0xc(%esp,1),%esi
   1edfd:	8b 7c 24 08          	mov    0x8(%esp,1),%edi
   1ee01:	8d 64 24 18          	lea    0x18(%esp,1),%esp
   1ee05:	c3                   	ret    

0001ee06 <aes_decrypt>:
   1ee06:	83 ec 18             	sub    $0x18,%esp
   1ee09:	89 6c 24 14          	mov    %ebp,0x14(%esp,1)
   1ee0d:	89 5c 24 10          	mov    %ebx,0x10(%esp,1)
   1ee11:	89 74 24 0c          	mov    %esi,0xc(%esp,1)
   1ee15:	89 7c 24 08          	mov    %edi,0x8(%esp,1)
   1ee19:	8b 4c 24 1c          	mov    0x1c(%esp,1),%ecx
   1ee1d:	8b 6c 24 24          	mov    0x24(%esp,1),%ebp
   1ee21:	8b 01                	mov    (%ecx),%eax
   1ee23:	8b 59 04             	mov    0x4(%ecx),%ebx
   1ee26:	8b 71 08             	mov    0x8(%ecx),%esi
   1ee29:	8b 79 0c             	mov    0xc(%ecx),%edi
   1ee2c:	8b 8d f0 00 00 00    	mov    0xf0(%ebp),%ecx
   1ee32:	8d 14 8d 00 00 00 00 	lea    0x0(,%ecx,4),%edx
   1ee39:	8d 54 95 00          	lea    0x0(%ebp,%edx,4),%edx
   1ee3d:	33 02                	xor    (%edx),%eax
   1ee3f:	33 5a 04             	xor    0x4(%edx),%ebx
   1ee42:	33 72 08             	xor    0x8(%edx),%esi
   1ee45:	33 7a 0c             	xor    0xc(%edx),%edi
   1ee48:	83 f9 0a             	cmp    $0xa,%ecx
   1ee4b:	0f 84 70 03 00 00    	je     1f1c1 <aes_decrypt.3>
   1ee51:	83 f9 0c             	cmp    $0xc,%ecx
   1ee54:	0f 84 bb 01 00 00    	je     1f015 <aes_decrypt.2>
   1ee5a:	83 f9 0e             	cmp    $0xe,%ecx
   1ee5d:	74 0a                	je     1ee69 <aes_decrypt.1>
   1ee5f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1ee64:	e9 66 0b 00 00       	jmp    1f9cf <aes_decrypt.4>

0001ee69 <aes_decrypt.1>:
   1ee69:	89 c1                	mov    %eax,%ecx
   1ee6b:	89 1c 24             	mov    %ebx,(%esp,1)
   1ee6e:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   1ee72:	0f b6 d1             	movzbl %cl,%edx
   1ee75:	8b 85 d0 00 00 00    	mov    0xd0(%ebp),%eax
   1ee7b:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1ee82:	0f b6 d5             	movzbl %ch,%edx
   1ee85:	c1 e9 10             	shr    $0x10,%ecx
   1ee88:	8b 9d d4 00 00 00    	mov    0xd4(%ebp),%ebx
   1ee8e:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1ee95:	0f b6 d1             	movzbl %cl,%edx
   1ee98:	8b b5 d8 00 00 00    	mov    0xd8(%ebp),%esi
   1ee9e:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1eea5:	0f b6 d5             	movzbl %ch,%edx
   1eea8:	89 f9                	mov    %edi,%ecx
   1eeaa:	8b bd dc 00 00 00    	mov    0xdc(%ebp),%edi
   1eeb0:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1eeb7:	0f b6 d1             	movzbl %cl,%edx
   1eeba:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1eec1:	0f b6 d5             	movzbl %ch,%edx
   1eec4:	c1 e9 10             	shr    $0x10,%ecx
   1eec7:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1eece:	0f b6 d1             	movzbl %cl,%edx
   1eed1:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1eed8:	0f b6 d5             	movzbl %ch,%edx
   1eedb:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1eee2:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1eee6:	0f b6 d1             	movzbl %cl,%edx
   1eee9:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1eef0:	0f b6 d5             	movzbl %ch,%edx
   1eef3:	c1 e9 10             	shr    $0x10,%ecx
   1eef6:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1eefd:	0f b6 d1             	movzbl %cl,%edx
   1ef00:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1ef07:	0f b6 d5             	movzbl %ch,%edx
   1ef0a:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1ef11:	8b 0c 24             	mov    (%esp,1),%ecx
   1ef14:	0f b6 d1             	movzbl %cl,%edx
   1ef17:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1ef1e:	0f b6 d5             	movzbl %ch,%edx
   1ef21:	c1 e9 10             	shr    $0x10,%ecx
   1ef24:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1ef2b:	0f b6 d1             	movzbl %cl,%edx
   1ef2e:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1ef35:	0f b6 d5             	movzbl %ch,%edx
   1ef38:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1ef3f:	89 c1                	mov    %eax,%ecx
   1ef41:	89 1c 24             	mov    %ebx,(%esp,1)
   1ef44:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   1ef48:	0f b6 d1             	movzbl %cl,%edx
   1ef4b:	8b 85 c0 00 00 00    	mov    0xc0(%ebp),%eax
   1ef51:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1ef58:	0f b6 d5             	movzbl %ch,%edx
   1ef5b:	c1 e9 10             	shr    $0x10,%ecx
   1ef5e:	8b 9d c4 00 00 00    	mov    0xc4(%ebp),%ebx
   1ef64:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1ef6b:	0f b6 d1             	movzbl %cl,%edx
   1ef6e:	8b b5 c8 00 00 00    	mov    0xc8(%ebp),%esi
   1ef74:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1ef7b:	0f b6 d5             	movzbl %ch,%edx
   1ef7e:	89 f9                	mov    %edi,%ecx
   1ef80:	8b bd cc 00 00 00    	mov    0xcc(%ebp),%edi
   1ef86:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1ef8d:	0f b6 d1             	movzbl %cl,%edx
   1ef90:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1ef97:	0f b6 d5             	movzbl %ch,%edx
   1ef9a:	c1 e9 10             	shr    $0x10,%ecx
   1ef9d:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1efa4:	0f b6 d1             	movzbl %cl,%edx
   1efa7:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1efae:	0f b6 d5             	movzbl %ch,%edx
   1efb1:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1efb8:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1efbc:	0f b6 d1             	movzbl %cl,%edx
   1efbf:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1efc6:	0f b6 d5             	movzbl %ch,%edx
   1efc9:	c1 e9 10             	shr    $0x10,%ecx
   1efcc:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1efd3:	0f b6 d1             	movzbl %cl,%edx
   1efd6:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1efdd:	0f b6 d5             	movzbl %ch,%edx
   1efe0:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1efe7:	8b 0c 24             	mov    (%esp,1),%ecx
   1efea:	0f b6 d1             	movzbl %cl,%edx
   1efed:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1eff4:	0f b6 d5             	movzbl %ch,%edx
   1eff7:	c1 e9 10             	shr    $0x10,%ecx
   1effa:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1f001:	0f b6 d1             	movzbl %cl,%edx
   1f004:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1f00b:	0f b6 d5             	movzbl %ch,%edx
   1f00e:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax

0001f015 <aes_decrypt.2>:
   1f015:	89 c1                	mov    %eax,%ecx
   1f017:	89 1c 24             	mov    %ebx,(%esp,1)
   1f01a:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   1f01e:	0f b6 d1             	movzbl %cl,%edx
   1f021:	8b 85 b0 00 00 00    	mov    0xb0(%ebp),%eax
   1f027:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1f02e:	0f b6 d5             	movzbl %ch,%edx
   1f031:	c1 e9 10             	shr    $0x10,%ecx
   1f034:	8b 9d b4 00 00 00    	mov    0xb4(%ebp),%ebx
   1f03a:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1f041:	0f b6 d1             	movzbl %cl,%edx
   1f044:	8b b5 b8 00 00 00    	mov    0xb8(%ebp),%esi
   1f04a:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1f051:	0f b6 d5             	movzbl %ch,%edx
   1f054:	89 f9                	mov    %edi,%ecx
   1f056:	8b bd bc 00 00 00    	mov    0xbc(%ebp),%edi
   1f05c:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1f063:	0f b6 d1             	movzbl %cl,%edx
   1f066:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1f06d:	0f b6 d5             	movzbl %ch,%edx
   1f070:	c1 e9 10             	shr    $0x10,%ecx
   1f073:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1f07a:	0f b6 d1             	movzbl %cl,%edx
   1f07d:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1f084:	0f b6 d5             	movzbl %ch,%edx
   1f087:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1f08e:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1f092:	0f b6 d1             	movzbl %cl,%edx
   1f095:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1f09c:	0f b6 d5             	movzbl %ch,%edx
   1f09f:	c1 e9 10             	shr    $0x10,%ecx
   1f0a2:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1f0a9:	0f b6 d1             	movzbl %cl,%edx
   1f0ac:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1f0b3:	0f b6 d5             	movzbl %ch,%edx
   1f0b6:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1f0bd:	8b 0c 24             	mov    (%esp,1),%ecx
   1f0c0:	0f b6 d1             	movzbl %cl,%edx
   1f0c3:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1f0ca:	0f b6 d5             	movzbl %ch,%edx
   1f0cd:	c1 e9 10             	shr    $0x10,%ecx
   1f0d0:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1f0d7:	0f b6 d1             	movzbl %cl,%edx
   1f0da:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1f0e1:	0f b6 d5             	movzbl %ch,%edx
   1f0e4:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1f0eb:	89 c1                	mov    %eax,%ecx
   1f0ed:	89 1c 24             	mov    %ebx,(%esp,1)
   1f0f0:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   1f0f4:	0f b6 d1             	movzbl %cl,%edx
   1f0f7:	8b 85 a0 00 00 00    	mov    0xa0(%ebp),%eax
   1f0fd:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1f104:	0f b6 d5             	movzbl %ch,%edx
   1f107:	c1 e9 10             	shr    $0x10,%ecx
   1f10a:	8b 9d a4 00 00 00    	mov    0xa4(%ebp),%ebx
   1f110:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1f117:	0f b6 d1             	movzbl %cl,%edx
   1f11a:	8b b5 a8 00 00 00    	mov    0xa8(%ebp),%esi
   1f120:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1f127:	0f b6 d5             	movzbl %ch,%edx
   1f12a:	89 f9                	mov    %edi,%ecx
   1f12c:	8b bd ac 00 00 00    	mov    0xac(%ebp),%edi
   1f132:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1f139:	0f b6 d1             	movzbl %cl,%edx
   1f13c:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1f143:	0f b6 d5             	movzbl %ch,%edx
   1f146:	c1 e9 10             	shr    $0x10,%ecx
   1f149:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1f150:	0f b6 d1             	movzbl %cl,%edx
   1f153:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1f15a:	0f b6 d5             	movzbl %ch,%edx
   1f15d:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1f164:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1f168:	0f b6 d1             	movzbl %cl,%edx
   1f16b:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1f172:	0f b6 d5             	movzbl %ch,%edx
   1f175:	c1 e9 10             	shr    $0x10,%ecx
   1f178:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1f17f:	0f b6 d1             	movzbl %cl,%edx
   1f182:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1f189:	0f b6 d5             	movzbl %ch,%edx
   1f18c:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1f193:	8b 0c 24             	mov    (%esp,1),%ecx
   1f196:	0f b6 d1             	movzbl %cl,%edx
   1f199:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1f1a0:	0f b6 d5             	movzbl %ch,%edx
   1f1a3:	c1 e9 10             	shr    $0x10,%ecx
   1f1a6:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1f1ad:	0f b6 d1             	movzbl %cl,%edx
   1f1b0:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1f1b7:	0f b6 d5             	movzbl %ch,%edx
   1f1ba:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax

0001f1c1 <aes_decrypt.3>:
   1f1c1:	89 c1                	mov    %eax,%ecx
   1f1c3:	89 1c 24             	mov    %ebx,(%esp,1)
   1f1c6:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   1f1ca:	0f b6 d1             	movzbl %cl,%edx
   1f1cd:	8b 85 90 00 00 00    	mov    0x90(%ebp),%eax
   1f1d3:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1f1da:	0f b6 d5             	movzbl %ch,%edx
   1f1dd:	c1 e9 10             	shr    $0x10,%ecx
   1f1e0:	8b 9d 94 00 00 00    	mov    0x94(%ebp),%ebx
   1f1e6:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1f1ed:	0f b6 d1             	movzbl %cl,%edx
   1f1f0:	8b b5 98 00 00 00    	mov    0x98(%ebp),%esi
   1f1f6:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1f1fd:	0f b6 d5             	movzbl %ch,%edx
   1f200:	89 f9                	mov    %edi,%ecx
   1f202:	8b bd 9c 00 00 00    	mov    0x9c(%ebp),%edi
   1f208:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1f20f:	0f b6 d1             	movzbl %cl,%edx
   1f212:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1f219:	0f b6 d5             	movzbl %ch,%edx
   1f21c:	c1 e9 10             	shr    $0x10,%ecx
   1f21f:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1f226:	0f b6 d1             	movzbl %cl,%edx
   1f229:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1f230:	0f b6 d5             	movzbl %ch,%edx
   1f233:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1f23a:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1f23e:	0f b6 d1             	movzbl %cl,%edx
   1f241:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1f248:	0f b6 d5             	movzbl %ch,%edx
   1f24b:	c1 e9 10             	shr    $0x10,%ecx
   1f24e:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1f255:	0f b6 d1             	movzbl %cl,%edx
   1f258:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1f25f:	0f b6 d5             	movzbl %ch,%edx
   1f262:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1f269:	8b 0c 24             	mov    (%esp,1),%ecx
   1f26c:	0f b6 d1             	movzbl %cl,%edx
   1f26f:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1f276:	0f b6 d5             	movzbl %ch,%edx
   1f279:	c1 e9 10             	shr    $0x10,%ecx
   1f27c:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1f283:	0f b6 d1             	movzbl %cl,%edx
   1f286:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1f28d:	0f b6 d5             	movzbl %ch,%edx
   1f290:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1f297:	89 c1                	mov    %eax,%ecx
   1f299:	89 1c 24             	mov    %ebx,(%esp,1)
   1f29c:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   1f2a0:	0f b6 d1             	movzbl %cl,%edx
   1f2a3:	8b 85 80 00 00 00    	mov    0x80(%ebp),%eax
   1f2a9:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1f2b0:	0f b6 d5             	movzbl %ch,%edx
   1f2b3:	c1 e9 10             	shr    $0x10,%ecx
   1f2b6:	8b 9d 84 00 00 00    	mov    0x84(%ebp),%ebx
   1f2bc:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1f2c3:	0f b6 d1             	movzbl %cl,%edx
   1f2c6:	8b b5 88 00 00 00    	mov    0x88(%ebp),%esi
   1f2cc:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1f2d3:	0f b6 d5             	movzbl %ch,%edx
   1f2d6:	89 f9                	mov    %edi,%ecx
   1f2d8:	8b bd 8c 00 00 00    	mov    0x8c(%ebp),%edi
   1f2de:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1f2e5:	0f b6 d1             	movzbl %cl,%edx
   1f2e8:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1f2ef:	0f b6 d5             	movzbl %ch,%edx
   1f2f2:	c1 e9 10             	shr    $0x10,%ecx
   1f2f5:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1f2fc:	0f b6 d1             	movzbl %cl,%edx
   1f2ff:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1f306:	0f b6 d5             	movzbl %ch,%edx
   1f309:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1f310:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1f314:	0f b6 d1             	movzbl %cl,%edx
   1f317:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1f31e:	0f b6 d5             	movzbl %ch,%edx
   1f321:	c1 e9 10             	shr    $0x10,%ecx
   1f324:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1f32b:	0f b6 d1             	movzbl %cl,%edx
   1f32e:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1f335:	0f b6 d5             	movzbl %ch,%edx
   1f338:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1f33f:	8b 0c 24             	mov    (%esp,1),%ecx
   1f342:	0f b6 d1             	movzbl %cl,%edx
   1f345:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1f34c:	0f b6 d5             	movzbl %ch,%edx
   1f34f:	c1 e9 10             	shr    $0x10,%ecx
   1f352:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1f359:	0f b6 d1             	movzbl %cl,%edx
   1f35c:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1f363:	0f b6 d5             	movzbl %ch,%edx
   1f366:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1f36d:	89 c1                	mov    %eax,%ecx
   1f36f:	89 1c 24             	mov    %ebx,(%esp,1)
   1f372:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   1f376:	0f b6 d1             	movzbl %cl,%edx
   1f379:	8b 45 70             	mov    0x70(%ebp),%eax
   1f37c:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1f383:	0f b6 d5             	movzbl %ch,%edx
   1f386:	c1 e9 10             	shr    $0x10,%ecx
   1f389:	8b 5d 74             	mov    0x74(%ebp),%ebx
   1f38c:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1f393:	0f b6 d1             	movzbl %cl,%edx
   1f396:	8b 75 78             	mov    0x78(%ebp),%esi
   1f399:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1f3a0:	0f b6 d5             	movzbl %ch,%edx
   1f3a3:	89 f9                	mov    %edi,%ecx
   1f3a5:	8b 7d 7c             	mov    0x7c(%ebp),%edi
   1f3a8:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1f3af:	0f b6 d1             	movzbl %cl,%edx
   1f3b2:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1f3b9:	0f b6 d5             	movzbl %ch,%edx
   1f3bc:	c1 e9 10             	shr    $0x10,%ecx
   1f3bf:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1f3c6:	0f b6 d1             	movzbl %cl,%edx
   1f3c9:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1f3d0:	0f b6 d5             	movzbl %ch,%edx
   1f3d3:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1f3da:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1f3de:	0f b6 d1             	movzbl %cl,%edx
   1f3e1:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1f3e8:	0f b6 d5             	movzbl %ch,%edx
   1f3eb:	c1 e9 10             	shr    $0x10,%ecx
   1f3ee:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1f3f5:	0f b6 d1             	movzbl %cl,%edx
   1f3f8:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1f3ff:	0f b6 d5             	movzbl %ch,%edx
   1f402:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1f409:	8b 0c 24             	mov    (%esp,1),%ecx
   1f40c:	0f b6 d1             	movzbl %cl,%edx
   1f40f:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1f416:	0f b6 d5             	movzbl %ch,%edx
   1f419:	c1 e9 10             	shr    $0x10,%ecx
   1f41c:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1f423:	0f b6 d1             	movzbl %cl,%edx
   1f426:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1f42d:	0f b6 d5             	movzbl %ch,%edx
   1f430:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1f437:	89 c1                	mov    %eax,%ecx
   1f439:	89 1c 24             	mov    %ebx,(%esp,1)
   1f43c:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   1f440:	0f b6 d1             	movzbl %cl,%edx
   1f443:	8b 45 60             	mov    0x60(%ebp),%eax
   1f446:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1f44d:	0f b6 d5             	movzbl %ch,%edx
   1f450:	c1 e9 10             	shr    $0x10,%ecx
   1f453:	8b 5d 64             	mov    0x64(%ebp),%ebx
   1f456:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1f45d:	0f b6 d1             	movzbl %cl,%edx
   1f460:	8b 75 68             	mov    0x68(%ebp),%esi
   1f463:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1f46a:	0f b6 d5             	movzbl %ch,%edx
   1f46d:	89 f9                	mov    %edi,%ecx
   1f46f:	8b 7d 6c             	mov    0x6c(%ebp),%edi
   1f472:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1f479:	0f b6 d1             	movzbl %cl,%edx
   1f47c:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1f483:	0f b6 d5             	movzbl %ch,%edx
   1f486:	c1 e9 10             	shr    $0x10,%ecx
   1f489:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1f490:	0f b6 d1             	movzbl %cl,%edx
   1f493:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1f49a:	0f b6 d5             	movzbl %ch,%edx
   1f49d:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1f4a4:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1f4a8:	0f b6 d1             	movzbl %cl,%edx
   1f4ab:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1f4b2:	0f b6 d5             	movzbl %ch,%edx
   1f4b5:	c1 e9 10             	shr    $0x10,%ecx
   1f4b8:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1f4bf:	0f b6 d1             	movzbl %cl,%edx
   1f4c2:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1f4c9:	0f b6 d5             	movzbl %ch,%edx
   1f4cc:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1f4d3:	8b 0c 24             	mov    (%esp,1),%ecx
   1f4d6:	0f b6 d1             	movzbl %cl,%edx
   1f4d9:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1f4e0:	0f b6 d5             	movzbl %ch,%edx
   1f4e3:	c1 e9 10             	shr    $0x10,%ecx
   1f4e6:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1f4ed:	0f b6 d1             	movzbl %cl,%edx
   1f4f0:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1f4f7:	0f b6 d5             	movzbl %ch,%edx
   1f4fa:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1f501:	89 c1                	mov    %eax,%ecx
   1f503:	89 1c 24             	mov    %ebx,(%esp,1)
   1f506:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   1f50a:	0f b6 d1             	movzbl %cl,%edx
   1f50d:	8b 45 50             	mov    0x50(%ebp),%eax
   1f510:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1f517:	0f b6 d5             	movzbl %ch,%edx
   1f51a:	c1 e9 10             	shr    $0x10,%ecx
   1f51d:	8b 5d 54             	mov    0x54(%ebp),%ebx
   1f520:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1f527:	0f b6 d1             	movzbl %cl,%edx
   1f52a:	8b 75 58             	mov    0x58(%ebp),%esi
   1f52d:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1f534:	0f b6 d5             	movzbl %ch,%edx
   1f537:	89 f9                	mov    %edi,%ecx
   1f539:	8b 7d 5c             	mov    0x5c(%ebp),%edi
   1f53c:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1f543:	0f b6 d1             	movzbl %cl,%edx
   1f546:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1f54d:	0f b6 d5             	movzbl %ch,%edx
   1f550:	c1 e9 10             	shr    $0x10,%ecx
   1f553:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1f55a:	0f b6 d1             	movzbl %cl,%edx
   1f55d:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1f564:	0f b6 d5             	movzbl %ch,%edx
   1f567:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1f56e:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1f572:	0f b6 d1             	movzbl %cl,%edx
   1f575:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1f57c:	0f b6 d5             	movzbl %ch,%edx
   1f57f:	c1 e9 10             	shr    $0x10,%ecx
   1f582:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1f589:	0f b6 d1             	movzbl %cl,%edx
   1f58c:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1f593:	0f b6 d5             	movzbl %ch,%edx
   1f596:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1f59d:	8b 0c 24             	mov    (%esp,1),%ecx
   1f5a0:	0f b6 d1             	movzbl %cl,%edx
   1f5a3:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1f5aa:	0f b6 d5             	movzbl %ch,%edx
   1f5ad:	c1 e9 10             	shr    $0x10,%ecx
   1f5b0:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1f5b7:	0f b6 d1             	movzbl %cl,%edx
   1f5ba:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1f5c1:	0f b6 d5             	movzbl %ch,%edx
   1f5c4:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1f5cb:	89 c1                	mov    %eax,%ecx
   1f5cd:	89 1c 24             	mov    %ebx,(%esp,1)
   1f5d0:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   1f5d4:	0f b6 d1             	movzbl %cl,%edx
   1f5d7:	8b 45 40             	mov    0x40(%ebp),%eax
   1f5da:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1f5e1:	0f b6 d5             	movzbl %ch,%edx
   1f5e4:	c1 e9 10             	shr    $0x10,%ecx
   1f5e7:	8b 5d 44             	mov    0x44(%ebp),%ebx
   1f5ea:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1f5f1:	0f b6 d1             	movzbl %cl,%edx
   1f5f4:	8b 75 48             	mov    0x48(%ebp),%esi
   1f5f7:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1f5fe:	0f b6 d5             	movzbl %ch,%edx
   1f601:	89 f9                	mov    %edi,%ecx
   1f603:	8b 7d 4c             	mov    0x4c(%ebp),%edi
   1f606:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1f60d:	0f b6 d1             	movzbl %cl,%edx
   1f610:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1f617:	0f b6 d5             	movzbl %ch,%edx
   1f61a:	c1 e9 10             	shr    $0x10,%ecx
   1f61d:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1f624:	0f b6 d1             	movzbl %cl,%edx
   1f627:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1f62e:	0f b6 d5             	movzbl %ch,%edx
   1f631:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1f638:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1f63c:	0f b6 d1             	movzbl %cl,%edx
   1f63f:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1f646:	0f b6 d5             	movzbl %ch,%edx
   1f649:	c1 e9 10             	shr    $0x10,%ecx
   1f64c:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1f653:	0f b6 d1             	movzbl %cl,%edx
   1f656:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1f65d:	0f b6 d5             	movzbl %ch,%edx
   1f660:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1f667:	8b 0c 24             	mov    (%esp,1),%ecx
   1f66a:	0f b6 d1             	movzbl %cl,%edx
   1f66d:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1f674:	0f b6 d5             	movzbl %ch,%edx
   1f677:	c1 e9 10             	shr    $0x10,%ecx
   1f67a:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1f681:	0f b6 d1             	movzbl %cl,%edx
   1f684:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1f68b:	0f b6 d5             	movzbl %ch,%edx
   1f68e:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1f695:	89 c1                	mov    %eax,%ecx
   1f697:	89 1c 24             	mov    %ebx,(%esp,1)
   1f69a:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   1f69e:	0f b6 d1             	movzbl %cl,%edx
   1f6a1:	8b 45 30             	mov    0x30(%ebp),%eax
   1f6a4:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1f6ab:	0f b6 d5             	movzbl %ch,%edx
   1f6ae:	c1 e9 10             	shr    $0x10,%ecx
   1f6b1:	8b 5d 34             	mov    0x34(%ebp),%ebx
   1f6b4:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1f6bb:	0f b6 d1             	movzbl %cl,%edx
   1f6be:	8b 75 38             	mov    0x38(%ebp),%esi
   1f6c1:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1f6c8:	0f b6 d5             	movzbl %ch,%edx
   1f6cb:	89 f9                	mov    %edi,%ecx
   1f6cd:	8b 7d 3c             	mov    0x3c(%ebp),%edi
   1f6d0:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1f6d7:	0f b6 d1             	movzbl %cl,%edx
   1f6da:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1f6e1:	0f b6 d5             	movzbl %ch,%edx
   1f6e4:	c1 e9 10             	shr    $0x10,%ecx
   1f6e7:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1f6ee:	0f b6 d1             	movzbl %cl,%edx
   1f6f1:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1f6f8:	0f b6 d5             	movzbl %ch,%edx
   1f6fb:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1f702:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1f706:	0f b6 d1             	movzbl %cl,%edx
   1f709:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1f710:	0f b6 d5             	movzbl %ch,%edx
   1f713:	c1 e9 10             	shr    $0x10,%ecx
   1f716:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1f71d:	0f b6 d1             	movzbl %cl,%edx
   1f720:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1f727:	0f b6 d5             	movzbl %ch,%edx
   1f72a:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1f731:	8b 0c 24             	mov    (%esp,1),%ecx
   1f734:	0f b6 d1             	movzbl %cl,%edx
   1f737:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1f73e:	0f b6 d5             	movzbl %ch,%edx
   1f741:	c1 e9 10             	shr    $0x10,%ecx
   1f744:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1f74b:	0f b6 d1             	movzbl %cl,%edx
   1f74e:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1f755:	0f b6 d5             	movzbl %ch,%edx
   1f758:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1f75f:	89 c1                	mov    %eax,%ecx
   1f761:	89 1c 24             	mov    %ebx,(%esp,1)
   1f764:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   1f768:	0f b6 d1             	movzbl %cl,%edx
   1f76b:	8b 45 20             	mov    0x20(%ebp),%eax
   1f76e:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1f775:	0f b6 d5             	movzbl %ch,%edx
   1f778:	c1 e9 10             	shr    $0x10,%ecx
   1f77b:	8b 5d 24             	mov    0x24(%ebp),%ebx
   1f77e:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1f785:	0f b6 d1             	movzbl %cl,%edx
   1f788:	8b 75 28             	mov    0x28(%ebp),%esi
   1f78b:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1f792:	0f b6 d5             	movzbl %ch,%edx
   1f795:	89 f9                	mov    %edi,%ecx
   1f797:	8b 7d 2c             	mov    0x2c(%ebp),%edi
   1f79a:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1f7a1:	0f b6 d1             	movzbl %cl,%edx
   1f7a4:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1f7ab:	0f b6 d5             	movzbl %ch,%edx
   1f7ae:	c1 e9 10             	shr    $0x10,%ecx
   1f7b1:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1f7b8:	0f b6 d1             	movzbl %cl,%edx
   1f7bb:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1f7c2:	0f b6 d5             	movzbl %ch,%edx
   1f7c5:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1f7cc:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1f7d0:	0f b6 d1             	movzbl %cl,%edx
   1f7d3:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1f7da:	0f b6 d5             	movzbl %ch,%edx
   1f7dd:	c1 e9 10             	shr    $0x10,%ecx
   1f7e0:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1f7e7:	0f b6 d1             	movzbl %cl,%edx
   1f7ea:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1f7f1:	0f b6 d5             	movzbl %ch,%edx
   1f7f4:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1f7fb:	8b 0c 24             	mov    (%esp,1),%ecx
   1f7fe:	0f b6 d1             	movzbl %cl,%edx
   1f801:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1f808:	0f b6 d5             	movzbl %ch,%edx
   1f80b:	c1 e9 10             	shr    $0x10,%ecx
   1f80e:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1f815:	0f b6 d1             	movzbl %cl,%edx
   1f818:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1f81f:	0f b6 d5             	movzbl %ch,%edx
   1f822:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1f829:	89 c1                	mov    %eax,%ecx
   1f82b:	89 1c 24             	mov    %ebx,(%esp,1)
   1f82e:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   1f832:	0f b6 d1             	movzbl %cl,%edx
   1f835:	8b 45 10             	mov    0x10(%ebp),%eax
   1f838:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1f83f:	0f b6 d5             	movzbl %ch,%edx
   1f842:	c1 e9 10             	shr    $0x10,%ecx
   1f845:	8b 5d 14             	mov    0x14(%ebp),%ebx
   1f848:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1f84f:	0f b6 d1             	movzbl %cl,%edx
   1f852:	8b 75 18             	mov    0x18(%ebp),%esi
   1f855:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1f85c:	0f b6 d5             	movzbl %ch,%edx
   1f85f:	89 f9                	mov    %edi,%ecx
   1f861:	8b 7d 1c             	mov    0x1c(%ebp),%edi
   1f864:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1f86b:	0f b6 d1             	movzbl %cl,%edx
   1f86e:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1f875:	0f b6 d5             	movzbl %ch,%edx
   1f878:	c1 e9 10             	shr    $0x10,%ecx
   1f87b:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1f882:	0f b6 d1             	movzbl %cl,%edx
   1f885:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1f88c:	0f b6 d5             	movzbl %ch,%edx
   1f88f:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1f896:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1f89a:	0f b6 d1             	movzbl %cl,%edx
   1f89d:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1f8a4:	0f b6 d5             	movzbl %ch,%edx
   1f8a7:	c1 e9 10             	shr    $0x10,%ecx
   1f8aa:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1f8b1:	0f b6 d1             	movzbl %cl,%edx
   1f8b4:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1f8bb:	0f b6 d5             	movzbl %ch,%edx
   1f8be:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1f8c5:	8b 0c 24             	mov    (%esp,1),%ecx
   1f8c8:	0f b6 d1             	movzbl %cl,%edx
   1f8cb:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1f8d2:	0f b6 d5             	movzbl %ch,%edx
   1f8d5:	c1 e9 10             	shr    $0x10,%ecx
   1f8d8:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1f8df:	0f b6 d1             	movzbl %cl,%edx
   1f8e2:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1f8e9:	0f b6 d5             	movzbl %ch,%edx
   1f8ec:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1f8f3:	89 c1                	mov    %eax,%ecx
   1f8f5:	89 1c 24             	mov    %ebx,(%esp,1)
   1f8f8:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   1f8fc:	0f b6 d1             	movzbl %cl,%edx
   1f8ff:	8b 45 00             	mov    0x0(%ebp),%eax
   1f902:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1f909:	0f b6 d5             	movzbl %ch,%edx
   1f90c:	c1 e9 10             	shr    $0x10,%ecx
   1f90f:	8b 5d 04             	mov    0x4(%ebp),%ebx
   1f912:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1f919:	0f b6 d1             	movzbl %cl,%edx
   1f91c:	8b 75 08             	mov    0x8(%ebp),%esi
   1f91f:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1f926:	0f b6 d5             	movzbl %ch,%edx
   1f929:	89 f9                	mov    %edi,%ecx
   1f92b:	8b 7d 0c             	mov    0xc(%ebp),%edi
   1f92e:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1f935:	0f b6 d1             	movzbl %cl,%edx
   1f938:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1f93f:	0f b6 d5             	movzbl %ch,%edx
   1f942:	c1 e9 10             	shr    $0x10,%ecx
   1f945:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1f94c:	0f b6 d1             	movzbl %cl,%edx
   1f94f:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1f956:	0f b6 d5             	movzbl %ch,%edx
   1f959:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1f960:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1f964:	0f b6 d1             	movzbl %cl,%edx
   1f967:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1f96e:	0f b6 d5             	movzbl %ch,%edx
   1f971:	c1 e9 10             	shr    $0x10,%ecx
   1f974:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1f97b:	0f b6 d1             	movzbl %cl,%edx
   1f97e:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1f985:	0f b6 d5             	movzbl %ch,%edx
   1f988:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1f98f:	8b 0c 24             	mov    (%esp,1),%ecx
   1f992:	0f b6 d1             	movzbl %cl,%edx
   1f995:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1f99c:	0f b6 d5             	movzbl %ch,%edx
   1f99f:	c1 e9 10             	shr    $0x10,%ecx
   1f9a2:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1f9a9:	0f b6 d1             	movzbl %cl,%edx
   1f9ac:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1f9b3:	0f b6 d5             	movzbl %ch,%edx
   1f9b6:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1f9bd:	8b 6c 24 20          	mov    0x20(%esp,1),%ebp
   1f9c1:	89 7d 0c             	mov    %edi,0xc(%ebp)
   1f9c4:	89 75 08             	mov    %esi,0x8(%ebp)
   1f9c7:	89 5d 04             	mov    %ebx,0x4(%ebp)
   1f9ca:	89 45 00             	mov    %eax,0x0(%ebp)
   1f9cd:	31 c0                	xor    %eax,%eax

0001f9cf <aes_decrypt.4>:
   1f9cf:	8b 6c 24 14          	mov    0x14(%esp,1),%ebp
   1f9d3:	8b 5c 24 10          	mov    0x10(%esp,1),%ebx
   1f9d7:	8b 74 24 0c          	mov    0xc(%esp,1),%esi
   1f9db:	8b 7c 24 08          	mov    0x8(%esp,1),%edi
   1f9df:	8d 64 24 18          	lea    0x18(%esp,1),%esp
   1f9e3:	c3                   	ret    

0001f9e4 <end>:
   1f9e4:	83 ec 18             	sub    $0x18,%esp
   1f9e7:	89 6c 24 14          	mov    %ebp,0x14(%esp,1)
   1f9eb:	89 5c 24 10          	mov    %ebx,0x10(%esp,1)
   1f9ef:	89 74 24 0c          	mov    %esi,0xc(%esp,1)
   1f9f3:	89 7c 24 08          	mov    %edi,0x8(%esp,1)
   1f9f7:	8b 4c 24 1c          	mov    0x1c(%esp,1),%ecx
   1f9fb:	8b 6c 24 24          	mov    0x24(%esp,1),%ebp
   1f9ff:	8b 01                	mov    (%ecx),%eax
   1fa01:	8b 59 04             	mov    0x4(%ecx),%ebx
   1fa04:	33 45 00             	xor    0x0(%ebp),%eax
   1fa07:	33 5d 04             	xor    0x4(%ebp),%ebx
   1fa0a:	8b 71 08             	mov    0x8(%ecx),%esi
   1fa0d:	8b 79 0c             	mov    0xc(%ecx),%edi
   1fa10:	33 75 08             	xor    0x8(%ebp),%esi
   1fa13:	33 7d 0c             	xor    0xc(%ebp),%edi
   1fa16:	8b 8d f0 00 00 00    	mov    0xf0(%ebp),%ecx
   1fa1c:	83 f9 0a             	cmp    $0xa,%ecx
   1fa1f:	0f 84 46 03 00 00    	je     1fd6b <end+0x387>
   1fa25:	8d 6d 20             	lea    0x20(%ebp),%ebp
   1fa28:	83 f9 0c             	cmp    $0xc,%ecx
   1fa2b:	0f 84 a6 01 00 00    	je     1fbd7 <end+0x1f3>
   1fa31:	8d 6d 20             	lea    0x20(%ebp),%ebp
   1fa34:	83 f9 0e             	cmp    $0xe,%ecx
   1fa37:	74 0a                	je     1fa43 <end+0x5f>
   1fa39:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1fa3e:	e9 42 0b 00 00       	jmp    20585 <end+0xba1>
   1fa43:	89 c1                	mov    %eax,%ecx
   1fa45:	89 34 24             	mov    %esi,(%esp,1)
   1fa48:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1fa4c:	0f b6 d1             	movzbl %cl,%edx
   1fa4f:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   1fa52:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1fa59:	0f b6 d5             	movzbl %ch,%edx
   1fa5c:	c1 e9 10             	shr    $0x10,%ecx
   1fa5f:	8b 7d dc             	mov    0xffffffdc(%ebp),%edi
   1fa62:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1fa69:	0f b6 d1             	movzbl %cl,%edx
   1fa6c:	8b 75 d8             	mov    0xffffffd8(%ebp),%esi
   1fa6f:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1fa76:	0f b6 d5             	movzbl %ch,%edx
   1fa79:	89 d9                	mov    %ebx,%ecx
   1fa7b:	8b 5d d4             	mov    0xffffffd4(%ebp),%ebx
   1fa7e:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1fa85:	0f b6 d1             	movzbl %cl,%edx
   1fa88:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1fa8f:	0f b6 d5             	movzbl %ch,%edx
   1fa92:	c1 e9 10             	shr    $0x10,%ecx
   1fa95:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1fa9c:	0f b6 d1             	movzbl %cl,%edx
   1fa9f:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1faa6:	0f b6 d5             	movzbl %ch,%edx
   1faa9:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1fab0:	8b 0c 24             	mov    (%esp,1),%ecx
   1fab3:	0f b6 d1             	movzbl %cl,%edx
   1fab6:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1fabd:	0f b6 d5             	movzbl %ch,%edx
   1fac0:	c1 e9 10             	shr    $0x10,%ecx
   1fac3:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1faca:	0f b6 d1             	movzbl %cl,%edx
   1facd:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1fad4:	0f b6 d5             	movzbl %ch,%edx
   1fad7:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1fade:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1fae2:	0f b6 d1             	movzbl %cl,%edx
   1fae5:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1faec:	0f b6 d5             	movzbl %ch,%edx
   1faef:	c1 e9 10             	shr    $0x10,%ecx
   1faf2:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1faf9:	0f b6 d1             	movzbl %cl,%edx
   1fafc:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1fb03:	0f b6 d5             	movzbl %ch,%edx
   1fb06:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1fb0d:	89 c1                	mov    %eax,%ecx
   1fb0f:	89 34 24             	mov    %esi,(%esp,1)
   1fb12:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1fb16:	0f b6 d1             	movzbl %cl,%edx
   1fb19:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   1fb1c:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1fb23:	0f b6 d5             	movzbl %ch,%edx
   1fb26:	c1 e9 10             	shr    $0x10,%ecx
   1fb29:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
   1fb2c:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1fb33:	0f b6 d1             	movzbl %cl,%edx
   1fb36:	8b 75 e8             	mov    0xffffffe8(%ebp),%esi
   1fb39:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1fb40:	0f b6 d5             	movzbl %ch,%edx
   1fb43:	89 d9                	mov    %ebx,%ecx
   1fb45:	8b 5d e4             	mov    0xffffffe4(%ebp),%ebx
   1fb48:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1fb4f:	0f b6 d1             	movzbl %cl,%edx
   1fb52:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1fb59:	0f b6 d5             	movzbl %ch,%edx
   1fb5c:	c1 e9 10             	shr    $0x10,%ecx
   1fb5f:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1fb66:	0f b6 d1             	movzbl %cl,%edx
   1fb69:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1fb70:	0f b6 d5             	movzbl %ch,%edx
   1fb73:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1fb7a:	8b 0c 24             	mov    (%esp,1),%ecx
   1fb7d:	0f b6 d1             	movzbl %cl,%edx
   1fb80:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1fb87:	0f b6 d5             	movzbl %ch,%edx
   1fb8a:	c1 e9 10             	shr    $0x10,%ecx
   1fb8d:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1fb94:	0f b6 d1             	movzbl %cl,%edx
   1fb97:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1fb9e:	0f b6 d5             	movzbl %ch,%edx
   1fba1:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1fba8:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1fbac:	0f b6 d1             	movzbl %cl,%edx
   1fbaf:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1fbb6:	0f b6 d5             	movzbl %ch,%edx
   1fbb9:	c1 e9 10             	shr    $0x10,%ecx
   1fbbc:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1fbc3:	0f b6 d1             	movzbl %cl,%edx
   1fbc6:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1fbcd:	0f b6 d5             	movzbl %ch,%edx
   1fbd0:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1fbd7:	89 c1                	mov    %eax,%ecx
   1fbd9:	89 34 24             	mov    %esi,(%esp,1)
   1fbdc:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1fbe0:	0f b6 d1             	movzbl %cl,%edx
   1fbe3:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   1fbe6:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1fbed:	0f b6 d5             	movzbl %ch,%edx
   1fbf0:	c1 e9 10             	shr    $0x10,%ecx
   1fbf3:	8b 7d fc             	mov    0xfffffffc(%ebp),%edi
   1fbf6:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1fbfd:	0f b6 d1             	movzbl %cl,%edx
   1fc00:	8b 75 f8             	mov    0xfffffff8(%ebp),%esi
   1fc03:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1fc0a:	0f b6 d5             	movzbl %ch,%edx
   1fc0d:	89 d9                	mov    %ebx,%ecx
   1fc0f:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
   1fc12:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1fc19:	0f b6 d1             	movzbl %cl,%edx
   1fc1c:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1fc23:	0f b6 d5             	movzbl %ch,%edx
   1fc26:	c1 e9 10             	shr    $0x10,%ecx
   1fc29:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1fc30:	0f b6 d1             	movzbl %cl,%edx
   1fc33:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1fc3a:	0f b6 d5             	movzbl %ch,%edx
   1fc3d:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1fc44:	8b 0c 24             	mov    (%esp,1),%ecx
   1fc47:	0f b6 d1             	movzbl %cl,%edx
   1fc4a:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1fc51:	0f b6 d5             	movzbl %ch,%edx
   1fc54:	c1 e9 10             	shr    $0x10,%ecx
   1fc57:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1fc5e:	0f b6 d1             	movzbl %cl,%edx
   1fc61:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1fc68:	0f b6 d5             	movzbl %ch,%edx
   1fc6b:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1fc72:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1fc76:	0f b6 d1             	movzbl %cl,%edx
   1fc79:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1fc80:	0f b6 d5             	movzbl %ch,%edx
   1fc83:	c1 e9 10             	shr    $0x10,%ecx
   1fc86:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1fc8d:	0f b6 d1             	movzbl %cl,%edx
   1fc90:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1fc97:	0f b6 d5             	movzbl %ch,%edx
   1fc9a:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1fca1:	89 c1                	mov    %eax,%ecx
   1fca3:	89 34 24             	mov    %esi,(%esp,1)
   1fca6:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1fcaa:	0f b6 d1             	movzbl %cl,%edx
   1fcad:	8b 45 00             	mov    0x0(%ebp),%eax
   1fcb0:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1fcb7:	0f b6 d5             	movzbl %ch,%edx
   1fcba:	c1 e9 10             	shr    $0x10,%ecx
   1fcbd:	8b 7d 0c             	mov    0xc(%ebp),%edi
   1fcc0:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1fcc7:	0f b6 d1             	movzbl %cl,%edx
   1fcca:	8b 75 08             	mov    0x8(%ebp),%esi
   1fccd:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1fcd4:	0f b6 d5             	movzbl %ch,%edx
   1fcd7:	89 d9                	mov    %ebx,%ecx
   1fcd9:	8b 5d 04             	mov    0x4(%ebp),%ebx
   1fcdc:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1fce3:	0f b6 d1             	movzbl %cl,%edx
   1fce6:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1fced:	0f b6 d5             	movzbl %ch,%edx
   1fcf0:	c1 e9 10             	shr    $0x10,%ecx
   1fcf3:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1fcfa:	0f b6 d1             	movzbl %cl,%edx
   1fcfd:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1fd04:	0f b6 d5             	movzbl %ch,%edx
   1fd07:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1fd0e:	8b 0c 24             	mov    (%esp,1),%ecx
   1fd11:	0f b6 d1             	movzbl %cl,%edx
   1fd14:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1fd1b:	0f b6 d5             	movzbl %ch,%edx
   1fd1e:	c1 e9 10             	shr    $0x10,%ecx
   1fd21:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1fd28:	0f b6 d1             	movzbl %cl,%edx
   1fd2b:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1fd32:	0f b6 d5             	movzbl %ch,%edx
   1fd35:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1fd3c:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1fd40:	0f b6 d1             	movzbl %cl,%edx
   1fd43:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1fd4a:	0f b6 d5             	movzbl %ch,%edx
   1fd4d:	c1 e9 10             	shr    $0x10,%ecx
   1fd50:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1fd57:	0f b6 d1             	movzbl %cl,%edx
   1fd5a:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1fd61:	0f b6 d5             	movzbl %ch,%edx
   1fd64:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1fd6b:	89 c1                	mov    %eax,%ecx
   1fd6d:	89 34 24             	mov    %esi,(%esp,1)
   1fd70:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1fd74:	0f b6 d1             	movzbl %cl,%edx
   1fd77:	8b 45 10             	mov    0x10(%ebp),%eax
   1fd7a:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1fd81:	0f b6 d5             	movzbl %ch,%edx
   1fd84:	c1 e9 10             	shr    $0x10,%ecx
   1fd87:	8b 7d 1c             	mov    0x1c(%ebp),%edi
   1fd8a:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1fd91:	0f b6 d1             	movzbl %cl,%edx
   1fd94:	8b 75 18             	mov    0x18(%ebp),%esi
   1fd97:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1fd9e:	0f b6 d5             	movzbl %ch,%edx
   1fda1:	89 d9                	mov    %ebx,%ecx
   1fda3:	8b 5d 14             	mov    0x14(%ebp),%ebx
   1fda6:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1fdad:	0f b6 d1             	movzbl %cl,%edx
   1fdb0:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1fdb7:	0f b6 d5             	movzbl %ch,%edx
   1fdba:	c1 e9 10             	shr    $0x10,%ecx
   1fdbd:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1fdc4:	0f b6 d1             	movzbl %cl,%edx
   1fdc7:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1fdce:	0f b6 d5             	movzbl %ch,%edx
   1fdd1:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1fdd8:	8b 0c 24             	mov    (%esp,1),%ecx
   1fddb:	0f b6 d1             	movzbl %cl,%edx
   1fdde:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1fde5:	0f b6 d5             	movzbl %ch,%edx
   1fde8:	c1 e9 10             	shr    $0x10,%ecx
   1fdeb:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1fdf2:	0f b6 d1             	movzbl %cl,%edx
   1fdf5:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1fdfc:	0f b6 d5             	movzbl %ch,%edx
   1fdff:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1fe06:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1fe0a:	0f b6 d1             	movzbl %cl,%edx
   1fe0d:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1fe14:	0f b6 d5             	movzbl %ch,%edx
   1fe17:	c1 e9 10             	shr    $0x10,%ecx
   1fe1a:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1fe21:	0f b6 d1             	movzbl %cl,%edx
   1fe24:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1fe2b:	0f b6 d5             	movzbl %ch,%edx
   1fe2e:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1fe35:	89 c1                	mov    %eax,%ecx
   1fe37:	89 34 24             	mov    %esi,(%esp,1)
   1fe3a:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1fe3e:	0f b6 d1             	movzbl %cl,%edx
   1fe41:	8b 45 20             	mov    0x20(%ebp),%eax
   1fe44:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1fe4b:	0f b6 d5             	movzbl %ch,%edx
   1fe4e:	c1 e9 10             	shr    $0x10,%ecx
   1fe51:	8b 7d 2c             	mov    0x2c(%ebp),%edi
   1fe54:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1fe5b:	0f b6 d1             	movzbl %cl,%edx
   1fe5e:	8b 75 28             	mov    0x28(%ebp),%esi
   1fe61:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1fe68:	0f b6 d5             	movzbl %ch,%edx
   1fe6b:	89 d9                	mov    %ebx,%ecx
   1fe6d:	8b 5d 24             	mov    0x24(%ebp),%ebx
   1fe70:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1fe77:	0f b6 d1             	movzbl %cl,%edx
   1fe7a:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1fe81:	0f b6 d5             	movzbl %ch,%edx
   1fe84:	c1 e9 10             	shr    $0x10,%ecx
   1fe87:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1fe8e:	0f b6 d1             	movzbl %cl,%edx
   1fe91:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1fe98:	0f b6 d5             	movzbl %ch,%edx
   1fe9b:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1fea2:	8b 0c 24             	mov    (%esp,1),%ecx
   1fea5:	0f b6 d1             	movzbl %cl,%edx
   1fea8:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1feaf:	0f b6 d5             	movzbl %ch,%edx
   1feb2:	c1 e9 10             	shr    $0x10,%ecx
   1feb5:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1febc:	0f b6 d1             	movzbl %cl,%edx
   1febf:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1fec6:	0f b6 d5             	movzbl %ch,%edx
   1fec9:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1fed0:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1fed4:	0f b6 d1             	movzbl %cl,%edx
   1fed7:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1fede:	0f b6 d5             	movzbl %ch,%edx
   1fee1:	c1 e9 10             	shr    $0x10,%ecx
   1fee4:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1feeb:	0f b6 d1             	movzbl %cl,%edx
   1feee:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1fef5:	0f b6 d5             	movzbl %ch,%edx
   1fef8:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1feff:	89 c1                	mov    %eax,%ecx
   1ff01:	89 34 24             	mov    %esi,(%esp,1)
   1ff04:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1ff08:	0f b6 d1             	movzbl %cl,%edx
   1ff0b:	8b 45 30             	mov    0x30(%ebp),%eax
   1ff0e:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1ff15:	0f b6 d5             	movzbl %ch,%edx
   1ff18:	c1 e9 10             	shr    $0x10,%ecx
   1ff1b:	8b 7d 3c             	mov    0x3c(%ebp),%edi
   1ff1e:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1ff25:	0f b6 d1             	movzbl %cl,%edx
   1ff28:	8b 75 38             	mov    0x38(%ebp),%esi
   1ff2b:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1ff32:	0f b6 d5             	movzbl %ch,%edx
   1ff35:	89 d9                	mov    %ebx,%ecx
   1ff37:	8b 5d 34             	mov    0x34(%ebp),%ebx
   1ff3a:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   1ff41:	0f b6 d1             	movzbl %cl,%edx
   1ff44:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   1ff4b:	0f b6 d5             	movzbl %ch,%edx
   1ff4e:	c1 e9 10             	shr    $0x10,%ecx
   1ff51:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   1ff58:	0f b6 d1             	movzbl %cl,%edx
   1ff5b:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   1ff62:	0f b6 d5             	movzbl %ch,%edx
   1ff65:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   1ff6c:	8b 0c 24             	mov    (%esp,1),%ecx
   1ff6f:	0f b6 d1             	movzbl %cl,%edx
   1ff72:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   1ff79:	0f b6 d5             	movzbl %ch,%edx
   1ff7c:	c1 e9 10             	shr    $0x10,%ecx
   1ff7f:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   1ff86:	0f b6 d1             	movzbl %cl,%edx
   1ff89:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   1ff90:	0f b6 d5             	movzbl %ch,%edx
   1ff93:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   1ff9a:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   1ff9e:	0f b6 d1             	movzbl %cl,%edx
   1ffa1:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   1ffa8:	0f b6 d5             	movzbl %ch,%edx
   1ffab:	c1 e9 10             	shr    $0x10,%ecx
   1ffae:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   1ffb5:	0f b6 d1             	movzbl %cl,%edx
   1ffb8:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   1ffbf:	0f b6 d5             	movzbl %ch,%edx
   1ffc2:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   1ffc9:	89 c1                	mov    %eax,%ecx
   1ffcb:	89 34 24             	mov    %esi,(%esp,1)
   1ffce:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   1ffd2:	0f b6 d1             	movzbl %cl,%edx
   1ffd5:	8b 45 40             	mov    0x40(%ebp),%eax
   1ffd8:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   1ffdf:	0f b6 d5             	movzbl %ch,%edx
   1ffe2:	c1 e9 10             	shr    $0x10,%ecx
   1ffe5:	8b 7d 4c             	mov    0x4c(%ebp),%edi
   1ffe8:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   1ffef:	0f b6 d1             	movzbl %cl,%edx
   1fff2:	8b 75 48             	mov    0x48(%ebp),%esi
   1fff5:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   1fffc:	0f b6 d5             	movzbl %ch,%edx
   1ffff:	89 d9                	mov    %ebx,%ecx
   20001:	8b 5d 44             	mov    0x44(%ebp),%ebx
   20004:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   2000b:	0f b6 d1             	movzbl %cl,%edx
   2000e:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   20015:	0f b6 d5             	movzbl %ch,%edx
   20018:	c1 e9 10             	shr    $0x10,%ecx
   2001b:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   20022:	0f b6 d1             	movzbl %cl,%edx
   20025:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   2002c:	0f b6 d5             	movzbl %ch,%edx
   2002f:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   20036:	8b 0c 24             	mov    (%esp,1),%ecx
   20039:	0f b6 d1             	movzbl %cl,%edx
   2003c:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   20043:	0f b6 d5             	movzbl %ch,%edx
   20046:	c1 e9 10             	shr    $0x10,%ecx
   20049:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   20050:	0f b6 d1             	movzbl %cl,%edx
   20053:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   2005a:	0f b6 d5             	movzbl %ch,%edx
   2005d:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   20064:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   20068:	0f b6 d1             	movzbl %cl,%edx
   2006b:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   20072:	0f b6 d5             	movzbl %ch,%edx
   20075:	c1 e9 10             	shr    $0x10,%ecx
   20078:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   2007f:	0f b6 d1             	movzbl %cl,%edx
   20082:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   20089:	0f b6 d5             	movzbl %ch,%edx
   2008c:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   20093:	89 c1                	mov    %eax,%ecx
   20095:	89 34 24             	mov    %esi,(%esp,1)
   20098:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   2009c:	0f b6 d1             	movzbl %cl,%edx
   2009f:	8b 45 50             	mov    0x50(%ebp),%eax
   200a2:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   200a9:	0f b6 d5             	movzbl %ch,%edx
   200ac:	c1 e9 10             	shr    $0x10,%ecx
   200af:	8b 7d 5c             	mov    0x5c(%ebp),%edi
   200b2:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   200b9:	0f b6 d1             	movzbl %cl,%edx
   200bc:	8b 75 58             	mov    0x58(%ebp),%esi
   200bf:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   200c6:	0f b6 d5             	movzbl %ch,%edx
   200c9:	89 d9                	mov    %ebx,%ecx
   200cb:	8b 5d 54             	mov    0x54(%ebp),%ebx
   200ce:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   200d5:	0f b6 d1             	movzbl %cl,%edx
   200d8:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   200df:	0f b6 d5             	movzbl %ch,%edx
   200e2:	c1 e9 10             	shr    $0x10,%ecx
   200e5:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   200ec:	0f b6 d1             	movzbl %cl,%edx
   200ef:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   200f6:	0f b6 d5             	movzbl %ch,%edx
   200f9:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   20100:	8b 0c 24             	mov    (%esp,1),%ecx
   20103:	0f b6 d1             	movzbl %cl,%edx
   20106:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   2010d:	0f b6 d5             	movzbl %ch,%edx
   20110:	c1 e9 10             	shr    $0x10,%ecx
   20113:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   2011a:	0f b6 d1             	movzbl %cl,%edx
   2011d:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   20124:	0f b6 d5             	movzbl %ch,%edx
   20127:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   2012e:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   20132:	0f b6 d1             	movzbl %cl,%edx
   20135:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   2013c:	0f b6 d5             	movzbl %ch,%edx
   2013f:	c1 e9 10             	shr    $0x10,%ecx
   20142:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   20149:	0f b6 d1             	movzbl %cl,%edx
   2014c:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   20153:	0f b6 d5             	movzbl %ch,%edx
   20156:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   2015d:	89 c1                	mov    %eax,%ecx
   2015f:	89 34 24             	mov    %esi,(%esp,1)
   20162:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   20166:	0f b6 d1             	movzbl %cl,%edx
   20169:	8b 45 60             	mov    0x60(%ebp),%eax
   2016c:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   20173:	0f b6 d5             	movzbl %ch,%edx
   20176:	c1 e9 10             	shr    $0x10,%ecx
   20179:	8b 7d 6c             	mov    0x6c(%ebp),%edi
   2017c:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   20183:	0f b6 d1             	movzbl %cl,%edx
   20186:	8b 75 68             	mov    0x68(%ebp),%esi
   20189:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   20190:	0f b6 d5             	movzbl %ch,%edx
   20193:	89 d9                	mov    %ebx,%ecx
   20195:	8b 5d 64             	mov    0x64(%ebp),%ebx
   20198:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   2019f:	0f b6 d1             	movzbl %cl,%edx
   201a2:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   201a9:	0f b6 d5             	movzbl %ch,%edx
   201ac:	c1 e9 10             	shr    $0x10,%ecx
   201af:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   201b6:	0f b6 d1             	movzbl %cl,%edx
   201b9:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   201c0:	0f b6 d5             	movzbl %ch,%edx
   201c3:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   201ca:	8b 0c 24             	mov    (%esp,1),%ecx
   201cd:	0f b6 d1             	movzbl %cl,%edx
   201d0:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   201d7:	0f b6 d5             	movzbl %ch,%edx
   201da:	c1 e9 10             	shr    $0x10,%ecx
   201dd:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   201e4:	0f b6 d1             	movzbl %cl,%edx
   201e7:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   201ee:	0f b6 d5             	movzbl %ch,%edx
   201f1:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   201f8:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   201fc:	0f b6 d1             	movzbl %cl,%edx
   201ff:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   20206:	0f b6 d5             	movzbl %ch,%edx
   20209:	c1 e9 10             	shr    $0x10,%ecx
   2020c:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   20213:	0f b6 d1             	movzbl %cl,%edx
   20216:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   2021d:	0f b6 d5             	movzbl %ch,%edx
   20220:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   20227:	89 c1                	mov    %eax,%ecx
   20229:	89 34 24             	mov    %esi,(%esp,1)
   2022c:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   20230:	0f b6 d1             	movzbl %cl,%edx
   20233:	8b 45 70             	mov    0x70(%ebp),%eax
   20236:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   2023d:	0f b6 d5             	movzbl %ch,%edx
   20240:	c1 e9 10             	shr    $0x10,%ecx
   20243:	8b 7d 7c             	mov    0x7c(%ebp),%edi
   20246:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   2024d:	0f b6 d1             	movzbl %cl,%edx
   20250:	8b 75 78             	mov    0x78(%ebp),%esi
   20253:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   2025a:	0f b6 d5             	movzbl %ch,%edx
   2025d:	89 d9                	mov    %ebx,%ecx
   2025f:	8b 5d 74             	mov    0x74(%ebp),%ebx
   20262:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   20269:	0f b6 d1             	movzbl %cl,%edx
   2026c:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   20273:	0f b6 d5             	movzbl %ch,%edx
   20276:	c1 e9 10             	shr    $0x10,%ecx
   20279:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   20280:	0f b6 d1             	movzbl %cl,%edx
   20283:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   2028a:	0f b6 d5             	movzbl %ch,%edx
   2028d:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   20294:	8b 0c 24             	mov    (%esp,1),%ecx
   20297:	0f b6 d1             	movzbl %cl,%edx
   2029a:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   202a1:	0f b6 d5             	movzbl %ch,%edx
   202a4:	c1 e9 10             	shr    $0x10,%ecx
   202a7:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   202ae:	0f b6 d1             	movzbl %cl,%edx
   202b1:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   202b8:	0f b6 d5             	movzbl %ch,%edx
   202bb:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   202c2:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   202c6:	0f b6 d1             	movzbl %cl,%edx
   202c9:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   202d0:	0f b6 d5             	movzbl %ch,%edx
   202d3:	c1 e9 10             	shr    $0x10,%ecx
   202d6:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   202dd:	0f b6 d1             	movzbl %cl,%edx
   202e0:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   202e7:	0f b6 d5             	movzbl %ch,%edx
   202ea:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   202f1:	89 c1                	mov    %eax,%ecx
   202f3:	89 34 24             	mov    %esi,(%esp,1)
   202f6:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   202fa:	0f b6 d1             	movzbl %cl,%edx
   202fd:	8b 85 80 00 00 00    	mov    0x80(%ebp),%eax
   20303:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   2030a:	0f b6 d5             	movzbl %ch,%edx
   2030d:	c1 e9 10             	shr    $0x10,%ecx
   20310:	8b bd 8c 00 00 00    	mov    0x8c(%ebp),%edi
   20316:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   2031d:	0f b6 d1             	movzbl %cl,%edx
   20320:	8b b5 88 00 00 00    	mov    0x88(%ebp),%esi
   20326:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   2032d:	0f b6 d5             	movzbl %ch,%edx
   20330:	89 d9                	mov    %ebx,%ecx
   20332:	8b 9d 84 00 00 00    	mov    0x84(%ebp),%ebx
   20338:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   2033f:	0f b6 d1             	movzbl %cl,%edx
   20342:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   20349:	0f b6 d5             	movzbl %ch,%edx
   2034c:	c1 e9 10             	shr    $0x10,%ecx
   2034f:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   20356:	0f b6 d1             	movzbl %cl,%edx
   20359:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   20360:	0f b6 d5             	movzbl %ch,%edx
   20363:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   2036a:	8b 0c 24             	mov    (%esp,1),%ecx
   2036d:	0f b6 d1             	movzbl %cl,%edx
   20370:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   20377:	0f b6 d5             	movzbl %ch,%edx
   2037a:	c1 e9 10             	shr    $0x10,%ecx
   2037d:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   20384:	0f b6 d1             	movzbl %cl,%edx
   20387:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   2038e:	0f b6 d5             	movzbl %ch,%edx
   20391:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   20398:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   2039c:	0f b6 d1             	movzbl %cl,%edx
   2039f:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   203a6:	0f b6 d5             	movzbl %ch,%edx
   203a9:	c1 e9 10             	shr    $0x10,%ecx
   203ac:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   203b3:	0f b6 d1             	movzbl %cl,%edx
   203b6:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   203bd:	0f b6 d5             	movzbl %ch,%edx
   203c0:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   203c7:	89 c1                	mov    %eax,%ecx
   203c9:	89 34 24             	mov    %esi,(%esp,1)
   203cc:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   203d0:	0f b6 d1             	movzbl %cl,%edx
   203d3:	8b 85 90 00 00 00    	mov    0x90(%ebp),%eax
   203d9:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   203e0:	0f b6 d5             	movzbl %ch,%edx
   203e3:	c1 e9 10             	shr    $0x10,%ecx
   203e6:	8b bd 9c 00 00 00    	mov    0x9c(%ebp),%edi
   203ec:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   203f3:	0f b6 d1             	movzbl %cl,%edx
   203f6:	8b b5 98 00 00 00    	mov    0x98(%ebp),%esi
   203fc:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   20403:	0f b6 d5             	movzbl %ch,%edx
   20406:	89 d9                	mov    %ebx,%ecx
   20408:	8b 9d 94 00 00 00    	mov    0x94(%ebp),%ebx
   2040e:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   20415:	0f b6 d1             	movzbl %cl,%edx
   20418:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   2041f:	0f b6 d5             	movzbl %ch,%edx
   20422:	c1 e9 10             	shr    $0x10,%ecx
   20425:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   2042c:	0f b6 d1             	movzbl %cl,%edx
   2042f:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   20436:	0f b6 d5             	movzbl %ch,%edx
   20439:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   20440:	8b 0c 24             	mov    (%esp,1),%ecx
   20443:	0f b6 d1             	movzbl %cl,%edx
   20446:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   2044d:	0f b6 d5             	movzbl %ch,%edx
   20450:	c1 e9 10             	shr    $0x10,%ecx
   20453:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   2045a:	0f b6 d1             	movzbl %cl,%edx
   2045d:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   20464:	0f b6 d5             	movzbl %ch,%edx
   20467:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   2046e:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   20472:	0f b6 d1             	movzbl %cl,%edx
   20475:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   2047c:	0f b6 d5             	movzbl %ch,%edx
   2047f:	c1 e9 10             	shr    $0x10,%ecx
   20482:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   20489:	0f b6 d1             	movzbl %cl,%edx
   2048c:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   20493:	0f b6 d5             	movzbl %ch,%edx
   20496:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   2049d:	89 c1                	mov    %eax,%ecx
   2049f:	89 34 24             	mov    %esi,(%esp,1)
   204a2:	89 7c 24 04          	mov    %edi,0x4(%esp,1)
   204a6:	0f b6 d1             	movzbl %cl,%edx
   204a9:	8b 85 a0 00 00 00    	mov    0xa0(%ebp),%eax
   204af:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   204b6:	0f b6 d5             	movzbl %ch,%edx
   204b9:	c1 e9 10             	shr    $0x10,%ecx
   204bc:	8b bd ac 00 00 00    	mov    0xac(%ebp),%edi
   204c2:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   204c9:	0f b6 d1             	movzbl %cl,%edx
   204cc:	8b b5 a8 00 00 00    	mov    0xa8(%ebp),%esi
   204d2:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   204d9:	0f b6 d5             	movzbl %ch,%edx
   204dc:	89 d9                	mov    %ebx,%ecx
   204de:	8b 9d a4 00 00 00    	mov    0xa4(%ebp),%ebx
   204e4:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   204eb:	0f b6 d1             	movzbl %cl,%edx
   204ee:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   204f5:	0f b6 d5             	movzbl %ch,%edx
   204f8:	c1 e9 10             	shr    $0x10,%ecx
   204fb:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   20502:	0f b6 d1             	movzbl %cl,%edx
   20505:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   2050c:	0f b6 d5             	movzbl %ch,%edx
   2050f:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   20516:	8b 0c 24             	mov    (%esp,1),%ecx
   20519:	0f b6 d1             	movzbl %cl,%edx
   2051c:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   20523:	0f b6 d5             	movzbl %ch,%edx
   20526:	c1 e9 10             	shr    $0x10,%ecx
   20529:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   20530:	0f b6 d1             	movzbl %cl,%edx
   20533:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   2053a:	0f b6 d5             	movzbl %ch,%edx
   2053d:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   20544:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   20548:	0f b6 d1             	movzbl %cl,%edx
   2054b:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   20552:	0f b6 d5             	movzbl %ch,%edx
   20555:	c1 e9 10             	shr    $0x10,%ecx
   20558:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   2055f:	0f b6 d1             	movzbl %cl,%edx
   20562:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   20569:	0f b6 d5             	movzbl %ch,%edx
   2056c:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   20573:	8b 6c 24 20          	mov    0x20(%esp,1),%ebp
   20577:	89 7d 0c             	mov    %edi,0xc(%ebp)
   2057a:	89 75 08             	mov    %esi,0x8(%ebp)
   2057d:	89 5d 04             	mov    %ebx,0x4(%ebp)
   20580:	89 45 00             	mov    %eax,0x0(%ebp)
   20583:	31 c0                	xor    %eax,%eax
   20585:	8b 6c 24 14          	mov    0x14(%esp,1),%ebp
   20589:	8b 5c 24 10          	mov    0x10(%esp,1),%ebx
   2058d:	8b 74 24 0c          	mov    0xc(%esp,1),%esi
   20591:	8b 7c 24 08          	mov    0x8(%esp,1),%edi
   20595:	8d 64 24 18          	lea    0x18(%esp,1),%esp
   20599:	c3                   	ret    
   2059a:	83 ec 18             	sub    $0x18,%esp
   2059d:	89 6c 24 14          	mov    %ebp,0x14(%esp,1)
   205a1:	89 5c 24 10          	mov    %ebx,0x10(%esp,1)
   205a5:	89 74 24 0c          	mov    %esi,0xc(%esp,1)
   205a9:	89 7c 24 08          	mov    %edi,0x8(%esp,1)
   205ad:	8b 4c 24 1c          	mov    0x1c(%esp,1),%ecx
   205b1:	8b 6c 24 24          	mov    0x24(%esp,1),%ebp
   205b5:	8b 01                	mov    (%ecx),%eax
   205b7:	8b 59 04             	mov    0x4(%ecx),%ebx
   205ba:	8b 71 08             	mov    0x8(%ecx),%esi
   205bd:	8b 79 0c             	mov    0xc(%ecx),%edi
   205c0:	8b 8d f0 00 00 00    	mov    0xf0(%ebp),%ecx
   205c6:	8d 14 8d 00 00 00 00 	lea    0x0(,%ecx,4),%edx
   205cd:	8d 54 95 00          	lea    0x0(%ebp,%edx,4),%edx
   205d1:	33 02                	xor    (%edx),%eax
   205d3:	33 5a 04             	xor    0x4(%edx),%ebx
   205d6:	33 72 08             	xor    0x8(%edx),%esi
   205d9:	33 7a 0c             	xor    0xc(%edx),%edi
   205dc:	83 f9 0a             	cmp    $0xa,%ecx
   205df:	0f 84 70 03 00 00    	je     20955 <end+0xf71>
   205e5:	83 f9 0c             	cmp    $0xc,%ecx
   205e8:	0f 84 bb 01 00 00    	je     207a9 <end+0xdc5>
   205ee:	83 f9 0e             	cmp    $0xe,%ecx
   205f1:	74 0a                	je     205fd <end+0xc19>
   205f3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   205f8:	e9 66 0b 00 00       	jmp    21163 <end+0x177f>
   205fd:	89 c1                	mov    %eax,%ecx
   205ff:	89 1c 24             	mov    %ebx,(%esp,1)
   20602:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   20606:	0f b6 d1             	movzbl %cl,%edx
   20609:	8b 85 d0 00 00 00    	mov    0xd0(%ebp),%eax
   2060f:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   20616:	0f b6 d5             	movzbl %ch,%edx
   20619:	c1 e9 10             	shr    $0x10,%ecx
   2061c:	8b 9d d4 00 00 00    	mov    0xd4(%ebp),%ebx
   20622:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   20629:	0f b6 d1             	movzbl %cl,%edx
   2062c:	8b b5 d8 00 00 00    	mov    0xd8(%ebp),%esi
   20632:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   20639:	0f b6 d5             	movzbl %ch,%edx
   2063c:	89 f9                	mov    %edi,%ecx
   2063e:	8b bd dc 00 00 00    	mov    0xdc(%ebp),%edi
   20644:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   2064b:	0f b6 d1             	movzbl %cl,%edx
   2064e:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   20655:	0f b6 d5             	movzbl %ch,%edx
   20658:	c1 e9 10             	shr    $0x10,%ecx
   2065b:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   20662:	0f b6 d1             	movzbl %cl,%edx
   20665:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   2066c:	0f b6 d5             	movzbl %ch,%edx
   2066f:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   20676:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   2067a:	0f b6 d1             	movzbl %cl,%edx
   2067d:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   20684:	0f b6 d5             	movzbl %ch,%edx
   20687:	c1 e9 10             	shr    $0x10,%ecx
   2068a:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   20691:	0f b6 d1             	movzbl %cl,%edx
   20694:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   2069b:	0f b6 d5             	movzbl %ch,%edx
   2069e:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   206a5:	8b 0c 24             	mov    (%esp,1),%ecx
   206a8:	0f b6 d1             	movzbl %cl,%edx
   206ab:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   206b2:	0f b6 d5             	movzbl %ch,%edx
   206b5:	c1 e9 10             	shr    $0x10,%ecx
   206b8:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   206bf:	0f b6 d1             	movzbl %cl,%edx
   206c2:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   206c9:	0f b6 d5             	movzbl %ch,%edx
   206cc:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   206d3:	89 c1                	mov    %eax,%ecx
   206d5:	89 1c 24             	mov    %ebx,(%esp,1)
   206d8:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   206dc:	0f b6 d1             	movzbl %cl,%edx
   206df:	8b 85 c0 00 00 00    	mov    0xc0(%ebp),%eax
   206e5:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   206ec:	0f b6 d5             	movzbl %ch,%edx
   206ef:	c1 e9 10             	shr    $0x10,%ecx
   206f2:	8b 9d c4 00 00 00    	mov    0xc4(%ebp),%ebx
   206f8:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   206ff:	0f b6 d1             	movzbl %cl,%edx
   20702:	8b b5 c8 00 00 00    	mov    0xc8(%ebp),%esi
   20708:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   2070f:	0f b6 d5             	movzbl %ch,%edx
   20712:	89 f9                	mov    %edi,%ecx
   20714:	8b bd cc 00 00 00    	mov    0xcc(%ebp),%edi
   2071a:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   20721:	0f b6 d1             	movzbl %cl,%edx
   20724:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   2072b:	0f b6 d5             	movzbl %ch,%edx
   2072e:	c1 e9 10             	shr    $0x10,%ecx
   20731:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   20738:	0f b6 d1             	movzbl %cl,%edx
   2073b:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   20742:	0f b6 d5             	movzbl %ch,%edx
   20745:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   2074c:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   20750:	0f b6 d1             	movzbl %cl,%edx
   20753:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   2075a:	0f b6 d5             	movzbl %ch,%edx
   2075d:	c1 e9 10             	shr    $0x10,%ecx
   20760:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   20767:	0f b6 d1             	movzbl %cl,%edx
   2076a:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   20771:	0f b6 d5             	movzbl %ch,%edx
   20774:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   2077b:	8b 0c 24             	mov    (%esp,1),%ecx
   2077e:	0f b6 d1             	movzbl %cl,%edx
   20781:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   20788:	0f b6 d5             	movzbl %ch,%edx
   2078b:	c1 e9 10             	shr    $0x10,%ecx
   2078e:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   20795:	0f b6 d1             	movzbl %cl,%edx
   20798:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   2079f:	0f b6 d5             	movzbl %ch,%edx
   207a2:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   207a9:	89 c1                	mov    %eax,%ecx
   207ab:	89 1c 24             	mov    %ebx,(%esp,1)
   207ae:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   207b2:	0f b6 d1             	movzbl %cl,%edx
   207b5:	8b 85 b0 00 00 00    	mov    0xb0(%ebp),%eax
   207bb:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   207c2:	0f b6 d5             	movzbl %ch,%edx
   207c5:	c1 e9 10             	shr    $0x10,%ecx
   207c8:	8b 9d b4 00 00 00    	mov    0xb4(%ebp),%ebx
   207ce:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   207d5:	0f b6 d1             	movzbl %cl,%edx
   207d8:	8b b5 b8 00 00 00    	mov    0xb8(%ebp),%esi
   207de:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   207e5:	0f b6 d5             	movzbl %ch,%edx
   207e8:	89 f9                	mov    %edi,%ecx
   207ea:	8b bd bc 00 00 00    	mov    0xbc(%ebp),%edi
   207f0:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   207f7:	0f b6 d1             	movzbl %cl,%edx
   207fa:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   20801:	0f b6 d5             	movzbl %ch,%edx
   20804:	c1 e9 10             	shr    $0x10,%ecx
   20807:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   2080e:	0f b6 d1             	movzbl %cl,%edx
   20811:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   20818:	0f b6 d5             	movzbl %ch,%edx
   2081b:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   20822:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   20826:	0f b6 d1             	movzbl %cl,%edx
   20829:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   20830:	0f b6 d5             	movzbl %ch,%edx
   20833:	c1 e9 10             	shr    $0x10,%ecx
   20836:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   2083d:	0f b6 d1             	movzbl %cl,%edx
   20840:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   20847:	0f b6 d5             	movzbl %ch,%edx
   2084a:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   20851:	8b 0c 24             	mov    (%esp,1),%ecx
   20854:	0f b6 d1             	movzbl %cl,%edx
   20857:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   2085e:	0f b6 d5             	movzbl %ch,%edx
   20861:	c1 e9 10             	shr    $0x10,%ecx
   20864:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   2086b:	0f b6 d1             	movzbl %cl,%edx
   2086e:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   20875:	0f b6 d5             	movzbl %ch,%edx
   20878:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   2087f:	89 c1                	mov    %eax,%ecx
   20881:	89 1c 24             	mov    %ebx,(%esp,1)
   20884:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   20888:	0f b6 d1             	movzbl %cl,%edx
   2088b:	8b 85 a0 00 00 00    	mov    0xa0(%ebp),%eax
   20891:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   20898:	0f b6 d5             	movzbl %ch,%edx
   2089b:	c1 e9 10             	shr    $0x10,%ecx
   2089e:	8b 9d a4 00 00 00    	mov    0xa4(%ebp),%ebx
   208a4:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   208ab:	0f b6 d1             	movzbl %cl,%edx
   208ae:	8b b5 a8 00 00 00    	mov    0xa8(%ebp),%esi
   208b4:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   208bb:	0f b6 d5             	movzbl %ch,%edx
   208be:	89 f9                	mov    %edi,%ecx
   208c0:	8b bd ac 00 00 00    	mov    0xac(%ebp),%edi
   208c6:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   208cd:	0f b6 d1             	movzbl %cl,%edx
   208d0:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   208d7:	0f b6 d5             	movzbl %ch,%edx
   208da:	c1 e9 10             	shr    $0x10,%ecx
   208dd:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   208e4:	0f b6 d1             	movzbl %cl,%edx
   208e7:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   208ee:	0f b6 d5             	movzbl %ch,%edx
   208f1:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   208f8:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   208fc:	0f b6 d1             	movzbl %cl,%edx
   208ff:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   20906:	0f b6 d5             	movzbl %ch,%edx
   20909:	c1 e9 10             	shr    $0x10,%ecx
   2090c:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   20913:	0f b6 d1             	movzbl %cl,%edx
   20916:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   2091d:	0f b6 d5             	movzbl %ch,%edx
   20920:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   20927:	8b 0c 24             	mov    (%esp,1),%ecx
   2092a:	0f b6 d1             	movzbl %cl,%edx
   2092d:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   20934:	0f b6 d5             	movzbl %ch,%edx
   20937:	c1 e9 10             	shr    $0x10,%ecx
   2093a:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   20941:	0f b6 d1             	movzbl %cl,%edx
   20944:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   2094b:	0f b6 d5             	movzbl %ch,%edx
   2094e:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   20955:	89 c1                	mov    %eax,%ecx
   20957:	89 1c 24             	mov    %ebx,(%esp,1)
   2095a:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   2095e:	0f b6 d1             	movzbl %cl,%edx
   20961:	8b 85 90 00 00 00    	mov    0x90(%ebp),%eax
   20967:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   2096e:	0f b6 d5             	movzbl %ch,%edx
   20971:	c1 e9 10             	shr    $0x10,%ecx
   20974:	8b 9d 94 00 00 00    	mov    0x94(%ebp),%ebx
   2097a:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   20981:	0f b6 d1             	movzbl %cl,%edx
   20984:	8b b5 98 00 00 00    	mov    0x98(%ebp),%esi
   2098a:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   20991:	0f b6 d5             	movzbl %ch,%edx
   20994:	89 f9                	mov    %edi,%ecx
   20996:	8b bd 9c 00 00 00    	mov    0x9c(%ebp),%edi
   2099c:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   209a3:	0f b6 d1             	movzbl %cl,%edx
   209a6:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   209ad:	0f b6 d5             	movzbl %ch,%edx
   209b0:	c1 e9 10             	shr    $0x10,%ecx
   209b3:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   209ba:	0f b6 d1             	movzbl %cl,%edx
   209bd:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   209c4:	0f b6 d5             	movzbl %ch,%edx
   209c7:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   209ce:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   209d2:	0f b6 d1             	movzbl %cl,%edx
   209d5:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   209dc:	0f b6 d5             	movzbl %ch,%edx
   209df:	c1 e9 10             	shr    $0x10,%ecx
   209e2:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   209e9:	0f b6 d1             	movzbl %cl,%edx
   209ec:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   209f3:	0f b6 d5             	movzbl %ch,%edx
   209f6:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   209fd:	8b 0c 24             	mov    (%esp,1),%ecx
   20a00:	0f b6 d1             	movzbl %cl,%edx
   20a03:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   20a0a:	0f b6 d5             	movzbl %ch,%edx
   20a0d:	c1 e9 10             	shr    $0x10,%ecx
   20a10:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   20a17:	0f b6 d1             	movzbl %cl,%edx
   20a1a:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   20a21:	0f b6 d5             	movzbl %ch,%edx
   20a24:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   20a2b:	89 c1                	mov    %eax,%ecx
   20a2d:	89 1c 24             	mov    %ebx,(%esp,1)
   20a30:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   20a34:	0f b6 d1             	movzbl %cl,%edx
   20a37:	8b 85 80 00 00 00    	mov    0x80(%ebp),%eax
   20a3d:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   20a44:	0f b6 d5             	movzbl %ch,%edx
   20a47:	c1 e9 10             	shr    $0x10,%ecx
   20a4a:	8b 9d 84 00 00 00    	mov    0x84(%ebp),%ebx
   20a50:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   20a57:	0f b6 d1             	movzbl %cl,%edx
   20a5a:	8b b5 88 00 00 00    	mov    0x88(%ebp),%esi
   20a60:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   20a67:	0f b6 d5             	movzbl %ch,%edx
   20a6a:	89 f9                	mov    %edi,%ecx
   20a6c:	8b bd 8c 00 00 00    	mov    0x8c(%ebp),%edi
   20a72:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   20a79:	0f b6 d1             	movzbl %cl,%edx
   20a7c:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   20a83:	0f b6 d5             	movzbl %ch,%edx
   20a86:	c1 e9 10             	shr    $0x10,%ecx
   20a89:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   20a90:	0f b6 d1             	movzbl %cl,%edx
   20a93:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   20a9a:	0f b6 d5             	movzbl %ch,%edx
   20a9d:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   20aa4:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   20aa8:	0f b6 d1             	movzbl %cl,%edx
   20aab:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   20ab2:	0f b6 d5             	movzbl %ch,%edx
   20ab5:	c1 e9 10             	shr    $0x10,%ecx
   20ab8:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   20abf:	0f b6 d1             	movzbl %cl,%edx
   20ac2:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   20ac9:	0f b6 d5             	movzbl %ch,%edx
   20acc:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   20ad3:	8b 0c 24             	mov    (%esp,1),%ecx
   20ad6:	0f b6 d1             	movzbl %cl,%edx
   20ad9:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   20ae0:	0f b6 d5             	movzbl %ch,%edx
   20ae3:	c1 e9 10             	shr    $0x10,%ecx
   20ae6:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   20aed:	0f b6 d1             	movzbl %cl,%edx
   20af0:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   20af7:	0f b6 d5             	movzbl %ch,%edx
   20afa:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   20b01:	89 c1                	mov    %eax,%ecx
   20b03:	89 1c 24             	mov    %ebx,(%esp,1)
   20b06:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   20b0a:	0f b6 d1             	movzbl %cl,%edx
   20b0d:	8b 45 70             	mov    0x70(%ebp),%eax
   20b10:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   20b17:	0f b6 d5             	movzbl %ch,%edx
   20b1a:	c1 e9 10             	shr    $0x10,%ecx
   20b1d:	8b 5d 74             	mov    0x74(%ebp),%ebx
   20b20:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   20b27:	0f b6 d1             	movzbl %cl,%edx
   20b2a:	8b 75 78             	mov    0x78(%ebp),%esi
   20b2d:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   20b34:	0f b6 d5             	movzbl %ch,%edx
   20b37:	89 f9                	mov    %edi,%ecx
   20b39:	8b 7d 7c             	mov    0x7c(%ebp),%edi
   20b3c:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   20b43:	0f b6 d1             	movzbl %cl,%edx
   20b46:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   20b4d:	0f b6 d5             	movzbl %ch,%edx
   20b50:	c1 e9 10             	shr    $0x10,%ecx
   20b53:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   20b5a:	0f b6 d1             	movzbl %cl,%edx
   20b5d:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   20b64:	0f b6 d5             	movzbl %ch,%edx
   20b67:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   20b6e:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   20b72:	0f b6 d1             	movzbl %cl,%edx
   20b75:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   20b7c:	0f b6 d5             	movzbl %ch,%edx
   20b7f:	c1 e9 10             	shr    $0x10,%ecx
   20b82:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   20b89:	0f b6 d1             	movzbl %cl,%edx
   20b8c:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   20b93:	0f b6 d5             	movzbl %ch,%edx
   20b96:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   20b9d:	8b 0c 24             	mov    (%esp,1),%ecx
   20ba0:	0f b6 d1             	movzbl %cl,%edx
   20ba3:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   20baa:	0f b6 d5             	movzbl %ch,%edx
   20bad:	c1 e9 10             	shr    $0x10,%ecx
   20bb0:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   20bb7:	0f b6 d1             	movzbl %cl,%edx
   20bba:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   20bc1:	0f b6 d5             	movzbl %ch,%edx
   20bc4:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   20bcb:	89 c1                	mov    %eax,%ecx
   20bcd:	89 1c 24             	mov    %ebx,(%esp,1)
   20bd0:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   20bd4:	0f b6 d1             	movzbl %cl,%edx
   20bd7:	8b 45 60             	mov    0x60(%ebp),%eax
   20bda:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   20be1:	0f b6 d5             	movzbl %ch,%edx
   20be4:	c1 e9 10             	shr    $0x10,%ecx
   20be7:	8b 5d 64             	mov    0x64(%ebp),%ebx
   20bea:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   20bf1:	0f b6 d1             	movzbl %cl,%edx
   20bf4:	8b 75 68             	mov    0x68(%ebp),%esi
   20bf7:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   20bfe:	0f b6 d5             	movzbl %ch,%edx
   20c01:	89 f9                	mov    %edi,%ecx
   20c03:	8b 7d 6c             	mov    0x6c(%ebp),%edi
   20c06:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   20c0d:	0f b6 d1             	movzbl %cl,%edx
   20c10:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   20c17:	0f b6 d5             	movzbl %ch,%edx
   20c1a:	c1 e9 10             	shr    $0x10,%ecx
   20c1d:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   20c24:	0f b6 d1             	movzbl %cl,%edx
   20c27:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   20c2e:	0f b6 d5             	movzbl %ch,%edx
   20c31:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   20c38:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   20c3c:	0f b6 d1             	movzbl %cl,%edx
   20c3f:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   20c46:	0f b6 d5             	movzbl %ch,%edx
   20c49:	c1 e9 10             	shr    $0x10,%ecx
   20c4c:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   20c53:	0f b6 d1             	movzbl %cl,%edx
   20c56:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   20c5d:	0f b6 d5             	movzbl %ch,%edx
   20c60:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   20c67:	8b 0c 24             	mov    (%esp,1),%ecx
   20c6a:	0f b6 d1             	movzbl %cl,%edx
   20c6d:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   20c74:	0f b6 d5             	movzbl %ch,%edx
   20c77:	c1 e9 10             	shr    $0x10,%ecx
   20c7a:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   20c81:	0f b6 d1             	movzbl %cl,%edx
   20c84:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   20c8b:	0f b6 d5             	movzbl %ch,%edx
   20c8e:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   20c95:	89 c1                	mov    %eax,%ecx
   20c97:	89 1c 24             	mov    %ebx,(%esp,1)
   20c9a:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   20c9e:	0f b6 d1             	movzbl %cl,%edx
   20ca1:	8b 45 50             	mov    0x50(%ebp),%eax
   20ca4:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   20cab:	0f b6 d5             	movzbl %ch,%edx
   20cae:	c1 e9 10             	shr    $0x10,%ecx
   20cb1:	8b 5d 54             	mov    0x54(%ebp),%ebx
   20cb4:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   20cbb:	0f b6 d1             	movzbl %cl,%edx
   20cbe:	8b 75 58             	mov    0x58(%ebp),%esi
   20cc1:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   20cc8:	0f b6 d5             	movzbl %ch,%edx
   20ccb:	89 f9                	mov    %edi,%ecx
   20ccd:	8b 7d 5c             	mov    0x5c(%ebp),%edi
   20cd0:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   20cd7:	0f b6 d1             	movzbl %cl,%edx
   20cda:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   20ce1:	0f b6 d5             	movzbl %ch,%edx
   20ce4:	c1 e9 10             	shr    $0x10,%ecx
   20ce7:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   20cee:	0f b6 d1             	movzbl %cl,%edx
   20cf1:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   20cf8:	0f b6 d5             	movzbl %ch,%edx
   20cfb:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   20d02:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   20d06:	0f b6 d1             	movzbl %cl,%edx
   20d09:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   20d10:	0f b6 d5             	movzbl %ch,%edx
   20d13:	c1 e9 10             	shr    $0x10,%ecx
   20d16:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   20d1d:	0f b6 d1             	movzbl %cl,%edx
   20d20:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   20d27:	0f b6 d5             	movzbl %ch,%edx
   20d2a:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   20d31:	8b 0c 24             	mov    (%esp,1),%ecx
   20d34:	0f b6 d1             	movzbl %cl,%edx
   20d37:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   20d3e:	0f b6 d5             	movzbl %ch,%edx
   20d41:	c1 e9 10             	shr    $0x10,%ecx
   20d44:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   20d4b:	0f b6 d1             	movzbl %cl,%edx
   20d4e:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   20d55:	0f b6 d5             	movzbl %ch,%edx
   20d58:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   20d5f:	89 c1                	mov    %eax,%ecx
   20d61:	89 1c 24             	mov    %ebx,(%esp,1)
   20d64:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   20d68:	0f b6 d1             	movzbl %cl,%edx
   20d6b:	8b 45 40             	mov    0x40(%ebp),%eax
   20d6e:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   20d75:	0f b6 d5             	movzbl %ch,%edx
   20d78:	c1 e9 10             	shr    $0x10,%ecx
   20d7b:	8b 5d 44             	mov    0x44(%ebp),%ebx
   20d7e:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   20d85:	0f b6 d1             	movzbl %cl,%edx
   20d88:	8b 75 48             	mov    0x48(%ebp),%esi
   20d8b:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   20d92:	0f b6 d5             	movzbl %ch,%edx
   20d95:	89 f9                	mov    %edi,%ecx
   20d97:	8b 7d 4c             	mov    0x4c(%ebp),%edi
   20d9a:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   20da1:	0f b6 d1             	movzbl %cl,%edx
   20da4:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   20dab:	0f b6 d5             	movzbl %ch,%edx
   20dae:	c1 e9 10             	shr    $0x10,%ecx
   20db1:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   20db8:	0f b6 d1             	movzbl %cl,%edx
   20dbb:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   20dc2:	0f b6 d5             	movzbl %ch,%edx
   20dc5:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   20dcc:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   20dd0:	0f b6 d1             	movzbl %cl,%edx
   20dd3:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   20dda:	0f b6 d5             	movzbl %ch,%edx
   20ddd:	c1 e9 10             	shr    $0x10,%ecx
   20de0:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   20de7:	0f b6 d1             	movzbl %cl,%edx
   20dea:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   20df1:	0f b6 d5             	movzbl %ch,%edx
   20df4:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   20dfb:	8b 0c 24             	mov    (%esp,1),%ecx
   20dfe:	0f b6 d1             	movzbl %cl,%edx
   20e01:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   20e08:	0f b6 d5             	movzbl %ch,%edx
   20e0b:	c1 e9 10             	shr    $0x10,%ecx
   20e0e:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   20e15:	0f b6 d1             	movzbl %cl,%edx
   20e18:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   20e1f:	0f b6 d5             	movzbl %ch,%edx
   20e22:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   20e29:	89 c1                	mov    %eax,%ecx
   20e2b:	89 1c 24             	mov    %ebx,(%esp,1)
   20e2e:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   20e32:	0f b6 d1             	movzbl %cl,%edx
   20e35:	8b 45 30             	mov    0x30(%ebp),%eax
   20e38:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   20e3f:	0f b6 d5             	movzbl %ch,%edx
   20e42:	c1 e9 10             	shr    $0x10,%ecx
   20e45:	8b 5d 34             	mov    0x34(%ebp),%ebx
   20e48:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   20e4f:	0f b6 d1             	movzbl %cl,%edx
   20e52:	8b 75 38             	mov    0x38(%ebp),%esi
   20e55:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   20e5c:	0f b6 d5             	movzbl %ch,%edx
   20e5f:	89 f9                	mov    %edi,%ecx
   20e61:	8b 7d 3c             	mov    0x3c(%ebp),%edi
   20e64:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   20e6b:	0f b6 d1             	movzbl %cl,%edx
   20e6e:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   20e75:	0f b6 d5             	movzbl %ch,%edx
   20e78:	c1 e9 10             	shr    $0x10,%ecx
   20e7b:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   20e82:	0f b6 d1             	movzbl %cl,%edx
   20e85:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   20e8c:	0f b6 d5             	movzbl %ch,%edx
   20e8f:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   20e96:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   20e9a:	0f b6 d1             	movzbl %cl,%edx
   20e9d:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   20ea4:	0f b6 d5             	movzbl %ch,%edx
   20ea7:	c1 e9 10             	shr    $0x10,%ecx
   20eaa:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   20eb1:	0f b6 d1             	movzbl %cl,%edx
   20eb4:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   20ebb:	0f b6 d5             	movzbl %ch,%edx
   20ebe:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   20ec5:	8b 0c 24             	mov    (%esp,1),%ecx
   20ec8:	0f b6 d1             	movzbl %cl,%edx
   20ecb:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   20ed2:	0f b6 d5             	movzbl %ch,%edx
   20ed5:	c1 e9 10             	shr    $0x10,%ecx
   20ed8:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   20edf:	0f b6 d1             	movzbl %cl,%edx
   20ee2:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   20ee9:	0f b6 d5             	movzbl %ch,%edx
   20eec:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   20ef3:	89 c1                	mov    %eax,%ecx
   20ef5:	89 1c 24             	mov    %ebx,(%esp,1)
   20ef8:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   20efc:	0f b6 d1             	movzbl %cl,%edx
   20eff:	8b 45 20             	mov    0x20(%ebp),%eax
   20f02:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   20f09:	0f b6 d5             	movzbl %ch,%edx
   20f0c:	c1 e9 10             	shr    $0x10,%ecx
   20f0f:	8b 5d 24             	mov    0x24(%ebp),%ebx
   20f12:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   20f19:	0f b6 d1             	movzbl %cl,%edx
   20f1c:	8b 75 28             	mov    0x28(%ebp),%esi
   20f1f:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   20f26:	0f b6 d5             	movzbl %ch,%edx
   20f29:	89 f9                	mov    %edi,%ecx
   20f2b:	8b 7d 2c             	mov    0x2c(%ebp),%edi
   20f2e:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   20f35:	0f b6 d1             	movzbl %cl,%edx
   20f38:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   20f3f:	0f b6 d5             	movzbl %ch,%edx
   20f42:	c1 e9 10             	shr    $0x10,%ecx
   20f45:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   20f4c:	0f b6 d1             	movzbl %cl,%edx
   20f4f:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   20f56:	0f b6 d5             	movzbl %ch,%edx
   20f59:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   20f60:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   20f64:	0f b6 d1             	movzbl %cl,%edx
   20f67:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   20f6e:	0f b6 d5             	movzbl %ch,%edx
   20f71:	c1 e9 10             	shr    $0x10,%ecx
   20f74:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   20f7b:	0f b6 d1             	movzbl %cl,%edx
   20f7e:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   20f85:	0f b6 d5             	movzbl %ch,%edx
   20f88:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   20f8f:	8b 0c 24             	mov    (%esp,1),%ecx
   20f92:	0f b6 d1             	movzbl %cl,%edx
   20f95:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   20f9c:	0f b6 d5             	movzbl %ch,%edx
   20f9f:	c1 e9 10             	shr    $0x10,%ecx
   20fa2:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   20fa9:	0f b6 d1             	movzbl %cl,%edx
   20fac:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   20fb3:	0f b6 d5             	movzbl %ch,%edx
   20fb6:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   20fbd:	89 c1                	mov    %eax,%ecx
   20fbf:	89 1c 24             	mov    %ebx,(%esp,1)
   20fc2:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   20fc6:	0f b6 d1             	movzbl %cl,%edx
   20fc9:	8b 45 10             	mov    0x10(%ebp),%eax
   20fcc:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   20fd3:	0f b6 d5             	movzbl %ch,%edx
   20fd6:	c1 e9 10             	shr    $0x10,%ecx
   20fd9:	8b 5d 14             	mov    0x14(%ebp),%ebx
   20fdc:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   20fe3:	0f b6 d1             	movzbl %cl,%edx
   20fe6:	8b 75 18             	mov    0x18(%ebp),%esi
   20fe9:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   20ff0:	0f b6 d5             	movzbl %ch,%edx
   20ff3:	89 f9                	mov    %edi,%ecx
   20ff5:	8b 7d 1c             	mov    0x1c(%ebp),%edi
   20ff8:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   20fff:	0f b6 d1             	movzbl %cl,%edx
   21002:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   21009:	0f b6 d5             	movzbl %ch,%edx
   2100c:	c1 e9 10             	shr    $0x10,%ecx
   2100f:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   21016:	0f b6 d1             	movzbl %cl,%edx
   21019:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   21020:	0f b6 d5             	movzbl %ch,%edx
   21023:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   2102a:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   2102e:	0f b6 d1             	movzbl %cl,%edx
   21031:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   21038:	0f b6 d5             	movzbl %ch,%edx
   2103b:	c1 e9 10             	shr    $0x10,%ecx
   2103e:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   21045:	0f b6 d1             	movzbl %cl,%edx
   21048:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   2104f:	0f b6 d5             	movzbl %ch,%edx
   21052:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   21059:	8b 0c 24             	mov    (%esp,1),%ecx
   2105c:	0f b6 d1             	movzbl %cl,%edx
   2105f:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   21066:	0f b6 d5             	movzbl %ch,%edx
   21069:	c1 e9 10             	shr    $0x10,%ecx
   2106c:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   21073:	0f b6 d1             	movzbl %cl,%edx
   21076:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   2107d:	0f b6 d5             	movzbl %ch,%edx
   21080:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   21087:	89 c1                	mov    %eax,%ecx
   21089:	89 1c 24             	mov    %ebx,(%esp,1)
   2108c:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   21090:	0f b6 d1             	movzbl %cl,%edx
   21093:	8b 45 00             	mov    0x0(%ebp),%eax
   21096:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   2109d:	0f b6 d5             	movzbl %ch,%edx
   210a0:	c1 e9 10             	shr    $0x10,%ecx
   210a3:	8b 5d 04             	mov    0x4(%ebp),%ebx
   210a6:	33 1c 95 00 04 00 00 	xor    0x400(,%edx,4),%ebx
   210ad:	0f b6 d1             	movzbl %cl,%edx
   210b0:	8b 75 08             	mov    0x8(%ebp),%esi
   210b3:	33 34 95 00 08 00 00 	xor    0x800(,%edx,4),%esi
   210ba:	0f b6 d5             	movzbl %ch,%edx
   210bd:	89 f9                	mov    %edi,%ecx
   210bf:	8b 7d 0c             	mov    0xc(%ebp),%edi
   210c2:	33 3c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%edi
   210c9:	0f b6 d1             	movzbl %cl,%edx
   210cc:	33 3c 95 00 00 00 00 	xor    0x0(,%edx,4),%edi
   210d3:	0f b6 d5             	movzbl %ch,%edx
   210d6:	c1 e9 10             	shr    $0x10,%ecx
   210d9:	33 04 95 00 04 00 00 	xor    0x400(,%edx,4),%eax
   210e0:	0f b6 d1             	movzbl %cl,%edx
   210e3:	33 1c 95 00 08 00 00 	xor    0x800(,%edx,4),%ebx
   210ea:	0f b6 d5             	movzbl %ch,%edx
   210ed:	33 34 95 00 0c 00 00 	xor    0xc00(,%edx,4),%esi
   210f4:	8b 4c 24 04          	mov    0x4(%esp,1),%ecx
   210f8:	0f b6 d1             	movzbl %cl,%edx
   210fb:	33 34 95 00 00 00 00 	xor    0x0(,%edx,4),%esi
   21102:	0f b6 d5             	movzbl %ch,%edx
   21105:	c1 e9 10             	shr    $0x10,%ecx
   21108:	33 3c 95 00 04 00 00 	xor    0x400(,%edx,4),%edi
   2110f:	0f b6 d1             	movzbl %cl,%edx
   21112:	33 04 95 00 08 00 00 	xor    0x800(,%edx,4),%eax
   21119:	0f b6 d5             	movzbl %ch,%edx
   2111c:	33 1c 95 00 0c 00 00 	xor    0xc00(,%edx,4),%ebx
   21123:	8b 0c 24             	mov    (%esp,1),%ecx
   21126:	0f b6 d1             	movzbl %cl,%edx
   21129:	33 1c 95 00 00 00 00 	xor    0x0(,%edx,4),%ebx
   21130:	0f b6 d5             	movzbl %ch,%edx
   21133:	c1 e9 10             	shr    $0x10,%ecx
   21136:	33 34 95 00 04 00 00 	xor    0x400(,%edx,4),%esi
   2113d:	0f b6 d1             	movzbl %cl,%edx
   21140:	33 3c 95 00 08 00 00 	xor    0x800(,%edx,4),%edi
   21147:	0f b6 d5             	movzbl %ch,%edx
   2114a:	33 04 95 00 0c 00 00 	xor    0xc00(,%edx,4),%eax
   21151:	8b 6c 24 20          	mov    0x20(%esp,1),%ebp
   21155:	89 7d 0c             	mov    %edi,0xc(%ebp)
   21158:	89 75 08             	mov    %esi,0x8(%ebp)
   2115b:	89 5d 04             	mov    %ebx,0x4(%ebp)
   2115e:	89 45 00             	mov    %eax,0x0(%ebp)
   21161:	31 c0                	xor    %eax,%eax
   21163:	8b 6c 24 14          	mov    0x14(%esp,1),%ebp
   21167:	8b 5c 24 10          	mov    0x10(%esp,1),%ebx
   2116b:	8b 74 24 0c          	mov    0xc(%esp,1),%esi
   2116f:	8b 7c 24 08          	mov    0x8(%esp,1),%edi
   21173:	8d 64 24 18          	lea    0x18(%esp,1),%esp
   21177:	c3                   	ret    
   21178:	90                   	nop    
   21179:	90                   	nop    
   2117a:	90                   	nop    
   2117b:	90                   	nop    
   2117c:	90                   	nop    
   2117d:	90                   	nop    
   2117e:	90                   	nop    
   2117f:	90                   	nop    

00021180 <aes_encrypt_key128>:

#if defined(AES_128) || defined(AES_VAR)

aes_rval aes_encrypt_key128(const unsigned char *key, aes_encrypt_ctx cx[1])
{   aes_32t    ss[4];
   21180:	55                   	push   %ebp
   21181:	89 e5                	mov    %esp,%ebp
   21183:	57                   	push   %edi
   21184:	56                   	push   %esi
   21185:	53                   	push   %ebx
   21186:	81 ec d4 00 00 00    	sub    $0xd4,%esp
   2118c:	8b 5d 08             	mov    0x8(%ebp),%ebx

    cx->ks[0] = ss[0] = word_in(key, 0);
   2118f:	8b 55 0c             	mov    0xc(%ebp),%edx
   21192:	0f b6 43 03          	movzbl 0x3(%ebx),%eax
   21196:	c1 e0 18             	shl    $0x18,%eax
   21199:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   2119c:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
   211a0:	c1 e0 10             	shl    $0x10,%eax
   211a3:	09 45 e0             	or     %eax,0xffffffe0(%ebp)
   211a6:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
   211aa:	c1 e0 08             	shl    $0x8,%eax
   211ad:	09 45 e0             	or     %eax,0xffffffe0(%ebp)
   211b0:	0f b6 03             	movzbl (%ebx),%eax
   211b3:	09 45 e0             	or     %eax,0xffffffe0(%ebp)
   211b6:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
   211b9:	89 0a                	mov    %ecx,(%edx)
    cx->ks[1] = ss[1] = word_in(key, 1);
   211bb:	0f b6 43 07          	movzbl 0x7(%ebx),%eax
   211bf:	c1 e0 18             	shl    $0x18,%eax
   211c2:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
   211c5:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
   211c9:	c1 e0 10             	shl    $0x10,%eax
   211cc:	09 45 dc             	or     %eax,0xffffffdc(%ebp)
   211cf:	0f b6 43 05          	movzbl 0x5(%ebx),%eax
   211d3:	c1 e0 08             	shl    $0x8,%eax
   211d6:	09 45 dc             	or     %eax,0xffffffdc(%ebp)
   211d9:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
   211dd:	09 45 dc             	or     %eax,0xffffffdc(%ebp)
   211e0:	8b 4d dc             	mov    0xffffffdc(%ebp),%ecx
   211e3:	89 4a 04             	mov    %ecx,0x4(%edx)
    cx->ks[2] = ss[2] = word_in(key, 2);
   211e6:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
   211ea:	c1 e0 18             	shl    $0x18,%eax
   211ed:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
   211f0:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
   211f4:	c1 e0 10             	shl    $0x10,%eax
   211f7:	09 45 d8             	or     %eax,0xffffffd8(%ebp)
   211fa:	0f b6 43 09          	movzbl 0x9(%ebx),%eax
   211fe:	c1 e0 08             	shl    $0x8,%eax
   21201:	09 45 d8             	or     %eax,0xffffffd8(%ebp)
   21204:	0f b6 43 08          	movzbl 0x8(%ebx),%eax
   21208:	09 45 d8             	or     %eax,0xffffffd8(%ebp)
   2120b:	8b 4d d8             	mov    0xffffffd8(%ebp),%ecx
   2120e:	89 4a 08             	mov    %ecx,0x8(%edx)
    cx->ks[3] = ss[3] = word_in(key, 3);
   21211:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   21214:	0f b6 43 0f          	movzbl 0xf(%ebx),%eax
   21218:	c1 e0 18             	shl    $0x18,%eax
   2121b:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   2121e:	0f b6 43 0e          	movzbl 0xe(%ebx),%eax
   21222:	c1 e0 10             	shl    $0x10,%eax
   21225:	09 45 d4             	or     %eax,0xffffffd4(%ebp)
   21228:	0f b6 43 0d          	movzbl 0xd(%ebx),%eax
   2122c:	c1 e0 08             	shl    $0x8,%eax
   2122f:	09 45 d4             	or     %eax,0xffffffd4(%ebp)
   21232:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
   21236:	09 45 d4             	or     %eax,0xffffffd4(%ebp)
   21239:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx

#if ENC_UNROLL == NONE
    {   aes_32t i;

        for(i = 0; i < ((11 * N_COLS - 5) / 4); ++i)
            ke4(cx->ks, i);
    }
#else
    ke4(cx->ks, 0);  ke4(cx->ks, 1);
   2123c:	0f b6 c6             	movzbl %dh,%eax
   2123f:	89 55 f0             	mov    %edx,0xfffffff0(%ebp)
   21242:	89 51 0c             	mov    %edx,0xc(%ecx)
   21245:	b9 00 00 00 00       	mov    $0x0,%ecx
   2124a:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
   2124d:	89 d0                	mov    %edx,%eax
   2124f:	8b 55 d0             	mov    0xffffffd0(%ebp),%edx
   21252:	c1 e8 10             	shr    $0x10,%eax
   21255:	0f b6 c0             	movzbl %al,%eax
   21258:	8b 14 91             	mov    (%ecx,%edx,4),%edx
   2125b:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   21262:	31 d0                	xor    %edx,%eax
   21264:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
   21267:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   2126a:	c1 e8 18             	shr    $0x18,%eax
   2126d:	8b 0c 85 00 08 00 00 	mov    0x800(,%eax,4),%ecx
   21274:	31 4d cc             	xor    %ecx,0xffffffcc(%ebp)
   21277:	8b 0d 00 00 00 00    	mov    0x0,%ecx
   2127d:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
   21281:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   21288:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
   2128b:	31 55 cc             	xor    %edx,0xffffffcc(%ebp)
   2128e:	8b 55 0c             	mov    0xc(%ebp),%edx
   21291:	31 4d cc             	xor    %ecx,0xffffffcc(%ebp)
   21294:	31 45 cc             	xor    %eax,0xffffffcc(%ebp)
   21297:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
   2129a:	89 4a 10             	mov    %ecx,0x10(%edx)
   2129d:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
   212a0:	31 c8                	xor    %ecx,%eax
   212a2:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
   212a5:	89 42 14             	mov    %eax,0x14(%edx)
   212a8:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
   212ab:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   212ae:	31 c2                	xor    %eax,%edx
   212b0:	89 55 c4             	mov    %edx,0xffffffc4(%ebp)
   212b3:	89 51 18             	mov    %edx,0x18(%ecx)
   212b6:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
   212b9:	31 d0                	xor    %edx,%eax
   212bb:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
   212be:	0f b6 d4             	movzbl %ah,%edx
   212c1:	8b 34 95 00 00 00 00 	mov    0x0(,%edx,4),%esi
   212c8:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   212cb:	89 41 1c             	mov    %eax,0x1c(%ecx)
   212ce:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
   212d1:	c1 e8 10             	shr    $0x10,%eax
   212d4:	0f b6 c0             	movzbl %al,%eax
   212d7:	8b 3c 85 00 04 00 00 	mov    0x400(,%eax,4),%edi
   212de:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
   212e1:	31 f7                	xor    %esi,%edi
   212e3:	8b 75 cc             	mov    0xffffffcc(%ebp),%esi
   212e6:	c1 e8 18             	shr    $0x18,%eax
   212e9:	8b 1c 85 00 08 00 00 	mov    0x800(,%eax,4),%ebx
   212f0:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
   212f4:	31 df                	xor    %ebx,%edi
   212f6:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   212fd:	a1 04 00 00 00       	mov    0x4,%eax
   21302:	31 d7                	xor    %edx,%edi
   21304:	31 c7                	xor    %eax,%edi
   21306:	31 f7                	xor    %esi,%edi
   21308:	89 79 20             	mov    %edi,0x20(%ecx)
   2130b:	8b 55 c8             	mov    0xffffffc8(%ebp),%edx
   2130e:	31 fa                	xor    %edi,%edx
   21310:	89 55 bc             	mov    %edx,0xffffffbc(%ebp)
   21313:	89 51 24             	mov    %edx,0x24(%ecx)
   21316:	8b 4d c4             	mov    0xffffffc4(%ebp),%ecx
   21319:	8b 45 0c             	mov    0xc(%ebp),%eax
   2131c:	31 d1                	xor    %edx,%ecx
   2131e:	89 4d b8             	mov    %ecx,0xffffffb8(%ebp)
   21321:	89 48 28             	mov    %ecx,0x28(%eax)
   21324:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
   21327:	31 ca                	xor    %ecx,%edx
   21329:	89 55 b4             	mov    %edx,0xffffffb4(%ebp)
    ke4(cx->ks, 2);  ke4(cx->ks, 3);
   2132c:	0f b6 ce             	movzbl %dh,%ecx
   2132f:	89 55 f0             	mov    %edx,0xfffffff0(%ebp)
   21332:	89 50 2c             	mov    %edx,0x2c(%eax)
   21335:	89 d0                	mov    %edx,%eax
   21337:	ba 00 00 00 00       	mov    $0x0,%edx
   2133c:	c1 e8 10             	shr    $0x10,%eax
   2133f:	0f b6 c0             	movzbl %al,%eax
   21342:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
   21345:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   2134c:	31 d0                	xor    %edx,%eax
   2134e:	89 45 ac             	mov    %eax,0xffffffac(%ebp)
   21351:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
   21354:	c1 e8 18             	shr    $0x18,%eax
   21357:	8b 0c 85 00 08 00 00 	mov    0x800(,%eax,4),%ecx
   2135e:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
   21362:	31 4d ac             	xor    %ecx,0xffffffac(%ebp)
   21365:	8b 0d 08 00 00 00    	mov    0x8,%ecx
   2136b:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   21372:	31 55 ac             	xor    %edx,0xffffffac(%ebp)
   21375:	8b 45 0c             	mov    0xc(%ebp),%eax
   21378:	31 4d ac             	xor    %ecx,0xffffffac(%ebp)
   2137b:	31 7d ac             	xor    %edi,0xffffffac(%ebp)
   2137e:	8b 55 ac             	mov    0xffffffac(%ebp),%edx
   21381:	89 50 30             	mov    %edx,0x30(%eax)
   21384:	8b 4d bc             	mov    0xffffffbc(%ebp),%ecx
   21387:	31 d1                	xor    %edx,%ecx
   21389:	89 4d a8             	mov    %ecx,0xffffffa8(%ebp)
   2138c:	89 48 34             	mov    %ecx,0x34(%eax)
   2138f:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
   21392:	31 c8                	xor    %ecx,%eax
   21394:	89 45 a4             	mov    %eax,0xffffffa4(%ebp)
   21397:	8b 55 0c             	mov    0xc(%ebp),%edx
   2139a:	89 42 38             	mov    %eax,0x38(%edx)
   2139d:	8b 4d b4             	mov    0xffffffb4(%ebp),%ecx
   213a0:	31 c1                	xor    %eax,%ecx
   213a2:	89 4d a0             	mov    %ecx,0xffffffa0(%ebp)
   213a5:	0f b6 c5             	movzbl %ch,%eax
   213a8:	89 4d f0             	mov    %ecx,0xfffffff0(%ebp)
   213ab:	89 4a 3c             	mov    %ecx,0x3c(%edx)
   213ae:	8b 7d ac             	mov    0xffffffac(%ebp),%edi
   213b1:	89 45 9c             	mov    %eax,0xffffff9c(%ebp)
   213b4:	89 c8                	mov    %ecx,%eax
   213b6:	b9 00 00 00 00       	mov    $0x0,%ecx
   213bb:	c1 e8 10             	shr    $0x10,%eax
   213be:	0f b6 c0             	movzbl %al,%eax
   213c1:	8b 34 85 00 04 00 00 	mov    0x400(,%eax,4),%esi
   213c8:	8b 45 a0             	mov    0xffffffa0(%ebp),%eax
   213cb:	8b 55 9c             	mov    0xffffff9c(%ebp),%edx
   213ce:	c1 e8 18             	shr    $0x18,%eax
   213d1:	8b 1c 91             	mov    (%ecx,%edx,4),%ebx
   213d4:	8b 0c 85 00 08 00 00 	mov    0x800(,%eax,4),%ecx
   213db:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
   213df:	31 de                	xor    %ebx,%esi
   213e1:	31 ce                	xor    %ecx,%esi
   213e3:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   213ea:	a1 0c 00 00 00       	mov    0xc,%eax
   213ef:	31 d6                	xor    %edx,%esi
   213f1:	31 c6                	xor    %eax,%esi
   213f3:	8b 45 0c             	mov    0xc(%ebp),%eax
   213f6:	31 fe                	xor    %edi,%esi
   213f8:	89 70 40             	mov    %esi,0x40(%eax)
   213fb:	8b 55 a8             	mov    0xffffffa8(%ebp),%edx
   213fe:	31 f2                	xor    %esi,%edx
   21400:	89 55 98             	mov    %edx,0xffffff98(%ebp)
   21403:	89 50 44             	mov    %edx,0x44(%eax)
   21406:	8b 4d a4             	mov    0xffffffa4(%ebp),%ecx
   21409:	31 d1                	xor    %edx,%ecx
   2140b:	89 4d 94             	mov    %ecx,0xffffff94(%ebp)
   2140e:	89 48 48             	mov    %ecx,0x48(%eax)
   21411:	8b 45 a0             	mov    0xffffffa0(%ebp),%eax
   21414:	8b 55 0c             	mov    0xc(%ebp),%edx
   21417:	31 c8                	xor    %ecx,%eax
    ke4(cx->ks, 4);  ke4(cx->ks, 5);
   21419:	0f b6 cc             	movzbl %ah,%ecx
   2141c:	89 45 90             	mov    %eax,0xffffff90(%ebp)
   2141f:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   21422:	89 42 4c             	mov    %eax,0x4c(%edx)
   21425:	ba 00 00 00 00       	mov    $0x0,%edx
   2142a:	8b 45 90             	mov    0xffffff90(%ebp),%eax
   2142d:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
   21430:	c1 e8 10             	shr    $0x10,%eax
   21433:	0f b6 c0             	movzbl %al,%eax
   21436:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   2143d:	31 d0                	xor    %edx,%eax
   2143f:	89 45 88             	mov    %eax,0xffffff88(%ebp)
   21442:	8b 45 90             	mov    0xffffff90(%ebp),%eax
   21445:	c1 e8 18             	shr    $0x18,%eax
   21448:	8b 0c 85 00 08 00 00 	mov    0x800(,%eax,4),%ecx
   2144f:	31 4d 88             	xor    %ecx,0xffffff88(%ebp)
   21452:	8b 0d 10 00 00 00    	mov    0x10,%ecx
   21458:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
   2145c:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   21463:	8b 45 0c             	mov    0xc(%ebp),%eax
   21466:	31 55 88             	xor    %edx,0xffffff88(%ebp)
   21469:	31 4d 88             	xor    %ecx,0xffffff88(%ebp)
   2146c:	31 75 88             	xor    %esi,0xffffff88(%ebp)
   2146f:	8b 55 88             	mov    0xffffff88(%ebp),%edx
   21472:	89 50 50             	mov    %edx,0x50(%eax)
   21475:	8b 4d 98             	mov    0xffffff98(%ebp),%ecx
   21478:	31 d1                	xor    %edx,%ecx
   2147a:	89 4d 84             	mov    %ecx,0xffffff84(%ebp)
   2147d:	89 48 54             	mov    %ecx,0x54(%eax)
   21480:	8b 45 94             	mov    0xffffff94(%ebp),%eax
   21483:	8b 55 0c             	mov    0xc(%ebp),%edx
   21486:	31 c8                	xor    %ecx,%eax
   21488:	89 45 80             	mov    %eax,0xffffff80(%ebp)
   2148b:	89 42 58             	mov    %eax,0x58(%edx)
   2148e:	8b 4d 90             	mov    0xffffff90(%ebp),%ecx
   21491:	31 c1                	xor    %eax,%ecx
   21493:	89 8d 7c ff ff ff    	mov    %ecx,0xffffff7c(%ebp)
   21499:	0f b6 c5             	movzbl %ch,%eax
   2149c:	89 4d f0             	mov    %ecx,0xfffffff0(%ebp)
   2149f:	89 4a 5c             	mov    %ecx,0x5c(%edx)
   214a2:	8b 7d 88             	mov    0xffffff88(%ebp),%edi
   214a5:	89 85 78 ff ff ff    	mov    %eax,0xffffff78(%ebp)
   214ab:	89 c8                	mov    %ecx,%eax
   214ad:	b9 00 00 00 00       	mov    $0x0,%ecx
   214b2:	c1 e8 10             	shr    $0x10,%eax
   214b5:	0f b6 c0             	movzbl %al,%eax
   214b8:	8b 1c 85 00 04 00 00 	mov    0x400(,%eax,4),%ebx
   214bf:	8b 85 7c ff ff ff    	mov    0xffffff7c(%ebp),%eax
   214c5:	8b 95 78 ff ff ff    	mov    0xffffff78(%ebp),%edx
   214cb:	c1 e8 18             	shr    $0x18,%eax
   214ce:	8b 34 91             	mov    (%ecx,%edx,4),%esi
   214d1:	8b 0c 85 00 08 00 00 	mov    0x800(,%eax,4),%ecx
   214d8:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
   214dc:	31 f3                	xor    %esi,%ebx
   214de:	31 cb                	xor    %ecx,%ebx
   214e0:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   214e7:	a1 14 00 00 00       	mov    0x14,%eax
   214ec:	31 d3                	xor    %edx,%ebx
   214ee:	31 c3                	xor    %eax,%ebx
   214f0:	8b 45 0c             	mov    0xc(%ebp),%eax
   214f3:	31 fb                	xor    %edi,%ebx
   214f5:	89 58 60             	mov    %ebx,0x60(%eax)
   214f8:	8b 55 84             	mov    0xffffff84(%ebp),%edx
   214fb:	31 da                	xor    %ebx,%edx
   214fd:	89 95 74 ff ff ff    	mov    %edx,0xffffff74(%ebp)
   21503:	89 50 64             	mov    %edx,0x64(%eax)
   21506:	8b 4d 80             	mov    0xffffff80(%ebp),%ecx
   21509:	31 d1                	xor    %edx,%ecx
   2150b:	89 8d 70 ff ff ff    	mov    %ecx,0xffffff70(%ebp)
   21511:	89 48 68             	mov    %ecx,0x68(%eax)
   21514:	8b 85 7c ff ff ff    	mov    0xffffff7c(%ebp),%eax
   2151a:	8b 55 0c             	mov    0xc(%ebp),%edx
   2151d:	31 c8                	xor    %ecx,%eax
    ke4(cx->ks, 6);  ke4(cx->ks, 7);
   2151f:	0f b6 cc             	movzbl %ah,%ecx
   21522:	89 85 6c ff ff ff    	mov    %eax,0xffffff6c(%ebp)
   21528:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   2152b:	89 42 6c             	mov    %eax,0x6c(%edx)
   2152e:	ba 00 00 00 00       	mov    $0x0,%edx
   21533:	8b 85 6c ff ff ff    	mov    0xffffff6c(%ebp),%eax
   21539:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
   2153c:	c1 e8 10             	shr    $0x10,%eax
   2153f:	0f b6 c0             	movzbl %al,%eax
   21542:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   21549:	31 d0                	xor    %edx,%eax
   2154b:	89 85 64 ff ff ff    	mov    %eax,0xffffff64(%ebp)
   21551:	8b 85 6c ff ff ff    	mov    0xffffff6c(%ebp),%eax
   21557:	c1 e8 18             	shr    $0x18,%eax
   2155a:	8b 0c 85 00 08 00 00 	mov    0x800(,%eax,4),%ecx
   21561:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
   21565:	31 8d 64 ff ff ff    	xor    %ecx,0xffffff64(%ebp)
   2156b:	8b 0d 18 00 00 00    	mov    0x18,%ecx
   21571:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   21578:	31 95 64 ff ff ff    	xor    %edx,0xffffff64(%ebp)
   2157e:	8b 45 0c             	mov    0xc(%ebp),%eax
   21581:	31 8d 64 ff ff ff    	xor    %ecx,0xffffff64(%ebp)
   21587:	31 9d 64 ff ff ff    	xor    %ebx,0xffffff64(%ebp)
   2158d:	8b 95 64 ff ff ff    	mov    0xffffff64(%ebp),%edx
   21593:	89 50 70             	mov    %edx,0x70(%eax)
   21596:	8b 8d 74 ff ff ff    	mov    0xffffff74(%ebp),%ecx
   2159c:	31 d1                	xor    %edx,%ecx
   2159e:	89 8d 60 ff ff ff    	mov    %ecx,0xffffff60(%ebp)
   215a4:	89 48 74             	mov    %ecx,0x74(%eax)
   215a7:	8b 85 70 ff ff ff    	mov    0xffffff70(%ebp),%eax
   215ad:	8b 55 0c             	mov    0xc(%ebp),%edx
   215b0:	8b 3d 1c 00 00 00    	mov    0x1c,%edi
   215b6:	31 c8                	xor    %ecx,%eax
   215b8:	89 85 5c ff ff ff    	mov    %eax,0xffffff5c(%ebp)
   215be:	89 42 78             	mov    %eax,0x78(%edx)
   215c1:	8b 8d 6c ff ff ff    	mov    0xffffff6c(%ebp),%ecx
   215c7:	31 c1                	xor    %eax,%ecx
   215c9:	89 8d 58 ff ff ff    	mov    %ecx,0xffffff58(%ebp)
   215cf:	0f b6 c5             	movzbl %ch,%eax
   215d2:	89 4d f0             	mov    %ecx,0xfffffff0(%ebp)
   215d5:	89 4a 7c             	mov    %ecx,0x7c(%edx)
   215d8:	89 85 54 ff ff ff    	mov    %eax,0xffffff54(%ebp)
   215de:	89 c8                	mov    %ecx,%eax
   215e0:	8b 95 54 ff ff ff    	mov    0xffffff54(%ebp),%edx
   215e6:	c1 e8 10             	shr    $0x10,%eax
   215e9:	0f b6 c0             	movzbl %al,%eax
   215ec:	8b 0c 85 00 04 00 00 	mov    0x400(,%eax,4),%ecx
   215f3:	b8 00 00 00 00       	mov    $0x0,%eax
   215f8:	8b 34 90             	mov    (%eax,%edx,4),%esi
   215fb:	8b 85 58 ff ff ff    	mov    0xffffff58(%ebp),%eax
   21601:	31 f1                	xor    %esi,%ecx
   21603:	8b b5 64 ff ff ff    	mov    0xffffff64(%ebp),%esi
   21609:	c1 e8 18             	shr    $0x18,%eax
   2160c:	8b 1c 85 00 08 00 00 	mov    0x800(,%eax,4),%ebx
   21613:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
   21617:	31 d9                	xor    %ebx,%ecx
   21619:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   21620:	31 d1                	xor    %edx,%ecx
   21622:	8b 55 0c             	mov    0xc(%ebp),%edx
   21625:	31 f9                	xor    %edi,%ecx
   21627:	31 f1                	xor    %esi,%ecx
   21629:	89 8a 80 00 00 00    	mov    %ecx,0x80(%edx)
   2162f:	8b 85 60 ff ff ff    	mov    0xffffff60(%ebp),%eax
   21635:	31 c8                	xor    %ecx,%eax
   21637:	89 85 50 ff ff ff    	mov    %eax,0xffffff50(%ebp)
   2163d:	89 82 84 00 00 00    	mov    %eax,0x84(%edx)
   21643:	8b 95 5c ff ff ff    	mov    0xffffff5c(%ebp),%edx
   21649:	31 c2                	xor    %eax,%edx
   2164b:	8b 45 0c             	mov    0xc(%ebp),%eax
   2164e:	89 95 4c ff ff ff    	mov    %edx,0xffffff4c(%ebp)
   21654:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
   2165a:	8b 85 58 ff ff ff    	mov    0xffffff58(%ebp),%eax
   21660:	31 d0                	xor    %edx,%eax
   21662:	8b 55 0c             	mov    0xc(%ebp),%edx
   21665:	89 85 48 ff ff ff    	mov    %eax,0xffffff48(%ebp)
   2166b:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   2166e:	89 82 8c 00 00 00    	mov    %eax,0x8c(%edx)
    ke4(cx->ks, 8);
   21674:	0f b6 c4             	movzbl %ah,%eax
   21677:	ba 00 00 00 00       	mov    $0x0,%edx
   2167c:	89 85 44 ff ff ff    	mov    %eax,0xffffff44(%ebp)
   21682:	8b 85 48 ff ff ff    	mov    0xffffff48(%ebp),%eax
   21688:	c1 e8 10             	shr    $0x10,%eax
   2168b:	0f b6 c0             	movzbl %al,%eax
   2168e:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   21695:	89 85 40 ff ff ff    	mov    %eax,0xffffff40(%ebp)
   2169b:	8b 85 44 ff ff ff    	mov    0xffffff44(%ebp),%eax
   216a1:	8b 04 82             	mov    (%edx,%eax,4),%eax
   216a4:	31 85 40 ff ff ff    	xor    %eax,0xffffff40(%ebp)
   216aa:	8b 85 48 ff ff ff    	mov    0xffffff48(%ebp),%eax
   216b0:	c1 e8 18             	shr    $0x18,%eax
   216b3:	8b 14 85 00 08 00 00 	mov    0x800(,%eax,4),%edx
   216ba:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
   216be:	31 95 40 ff ff ff    	xor    %edx,0xffffff40(%ebp)
   216c4:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   216cb:	a1 20 00 00 00       	mov    0x20,%eax
   216d0:	31 95 40 ff ff ff    	xor    %edx,0xffffff40(%ebp)
   216d6:	8b 55 0c             	mov    0xc(%ebp),%edx
   216d9:	31 85 40 ff ff ff    	xor    %eax,0xffffff40(%ebp)
   216df:	31 8d 40 ff ff ff    	xor    %ecx,0xffffff40(%ebp)
   216e5:	8b 8d 40 ff ff ff    	mov    0xffffff40(%ebp),%ecx
   216eb:	89 8a 90 00 00 00    	mov    %ecx,0x90(%edx)
   216f1:	8b 85 50 ff ff ff    	mov    0xffffff50(%ebp),%eax
   216f7:	31 c8                	xor    %ecx,%eax
   216f9:	89 85 3c ff ff ff    	mov    %eax,0xffffff3c(%ebp)
   216ff:	89 82 94 00 00 00    	mov    %eax,0x94(%edx)
   21705:	8b 95 4c ff ff ff    	mov    0xffffff4c(%ebp),%edx
   2170b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   2170e:	31 c2                	xor    %eax,%edx
   21710:	89 95 38 ff ff ff    	mov    %edx,0xffffff38(%ebp)
   21716:	89 91 98 00 00 00    	mov    %edx,0x98(%ecx)
   2171c:	8b 85 48 ff ff ff    	mov    0xffffff48(%ebp),%eax
   21722:	31 d0                	xor    %edx,%eax
   21724:	89 85 34 ff ff ff    	mov    %eax,0xffffff34(%ebp)
#endif
    kel4(cx->ks, 9);
   2172a:	0f b6 d4             	movzbl %ah,%edx
   2172d:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
   21730:	89 81 9c 00 00 00    	mov    %eax,0x9c(%ecx)
   21736:	b9 00 00 00 00       	mov    $0x0,%ecx
   2173b:	8b 1c 91             	mov    (%ecx,%edx,4),%ebx
   2173e:	8b 95 34 ff ff ff    	mov    0xffffff34(%ebp),%edx
   21744:	8b 85 34 ff ff ff    	mov    0xffffff34(%ebp),%eax
   2174a:	c1 ea 18             	shr    $0x18,%edx
   2174d:	8b bc 91 00 08 00 00 	mov    0x800(%ecx,%edx,4),%edi
   21754:	c1 e8 10             	shr    $0x10,%eax
   21757:	0f b6 4d f0          	movzbl 0xfffffff0(%ebp),%ecx
   2175b:	0f b6 c0             	movzbl %al,%eax
   2175e:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   21765:	ba 00 00 00 00       	mov    $0x0,%edx
   2176a:	8b b4 8a 00 0c 00 00 	mov    0xc00(%edx,%ecx,4),%esi
   21771:	31 d8                	xor    %ebx,%eax
   21773:	8b 1d 24 00 00 00    	mov    0x24,%ebx
   21779:	31 f8                	xor    %edi,%eax
   2177b:	8b 8d 40 ff ff ff    	mov    0xffffff40(%ebp),%ecx
   21781:	31 f0                	xor    %esi,%eax
   21783:	31 d8                	xor    %ebx,%eax
   21785:	31 c8                	xor    %ecx,%eax
   21787:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   2178a:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
   21790:	8b 95 3c ff ff ff    	mov    0xffffff3c(%ebp),%edx
   21796:	31 d0                	xor    %edx,%eax
   21798:	89 81 a4 00 00 00    	mov    %eax,0xa4(%ecx)
   2179e:	8b 95 38 ff ff ff    	mov    0xffffff38(%ebp),%edx
   217a4:	31 c2                	xor    %eax,%edx
   217a6:	89 91 a8 00 00 00    	mov    %edx,0xa8(%ecx)
   217ac:	31 95 34 ff ff ff    	xor    %edx,0xffffff34(%ebp)
   217b2:	8b 85 34 ff ff ff    	mov    0xffffff34(%ebp),%eax
   217b8:	89 81 ac 00 00 00    	mov    %eax,0xac(%ecx)
    cx->rn = 10;
   217be:	b8 0a 00 00 00       	mov    $0xa,%eax
   217c3:	89 81 f0 00 00 00    	mov    %eax,0xf0(%ecx)
#if defined( AES_ERR_CHK )
    return aes_good;
#endif
}
   217c9:	81 c4 d4 00 00 00    	add    $0xd4,%esp
   217cf:	31 c0                	xor    %eax,%eax
   217d1:	5b                   	pop    %ebx
   217d2:	5e                   	pop    %esi
   217d3:	5f                   	pop    %edi
   217d4:	5d                   	pop    %ebp
   217d5:	c3                   	ret    
   217d6:	8d 76 00             	lea    0x0(%esi),%esi
   217d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

000217e0 <aes_encrypt_key192>:

#endif

#if defined(AES_192) || defined(AES_VAR)

aes_rval aes_encrypt_key192(const unsigned char *key, aes_encrypt_ctx cx[1])
{   aes_32t    ss[6];
   217e0:	55                   	push   %ebp
   217e1:	89 e5                	mov    %esp,%ebp
   217e3:	57                   	push   %edi
   217e4:	56                   	push   %esi
   217e5:	53                   	push   %ebx
   217e6:	81 ec f0 00 00 00    	sub    $0xf0,%esp

    cx->ks[0] = ss[0] = word_in(key, 0);
   217ec:	8b 45 08             	mov    0x8(%ebp),%eax
   217ef:	8b 55 08             	mov    0x8(%ebp),%edx
   217f2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   217f5:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   217f9:	c1 e0 18             	shl    $0x18,%eax
   217fc:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
   217ff:	0f b6 42 02          	movzbl 0x2(%edx),%eax
   21803:	c1 e0 10             	shl    $0x10,%eax
   21806:	09 45 d0             	or     %eax,0xffffffd0(%ebp)
   21809:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   2180d:	c1 e0 08             	shl    $0x8,%eax
   21810:	09 45 d0             	or     %eax,0xffffffd0(%ebp)
   21813:	0f b6 02             	movzbl (%edx),%eax
   21816:	09 45 d0             	or     %eax,0xffffffd0(%ebp)
   21819:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   2181c:	89 01                	mov    %eax,(%ecx)
    cx->ks[1] = ss[1] = word_in(key, 1);
   2181e:	8b 4d 08             	mov    0x8(%ebp),%ecx
   21821:	0f b6 52 07          	movzbl 0x7(%edx),%edx
   21825:	0f b6 41 06          	movzbl 0x6(%ecx),%eax
   21829:	c1 e2 18             	shl    $0x18,%edx
   2182c:	c1 e0 10             	shl    $0x10,%eax
   2182f:	09 c2                	or     %eax,%edx
   21831:	0f b6 41 05          	movzbl 0x5(%ecx),%eax
   21835:	c1 e0 08             	shl    $0x8,%eax
   21838:	09 c2                	or     %eax,%edx
   2183a:	0f b6 41 04          	movzbl 0x4(%ecx),%eax
   2183e:	09 c2                	or     %eax,%edx
   21840:	8b 45 0c             	mov    0xc(%ebp),%eax
   21843:	89 55 cc             	mov    %edx,0xffffffcc(%ebp)
   21846:	89 50 04             	mov    %edx,0x4(%eax)
    cx->ks[2] = ss[2] = word_in(key, 2);
   21849:	0f b6 51 0b          	movzbl 0xb(%ecx),%edx
   2184d:	0f b6 41 0a          	movzbl 0xa(%ecx),%eax
   21851:	c1 e2 18             	shl    $0x18,%edx
   21854:	c1 e0 10             	shl    $0x10,%eax
   21857:	09 c2                	or     %eax,%edx
   21859:	0f b6 41 09          	movzbl 0x9(%ecx),%eax
   2185d:	c1 e0 08             	shl    $0x8,%eax
   21860:	09 c2                	or     %eax,%edx
   21862:	0f b6 41 08          	movzbl 0x8(%ecx),%eax
   21866:	09 c2                	or     %eax,%edx
   21868:	89 55 c8             	mov    %edx,0xffffffc8(%ebp)
   2186b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   2186e:	89 51 08             	mov    %edx,0x8(%ecx)
    cx->ks[3] = ss[3] = word_in(key, 3);
   21871:	8b 45 08             	mov    0x8(%ebp),%eax
   21874:	8b 55 08             	mov    0x8(%ebp),%edx
   21877:	0f b6 40 0f          	movzbl 0xf(%eax),%eax
   2187b:	c1 e0 18             	shl    $0x18,%eax
   2187e:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
   21881:	0f b6 42 0e          	movzbl 0xe(%edx),%eax
   21885:	c1 e0 10             	shl    $0x10,%eax
   21888:	09 45 c4             	or     %eax,0xffffffc4(%ebp)
   2188b:	0f b6 42 0d          	movzbl 0xd(%edx),%eax
   2188f:	c1 e0 08             	shl    $0x8,%eax
   21892:	09 45 c4             	or     %eax,0xffffffc4(%ebp)
   21895:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
   21899:	09 45 c4             	or     %eax,0xffffffc4(%ebp)
   2189c:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
   2189f:	89 41 0c             	mov    %eax,0xc(%ecx)
    cx->ks[4] = ss[4] = word_in(key, 4);
   218a2:	8b 4d 08             	mov    0x8(%ebp),%ecx
   218a5:	0f b6 52 13          	movzbl 0x13(%edx),%edx
   218a9:	0f b6 41 12          	movzbl 0x12(%ecx),%eax
   218ad:	c1 e2 18             	shl    $0x18,%edx
   218b0:	c1 e0 10             	shl    $0x10,%eax
   218b3:	09 c2                	or     %eax,%edx
   218b5:	0f b6 41 11          	movzbl 0x11(%ecx),%eax
   218b9:	c1 e0 08             	shl    $0x8,%eax
   218bc:	09 c2                	or     %eax,%edx
   218be:	0f b6 41 10          	movzbl 0x10(%ecx),%eax
   218c2:	09 c2                	or     %eax,%edx
   218c4:	8b 45 0c             	mov    0xc(%ebp),%eax
   218c7:	89 55 c0             	mov    %edx,0xffffffc0(%ebp)
   218ca:	89 50 10             	mov    %edx,0x10(%eax)
    cx->ks[5] = ss[5] = word_in(key, 5);
   218cd:	0f b6 51 17          	movzbl 0x17(%ecx),%edx
   218d1:	0f b6 41 16          	movzbl 0x16(%ecx),%eax
   218d5:	c1 e2 18             	shl    $0x18,%edx
   218d8:	c1 e0 10             	shl    $0x10,%eax
   218db:	09 c2                	or     %eax,%edx
   218dd:	0f b6 41 15          	movzbl 0x15(%ecx),%eax
   218e1:	c1 e0 08             	shl    $0x8,%eax
   218e4:	09 c2                	or     %eax,%edx
   218e6:	0f b6 41 14          	movzbl 0x14(%ecx),%eax
   218ea:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   218ed:	09 c2                	or     %eax,%edx
   218ef:	89 55 bc             	mov    %edx,0xffffffbc(%ebp)

#if ENC_UNROLL == NONE
    {   aes_32t i;

        for(i = 0; i < (13 * N_COLS - 7) / 6; ++i)
            ke6(cx->ks, i);
    }
#else
    ke6(cx->ks, 0);  ke6(cx->ks, 1);
   218f2:	0f b6 c6             	movzbl %dh,%eax
   218f5:	89 55 e8             	mov    %edx,0xffffffe8(%ebp)
   218f8:	89 51 14             	mov    %edx,0x14(%ecx)
   218fb:	b9 00 00 00 00       	mov    $0x0,%ecx
   21900:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
   21903:	89 d0                	mov    %edx,%eax
   21905:	8b 55 b8             	mov    0xffffffb8(%ebp),%edx
   21908:	c1 e8 10             	shr    $0x10,%eax
   2190b:	0f b6 c0             	movzbl %al,%eax
   2190e:	8b 14 91             	mov    (%ecx,%edx,4),%edx
   21911:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   21918:	31 d0                	xor    %edx,%eax
   2191a:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
   2191d:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
   21920:	c1 e8 18             	shr    $0x18,%eax
   21923:	8b 0c 85 00 08 00 00 	mov    0x800(,%eax,4),%ecx
   2192a:	0f b6 45 e8          	movzbl 0xffffffe8(%ebp),%eax
   2192e:	31 4d b4             	xor    %ecx,0xffffffb4(%ebp)
   21931:	8b 0d 00 00 00 00    	mov    0x0,%ecx
   21937:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   2193e:	31 55 b4             	xor    %edx,0xffffffb4(%ebp)
   21941:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   21944:	8b 55 0c             	mov    0xc(%ebp),%edx
   21947:	31 4d b4             	xor    %ecx,0xffffffb4(%ebp)
   2194a:	31 45 b4             	xor    %eax,0xffffffb4(%ebp)
   2194d:	8b 4d b4             	mov    0xffffffb4(%ebp),%ecx
   21950:	89 4a 18             	mov    %ecx,0x18(%edx)
   21953:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
   21956:	31 c8                	xor    %ecx,%eax
   21958:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
   2195b:	89 42 1c             	mov    %eax,0x1c(%edx)
   2195e:	8b 55 c8             	mov    0xffffffc8(%ebp),%edx
   21961:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   21964:	31 c2                	xor    %eax,%edx
   21966:	89 55 ac             	mov    %edx,0xffffffac(%ebp)
   21969:	89 51 20             	mov    %edx,0x20(%ecx)
   2196c:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
   2196f:	31 d0                	xor    %edx,%eax
   21971:	89 45 a8             	mov    %eax,0xffffffa8(%ebp)
   21974:	89 41 24             	mov    %eax,0x24(%ecx)
   21977:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
   2197a:	31 c2                	xor    %eax,%edx
   2197c:	89 55 a4             	mov    %edx,0xffffffa4(%ebp)
   2197f:	89 51 28             	mov    %edx,0x28(%ecx)
   21982:	8b 4d bc             	mov    0xffffffbc(%ebp),%ecx
   21985:	8b 45 0c             	mov    0xc(%ebp),%eax
   21988:	31 d1                	xor    %edx,%ecx
   2198a:	0f b6 d5             	movzbl %ch,%edx
   2198d:	8b 1c 95 00 00 00 00 	mov    0x0(,%edx,4),%ebx
   21994:	89 4d e8             	mov    %ecx,0xffffffe8(%ebp)
   21997:	89 4d a0             	mov    %ecx,0xffffffa0(%ebp)
   2199a:	89 48 2c             	mov    %ecx,0x2c(%eax)
   2199d:	89 c8                	mov    %ecx,%eax
   2199f:	c1 e8 10             	shr    $0x10,%eax
   219a2:	0f b6 c0             	movzbl %al,%eax
   219a5:	8b 34 85 00 04 00 00 	mov    0x400(,%eax,4),%esi
   219ac:	89 c8                	mov    %ecx,%eax
   219ae:	c1 e8 18             	shr    $0x18,%eax
   219b1:	8b 0c 85 00 08 00 00 	mov    0x800(,%eax,4),%ecx
   219b8:	31 de                	xor    %ebx,%esi
   219ba:	0f b6 45 e8          	movzbl 0xffffffe8(%ebp),%eax
   219be:	8b 7d b4             	mov    0xffffffb4(%ebp),%edi
   219c1:	31 ce                	xor    %ecx,%esi
   219c3:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   219ca:	a1 04 00 00 00       	mov    0x4,%eax
   219cf:	31 d6                	xor    %edx,%esi
   219d1:	8b 55 0c             	mov    0xc(%ebp),%edx
   219d4:	31 c6                	xor    %eax,%esi
   219d6:	31 fe                	xor    %edi,%esi
   219d8:	89 72 30             	mov    %esi,0x30(%edx)
   219db:	8b 4d b0             	mov    0xffffffb0(%ebp),%ecx
   219de:	31 f1                	xor    %esi,%ecx
   219e0:	89 4d 9c             	mov    %ecx,0xffffff9c(%ebp)
   219e3:	89 4a 34             	mov    %ecx,0x34(%edx)
   219e6:	8b 45 ac             	mov    0xffffffac(%ebp),%eax
   219e9:	31 c8                	xor    %ecx,%eax
   219eb:	89 45 98             	mov    %eax,0xffffff98(%ebp)
   219ee:	89 42 38             	mov    %eax,0x38(%edx)
   219f1:	8b 55 a8             	mov    0xffffffa8(%ebp),%edx
   219f4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   219f7:	31 c2                	xor    %eax,%edx
   219f9:	89 55 94             	mov    %edx,0xffffff94(%ebp)
   219fc:	89 51 3c             	mov    %edx,0x3c(%ecx)
   219ff:	8b 45 a4             	mov    0xffffffa4(%ebp),%eax
   21a02:	31 d0                	xor    %edx,%eax
   21a04:	89 45 90             	mov    %eax,0xffffff90(%ebp)
   21a07:	89 41 40             	mov    %eax,0x40(%ecx)
   21a0a:	8b 55 a0             	mov    0xffffffa0(%ebp),%edx
   21a0d:	31 c2                	xor    %eax,%edx
   21a0f:	89 55 8c             	mov    %edx,0xffffff8c(%ebp)
    ke6(cx->ks, 2);  ke6(cx->ks, 3);
   21a12:	89 d0                	mov    %edx,%eax
   21a14:	0f b6 fe             	movzbl %dh,%edi
   21a17:	89 55 e8             	mov    %edx,0xffffffe8(%ebp)
   21a1a:	c1 e8 10             	shr    $0x10,%eax
   21a1d:	0f b6 c0             	movzbl %al,%eax
   21a20:	89 51 44             	mov    %edx,0x44(%ecx)
   21a23:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   21a2a:	8b 0c bd 00 00 00 00 	mov    0x0(,%edi,4),%ecx
   21a31:	31 c8                	xor    %ecx,%eax
   21a33:	89 45 88             	mov    %eax,0xffffff88(%ebp)
   21a36:	89 d0                	mov    %edx,%eax
   21a38:	c1 e8 18             	shr    $0x18,%eax
   21a3b:	8b 14 85 00 08 00 00 	mov    0x800(,%eax,4),%edx
   21a42:	0f b6 45 e8          	movzbl 0xffffffe8(%ebp),%eax
   21a46:	31 55 88             	xor    %edx,0xffffff88(%ebp)
   21a49:	8b 55 0c             	mov    0xc(%ebp),%edx
   21a4c:	8b 0c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ecx
   21a53:	31 4d 88             	xor    %ecx,0xffffff88(%ebp)
   21a56:	a1 08 00 00 00       	mov    0x8,%eax
   21a5b:	31 45 88             	xor    %eax,0xffffff88(%ebp)
   21a5e:	31 75 88             	xor    %esi,0xffffff88(%ebp)
   21a61:	8b 4d 88             	mov    0xffffff88(%ebp),%ecx
   21a64:	89 4a 48             	mov    %ecx,0x48(%edx)
   21a67:	8b 45 9c             	mov    0xffffff9c(%ebp),%eax
   21a6a:	31 c8                	xor    %ecx,%eax
   21a6c:	89 45 84             	mov    %eax,0xffffff84(%ebp)
   21a6f:	89 42 4c             	mov    %eax,0x4c(%edx)
   21a72:	8b 55 98             	mov    0xffffff98(%ebp),%edx
   21a75:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   21a78:	31 c2                	xor    %eax,%edx
   21a7a:	89 55 80             	mov    %edx,0xffffff80(%ebp)
   21a7d:	89 51 50             	mov    %edx,0x50(%ecx)
   21a80:	8b 45 94             	mov    0xffffff94(%ebp),%eax
   21a83:	31 d0                	xor    %edx,%eax
   21a85:	89 85 7c ff ff ff    	mov    %eax,0xffffff7c(%ebp)
   21a8b:	89 41 54             	mov    %eax,0x54(%ecx)
   21a8e:	8b 55 90             	mov    0xffffff90(%ebp),%edx
   21a91:	31 c2                	xor    %eax,%edx
   21a93:	89 95 78 ff ff ff    	mov    %edx,0xffffff78(%ebp)
   21a99:	89 51 58             	mov    %edx,0x58(%ecx)
   21a9c:	8b 4d 8c             	mov    0xffffff8c(%ebp),%ecx
   21a9f:	8b 45 0c             	mov    0xc(%ebp),%eax
   21aa2:	31 d1                	xor    %edx,%ecx
   21aa4:	0f b6 d5             	movzbl %ch,%edx
   21aa7:	89 8d 74 ff ff ff    	mov    %ecx,0xffffff74(%ebp)
   21aad:	89 4d e8             	mov    %ecx,0xffffffe8(%ebp)
   21ab0:	89 48 5c             	mov    %ecx,0x5c(%eax)
   21ab3:	89 c8                	mov    %ecx,%eax
   21ab5:	b9 00 00 00 00       	mov    $0x0,%ecx
   21aba:	c1 e8 10             	shr    $0x10,%eax
   21abd:	8b 34 91             	mov    (%ecx,%edx,4),%esi
   21ac0:	0f b6 c0             	movzbl %al,%eax
   21ac3:	8b 1c 85 00 04 00 00 	mov    0x400(,%eax,4),%ebx
   21aca:	8b 85 74 ff ff ff    	mov    0xffffff74(%ebp),%eax
   21ad0:	8b 7d 88             	mov    0xffffff88(%ebp),%edi
   21ad3:	31 f3                	xor    %esi,%ebx
   21ad5:	c1 e8 18             	shr    $0x18,%eax
   21ad8:	8b 0c 85 00 08 00 00 	mov    0x800(,%eax,4),%ecx
   21adf:	0f b6 45 e8          	movzbl 0xffffffe8(%ebp),%eax
   21ae3:	31 cb                	xor    %ecx,%ebx
   21ae5:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   21aec:	a1 0c 00 00 00       	mov    0xc,%eax
   21af1:	31 d3                	xor    %edx,%ebx
   21af3:	31 c3                	xor    %eax,%ebx
   21af5:	8b 45 0c             	mov    0xc(%ebp),%eax
   21af8:	31 fb                	xor    %edi,%ebx
   21afa:	89 58 60             	mov    %ebx,0x60(%eax)
   21afd:	8b 55 84             	mov    0xffffff84(%ebp),%edx
   21b00:	31 da                	xor    %ebx,%edx
   21b02:	89 95 6c ff ff ff    	mov    %edx,0xffffff6c(%ebp)
   21b08:	89 50 64             	mov    %edx,0x64(%eax)
   21b0b:	8b 4d 80             	mov    0xffffff80(%ebp),%ecx
   21b0e:	31 d1                	xor    %edx,%ecx
   21b10:	89 8d 68 ff ff ff    	mov    %ecx,0xffffff68(%ebp)
   21b16:	89 48 68             	mov    %ecx,0x68(%eax)
   21b19:	8b 85 7c ff ff ff    	mov    0xffffff7c(%ebp),%eax
   21b1f:	8b 55 0c             	mov    0xc(%ebp),%edx
   21b22:	31 c8                	xor    %ecx,%eax
   21b24:	89 85 64 ff ff ff    	mov    %eax,0xffffff64(%ebp)
   21b2a:	89 42 6c             	mov    %eax,0x6c(%edx)
   21b2d:	8b 8d 78 ff ff ff    	mov    0xffffff78(%ebp),%ecx
   21b33:	31 c1                	xor    %eax,%ecx
   21b35:	89 8d 60 ff ff ff    	mov    %ecx,0xffffff60(%ebp)
   21b3b:	89 4a 70             	mov    %ecx,0x70(%edx)
   21b3e:	8b 85 74 ff ff ff    	mov    0xffffff74(%ebp),%eax
   21b44:	31 c8                	xor    %ecx,%eax
    ke6(cx->ks, 4);  ke6(cx->ks, 5);
   21b46:	b9 00 00 00 00       	mov    $0x0,%ecx
   21b4b:	89 85 5c ff ff ff    	mov    %eax,0xffffff5c(%ebp)
   21b51:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   21b54:	89 42 74             	mov    %eax,0x74(%edx)
   21b57:	0f b6 d4             	movzbl %ah,%edx
   21b5a:	8b 85 5c ff ff ff    	mov    0xffffff5c(%ebp),%eax
   21b60:	8b 0c 91             	mov    (%ecx,%edx,4),%ecx
   21b63:	c1 e8 10             	shr    $0x10,%eax
   21b66:	0f b6 c0             	movzbl %al,%eax
   21b69:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   21b70:	31 c8                	xor    %ecx,%eax
   21b72:	89 85 54 ff ff ff    	mov    %eax,0xffffff54(%ebp)
   21b78:	8b 85 5c ff ff ff    	mov    0xffffff5c(%ebp),%eax
   21b7e:	c1 e8 18             	shr    $0x18,%eax
   21b81:	8b 14 85 00 08 00 00 	mov    0x800(,%eax,4),%edx
   21b88:	0f b6 45 e8          	movzbl 0xffffffe8(%ebp),%eax
   21b8c:	31 95 54 ff ff ff    	xor    %edx,0xffffff54(%ebp)
   21b92:	8b 55 0c             	mov    0xc(%ebp),%edx
   21b95:	8b 0c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ecx
   21b9c:	31 8d 54 ff ff ff    	xor    %ecx,0xffffff54(%ebp)
   21ba2:	a1 10 00 00 00       	mov    0x10,%eax
   21ba7:	31 85 54 ff ff ff    	xor    %eax,0xffffff54(%ebp)
   21bad:	31 9d 54 ff ff ff    	xor    %ebx,0xffffff54(%ebp)
   21bb3:	8b 8d 54 ff ff ff    	mov    0xffffff54(%ebp),%ecx
   21bb9:	89 4a 78             	mov    %ecx,0x78(%edx)
   21bbc:	8b 85 6c ff ff ff    	mov    0xffffff6c(%ebp),%eax
   21bc2:	31 c8                	xor    %ecx,%eax
   21bc4:	89 85 50 ff ff ff    	mov    %eax,0xffffff50(%ebp)
   21bca:	89 42 7c             	mov    %eax,0x7c(%edx)
   21bcd:	8b 95 68 ff ff ff    	mov    0xffffff68(%ebp),%edx
   21bd3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   21bd6:	31 c2                	xor    %eax,%edx
   21bd8:	89 95 4c ff ff ff    	mov    %edx,0xffffff4c(%ebp)
   21bde:	89 91 80 00 00 00    	mov    %edx,0x80(%ecx)
   21be4:	8b 85 64 ff ff ff    	mov    0xffffff64(%ebp),%eax
   21bea:	31 d0                	xor    %edx,%eax
   21bec:	89 85 48 ff ff ff    	mov    %eax,0xffffff48(%ebp)
   21bf2:	89 81 84 00 00 00    	mov    %eax,0x84(%ecx)
   21bf8:	8b 95 60 ff ff ff    	mov    0xffffff60(%ebp),%edx
   21bfe:	31 c2                	xor    %eax,%edx
   21c00:	89 95 44 ff ff ff    	mov    %edx,0xffffff44(%ebp)
   21c06:	89 91 88 00 00 00    	mov    %edx,0x88(%ecx)
   21c0c:	8b 8d 5c ff ff ff    	mov    0xffffff5c(%ebp),%ecx
   21c12:	8b 45 0c             	mov    0xc(%ebp),%eax
   21c15:	31 d1                	xor    %edx,%ecx
   21c17:	0f b6 d5             	movzbl %ch,%edx
   21c1a:	89 8d 40 ff ff ff    	mov    %ecx,0xffffff40(%ebp)
   21c20:	89 4d e8             	mov    %ecx,0xffffffe8(%ebp)
   21c23:	89 88 8c 00 00 00    	mov    %ecx,0x8c(%eax)
   21c29:	89 c8                	mov    %ecx,%eax
   21c2b:	c1 e8 10             	shr    $0x10,%eax
   21c2e:	0f b6 c0             	movzbl %al,%eax
   21c31:	8b 0c 85 00 04 00 00 	mov    0x400(,%eax,4),%ecx
   21c38:	b8 00 00 00 00       	mov    $0x0,%eax
   21c3d:	8b 34 90             	mov    (%eax,%edx,4),%esi
   21c40:	8b 85 40 ff ff ff    	mov    0xffffff40(%ebp),%eax
   21c46:	31 f1                	xor    %esi,%ecx
   21c48:	c1 e8 18             	shr    $0x18,%eax
   21c4b:	8b 1c 85 00 08 00 00 	mov    0x800(,%eax,4),%ebx
   21c52:	0f b6 45 e8          	movzbl 0xffffffe8(%ebp),%eax
   21c56:	31 d9                	xor    %ebx,%ecx
   21c58:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   21c5f:	a1 14 00 00 00       	mov    0x14,%eax
   21c64:	31 d1                	xor    %edx,%ecx
   21c66:	8b 55 0c             	mov    0xc(%ebp),%edx
   21c69:	31 c1                	xor    %eax,%ecx
   21c6b:	8b 85 54 ff ff ff    	mov    0xffffff54(%ebp),%eax
   21c71:	31 c1                	xor    %eax,%ecx
   21c73:	89 8a 90 00 00 00    	mov    %ecx,0x90(%edx)
   21c79:	8b 85 50 ff ff ff    	mov    0xffffff50(%ebp),%eax
   21c7f:	31 c8                	xor    %ecx,%eax
   21c81:	89 85 38 ff ff ff    	mov    %eax,0xffffff38(%ebp)
   21c87:	89 82 94 00 00 00    	mov    %eax,0x94(%edx)
   21c8d:	8b 95 4c ff ff ff    	mov    0xffffff4c(%ebp),%edx
   21c93:	31 c2                	xor    %eax,%edx
   21c95:	8b 45 0c             	mov    0xc(%ebp),%eax
   21c98:	89 95 34 ff ff ff    	mov    %edx,0xffffff34(%ebp)
   21c9e:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
   21ca4:	8b 85 48 ff ff ff    	mov    0xffffff48(%ebp),%eax
   21caa:	31 d0                	xor    %edx,%eax
   21cac:	8b 55 0c             	mov    0xc(%ebp),%edx
   21caf:	89 85 30 ff ff ff    	mov    %eax,0xffffff30(%ebp)
   21cb5:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
   21cbb:	8b 95 44 ff ff ff    	mov    0xffffff44(%ebp),%edx
   21cc1:	31 c2                	xor    %eax,%edx
   21cc3:	8b 45 0c             	mov    0xc(%ebp),%eax
   21cc6:	89 95 2c ff ff ff    	mov    %edx,0xffffff2c(%ebp)
   21ccc:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
   21cd2:	8b 85 40 ff ff ff    	mov    0xffffff40(%ebp),%eax
   21cd8:	31 d0                	xor    %edx,%eax
   21cda:	8b 55 0c             	mov    0xc(%ebp),%edx
   21cdd:	89 85 28 ff ff ff    	mov    %eax,0xffffff28(%ebp)
   21ce3:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   21ce6:	89 82 a4 00 00 00    	mov    %eax,0xa4(%edx)
    ke6(cx->ks, 6);
   21cec:	0f b6 c4             	movzbl %ah,%eax
   21cef:	ba 00 00 00 00       	mov    $0x0,%edx
   21cf4:	89 85 24 ff ff ff    	mov    %eax,0xffffff24(%ebp)
   21cfa:	8b 85 28 ff ff ff    	mov    0xffffff28(%ebp),%eax
   21d00:	c1 e8 10             	shr    $0x10,%eax
   21d03:	0f b6 c0             	movzbl %al,%eax
   21d06:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   21d0d:	89 85 20 ff ff ff    	mov    %eax,0xffffff20(%ebp)
   21d13:	8b 85 24 ff ff ff    	mov    0xffffff24(%ebp),%eax
   21d19:	8b 04 82             	mov    (%edx,%eax,4),%eax
   21d1c:	31 85 20 ff ff ff    	xor    %eax,0xffffff20(%ebp)
   21d22:	8b 85 28 ff ff ff    	mov    0xffffff28(%ebp),%eax
   21d28:	c1 e8 18             	shr    $0x18,%eax
   21d2b:	8b 14 85 00 08 00 00 	mov    0x800(,%eax,4),%edx
   21d32:	0f b6 45 e8          	movzbl 0xffffffe8(%ebp),%eax
   21d36:	31 95 20 ff ff ff    	xor    %edx,0xffffff20(%ebp)
   21d3c:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   21d43:	a1 18 00 00 00       	mov    0x18,%eax
   21d48:	31 95 20 ff ff ff    	xor    %edx,0xffffff20(%ebp)
   21d4e:	8b 55 0c             	mov    0xc(%ebp),%edx
   21d51:	31 85 20 ff ff ff    	xor    %eax,0xffffff20(%ebp)
   21d57:	31 8d 20 ff ff ff    	xor    %ecx,0xffffff20(%ebp)
   21d5d:	8b 8d 20 ff ff ff    	mov    0xffffff20(%ebp),%ecx
   21d63:	89 8a a8 00 00 00    	mov    %ecx,0xa8(%edx)
   21d69:	8b 85 38 ff ff ff    	mov    0xffffff38(%ebp),%eax
   21d6f:	31 c8                	xor    %ecx,%eax
   21d71:	89 85 1c ff ff ff    	mov    %eax,0xffffff1c(%ebp)
   21d77:	89 82 ac 00 00 00    	mov    %eax,0xac(%edx)
   21d7d:	8b 95 34 ff ff ff    	mov    0xffffff34(%ebp),%edx
   21d83:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   21d86:	31 c2                	xor    %eax,%edx
   21d88:	89 95 18 ff ff ff    	mov    %edx,0xffffff18(%ebp)
   21d8e:	89 91 b0 00 00 00    	mov    %edx,0xb0(%ecx)
   21d94:	8b 85 30 ff ff ff    	mov    0xffffff30(%ebp),%eax
   21d9a:	31 d0                	xor    %edx,%eax
   21d9c:	89 85 14 ff ff ff    	mov    %eax,0xffffff14(%ebp)
   21da2:	89 81 b4 00 00 00    	mov    %eax,0xb4(%ecx)
   21da8:	8b 95 2c ff ff ff    	mov    0xffffff2c(%ebp),%edx
   21dae:	31 c2                	xor    %eax,%edx
   21db0:	89 91 b8 00 00 00    	mov    %edx,0xb8(%ecx)
   21db6:	8b 8d 28 ff ff ff    	mov    0xffffff28(%ebp),%ecx
   21dbc:	8b 45 0c             	mov    0xc(%ebp),%eax
   21dbf:	31 d1                	xor    %edx,%ecx
#endif
    kel6(cx->ks, 7);
   21dc1:	0f b6 d5             	movzbl %ch,%edx
   21dc4:	89 4d e8             	mov    %ecx,0xffffffe8(%ebp)
   21dc7:	89 88 bc 00 00 00    	mov    %ecx,0xbc(%eax)
   21dcd:	c1 e9 10             	shr    $0x10,%ecx
   21dd0:	0f b6 c1             	movzbl %cl,%eax
   21dd3:	89 8d 0c ff ff ff    	mov    %ecx,0xffffff0c(%ebp)
   21dd9:	b9 00 00 00 00       	mov    $0x0,%ecx
   21dde:	c1 ad 0c ff ff ff 08 	shrl   $0x8,0xffffff0c(%ebp)
   21de5:	8b 3c 91             	mov    (%ecx,%edx,4),%edi
   21de8:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   21def:	8b 95 0c ff ff ff    	mov    0xffffff0c(%ebp),%edx
   21df5:	31 f8                	xor    %edi,%eax
   21df7:	8b 3d 1c 00 00 00    	mov    0x1c,%edi
   21dfd:	8b b4 91 00 08 00 00 	mov    0x800(%ecx,%edx,4),%esi
   21e04:	ba 00 00 00 00       	mov    $0x0,%edx
   21e09:	0f b6 4d e8          	movzbl 0xffffffe8(%ebp),%ecx
   21e0d:	31 f0                	xor    %esi,%eax
   21e0f:	8b b5 20 ff ff ff    	mov    0xffffff20(%ebp),%esi
   21e15:	8b 9c 8a 00 0c 00 00 	mov    0xc00(%edx,%ecx,4),%ebx
   21e1c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   21e1f:	31 d8                	xor    %ebx,%eax
   21e21:	31 f8                	xor    %edi,%eax
    cx->rn = 12;
   21e23:	bf 0c 00 00 00       	mov    $0xc,%edi
   21e28:	31 f0                	xor    %esi,%eax
   21e2a:	89 81 c0 00 00 00    	mov    %eax,0xc0(%ecx)
   21e30:	8b 9d 1c ff ff ff    	mov    0xffffff1c(%ebp),%ebx
   21e36:	31 d8                	xor    %ebx,%eax
   21e38:	89 81 c4 00 00 00    	mov    %eax,0xc4(%ecx)
   21e3e:	8b 95 18 ff ff ff    	mov    0xffffff18(%ebp),%edx
   21e44:	31 d0                	xor    %edx,%eax
   21e46:	89 81 c8 00 00 00    	mov    %eax,0xc8(%ecx)
   21e4c:	31 85 14 ff ff ff    	xor    %eax,0xffffff14(%ebp)
   21e52:	8b 85 14 ff ff ff    	mov    0xffffff14(%ebp),%eax
   21e58:	89 b9 f0 00 00 00    	mov    %edi,0xf0(%ecx)
   21e5e:	89 81 cc 00 00 00    	mov    %eax,0xcc(%ecx)
#if defined( AES_ERR_CHK )
    return aes_good;
#endif
}
   21e64:	31 c0                	xor    %eax,%eax
   21e66:	81 c4 f0 00 00 00    	add    $0xf0,%esp
   21e6c:	5b                   	pop    %ebx
   21e6d:	5e                   	pop    %esi
   21e6e:	5f                   	pop    %edi
   21e6f:	5d                   	pop    %ebp
   21e70:	c3                   	ret    
   21e71:	eb 0d                	jmp    21e80 <aes_encrypt_key256>
   21e73:	90                   	nop    
   21e74:	90                   	nop    
   21e75:	90                   	nop    
   21e76:	90                   	nop    
   21e77:	90                   	nop    
   21e78:	90                   	nop    
   21e79:	90                   	nop    
   21e7a:	90                   	nop    
   21e7b:	90                   	nop    
   21e7c:	90                   	nop    
   21e7d:	90                   	nop    
   21e7e:	90                   	nop    
   21e7f:	90                   	nop    

00021e80 <aes_encrypt_key256>:

#endif

#if defined(AES_256) || defined(AES_VAR)

aes_rval aes_encrypt_key256(const unsigned char *key, aes_encrypt_ctx cx[1])
{   aes_32t    ss[8];
   21e80:	55                   	push   %ebp
   21e81:	89 e5                	mov    %esp,%ebp
   21e83:	57                   	push   %edi
   21e84:	56                   	push   %esi

    cx->ks[0] = ss[0] = word_in(key, 0);
    cx->ks[1] = ss[1] = word_in(key, 1);
    cx->ks[2] = ss[2] = word_in(key, 2);
    cx->ks[3] = ss[3] = word_in(key, 3);
    cx->ks[4] = ss[4] = word_in(key, 4);
    cx->ks[5] = ss[5] = word_in(key, 5);
    cx->ks[6] = ss[6] = word_in(key, 6);
    cx->ks[7] = ss[7] = word_in(key, 7);

#if ENC_UNROLL == NONE
    {   aes_32t i;

        for(i = 0; i < (15 * N_COLS - 9) / 8; ++i)
            ke8(cx->ks,  i);
    }
#else
    ke8(cx->ks, 0); ke8(cx->ks, 1);
   21e85:	be 00 00 00 00       	mov    $0x0,%esi
   21e8a:	53                   	push   %ebx
   21e8b:	81 ec c8 00 00 00    	sub    $0xc8,%esp
   21e91:	8b 55 08             	mov    0x8(%ebp),%edx
   21e94:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   21e97:	0f b6 42 03          	movzbl 0x3(%edx),%eax
   21e9b:	c1 e0 18             	shl    $0x18,%eax
   21e9e:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
   21ea1:	0f b6 42 02          	movzbl 0x2(%edx),%eax
   21ea5:	c1 e0 10             	shl    $0x10,%eax
   21ea8:	09 45 d0             	or     %eax,0xffffffd0(%ebp)
   21eab:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   21eaf:	c1 e0 08             	shl    $0x8,%eax
   21eb2:	09 45 d0             	or     %eax,0xffffffd0(%ebp)
   21eb5:	0f b6 02             	movzbl (%edx),%eax
   21eb8:	09 45 d0             	or     %eax,0xffffffd0(%ebp)
   21ebb:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   21ebe:	89 01                	mov    %eax,(%ecx)
   21ec0:	0f b6 4a 07          	movzbl 0x7(%edx),%ecx
   21ec4:	0f b6 42 06          	movzbl 0x6(%edx),%eax
   21ec8:	c1 e1 18             	shl    $0x18,%ecx
   21ecb:	c1 e0 10             	shl    $0x10,%eax
   21ece:	09 c1                	or     %eax,%ecx
   21ed0:	0f b6 42 05          	movzbl 0x5(%edx),%eax
   21ed4:	c1 e0 08             	shl    $0x8,%eax
   21ed7:	09 c1                	or     %eax,%ecx
   21ed9:	0f b6 42 04          	movzbl 0x4(%edx),%eax
   21edd:	09 c1                	or     %eax,%ecx
   21edf:	8b 45 0c             	mov    0xc(%ebp),%eax
   21ee2:	89 4d cc             	mov    %ecx,0xffffffcc(%ebp)
   21ee5:	89 48 04             	mov    %ecx,0x4(%eax)
   21ee8:	0f b6 4a 0b          	movzbl 0xb(%edx),%ecx
   21eec:	0f b6 42 0a          	movzbl 0xa(%edx),%eax
   21ef0:	c1 e1 18             	shl    $0x18,%ecx
   21ef3:	c1 e0 10             	shl    $0x10,%eax
   21ef6:	09 c1                	or     %eax,%ecx
   21ef8:	0f b6 42 09          	movzbl 0x9(%edx),%eax
   21efc:	c1 e0 08             	shl    $0x8,%eax
   21eff:	09 c1                	or     %eax,%ecx
   21f01:	0f b6 42 08          	movzbl 0x8(%edx),%eax
   21f05:	09 c1                	or     %eax,%ecx
   21f07:	8b 45 0c             	mov    0xc(%ebp),%eax
   21f0a:	89 4d c8             	mov    %ecx,0xffffffc8(%ebp)
   21f0d:	89 48 08             	mov    %ecx,0x8(%eax)
   21f10:	0f b6 4a 0f          	movzbl 0xf(%edx),%ecx
   21f14:	0f b6 42 0e          	movzbl 0xe(%edx),%eax
   21f18:	c1 e1 18             	shl    $0x18,%ecx
   21f1b:	c1 e0 10             	shl    $0x10,%eax
   21f1e:	09 c1                	or     %eax,%ecx
   21f20:	0f b6 42 0d          	movzbl 0xd(%edx),%eax
   21f24:	c1 e0 08             	shl    $0x8,%eax
   21f27:	09 c1                	or     %eax,%ecx
   21f29:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
   21f2d:	09 c1                	or     %eax,%ecx
   21f2f:	8b 45 0c             	mov    0xc(%ebp),%eax
   21f32:	89 4d c4             	mov    %ecx,0xffffffc4(%ebp)
   21f35:	89 48 0c             	mov    %ecx,0xc(%eax)
   21f38:	0f b6 4a 13          	movzbl 0x13(%edx),%ecx
   21f3c:	0f b6 42 12          	movzbl 0x12(%edx),%eax
   21f40:	c1 e1 18             	shl    $0x18,%ecx
   21f43:	c1 e0 10             	shl    $0x10,%eax
   21f46:	09 c1                	or     %eax,%ecx
   21f48:	0f b6 42 11          	movzbl 0x11(%edx),%eax
   21f4c:	c1 e0 08             	shl    $0x8,%eax
   21f4f:	09 c1                	or     %eax,%ecx
   21f51:	0f b6 42 10          	movzbl 0x10(%edx),%eax
   21f55:	09 c1                	or     %eax,%ecx
   21f57:	8b 45 0c             	mov    0xc(%ebp),%eax
   21f5a:	89 4d c0             	mov    %ecx,0xffffffc0(%ebp)
   21f5d:	89 48 10             	mov    %ecx,0x10(%eax)
   21f60:	0f b6 4a 17          	movzbl 0x17(%edx),%ecx
   21f64:	0f b6 42 16          	movzbl 0x16(%edx),%eax
   21f68:	c1 e1 18             	shl    $0x18,%ecx
   21f6b:	c1 e0 10             	shl    $0x10,%eax
   21f6e:	09 c1                	or     %eax,%ecx
   21f70:	0f b6 42 15          	movzbl 0x15(%edx),%eax
   21f74:	c1 e0 08             	shl    $0x8,%eax
   21f77:	09 c1                	or     %eax,%ecx
   21f79:	0f b6 42 14          	movzbl 0x14(%edx),%eax
   21f7d:	09 c1                	or     %eax,%ecx
   21f7f:	8b 45 0c             	mov    0xc(%ebp),%eax
   21f82:	89 4d bc             	mov    %ecx,0xffffffbc(%ebp)
   21f85:	89 48 14             	mov    %ecx,0x14(%eax)
   21f88:	0f b6 4a 1b          	movzbl 0x1b(%edx),%ecx
   21f8c:	0f b6 42 1a          	movzbl 0x1a(%edx),%eax
   21f90:	c1 e1 18             	shl    $0x18,%ecx
   21f93:	c1 e0 10             	shl    $0x10,%eax
   21f96:	09 c1                	or     %eax,%ecx
   21f98:	0f b6 42 19          	movzbl 0x19(%edx),%eax
   21f9c:	c1 e0 08             	shl    $0x8,%eax
   21f9f:	09 c1                	or     %eax,%ecx
   21fa1:	0f b6 42 18          	movzbl 0x18(%edx),%eax
   21fa5:	09 c1                	or     %eax,%ecx
   21fa7:	8b 45 0c             	mov    0xc(%ebp),%eax
   21faa:	89 4d b8             	mov    %ecx,0xffffffb8(%ebp)
   21fad:	89 48 18             	mov    %ecx,0x18(%eax)
   21fb0:	0f b6 5a 1f          	movzbl 0x1f(%edx),%ebx
   21fb4:	0f b6 42 1e          	movzbl 0x1e(%edx),%eax
   21fb8:	c1 e3 18             	shl    $0x18,%ebx
   21fbb:	c1 e0 10             	shl    $0x10,%eax
   21fbe:	09 c3                	or     %eax,%ebx
   21fc0:	0f b6 42 1d          	movzbl 0x1d(%edx),%eax
   21fc4:	c1 e0 08             	shl    $0x8,%eax
   21fc7:	09 c3                	or     %eax,%ebx
   21fc9:	0f b6 42 1c          	movzbl 0x1c(%edx),%eax
   21fcd:	8b 55 0c             	mov    0xc(%ebp),%edx
   21fd0:	09 c3                	or     %eax,%ebx
   21fd2:	89 5d f0             	mov    %ebx,0xfffffff0(%ebp)
   21fd5:	89 d8                	mov    %ebx,%eax
   21fd7:	c1 e8 10             	shr    $0x10,%eax
   21fda:	89 5a 1c             	mov    %ebx,0x1c(%edx)
   21fdd:	0f b6 c0             	movzbl %al,%eax
   21fe0:	0f b6 d7             	movzbl %bh,%edx
   21fe3:	8b bc 86 00 04 00 00 	mov    0x400(%esi,%eax,4),%edi
   21fea:	8b 04 96             	mov    (%esi,%edx,4),%eax
   21fed:	31 c7                	xor    %eax,%edi
   21fef:	89 d8                	mov    %ebx,%eax
   21ff1:	c1 e8 18             	shr    $0x18,%eax
   21ff4:	8b 8c 86 00 08 00 00 	mov    0x800(%esi,%eax,4),%ecx
   21ffb:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
   21fff:	31 cf                	xor    %ecx,%edi
   22001:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   22004:	8b 94 86 00 0c 00 00 	mov    0xc00(%esi,%eax,4),%edx
   2200b:	a1 00 00 00 00       	mov    0x0,%eax
   22010:	31 d7                	xor    %edx,%edi
   22012:	31 c7                	xor    %eax,%edi
   22014:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   22017:	31 c7                	xor    %eax,%edi
   22019:	89 79 20             	mov    %edi,0x20(%ecx)
   2201c:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
   2201f:	31 f8                	xor    %edi,%eax
   22021:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
   22024:	89 41 24             	mov    %eax,0x24(%ecx)
   22027:	8b 55 c8             	mov    0xffffffc8(%ebp),%edx
   2202a:	31 c2                	xor    %eax,%edx
   2202c:	89 55 b0             	mov    %edx,0xffffffb0(%ebp)
   2202f:	89 51 28             	mov    %edx,0x28(%ecx)
   22032:	8b 4d c4             	mov    0xffffffc4(%ebp),%ecx
   22035:	8b 45 0c             	mov    0xc(%ebp),%eax
   22038:	31 d1                	xor    %edx,%ecx
   2203a:	89 4d ac             	mov    %ecx,0xffffffac(%ebp)
   2203d:	89 4d e0             	mov    %ecx,0xffffffe0(%ebp)
   22040:	89 48 2c             	mov    %ecx,0x2c(%eax)
   22043:	0f b6 c5             	movzbl %ch,%eax
   22046:	8b 84 86 00 04 00 00 	mov    0x400(%esi,%eax,4),%eax
   2204d:	0f b6 55 e0          	movzbl 0xffffffe0(%ebp),%edx
   22051:	8b 0c 96             	mov    (%esi,%edx,4),%ecx
   22054:	31 c8                	xor    %ecx,%eax
   22056:	89 45 a8             	mov    %eax,0xffffffa8(%ebp)
   22059:	8b 45 ac             	mov    0xffffffac(%ebp),%eax
   2205c:	c1 e8 10             	shr    $0x10,%eax
   2205f:	0f b6 c0             	movzbl %al,%eax
   22062:	8b 94 86 00 08 00 00 	mov    0x800(%esi,%eax,4),%edx
   22069:	8b 45 ac             	mov    0xffffffac(%ebp),%eax
   2206c:	31 55 a8             	xor    %edx,0xffffffa8(%ebp)
   2206f:	c1 e8 18             	shr    $0x18,%eax
   22072:	8b 8c 86 00 0c 00 00 	mov    0xc00(%esi,%eax,4),%ecx
   22079:	31 4d a8             	xor    %ecx,0xffffffa8(%ebp)
   2207c:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
   2207f:	31 45 a8             	xor    %eax,0xffffffa8(%ebp)
   22082:	8b 4d a8             	mov    0xffffffa8(%ebp),%ecx
   22085:	8b 55 0c             	mov    0xc(%ebp),%edx
   22088:	89 4a 30             	mov    %ecx,0x30(%edx)
   2208b:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
   2208e:	31 c8                	xor    %ecx,%eax
   22090:	89 45 a4             	mov    %eax,0xffffffa4(%ebp)
   22093:	89 42 34             	mov    %eax,0x34(%edx)
   22096:	8b 55 b8             	mov    0xffffffb8(%ebp),%edx
   22099:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   2209c:	31 c2                	xor    %eax,%edx
   2209e:	31 d3                	xor    %edx,%ebx
   220a0:	89 d8                	mov    %ebx,%eax
   220a2:	89 55 a0             	mov    %edx,0xffffffa0(%ebp)
   220a5:	c1 e8 10             	shr    $0x10,%eax
   220a8:	0f b6 c0             	movzbl %al,%eax
   220ab:	89 51 38             	mov    %edx,0x38(%ecx)
   220ae:	0f b6 d7             	movzbl %bh,%edx
   220b1:	89 5d f0             	mov    %ebx,0xfffffff0(%ebp)
   220b4:	8b 84 86 00 04 00 00 	mov    0x400(%esi,%eax,4),%eax
   220bb:	89 59 3c             	mov    %ebx,0x3c(%ecx)
   220be:	8b 0c 96             	mov    (%esi,%edx,4),%ecx
   220c1:	31 c8                	xor    %ecx,%eax
   220c3:	89 45 9c             	mov    %eax,0xffffff9c(%ebp)
   220c6:	89 d8                	mov    %ebx,%eax
   220c8:	c1 e8 18             	shr    $0x18,%eax
   220cb:	8b 94 86 00 08 00 00 	mov    0x800(%esi,%eax,4),%edx
   220d2:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
   220d6:	31 55 9c             	xor    %edx,0xffffff9c(%ebp)
   220d9:	8b 55 0c             	mov    0xc(%ebp),%edx
   220dc:	8b 8c 86 00 0c 00 00 	mov    0xc00(%esi,%eax,4),%ecx
   220e3:	31 4d 9c             	xor    %ecx,0xffffff9c(%ebp)
   220e6:	a1 04 00 00 00       	mov    0x4,%eax
   220eb:	31 45 9c             	xor    %eax,0xffffff9c(%ebp)
   220ee:	31 7d 9c             	xor    %edi,0xffffff9c(%ebp)
   220f1:	8b 4d 9c             	mov    0xffffff9c(%ebp),%ecx
   220f4:	89 4a 40             	mov    %ecx,0x40(%edx)
   220f7:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
   220fa:	31 c8                	xor    %ecx,%eax
   220fc:	89 45 98             	mov    %eax,0xffffff98(%ebp)
   220ff:	89 42 44             	mov    %eax,0x44(%edx)
   22102:	8b 55 b0             	mov    0xffffffb0(%ebp),%edx
   22105:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   22108:	31 c2                	xor    %eax,%edx
   2210a:	89 55 94             	mov    %edx,0xffffff94(%ebp)
   2210d:	89 51 48             	mov    %edx,0x48(%ecx)
   22110:	8b 45 ac             	mov    0xffffffac(%ebp),%eax
   22113:	31 d0                	xor    %edx,%eax
   22115:	89 45 90             	mov    %eax,0xffffff90(%ebp)
   22118:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   2211b:	89 41 4c             	mov    %eax,0x4c(%ecx)
   2211e:	8b 4d 90             	mov    0xffffff90(%ebp),%ecx
   22121:	0f b6 55 e0          	movzbl 0xffffffe0(%ebp),%edx
   22125:	0f b6 c5             	movzbl %ch,%eax
   22128:	8b 84 86 00 04 00 00 	mov    0x400(%esi,%eax,4),%eax
   2212f:	8b 0c 96             	mov    (%esi,%edx,4),%ecx
   22132:	31 c8                	xor    %ecx,%eax
   22134:	89 45 8c             	mov    %eax,0xffffff8c(%ebp)
   22137:	8b 45 90             	mov    0xffffff90(%ebp),%eax
   2213a:	c1 e8 10             	shr    $0x10,%eax
   2213d:	0f b6 c0             	movzbl %al,%eax
   22140:	8b 94 86 00 08 00 00 	mov    0x800(%esi,%eax,4),%edx
   22147:	8b 45 90             	mov    0xffffff90(%ebp),%eax
   2214a:	31 55 8c             	xor    %edx,0xffffff8c(%ebp)
   2214d:	8b 55 0c             	mov    0xc(%ebp),%edx
   22150:	c1 e8 18             	shr    $0x18,%eax
   22153:	8b 8c 86 00 0c 00 00 	mov    0xc00(%esi,%eax,4),%ecx
   2215a:	8b 45 a8             	mov    0xffffffa8(%ebp),%eax
   2215d:	31 4d 8c             	xor    %ecx,0xffffff8c(%ebp)
   22160:	31 45 8c             	xor    %eax,0xffffff8c(%ebp)
   22163:	8b 4d 8c             	mov    0xffffff8c(%ebp),%ecx
   22166:	89 4a 50             	mov    %ecx,0x50(%edx)
   22169:	8b 45 a4             	mov    0xffffffa4(%ebp),%eax
   2216c:	31 c8                	xor    %ecx,%eax
   2216e:	89 45 88             	mov    %eax,0xffffff88(%ebp)
   22171:	89 42 54             	mov    %eax,0x54(%edx)
   22174:	8b 55 a0             	mov    0xffffffa0(%ebp),%edx
   22177:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   2217a:	31 c2                	xor    %eax,%edx
   2217c:	31 d3                	xor    %edx,%ebx
    ke8(cx->ks, 2); ke8(cx->ks, 3);
   2217e:	89 d8                	mov    %ebx,%eax
   22180:	89 55 84             	mov    %edx,0xffffff84(%ebp)
   22183:	c1 e8 10             	shr    $0x10,%eax
   22186:	0f b6 c0             	movzbl %al,%eax
   22189:	89 51 58             	mov    %edx,0x58(%ecx)
   2218c:	0f b6 d7             	movzbl %bh,%edx
   2218f:	8b bc 86 00 04 00 00 	mov    0x400(%esi,%eax,4),%edi
   22196:	89 5d f0             	mov    %ebx,0xfffffff0(%ebp)
   22199:	8b 04 96             	mov    (%esi,%edx,4),%eax
   2219c:	89 59 5c             	mov    %ebx,0x5c(%ecx)
   2219f:	31 c7                	xor    %eax,%edi
   221a1:	89 d8                	mov    %ebx,%eax
   221a3:	c1 e8 18             	shr    $0x18,%eax
   221a6:	8b 94 86 00 08 00 00 	mov    0x800(%esi,%eax,4),%edx
   221ad:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
   221b1:	31 d7                	xor    %edx,%edi
   221b3:	8b 94 86 00 0c 00 00 	mov    0xc00(%esi,%eax,4),%edx
   221ba:	a1 08 00 00 00       	mov    0x8,%eax
   221bf:	31 d7                	xor    %edx,%edi
   221c1:	31 c7                	xor    %eax,%edi
   221c3:	8b 45 9c             	mov    0xffffff9c(%ebp),%eax
   221c6:	31 c7                	xor    %eax,%edi
   221c8:	89 79 60             	mov    %edi,0x60(%ecx)
   221cb:	8b 45 98             	mov    0xffffff98(%ebp),%eax
   221ce:	31 f8                	xor    %edi,%eax
   221d0:	89 45 80             	mov    %eax,0xffffff80(%ebp)
   221d3:	89 41 64             	mov    %eax,0x64(%ecx)
   221d6:	8b 55 94             	mov    0xffffff94(%ebp),%edx
   221d9:	31 c2                	xor    %eax,%edx
   221db:	89 95 7c ff ff ff    	mov    %edx,0xffffff7c(%ebp)
   221e1:	89 51 68             	mov    %edx,0x68(%ecx)
   221e4:	8b 4d 90             	mov    0xffffff90(%ebp),%ecx
   221e7:	8b 45 0c             	mov    0xc(%ebp),%eax
   221ea:	31 d1                	xor    %edx,%ecx
   221ec:	89 8d 78 ff ff ff    	mov    %ecx,0xffffff78(%ebp)
   221f2:	89 4d e0             	mov    %ecx,0xffffffe0(%ebp)
   221f5:	89 48 6c             	mov    %ecx,0x6c(%eax)
   221f8:	0f b6 c5             	movzbl %ch,%eax
   221fb:	8b 84 86 00 04 00 00 	mov    0x400(%esi,%eax,4),%eax
   22202:	0f b6 55 e0          	movzbl 0xffffffe0(%ebp),%edx
   22206:	8b 0c 96             	mov    (%esi,%edx,4),%ecx
   22209:	31 c8                	xor    %ecx,%eax
   2220b:	89 85 74 ff ff ff    	mov    %eax,0xffffff74(%ebp)
   22211:	8b 85 78 ff ff ff    	mov    0xffffff78(%ebp),%eax
   22217:	c1 e8 10             	shr    $0x10,%eax
   2221a:	0f b6 c0             	movzbl %al,%eax
   2221d:	8b 94 86 00 08 00 00 	mov    0x800(%esi,%eax,4),%edx
   22224:	8b 85 78 ff ff ff    	mov    0xffffff78(%ebp),%eax
   2222a:	31 95 74 ff ff ff    	xor    %edx,0xffffff74(%ebp)
   22230:	c1 e8 18             	shr    $0x18,%eax
   22233:	8b 8c 86 00 0c 00 00 	mov    0xc00(%esi,%eax,4),%ecx
   2223a:	31 8d 74 ff ff ff    	xor    %ecx,0xffffff74(%ebp)
   22240:	8b 45 8c             	mov    0xffffff8c(%ebp),%eax
   22243:	31 85 74 ff ff ff    	xor    %eax,0xffffff74(%ebp)
   22249:	8b 8d 74 ff ff ff    	mov    0xffffff74(%ebp),%ecx
   2224f:	8b 55 0c             	mov    0xc(%ebp),%edx
   22252:	89 4a 70             	mov    %ecx,0x70(%edx)
   22255:	8b 45 88             	mov    0xffffff88(%ebp),%eax
   22258:	31 c8                	xor    %ecx,%eax
   2225a:	89 85 70 ff ff ff    	mov    %eax,0xffffff70(%ebp)
   22260:	89 42 74             	mov    %eax,0x74(%edx)
   22263:	8b 55 84             	mov    0xffffff84(%ebp),%edx
   22266:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   22269:	31 c2                	xor    %eax,%edx
   2226b:	31 d3                	xor    %edx,%ebx
   2226d:	89 d8                	mov    %ebx,%eax
   2226f:	89 95 6c ff ff ff    	mov    %edx,0xffffff6c(%ebp)
   22275:	c1 e8 10             	shr    $0x10,%eax
   22278:	0f b6 c0             	movzbl %al,%eax
   2227b:	89 51 78             	mov    %edx,0x78(%ecx)
   2227e:	0f b6 d7             	movzbl %bh,%edx
   22281:	89 5d f0             	mov    %ebx,0xfffffff0(%ebp)
   22284:	8b 84 86 00 04 00 00 	mov    0x400(%esi,%eax,4),%eax
   2228b:	89 59 7c             	mov    %ebx,0x7c(%ecx)
   2228e:	8b 0c 96             	mov    (%esi,%edx,4),%ecx
   22291:	31 c8                	xor    %ecx,%eax
   22293:	89 85 68 ff ff ff    	mov    %eax,0xffffff68(%ebp)
   22299:	89 d8                	mov    %ebx,%eax
   2229b:	c1 e8 18             	shr    $0x18,%eax
   2229e:	8b 94 86 00 08 00 00 	mov    0x800(%esi,%eax,4),%edx
   222a5:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
   222a9:	31 95 68 ff ff ff    	xor    %edx,0xffffff68(%ebp)
   222af:	8b 55 0c             	mov    0xc(%ebp),%edx
   222b2:	8b 8c 86 00 0c 00 00 	mov    0xc00(%esi,%eax,4),%ecx
   222b9:	31 8d 68 ff ff ff    	xor    %ecx,0xffffff68(%ebp)
   222bf:	a1 0c 00 00 00       	mov    0xc,%eax
   222c4:	31 85 68 ff ff ff    	xor    %eax,0xffffff68(%ebp)
   222ca:	31 bd 68 ff ff ff    	xor    %edi,0xffffff68(%ebp)
   222d0:	8b 8d 68 ff ff ff    	mov    0xffffff68(%ebp),%ecx
   222d6:	89 8a 80 00 00 00    	mov    %ecx,0x80(%edx)
   222dc:	8b 45 80             	mov    0xffffff80(%ebp),%eax
   222df:	31 c8                	xor    %ecx,%eax
   222e1:	89 85 64 ff ff ff    	mov    %eax,0xffffff64(%ebp)
   222e7:	89 82 84 00 00 00    	mov    %eax,0x84(%edx)
   222ed:	8b 95 7c ff ff ff    	mov    0xffffff7c(%ebp),%edx
   222f3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   222f6:	31 c2                	xor    %eax,%edx
   222f8:	89 95 60 ff ff ff    	mov    %edx,0xffffff60(%ebp)
   222fe:	89 91 88 00 00 00    	mov    %edx,0x88(%ecx)
   22304:	8b 85 78 ff ff ff    	mov    0xffffff78(%ebp),%eax
   2230a:	31 d0                	xor    %edx,%eax
   2230c:	89 85 5c ff ff ff    	mov    %eax,0xffffff5c(%ebp)
   22312:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   22315:	89 81 8c 00 00 00    	mov    %eax,0x8c(%ecx)
   2231b:	8b 8d 5c ff ff ff    	mov    0xffffff5c(%ebp),%ecx
   22321:	0f b6 55 e0          	movzbl 0xffffffe0(%ebp),%edx
   22325:	0f b6 c5             	movzbl %ch,%eax
   22328:	8b 84 86 00 04 00 00 	mov    0x400(%esi,%eax,4),%eax
   2232f:	8b 0c 96             	mov    (%esi,%edx,4),%ecx
   22332:	31 c8                	xor    %ecx,%eax
   22334:	89 85 58 ff ff ff    	mov    %eax,0xffffff58(%ebp)
   2233a:	8b 85 5c ff ff ff    	mov    0xffffff5c(%ebp),%eax
   22340:	c1 e8 10             	shr    $0x10,%eax
   22343:	0f b6 c0             	movzbl %al,%eax
   22346:	8b 94 86 00 08 00 00 	mov    0x800(%esi,%eax,4),%edx
   2234d:	8b 85 5c ff ff ff    	mov    0xffffff5c(%ebp),%eax
   22353:	31 95 58 ff ff ff    	xor    %edx,0xffffff58(%ebp)
   22359:	8b 55 0c             	mov    0xc(%ebp),%edx
   2235c:	c1 e8 18             	shr    $0x18,%eax
   2235f:	8b 8c 86 00 0c 00 00 	mov    0xc00(%esi,%eax,4),%ecx
   22366:	8b 85 74 ff ff ff    	mov    0xffffff74(%ebp),%eax
   2236c:	31 8d 58 ff ff ff    	xor    %ecx,0xffffff58(%ebp)
   22372:	31 85 58 ff ff ff    	xor    %eax,0xffffff58(%ebp)
   22378:	8b 8d 58 ff ff ff    	mov    0xffffff58(%ebp),%ecx
   2237e:	89 8a 90 00 00 00    	mov    %ecx,0x90(%edx)
   22384:	8b 85 70 ff ff ff    	mov    0xffffff70(%ebp),%eax
   2238a:	31 c8                	xor    %ecx,%eax
   2238c:	89 85 54 ff ff ff    	mov    %eax,0xffffff54(%ebp)
   22392:	89 82 94 00 00 00    	mov    %eax,0x94(%edx)
   22398:	8b 95 6c ff ff ff    	mov    0xffffff6c(%ebp),%edx
   2239e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   223a1:	31 c2                	xor    %eax,%edx
   223a3:	31 d3                	xor    %edx,%ebx
    ke8(cx->ks, 4); ke8(cx->ks, 5);
   223a5:	89 d8                	mov    %ebx,%eax
   223a7:	89 95 50 ff ff ff    	mov    %edx,0xffffff50(%ebp)
   223ad:	c1 e8 10             	shr    $0x10,%eax
   223b0:	0f b6 c0             	movzbl %al,%eax
   223b3:	89 91 98 00 00 00    	mov    %edx,0x98(%ecx)
   223b9:	0f b6 d7             	movzbl %bh,%edx
   223bc:	8b bc 86 00 04 00 00 	mov    0x400(%esi,%eax,4),%edi
   223c3:	89 5d f0             	mov    %ebx,0xfffffff0(%ebp)
   223c6:	8b 04 96             	mov    (%esi,%edx,4),%eax
   223c9:	89 99 9c 00 00 00    	mov    %ebx,0x9c(%ecx)
   223cf:	31 c7                	xor    %eax,%edi
   223d1:	89 d8                	mov    %ebx,%eax
   223d3:	c1 e8 18             	shr    $0x18,%eax
   223d6:	8b 94 86 00 08 00 00 	mov    0x800(%esi,%eax,4),%edx
   223dd:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
   223e1:	31 d7                	xor    %edx,%edi
   223e3:	8b 94 86 00 0c 00 00 	mov    0xc00(%esi,%eax,4),%edx
   223ea:	a1 10 00 00 00       	mov    0x10,%eax
   223ef:	31 d7                	xor    %edx,%edi
   223f1:	31 c7                	xor    %eax,%edi
   223f3:	8b 85 68 ff ff ff    	mov    0xffffff68(%ebp),%eax
   223f9:	31 c7                	xor    %eax,%edi
   223fb:	89 b9 a0 00 00 00    	mov    %edi,0xa0(%ecx)
   22401:	8b 85 64 ff ff ff    	mov    0xffffff64(%ebp),%eax
   22407:	31 f8                	xor    %edi,%eax
   22409:	89 85 4c ff ff ff    	mov    %eax,0xffffff4c(%ebp)
   2240f:	89 81 a4 00 00 00    	mov    %eax,0xa4(%ecx)
   22415:	8b 95 60 ff ff ff    	mov    0xffffff60(%ebp),%edx
   2241b:	31 c2                	xor    %eax,%edx
   2241d:	89 95 48 ff ff ff    	mov    %edx,0xffffff48(%ebp)
   22423:	89 91 a8 00 00 00    	mov    %edx,0xa8(%ecx)
   22429:	8b 8d 5c ff ff ff    	mov    0xffffff5c(%ebp),%ecx
   2242f:	8b 45 0c             	mov    0xc(%ebp),%eax
   22432:	31 d1                	xor    %edx,%ecx
   22434:	89 8d 44 ff ff ff    	mov    %ecx,0xffffff44(%ebp)
   2243a:	89 4d e0             	mov    %ecx,0xffffffe0(%ebp)
   2243d:	89 88 ac 00 00 00    	mov    %ecx,0xac(%eax)
   22443:	0f b6 c5             	movzbl %ch,%eax
   22446:	8b 84 86 00 04 00 00 	mov    0x400(%esi,%eax,4),%eax
   2244d:	0f b6 55 e0          	movzbl 0xffffffe0(%ebp),%edx
   22451:	8b 0c 96             	mov    (%esi,%edx,4),%ecx
   22454:	31 c8                	xor    %ecx,%eax
   22456:	89 85 40 ff ff ff    	mov    %eax,0xffffff40(%ebp)
   2245c:	8b 85 44 ff ff ff    	mov    0xffffff44(%ebp),%eax
   22462:	c1 e8 10             	shr    $0x10,%eax
   22465:	0f b6 c0             	movzbl %al,%eax
   22468:	8b 94 86 00 08 00 00 	mov    0x800(%esi,%eax,4),%edx
   2246f:	8b 85 44 ff ff ff    	mov    0xffffff44(%ebp),%eax
   22475:	31 95 40 ff ff ff    	xor    %edx,0xffffff40(%ebp)
   2247b:	c1 e8 18             	shr    $0x18,%eax
   2247e:	8b 8c 86 00 0c 00 00 	mov    0xc00(%esi,%eax,4),%ecx
   22485:	31 8d 40 ff ff ff    	xor    %ecx,0xffffff40(%ebp)
   2248b:	8b 85 58 ff ff ff    	mov    0xffffff58(%ebp),%eax
   22491:	31 85 40 ff ff ff    	xor    %eax,0xffffff40(%ebp)
   22497:	8b 8d 40 ff ff ff    	mov    0xffffff40(%ebp),%ecx
   2249d:	8b 55 0c             	mov    0xc(%ebp),%edx
   224a0:	89 8a b0 00 00 00    	mov    %ecx,0xb0(%edx)
   224a6:	8b 85 54 ff ff ff    	mov    0xffffff54(%ebp),%eax
   224ac:	31 c8                	xor    %ecx,%eax
   224ae:	89 85 3c ff ff ff    	mov    %eax,0xffffff3c(%ebp)
   224b4:	89 82 b4 00 00 00    	mov    %eax,0xb4(%edx)
   224ba:	8b 95 50 ff ff ff    	mov    0xffffff50(%ebp),%edx
   224c0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   224c3:	31 c2                	xor    %eax,%edx
   224c5:	31 d3                	xor    %edx,%ebx
   224c7:	89 d8                	mov    %ebx,%eax
   224c9:	89 95 38 ff ff ff    	mov    %edx,0xffffff38(%ebp)
   224cf:	c1 e8 10             	shr    $0x10,%eax
   224d2:	0f b6 c0             	movzbl %al,%eax
   224d5:	89 91 b8 00 00 00    	mov    %edx,0xb8(%ecx)
   224db:	0f b6 d7             	movzbl %bh,%edx
   224de:	89 5d f0             	mov    %ebx,0xfffffff0(%ebp)
   224e1:	8b 84 86 00 04 00 00 	mov    0x400(%esi,%eax,4),%eax
   224e8:	89 99 bc 00 00 00    	mov    %ebx,0xbc(%ecx)
   224ee:	8b 0c 96             	mov    (%esi,%edx,4),%ecx
   224f1:	31 c8                	xor    %ecx,%eax
   224f3:	89 85 34 ff ff ff    	mov    %eax,0xffffff34(%ebp)
   224f9:	89 d8                	mov    %ebx,%eax
   224fb:	c1 e8 18             	shr    $0x18,%eax
   224fe:	8b 94 86 00 08 00 00 	mov    0x800(%esi,%eax,4),%edx
   22505:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
   22509:	31 95 34 ff ff ff    	xor    %edx,0xffffff34(%ebp)
   2250f:	8b 55 0c             	mov    0xc(%ebp),%edx
   22512:	8b 8c 86 00 0c 00 00 	mov    0xc00(%esi,%eax,4),%ecx
   22519:	31 8d 34 ff ff ff    	xor    %ecx,0xffffff34(%ebp)
   2251f:	a1 14 00 00 00       	mov    0x14,%eax
   22524:	31 85 34 ff ff ff    	xor    %eax,0xffffff34(%ebp)
   2252a:	31 bd 34 ff ff ff    	xor    %edi,0xffffff34(%ebp)
   22530:	8b 8d 34 ff ff ff    	mov    0xffffff34(%ebp),%ecx
   22536:	89 8a c0 00 00 00    	mov    %ecx,0xc0(%edx)
   2253c:	8b 85 4c ff ff ff    	mov    0xffffff4c(%ebp),%eax
   22542:	31 c8                	xor    %ecx,%eax
   22544:	89 85 30 ff ff ff    	mov    %eax,0xffffff30(%ebp)
   2254a:	89 82 c4 00 00 00    	mov    %eax,0xc4(%edx)
   22550:	8b 95 48 ff ff ff    	mov    0xffffff48(%ebp),%edx
   22556:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   22559:	31 c2                	xor    %eax,%edx
   2255b:	89 95 2c ff ff ff    	mov    %edx,0xffffff2c(%ebp)
   22561:	89 91 c8 00 00 00    	mov    %edx,0xc8(%ecx)
   22567:	8b 8d 44 ff ff ff    	mov    0xffffff44(%ebp),%ecx
   2256d:	8b 45 0c             	mov    0xc(%ebp),%eax
   22570:	31 d1                	xor    %edx,%ecx
   22572:	89 4d e0             	mov    %ecx,0xffffffe0(%ebp)
   22575:	89 88 cc 00 00 00    	mov    %ecx,0xcc(%eax)
   2257b:	0f b6 c5             	movzbl %ch,%eax
   2257e:	8b 94 86 00 04 00 00 	mov    0x400(%esi,%eax,4),%edx
   22585:	0f b6 7d e0          	movzbl 0xffffffe0(%ebp),%edi
   22589:	8b 04 be             	mov    (%esi,%edi,4),%eax
   2258c:	31 c2                	xor    %eax,%edx
   2258e:	89 c8                	mov    %ecx,%eax
   22590:	c1 e8 10             	shr    $0x10,%eax
   22593:	0f b6 c0             	movzbl %al,%eax
   22596:	8b bc 86 00 08 00 00 	mov    0x800(%esi,%eax,4),%edi
   2259d:	89 c8                	mov    %ecx,%eax
   2259f:	c1 e8 18             	shr    $0x18,%eax
   225a2:	31 fa                	xor    %edi,%edx
   225a4:	8b bc 86 00 0c 00 00 	mov    0xc00(%esi,%eax,4),%edi
   225ab:	8b 85 40 ff ff ff    	mov    0xffffff40(%ebp),%eax
   225b1:	31 fa                	xor    %edi,%edx
   225b3:	31 c2                	xor    %eax,%edx
   225b5:	8b 45 0c             	mov    0xc(%ebp),%eax
   225b8:	89 90 d0 00 00 00    	mov    %edx,0xd0(%eax)
   225be:	8b 85 3c ff ff ff    	mov    0xffffff3c(%ebp),%eax
   225c4:	31 d0                	xor    %edx,%eax
   225c6:	8b 55 0c             	mov    0xc(%ebp),%edx
   225c9:	89 82 d4 00 00 00    	mov    %eax,0xd4(%edx)
   225cf:	8b bd 38 ff ff ff    	mov    0xffffff38(%ebp),%edi
   225d5:	31 f8                	xor    %edi,%eax
   225d7:	89 82 d8 00 00 00    	mov    %eax,0xd8(%edx)
   225dd:	31 c3                	xor    %eax,%ebx
   225df:	89 5d f0             	mov    %ebx,0xfffffff0(%ebp)
   225e2:	89 9a dc 00 00 00    	mov    %ebx,0xdc(%edx)
#endif
    kel8(cx->ks, 6);
   225e8:	0f b6 d7             	movzbl %bh,%edx
   225eb:	c1 eb 10             	shr    $0x10,%ebx
   225ee:	0f b6 c3             	movzbl %bl,%eax
   225f1:	8b 3c 96             	mov    (%esi,%edx,4),%edi
   225f4:	8b 84 86 00 04 00 00 	mov    0x400(%esi,%eax,4),%eax
   225fb:	0f b6 55 f0          	movzbl 0xfffffff0(%ebp),%edx
   225ff:	31 f8                	xor    %edi,%eax
   22601:	c1 eb 08             	shr    $0x8,%ebx
   22604:	8b bc 9e 00 08 00 00 	mov    0x800(%esi,%ebx,4),%edi
   2260b:	8b 9c 96 00 0c 00 00 	mov    0xc00(%esi,%edx,4),%ebx
   22612:	8b b5 34 ff ff ff    	mov    0xffffff34(%ebp),%esi
   22618:	31 f8                	xor    %edi,%eax
   2261a:	8b 3d 18 00 00 00    	mov    0x18,%edi
   22620:	31 d8                	xor    %ebx,%eax
   22622:	8b 55 0c             	mov    0xc(%ebp),%edx
   22625:	31 f8                	xor    %edi,%eax
   22627:	31 f0                	xor    %esi,%eax
    cx->rn = 14;
   22629:	be 0e 00 00 00       	mov    $0xe,%esi
   2262e:	89 82 e0 00 00 00    	mov    %eax,0xe0(%edx)
   22634:	8b 9d 30 ff ff ff    	mov    0xffffff30(%ebp),%ebx
   2263a:	31 d8                	xor    %ebx,%eax
   2263c:	89 82 e4 00 00 00    	mov    %eax,0xe4(%edx)
   22642:	8b bd 2c ff ff ff    	mov    0xffffff2c(%ebp),%edi
   22648:	89 b2 f0 00 00 00    	mov    %esi,0xf0(%edx)
   2264e:	31 f8                	xor    %edi,%eax
   22650:	31 c1                	xor    %eax,%ecx
   22652:	89 82 e8 00 00 00    	mov    %eax,0xe8(%edx)
#if defined( AES_ERR_CHK )
    return aes_good;
#endif
}
   22658:	31 c0                	xor    %eax,%eax
   2265a:	89 8a ec 00 00 00    	mov    %ecx,0xec(%edx)
   22660:	81 c4 c8 00 00 00    	add    $0xc8,%esp
   22666:	5b                   	pop    %ebx
   22667:	5e                   	pop    %esi
   22668:	5f                   	pop    %edi
   22669:	5d                   	pop    %ebp
   2266a:	c3                   	ret    
   2266b:	90                   	nop    
   2266c:	8d 74 26 00          	lea    0x0(%esi,1),%esi

00022670 <aes_encrypt_key>:

#endif

#if defined(AES_VAR)

aes_rval aes_encrypt_key(const unsigned char *key, int key_len, aes_encrypt_ctx cx[1])
{
   22670:	55                   	push   %ebp
   22671:	89 e5                	mov    %esp,%ebp
   22673:	8b 45 0c             	mov    0xc(%ebp),%eax
   22676:	8b 4d 08             	mov    0x8(%ebp),%ecx
   22679:	8b 55 10             	mov    0x10(%ebp),%edx
    switch(key_len)
   2267c:	83 f8 20             	cmp    $0x20,%eax
   2267f:	74 4b                	je     226cc <aes_encrypt_key+0x5c>
   22681:	83 f8 20             	cmp    $0x20,%eax
   22684:	7f 2a                	jg     226b0 <aes_encrypt_key+0x40>
   22686:	83 f8 10             	cmp    $0x10,%eax
   22689:	74 18                	je     226a3 <aes_encrypt_key+0x33>
   2268b:	83 f8 18             	cmp    $0x18,%eax
   2268e:	74 07                	je     22697 <aes_encrypt_key+0x27>
    {
#if defined( AES_ERR_CHK )
    case 16: case 128: return aes_encrypt_key128(key, cx);
    case 24: case 192: return aes_encrypt_key192(key, cx);
    case 32: case 256: return aes_encrypt_key256(key, cx);
    default: return aes_error;
#else
    case 16: case 128: aes_encrypt_key128(key, cx); return;
    case 24: case 192: aes_encrypt_key192(key, cx); return;
    case 32: case 256: aes_encrypt_key256(key, cx); return;
#endif
    }
}
   22690:	5d                   	pop    %ebp
   22691:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   22696:	c3                   	ret    
   22697:	89 55 0c             	mov    %edx,0xc(%ebp)
   2269a:	89 4d 08             	mov    %ecx,0x8(%ebp)
   2269d:	5d                   	pop    %ebp
   2269e:	e9 fc ff ff ff       	jmp    2269f <aes_encrypt_key+0x2f>
   226a3:	89 55 0c             	mov    %edx,0xc(%ebp)
   226a6:	89 4d 08             	mov    %ecx,0x8(%ebp)
   226a9:	5d                   	pop    %ebp
   226aa:	e9 fc ff ff ff       	jmp    226ab <aes_encrypt_key+0x3b>
   226af:	90                   	nop    
   226b0:	3d c0 00 00 00       	cmp    $0xc0,%eax
   226b5:	74 e0                	je     22697 <aes_encrypt_key+0x27>
   226b7:	3d c0 00 00 00       	cmp    $0xc0,%eax
   226bc:	7f 07                	jg     226c5 <aes_encrypt_key+0x55>
   226be:	83 c0 80             	add    $0xffffff80,%eax
   226c1:	74 e0                	je     226a3 <aes_encrypt_key+0x33>
   226c3:	eb cb                	jmp    22690 <aes_encrypt_key+0x20>
   226c5:	3d 00 01 00 00       	cmp    $0x100,%eax
   226ca:	75 c4                	jne    22690 <aes_encrypt_key+0x20>
   226cc:	89 55 0c             	mov    %edx,0xc(%ebp)
   226cf:	89 4d 08             	mov    %ecx,0x8(%ebp)
   226d2:	5d                   	pop    %ebp
   226d3:	e9 fc ff ff ff       	jmp    226d4 <aes_encrypt_key+0x64>
   226d8:	90                   	nop    
   226d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi

000226e0 <aes_decrypt_key128>:

#endif

#endif

#if defined(DECRYPTION_KEY_SCHEDULE)

#if DEC_ROUND == NO_TABLES
#define ff(x)   (x)
#else
#define ff(x)   inv_mcol(x)
#if defined( dec_imvars )
#define d_vars  dec_imvars
#endif
#endif

#if 1
#define kdf4(k,i) \
{   ss[0] = ss[0] ^ ss[2] ^ ss[1] ^ ss[3]; ss[1] = ss[1] ^ ss[3]; ss[2] = ss[2] ^ ss[3]; ss[3] = ss[3]; \
    ss[4] = ls_box(ss[(i+3) % 4], 3) ^ t_use(r,c)[i]; ss[i % 4] ^= ss[4]; \
    ss[4] ^= k[4*(i)];   k[4*(i)+4] = ff(ss[4]); ss[4] ^= k[4*(i)+1]; k[4*(i)+5] = ff(ss[4]); \
    ss[4] ^= k[4*(i)+2]; k[4*(i)+6] = ff(ss[4]); ss[4] ^= k[4*(i)+3]; k[4*(i)+7] = ff(ss[4]); \
}
#define kd4(k,i) \
{   ss[4] = ls_box(ss[(i+3) % 4], 3) ^ t_use(r,c)[i]; ss[i % 4] ^= ss[4]; ss[4] = ff(ss[4]); \
    k[4*(i)+4] = ss[4] ^= k[4*(i)]; k[4*(i)+5] = ss[4] ^= k[4*(i)+1]; \
    k[4*(i)+6] = ss[4] ^= k[4*(i)+2]; k[4*(i)+7] = ss[4] ^= k[4*(i)+3]; \
}
#define kdl4(k,i) \
{   ss[4] = ls_box(ss[(i+3) % 4], 3) ^ t_use(r,c)[i]; ss[i % 4] ^= ss[4]; \
    k[4*(i)+4] = (ss[0] ^= ss[1]) ^ ss[2] ^ ss[3]; k[4*(i)+5] = ss[1] ^ ss[3]; \
    k[4*(i)+6] = ss[0]; k[4*(i)+7] = ss[1]; \
}
#else
#define kdf4(k,i) \
{   ss[0] ^= ls_box(ss[3],3) ^ t_use(r,c)[i]; k[4*(i)+ 4] = ff(ss[0]); ss[1] ^= ss[0]; k[4*(i)+ 5] = ff(ss[1]); \
    ss[2] ^= ss[1]; k[4*(i)+ 6] = ff(ss[2]); ss[3] ^= ss[2]; k[4*(i)+ 7] = ff(ss[3]); \
}
#define kd4(k,i) \
{   ss[4] = ls_box(ss[3],3) ^ t_use(r,c)[i]; \
    ss[0] ^= ss[4]; ss[4] = ff(ss[4]); k[4*(i)+ 4] = ss[4] ^= k[4*(i)]; \
    ss[1] ^= ss[0]; k[4*(i)+ 5] = ss[4] ^= k[4*(i)+ 1]; \
    ss[2] ^= ss[1]; k[4*(i)+ 6] = ss[4] ^= k[4*(i)+ 2]; \
    ss[3] ^= ss[2]; k[4*(i)+ 7] = ss[4] ^= k[4*(i)+ 3]; \
}
#define kdl4(k,i) \
{   ss[0] ^= ls_box(ss[3],3) ^ t_use(r,c)[i]; k[4*(i)+ 4] = ss[0]; ss[1] ^= ss[0]; k[4*(i)+ 5] = ss[1]; \
    ss[2] ^= ss[1]; k[4*(i)+ 6] = ss[2]; ss[3] ^= ss[2]; k[4*(i)+ 7] = ss[3]; \
}
#endif

#define kdf6(k,i) \
{   ss[0] ^= ls_box(ss[5],3) ^ t_use(r,c)[i]; k[6*(i)+ 6] = ff(ss[0]); ss[1] ^= ss[0]; k[6*(i)+ 7] = ff(ss[1]); \
    ss[2] ^= ss[1]; k[6*(i)+ 8] = ff(ss[2]); ss[3] ^= ss[2]; k[6*(i)+ 9] = ff(ss[3]); \
    ss[4] ^= ss[3]; k[6*(i)+10] = ff(ss[4]); ss[5] ^= ss[4]; k[6*(i)+11] = ff(ss[5]); \
}
#define kd6(k,i) \
{   ss[6] = ls_box(ss[5],3) ^ t_use(r,c)[i]; \
    ss[0] ^= ss[6]; ss[6] = ff(ss[6]); k[6*(i)+ 6] = ss[6] ^= k[6*(i)]; \
    ss[1] ^= ss[0]; k[6*(i)+ 7] = ss[6] ^= k[6*(i)+ 1]; \
    ss[2] ^= ss[1]; k[6*(i)+ 8] = ss[6] ^= k[6*(i)+ 2]; \
    ss[3] ^= ss[2]; k[6*(i)+ 9] = ss[6] ^= k[6*(i)+ 3]; \
    ss[4] ^= ss[3]; k[6*(i)+10] = ss[6] ^= k[6*(i)+ 4]; \
    ss[5] ^= ss[4]; k[6*(i)+11] = ss[6] ^= k[6*(i)+ 5]; \
}
#define kdl6(k,i) \
{   ss[0] ^= ls_box(ss[5],3) ^ t_use(r,c)[i]; k[6*(i)+ 6] = ss[0]; ss[1] ^= ss[0]; k[6*(i)+ 7] = ss[1]; \
    ss[2] ^= ss[1]; k[6*(i)+ 8] = ss[2]; ss[3] ^= ss[2]; k[6*(i)+ 9] = ss[3]; \
}

#define kdf8(k,i) \
{   ss[0] ^= ls_box(ss[7],3) ^ t_use(r,c)[i]; k[8*(i)+ 8] = ff(ss[0]); ss[1] ^= ss[0]; k[8*(i)+ 9] = ff(ss[1]); \
    ss[2] ^= ss[1]; k[8*(i)+10] = ff(ss[2]); ss[3] ^= ss[2]; k[8*(i)+11] = ff(ss[3]); \
    ss[4] ^= ls_box(ss[3],0); k[8*(i)+12] = ff(ss[4]); ss[5] ^= ss[4]; k[8*(i)+13] = ff(ss[5]); \
    ss[6] ^= ss[5]; k[8*(i)+14] = ff(ss[6]); ss[7] ^= ss[6]; k[8*(i)+15] = ff(ss[7]); \
}
#define kd8(k,i) \
{   aes_32t g = ls_box(ss[7],3) ^ t_use(r,c)[i]; \
    ss[0] ^= g; g = ff(g); k[8*(i)+ 8] = g ^= k[8*(i)]; \
    ss[1] ^= ss[0]; k[8*(i)+ 9] = g ^= k[8*(i)+ 1]; \
    ss[2] ^= ss[1]; k[8*(i)+10] = g ^= k[8*(i)+ 2]; \
    ss[3] ^= ss[2]; k[8*(i)+11] = g ^= k[8*(i)+ 3]; \
    g = ls_box(ss[3],0); \
    ss[4] ^= g; g = ff(g); k[8*(i)+12] = g ^= k[8*(i)+ 4]; \
    ss[5] ^= ss[4]; k[8*(i)+13] = g ^= k[8*(i)+ 5]; \
    ss[6] ^= ss[5]; k[8*(i)+14] = g ^= k[8*(i)+ 6]; \
    ss[7] ^= ss[6]; k[8*(i)+15] = g ^= k[8*(i)+ 7]; \
}
#define kdl8(k,i) \
{   ss[0] ^= ls_box(ss[7],3) ^ t_use(r,c)[i]; k[8*(i)+ 8] = ss[0]; ss[1] ^= ss[0]; k[8*(i)+ 9] = ss[1]; \
    ss[2] ^= ss[1]; k[8*(i)+10] = ss[2]; ss[3] ^= ss[2]; k[8*(i)+11] = ss[3]; \
}

#if defined(AES_128) || defined(AES_VAR)

aes_rval aes_decrypt_key128(const unsigned char *key, aes_decrypt_ctx cx[1])
{   aes_32t    ss[5];
   226e0:	55                   	push   %ebp
   226e1:	89 e5                	mov    %esp,%ebp
   226e3:	57                   	push   %edi
   226e4:	56                   	push   %esi
   226e5:	53                   	push   %ebx
   226e6:	81 ec c8 00 00 00    	sub    $0xc8,%esp
   226ec:	8b 55 08             	mov    0x8(%ebp),%edx
#if defined( d_vars )
        d_vars;
#endif
    cx->ks[0] = ss[0] = word_in(key, 0);
   226ef:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   226f2:	0f b6 42 03          	movzbl 0x3(%edx),%eax
   226f6:	c1 e0 18             	shl    $0x18,%eax
   226f9:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
   226fc:	0f b6 42 02          	movzbl 0x2(%edx),%eax
   22700:	c1 e0 10             	shl    $0x10,%eax
   22703:	09 45 d0             	or     %eax,0xffffffd0(%ebp)
   22706:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   2270a:	c1 e0 08             	shl    $0x8,%eax
   2270d:	09 45 d0             	or     %eax,0xffffffd0(%ebp)
   22710:	0f b6 02             	movzbl (%edx),%eax
   22713:	09 45 d0             	or     %eax,0xffffffd0(%ebp)
   22716:	8b 5d d0             	mov    0xffffffd0(%ebp),%ebx
   22719:	89 19                	mov    %ebx,(%ecx)
    cx->ks[1] = ss[1] = word_in(key, 1);
   2271b:	0f b6 42 07          	movzbl 0x7(%edx),%eax
   2271f:	c1 e0 18             	shl    $0x18,%eax
   22722:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
   22725:	0f b6 42 06          	movzbl 0x6(%edx),%eax
   22729:	c1 e0 10             	shl    $0x10,%eax
   2272c:	09 45 cc             	or     %eax,0xffffffcc(%ebp)
   2272f:	0f b6 42 05          	movzbl 0x5(%edx),%eax
   22733:	c1 e0 08             	shl    $0x8,%eax
   22736:	09 45 cc             	or     %eax,0xffffffcc(%ebp)
   22739:	0f b6 42 04          	movzbl 0x4(%edx),%eax
   2273d:	09 45 cc             	or     %eax,0xffffffcc(%ebp)
   22740:	8b 5d cc             	mov    0xffffffcc(%ebp),%ebx
   22743:	89 59 04             	mov    %ebx,0x4(%ecx)
    cx->ks[2] = ss[2] = word_in(key, 2);
   22746:	0f b6 42 0b          	movzbl 0xb(%edx),%eax
   2274a:	c1 e0 18             	shl    $0x18,%eax
   2274d:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
   22750:	0f b6 42 0a          	movzbl 0xa(%edx),%eax
   22754:	c1 e0 10             	shl    $0x10,%eax
   22757:	09 45 c8             	or     %eax,0xffffffc8(%ebp)
   2275a:	0f b6 42 09          	movzbl 0x9(%edx),%eax
   2275e:	c1 e0 08             	shl    $0x8,%eax
   22761:	09 45 c8             	or     %eax,0xffffffc8(%ebp)
   22764:	0f b6 42 08          	movzbl 0x8(%edx),%eax
   22768:	09 45 c8             	or     %eax,0xffffffc8(%ebp)
   2276b:	8b 5d c8             	mov    0xffffffc8(%ebp),%ebx
   2276e:	89 59 08             	mov    %ebx,0x8(%ecx)
    cx->ks[3] = ss[3] = word_in(key, 3);
   22771:	0f b6 42 0f          	movzbl 0xf(%edx),%eax
   22775:	c1 e0 18             	shl    $0x18,%eax
   22778:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
   2277b:	0f b6 42 0e          	movzbl 0xe(%edx),%eax
   2277f:	c1 e0 10             	shl    $0x10,%eax
   22782:	09 45 c4             	or     %eax,0xffffffc4(%ebp)
   22785:	0f b6 42 0d          	movzbl 0xd(%edx),%eax
   22789:	c1 e0 08             	shl    $0x8,%eax
   2278c:	09 45 c4             	or     %eax,0xffffffc4(%ebp)
   2278f:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
   22793:	09 45 c4             	or     %eax,0xffffffc4(%ebp)
   22796:	8b 55 c4             	mov    0xffffffc4(%ebp),%edx
   22799:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
   2279c:	89 51 0c             	mov    %edx,0xc(%ecx)

#if DEC_UNROLL == NONE
    {   aes_32t i;

        for(i = 0; i < (11 * N_COLS - 5) / 4; ++i)
            ke4(cx->ks, i);
        kel4(cx->ks, 9);
#if !(DEC_ROUND == NO_TABLES)
        for(i = N_COLS; i < 10 * N_COLS; ++i)
            cx->ks[i] = inv_mcol(cx->ks[i]);
#endif
    }
#else
    kdf4(cx->ks, 0);  kd4(cx->ks, 1);
   2279f:	8b 4d d0             	mov    0xffffffd0(%ebp),%ecx
   227a2:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   227a5:	31 d9                	xor    %ebx,%ecx
   227a7:	8b 5d cc             	mov    0xffffffcc(%ebp),%ebx
   227aa:	31 d0                	xor    %edx,%eax
   227ac:	89 45 98             	mov    %eax,0xffffff98(%ebp)
   227af:	89 d0                	mov    %edx,%eax
   227b1:	31 d9                	xor    %ebx,%ecx
   227b3:	c1 e8 10             	shr    $0x10,%eax
   227b6:	31 d1                	xor    %edx,%ecx
   227b8:	0f b6 c0             	movzbl %al,%eax
   227bb:	89 4d c0             	mov    %ecx,0xffffffc0(%ebp)
   227be:	31 d3                	xor    %edx,%ebx
   227c0:	0f b6 ce             	movzbl %dh,%ecx
   227c3:	89 5d ac             	mov    %ebx,0xffffffac(%ebp)
   227c6:	8b 14 85 00 04 00 00 	mov    0x400(,%eax,4),%edx
   227cd:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
   227d0:	8b 34 8d 00 00 00 00 	mov    0x0(,%ecx,4),%esi
   227d7:	c1 e8 18             	shr    $0x18,%eax
   227da:	8b 1c 85 00 08 00 00 	mov    0x800(,%eax,4),%ebx
   227e1:	0f b6 45 e0          	movzbl 0xffffffe0(%ebp),%eax
   227e5:	31 f2                	xor    %esi,%edx
   227e7:	31 da                	xor    %ebx,%edx
   227e9:	8b 0c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ecx
   227f0:	a1 00 00 00 00       	mov    0x0,%eax
   227f5:	31 ca                	xor    %ecx,%edx
   227f7:	31 c2                	xor    %eax,%edx
   227f9:	31 55 c0             	xor    %edx,0xffffffc0(%ebp)
   227fc:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   227ff:	8b 4d c0             	mov    0xffffffc0(%ebp),%ecx
   22802:	31 c2                	xor    %eax,%edx
   22804:	0f b6 c6             	movzbl %dh,%eax
   22807:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   2280e:	89 55 e4             	mov    %edx,0xffffffe4(%ebp)
   22811:	89 4d d4             	mov    %ecx,0xffffffd4(%ebp)
   22814:	0f b6 4d e4          	movzbl 0xffffffe4(%ebp),%ecx
   22818:	8b 1c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%ebx
   2281f:	31 d8                	xor    %ebx,%eax
   22821:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
   22824:	89 d0                	mov    %edx,%eax
   22826:	c1 e8 10             	shr    $0x10,%eax
   22829:	0f b6 c0             	movzbl %al,%eax
   2282c:	8b 0c 85 00 08 00 00 	mov    0x800(,%eax,4),%ecx
   22833:	89 d0                	mov    %edx,%eax
   22835:	31 4d bc             	xor    %ecx,0xffffffbc(%ebp)
   22838:	c1 e8 18             	shr    $0x18,%eax
   2283b:	8b 1c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ebx
   22842:	31 5d bc             	xor    %ebx,0xffffffbc(%ebp)
   22845:	8b 45 0c             	mov    0xc(%ebp),%eax
   22848:	8b 4d bc             	mov    0xffffffbc(%ebp),%ecx
   2284b:	89 48 10             	mov    %ecx,0x10(%eax)
   2284e:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
   22851:	31 c2                	xor    %eax,%edx
   22853:	89 55 e4             	mov    %edx,0xffffffe4(%ebp)
   22856:	0f b6 c6             	movzbl %dh,%eax
   22859:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   22860:	0f b6 4d e4          	movzbl 0xffffffe4(%ebp),%ecx
   22864:	8b 1c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%ebx
   2286b:	31 d8                	xor    %ebx,%eax
   2286d:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
   22870:	89 d0                	mov    %edx,%eax
   22872:	c1 e8 10             	shr    $0x10,%eax
   22875:	0f b6 c0             	movzbl %al,%eax
   22878:	8b 0c 85 00 08 00 00 	mov    0x800(,%eax,4),%ecx
   2287f:	89 d0                	mov    %edx,%eax
   22881:	31 4d b8             	xor    %ecx,0xffffffb8(%ebp)
   22884:	c1 e8 18             	shr    $0x18,%eax
   22887:	8b 1c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ebx
   2288e:	31 5d b8             	xor    %ebx,0xffffffb8(%ebp)
   22891:	8b 45 0c             	mov    0xc(%ebp),%eax
   22894:	8b 4d b8             	mov    0xffffffb8(%ebp),%ecx
   22897:	89 48 14             	mov    %ecx,0x14(%eax)
   2289a:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   2289d:	31 c2                	xor    %eax,%edx
   2289f:	89 55 e4             	mov    %edx,0xffffffe4(%ebp)
   228a2:	0f b6 c6             	movzbl %dh,%eax
   228a5:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   228ac:	0f b6 4d e4          	movzbl 0xffffffe4(%ebp),%ecx
   228b0:	8b 1c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%ebx
   228b7:	31 d8                	xor    %ebx,%eax
   228b9:	89 45 b4             	mov    %eax,0xffffffb4(%ebp)
   228bc:	89 d0                	mov    %edx,%eax
   228be:	c1 e8 10             	shr    $0x10,%eax
   228c1:	0f b6 c0             	movzbl %al,%eax
   228c4:	8b 0c 85 00 08 00 00 	mov    0x800(,%eax,4),%ecx
   228cb:	89 d0                	mov    %edx,%eax
   228cd:	31 4d b4             	xor    %ecx,0xffffffb4(%ebp)
   228d0:	c1 e8 18             	shr    $0x18,%eax
   228d3:	8b 1c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ebx
   228da:	31 5d b4             	xor    %ebx,0xffffffb4(%ebp)
   228dd:	8b 45 0c             	mov    0xc(%ebp),%eax
   228e0:	8b 4d b4             	mov    0xffffffb4(%ebp),%ecx
   228e3:	89 48 18             	mov    %ecx,0x18(%eax)
   228e6:	8b 7d c4             	mov    0xffffffc4(%ebp),%edi
   228e9:	31 fa                	xor    %edi,%edx
   228eb:	89 55 e4             	mov    %edx,0xffffffe4(%ebp)
   228ee:	0f b6 c6             	movzbl %dh,%eax
   228f1:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   228f8:	0f b6 4d e4          	movzbl 0xffffffe4(%ebp),%ecx
   228fc:	c1 ea 10             	shr    $0x10,%edx
   228ff:	8b 1c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%ebx
   22906:	31 d8                	xor    %ebx,%eax
   22908:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
   2290b:	0f b6 c2             	movzbl %dl,%eax
   2290e:	c1 ea 08             	shr    $0x8,%edx
   22911:	8b 0c 85 00 08 00 00 	mov    0x800(,%eax,4),%ecx
   22918:	8b 1c 95 00 0c 00 00 	mov    0xc00(,%edx,4),%ebx
   2291f:	8b 45 0c             	mov    0xc(%ebp),%eax
   22922:	31 4d b0             	xor    %ecx,0xffffffb0(%ebp)
   22925:	31 5d b0             	xor    %ebx,0xffffffb0(%ebp)
   22928:	8b 55 b0             	mov    0xffffffb0(%ebp),%edx
   2292b:	89 50 1c             	mov    %edx,0x1c(%eax)
   2292e:	8b 4d c0             	mov    0xffffffc0(%ebp),%ecx
   22931:	0f b6 d5             	movzbl %ch,%edx
   22934:	8b 34 95 00 00 00 00 	mov    0x0(,%edx,4),%esi
   2293b:	89 ca                	mov    %ecx,%edx
   2293d:	c1 ea 18             	shr    $0x18,%edx
   22940:	89 c8                	mov    %ecx,%eax
   22942:	8b 1c 95 00 08 00 00 	mov    0x800(,%edx,4),%ebx
   22949:	c1 e8 10             	shr    $0x10,%eax
   2294c:	0f b6 55 d4          	movzbl 0xffffffd4(%ebp),%edx
   22950:	0f b6 c0             	movzbl %al,%eax
   22953:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   2295a:	8b 0c 95 00 0c 00 00 	mov    0xc00(,%edx,4),%ecx
   22961:	31 f0                	xor    %esi,%eax
   22963:	8b 15 04 00 00 00    	mov    0x4,%edx
   22969:	31 d8                	xor    %ebx,%eax
   2296b:	31 c8                	xor    %ecx,%eax
   2296d:	31 d0                	xor    %edx,%eax
   2296f:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   22972:	0f b6 d4             	movzbl %ah,%edx
   22975:	8b 14 95 00 04 00 00 	mov    0x400(,%edx,4),%edx
   2297c:	31 45 ac             	xor    %eax,0xffffffac(%ebp)
   2297f:	c1 e8 10             	shr    $0x10,%eax
   22982:	0f b6 4d e4          	movzbl 0xffffffe4(%ebp),%ecx
   22986:	8b 5d ac             	mov    0xffffffac(%ebp),%ebx
   22989:	89 5d d8             	mov    %ebx,0xffffffd8(%ebp)
   2298c:	8b 1c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%ebx
   22993:	31 da                	xor    %ebx,%edx
   22995:	89 55 a8             	mov    %edx,0xffffffa8(%ebp)
   22998:	0f b6 d0             	movzbl %al,%edx
   2299b:	c1 e8 08             	shr    $0x8,%eax
   2299e:	8b 0c 95 00 08 00 00 	mov    0x800(,%edx,4),%ecx
   229a5:	8b 1c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ebx
   229ac:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
   229af:	31 4d a8             	xor    %ecx,0xffffffa8(%ebp)
   229b2:	8b 55 0c             	mov    0xc(%ebp),%edx
   229b5:	31 5d a8             	xor    %ebx,0xffffffa8(%ebp)
   229b8:	31 45 a8             	xor    %eax,0xffffffa8(%ebp)
   229bb:	8b 4d a8             	mov    0xffffffa8(%ebp),%ecx
   229be:	89 4a 20             	mov    %ecx,0x20(%edx)
   229c1:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
   229c4:	31 c1                	xor    %eax,%ecx
   229c6:	89 4d a4             	mov    %ecx,0xffffffa4(%ebp)
   229c9:	89 4a 24             	mov    %ecx,0x24(%edx)
   229cc:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
   229cf:	31 c1                	xor    %eax,%ecx
   229d1:	89 4d a0             	mov    %ecx,0xffffffa0(%ebp)
   229d4:	89 4a 28             	mov    %ecx,0x28(%edx)
   229d7:	8b 7d b0             	mov    0xffffffb0(%ebp),%edi
   229da:	31 f9                	xor    %edi,%ecx
   229dc:	89 4d 9c             	mov    %ecx,0xffffff9c(%ebp)
   229df:	89 4a 2c             	mov    %ecx,0x2c(%edx)
     kd4(cx->ks, 2);  kd4(cx->ks, 3);
   229e2:	8b 5d ac             	mov    0xffffffac(%ebp),%ebx
   229e5:	0f b6 d7             	movzbl %bh,%edx
   229e8:	8b 34 95 00 00 00 00 	mov    0x0(,%edx,4),%esi
   229ef:	89 da                	mov    %ebx,%edx
   229f1:	c1 ea 18             	shr    $0x18,%edx
   229f4:	89 d8                	mov    %ebx,%eax
   229f6:	8b 0c 95 00 08 00 00 	mov    0x800(,%edx,4),%ecx
   229fd:	c1 e8 10             	shr    $0x10,%eax
   22a00:	0f b6 55 d8          	movzbl 0xffffffd8(%ebp),%edx
   22a04:	0f b6 c0             	movzbl %al,%eax
   22a07:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   22a0e:	8b 3c 95 00 0c 00 00 	mov    0xc00(,%edx,4),%edi
   22a15:	31 f0                	xor    %esi,%eax
   22a17:	8b 35 08 00 00 00    	mov    0x8,%esi
   22a1d:	31 c8                	xor    %ecx,%eax
   22a1f:	31 f8                	xor    %edi,%eax
   22a21:	31 f0                	xor    %esi,%eax
   22a23:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   22a26:	0f b6 4d e4          	movzbl 0xffffffe4(%ebp),%ecx
   22a2a:	31 45 98             	xor    %eax,0xffffff98(%ebp)
   22a2d:	8b 55 98             	mov    0xffffff98(%ebp),%edx
   22a30:	8b 1c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%ebx
   22a37:	89 55 dc             	mov    %edx,0xffffffdc(%ebp)
   22a3a:	0f b6 d4             	movzbl %ah,%edx
   22a3d:	c1 e8 10             	shr    $0x10,%eax
   22a40:	8b 3c 95 00 04 00 00 	mov    0x400(,%edx,4),%edi
   22a47:	0f b6 d0             	movzbl %al,%edx
   22a4a:	c1 e8 08             	shr    $0x8,%eax
   22a4d:	8b 0c 95 00 08 00 00 	mov    0x800(,%edx,4),%ecx
   22a54:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   22a5b:	31 df                	xor    %ebx,%edi
   22a5d:	8b 45 a8             	mov    0xffffffa8(%ebp),%eax
   22a60:	31 cf                	xor    %ecx,%edi
   22a62:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   22a65:	31 d7                	xor    %edx,%edi
   22a67:	31 c7                	xor    %eax,%edi
   22a69:	89 79 30             	mov    %edi,0x30(%ecx)
   22a6c:	8b 5d a4             	mov    0xffffffa4(%ebp),%ebx
   22a6f:	31 fb                	xor    %edi,%ebx
   22a71:	89 5d 94             	mov    %ebx,0xffffff94(%ebp)
   22a74:	89 59 34             	mov    %ebx,0x34(%ecx)
   22a77:	8b 45 a0             	mov    0xffffffa0(%ebp),%eax
   22a7a:	31 c3                	xor    %eax,%ebx
   22a7c:	89 5d 90             	mov    %ebx,0xffffff90(%ebp)
   22a7f:	89 59 38             	mov    %ebx,0x38(%ecx)
   22a82:	8b 45 9c             	mov    0xffffff9c(%ebp),%eax
   22a85:	31 c3                	xor    %eax,%ebx
   22a87:	89 5d 8c             	mov    %ebx,0xffffff8c(%ebp)
   22a8a:	89 59 3c             	mov    %ebx,0x3c(%ecx)
   22a8d:	8b 45 98             	mov    0xffffff98(%ebp),%eax
   22a90:	0f b6 d4             	movzbl %ah,%edx
   22a93:	c1 e8 10             	shr    $0x10,%eax
   22a96:	8b 34 95 00 00 00 00 	mov    0x0(,%edx,4),%esi
   22a9d:	8b 55 98             	mov    0xffffff98(%ebp),%edx
   22aa0:	0f b6 c0             	movzbl %al,%eax
   22aa3:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   22aaa:	c1 ea 18             	shr    $0x18,%edx
   22aad:	8b 1c 95 00 08 00 00 	mov    0x800(,%edx,4),%ebx
   22ab4:	31 f0                	xor    %esi,%eax
   22ab6:	8b 35 0c 00 00 00    	mov    0xc,%esi
   22abc:	0f b6 55 dc          	movzbl 0xffffffdc(%ebp),%edx
   22ac0:	31 d8                	xor    %ebx,%eax
   22ac2:	8b 0c 95 00 0c 00 00 	mov    0xc00(,%edx,4),%ecx
   22ac9:	8b 55 c4             	mov    0xffffffc4(%ebp),%edx
   22acc:	31 c8                	xor    %ecx,%eax
   22ace:	31 f0                	xor    %esi,%eax
   22ad0:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   22ad3:	31 c2                	xor    %eax,%edx
   22ad5:	0f b6 4d e4          	movzbl 0xffffffe4(%ebp),%ecx
   22ad9:	89 55 88             	mov    %edx,0xffffff88(%ebp)
   22adc:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
   22adf:	0f b6 d4             	movzbl %ah,%edx
   22ae2:	c1 e8 10             	shr    $0x10,%eax
   22ae5:	8b 34 95 00 04 00 00 	mov    0x400(,%edx,4),%esi
   22aec:	0f b6 d0             	movzbl %al,%edx
   22aef:	c1 e8 08             	shr    $0x8,%eax
   22af2:	8b 1c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%ebx
   22af9:	8b 0c 95 00 08 00 00 	mov    0x800(,%edx,4),%ecx
   22b00:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   22b07:	31 de                	xor    %ebx,%esi
   22b09:	31 ce                	xor    %ecx,%esi
   22b0b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   22b0e:	31 d6                	xor    %edx,%esi
   22b10:	31 fe                	xor    %edi,%esi
   22b12:	89 71 40             	mov    %esi,0x40(%ecx)
   22b15:	8b 5d 94             	mov    0xffffff94(%ebp),%ebx
   22b18:	31 f3                	xor    %esi,%ebx
   22b1a:	89 5d 84             	mov    %ebx,0xffffff84(%ebp)
   22b1d:	89 59 44             	mov    %ebx,0x44(%ecx)
   22b20:	8b 45 90             	mov    0xffffff90(%ebp),%eax
   22b23:	31 c3                	xor    %eax,%ebx
   22b25:	89 5d 80             	mov    %ebx,0xffffff80(%ebp)
   22b28:	89 59 48             	mov    %ebx,0x48(%ecx)
   22b2b:	8b 45 8c             	mov    0xffffff8c(%ebp),%eax
   22b2e:	31 c3                	xor    %eax,%ebx
   22b30:	89 9d 7c ff ff ff    	mov    %ebx,0xffffff7c(%ebp)
   22b36:	89 59 4c             	mov    %ebx,0x4c(%ecx)
     kd4(cx->ks, 4);  kd4(cx->ks, 5);
   22b39:	8b 45 88             	mov    0xffffff88(%ebp),%eax
   22b3c:	0f b6 d4             	movzbl %ah,%edx
   22b3f:	c1 e8 10             	shr    $0x10,%eax
   22b42:	8b 3c 95 00 00 00 00 	mov    0x0(,%edx,4),%edi
   22b49:	8b 55 88             	mov    0xffffff88(%ebp),%edx
   22b4c:	0f b6 c0             	movzbl %al,%eax
   22b4f:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   22b56:	c1 ea 18             	shr    $0x18,%edx
   22b59:	8b 1c 95 00 08 00 00 	mov    0x800(,%edx,4),%ebx
   22b60:	31 f8                	xor    %edi,%eax
   22b62:	0f b6 55 e0          	movzbl 0xffffffe0(%ebp),%edx
   22b66:	31 d8                	xor    %ebx,%eax
   22b68:	8b 0c 95 00 0c 00 00 	mov    0xc00(,%edx,4),%ecx
   22b6f:	8b 15 10 00 00 00    	mov    0x10,%edx
   22b75:	31 c8                	xor    %ecx,%eax
   22b77:	31 d0                	xor    %edx,%eax
   22b79:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
   22b7c:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   22b7f:	0f b6 4d e4          	movzbl 0xffffffe4(%ebp),%ecx
   22b83:	31 c2                	xor    %eax,%edx
   22b85:	89 95 78 ff ff ff    	mov    %edx,0xffffff78(%ebp)
   22b8b:	89 55 d4             	mov    %edx,0xffffffd4(%ebp)
   22b8e:	0f b6 d4             	movzbl %ah,%edx
   22b91:	c1 e8 10             	shr    $0x10,%eax
   22b94:	8b 3c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%edi
   22b9b:	8b 1c 95 00 04 00 00 	mov    0x400(,%edx,4),%ebx
   22ba2:	0f b6 d0             	movzbl %al,%edx
   22ba5:	c1 e8 08             	shr    $0x8,%eax
   22ba8:	8b 0c 95 00 08 00 00 	mov    0x800(,%edx,4),%ecx
   22baf:	31 fb                	xor    %edi,%ebx
   22bb1:	8b 3c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edi
   22bb8:	31 cb                	xor    %ecx,%ebx
   22bba:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   22bbd:	31 fb                	xor    %edi,%ebx
   22bbf:	31 f3                	xor    %esi,%ebx
   22bc1:	89 59 50             	mov    %ebx,0x50(%ecx)
   22bc4:	8b 45 84             	mov    0xffffff84(%ebp),%eax
   22bc7:	31 d8                	xor    %ebx,%eax
   22bc9:	89 85 74 ff ff ff    	mov    %eax,0xffffff74(%ebp)
   22bcf:	89 41 54             	mov    %eax,0x54(%ecx)
   22bd2:	8b 75 80             	mov    0xffffff80(%ebp),%esi
   22bd5:	31 f0                	xor    %esi,%eax
   22bd7:	89 85 70 ff ff ff    	mov    %eax,0xffffff70(%ebp)
   22bdd:	89 41 58             	mov    %eax,0x58(%ecx)
   22be0:	8b 95 7c ff ff ff    	mov    0xffffff7c(%ebp),%edx
   22be6:	31 d0                	xor    %edx,%eax
   22be8:	89 85 6c ff ff ff    	mov    %eax,0xffffff6c(%ebp)
   22bee:	89 41 5c             	mov    %eax,0x5c(%ecx)
   22bf1:	8b 8d 78 ff ff ff    	mov    0xffffff78(%ebp),%ecx
   22bf7:	0f b6 d5             	movzbl %ch,%edx
   22bfa:	8b 3c 95 00 00 00 00 	mov    0x0(,%edx,4),%edi
   22c01:	89 ca                	mov    %ecx,%edx
   22c03:	c1 ea 18             	shr    $0x18,%edx
   22c06:	89 c8                	mov    %ecx,%eax
   22c08:	8b 34 95 00 08 00 00 	mov    0x800(,%edx,4),%esi
   22c0f:	c1 e8 10             	shr    $0x10,%eax
   22c12:	0f b6 55 d4          	movzbl 0xffffffd4(%ebp),%edx
   22c16:	0f b6 c0             	movzbl %al,%eax
   22c19:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   22c20:	8b 0c 95 00 0c 00 00 	mov    0xc00(,%edx,4),%ecx
   22c27:	31 f8                	xor    %edi,%eax
   22c29:	8b 15 14 00 00 00    	mov    0x14,%edx
   22c2f:	31 f0                	xor    %esi,%eax
   22c31:	31 c8                	xor    %ecx,%eax
   22c33:	31 d0                	xor    %edx,%eax
   22c35:	8b 55 ac             	mov    0xffffffac(%ebp),%edx
   22c38:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   22c3b:	0f b6 4d e4          	movzbl 0xffffffe4(%ebp),%ecx
   22c3f:	31 c2                	xor    %eax,%edx
   22c41:	89 95 68 ff ff ff    	mov    %edx,0xffffff68(%ebp)
   22c47:	89 55 d8             	mov    %edx,0xffffffd8(%ebp)
   22c4a:	0f b6 d4             	movzbl %ah,%edx
   22c4d:	8b 14 95 00 04 00 00 	mov    0x400(,%edx,4),%edx
   22c54:	89 95 64 ff ff ff    	mov    %edx,0xffffff64(%ebp)
   22c5a:	8b 14 8d 00 00 00 00 	mov    0x0(,%ecx,4),%edx
   22c61:	31 95 64 ff ff ff    	xor    %edx,0xffffff64(%ebp)
   22c67:	c1 e8 10             	shr    $0x10,%eax
   22c6a:	0f b6 d0             	movzbl %al,%edx
   22c6d:	c1 e8 08             	shr    $0x8,%eax
   22c70:	8b 0c 95 00 08 00 00 	mov    0x800(,%edx,4),%ecx
   22c77:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   22c7e:	31 8d 64 ff ff ff    	xor    %ecx,0xffffff64(%ebp)
   22c84:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   22c87:	31 95 64 ff ff ff    	xor    %edx,0xffffff64(%ebp)
   22c8d:	31 9d 64 ff ff ff    	xor    %ebx,0xffffff64(%ebp)
   22c93:	8b 9d 64 ff ff ff    	mov    0xffffff64(%ebp),%ebx
   22c99:	89 59 60             	mov    %ebx,0x60(%ecx)
   22c9c:	8b 85 74 ff ff ff    	mov    0xffffff74(%ebp),%eax
   22ca2:	31 c3                	xor    %eax,%ebx
   22ca4:	89 9d 60 ff ff ff    	mov    %ebx,0xffffff60(%ebp)
   22caa:	89 59 64             	mov    %ebx,0x64(%ecx)
   22cad:	8b 85 70 ff ff ff    	mov    0xffffff70(%ebp),%eax
   22cb3:	31 c3                	xor    %eax,%ebx
   22cb5:	89 9d 5c ff ff ff    	mov    %ebx,0xffffff5c(%ebp)
   22cbb:	89 59 68             	mov    %ebx,0x68(%ecx)
   22cbe:	8b bd 6c ff ff ff    	mov    0xffffff6c(%ebp),%edi
   22cc4:	31 fb                	xor    %edi,%ebx
   22cc6:	89 9d 58 ff ff ff    	mov    %ebx,0xffffff58(%ebp)
   22ccc:	89 59 6c             	mov    %ebx,0x6c(%ecx)
     kd4(cx->ks, 6);  kd4(cx->ks, 7);
   22ccf:	8b 85 68 ff ff ff    	mov    0xffffff68(%ebp),%eax
   22cd5:	0f b6 d4             	movzbl %ah,%edx
   22cd8:	c1 e8 10             	shr    $0x10,%eax
   22cdb:	8b 34 95 00 00 00 00 	mov    0x0(,%edx,4),%esi
   22ce2:	8b 95 68 ff ff ff    	mov    0xffffff68(%ebp),%edx
   22ce8:	0f b6 c0             	movzbl %al,%eax
   22ceb:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   22cf2:	c1 ea 18             	shr    $0x18,%edx
   22cf5:	8b 1c 95 00 08 00 00 	mov    0x800(,%edx,4),%ebx
   22cfc:	31 f0                	xor    %esi,%eax
   22cfe:	0f b6 55 d8          	movzbl 0xffffffd8(%ebp),%edx
   22d02:	31 d8                	xor    %ebx,%eax
   22d04:	8b 0c 95 00 0c 00 00 	mov    0xc00(,%edx,4),%ecx
   22d0b:	8b 15 18 00 00 00    	mov    0x18,%edx
   22d11:	31 c8                	xor    %ecx,%eax
   22d13:	31 d0                	xor    %edx,%eax
   22d15:	8b 55 98             	mov    0xffffff98(%ebp),%edx
   22d18:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   22d1b:	0f b6 4d e4          	movzbl 0xffffffe4(%ebp),%ecx
   22d1f:	31 c2                	xor    %eax,%edx
   22d21:	89 95 54 ff ff ff    	mov    %edx,0xffffff54(%ebp)
   22d27:	89 55 dc             	mov    %edx,0xffffffdc(%ebp)
   22d2a:	0f b6 d4             	movzbl %ah,%edx
   22d2d:	c1 e8 10             	shr    $0x10,%eax
   22d30:	8b 1c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%ebx
   22d37:	8b 14 95 00 04 00 00 	mov    0x400(,%edx,4),%edx
   22d3e:	31 da                	xor    %ebx,%edx
   22d40:	89 95 50 ff ff ff    	mov    %edx,0xffffff50(%ebp)
   22d46:	0f b6 d0             	movzbl %al,%edx
   22d49:	c1 e8 08             	shr    $0x8,%eax
   22d4c:	8b 0c 95 00 08 00 00 	mov    0x800(,%edx,4),%ecx
   22d53:	8b 1c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ebx
   22d5a:	8b 85 64 ff ff ff    	mov    0xffffff64(%ebp),%eax
   22d60:	31 8d 50 ff ff ff    	xor    %ecx,0xffffff50(%ebp)
   22d66:	8b 55 0c             	mov    0xc(%ebp),%edx
   22d69:	31 9d 50 ff ff ff    	xor    %ebx,0xffffff50(%ebp)
   22d6f:	31 85 50 ff ff ff    	xor    %eax,0xffffff50(%ebp)
   22d75:	8b 8d 50 ff ff ff    	mov    0xffffff50(%ebp),%ecx
   22d7b:	89 4a 70             	mov    %ecx,0x70(%edx)
   22d7e:	8b 85 60 ff ff ff    	mov    0xffffff60(%ebp),%eax
   22d84:	31 c1                	xor    %eax,%ecx
   22d86:	89 8d 4c ff ff ff    	mov    %ecx,0xffffff4c(%ebp)
   22d8c:	89 4a 74             	mov    %ecx,0x74(%edx)
   22d8f:	8b 85 5c ff ff ff    	mov    0xffffff5c(%ebp),%eax
   22d95:	31 c1                	xor    %eax,%ecx
   22d97:	89 8d 48 ff ff ff    	mov    %ecx,0xffffff48(%ebp)
   22d9d:	89 4a 78             	mov    %ecx,0x78(%edx)
   22da0:	8b bd 58 ff ff ff    	mov    0xffffff58(%ebp),%edi
   22da6:	31 f9                	xor    %edi,%ecx
   22da8:	89 8d 44 ff ff ff    	mov    %ecx,0xffffff44(%ebp)
   22dae:	89 4a 7c             	mov    %ecx,0x7c(%edx)
   22db1:	8b 9d 54 ff ff ff    	mov    0xffffff54(%ebp),%ebx
   22db7:	0f b6 d7             	movzbl %bh,%edx
   22dba:	8b 34 95 00 00 00 00 	mov    0x0(,%edx,4),%esi
   22dc1:	89 da                	mov    %ebx,%edx
   22dc3:	c1 ea 18             	shr    $0x18,%edx
   22dc6:	89 d8                	mov    %ebx,%eax
   22dc8:	8b 1c 95 00 08 00 00 	mov    0x800(,%edx,4),%ebx
   22dcf:	c1 e8 10             	shr    $0x10,%eax
   22dd2:	0f b6 55 dc          	movzbl 0xffffffdc(%ebp),%edx
   22dd6:	0f b6 c0             	movzbl %al,%eax
   22dd9:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   22de0:	8b 0c 95 00 0c 00 00 	mov    0xc00(,%edx,4),%ecx
   22de7:	31 f0                	xor    %esi,%eax
   22de9:	8b 15 1c 00 00 00    	mov    0x1c,%edx
   22def:	31 d8                	xor    %ebx,%eax
   22df1:	31 c8                	xor    %ecx,%eax
   22df3:	31 d0                	xor    %edx,%eax
   22df5:	8b 55 88             	mov    0xffffff88(%ebp),%edx
   22df8:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   22dfb:	0f b6 4d e4          	movzbl 0xffffffe4(%ebp),%ecx
   22dff:	31 c2                	xor    %eax,%edx
   22e01:	89 95 40 ff ff ff    	mov    %edx,0xffffff40(%ebp)
   22e07:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
   22e0a:	0f b6 d4             	movzbl %ah,%edx
   22e0d:	8b 1c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%ebx
   22e14:	8b 14 95 00 04 00 00 	mov    0x400(,%edx,4),%edx
   22e1b:	31 da                	xor    %ebx,%edx
   22e1d:	c1 e8 10             	shr    $0x10,%eax
   22e20:	89 95 3c ff ff ff    	mov    %edx,0xffffff3c(%ebp)
   22e26:	0f b6 d0             	movzbl %al,%edx
   22e29:	c1 e8 08             	shr    $0x8,%eax
   22e2c:	8b 0c 95 00 08 00 00 	mov    0x800(,%edx,4),%ecx
   22e33:	8b 1c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ebx
   22e3a:	8b 85 50 ff ff ff    	mov    0xffffff50(%ebp),%eax
   22e40:	31 8d 3c ff ff ff    	xor    %ecx,0xffffff3c(%ebp)
   22e46:	8b 55 0c             	mov    0xc(%ebp),%edx
   22e49:	31 9d 3c ff ff ff    	xor    %ebx,0xffffff3c(%ebp)
   22e4f:	31 85 3c ff ff ff    	xor    %eax,0xffffff3c(%ebp)
   22e55:	8b 8d 3c ff ff ff    	mov    0xffffff3c(%ebp),%ecx
   22e5b:	89 8a 80 00 00 00    	mov    %ecx,0x80(%edx)
   22e61:	8b 85 4c ff ff ff    	mov    0xffffff4c(%ebp),%eax
   22e67:	31 c1                	xor    %eax,%ecx
   22e69:	89 8d 38 ff ff ff    	mov    %ecx,0xffffff38(%ebp)
   22e6f:	89 8a 84 00 00 00    	mov    %ecx,0x84(%edx)
   22e75:	8b 85 48 ff ff ff    	mov    0xffffff48(%ebp),%eax
   22e7b:	31 c1                	xor    %eax,%ecx
   22e7d:	89 8d 34 ff ff ff    	mov    %ecx,0xffffff34(%ebp)
   22e83:	89 8a 88 00 00 00    	mov    %ecx,0x88(%edx)
   22e89:	8b bd 44 ff ff ff    	mov    0xffffff44(%ebp),%edi
   22e8f:	31 f9                	xor    %edi,%ecx
     kd4(cx->ks, 8); kdl4(cx->ks, 9);
   22e91:	8b 3d 20 00 00 00    	mov    0x20,%edi
   22e97:	89 8d 30 ff ff ff    	mov    %ecx,0xffffff30(%ebp)
   22e9d:	89 8a 8c 00 00 00    	mov    %ecx,0x8c(%edx)
   22ea3:	8b 9d 40 ff ff ff    	mov    0xffffff40(%ebp),%ebx
   22ea9:	89 d8                	mov    %ebx,%eax
   22eab:	c1 e8 10             	shr    $0x10,%eax
   22eae:	0f b6 c0             	movzbl %al,%eax
   22eb1:	8b 14 85 00 04 00 00 	mov    0x400(,%eax,4),%edx
   22eb8:	89 d8                	mov    %ebx,%eax
   22eba:	c1 e8 18             	shr    $0x18,%eax
   22ebd:	0f b6 cf             	movzbl %bh,%ecx
   22ec0:	8b 1c 85 00 08 00 00 	mov    0x800(,%eax,4),%ebx
   22ec7:	8b 34 8d 00 00 00 00 	mov    0x0(,%ecx,4),%esi
   22ece:	0f b6 45 e0          	movzbl 0xffffffe0(%ebp),%eax
   22ed2:	31 f2                	xor    %esi,%edx
   22ed4:	31 da                	xor    %ebx,%edx
   22ed6:	8b 0c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ecx
   22edd:	8b 85 78 ff ff ff    	mov    0xffffff78(%ebp),%eax
   22ee3:	31 ca                	xor    %ecx,%edx
   22ee5:	31 fa                	xor    %edi,%edx
   22ee7:	8b bd 3c ff ff ff    	mov    0xffffff3c(%ebp),%edi
   22eed:	31 d0                	xor    %edx,%eax
   22eef:	89 55 e4             	mov    %edx,0xffffffe4(%ebp)
   22ef2:	0f b6 4d e4          	movzbl 0xffffffe4(%ebp),%ecx
   22ef6:	89 85 2c ff ff ff    	mov    %eax,0xffffff2c(%ebp)
   22efc:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
   22eff:	0f b6 c6             	movzbl %dh,%eax
   22f02:	c1 ea 10             	shr    $0x10,%edx
   22f05:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   22f0c:	8b 34 8d 00 00 00 00 	mov    0x0(,%ecx,4),%esi
   22f13:	0f b6 ca             	movzbl %dl,%ecx
   22f16:	c1 ea 08             	shr    $0x8,%edx
   22f19:	8b 1c 8d 00 08 00 00 	mov    0x800(,%ecx,4),%ebx
   22f20:	8b 0c 95 00 0c 00 00 	mov    0xc00(,%edx,4),%ecx
   22f27:	31 f0                	xor    %esi,%eax
   22f29:	8b 55 0c             	mov    0xc(%ebp),%edx
   22f2c:	31 d8                	xor    %ebx,%eax
   22f2e:	31 c8                	xor    %ecx,%eax
   22f30:	31 f8                	xor    %edi,%eax
   22f32:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
   22f38:	8b b5 38 ff ff ff    	mov    0xffffff38(%ebp),%esi
   22f3e:	31 f0                	xor    %esi,%eax
   22f40:	89 82 94 00 00 00    	mov    %eax,0x94(%edx)
   22f46:	8b 9d 34 ff ff ff    	mov    0xffffff34(%ebp),%ebx
   22f4c:	31 d8                	xor    %ebx,%eax
   22f4e:	89 82 98 00 00 00    	mov    %eax,0x98(%edx)
   22f54:	8b 8d 30 ff ff ff    	mov    0xffffff30(%ebp),%ecx
   22f5a:	31 c8                	xor    %ecx,%eax
   22f5c:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
   22f62:	8b 9d 2c ff ff ff    	mov    0xffffff2c(%ebp),%ebx
   22f68:	89 d8                	mov    %ebx,%eax
   22f6a:	c1 e8 10             	shr    $0x10,%eax
   22f6d:	0f b6 c0             	movzbl %al,%eax
   22f70:	8b 14 85 00 04 00 00 	mov    0x400(,%eax,4),%edx
   22f77:	89 d8                	mov    %ebx,%eax
   22f79:	c1 e8 18             	shr    $0x18,%eax
   22f7c:	8b 34 85 00 08 00 00 	mov    0x800(,%eax,4),%esi
   22f83:	0f b6 45 d4          	movzbl 0xffffffd4(%ebp),%eax
   22f87:	0f b6 cf             	movzbl %bh,%ecx
   22f8a:	8b 3c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%edi
   22f91:	8b 0c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ecx
   22f98:	31 fa                	xor    %edi,%edx
   22f9a:	a1 24 00 00 00       	mov    0x24,%eax
   22f9f:	31 f2                	xor    %esi,%edx
   22fa1:	31 ca                	xor    %ecx,%edx
   22fa3:	8b 8d 40 ff ff ff    	mov    0xffffff40(%ebp),%ecx
   22fa9:	31 c2                	xor    %eax,%edx
   22fab:	8b 85 68 ff ff ff    	mov    0xffffff68(%ebp),%eax
   22fb1:	31 c2                	xor    %eax,%edx
   22fb3:	89 d8                	mov    %ebx,%eax
   22fb5:	31 d0                	xor    %edx,%eax
   22fb7:	31 85 54 ff ff ff    	xor    %eax,0xffffff54(%ebp)
   22fbd:	31 8d 54 ff ff ff    	xor    %ecx,0xffffff54(%ebp)
   22fc3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   22fc6:	8b 9d 54 ff ff ff    	mov    0xffffff54(%ebp),%ebx
   22fcc:	89 99 a0 00 00 00    	mov    %ebx,0xa0(%ecx)
   22fd2:	31 95 40 ff ff ff    	xor    %edx,0xffffff40(%ebp)
   22fd8:	8b 9d 40 ff ff ff    	mov    0xffffff40(%ebp),%ebx
   22fde:	89 81 a8 00 00 00    	mov    %eax,0xa8(%ecx)
#endif
    cx->rn = 10;
   22fe4:	b8 0a 00 00 00       	mov    $0xa,%eax
   22fe9:	89 81 f0 00 00 00    	mov    %eax,0xf0(%ecx)
#if defined( AES_ERR_CHK )
    return aes_good;
#endif
}
   22fef:	31 c0                	xor    %eax,%eax
   22ff1:	89 99 a4 00 00 00    	mov    %ebx,0xa4(%ecx)
   22ff7:	89 91 ac 00 00 00    	mov    %edx,0xac(%ecx)
   22ffd:	81 c4 c8 00 00 00    	add    $0xc8,%esp
   23003:	5b                   	pop    %ebx
   23004:	5e                   	pop    %esi
   23005:	5f                   	pop    %edi
   23006:	5d                   	pop    %ebp
   23007:	c3                   	ret    
   23008:	90                   	nop    
   23009:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi

00023010 <aes_decrypt_key192>:

#endif

#if defined(AES_192) || defined(AES_VAR)

aes_rval aes_decrypt_key192(const unsigned char *key, aes_decrypt_ctx cx[1])
{   aes_32t    ss[7];
   23010:	55                   	push   %ebp
   23011:	89 e5                	mov    %esp,%ebp
   23013:	57                   	push   %edi
   23014:	56                   	push   %esi
   23015:	53                   	push   %ebx
   23016:	81 ec 64 01 00 00    	sub    $0x164,%esp
   2301c:	8b 4d 08             	mov    0x8(%ebp),%ecx
#if defined( d_vars )
        d_vars;
#endif
    cx->ks[0] = ss[0] = word_in(key, 0);
   2301f:	8b 55 0c             	mov    0xc(%ebp),%edx
   23022:	0f b6 41 03          	movzbl 0x3(%ecx),%eax
   23026:	c1 e0 18             	shl    $0x18,%eax
   23029:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
   2302c:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
   23030:	c1 e0 10             	shl    $0x10,%eax
   23033:	09 45 d0             	or     %eax,0xffffffd0(%ebp)
   23036:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
   2303a:	c1 e0 08             	shl    $0x8,%eax
   2303d:	09 45 d0             	or     %eax,0xffffffd0(%ebp)
   23040:	0f b6 01             	movzbl (%ecx),%eax
   23043:	09 45 d0             	or     %eax,0xffffffd0(%ebp)
   23046:	8b 5d d0             	mov    0xffffffd0(%ebp),%ebx
   23049:	89 1a                	mov    %ebx,(%edx)
    cx->ks[1] = ss[1] = word_in(key, 1);
   2304b:	0f b6 71 07          	movzbl 0x7(%ecx),%esi
   2304f:	0f b6 41 06          	movzbl 0x6(%ecx),%eax
   23053:	c1 e6 18             	shl    $0x18,%esi
   23056:	c1 e0 10             	shl    $0x10,%eax
   23059:	09 c6                	or     %eax,%esi
   2305b:	0f b6 41 05          	movzbl 0x5(%ecx),%eax
   2305f:	c1 e0 08             	shl    $0x8,%eax
   23062:	09 c6                	or     %eax,%esi
   23064:	0f b6 41 04          	movzbl 0x4(%ecx),%eax
   23068:	09 c6                	or     %eax,%esi
   2306a:	89 75 cc             	mov    %esi,0xffffffcc(%ebp)
   2306d:	89 72 04             	mov    %esi,0x4(%edx)
    cx->ks[2] = ss[2] = word_in(key, 2);
   23070:	0f b6 79 0b          	movzbl 0xb(%ecx),%edi
   23074:	0f b6 41 0a          	movzbl 0xa(%ecx),%eax
   23078:	c1 e7 18             	shl    $0x18,%edi
   2307b:	c1 e0 10             	shl    $0x10,%eax
   2307e:	09 c7                	or     %eax,%edi
   23080:	0f b6 41 09          	movzbl 0x9(%ecx),%eax
   23084:	c1 e0 08             	shl    $0x8,%eax
   23087:	09 c7                	or     %eax,%edi
   23089:	0f b6 41 08          	movzbl 0x8(%ecx),%eax
   2308d:	09 c7                	or     %eax,%edi
   2308f:	89 7d c8             	mov    %edi,0xffffffc8(%ebp)
   23092:	89 7a 08             	mov    %edi,0x8(%edx)
    cx->ks[3] = ss[3] = word_in(key, 3);

#if DEC_UNROLL == NONE
    cx->ks[4] = ss[4] = word_in(key, 4);
    cx->ks[5] = ss[5] = word_in(key, 5);
    {   aes_32t i;

        for(i = 0; i < (13 * N_COLS - 7) / 6; ++i)
            ke6(cx->ks, i);
        kel6(cx->ks, 7);
#if !(DEC_ROUND == NO_TABLES)
        for(i = N_COLS; i < 12 * N_COLS; ++i)
            cx->ks[i] = inv_mcol(cx->ks[i]);
#endif
    }
#else
    cx->ks[4] = ff(ss[4] = word_in(key, 4));
   23095:	bf 00 00 00 00       	mov    $0x0,%edi
   2309a:	0f b6 41 0f          	movzbl 0xf(%ecx),%eax
   2309e:	c1 e0 18             	shl    $0x18,%eax
   230a1:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
   230a4:	0f b6 41 0e          	movzbl 0xe(%ecx),%eax
   230a8:	c1 e0 10             	shl    $0x10,%eax
   230ab:	09 45 c4             	or     %eax,0xffffffc4(%ebp)
   230ae:	0f b6 41 0d          	movzbl 0xd(%ecx),%eax
   230b2:	c1 e0 08             	shl    $0x8,%eax
   230b5:	09 45 c4             	or     %eax,0xffffffc4(%ebp)
   230b8:	0f b6 41 0c          	movzbl 0xc(%ecx),%eax
   230bc:	09 45 c4             	or     %eax,0xffffffc4(%ebp)
   230bf:	8b 5d c4             	mov    0xffffffc4(%ebp),%ebx
   230c2:	89 5a 0c             	mov    %ebx,0xc(%edx)
   230c5:	0f b6 41 13          	movzbl 0x13(%ecx),%eax
   230c9:	c1 e0 18             	shl    $0x18,%eax
   230cc:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
   230cf:	0f b6 41 12          	movzbl 0x12(%ecx),%eax
   230d3:	c1 e0 10             	shl    $0x10,%eax
   230d6:	09 45 c0             	or     %eax,0xffffffc0(%ebp)
   230d9:	0f b6 41 11          	movzbl 0x11(%ecx),%eax
   230dd:	c1 e0 08             	shl    $0x8,%eax
   230e0:	09 45 c0             	or     %eax,0xffffffc0(%ebp)
   230e3:	0f b6 41 10          	movzbl 0x10(%ecx),%eax
   230e7:	09 45 c0             	or     %eax,0xffffffc0(%ebp)
   230ea:	8b 5d c0             	mov    0xffffffc0(%ebp),%ebx
   230ed:	0f b6 55 c0          	movzbl 0xffffffc0(%ebp),%edx
   230f1:	0f b6 c7             	movzbl %bh,%eax
   230f4:	89 55 bc             	mov    %edx,0xffffffbc(%ebp)
   230f7:	8b 14 85 00 04 00 00 	mov    0x400(,%eax,4),%edx
   230fe:	8b 75 bc             	mov    0xffffffbc(%ebp),%esi
   23101:	8b 04 b7             	mov    (%edi,%esi,4),%eax
   23104:	31 c2                	xor    %eax,%edx
   23106:	89 d8                	mov    %ebx,%eax
   23108:	c1 e8 10             	shr    $0x10,%eax
   2310b:	0f b6 c0             	movzbl %al,%eax
   2310e:	8b 34 85 00 08 00 00 	mov    0x800(,%eax,4),%esi
   23115:	89 d8                	mov    %ebx,%eax
   23117:	31 f2                	xor    %esi,%edx
   23119:	c1 e8 18             	shr    $0x18,%eax
   2311c:	8b 1c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ebx
   23123:	8b 45 0c             	mov    0xc(%ebp),%eax
   23126:	31 da                	xor    %ebx,%edx
   23128:	89 50 10             	mov    %edx,0x10(%eax)
    cx->ks[5] = ff(ss[5] = word_in(key, 5));
   2312b:	0f b6 51 17          	movzbl 0x17(%ecx),%edx
   2312f:	0f b6 41 16          	movzbl 0x16(%ecx),%eax
   23133:	c1 e2 18             	shl    $0x18,%edx
   23136:	c1 e0 10             	shl    $0x10,%eax
   23139:	09 c2                	or     %eax,%edx
   2313b:	0f b6 41 15          	movzbl 0x15(%ecx),%eax
   2313f:	c1 e0 08             	shl    $0x8,%eax
   23142:	09 c2                	or     %eax,%edx
   23144:	0f b6 41 14          	movzbl 0x14(%ecx),%eax
   23148:	09 c2                	or     %eax,%edx
   2314a:	89 55 b8             	mov    %edx,0xffffffb8(%ebp)
   2314d:	0f b6 55 b8          	movzbl 0xffffffb8(%ebp),%edx
   23151:	8b 4d b8             	mov    0xffffffb8(%ebp),%ecx
   23154:	8b 5d b8             	mov    0xffffffb8(%ebp),%ebx
   23157:	0f b6 cd             	movzbl %ch,%ecx
   2315a:	8b 84 8f 00 04 00 00 	mov    0x400(%edi,%ecx,4),%eax
   23161:	8b 3c 95 00 00 00 00 	mov    0x0(,%edx,4),%edi
   23168:	89 4d b4             	mov    %ecx,0xffffffb4(%ebp)
   2316b:	8b 55 b8             	mov    0xffffffb8(%ebp),%edx
   2316e:	89 d9                	mov    %ebx,%ecx
   23170:	89 5d e8             	mov    %ebx,0xffffffe8(%ebp)
   23173:	c1 e9 18             	shr    $0x18,%ecx
   23176:	c1 ea 10             	shr    $0x10,%edx
   23179:	0f b6 d2             	movzbl %dl,%edx
   2317c:	8b 1c 8d 00 0c 00 00 	mov    0xc00(,%ecx,4),%ebx
   23183:	8b 34 95 00 08 00 00 	mov    0x800(,%edx,4),%esi
   2318a:	31 f8                	xor    %edi,%eax
   2318c:	31 f0                	xor    %esi,%eax
   2318e:	8b 75 0c             	mov    0xc(%ebp),%esi
   23191:	31 d8                	xor    %ebx,%eax
    kdf6(cx->ks, 0); kd6(cx->ks, 1);
   23193:	8b 1c 95 00 04 00 00 	mov    0x400(,%edx,4),%ebx
   2319a:	89 46 14             	mov    %eax,0x14(%esi)
   2319d:	b8 00 00 00 00       	mov    $0x0,%eax
   231a2:	8b 34 8d 00 08 00 00 	mov    0x800(,%ecx,4),%esi
   231a9:	8b 7d b4             	mov    0xffffffb4(%ebp),%edi
   231ac:	8b 14 b8             	mov    (%eax,%edi,4),%edx
   231af:	8b 7d d0             	mov    0xffffffd0(%ebp),%edi
   231b2:	0f b6 45 e8          	movzbl 0xffffffe8(%ebp),%eax
   231b6:	31 d3                	xor    %edx,%ebx
   231b8:	31 f3                	xor    %esi,%ebx
   231ba:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   231c1:	a1 00 00 00 00       	mov    0x0,%eax
   231c6:	31 d3                	xor    %edx,%ebx
   231c8:	31 c3                	xor    %eax,%ebx
   231ca:	31 fb                	xor    %edi,%ebx
   231cc:	0f b6 c7             	movzbl %bh,%eax
   231cf:	89 5d d4             	mov    %ebx,0xffffffd4(%ebp)
   231d2:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   231d9:	0f b6 55 d4          	movzbl 0xffffffd4(%ebp),%edx
   231dd:	8b 0c 95 00 00 00 00 	mov    0x0(,%edx,4),%ecx
   231e4:	31 c8                	xor    %ecx,%eax
   231e6:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
   231e9:	89 d8                	mov    %ebx,%eax
   231eb:	c1 e8 10             	shr    $0x10,%eax
   231ee:	0f b6 c0             	movzbl %al,%eax
   231f1:	8b 34 85 00 08 00 00 	mov    0x800(,%eax,4),%esi
   231f8:	89 d8                	mov    %ebx,%eax
   231fa:	31 75 b0             	xor    %esi,0xffffffb0(%ebp)
   231fd:	c1 e8 18             	shr    $0x18,%eax
   23200:	8b 3c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edi
   23207:	31 7d b0             	xor    %edi,0xffffffb0(%ebp)
   2320a:	8b 45 0c             	mov    0xc(%ebp),%eax
   2320d:	8b 55 b0             	mov    0xffffffb0(%ebp),%edx
   23210:	89 50 18             	mov    %edx,0x18(%eax)
   23213:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
   23216:	31 d9                	xor    %ebx,%ecx
   23218:	89 4d d8             	mov    %ecx,0xffffffd8(%ebp)
   2321b:	0f b6 c5             	movzbl %ch,%eax
   2321e:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   23225:	0f b6 55 d8          	movzbl 0xffffffd8(%ebp),%edx
   23229:	89 4d ac             	mov    %ecx,0xffffffac(%ebp)
   2322c:	8b 34 95 00 00 00 00 	mov    0x0(,%edx,4),%esi
   23233:	31 f0                	xor    %esi,%eax
   23235:	89 45 a8             	mov    %eax,0xffffffa8(%ebp)
   23238:	89 c8                	mov    %ecx,%eax
   2323a:	c1 e8 10             	shr    $0x10,%eax
   2323d:	0f b6 c0             	movzbl %al,%eax
   23240:	8b 3c 85 00 08 00 00 	mov    0x800(,%eax,4),%edi
   23247:	89 c8                	mov    %ecx,%eax
   23249:	31 7d a8             	xor    %edi,0xffffffa8(%ebp)
   2324c:	c1 e8 18             	shr    $0x18,%eax
   2324f:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   23256:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   23259:	31 55 a8             	xor    %edx,0xffffffa8(%ebp)
   2325c:	8b 75 a8             	mov    0xffffffa8(%ebp),%esi
   2325f:	89 71 1c             	mov    %esi,0x1c(%ecx)
   23262:	8b 75 ac             	mov    0xffffffac(%ebp),%esi
   23265:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
   23268:	31 f0                	xor    %esi,%eax
   2326a:	89 c1                	mov    %eax,%ecx
   2326c:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
   2326f:	0f b6 55 dc          	movzbl 0xffffffdc(%ebp),%edx
   23273:	89 45 a4             	mov    %eax,0xffffffa4(%ebp)
   23276:	0f b6 c4             	movzbl %ah,%eax
   23279:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   23280:	8b 34 95 00 00 00 00 	mov    0x0(,%edx,4),%esi
   23287:	31 f0                	xor    %esi,%eax
   23289:	89 45 a0             	mov    %eax,0xffffffa0(%ebp)
   2328c:	89 c8                	mov    %ecx,%eax
   2328e:	c1 e8 10             	shr    $0x10,%eax
   23291:	0f b6 c0             	movzbl %al,%eax
   23294:	8b 3c 85 00 08 00 00 	mov    0x800(,%eax,4),%edi
   2329b:	89 c8                	mov    %ecx,%eax
   2329d:	31 7d a0             	xor    %edi,0xffffffa0(%ebp)
   232a0:	c1 e8 18             	shr    $0x18,%eax
   232a3:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   232aa:	31 55 a0             	xor    %edx,0xffffffa0(%ebp)
   232ad:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   232b0:	8b 75 a0             	mov    0xffffffa0(%ebp),%esi
   232b3:	89 71 20             	mov    %esi,0x20(%ecx)
   232b6:	8b 4d a4             	mov    0xffffffa4(%ebp),%ecx
   232b9:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
   232bc:	31 c8                	xor    %ecx,%eax
   232be:	89 c1                	mov    %eax,%ecx
   232c0:	89 45 9c             	mov    %eax,0xffffff9c(%ebp)
   232c3:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   232c6:	0f b6 c4             	movzbl %ah,%eax
   232c9:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   232d0:	0f b6 55 e0          	movzbl 0xffffffe0(%ebp),%edx
   232d4:	8b 34 95 00 00 00 00 	mov    0x0(,%edx,4),%esi
   232db:	31 f0                	xor    %esi,%eax
   232dd:	89 45 98             	mov    %eax,0xffffff98(%ebp)
   232e0:	89 c8                	mov    %ecx,%eax
   232e2:	c1 e8 10             	shr    $0x10,%eax
   232e5:	0f b6 c0             	movzbl %al,%eax
   232e8:	8b 3c 85 00 08 00 00 	mov    0x800(,%eax,4),%edi
   232ef:	89 c8                	mov    %ecx,%eax
   232f1:	31 7d 98             	xor    %edi,0xffffff98(%ebp)
   232f4:	c1 e8 18             	shr    $0x18,%eax
   232f7:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   232fe:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   23301:	31 55 98             	xor    %edx,0xffffff98(%ebp)
   23304:	8b 75 98             	mov    0xffffff98(%ebp),%esi
   23307:	89 71 24             	mov    %esi,0x24(%ecx)
   2330a:	8b 55 9c             	mov    0xffffff9c(%ebp),%edx
   2330d:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
   23310:	31 d0                	xor    %edx,%eax
   23312:	89 c1                	mov    %eax,%ecx
   23314:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
   23317:	0f b6 55 e4          	movzbl 0xffffffe4(%ebp),%edx
   2331b:	89 45 94             	mov    %eax,0xffffff94(%ebp)
   2331e:	0f b6 c4             	movzbl %ah,%eax
   23321:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   23328:	8b 34 95 00 00 00 00 	mov    0x0(,%edx,4),%esi
   2332f:	31 f0                	xor    %esi,%eax
   23331:	89 45 90             	mov    %eax,0xffffff90(%ebp)
   23334:	89 c8                	mov    %ecx,%eax
   23336:	c1 e8 10             	shr    $0x10,%eax
   23339:	0f b6 c0             	movzbl %al,%eax
   2333c:	8b 3c 85 00 08 00 00 	mov    0x800(,%eax,4),%edi
   23343:	89 c8                	mov    %ecx,%eax
   23345:	31 7d 90             	xor    %edi,0xffffff90(%ebp)
   23348:	c1 e8 18             	shr    $0x18,%eax
   2334b:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   23352:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   23355:	31 55 90             	xor    %edx,0xffffff90(%ebp)
   23358:	8b 75 90             	mov    0xffffff90(%ebp),%esi
   2335b:	89 71 28             	mov    %esi,0x28(%ecx)
   2335e:	8b 7d 94             	mov    0xffffff94(%ebp),%edi
   23361:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
   23364:	31 f8                	xor    %edi,%eax
   23366:	bf 00 00 00 00       	mov    $0x0,%edi
   2336b:	0f b6 cc             	movzbl %ah,%ecx
   2336e:	89 45 8c             	mov    %eax,0xffffff8c(%ebp)
   23371:	8b 34 8d 00 04 00 00 	mov    0x400(,%ecx,4),%esi
   23378:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   2337b:	c1 e8 10             	shr    $0x10,%eax
   2337e:	0f b6 c0             	movzbl %al,%eax
   23381:	0f b6 55 e8          	movzbl 0xffffffe8(%ebp),%edx
   23385:	8b 3c 97             	mov    (%edi,%edx,4),%edi
   23388:	89 55 88             	mov    %edx,0xffffff88(%ebp)
   2338b:	8b 14 85 00 08 00 00 	mov    0x800(,%eax,4),%edx
   23392:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   23399:	31 fe                	xor    %edi,%esi
   2339b:	31 d6                	xor    %edx,%esi
   2339d:	8b 55 8c             	mov    0xffffff8c(%ebp),%edx
   233a0:	c1 ea 18             	shr    $0x18,%edx
   233a3:	8b 3c 95 00 0c 00 00 	mov    0xc00(,%edx,4),%edi
   233aa:	31 fe                	xor    %edi,%esi
   233ac:	8b 7d 0c             	mov    0xc(%ebp),%edi
   233af:	89 75 84             	mov    %esi,0xffffff84(%ebp)
   233b2:	89 77 2c             	mov    %esi,0x2c(%edi)
   233b5:	8b 34 8d 00 00 00 00 	mov    0x0(,%ecx,4),%esi
   233bc:	8b 0c 95 00 08 00 00 	mov    0x800(,%edx,4),%ecx
   233c3:	8b 55 88             	mov    0xffffff88(%ebp),%edx
   233c6:	31 f0                	xor    %esi,%eax
   233c8:	8b 35 04 00 00 00    	mov    0x4,%esi
   233ce:	31 c8                	xor    %ecx,%eax
   233d0:	b9 00 00 00 00       	mov    $0x0,%ecx
   233d5:	8b bc 91 00 0c 00 00 	mov    0xc00(%ecx,%edx,4),%edi
   233dc:	31 f8                	xor    %edi,%eax
   233de:	31 f0                	xor    %esi,%eax
   233e0:	31 c3                	xor    %eax,%ebx
   233e2:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   233e5:	0f b6 d4             	movzbl %ah,%edx
   233e8:	c1 e8 10             	shr    $0x10,%eax
   233eb:	0f b6 4d ec          	movzbl 0xffffffec(%ebp),%ecx
   233ef:	89 5d 80             	mov    %ebx,0xffffff80(%ebp)
   233f2:	8b 3c 95 00 04 00 00 	mov    0x400(,%edx,4),%edi
   233f9:	0f b6 d0             	movzbl %al,%edx
   233fc:	c1 e8 08             	shr    $0x8,%eax
   233ff:	8b 1c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%ebx
   23406:	8b 0c 95 00 08 00 00 	mov    0x800(,%edx,4),%ecx
   2340d:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   23414:	31 df                	xor    %ebx,%edi
   23416:	8b 45 b0             	mov    0xffffffb0(%ebp),%eax
   23419:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   2341c:	31 cf                	xor    %ecx,%edi
   2341e:	31 d7                	xor    %edx,%edi
   23420:	31 c7                	xor    %eax,%edi
   23422:	89 7b 30             	mov    %edi,0x30(%ebx)
   23425:	8b 45 80             	mov    0xffffff80(%ebp),%eax
   23428:	8b 75 ac             	mov    0xffffffac(%ebp),%esi
   2342b:	31 c6                	xor    %eax,%esi
   2342d:	8b 45 a8             	mov    0xffffffa8(%ebp),%eax
   23430:	89 b5 7c ff ff ff    	mov    %esi,0xffffff7c(%ebp)
   23436:	31 f8                	xor    %edi,%eax
   23438:	89 85 78 ff ff ff    	mov    %eax,0xffffff78(%ebp)
   2343e:	89 43 34             	mov    %eax,0x34(%ebx)
   23441:	8b 55 a4             	mov    0xffffffa4(%ebp),%edx
   23444:	31 f2                	xor    %esi,%edx
   23446:	89 95 74 ff ff ff    	mov    %edx,0xffffff74(%ebp)
   2344c:	8b 4d a0             	mov    0xffffffa0(%ebp),%ecx
   2344f:	31 c8                	xor    %ecx,%eax
   23451:	89 85 70 ff ff ff    	mov    %eax,0xffffff70(%ebp)
   23457:	89 43 38             	mov    %eax,0x38(%ebx)
   2345a:	8b 4d 9c             	mov    0xffffff9c(%ebp),%ecx
   2345d:	31 d1                	xor    %edx,%ecx
   2345f:	8b 55 98             	mov    0xffffff98(%ebp),%edx
   23462:	89 8d 6c ff ff ff    	mov    %ecx,0xffffff6c(%ebp)
   23468:	31 d0                	xor    %edx,%eax
   2346a:	89 85 68 ff ff ff    	mov    %eax,0xffffff68(%ebp)
   23470:	89 43 3c             	mov    %eax,0x3c(%ebx)
   23473:	8b 75 90             	mov    0xffffff90(%ebp),%esi
   23476:	8b 5d 94             	mov    0xffffff94(%ebp),%ebx
   23479:	31 f0                	xor    %esi,%eax
   2347b:	8b 75 0c             	mov    0xc(%ebp),%esi
   2347e:	31 cb                	xor    %ecx,%ebx
   23480:	89 85 60 ff ff ff    	mov    %eax,0xffffff60(%ebp)
   23486:	89 9d 64 ff ff ff    	mov    %ebx,0xffffff64(%ebp)
   2348c:	89 46 40             	mov    %eax,0x40(%esi)
   2348f:	8b 4d 84             	mov    0xffffff84(%ebp),%ecx
   23492:	8b 45 8c             	mov    0xffffff8c(%ebp),%eax
   23495:	8b 95 60 ff ff ff    	mov    0xffffff60(%ebp),%edx
   2349b:	31 d8                	xor    %ebx,%eax
   2349d:	31 ca                	xor    %ecx,%edx
   2349f:	89 85 5c ff ff ff    	mov    %eax,0xffffff5c(%ebp)
   234a5:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   234a8:	89 95 58 ff ff ff    	mov    %edx,0xffffff58(%ebp)
   234ae:	89 56 44             	mov    %edx,0x44(%esi)
    kd6(cx->ks, 2);  kd6(cx->ks, 3);
   234b1:	0f b6 d4             	movzbl %ah,%edx
   234b4:	8b 34 95 00 00 00 00 	mov    0x0(,%edx,4),%esi
   234bb:	8b 95 5c ff ff ff    	mov    0xffffff5c(%ebp),%edx
   234c1:	8b 85 5c ff ff ff    	mov    0xffffff5c(%ebp),%eax
   234c7:	c1 ea 18             	shr    $0x18,%edx
   234ca:	8b 1c 95 00 08 00 00 	mov    0x800(,%edx,4),%ebx
   234d1:	c1 e8 10             	shr    $0x10,%eax
   234d4:	0f b6 c0             	movzbl %al,%eax
   234d7:	0f b6 55 e8          	movzbl 0xffffffe8(%ebp),%edx
   234db:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   234e2:	8b 0c 95 00 0c 00 00 	mov    0xc00(,%edx,4),%ecx
   234e9:	31 f0                	xor    %esi,%eax
   234eb:	8b 35 08 00 00 00    	mov    0x8,%esi
   234f1:	31 d8                	xor    %ebx,%eax
   234f3:	31 c8                	xor    %ecx,%eax
   234f5:	8b 4d 80             	mov    0xffffff80(%ebp),%ecx
   234f8:	31 f0                	xor    %esi,%eax
   234fa:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   234fd:	31 c1                	xor    %eax,%ecx
   234ff:	0f b6 d4             	movzbl %ah,%edx
   23502:	89 8d 54 ff ff ff    	mov    %ecx,0xffffff54(%ebp)
   23508:	0f b6 4d ec          	movzbl 0xffffffec(%ebp),%ecx
   2350c:	c1 e8 10             	shr    $0x10,%eax
   2350f:	8b 34 95 00 04 00 00 	mov    0x400(,%edx,4),%esi
   23516:	0f b6 d0             	movzbl %al,%edx
   23519:	c1 e8 08             	shr    $0x8,%eax
   2351c:	8b 1c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%ebx
   23523:	8b 0c 95 00 08 00 00 	mov    0x800(,%edx,4),%ecx
   2352a:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   23531:	31 de                	xor    %ebx,%esi
   23533:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   23536:	31 ce                	xor    %ecx,%esi
   23538:	31 d6                	xor    %edx,%esi
   2353a:	31 fe                	xor    %edi,%esi
   2353c:	89 73 48             	mov    %esi,0x48(%ebx)
   2353f:	8b 85 54 ff ff ff    	mov    0xffffff54(%ebp),%eax
   23545:	8b bd 7c ff ff ff    	mov    0xffffff7c(%ebp),%edi
   2354b:	31 c7                	xor    %eax,%edi
   2354d:	8b 85 78 ff ff ff    	mov    0xffffff78(%ebp),%eax
   23553:	89 bd 50 ff ff ff    	mov    %edi,0xffffff50(%ebp)
   23559:	31 f0                	xor    %esi,%eax
   2355b:	89 85 4c ff ff ff    	mov    %eax,0xffffff4c(%ebp)
   23561:	89 43 4c             	mov    %eax,0x4c(%ebx)
   23564:	8b 8d 70 ff ff ff    	mov    0xffffff70(%ebp),%ecx
   2356a:	8b 95 74 ff ff ff    	mov    0xffffff74(%ebp),%edx
   23570:	31 c8                	xor    %ecx,%eax
   23572:	31 fa                	xor    %edi,%edx
   23574:	89 95 48 ff ff ff    	mov    %edx,0xffffff48(%ebp)
   2357a:	89 85 44 ff ff ff    	mov    %eax,0xffffff44(%ebp)
   23580:	89 43 50             	mov    %eax,0x50(%ebx)
   23583:	8b 8d 6c ff ff ff    	mov    0xffffff6c(%ebp),%ecx
   23589:	31 d1                	xor    %edx,%ecx
   2358b:	8b 95 68 ff ff ff    	mov    0xffffff68(%ebp),%edx
   23591:	89 8d 40 ff ff ff    	mov    %ecx,0xffffff40(%ebp)
   23597:	31 d0                	xor    %edx,%eax
   23599:	89 85 3c ff ff ff    	mov    %eax,0xffffff3c(%ebp)
   2359f:	89 43 54             	mov    %eax,0x54(%ebx)
   235a2:	8b bd 60 ff ff ff    	mov    0xffffff60(%ebp),%edi
   235a8:	8b 9d 64 ff ff ff    	mov    0xffffff64(%ebp),%ebx
   235ae:	31 f8                	xor    %edi,%eax
   235b0:	8b 7d 0c             	mov    0xc(%ebp),%edi
   235b3:	31 cb                	xor    %ecx,%ebx
   235b5:	89 85 34 ff ff ff    	mov    %eax,0xffffff34(%ebp)
   235bb:	89 9d 38 ff ff ff    	mov    %ebx,0xffffff38(%ebp)
   235c1:	89 47 58             	mov    %eax,0x58(%edi)
   235c4:	8b 8d 58 ff ff ff    	mov    0xffffff58(%ebp),%ecx
   235ca:	8b 85 5c ff ff ff    	mov    0xffffff5c(%ebp),%eax
   235d0:	8b 95 34 ff ff ff    	mov    0xffffff34(%ebp),%edx
   235d6:	31 d8                	xor    %ebx,%eax
   235d8:	31 ca                	xor    %ecx,%edx
   235da:	89 85 30 ff ff ff    	mov    %eax,0xffffff30(%ebp)
   235e0:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
   235e3:	89 95 2c ff ff ff    	mov    %edx,0xffffff2c(%ebp)
   235e9:	89 57 5c             	mov    %edx,0x5c(%edi)
   235ec:	0f b6 d4             	movzbl %ah,%edx
   235ef:	8b 85 30 ff ff ff    	mov    0xffffff30(%ebp),%eax
   235f5:	8b 3c 95 00 00 00 00 	mov    0x0(,%edx,4),%edi
   235fc:	8b 95 30 ff ff ff    	mov    0xffffff30(%ebp),%edx
   23602:	c1 e8 10             	shr    $0x10,%eax
   23605:	0f b6 c0             	movzbl %al,%eax
   23608:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   2360f:	31 f8                	xor    %edi,%eax
   23611:	c1 ea 18             	shr    $0x18,%edx
   23614:	8b 1c 95 00 08 00 00 	mov    0x800(,%edx,4),%ebx
   2361b:	0f b6 55 e8          	movzbl 0xffffffe8(%ebp),%edx
   2361f:	31 d8                	xor    %ebx,%eax
   23621:	8b 0c 95 00 0c 00 00 	mov    0xc00(,%edx,4),%ecx
   23628:	8b 15 0c 00 00 00    	mov    0xc,%edx
   2362e:	31 c8                	xor    %ecx,%eax
   23630:	31 d0                	xor    %edx,%eax
   23632:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   23635:	8b 8d 54 ff ff ff    	mov    0xffffff54(%ebp),%ecx
   2363b:	0f b6 d4             	movzbl %ah,%edx
   2363e:	8b 14 95 00 04 00 00 	mov    0x400(,%edx,4),%edx
   23645:	31 c1                	xor    %eax,%ecx
   23647:	c1 e8 10             	shr    $0x10,%eax
   2364a:	89 8d 28 ff ff ff    	mov    %ecx,0xffffff28(%ebp)
   23650:	0f b6 4d ec          	movzbl 0xffffffec(%ebp),%ecx
   23654:	8b 1c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%ebx
   2365b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   2365e:	31 da                	xor    %ebx,%edx
   23660:	89 95 24 ff ff ff    	mov    %edx,0xffffff24(%ebp)
   23666:	0f b6 d0             	movzbl %al,%edx
   23669:	c1 e8 08             	shr    $0x8,%eax
   2366c:	8b 3c 95 00 08 00 00 	mov    0x800(,%edx,4),%edi
   23673:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   2367a:	31 bd 24 ff ff ff    	xor    %edi,0xffffff24(%ebp)
   23680:	31 95 24 ff ff ff    	xor    %edx,0xffffff24(%ebp)
   23686:	31 b5 24 ff ff ff    	xor    %esi,0xffffff24(%ebp)
   2368c:	8b 9d 24 ff ff ff    	mov    0xffffff24(%ebp),%ebx
   23692:	89 59 60             	mov    %ebx,0x60(%ecx)
   23695:	8b 85 28 ff ff ff    	mov    0xffffff28(%ebp),%eax
   2369b:	8b bd 4c ff ff ff    	mov    0xffffff4c(%ebp),%edi
   236a1:	8b b5 50 ff ff ff    	mov    0xffffff50(%ebp),%esi
   236a7:	31 fb                	xor    %edi,%ebx
   236a9:	31 c6                	xor    %eax,%esi
   236ab:	89 b5 20 ff ff ff    	mov    %esi,0xffffff20(%ebp)
   236b1:	89 9d 1c ff ff ff    	mov    %ebx,0xffffff1c(%ebp)
   236b7:	89 59 64             	mov    %ebx,0x64(%ecx)
   236ba:	8b bd 48 ff ff ff    	mov    0xffffff48(%ebp),%edi
   236c0:	31 f7                	xor    %esi,%edi
   236c2:	8b b5 44 ff ff ff    	mov    0xffffff44(%ebp),%esi
   236c8:	89 bd 18 ff ff ff    	mov    %edi,0xffffff18(%ebp)
   236ce:	31 f3                	xor    %esi,%ebx
   236d0:	89 9d 14 ff ff ff    	mov    %ebx,0xffffff14(%ebp)
   236d6:	89 59 68             	mov    %ebx,0x68(%ecx)
   236d9:	8b 95 3c ff ff ff    	mov    0xffffff3c(%ebp),%edx
   236df:	8b 85 40 ff ff ff    	mov    0xffffff40(%ebp),%eax
   236e5:	31 d3                	xor    %edx,%ebx
   236e7:	31 f8                	xor    %edi,%eax
   236e9:	89 85 10 ff ff ff    	mov    %eax,0xffffff10(%ebp)
   236ef:	89 9d 0c ff ff ff    	mov    %ebx,0xffffff0c(%ebp)
   236f5:	89 59 6c             	mov    %ebx,0x6c(%ecx)
   236f8:	8b 95 38 ff ff ff    	mov    0xffffff38(%ebp),%edx
   236fe:	31 c2                	xor    %eax,%edx
   23700:	89 95 08 ff ff ff    	mov    %edx,0xffffff08(%ebp)
   23706:	8b 85 34 ff ff ff    	mov    0xffffff34(%ebp),%eax
   2370c:	31 c3                	xor    %eax,%ebx
   2370e:	89 9d 04 ff ff ff    	mov    %ebx,0xffffff04(%ebp)
   23714:	89 59 70             	mov    %ebx,0x70(%ecx)
   23717:	8b 8d 30 ff ff ff    	mov    0xffffff30(%ebp),%ecx
   2371d:	8b bd 2c ff ff ff    	mov    0xffffff2c(%ebp),%edi
   23723:	8b 75 0c             	mov    0xc(%ebp),%esi
   23726:	31 d1                	xor    %edx,%ecx
   23728:	31 fb                	xor    %edi,%ebx
   2372a:	89 4d e8             	mov    %ecx,0xffffffe8(%ebp)
    kd6(cx->ks, 4);  kd6(cx->ks, 5);
   2372d:	0f b6 d5             	movzbl %ch,%edx
   23730:	89 c8                	mov    %ecx,%eax
   23732:	89 8d 00 ff ff ff    	mov    %ecx,0xffffff00(%ebp)
   23738:	c1 e8 10             	shr    $0x10,%eax
   2373b:	0f b6 c0             	movzbl %al,%eax
   2373e:	89 9d fc fe ff ff    	mov    %ebx,0xfffffefc(%ebp)
   23744:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   2374b:	89 5e 74             	mov    %ebx,0x74(%esi)
   2374e:	8b 34 95 00 00 00 00 	mov    0x0(,%edx,4),%esi
   23755:	89 ca                	mov    %ecx,%edx
   23757:	c1 ea 18             	shr    $0x18,%edx
   2375a:	8b 1c 95 00 08 00 00 	mov    0x800(,%edx,4),%ebx
   23761:	31 f0                	xor    %esi,%eax
   23763:	0f b6 55 e8          	movzbl 0xffffffe8(%ebp),%edx
   23767:	31 d8                	xor    %ebx,%eax
   23769:	8b bd 28 ff ff ff    	mov    0xffffff28(%ebp),%edi
   2376f:	8b 0c 95 00 0c 00 00 	mov    0xc00(,%edx,4),%ecx
   23776:	8b 15 10 00 00 00    	mov    0x10,%edx
   2377c:	31 c8                	xor    %ecx,%eax
   2377e:	31 d0                	xor    %edx,%eax
   23780:	0f b6 d4             	movzbl %ah,%edx
   23783:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   23786:	8b 14 95 00 04 00 00 	mov    0x400(,%edx,4),%edx
   2378d:	31 c7                	xor    %eax,%edi
   2378f:	0f b6 4d ec          	movzbl 0xffffffec(%ebp),%ecx
   23793:	c1 e8 10             	shr    $0x10,%eax
   23796:	89 bd f8 fe ff ff    	mov    %edi,0xfffffef8(%ebp)
   2379c:	8b 1c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%ebx
   237a3:	31 da                	xor    %ebx,%edx
   237a5:	89 95 f4 fe ff ff    	mov    %edx,0xfffffef4(%ebp)
   237ab:	0f b6 d0             	movzbl %al,%edx
   237ae:	c1 e8 08             	shr    $0x8,%eax
   237b1:	8b 34 95 00 08 00 00 	mov    0x800(,%edx,4),%esi
   237b8:	8b 3c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edi
   237bf:	8b 85 24 ff ff ff    	mov    0xffffff24(%ebp),%eax
   237c5:	31 b5 f4 fe ff ff    	xor    %esi,0xfffffef4(%ebp)
   237cb:	8b 55 0c             	mov    0xc(%ebp),%edx
   237ce:	31 bd f4 fe ff ff    	xor    %edi,0xfffffef4(%ebp)
   237d4:	31 85 f4 fe ff ff    	xor    %eax,0xfffffef4(%ebp)
   237da:	8b 8d f4 fe ff ff    	mov    0xfffffef4(%ebp),%ecx
   237e0:	89 4a 78             	mov    %ecx,0x78(%edx)
   237e3:	8b 85 f8 fe ff ff    	mov    0xfffffef8(%ebp),%eax
   237e9:	8b 9d 20 ff ff ff    	mov    0xffffff20(%ebp),%ebx
   237ef:	31 c3                	xor    %eax,%ebx
   237f1:	8b 85 1c ff ff ff    	mov    0xffffff1c(%ebp),%eax
   237f7:	89 9d f0 fe ff ff    	mov    %ebx,0xfffffef0(%ebp)
   237fd:	31 c1                	xor    %eax,%ecx
   237ff:	89 8d ec fe ff ff    	mov    %ecx,0xfffffeec(%ebp)
   23805:	89 4a 7c             	mov    %ecx,0x7c(%edx)
   23808:	8b bd 14 ff ff ff    	mov    0xffffff14(%ebp),%edi
   2380e:	8b b5 18 ff ff ff    	mov    0xffffff18(%ebp),%esi
   23814:	31 f9                	xor    %edi,%ecx
   23816:	31 de                	xor    %ebx,%esi
   23818:	89 b5 e8 fe ff ff    	mov    %esi,0xfffffee8(%ebp)
   2381e:	89 8d e4 fe ff ff    	mov    %ecx,0xfffffee4(%ebp)
   23824:	89 8a 80 00 00 00    	mov    %ecx,0x80(%edx)
   2382a:	8b bd 10 ff ff ff    	mov    0xffffff10(%ebp),%edi
   23830:	31 f7                	xor    %esi,%edi
   23832:	8b b5 0c ff ff ff    	mov    0xffffff0c(%ebp),%esi
   23838:	89 bd e0 fe ff ff    	mov    %edi,0xfffffee0(%ebp)
   2383e:	31 f1                	xor    %esi,%ecx
   23840:	89 8d dc fe ff ff    	mov    %ecx,0xfffffedc(%ebp)
   23846:	89 8a 84 00 00 00    	mov    %ecx,0x84(%edx)
   2384c:	8b 9d 04 ff ff ff    	mov    0xffffff04(%ebp),%ebx
   23852:	8b 85 08 ff ff ff    	mov    0xffffff08(%ebp),%eax
   23858:	31 d9                	xor    %ebx,%ecx
   2385a:	31 f8                	xor    %edi,%eax
   2385c:	89 85 d8 fe ff ff    	mov    %eax,0xfffffed8(%ebp)
   23862:	89 8d d4 fe ff ff    	mov    %ecx,0xfffffed4(%ebp)
   23868:	89 8a 88 00 00 00    	mov    %ecx,0x88(%edx)
   2386e:	8b bd fc fe ff ff    	mov    0xfffffefc(%ebp),%edi
   23874:	8b 95 00 ff ff ff    	mov    0xffffff00(%ebp),%edx
   2387a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   2387d:	31 f9                	xor    %edi,%ecx
   2387f:	31 c2                	xor    %eax,%edx
   23881:	89 95 d0 fe ff ff    	mov    %edx,0xfffffed0(%ebp)
   23887:	89 55 e8             	mov    %edx,0xffffffe8(%ebp)
   2388a:	89 8d cc fe ff ff    	mov    %ecx,0xfffffecc(%ebp)
   23890:	89 8b 8c 00 00 00    	mov    %ecx,0x8c(%ebx)
   23896:	8b 85 d0 fe ff ff    	mov    0xfffffed0(%ebp),%eax
   2389c:	0f b6 d4             	movzbl %ah,%edx
   2389f:	c1 e8 10             	shr    $0x10,%eax
   238a2:	8b 34 95 00 00 00 00 	mov    0x0(,%edx,4),%esi
   238a9:	8b 95 d0 fe ff ff    	mov    0xfffffed0(%ebp),%edx
   238af:	0f b6 c0             	movzbl %al,%eax
   238b2:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   238b9:	c1 ea 18             	shr    $0x18,%edx
   238bc:	8b 1c 95 00 08 00 00 	mov    0x800(,%edx,4),%ebx
   238c3:	31 f0                	xor    %esi,%eax
   238c5:	0f b6 55 e8          	movzbl 0xffffffe8(%ebp),%edx
   238c9:	31 d8                	xor    %ebx,%eax
   238cb:	8b 0c 95 00 0c 00 00 	mov    0xc00(,%edx,4),%ecx
   238d2:	8b 15 14 00 00 00    	mov    0x14,%edx
   238d8:	31 c8                	xor    %ecx,%eax
   238da:	31 d0                	xor    %edx,%eax
   238dc:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   238df:	8b 95 f8 fe ff ff    	mov    0xfffffef8(%ebp),%edx
   238e5:	0f b6 4d ec          	movzbl 0xffffffec(%ebp),%ecx
   238e9:	31 c2                	xor    %eax,%edx
   238eb:	89 95 c8 fe ff ff    	mov    %edx,0xfffffec8(%ebp)
   238f1:	0f b6 d4             	movzbl %ah,%edx
   238f4:	c1 e8 10             	shr    $0x10,%eax
   238f7:	8b 1c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%ebx
   238fe:	8b 14 95 00 04 00 00 	mov    0x400(,%edx,4),%edx
   23905:	31 da                	xor    %ebx,%edx
   23907:	89 95 c4 fe ff ff    	mov    %edx,0xfffffec4(%ebp)
   2390d:	0f b6 d0             	movzbl %al,%edx
   23910:	c1 e8 08             	shr    $0x8,%eax
   23913:	8b 34 95 00 08 00 00 	mov    0x800(,%edx,4),%esi
   2391a:	8b 3c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edi
   23921:	8b 85 f4 fe ff ff    	mov    0xfffffef4(%ebp),%eax
   23927:	31 b5 c4 fe ff ff    	xor    %esi,0xfffffec4(%ebp)
   2392d:	8b 55 0c             	mov    0xc(%ebp),%edx
   23930:	31 bd c4 fe ff ff    	xor    %edi,0xfffffec4(%ebp)
   23936:	31 85 c4 fe ff ff    	xor    %eax,0xfffffec4(%ebp)
   2393c:	8b 8d c4 fe ff ff    	mov    0xfffffec4(%ebp),%ecx
   23942:	89 8a 90 00 00 00    	mov    %ecx,0x90(%edx)
   23948:	8b 85 c8 fe ff ff    	mov    0xfffffec8(%ebp),%eax
   2394e:	8b 9d f0 fe ff ff    	mov    0xfffffef0(%ebp),%ebx
   23954:	31 c3                	xor    %eax,%ebx
   23956:	8b 85 ec fe ff ff    	mov    0xfffffeec(%ebp),%eax
   2395c:	89 9d c0 fe ff ff    	mov    %ebx,0xfffffec0(%ebp)
   23962:	31 c1                	xor    %eax,%ecx
   23964:	89 8d bc fe ff ff    	mov    %ecx,0xfffffebc(%ebp)
   2396a:	89 8a 94 00 00 00    	mov    %ecx,0x94(%edx)
   23970:	8b bd e4 fe ff ff    	mov    0xfffffee4(%ebp),%edi
   23976:	8b b5 e8 fe ff ff    	mov    0xfffffee8(%ebp),%esi
   2397c:	31 f9                	xor    %edi,%ecx
   2397e:	31 de                	xor    %ebx,%esi
   23980:	89 b5 b8 fe ff ff    	mov    %esi,0xfffffeb8(%ebp)
   23986:	89 8d b4 fe ff ff    	mov    %ecx,0xfffffeb4(%ebp)
   2398c:	89 8a 98 00 00 00    	mov    %ecx,0x98(%edx)
   23992:	8b bd e0 fe ff ff    	mov    0xfffffee0(%ebp),%edi
   23998:	31 f7                	xor    %esi,%edi
   2399a:	8b b5 dc fe ff ff    	mov    0xfffffedc(%ebp),%esi
   239a0:	89 bd b0 fe ff ff    	mov    %edi,0xfffffeb0(%ebp)
   239a6:	31 f1                	xor    %esi,%ecx
   239a8:	89 8d ac fe ff ff    	mov    %ecx,0xfffffeac(%ebp)
   239ae:	89 8a 9c 00 00 00    	mov    %ecx,0x9c(%edx)
   239b4:	8b 9d d4 fe ff ff    	mov    0xfffffed4(%ebp),%ebx
   239ba:	8b 85 d8 fe ff ff    	mov    0xfffffed8(%ebp),%eax
   239c0:	31 d9                	xor    %ebx,%ecx
   239c2:	31 f8                	xor    %edi,%eax
   239c4:	89 85 a8 fe ff ff    	mov    %eax,0xfffffea8(%ebp)
   239ca:	89 8d a4 fe ff ff    	mov    %ecx,0xfffffea4(%ebp)
   239d0:	89 8a a0 00 00 00    	mov    %ecx,0xa0(%edx)
   239d6:	8b 95 d0 fe ff ff    	mov    0xfffffed0(%ebp),%edx
   239dc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   239df:	31 c2                	xor    %eax,%edx
   239e1:	8b 85 cc fe ff ff    	mov    0xfffffecc(%ebp),%eax
   239e7:	89 95 a0 fe ff ff    	mov    %edx,0xfffffea0(%ebp)
   239ed:	89 55 e8             	mov    %edx,0xffffffe8(%ebp)
   239f0:	31 c1                	xor    %eax,%ecx
    kd6(cx->ks, 6); kdl6(cx->ks, 7);
   239f2:	89 d0                	mov    %edx,%eax
   239f4:	89 8d 9c fe ff ff    	mov    %ecx,0xfffffe9c(%ebp)
   239fa:	c1 e8 10             	shr    $0x10,%eax
   239fd:	0f b6 c0             	movzbl %al,%eax
   23a00:	89 8b a4 00 00 00    	mov    %ecx,0xa4(%ebx)
   23a06:	0f b6 ce             	movzbl %dh,%ecx
   23a09:	8b 14 85 00 04 00 00 	mov    0x400(,%eax,4),%edx
   23a10:	8b 85 a0 fe ff ff    	mov    0xfffffea0(%ebp),%eax
   23a16:	8b 3c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%edi
   23a1d:	c1 e8 18             	shr    $0x18,%eax
   23a20:	8b 34 85 00 08 00 00 	mov    0x800(,%eax,4),%esi
   23a27:	31 fa                	xor    %edi,%edx
   23a29:	0f b6 45 e8          	movzbl 0xffffffe8(%ebp),%eax
   23a2d:	31 f2                	xor    %esi,%edx
   23a2f:	8b b5 c8 fe ff ff    	mov    0xfffffec8(%ebp),%esi
   23a35:	8b 0c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ecx
   23a3c:	a1 18 00 00 00       	mov    0x18,%eax
   23a41:	31 ca                	xor    %ecx,%edx
   23a43:	31 c2                	xor    %eax,%edx
   23a45:	0f b6 c6             	movzbl %dh,%eax
   23a48:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
   23a4b:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   23a52:	31 d6                	xor    %edx,%esi
   23a54:	0f b6 4d ec          	movzbl 0xffffffec(%ebp),%ecx
   23a58:	c1 ea 10             	shr    $0x10,%edx
   23a5b:	89 b5 98 fe ff ff    	mov    %esi,0xfffffe98(%ebp)
   23a61:	8b 3c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%edi
   23a68:	0f b6 ca             	movzbl %dl,%ecx
   23a6b:	c1 ea 08             	shr    $0x8,%edx
   23a6e:	31 f8                	xor    %edi,%eax
   23a70:	8b 3c 8d 00 08 00 00 	mov    0x800(,%ecx,4),%edi
   23a77:	8b 0c 95 00 0c 00 00 	mov    0xc00(,%edx,4),%ecx
   23a7e:	31 f8                	xor    %edi,%eax
   23a80:	8b bd c4 fe ff ff    	mov    0xfffffec4(%ebp),%edi
   23a86:	31 c8                	xor    %ecx,%eax
   23a88:	31 f8                	xor    %edi,%eax
   23a8a:	89 83 a8 00 00 00    	mov    %eax,0xa8(%ebx)
   23a90:	8b bd c0 fe ff ff    	mov    0xfffffec0(%ebp),%edi
   23a96:	31 f7                	xor    %esi,%edi
   23a98:	8b b5 bc fe ff ff    	mov    0xfffffebc(%ebp),%esi
   23a9e:	31 f0                	xor    %esi,%eax
   23aa0:	89 83 ac 00 00 00    	mov    %eax,0xac(%ebx)
   23aa6:	8b 95 b8 fe ff ff    	mov    0xfffffeb8(%ebp),%edx
   23aac:	31 fa                	xor    %edi,%edx
   23aae:	89 95 90 fe ff ff    	mov    %edx,0xfffffe90(%ebp)
   23ab4:	8b 8d b4 fe ff ff    	mov    0xfffffeb4(%ebp),%ecx
   23aba:	31 c8                	xor    %ecx,%eax
   23abc:	89 83 b0 00 00 00    	mov    %eax,0xb0(%ebx)
   23ac2:	8b 9d b0 fe ff ff    	mov    0xfffffeb0(%ebp),%ebx
   23ac8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   23acb:	31 d3                	xor    %edx,%ebx
   23acd:	8b 95 ac fe ff ff    	mov    0xfffffeac(%ebp),%edx
   23ad3:	31 d0                	xor    %edx,%eax
   23ad5:	89 81 b4 00 00 00    	mov    %eax,0xb4(%ecx)
   23adb:	8b b5 a4 fe ff ff    	mov    0xfffffea4(%ebp),%esi
   23ae1:	8b 8d a8 fe ff ff    	mov    0xfffffea8(%ebp),%ecx
   23ae7:	31 f0                	xor    %esi,%eax
   23ae9:	8b 75 0c             	mov    0xc(%ebp),%esi
   23aec:	31 d9                	xor    %ebx,%ecx
   23aee:	89 86 b8 00 00 00    	mov    %eax,0xb8(%esi)
   23af4:	8b 95 a0 fe ff ff    	mov    0xfffffea0(%ebp),%edx
   23afa:	31 d1                	xor    %edx,%ecx
   23afc:	8b 95 9c fe ff ff    	mov    0xfffffe9c(%ebp),%edx
   23b02:	89 4d e8             	mov    %ecx,0xffffffe8(%ebp)
   23b05:	31 d0                	xor    %edx,%eax
   23b07:	0f b6 d5             	movzbl %ch,%edx
   23b0a:	89 86 bc 00 00 00    	mov    %eax,0xbc(%esi)
   23b10:	c1 e9 10             	shr    $0x10,%ecx
   23b13:	0f b6 c1             	movzbl %cl,%eax
   23b16:	c1 e9 08             	shr    $0x8,%ecx
   23b19:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   23b20:	33 04 95 00 00 00 00 	xor    0x0(,%edx,4),%eax
   23b27:	8b 14 8d 00 08 00 00 	mov    0x800(,%ecx,4),%edx
   23b2e:	31 d0                	xor    %edx,%eax
   23b30:	0f b6 55 e8          	movzbl 0xffffffe8(%ebp),%edx
   23b34:	8b 0c 95 00 0c 00 00 	mov    0xc00(,%edx,4),%ecx
   23b3b:	8b 15 1c 00 00 00    	mov    0x1c,%edx
   23b41:	31 c8                	xor    %ecx,%eax
   23b43:	8b 8d 98 fe ff ff    	mov    0xfffffe98(%ebp),%ecx
   23b49:	31 d0                	xor    %edx,%eax
   23b4b:	31 c8                	xor    %ecx,%eax
   23b4d:	89 86 c0 00 00 00    	mov    %eax,0xc0(%esi)
   23b53:	31 f8                	xor    %edi,%eax
#endif
    cx->rn = 12;
   23b55:	bf 0c 00 00 00       	mov    $0xc,%edi
   23b5a:	89 86 c4 00 00 00    	mov    %eax,0xc4(%esi)
   23b60:	8b 95 90 fe ff ff    	mov    0xfffffe90(%ebp),%edx
   23b66:	89 be f0 00 00 00    	mov    %edi,0xf0(%esi)
   23b6c:	31 d0                	xor    %edx,%eax
   23b6e:	31 c3                	xor    %eax,%ebx
   23b70:	89 86 c8 00 00 00    	mov    %eax,0xc8(%esi)
#if defined( AES_ERR_CHK )
    return aes_good;
#endif
}
   23b76:	31 c0                	xor    %eax,%eax
   23b78:	89 9e cc 00 00 00    	mov    %ebx,0xcc(%esi)
   23b7e:	81 c4 64 01 00 00    	add    $0x164,%esp
   23b84:	5b                   	pop    %ebx
   23b85:	5e                   	pop    %esi
   23b86:	5f                   	pop    %edi
   23b87:	5d                   	pop    %ebp
   23b88:	c3                   	ret    
   23b89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,1),%esi

00023b90 <aes_decrypt_key256>:

#endif

#if defined(AES_256) || defined(AES_VAR)

aes_rval aes_decrypt_key256(const unsigned char *key, aes_decrypt_ctx cx[1])
{   aes_32t    ss[8];
   23b90:	55                   	push   %ebp
   23b91:	89 e5                	mov    %esp,%ebp
   23b93:	57                   	push   %edi
   23b94:	56                   	push   %esi
   23b95:	53                   	push   %ebx
   23b96:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
#if defined( d_vars )
        d_vars;
#endif
    cx->ks[0] = ss[0] = word_in(key, 0);
   23b9c:	8b 45 08             	mov    0x8(%ebp),%eax
   23b9f:	8b 55 08             	mov    0x8(%ebp),%edx
   23ba2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   23ba5:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   23ba9:	c1 e0 18             	shl    $0x18,%eax
   23bac:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
   23baf:	0f b6 42 02          	movzbl 0x2(%edx),%eax
   23bb3:	c1 e0 10             	shl    $0x10,%eax
   23bb6:	09 45 d0             	or     %eax,0xffffffd0(%ebp)
   23bb9:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   23bbd:	c1 e0 08             	shl    $0x8,%eax
   23bc0:	09 45 d0             	or     %eax,0xffffffd0(%ebp)
   23bc3:	0f b6 02             	movzbl (%edx),%eax
   23bc6:	09 45 d0             	or     %eax,0xffffffd0(%ebp)
   23bc9:	8b 5d d0             	mov    0xffffffd0(%ebp),%ebx
   23bcc:	89 19                	mov    %ebx,(%ecx)
    cx->ks[1] = ss[1] = word_in(key, 1);
   23bce:	0f b6 42 07          	movzbl 0x7(%edx),%eax
   23bd2:	c1 e0 18             	shl    $0x18,%eax
   23bd5:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
   23bd8:	0f b6 42 06          	movzbl 0x6(%edx),%eax
   23bdc:	c1 e0 10             	shl    $0x10,%eax
   23bdf:	09 45 cc             	or     %eax,0xffffffcc(%ebp)
   23be2:	0f b6 42 05          	movzbl 0x5(%edx),%eax
   23be6:	c1 e0 08             	shl    $0x8,%eax
   23be9:	09 45 cc             	or     %eax,0xffffffcc(%ebp)
   23bec:	0f b6 42 04          	movzbl 0x4(%edx),%eax
   23bf0:	09 45 cc             	or     %eax,0xffffffcc(%ebp)
   23bf3:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
   23bf6:	89 51 04             	mov    %edx,0x4(%ecx)
    cx->ks[2] = ss[2] = word_in(key, 2);
   23bf9:	8b 5d 08             	mov    0x8(%ebp),%ebx
   23bfc:	8b 4d 08             	mov    0x8(%ebp),%ecx
   23bff:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
   23c03:	0f b6 49 0b          	movzbl 0xb(%ecx),%ecx
   23c07:	c1 e0 10             	shl    $0x10,%eax
   23c0a:	c1 e1 18             	shl    $0x18,%ecx
   23c0d:	09 c1                	or     %eax,%ecx
   23c0f:	0f b6 43 09          	movzbl 0x9(%ebx),%eax
   23c13:	c1 e0 08             	shl    $0x8,%eax
   23c16:	09 c1                	or     %eax,%ecx
   23c18:	0f b6 43 08          	movzbl 0x8(%ebx),%eax
   23c1c:	09 c1                	or     %eax,%ecx
   23c1e:	8b 45 0c             	mov    0xc(%ebp),%eax
   23c21:	89 4d c8             	mov    %ecx,0xffffffc8(%ebp)
   23c24:	89 48 08             	mov    %ecx,0x8(%eax)
    cx->ks[3] = ss[3] = word_in(key, 3);
   23c27:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   23c2a:	0f b6 53 0f          	movzbl 0xf(%ebx),%edx
   23c2e:	0f b6 43 0e          	movzbl 0xe(%ebx),%eax
   23c32:	c1 e2 18             	shl    $0x18,%edx
   23c35:	c1 e0 10             	shl    $0x10,%eax
   23c38:	09 c2                	or     %eax,%edx
   23c3a:	0f b6 43 0d          	movzbl 0xd(%ebx),%eax
   23c3e:	c1 e0 08             	shl    $0x8,%eax
   23c41:	09 c2                	or     %eax,%edx
   23c43:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
   23c47:	09 c2                	or     %eax,%edx
   23c49:	89 55 c4             	mov    %edx,0xffffffc4(%ebp)
   23c4c:	89 51 0c             	mov    %edx,0xc(%ecx)

#if DEC_UNROLL == NONE
    cx->ks[4] = ss[4] = word_in(key, 4);
    cx->ks[5] = ss[5] = word_in(key, 5);
    cx->ks[6] = ss[6] = word_in(key, 6);
    cx->ks[7] = ss[7] = word_in(key, 7);
    {   aes_32t i;

        for(i = 0; i < (15 * N_COLS - 9) / 8; ++i)
            ke8(cx->ks,  i);
        kel8(cx->ks,  i);
#if !(DEC_ROUND == NO_TABLES)
        for(i = N_COLS; i < 14 * N_COLS; ++i)
            cx->ks[i] = inv_mcol(cx->ks[i]);

#endif
    }
#else
    cx->ks[4] = ff(ss[4] = word_in(key, 4));
   23c4f:	8b 55 08             	mov    0x8(%ebp),%edx
   23c52:	0f b6 5b 13          	movzbl 0x13(%ebx),%ebx
   23c56:	0f b6 42 12          	movzbl 0x12(%edx),%eax
   23c5a:	c1 e3 18             	shl    $0x18,%ebx
   23c5d:	c1 e0 10             	shl    $0x10,%eax
   23c60:	09 c3                	or     %eax,%ebx
   23c62:	0f b6 42 11          	movzbl 0x11(%edx),%eax
   23c66:	c1 e0 08             	shl    $0x8,%eax
   23c69:	09 c3                	or     %eax,%ebx
   23c6b:	0f b6 42 10          	movzbl 0x10(%edx),%eax
   23c6f:	09 c3                	or     %eax,%ebx
   23c71:	0f b6 cb             	movzbl %bl,%ecx
   23c74:	89 5d c0             	mov    %ebx,0xffffffc0(%ebp)
   23c77:	0f b6 c7             	movzbl %bh,%eax
   23c7a:	bb 00 00 00 00       	mov    $0x0,%ebx
   23c7f:	8b 1c 8b             	mov    (%ebx,%ecx,4),%ebx
   23c82:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   23c89:	31 d8                	xor    %ebx,%eax
   23c8b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   23c8e:	89 45 b8             	mov    %eax,0xffffffb8(%ebp)
   23c91:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
   23c94:	c1 e8 10             	shr    $0x10,%eax
   23c97:	0f b6 c0             	movzbl %al,%eax
   23c9a:	8b 14 85 00 08 00 00 	mov    0x800(,%eax,4),%edx
   23ca1:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
   23ca4:	31 55 b8             	xor    %edx,0xffffffb8(%ebp)
   23ca7:	c1 e8 18             	shr    $0x18,%eax
   23caa:	8b 0c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ecx
   23cb1:	31 4d b8             	xor    %ecx,0xffffffb8(%ebp)
   23cb4:	8b 45 b8             	mov    0xffffffb8(%ebp),%eax
   23cb7:	89 43 10             	mov    %eax,0x10(%ebx)
    cx->ks[5] = ff(ss[5] = word_in(key, 5));
   23cba:	8b 4d 08             	mov    0x8(%ebp),%ecx
   23cbd:	8b 55 08             	mov    0x8(%ebp),%edx
   23cc0:	0f b6 41 16          	movzbl 0x16(%ecx),%eax
   23cc4:	0f b6 52 17          	movzbl 0x17(%edx),%edx
   23cc8:	c1 e0 10             	shl    $0x10,%eax
   23ccb:	c1 e2 18             	shl    $0x18,%edx
   23cce:	09 c2                	or     %eax,%edx
   23cd0:	0f b6 41 15          	movzbl 0x15(%ecx),%eax
   23cd4:	c1 e0 08             	shl    $0x8,%eax
   23cd7:	09 c2                	or     %eax,%edx
   23cd9:	0f b6 41 14          	movzbl 0x14(%ecx),%eax
   23cdd:	09 c2                	or     %eax,%edx
   23cdf:	89 55 b4             	mov    %edx,0xffffffb4(%ebp)
   23ce2:	8b 5d b4             	mov    0xffffffb4(%ebp),%ebx
   23ce5:	0f b6 55 b4          	movzbl 0xffffffb4(%ebp),%edx
   23ce9:	0f b6 c7             	movzbl %bh,%eax
   23cec:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   23cf3:	8b 0c 95 00 00 00 00 	mov    0x0(,%edx,4),%ecx
   23cfa:	31 c8                	xor    %ecx,%eax
   23cfc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   23cff:	89 45 b0             	mov    %eax,0xffffffb0(%ebp)
   23d02:	89 d8                	mov    %ebx,%eax
   23d04:	c1 e8 10             	shr    $0x10,%eax
   23d07:	0f b6 c0             	movzbl %al,%eax
   23d0a:	8b 1c 85 00 08 00 00 	mov    0x800(,%eax,4),%ebx
   23d11:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
   23d14:	31 5d b0             	xor    %ebx,0xffffffb0(%ebp)
   23d17:	c1 e8 18             	shr    $0x18,%eax
   23d1a:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   23d21:	31 55 b0             	xor    %edx,0xffffffb0(%ebp)
   23d24:	8b 5d b0             	mov    0xffffffb0(%ebp),%ebx
   23d27:	89 59 14             	mov    %ebx,0x14(%ecx)
    cx->ks[6] = ff(ss[6] = word_in(key, 6));
   23d2a:	8b 45 08             	mov    0x8(%ebp),%eax
   23d2d:	8b 55 08             	mov    0x8(%ebp),%edx
   23d30:	0f b6 40 1b          	movzbl 0x1b(%eax),%eax
   23d34:	c1 e0 18             	shl    $0x18,%eax
   23d37:	89 45 ac             	mov    %eax,0xffffffac(%ebp)
   23d3a:	0f b6 42 1a          	movzbl 0x1a(%edx),%eax
   23d3e:	c1 e0 10             	shl    $0x10,%eax
   23d41:	09 45 ac             	or     %eax,0xffffffac(%ebp)
   23d44:	0f b6 42 19          	movzbl 0x19(%edx),%eax
   23d48:	c1 e0 08             	shl    $0x8,%eax
   23d4b:	09 45 ac             	or     %eax,0xffffffac(%ebp)
   23d4e:	0f b6 42 18          	movzbl 0x18(%edx),%eax
   23d52:	ba 00 00 00 00       	mov    $0x0,%edx
   23d57:	09 45 ac             	or     %eax,0xffffffac(%ebp)
   23d5a:	8b 5d ac             	mov    0xffffffac(%ebp),%ebx
   23d5d:	0f b6 4d ac          	movzbl 0xffffffac(%ebp),%ecx
   23d61:	0f b6 c7             	movzbl %bh,%eax
   23d64:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   23d6b:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
   23d6e:	31 d0                	xor    %edx,%eax
   23d70:	89 45 a4             	mov    %eax,0xffffffa4(%ebp)
   23d73:	89 d8                	mov    %ebx,%eax
   23d75:	c1 e8 10             	shr    $0x10,%eax
   23d78:	0f b6 c0             	movzbl %al,%eax
   23d7b:	8b 0c 85 00 08 00 00 	mov    0x800(,%eax,4),%ecx
   23d82:	89 d8                	mov    %ebx,%eax
   23d84:	31 4d a4             	xor    %ecx,0xffffffa4(%ebp)
   23d87:	c1 e8 18             	shr    $0x18,%eax
   23d8a:	8b 1c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ebx
   23d91:	31 5d a4             	xor    %ebx,0xffffffa4(%ebp)
   23d94:	8b 45 0c             	mov    0xc(%ebp),%eax
   23d97:	8b 55 a4             	mov    0xffffffa4(%ebp),%edx
   23d9a:	89 50 18             	mov    %edx,0x18(%eax)
    cx->ks[7] = ff(ss[7] = word_in(key, 7));
   23d9d:	8b 5d 08             	mov    0x8(%ebp),%ebx
   23da0:	8b 4d 08             	mov    0x8(%ebp),%ecx
   23da3:	0f b6 43 1e          	movzbl 0x1e(%ebx),%eax
   23da7:	0f b6 49 1f          	movzbl 0x1f(%ecx),%ecx
   23dab:	c1 e0 10             	shl    $0x10,%eax
   23dae:	c1 e1 18             	shl    $0x18,%ecx
   23db1:	09 c1                	or     %eax,%ecx
   23db3:	0f b6 43 1d          	movzbl 0x1d(%ebx),%eax
   23db7:	c1 e0 08             	shl    $0x8,%eax
   23dba:	09 c1                	or     %eax,%ecx
   23dbc:	0f b6 43 1c          	movzbl 0x1c(%ebx),%eax
   23dc0:	bb 00 00 00 00       	mov    $0x0,%ebx
   23dc5:	09 c1                	or     %eax,%ecx
   23dc7:	89 4d a0             	mov    %ecx,0xffffffa0(%ebp)
   23dca:	8b 45 a0             	mov    0xffffffa0(%ebp),%eax
   23dcd:	8b 55 a0             	mov    0xffffffa0(%ebp),%edx
   23dd0:	0f b6 4d a0          	movzbl 0xffffffa0(%ebp),%ecx
   23dd4:	0f b6 c4             	movzbl %ah,%eax
   23dd7:	c1 ea 10             	shr    $0x10,%edx
   23dda:	89 45 9c             	mov    %eax,0xffffff9c(%ebp)
   23ddd:	8b 84 83 00 04 00 00 	mov    0x400(%ebx,%eax,4),%eax
   23de4:	8b 3c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%edi
   23deb:	0f b6 ca             	movzbl %dl,%ecx
   23dee:	ba 00 00 00 00       	mov    $0x0,%edx
   23df3:	8b b4 8b 00 08 00 00 	mov    0x800(%ebx,%ecx,4),%esi
   23dfa:	89 4d 94             	mov    %ecx,0xffffff94(%ebp)
   23dfd:	8b 5d a0             	mov    0xffffffa0(%ebp),%ebx
   23e00:	31 f8                	xor    %edi,%eax
   23e02:	31 f0                	xor    %esi,%eax
   23e04:	89 5d f0             	mov    %ebx,0xfffffff0(%ebp)
   23e07:	c1 eb 18             	shr    $0x18,%ebx
   23e0a:	8b 8c 9a 00 0c 00 00 	mov    0xc00(%edx,%ebx,4),%ecx
   23e11:	89 5d 90             	mov    %ebx,0xffffff90(%ebp)
   23e14:	31 c8                	xor    %ecx,%eax
   23e16:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   23e19:	89 41 1c             	mov    %eax,0x1c(%ecx)
    kdf8(cx->ks, 0); kd8(cx->ks, 1);
   23e1c:	8b 5d 94             	mov    0xffffff94(%ebp),%ebx
   23e1f:	b8 00 00 00 00       	mov    $0x0,%eax
   23e24:	8b 55 9c             	mov    0xffffff9c(%ebp),%edx
   23e27:	8b 4d 90             	mov    0xffffff90(%ebp),%ecx
   23e2a:	8b 9c 98 00 04 00 00 	mov    0x400(%eax,%ebx,4),%ebx
   23e31:	8b 14 90             	mov    (%eax,%edx,4),%edx
   23e34:	8b 8c 88 00 08 00 00 	mov    0x800(%eax,%ecx,4),%ecx
   23e3b:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
   23e3f:	31 d3                	xor    %edx,%ebx
   23e41:	31 cb                	xor    %ecx,%ebx
   23e43:	8b 0d 00 00 00 00    	mov    0x0,%ecx
   23e49:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   23e50:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
   23e53:	31 d3                	xor    %edx,%ebx
   23e55:	31 cb                	xor    %ecx,%ebx
   23e57:	31 c3                	xor    %eax,%ebx
   23e59:	89 5d d4             	mov    %ebx,0xffffffd4(%ebp)
   23e5c:	0f b6 c7             	movzbl %bh,%eax
   23e5f:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   23e66:	0f b6 4d d4          	movzbl 0xffffffd4(%ebp),%ecx
   23e6a:	89 5d 8c             	mov    %ebx,0xffffff8c(%ebp)
   23e6d:	8b 14 8d 00 00 00 00 	mov    0x0(,%ecx,4),%edx
   23e74:	31 d0                	xor    %edx,%eax
   23e76:	89 45 88             	mov    %eax,0xffffff88(%ebp)
   23e79:	89 d8                	mov    %ebx,%eax
   23e7b:	c1 e8 10             	shr    $0x10,%eax
   23e7e:	0f b6 c0             	movzbl %al,%eax
   23e81:	8b 0c 85 00 08 00 00 	mov    0x800(,%eax,4),%ecx
   23e88:	89 d8                	mov    %ebx,%eax
   23e8a:	31 4d 88             	xor    %ecx,0xffffff88(%ebp)
   23e8d:	c1 e8 18             	shr    $0x18,%eax
   23e90:	8b 1c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ebx
   23e97:	31 5d 88             	xor    %ebx,0xffffff88(%ebp)
   23e9a:	8b 45 0c             	mov    0xc(%ebp),%eax
   23e9d:	8b 55 88             	mov    0xffffff88(%ebp),%edx
   23ea0:	89 50 20             	mov    %edx,0x20(%eax)
   23ea3:	8b 45 8c             	mov    0xffffff8c(%ebp),%eax
   23ea6:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
   23ea9:	31 c1                	xor    %eax,%ecx
   23eab:	89 4d 84             	mov    %ecx,0xffffff84(%ebp)
   23eae:	8b 5d 84             	mov    0xffffff84(%ebp),%ebx
   23eb1:	89 4d d8             	mov    %ecx,0xffffffd8(%ebp)
   23eb4:	0f b6 4d d8          	movzbl 0xffffffd8(%ebp),%ecx
   23eb8:	0f b6 c7             	movzbl %bh,%eax
   23ebb:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   23ec2:	8b 14 8d 00 00 00 00 	mov    0x0(,%ecx,4),%edx
   23ec9:	31 d0                	xor    %edx,%eax
   23ecb:	89 45 80             	mov    %eax,0xffffff80(%ebp)
   23ece:	89 d8                	mov    %ebx,%eax
   23ed0:	c1 e8 10             	shr    $0x10,%eax
   23ed3:	0f b6 c0             	movzbl %al,%eax
   23ed6:	8b 0c 85 00 08 00 00 	mov    0x800(,%eax,4),%ecx
   23edd:	89 d8                	mov    %ebx,%eax
   23edf:	31 4d 80             	xor    %ecx,0xffffff80(%ebp)
   23ee2:	c1 e8 18             	shr    $0x18,%eax
   23ee5:	8b 1c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ebx
   23eec:	31 5d 80             	xor    %ebx,0xffffff80(%ebp)
   23eef:	8b 45 0c             	mov    0xc(%ebp),%eax
   23ef2:	8b 55 80             	mov    0xffffff80(%ebp),%edx
   23ef5:	89 50 24             	mov    %edx,0x24(%eax)
   23ef8:	8b 45 84             	mov    0xffffff84(%ebp),%eax
   23efb:	8b 4d c8             	mov    0xffffffc8(%ebp),%ecx
   23efe:	31 c1                	xor    %eax,%ecx
   23f00:	89 8d 7c ff ff ff    	mov    %ecx,0xffffff7c(%ebp)
   23f06:	8b 9d 7c ff ff ff    	mov    0xffffff7c(%ebp),%ebx
   23f0c:	89 4d dc             	mov    %ecx,0xffffffdc(%ebp)
   23f0f:	0f b6 4d dc          	movzbl 0xffffffdc(%ebp),%ecx
   23f13:	0f b6 c7             	movzbl %bh,%eax
   23f16:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   23f1d:	8b 14 8d 00 00 00 00 	mov    0x0(,%ecx,4),%edx
   23f24:	31 d0                	xor    %edx,%eax
   23f26:	89 85 78 ff ff ff    	mov    %eax,0xffffff78(%ebp)
   23f2c:	89 d8                	mov    %ebx,%eax
   23f2e:	c1 e8 10             	shr    $0x10,%eax
   23f31:	0f b6 c0             	movzbl %al,%eax
   23f34:	8b 0c 85 00 08 00 00 	mov    0x800(,%eax,4),%ecx
   23f3b:	89 d8                	mov    %ebx,%eax
   23f3d:	31 8d 78 ff ff ff    	xor    %ecx,0xffffff78(%ebp)
   23f43:	c1 e8 18             	shr    $0x18,%eax
   23f46:	8b 1c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ebx
   23f4d:	31 9d 78 ff ff ff    	xor    %ebx,0xffffff78(%ebp)
   23f53:	8b 45 0c             	mov    0xc(%ebp),%eax
   23f56:	8b 95 78 ff ff ff    	mov    0xffffff78(%ebp),%edx
   23f5c:	89 50 28             	mov    %edx,0x28(%eax)
   23f5f:	ba 00 00 00 00       	mov    $0x0,%edx
   23f64:	8b 85 7c ff ff ff    	mov    0xffffff7c(%ebp),%eax
   23f6a:	8b 4d c4             	mov    0xffffffc4(%ebp),%ecx
   23f6d:	31 c1                	xor    %eax,%ecx
   23f6f:	0f b6 c5             	movzbl %ch,%eax
   23f72:	89 4d e0             	mov    %ecx,0xffffffe0(%ebp)
   23f75:	0f b6 5d e0          	movzbl 0xffffffe0(%ebp),%ebx
   23f79:	89 8d 74 ff ff ff    	mov    %ecx,0xffffff74(%ebp)
   23f7f:	b9 00 00 00 00       	mov    $0x0,%ecx
   23f84:	89 9d 70 ff ff ff    	mov    %ebx,0xffffff70(%ebp)
   23f8a:	89 85 6c ff ff ff    	mov    %eax,0xffffff6c(%ebp)
   23f90:	8b 94 82 00 04 00 00 	mov    0x400(%edx,%eax,4),%edx
   23f97:	8b 85 74 ff ff ff    	mov    0xffffff74(%ebp),%eax
   23f9d:	8b 0c 99             	mov    (%ecx,%ebx,4),%ecx
   23fa0:	c1 e8 10             	shr    $0x10,%eax
   23fa3:	0f b6 c0             	movzbl %al,%eax
   23fa6:	8b 1c 85 00 08 00 00 	mov    0x800(,%eax,4),%ebx
   23fad:	31 ca                	xor    %ecx,%edx
   23faf:	b9 00 00 00 00       	mov    $0x0,%ecx
   23fb4:	31 da                	xor    %ebx,%edx
   23fb6:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   23fb9:	89 95 64 ff ff ff    	mov    %edx,0xffffff64(%ebp)
   23fbf:	8b 95 74 ff ff ff    	mov    0xffffff74(%ebp),%edx
   23fc5:	c1 ea 18             	shr    $0x18,%edx
   23fc8:	89 95 68 ff ff ff    	mov    %edx,0xffffff68(%ebp)
   23fce:	8b 8c 91 00 0c 00 00 	mov    0xc00(%ecx,%edx,4),%ecx
   23fd5:	31 8d 64 ff ff ff    	xor    %ecx,0xffffff64(%ebp)
   23fdb:	8b 95 64 ff ff ff    	mov    0xffffff64(%ebp),%edx
   23fe1:	89 53 2c             	mov    %edx,0x2c(%ebx)
   23fe4:	bb 00 00 00 00       	mov    $0x0,%ebx
   23fe9:	8b 8d 6c ff ff ff    	mov    0xffffff6c(%ebp),%ecx
   23fef:	8b 95 70 ff ff ff    	mov    0xffffff70(%ebp),%edx
   23ff5:	8b 8c 8b 00 04 00 00 	mov    0x400(%ebx,%ecx,4),%ecx
   23ffc:	8b 14 93             	mov    (%ebx,%edx,4),%edx
   23fff:	8b 1c 85 00 08 00 00 	mov    0x800(,%eax,4),%ebx
   24006:	8b 85 68 ff ff ff    	mov    0xffffff68(%ebp),%eax
   2400c:	31 d1                	xor    %edx,%ecx
   2400e:	ba 00 00 00 00       	mov    $0x0,%edx
   24013:	31 d9                	xor    %ebx,%ecx
   24015:	8b 84 82 00 0c 00 00 	mov    0xc00(%edx,%eax,4),%eax
   2401c:	8b 55 c0             	mov    0xffffffc0(%ebp),%edx
   2401f:	31 c1                	xor    %eax,%ecx
   24021:	31 d1                	xor    %edx,%ecx
   24023:	89 8d 60 ff ff ff    	mov    %ecx,0xffffff60(%ebp)
   24029:	8b 9d 60 ff ff ff    	mov    0xffffff60(%ebp),%ebx
   2402f:	89 4d e4             	mov    %ecx,0xffffffe4(%ebp)
   24032:	0f b6 4d e4          	movzbl 0xffffffe4(%ebp),%ecx
   24036:	0f b6 c7             	movzbl %bh,%eax
   24039:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   24040:	8b 14 8d 00 00 00 00 	mov    0x0(,%ecx,4),%edx
   24047:	31 d0                	xor    %edx,%eax
   24049:	89 85 5c ff ff ff    	mov    %eax,0xffffff5c(%ebp)
   2404f:	89 d8                	mov    %ebx,%eax
   24051:	c1 e8 10             	shr    $0x10,%eax
   24054:	0f b6 c0             	movzbl %al,%eax
   24057:	8b 0c 85 00 08 00 00 	mov    0x800(,%eax,4),%ecx
   2405e:	89 d8                	mov    %ebx,%eax
   24060:	31 8d 5c ff ff ff    	xor    %ecx,0xffffff5c(%ebp)
   24066:	c1 e8 18             	shr    $0x18,%eax
   24069:	8b 1c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ebx
   24070:	31 9d 5c ff ff ff    	xor    %ebx,0xffffff5c(%ebp)
   24076:	8b 45 0c             	mov    0xc(%ebp),%eax
   24079:	8b 95 5c ff ff ff    	mov    0xffffff5c(%ebp),%edx
   2407f:	89 50 30             	mov    %edx,0x30(%eax)
   24082:	8b bd 60 ff ff ff    	mov    0xffffff60(%ebp),%edi
   24088:	8b 4d b4             	mov    0xffffffb4(%ebp),%ecx
   2408b:	31 f9                	xor    %edi,%ecx
   2408d:	89 8d 58 ff ff ff    	mov    %ecx,0xffffff58(%ebp)
   24093:	8b 9d 58 ff ff ff    	mov    0xffffff58(%ebp),%ebx
   24099:	89 4d e8             	mov    %ecx,0xffffffe8(%ebp)
   2409c:	0f b6 4d e8          	movzbl 0xffffffe8(%ebp),%ecx
   240a0:	0f b6 c7             	movzbl %bh,%eax
   240a3:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   240aa:	8b 14 8d 00 00 00 00 	mov    0x0(,%ecx,4),%edx
   240b1:	31 d0                	xor    %edx,%eax
   240b3:	89 85 54 ff ff ff    	mov    %eax,0xffffff54(%ebp)
   240b9:	89 d8                	mov    %ebx,%eax
   240bb:	c1 e8 10             	shr    $0x10,%eax
   240be:	0f b6 c0             	movzbl %al,%eax
   240c1:	8b 0c 85 00 08 00 00 	mov    0x800(,%eax,4),%ecx
   240c8:	89 d8                	mov    %ebx,%eax
   240ca:	31 8d 54 ff ff ff    	xor    %ecx,0xffffff54(%ebp)
   240d0:	c1 e8 18             	shr    $0x18,%eax
   240d3:	8b 1c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ebx
   240da:	31 9d 54 ff ff ff    	xor    %ebx,0xffffff54(%ebp)
   240e0:	8b 45 0c             	mov    0xc(%ebp),%eax
   240e3:	8b 95 54 ff ff ff    	mov    0xffffff54(%ebp),%edx
   240e9:	89 50 34             	mov    %edx,0x34(%eax)
   240ec:	8b b5 58 ff ff ff    	mov    0xffffff58(%ebp),%esi
   240f2:	8b 4d ac             	mov    0xffffffac(%ebp),%ecx
   240f5:	31 f1                	xor    %esi,%ecx
   240f7:	89 8d 50 ff ff ff    	mov    %ecx,0xffffff50(%ebp)
   240fd:	8b 9d 50 ff ff ff    	mov    0xffffff50(%ebp),%ebx
   24103:	89 4d ec             	mov    %ecx,0xffffffec(%ebp)
   24106:	0f b6 4d ec          	movzbl 0xffffffec(%ebp),%ecx
   2410a:	0f b6 c7             	movzbl %bh,%eax
   2410d:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   24114:	8b 14 8d 00 00 00 00 	mov    0x0(,%ecx,4),%edx
   2411b:	31 d0                	xor    %edx,%eax
   2411d:	89 85 4c ff ff ff    	mov    %eax,0xffffff4c(%ebp)
   24123:	89 d8                	mov    %ebx,%eax
   24125:	c1 e8 10             	shr    $0x10,%eax
   24128:	0f b6 c0             	movzbl %al,%eax
   2412b:	8b 0c 85 00 08 00 00 	mov    0x800(,%eax,4),%ecx
   24132:	89 d8                	mov    %ebx,%eax
   24134:	31 8d 4c ff ff ff    	xor    %ecx,0xffffff4c(%ebp)
   2413a:	c1 e8 18             	shr    $0x18,%eax
   2413d:	8b 1c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ebx
   24144:	31 9d 4c ff ff ff    	xor    %ebx,0xffffff4c(%ebp)
   2414a:	8b 45 0c             	mov    0xc(%ebp),%eax
   2414d:	8b 95 4c ff ff ff    	mov    0xffffff4c(%ebp),%edx
   24153:	89 50 38             	mov    %edx,0x38(%eax)
   24156:	8b 9d 50 ff ff ff    	mov    0xffffff50(%ebp),%ebx
   2415c:	ba 00 00 00 00       	mov    $0x0,%edx
   24161:	8b 4d a0             	mov    0xffffffa0(%ebp),%ecx
   24164:	31 d9                	xor    %ebx,%ecx
   24166:	0f b6 c5             	movzbl %ch,%eax
   24169:	89 8d 48 ff ff ff    	mov    %ecx,0xffffff48(%ebp)
   2416f:	8b 94 82 00 04 00 00 	mov    0x400(%edx,%eax,4),%edx
   24176:	89 4d f0             	mov    %ecx,0xfffffff0(%ebp)
   24179:	b9 00 00 00 00       	mov    $0x0,%ecx
   2417e:	0f b6 5d f0          	movzbl 0xfffffff0(%ebp),%ebx
   24182:	89 85 40 ff ff ff    	mov    %eax,0xffffff40(%ebp)
   24188:	8b 85 48 ff ff ff    	mov    0xffffff48(%ebp),%eax
   2418e:	c1 e8 10             	shr    $0x10,%eax
   24191:	89 9d 44 ff ff ff    	mov    %ebx,0xffffff44(%ebp)
   24197:	8b 0c 99             	mov    (%ecx,%ebx,4),%ecx
   2419a:	0f b6 c0             	movzbl %al,%eax
   2419d:	8b 1c 85 00 08 00 00 	mov    0x800(,%eax,4),%ebx
   241a4:	31 ca                	xor    %ecx,%edx
   241a6:	b9 00 00 00 00       	mov    $0x0,%ecx
   241ab:	31 da                	xor    %ebx,%edx
   241ad:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   241b0:	89 95 38 ff ff ff    	mov    %edx,0xffffff38(%ebp)
   241b6:	8b 95 48 ff ff ff    	mov    0xffffff48(%ebp),%edx
   241bc:	c1 ea 18             	shr    $0x18,%edx
   241bf:	89 95 3c ff ff ff    	mov    %edx,0xffffff3c(%ebp)
   241c5:	8b 8c 91 00 0c 00 00 	mov    0xc00(%ecx,%edx,4),%ecx
   241cc:	31 8d 38 ff ff ff    	xor    %ecx,0xffffff38(%ebp)
   241d2:	8b 0c 85 00 04 00 00 	mov    0x400(,%eax,4),%ecx
   241d9:	b8 00 00 00 00       	mov    $0x0,%eax
   241de:	8b 95 38 ff ff ff    	mov    0xffffff38(%ebp),%edx
   241e4:	89 53 3c             	mov    %edx,0x3c(%ebx)
   241e7:	8b 9d 40 ff ff ff    	mov    0xffffff40(%ebp),%ebx
   241ed:	8b 14 98             	mov    (%eax,%ebx,4),%edx
   241f0:	8b 9d 44 ff ff ff    	mov    0xffffff44(%ebp),%ebx
   241f6:	31 d1                	xor    %edx,%ecx
   241f8:	8b 95 3c ff ff ff    	mov    0xffffff3c(%ebp),%edx
   241fe:	8b b4 98 00 0c 00 00 	mov    0xc00(%eax,%ebx,4),%esi
   24205:	8b 1d 04 00 00 00    	mov    0x4,%ebx
   2420b:	8b bc 90 00 08 00 00 	mov    0x800(%eax,%edx,4),%edi
   24212:	8b 45 8c             	mov    0xffffff8c(%ebp),%eax
   24215:	31 f9                	xor    %edi,%ecx
   24217:	31 f1                	xor    %esi,%ecx
   24219:	31 d9                	xor    %ebx,%ecx
   2421b:	bb 00 00 00 00       	mov    $0x0,%ebx
   24220:	31 c8                	xor    %ecx,%eax
   24222:	89 85 34 ff ff ff    	mov    %eax,0xffffff34(%ebp)
   24228:	0f b6 d1             	movzbl %cl,%edx
   2422b:	0f b6 c5             	movzbl %ch,%eax
   2422e:	8b 1c 93             	mov    (%ebx,%edx,4),%ebx
   24231:	c1 e9 10             	shr    $0x10,%ecx
   24234:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   2423b:	31 d8                	xor    %ebx,%eax
   2423d:	89 85 2c ff ff ff    	mov    %eax,0xffffff2c(%ebp)
   24243:	0f b6 c1             	movzbl %cl,%eax
   24246:	8b 14 85 00 08 00 00 	mov    0x800(,%eax,4),%edx
   2424d:	89 c8                	mov    %ecx,%eax
   2424f:	31 95 2c ff ff ff    	xor    %edx,0xffffff2c(%ebp)
   24255:	c1 e8 08             	shr    $0x8,%eax
   24258:	8b 8d 2c ff ff ff    	mov    0xffffff2c(%ebp),%ecx
   2425e:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   24265:	8b 7d 88             	mov    0xffffff88(%ebp),%edi
   24268:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   2426b:	31 d1                	xor    %edx,%ecx
   2426d:	31 f9                	xor    %edi,%ecx
   2426f:	89 8d 28 ff ff ff    	mov    %ecx,0xffffff28(%ebp)
   24275:	89 4b 40             	mov    %ecx,0x40(%ebx)
   24278:	8b b5 34 ff ff ff    	mov    0xffffff34(%ebp),%esi
   2427e:	8b 55 80             	mov    0xffffff80(%ebp),%edx
   24281:	8b 45 84             	mov    0xffffff84(%ebp),%eax
   24284:	31 d1                	xor    %edx,%ecx
   24286:	31 f0                	xor    %esi,%eax
   24288:	89 85 24 ff ff ff    	mov    %eax,0xffffff24(%ebp)
   2428e:	89 8d 20 ff ff ff    	mov    %ecx,0xffffff20(%ebp)
   24294:	89 4b 44             	mov    %ecx,0x44(%ebx)
   24297:	8b 95 7c ff ff ff    	mov    0xffffff7c(%ebp),%edx
   2429d:	31 c2                	xor    %eax,%edx
   2429f:	8b 85 78 ff ff ff    	mov    0xffffff78(%ebp),%eax
   242a5:	89 95 1c ff ff ff    	mov    %edx,0xffffff1c(%ebp)
   242ab:	31 c1                	xor    %eax,%ecx
   242ad:	89 8d 18 ff ff ff    	mov    %ecx,0xffffff18(%ebp)
   242b3:	89 4b 48             	mov    %ecx,0x48(%ebx)
   242b6:	8b 85 64 ff ff ff    	mov    0xffffff64(%ebp),%eax
   242bc:	8b 9d 74 ff ff ff    	mov    0xffffff74(%ebp),%ebx
   242c2:	31 c1                	xor    %eax,%ecx
   242c4:	8b 45 0c             	mov    0xc(%ebp),%eax
   242c7:	31 d3                	xor    %edx,%ebx
   242c9:	89 9d 14 ff ff ff    	mov    %ebx,0xffffff14(%ebp)
   242cf:	89 5d e0             	mov    %ebx,0xffffffe0(%ebp)
   242d2:	89 8d 10 ff ff ff    	mov    %ecx,0xffffff10(%ebp)
   242d8:	89 48 4c             	mov    %ecx,0x4c(%eax)
   242db:	0f b6 c7             	movzbl %bh,%eax
   242de:	bb 00 00 00 00       	mov    $0x0,%ebx
   242e3:	0f b6 55 e0          	movzbl 0xffffffe0(%ebp),%edx
   242e7:	8b 0c 85 00 04 00 00 	mov    0x400(,%eax,4),%ecx
   242ee:	8b 85 14 ff ff ff    	mov    0xffffff14(%ebp),%eax
   242f4:	8b 3c 93             	mov    (%ebx,%edx,4),%edi
   242f7:	c1 e8 10             	shr    $0x10,%eax
   242fa:	0f b6 c0             	movzbl %al,%eax
   242fd:	8b 34 85 00 08 00 00 	mov    0x800(,%eax,4),%esi
   24304:	8b 85 14 ff ff ff    	mov    0xffffff14(%ebp),%eax
   2430a:	31 f9                	xor    %edi,%ecx
   2430c:	31 f1                	xor    %esi,%ecx
   2430e:	c1 e8 18             	shr    $0x18,%eax
   24311:	8b 1c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ebx
   24318:	8b 85 60 ff ff ff    	mov    0xffffff60(%ebp),%eax
   2431e:	31 d9                	xor    %ebx,%ecx
   24320:	bb 00 00 00 00       	mov    $0x0,%ebx
   24325:	31 c8                	xor    %ecx,%eax
   24327:	0f b6 d1             	movzbl %cl,%edx
   2432a:	89 85 08 ff ff ff    	mov    %eax,0xffffff08(%ebp)
   24330:	0f b6 c5             	movzbl %ch,%eax
   24333:	8b 1c 93             	mov    (%ebx,%edx,4),%ebx
   24336:	c1 e9 10             	shr    $0x10,%ecx
   24339:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   24340:	8b bd 5c ff ff ff    	mov    0xffffff5c(%ebp),%edi
   24346:	31 d8                	xor    %ebx,%eax
   24348:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   2434b:	89 85 00 ff ff ff    	mov    %eax,0xffffff00(%ebp)
   24351:	0f b6 c1             	movzbl %cl,%eax
   24354:	8b 14 85 00 08 00 00 	mov    0x800(,%eax,4),%edx
   2435b:	89 c8                	mov    %ecx,%eax
   2435d:	c1 e8 08             	shr    $0x8,%eax
   24360:	31 95 00 ff ff ff    	xor    %edx,0xffffff00(%ebp)
   24366:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   2436d:	8b 8d 00 ff ff ff    	mov    0xffffff00(%ebp),%ecx
   24373:	31 d1                	xor    %edx,%ecx
   24375:	31 f9                	xor    %edi,%ecx
   24377:	89 8d fc fe ff ff    	mov    %ecx,0xfffffefc(%ebp)
   2437d:	89 4b 50             	mov    %ecx,0x50(%ebx)
   24380:	8b b5 08 ff ff ff    	mov    0xffffff08(%ebp),%esi
   24386:	8b 95 54 ff ff ff    	mov    0xffffff54(%ebp),%edx
   2438c:	8b 85 58 ff ff ff    	mov    0xffffff58(%ebp),%eax
   24392:	31 d1                	xor    %edx,%ecx
   24394:	31 f0                	xor    %esi,%eax
   24396:	89 85 f8 fe ff ff    	mov    %eax,0xfffffef8(%ebp)
   2439c:	89 8d f4 fe ff ff    	mov    %ecx,0xfffffef4(%ebp)
   243a2:	89 4b 54             	mov    %ecx,0x54(%ebx)
   243a5:	8b 95 50 ff ff ff    	mov    0xffffff50(%ebp),%edx
   243ab:	31 c2                	xor    %eax,%edx
   243ad:	8b 85 4c ff ff ff    	mov    0xffffff4c(%ebp),%eax
   243b3:	89 95 f0 fe ff ff    	mov    %edx,0xfffffef0(%ebp)
   243b9:	31 c1                	xor    %eax,%ecx
   243bb:	89 8d ec fe ff ff    	mov    %ecx,0xfffffeec(%ebp)
   243c1:	89 4b 58             	mov    %ecx,0x58(%ebx)
   243c4:	8b 85 38 ff ff ff    	mov    0xffffff38(%ebp),%eax
   243ca:	8b 9d 48 ff ff ff    	mov    0xffffff48(%ebp),%ebx
   243d0:	31 c1                	xor    %eax,%ecx
   243d2:	8b 45 0c             	mov    0xc(%ebp),%eax
   243d5:	31 d3                	xor    %edx,%ebx
   243d7:	89 9d e8 fe ff ff    	mov    %ebx,0xfffffee8(%ebp)
    kd8(cx->ks, 2);  kd8(cx->ks, 3);
   243dd:	0f b6 d7             	movzbl %bh,%edx
   243e0:	89 5d f0             	mov    %ebx,0xfffffff0(%ebp)
   243e3:	89 48 5c             	mov    %ecx,0x5c(%eax)
   243e6:	89 d8                	mov    %ebx,%eax
   243e8:	bb 00 00 00 00       	mov    $0x0,%ebx
   243ed:	c1 e8 10             	shr    $0x10,%eax
   243f0:	0f b6 c0             	movzbl %al,%eax
   243f3:	8b 1c 93             	mov    (%ebx,%edx,4),%ebx
   243f6:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   243fd:	31 d8                	xor    %ebx,%eax
   243ff:	89 85 e4 fe ff ff    	mov    %eax,0xfffffee4(%ebp)
   24405:	8b 85 e8 fe ff ff    	mov    0xfffffee8(%ebp),%eax
   2440b:	c1 e8 18             	shr    $0x18,%eax
   2440e:	8b 14 85 00 08 00 00 	mov    0x800(,%eax,4),%edx
   24415:	31 95 e4 fe ff ff    	xor    %edx,0xfffffee4(%ebp)
   2441b:	8b 95 34 ff ff ff    	mov    0xffffff34(%ebp),%edx
   24421:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
   24425:	8b 1c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ebx
   2442c:	a1 08 00 00 00       	mov    0x8,%eax
   24431:	31 9d e4 fe ff ff    	xor    %ebx,0xfffffee4(%ebp)
   24437:	31 85 e4 fe ff ff    	xor    %eax,0xfffffee4(%ebp)
   2443d:	8b bd e4 fe ff ff    	mov    0xfffffee4(%ebp),%edi
   24443:	0f b6 9d e4 fe ff ff 	movzbl 0xfffffee4(%ebp),%ebx
   2444a:	31 fa                	xor    %edi,%edx
   2444c:	89 95 dc fe ff ff    	mov    %edx,0xfffffedc(%ebp)
   24452:	8b 95 e4 fe ff ff    	mov    0xfffffee4(%ebp),%edx
   24458:	c1 ad e4 fe ff ff 10 	shrl   $0x10,0xfffffee4(%ebp)
   2445f:	0f b6 c6             	movzbl %dh,%eax
   24462:	ba 00 00 00 00       	mov    $0x0,%edx
   24467:	8b 14 9a             	mov    (%edx,%ebx,4),%edx
   2446a:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   24471:	31 d0                	xor    %edx,%eax
   24473:	89 85 d4 fe ff ff    	mov    %eax,0xfffffed4(%ebp)
   24479:	0f b6 85 e4 fe ff ff 	movzbl 0xfffffee4(%ebp),%eax
   24480:	8b 1c 85 00 08 00 00 	mov    0x800(,%eax,4),%ebx
   24487:	8b 85 e4 fe ff ff    	mov    0xfffffee4(%ebp),%eax
   2448d:	31 9d d4 fe ff ff    	xor    %ebx,0xfffffed4(%ebp)
   24493:	8b 9d 28 ff ff ff    	mov    0xffffff28(%ebp),%ebx
   24499:	c1 e8 08             	shr    $0x8,%eax
   2449c:	8b 95 d4 fe ff ff    	mov    0xfffffed4(%ebp),%edx
   244a2:	8b 34 85 00 0c 00 00 	mov    0xc00(,%eax,4),%esi
   244a9:	8b 45 0c             	mov    0xc(%ebp),%eax
   244ac:	31 f2                	xor    %esi,%edx
   244ae:	31 da                	xor    %ebx,%edx
   244b0:	89 95 e4 fe ff ff    	mov    %edx,0xfffffee4(%ebp)
   244b6:	89 95 d0 fe ff ff    	mov    %edx,0xfffffed0(%ebp)
   244bc:	89 50 60             	mov    %edx,0x60(%eax)
   244bf:	8b 9d dc fe ff ff    	mov    0xfffffedc(%ebp),%ebx
   244c5:	8b 95 24 ff ff ff    	mov    0xffffff24(%ebp),%edx
   244cb:	31 da                	xor    %ebx,%edx
   244cd:	8b 9d 20 ff ff ff    	mov    0xffffff20(%ebp),%ebx
   244d3:	89 95 cc fe ff ff    	mov    %edx,0xfffffecc(%ebp)
   244d9:	31 9d e4 fe ff ff    	xor    %ebx,0xfffffee4(%ebp)
   244df:	8b 95 e4 fe ff ff    	mov    0xfffffee4(%ebp),%edx
   244e5:	89 50 64             	mov    %edx,0x64(%eax)
   244e8:	8b bd cc fe ff ff    	mov    0xfffffecc(%ebp),%edi
   244ee:	8b 9d 1c ff ff ff    	mov    0xffffff1c(%ebp),%ebx
   244f4:	8b 85 18 ff ff ff    	mov    0xffffff18(%ebp),%eax
   244fa:	31 fb                	xor    %edi,%ebx
   244fc:	31 c2                	xor    %eax,%edx
   244fe:	89 9d c8 fe ff ff    	mov    %ebx,0xfffffec8(%ebp)
   24504:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   24507:	89 53 68             	mov    %edx,0x68(%ebx)
   2450a:	8b b5 c8 fe ff ff    	mov    0xfffffec8(%ebp),%esi
   24510:	8b 85 14 ff ff ff    	mov    0xffffff14(%ebp),%eax
   24516:	8b 9d 10 ff ff ff    	mov    0xffffff10(%ebp),%ebx
   2451c:	31 f0                	xor    %esi,%eax
   2451e:	31 da                	xor    %ebx,%edx
   24520:	89 85 c4 fe ff ff    	mov    %eax,0xfffffec4(%ebp)
   24526:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   24529:	8b 45 0c             	mov    0xc(%ebp),%eax
   2452c:	89 50 6c             	mov    %edx,0x6c(%eax)
   2452f:	8b 9d c4 fe ff ff    	mov    0xfffffec4(%ebp),%ebx
   24535:	0f b6 55 e0          	movzbl 0xffffffe0(%ebp),%edx
   24539:	0f b6 c7             	movzbl %bh,%eax
   2453c:	bb 00 00 00 00       	mov    $0x0,%ebx
   24541:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   24548:	8b 1c 93             	mov    (%ebx,%edx,4),%ebx
   2454b:	31 d8                	xor    %ebx,%eax
   2454d:	89 85 e4 fe ff ff    	mov    %eax,0xfffffee4(%ebp)
   24553:	8b 85 c4 fe ff ff    	mov    0xfffffec4(%ebp),%eax
   24559:	c1 e8 10             	shr    $0x10,%eax
   2455c:	0f b6 c0             	movzbl %al,%eax
   2455f:	8b 14 85 00 08 00 00 	mov    0x800(,%eax,4),%edx
   24566:	8b 85 c4 fe ff ff    	mov    0xfffffec4(%ebp),%eax
   2456c:	31 95 e4 fe ff ff    	xor    %edx,0xfffffee4(%ebp)
   24572:	c1 e8 18             	shr    $0x18,%eax
   24575:	8b 1c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ebx
   2457c:	31 9d e4 fe ff ff    	xor    %ebx,0xfffffee4(%ebp)
   24582:	8b 85 08 ff ff ff    	mov    0xffffff08(%ebp),%eax
   24588:	8b 9d e4 fe ff ff    	mov    0xfffffee4(%ebp),%ebx
   2458e:	0f b6 95 e4 fe ff ff 	movzbl 0xfffffee4(%ebp),%edx
   24595:	31 d8                	xor    %ebx,%eax
   24597:	8b 9d e4 fe ff ff    	mov    0xfffffee4(%ebp),%ebx
   2459d:	89 85 bc fe ff ff    	mov    %eax,0xfffffebc(%ebp)
   245a3:	0f b6 c7             	movzbl %bh,%eax
   245a6:	bb 00 00 00 00       	mov    $0x0,%ebx
   245ab:	8b 1c 93             	mov    (%ebx,%edx,4),%ebx
   245ae:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   245b5:	31 d8                	xor    %ebx,%eax
   245b7:	89 85 b4 fe ff ff    	mov    %eax,0xfffffeb4(%ebp)
   245bd:	c1 ad e4 fe ff ff 10 	shrl   $0x10,0xfffffee4(%ebp)
   245c4:	0f b6 85 e4 fe ff ff 	movzbl 0xfffffee4(%ebp),%eax
   245cb:	8b 14 85 00 08 00 00 	mov    0x800(,%eax,4),%edx
   245d2:	8b 85 e4 fe ff ff    	mov    0xfffffee4(%ebp),%eax
   245d8:	31 95 b4 fe ff ff    	xor    %edx,0xfffffeb4(%ebp)
   245de:	c1 e8 08             	shr    $0x8,%eax
   245e1:	8b 9d b4 fe ff ff    	mov    0xfffffeb4(%ebp),%ebx
   245e7:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   245ee:	8b 85 fc fe ff ff    	mov    0xfffffefc(%ebp),%eax
   245f4:	31 d3                	xor    %edx,%ebx
   245f6:	8b 55 0c             	mov    0xc(%ebp),%edx
   245f9:	31 c3                	xor    %eax,%ebx
   245fb:	89 9d e4 fe ff ff    	mov    %ebx,0xfffffee4(%ebp)
   24601:	89 5a 70             	mov    %ebx,0x70(%edx)
   24604:	8b 85 bc fe ff ff    	mov    0xfffffebc(%ebp),%eax
   2460a:	8b 9d f8 fe ff ff    	mov    0xfffffef8(%ebp),%ebx
   24610:	31 c3                	xor    %eax,%ebx
   24612:	8b 85 f4 fe ff ff    	mov    0xfffffef4(%ebp),%eax
   24618:	31 85 e4 fe ff ff    	xor    %eax,0xfffffee4(%ebp)
   2461e:	89 9d b0 fe ff ff    	mov    %ebx,0xfffffeb0(%ebp)
   24624:	8b 9d e4 fe ff ff    	mov    0xfffffee4(%ebp),%ebx
   2462a:	89 5a 74             	mov    %ebx,0x74(%edx)
   2462d:	8b bd b0 fe ff ff    	mov    0xfffffeb0(%ebp),%edi
   24633:	8b 85 f0 fe ff ff    	mov    0xfffffef0(%ebp),%eax
   24639:	8b 95 ec fe ff ff    	mov    0xfffffeec(%ebp),%edx
   2463f:	31 f8                	xor    %edi,%eax
   24641:	31 d3                	xor    %edx,%ebx
   24643:	89 85 ac fe ff ff    	mov    %eax,0xfffffeac(%ebp)
   24649:	8b 45 0c             	mov    0xc(%ebp),%eax
   2464c:	89 58 78             	mov    %ebx,0x78(%eax)
   2464f:	31 cb                	xor    %ecx,%ebx
   24651:	8b b5 ac fe ff ff    	mov    0xfffffeac(%ebp),%esi
   24657:	89 9d e4 fe ff ff    	mov    %ebx,0xfffffee4(%ebp)
   2465d:	8b 95 e8 fe ff ff    	mov    0xfffffee8(%ebp),%edx
   24663:	31 f2                	xor    %esi,%edx
   24665:	89 55 f0             	mov    %edx,0xfffffff0(%ebp)
   24668:	0f b6 ce             	movzbl %dh,%ecx
   2466b:	89 95 a8 fe ff ff    	mov    %edx,0xfffffea8(%ebp)
   24671:	89 58 7c             	mov    %ebx,0x7c(%eax)
   24674:	89 d0                	mov    %edx,%eax
   24676:	c1 e8 10             	shr    $0x10,%eax
   24679:	0f b6 c0             	movzbl %al,%eax
   2467c:	8b 34 85 00 04 00 00 	mov    0x400(,%eax,4),%esi
   24683:	8b 04 8d 00 00 00 00 	mov    0x0(,%ecx,4),%eax
   2468a:	8b 0d 0c 00 00 00    	mov    0xc,%ecx
   24690:	31 c6                	xor    %eax,%esi
   24692:	89 d0                	mov    %edx,%eax
   24694:	c1 e8 18             	shr    $0x18,%eax
   24697:	8b 3c 85 00 08 00 00 	mov    0x800(,%eax,4),%edi
   2469e:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
   246a2:	31 fe                	xor    %edi,%esi
   246a4:	8b 1c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ebx
   246ab:	31 de                	xor    %ebx,%esi
   246ad:	31 ce                	xor    %ecx,%esi
   246af:	8b 8d dc fe ff ff    	mov    0xfffffedc(%ebp),%ecx
   246b5:	89 f2                	mov    %esi,%edx
   246b7:	89 f3                	mov    %esi,%ebx
   246b9:	31 f1                	xor    %esi,%ecx
   246bb:	89 8d a4 fe ff ff    	mov    %ecx,0xfffffea4(%ebp)
   246c1:	0f b6 db             	movzbl %bl,%ebx
   246c4:	0f b6 c6             	movzbl %dh,%eax
   246c7:	89 9d a0 fe ff ff    	mov    %ebx,0xfffffea0(%ebp)
   246cd:	b9 00 00 00 00       	mov    $0x0,%ecx
   246d2:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   246d9:	8b 0c 99             	mov    (%ecx,%ebx,4),%ecx
   246dc:	c1 ee 10             	shr    $0x10,%esi
   246df:	89 f3                	mov    %esi,%ebx
   246e1:	31 c8                	xor    %ecx,%eax
   246e3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   246e6:	89 85 9c fe ff ff    	mov    %eax,0xfffffe9c(%ebp)
   246ec:	0f b6 c3             	movzbl %bl,%eax
   246ef:	8b 14 85 00 08 00 00 	mov    0x800(,%eax,4),%edx
   246f6:	89 f0                	mov    %esi,%eax
   246f8:	c1 e8 08             	shr    $0x8,%eax
   246fb:	31 95 9c fe ff ff    	xor    %edx,0xfffffe9c(%ebp)
   24701:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   24708:	8b 85 d0 fe ff ff    	mov    0xfffffed0(%ebp),%eax
   2470e:	8b b5 9c fe ff ff    	mov    0xfffffe9c(%ebp),%esi
   24714:	31 d6                	xor    %edx,%esi
   24716:	31 c6                	xor    %eax,%esi
   24718:	89 b5 98 fe ff ff    	mov    %esi,0xfffffe98(%ebp)
   2471e:	89 b1 80 00 00 00    	mov    %esi,0x80(%ecx)
   24724:	8b 85 a4 fe ff ff    	mov    0xfffffea4(%ebp),%eax
   2472a:	8b 9d cc fe ff ff    	mov    0xfffffecc(%ebp),%ebx
   24730:	31 c3                	xor    %eax,%ebx
   24732:	89 9d 94 fe ff ff    	mov    %ebx,0xfffffe94(%ebp)
   24738:	8b 79 64             	mov    0x64(%ecx),%edi
   2473b:	31 fe                	xor    %edi,%esi
   2473d:	89 b5 90 fe ff ff    	mov    %esi,0xfffffe90(%ebp)
   24743:	89 b1 84 00 00 00    	mov    %esi,0x84(%ecx)
   24749:	8b 85 c8 fe ff ff    	mov    0xfffffec8(%ebp),%eax
   2474f:	31 d8                	xor    %ebx,%eax
   24751:	89 85 8c fe ff ff    	mov    %eax,0xfffffe8c(%ebp)
   24757:	8b 51 68             	mov    0x68(%ecx),%edx
   2475a:	31 d6                	xor    %edx,%esi
   2475c:	89 b5 88 fe ff ff    	mov    %esi,0xfffffe88(%ebp)
   24762:	89 b1 88 00 00 00    	mov    %esi,0x88(%ecx)
   24768:	8b 95 c4 fe ff ff    	mov    0xfffffec4(%ebp),%edx
   2476e:	31 c2                	xor    %eax,%edx
   24770:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
   24773:	89 95 84 fe ff ff    	mov    %edx,0xfffffe84(%ebp)
   24779:	8b 41 6c             	mov    0x6c(%ecx),%eax
   2477c:	31 c6                	xor    %eax,%esi
   2477e:	0f b6 c6             	movzbl %dh,%eax
   24781:	89 b5 80 fe ff ff    	mov    %esi,0xfffffe80(%ebp)
   24787:	89 b1 8c 00 00 00    	mov    %esi,0x8c(%ecx)
   2478d:	8b 34 85 00 04 00 00 	mov    0x400(,%eax,4),%esi
   24794:	89 d0                	mov    %edx,%eax
   24796:	0f b6 4d e0          	movzbl 0xffffffe0(%ebp),%ecx
   2479a:	c1 e8 10             	shr    $0x10,%eax
   2479d:	0f b6 c0             	movzbl %al,%eax
   247a0:	8b 1c 85 00 08 00 00 	mov    0x800(,%eax,4),%ebx
   247a7:	89 d0                	mov    %edx,%eax
   247a9:	8b 3c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%edi
   247b0:	c1 e8 18             	shr    $0x18,%eax
   247b3:	8b 0c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ecx
   247ba:	31 fe                	xor    %edi,%esi
   247bc:	31 de                	xor    %ebx,%esi
   247be:	31 ce                	xor    %ecx,%esi
   247c0:	8b 8d bc fe ff ff    	mov    0xfffffebc(%ebp),%ecx
   247c6:	89 f2                	mov    %esi,%edx
   247c8:	89 f3                	mov    %esi,%ebx
   247ca:	31 f1                	xor    %esi,%ecx
   247cc:	89 8d 7c fe ff ff    	mov    %ecx,0xfffffe7c(%ebp)
   247d2:	0f b6 db             	movzbl %bl,%ebx
   247d5:	0f b6 c6             	movzbl %dh,%eax
   247d8:	89 9d 78 fe ff ff    	mov    %ebx,0xfffffe78(%ebp)
   247de:	b9 00 00 00 00       	mov    $0x0,%ecx
   247e3:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   247ea:	8b 0c 99             	mov    (%ecx,%ebx,4),%ecx
   247ed:	c1 ee 10             	shr    $0x10,%esi
   247f0:	89 f3                	mov    %esi,%ebx
   247f2:	31 c8                	xor    %ecx,%eax
   247f4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   247f7:	89 85 74 fe ff ff    	mov    %eax,0xfffffe74(%ebp)
   247fd:	0f b6 c3             	movzbl %bl,%eax
   24800:	8b 14 85 00 08 00 00 	mov    0x800(,%eax,4),%edx
   24807:	89 f0                	mov    %esi,%eax
   24809:	c1 e8 08             	shr    $0x8,%eax
   2480c:	31 95 74 fe ff ff    	xor    %edx,0xfffffe74(%ebp)
   24812:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   24819:	8b b5 74 fe ff ff    	mov    0xfffffe74(%ebp),%esi
   2481f:	8b 41 70             	mov    0x70(%ecx),%eax
   24822:	31 d6                	xor    %edx,%esi
   24824:	31 c6                	xor    %eax,%esi
   24826:	89 b5 70 fe ff ff    	mov    %esi,0xfffffe70(%ebp)
   2482c:	89 b1 90 00 00 00    	mov    %esi,0x90(%ecx)
   24832:	8b 85 7c fe ff ff    	mov    0xfffffe7c(%ebp),%eax
   24838:	8b 9d b0 fe ff ff    	mov    0xfffffeb0(%ebp),%ebx
   2483e:	31 c3                	xor    %eax,%ebx
   24840:	89 9d 6c fe ff ff    	mov    %ebx,0xfffffe6c(%ebp)
   24846:	8b 79 74             	mov    0x74(%ecx),%edi
   24849:	31 fe                	xor    %edi,%esi
   2484b:	89 b5 68 fe ff ff    	mov    %esi,0xfffffe68(%ebp)
   24851:	89 b1 94 00 00 00    	mov    %esi,0x94(%ecx)
   24857:	8b 85 ac fe ff ff    	mov    0xfffffeac(%ebp),%eax
   2485d:	31 d8                	xor    %ebx,%eax
   2485f:	89 85 64 fe ff ff    	mov    %eax,0xfffffe64(%ebp)
   24865:	8b 51 78             	mov    0x78(%ecx),%edx
   24868:	31 d6                	xor    %edx,%esi
   2486a:	89 b5 60 fe ff ff    	mov    %esi,0xfffffe60(%ebp)
   24870:	89 b1 98 00 00 00    	mov    %esi,0x98(%ecx)
   24876:	8b 95 a8 fe ff ff    	mov    0xfffffea8(%ebp),%edx
   2487c:	8b bd e4 fe ff ff    	mov    0xfffffee4(%ebp),%edi
   24882:	31 c2                	xor    %eax,%edx
    kd8(cx->ks, 4);  kd8(cx->ks, 5);
   24884:	89 d0                	mov    %edx,%eax
   24886:	31 fe                	xor    %edi,%esi
   24888:	89 55 f0             	mov    %edx,0xfffffff0(%ebp)
   2488b:	c1 e8 10             	shr    $0x10,%eax
   2488e:	0f b6 c0             	movzbl %al,%eax
   24891:	89 95 5c fe ff ff    	mov    %edx,0xfffffe5c(%ebp)
   24897:	8b 3c 85 00 04 00 00 	mov    0x400(,%eax,4),%edi
   2489e:	89 d0                	mov    %edx,%eax
   248a0:	89 b1 9c 00 00 00    	mov    %esi,0x9c(%ecx)
   248a6:	c1 e8 18             	shr    $0x18,%eax
   248a9:	0f b6 ce             	movzbl %dh,%ecx
   248ac:	8b 14 85 00 08 00 00 	mov    0x800(,%eax,4),%edx
   248b3:	8b 1c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%ebx
   248ba:	8b 0d 10 00 00 00    	mov    0x10,%ecx
   248c0:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
   248c4:	31 df                	xor    %ebx,%edi
   248c6:	31 d7                	xor    %edx,%edi
   248c8:	8b 1c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ebx
   248cf:	31 df                	xor    %ebx,%edi
   248d1:	31 cf                	xor    %ecx,%edi
   248d3:	8b 8d a4 fe ff ff    	mov    0xfffffea4(%ebp),%ecx
   248d9:	89 fa                	mov    %edi,%edx
   248db:	89 fb                	mov    %edi,%ebx
   248dd:	31 f9                	xor    %edi,%ecx
   248df:	0f b6 db             	movzbl %bl,%ebx
   248e2:	0f b6 c6             	movzbl %dh,%eax
   248e5:	89 8d 58 fe ff ff    	mov    %ecx,0xfffffe58(%ebp)
   248eb:	b9 00 00 00 00       	mov    $0x0,%ecx
   248f0:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   248f7:	89 9d 54 fe ff ff    	mov    %ebx,0xfffffe54(%ebp)
   248fd:	8b 0c 99             	mov    (%ecx,%ebx,4),%ecx
   24900:	c1 ef 10             	shr    $0x10,%edi
   24903:	89 fb                	mov    %edi,%ebx
   24905:	31 c8                	xor    %ecx,%eax
   24907:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   2490a:	89 85 50 fe ff ff    	mov    %eax,0xfffffe50(%ebp)
   24910:	0f b6 c3             	movzbl %bl,%eax
   24913:	8b 14 85 00 08 00 00 	mov    0x800(,%eax,4),%edx
   2491a:	89 f8                	mov    %edi,%eax
   2491c:	c1 e8 08             	shr    $0x8,%eax
   2491f:	31 95 50 fe ff ff    	xor    %edx,0xfffffe50(%ebp)
   24925:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   2492c:	8b 85 98 fe ff ff    	mov    0xfffffe98(%ebp),%eax
   24932:	8b bd 50 fe ff ff    	mov    0xfffffe50(%ebp),%edi
   24938:	31 d7                	xor    %edx,%edi
   2493a:	31 c7                	xor    %eax,%edi
   2493c:	89 bd 4c fe ff ff    	mov    %edi,0xfffffe4c(%ebp)
   24942:	89 b9 a0 00 00 00    	mov    %edi,0xa0(%ecx)
   24948:	8b 85 58 fe ff ff    	mov    0xfffffe58(%ebp),%eax
   2494e:	8b 9d 94 fe ff ff    	mov    0xfffffe94(%ebp),%ebx
   24954:	31 c3                	xor    %eax,%ebx
   24956:	8b 85 90 fe ff ff    	mov    0xfffffe90(%ebp),%eax
   2495c:	89 9d 48 fe ff ff    	mov    %ebx,0xfffffe48(%ebp)
   24962:	31 c7                	xor    %eax,%edi
   24964:	89 bd 44 fe ff ff    	mov    %edi,0xfffffe44(%ebp)
   2496a:	89 b9 a4 00 00 00    	mov    %edi,0xa4(%ecx)
   24970:	8b 95 88 fe ff ff    	mov    0xfffffe88(%ebp),%edx
   24976:	8b 85 8c fe ff ff    	mov    0xfffffe8c(%ebp),%eax
   2497c:	31 d7                	xor    %edx,%edi
   2497e:	31 d8                	xor    %ebx,%eax
   24980:	89 85 40 fe ff ff    	mov    %eax,0xfffffe40(%ebp)
   24986:	89 bd 3c fe ff ff    	mov    %edi,0xfffffe3c(%ebp)
   2498c:	89 b9 a8 00 00 00    	mov    %edi,0xa8(%ecx)
   24992:	8b 95 84 fe ff ff    	mov    0xfffffe84(%ebp),%edx
   24998:	31 c2                	xor    %eax,%edx
   2499a:	8b 85 80 fe ff ff    	mov    0xfffffe80(%ebp),%eax
   249a0:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
   249a3:	89 95 38 fe ff ff    	mov    %edx,0xfffffe38(%ebp)
   249a9:	31 c7                	xor    %eax,%edi
   249ab:	0f b6 c6             	movzbl %dh,%eax
   249ae:	89 bd 34 fe ff ff    	mov    %edi,0xfffffe34(%ebp)
   249b4:	89 b9 ac 00 00 00    	mov    %edi,0xac(%ecx)
   249ba:	8b 3c 85 00 04 00 00 	mov    0x400(,%eax,4),%edi
   249c1:	0f b6 4d e0          	movzbl 0xffffffe0(%ebp),%ecx
   249c5:	8b 04 8d 00 00 00 00 	mov    0x0(,%ecx,4),%eax
   249cc:	31 c7                	xor    %eax,%edi
   249ce:	89 d0                	mov    %edx,%eax
   249d0:	c1 e8 10             	shr    $0x10,%eax
   249d3:	0f b6 c0             	movzbl %al,%eax
   249d6:	8b 1c 85 00 08 00 00 	mov    0x800(,%eax,4),%ebx
   249dd:	89 d0                	mov    %edx,%eax
   249df:	c1 e8 18             	shr    $0x18,%eax
   249e2:	8b 0c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ecx
   249e9:	31 df                	xor    %ebx,%edi
   249eb:	31 cf                	xor    %ecx,%edi
   249ed:	8b 8d 7c fe ff ff    	mov    0xfffffe7c(%ebp),%ecx
   249f3:	89 fa                	mov    %edi,%edx
   249f5:	89 fb                	mov    %edi,%ebx
   249f7:	31 f9                	xor    %edi,%ecx
   249f9:	0f b6 db             	movzbl %bl,%ebx
   249fc:	0f b6 c6             	movzbl %dh,%eax
   249ff:	89 8d 30 fe ff ff    	mov    %ecx,0xfffffe30(%ebp)
   24a05:	b9 00 00 00 00       	mov    $0x0,%ecx
   24a0a:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   24a11:	89 9d 2c fe ff ff    	mov    %ebx,0xfffffe2c(%ebp)
   24a17:	8b 0c 99             	mov    (%ecx,%ebx,4),%ecx
   24a1a:	c1 ef 10             	shr    $0x10,%edi
   24a1d:	89 fb                	mov    %edi,%ebx
   24a1f:	31 c8                	xor    %ecx,%eax
   24a21:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   24a24:	89 85 28 fe ff ff    	mov    %eax,0xfffffe28(%ebp)
   24a2a:	0f b6 c3             	movzbl %bl,%eax
   24a2d:	8b 14 85 00 08 00 00 	mov    0x800(,%eax,4),%edx
   24a34:	89 f8                	mov    %edi,%eax
   24a36:	c1 e8 08             	shr    $0x8,%eax
   24a39:	31 95 28 fe ff ff    	xor    %edx,0xfffffe28(%ebp)
   24a3f:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   24a46:	8b 85 70 fe ff ff    	mov    0xfffffe70(%ebp),%eax
   24a4c:	8b bd 28 fe ff ff    	mov    0xfffffe28(%ebp),%edi
   24a52:	31 d7                	xor    %edx,%edi
   24a54:	31 c7                	xor    %eax,%edi
   24a56:	89 bd 24 fe ff ff    	mov    %edi,0xfffffe24(%ebp)
   24a5c:	89 b9 b0 00 00 00    	mov    %edi,0xb0(%ecx)
   24a62:	8b 85 30 fe ff ff    	mov    0xfffffe30(%ebp),%eax
   24a68:	8b 9d 6c fe ff ff    	mov    0xfffffe6c(%ebp),%ebx
   24a6e:	31 c3                	xor    %eax,%ebx
   24a70:	8b 85 68 fe ff ff    	mov    0xfffffe68(%ebp),%eax
   24a76:	89 9d 20 fe ff ff    	mov    %ebx,0xfffffe20(%ebp)
   24a7c:	31 c7                	xor    %eax,%edi
   24a7e:	89 bd 1c fe ff ff    	mov    %edi,0xfffffe1c(%ebp)
   24a84:	89 b9 b4 00 00 00    	mov    %edi,0xb4(%ecx)
   24a8a:	8b 95 60 fe ff ff    	mov    0xfffffe60(%ebp),%edx
   24a90:	8b 85 64 fe ff ff    	mov    0xfffffe64(%ebp),%eax
   24a96:	31 d7                	xor    %edx,%edi
   24a98:	31 d8                	xor    %ebx,%eax
   24a9a:	89 85 18 fe ff ff    	mov    %eax,0xfffffe18(%ebp)
   24aa0:	89 bd 14 fe ff ff    	mov    %edi,0xfffffe14(%ebp)
   24aa6:	89 b9 b8 00 00 00    	mov    %edi,0xb8(%ecx)
   24aac:	31 f7                	xor    %esi,%edi
   24aae:	8b 95 5c fe ff ff    	mov    0xfffffe5c(%ebp),%edx
   24ab4:	31 c2                	xor    %eax,%edx
   24ab6:	89 d0                	mov    %edx,%eax
   24ab8:	c1 e8 10             	shr    $0x10,%eax
   24abb:	89 55 f0             	mov    %edx,0xfffffff0(%ebp)
   24abe:	0f b6 c0             	movzbl %al,%eax
   24ac1:	8b 1c 85 00 04 00 00 	mov    0x400(,%eax,4),%ebx
   24ac8:	89 95 10 fe ff ff    	mov    %edx,0xfffffe10(%ebp)
   24ace:	89 d0                	mov    %edx,%eax
   24ad0:	c1 e8 18             	shr    $0x18,%eax
   24ad3:	89 b9 bc 00 00 00    	mov    %edi,0xbc(%ecx)
   24ad9:	0f b6 ce             	movzbl %dh,%ecx
   24adc:	8b 14 85 00 08 00 00 	mov    0x800(,%eax,4),%edx
   24ae3:	0f b6 45 f0          	movzbl 0xfffffff0(%ebp),%eax
   24ae7:	8b 34 8d 00 00 00 00 	mov    0x0(,%ecx,4),%esi
   24aee:	8b 0d 14 00 00 00    	mov    0x14,%ecx
   24af4:	31 f3                	xor    %esi,%ebx
   24af6:	8b 34 85 00 0c 00 00 	mov    0xc00(,%eax,4),%esi
   24afd:	31 d3                	xor    %edx,%ebx
   24aff:	31 f3                	xor    %esi,%ebx
   24b01:	31 cb                	xor    %ecx,%ebx
   24b03:	8b 8d 58 fe ff ff    	mov    0xfffffe58(%ebp),%ecx
   24b09:	0f b6 c3             	movzbl %bl,%eax
   24b0c:	31 d9                	xor    %ebx,%ecx
   24b0e:	89 8d 0c fe ff ff    	mov    %ecx,0xfffffe0c(%ebp)
   24b14:	b9 00 00 00 00       	mov    $0x0,%ecx
   24b19:	89 85 08 fe ff ff    	mov    %eax,0xfffffe08(%ebp)
   24b1f:	0f b6 c7             	movzbl %bh,%eax
   24b22:	c1 eb 10             	shr    $0x10,%ebx
   24b25:	8b 95 08 fe ff ff    	mov    0xfffffe08(%ebp),%edx
   24b2b:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   24b32:	8b 14 91             	mov    (%ecx,%edx,4),%edx
   24b35:	31 d0                	xor    %edx,%eax
   24b37:	89 85 04 fe ff ff    	mov    %eax,0xfffffe04(%ebp)
   24b3d:	0f b6 c3             	movzbl %bl,%eax
   24b40:	8b 0c 85 00 08 00 00 	mov    0x800(,%eax,4),%ecx
   24b47:	89 d8                	mov    %ebx,%eax
   24b49:	c1 e8 08             	shr    $0x8,%eax
   24b4c:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   24b53:	31 8d 04 fe ff ff    	xor    %ecx,0xfffffe04(%ebp)
   24b59:	8b 85 4c fe ff ff    	mov    0xfffffe4c(%ebp),%eax
   24b5f:	8b 9d 04 fe ff ff    	mov    0xfffffe04(%ebp),%ebx
   24b65:	31 d3                	xor    %edx,%ebx
   24b67:	31 c3                	xor    %eax,%ebx
   24b69:	8b 45 0c             	mov    0xc(%ebp),%eax
   24b6c:	89 98 c0 00 00 00    	mov    %ebx,0xc0(%eax)
   24b72:	8b b5 0c fe ff ff    	mov    0xfffffe0c(%ebp),%esi
   24b78:	8b 8d 44 fe ff ff    	mov    0xfffffe44(%ebp),%ecx
   24b7e:	8b 95 48 fe ff ff    	mov    0xfffffe48(%ebp),%edx
   24b84:	31 cb                	xor    %ecx,%ebx
   24b86:	31 f2                	xor    %esi,%edx
   24b88:	89 95 00 fe ff ff    	mov    %edx,0xfffffe00(%ebp)
   24b8e:	89 98 c4 00 00 00    	mov    %ebx,0xc4(%eax)
   24b94:	8b 8d 40 fe ff ff    	mov    0xfffffe40(%ebp),%ecx
   24b9a:	31 d1                	xor    %edx,%ecx
   24b9c:	8b 95 3c fe ff ff    	mov    0xfffffe3c(%ebp),%edx
   24ba2:	89 8d fc fd ff ff    	mov    %ecx,0xfffffdfc(%ebp)
   24ba8:	31 d3                	xor    %edx,%ebx
   24baa:	89 98 c8 00 00 00    	mov    %ebx,0xc8(%eax)
   24bb0:	8b 85 38 fe ff ff    	mov    0xfffffe38(%ebp),%eax
   24bb6:	8b 55 0c             	mov    0xc(%ebp),%edx
   24bb9:	31 c8                	xor    %ecx,%eax
   24bbb:	89 85 f8 fd ff ff    	mov    %eax,0xfffffdf8(%ebp)
   24bc1:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
   24bc4:	8b 85 34 fe ff ff    	mov    0xfffffe34(%ebp),%eax
   24bca:	31 c3                	xor    %eax,%ebx
   24bcc:	89 9a cc 00 00 00    	mov    %ebx,0xcc(%edx)
   24bd2:	8b 9d f8 fd ff ff    	mov    0xfffffdf8(%ebp),%ebx
   24bd8:	0f b6 4d e0          	movzbl 0xffffffe0(%ebp),%ecx
   24bdc:	0f b6 c7             	movzbl %bh,%eax
   24bdf:	8b 1c 85 00 04 00 00 	mov    0x400(,%eax,4),%ebx
   24be6:	8b 04 8d 00 00 00 00 	mov    0x0(,%ecx,4),%eax
   24bed:	31 c3                	xor    %eax,%ebx
   24bef:	8b 85 f8 fd ff ff    	mov    0xfffffdf8(%ebp),%eax
   24bf5:	c1 e8 10             	shr    $0x10,%eax
   24bf8:	0f b6 c0             	movzbl %al,%eax
   24bfb:	8b 34 85 00 08 00 00 	mov    0x800(,%eax,4),%esi
   24c02:	8b 85 f8 fd ff ff    	mov    0xfffffdf8(%ebp),%eax
   24c08:	31 f3                	xor    %esi,%ebx
   24c0a:	c1 e8 18             	shr    $0x18,%eax
   24c0d:	8b 0c 85 00 0c 00 00 	mov    0xc00(,%eax,4),%ecx
   24c14:	8b 85 30 fe ff ff    	mov    0xfffffe30(%ebp),%eax
   24c1a:	31 cb                	xor    %ecx,%ebx
   24c1c:	b9 00 00 00 00       	mov    $0x0,%ecx
   24c21:	31 d8                	xor    %ebx,%eax
   24c23:	0f b6 d3             	movzbl %bl,%edx
   24c26:	89 85 ec fd ff ff    	mov    %eax,0xfffffdec(%ebp)
   24c2c:	0f b6 c7             	movzbl %bh,%eax
   24c2f:	8b 0c 91             	mov    (%ecx,%edx,4),%ecx
   24c32:	c1 eb 10             	shr    $0x10,%ebx
   24c35:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   24c3c:	31 c8                	xor    %ecx,%eax
   24c3e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   24c41:	89 85 f0 fd ff ff    	mov    %eax,0xfffffdf0(%ebp)
   24c47:	0f b6 c3             	movzbl %bl,%eax
   24c4a:	8b 14 85 00 08 00 00 	mov    0x800(,%eax,4),%edx
   24c51:	89 d8                	mov    %ebx,%eax
   24c53:	31 95 f0 fd ff ff    	xor    %edx,0xfffffdf0(%ebp)
   24c59:	c1 e8 08             	shr    $0x8,%eax
   24c5c:	8b 14 85 00 0c 00 00 	mov    0xc00(,%eax,4),%edx
   24c63:	8b 85 24 fe ff ff    	mov    0xfffffe24(%ebp),%eax
   24c69:	8b 9d f0 fd ff ff    	mov    0xfffffdf0(%ebp),%ebx
   24c6f:	31 d3                	xor    %edx,%ebx
   24c71:	31 c3                	xor    %eax,%ebx
   24c73:	89 99 d0 00 00 00    	mov    %ebx,0xd0(%ecx)
   24c79:	8b 85 20 fe ff ff    	mov    0xfffffe20(%ebp),%eax
   24c7f:	31 85 ec fd ff ff    	xor    %eax,0xfffffdec(%ebp)
   24c85:	8b 85 1c fe ff ff    	mov    0xfffffe1c(%ebp),%eax
   24c8b:	31 c3                	xor    %eax,%ebx
   24c8d:	89 99 d4 00 00 00    	mov    %ebx,0xd4(%ecx)
   24c93:	8b 85 14 fe ff ff    	mov    0xfffffe14(%ebp),%eax
   24c99:	8b 95 18 fe ff ff    	mov    0xfffffe18(%ebp),%edx
   24c9f:	31 95 ec fd ff ff    	xor    %edx,0xfffffdec(%ebp)
   24ca5:	31 c3                	xor    %eax,%ebx
   24ca7:	89 99 d8 00 00 00    	mov    %ebx,0xd8(%ecx)
   24cad:	31 fb                	xor    %edi,%ebx
   24caf:	8b 8d 10 fe ff ff    	mov    0xfffffe10(%ebp),%ecx
   24cb5:	31 8d ec fd ff ff    	xor    %ecx,0xfffffdec(%ebp)
   24cbb:	8b 55 0c             	mov    0xc(%ebp),%edx
   24cbe:	8b 85 ec fd ff ff    	mov    0xfffffdec(%ebp),%eax
   24cc4:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    kdl8(cx->ks, 6);
   24cc7:	0f b6 cc             	movzbl %ah,%ecx
   24cca:	c1 e8 10             	shr    $0x10,%eax
   24ccd:	89 9a dc 00 00 00    	mov    %ebx,0xdc(%edx)
   24cd3:	8b 3c 8d 00 00 00 00 	mov    0x0(,%ecx,4),%edi
   24cda:	89 85 ec fd ff ff    	mov    %eax,0xfffffdec(%ebp)
   24ce0:	bb 00 00 00 00       	mov    $0x0,%ebx
   24ce5:	0f b6 85 ec fd ff ff 	movzbl 0xfffffdec(%ebp),%eax
   24cec:	c1 ad ec fd ff ff 08 	shrl   $0x8,0xfffffdec(%ebp)
   24cf3:	0f b6 55 f0          	movzbl 0xfffffff0(%ebp),%edx
   24cf7:	8b 8d ec fd ff ff    	mov    0xfffffdec(%ebp),%ecx
   24cfd:	8b 04 85 00 04 00 00 	mov    0x400(,%eax,4),%eax
   24d04:	8b b4 8b 00 08 00 00 	mov    0x800(%ebx,%ecx,4),%esi
   24d0b:	8b 8c 93 00 0c 00 00 	mov    0xc00(%ebx,%edx,4),%ecx
   24d12:	31 f8                	xor    %edi,%eax
   24d14:	8b 3d 18 00 00 00    	mov    0x18,%edi
   24d1a:	31 f0                	xor    %esi,%eax
   24d1c:	8b b5 0c fe ff ff    	mov    0xfffffe0c(%ebp),%esi
   24d22:	31 c8                	xor    %ecx,%eax
   24d24:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   24d27:	31 f8                	xor    %edi,%eax
   24d29:	31 f0                	xor    %esi,%eax
   24d2b:	89 81 e0 00 00 00    	mov    %eax,0xe0(%ecx)
   24d31:	8b 9d 00 fe ff ff    	mov    0xfffffe00(%ebp),%ebx
   24d37:	31 d8                	xor    %ebx,%eax
   24d39:	89 81 e4 00 00 00    	mov    %eax,0xe4(%ecx)
   24d3f:	8b 95 fc fd ff ff    	mov    0xfffffdfc(%ebp),%edx
   24d45:	31 d0                	xor    %edx,%eax
   24d47:	89 81 e8 00 00 00    	mov    %eax,0xe8(%ecx)
   24d4d:	31 85 f8 fd ff ff    	xor    %eax,0xfffffdf8(%ebp)
#endif
    cx->rn = 14;
   24d53:	b8 0e 00 00 00       	mov    $0xe,%eax
   24d58:	8b 9d f8 fd ff ff    	mov    0xfffffdf8(%ebp),%ebx
   24d5e:	89 81 f0 00 00 00    	mov    %eax,0xf0(%ecx)
#if defined( AES_ERR_CHK )
    return aes_good;
#endif
}
   24d64:	31 c0                	xor    %eax,%eax
   24d66:	89 99 ec 00 00 00    	mov    %ebx,0xec(%ecx)
   24d6c:	81 c4 0c 02 00 00    	add    $0x20c,%esp
   24d72:	5b                   	pop    %ebx
   24d73:	5e                   	pop    %esi
   24d74:	5f                   	pop    %edi
   24d75:	5d                   	pop    %ebp
   24d76:	c3                   	ret    
   24d77:	89 f6                	mov    %esi,%esi
   24d79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

00024d80 <aes_decrypt_key>:

#endif

#if defined(AES_VAR)

aes_rval aes_decrypt_key(const unsigned char *key, int key_len, aes_decrypt_ctx cx[1])
{
   24d80:	55                   	push   %ebp
   24d81:	89 e5                	mov    %esp,%ebp
   24d83:	8b 45 0c             	mov    0xc(%ebp),%eax
   24d86:	8b 4d 08             	mov    0x8(%ebp),%ecx
   24d89:	8b 55 10             	mov    0x10(%ebp),%edx
    switch(key_len)
   24d8c:	83 f8 20             	cmp    $0x20,%eax
   24d8f:	74 4b                	je     24ddc <aes_decrypt_key+0x5c>
   24d91:	83 f8 20             	cmp    $0x20,%eax
   24d94:	7f 2a                	jg     24dc0 <aes_decrypt_key+0x40>
   24d96:	83 f8 10             	cmp    $0x10,%eax
   24d99:	74 18                	je     24db3 <aes_decrypt_key+0x33>
   24d9b:	83 f8 18             	cmp    $0x18,%eax
   24d9e:	74 07                	je     24da7 <aes_decrypt_key+0x27>
    {
#if defined( AES_ERR_CHK )
    case 16: case 128: return aes_decrypt_key128(key, cx);
    case 24: case 192: return aes_decrypt_key192(key, cx);
    case 32: case 256: return aes_decrypt_key256(key, cx);
    default: return aes_error;
#else
    case 16: case 128: aes_decrypt_key128(key, cx); return;
    case 24: case 192: aes_decrypt_key192(key, cx); return;
    case 32: case 256: aes_decrypt_key256(key, cx); return;
#endif
    }
}
   24da0:	5d                   	pop    %ebp
   24da1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   24da6:	c3                   	ret    
   24da7:	89 55 0c             	mov    %edx,0xc(%ebp)
   24daa:	89 4d 08             	mov    %ecx,0x8(%ebp)
   24dad:	5d                   	pop    %ebp
   24dae:	e9 fc ff ff ff       	jmp    24daf <aes_decrypt_key+0x2f>
   24db3:	89 55 0c             	mov    %edx,0xc(%ebp)
   24db6:	89 4d 08             	mov    %ecx,0x8(%ebp)
   24db9:	5d                   	pop    %ebp
   24dba:	e9 fc ff ff ff       	jmp    24dbb <aes_decrypt_key+0x3b>
   24dbf:	90                   	nop    
   24dc0:	3d c0 00 00 00       	cmp    $0xc0,%eax
   24dc5:	74 e0                	je     24da7 <aes_decrypt_key+0x27>
   24dc7:	3d c0 00 00 00       	cmp    $0xc0,%eax
   24dcc:	7f 07                	jg     24dd5 <aes_decrypt_key+0x55>
   24dce:	83 c0 80             	add    $0xffffff80,%eax
   24dd1:	74 e0                	je     24db3 <aes_decrypt_key+0x33>
   24dd3:	eb cb                	jmp    24da0 <aes_decrypt_key+0x20>
   24dd5:	3d 00 01 00 00       	cmp    $0x100,%eax
   24dda:	75 c4                	jne    24da0 <aes_decrypt_key+0x20>
   24ddc:	89 55 0c             	mov    %edx,0xc(%ebp)
   24ddf:	89 4d 08             	mov    %ecx,0x8(%ebp)
   24de2:	5d                   	pop    %ebp
   24de3:	e9 fc ff ff ff       	jmp    24de4 <aes_decrypt_key+0x64>
   24de8:	90                   	nop    
   24de9:	90                   	nop    
   24dea:	90                   	nop    
   24deb:	90                   	nop    
   24dec:	90                   	nop    
   24ded:	90                   	nop    
   24dee:	90                   	nop    
   24def:	90                   	nop    

00024df0 <gen_tabs>:

/* implemented in case of wrong call for fixed tables */

void gen_tabs(void)
{
   24df0:	55                   	push   %ebp
   24df1:	89 e5                	mov    %esp,%ebp
}
   24df3:	5d                   	pop    %ebp
   24df4:	c3                   	ret    
   24df5:	90                   	nop    
   24df6:	90                   	nop    
   24df7:	90                   	nop    
   24df8:	90                   	nop    
   24df9:	90                   	nop    
   24dfa:	90                   	nop    
   24dfb:	90                   	nop    
   24dfc:	90                   	nop    
   24dfd:	90                   	nop    
   24dfe:	90                   	nop    
   24dff:	90                   	nop    

00024e00 <MD5>:
#include <openssl/ebcdic.h>
#endif

unsigned char *MD5(const unsigned char *d, unsigned long n, unsigned char *md)
	{
   24e00:	55                   	push   %ebp
   24e01:	89 e5                	mov    %esp,%ebp
	MD5_CTX c;
	static unsigned char m[MD5_DIGEST_LENGTH];

	if (md == NULL) md=m;
   24e03:	b8 68 ab 16 00       	mov    $0x16ab68,%eax
   24e08:	56                   	push   %esi
   24e09:	53                   	push   %ebx
	MD5_Init(&c);
   24e0a:	8d 5d 98             	lea    0xffffff98(%ebp),%ebx
   24e0d:	83 ec 6c             	sub    $0x6c,%esp
   24e10:	89 1c 24             	mov    %ebx,(%esp,1)
   24e13:	8b 75 10             	mov    0x10(%ebp),%esi
   24e16:	85 f6                	test   %esi,%esi
   24e18:	0f 44 f0             	cmove  %eax,%esi
   24e1b:	e8 fc ff ff ff       	call   24e1c <MD5+0x1c>
#ifndef CHARSET_EBCDIC
	MD5_Update(&c,d,n);
   24e20:	8b 45 0c             	mov    0xc(%ebp),%eax
   24e23:	89 1c 24             	mov    %ebx,(%esp,1)
   24e26:	89 44 24 08          	mov    %eax,0x8(%esp,1)
   24e2a:	8b 45 08             	mov    0x8(%ebp),%eax
   24e2d:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   24e31:	e8 fc ff ff ff       	call   24e32 <MD5+0x32>
#else
	{
		char temp[1024];
		unsigned long chunk;

		while (n > 0)
		{
			chunk = (n > sizeof(temp)) ? sizeof(temp) : n;
			ebcdic2ascii(temp, d, chunk);
			MD5_Update(&c,temp,chunk);
			n -= chunk;
			d += chunk;
		}
	}
#endif
	MD5_Final(md,&c);
   24e36:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
   24e3a:	89 34 24             	mov    %esi,(%esp,1)
   24e3d:	e8 fc ff ff ff       	call   24e3e <MD5+0x3e>
#endif

static inline void OPENSSL_cleanse(char *dest, int len) {
	int i;
	for(i=0; i < len; i++) {
   24e42:	31 c0                	xor    %eax,%eax
   24e44:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   24e4a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
		dest[i] = 0;
   24e50:	c6 04 18 00          	movb   $0x0,(%eax,%ebx,1)
   24e54:	40                   	inc    %eax
   24e55:	83 f8 5c             	cmp    $0x5c,%eax
   24e58:	7c f6                	jl     24e50 <MD5+0x50>
	OPENSSL_cleanse(&c,sizeof(c)); /* security consideration */
	return(md);
	}
   24e5a:	83 c4 6c             	add    $0x6c,%esp
   24e5d:	89 f0                	mov    %esi,%eax
   24e5f:	5b                   	pop    %ebx
   24e60:	5e                   	pop    %esi
   24e61:	5d                   	pop    %ebp
   24e62:	c3                   	ret    
   24e63:	90                   	nop    
   24e64:	90                   	nop    
   24e65:	90                   	nop    
   24e66:	90                   	nop    
   24e67:	90                   	nop    
   24e68:	90                   	nop    
   24e69:	90                   	nop    
   24e6a:	90                   	nop    
   24e6b:	90                   	nop    
   24e6c:	90                   	nop    
   24e6d:	90                   	nop    
   24e6e:	90                   	nop    
   24e6f:	90                   	nop    

00024e70 <MD5_Update>:
 * Time for some action:-)
 */

void HASH_UPDATE (HASH_CTX *c, const void *data_, unsigned long len)
	{
   24e70:	55                   	push   %ebp
   24e71:	89 e5                	mov    %esp,%ebp
   24e73:	57                   	push   %edi
   24e74:	56                   	push   %esi
   24e75:	53                   	push   %ebx
   24e76:	83 ec 14             	sub    $0x14,%esp
   24e79:	8b 75 10             	mov    0x10(%ebp),%esi
	const unsigned char *data=data_;
   24e7c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	register HASH_LONG * p;
	register unsigned long l;
	int sw,sc,ew,ec;

	if (len==0) return;
   24e7f:	85 f6                	test   %esi,%esi
   24e81:	0f 84 74 01 00 00    	je     24ffb <MD5_Update+0x18b>

	l=(c->Nl+(len<<3))&0xffffffffL;
   24e87:	8b 55 08             	mov    0x8(%ebp),%edx
   24e8a:	8b 42 10             	mov    0x10(%edx),%eax
   24e8d:	8d 14 f0             	lea    (%eax,%esi,8),%edx
	/* 95-05-24 eay Fixed a bug with the overflow handling, thanks to
	 * Wei Dai <weidai@eskimo.com> for pointing it out. */
	if (l < c->Nl) /* overflow */
   24e90:	39 c2                	cmp    %eax,%edx
   24e92:	73 06                	jae    24e9a <MD5_Update+0x2a>
		c->Nh++;
   24e94:	8b 4d 08             	mov    0x8(%ebp),%ecx
   24e97:	ff 41 14             	incl   0x14(%ecx)
	c->Nh+=(len>>29);
   24e9a:	8b 4d 08             	mov    0x8(%ebp),%ecx
   24e9d:	89 f0                	mov    %esi,%eax
   24e9f:	c1 e8 1d             	shr    $0x1d,%eax
   24ea2:	01 41 14             	add    %eax,0x14(%ecx)
	c->Nl=l;

	if (c->num != 0)
   24ea5:	8b 41 58             	mov    0x58(%ecx),%eax
   24ea8:	89 51 10             	mov    %edx,0x10(%ecx)
   24eab:	85 c0                	test   %eax,%eax
   24ead:	0f 84 b6 00 00 00    	je     24f69 <MD5_Update+0xf9>
		{
		p=c->data;
   24eb3:	83 c1 18             	add    $0x18,%ecx
		sw=c->num>>2;
   24eb6:	89 c7                	mov    %eax,%edi
		sc=c->num&0x03;

		if ((c->num+len) >= HASH_CBLOCK)
   24eb8:	8d 14 06             	lea    (%esi,%eax,1),%edx
   24ebb:	89 4d f0             	mov    %ecx,0xfffffff0(%ebp)
   24ebe:	89 c1                	mov    %eax,%ecx
   24ec0:	c1 ff 02             	sar    $0x2,%edi
   24ec3:	83 e1 03             	and    $0x3,%ecx
   24ec6:	83 fa 3f             	cmp    $0x3f,%edx
   24ec9:	0f 86 84 01 00 00    	jbe    25053 <MD5_Update+0x1e3>
			{
			l=p[sw]; HOST_p_c2l(data,l,sc); p[sw++]=l;
   24ecf:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   24ed2:	83 f9 01             	cmp    $0x1,%ecx
   24ed5:	8b 14 b8             	mov    (%eax,%edi,4),%edx
   24ed8:	0f 84 6a 01 00 00    	je     25048 <MD5_Update+0x1d8>
   24ede:	83 f9 01             	cmp    $0x1,%ecx
   24ee1:	0f 8e 55 01 00 00    	jle    2503c <MD5_Update+0x1cc>
   24ee7:	83 f9 02             	cmp    $0x2,%ecx
   24eea:	0f 84 41 01 00 00    	je     25031 <MD5_Update+0x1c1>
   24ef0:	83 f9 03             	cmp    $0x3,%ecx
   24ef3:	0f 84 2a 01 00 00    	je     25023 <MD5_Update+0x1b3>
   24ef9:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
   24efc:	89 14 b9             	mov    %edx,(%ecx,%edi,4)
   24eff:	47                   	inc    %edi
			for (; sw<HASH_LBLOCK; sw++)
   24f00:	83 ff 0f             	cmp    $0xf,%edi
   24f03:	7f 36                	jg     24f3b <MD5_Update+0xcb>
   24f05:	8d 74 26 00          	lea    0x0(%esi,1),%esi
   24f09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
				{
				HOST_c2l(data,l); p[sw]=l;
   24f10:	0f b6 13             	movzbl (%ebx),%edx
   24f13:	43                   	inc    %ebx
   24f14:	0f b6 03             	movzbl (%ebx),%eax
   24f17:	43                   	inc    %ebx
   24f18:	c1 e0 08             	shl    $0x8,%eax
   24f1b:	09 c2                	or     %eax,%edx
   24f1d:	0f b6 03             	movzbl (%ebx),%eax
   24f20:	43                   	inc    %ebx
   24f21:	c1 e0 10             	shl    $0x10,%eax
   24f24:	09 c2                	or     %eax,%edx
   24f26:	0f b6 03             	movzbl (%ebx),%eax
   24f29:	43                   	inc    %ebx
   24f2a:	c1 e0 18             	shl    $0x18,%eax
   24f2d:	09 c2                	or     %eax,%edx
   24f2f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   24f32:	89 14 b8             	mov    %edx,(%eax,%edi,4)
   24f35:	47                   	inc    %edi
   24f36:	83 ff 0f             	cmp    $0xf,%edi
   24f39:	7e d5                	jle    24f10 <MD5_Update+0xa0>
				}
			HASH_BLOCK_HOST_ORDER (c,p,1);
   24f3b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp,1)
   24f42:	00 
   24f43:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
   24f46:	8b 4d 08             	mov    0x8(%ebp),%ecx
   24f49:	89 54 24 04          	mov    %edx,0x4(%esp,1)
   24f4d:	89 0c 24             	mov    %ecx,(%esp,1)
   24f50:	e8 fc ff ff ff       	call   24f51 <MD5_Update+0xe1>
			len-=(HASH_CBLOCK-c->num);
   24f55:	8b 55 08             	mov    0x8(%ebp),%edx
   24f58:	89 f0                	mov    %esi,%eax
   24f5a:	8b 7a 58             	mov    0x58(%edx),%edi
			c->num=0;
   24f5d:	c7 42 58 00 00 00 00 	movl   $0x0,0x58(%edx)
   24f64:	01 f8                	add    %edi,%eax
   24f66:	8d 70 c0             	lea    0xffffffc0(%eax),%esi
			/* drop through and do the rest */
			}
		else
			{
			c->num+=len;
			if ((sc+len) < 4) /* ugly, add char's to a word */
				{
				l=p[sw]; HOST_p_c2l_p(data,l,sc,len); p[sw]=l;
				}
			else
				{
				ew=(c->num>>2);
				ec=(c->num&0x03);
				l=p[sw]; HOST_p_c2l(data,l,sc); p[sw++]=l;
				for (; sw < ew; sw++)
					{
					HOST_c2l(data,l); p[sw]=l;
					}
				if (ec)
					{
					HOST_c2l_p(data,l,ec); p[sw]=l;
					}
				}
			return;
			}
		}

	sw=len/HASH_CBLOCK;
   24f69:	89 f7                	mov    %esi,%edi
   24f6b:	c1 ef 06             	shr    $0x6,%edi
	if (sw > 0)
   24f6e:	85 ff                	test   %edi,%edi
   24f70:	7e 1a                	jle    24f8c <MD5_Update+0x11c>
		{
#if defined(HASH_BLOCK_DATA_ORDER_ALIGNED)
		/*
		 * Note that HASH_BLOCK_DATA_ORDER_ALIGNED gets defined
		 * only if sizeof(HASH_LONG)==4.
		 */
		if ((((unsigned long)data)%4) == 0)
			{
			/* data is properly aligned so that we can cast it: */
			HASH_BLOCK_DATA_ORDER_ALIGNED (c,(HASH_LONG *)data,sw);
			sw*=HASH_CBLOCK;
			data+=sw;
			len-=sw;
			}
		else
#if !defined(HASH_BLOCK_DATA_ORDER)
			while (sw--)
				{
				memcpy (p=c->data,data,HASH_CBLOCK);
				HASH_BLOCK_DATA_ORDER_ALIGNED(c,p,1);
				data+=HASH_CBLOCK;
				len-=HASH_CBLOCK;
				}
#endif
#endif
#if defined(HASH_BLOCK_DATA_ORDER)
			{
			HASH_BLOCK_DATA_ORDER(c,data,sw);
   24f72:	89 7c 24 08          	mov    %edi,0x8(%esp,1)
   24f76:	8b 45 08             	mov    0x8(%ebp),%eax
			sw*=HASH_CBLOCK;
   24f79:	c1 e7 06             	shl    $0x6,%edi
   24f7c:	89 5c 24 04          	mov    %ebx,0x4(%esp,1)
			data+=sw;
			len-=sw;
   24f80:	29 fe                	sub    %edi,%esi
   24f82:	89 04 24             	mov    %eax,(%esp,1)
   24f85:	01 fb                	add    %edi,%ebx
   24f87:	e8 fc ff ff ff       	call   24f88 <MD5_Update+0x118>
			}
#endif
		}

	if (len!=0)
   24f8c:	85 f6                	test   %esi,%esi
   24f8e:	74 6b                	je     24ffb <MD5_Update+0x18b>
		{
		p = c->data;
   24f90:	8b 55 08             	mov    0x8(%ebp),%edx
		c->num = len;
		ew=len>>2;	/* words to copy */
		ec=len&0x03;
   24f93:	89 f0                	mov    %esi,%eax
   24f95:	8b 4d 08             	mov    0x8(%ebp),%ecx
   24f98:	83 e0 03             	and    $0x3,%eax
   24f9b:	83 c2 18             	add    $0x18,%edx
   24f9e:	89 55 f0             	mov    %edx,0xfffffff0(%ebp)
   24fa1:	89 71 58             	mov    %esi,0x58(%ecx)
		for (; ew; ew--,p++)
   24fa4:	c1 ee 02             	shr    $0x2,%esi
   24fa7:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
   24faa:	74 31                	je     24fdd <MD5_Update+0x16d>
   24fac:	8d 74 26 00          	lea    0x0(%esi,1),%esi
			{
			HOST_c2l(data,l); *p=l;
   24fb0:	0f b6 13             	movzbl (%ebx),%edx
   24fb3:	43                   	inc    %ebx
   24fb4:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
   24fb7:	0f b6 03             	movzbl (%ebx),%eax
   24fba:	43                   	inc    %ebx
   24fbb:	c1 e0 08             	shl    $0x8,%eax
   24fbe:	09 c2                	or     %eax,%edx
   24fc0:	0f b6 03             	movzbl (%ebx),%eax
   24fc3:	43                   	inc    %ebx
   24fc4:	c1 e0 10             	shl    $0x10,%eax
   24fc7:	09 c2                	or     %eax,%edx
   24fc9:	0f b6 03             	movzbl (%ebx),%eax
   24fcc:	43                   	inc    %ebx
   24fcd:	c1 e0 18             	shl    $0x18,%eax
   24fd0:	09 c2                	or     %eax,%edx
   24fd2:	89 11                	mov    %edx,(%ecx)
   24fd4:	83 c1 04             	add    $0x4,%ecx
   24fd7:	4e                   	dec    %esi
   24fd8:	89 4d f0             	mov    %ecx,0xfffffff0(%ebp)
   24fdb:	75 d3                	jne    24fb0 <MD5_Update+0x140>
			}
		HOST_c2l_p(data,l,ec);
   24fdd:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
   24fe0:	31 d2                	xor    %edx,%edx
   24fe2:	01 c3                	add    %eax,%ebx
   24fe4:	83 7d ec 02          	cmpl   $0x2,0xffffffec(%ebp)
   24fe8:	74 2e                	je     25018 <MD5_Update+0x1a8>
   24fea:	83 7d ec 02          	cmpl   $0x2,0xffffffec(%ebp)
   24fee:	7f 1b                	jg     2500b <MD5_Update+0x19b>
   24ff0:	83 7d ec 01          	cmpl   $0x1,0xffffffec(%ebp)
   24ff4:	74 0d                	je     25003 <MD5_Update+0x193>
		*p=l;
   24ff6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   24ff9:	89 10                	mov    %edx,(%eax)
		}
	}
   24ffb:	83 c4 14             	add    $0x14,%esp
   24ffe:	5b                   	pop    %ebx
   24fff:	5e                   	pop    %esi
   25000:	5f                   	pop    %edi
   25001:	5d                   	pop    %ebp
   25002:	c3                   	ret    
   25003:	0f b6 43 ff          	movzbl 0xffffffff(%ebx),%eax
   25007:	09 c2                	or     %eax,%edx
   25009:	eb eb                	jmp    24ff6 <MD5_Update+0x186>
   2500b:	83 7d ec 03          	cmpl   $0x3,0xffffffec(%ebp)
   2500f:	75 e5                	jne    24ff6 <MD5_Update+0x186>
   25011:	4b                   	dec    %ebx
   25012:	0f b6 13             	movzbl (%ebx),%edx
   25015:	c1 e2 10             	shl    $0x10,%edx
   25018:	4b                   	dec    %ebx
   25019:	0f b6 03             	movzbl (%ebx),%eax
   2501c:	c1 e0 08             	shl    $0x8,%eax
   2501f:	09 c2                	or     %eax,%edx
   25021:	eb e0                	jmp    25003 <MD5_Update+0x193>
   25023:	0f b6 03             	movzbl (%ebx),%eax
   25026:	43                   	inc    %ebx
   25027:	c1 e0 18             	shl    $0x18,%eax
   2502a:	09 c2                	or     %eax,%edx
   2502c:	e9 c8 fe ff ff       	jmp    24ef9 <MD5_Update+0x89>
   25031:	0f b6 03             	movzbl (%ebx),%eax
   25034:	43                   	inc    %ebx
   25035:	c1 e0 10             	shl    $0x10,%eax
   25038:	09 c2                	or     %eax,%edx
   2503a:	eb e7                	jmp    25023 <MD5_Update+0x1b3>
   2503c:	85 c9                	test   %ecx,%ecx
   2503e:	0f 85 b5 fe ff ff    	jne    24ef9 <MD5_Update+0x89>
   25044:	0f b6 13             	movzbl (%ebx),%edx
   25047:	43                   	inc    %ebx
   25048:	0f b6 03             	movzbl (%ebx),%eax
   2504b:	43                   	inc    %ebx
   2504c:	c1 e0 08             	shl    $0x8,%eax
   2504f:	09 c2                	or     %eax,%edx
   25051:	eb de                	jmp    25031 <MD5_Update+0x1c1>
   25053:	8b 45 08             	mov    0x8(%ebp),%eax
   25056:	89 50 58             	mov    %edx,0x58(%eax)
   25059:	8d 04 0e             	lea    (%esi,%ecx,1),%eax
   2505c:	83 f8 03             	cmp    $0x3,%eax
   2505f:	77 43                	ja     250a4 <MD5_Update+0x234>
   25061:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   25064:	83 f9 01             	cmp    $0x1,%ecx
   25067:	8b 14 b8             	mov    (%eax,%edi,4),%edx
   2506a:	74 2a                	je     25096 <MD5_Update+0x226>
   2506c:	83 f9 01             	cmp    $0x1,%ecx
   2506f:	7e 1a                	jle    2508b <MD5_Update+0x21b>
   25071:	83 f9 02             	cmp    $0x2,%ecx
   25074:	74 0b                	je     25081 <MD5_Update+0x211>
   25076:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
   25079:	89 14 b9             	mov    %edx,(%ecx,%edi,4)
   2507c:	e9 7a ff ff ff       	jmp    24ffb <MD5_Update+0x18b>
   25081:	0f b6 03             	movzbl (%ebx),%eax
   25084:	c1 e0 10             	shl    $0x10,%eax
   25087:	09 c2                	or     %eax,%edx
   25089:	eb eb                	jmp    25076 <MD5_Update+0x206>
   2508b:	85 c9                	test   %ecx,%ecx
   2508d:	75 e7                	jne    25076 <MD5_Update+0x206>
   2508f:	0f b6 13             	movzbl (%ebx),%edx
   25092:	43                   	inc    %ebx
   25093:	4e                   	dec    %esi
   25094:	74 e0                	je     25076 <MD5_Update+0x206>
   25096:	0f b6 03             	movzbl (%ebx),%eax
   25099:	43                   	inc    %ebx
   2509a:	c1 e0 08             	shl    $0x8,%eax
   2509d:	09 c2                	or     %eax,%edx
   2509f:	4e                   	dec    %esi
   250a0:	74 d4                	je     25076 <MD5_Update+0x206>
   250a2:	eb dd                	jmp    25081 <MD5_Update+0x211>
   250a4:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   250a7:	89 d6                	mov    %edx,%esi
   250a9:	83 e2 03             	and    $0x3,%edx
   250ac:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
   250af:	c1 fe 02             	sar    $0x2,%esi
   250b2:	83 f9 01             	cmp    $0x1,%ecx
   250b5:	8b 14 b8             	mov    (%eax,%edi,4),%edx
   250b8:	0f 84 ce 00 00 00    	je     2518c <MD5_Update+0x31c>
   250be:	83 f9 01             	cmp    $0x1,%ecx
   250c1:	0f 8e b9 00 00 00    	jle    25180 <MD5_Update+0x310>
   250c7:	83 f9 02             	cmp    $0x2,%ecx
   250ca:	0f 84 a5 00 00 00    	je     25175 <MD5_Update+0x305>
   250d0:	83 f9 03             	cmp    $0x3,%ecx
   250d3:	0f 84 8e 00 00 00    	je     25167 <MD5_Update+0x2f7>
   250d9:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
   250dc:	89 14 b9             	mov    %edx,(%ecx,%edi,4)
   250df:	47                   	inc    %edi
   250e0:	39 f7                	cmp    %esi,%edi
   250e2:	7d 36                	jge    2511a <MD5_Update+0x2aa>
   250e4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   250ea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
   250f0:	0f b6 13             	movzbl (%ebx),%edx
   250f3:	43                   	inc    %ebx
   250f4:	0f b6 03             	movzbl (%ebx),%eax
   250f7:	43                   	inc    %ebx
   250f8:	c1 e0 08             	shl    $0x8,%eax
   250fb:	09 c2                	or     %eax,%edx
   250fd:	0f b6 03             	movzbl (%ebx),%eax
   25100:	43                   	inc    %ebx
   25101:	c1 e0 10             	shl    $0x10,%eax
   25104:	09 c2                	or     %eax,%edx
   25106:	0f b6 03             	movzbl (%ebx),%eax
   25109:	43                   	inc    %ebx
   2510a:	c1 e0 18             	shl    $0x18,%eax
   2510d:	09 c2                	or     %eax,%edx
   2510f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
   25112:	89 14 b8             	mov    %edx,(%eax,%edi,4)
   25115:	47                   	inc    %edi
   25116:	39 f7                	cmp    %esi,%edi
   25118:	7c d6                	jl     250f0 <MD5_Update+0x280>
   2511a:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
   2511d:	85 f6                	test   %esi,%esi
   2511f:	0f 84 d6 fe ff ff    	je     24ffb <MD5_Update+0x18b>
   25125:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
   25128:	31 d2                	xor    %edx,%edx
   2512a:	01 cb                	add    %ecx,%ebx
   2512c:	83 7d ec 02          	cmpl   $0x2,0xffffffec(%ebp)
   25130:	74 2a                	je     2515c <MD5_Update+0x2ec>
   25132:	83 7d ec 02          	cmpl   $0x2,0xffffffec(%ebp)
   25136:	7f 13                	jg     2514b <MD5_Update+0x2db>
   25138:	83 7d ec 01          	cmpl   $0x1,0xffffffec(%ebp)
   2513c:	0f 85 34 ff ff ff    	jne    25076 <MD5_Update+0x206>
   25142:	0f b6 43 ff          	movzbl 0xffffffff(%ebx),%eax
   25146:	e9 3c ff ff ff       	jmp    25087 <MD5_Update+0x217>
   2514b:	83 7d ec 03          	cmpl   $0x3,0xffffffec(%ebp)
   2514f:	0f 85 21 ff ff ff    	jne    25076 <MD5_Update+0x206>
   25155:	4b                   	dec    %ebx
   25156:	0f b6 13             	movzbl (%ebx),%edx
   25159:	c1 e2 10             	shl    $0x10,%edx
   2515c:	4b                   	dec    %ebx
   2515d:	0f b6 03             	movzbl (%ebx),%eax
   25160:	c1 e0 08             	shl    $0x8,%eax
   25163:	09 c2                	or     %eax,%edx
   25165:	eb db                	jmp    25142 <MD5_Update+0x2d2>
   25167:	0f b6 03             	movzbl (%ebx),%eax
   2516a:	43                   	inc    %ebx
   2516b:	c1 e0 18             	shl    $0x18,%eax
   2516e:	09 c2                	or     %eax,%edx
   25170:	e9 64 ff ff ff       	jmp    250d9 <MD5_Update+0x269>
   25175:	0f b6 03             	movzbl (%ebx),%eax
   25178:	43                   	inc    %ebx
   25179:	c1 e0 10             	shl    $0x10,%eax
   2517c:	09 c2                	or     %eax,%edx
   2517e:	eb e7                	jmp    25167 <MD5_Update+0x2f7>
   25180:	85 c9                	test   %ecx,%ecx
   25182:	0f 85 51 ff ff ff    	jne    250d9 <MD5_Update+0x269>
   25188:	0f b6 13             	movzbl (%ebx),%edx
   2518b:	43                   	inc    %ebx
   2518c:	0f b6 03             	movzbl (%ebx),%eax
   2518f:	43                   	inc    %ebx
   25190:	c1 e0 08             	shl    $0x8,%eax
   25193:	09 c2                	or     %eax,%edx
   25195:	eb de                	jmp    25175 <MD5_Update+0x305>
   25197:	89 f6                	mov    %esi,%esi
   25199:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi

000251a0 <MD5_Transform>:


void HASH_TRANSFORM (HASH_CTX *c, const unsigned char *data)
	{
   251a0:	55                   	push   %ebp
   251a1:	89 e5                	mov    %esp,%ebp
   251a3:	83 ec 0c             	sub    $0xc,%esp
#if defined(HASH_BLOCK_DATA_ORDER_ALIGNED)
	if ((((unsigned long)data)%4) == 0)
		/* data is properly aligned so that we can cast it: */
		HASH_BLOCK_DATA_ORDER_ALIGNED (c,(HASH_LONG *)data,1);
	else
#if !defined(HASH_BLOCK_DATA_ORDER)
		{
		memcpy (c->data,data,HASH_CBLOCK);
		HASH_BLOCK_DATA_ORDER_ALIGNED (c,c->data,1);
		}
#endif
#endif
#if defined(HASH_BLOCK_DATA_ORDER)
	HASH_BLOCK_DATA_ORDER (c,data,1);
   251a6:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp,1)
   251ad:	00 
   251ae:	8b 45 0c             	mov    0xc(%ebp),%eax
   251b1:	89 44 24 04          	mov    %eax,0x4(%esp,1)
   251b5:	8b 45 08             	mov    0x8(%ebp),%eax
   251b8:	89 04 24             	mov    %eax,(%esp,1)
   251bb:	e8 fc ff ff ff       	call   251bc <MD5_Transform+0x1c>
#endif
	}
   251c0:	89 ec                	mov    %ebp,%esp
   251c2:	5d                   	pop    %ebp
   251c3:	c3                   	ret    
   251c4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   251ca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

000251d0 <MD5_Final>:


void HASH_FINAL (unsigned char *md, HASH_CTX *c)
	{
   251d0:	55                   	push   %ebp
   251d1:	89 e5                	mov    %esp,%ebp
   251d3:	57                   	push   %edi
	register HASH_LONG *p;
	register unsigned long l;
	register int i,j;
	static const unsigned char end[4]={0x80,0x00,0x00,0x00};
	const unsigned char *cp=end;
   251d4:	bf 00 c9 00 00       	mov    $0xc900,%edi
   251d9:	56                   	push   %esi
   251da:	53                   	push   %ebx
   251db:	83 ec 0c             	sub    $0xc,%esp

	/* c->num should definitly have room for at least one more byte. */
	p=c->data;
	i=c->num>>2;
   251de:	8b 55 0c             	mov    0xc(%ebp),%edx
   251e1:	8b 75 0c             	mov    0xc(%ebp),%esi
   251e4:	8b 5d 08             	mov    0x8(%ebp),%ebx
   251e7:	8b 42 58             	mov    0x58(%edx),%eax
   251ea:	83 c6 18             	add    $0x18,%esi
   251ed:	89 c2                	mov    %eax,%edx
   251ef:	c1 fa 02             	sar    $0x2,%edx
	j=c->num&0x03;

#if 0
	/* purify often complains about the following line as an
	 * Uninitialized Memory Read.  While this can be true, the
	 * following p_c2l macro will reset l when that case is true.
	 * This is because j&0x03 contains the number of 'valid' bytes
	 * already in p[i].  If and only if j&0x03 == 0, the UMR will
	 * occur but this is also the only time p_c2l will do
	 * l= *(cp++) instead of l|= *(cp++)
	 * Many thanks to Alex Tang <altitude@cic.net> for pickup this
	 * 'potential bug' */
#ifdef PURIFY
	if (j==0) p[i]=0; /* Yeah, but that's not the way to fix it:-) */
#endif
	l=p[i];
#else
	l = (j==0) ? 0 : p[i];
   251f2:	83 e0 03             	and    $0x3,%eax
   251f5:	0f 84 3c 01 00 00    	je     25337 <MD5_Final+0x167>
   251fb:	8b 0c 96             	mov    (%esi,%edx,4),%ecx
#endif
	HOST_p_c2l(cp,l,j); p[i++]=l; /* i is the next 'undefined word' */
   251fe:	83 f8 01             	cmp    $0x1,%eax
   25201:	0f 84 25 01 00 00    	je     2532c <MD5_Final+0x15c>
   25207:	83 f8 01             	cmp    $0x1,%eax
   2520a:	0f 8e 08 01 00 00    	jle    25318 <MD5_Final+0x148>
   25210:	83 f8 02             	cmp    $0x2,%eax
   25213:	0f 84 f4 00 00 00    	je     2530d <MD5_Final+0x13d>
   25219:	83 f8 03             	cmp    $0x3,%eax
   2521c:	0f 84 de 00 00 00    	je     25300 <MD5_Final+0x130>
   25222:	89 0c 96             	mov    %ecx,(%esi,%edx,4)
   25225:	42                   	inc    %edx

	if (i>(HASH_LBLOCK-2)) /* save room for Nl and Nh */
   25226:	83 fa 0e             	cmp    $0xe,%edx
   25229:	7e 25                	jle    25250 <MD5_Final+0x80>
		{
		if (i<HASH_LBLOCK) p[i]=0;
   2522b:	83 fa 0f             	cmp    $0xf,%edx
   2522e:	7f 07                	jg     25237 <MD5_Final+0x67>
   25230:	c7 04 96 00 00 00 00 	movl   $0x0,(%esi,%edx,4)
		HASH_BLOCK_HOST_ORDER (c,p,1);
   25237:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp,1)
   2523e:	00 
   2523f:	8b 45 0c             	mov    0xc(%ebp),%eax
   25242:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   25246:	89 04 24             	mov    %eax,(%esp,1)
   25249:	e8 fc ff ff ff       	call   2524a <MD5_Final+0x7a>
		i=0;
   2524e:	31 d2                	xor    %edx,%edx
		}
	for (; i<(HASH_LBLOCK-2); i++)
   25250:	83 fa 0d             	cmp    $0xd,%edx
   25253:	7f 18                	jg     2526d <MD5_Final+0x9d>
   25255:	8d 74 26 00          	lea    0x0(%esi,1),%esi
   25259:	8d bc 27 00 00 00 00 	lea    0x0(%edi,1),%edi
		p[i]=0;
   25260:	c7 04 96 00 00 00 00 	movl   $0x0,(%esi,%edx,4)
   25267:	42                   	inc    %edx
   25268:	83 fa 0d             	cmp    $0xd,%edx
   2526b:	7e f3                	jle    25260 <MD5_Final+0x90>

#if   defined(DATA_ORDER_IS_BIG_ENDIAN)
	p[HASH_LBLOCK-2]=c->Nh;
	p[HASH_LBLOCK-1]=c->Nl;
#elif defined(DATA_ORDER_IS_LITTLE_ENDIAN)
	p[HASH_LBLOCK-2]=c->Nl;
   2526d:	8b 55 0c             	mov    0xc(%ebp),%edx
   25270:	8b 42 10             	mov    0x10(%edx),%eax
   25273:	89 46 38             	mov    %eax,0x38(%esi)
	p[HASH_LBLOCK-1]=c->Nh;
   25276:	8b 42 14             	mov    0x14(%edx),%eax
   25279:	89 46 3c             	mov    %eax,0x3c(%esi)
#endif
	HASH_BLOCK_HOST_ORDER (c,p,1);
   2527c:	89 74 24 04          	mov    %esi,0x4(%esp,1)
   25280:	89 14 24             	mov    %edx,(%esp,1)
   25283:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp,1)
   2528a:	00 
   2528b:	e8 fc ff ff ff       	call   2528c <MD5_Final+0xbc>

#ifndef HASH_MAKE_STRING
#error "HASH_MAKE_STRING must be defined!"
#else
	HASH_MAKE_STRING(c,md);
   25290:	8b 55 0c             	mov    0xc(%ebp),%edx
   25293:	8b 02                	mov    (%edx),%eax
   25295:	88 03                	mov    %al,(%ebx)
   25297:	43                   	inc    %ebx
   25298:	c1 e8 08             	shr    $0x8,%eax
   2529b:	88 03                	mov    %al,(%ebx)
   2529d:	43                   	inc    %ebx
   2529e:	c1 e8 08             	shr    $0x8,%eax
   252a1:	88 03                	mov    %al,(%ebx)
   252a3:	43                   	inc    %ebx
   252a4:	c1 e8 08             	shr    $0x8,%eax
   252a7:	88 03                	mov    %al,(%ebx)
   252a9:	43                   	inc    %ebx
   252aa:	8b 42 04             	mov    0x4(%edx),%eax
   252ad:	88 03                	mov    %al,(%ebx)
   252af:	43                   	inc    %ebx
   252b0:	c1 e8 08             	shr    $0x8,%eax
   252b3:	88 03                	mov    %al,(%ebx)
   252b5:	43                   	inc    %ebx
   252b6:	c1 e8 08             	shr    $0x8,%eax
   252b9:	88 03                	mov    %al,(%ebx)
   252bb:	43                   	inc    %ebx
   252bc:	c1 e8 08             	shr    $0x8,%eax
   252bf:	88 03                	mov    %al,(%ebx)
   252c1:	43                   	inc    %ebx
   252c2:	8b 42 08             	mov    0x8(%edx),%eax
   252c5:	88 03                	mov    %al,(%ebx)
   252c7:	43                   	inc    %ebx
   252c8:	c1 e8 08             	shr    $0x8,%eax
   252cb:	88 03                	mov    %al,(%ebx)
   252cd:	43                   	inc    %ebx
   252ce:	c1 e8 08             	shr    $0x8,%eax
   252d1:	88 03                	mov    %al,(%ebx)
   252d3:	43                   	inc    %ebx
   252d4:	c1 e8 08             	shr    $0x8,%eax
   252d7:	88 03                	mov    %al,(%ebx)
   252d9:	43                   	inc    %ebx
   252da:	8b 42 0c             	mov    0xc(%edx),%eax
   252dd:	88 03                	mov    %al,(%ebx)
   252df:	43                   	inc    %ebx
   252e0:	c1 e8 08             	shr    $0x8,%eax
   252e3:	88 03                	mov    %al,(%ebx)
   252e5:	43                   	inc    %ebx
   252e6:	c1 e8 08             	shr    $0x8,%eax
   252e9:	88 03                	mov    %al,(%ebx)
   252eb:	c1 e8 08             	shr    $0x8,%eax
   252ee:	88 43 01             	mov    %al,0x1(%ebx)
#endif

	c->num=0;
   252f1:	c7 42 58 00 00 00 00 	movl   $0x0,0x58(%edx)
	/* clear stuff, HASH_BLOCK may be leaving some stuff on the stack
	 * but I'm not worried :-)
	OPENSSL_cleanse((void *)c,sizeof(HASH_CTX));
	 */
	}
   252f8:	83 c4 0c             	add    $0xc,%esp
   252fb:	5b                   	pop    %ebx
   252fc:	5e                   	pop    %esi
   252fd:	5f                   	pop    %edi
   252fe:	5d                   	pop    %ebp
   252ff:	c3                   	ret    
   25300:	0f b6 07             	movzbl (%edi),%eax
   25303:	c1 e0 18             	shl    $0x18,%eax
   25306:	09 c1                	or     %eax,%ecx
   25308:	e9 15 ff ff ff       	jmp    25222 <MD5_Final+0x52>
   2530d:	0f b6 07             	movzbl (%edi),%eax
   25310:	47                   	inc    %edi
   25311:	c1 e0 10             	shl    $0x10,%eax
   25314:	09 c1                	or     %eax,%ecx
   25316:	eb e8                	jmp    25300 <MD5_Final+0x130>
   25318:	85 c0                	test   %eax,%eax
   2531a:	0f 85 02 ff ff ff    	jne    25222 <MD5_Final+0x52>
   25320:	0f b6 0d 00 c9 00 00 	movzbl 0xc900,%ecx
   25327:	bf 01 c9 00 00       	mov    $0xc901,%edi
   2532c:	0f b6 07             	movzbl (%edi),%eax
   2532f:	47                   	inc    %edi
   25330:	c1 e0 08             	shl    $0x8,%eax
   25333:	09 c1                	or     %eax,%ecx
   25335:	eb d6                	jmp    2530d <MD5_Final+0x13d>
   25337:	31 c9                	xor    %ecx,%ecx
   25339:	e9 c0 fe ff ff       	jmp    251fe <MD5_Final+0x2e>
   2533e:	89 f6                	mov    %esi,%esi

00025340 <MD5_Init>:
#define INIT_DATA_C (unsigned long)0x98badcfeL
#define INIT_DATA_D (unsigned long)0x10325476L

void MD5_Init(MD5_CTX *c)
	{
   25340:	55                   	push   %ebp
   25341:	89 e5                	mov    %esp,%ebp
   25343:	8b 45 08             	mov    0x8(%ebp),%eax
	c->A=INIT_DATA_A;
   25346:	c7 00 01 23 45 67    	movl   $0x67452301,(%eax)
	c->B=INIT_DATA_B;
   2534c:	c7 40 04 89 ab cd ef 	movl   $0xefcdab89,0x4(%eax)
	c->C=INIT_DATA_C;
   25353:	c7 40 08 fe dc ba 98 	movl   $0x98badcfe,0x8(%eax)
	c->D=INIT_DATA_D;
   2535a:	c7 40 0c 76 54 32 10 	movl   $0x10325476,0xc(%eax)
	c->Nl=0;
   25361:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->Nh=0;
   25368:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	c->num=0;
   2536f:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
	}
   25376:	5d                   	pop    %ebp
   25377:	c3                   	ret    
   25378:	90                   	nop    
   25379:	90                   	nop    
   2537a:	90                   	nop    
   2537b:	90                   	nop    
   2537c:	90                   	nop    
   2537d:	90                   	nop    
   2537e:	90                   	nop    
   2537f:	90                   	nop    

00025380 <md5_block_asm_host_order>:
   25380:	56                   	push   %esi
   25381:	57                   	push   %edi
   25382:	8b 7c 24 0c          	mov    0xc(%esp,1),%edi
   25386:	8b 74 24 10          	mov    0x10(%esp,1),%esi
   2538a:	8b 4c 24 14          	mov    0x14(%esp,1),%ecx
   2538e:	55                   	push   %ebp
   2538f:	c1 e1 06             	shl    $0x6,%ecx
   25392:	53                   	push   %ebx
   25393:	01 f1                	add    %esi,%ecx
   25395:	83 e9 40             	sub    $0x40,%ecx
   25398:	8b 07                	mov    (%edi),%eax
   2539a:	51                   	push   %ecx
   2539b:	8b 5f 04             	mov    0x4(%edi),%ebx
   2539e:	8b 4f 08             	mov    0x8(%edi),%ecx
   253a1:	8b 57 0c             	mov    0xc(%edi),%edx
   253a4:	89 cf                	mov    %ecx,%edi
   253a6:	8b 2e                	mov    (%esi),%ebp
   253a8:	31 d7                	xor    %edx,%edi
   253aa:	21 df                	and    %ebx,%edi
   253ac:	8d 84 28 78 a4 6a d7 	lea    0xd76aa478(%eax,%ebp,1),%eax
   253b3:	31 d7                	xor    %edx,%edi
   253b5:	01 f8                	add    %edi,%eax
   253b7:	89 df                	mov    %ebx,%edi
   253b9:	c1 c0 07             	rol    $0x7,%eax
   253bc:	8b 6e 04             	mov    0x4(%esi),%ebp
   253bf:	01 d8                	add    %ebx,%eax
   253c1:	31 cf                	xor    %ecx,%edi
   253c3:	21 c7                	and    %eax,%edi
   253c5:	8d 94 2a 56 b7 c7 e8 	lea    0xe8c7b756(%edx,%ebp,1),%edx
   253cc:	31 cf                	xor    %ecx,%edi
   253ce:	01 fa                	add    %edi,%edx
   253d0:	89 c7                	mov    %eax,%edi
   253d2:	c1 c2 0c             	rol    $0xc,%edx
   253d5:	8b 6e 08             	mov    0x8(%esi),%ebp
   253d8:	01 c2                	add    %eax,%edx
   253da:	31 df                	xor    %ebx,%edi
   253dc:	21 d7                	and    %edx,%edi
   253de:	8d 8c 29 db 70 20 24 	lea    0x242070db(%ecx,%ebp,1),%ecx
   253e5:	31 df                	xor    %ebx,%edi
   253e7:	01 f9                	add    %edi,%ecx
   253e9:	89 d7                	mov    %edx,%edi
   253eb:	c1 c1 11             	rol    $0x11,%ecx
   253ee:	8b 6e 0c             	mov    0xc(%esi),%ebp
   253f1:	01 d1                	add    %edx,%ecx
   253f3:	31 c7                	xor    %eax,%edi
   253f5:	21 cf                	and    %ecx,%edi
   253f7:	8d 9c 2b ee ce bd c1 	lea    0xc1bdceee(%ebx,%ebp,1),%ebx
   253fe:	31 c7                	xor    %eax,%edi
   25400:	01 fb                	add    %edi,%ebx
   25402:	89 cf                	mov    %ecx,%edi
   25404:	c1 c3 16             	rol    $0x16,%ebx
   25407:	8b 6e 10             	mov    0x10(%esi),%ebp
   2540a:	01 cb                	add    %ecx,%ebx
   2540c:	31 d7                	xor    %edx,%edi
   2540e:	21 df                	and    %ebx,%edi
   25410:	8d 84 28 af 0f 7c f5 	lea    0xf57c0faf(%eax,%ebp,1),%eax
   25417:	31 d7                	xor    %edx,%edi
   25419:	01 f8                	add    %edi,%eax
   2541b:	89 df                	mov    %ebx,%edi
   2541d:	c1 c0 07             	rol    $0x7,%eax
   25420:	8b 6e 14             	mov    0x14(%esi),%ebp
   25423:	01 d8                	add    %ebx,%eax
   25425:	31 cf                	xor    %ecx,%edi
   25427:	21 c7                	and    %eax,%edi
   25429:	8d 94 2a 2a c6 87 47 	lea    0x4787c62a(%edx,%ebp,1),%edx
   25430:	31 cf                	xor    %ecx,%edi
   25432:	01 fa                	add    %edi,%edx
   25434:	89 c7                	mov    %eax,%edi
   25436:	c1 c2 0c             	rol    $0xc,%edx
   25439:	8b 6e 18             	mov    0x18(%esi),%ebp
   2543c:	01 c2                	add    %eax,%edx
   2543e:	31 df                	xor    %ebx,%edi
   25440:	21 d7                	and    %edx,%edi
   25442:	8d 8c 29 13 46 30 a8 	lea    0xa8304613(%ecx,%ebp,1),%ecx
   25449:	31 df                	xor    %ebx,%edi
   2544b:	01 f9                	add    %edi,%ecx
   2544d:	89 d7                	mov    %edx,%edi
   2544f:	c1 c1 11             	rol    $0x11,%ecx
   25452:	8b 6e 1c             	mov    0x1c(%esi),%ebp
   25455:	01 d1                	add    %edx,%ecx
   25457:	31 c7                	xor    %eax,%edi
   25459:	21 cf                	and    %ecx,%edi
   2545b:	8d 9c 2b 01 95 46 fd 	lea    0xfd469501(%ebx,%ebp,1),%ebx
   25462:	31 c7                	xor    %eax,%edi
   25464:	01 fb                	add    %edi,%ebx
   25466:	89 cf                	mov    %ecx,%edi
   25468:	c1 c3 16             	rol    $0x16,%ebx
   2546b:	8b 6e 20             	mov    0x20(%esi),%ebp
   2546e:	01 cb                	add    %ecx,%ebx
   25470:	31 d7                	xor    %edx,%edi
   25472:	21 df                	and    %ebx,%edi
   25474:	8d 84 28 d8 98 80 69 	lea    0x698098d8(%eax,%ebp,1),%eax
   2547b:	31 d7                	xor    %edx,%edi
   2547d:	01 f8                	add    %edi,%eax
   2547f:	89 df                	mov    %ebx,%edi
   25481:	c1 c0 07             	rol    $0x7,%eax
   25484:	8b 6e 24             	mov    0x24(%esi),%ebp
   25487:	01 d8                	add    %ebx,%eax
   25489:	31 cf                	xor    %ecx,%edi
   2548b:	21 c7                	and    %eax,%edi
   2548d:	8d 94 2a af f7 44 8b 	lea    0x8b44f7af(%edx,%ebp,1),%edx
   25494:	31 cf                	xor    %ecx,%edi
   25496:	01 fa                	add    %edi,%edx
   25498:	89 c7                	mov    %eax,%edi
   2549a:	c1 c2 0c             	rol    $0xc,%edx
   2549d:	8b 6e 28             	mov    0x28(%esi),%ebp
   254a0:	01 c2                	add    %eax,%edx
   254a2:	31 df                	xor    %ebx,%edi
   254a4:	21 d7                	and    %edx,%edi
   254a6:	8d 8c 29 b1 5b ff ff 	lea    0xffff5bb1(%ecx,%ebp,1),%ecx
   254ad:	31 df                	xor    %ebx,%edi
   254af:	01 f9                	add    %edi,%ecx
   254b1:	89 d7                	mov    %edx,%edi
   254b3:	c1 c1 11             	rol    $0x11,%ecx
   254b6:	8b 6e 2c             	mov    0x2c(%esi),%ebp
   254b9:	01 d1                	add    %edx,%ecx
   254bb:	31 c7                	xor    %eax,%edi
   254bd:	21 cf                	and    %ecx,%edi
   254bf:	8d 9c 2b be d7 5c 89 	lea    0x895cd7be(%ebx,%ebp,1),%ebx
   254c6:	31 c7                	xor    %eax,%edi
   254c8:	01 fb                	add    %edi,%ebx
   254ca:	89 cf                	mov    %ecx,%edi
   254cc:	c1 c3 16             	rol    $0x16,%ebx
   254cf:	8b 6e 30             	mov    0x30(%esi),%ebp
   254d2:	01 cb                	add    %ecx,%ebx
   254d4:	31 d7                	xor    %edx,%edi
   254d6:	21 df                	and    %ebx,%edi
   254d8:	8d 84 28 22 11 90 6b 	lea    0x6b901122(%eax,%ebp,1),%eax
   254df:	31 d7                	xor    %edx,%edi
   254e1:	01 f8                	add    %edi,%eax
   254e3:	89 df                	mov    %ebx,%edi
   254e5:	c1 c0 07             	rol    $0x7,%eax
   254e8:	8b 6e 34             	mov    0x34(%esi),%ebp
   254eb:	01 d8                	add    %ebx,%eax
   254ed:	31 cf                	xor    %ecx,%edi
   254ef:	21 c7                	and    %eax,%edi
   254f1:	8d 94 2a 93 71 98 fd 	lea    0xfd987193(%edx,%ebp,1),%edx
   254f8:	31 cf                	xor    %ecx,%edi
   254fa:	01 fa                	add    %edi,%edx
   254fc:	89 c7                	mov    %eax,%edi
   254fe:	c1 c2 0c             	rol    $0xc,%edx
   25501:	8b 6e 38             	mov    0x38(%esi),%ebp
   25504:	01 c2                	add    %eax,%edx
   25506:	31 df                	xor    %ebx,%edi
   25508:	21 d7                	and    %edx,%edi
   2550a:	8d 8c 29 8e 43 79 a6 	lea    0xa679438e(%ecx,%ebp,1),%ecx
   25511:	31 df                	xor    %ebx,%edi
   25513:	01 f9                	add    %edi,%ecx
   25515:	89 d7                	mov    %edx,%edi
   25517:	c1 c1 11             	rol    $0x11,%ecx
   2551a:	8b 6e 3c             	mov    0x3c(%esi),%ebp
   2551d:	01 d1                	add    %edx,%ecx
   2551f:	31 c7                	xor    %eax,%edi
   25521:	21 cf                	and    %ecx,%edi
   25523:	8d 9c 2b 21 08 b4 49 	lea    0x49b40821(%ebx,%ebp,1),%ebx
   2552a:	31 c7                	xor    %eax,%edi
   2552c:	01 fb                	add    %edi,%ebx
   2552e:	89 cf                	mov    %ecx,%edi
   25530:	c1 c3 16             	rol    $0x16,%ebx
   25533:	8b 6e 04             	mov    0x4(%esi),%ebp
   25536:	01 cb                	add    %ecx,%ebx
   25538:	8d 84 28 62 25 1e f6 	lea    0xf61e2562(%eax,%ebp,1),%eax
   2553f:	31 df                	xor    %ebx,%edi
   25541:	21 d7                	and    %edx,%edi
   25543:	8b 6e 18             	mov    0x18(%esi),%ebp
   25546:	31 cf                	xor    %ecx,%edi
   25548:	01 f8                	add    %edi,%eax
   2554a:	89 df                	mov    %ebx,%edi
   2554c:	c1 c0 05             	rol    $0x5,%eax
   2554f:	01 d8                	add    %ebx,%eax
   25551:	8d 94 2a 40 b3 40 c0 	lea    0xc040b340(%edx,%ebp,1),%edx
   25558:	31 c7                	xor    %eax,%edi
   2555a:	21 cf                	and    %ecx,%edi
   2555c:	8b 6e 2c             	mov    0x2c(%esi),%ebp
   2555f:	31 df                	xor    %ebx,%edi
   25561:	01 fa                	add    %edi,%edx
   25563:	89 c7                	mov    %eax,%edi
   25565:	c1 c2 09             	rol    $0x9,%edx
   25568:	01 c2                	add    %eax,%edx
   2556a:	8d 8c 29 51 5a 5e 26 	lea    0x265e5a51(%ecx,%ebp,1),%ecx
   25571:	31 d7                	xor    %edx,%edi
   25573:	21 df                	and    %ebx,%edi
   25575:	8b 2e                	mov    (%esi),%ebp
   25577:	31 c7                	xor    %eax,%edi
   25579:	01 f9                	add    %edi,%ecx
   2557b:	89 d7                	mov    %edx,%edi
   2557d:	c1 c1 0e             	rol    $0xe,%ecx
   25580:	01 d1                	add    %edx,%ecx
   25582:	8d 9c 2b aa c7 b6 e9 	lea    0xe9b6c7aa(%ebx,%ebp,1),%ebx
   25589:	31 cf                	xor    %ecx,%edi
   2558b:	21 c7                	and    %eax,%edi
   2558d:	8b 6e 14             	mov    0x14(%esi),%ebp
   25590:	31 d7                	xor    %edx,%edi
   25592:	01 fb                	add    %edi,%ebx
   25594:	89 cf                	mov    %ecx,%edi
   25596:	c1 c3 14             	rol    $0x14,%ebx
   25599:	01 cb                	add    %ecx,%ebx
   2559b:	8d 84 28 5d 10 2f d6 	lea    0xd62f105d(%eax,%ebp,1),%eax
   255a2:	31 df                	xor    %ebx,%edi
   255a4:	21 d7                	and    %edx,%edi
   255a6:	8b 6e 28             	mov    0x28(%esi),%ebp
   255a9:	31 cf                	xor    %ecx,%edi
   255ab:	01 f8                	add    %edi,%eax
   255ad:	89 df                	mov    %ebx,%edi
   255af:	c1 c0 05             	rol    $0x5,%eax
   255b2:	01 d8                	add    %ebx,%eax
   255b4:	8d 94 2a 53 14 44 02 	lea    0x2441453(%edx,%ebp,1),%edx
   255bb:	31 c7                	xor    %eax,%edi
   255bd:	21 cf                	and    %ecx,%edi
   255bf:	8b 6e 3c             	mov    0x3c(%esi),%ebp
   255c2:	31 df                	xor    %ebx,%edi
   255c4:	01 fa                	add    %edi,%edx
   255c6:	89 c7                	mov    %eax,%edi
   255c8:	c1 c2 09             	rol    $0x9,%edx
   255cb:	01 c2                	add    %eax,%edx
   255cd:	8d 8c 29 81 e6 a1 d8 	lea    0xd8a1e681(%ecx,%ebp,1),%ecx
   255d4:	31 d7                	xor    %edx,%edi
   255d6:	21 df                	and    %ebx,%edi
   255d8:	8b 6e 10             	mov    0x10(%esi),%ebp
   255db:	31 c7                	xor    %eax,%edi
   255dd:	01 f9                	add    %edi,%ecx
   255df:	89 d7                	mov    %edx,%edi
   255e1:	c1 c1 0e             	rol    $0xe,%ecx
   255e4:	01 d1                	add    %edx,%ecx
   255e6:	8d 9c 2b c8 fb d3 e7 	lea    0xe7d3fbc8(%ebx,%ebp,1),%ebx
   255ed:	31 cf                	xor    %ecx,%edi
   255ef:	21 c7                	and    %eax,%edi
   255f1:	8b 6e 24             	mov    0x24(%esi),%ebp
   255f4:	31 d7                	xor    %edx,%edi
   255f6:	01 fb                	add    %edi,%ebx
   255f8:	89 cf                	mov    %ecx,%edi
   255fa:	c1 c3 14             	rol    $0x14,%ebx
   255fd:	01 cb                	add    %ecx,%ebx
   255ff:	8d 84 28 e6 cd e1 21 	lea    0x21e1cde6(%eax,%ebp,1),%eax
   25606:	31 df                	xor    %ebx,%edi
   25608:	21 d7                	and    %edx,%edi
   2560a:	8b 6e 38             	mov    0x38(%esi),%ebp
   2560d:	31 cf                	xor    %ecx,%edi
   2560f:	01 f8                	add    %edi,%eax
   25611:	89 df                	mov    %ebx,%edi
   25613:	c1 c0 05             	rol    $0x5,%eax
   25616:	01 d8                	add    %ebx,%eax
   25618:	8d 94 2a d6 07 37 c3 	lea    0xc33707d6(%edx,%ebp,1),%edx
   2561f:	31 c7                	xor    %eax,%edi
   25621:	21 cf                	and    %ecx,%edi
   25623:	8b 6e 0c             	mov    0xc(%esi),%ebp
   25626:	31 df                	xor    %ebx,%edi
   25628:	01 fa                	add    %edi,%edx
   2562a:	89 c7                	mov    %eax,%edi
   2562c:	c1 c2 09             	rol    $0x9,%edx
   2562f:	01 c2                	add    %eax,%edx
   25631:	8d 8c 29 87 0d d5 f4 	lea    0xf4d50d87(%ecx,%ebp,1),%ecx
   25638:	31 d7                	xor    %edx,%edi
   2563a:	21 df                	and    %ebx,%edi
   2563c:	8b 6e 20             	mov    0x20(%esi),%ebp
   2563f:	31 c7                	xor    %eax,%edi
   25641:	01 f9                	add    %edi,%ecx
   25643:	89 d7                	mov    %edx,%edi
   25645:	c1 c1 0e             	rol    $0xe,%ecx
   25648:	01 d1                	add    %edx,%ecx
   2564a:	8d 9c 2b ed 14 5a 45 	lea    0x455a14ed(%ebx,%ebp,1),%ebx
   25651:	31 cf                	xor    %ecx,%edi
   25653:	21 c7                	and    %eax,%edi
   25655:	8b 6e 34             	mov    0x34(%esi),%ebp
   25658:	31 d7                	xor    %edx,%edi
   2565a:	01 fb                	add    %edi,%ebx
   2565c:	89 cf                	mov    %ecx,%edi
   2565e:	c1 c3 14             	rol    $0x14,%ebx
   25661:	01 cb                	add    %ecx,%ebx
   25663:	8d 84 28 05 e9 e3 a9 	lea    0xa9e3e905(%eax,%ebp,1),%eax
   2566a:	31 df                	xor    %ebx,%edi
   2566c:	21 d7                	and    %edx,%edi
   2566e:	8b 6e 08             	mov    0x8(%esi),%ebp
   25671:	31 cf                	xor    %ecx,%edi
   25673:	01 f8                	add    %edi,%eax
   25675:	89 df                	mov    %ebx,%edi
   25677:	c1 c0 05             	rol    $0x5,%eax
   2567a:	01 d8                	add    %ebx,%eax
   2567c:	8d 94 2a f8 a3 ef fc 	lea    0xfcefa3f8(%edx,%ebp,1),%edx
   25683:	31 c7                	xor    %eax,%edi
   25685:	21 cf                	and    %ecx,%edi
   25687:	8b 6e 1c             	mov    0x1c(%esi),%ebp
   2568a:	31 df                	xor    %ebx,%edi
   2568c:	01 fa                	add    %edi,%edx
   2568e:	89 c7                	mov    %eax,%edi
   25690:	c1 c2 09             	rol    $0x9,%edx
   25693:	01 c2                	add    %eax,%edx
   25695:	8d 8c 29 d9 02 6f 67 	lea    0x676f02d9(%ecx,%ebp,1),%ecx
   2569c:	31 d7                	xor    %edx,%edi
   2569e:	21 df                	and    %ebx,%edi
   256a0:	8b 6e 30             	mov    0x30(%esi),%ebp
   256a3:	31 c7                	xor    %eax,%edi
   256a5:	01 f9                	add    %edi,%ecx
   256a7:	89 d7                	mov    %edx,%edi
   256a9:	c1 c1 0e             	rol    $0xe,%ecx
   256ac:	01 d1                	add    %edx,%ecx
   256ae:	8d 9c 2b 8a 4c 2a 8d 	lea    0x8d2a4c8a(%ebx,%ebp,1),%ebx
   256b5:	31 cf                	xor    %ecx,%edi
   256b7:	21 c7                	and    %eax,%edi
   256b9:	8b 6e 14             	mov    0x14(%esi),%ebp
   256bc:	31 d7                	xor    %edx,%edi
   256be:	01 fb                	add    %edi,%ebx
   256c0:	89 cf                	mov    %ecx,%edi
   256c2:	c1 c3 14             	rol    $0x14,%ebx
   256c5:	01 cb                	add    %ecx,%ebx
   256c7:	31 d7                	xor    %edx,%edi
   256c9:	31 df                	xor    %ebx,%edi
   256cb:	8d 84 28 42 39 fa ff 	lea    0xfffa3942(%eax,%ebp,1),%eax
   256d2:	01 f8                	add    %edi,%eax
   256d4:	c1 c0 04             	rol    $0x4,%eax
   256d7:	8b 6e 20             	mov    0x20(%esi),%ebp
   256da:	89 df                	mov    %ebx,%edi
   256dc:	8d 94 2a 81 f6 71 87 	lea    0x8771f681(%edx,%ebp,1),%edx
   256e3:	01 d8                	add    %ebx,%eax
   256e5:	31 cf                	xor    %ecx,%edi
   256e7:	31 c7                	xor    %eax,%edi
   256e9:	8b 6e 2c             	mov    0x2c(%esi),%ebp
   256ec:	01 fa                	add    %edi,%edx
   256ee:	89 c7                	mov    %eax,%edi
   256f0:	c1 c2 0b             	rol    $0xb,%edx
   256f3:	01 c2                	add    %eax,%edx
   256f5:	31 df                	xor    %ebx,%edi
   256f7:	31 d7                	xor    %edx,%edi
   256f9:	8d 8c 29 22 61 9d 6d 	lea    0x6d9d6122(%ecx,%ebp,1),%ecx
   25700:	01 f9                	add    %edi,%ecx
   25702:	c1 c1 10             	rol    $0x10,%ecx
   25705:	8b 6e 38             	mov    0x38(%esi),%ebp
   25708:	89 d7                	mov    %edx,%edi
   2570a:	8d 9c 2b 0c 38 e5 fd 	lea    0xfde5380c(%ebx,%ebp,1),%ebx
   25711:	01 d1                	add    %edx,%ecx
   25713:	31 c7                	xor    %eax,%edi
   25715:	31 cf                	xor    %ecx,%edi
   25717:	8b 6e 04             	mov    0x4(%esi),%ebp
   2571a:	01 fb                	add    %edi,%ebx
   2571c:	89 cf                	mov    %ecx,%edi
   2571e:	c1 c3 17             	rol    $0x17,%ebx
   25721:	01 cb                	add    %ecx,%ebx
   25723:	31 d7                	xor    %edx,%edi
   25725:	31 df                	xor    %ebx,%edi
   25727:	8d 84 28 44 ea be a4 	lea    0xa4beea44(%eax,%ebp,1),%eax
   2572e:	01 f8                	add    %edi,%eax
   25730:	c1 c0 04             	rol    $0x4,%eax
   25733:	8b 6e 10             	mov    0x10(%esi),%ebp
   25736:	89 df                	mov    %ebx,%edi
   25738:	8d 94 2a a9 cf de 4b 	lea    0x4bdecfa9(%edx,%ebp,1),%edx
   2573f:	01 d8                	add    %ebx,%eax
   25741:	31 cf                	xor    %ecx,%edi
   25743:	31 c7                	xor    %eax,%edi
   25745:	8b 6e 1c             	mov    0x1c(%esi),%ebp
   25748:	01 fa                	add    %edi,%edx
   2574a:	89 c7                	mov    %eax,%edi
   2574c:	c1 c2 0b             	rol    $0xb,%edx
   2574f:	01 c2                	add    %eax,%edx
   25751:	31 df                	xor    %ebx,%edi
   25753:	31 d7                	xor    %edx,%edi
   25755:	8d 8c 29 60 4b bb f6 	lea    0xf6bb4b60(%ecx,%ebp,1),%ecx
   2575c:	01 f9                	add    %edi,%ecx
   2575e:	c1 c1 10             	rol    $0x10,%ecx
   25761:	8b 6e 28             	mov    0x28(%esi),%ebp
   25764:	89 d7                	mov    %edx,%edi
   25766:	8d 9c 2b 70 bc bf be 	lea    0xbebfbc70(%ebx,%ebp,1),%ebx
   2576d:	01 d1                	add    %edx,%ecx
   2576f:	31 c7                	xor    %eax,%edi
   25771:	31 cf                	xor    %ecx,%edi
   25773:	8b 6e 34             	mov    0x34(%esi),%ebp
   25776:	01 fb                	add    %edi,%ebx
   25778:	89 cf                	mov    %ecx,%edi
   2577a:	c1 c3 17             	rol    $0x17,%ebx
   2577d:	01 cb                	add    %ecx,%ebx
   2577f:	31 d7                	xor    %edx,%edi
   25781:	31 df                	xor    %ebx,%edi
   25783:	8d 84 28 c6 7e 9b 28 	lea    0x289b7ec6(%eax,%ebp,1),%eax
   2578a:	01 f8                	add    %edi,%eax
   2578c:	c1 c0 04             	rol    $0x4,%eax
   2578f:	8b 2e                	mov    (%esi),%ebp
   25791:	89 df                	mov    %ebx,%edi
   25793:	8d 94 2a fa 27 a1 ea 	lea    0xeaa127fa(%edx,%ebp,1),%edx
   2579a:	01 d8                	add    %ebx,%eax
   2579c:	31 cf                	xor    %ecx,%edi
   2579e:	31 c7                	xor    %eax,%edi
   257a0:	8b 6e 0c             	mov    0xc(%esi),%ebp
   257a3:	01 fa                	add    %edi,%edx
   257a5:	89 c7                	mov    %eax,%edi
   257a7:	c1 c2 0b             	rol    $0xb,%edx
   257aa:	01 c2                	add    %eax,%edx
   257ac:	31 df                	xor    %ebx,%edi
   257ae:	31 d7                	xor    %edx,%edi
   257b0:	8d 8c 29 85 30 ef d4 	lea    0xd4ef3085(%ecx,%ebp,1),%ecx
   257b7:	01 f9                	add    %edi,%ecx
   257b9:	c1 c1 10             	rol    $0x10,%ecx
   257bc:	8b 6e 18             	mov    0x18(%esi),%ebp
   257bf:	89 d7                	mov    %edx,%edi
   257c1:	8d 9c 2b 05 1d 88 04 	lea    0x4881d05(%ebx,%ebp,1),%ebx
   257c8:	01 d1                	add    %edx,%ecx
   257ca:	31 c7                	xor    %eax,%edi
   257cc:	31 cf                	xor    %ecx,%edi
   257ce:	8b 6e 24             	mov    0x24(%esi),%ebp
   257d1:	01 fb                	add    %edi,%ebx
   257d3:	89 cf                	mov    %ecx,%edi
   257d5:	c1 c3 17             	rol    $0x17,%ebx
   257d8:	01 cb                	add    %ecx,%ebx
   257da:	31 d7                	xor    %edx,%edi
   257dc:	31 df                	xor    %ebx,%edi
   257de:	8d 84 28 39 d0 d4 d9 	lea    0xd9d4d039(%eax,%ebp,1),%eax
   257e5:	01 f8                	add    %edi,%eax
   257e7:	c1 c0 04             	rol    $0x4,%eax
   257ea:	8b 6e 30             	mov    0x30(%esi),%ebp
   257ed:	89 df                	mov    %ebx,%edi
   257ef:	8d 94 2a e5 99 db e6 	lea    0xe6db99e5(%edx,%ebp,1),%edx
   257f6:	01 d8                	add    %ebx,%eax
   257f8:	31 cf                	xor    %ecx,%edi
   257fa:	31 c7                	xor    %eax,%edi
   257fc:	8b 6e 3c             	mov    0x3c(%esi),%ebp
   257ff:	01 fa                	add    %edi,%edx
   25801:	89 c7                	mov    %eax,%edi
   25803:	c1 c2 0b             	rol    $0xb,%edx
   25806:	01 c2                	add    %eax,%edx
   25808:	31 df                	xor    %ebx,%edi
   2580a:	31 d7                	xor    %edx,%edi
   2580c:	8d 8c 29 f8 7c a2 1f 	lea    0x1fa27cf8(%ecx,%ebp,1),%ecx
   25813:	01 f9                	add    %edi,%ecx
   25815:	c1 c1 10             	rol    $0x10,%ecx
   25818:	8b 6e 08             	mov    0x8(%esi),%ebp
   2581b:	89 d7                	mov    %edx,%edi
   2581d:	8d 9c 2b 65 56 ac c4 	lea    0xc4ac5665(%ebx,%ebp,1),%ebx
   25824:	01 d1                	add    %edx,%ecx
   25826:	31 c7                	xor    %eax,%edi
   25828:	31 cf                	xor    %ecx,%edi
   2582a:	8b 2e                	mov    (%esi),%ebp
   2582c:	01 fb                	add    %edi,%ebx
   2582e:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   25833:	c1 c3 17             	rol    $0x17,%ebx
   25836:	01 cb                	add    %ecx,%ebx
   25838:	31 d7                	xor    %edx,%edi
   2583a:	09 df                	or     %ebx,%edi
   2583c:	8d 84 28 44 22 29 f4 	lea    0xf4292244(%eax,%ebp,1),%eax
   25843:	31 cf                	xor    %ecx,%edi
   25845:	8b 6e 1c             	mov    0x1c(%esi),%ebp
   25848:	01 f8                	add    %edi,%eax
   2584a:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   2584f:	c1 c0 06             	rol    $0x6,%eax
   25852:	31 cf                	xor    %ecx,%edi
   25854:	01 d8                	add    %ebx,%eax
   25856:	09 c7                	or     %eax,%edi
   25858:	8d 94 2a 97 ff 2a 43 	lea    0x432aff97(%edx,%ebp,1),%edx
   2585f:	31 df                	xor    %ebx,%edi
   25861:	8b 6e 38             	mov    0x38(%esi),%ebp
   25864:	01 fa                	add    %edi,%edx
   25866:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   2586b:	c1 c2 0a             	rol    $0xa,%edx
   2586e:	31 df                	xor    %ebx,%edi
   25870:	01 c2                	add    %eax,%edx
   25872:	09 d7                	or     %edx,%edi
   25874:	8d 8c 29 a7 23 94 ab 	lea    0xab9423a7(%ecx,%ebp,1),%ecx
   2587b:	31 c7                	xor    %eax,%edi
   2587d:	8b 6e 14             	mov    0x14(%esi),%ebp
   25880:	01 f9                	add    %edi,%ecx
   25882:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   25887:	c1 c1 0f             	rol    $0xf,%ecx
   2588a:	31 c7                	xor    %eax,%edi
   2588c:	01 d1                	add    %edx,%ecx
   2588e:	09 cf                	or     %ecx,%edi
   25890:	8d 9c 2b 39 a0 93 fc 	lea    0xfc93a039(%ebx,%ebp,1),%ebx
   25897:	31 d7                	xor    %edx,%edi
   25899:	8b 6e 30             	mov    0x30(%esi),%ebp
   2589c:	01 fb                	add    %edi,%ebx
   2589e:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   258a3:	c1 c3 15             	rol    $0x15,%ebx
   258a6:	31 d7                	xor    %edx,%edi
   258a8:	01 cb                	add    %ecx,%ebx
   258aa:	09 df                	or     %ebx,%edi
   258ac:	8d 84 28 c3 59 5b 65 	lea    0x655b59c3(%eax,%ebp,1),%eax
   258b3:	31 cf                	xor    %ecx,%edi
   258b5:	8b 6e 0c             	mov    0xc(%esi),%ebp
   258b8:	01 f8                	add    %edi,%eax
   258ba:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   258bf:	c1 c0 06             	rol    $0x6,%eax
   258c2:	31 cf                	xor    %ecx,%edi
   258c4:	01 d8                	add    %ebx,%eax
   258c6:	09 c7                	or     %eax,%edi
   258c8:	8d 94 2a 92 cc 0c 8f 	lea    0x8f0ccc92(%edx,%ebp,1),%edx
   258cf:	31 df                	xor    %ebx,%edi
   258d1:	8b 6e 28             	mov    0x28(%esi),%ebp
   258d4:	01 fa                	add    %edi,%edx
   258d6:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   258db:	c1 c2 0a             	rol    $0xa,%edx
   258de:	31 df                	xor    %ebx,%edi
   258e0:	01 c2                	add    %eax,%edx
   258e2:	09 d7                	or     %edx,%edi
   258e4:	8d 8c 29 7d f4 ef ff 	lea    0xffeff47d(%ecx,%ebp,1),%ecx
   258eb:	31 c7                	xor    %eax,%edi
   258ed:	8b 6e 04             	mov    0x4(%esi),%ebp
   258f0:	01 f9                	add    %edi,%ecx
   258f2:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   258f7:	c1 c1 0f             	rol    $0xf,%ecx
   258fa:	31 c7                	xor    %eax,%edi
   258fc:	01 d1                	add    %edx,%ecx
   258fe:	09 cf                	or     %ecx,%edi
   25900:	8d 9c 2b d1 5d 84 85 	lea    0x85845dd1(%ebx,%ebp,1),%ebx
   25907:	31 d7                	xor    %edx,%edi
   25909:	8b 6e 20             	mov    0x20(%esi),%ebp
   2590c:	01 fb                	add    %edi,%ebx
   2590e:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   25913:	c1 c3 15             	rol    $0x15,%ebx
   25916:	31 d7                	xor    %edx,%edi
   25918:	01 cb                	add    %ecx,%ebx
   2591a:	09 df                	or     %ebx,%edi
   2591c:	8d 84 28 4f 7e a8 6f 	lea    0x6fa87e4f(%eax,%ebp,1),%eax
   25923:	31 cf                	xor    %ecx,%edi
   25925:	8b 6e 3c             	mov    0x3c(%esi),%ebp
   25928:	01 f8                	add    %edi,%eax
   2592a:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   2592f:	c1 c0 06             	rol    $0x6,%eax
   25932:	31 cf                	xor    %ecx,%edi
   25934:	01 d8                	add    %ebx,%eax
   25936:	09 c7                	or     %eax,%edi
   25938:	8d 94 2a e0 e6 2c fe 	lea    0xfe2ce6e0(%edx,%ebp,1),%edx
   2593f:	31 df                	xor    %ebx,%edi
   25941:	8b 6e 18             	mov    0x18(%esi),%ebp
   25944:	01 fa                	add    %edi,%edx
   25946:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   2594b:	c1 c2 0a             	rol    $0xa,%edx
   2594e:	31 df                	xor    %ebx,%edi
   25950:	01 c2                	add    %eax,%edx
   25952:	09 d7                	or     %edx,%edi
   25954:	8d 8c 29 14 43 01 a3 	lea    0xa3014314(%ecx,%ebp,1),%ecx
   2595b:	31 c7                	xor    %eax,%edi
   2595d:	8b 6e 34             	mov    0x34(%esi),%ebp
   25960:	01 f9                	add    %edi,%ecx
   25962:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   25967:	c1 c1 0f             	rol    $0xf,%ecx
   2596a:	31 c7                	xor    %eax,%edi
   2596c:	01 d1                	add    %edx,%ecx
   2596e:	09 cf                	or     %ecx,%edi
   25970:	8d 9c 2b a1 11 08 4e 	lea    0x4e0811a1(%ebx,%ebp,1),%ebx
   25977:	31 d7                	xor    %edx,%edi
   25979:	8b 6e 10             	mov    0x10(%esi),%ebp
   2597c:	01 fb                	add    %edi,%ebx
   2597e:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   25983:	c1 c3 15             	rol    $0x15,%ebx
   25986:	31 d7                	xor    %edx,%edi
   25988:	01 cb                	add    %ecx,%ebx
   2598a:	09 df                	or     %ebx,%edi
   2598c:	8d 84 28 82 7e 53 f7 	lea    0xf7537e82(%eax,%ebp,1),%eax
   25993:	31 cf                	xor    %ecx,%edi
   25995:	8b 6e 2c             	mov    0x2c(%esi),%ebp
   25998:	01 f8                	add    %edi,%eax
   2599a:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   2599f:	c1 c0 06             	rol    $0x6,%eax
   259a2:	31 cf                	xor    %ecx,%edi
   259a4:	01 d8                	add    %ebx,%eax
   259a6:	09 c7                	or     %eax,%edi
   259a8:	8d 94 2a 35 f2 3a bd 	lea    0xbd3af235(%edx,%ebp,1),%edx
   259af:	31 df                	xor    %ebx,%edi
   259b1:	8b 6e 08             	mov    0x8(%esi),%ebp
   259b4:	01 fa                	add    %edi,%edx
   259b6:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   259bb:	c1 c2 0a             	rol    $0xa,%edx
   259be:	31 df                	xor    %ebx,%edi
   259c0:	01 c2                	add    %eax,%edx
   259c2:	09 d7                	or     %edx,%edi
   259c4:	8d 8c 29 bb d2 d7 2a 	lea    0x2ad7d2bb(%ecx,%ebp,1),%ecx
   259cb:	31 c7                	xor    %eax,%edi
   259cd:	8b 6e 24             	mov    0x24(%esi),%ebp
   259d0:	01 f9                	add    %edi,%ecx
   259d2:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   259d7:	c1 c1 0f             	rol    $0xf,%ecx
   259da:	31 c7                	xor    %eax,%edi
   259dc:	01 d1                	add    %edx,%ecx
   259de:	09 cf                	or     %ecx,%edi
   259e0:	8d 9c 2b 91 d3 86 eb 	lea    0xeb86d391(%ebx,%ebp,1),%ebx
   259e7:	31 d7                	xor    %edx,%edi
   259e9:	8b 6c 24 18          	mov    0x18(%esp,1),%ebp
   259ed:	01 fb                	add    %edi,%ebx
   259ef:	83 c6 40             	add    $0x40,%esi
   259f2:	c1 c3 15             	rol    $0x15,%ebx
   259f5:	8b 7d 00             	mov    0x0(%ebp),%edi
   259f8:	01 cb                	add    %ecx,%ebx
   259fa:	01 f8                	add    %edi,%eax
   259fc:	8b 7d 04             	mov    0x4(%ebp),%edi
   259ff:	01 fb                	add    %edi,%ebx
   25a01:	8b 7d 08             	mov    0x8(%ebp),%edi
   25a04:	01 f9                	add    %edi,%ecx
   25a06:	8b 7d 0c             	mov    0xc(%ebp),%edi
   25a09:	01 fa                	add    %edi,%edx
   25a0b:	89 45 00             	mov    %eax,0x0(%ebp)
   25a0e:	89 5d 04             	mov    %ebx,0x4(%ebp)
   25a11:	8b 3c 24             	mov    (%esp,1),%edi
   25a14:	89 4d 08             	mov    %ecx,0x8(%ebp)
   25a17:	89 55 0c             	mov    %edx,0xc(%ebp)
   25a1a:	39 f7                	cmp    %esi,%edi
   25a1c:	0f 83 82 f9 ff ff    	jae    253a4 <md5_block_asm_host_order+0x24>
   25a22:	58                   	pop    %eax
   25a23:	5b                   	pop    %ebx
   25a24:	5d                   	pop    %ebp
   25a25:	5f                   	pop    %edi
   25a26:	5e                   	pop    %esi
   25a27:	c3                   	ret    
Disassembly of section .fixup:

00000000 <.fixup>:
   0:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
   5:	e9 c1 46 01 00       	jmp    146cb <cminisock_config_pipe_impl+0x6ce>
   a:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
   f:	e9 4b 48 01 00       	jmp    1485f <trickles_getsockopt_impl+0x124>
  14:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
  19:	e9 a4 48 01 00       	jmp    148c2 <trickles_getsockopt_impl+0x187>
  1e:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
}

static inline 
void record_transfer_skb(struct sk_buff *skb, int newType) {
}
  23:	e9 54 7a 01 00       	jmp    17a7c <convertMSK_in+0x158>
/* Two phase free: first phase disconnects socket from event list,
   sets to ALLOC_PROCESSING; second phase adds the socket to free
   list, sets to ALLOC_FREE and ready for reuse */
#ifndef USERTEST
static inline void free_trickles_msk(struct sock *sk, struct cminisock *msk) {
  28:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
	if(!SIMULATION_MODE(sk)) {
  2d:	31 d2                	xor    %edx,%edx
  2f:	e9 82 7a 01 00       	jmp    17ab6 <convertMSK_in+0x192>
  34:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
  39:	e9 38 7c 01 00       	jmp    17c76 <convertMSK_in+0x352>
  3e:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
  43:	e9 6d 7d 01 00       	jmp    17db5 <convertMSK_in+0x491>
  48:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
  4d:	e9 ab 7e 01 00       	jmp    17efd <convertMSK_in+0x5d9>
  52:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
		if(msk->ctl == ALLOC_FREE || msk->ctl == ALLOC_PROCESSING) {
  57:	e9 60 80 01 00       	jmp    180bc <convertMSK_in+0x798>
  5c:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
  61:	e9 ef 80 01 00       	jmp    18155 <convertMSK_in+0x831>
  66:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
			printk("double free\n");
  6b:	31 d2                	xor    %edx,%edx
  6d:	e9 23 81 01 00       	jmp    18195 <convertMSK_in+0x871>
  72:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
			BUG();
  77:	e9 fe 82 01 00       	jmp    1837a <convertMSK_out+0x19c>
  7c:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
  81:	e9 bd 84 01 00       	jmp    18543 <convertMSK_out+0x365>
  86:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
  8b:	e9 ec 85 01 00       	jmp    1867c <convertMSK_out+0x49e>
  90:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
  95:	e9 24 87 01 00       	jmp    187be <convertMSK_out+0x5e0>
  9a:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
		}
		if(msk->ctl == ALLOC_READY && msk->prev != NULL) {
  9f:	e9 d3 88 01 00       	jmp    18977 <convertMSK_out+0x799>
  a4:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
  a9:	e9 56 89 01 00       	jmp    18a04 <trickles_extract_events_impl+0x67>
			unlink((struct alloc_head *)msk);
  ae:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
  b3:	31 d2                	xor    %edx,%edx
  b5:	e9 62 95 01 00       	jmp    1961c <trickles_install_events_impl+0x2de>
		}
		msk->ctl = ALLOC_PROCESSING;
  ba:	c1 e1 02             	shl    $0x2,%ecx
  bd:	e9 12 a2 01 00       	jmp    1a2d4 <__constant_copy_from_user+0x3b>
	}
}
  c2:	c1 e1 02             	shl    $0x2,%ecx

static inline void msk_release(struct sock *sk, struct cminisock *msk) {
	// Perform actual deallocation. This function is common to
	// state cache and event queue
	msk->refCnt--;
	BUG_TRAP(msk->refCnt >= 0);
	if(msk->refCnt == 0) {
		// printk("release: refcnt %p\n", msk);
		struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
		struct alloc_head_list *head = &tp->cminisock_api_config.msk_freelist;

		free_minisock(sk,msk);
		if(!SIMULATION_MODE(sk)) {
			insert_head(head, (struct alloc_head *)msk);
			msk->ctl = ALLOC_FREE;
		} else {
			if(msk == tp->t.responseMSK) {
			} else {
				// overflow
				unlink((struct alloc_head*)msk);
				kfree(msk);
			}
			tp->t.responseCount--;
		}
	} else {
		//printk("release: refcnt == %d\n", msk->refCnt);
	}
}

static inline void free_trickles_msk_finish(struct sock *sk, struct cminisock *msk) {
  c5:	41                   	inc    %ecx
  c6:	e9 34 a2 01 00       	jmp    1a2ff <__constant_copy_from_user+0x66>
	if(!SIMULATION_MODE(sk)) {
  cb:	c1 e1 02             	shl    $0x2,%ecx
  ce:	83 c1 02             	add    $0x2,%ecx
  d1:	e9 57 a2 01 00       	jmp    1a32d <__constant_copy_from_user+0x94>
  d6:	c1 e1 02             	shl    $0x2,%ecx
  d9:	83 c1 02             	add    $0x2,%ecx
  dc:	41                   	inc    %ecx
  dd:	e9 7b a2 01 00       	jmp    1a35d <__constant_copy_from_user+0xc4>
  e2:	51                   	push   %ecx
  e3:	50                   	push   %eax
  e4:	31 c0                	xor    %eax,%eax
  e6:	f3 ab                	repz stos %eax,%es:(%edi)
  e8:	58                   	pop    %eax
  e9:	59                   	pop    %ecx
  ea:	c1 e1 02             	shl    $0x2,%ecx
  ed:	e9 fb a2 01 00       	jmp    1a3ed <__constant_copy_to_user_nocheck+0x4c>
  f2:	51                   	push   %ecx
  f3:	50                   	push   %eax
		if(msk->ctl != ALLOC_PROCESSING && msk->ctl != ALLOC_HALFFREE) {
  f4:	31 c0                	xor    %eax,%eax
  f6:	f3 ab                	repz stos %eax,%es:(%edi)
  f8:	aa                   	stos   %al,%es:(%edi)
  f9:	58                   	pop    %eax
  fa:	59                   	pop    %ecx
  fb:	c1 e1 02             	shl    $0x2,%ecx
  fe:	41                   	inc    %ecx
  ff:	e9 20 a3 01 00       	jmp    1a424 <__constant_copy_to_user_nocheck+0x83>
 104:	50                   	push   %eax
 105:	31 c0                	xor    %eax,%eax
			printk("(free_trickles_msk_finish) without corresponding free_trickles_msk: msk->ctl = %d\n", msk->ctl);
 107:	aa                   	stos   %al,%es:(%edi)
 108:	58                   	pop    %eax
 109:	41                   	inc    %ecx
 10a:	e9 20 a3 01 00       	jmp    1a42f <__constant_copy_to_user_nocheck+0x8e>
 10f:	51                   	push   %ecx
 110:	50                   	push   %eax
 111:	31 c0                	xor    %eax,%eax
 113:	f3 ab                	repz stos %eax,%es:(%edi)
 115:	66 ab                	stos   %ax,%es:(%edi)
 117:	58                   	pop    %eax
 118:	59                   	pop    %ecx
 119:	c1 e1 02             	shl    $0x2,%ecx
			BUG();
 11c:	83 c1 02             	add    $0x2,%ecx
 11f:	e9 43 a3 01 00       	jmp    1a467 <__constant_copy_from_user_nocheck+0x9>
 124:	50                   	push   %eax
 125:	31 c0                	xor    %eax,%eax
 127:	66 ab                	stos   %ax,%es:(%edi)
 129:	58                   	pop    %eax
 12a:	83 c1 02             	add    $0x2,%ecx
 12d:	e9 43 a3 01 00       	jmp    1a475 <__constant_copy_from_user_nocheck+0x17>
 132:	51                   	push   %ecx
 133:	50                   	push   %eax
 134:	31 c0                	xor    %eax,%eax
 136:	f3 ab                	repz stos %eax,%es:(%edi)
 138:	66 ab                	stos   %ax,%es:(%edi)
 13a:	aa                   	stos   %al,%es:(%edi)
 13b:	58                   	pop    %eax
 13c:	59                   	pop    %ecx
 13d:	c1 e1 02             	shl    $0x2,%ecx
 140:	83 c1 03             	add    $0x3,%ecx
		}
	}
	msk_release(sk,msk);
 143:	e9 66 a3 01 00       	jmp    1a4ae <__constant_copy_from_user_nocheck+0x50>
 148:	50                   	push   %eax
 149:	31 c0                	xor    %eax,%eax
 14b:	66 ab                	stos   %ax,%es:(%edi)
 14d:	aa                   	stos   %al,%es:(%edi)
 14e:	58                   	pop    %eax
 14f:	83 c1 03             	add    $0x3,%ecx
 152:	e9 66 a3 01 00       	jmp    1a4bd <__constant_copy_from_user_nocheck+0x5f>
};

#define SAFEAVG(SUM,COUNT)  (((__u32)((COUNT) >> 4)) ? ((__u32)((SUM) >> 4)) / ((__u32)((COUNT) >> 4)) : 0)

void SKBStat_update(struct SKBStat *sstat, struct sk_buff *skb, int overhead) {
 157:	50                   	push   %eax
 158:	31 c0                	xor    %eax,%eax
	sstat->count++;
 15a:	aa                   	stos   %al,%es:(%edi)
 15b:	58                   	pop    %eax
 15c:	41                   	inc    %ecx
 15d:	e9 67 a3 01 00       	jmp    1a4c9 <__constant_copy_from_user_nocheck+0x6b>
 162:	c1 e1 02             	shl    $0x2,%ecx
	sstat->totalBytes += skb->tail - skb->head;
 165:	e9 d8 a3 01 00       	jmp    1a542 <init_head+0x13>
 16a:	c1 e1 02             	shl    $0x2,%ecx
 16d:	41                   	inc    %ecx
 16e:	e9 fa a3 01 00       	jmp    1a56d <insert_tail+0x18>
 173:	c1 e1 02             	shl    $0x2,%ecx
 176:	83 c1 02             	add    $0x2,%ecx
 179:	e9 1d a4 01 00       	jmp    1a59b <insert_tail+0x46>
 17e:	c1 e1 02             	shl    $0x2,%ecx
 181:	83 c1 02             	add    $0x2,%ecx
 184:	41                   	inc    %ecx
 185:	e9 41 a4 01 00       	jmp    1a5cb <insert_tail+0x76>
 18a:	51                   	push   %ecx
	sstat->totalOverheadBytes += overhead;
 18b:	50                   	push   %eax
 18c:	31 c0                	xor    %eax,%eax
 18e:	f3 ab                	repz stos %eax,%es:(%edi)
 190:	58                   	pop    %eax
 191:	59                   	pop    %ecx
 192:	c1 e1 02             	shl    $0x2,%ecx
 195:	e9 95 a4 01 00       	jmp    1a62f <insert_tail_mb+0x62>
 19a:	51                   	push   %ecx
 19b:	50                   	push   %eax
 19c:	31 c0                	xor    %eax,%eax
 19e:	f3 ab                	repz stos %eax,%es:(%edi)
 1a0:	aa                   	stos   %al,%es:(%edi)
}
 1a1:	58                   	pop    %eax
 1a2:	59                   	pop    %ecx
 1a3:	c1 e1 02             	shl    $0x2,%ecx

void SKBStat_dump(struct SKBStat *sstat) {
 1a6:	41                   	inc    %ecx
 1a7:	e9 b7 a4 01 00       	jmp    1a663 <unlink+0x18>
	printk("total = %d, totalBytes = %d (%d), totalOverhead = %d (%d)\n",
 1ac:	50                   	push   %eax
 1ad:	31 c0                	xor    %eax,%eax
 1af:	aa                   	stos   %al,%es:(%edi)
 1b0:	58                   	pop    %eax
 1b1:	41                   	inc    %ecx
 1b2:	e9 b7 a4 01 00       	jmp    1a66e <unlink+0x23>
 1b7:	51                   	push   %ecx
 1b8:	50                   	push   %eax
 1b9:	31 c0                	xor    %eax,%eax
 1bb:	f3 ab                	repz stos %eax,%es:(%edi)
 1bd:	66 ab                	stos   %ax,%es:(%edi)
 1bf:	58                   	pop    %eax
 1c0:	59                   	pop    %ecx
 1c1:	c1 e1 02             	shl    $0x2,%ecx
 1c4:	83 c1 02             	add    $0x2,%ecx
 1c7:	e9 da a4 01 00       	jmp    1a6a6 <setPacketUCont+0x15>
 1cc:	50                   	push   %eax
 1cd:	31 c0                	xor    %eax,%eax
 1cf:	66 ab                	stos   %ax,%es:(%edi)
 1d1:	58                   	pop    %eax
 1d2:	83 c1 02             	add    $0x2,%ecx
 1d5:	e9 da a4 01 00       	jmp    1a6b4 <setPacketUCont+0x23>
 1da:	51                   	push   %ecx
 1db:	50                   	push   %eax
 1dc:	31 c0                	xor    %eax,%eax
 1de:	f3 ab                	repz stos %eax,%es:(%edi)
 1e0:	66 ab                	stos   %ax,%es:(%edi)
 1e2:	aa                   	stos   %al,%es:(%edi)
 1e3:	58                   	pop    %eax
 1e4:	59                   	pop    %ecx
 1e5:	c1 e1 02             	shl    $0x2,%ecx
 1e8:	83 c1 03             	add    $0x3,%ecx
 1eb:	e9 fd a4 01 00       	jmp    1a6ed <setPacketUCont+0x5c>
 1f0:	50                   	push   %eax
 1f1:	31 c0                	xor    %eax,%eax
 1f3:	66 ab                	stos   %ax,%es:(%edi)
 1f5:	aa                   	stos   %al,%es:(%edi)
 1f6:	58                   	pop    %eax
 1f7:	83 c1 03             	add    $0x3,%ecx
 1fa:	e9 fd a4 01 00       	jmp    1a6fc <setPacketUCont+0x6b>
 1ff:	50                   	push   %eax
 200:	31 c0                	xor    %eax,%eax
 202:	aa                   	stos   %al,%es:(%edi)
 203:	58                   	pop    %eax
 204:	41                   	inc    %ecx
 205:	e9 fe a4 01 00       	jmp    1a708 <setPacketUCont+0x77>
 20a:	8d 4c 88 00          	lea    0x0(%eax,%ecx,4),%ecx
 20e:	51                   	push   %ecx
 20f:	50                   	push   %eax
 210:	31 c0                	xor    %eax,%eax
 212:	f3 aa                	repz stos %al,%es:(%edi)
 214:	58                   	pop    %eax
 215:	59                   	pop    %ecx
 216:	e9 4d bb 01 00       	jmp    1bd68 <free_minisock+0xef>
 21b:	8d 4c 88 00          	lea    0x0(%eax,%ecx,4),%ecx
 21f:	e9 88 bb 01 00       	jmp    1bdac <free_minisock+0x133>
